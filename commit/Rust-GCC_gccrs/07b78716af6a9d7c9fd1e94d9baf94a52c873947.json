{"sha": "07b78716af6a9d7c9fd1e94d9baf94a52c873947", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiNzg3MTZhZjZhOWQ3YzlmZDFlOTRkOWJhZjk0YTUyYzg3Mzk0Nw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2016-09-30T16:24:48Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2016-09-30T16:24:48Z"}, "message": "Makefile.def: Remove libjava.\n\n2016-09-30  Andrew Haley  <aph@redhat.com>\n\n\t* Makefile.def: Remove libjava.\n\t* Makefile.tpl: Likewise.\n\t* Makefile.in: Regenerate.\n\t* configure.ac: Likewise.\n\t* configure: Likewise.\n\t* gcc/java: Remove.\n\t* libjava: Likewise.\n\nFrom-SVN: r240662", "tree": {"sha": "3f22b3241c513ad168c8353805614ae1249410f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f22b3241c513ad168c8353805614ae1249410f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07b78716af6a9d7c9fd1e94d9baf94a52c873947", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b78716af6a9d7c9fd1e94d9baf94a52c873947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b78716af6a9d7c9fd1e94d9baf94a52c873947", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b78716af6a9d7c9fd1e94d9baf94a52c873947/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eae993948bae8b788c53772bcb9217c063716f93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eae993948bae8b788c53772bcb9217c063716f93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eae993948bae8b788c53772bcb9217c063716f93"}], "stats": {"total": 2642265, "additions": 10, "deletions": 2642255}, "files": [{"sha": "e91a50cbda3aa92154b4574119b1d5c93bcdf5cc", "filename": "ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b78716af6a9d7c9fd1e94d9baf94a52c873947/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b78716af6a9d7c9fd1e94d9baf94a52c873947/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=07b78716af6a9d7c9fd1e94d9baf94a52c873947", "patch": "@@ -1,3 +1,13 @@\n+2016-09-30  Andrew Haley  <aph@redhat.com>\n+\n+\t* Makefile.def: Remove libjava.\n+\t* Makefile.tpl: Likewise.\n+\t* Makefile.in: Regenerate.\n+\t* configure.ac: Likewise.\n+\t* configure: Likewise.\n+\t* gcc/java: Remove.\n+\t* libjava: Likewise.\n+\n 2016-09-28  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* MAINTAINERS (Reviewers): Add myself."}, {"sha": "770b4226aa230941db15eaadb046fed34f670d05", "filename": "gcc/java/ChangeLog", "status": "removed", "additions": 0, "deletions": 23381, "changes": 23381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1f7488e11a62a8de3bf601dc090976963aa9c1e5", "filename": "gcc/java/ChangeLog.gimple-classes", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.gimple-classes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.gimple-classes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.gimple-classes?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,20 +0,0 @@\n-2014-10-27  David Malcolm  <dmalcolm@redhat.com>\n-\n-\tPatch autogenerated by rename_gimple_subclasses.py from\n-\thttps://github.com/davidmalcolm/gcc-refactoring-scripts\n-\trevision 7d754b63ff2bf47226a67b2c0af5d74b54d4709f\n-\n-\t* java-gimplify.c (java_gimplify_block): Rename gimple subclass types.\n-\n-2014-10-24  David Malcolm  <dmalcolm@redhat.com>\n-\n-\tIntroduce gimple_bind and use it for accessors.\n-\n-\t* java-gimplify.c (java_gimplify_block): Update local to be a\n-\tgimple_bind rather than just a gimple.\n-\n-Copyright (C) 2014 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "e5e7e273e9f9e5bbd9df5cdfa01ffdc62869b80e", "filename": "gcc/java/ChangeLog.jit", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.jit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.jit?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,14 +0,0 @@\n-2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* ChangeLog.jit: Add copyright footer.\n-\n-2013-10-11  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* lang.c (java_handle_option): Update for introduction of\n-\tgcc::dump_manager.\n-\f\n-Copyright (C) 2013-2014 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "3243223f5e9165e280ae978be41e2c42e4b814ff", "filename": "gcc/java/ChangeLog.ptr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.ptr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.ptr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.ptr?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,25 +0,0 @@\n-2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n-\n-\t* except.c (build_exception_object_ref):\n-\tUse fold_build1 instead of build1 for NEGATE_EXPR.\n-\n-2007-05-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n-\n-\t* class.c (make_class_data): Build the index in sizetype.\n-\tUse POINTER_PLUS_EXPR instead of PLUS_EXPR when\n-\tadding to a pointer type.\n-\t(build_symbol_entry): Likewise.\n-\t* expr.c (build_java_arrayaccess): Likewise.\n-\t(build_field_ref): Likewise.\n-\t(build_known_method_ref): Likewise.\n-\t(build_invokevirtual): Likewise.\n-\t* except.c (build_exception_object_ref): Do a\n-\tNEGATIVE and then a POINTER_PLUS_EXPR instead\n-\tof a MINUS_EXPR.\n-\n-\f\n-Copyright (C) 2007 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "6abe4f2899efc84e05a1969997f587bdb0e150b8", "filename": "gcc/java/ChangeLog.tree-ssa", "status": "removed", "additions": 0, "deletions": 367, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.tree-ssa?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,367 +0,0 @@\n-2004-05-10  Andrew Haley  <aph@redhat.com>\n-\n-\t* java-gimplify.c (java_gimplify_expr): Copy the LHS of a binary\n-\texpression into a temporary variable.\n-\n-\t(java_gimplify_new_array_init): Set the DECL_CONTEXT of array and\n-\ttmp to current_function_decl.\n-\n-2004-04-13  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* expr.c (build_expr_wfl): Don't check type nodes for\n-\tside effects.\n-\n-2004-04-12  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* decl.c (java_expand_stmt): Remove.\n-\t* lang.c (LANG_HOOKS_RTL_EXPAND_STMT): Remove.\n-\n-2004-02-24  Richard Henderson  <rth@redhat.com>\n-\n-\t* java-gimplify.c (java_gimplify_new_array_init): Remove extra\n-\targument building BLOCK.\n-\n-2004-02-19  Steven Bosscher  <stevenb@suse.de>\n-\n-\t* decl.c (poplevel): Don't output nested inline functions.\n-\n-2004-02-16  Richard Henderson  <rth@redhat.com>\n-\n-\t* builtins.c (java_build_function_call_expr): Add static chain\n-\toperand to call_expr.\n-\n-2004-01-29  Richard Henderson  <rth@redhat.com>\n-\n-\tPR java/12906\n-\t* decl.c (maybe_pushlevels): Careful with TREE_CHAIN when\n-\tregistering decls with push_jvm_slot.\n-\n-2003-12-10  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* parse.y (resolve_field_access): Remove superfluous\n-\tinitialization of decl.\n-\n-2003-12-10  Richard Henderson  <rth@redhat.com>\n-\n-\t* lang.c (java_post_options): Don't ever use rtl inlining.\n-\n-2003-12-06  Jan Hubicka  <jh@suse.cz>\n-\n-\t* parse.y (resolve_field_access): Initialize decl.\n-\n-2003-11-31  Richard Henderson  <rth@redhat.com>\n-\n-\t* lang.c (java_start_inlining): Remove.\n-\t(LANG_HOOKS_TREE_INLINING_START_INLINING): Remove.\n-\n-2003-11-31  Richard Henderson  <rth@redhat.com>\n-\n-\t* jcf-parse.c (java_parse_file): Finalize cgraph after emitting\n-\tclass tables.\n-\n-2003-11-24  Richard Henderson  <rth@redhat.com>\n-\n-\t* Make-lang.in (parse.o): Remove -Wno-error.\n-\n-2003-11-20  Richard Henderson <rth@redhat.com>\n-\n-\t* constants.c (build_constant_data_ref): Lay out the array type.\n-\n-2003-11-20  Richard Henderson <rth@redhat.com>\n-\n-\t* class.c (build_indirect_class_ref): Use convert.\n-\t* constants.c (build_constant_data_ref): Fix type on the decl\n-\tand return that directly.\n-\t(build_constants_constructor): Remove kruft to match.\n-\t(build_ref_from_constant_pool): Use ARRAY_REF.\n-\t* expr.c (build_java_indirect_ref): Use convert.\n-\t(build_known_method_ref): Likewise.\n-\t* parse.y (patch_string_cst): Likewise.\n-\n-\t* class.c (finish_class): Kill code to output_inline_function.\n-\n-2003-11-12  Jason Merrill  <jason@redhat.com>\n-\n-\tPR optimization/12547\n-\t* lang.c (java_tree_inlining_walk_subtrees): Restore.\n-\t(LANG_HOOKS_TREE_INLINING_WALK_SUBTREES): Restore.\n-\n-2003-11-12  Richard Henderson  <rth@redhat.com>\n-\n-\t* java-gimplify.c (java_gimplify_expr): Use annotate_with_locus\n-\tinstead of annotate_all_with_locus.\n-\n-2003-11-10  Richard Henderson  <rth@redhat.com>\n-\n-\t* expr.c: Use append_to_statement_list instead of add_tree.\n-\n-2003-10-30  Richard Henderson  <rth@redhat.com>\n-\n-\t* java-gimplify.c (cleanup_compound_expr): Remove.\n-\t(cleanup_try_finally_expr): Remove.\n-\t(java_gimplify_expr): Don't call them.\n-\t(java_gimplify_case_expr): Use create_artificial_label.\n-\t(java_gimplify_default_expr): Likewise.\n-\n-2003-10-30  Richard Henderson  <rth@redhat.com>\n-\n-\t* expr.c (expand_java_switch, expand_java_add_case): New.\n-\t(LOOKUP_SWITCH, TABLE_SWITCH): Use them.\n-\n-2003-10-23  Richard Henderson  <rth@redhat.com>\n-\n-\t* java-gimplify.c (java_gimplify_expr): Return gimplify_status.\n-\n-2003-10-14  Richard Henderson  <rth@redhat.com>\n-\n-\t* decl.c (finish_method): Set cfun->function_end_locus.\n-\t* java-gimplify.c (java_gimplify_expr): Set input_location\n-\tfor EXPR_WITH_FILE_LOCATION.  Use annotate_all_with_locus.\n-\t* parse.h (DECL_SOURCE_LINE_MERGE): Remove.\n-\t(DECL_SOURCE_LINE_FIRST, DECL_SOURCE_LINE_LAST): Remove.\n-\t* parse.y (missing_return_error): Use DECL_FUNCTION_LAST_LINE.\n-\t(finish_method_declaration): Likewise.\n-\t(start_artificial_method_body): Likewise.\n-\t(lookup_cl): Use DECL_SOURCE_LINE.\n-\t(start_complete_expand_method): Likewise.\n-\t(java_complete_lhs): Fix IS_EXPR_CODE_CLASS check.\n-\n-2003-10-13  Richard Henderson  <rth@redhat.com>\n-\n-\t* decl.c (java_add_stmt): Use annotate_with_locus.\n-\n-2003-10-13  Richard Henderson  <rth@redhat.com>\n-\n-\t* expr.c (build_java_jsr): Don't emit LABEL_EXPR or\n-\tload_type_state here.\n-\n-2003-10-12  Richard Henderson  <rth@redhat.com>\n-\n-\t* class.c (build_utf8_ref, get_dispatch_table): Set TREE_INVARIANT.\n-\t(make_class_data, build_symbol_entry, emit_symbol_table): Likewise.\n-\t* decl.c (java_init_decl_processing): Likewise.\n-\t* except.c (prepare_eh_table_type): Likewise.\n-\t* parse.y (patch_assignment, patch_binop): Likewise.\n-\t(patch_string_cst, patch_new_array_init): Likewise.\n-\t* resource.c (compile_resource_data): Likewise.\n-\n-2003-10-08  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* decl.c (cgraph.h): Include.\n-\t(tree-inline.h, tree-dump.h, tree-flow.h): Remove includes.\n-\t(complete_start_java_method): Remove.\n-\t(start_java_method): Combine with complete_start_java_method.\n-\tRemove dead code.\n-\t(end_java_method): Don't patch or expand tree.\n-\tUse finish_method.\n-\t(finish_method): New function.\n-\t(java_expand_body): Use tree_rest_of_compilation.\n-\t(java_expand_stmt): New function.\n-\n-\t* java-gimplify.c (tree-dump.h): Include.\n-\t(java_genericize): New function.\n-\t(dump_java_tree): Declare.  New function.\n-\n-\t* java-tree.h (start_complete_expand_method): Remove declaration.\n-\t(complete_start_java_method): Remove declaration.\n-\t(finish_method, java_expand_stmt, java_genericize): Declare.\n-\n-\t* lang.c (LANG_HOOKS_RTL_EXPAND_STMT): Define.\n-\n-\t* parse.y (tree-inline.h, tree-dump.h, tree-flow.h,\n-\tcgraph.h): Remove includes.\n-\t(start_complete_expand_method): Declare.\n-\t(source_end_java_method): Don't expand tree.  Use finish_method.\n-\tReset current_function_decl.\n-\t(java_expand_method_bodies): Don't patch tree for class\n-\tinitialization or method synchronization.\n-\n-2003-10-01  Richard Henderson  <rth@redhat.com>\n-\n-\t* decl.c (end_java_method): Invoke remove_useless_stmts_and_vars\n-\tand lower_eh_constructs.\n-\t* parse.y (source_end_java_method): Likewise.\n-\n-2003-09-24  Jason Merrill  <jason@redhat.com>\n-\n-\t* decl.c, jcf-parse.c, jcf-write.c, parse.h, parse.y, resource.c:\n-\tRevert from TREE_LOCUS to DECL_SOURCE_LOCATION.\n-\n-2003-09-18  Richard Henderson  <rth@redhat.com>\n-\n-\t* lang.c (java_estimate_num_insns): Take an expr, not a decl.\n-\n-2003-08-12  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* java-gimplify.c (java_gimplify_block): If the body is a\n-\tNULL_TREE, return an empty statement.\n-\n-2003-08-08  Jason Merrill  <jason@redhat.com>\n-\n-\t* parse.y (source_end_java_method): Support\n-\t!keep_function_tree_in_gimple_form.\n-\tDo TDI_generic dump.\n-\n-2003-07-31  Andrew Haley  <aph@redhat.com>\n-\n-\t* java-tree.h: (add_stmt_to_compound): New function.\n-\t(java_add_stmt): New function.\n-\t(java_add_local_var): New function.\n-\t(get_stmts): New function.\n-\t* java-gimplify.c (java_gimplify_block): Allow for null body.\n-\t* except.c (link_handler): Set h->stmt.\n-\t(expand_start_java_handler): Build a TRY_CATCH_EXPR for this\n-\trange;  don't expand_eh_region_start.\n-\t(expand_end_java_handler): Rewrite.\n-\t* java-except.h (stmt): New field.\n-\t* expr.c (flush_quick_stack): Replace expand_assignment with\n-\tjava_add_stmt.\n-\t(java_stack_dup): Replace emit_move_insn with java_add_stmt.\n-\t(build_java_athrow): Replace expand_expr_stmt with java_add_stmt.\n-\t(build_java_jsr): Replace emit_jump with java_add_stmt (build (GOTO_EXPR))\n-\t(build_java_ret): Replace expand_computed_goto with\n-\tjava_add_stmt (build (GOTO_EXPR))\n-\t(expand_java_arraystore): Replace expand_assignment with\n-\tjava_add_stmt.\n-\t(expand_java_return): Replace expand_return with\n-\tjava_add_stmt (build (RETURN_EXPR))\n-\t(expand_load_internal): Remove layout_decl, DECL_REGISTER,\n-\texpand_decl, and expand_decl_init.  Instead, add the local\n-\tvariable and a MODIFY_EXPR to the current tree.\n-\t(expand_iinc): Replace expand_assignment with\n-\tjava_add_stmt.\n-\t(expand_compare): Replace expand_cond with\n-\tjava_add_stmt(build (COND_EXPR))\n-\t(expand_java_goto): Replace expand_goto with\n-\tjava_add_stmt (build (GOTO_EXPR))\n-\t(expand_invoke): Replace expand_expr_stmt with java_add_stmt.\n-\t(build_jni_stub): Generate a BIND_EXPR to hold the block we've\n-\tcreated.  Don't distinguish between source and byte compiler.\n-\t(expand_java_field_op):  Replace expand_assignment with\n-\tjava_add_stmt.\n-\t(java_expand_expr): Abort.  No-one should call this function any\n-\tmore.\n-\t(expand_byte_code): Replace expand_label with\n-\tjava_add_stmt (build (LABEL_EXPR))\n-\t(process_jvm_instruction): Replace build (JAVA_EXC_OBJ_EXPR) with\n-\tbuild_exception_object_ref.  Replace expand_assignment with\n-\tjava_add_stmt.\n-\t* except.c (link_handler): Null stmt field.\n-\t(expand_start_java_handler): Don't expand_eh_region_start.\n-\tInstead, generate a TRY_CATCH_EXPR and insert it into the tree\n-\twe're building.\n-\t(expand_end_java_handler): Don't expand_start_all_catch.  Instead,\n-\tbuild a TRY_FINALLY_EXPR and wrap the catch block with it.\n-\tDon't expand_end_all_catch.\n-\t* decl.c (push_jvm_slot): Call pushdecl().\n-\t(find_local_variable): Give symbolic names to unnamed local\n-\tvariables.\n-\t(struct binding_level: stmts): New field.\n-\t(poplevel): If any statements have been generated at this level,\n-\tcreate a BIND_EXPR to hold them and copy the variables to it.  If\n-\twe are at the outermost level, save this BIND_EXPR in the\n-\tDECL_SAVED_TREE of this function.\n-\t(maybe_pushlevels): Don't expand_start_bindings.\n-\t(maybe_poplevels): Don't expand_end_bindings.\n-\t(complete_start_java_method): Reorganize static initialization and\n-\tsynchronization logic for source compiler.  Remove pushlevel and\n-\texpand_start_bindings for byte compiler.\n-\t(end_java_method): Don't expand_end_bindings.  Add static\n-\tinitialization and synchronization logic for byte compiler.\n-\tSet cfun->x_whole_function_mode_p.\n-\tCall gimplify_function_tree and optimize_function_tree and\n-\texpand_expr_stmt.\n-\t(add_stmt_to_compound): New.\n-\t(java_add_stmt): New.\n-\t(java_add_local_var): New.\n-\t(get_stmts): New.\n-\t* parse.y (add_stmt_to_compound): Remove.\n-\t* jcf-parse.c (parse_class_file): Don't call expand_expr_stmt for\n-\ta native method -- we'll do that later.\n-\n-2003-07-27  Andreas Jaeger  <aj@suse.de>\n-\n-\t* expr.c (build_expr_wfl): Convert remaining K&R prototypes\n-\tto ISO C90.\n-\n-2003-06-28  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* java-gimplify.c (java_gimplify_block): Rebuild BLOCK_SUBBLOCKS.\n-\t* lang.c (flag_disable_gimple): Remove initialization.\n-\n-2003-06-23  Jeff Law  <law@redhat.com>\n-\n-\t* Make-lang.in (java-gimplify.o): Add dependencies.\n-\n-2003-06-22  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* parse.y (source_end_java_method): Don't attempt to inline\n-\tor optimize trees if flag_disable_gimple.\n-\n-\t* Make-lang.in (JAVA_OBJS): Remove java-tree-inline.o.\n-\n-2003-06-21  Jeff Sturm  <jsturm@one-point.com>\n-\n-\t* Make-lang.in (JAVA_OBJS): Add java-gimplify.o.\n-\n-\t* decl.c (java_init_decl_processing): Initialize size_type_node.\n-\t(complete_start_java_method): Update DECL_SAVED_TREE.\n-\t(dump_function): Remove.\n-\t(java_optimize_inline): Remove.\n-\n-\t* expr.c (always_initialize_class_p): Initialize to 1.\n-\t(build_instanceof): Build proper boolean condition.\n-\t(build_class_init): Set DECL_INITIAL for init_test_decl.\n-\t(force_evaluation_order): Don't save_expr a void expr node.\n-\n-\t* java-gimplify.c: New file.\n-\n-\t* java-tree.h (java_gimplify_expr): Declare.\n-\n-\t* lang.c (java_tree_inlining_walk_subtrees): Remove declaration.\n-\t(flag_optimize_sci): Initialize to 0.\n-\t(LANG_HOOKS_TREE_INLINING_WALK_SUBTREES): Remove define.\n-\t(LANG_HOOKS_SIMPLIFY_EXPR): Add define.\n-\t(java_tree_inlining_walk_subtrees): Remove function.\n-\t(java_init): Set flag_disable_gimple to 1.\n-\n-\t* parse.y (source_end_java_method): Set cfun->x_whole_function_mode_p.\n-\tGimplify.  Optimize tree before expanding.  Update comments.\n-\t(java_expand_method_bodies): Always save DECL_SAVED_TREE.\n-\t(patch_invoke): Don't save_expr force_evaluation_order result.\n-\t(patch_assignment): Use simpler compound expression.\n-\t(patch_if_else_statement): Don't optimize constant condition nodes.\n-\n-2003-03-02  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* class.c: Replace DECL_SOURCE_FILE with TREE_FILENAME and\n-\tDECL_SOURCE_LINE with TREE_LINENO everywhere.\n-\n-2003-02-03  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* parse.y (qualify_ambiguous_name): Initialize variable 'decl'.\n-\n-2003-01-15  Jeff Law <law@redhat.com>\n-\n-\t* class.c: Use TREE_FILENAME and TREE_LINENO to extract file/line\n-\tinformation from tree nodes.  Use annotate_with_file_line to\n-\tannotate tree nodes with file/line information.\n-\t* decl.c, jcf-parse.c, jcf-write.c, parse.h: Likewise.\n-\t* parse.y: Likewise.\n-\t* expr.c (java_expand_expr): Handle EXPR_WITH_FILE_LOCATION nodes.\n-\t(build_expr_wfl): New function.\n-\t* java-tree.def (EXPR_WITH_FILE_LOCATION): New node.\n-\t* java-tree.h (EXPR_WFL_*): New macros.\n-\t(build_expr_wfl): Declare.\n-\n-Local Variables:\n-mode: change-log\n-change-log-default-name: \"ChangeLog.tree-ssa\"\n-End:\n-\n-\f\n-Copyright (C) 2003-2004 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "cbfd479a3dddb565aef902a4dbed0d50f6fa4f87", "filename": "gcc/java/Make-lang.in", "status": "removed", "additions": 0, "deletions": 343, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,343 +0,0 @@\n-# Top level -*- makefile -*- fragment for the GNU compiler for the Java(TM)\n-# language.\n-#   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-#This file is part of GCC.\n-\n-#GCC is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 3, or (at your option)\n-#any later version.\n-\n-#GCC is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GCC; see the file COPYING3.  If not see\n-#<http://www.gnu.org/licenses/>.\n-\n-#Java and all Java-based marks are trademarks or registered trademarks\n-#of Sun Microsystems, Inc. in the United States and other countries.\n-#The Free Software Foundation is independent of Sun Microsystems, Inc.\n-\n-# This file provides the language dependent support in the main Makefile.\n-# Each language makefile fragment must provide the following targets:\n-#\n-# foo.all.cross, foo.start.encap, foo.rest.encap,\n-# foo.install-common, foo.install-man, foo.install-info, foo.install-pdf,\n-# foo.install-html, foo.info, foo.dvi, foo.pdf, foo.html, foo.uninstall,\n-# foo.mostlyclean, foo.clean, foo.distclean,\n-# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n-#\n-# where `foo' is the name of the language.\n-#\n-# It should also provide rules for:\n-#\n-# - making any compiler driver (eg: g++)\n-# - the compiler proper (eg: jc1)\n-# - define the names for selecting the language in LANGUAGES.\n-\n-# Actual names to use when installing a native compiler.\n-JAVA_INSTALL_NAME := $(shell echo gcj|sed '$(program_transform_name)')\n-JAVA_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gcj|sed '$(program_transform_name)')\n-\n-XGCJ = gcj\n-\n-# Define the names for selecting java in LANGUAGES.\n-java: jc1$(exeext) $(XGCJ)$(exeext) jvgenmain$(exeext) jcf-dump$(exeext)\n-\n-# Define the name of target independent tools to be installed in $(bindir)\n-# Names are subject to changes\n-JAVA_TARGET_INDEPENDENT_BIN_TOOLS = jcf-dump\n-\n-# Tell GNU make to ignore these if they exist.\n-.PHONY: java\n-\n-CFLAGS-java/jvspec.o += $(DRIVER_DEFINES)\n-\n-# Create the compiler driver for $(XGCJ).\n-$(XGCJ)$(exeext): $(GCC_OBJS) java/jvspec.o java/jcf-path.o \\\n-\t   libcommon-target.a $(LIBDEPS) $(EXTRA_GCC_OBJS)\n-\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(GCC_OBJS) \\\n-\t  java/jvspec.o java/jcf-path.o $(EXTRA_GCC_OBJS) libcommon-target.a \\\n-\t  $(EXTRA_GCC_LIBS) $(LIBS)\n-\n-# Create a version of the $(XGCJ) driver which calls the cross-compiler.\n-$(XGCJ)-cross$(exeext): $(XGCJ)$(exeext)\n-\t-rm -f $(XGCJ)-cross$(exeext)\n-\tcp $(XGCJ)$(exeext) $(XGCJ)-cross$(exeext)\n-\n-java.srcextra:\n-\n-# Executables built by this Makefile:\n-JAVA_OBJS = java/class.o java/decl.o java/expr.o \\\n-  java/constants.o java/lang.o java/typeck.o java/except.o \\\n-  java/verify-glue.o java/verify-impl.o \\\n-  java/zextract.o java/jcf-io.o java/win32-host.o java/jcf-parse.o java/mangle.o \\\n-  java/mangle_name.o java/builtins.o java/resource.o \\\n-  java/jcf-depend.o \\\n-  java/jcf-path.o java/boehm.o java/java-gimplify.o hash-table.o\n-\n-JCFDUMP_OBJS = java/jcf-dump.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \\\n-\t\tjava/win32-host.o java/zextract.o ggc-none.o hash-table.o\n-\n-JVGENMAIN_OBJS = java/jvgenmain.o java/mangle_name.o\n-\n-java_OBJS = $(sort $(JAVA_OBJS) $(JCFDUMP_OBJS) $(JVGENMAIN_OBJS)) java/jvspec.o\n-\n-# Use strict warnings for this front end.\n-java-warn = $(STRICT_WARN)\n-\n-# String length warnings\n-java/jvspec.o-warn = -Wno-error\n-\n-jc1$(exeext): $(JAVA_OBJS) $(BACKEND) $(LIBDEPS) attribs.o\n-\trm -f $@\n-\t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t\t$(JAVA_OBJS) $(BACKEND) $(ZLIB) $(LIBICONV) $(LIBS) attribs.o $(BACKENDLIBS)\n-\n-jcf-dump$(exeext): $(JCFDUMP_OBJS) $(LIBDEPS)\n-\trm -f $@\n-\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(JCFDUMP_OBJS) \\\n-\t\t$(CPPLIBS) $(ZLIB) $(LDEXP_LIB) $(LIBS)\n-\n-jvgenmain$(exeext): $(JVGENMAIN_OBJS) $(LIBDEPS)\n-\trm -f $@\n-\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $(JVGENMAIN_OBJS) \\\n-\t\t$(LIBS)\n-\n-#\f\n-# Build hooks:\n-\n-java.all.cross: $(XGCJ)-cross$(exeext)\n-java.start.encap: $(XGCJ)$(exeext)\n-java.rest.encap:\n-\n-\n-java.tags: force\n-\tcd $(srcdir)/java; etags -o TAGS.sub *.c *.h --language=none \\\n-\t  --regex='/DEFTREECODE [(]\\([A-Z_]+\\)/\\1/' java-tree.def; \\\n-\tetags --include TAGS.sub --include ../TAGS.sub\n-\n-\n-java.info: doc/gcj.info\n-\n-java.srcinfo: doc/gcj.info\n-\t-cp -p $^ $(srcdir)/doc\n-\n-java.dvi: doc/gcj.dvi\n-\n-JAVA_PDFFILES = doc/gcj.pdf\n-\n-java.pdf: $(JAVA_PDFFILES)\n-\n-JAVA_HTMLFILES = $(build_htmldir)/java\n-\n-java.html: $(JAVA_HTMLFILES)/index.html\n-\n-JAVA_MANFILES = doc/gcj.1 doc/jcf-dump.1 doc/gij.1 \\\n-                doc/jv-convert.1 doc/grmic.1 \\\n-                doc/gcj-dbtool.1 doc/gc-analyze.1 doc/aot-compile.1 \\\n-                doc/rebuild-gcj-db.1\n-\n-java.man: $(JAVA_MANFILES)\n-\n-java.srcman: $(JAVA_MANFILES)\n-\t-cp -p $^ $(srcdir)/doc\n-\n-check-java :\n-check-java-subtargets :\n-\n-# Install hooks:\n-# jc1, gcj, and jvgenmain are installed elsewhere as part\n-# of $(COMPILERS).\n-\n-# Install gcj as well as the target-independent tools.\n-java.install-common: installdirs\n-\t-if [ -f $(XGCJ)$(exeext) ]; then \\\n-\t  rm -f $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \\\n-\t  $(INSTALL_PROGRAM) $(XGCJ)$(exeext) $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \\\n-\t  chmod a+x $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext); \\\n-\t  if [ -f $(XGCJ)-cross$(exeext) ]; then \\\n-\t    true; \\\n-\t  else \\\n-\t    rm -f $(DESTDIR)$(bindir)/$(JAVA_TARGET_INSTALL_NAME)$(exeext); \\\n-\t    ( cd $(DESTDIR)$(bindir) && \\\n-\t      $(LN) $(JAVA_INSTALL_NAME)$(exeext) $(JAVA_TARGET_INSTALL_NAME)$(exeext) ); \\\n-\t  fi ; \\\n-\tfi ; \\\n-        for tool in $(JAVA_TARGET_INDEPENDENT_BIN_TOOLS); do \\\n-\t  tool_transformed_name=`echo $$tool|sed '$(program_transform_name)'`; \\\n-          if [ -f $$tool$(exeext) ]; then \\\n-\t    rm -f $(DESTDIR)$(bindir)/$$tool_transformed_name$(exeext); \\\n-\t    $(INSTALL_PROGRAM) $$tool$(exeext) $(DESTDIR)$(bindir)/$$tool_transformed_name$(exeext); \\\n-\t    chmod a+x $(DESTDIR)$(bindir)/$$tool_transformed_name$(exeext); \\\n-          fi ; \\\n-       done\n-\n-java.install-plugin:\n-java.install-man:\n-\n-java.uninstall:\n-\t-rm -rf $(DESTDIR)$(bindir)/$(JAVA_INSTALL_NAME)$(exeext)\n-\t-rm -rf $(DESTDIR)$(man1dir)/$(JAVA_INSTALL_NAME)$(man1ext)\n-\t-rm -rf $(DESTDIR)$(man1dir)/jcf-dump$(man1ext)\n-\t-rm -rf $(DESTDIR)$(man1dir)/gij$(man1ext)\n-\t-rm -rf $(DESTDIR)$(man1dir)/jv-convert$(man1ext)\n-\t-rm -rf $(DESTDIR)$(man1dir)/gcj-dbtool$(man1ext)\n-\t-rm -rf $(DESTDIR)$(man1dir)/aot-compile$(man1ext)\n-\t-rm -rf $(DESTDIR)$(man1dir)/rebuild-gcj-db$(man1ext)\n-\n-java.install-info: $(DESTDIR)$(infodir)/gcj.info\n-\n-java.install-pdf: $(JAVA_PDFFILES)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n-\t@list='$(JAVA_PDFFILES)'; for p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  f=$(pdf__strip_dir) \\\n-\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n-\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n-\tdone\n-\n-java.install-html: $(JAVA_HTMLFILES)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n-\t@list='$(JAVA_HTMLFILES)'; for p in $$list; do \\\n-\t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; fi; \\\n-\t  f=$(html__strip_dir) \\\n-\t  if test -d \"$$d$$p\"; then \\\n-\t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n-\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-\t  else \\\n-\t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-\t  fi; \\\n-\tdone\n-#\f\n-# Clean hooks:\n-# A lot of the ancillary files are deleted by the main makefile.\n-# We just have to delete files specific to us.\n-\n-java.mostlyclean:\n-\t-rm -f java/*$(objext) $(DEMANGLER_PROG)\n-\t-rm -f java/*$(coverageexts)\n-\t-rm -f jc1$(exeext) $(XGCJ)$(exeext) jvgenmain$(exeext) \\\n-          jcf-dump$(exeext) s-java\n-java.clean:\n-java.distclean:\n-\t-rm -f java/config.status java/Makefile\n-java.maintainer-clean:\n-\t-rm -f $(docobjdir)/gcj.1\n-\t-rm -f $(docobjdir)/jcf-dump.1\n-\t-rm -f $(docobjdir)/gij.1\n-\t-rm -f $(docobjdir)/jv-convert.1\n-\t-rm -f $(docobjdir)/grmic.1\n-\t-rm -f $(docobjdir)/gcj-dbtool.1\n-\t-rm -f $(docobjdir)/gc-analyze.1\n-\t-rm -f $(docobjdir)/aot-compile.1\n-\t-rm -f $(docobjdir)/rebuild-gcj-db.1\n-#\f\n-# Stage hooks:\n-# The main makefile has already created stage?/java.\n-\n-java.stage1: stage1-start\n-\t-mv java/*$(objext) stage1/java\n-java.stage2: stage2-start\n-\t-mv java/*$(objext) stage2/java\n-java.stage3: stage3-start\n-\t-mv java/*$(objext) stage3/java\n-java.stage4: stage4-start\n-\t-mv java/*$(objext) stage4/java\n-java.stageprofile: stageprofile-start\n-\t-mv java/*$(objext) stageprofile/java\n-java.stagefeedback: stageprofile-start\n-\t-mv java/*$(objext) stagefeedback/java\n-\n-#\f\n-\n-# jcf-io.o needs $(ZLIBINC) added to cflags.\n-CFLAGS-java/jcf-io.o += $(ZLIBINC)\n-\n-# jcf-path.o needs a -D.\n-CFLAGS-java/jcf-path.o += \\\n-\t-DLIBGCJ_ZIP_FILE='\"$(datadir)/java/libgcj-$(version).jar\"' \\\n-\t-DDEFAULT_TARGET_VERSION=\\\"$(version)\\\"\n-\n-TEXI_JAVA_FILES = java/gcj.texi $(gcc_docdir)/include/fdl.texi\t\t\\\n-\t $(gcc_docdir)/include/gpl_v3.texi $(gcc_docdir)/include/gcc-common.texi   \\\n-\t gcc-vers.texi\n-\n-# Documentation\n-doc/gcj.info: $(TEXI_JAVA_FILES)\n-\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n-\t  rm -f doc/gcj.info*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \\\n-\t\t-I $(gcc_docdir)/include -o $@ $<; \\\n-\telse true; fi\n-\n-doc/gcj.dvi: $(TEXI_JAVA_FILES)\n-\t$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n-\n-doc/gcj.pdf: $(TEXI_JAVA_FILES)\n-\t$(TEXI2PDF) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n-\n-$(build_htmldir)/java/index.html: $(TEXI_JAVA_FILES)\n-\t$(mkinstalldirs) $(@D)\n-\trm -f $(@D)/*\n-\t$(TEXI2HTML) -I $(gcc_docdir) -I $(gcc_docdir)/include \\\n-\t\t-I $(srcdir)/java -o $(@D) $<\n-\n-.INTERMEDIATE: gcj.pod jcf-dump.pod gij.pod \\\n-  jv-convert.pod grmic.pod gcj-dbtool.pod gc-analyze.pod\n-\n-gcj.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D gcj < $< > $@\n-jcf-dump.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D jcf-dump < $< > $@\n-gij.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D gij < $< > $@\n-jv-convert.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D jv-convert < $< > $@\n-grmic.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D grmic < $< > $@\n-gcj-dbtool.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D gcj-dbtool < $< > $@\n-gc-analyze.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D gc-analyze < $< > $@\n-aot-compile.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D aot-compile < $< > $@\n-rebuild-gcj-db.pod: java/gcj.texi\n-\t-$(TEXI2POD) -D rebuild-gcj-db < $< > $@\n-\n-# Install the man pages.\n-java.install-man: installdirs \\\n-                  $(DESTDIR)$(man1dir)/$(JAVA_INSTALL_NAME)$(man1ext) \\\n-\t\t  $(JAVA_TARGET_INDEPENDENT_BIN_TOOLS:%=doc/%.1) \\\n-\t\t  doc/gij.1 doc/jv-convert.1 doc/grmic.1 \\\n-\t\t  doc/gcj-dbtool.1 doc/gc-analyze.1 \\\n-\t\t  doc/aot-compile.1 doc/rebuild-gcj-db.1\n-\tfor tool in $(JAVA_TARGET_INDEPENDENT_BIN_TOOLS) \\\n-\t\tgij jv-convert grmic gcj-dbtool gc-analyze aot-compile \\\n-\t\trebuild-gcj-db; do \\\n-\t  tool_transformed_name=`echo $$tool|sed '$(program_transform_name)'`; \\\n-\t  man_name=$(DESTDIR)$(man1dir)/$${tool_transformed_name}$(man1ext); \\\n-\t  rm -f $$man_name ; \\\n-\t  for source_name in doc/$${tool}.1 $(srcdir)/doc/$${tool}.1 ; do \\\n-\t    if test -f $$source_name; then \\\n-\t      $(INSTALL_DATA) $$source_name $$man_name; \\\n-\t      break; \\\n-\t      else : ; \\\n-\t    fi; \\\n-\t  done ; \\\n-\t  chmod a-x $$man_name ; \\\n-\tdone\n-\n-$(DESTDIR)$(man1dir)/$(JAVA_INSTALL_NAME)$(man1ext): doc/gcj.1 installdirs\n-\t-rm -f $@\n-\t-$(INSTALL_DATA) $< $@\n-\t-chmod a-x $@"}, {"sha": "38a2131e6f808df863aa884c62ebfe328d33c643", "filename": "gcc/java/boehm.c", "status": "removed", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,234 +0,0 @@\n-/* Functions related to the Boehm garbage collector.\n-   Copyright (C) 2000-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Tom Tromey <tromey@cygnus.com>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"java-tree.h\"\n-#include \"parse.h\"\n-\n-static void mark_reference_fields (tree, wide_int *, unsigned int,\n-\t\t\t\t   int *, int *, int *, HOST_WIDE_INT *);\n-\n-/* A procedure-based object descriptor.  We know that our\n-   `kind' is 0, and `env' is likewise 0, so we have a simple\n-   computation.  From the GC sources:\n-   (((((env) << LOG_MAX_MARK_PROCS) | (proc_index)) << DS_TAG_BITS)\t\\\n-   | DS_PROC)\n-   Here DS_PROC == 2.  */\n-#define PROCEDURE_OBJECT_DESCRIPTOR 2\n-\n-/* Recursively mark reference fields.  */\n-static void\n-mark_reference_fields (tree field,\n-\t\t       wide_int *mask,\n-\t\t       unsigned int ubit,\n-\t\t       int *pointer_after_end,\n-\t\t       int *all_bits_set,\n-\t\t       int *last_set_index,\n-\t\t       HOST_WIDE_INT *last_view_index)\n-{\n-  /* See if we have fields from our superclass.  */\n-  if (DECL_NAME (field) == NULL_TREE)\n-    {\n-      mark_reference_fields (TYPE_FIELDS (TREE_TYPE (field)),\n-\t\t\t     mask, ubit,\n-\t\t\t     pointer_after_end, all_bits_set,\n-\t\t\t     last_set_index, last_view_index);\n-      field = DECL_CHAIN (field);\n-    }\n-\n-  for (; field != NULL_TREE; field = DECL_CHAIN (field))\n-    {\n-      HOST_WIDE_INT offset;\n-      HOST_WIDE_INT size_bytes;\n-\n-      if (FIELD_STATIC (field))\n-\tcontinue;\n-\n-      offset = int_byte_position (field);\n-      size_bytes = int_size_in_bytes (TREE_TYPE (field));\n-\n-      if (JREFERENCE_TYPE_P (TREE_TYPE (field))\n-\t  /* An `object' of type gnu.gcj.RawData is actually non-Java\n-\t     data.  */\n-\t  && TREE_TYPE (field) != rawdata_ptr_type_node)\n-\t{\n-\t  unsigned int count;\n-\t  unsigned int size_words;\n-\t  unsigned int i;\n-\n-\t  /* If this reference slot appears to overlay a slot we think\n-\t     we already covered, then we are doomed.  */\n-\t  gcc_assert (offset > *last_view_index);\n-\n-\t  if (offset % (HOST_WIDE_INT) (POINTER_SIZE / BITS_PER_UNIT))\n-\t    {\n-\t      *all_bits_set = -1;\n-\t      *pointer_after_end = 1;\n-\t      break;\n-\t    }\n-\n-\t  count = offset * BITS_PER_UNIT / POINTER_SIZE;\n-\t  size_words = size_bytes * BITS_PER_UNIT / POINTER_SIZE;\n-\n-\t  *last_set_index = count;\n-\t     \n-\t  if (count >= ubit - 2)\n-\t    *pointer_after_end = 1;\n-\t  else\n-\t    /* First word in object corresponds to most significant byte of \n-\t       bitmap. \n-\t     \n-\t       In the case of a multiple-word record, we set pointer \n-\t       bits for all words in the record. This is conservative, but the \n-\t       size_words != 1 case is impossible in regular java code. */\n-\t    for (i = 0; i < size_words; ++i)\n-\t      *mask = wi::set_bit (*mask, ubit - count - i - 1);\n-\n-\t  /* If we saw a non-reference field earlier, then we can't\n-\t     use the count representation.  We keep track of that in\n-\t     *ALL_BITS_SET.  */\n-\t  if (! *all_bits_set)\n-\t    *all_bits_set = -1;\n-\t}\n-      else if (*all_bits_set > 0)\n-\t*all_bits_set = 0;\n-\n-      *last_view_index = offset;\n-    }\n-}\n-\n-/* Return the marking bitmap for the class TYPE.  For now this is a\n-   single word describing the type.  */\n-tree\n-get_boehm_type_descriptor (tree type)\n-{\n-  unsigned int count, log2_size, ubit;\n-  int bit;\n-  int all_bits_set = 1;\n-  int last_set_index = 0;\n-  HOST_WIDE_INT last_view_index = -1;\n-  int pointer_after_end = 0;\n-  tree field, value, value_type;\n-\n-  /* If the GC wasn't requested, just use a null pointer.  */\n-  if (! flag_use_boehm_gc)\n-    return null_pointer_node;\n-\n-  value_type = java_type_for_mode (ptr_mode, 1);\n-  wide_int mask = wi::zero (TYPE_PRECISION (value_type));\n-\n-  /* If we have a type of unknown size, use a proc.  */\n-  if (int_size_in_bytes (type) == -1)\n-    goto procedure_object_descriptor;\n-\n-  bit = POINTER_SIZE / BITS_PER_UNIT;\n-  /* The size of this node has to be known.  And, we only support 32\n-     and 64 bit targets, so we need to know that the log2 is one of\n-     our values.  */\n-  log2_size = exact_log2 (bit);\n-  if (bit == -1 || (log2_size != 2 && log2_size != 3))\n-    {\n-      /* This means the GC isn't supported.  We should probably\n-\t abort or give an error.  Instead, for now, we just silently\n-\t revert.  FIXME.  */\n-      return null_pointer_node;\n-    }\n-  bit *= BITS_PER_UNIT;\n-\n-  /* Warning avoidance.  */\n-  ubit = (unsigned int) bit;\n-\n-  if (type == class_type_node)\n-    goto procedure_object_descriptor;\n-\n-  field = TYPE_FIELDS (type);\n-  mark_reference_fields (field, &mask, ubit,\n-\t\t\t &pointer_after_end, &all_bits_set,\n-\t\t\t &last_set_index, &last_view_index);\n-\n-  /* If the object is all pointers, or if the part with pointers fits\n-     in our bitmap, then we are ok.  Otherwise we have to allocate it\n-     a different way.  */\n-  if (all_bits_set != -1 || (pointer_after_end && flag_reduced_reflection))\n-    {\n-      /* In this case the initial part of the object is all reference\n-\t fields, and the end of the object is all non-reference\n-\t fields.  We represent the mark as a count of the fields,\n-\t shifted.  In the GC the computation looks something like\n-\t this:\n-\t value = DS_LENGTH | WORDS_TO_BYTES (last_set_index + 1);\n-\t DS_LENGTH is 0.\n-\t WORDS_TO_BYTES shifts by log2(bytes-per-pointer).\n-\n-         In the case of flag_reduced_reflection and the bitmap would\n-         overflow, we tell the gc that the object is all pointers so\n-         that we don't have to emit reflection data for run time\n-         marking. */\n-      count = 0;\n-      mask = wi::zero (TYPE_PRECISION (value_type));\n-      ++last_set_index;\n-      while (last_set_index)\n-\t{\n-\t  if ((last_set_index & 1))\n-\t    mask = wi::set_bit (mask, log2_size + count);\n-\t  last_set_index >>= 1;\n-\t  ++count;\n-\t}\n-      value = wide_int_to_tree (value_type, mask);\n-    }\n-  else if (! pointer_after_end)\n-    {\n-      /* Bottom two bits for bitmap mark type are 01.  */\n-      mask = wi::set_bit (mask, 0);\n-      value = wide_int_to_tree (value_type, mask);\n-    }\n-  else\n-    {\n-    procedure_object_descriptor:\n-      value = build_int_cst (value_type, PROCEDURE_OBJECT_DESCRIPTOR);\n-    }\n-\n-  return value;\n-}\n-\n-/* The fourth (index of 3) element in the vtable is the GC descriptor.\n-   A value of 2 indicates that the class uses _Jv_MarkObj. */\n-bool\n-uses_jv_markobj_p (tree dtable)\n-{\n-  tree v;\n-  /* FIXME: what do we return if !flag_use_boehm_gc ? */\n-  gcc_assert (flag_use_boehm_gc);\n-  /* FIXME: this is wrong if TARGET_VTABLE_USES_DESCRIPTORS.  However,\n-     this function is only used with flag_reduced_reflection.  No\n-     point in asserting unless we hit the bad case.  */\n-  gcc_assert (!flag_reduced_reflection || TARGET_VTABLE_USES_DESCRIPTORS == 0);\n-  v = (*CONSTRUCTOR_ELTS (dtable))[3].value;\n-  return (PROCEDURE_OBJECT_DESCRIPTOR == TREE_INT_CST_LOW (v));\n-}"}, {"sha": "f27831d51c24ffa42c8cc6030780afa1489d59cd", "filename": "gcc/java/builtins.c", "status": "removed", "additions": 0, "deletions": 662, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,662 +0,0 @@\n-/* Built-in and inline functions for gcj\n-   Copyright (C) 2001-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-.\n-\n-.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Tom Tromey <tromey@redhat.com>.  */\n-\n-/* FIXME: Still need to include rtl.h here (see below).  */\n-#undef IN_GCC_FRONTEND\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"expmed.h\"\n-#include \"optabs.h\"\n-#include \"fold-const.h\"\n-#include \"stor-layout.h\"\n-#include \"java-tree.h\"\n-\n-/* FIXME: All these headers are necessary for sync_compare_and_swap.\n-   Front ends should never have to look at that.  */\n-\n-static tree max_builtin (tree, tree);\n-static tree min_builtin (tree, tree);\n-static tree abs_builtin (tree, tree);\n-static tree convert_real (tree, tree);\n-\n-static tree java_build_function_call_expr (tree, tree);\n-\n-static tree putObject_builtin (tree, tree);\n-static tree compareAndSwapInt_builtin (tree, tree);\n-static tree compareAndSwapLong_builtin (tree, tree);\n-static tree compareAndSwapObject_builtin (tree, tree);\n-static tree putVolatile_builtin (tree, tree);\n-static tree getVolatile_builtin (tree, tree);\n-static tree VMSupportsCS8_builtin (tree, tree);\n-\f\n-\n-/* Functions of this type are used to inline a given call.  Such a\n-   function should either return an expression, if the call is to be\n-   inlined, or NULL_TREE if a real call should be emitted.  Arguments\n-   are method return type and the original CALL_EXPR containing the\n-   arguments to the call.  */\n-typedef tree builtin_creator_function (tree, tree);\n-\n-/* Hold a char*, before initialization, or a tree, after\n-   initialization.  */\n-union GTY(()) string_or_tree {\n-  const char * GTY ((tag (\"0\"))) s;\n-  tree GTY ((tag (\"1\"))) t;\n-};\n-\n-/* Used to hold a single builtin record.  */\n-struct GTY(()) builtin_record {\n-  union string_or_tree GTY ((desc (\"1\"))) class_name;\n-  union string_or_tree GTY ((desc (\"1\"))) method_name;\n-  builtin_creator_function * GTY((skip)) creator;\n-  enum built_in_function builtin_code;\n-};\n-\n-static GTY(()) struct builtin_record java_builtins[] =\n-{\n-  { { \"java.lang.Math\" }, { \"min\" }, min_builtin, (enum built_in_function) 0 },\n-  { { \"java.lang.Math\" }, { \"max\" }, max_builtin, (enum built_in_function) 0 },\n-  { { \"java.lang.Math\" }, { \"abs\" }, abs_builtin, (enum built_in_function) 0 },\n-  { { \"java.lang.Math\" }, { \"acos\" }, NULL, BUILT_IN_ACOS },\n-  { { \"java.lang.Math\" }, { \"asin\" }, NULL, BUILT_IN_ASIN },\n-  { { \"java.lang.Math\" }, { \"atan\" }, NULL, BUILT_IN_ATAN },\n-  { { \"java.lang.Math\" }, { \"atan2\" }, NULL, BUILT_IN_ATAN2 },\n-  { { \"java.lang.Math\" }, { \"ceil\" }, NULL, BUILT_IN_CEIL },\n-  { { \"java.lang.Math\" }, { \"cos\" }, NULL, BUILT_IN_COS },\n-  { { \"java.lang.Math\" }, { \"exp\" }, NULL, BUILT_IN_EXP },\n-  { { \"java.lang.Math\" }, { \"floor\" }, NULL, BUILT_IN_FLOOR },\n-  { { \"java.lang.Math\" }, { \"log\" }, NULL, BUILT_IN_LOG },\n-  { { \"java.lang.Math\" }, { \"pow\" }, NULL, BUILT_IN_POW },\n-  { { \"java.lang.Math\" }, { \"sin\" }, NULL, BUILT_IN_SIN },\n-  { { \"java.lang.Math\" }, { \"sqrt\" }, NULL, BUILT_IN_SQRT },\n-  { { \"java.lang.Math\" }, { \"tan\" }, NULL, BUILT_IN_TAN },\n-  { { \"java.lang.Integer\" }, { \"bitCount\" }, NULL, BUILT_IN_POPCOUNT },\n-  { { \"java.lang.Integer\" }, { \"reverseBytes\" }, NULL, BUILT_IN_BSWAP32 },\n-  { { \"java.lang.Long\" }, { \"bitCount\" }, NULL, BUILT_IN_POPCOUNTL },\n-  { { \"java.lang.Long\" }, { \"reverseBytes\" }, NULL, BUILT_IN_BSWAP64 },\n-  { { \"java.lang.Short\" }, { \"reverseBytes\" }, NULL, BUILT_IN_BSWAP16 },\n-  { { \"java.lang.Float\" }, { \"intBitsToFloat\" }, convert_real,\n-    (enum built_in_function) 0 },\n-  { { \"java.lang.Double\" }, { \"longBitsToDouble\" }, convert_real,\n-    (enum built_in_function) 0 },\n-  { { \"java.lang.Float\" }, { \"floatToRawIntBits\" }, convert_real,\n-    (enum built_in_function) 0 },\n-  { { \"java.lang.Double\" }, { \"doubleToRawLongBits\" }, convert_real,\n-    (enum built_in_function) 0 },\n-  { { \"sun.misc.Unsafe\" }, { \"putInt\" }, putObject_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putLong\" }, putObject_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putObject\" }, putObject_builtin,\n-  (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"compareAndSwapInt\" },\n-    compareAndSwapInt_builtin, (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"compareAndSwapLong\" },\n-    compareAndSwapLong_builtin, (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"compareAndSwapObject\" },\n-    compareAndSwapObject_builtin, (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putOrderedInt\" }, putVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putOrderedLong\" }, putVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putOrderedObject\" }, putVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putIntVolatile\" }, putVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putLongVolatile\" }, putVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"putObjectVolatile\" }, putVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"getObjectVolatile\" }, getVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"getIntVolatile\" }, getVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"getLongVolatile\" }, getVolatile_builtin, (enum built_in_function) 0},\n-  { { \"sun.misc.Unsafe\" }, { \"getLong\" }, getVolatile_builtin,\n-    (enum built_in_function) 0},\n-  { { \"java.util.concurrent.atomic.AtomicLong\" }, { \"VMSupportsCS8\" },\n-    VMSupportsCS8_builtin, (enum built_in_function) 0},\n-  { { NULL }, { NULL }, NULL, END_BUILTINS }\n-};\n-\n-\f\n-/* Internal functions which implement various builtin conversions.  */\n-\n-static tree\n-max_builtin (tree method_return_type, tree orig_call)\n-{\n-  /* MAX_EXPR does not handle -0.0 in the Java style.  */\n-  if (TREE_CODE (method_return_type) == REAL_TYPE)\n-    return NULL_TREE;\n-  return fold_build2 (MAX_EXPR, method_return_type,\n-\t\t      CALL_EXPR_ARG (orig_call, 0),\n-\t\t      CALL_EXPR_ARG (orig_call, 1));\n-}\n-\n-static tree\n-min_builtin (tree method_return_type, tree orig_call)\n-{\n-  /* MIN_EXPR does not handle -0.0 in the Java style.  */\n-  if (TREE_CODE (method_return_type) == REAL_TYPE)\n-    return NULL_TREE;\n-  return fold_build2 (MIN_EXPR, method_return_type,\n-\t\t      CALL_EXPR_ARG (orig_call, 0),\n-\t\t      CALL_EXPR_ARG (orig_call, 1));\n-}\n-\n-static tree\n-abs_builtin (tree method_return_type, tree orig_call)\n-{\n-  return fold_build1 (ABS_EXPR, method_return_type,\n-\t\t      CALL_EXPR_ARG (orig_call, 0));\n-}\n-\n-/* Construct a new call to FN using the arguments from ORIG_CALL.  */\n-\n-static tree\n-java_build_function_call_expr (tree fn, tree orig_call)\n-{\n-  int nargs = call_expr_nargs (orig_call);\n-  switch (nargs)\n-    {\n-      /* Although we could handle the 0-3 argument cases using the general\n-\t logic in the default case, splitting them out permits folding to\n-\t be performed without constructing a temporary CALL_EXPR.  */\n-    case 0:\n-      return build_call_expr (fn, 0);\n-    case 1:\n-      return build_call_expr (fn, 1, CALL_EXPR_ARG (orig_call, 0));\n-    case 2:\n-      return build_call_expr (fn, 2,\n-\t\t\t      CALL_EXPR_ARG (orig_call, 0),\n-\t\t\t      CALL_EXPR_ARG (orig_call, 1));\n-    case 3:\n-      return build_call_expr (fn, 3,\n-\t\t\t      CALL_EXPR_ARG (orig_call, 0),\n-\t\t\t      CALL_EXPR_ARG (orig_call, 1),\n-\t\t\t      CALL_EXPR_ARG (orig_call, 2));\n-    default:\n-      {\n-\ttree fntype = TREE_TYPE (fn);\n-\tfn = build1 (ADDR_EXPR, build_pointer_type (fntype), fn);\n-\treturn fold (build_call_array (TREE_TYPE (fntype),\n-\t\t\t\t       fn, nargs, CALL_EXPR_ARGP (orig_call)));\n-      }\n-    }\n-}\n-\n-static tree\n-convert_real (tree method_return_type, tree orig_call)\n-{\n-  return build1 (VIEW_CONVERT_EXPR, method_return_type,\n-\t\t CALL_EXPR_ARG (orig_call, 0));\n-}\n-\n-\f\n-\n-/* Provide builtin support for atomic operations.  These are\n-   documented at length in libjava/sun/misc/Unsafe.java.  */\n-\n-/* FIXME.  There are still a few things wrong with this logic.  In\n-   particular, atomic writes of multi-word integers are not truly\n-   atomic: this requires more work.\n-\n-   In general, double-word compare-and-swap cannot portably be\n-   implemented, so we need some kind of fallback for 32-bit machines.\n-\n-*/\n-\n-\n-/* Macros to unmarshal arguments from a CALL_EXPR into a few\n-   variables.  We also convert the offset arg from a long to an\n-   integer that is the same size as a pointer.  */\n-\n-#define UNMARSHAL3(METHOD_CALL)\t\t\t\t\t\\\n-tree this_arg, obj_arg, offset_arg;\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  tree orig_method_call = METHOD_CALL;\t\t\t\t\t\\\n-  this_arg = CALL_EXPR_ARG (orig_method_call, 0);\t\t\t\\\n-  obj_arg = CALL_EXPR_ARG (orig_method_call, 1);\t\t\t\\\n-  offset_arg = fold_convert (java_type_for_size (POINTER_SIZE, 0),\t\\\n-\t\t\t     CALL_EXPR_ARG (orig_method_call, 2));\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-#define UNMARSHAL4(METHOD_CALL)\t\t\t\t\t\\\n-tree value_type, this_arg, obj_arg, offset_arg, value_arg;\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  tree orig_method_call = METHOD_CALL;\t\t\t\t\t\\\n-  this_arg = CALL_EXPR_ARG (orig_method_call, 0);\t\t\t\\\n-  obj_arg = CALL_EXPR_ARG (orig_method_call, 1);\t\t\t\\\n-  offset_arg = fold_convert (java_type_for_size (POINTER_SIZE, 0),\t\\\n-\t\t\t     CALL_EXPR_ARG (orig_method_call, 2));\t\\\n-  value_arg = CALL_EXPR_ARG (orig_method_call, 3);\t\t\t\\\n-  value_type = TREE_TYPE (value_arg);\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-#define UNMARSHAL5(METHOD_CALL)\t\t\t\t\t\\\n-tree value_type, this_arg, obj_arg, offset_arg, expected_arg, value_arg; \\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  tree orig_method_call = METHOD_CALL;\t\t\t\t\t\\\n-  this_arg = CALL_EXPR_ARG (orig_method_call, 0);\t\t\t\\\n-  obj_arg = CALL_EXPR_ARG (orig_method_call, 1);\t\t\t\\\n-  offset_arg = fold_convert (java_type_for_size (POINTER_SIZE, 0),\t\\\n-\t\t\t     CALL_EXPR_ARG (orig_method_call, 2));\t\\\n-  expected_arg = CALL_EXPR_ARG (orig_method_call, 3);\t\t\t\\\n-  value_arg = CALL_EXPR_ARG (orig_method_call, 4);\t\t\t\\\n-  value_type = TREE_TYPE (value_arg);\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* Add an address to an offset, forming a sum.  */\n-\n-static tree\n-build_addr_sum (tree type, tree addr, tree offset)\n-{\n-  tree ptr_type = build_pointer_type (type);\n-  return fold_build_pointer_plus (fold_convert (ptr_type, addr), offset);\n-}\n-\n-/* Make sure that this-arg is non-NULL.  This is a security check.  */\n-\n-static tree\n-build_check_this (tree stmt, tree this_arg)\n-{\n-  return build2 (COMPOUND_EXPR, TREE_TYPE (stmt), \n-\t\t java_check_reference (this_arg, 1), stmt);\n-}\n-\n-/* Now the builtins.  These correspond to the primitive functions in\n-   libjava/sun/misc/natUnsafe.cc.  */\n-\n-static tree\n-putObject_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t   tree orig_call)\n-{\n-  tree addr, stmt;\n-  UNMARSHAL4 (orig_call);\n-\n-  addr = build_addr_sum (value_type, obj_arg, offset_arg);\n-  stmt = fold_build2 (MODIFY_EXPR, value_type,\n-\t\t      build_java_indirect_ref (value_type, addr,\n-\t\t\t\t\t       flag_check_references),\n-\t\t      value_arg);\n-\n-  return build_check_this (stmt, this_arg);\n-}\n-\n-static tree\n-compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n-\t\t\t   tree orig_call)\n-{\n-  machine_mode mode = TYPE_MODE (int_type_node);\n-  if (can_compare_and_swap_p (mode, flag_use_atomic_builtins))\n-    {\n-      tree addr, stmt;\n-      enum built_in_function fncode = BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4;\n-      UNMARSHAL5 (orig_call);\n-      (void) value_type; /* Avoid set but not used warning.  */\n-\n-      addr = build_addr_sum (int_type_node, obj_arg, offset_arg);\n-      stmt = build_call_expr (builtin_decl_explicit (fncode),\n-\t\t\t      3, addr, expected_arg, value_arg);\n-\n-      return build_check_this (stmt, this_arg);\n-    }\n-  return NULL_TREE;\n-}\n-\n-static tree\n-compareAndSwapLong_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n-\t\t\t    tree orig_call)\n-{\n-  machine_mode mode = TYPE_MODE (long_type_node);\n-  /* We don't trust flag_use_atomic_builtins for multi-word compareAndSwap.\n-     Some machines such as ARM have atomic libfuncs but not the multi-word\n-     versions.  */\n-  if (can_compare_and_swap_p (mode,\n-\t\t\t      (flag_use_atomic_builtins\n-\t\t\t       && GET_MODE_SIZE (mode) <= UNITS_PER_WORD)))\n-    {\n-      tree addr, stmt;\n-      enum built_in_function fncode = BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8;\n-      UNMARSHAL5 (orig_call);\n-      (void) value_type; /* Avoid set but not used warning.  */\n-\n-      addr = build_addr_sum (long_type_node, obj_arg, offset_arg);\n-      stmt = build_call_expr (builtin_decl_explicit (fncode),\n-\t\t\t      3, addr, expected_arg, value_arg);\n-\n-      return build_check_this (stmt, this_arg);\n-    }\n-  return NULL_TREE;\n-}\n-static tree\n-compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t\t      tree orig_call)\n-{\n-  machine_mode mode = TYPE_MODE (ptr_type_node);\n-  if (can_compare_and_swap_p (mode, flag_use_atomic_builtins))\n-  {\n-    tree addr, stmt;\n-    enum built_in_function builtin;\n-\n-    UNMARSHAL5 (orig_call);\n-    builtin = (POINTER_SIZE == 32 \n-\t       ? BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4 \n-\t       : BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8);\n-\n-    addr = build_addr_sum (value_type, obj_arg, offset_arg);\n-    stmt = build_call_expr (builtin_decl_explicit (builtin),\n-\t\t\t    3, addr, expected_arg, value_arg);\n-\n-    return build_check_this (stmt, this_arg);\n-  }\n-  return NULL_TREE;\n-}\n-\n-static tree\n-putVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t     tree orig_call)\n-{\n-  tree addr, stmt, modify_stmt;\n-  UNMARSHAL4 (orig_call);\n-  \n-  addr = build_addr_sum (value_type, obj_arg, offset_arg);\n-  addr \n-    = fold_convert (build_pointer_type (build_qualified_type\n-\t\t\t\t\t(value_type, TYPE_QUAL_VOLATILE)),\n-\t\t    addr);\n-  \n-  stmt = build_call_expr (builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE), 0);\n-  modify_stmt = fold_build2 (MODIFY_EXPR, value_type,\n-\t\t\t     build_java_indirect_ref (value_type, addr,\n-\t\t\t\t\t\t      flag_check_references),\n-\t\t\t     value_arg);\n-  stmt = build2 (COMPOUND_EXPR, TREE_TYPE (modify_stmt), \n-\t\t stmt, modify_stmt);\n-\n-  return build_check_this (stmt, this_arg);\n-}\n-\n-static tree\n-getVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED, \n-\t\t     tree orig_call)\n-{\n-  tree addr, stmt, modify_stmt, tmp;\n-  UNMARSHAL3 (orig_call);\n-  (void) this_arg; /* Avoid set but not used warning.  */\n-\n-  addr = build_addr_sum (method_return_type, obj_arg, offset_arg);\n-  addr \n-    = fold_convert (build_pointer_type (build_qualified_type\n-\t\t\t\t\t(method_return_type,\n-\t\t\t\t\t TYPE_QUAL_VOLATILE)), addr);\n-  \n-  stmt = build_call_expr (builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE), 0);\n-  tmp = build_decl (BUILTINS_LOCATION, VAR_DECL, NULL, method_return_type);\n-  DECL_IGNORED_P (tmp) = 1;\n-  DECL_ARTIFICIAL (tmp) = 1;\n-  pushdecl (tmp);\n-\n-  modify_stmt = fold_build2 (MODIFY_EXPR, method_return_type,\n-\t\t\t     tmp,\n-\t\t\t     build_java_indirect_ref (method_return_type, addr,\n-\t\t\t\t\t\t      flag_check_references));\n-\n-  stmt = build2 (COMPOUND_EXPR, void_type_node, modify_stmt, stmt);\n-  stmt = build2 (COMPOUND_EXPR, method_return_type, stmt, tmp);\n-  \n-  return stmt;\n-}\n-\n-static tree\n-VMSupportsCS8_builtin (tree method_return_type, \n-\t\t       tree orig_call ATTRIBUTE_UNUSED)\n-{\n-  machine_mode mode = TYPE_MODE (long_type_node);\n-  gcc_assert (method_return_type == boolean_type_node);\n-  if (can_compare_and_swap_p (mode, false))\n-    return boolean_true_node;\n-  else\n-    return boolean_false_node;\n-}  \n-\n-\f\n-\n-/* Define a single builtin.  */\n-static void\n-define_builtin (enum built_in_function val,\n-\t\tconst char *name,\n-\t\ttree type,\n-\t\tconst char *libname,\n-\t\tint flags)\n-{\n-  tree decl;\n-\n-  decl = build_decl (BUILTINS_LOCATION,\n-\t\t     FUNCTION_DECL, get_identifier (name), type);\n-  DECL_EXTERNAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  SET_DECL_ASSEMBLER_NAME (decl, get_identifier (libname));\n-  pushdecl (decl);\n-  DECL_BUILT_IN_CLASS (decl) = BUILT_IN_NORMAL;\n-  DECL_FUNCTION_CODE (decl) = val;\n-  set_call_expr_flags (decl, flags);\n-\n-  set_builtin_decl (val, decl, true);\n-}\n-\n-\f\n-\n-/* Initialize the builtins.  */\n-void\n-initialize_builtins (void)\n-{\n-  tree double_ftype_double, double_ftype_double_double;\n-  tree float_ftype_float_float;\n-  tree boolean_ftype_boolean_boolean;\n-  tree int_ftype_int;\n-  int i;\n-\n-  for (i = 0; java_builtins[i].builtin_code != END_BUILTINS; ++i)\n-    {\n-      tree klass_id = get_identifier (java_builtins[i].class_name.s);\n-      tree m = get_identifier (java_builtins[i].method_name.s);\n-\n-      java_builtins[i].class_name.t = klass_id;\n-      java_builtins[i].method_name.t = m;\n-    }\n-\n-  void_list_node = end_params_node;\n-\n-  float_ftype_float_float\n-    = build_function_type_list (float_type_node,\n-\t\t\t\tfloat_type_node, float_type_node, NULL_TREE);\n-\n-  double_ftype_double\n-    = build_function_type_list (double_type_node, double_type_node, NULL_TREE);\n-  double_ftype_double_double\n-    = build_function_type_list (double_type_node,\n-\t\t\t\tdouble_type_node, double_type_node, NULL_TREE);\n-\n-  define_builtin (BUILT_IN_FMOD, \"__builtin_fmod\",\n-\t\t  double_ftype_double_double, \"fmod\", ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_FMODF, \"__builtin_fmodf\",\n-\t\t  float_ftype_float_float, \"fmodf\", ECF_CONST | ECF_LEAF);\n-\n-  define_builtin (BUILT_IN_ACOS, \"__builtin_acos\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math4acosEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_ASIN, \"__builtin_asin\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math4asinEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_ATAN, \"__builtin_atan\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math4atanEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_ATAN2, \"__builtin_atan2\",\n-\t\t  double_ftype_double_double, \"_ZN4java4lang4Math5atan2EJddd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_CEIL, \"__builtin_ceil\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math4ceilEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_COS, \"__builtin_cos\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math3cosEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_EXP, \"__builtin_exp\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math3expEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_FLOOR, \"__builtin_floor\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math5floorEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_LOG, \"__builtin_log\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math3logEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_POW, \"__builtin_pow\",\n-\t\t  double_ftype_double_double, \"_ZN4java4lang4Math3powEJddd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_SIN, \"__builtin_sin\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math3sinEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_SQRT, \"__builtin_sqrt\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math4sqrtEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-  define_builtin (BUILT_IN_TAN, \"__builtin_tan\",\n-\t\t  double_ftype_double, \"_ZN4java4lang4Math3tanEJdd\",\n-\t\t  ECF_CONST | ECF_LEAF);\n-\n-  int_ftype_int = build_function_type_list (int_type_node,\n-                                            int_type_node, NULL_TREE);\n-\n-  define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", int_ftype_int,\n-                  \"_ZN4java4lang7Integer8bitCountEJii\",\n-                  ECF_CONST | ECF_LEAF | ECF_NOTHROW);\n-  define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", int_ftype_int,\n-\t\t  \"_ZN4java4lang7Integer12reverseBytesEJii\",\n-                  ECF_CONST | ECF_LEAF | ECF_NOTHROW);\n-\n-  define_builtin (BUILT_IN_POPCOUNTL, \"__builtin_popcountl\",\n-                  build_function_type_list (int_type_node,\n-\t\t\t\t\t    long_type_node, NULL_TREE),\n-\t\t  \"_ZN4java4lang4Long8bitCountEJix\",\n-                  ECF_CONST | ECF_LEAF | ECF_NOTHROW);\n-  define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\",\n-\t\t  build_function_type_list (long_type_node,\n-\t\t\t\t\t    long_type_node, NULL_TREE),\n-\t\t  \"_ZN4java4lang4Long12reverseBytesEJxx\",\n-                  ECF_CONST | ECF_LEAF | ECF_NOTHROW);\n-                  \n-  define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\",\n-\t\t  build_function_type_list (short_type_node,\n-\t\t\t\t\t    short_type_node, NULL_TREE),\n-\t\t  \"_ZN4java4lang5Short12reverseBytesEJss\",\n-                  ECF_CONST | ECF_LEAF | ECF_NOTHROW);\n-\n-  boolean_ftype_boolean_boolean\n-    = build_function_type_list (boolean_type_node,\n-\t\t\t\tboolean_type_node, boolean_type_node,\n-\t\t\t\tNULL_TREE);\n-  define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", \n-\t\t  boolean_ftype_boolean_boolean,\n-\t\t  \"__builtin_expect\",\n-\t\t  ECF_CONST | ECF_NOTHROW);\n-  define_builtin (BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_4, \n-\t\t  \"__sync_bool_compare_and_swap_4\",\n-\t\t  build_function_type_list (boolean_type_node,\n-\t\t\t\t\t    int_type_node, \n-\t\t\t\t\t    build_pointer_type (int_type_node),\n-\t\t\t\t\t    int_type_node, NULL_TREE), \n-\t\t  \"__sync_bool_compare_and_swap_4\", ECF_NOTHROW | ECF_LEAF);\n-  define_builtin (BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_8, \n-\t\t  \"__sync_bool_compare_and_swap_8\",\n-\t\t  build_function_type_list (boolean_type_node,\n-\t\t\t\t\t    long_type_node, \n-\t\t\t\t\t    build_pointer_type (long_type_node),\n-\t\t\t\t\t    int_type_node, NULL_TREE), \n-\t\t  \"__sync_bool_compare_and_swap_8\", ECF_NOTHROW | ECF_LEAF);\n-  define_builtin (BUILT_IN_SYNC_SYNCHRONIZE, \"__sync_synchronize\",\n-\t\t  build_function_type_list (void_type_node, NULL_TREE),\n-\t\t  \"__sync_synchronize\", ECF_NOTHROW | ECF_LEAF);\n-  \n-  define_builtin (BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\",\n-\t\t  build_function_type_list (ptr_type_node, int_type_node, NULL_TREE),\n-\t\t  \"__builtin_return_address\", ECF_NOTHROW | ECF_LEAF);\n-  define_builtin (BUILT_IN_TRAP, \"__builtin_trap\",\n-\t\t  build_function_type_list (void_type_node, NULL_TREE),\n-\t\t  \"__builtin_trap\", ECF_NOTHROW | ECF_LEAF | ECF_NORETURN);\n-  build_common_builtin_nodes ();\n-}\n-\n-/* If the call matches a builtin, return the\n-   appropriate builtin expression instead.  */\n-tree\n-check_for_builtin (tree method, tree call)\n-{\n-  if (optimize && TREE_CODE (call) == CALL_EXPR)\n-    {\n-      int i;\n-      tree method_class = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));\n-      tree method_name = DECL_NAME (method);\n-      tree method_return_type = TREE_TYPE (TREE_TYPE (method));\n-\n-      for (i = 0; java_builtins[i].builtin_code != END_BUILTINS; ++i)\n-\t{\n-\t  if (method_class == java_builtins[i].class_name.t\n-\t      && method_name == java_builtins[i].method_name.t)\n-\t    {\n-\t      tree fn;\n-\n-\t      if (java_builtins[i].creator != NULL)\n-\t\t{\n-\t\t  tree result\n-\t\t    = (*java_builtins[i].creator) (method_return_type, call);\n-\t\t  return result == NULL_TREE ? call : result;\n-\t\t}\n-\n-\t      /* Builtin functions emit a direct call which is incompatible\n-\t         with the BC-ABI.  */\n-\t      if (flag_indirect_dispatch)\n-\t        return call;\n-\t      fn = builtin_decl_explicit (java_builtins[i].builtin_code);\n-\t      if (fn == NULL_TREE)\n-\t\treturn call;\n-\t      return java_build_function_call_expr (fn, call);\n-\t    }\n-\t}\n-    }\n-  return call;\n-}\n-\n-#include \"gt-java-builtins.h\""}, {"sha": "b4708bcbcdf291be8ef502aca430fb4640f586c8", "filename": "gcc/java/class.c", "status": "removed", "additions": 0, "deletions": 3245, "changes": 3245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9e84288c33a84c41d42d6a471b74069563293e88", "filename": "gcc/java/config-lang.in", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconfig-lang.in?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,40 +0,0 @@\n-# Top level configure fragment for the GNU compiler for the Java(TM)\n-# language.\n-#  Copyright (C) 1994-2016 Free Software Foundation, Inc.\n-\n-#This file is part of GCC.\n-\n-#GCC is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 3, or (at your option)\n-#any later version.\n-\n-#GCC is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GCC; see the file COPYING3.  If not see\n-#<http://www.gnu.org/licenses/>.\n-\n-#Java and all Java-based marks are trademarks or registered trademarks\n-#of Sun Microsystems, Inc. in the United States and other countries.\n-#The Free Software Foundation is independent of Sun Microsystems, Inc.\n-\n-# Configure looks for the existence of this file to auto-config each language.\n-# We define several parameters used by configure:\n-#\n-# language\t- name of language as it would appear in $(LANGUAGES)\n-# compilers\t- value to add to $(COMPILERS)\n-\n-language=\"java\"\n-\n-compilers=\"jc1\\$(exeext) jvgenmain\\$(exeext)\"\n-\n-gtfiles=\"\\$(srcdir)/java/java-tree.h \\$(srcdir)/java/jcf.h \\$(srcdir)/java/parse.h \\$(srcdir)/java/builtins.c \\$(srcdir)/java/class.c \\$(srcdir)/java/constants.c \\$(srcdir)/java/decl.c \\$(srcdir)/java/expr.c \\$(srcdir)/java/jcf-parse.c \\$(srcdir)/java/lang.c \\$(srcdir)/java/mangle.c \\$(srcdir)/java/resource.c\"\n-\n-target_libs=${libgcj_saved}\n-lang_dirs=\"fastjar\"\n-#build_by_default=no\n-lang_requires=c++"}, {"sha": "817f04acc2ec60765966fafdeae399eff644a2ce", "filename": "gcc/java/constants.c", "status": "removed", "additions": 0, "deletions": 614, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,614 +0,0 @@\n-/* Handle the constant pool of the Java(TM) Virtual Machine.\n-   Copyright (C) 1997-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"jcf.h\"\n-#include \"fold-const.h\"\n-#include \"stor-layout.h\"\n-#include \"java-tree.h\"\n-#include \"toplev.h\"\n-\n-static void set_constant_entry (CPool *, int, int, jword);\n-static int find_tree_constant (CPool *, int, tree);\n-static int find_name_and_type_constant (CPool *, tree, tree);\n-static tree get_tag_node (int);\n-\n-/* Set the INDEX'th constant in CPOOL to have the given TAG and VALUE. */\n-\n-static void\n-set_constant_entry (CPool *cpool, int index, int tag, jword value)\n-{\n-  if (cpool->data == NULL)\n-    {\n-      cpool->capacity = 100;\n-      cpool->tags = ggc_cleared_vec_alloc<uint8> (cpool->capacity);\n-      cpool->data = ggc_cleared_vec_alloc<cpool_entry> (cpool->capacity);\n-      cpool->count = 1;\n-    }\n-  if (index >= cpool->capacity)\n-    {\n-      int old_cap = cpool->capacity;\n-      cpool->capacity *= 2;\n-      if (index >= cpool->capacity)\n-\tcpool->capacity = index + 10;\n-      cpool->tags = GGC_RESIZEVEC (uint8, cpool->tags, cpool->capacity);\n-      cpool->data = GGC_RESIZEVEC (union cpool_entry, cpool->data,\n-\t\t\t\t   cpool->capacity);\n-\n-      /* Make sure GC never sees uninitialized tag values.  */\n-      memset (cpool->tags + old_cap, 0, cpool->capacity - old_cap);\n-      memset (cpool->data + old_cap, 0,\n-\t      (cpool->capacity - old_cap) * sizeof (union cpool_entry));\n-    }\n-  if (index >= cpool->count)\n-    cpool->count = index + 1;\n-  cpool->tags[index] = tag;\n-  cpool->data[index].w = value;\n-}\n-\n-/* Find (or create) a constant pool entry matching TAG and VALUE. */\n-\n-int\n-find_constant1 (CPool *cpool, int tag, jword value)\n-{\n-  int i;\n-  for (i = cpool->count;  --i > 0; )\n-    {\n-      if (cpool->tags[i] == tag && cpool->data[i].w == value)\n-\treturn i;\n-    }\n-  i = cpool->count == 0 ? 1 : cpool->count;\n-  set_constant_entry (cpool, i, tag, value);\n-  return i;\n-}\n-\n-/* Find a double-word constant pool entry matching TAG and WORD1/WORD2. */\n-\n-int\n-find_constant2 (CPool *cpool, int tag, jword word1, jword word2)\n-{\n-  int i;\n-  for (i = cpool->count - 1;  --i > 0; )\n-    {\n-      if (cpool->tags[i] == tag\n-\t  && cpool->data[i].w == word1\n-\t  && cpool->data[i+1].w == word2)\n-\treturn i;\n-    }\n-  i = cpool->count == 0 ? 1 : cpool->count;\n-  set_constant_entry (cpool, i, tag, word1);\n-  set_constant_entry (cpool, i+1, 0, word2);\n-  return i;\n-}\n-\n-static int\n-find_tree_constant (CPool *cpool, int tag, tree value)\n-{\n-  int i;\n-  for (i = cpool->count;  --i > 0; )\n-    {\n-      if (cpool->tags[i] == tag && cpool->data[i].t == value)\n-\treturn i;\n-    }\n-  i = cpool->count == 0 ? 1 : cpool->count;\n-  set_constant_entry (cpool, i, tag, 0);\n-  cpool->data[i].t = value;\n-  return i;\n-}\n-\n-\n-int\n-find_utf8_constant (CPool *cpool, tree name)\n-{\n-  if (name == NULL_TREE)\n-    return 0;\n-  return find_tree_constant (cpool, CONSTANT_Utf8, name);\n-}\n-\n-int\n-find_class_or_string_constant (CPool *cpool, int tag, tree name)\n-{\n-  jword j = find_utf8_constant (cpool, name);\n-  int i;\n-  for (i = cpool->count;  --i > 0; )\n-    {\n-      if (cpool->tags[i] == tag && cpool->data[i].w == j)\n-\treturn i;\n-    }\n-  i = cpool->count;\n-  set_constant_entry (cpool, i, tag, j);\n-  return i;\n-}\n-\n-int\n-find_class_constant (CPool *cpool, tree type)\n-{\n-  return find_class_or_string_constant (cpool, CONSTANT_Class,\n-\t\t\t\t\tbuild_internal_class_name (type));\n-}\n-\n-/* Allocate a CONSTANT_string entry given a STRING_CST. */\n-\n-int\n-find_string_constant (CPool *cpool, tree string)\n-{\n-  string = get_identifier (TREE_STRING_POINTER (string));\n-  return find_class_or_string_constant (cpool, CONSTANT_String, string);\n-\n-}\n-\n-/* Find (or create) a CONSTANT_NameAndType matching NAME and TYPE.\n-   Return its index in the constant pool CPOOL. */\n-\n-static int\n-find_name_and_type_constant (CPool *cpool, tree name, tree type)\n-{\n-  int name_index = find_utf8_constant (cpool, name);\n-  int type_index = find_utf8_constant (cpool, build_java_signature (type));\n-  return find_constant1 (cpool, CONSTANT_NameAndType,\n-\t\t\t (name_index << 16) | type_index);\n-}\n-\n-/* Find (or create) a CONSTANT_Fieldref for DECL (a FIELD_DECL or VAR_DECL).\n-   Return its index in the constant pool CPOOL. */\n-\n-int\n-find_fieldref_index (CPool *cpool, tree decl)\n-{\n-  int class_index = find_class_constant (cpool, DECL_CONTEXT (decl));\n-  int name_type_index\n-    = find_name_and_type_constant (cpool, DECL_NAME (decl), TREE_TYPE (decl));\n-  return find_constant1 (cpool, CONSTANT_Fieldref,\n-\t\t\t (class_index << 16) | name_type_index);\n-}\n-\n-/* Find (or create) a CONSTANT_Methodref for DECL (a FUNCTION_DECL).\n-   Return its index in the constant pool CPOOL. */\n-\n-int\n-find_methodref_index (CPool *cpool, tree decl)\n-{\n-  return find_methodref_with_class_index (cpool, decl, DECL_CONTEXT (decl));\n-}\n-\n-int\n-find_methodref_with_class_index (CPool *cpool, tree decl, tree mclass)\n-{\n-  int class_index = find_class_constant (cpool, mclass);\n-  tree name = DECL_CONSTRUCTOR_P (decl) ? init_identifier_node\n-    : DECL_NAME (decl);\n-  int name_type_index;\n-  name_type_index = \n-      find_name_and_type_constant (cpool, name, TREE_TYPE (decl));\n-  return find_constant1 (cpool,\n-\t\t\t CLASS_INTERFACE (TYPE_NAME (mclass))\n-\t\t\t ? CONSTANT_InterfaceMethodref\n-\t\t\t : CONSTANT_Methodref,\n-\t\t\t (class_index << 16) | name_type_index);\n-}\n-\n-#define PUT1(X)  (*ptr++ = (X))\n-#define PUT2(X)  (PUT1((X) >> 8), PUT1(X))\n-#define PUT4(X)  (PUT2((X) >> 16), PUT2(X))\n-#define PUTN(P, N)  (memcpy(ptr, (P), (N)), ptr += (N))\n-\n-/* Give the number of bytes needed in a .class file for the CPOOL\n-   constant pool.  Includes the 2-byte constant_pool_count. */\n-\n-int\n-count_constant_pool_bytes (CPool *cpool)\n-{\n-  int size = 2;\n-  int i = 1;\n-  for ( ;  i < cpool->count;  i++)\n-    {\n-      size++;\n-      switch (cpool->tags[i])\n-\t{\n-\tcase CONSTANT_NameAndType:\n-\tcase CONSTANT_Fieldref:\n-\tcase CONSTANT_Methodref:\n-\tcase CONSTANT_InterfaceMethodref:\n-\tcase CONSTANT_Float:\n-\tcase CONSTANT_Integer:\n-\t  size += 4;\n-\t  break;\n-\tcase CONSTANT_Class:\n-\tcase CONSTANT_String:\n-\t  size += 2;\n-\t  break;\n-\tcase CONSTANT_Long:\n-\tcase CONSTANT_Double:\n-\t  size += 8;\n-\t  i++;\n-\t  break;\n-\tcase CONSTANT_Utf8:\n-\t  {\n-\t    tree t = cpool->data[i].t;\n-\t    int len = IDENTIFIER_LENGTH (t);\n-\t    size += len + 2;\n-\t  }\n-\t  break;\n-\tdefault:\n-\t  /* Second word of CONSTANT_Long and  CONSTANT_Double. */\n-\t  size--;\n-\t}\n-    }\n-  return size;\n-}\n-\n-/* Write the constant pool CPOOL into BUFFER.\n-   The length of BUFFER is LENGTH, which must match the needed length. */\n-\n-void\n-write_constant_pool (CPool *cpool, unsigned char *buffer, int length)\n-{\n-  unsigned char *ptr = buffer;\n-  int i = 1;\n-  union cpool_entry *datap = &cpool->data[1];\n-  PUT2 (cpool->count);\n-  for ( ;  i < cpool->count;  i++, datap++)\n-    {\n-      int tag = cpool->tags[i];\n-      PUT1 (tag);\n-      switch (tag)\n-\t{\n-\tcase CONSTANT_NameAndType:\n-\tcase CONSTANT_Fieldref:\n-\tcase CONSTANT_Methodref:\n-\tcase CONSTANT_InterfaceMethodref:\n-\tcase CONSTANT_Float:\n-\tcase CONSTANT_Integer:\n-\t  PUT4 (datap->w);\n-\t  break;\n-\tcase CONSTANT_Class:\n-\tcase CONSTANT_String:\n-\t  PUT2 (datap->w);\n-\t  break;\n-\t  break;\n-\tcase CONSTANT_Long:\n-\tcase CONSTANT_Double:\n-\t  PUT4(datap->w);\n-\t  i++;\n-\t  datap++;\n-\t  PUT4 (datap->w);\n-\t  break;\n-\tcase CONSTANT_Utf8:\n-\t  {\n-\t    tree t = datap->t;\n-\t    int len = IDENTIFIER_LENGTH (t);\n-\t    PUT2 (len);\n-\t    PUTN (IDENTIFIER_POINTER (t), len);\n-\t  }\n-\t  break;\n-\t}\n-    }\n-\n-  gcc_assert (ptr == buffer + length);\n-}\n-\n-static GTY(()) tree tag_nodes[13];\n-static tree\n-get_tag_node (int tag)\n-{\n-  /* A Cache for build_int_cst (CONSTANT_XXX, 0). */\n-\n-  if (tag >= 13)\n-    return build_int_cst (NULL_TREE, tag);\n-\n-  if (tag_nodes[tag] == NULL_TREE)\n-    tag_nodes[tag] = build_int_cst (NULL_TREE, tag);\n-  return tag_nodes[tag];\n-}\n-\n-/* Given a class, return its constant pool, creating one if necessary.  */\n-\n-CPool *\n-cpool_for_class (tree klass)\n-{\n-  CPool *cpool = TYPE_CPOOL (klass);\n-\n-  if (cpool == NULL)\n-    {\n-      cpool = ggc_cleared_alloc<CPool> ();\n-      TYPE_CPOOL (klass) = cpool;\n-    }\n-  return cpool;\n-}\n-\n-/* Look for a constant pool entry that matches TAG and NAME.\n-   Creates a new entry if not found.\n-   TAG is one of CONSTANT_Utf8, CONSTANT_String or CONSTANT_Class.\n-   NAME is an IDENTIFIER_NODE naming the Utf8 constant, string, or class.\n-   Returns the index of the entry. */\n-\n-int\n-alloc_name_constant (int tag, tree name)\n-{\n-  CPool *outgoing_cpool = cpool_for_class (output_class);\n-  return find_tree_constant (outgoing_cpool, tag, name);\n-}\n-\n-/* Create a constant pool entry for a name_and_type.  This one has '.'\n-   rather than '/' because it isn't going into a class file, it's\n-   going into a compiled object.  We don't use the '/' separator in\n-   compiled objects.  */\n-\n-static int\n-find_name_and_type_constant_tree (CPool *cpool, tree name, tree type)\n-{\n-  int name_index = find_utf8_constant (cpool, name);\n-  int type_index \n-    = find_utf8_constant (cpool, \n-\t\t\t  identifier_subst (build_java_signature (type), \n-\t\t\t\t\t    \"\", '/', '.', \"\"));\n-  return find_constant1 (cpool, CONSTANT_NameAndType,\n-\t\t\t (name_index << 16) | type_index);\n-}\n-\n-/* Look for a field ref that matches DECL in the constant pool of\n-   KLASS.  \n-   Return the index of the entry.  */\n-\n-int\n-alloc_constant_fieldref (tree klass, tree decl)\n-{\n-  CPool *outgoing_cpool = cpool_for_class (klass);\n-  int class_index \n-    = find_tree_constant (outgoing_cpool, CONSTANT_Class, \n-\t\t\t  DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))));\n-  int name_type_index\n-    = find_name_and_type_constant_tree (outgoing_cpool, DECL_NAME (decl), \n-\t\t\t\t\tTREE_TYPE (decl));\n-  return find_constant1 (outgoing_cpool, CONSTANT_Fieldref,\n-\t\t\t (class_index << 16) | name_type_index);\n-}\n-\n-/* Build an identifier for the internal name of reference type TYPE. */\n-\n-tree\n-build_internal_class_name (tree type)\n-{\n-  tree name;\n-  if (TYPE_ARRAY_P (type))\n-    name = build_java_signature (type);\n-  else\n-    {\n-      name = TYPE_NAME (type);\n-      if (TREE_CODE (name) != IDENTIFIER_NODE)\n-\tname = DECL_NAME (name);\n-      name = identifier_subst (name, \"\", '.', '/', \"\");\n-    }\n-  return name;\n-}\n-\n-/* Look for a CONSTANT_Class entry for CLAS, creating a new one if needed. */\n-\n-int\n-alloc_class_constant (tree clas)\n-{\n-  tree class_name = build_internal_class_name (clas);\n-  \n-  return alloc_name_constant (CONSTANT_Class,\n-\t\t\t      (unmangle_classname \n-\t\t\t       (IDENTIFIER_POINTER(class_name),\n-\t\t\t\tIDENTIFIER_LENGTH(class_name))));\n-}\n-\n-/* Return the decl of the data array of the current constant pool. */\n-\n-tree\n-build_constant_data_ref (bool indirect)\n-{\n-  if (indirect)\n-    {\n-      tree d;\n-      tree cpool_type = build_array_type (ptr_type_node, NULL_TREE);\n-      tree decl = build_class_ref (output_class);\n-      tree klass = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (decl)),\n-\t\t\t   decl);\n-      tree constants = build3 (COMPONENT_REF, \n-\t\t\t       TREE_TYPE (constants_field_decl_node), klass,\n-\t\t\t       constants_field_decl_node,\n-\t\t\t       NULL_TREE);\n-      tree data = build3 (COMPONENT_REF, \n-\t\t\t  TREE_TYPE (constants_data_field_decl_node), \n-\t\t\t  constants,\n-\t\t\t  constants_data_field_decl_node,\n-\t\t\t  NULL_TREE);\n-\n-      TREE_THIS_NOTRAP (klass) = 1;\n-      data = fold_convert (build_pointer_type (cpool_type), data);\n-      d = build1 (INDIRECT_REF, cpool_type, data);\n-\n-      return d;\n-    }\n-  else\n-    {\n-      tree decl_name = mangled_classname (\"_CD_\", output_class);\n-      tree decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n-\n-      if (! decl)\n-\t{\n-\t  /* Build a type with unspecified bounds.  The will make sure\n-\t     that targets do the right thing with whatever size we end\n-\t     up with at the end.  Using bounds that are too small risks\n-\t     assuming the data is in the small data section.  */\n-\t  tree type = build_array_type (ptr_type_node, NULL_TREE);\n-\n-\t  /* We need to lay out the type ourselves, since build_array_type\n-\t     thinks the type is incomplete.  */\n-\t  layout_type (type);\n-\n-\t  decl = build_decl (input_location, VAR_DECL, decl_name, type);\n-\t  TREE_STATIC (decl) = 1;\n-\t  IDENTIFIER_GLOBAL_VALUE (decl_name) = decl;\n-\t}\n-\n-      return decl;\n-    }\n-}\n-\n-/* Get the pointer value at the INDEX'th element of the constant pool. */\n-\n-tree\n-build_ref_from_constant_pool (int index)\n-{\n-  tree i;\n-  tree d = TYPE_CPOOL_DATA_REF (output_class);\n-\n-  if (d == NULL_TREE)\n-    d = build_constant_data_ref (flag_indirect_classes);\n-\n-  i = build_int_cst (NULL_TREE, index);\n-  d = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (d)), d, i,\n-\t\t NULL_TREE, NULL_TREE);\n-  return d;\n-}\n-\n-/* Build an initializer for the constants field of the current constant pool.\n-   Should only be called at top-level, since it may emit declarations. */\n-\n-tree\n-build_constants_constructor (void)\n-{\n-  CPool *outgoing_cpool = cpool_for_class (current_class);\n-  tree tags_value, data_value;\n-  tree cons;\n-  vec<constructor_elt, va_gc> *v = NULL;\n-  int i;\n-  vec<constructor_elt, va_gc> *tags = NULL;\n-  vec<constructor_elt, va_gc> *data = NULL;\n-  constructor_elt *t = NULL;\n-  constructor_elt *d = NULL;\n-\n-  if (outgoing_cpool->count > 0)\n-    {\n-      int c = outgoing_cpool->count;\n-      vec_safe_grow_cleared (tags, c);\n-      vec_safe_grow_cleared (data, c);\n-      t = &(*tags)[c-1];\n-      d = &(*data)[c-1];\n-    }\n-\n-#define CONSTRUCTOR_PREPEND_VALUE(E, V) E->value = V, E--\n-  for (i = outgoing_cpool->count;  --i > 0; )\n-    switch (outgoing_cpool->tags[i] & ~CONSTANT_LazyFlag)\n-      {\n-      case CONSTANT_None:  /* The second half of a Double or Long on a\n-\t\t\t      32-bit target.  */\n-      case CONSTANT_Fieldref:\n-      case CONSTANT_NameAndType:\n-      case CONSTANT_Float:\n-      case CONSTANT_Integer:\n-      case CONSTANT_Double:\n-      case CONSTANT_Long:\n-      case CONSTANT_Methodref:\n-      case CONSTANT_InterfaceMethodref:\n-\t{\n-\t  unsigned HOST_WIDE_INT temp = outgoing_cpool->data[i].w;\n-\n-\t  /* Make sure that on a big-endian machine with 64-bit\n-\t     pointers this 32-bit jint appears in the first word.\n-\t     FIXME: This is a kludge.  The field we're initializing is\n-\t     not a scalar but a union, and that's how we should\n-\t     represent it in the compiler.  We should fix this.  */\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    temp <<= ((POINTER_SIZE > 32) ? POINTER_SIZE - 32 : 0);\n-\n-          CONSTRUCTOR_PREPEND_VALUE (t, get_tag_node (outgoing_cpool->tags[i]));\n-          CONSTRUCTOR_PREPEND_VALUE (d, build_int_cst (ptr_type_node, temp));\n-\t}\n-\tbreak;\n-\n-      case CONSTANT_Class:\n-      case CONSTANT_String:\n-      case CONSTANT_Unicode:\n-      case CONSTANT_Utf8:\n-        CONSTRUCTOR_PREPEND_VALUE (t, get_tag_node (outgoing_cpool->tags[i]));\n-        CONSTRUCTOR_PREPEND_VALUE (d, build_utf8_ref (outgoing_cpool->data[i].t));\n-\tbreak;\n-\n-      default:\n-\tgcc_assert (false);\n-      }\n-#undef CONSTRUCTOR_PREPEND_VALUE\n-\n-  if (outgoing_cpool->count > 0)\n-    {\n-      tree data_decl, tags_decl, tags_type;\n-      tree max_index = build_int_cst (sizetype, outgoing_cpool->count - 1);\n-      tree index_type = build_index_type (max_index);\n-      tree tem;\n-\n-      /* Add dummy 0'th element of constant pool. */\n-      gcc_assert (t == tags->address ());\n-      gcc_assert (d == data->address ());\n-      t->value = get_tag_node (0);\n-      d->value = null_pointer_node;\n-  \n-      /* Change the type of the decl to have the proper array size.\n-         ???  Make sure to transition the old type-pointer-to list to this\n-\t new type to not invalidate all build address expressions.  */\n-      data_decl = build_constant_data_ref (false);\n-      tem = TYPE_POINTER_TO (TREE_TYPE (data_decl));\n-      if (!tem)\n-\ttem = build_pointer_type (TREE_TYPE (data_decl));\n-      TYPE_POINTER_TO (TREE_TYPE (data_decl)) = NULL_TREE;\n-      TREE_TYPE (data_decl) = build_array_type (ptr_type_node, index_type);\n-      TYPE_POINTER_TO (TREE_TYPE (data_decl)) = tem;\n-      DECL_INITIAL (data_decl) = build_constructor (TREE_TYPE (data_decl), data);\n-      DECL_SIZE (data_decl) = TYPE_SIZE (TREE_TYPE (data_decl));\n-      DECL_SIZE_UNIT (data_decl) = TYPE_SIZE_UNIT (TREE_TYPE (data_decl));\n-      rest_of_decl_compilation (data_decl, 1, 0);\n-      data_value = build_address_of (data_decl);\n-\n-      tags_type = build_array_type (unsigned_byte_type_node, index_type);\n-      tags_decl = build_decl (input_location, \n-      \t\t\t      VAR_DECL, mangled_classname (\"_CT_\", \n-\t\t\t\t\t\t\t   current_class),\n-\t\t\t      tags_type);\n-      TREE_STATIC (tags_decl) = 1;\n-      DECL_INITIAL (tags_decl) = build_constructor (tags_type, tags);\n-      rest_of_decl_compilation (tags_decl, 1, 0);\n-      tags_value = build_address_of (tags_decl);\n-    }\n-  else\n-    {\n-      data_value = null_pointer_node;\n-      tags_value = null_pointer_node;\n-    }\n-  START_RECORD_CONSTRUCTOR (v, constants_type_node);\n-  PUSH_FIELD_VALUE (v, \"size\",\n-\t\t    build_int_cst (NULL_TREE, outgoing_cpool->count));\n-  PUSH_FIELD_VALUE (v, \"tags\", tags_value);\n-  PUSH_FIELD_VALUE (v, \"data\", data_value);\n-  FINISH_RECORD_CONSTRUCTOR (cons, v, constants_type_node);\n-  return cons;\n-}\n-\n-#include \"gt-java-constants.h\""}, {"sha": "70eac31511373398935b6afbdc4b162f7671f1eb", "filename": "gcc/java/decl.c", "status": "removed", "additions": 0, "deletions": 2065, "changes": 2065, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,2065 +0,0 @@\n-/* Process declarations and variables for the GNU compiler for the\n-   Java(TM) language.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"function.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"diagnostic-core.h\"\n-#include \"stor-layout.h\"\n-#include \"varasm.h\"\n-#include \"toplev.h\"\n-#include \"java-tree.h\"\n-#include \"jcf.h\"\n-#include \"java-except.h\"\n-#include \"version.h\"\n-#include \"tree-iterator.h\"\n-#include \"langhooks.h\"\n-\n-#if defined (DEBUG_JAVA_BINDING_LEVELS)\n-extern void indent (void);\n-#endif\n-\n-static tree push_jvm_slot (int, tree);\n-static tree lookup_name_current_level (tree);\n-static tree push_promoted_type (const char *, tree);\n-static struct binding_level *make_binding_level (void);\n-static tree create_primitive_vtable (const char *);\n-static tree check_local_unnamed_variable (tree, tree, tree);\n-static void parse_version (void);\n-\n-\n-/* The following ABI flags are used in the high-order bits of the version\n-   ID field. The version ID number itself should never be larger than \n-   0xfffff, so it should be safe to use top 12 bits for these flags. */\n-\n-#define FLAG_BINARYCOMPAT_ABI (1<<31)  /* Class is built with the BC-ABI. */\n-\n-#define FLAG_BOOTSTRAP_LOADER (1<<30)  /* Used when defining a class that \n-\t\t\t\t\t  should be loaded by the bootstrap\n-\t\t\t\t\t  loader.  */\n-\n-/* If an ABI change is made within a GCC release series, rendering current\n-   binaries incompatible with the old runtimes, this number must be set to\n-   enforce the compatibility rules. */\n-#define MINOR_BINARYCOMPAT_ABI_VERSION 1\n-\n-/* The runtime may recognize a variety of BC ABIs (objects generated by \n-   different version of gcj), but will probably always require strict \n-   matching for the ordinary (C++) ABI.  */\n-\n-/* The version ID of the BC ABI that we generate.  This must be kept in\n-   sync with parse_version(), libgcj, and reality (if the BC format changes, \n-   this must change).  */\n-#define GCJ_CURRENT_BC_ABI_VERSION \\\n-  (4 * 100000 + 0 * 1000 + MINOR_BINARYCOMPAT_ABI_VERSION)\n-\n-/* The ABI version number.  */\n-tree gcj_abi_version;\n-\n-/* Name of the Cloneable class.  */\n-tree java_lang_cloneable_identifier_node;\n-\n-/* Name of the Serializable class.  */\n-tree java_io_serializable_identifier_node;\n-\n-/* The DECL_MAP is a mapping from (index, type) to a decl node.\n-   If index < max_locals, it is the index of a local variable.\n-   if index >= max_locals, then index-max_locals is a stack slot.\n-   The DECL_MAP mapping is represented as a TREE_VEC whose elements\n-   are a list of decls (VAR_DECL or PARM_DECL) chained by\n-   DECL_LOCAL_SLOT_CHAIN; the index finds the TREE_VEC element, and then\n-   we search the chain for a decl with a matching TREE_TYPE. */\n-\n-static GTY(()) tree decl_map;\n-\n-/* The base_decl_map is contains one variable of ptr_type: this is\n-   used to contain every variable of reference type that is ever\n-   stored in a local variable slot.  */\n-\n-static GTY(()) tree base_decl_map;\n-\n-/* An index used to make temporary identifiers unique.  */\n-static int uniq;\n-\n-/* A list of local variables VAR_DECLs for this method that we have seen\n-   debug information, but we have not reached their starting (byte) PC yet. */\n-\n-static GTY(()) tree pending_local_decls;\n-\n-/* The decl for \"_Jv_ResolvePoolEntry\".  */\n-tree soft_resolvepoolentry_node;\n-\n-/* The decl for the .constants field of an instance of Class.  */\n-tree constants_field_decl_node;\n-\n-/* The decl for the .data field of an instance of Class.  */\n-tree constants_data_field_decl_node;\n-\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-int binding_depth = 0;\n-int is_class_level = 0;\n-int current_pc;\n-\n-void\n-indent (void)\n-{\n-  int i;\n-\n-  for (i = 0; i < binding_depth*2; i++)\n-    putc (' ', stderr);\n-}\n-#endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n-\n-/* True if decl is a named local variable, i.e. if it is an alias\n-   that's used only for debugging purposes.  */\n-\n-static bool\n-debug_variable_p (tree decl)\n-{\n-  if (TREE_CODE (decl) == PARM_DECL)\n-    return false;\n-\n-  if (LOCAL_SLOT_P (decl))\n-    return false;\n-\n-  return true;\n-}\n- \n-static tree\n-push_jvm_slot (int index, tree decl)\n-{\n-  DECL_CONTEXT (decl) = current_function_decl;\n-  layout_decl (decl, 0);\n-\n-  /* Now link the decl into the decl_map. */\n-  if (DECL_LANG_SPECIFIC (decl) == NULL)\n-    {\n-      MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n-      DECL_LOCAL_START_PC (decl) = 0;\n-      DECL_LOCAL_END_PC (decl) = DECL_CODE_LENGTH (current_function_decl);\n-      DECL_LOCAL_SLOT_NUMBER (decl) = index;\n-    }\n-  DECL_LOCAL_SLOT_CHAIN (decl) = TREE_VEC_ELT (decl_map, index);\n-  TREE_VEC_ELT (decl_map, index) = decl;\n-\n-  return decl;\n-}\n-\n-/* Find the best declaration based upon type.  If 'decl' fits 'type' better\n-   than 'best', return 'decl'.  Otherwise return 'best'.  */\n-\n-static tree\n-check_local_unnamed_variable (tree best, tree decl, tree type)\n-{\n-  tree decl_type = TREE_TYPE (decl);\n-  \n-  gcc_assert (! LOCAL_VAR_OUT_OF_SCOPE_P (decl));\n-\n-  /* Use the same decl for all integer types <= 32 bits.  This is\n-     necessary because sometimes a value is stored as (for example)\n-     boolean but loaded as int.  */\n-  if (decl_type == type\n-      || (INTEGRAL_TYPE_P (decl_type)\n-\t  && INTEGRAL_TYPE_P (type)\n-\t  && TYPE_PRECISION (decl_type) <= 32\n-\t  && TYPE_PRECISION (type) <= 32\n-\t  && TYPE_PRECISION (decl_type) >= TYPE_PRECISION (type))      \n-      /*  ptr_type_node is used for null pointers, which are\n-\t  assignment compatible with everything.  */\n-      || (TREE_CODE (decl_type) == POINTER_TYPE\n-\t  && type == ptr_type_node)\n-      /* Whenever anyone wants to use a slot that is initially\n-\t occupied by a PARM_DECL of pointer type they must get that\n-\t decl, even if they asked for a pointer to a different type.\n-\t However, if someone wants a scalar variable in a slot that\n-\t initially held a pointer arg -- or vice versa -- we create a\n-\t new VAR_DECL.  \n-\n-      \t ???: As long as verification is correct, this will be a\n-\t compatible type.  But maybe we should create a dummy variable\n-\t and replace all references to it with the DECL and a\n-\t NOP_EXPR.  \n-      */\n-      || (TREE_CODE (decl_type) == POINTER_TYPE\n-\t  && TREE_CODE (decl) == PARM_DECL\n-\t  && TREE_CODE (type) == POINTER_TYPE))\n-    {\n-      if (best == NULL_TREE\n-\t  || (decl_type == type && TREE_TYPE (best) != type))\n-\treturn decl;\n-    }\n-\n-  return best;\n-}\n-\n-\n-/* Find a VAR_DECL (or PARM_DECL) at local index INDEX that has type TYPE,\n-   that is valid at PC (or -1 if any pc).\n-   If there is no existing matching decl, allocate one.  */\n-\n-tree\n-find_local_variable (int index, tree type, int pc ATTRIBUTE_UNUSED)\n-{\n-  tree tmp = TREE_VEC_ELT (decl_map, index);\n-  tree decl = NULL_TREE;\n-\n-  /* Scan through every declaration that has been created in this\n-     slot.  We're only looking for variables that correspond to local\n-     index declarations and PARM_DECLs, not named variables: such\n-     local variables are used only for debugging information.  */\n-  while (tmp != NULL_TREE)\n-    {\n-      if (! debug_variable_p (tmp))\n-\tdecl = check_local_unnamed_variable (decl, tmp, type);\n-      tmp = DECL_LOCAL_SLOT_CHAIN (tmp);\n-    }\n-\n-  /* gcj has a function called promote_type(), which is used by both\n-     the bytecode compiler and the source compiler.  Unfortunately,\n-     the type systems for the Java VM and the Java language are not\n-     the same: a boolean in the VM promotes to an int, not to a wide\n-     boolean.  If our caller wants something to hold a boolean, that\n-     had better be an int, because that slot might be re-used\n-     later in integer context.  */\n-  if (TREE_CODE (type) == BOOLEAN_TYPE)\n-    type = integer_type_node;\n-\n-  /* If we don't find a match, create one with the type passed in.\n-     The name of the variable is #n#m, which n is the variable index\n-     in the local variable area and m is a dummy identifier for\n-     uniqueness -- multiple variables may share the same local\n-     variable index.  We don't call pushdecl() to push pointer types\n-     into a binding expr because they'll all be replaced by a single\n-     variable that is used for every reference in that local variable\n-     slot.  */\n-  if (! decl)\n-    {\n-      char buf[64];\n-      tree name;\n-      sprintf (buf, \"#slot#%d#%d\", index, uniq++);\n-      name = get_identifier (buf);\n-      decl = build_decl (input_location, VAR_DECL, name, type);\n-      DECL_IGNORED_P (decl) = 1;\n-      DECL_ARTIFICIAL (decl) = 1;\n-      decl = push_jvm_slot (index, decl);\n-      LOCAL_SLOT_P (decl) = 1;\n-\n-      if (TREE_CODE (type) != POINTER_TYPE)\n-\tpushdecl_function_level (decl);\n-    }\n-\n-  /* As well as creating a local variable that matches the type, we\n-     also create a base variable (of ptr_type) that will hold all its\n-     aliases.  */\n-  if (TREE_CODE (type) == POINTER_TYPE\n-      && ! TREE_VEC_ELT (base_decl_map, index))\n-    {\n-      char buf[64];\n-      tree name;\n-      tree base_decl;\n-      sprintf (buf, \"#ref#%d#%d\", index, uniq++);\n-      name = get_identifier (buf);\n-      base_decl\n-\t= TREE_VEC_ELT (base_decl_map, index)\n-\t= build_decl (input_location, VAR_DECL, name, ptr_type_node);\n-      pushdecl_function_level (base_decl);\n-      DECL_IGNORED_P (base_decl) = 1;\n-      DECL_ARTIFICIAL (base_decl) = 1;\n-    }\n-\n-  return decl;\n-}\n-\n-/* Called during genericization for every variable.  If the variable\n-   is a temporary of pointer type, replace it with a common variable\n-   thath is used to hold all pointer types that are ever stored in\n-   that slot.  Set WANT_LVALUE if you want a variable that is to be\n-   written to.  */\n-\n-static tree \n-java_replace_reference (tree var_decl, bool want_lvalue)\n-{\n-  tree decl_type;\n-\n-  if (! base_decl_map)\n-    return var_decl;\n-\n-  decl_type = TREE_TYPE (var_decl);\n-\n-  if (TREE_CODE (decl_type) == POINTER_TYPE)\n-    {\n-      if (DECL_LANG_SPECIFIC (var_decl)\n-\t  && LOCAL_SLOT_P (var_decl))\n-\t{\n-\t  int index = DECL_LOCAL_SLOT_NUMBER (var_decl);\n-\t  tree base_decl = TREE_VEC_ELT (base_decl_map, index); \n-\n-\t  gcc_assert (base_decl);\n-\t  if (! want_lvalue)\n-\t    base_decl = build1 (NOP_EXPR, decl_type, base_decl);\n-\n-\t  return base_decl;\n-\t}\n-    }\n-\n-  return var_decl;\n-}\n-\n-/* Helper for java_genericize.  */\n-\n-tree\n-java_replace_references (tree *tp, int *walk_subtrees,\n-\t\t\t void *data ATTRIBUTE_UNUSED)\n-{\n-  if (TREE_CODE (*tp) == MODIFY_EXPR)\n-    {\n-      source_location loc = EXPR_LOCATION (*tp);\n-      tree lhs = TREE_OPERAND (*tp, 0);\n-      /* This is specific to the bytecode compiler.  If a variable has\n-\t LOCAL_SLOT_P set, replace an assignment to it with an assignment\n-\t to the corresponding variable that holds all its aliases.  */\n-      if (TREE_CODE (lhs) == VAR_DECL\n-\t  && DECL_LANG_SPECIFIC (lhs)\n-\t  && LOCAL_SLOT_P (lhs)\n-\t  && TREE_CODE (TREE_TYPE (lhs)) == POINTER_TYPE)\n-\t{\n-\t  tree new_lhs = java_replace_reference (lhs, /* want_lvalue */ true);\n-\t  tree new_rhs = build1 (NOP_EXPR, TREE_TYPE (new_lhs),\n-\t\t\t\t TREE_OPERAND (*tp, 1));\n-\t  tree tem = build2 (MODIFY_EXPR, TREE_TYPE (new_lhs),\n-\t\t\t     new_lhs, new_rhs);\n-\t  *tp = build1 (NOP_EXPR, TREE_TYPE (lhs), tem);\n-\t  SET_EXPR_LOCATION (tem, loc);\n-\t  SET_EXPR_LOCATION (new_rhs, loc);\n-\t  SET_EXPR_LOCATION (*tp, loc);\n-\t}\n-    }\n-  if (TREE_CODE (*tp) == VAR_DECL)\n-    {\n-      *tp = java_replace_reference (*tp, /* want_lvalue */ false);\n-      *walk_subtrees = 0;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Same as find_local_index, except that INDEX is a stack index. */\n-\n-tree\n-find_stack_slot (int index, tree type)\n-{\n-  return find_local_variable (index + DECL_MAX_LOCALS (current_function_decl),\n-\t\t\t      type, -1);\n-}\n-\n-struct GTY(())\n-  binding_level {\n-    /* A chain of _DECL nodes for all variables, constants, functions,\n-     * and typedef types.  These are in the reverse of the order supplied.\n-     */\n-    tree names;\n-\n-    /* For each level, a list of shadowed outer-level local definitions\n-       to be restored when this level is popped.\n-       Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n-       whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */\n-    tree shadowed;\n-\n-    /* For each level (except not the global one),\n-       a chain of BLOCK nodes for all the levels\n-       that were entered and exited one level down.  */\n-    tree blocks;\n-\n-    /* The binding level which this one is contained in (inherits from).  */\n-    struct binding_level *level_chain;\n-\n-    /* The bytecode PC that marks the end of this level. */\n-    int end_pc;\n-    /* The bytecode PC that marks the start of this level. */\n-    int start_pc;\n-\n-    /* The statements in this binding level.  */\n-    tree stmts;\n-\n-    /* An exception range associated with this binding level.  */\n-    struct eh_range * GTY((skip (\"\"))) exception_range;\n-\n-    /* Binding depth at which this level began.  Used only for debugging.  */\n-    unsigned binding_depth;\n-\n-    /* The location at which this level began.  */\n-    source_location loc;\n-  };\n-\n-#define NULL_BINDING_LEVEL (struct binding_level *) NULL\n-\n-/* The binding level currently in effect.  */\n-\n-static GTY(()) struct binding_level *current_binding_level;\n-\n-/* A chain of binding_level structures awaiting reuse.  */\n-\n-static GTY(()) struct binding_level *free_binding_level;\n-\n-/* The outermost binding level, for names of file scope.\n-   This is created when the compiler is started and exists\n-   through the entire run.  */\n-\n-static GTY(()) struct binding_level *global_binding_level;\n-\n-/* The binding level that holds variables declared at the outermost\n-   level within a function body.  */\n-\n-static struct binding_level *function_binding_level;\n-\n-/* A PC value bigger than any PC value we may ever may encounter. */\n-\n-#define LARGEST_PC (( (unsigned int)1 << (HOST_BITS_PER_INT - 1)) - 1)\n-\n-/* Binding level structures are initialized by copying this one.  */\n-\n-static const struct binding_level clear_binding_level\n-= {\n-    NULL_TREE, /* names */\n-    NULL_TREE, /* shadowed */\n-    NULL_TREE, /* blocks */\n-    NULL_BINDING_LEVEL, /* level_chain */\n-    LARGEST_PC, /* end_pc */\n-    0, /* start_pc */\n-    NULL, /* stmts */\n-    NULL, /* exception_range */\n-    0, /* binding_depth */\n-    0, /* loc */\n-  };\n-\n-tree java_global_trees[JTI_MAX];\n-\n-/* Build (and pushdecl) a \"promoted type\" for all standard\n-   types shorter than int.  */\n-\n-static tree\n-push_promoted_type (const char *name, tree actual_type)\n-{\n-  tree type = make_node (TREE_CODE (actual_type));\n-#if 1\n-  tree in_min = TYPE_MIN_VALUE (int_type_node);\n-  tree in_max = TYPE_MAX_VALUE (int_type_node);\n-#else\n-  tree in_min = TYPE_MIN_VALUE (actual_type);\n-  tree in_max = TYPE_MAX_VALUE (actual_type);\n-#endif\n-  TYPE_MIN_VALUE (type) = copy_node (in_min);\n-  TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n-  TYPE_MAX_VALUE (type) = copy_node (in_max);\n-  TREE_TYPE (TYPE_MAX_VALUE (type)) = type;\n-  TYPE_PRECISION (type) = TYPE_PRECISION (int_type_node);\n-  TYPE_STRING_FLAG (type) = TYPE_STRING_FLAG (actual_type);\n-  layout_type (type);\n-  pushdecl (build_decl (input_location,\n-\t\t\tTYPE_DECL, get_identifier (name), type));\n-  return type;\n-}\n-\n-/* Return tree that represents a vtable for a primitive array.  */\n-static tree\n-create_primitive_vtable (const char *name)\n-{\n-  tree r;\n-  char buf[50];\n-\n-  sprintf (buf, \"_Jv_%sVTable\", name);\n-  r = build_decl (input_location,\n-\t\t  VAR_DECL, get_identifier (buf), ptr_type_node);\n-  DECL_EXTERNAL (r) = 1;\n-  return r;\n-}\n-\n-/* Parse the version string and compute the ABI version number.  */\n-static void\n-parse_version (void)\n-{\n-  const char *p = version_string;\n-  unsigned int major = 0;\n-  unsigned int abi_version;\n-\n-  /* Skip leading junk.  */\n-  while (*p && !ISDIGIT (*p))\n-    ++p;\n-  gcc_assert (*p);\n-\n-  /* Extract major version.  */\n-  while (ISDIGIT (*p))\n-    {\n-      major = major * 10 + *p - '0';\n-      ++p;\n-    }\n-\n-  gcc_assert (*p == '.' && ISDIGIT (p[1]));\n-  ++p;\n-\n-  if (flag_indirect_dispatch)\n-    {\n-      abi_version = GCJ_CURRENT_BC_ABI_VERSION;\n-      abi_version |= FLAG_BINARYCOMPAT_ABI;\n-    }\n-  else /* C++ ABI */\n-    {\n-      /* Implicit in this computation is the idea that we won't break the\n-\t old-style binary ABI in a minor release (e.g., from 6.1.0 to\n-\t 6.2.0).  */\n-      abi_version = 100000 * major;\n-    }\n-  if (flag_bootstrap_classes)\n-    abi_version |= FLAG_BOOTSTRAP_LOADER;\n-\n-  gcj_abi_version = build_int_cstu (ptr_type_node, abi_version);\n-}\n-\n-void\n-java_init_decl_processing (void)\n-{\n-  tree field = NULL_TREE;\n-  tree t;\n-\n-  init_class_processing ();\n-\n-  current_function_decl = NULL;\n-  current_binding_level = NULL_BINDING_LEVEL;\n-  free_binding_level = NULL_BINDING_LEVEL;\n-  pushlevel (0);\t/* make the binding_level structure for global names */\n-  global_binding_level = current_binding_level;\n-\n-  /* Build common tree nodes, Java has an unsigned char.  */\n-  build_common_tree_nodes (false);\n-\n-  /* ???  Now we continue and override some of the built types again\n-     with Java specific types.  As the above generated types are\n-     supposed to match the targets C ABI this isn't really the way\n-     to go and any Java specifics should _not_ use those global types\n-     if the Java ABI does not match the C one.  */\n-\n-  byte_type_node = make_signed_type (8);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"byte\"), byte_type_node));\n-  short_type_node = make_signed_type (16);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"short\"), short_type_node));\n-  int_type_node = make_signed_type (32);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"int\"), int_type_node));\n-  long_type_node = make_signed_type (64);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"long\"), long_type_node));\n-\n-  unsigned_byte_type_node = make_unsigned_type (8);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"unsigned byte\"),\n-\t\t\tunsigned_byte_type_node));\n-  unsigned_short_type_node = make_unsigned_type (16);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"unsigned short\"),\n-\t\t\tunsigned_short_type_node));\n-  unsigned_int_type_node = make_unsigned_type (32);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"unsigned int\"),\n-\t\t\tunsigned_int_type_node));\n-  unsigned_long_type_node = make_unsigned_type (64);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"unsigned long\"),\n-\t\t\tunsigned_long_type_node));\n-\n-  /* Define these next since types below may used them.  */\n-  integer_type_node = java_type_for_size (INT_TYPE_SIZE, 0);\n-  integer_zero_node = build_int_cst (NULL_TREE, 0);\n-  integer_one_node = build_int_cst (NULL_TREE, 1);\n-  integer_two_node = build_int_cst (NULL_TREE, 2);\n-  integer_three_node = build_int_cst (NULL_TREE, 3);\n-  integer_four_node = build_int_cst (NULL_TREE, 4);\n-  integer_minus_one_node = build_int_cst (NULL_TREE, -1);\n-\n-  /* A few values used for range checking in the lexer.  */\n-  decimal_int_max = build_int_cstu (unsigned_int_type_node, 0x80000000);\n-  decimal_long_max\n-    = double_int_to_tree (unsigned_long_type_node,\n-\t\t\t  double_int_zero.set_bit (64));\n-\n-  long_zero_node = build_int_cst (long_type_node, 0);\n-\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"void\"), void_type_node));\n-\n-  t = make_node (VOID_TYPE);\n-  layout_type (t); /* Uses size_zero_node */\n-  return_address_type_node = build_pointer_type (t);\n-\n-  char_type_node = make_unsigned_type (16);\n-  TYPE_STRING_FLAG (char_type_node) = 1;\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"char\"), char_type_node));\n-\n-  boolean_type_node = make_unsigned_type (1);\n-  TREE_SET_CODE (boolean_type_node, BOOLEAN_TYPE);\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"boolean\"),\n-\t\t\tboolean_type_node));\n-  boolean_false_node = TYPE_MIN_VALUE (boolean_type_node);\n-  boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n-\n-  promoted_byte_type_node\n-    = push_promoted_type (\"promoted_byte\", byte_type_node);\n-  promoted_short_type_node\n-    = push_promoted_type (\"promoted_short\", short_type_node);\n-  promoted_char_type_node\n-    = push_promoted_type (\"promoted_char\", char_type_node);\n-  promoted_boolean_type_node\n-    = push_promoted_type (\"promoted_boolean\", boolean_type_node);\n-\n-  float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (float_type_node) = 32;\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"float\"),\n-                        float_type_node));\n-  layout_type (float_type_node);\n-\n-  double_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (double_type_node) = 64;\n-  pushdecl (build_decl (BUILTINS_LOCATION,\n-\t\t\tTYPE_DECL, get_identifier (\"double\"),\n-                        double_type_node));\n-  layout_type (double_type_node);\n-\n-  float_zero_node = build_real (float_type_node, dconst0);\n-  double_zero_node = build_real (double_type_node, dconst0);\n-\n-  /* These are the vtables for arrays of primitives.  */\n-  boolean_array_vtable = create_primitive_vtable (\"boolean\");\n-  byte_array_vtable = create_primitive_vtable (\"byte\");\n-  char_array_vtable = create_primitive_vtable (\"char\");\n-  short_array_vtable = create_primitive_vtable (\"short\");\n-  int_array_vtable = create_primitive_vtable (\"int\");\n-  long_array_vtable = create_primitive_vtable (\"long\");\n-  float_array_vtable = create_primitive_vtable (\"float\");\n-  double_array_vtable = create_primitive_vtable (\"double\");\n-\n-  one_elt_array_domain_type = build_index_type (integer_one_node);\n-  utf8const_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      utf8const_type, field, \"hash\", unsigned_short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      utf8const_type, field, \"length\", unsigned_short_type_node);\n-  FINISH_RECORD (utf8const_type);\n-  utf8const_ptr_type = build_pointer_type (utf8const_type);\n-\n-  atable_type = build_array_type (ptr_type_node, \n-\t\t\t\t  one_elt_array_domain_type);\n-  TYPE_NONALIASED_COMPONENT (atable_type) = 1;\n-  atable_ptr_type = build_pointer_type (atable_type);\n-\n-  itable_type = build_array_type (ptr_type_node, \n-\t\t\t\t  one_elt_array_domain_type);\n-  TYPE_NONALIASED_COMPONENT (itable_type) = 1;\n-  itable_ptr_type = build_pointer_type (itable_type);\n-\n-  symbol_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      symbol_type, field, \"clname\", utf8const_ptr_type);\n-  PUSH_FIELD (input_location, symbol_type, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      symbol_type, field, \"signature\", utf8const_ptr_type);\n-  FINISH_RECORD (symbol_type);\n-\n-  symbols_array_type = build_array_type (symbol_type, \n-\t\t\t\t\t one_elt_array_domain_type);\n-  symbols_array_ptr_type = build_pointer_type (symbols_array_type);\n-\n-  assertion_entry_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      assertion_entry_type, field, \"assertion_code\", integer_type_node);\n-  PUSH_FIELD (input_location,\n-\t      assertion_entry_type, field, \"op1\", utf8const_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      assertion_entry_type, field, \"op2\", utf8const_ptr_type);\n-  FINISH_RECORD (assertion_entry_type);\n-  \n-  assertion_table_type = build_array_type (assertion_entry_type,\n-                                           one_elt_array_domain_type);\n-\n-  /* As you're adding items here, please update the code right after\n-     this section, so that the filename containing the source code of\n-     the pre-defined class gets registered correctly. */\n-  unqualified_object_id_node = get_identifier (\"Object\");\n-  object_type_node = lookup_class (get_identifier (\"java.lang.Object\"));\n-  object_ptr_type_node = promote_type (object_type_node);\n-  string_type_node = lookup_class (get_identifier (\"java.lang.String\"));\n-  string_ptr_type_node = promote_type (string_type_node);\n-  class_type_node = lookup_class (get_identifier (\"java.lang.Class\"));\n-  throwable_type_node = lookup_class (get_identifier (\"java.lang.Throwable\"));\n-  exception_type_node = lookup_class (get_identifier (\"java.lang.Exception\"));\n-  runtime_exception_type_node = \n-    lookup_class (get_identifier (\"java.lang.RuntimeException\"));\n-  error_exception_type_node = \n-    lookup_class (get_identifier (\"java.lang.Error\"));\n-\n-  rawdata_ptr_type_node\n-    = promote_type (lookup_class (get_identifier (\"gnu.gcj.RawData\")));\n-\n-  add_predefined_file (get_identifier (\"java/lang/Class.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/Error.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/Object.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/RuntimeException.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/String.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/Throwable.java\"));\n-  add_predefined_file (get_identifier (\"gnu/gcj/RawData.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/Exception.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/ClassNotFoundException.java\"));\n-  add_predefined_file (get_identifier (\"java/lang/NoClassDefFoundError.java\"));\n-\n-  methodtable_type = make_node (RECORD_TYPE);\n-  layout_type (methodtable_type);\n-  build_decl (BUILTINS_LOCATION,\n-\t      TYPE_DECL, get_identifier (\"methodtable\"), methodtable_type);\n-  methodtable_ptr_type = build_pointer_type (methodtable_type);\n-\n-  TYPE_identifier_node = get_identifier (\"TYPE\");\n-  init_identifier_node = get_identifier (\"<init>\");\n-  clinit_identifier_node = get_identifier (\"<clinit>\");\n-  void_signature_node = get_identifier (\"()V\");\n-  finalize_identifier_node = get_identifier (\"finalize\");\n-  this_identifier_node = get_identifier (\"this\");\n-\n-  java_lang_cloneable_identifier_node = get_identifier (\"java.lang.Cloneable\");\n-  java_io_serializable_identifier_node =\n-    get_identifier (\"java.io.Serializable\");\n-\n-  /* for lack of a better place to put this stub call */\n-  init_expr_processing();\n-\n-  constants_type_node = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      constants_type_node, field, \"size\", unsigned_int_type_node);\n-  PUSH_FIELD (input_location,\n-\t      constants_type_node, field, \"tags\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      constants_type_node, field, \"data\", ptr_type_node);\n-  constants_data_field_decl_node = field;\n-  FINISH_RECORD (constants_type_node);\n-  build_decl (BUILTINS_LOCATION,\n-\t      TYPE_DECL, get_identifier (\"constants\"), constants_type_node);\n-\n-  access_flags_type_node = unsigned_short_type_node;\n-\n-  dtable_type = make_node (RECORD_TYPE);\n-  dtable_ptr_type = build_pointer_type (dtable_type);\n-\n-  otable_type = build_array_type (integer_type_node, \n-\t\t\t\t  one_elt_array_domain_type);\n-  TYPE_NONALIASED_COMPONENT (otable_type) = 1;\n-  otable_ptr_type = build_pointer_type (otable_type);\n-\n-  PUSH_FIELD (input_location,\n-\t      object_type_node, field, \"vtable\", dtable_ptr_type);\n-  DECL_FCONTEXT (field) = object_type_node;\n-  TYPE_VFIELD (object_type_node) = field;\n-\n-  /* This isn't exactly true, but it is what we have in the source.\n-     There is an unresolved issue here, which is whether the vtable\n-     should be marked by the GC.  */\n-  if (! flag_hash_synchronization)\n-    PUSH_FIELD (input_location, object_type_node, field, \"sync_info\",\n-\t\tbuild_pointer_type (object_type_node));\n-  for (t = TYPE_FIELDS (object_type_node); t != NULL_TREE; t = DECL_CHAIN (t))\n-    FIELD_PRIVATE (t) = 1;\n-  FINISH_RECORD (object_type_node);\n-\n-  field_type_node = make_node (RECORD_TYPE);\n-  field_ptr_type_node = build_pointer_type (field_type_node);\n-  method_type_node = make_node (RECORD_TYPE);\n-  method_ptr_type_node = build_pointer_type (method_type_node);\n-\n-  set_super_info (0, class_type_node, object_type_node, 0);\n-  set_super_info (0, string_type_node, object_type_node, 0);\n-  class_ptr_type = build_pointer_type (class_type_node);\n-\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"next_or_version\", class_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"accflags\", access_flags_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"superclass\", class_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"constants\", constants_type_node);\n-  constants_field_decl_node = field;\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"methods\", method_ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"method_count\", short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"vtable_method_count\", short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"fields\", field_ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"size_in_bytes\", int_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"field_count\", short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"static_field_count\", short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"vtable\", dtable_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"otable\", otable_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"otable_syms\", \n-  \t      symbols_array_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"atable\", atable_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"atable_syms\", \n-  \t      symbols_array_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"itable\", itable_ptr_type);\n-  PUSH_FIELD (input_location, class_type_node, field, \"itable_syms\", \n-  \t      symbols_array_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"catch_classes\", ptr_type_node);\n-  PUSH_FIELD (input_location, class_type_node, field, \"interfaces\",\n-\t      build_pointer_type (class_ptr_type));\n-  PUSH_FIELD (input_location, class_type_node, field, \"loader\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"interface_count\", short_type_node);\n-  PUSH_FIELD (input_location, class_type_node, field, \"state\", byte_type_node);\n-  PUSH_FIELD (input_location, class_type_node, field, \"thread\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"depth\", short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"ancestors\", ptr_type_node);\n-  PUSH_FIELD (input_location, class_type_node, field, \"idt\", ptr_type_node);  \n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"arrayclass\", ptr_type_node);  \n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"protectionDomain\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"assertion_table\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"hack_signers\", ptr_type_node);\n-  PUSH_FIELD (input_location, class_type_node, field, \"chain\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"aux_info\", ptr_type_node);\n-  PUSH_FIELD (input_location, class_type_node, field, \"engine\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      class_type_node, field, \"reflection_data\", ptr_type_node);\n-  for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = DECL_CHAIN (t))\n-    FIELD_PRIVATE (t) = 1;\n-  push_super_field (class_type_node, object_type_node);\n-\n-  FINISH_RECORD (class_type_node);\n-  build_decl (BUILTINS_LOCATION,\n-\t      TYPE_DECL, get_identifier (\"Class\"), class_type_node);\n-\n-  field_info_union_node = make_node (UNION_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      field_info_union_node, field, \"boffset\", int_type_node);\n-  PUSH_FIELD (input_location,\n-\t      field_info_union_node, field, \"addr\", ptr_type_node);\n-  layout_type (field_info_union_node);\n-\n-  PUSH_FIELD (input_location,\n-\t      field_type_node, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (input_location, field_type_node, field, \"type\", class_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      field_type_node, field, \"accflags\", access_flags_type_node);\n-  PUSH_FIELD (input_location,\n-\t      field_type_node, field, \"bsize\", unsigned_short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      field_type_node, field, \"info\", field_info_union_node);\n-  FINISH_RECORD (field_type_node);\n-  build_decl (BUILTINS_LOCATION,\n-\t      TYPE_DECL, get_identifier (\"Field\"), field_type_node);\n-\n-  nativecode_ptr_array_type_node\n-    = build_array_type (nativecode_ptr_type_node, one_elt_array_domain_type);\n-\n-  PUSH_FIELD (input_location,\n-\t      dtable_type, field, \"class\", class_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      dtable_type, field, \"methods\", nativecode_ptr_array_type_node);\n-  FINISH_RECORD (dtable_type);\n-  build_decl (BUILTINS_LOCATION,\n-\t      TYPE_DECL, get_identifier (\"dispatchTable\"), dtable_type);\n-\n-  jexception_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      jexception_type, field, \"start_pc\", ptr_type_node);\n-  PUSH_FIELD (input_location, jexception_type, field, \"end_pc\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      jexception_type, field, \"handler_pc\", ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      jexception_type, field, \"catch_type\", class_ptr_type);\n-  FINISH_RECORD (jexception_type);\n-  build_decl (BUILTINS_LOCATION,\n-\t      TYPE_DECL, get_identifier (\"jexception\"), field_type_node);\n-  jexception_ptr_type = build_pointer_type (jexception_type);\n-\n-  lineNumberEntry_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      lineNumberEntry_type, field, \"line_nr\", unsigned_short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      lineNumberEntry_type, field, \"start_pc\", ptr_type_node);\n-  FINISH_RECORD (lineNumberEntry_type);\n-\n-  lineNumbers_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      lineNumbers_type, field, \"length\", unsigned_int_type_node);\n-  FINISH_RECORD (lineNumbers_type);\n-\n-  PUSH_FIELD (input_location,\n-\t      method_type_node, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      method_type_node, field, \"signature\", utf8const_ptr_type);\n-  PUSH_FIELD (input_location,\n-\t      method_type_node, field, \"accflags\", access_flags_type_node);\n-  PUSH_FIELD (input_location,\n-\t      method_type_node, field, \"index\", unsigned_short_type_node);\n-  PUSH_FIELD (input_location,\n-\t      method_type_node, field, \"ncode\", nativecode_ptr_type_node);\n-  PUSH_FIELD (input_location,\n-\t      method_type_node, field, \"throws\", ptr_type_node);\n-  FINISH_RECORD (method_type_node);\n-  build_decl (BUILTINS_LOCATION,\n-\t      TYPE_DECL, get_identifier (\"Method\"), method_type_node);\n-\n-  end_params_node = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n-\n-  t = build_function_type_list (ptr_type_node, class_ptr_type, NULL_TREE);\n-  alloc_object_node = add_builtin_function (\"_Jv_AllocObject\", t,\n-\t\t\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_MALLOC (alloc_object_node) = 1;\n-  alloc_no_finalizer_node =\n-    add_builtin_function (\"_Jv_AllocObjectNoFinalizer\", t,\n-\t\t\t  0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_MALLOC (alloc_no_finalizer_node) = 1;\n-\n-  t = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n-  soft_initclass_node = add_builtin_function (\"_Jv_InitClass\", t,\n-\t\t\t\t\t      0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  t = build_function_type_list (ptr_type_node,\n-\t\t\t\tclass_ptr_type, int_type_node, NULL_TREE);\n-  soft_resolvepoolentry_node\n-    = add_builtin_function (\"_Jv_ResolvePoolEntry\", t,\n-\t\t\t    0,NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_PURE_P (soft_resolvepoolentry_node) = 1;\n-  t = build_function_type_list (void_type_node,\n-\t\t\t\tclass_ptr_type, int_type_node, NULL_TREE);\n-  throw_node = add_builtin_function (\"_Jv_Throw\", t,\n-\t\t\t\t     0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  /* Mark throw_nodes as `noreturn' functions with side effects.  */\n-  TREE_THIS_VOLATILE (throw_node) = 1;\n-  TREE_SIDE_EFFECTS (throw_node) = 1;\n-\n-  t = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n-  soft_monitorenter_node\n-    = add_builtin_function (\"_Jv_MonitorEnter\", t, 0, NOT_BUILT_IN,\n-\t\t\t    NULL, NULL_TREE);\n-  soft_monitorexit_node\n-    = add_builtin_function (\"_Jv_MonitorExit\", t, 0, NOT_BUILT_IN,\n-\t\t\t    NULL, NULL_TREE);\n-\n-  t = build_function_type_list (ptr_type_node,\n-\t\t\t\tptr_type_node, int_type_node, NULL_TREE);\n-  soft_newarray_node\n-      = add_builtin_function (\"_Jv_NewPrimArray\", t,\n-\t\t\t      0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_MALLOC (soft_newarray_node) = 1;\n-\n-  t = build_function_type_list (ptr_type_node,\n-\t\t\t\tint_type_node, class_ptr_type,\n-\t\t\t\tobject_ptr_type_node, NULL_TREE);\n-  soft_anewarray_node\n-      = add_builtin_function (\"_Jv_NewObjectArray\", t,\n-\t\t\t      0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_MALLOC (soft_anewarray_node) = 1;\n-\n-  t = build_varargs_function_type_list (ptr_type_node,\n-\t\t\t\t\tptr_type_node, int_type_node,\n-\t\t\t\t\tNULL_TREE);\n-  soft_multianewarray_node\n-      = add_builtin_function (\"_Jv_NewMultiArray\", t,\n-\t\t\t      0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_IS_MALLOC (soft_multianewarray_node) = 1;\n-\n-  t = build_function_type_list (void_type_node, int_type_node, NULL_TREE);\n-  soft_badarrayindex_node\n-      = add_builtin_function (\"_Jv_ThrowBadArrayIndex\", t,\n-\t\t\t      0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  /* Mark soft_badarrayindex_node as a `noreturn' function with side\n-     effects.  */\n-  TREE_THIS_VOLATILE (soft_badarrayindex_node) = 1;\n-  TREE_SIDE_EFFECTS (soft_badarrayindex_node) = 1;\n-\n-  t = build_function_type_list (void_type_node, NULL_TREE);\n-  soft_nullpointer_node\n-    = add_builtin_function (\"_Jv_ThrowNullPointerException\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  /* Mark soft_nullpointer_node as a `noreturn' function with side\n-     effects.  */\n-  TREE_THIS_VOLATILE (soft_nullpointer_node) = 1;\n-  TREE_SIDE_EFFECTS (soft_nullpointer_node) = 1;\n-\n-  soft_abstractmethod_node\n-    = add_builtin_function (\"_Jv_ThrowAbstractMethodError\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  /* Mark soft_abstractmethod_node as a `noreturn' function with side\n-     effects.  */\n-  TREE_THIS_VOLATILE (soft_abstractmethod_node) = 1;\n-  TREE_SIDE_EFFECTS (soft_abstractmethod_node) = 1;\n-\n-  soft_nosuchfield_node\n-    = add_builtin_function (\"_Jv_ThrowNoSuchFieldError\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  /* Mark soft_nosuchfield_node as a `noreturn' function with side\n-     effects.  */\n-  TREE_THIS_VOLATILE (soft_nosuchfield_node) = 1;\n-  TREE_SIDE_EFFECTS (soft_nosuchfield_node) = 1;\n-\n-  t = build_function_type_list (ptr_type_node,\n-\t\t\t\tclass_ptr_type, object_ptr_type_node,\n-\t\t\t\tNULL_TREE);\n-  soft_checkcast_node\n-    = add_builtin_function (\"_Jv_CheckCast\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  t = build_function_type_list (boolean_type_node,\n-\t\t\t\tobject_ptr_type_node, class_ptr_type,\n-\t\t\t\tNULL_TREE);\n-  soft_instanceof_node\n-    = add_builtin_function (\"_Jv_IsInstanceOf\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_PURE_P (soft_instanceof_node) = 1;\n-  t = build_function_type_list (void_type_node,\n-\t\t\t\tobject_ptr_type_node, object_ptr_type_node,\n-\t\t\t\tNULL_TREE);\n-  soft_checkarraystore_node\n-    = add_builtin_function (\"_Jv_CheckArrayStore\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  t = build_function_type_list (ptr_type_node,\n-\t\t\t\tptr_type_node, ptr_type_node, int_type_node,\n-\t\t\t\tNULL_TREE);\n-  soft_lookupinterfacemethod_node\n-    = add_builtin_function (\"_Jv_LookupInterfaceMethodIdx\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_PURE_P (soft_lookupinterfacemethod_node) = 1;\n-\n-  t = build_function_type_list (ptr_type_node,\n-\t\t\t\tptr_type_node, ptr_type_node, ptr_type_node,\n-\t\t\t\tNULL_TREE);\n-  soft_lookupinterfacemethodbyname_node\n-    = add_builtin_function (\"_Jv_LookupInterfaceMethod\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  t = build_function_type_list (ptr_type_node,\n-\t\t\t\tobject_ptr_type_node, ptr_type_node,\n-\t\t\t\tptr_type_node, int_type_node, NULL_TREE);\n-  soft_lookupjnimethod_node\n-    = add_builtin_function (\"_Jv_LookupJNIMethod\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  t = build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE);\n-  soft_getjnienvnewframe_node\n-    = add_builtin_function (\"_Jv_GetJNIEnvNewFrame\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-  t = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n-  soft_jnipopsystemframe_node\n-    = add_builtin_function (\"_Jv_JNI_PopSystemFrame\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n-  t = build_function_type_list (object_ptr_type_node,\n-\t\t\t\tobject_ptr_type_node, NULL_TREE);\n-  soft_unwrapjni_node\n-    = add_builtin_function (\"_Jv_UnwrapJNIweakReference\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n-  t = build_function_type_list (int_type_node,\n-\t\t\t\tint_type_node, int_type_node, NULL_TREE);\n-  soft_idiv_node\n-    = add_builtin_function (\"_Jv_divI\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n-  soft_irem_node\n-    = add_builtin_function (\"_Jv_remI\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n-  t = build_function_type_list (long_type_node,\n-\t\t\t\tlong_type_node, long_type_node, NULL_TREE);\n-  soft_ldiv_node\n-    = add_builtin_function (\"_Jv_divJ\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n-  soft_lrem_node\n-    = add_builtin_function (\"_Jv_remJ\", t,\n-\t\t\t    0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n-  initialize_builtins ();\n-\n-  soft_fmod_node = builtin_decl_explicit (BUILT_IN_FMOD);\n-\n-  parse_version ();\n-}\n-\n-\n-/* Look up NAME in the current binding level and its superiors\n-   in the namespace of variables, functions and typedefs.\n-   Return a ..._DECL node of some kind representing its definition,\n-   or return 0 if it is undefined.  */\n-\n-tree\n-lookup_name (tree name)\n-{\n-  tree val;\n-  if (current_binding_level != global_binding_level\n-      && IDENTIFIER_LOCAL_VALUE (name))\n-    val = IDENTIFIER_LOCAL_VALUE (name);\n-  else\n-    val = IDENTIFIER_GLOBAL_VALUE (name);\n-  return val;\n-}\n-\n-/* Similar to `lookup_name' but look only at current binding level and\n-   the previous one if it's the parameter level.  */\n-\n-static tree\n-lookup_name_current_level (tree name)\n-{\n-  tree t;\n-\n-  if (current_binding_level == global_binding_level)\n-    return IDENTIFIER_GLOBAL_VALUE (name);\n-\n-  if (IDENTIFIER_LOCAL_VALUE (name) == 0)\n-    return 0;\n-\n-  for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n-    if (DECL_NAME (t) == name)\n-      break;\n-\n-  return t;\n-}\n-\n-/* Record a decl-node X as belonging to the current lexical scope.\n-   Check for errors (such as an incompatible declaration for the same\n-   name already seen in the same scope).\n-\n-   Returns either X or an old decl for the same name.\n-   If an old decl is returned, it may have been smashed\n-   to agree with what X says.  */\n-\n-tree\n-pushdecl (tree x)\n-{\n-  tree t;\n-  tree name = DECL_NAME (x);\n-  struct binding_level *b = current_binding_level;\n-  \n-  if (TREE_CODE (x) != TYPE_DECL)\n-    DECL_CONTEXT (x) = current_function_decl;\n-  if (name)\n-    {\n-      t = lookup_name_current_level (name);\n-      if (t != 0 && t == error_mark_node)\n-\t/* error_mark_node is 0 for a while during initialization!  */\n-\t{\n-\t  t = 0;\n-\t  error (\"%q+D used prior to declaration\", x);\n-\t}\n-\n-      /* If we're naming a hitherto-unnamed type, set its TYPE_NAME\n-\t to point to the TYPE_DECL.\n-\t Since Java does not have typedefs, a type can only have\n-\t one (true) name, given by a class, interface, or builtin. */\n-      if (TREE_CODE (x) == TYPE_DECL\n-\t  && TYPE_NAME (TREE_TYPE (x)) == 0\n-\t  && TREE_TYPE (x) != error_mark_node)\n-\t{\n-\t  TYPE_NAME (TREE_TYPE (x)) = x;\n-\t  TYPE_STUB_DECL (TREE_TYPE (x)) = x;\n-\t}\n-\n-      /* This name is new in its binding level.\n-\t Install the new declaration and return it.  */\n-      if (b == global_binding_level)\n-\t{\n-\t  /* Install a global value.  */\n-\t  \n-\t  IDENTIFIER_GLOBAL_VALUE (name) = x;\n-\t}\n-      else\n-\t{\n-\t  /* Here to install a non-global value.  */\n-\t  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n-\t  IDENTIFIER_LOCAL_VALUE (name) = x;\n-\n-\t  /* If storing a local value, there may already be one (inherited).\n-\t     If so, record it for restoration when this binding level ends.  */\n-\t  if (oldlocal != 0)\n-\t    b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n-\t}\n-    }\n-\n-  /* Put decls on list in reverse order.\n-     We will reverse them later if necessary.  */\n-  DECL_CHAIN (x) = b->names;\n-  b->names = x;\n-\n-  return x;\n-}\n-\n-void\n-pushdecl_force_head (tree x)\n-{\n-  current_binding_level->names = x;\n-}\n-\n-/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL, if appropriate.  */\n-\n-tree\n-pushdecl_top_level (tree x)\n-{\n-  tree t;\n-  struct binding_level *b = current_binding_level;\n-\n-  current_binding_level = global_binding_level;\n-  t = pushdecl (x);\n-  current_binding_level = b;\n-  return t;\n-}\n-\n-/* Like pushdecl, only it places X in FUNCTION_BINDING_LEVEL, if appropriate.  */\n-\n-tree\n-pushdecl_function_level (tree x)\n-{\n-  tree t;\n-  struct binding_level *b = current_binding_level;\n-\n-  current_binding_level = function_binding_level;\n-  t = pushdecl (x);\n-  current_binding_level = b;\n-  return t;\n-}\n-\n-/* Return true if we are in the global binding level.  */\n-\n-bool\n-global_bindings_p (void)\n-{\n-  return current_binding_level == global_binding_level;\n-}\n-\n-/* Return the list of declarations of the current level.\n-   Note that this list is in reverse order unless/until\n-   you nreverse it; and when you do nreverse it, you must\n-   store the result back using `storedecls' or you will lose.  */\n-\n-tree\n-getdecls (void)\n-{\n-  return current_binding_level->names;\n-}\n-\n-/* Create a new `struct binding_level'.  */\n-\n-static struct binding_level *\n-make_binding_level (void)\n-{\n-  /* NOSTRICT */\n-  return ggc_cleared_alloc<binding_level> ();\n-}\n-\n-void\n-pushlevel (int unused ATTRIBUTE_UNUSED)\n-{\n-  struct binding_level *newlevel = NULL_BINDING_LEVEL;\n-\n-  /* Reuse or create a struct for this binding level.  */\n-\n-  if (free_binding_level)\n-    {\n-      newlevel = free_binding_level;\n-      free_binding_level = free_binding_level->level_chain;\n-    }\n-  else\n-    {\n-      newlevel = make_binding_level ();\n-    }\n-\n-  /* Add this level to the front of the chain (stack) of levels that\n-     are active.  */\n-\n-  *newlevel = clear_binding_level;\n-  newlevel->level_chain = current_binding_level;\n-  newlevel->loc = input_location;\n-  current_binding_level = newlevel;  \n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-  newlevel->binding_depth = binding_depth;\n-  indent ();\n-  fprintf (stderr, \"push %s level %p pc %d\\n\",\n-\t   (is_class_level) ? \"class\" : \"block\", newlevel, current_pc);\n-  is_class_level = 0;\n-  binding_depth++;\n-#endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n-}\n-\n-/* Exit a binding level.\n-   Pop the level off, and restore the state of the identifier-decl mappings\n-   that were in effect when this level was entered.\n-\n-   If KEEP is nonzero, this level had explicit declarations, so\n-   and create a \"block\" (a BLOCK node) for the level\n-   to record its declarations and subblocks for symbol table output.\n-\n-   If FUNCTIONBODY is nonzero, this level is the body of a function,\n-   so create a block as if KEEP were set and also clear out all\n-   label names.\n-\n-   If REVERSE is nonzero, reverse the order of decls before putting\n-   them into the BLOCK.  */\n-\n-tree\n-poplevel (int keep, int reverse, int functionbody)\n-{\n-  tree link;\n-  /* The chain of decls was accumulated in reverse order.\n-     Put it into forward order, just for cleanliness.  */\n-  tree decls;\n-  tree subblocks = current_binding_level->blocks;\n-  tree block = 0;\n-  tree decl;\n-  tree bind = 0;\n-\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-  binding_depth--;\n-  indent ();\n-  if (current_binding_level->end_pc != LARGEST_PC)\n-    fprintf (stderr, \"pop  %s level %p pc %d (end pc %d)\\n\",\n-\t     (is_class_level) ? \"class\" : \"block\", current_binding_level, current_pc,\n-\t     current_binding_level->end_pc);\n-  else\n-    fprintf (stderr, \"pop  %s level %p pc %d\\n\",\n-\t     (is_class_level) ? \"class\" : \"block\", current_binding_level, current_pc);\n-#endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n-\n-  /* Get the decls in the order they were written.\n-     Usually current_binding_level->names is in reverse order.\n-     But parameter decls were previously put in forward order.  */\n-\n-  if (reverse)\n-    current_binding_level->names\n-      = decls = nreverse (current_binding_level->names);\n-  else\n-    decls = current_binding_level->names;\n-\n-  for (decl = decls; decl; decl = DECL_CHAIN (decl))\n-    if (TREE_CODE (decl) == VAR_DECL\n-\t&& DECL_LANG_SPECIFIC (decl) != NULL\n-\t&& DECL_LOCAL_SLOT_NUMBER (decl))\n-      LOCAL_VAR_OUT_OF_SCOPE_P (decl) = 1;\n-\n-  /* If there were any declarations in that level,\n-     or if this level is a function body,\n-     create a BLOCK to record them for the life of this function.  */\n-\n-  block = 0;\n-  if (keep || functionbody)\n-    block = make_node (BLOCK);\n-\n-  if (current_binding_level->exception_range)\n-    expand_end_java_handler (current_binding_level->exception_range);\n-\n-  if (block != 0)\n-    {\n-      /* If any statements have been generated at this level, create a\n-\t BIND_EXPR to hold them and copy the variables to it.  This\n-\t only applies to the bytecode compiler.  */\n-      if (current_binding_level->stmts)\n-\t{\n-\t  tree decl = decls;\n-\t  tree *var = &BLOCK_VARS (block);\n-\n-\t  /* Copy decls from names list, ignoring labels.  */\n-\t  while (decl)\n-\t    {\n-\t      tree next = DECL_CHAIN (decl);\n-\t      if (TREE_CODE (decl) != LABEL_DECL)\n-\t\t{\n-\t\t  *var = decl;\n-\t\t  var = &DECL_CHAIN (decl);\n-\t\t}\n-\t      decl = next;\n-\t    }\n-\t  *var = NULL;\n-\t    \n-\t  bind = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (block), \n-\t\t\t BLOCK_EXPR_BODY (block), block);\n-\t  BIND_EXPR_BODY (bind) = current_binding_level->stmts;\n-\t  \n-\t  if (BIND_EXPR_BODY (bind)\n-\t      && TREE_SIDE_EFFECTS (BIND_EXPR_BODY (bind)))\n-\t    TREE_SIDE_EFFECTS (bind) = 1;\n-\t  \n-\t  /* FIXME: gimplifier brain damage.  */\n-\t  if (BIND_EXPR_BODY (bind) == NULL)\n-\t    BIND_EXPR_BODY (bind) = build_java_empty_stmt ();\n-\n-\t  SET_EXPR_LOCATION (bind, current_binding_level->loc);\n-\n-\t  current_binding_level->stmts = NULL;\n-\t}\n-      else\n-\t{\n-\t  BLOCK_VARS (block) = decls;\n-\t}\n-      BLOCK_SUBBLOCKS (block) = subblocks;\n-    }\t\n-\n-  /* In each subblock, record that this is its superior.  */\n-\n-  for (link = subblocks; link; link = BLOCK_CHAIN (link))\n-    BLOCK_SUPERCONTEXT (link) = block;\n-\n-  /* Clear out the meanings of the local variables of this level.  */\n-\n-  for (link = decls; link; link = DECL_CHAIN (link))\n-    {\n-      tree name = DECL_NAME (link);\n-      if (name != 0 && IDENTIFIER_LOCAL_VALUE (name) == link)\n-\t{\n-\t  /* If the ident. was used or addressed via a local extern decl,\n-\t     don't forget that fact.  */\n-\t  if (DECL_EXTERNAL (link))\n-\t    {\n-\t      if (TREE_USED (link))\n-\t\tTREE_USED (name) = 1;\n-\t      if (TREE_ADDRESSABLE (link))\n-\t\tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n-\t    }\n-\t  IDENTIFIER_LOCAL_VALUE (name) = 0;\n-\t}\n-    }\n-\n-  /* Restore all name-meanings of the outer levels\n-     that were shadowed by this level.  */\n-\n-  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-\n-  /* If the level being exited is the top level of a function,\n-     check over all the labels, and clear out the current\n-     (function local) meanings of their names.  */\n-\n-  if (functionbody)\n-    {\n-      /* If this is the top level block of a function,\n-\t the vars are the function's parameters.\n-\t Don't leave them in the BLOCK because they are\n-\t found in the FUNCTION_DECL instead.  */\n-\n-      BLOCK_VARS (block) = 0;\n-    }\n-\n-  /* Pop the current level, and free the structure for reuse.  */\n-\n-  {\n-    struct binding_level *level = current_binding_level;\n-    current_binding_level = current_binding_level->level_chain;\n-\n-    level->level_chain = free_binding_level;\n-    free_binding_level = level;\n-  }\n-\n-  /* Dispose of the block that we just made inside some higher level.  */\n-  if (functionbody)\n-    {\n-      DECL_INITIAL (current_function_decl) = block;\n-      DECL_SAVED_TREE (current_function_decl) = bind;\n-    }\n-  else \n-    {\n-      if (block)\n-\t{\n-\t  current_binding_level->blocks\n-\t    = block_chainon (current_binding_level->blocks, block);\n-\t}\n-      /* If we did not make a block for the level just exited,\n-\t any blocks made for inner levels\n-\t (since they cannot be recorded as subblocks in that level)\n-\t must be carried forward so they will later become subblocks\n-\t of something else.  */\n-      else if (subblocks)\n-\tcurrent_binding_level->blocks\n-\t  = block_chainon (current_binding_level->blocks, subblocks);\n-\n-      if (bind)\n-\tjava_add_stmt (bind);\n-    }\n-\n-  if (block)\n-    TREE_USED (block) = 1;\n-  return block;\n-}\n-\n-void\n-maybe_pushlevels (int pc)\n-{\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-  current_pc = pc;\n-#endif\n-\n-  while (pending_local_decls != NULL_TREE &&\n-\t DECL_LOCAL_START_PC (pending_local_decls) <= pc)\n-    {\n-      tree *ptr = &pending_local_decls;\n-      tree decl = *ptr, next;\n-      int end_pc = DECL_LOCAL_END_PC (decl);\n-\n-      while (*ptr != NULL_TREE\n-\t     && DECL_LOCAL_START_PC (*ptr) <= pc\n-\t     && DECL_LOCAL_END_PC (*ptr) == end_pc)\n-\tptr = &DECL_CHAIN (*ptr);\n-      pending_local_decls = *ptr;\n-      *ptr = NULL_TREE;\n-\n-      /* Force non-nested range to be nested in current range by\n-\t truncating variable lifetimes. */\n-      if (end_pc > current_binding_level->end_pc)\n-\t{\n-\t  tree t;\n-\t  end_pc = current_binding_level->end_pc;\n-\t  for (t = decl; t != NULL_TREE; t = DECL_CHAIN (t))\n-\t    DECL_LOCAL_END_PC (t) = end_pc;\n-\t}\n-\n-      maybe_start_try (pc, end_pc);\n-      \n-      pushlevel (1);\n-\n-      current_binding_level->end_pc = end_pc;\n-      current_binding_level->start_pc = pc;      \n-      current_binding_level->names = NULL;\n-      for ( ; decl != NULL_TREE; decl = next)\n-\t{\n-\t  int index = DECL_LOCAL_SLOT_NUMBER (decl);\n-\t  tree base_decl;\n-\t  next = DECL_CHAIN (decl);\n-\t  push_jvm_slot (index, decl);\n-\t  pushdecl (decl);\n-\t  base_decl\n-\t    = find_local_variable (index, TREE_TYPE (decl), pc);\n-\t  if (TREE_CODE (TREE_TYPE (base_decl)) == POINTER_TYPE)\n-\t    base_decl = TREE_VEC_ELT (base_decl_map, index);\n-\t  SET_DECL_VALUE_EXPR (decl, base_decl);\n-\t  DECL_HAS_VALUE_EXPR_P (decl) = 1;\n-\t}\n-    }      \n-\n-  maybe_start_try (pc, 0);\n-}\n-\n-void\n-maybe_poplevels (int pc)\n-{\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-  current_pc = pc;\n-#endif\n-\n-  /* FIXME: I'm pretty sure that this is wrong.  Variable scopes are\n-     inclusive, so a variable is live if pc == end_pc.  Here, we\n-     terminate a range if the current pc is equal to the end of the\n-     range, and this is *before* we have generated code for the\n-     instruction at end_pc.  We're closing a binding level one\n-     instruction too early.*/\n-  while (current_binding_level->end_pc <= pc)\n-    poplevel (1, 0, 0);\n-}\n-\n-/* Terminate any binding which began during the range beginning at\n-   start_pc.  This tidies up improperly nested local variable ranges\n-   and exception handlers; a variable declared within an exception\n-   range is forcibly terminated when that exception ends. */\n-\n-void\n-force_poplevels (int start_pc)\n-{\n-  while (current_binding_level->start_pc > start_pc)\n-    {\n-      if (pedantic && current_binding_level->start_pc > start_pc)\n-\twarning (0, \"In %+D: overlapped variable and exception ranges at %d\",\n-                 current_function_decl,\n-\t\t current_binding_level->start_pc);\n-      poplevel (1, 0, 0);\n-    }\n-}\n-\n-/* integrate_decl_tree calls this function. */\n-\n-void\n-java_dup_lang_specific_decl (tree node)\n-{\n-  int lang_decl_size;\n-  struct lang_decl *x;\n-\n-  if (!DECL_LANG_SPECIFIC (node))\n-    return;\n-\n-  lang_decl_size = sizeof (struct lang_decl);\n-  x = ggc_alloc<struct lang_decl> ();\n-  memcpy (x, DECL_LANG_SPECIFIC (node), lang_decl_size);\n-  DECL_LANG_SPECIFIC (node) = x;\n-}\n-\n-void\n-give_name_to_locals (JCF *jcf)\n-{\n-  int i, n = DECL_LOCALVARIABLES_OFFSET (current_function_decl);\n-  int code_offset = DECL_CODE_OFFSET (current_function_decl);\n-  tree parm;\n-  pending_local_decls = NULL_TREE;\n-  if (n == 0)\n-    return;\n-  JCF_SEEK (jcf, n);\n-  n = JCF_readu2 (jcf);\n-  for (i = 0; i < n; i++)\n-    {\n-      int start_pc = JCF_readu2 (jcf);\n-      int length = JCF_readu2 (jcf);\n-      int name_index = JCF_readu2 (jcf);\n-      int signature_index = JCF_readu2 (jcf);\n-      int slot = JCF_readu2 (jcf);\n-      tree name = get_name_constant (jcf, name_index);\n-      tree type = parse_signature (jcf, signature_index);\n-      if (slot < DECL_ARG_SLOT_COUNT (current_function_decl)\n-\t  && start_pc == 0\n-\t  && length == DECL_CODE_LENGTH (current_function_decl))\n-\t{\n-\t  tree decl = TREE_VEC_ELT (decl_map, slot);\n-\t  DECL_NAME (decl) = name;\n-\t  if (TREE_CODE (decl) != PARM_DECL || TREE_TYPE (decl) != type)\n-\t    warning (0, \"bad type in parameter debug info\");\n-\t}\n-      else\n-\t{\n-\t  tree *ptr;\n-\t  int end_pc = start_pc + length;\n-\t  tree decl = build_decl (input_location, VAR_DECL, name, type);\n-\t  if (end_pc > DECL_CODE_LENGTH (current_function_decl))\n-\t    {\n-\t      warning (0, \"bad PC range for debug info for local %q+D\",\n-                       decl);\n-\t      end_pc = DECL_CODE_LENGTH (current_function_decl);\n-\t    }\n-\n-\t  /* Adjust start_pc if necessary so that the local's first\n-\t     store operation will use the relevant DECL as a\n-\t     destination. Fore more information, read the leading\n-\t     comments for expr.c:maybe_adjust_start_pc. */\n-\t  start_pc = maybe_adjust_start_pc (jcf, code_offset, start_pc, slot);\n-\n-\t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n-\t  DECL_LOCAL_SLOT_NUMBER (decl) = slot;\n-\t  DECL_LOCAL_START_PC (decl) = start_pc;\n-\t  DECL_LOCAL_END_PC (decl) = end_pc;\n-\n-\t  /* Now insert the new decl in the proper place in\n-\t     pending_local_decls.  We are essentially doing an insertion sort,\n-\t     which works fine, since the list input will normally already\n-\t     be sorted. */\n-\t  ptr = &pending_local_decls;\n-\t  while (*ptr != NULL_TREE\n-\t\t && (DECL_LOCAL_START_PC (*ptr) > start_pc\n-\t\t     || (DECL_LOCAL_START_PC (*ptr) == start_pc\n-\t\t\t && DECL_LOCAL_END_PC (*ptr) < end_pc)))\n-\t    ptr = &DECL_CHAIN (*ptr);\n-\t  DECL_CHAIN (decl) = *ptr;\n-\t  *ptr = decl;\n-\t}\n-    }\n-\n-  pending_local_decls = nreverse (pending_local_decls);\n-\n-  /* Fill in default names for the parameters. */ \n-  for (parm = DECL_ARGUMENTS (current_function_decl), i = 0;\n-       parm != NULL_TREE;  parm = DECL_CHAIN (parm), i++)\n-    {\n-      if (DECL_NAME (parm) == NULL_TREE)\n-\t{\n-\t  int arg_i = METHOD_STATIC (current_function_decl) ? i+1 : i;\n-\t  if (arg_i == 0)\n-\t    DECL_NAME (parm) = get_identifier (\"this\");\n-\t  else\n-\t    {\n-\t      /* Buffer large enough for INT_MAX plus prefix.  */\n-\t      char buffer[15];\n-\t      sprintf (buffer, \"ARG_%d\", arg_i);\n-\t      DECL_NAME (parm) = get_identifier (buffer);\n-\t    }\n-\t}\n-    }\n-}\n-\n-tree\n-build_result_decl (tree fndecl)\n-{\n-  tree restype = TREE_TYPE (TREE_TYPE (fndecl));\n-  tree result = DECL_RESULT (fndecl);\n-  if (! result)\n-    {\n-      result = build_decl (DECL_SOURCE_LOCATION (fndecl),\n-\t\t\t   RESULT_DECL, NULL_TREE, restype);\n-      DECL_ARTIFICIAL (result) = 1;\n-      DECL_IGNORED_P (result) = 1;\n-      DECL_CONTEXT (result) = fndecl;\n-      DECL_RESULT (fndecl) = result;\n-    }\n-  return result;\n-}\n-\n-void\n-start_java_method (tree fndecl)\n-{\n-  tree tem, *ptr;\n-  int i;\n-\n-  uniq = 0;\n-\n-  current_function_decl = fndecl;\n-  announce_function (fndecl);\n-\n-  i = DECL_MAX_LOCALS(fndecl) + DECL_MAX_STACK(fndecl);\n-  decl_map = make_tree_vec (i);\n-  base_decl_map = make_tree_vec (i);\n-  type_map = XRESIZEVEC (tree, type_map, i);\n-\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-  fprintf (stderr, \"%s:\\n\", lang_printable_name (fndecl, 2));\n-  current_pc = 0;\n-#endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n-  pushlevel (1);  /* Push parameters. */\n-\n-  ptr = &DECL_ARGUMENTS (fndecl);\n-  for (tem = TYPE_ARG_TYPES (TREE_TYPE (fndecl)), i = 0;\n-       tem != end_params_node; tem = TREE_CHAIN (tem), i++)\n-    {\n-      tree parm_name = NULL_TREE, parm_decl;\n-      tree parm_type = TREE_VALUE (tem);\n-      gcc_assert (i < DECL_MAX_LOCALS (fndecl));\n-\n-      parm_decl = build_decl (input_location, PARM_DECL, parm_name, parm_type);\n-      DECL_CONTEXT (parm_decl) = fndecl;\n-      if (targetm.calls.promote_prototypes (parm_type)\n-\t  && TYPE_PRECISION (parm_type) < TYPE_PRECISION (integer_type_node)\n-\t  && INTEGRAL_TYPE_P (parm_type))\n-\tparm_type = integer_type_node;\n-      DECL_ARG_TYPE (parm_decl) = parm_type;\n-\n-      *ptr = parm_decl;\n-      ptr = &DECL_CHAIN (parm_decl);\n-\n-      /* Add parm_decl to the decl_map. */\n-      push_jvm_slot (i, parm_decl);\n-\n-      /* The this parameter of methods is artificial.  */\n-      if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE && i == 0)\n-\tDECL_ARTIFICIAL (parm_decl) = 1;\n-\n-      type_map[i] = TREE_TYPE (parm_decl);\n-      if (TYPE_IS_WIDE (TREE_TYPE (parm_decl)))\n-\t{\n-\t  i++;\n-\t  type_map[i] = void_type_node;\n-\t}\n-    }\n-  *ptr = NULL_TREE;\n-  DECL_ARG_SLOT_COUNT (current_function_decl) = i;\n-\n-  while (i < DECL_MAX_LOCALS(fndecl))\n-    type_map[i++] = NULL_TREE;\n-\n-  build_result_decl (fndecl);\n-  DECL_SOURCE_LOCATION (fndecl) = input_location;\n-\n-  /* Push local variables.  */\n-  pushlevel (2);\n-\n-  function_binding_level = current_binding_level;\n-}\n-\n-void\n-end_java_method (void)\n-{\n-  tree fndecl = current_function_decl;\n-\n-  /* pop out of function */\n-  poplevel (1, 1, 0);\n-\n-  /* pop out of its parameters */\n-  poplevel (1, 0, 1);\n-\n-  BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n-  \n-  if (DECL_SAVED_TREE (fndecl))\n-    {\n-      tree fbody, block_body;\n-      /* Before we check initialization, attached all class initialization\n-\t variable to the block_body */\n-      fbody = DECL_SAVED_TREE (fndecl);\n-      block_body = BIND_EXPR_BODY (fbody);\n-      hash_table<treetreehasher> *ht = DECL_FUNCTION_INIT_TEST_TABLE (fndecl);\n-      ht->traverse<tree, attach_init_test_initialization_flags> (block_body);\n-    }\n-\n-  finish_method (fndecl);\n-\n-  current_function_decl = NULL_TREE;\n-  base_decl_map = NULL_TREE;\n-}\n-\n-/* Prepare a method for expansion.  */\n-\n-void\n-finish_method (tree fndecl)\n-{\n-  tree *tp = &DECL_SAVED_TREE (fndecl);\n-\n-  /* Wrap body of synchronized methods in a monitorenter,\n-     plus monitorexit cleanup.  */\n-  if (METHOD_SYNCHRONIZED (fndecl))\n-    {\n-      tree enter, exit, lock;\n-      if (METHOD_STATIC (fndecl))\n-\tlock = build_class_ref (DECL_CONTEXT (fndecl));\n-      else\n-\tlock = DECL_ARGUMENTS (fndecl);\n-      BUILD_MONITOR_ENTER (enter, lock);\n-      BUILD_MONITOR_EXIT (exit, lock);\n-      *tp = build2 (COMPOUND_EXPR, void_type_node, enter,\n-\t\t    build2 (TRY_FINALLY_EXPR, void_type_node, *tp, exit));\n-    }\n-\n-  /* Convert function tree to GENERIC prior to inlining.  */\n-  java_genericize (fndecl);\n-\n-  /* Store the end of the function, so that we get good line number\n-     info for the epilogue.  */\n-  if (DECL_STRUCT_FUNCTION (fndecl))\n-    set_cfun (DECL_STRUCT_FUNCTION (fndecl));\n-  else\n-    allocate_struct_function (fndecl, false);\n-  cfun->function_end_locus = DECL_FUNCTION_LAST_LINE (fndecl);\n-\n-  /* Defer inlining and expansion to the cgraph optimizers.  */\n-  cgraph_node::finalize_function (fndecl, false);\n-}\n-\n-/* We pessimistically marked all methods and fields external until we\n-   knew what set of classes we were planning to compile.  Now mark those\n-   associated with CLASS to be generated locally as not external.  */\n-\n-static void\n-java_mark_decl_local (tree decl)\n-{\n-  DECL_EXTERNAL (decl) = 0;\n-\n-  /* Double check that we didn't pass the function to the callgraph early.  */\n-  if (flag_checking && TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      struct cgraph_node *node = cgraph_node::get (decl);\n-      gcc_assert (!node || !node->definition);\n-    }\n-  gcc_assert (!DECL_RTL_SET_P (decl));\n-}\n-\n-/* Given appropriate target support, G++ will emit hidden aliases for native\n-   methods.  Using this hidden name is required for proper operation of\n-   _Jv_Method::ncode, but it doesn't hurt to use it everywhere.  Look for\n-   proper target support, then mark the method for aliasing.  */\n-\n-static void\n-java_mark_cni_decl_local (tree decl)\n-{\n-#if !defined(HAVE_GAS_HIDDEN) || !defined(ASM_OUTPUT_DEF)\n-  return;\n-#endif\n-\n-  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n-  DECL_LOCAL_CNI_METHOD_P (decl) = 1;\n-\n-  /* Setting DECL_LOCAL_CNI_METHOD_P changes the behavior of the\n-     mangler.  We might have already referenced this native method and\n-     therefore created its name, but even if we have it won't hurt.\n-     We'll just go via its externally visible name, rather than its\n-     hidden alias.  However, we must force things so that the correct\n-     mangling is done.  */\n-\n-  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n-    java_mangle_decl (decl);\n-  if (DECL_RTL_SET_P (decl))\n-    {\n-      SET_DECL_RTL (decl, 0);\n-      make_decl_rtl (decl);\n-    }\n-}\n-\n-/* Use the preceding two functions and mark all members of the class.  */\n-\n-void\n-java_mark_class_local (tree klass)\n-{\n-  tree t;\n-\n-  for (t = TYPE_FIELDS (klass); t ; t = DECL_CHAIN (t))\n-    if (FIELD_STATIC (t))\n-      java_mark_decl_local (t);\n-\n-  for (t = TYPE_METHODS (klass); t ; t = DECL_CHAIN (t))\n-    if (!METHOD_ABSTRACT (t))\n-      {\n-\tif (METHOD_NATIVE (t) && !flag_jni)\n-\t  java_mark_cni_decl_local (t);\n-        else\n-\t  java_mark_decl_local (t);\n-      }\n-}\n-\n-/* Add a statement to a compound_expr.  */\n-\n-tree\n-add_stmt_to_compound (tree existing, tree type, tree stmt)\n-{\n-  if (!stmt)\n-    return existing;\n-  else if (existing)\n-    {\n-      tree expr = build2 (COMPOUND_EXPR, type, existing, stmt);\n-      TREE_SIDE_EFFECTS (expr) = TREE_SIDE_EFFECTS (existing)\n-\t\t\t\t | TREE_SIDE_EFFECTS (stmt);\n-      return expr;\n-    }\n-  else\n-    return stmt;\n-}\n-\n-/* If this node is an expr, mark its input location.  Called from\n-   walk_tree().  */\n-\n-static tree\n-set_input_location (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t    void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp;\n-\n-  if (CAN_HAVE_LOCATION_P (t))\n-    {\n-      if (EXPR_HAS_LOCATION(t))\n-\treturn t;  /* Don't walk any further into this expr.   */\n-      else\n-\tSET_EXPR_LOCATION (t, input_location);\n-    }\n-\n-  return NULL_TREE;  /* Continue walking this expr.   */\n-}\n-\n-/* Add a statement to the statement_list currently being constructed.\n-   If the statement_list is null, we don't create a singleton list.\n-   This is necessary because poplevel() assumes that adding a\n-   statement to a null statement_list returns the statement.  */\n-\n-tree\n-java_add_stmt (tree new_stmt)\n-{\n-  tree stmts = current_binding_level->stmts;\n-  tree_stmt_iterator i;\n-\n-  if (LOCATION_FILE (input_location))\n-    walk_tree (&new_stmt, set_input_location, NULL, NULL);\n-\n-  if (stmts == NULL)\n-    return current_binding_level->stmts = new_stmt;\n-\n-  /* Force STMTS to be a statement_list.  */\n-  if (TREE_CODE (stmts) != STATEMENT_LIST)\n-    {\n-      tree t = make_node (STATEMENT_LIST);\n-      i = tsi_last (t);\n-      tsi_link_after (&i, stmts, TSI_CONTINUE_LINKING);\n-      stmts = t;\n-    }  \n-      \n-  i = tsi_last (stmts);\n-  tsi_link_after (&i, new_stmt, TSI_CONTINUE_LINKING);\n-  TREE_TYPE (stmts) = void_type_node;\n-\n-  return current_binding_level->stmts = stmts;\n-}\n-\n-/* Add a variable to the current scope.  */\n-\n-tree\n-java_add_local_var (tree decl)\n-{\n-  tree *vars = &current_binding_level->names;\n-  tree next = *vars;\n-  DECL_CHAIN (decl) = next;\n-  *vars = decl;\n-  DECL_CONTEXT (decl) = current_function_decl;\n-  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n-  return decl;\n-}\n-\n-/* Return a pointer to the compound_expr currently being\n-   constructed.  */\n-\n-tree *\n-get_stmts (void)\n-{\n-  return &current_binding_level->stmts;\n-}\n-\n-/* Register an exception range as belonging to the current binding\n-   level.  There may only be one: if there are more, we'll create more\n-   binding levels.  However, each range can have multiple handlers,\n-   and these are expanded when we call expand_end_java_handler().  */\n-\n-void\n-register_exception_range (struct eh_range *range, int pc, int end_pc)\n-{\n-  gcc_assert (! current_binding_level->exception_range);\n-  current_binding_level->exception_range = range;\n-  current_binding_level->end_pc = end_pc;\n-  current_binding_level->start_pc = pc;      \n-}\n-\n-#include \"gt-java-decl.h\""}, {"sha": "c5ecccc232684a9bff73f63bc8486567db7e5eac", "filename": "gcc/java/except.c", "status": "removed", "additions": 0, "deletions": 608, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,608 +0,0 @@\n-/* Handle exceptions for GNU compiler for the Java(TM) language.\n-   Copyright (C) 1997-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"diagnostic-core.h\"\n-#include \"fold-const.h\"\n-#include \"stor-layout.h\"\n-#include \"java-tree.h\"\n-#include \"java-except.h\"\n-#include \"toplev.h\"\n-#include \"tree-iterator.h\"\n-\n-\n-static void expand_start_java_handler (struct eh_range *);\n-static struct eh_range *find_handler_in_range (int, struct eh_range *,\n-\t\t\t\t\t       struct eh_range *);\n-static void check_start_handlers (struct eh_range *, int);\n-static void free_eh_ranges (struct eh_range *range);\n-\n-struct eh_range *current_method_handlers;\n-\n-struct eh_range *current_try_block = NULL;\n-\n-/* These variables are used to speed up find_handler. */\n-\n-static int cache_range_start, cache_range_end;\n-static struct eh_range *cache_range;\n-static struct eh_range *cache_next_child;\n-\n-/* A dummy range that represents the entire method. */\n-\n-struct eh_range whole_range;\n-\n-/* Check the invariants of the structure we're using to contain\n-   exception regions.  Either returns true or fails an assertion\n-   check.  */\n-\n-bool\n-sanity_check_exception_range (struct eh_range *range)\n-{\n-  struct eh_range *ptr = range->first_child;\n-  for (; ptr; ptr = ptr->next_sibling)\n-    {\n-      gcc_assert (ptr->outer == range\n-\t\t  && ptr->end_pc > ptr->start_pc);\n-      if (ptr->next_sibling)\n-\tgcc_assert (ptr->next_sibling->start_pc >= ptr->end_pc);\n-      gcc_assert (ptr->start_pc >= ptr->outer->start_pc\n-\t\t  && ptr->end_pc <=  ptr->outer->end_pc);\n-      (void) sanity_check_exception_range (ptr);\n-    }\n-  return true;\n-}\n-\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-extern int is_class_level;\n-extern int current_pc;\n-extern int binding_depth;\n-extern void indent (void);\n-static void\n-print_ranges (struct eh_range *range)\n-{\n-  if (! range)\n-    return;\n-\n-  struct eh_range *child = range->first_child;\n-  \n-  indent ();\n-  fprintf (stderr, \"handler pc %d --> %d \", range->start_pc, range->end_pc);\n-  \n-  tree handler = range->handlers;\n-  for ( ; handler != NULL_TREE; handler = TREE_CHAIN (handler))\n-    {\n-      tree type = TREE_PURPOSE (handler);\n-      if (type == NULL)\n-\ttype = throwable_type_node;\n-      fprintf (stderr, \" type=%s \", IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n-    }\n-  fprintf (stderr, \"\\n\");\n-\n-  int saved = binding_depth;\n-  binding_depth++;\n-  print_ranges (child);\n-  binding_depth = saved;\n-\n-  print_ranges (range->next_sibling);\n-}\n-#endif\n-\n-/* Search for the most specific eh_range containing PC.\n-   Assume PC is within RANGE.\n-   CHILD is a list of children of RANGE such that any\n-   previous children have end_pc values that are too low. */\n-\n-static struct eh_range *\n-find_handler_in_range (int pc, struct eh_range *range, struct eh_range *child)\n-{\n-  for (; child != NULL;  child = child->next_sibling)\n-    {\n-      if (pc < child->start_pc)\n-\tbreak;\n-      if (pc < child->end_pc)\n-\treturn find_handler_in_range (pc, child, child->first_child);\n-    }\n-  cache_range = range;\n-  cache_range_start = pc;\n-  cache_next_child = child;\n-  cache_range_end = child == NULL ? range->end_pc : child->start_pc;\n-  return range;\n-}\n-\n-/* Find the inner-most handler that contains PC. */\n-\n-struct eh_range *\n-find_handler (int pc)\n-{\n-  struct eh_range *h;\n-  if (pc >= cache_range_start)\n-    {\n-      h = cache_range;\n-      if (pc < cache_range_end)\n-\treturn h;\n-      while (pc >= h->end_pc)\n-\t{\n-\t  cache_next_child = h->next_sibling;\n-\t  h = h->outer;\n-\t}\n-    }\n-  else\n-    {\n-      h = &whole_range;\n-      cache_next_child = h->first_child;\n-    }\n-  return find_handler_in_range (pc, h, cache_next_child);\n-}\n-\n-static void\n-free_eh_ranges (struct eh_range *range)\n-{\n-  while (range) \n-    {\n-      struct eh_range *next = range->next_sibling;\n-      free_eh_ranges (range->first_child);\n-      if (range != &whole_range)\n-\tfree (range);\n-      range = next;\n-    }\n-}\n-\n-/* Called to re-initialize the exception machinery for a new method. */\n-\n-void\n-method_init_exceptions (void)\n-{\n-  free_eh_ranges (&whole_range);\n-  whole_range.start_pc = 0;\n-  whole_range.end_pc = DECL_CODE_LENGTH (current_function_decl) + 1;\n-  whole_range.outer = NULL;\n-  whole_range.first_child = NULL;\n-  whole_range.next_sibling = NULL;\n-  cache_range_start = 0xFFFFFF;\n-}\n-\n-/* Split an exception range into two at PC.  The sub-ranges that\n-   belong to the range are split and distributed between the two new\n-   ranges.  */\n-\n-static void\n-split_range (struct eh_range *range, int pc)\n-{\n-  struct eh_range *ptr;\n-  struct eh_range **first_child, **second_child;\n-  struct eh_range *h;\n-\n-  /* First, split all the sub-ranges.  */\n-  for (ptr = range->first_child; ptr; ptr = ptr->next_sibling)\n-    {\n-      if (pc > ptr->start_pc\n-\t  && pc < ptr->end_pc)\n-\t{\n-\t  split_range (ptr, pc);\n-\t}\n-    }\n-\n-  /* Create a new range.  */\n-  h = XNEW (struct eh_range);\n-\n-  h->start_pc = pc;\n-  h->end_pc = range->end_pc;\n-  h->next_sibling = range->next_sibling;\n-  range->next_sibling = h;\n-  range->end_pc = pc;\n-  h->handlers = build_tree_list (TREE_PURPOSE (range->handlers),\n-\t\t\t\t TREE_VALUE (range->handlers));\n-  h->next_sibling = NULL;\n-  h->expanded = 0;\n-  h->stmt = NULL;\n-  h->outer = range->outer;\n-  h->first_child = NULL;\n-\n-  ptr = range->first_child;\n-  first_child = &range->first_child;\n-  second_child = &h->first_child;\n-\n-  /* Distribute the sub-ranges between the two new ranges.  */\n-  for (ptr = range->first_child; ptr; ptr = ptr->next_sibling)\n-    {\n-      if (ptr->start_pc < pc)\n-\t{\n-\t  *first_child = ptr;\n-\t  ptr->outer = range;\n-\t  first_child = &ptr->next_sibling;\n-\t}\n-      else\n-\t{\n-\t  *second_child = ptr;\n-\t  ptr->outer = h;\n-\t  second_child = &ptr->next_sibling;\n-\t}\n-    }\n-  *first_child = NULL;\n-  *second_child = NULL;\n-}  \n-\n-\n-/* Add an exception range. \n-\n-   There are some missed optimization opportunities here.  For\n-   example, some bytecode obfuscators generate seemingly\n-   nonoverlapping exception ranges which, when coalesced, do in fact\n-   nest correctly.  We could merge these, but we'd have to fix up all\n-   the enclosed regions first and perhaps create a new range anyway if\n-   it overlapped existing ranges.\n-   \n-   Also, we don't attempt to detect the case where two previously\n-   added disjoint ranges could be coalesced by a new range.  */\n-\n-void \n-add_handler (int start_pc, int end_pc, tree handler, tree type)\n-{\n-  struct eh_range *ptr, *h;\n-  struct eh_range **first_child, **prev;\n-\n-  /* First, split all the existing ranges that we need to enclose.  */\n-  for (ptr = whole_range.first_child; ptr; ptr = ptr->next_sibling)\n-    {\n-      if (start_pc > ptr->start_pc\n-\t  && start_pc < ptr->end_pc)\n-\t{\n-\t  split_range (ptr, start_pc);\n-\t}\n-\n-      if (end_pc > ptr->start_pc\n-\t  && end_pc < ptr->end_pc)\n-\t{\n-\t  split_range (ptr, end_pc);\n-\t}\n-\n-      if (ptr->start_pc >= end_pc)\n-\tbreak;\n-    }\n-\n-  /* Create the new range.  */\n-  h = XNEW (struct eh_range);\n-  first_child = &h->first_child;\n-\n-  h->start_pc = start_pc;\n-  h->end_pc = end_pc;\n-  h->first_child = NULL;\n-  h->outer = NULL_EH_RANGE;\n-  h->handlers = build_tree_list (type, handler);\n-  h->next_sibling = NULL;\n-  h->expanded = 0;\n-  h->stmt = NULL;\n-\n-  /* Find every range at the top level that will be a sub-range of the\n-     range we're inserting and make it so.  */\n-  {\n-    struct eh_range **prev = &whole_range.first_child;\n-    for (ptr = *prev; ptr;)\n-      {\n-\tstruct eh_range *next = ptr->next_sibling;\n-\n-\tif (ptr->start_pc >= end_pc)\n-\t  break;\n-\n-\tif (ptr->start_pc < start_pc)\n-\t  {\n-\t    prev = &ptr->next_sibling;\n-\t  }\n-\telse if (ptr->start_pc >= start_pc\n-\t\t && ptr->start_pc < end_pc)\n-\t  {\n-\t    *prev = next;\n-\t    *first_child = ptr;\n-\t    first_child = &ptr->next_sibling;\n-\t    ptr->outer = h;\n-\t    ptr->next_sibling = NULL;\t  \n-\t  }\n-\n-\tptr = next;\n-      }\n-  }\n-\n-  /* Find the right place to insert the new range.  */\n-  prev = &whole_range.first_child;\n-  for (ptr = *prev; ptr; prev = &ptr->next_sibling, ptr = ptr->next_sibling)\n-    {\n-      gcc_assert (ptr->outer == NULL_EH_RANGE);\n-      if (ptr->start_pc >= start_pc)\n-\tbreak;\n-    }\n-\n-  /* And insert it there.  */\n-  *prev = h;\n-  if (ptr)\n-    {\n-      h->next_sibling = ptr;\n-      h->outer = ptr->outer;\n-    }\n-}\n-      \n-  \n-/* if there are any handlers for this range, issue start of region */\n-static void\n-expand_start_java_handler (struct eh_range *range)\n-{\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-  indent ();\n-  fprintf (stderr, \"expand start handler pc %d --> %d\\n\",\n-\t   current_pc, range->end_pc);\n-#endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n-  pushlevel (0);\n-  register_exception_range (range,  range->start_pc, range->end_pc);\n-  range->expanded = 1;\n-}\n-\n-tree\n-prepare_eh_table_type (tree type)\n-{\n-  tree exp;\n-  tree *slot;\n-  const char *name;\n-  char *buf;\n-  tree decl;\n-  tree utf8_ref;\n-\n-  /* The \"type\" (match_info) in a (Java) exception table is a pointer to:\n-   * a) NULL - meaning match any type in a try-finally.\n-   * b) a pointer to a pointer to a class.\n-   * c) a pointer to a pointer to a utf8_ref.  The pointer is\n-   * rewritten to point to the appropriate class.  */\n-\n-  if (type == NULL_TREE)\n-    return NULL_TREE;\n-\n-  if (TYPE_TO_RUNTIME_MAP (output_class) == NULL)\n-    TYPE_TO_RUNTIME_MAP (output_class) = java_treetreehash_create (10);\n-  \n-  slot = java_treetreehash_new (TYPE_TO_RUNTIME_MAP (output_class), type);\n-  if (*slot != NULL)\n-    return TREE_VALUE (*slot);\n-\n-  if (is_compiled_class (type) && !flag_indirect_dispatch)\n-    {\n-      name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-      buf = (char *) alloca (strlen (name) + 5);\n-      sprintf (buf, \"%s_ref\", name);\n-      decl = build_decl (input_location,\n-\t\t\t VAR_DECL, get_identifier (buf), ptr_type_node);\n-      TREE_STATIC (decl) = 1;\n-      DECL_ARTIFICIAL (decl) = 1;\n-      DECL_IGNORED_P (decl) = 1;\n-      TREE_READONLY (decl) = 1;\n-      TREE_THIS_VOLATILE (decl) = 0;\n-      DECL_INITIAL (decl) = build_class_ref (type);\n-      layout_decl (decl, 0);\n-      pushdecl (decl);\n-      exp = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (decl)), decl);\n-    }\n-  else\n-    {\n-      utf8_ref = build_utf8_ref (DECL_NAME (TYPE_NAME (type)));\n-      name = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (utf8_ref, 0)));\n-      buf = (char *) alloca (strlen (name) + 5);\n-      sprintf (buf, \"%s_ref\", name);\n-      decl = build_decl (input_location,\n-\t\t\t VAR_DECL, get_identifier (buf), utf8const_ptr_type);\n-      TREE_STATIC (decl) = 1;\n-      DECL_ARTIFICIAL (decl) = 1;\n-      DECL_IGNORED_P (decl) = 1;\n-      TREE_READONLY (decl) = 1;\n-      TREE_THIS_VOLATILE (decl) = 0;\n-      layout_decl (decl, 0);\n-      pushdecl (decl);\n-      exp = build1 (ADDR_EXPR, build_pointer_type (utf8const_ptr_type), decl);\n-      CONSTRUCTOR_APPEND_ELT (TYPE_CATCH_CLASSES (output_class),\n-\t\t\t      NULL_TREE,\n-\t\t\t      make_catch_class_record (exp, utf8_ref));\n-    }\n-\n-  exp = convert (ptr_type_node, exp);\n-\n-  *slot = tree_cons (type, exp, NULL_TREE);\n-\n-  return exp;\n-}\n-\n-int\n-expand_catch_class (treetreehash_entry **entry, int)\n-{\n-  struct treetreehash_entry *ite = *entry;\n-  tree addr = TREE_VALUE ((tree)ite->value);\n-  tree decl;\n-  STRIP_NOPS (addr);\n-  decl = TREE_OPERAND (addr, 0);\n-  rest_of_decl_compilation (decl, global_bindings_p (), 0);\n-  return true;\n-}\n-  \n-/* For every class in the TYPE_TO_RUNTIME_MAP, expand the\n-   corresponding object that is used by the runtime type matcher.  */\n-\n-void\n-java_expand_catch_classes (tree this_class)\n-{\n-  if (TYPE_TO_RUNTIME_MAP (this_class))\n-    TYPE_TO_RUNTIME_MAP (this_class)->traverse<int, expand_catch_class> (0);\n-}\n-\n-/* Build and push the variable that will hold the exception object\n-   within this function.  */\n-\n-static tree\n-build_exception_object_var (void)\n-{\n-  tree decl = DECL_FUNCTION_EXC_OBJ (current_function_decl);\n-  if (decl == NULL)\n-    {\n-      decl = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n-\t\t\t VAR_DECL, get_identifier (\"#exc_obj\"), ptr_type_node);\n-      DECL_IGNORED_P (decl) = 1;\n-      DECL_ARTIFICIAL (decl) = 1;\n-\n-      DECL_FUNCTION_EXC_OBJ (current_function_decl) = decl;\n-      pushdecl_function_level (decl);\n-    }\n-  return decl;\n-}\n-\n-/* Build a reference to the jthrowable object being carried in the\n-   exception header.  */\n-\n-tree\n-build_exception_object_ref (tree type)\n-{\n-  tree obj;\n-\n-  /* Java only passes object via pointer and doesn't require adjusting.\n-     The java object is immediately before the generic exception header.  */\n-  obj = build_exception_object_var ();\n-  obj = fold_convert (build_pointer_type (type), obj);\n-  obj = fold_build_pointer_plus (obj,\n-\t\tfold_build1 (NEGATE_EXPR, sizetype,\n-\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (obj))));\n-  obj = build1 (INDIRECT_REF, type, obj);\n-\n-  return obj;\n-}\n-\n-/* If there are any handlers for this range, issue end of range,\n-   and then all handler blocks */\n-void\n-expand_end_java_handler (struct eh_range *range)\n-{  \n-  tree handler = range->handlers;\n-  if (handler)\n-    {\n-      tree exc_obj = build_exception_object_var ();\n-      tree catches = make_node (STATEMENT_LIST);\n-      tree_stmt_iterator catches_i = tsi_last (catches);\n-      tree *body;\n-\n-      for (; handler; handler = TREE_CHAIN (handler))\n-\t{\n-\t  tree type, eh_type, x;\n-\t  tree stmts = make_node (STATEMENT_LIST);\n-\t  tree_stmt_iterator stmts_i = tsi_last (stmts);\n-\n-\t  type = TREE_PURPOSE (handler);\n-\t  if (type == NULL)\n-\t    type = throwable_type_node;\n-\t  eh_type = prepare_eh_table_type (type);\n-\n-\t  x = build_call_expr (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n-\t\t\t       1, integer_zero_node);\n-\t  x = build2 (MODIFY_EXPR, void_type_node, exc_obj, x);\n-\t  tsi_link_after (&stmts_i, x, TSI_CONTINUE_LINKING);\n-\n-\t  x = build1 (GOTO_EXPR, void_type_node, TREE_VALUE (handler));\n-\t  tsi_link_after (&stmts_i, x, TSI_CONTINUE_LINKING);\n-\n-\t  x = build2 (CATCH_EXPR, void_type_node, eh_type, stmts);\n-\t  tsi_link_after (&catches_i, x, TSI_CONTINUE_LINKING);\n-\n-\t  /* Throwable can match anything in Java, and therefore\n-\t     any subsequent handlers are unreachable.  */\n-\t  /* ??? If we're assured of no foreign language exceptions,\n-\t     we'd be better off using NULL as the exception type\n-\t     for the catch.  */\n-\t  if (type == throwable_type_node)\n-\t    break;\n-\t}\n-\n-      body = get_stmts ();\n-      *body = build2 (TRY_CATCH_EXPR, void_type_node, *body, catches);\n-    }\n-\n-#if defined(DEBUG_JAVA_BINDING_LEVELS)\n-  indent ();\n-  fprintf (stderr, \"expand end handler pc %d <-- %d\\n\",\n-\t   current_pc, range->start_pc);\n-#endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n-}\n-\n-/* Recursive helper routine for maybe_start_handlers. */\n-\n-static void\n-check_start_handlers (struct eh_range *range, int pc)\n-{\n-  if (range != NULL_EH_RANGE && range->start_pc == pc)\n-    {\n-      check_start_handlers (range->outer, pc);\n-      if (!range->expanded)\n-\texpand_start_java_handler (range);\n-    }\n-}\n-\n-\n-/* Routine to see if exception handling is turned on.\n-   DO_WARN is nonzero if we want to inform the user that exception\n-   handling is turned off.\n-\n-   This is used to ensure that -fexceptions has been specified if the\n-   compiler tries to use any exception-specific functions.  */\n-\n-static inline int\n-doing_eh (void)\n-{\n-  if (! flag_exceptions)\n-    {\n-      static int warned = 0;\n-      if (! warned)\n-\t{\n-\t  error (\"exception handling disabled, use -fexceptions to enable\");\n-\t  warned = 1;\n-\t}\n-      return 0;\n-    }\n-  return 1;\n-}\n-\n-static struct eh_range *current_range;\n-\n-/* Emit any start-of-try-range starting at start_pc and ending after\n-   end_pc. */\n-\n-void\n-maybe_start_try (int start_pc, int end_pc)\n-{\n-  struct eh_range *range;\n-  if (! doing_eh ())\n-    return;\n-\n-  range = find_handler (start_pc);\n-  while (range != NULL_EH_RANGE && range->start_pc == start_pc\n-\t && range->end_pc < end_pc)\n-    range = range->outer;\n-\t \n-  current_range = range;\n-  check_start_handlers (range, start_pc);\n-}\n-"}, {"sha": "ba798ca3165087d7318ad9029d3ff54691b7432b", "filename": "gcc/java/expr.c", "status": "removed", "additions": 0, "deletions": 3760, "changes": 3760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c9fc8057af179671c49b9990cec7b5a53155c9e2", "filename": "gcc/java/gcj.texi", "status": "removed", "additions": 0, "deletions": 2733, "changes": 2733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,2733 +0,0 @@\n-\\input texinfo @c -*-texinfo-*-\n-@setfilename gcj.info\n-@settitle Guide to GNU gcj\n-\n-@c Merge the standard indexes into a single one.\n-@syncodeindex fn cp\n-@syncodeindex vr cp\n-@syncodeindex ky cp\n-@syncodeindex pg cp\n-@syncodeindex tp cp\n-\n-@include gcc-common.texi\n-\n-@c Note: When reading this manual you'll find lots of strange\n-@c circumlocutions like ``compiler for the Java language''.\n-@c This is necessary due to Sun's restrictions on the use of\n-@c the word ``Java'.\n-\n-@c When this manual is copyrighted.\n-@set copyrights-gcj 2001-2016\n-\n-@copying\n-@c man begin COPYRIGHT\n-Copyright @copyright{} @value{copyrights-gcj} Free Software Foundation, Inc.\n-\n-Permission is granted to copy, distribute and/or modify this document\n-under the terms of the GNU Free Documentation License, Version 1.3 or\n-any later version published by the Free Software Foundation; with no\n-Invariant Sections, the Front-Cover Texts being (a) (see below), and\n-with the Back-Cover Texts being (b) (see below).\n-A copy of the license is included in the\n-@c man end\n-section entitled ``GNU Free Documentation License''.\n-@ignore\n-@c man begin COPYRIGHT\n-man page gfdl(7).\n-@c man end\n-@end ignore\n-\n-@c man begin COPYRIGHT\n-\n-(a) The FSF's Front-Cover Text is:\n-\n-     A GNU Manual\n-\n-(b) The FSF's Back-Cover Text is:\n-\n-     You have freedom to copy and modify this GNU Manual, like GNU\n-     software.  Copies published by the Free Software Foundation raise\n-     funds for GNU development.\n-@c man end\n-@end copying\n-\n-@ifinfo\n-@format\n-@dircategory Software development\n-@direntry\n-* Gcj: (gcj).               Ahead-of-time compiler for the Java language\n-@end direntry\n-\n-@dircategory Individual utilities\n-@direntry\n-* jcf-dump: (gcj)Invoking jcf-dump.\n-                            Print information about Java class files\n-* gij: (gcj)Invoking gij.   GNU interpreter for Java bytecode\n-* gcj-dbtool: (gcj)Invoking gcj-dbtool.\n-                            Tool for manipulating class file databases.\n-* jv-convert: (gcj)Invoking jv-convert.\n-                            Convert file from one encoding to another\n-* grmic: (gcj)Invoking grmic.\n-                            Generate stubs for Remote Method Invocation.\n-* gc-analyze: (gcj)Invoking gc-analyze.\n-                            Analyze Garbage Collector (GC) memory dumps.\n-* aot-compile: (gcj)Invoking aot-compile.\n-                            Compile bytecode to native and generate databases.\n-* rebuild-gcj-db: (gcj)Invoking rebuild-gcj-db.\n-                            Merge the per-solib databases made by aot-compile\n-                            into one system-wide database.\n-@end direntry\n-@end format\n-\n-@insertcopying\n-@end ifinfo\n-\n-@titlepage\n-@title GNU gcj\n-@versionsubtitle\n-@author Tom Tromey\n-\n-@page\n-@vskip 0pt plus 1filll\n-Published by the Free Software Foundation @*\n-51 Franklin Street, Fifth Floor@*\n-Boston, MA 02110-1301, USA@*\n-@sp 1\n-@insertcopying\n-@end titlepage\n-@contents\n-@page\n-\n-\n-@node Top\n-@top Introduction\n-\n-This manual describes how to use @command{gcj}, the GNU compiler for the\n-Java programming language.  @command{gcj} can generate both @file{.class}\n-files and object files, and it can read both Java source code and\n-@file{.class} files.\n-\n-@menu\n-* Copying::             The GNU General Public License\n-* GNU Free Documentation License::\n-                        How you can share and copy this manual\n-* Invoking gcj::        Compiler options supported by @command{gcj}\n-* Compatibility::       Compatibility between gcj and other tools for Java\n-* Invoking jcf-dump::   Print information about class files\n-* Invoking gij::        Interpreting Java bytecodes\n-* Invoking gcj-dbtool:: Tool for manipulating class file databases.\n-* Invoking jv-convert:: Converting from one encoding to another\n-* Invoking grmic::      Generate stubs for Remote Method Invocation.\n-* Invoking gc-analyze:: Analyze Garbage Collector (GC) memory dumps.\n-* Invoking aot-compile:: Compile bytecode to native and generate databases.\n-* Invoking rebuild-gcj-db:: Merge the per-solib databases made by aot-compile\n-                            into one system-wide database.\n-* About CNI::           Description of the Compiled Native Interface\n-* System properties::   Modifying runtime behavior of the libgcj library\n-* Resources::           Where to look for more information\n-* Index::               Index.\n-@end menu\n-\n-\n-@include gpl_v3.texi\n-\n-@include fdl.texi\n-\n-\n-@node Invoking gcj\n-@chapter Invoking gcj\n-\n-@c man title gcj Ahead-of-time compiler for the Java language\n-\n-@ignore\n-@c man begin SYNOPSIS gcj\n-gcj [@option{-I}@var{dir}@dots{}] [@option{-d} @var{dir}@dots{}]\n-    [@option{--CLASSPATH}=@var{path}] [@option{--classpath}=@var{path}]\n-    [@option{-f}@var{option}@dots{}] [@option{--encoding}=@var{name}]\n-    [@option{--main}=@var{classname}] [@option{-D}@var{name}[=@var{value}]@dots{}]\n-    [@option{-C}] [@option{--resource} @var{resource-name}] [@option{-d} @var{directory}]\n-    [@option{-W}@var{warn}@dots{}]\n-    @var{sourcefile}@dots{}\n-@c man end\n-@c man begin SEEALSO gcj\n-gcc(1), gcjh(1), gjnih(1), gij(1), jcf-dump(1), gfdl(7),\n-and the Info entries for @file{gcj} and @file{gcc}.\n-@c man end\n-@end ignore\n-\n-@c man begin DESCRIPTION gcj\n-\n-As @command{gcj} is just another front end to @command{gcc}, it supports many\n-of the same options as gcc.  @xref{Option Summary, , Option Summary,\n-gcc, Using the GNU Compiler Collection (GCC)}.  This manual only documents the\n-options specific to @command{gcj}.\n-\n-@c man end\n-\n-@menu\n-* Input and output files::\n-* Input Options::               How gcj finds files\n-* Encodings::                   Options controlling source file encoding\n-* Warnings::                    Options controlling warnings specific to gcj\n-* Linking::                     Options for making an executable\n-* Code Generation::             Options controlling the output of gcj\n-* Configure-time Options::      Options you won't use\n-@end menu\n-\n-@c man begin OPTIONS gcj\n-\n-@node Input and output files\n-@section Input and output files\n-\n-A @command{gcj} command is like a @command{gcc} command, in that it\n-consists of a number of options and file names.  The following kinds\n-of input file names are supported:\n-\n-@table @gcctabopt\n-@item @var{file}.java\n-Java source files.\n-@item @var{file}.class\n-Java bytecode files.\n-@item @var{file}.zip\n-@itemx @var{file}.jar\n-An archive containing one or more @code{.class} files, all of\n-which are compiled.  The archive may be compressed.  Files in\n-an archive which don't end with @samp{.class} are treated as\n-resource files; they are compiled into the resulting object file\n-as @samp{core:} URLs.\n-@item @@@var{file}\n-A file containing a whitespace-separated list of input file names.\n-(Currently, these must all be @code{.java} source files, but that\n-may change.)\n-Each named file is compiled, just as if it had been on the command line.\n-@item @var{library}.a\n-@itemx @var{library}.so\n-@itemx -l@var{libname}\n-Libraries to use when linking.  See the @command{gcc} manual.\n-@end table\n-\n-You can specify more than one input file on the @command{gcj} command line,\n-in which case they will all be compiled.  If you specify a\n-@code{-o @var{FILENAME}}\n-option, all the input files will be compiled together, producing a\n-single output file, named @var{FILENAME}.\n-This is allowed even when using @code{-S} or @code{-c},\n-but not when using @code{-C} or @code{--resource}.\n-(This is an extension beyond the what plain @command{gcc} allows.)\n-(If more than one input file is specified, all must currently\n-be @code{.java} files, though we hope to fix this.)\n-\n-@node Input Options\n-@section Input Options\n-\n-@cindex class path\n-\n-@command{gcj} has options to control where it looks to find files it needs.\n-For instance, @command{gcj} might need to load a class that is referenced\n-by the file it has been asked to compile.  Like other compilers for the\n-Java language, @command{gcj} has a notion of a @dfn{class path}.  There are\n-several options and environment variables which can be used to\n-manipulate the class path.  When @command{gcj} looks for a given class, it\n-searches the class path looking for matching @file{.class} or\n-@file{.java} file.  @command{gcj} comes with a built-in class path which\n-points at the installed @file{libgcj.jar}, a file which contains all the\n-standard classes.\n-\n-In the text below, a directory or path component can refer either to an\n-actual directory on the filesystem, or to a @file{.zip} or @file{.jar}\n-file, which @command{gcj} will search as if it is a directory.\n-\n-@table @gcctabopt\n-@item -I@var{dir}\n-All directories specified by @code{-I} are kept in order and prepended\n-to the class path constructed from all the other options.  Unless\n-compatibility with tools like @code{javac} is important, we recommend\n-always using @code{-I} instead of the other options for manipulating the\n-class path.\n-\n-@item --classpath=@var{path}\n-This sets the class path to @var{path}, a colon-separated list of paths\n-(on Windows-based systems, a semicolon-separate list of paths).\n-This does not override the builtin (``boot'') search path.\n-\n-@item --CLASSPATH=@var{path}\n-Deprecated synonym for @code{--classpath}.\n-\n-@item --bootclasspath=@var{path}\n-Where to find the standard builtin classes, such as @code{java.lang.String}.\n-\n-@item --extdirs=@var{path}\n-For each directory in the @var{path}, place the contents of that\n-directory at the end of the class path.\n-\n-@item CLASSPATH\n-This is an environment variable which holds a list of paths.\n-@end table\n-\n-The final class path is constructed like so:\n-\n-@itemize @bullet\n-@item\n-First come all directories specified via @code{-I}.\n-\n-@item\n-If @option{--classpath} is specified, its value is appended.\n-Otherwise, if the @code{CLASSPATH} environment variable is specified,\n-then its value is appended.\n-Otherwise, the current directory (@code{\".\"}) is appended.\n-\n-@item\n-If @code{--bootclasspath} was specified, append its value.\n-Otherwise, append the built-in system directory, @file{libgcj.jar}.\n-\n-@item\n-Finally, if @code{--extdirs} was specified, append the contents of the\n-specified directories at the end of the class path.  Otherwise, append\n-the contents of the built-in extdirs at @code{$(prefix)/share/java/ext}.\n-@end itemize\n-\n-The classfile built by @command{gcj} for the class @code{java.lang.Object}\n-(and placed in @code{libgcj.jar}) contains a special zero length\n-attribute @code{gnu.gcj.gcj-compiled}. The compiler looks for this\n-attribute when loading @code{java.lang.Object} and will report an error\n-if it isn't found, unless it compiles to bytecode (the option\n-@code{-fforce-classes-archive-check} can be used to override this\n-behavior in this particular case.)\n-\n-@table @gcctabopt\n-@item -fforce-classes-archive-check\n-This forces the compiler to always check for the special zero length\n-attribute @code{gnu.gcj.gcj-compiled} in @code{java.lang.Object} and\n-issue an error if it isn't found.\n-\n-@item -fsource=@var{VERSION}\n-This option is used to choose the source version accepted by\n-@command{gcj}.  The default is @samp{1.5}.\n-@end table\n-\n-@node Encodings\n-@section Encodings\n-\n-The Java programming language uses Unicode throughout.  In an effort to\n-integrate well with other locales, @command{gcj} allows @file{.java} files\n-to be written using almost any encoding.  @command{gcj} knows how to\n-convert these encodings into its internal encoding at compile time.\n-\n-You can use the @code{--encoding=@var{NAME}} option to specify an\n-encoding (of a particular character set) to use for source files.  If\n-this is not specified, the default encoding comes from your current\n-locale.  If your host system has insufficient locale support, then\n-@command{gcj} assumes the default encoding to be the @samp{UTF-8} encoding\n-of Unicode.\n-\n-To implement @code{--encoding}, @command{gcj} simply uses the host\n-platform's @code{iconv} conversion routine.  This means that in practice\n-@command{gcj} is limited by the capabilities of the host platform.\n-\n-The names allowed for the argument @code{--encoding} vary from platform\n-to platform (since they are not standardized anywhere).  However,\n-@command{gcj} implements the encoding named @samp{UTF-8} internally, so if\n-you choose to use this for your source files you can be assured that it\n-will work on every host.\n-\n-\n-@node Warnings\n-@section Warnings\n-\n-@command{gcj} implements several warnings.  As with other generic\n-@command{gcc} warnings, if an option of the form @code{-Wfoo} enables a\n-warning, then @code{-Wno-foo} will disable it.  Here we've chosen to\n-document the form of the warning which will have an effect -- the\n-default being the opposite of what is listed.\n-\n-@table @gcctabopt\n-@item -Wredundant-modifiers\n-With this flag, @command{gcj} will warn about redundant modifiers.  For\n-instance, it will warn if an interface method is declared @code{public}.\n-\n-@item -Wextraneous-semicolon\n-This causes @command{gcj} to warn about empty statements.  Empty statements\n-have been deprecated.\n-\n-@item -Wno-out-of-date\n-This option will cause @command{gcj} not to warn when a source file is\n-newer than its matching class file.  By default @command{gcj} will warn\n-about this.\n-\n-@item -Wno-deprecated\n-Warn if a deprecated class, method, or field is referred to.\n-\n-@item -Wunused\n-This is the same as @command{gcc}'s @code{-Wunused}.\n-\n-@item -Wall\n-This is the same as @code{-Wredundant-modifiers -Wextraneous-semicolon\n--Wunused}.\n-@end table\n-\n-\n-@node Linking\n-@section Linking\n-\n-To turn a Java application into an executable program,\n-you need to link it with the needed libraries, just as for C or C++.\n-The linker by default looks for a global function named @code{main}.\n-Since Java does not have global functions, and a\n-collection of Java classes may have more than one class with a\n-@code{main} method, you need to let the linker know which of those\n-@code{main} methods it should invoke when starting the application.\n-You can do that in any of these ways:\n-\n-@itemize @bullet\n-@item\n-Specify the class containing the desired @code{main} method\n-when you link the application, using the @code{--main} flag,\n-described below.\n-@item\n-Link the Java package(s) into a shared library (dll) rather than an\n-executable.  Then invoke the application using the @code{gij} program,\n-making sure that @code{gij} can find the libraries it needs.\n-@item\n-Link the Java packages(s) with the flag @code{-lgij}, which links\n-in the @code{main} routine from the @code{gij} command.\n-This allows you to select the class whose @code{main} method you\n-want to run when you run the application.  You can also use\n-other @code{gij} flags, such as @code{-D} flags to set properties.\n-Using the @code{-lgij} library (rather than the @code{gij} program\n-of the previous mechanism) has some advantages: it is compatible with\n-static linking, and does not require configuring or installing libraries.\n-@end itemize\n-\n-These @code{gij} options relate to linking an executable:\n-\n-@table @gcctabopt\n-@item --main=@var{CLASSNAME}\n-This option is used when linking to specify the name of the class whose\n-@code{main} method should be invoked when the resulting executable is\n-run.\n-\n-@item -D@var{name}[=@var{value}]\n-This option can only be used with @code{--main}.  It defines a system\n-property named @var{name} with value @var{value}.  If @var{value} is not\n-specified then it defaults to the empty string.  These system properties\n-are initialized at the program's startup and can be retrieved at runtime\n-using the @code{java.lang.System.getProperty} method.\n-\n-@item -lgij\n-Create an application whose command-line processing is that\n-of the @code{gij} command.\n-\n-This option is an alternative to using @code{--main}; you cannot use both.\n-\n-@item -static-libgcj\n-This option causes linking to be done against a static version of the\n-libgcj runtime library.  This option is only available if\n-corresponding linker support exists.\n-\n-@strong{Caution:} Static linking of libgcj may cause essential parts\n-of libgcj to be omitted.  Some parts of libgcj use reflection to load\n-classes at runtime.  Since the linker does not see these references at\n-link time, it can omit the referred to classes.  The result is usually\n-(but not always) a @code{ClassNotFoundException} being thrown at\n-runtime. Caution must be used when using this option.  For more\n-details see:\n-@w{@uref{http://gcc.gnu.org/wiki/Statically%20linking%20libgcj}}\n-@end table\n-\n-@node Code Generation\n-@section Code Generation\n-\n-In addition to the many @command{gcc} options controlling code generation,\n-@command{gcj} has several options specific to itself.\n-\n-@table @gcctabopt\n-\n-@item -C\n-This option is used to tell @command{gcj} to generate bytecode\n-(@file{.class} files) rather than object code.\n-\n-@item --resource @var{resource-name}\n-This option is used to tell @command{gcj} to compile the contents of a\n-given file to object code so it may be accessed at runtime with the core\n-protocol handler as @samp{core:/@var{resource-name}}.  Note that\n-@var{resource-name} is the name of the resource as found at runtime; for\n-instance, it could be used in a call to @code{ResourceBundle.getBundle}.\n-The actual file name to be compiled this way must be specified\n-separately.\n-\n-@item -ftarget=@var{VERSION}\n-This can be used with @option{-C} to choose the version of bytecode\n-emitted by @command{gcj}.  The default is @samp{1.5}.  When not\n-generating bytecode, this option has no effect.\n-\n-@item -d @var{directory}\n-When used with @code{-C}, this causes all generated @file{.class} files\n-to be put in the appropriate subdirectory of @var{directory}.  By\n-default they will be put in subdirectories of the current working\n-directory.\n-\n-@item -fno-bounds-check\n-By default, @command{gcj} generates code which checks the bounds of all\n-array indexing operations.  With this option, these checks are omitted, which\n-can improve performance for code that uses arrays extensively.  Note that this \n-can result in unpredictable behavior if the code in question actually does \n-violate array bounds constraints.  It is safe to use this option if you are \n-sure that your code will never throw an @code{ArrayIndexOutOfBoundsException}.\n-\n-@item -fno-store-check\n-Don't generate array store checks.  When storing objects into arrays, a runtime\n-check is normally generated in order to ensure that the object is assignment\n-compatible with the component type of the array (which may not be known\n-at compile-time).  With this option, these checks are omitted.  This can \n-improve performance for code which stores objects into arrays frequently.\n-It is safe to use this option if you are sure your code will never throw an \n-@code{ArrayStoreException}.\n-\n-@item -fjni\n-With @command{gcj} there are two options for writing native methods: CNI\n-and JNI@.  By default @command{gcj} assumes you are using CNI@.  If you are\n-compiling a class with native methods, and these methods are implemented\n-using JNI, then you must use @code{-fjni}.  This option causes\n-@command{gcj} to generate stubs which will invoke the underlying JNI\n-methods.\n-\n-@item -fno-assert\n-Don't recognize the @code{assert} keyword.  This is for compatibility\n-with older versions of the language specification.\n-\n-@item -fno-optimize-static-class-initialization\n-When the optimization level is greater or equal to @code{-O2},\n-@command{gcj} will try to optimize the way calls into the runtime are made\n-to initialize static classes upon their first use (this optimization\n-isn't carried out if @code{-C} was specified.) When compiling to native\n-code, @code{-fno-optimize-static-class-initialization} will turn this\n-optimization off, regardless of the optimization level in use.\n-\n-@item --disable-assertions[=@var{class-or-package}]\n-Don't include code for checking assertions in the compiled code.\n-If @code{=@var{class-or-package}} is missing disables assertion code\n-generation for all classes, unless overridden by a more\n-specific @code{--enable-assertions} flag.\n-If @var{class-or-package} is a class name, only disables generating\n-assertion checks within the named class or its inner classes.\n-If @var{class-or-package} is a package name, disables generating\n-assertion checks within the named package or a subpackage.\n-\n-By default, assertions are enabled when generating class files\n-or when not optimizing, and disabled when generating optimized binaries.\n-\n-@item --enable-assertions[=@var{class-or-package}]\n-Generates code to check assertions.  The option is perhaps misnamed,\n-as you still need to turn on assertion checking at run-time,\n-and we don't support any easy way to do that.\n-So this flag isn't very useful yet, except to partially override\n-@code{--disable-assertions}.\n-\n-@item -findirect-dispatch\n-@command{gcj} has a special binary compatibility ABI, which is enabled\n-by the @code{-findirect-dispatch} option.  In this mode, the code\n-generated by @command{gcj} honors the binary compatibility guarantees\n-in the Java Language Specification, and the resulting object files do\n-not need to be directly linked against their dependencies.  Instead,\n-all dependencies are looked up at runtime.  This allows free mixing of\n-interpreted and compiled code.\n-\n-Note that, at present, @code{-findirect-dispatch} can only be used\n-when compiling @file{.class} files.  It will not work when compiling\n-from source.  CNI also does not yet work with the binary compatibility\n-ABI.  These restrictions will be lifted in some future release.\n-\n-However, if you compile CNI code with the standard ABI, you can call\n-it from code built with the binary compatibility ABI.\n-\n-@item -fbootstrap-classes\n-This option can be use to tell @code{libgcj} that the compiled classes\n-should be loaded by the bootstrap loader, not the system class loader.\n-By default, if you compile a class and link it into an executable, it\n-will be treated as if it was loaded using the system class loader.\n-This is convenient, as it means that things like\n-@code{Class.forName()} will search @samp{CLASSPATH} to find the\n-desired class.\n-\n-@item -freduced-reflection\n-This option causes the code generated by @command{gcj} to contain a\n-reduced amount of the class meta-data used to support runtime\n-reflection. The cost of this savings is the loss of\n-the ability to use certain reflection capabilities of the standard\n-Java runtime environment. When set all meta-data except for that\n-which is needed to obtain correct runtime semantics is eliminated.\n-\n-For code that does not use reflection (i.e. serialization, RMI, CORBA\n-or call methods in the @code{java.lang.reflect} package),\n-@code{-freduced-reflection} will result in proper operation with a\n-savings in executable code size.\n-\n-JNI (@code{-fjni}) and the binary compatibility ABI\n-(@code{-findirect-dispatch}) do not work properly without full\n-reflection meta-data.  Because of this, it is an error to use these options\n-with @code{-freduced-reflection}.\n-\n-@strong{Caution:} If there is no reflection meta-data, code that uses\n-a @code{SecurityManager} may not work properly.  Also calling\n-@code{Class.forName()} may fail if the calling method has no\n-reflection meta-data.\n-\n-@end table\n-\n-\n-@node Configure-time Options\n-@section Configure-time Options\n-\n-Some @command{gcj} code generations options affect the resulting ABI, and\n-so can only be meaningfully given when @code{libgcj}, the runtime\n-package, is configured.  @code{libgcj} puts the appropriate options from\n-this group into a @samp{spec} file which is read by @command{gcj}.  These\n-options are listed here for completeness; if you are using @code{libgcj}\n-then you won't want to touch these options.\n-\n-@table @gcctabopt\n-@item -fuse-boehm-gc\n-This enables the use of the Boehm GC bitmap marking code.  In particular\n-this causes @command{gcj} to put an object marking descriptor into each\n-vtable.\n-\n-@item -fhash-synchronization\n-By default, synchronization data (the data used for @code{synchronize},\n-@code{wait}, and @code{notify}) is pointed to by a word in each object.\n-With this option @command{gcj} assumes that this information is stored in a\n-hash table and not in the object itself.\n-\n-@item -fuse-divide-subroutine\n-On some systems, a library routine is called to perform integer\n-division.  This is required to get exception handling correct when\n-dividing by zero.\n-\n-@item -fcheck-references\n-On some systems it's necessary to insert inline checks whenever\n-accessing an object via a reference.  On other systems you won't need\n-this because null pointer accesses are caught automatically by the\n-processor.\n-\n-@item -fuse-atomic-builtins\n-On some systems, GCC can generate code for built-in atomic operations.\n-Use this option to force gcj to use these builtins when compiling Java\n-code.  Where this capability is present it should be automatically\n-detected, so you won't usually need to use this option.\n-\n-@end table\n-\n-@c man end\n-\n-@node Compatibility\n-@chapter Compatibility with the Java Platform\n-\n-As we believe it is important that the Java platform not be fragmented,\n-@command{gcj} and @code{libgcj} try to conform to the relevant Java\n-specifications.  However, limited manpower and incomplete and unclear\n-documentation work against us.  So, there are caveats to using\n-@command{gcj}.\n-\n-@menu\n-* Limitations::                 \n-* Extensions::                  \n-@end menu\n-\n-@node Limitations\n-@section Standard features not yet supported\n-\n-This list of compatibility issues is by no means complete.\n-\n-@itemize @bullet\n-@item\n-@command{gcj} implements the JDK 1.2 language.  It supports inner classes\n-and the new 1.4 @code{assert} keyword.  It does not yet support the Java 2\n-@code{strictfp} keyword (it recognizes the keyword but ignores it).  \n-\n-@item\n-@code{libgcj} is largely compatible with the JDK 1.2 libraries.\n-However, @code{libgcj} is missing many packages, most notably\n-@code{java.awt}.  There are also individual missing classes and methods.\n-We currently do not have a list showing differences between\n-@code{libgcj} and the Java 2 platform.\n-\n-@item\n-Sometimes the @code{libgcj} implementation of a method or class differs\n-from the JDK implementation.  This is not always a bug.  Still, if it\n-affects you, it probably makes sense to report it so that we can discuss\n-the appropriate response.\n-\n-@item\n-@command{gcj} does not currently allow for piecemeal replacement of\n-components within @code{libgcj}. Unfortunately, programmers often want\n-to use newer versions of certain packages, such as those provided by\n-the Apache Software Foundation's Jakarta project.  This has forced us\n-to place the @code{org.w3c.dom} and @code{org.xml.sax} packages into\n-their own libraries, separate from @code{libgcj}.  If you intend to\n-use these classes, you must link them explicitly with\n-@code{-l-org-w3c-dom} and @code{-l-org-xml-sax}.  Future versions of\n-@command{gcj} may not have this restriction.\n-@end itemize\n-\n-@node Extensions\n-@section Extra features unique to gcj\n-\n-The main feature of @command{gcj} is that it can compile programs written in\n-the Java programming language to native code.  Most extensions that have been\n-added are to facilitate this functionality.\n-\n-@itemize @bullet\n-@item\n-@command{gcj} makes it easy and efficient to mix code written in Java and C++.\n-@xref{About CNI}, for more info on how to use this in your programs.\n-\n-@item\n-When you compile your classes into a shared library using\n-@code{-findirect-dispatch} then add them to the system-wide\n-classmap.db file using @code{gcj-dbtool}, they will be automatically\n-loaded by the @code{libgcj} system classloader.  This is the new,\n-preferred classname-to-library resolution mechanism.  @xref{Invoking\n-gcj-dbtool}, for more information on using the classmap database.\n-\n-@item\n-The old classname-to-library lookup mechanism is still supported\n-through the @code{gnu.gcj.runtime.VMClassLoader.library_control}\n-property, but it is deprecated and will likely be removed in some\n-future release.  When trying to load a class @code{gnu.pkg.SomeClass}\n-the system classloader will first try to load the shared library\n-@file{lib-gnu-pkg-SomeClass.so}, if that fails to load the class then\n-it will try to load @file{lib-gnu-pkg.so} and finally when the class\n-is still not loaded it will try to load @file{lib-gnu.so}.  Note that\n-all @samp{.}s will be transformed into @samp{-}s and that searching\n-for inner classes starts with their outermost outer class.  If the\n-class cannot be found this way the system classloader tries to use the\n-@code{libgcj} bytecode interpreter to load the class from the standard\n-classpath.  This process can be controlled to some degree via the\n-@code{gnu.gcj.runtime.VMClassLoader.library_control} property;\n-@xref{libgcj Runtime Properties}.\n-\n-@item\n-@code{libgcj} includes a special @samp{gcjlib} URL type.  A URL of\n-this form is like a @code{jar} URL, and looks like\n-@samp{gcjlib:/path/to/shared/library.so!/path/to/resource}.  An access\n-to one of these URLs causes the shared library to be @code{dlopen()}d,\n-and then the resource is looked for in that library.  These URLs are\n-most useful when used in conjunction with @code{java.net.URLClassLoader}.\n-Note that, due to implementation limitations, currently any such URL\n-can be accessed by only one class loader, and libraries are never\n-unloaded.  This means some care must be exercised to make sure that\n-a @code{gcjlib} URL is not accessed by more than one class loader at once.\n-In a future release this limitation will be lifted, and such\n-libraries will be mapped privately.\n-\n-@item\n-A program compiled by @command{gcj} will examine the\n-@env{GCJ_PROPERTIES} environment variable and change its behavior in\n-some ways.  In particular @env{GCJ_PROPERTIES} holds a list of\n-assignments to global properties, such as would be set with the\n-@option{-D} option to @command{java}.  For instance,\n-@samp{java.compiler=gcj} is a valid (but currently meaningless)\n-setting.\n-@cindex GCJ_PROPERTIES\n-@vindex GCJ_PROPERTIES\n-\n-@end itemize\n-\n-\n-@node Invoking jcf-dump\n-@chapter Invoking jcf-dump\n-\n-@c man title jcf-dump print information about Java class files\n-\n-@ignore\n-@c man begin SYNOPSIS jcf-dump\n-jcf-dump [@option{-c}] [@option{--javap}]\n-    [@option{--classpath}=@var{path}] [@option{--CLASSPATH}=@var{path}]\n-    [@option{-I}@var{dir}@dots{}] [@option{-o} @var{file}]\n-    [@option{--version}] [@option{--help}] [@option{-v}] [@option{--verbose}]\n-    @var{classname}@dots{}\n-@c man end\n-@c man begin SEEALSO jcf-dump\n-gcc(1), gcj(1), gcjh(1), gij(1), jcf-dump(1), gfdl(7),\n-and the Info entries for @file{gcj} and @file{gcc}.\n-@c man end\n-@end ignore\n-\n-@c man begin DESCRIPTION jcf-dump\n-\n-This is a class file examiner, similar to @code{javap}.  It will print\n-information about a number of classes, which are specified by class name\n-or file name.\n-\n-@c man end\n-\n-@c man begin OPTIONS jcf-dump\n-\n-@table @gcctabopt\n-@item -c\n-Disassemble method bodies.  By default method bodies are not printed.\n-\n-@item --print-constants\n-Print the constant pool.  When printing a reference to a constant\n-also print its index in the constant pool.\n-\n-@item --javap\n-Generate output in @code{javap} format.  The implementation of this\n-feature is very incomplete.\n-\n-@item --classpath=@var{path}\n-@itemx --CLASSPATH=@var{path}\n-@itemx -I@var{directory}\n-@itemx -o @var{file}\n-These options as the same as the corresponding @command{gcj} options.\n-\n-@item --help\n-Print help, then exit.\n-\n-@item --version\n-Print version number, then exit.\n-\n-@item -v, --verbose\n-Print extra information while running.\n-Implies @code{--print-constants}.\n-@end table\n-\n-@c man end\n-\n-@node Invoking gij\n-@chapter Invoking gij\n-\n-@c man title gij GNU interpreter for Java bytecode\n-\n-@ignore\n-@c man begin SYNOPSIS gij\n-gij [@option{OPTION}] @dots{} @var{JARFILE} [@var{ARGS}@dots{}]\n-\n-gij [@option{-jar}] [@option{OPTION}] @dots{} @var{CLASS} [@var{ARGS}@dots{}]\n-  [@option{-cp} @var{path}] [@option{-classpath} @var{path}]\n-  [@option{-D}@var{name}[=@var{value}]@dots{}]\n-  [@option{-ms=}@var{number}] [@option{-mx=}@var{number}]\n-  [@option{-X@var{argument}}] [@option{-verbose}] [@option{-verbose:class}]\n-  [@option{--showversion}] [@option{--version}] [@option{--help}][@option{-?}]\n-@c man end\n-@c man begin SEEALSO gij\n-gcc(1), gcj(1), gcjh(1), jcf-dump(1), gfdl(7),\n-and the Info entries for @file{gcj} and @file{gcc}.\n-@c man end\n-@end ignore\n-\n-@c man begin DESCRIPTION gij\n-\n-@code{gij} is a Java bytecode interpreter included with @code{libgcj}.\n-@code{gij} is not available on every platform; porting it requires a\n-small amount of assembly programming which has not been done for all the\n-targets supported by @command{gcj}.\n-\n-The primary argument to @code{gij} is the name of a class or, with\n-@code{-jar}, a jar file.  Options before this argument are interpreted\n-by @code{gij}; remaining options are passed to the interpreted program.\n-\n-If a class name is specified and this class does not have a @code{main}\n-method with the appropriate signature (a @code{static void} method with\n-a @code{String[]} as its sole argument), then @code{gij} will print an\n-error and exit.\n-\n-If a jar file is specified then @code{gij} will use information in it to\n-determine which class' @code{main} method will be invoked.\n-\n-@code{gij} will invoke the @code{main} method with all the remaining\n-command-line options.\n-\n-Note that @code{gij} is not limited to interpreting code.  Because\n-@code{libgcj} includes a class loader which can dynamically load shared\n-objects, it is possible to give @code{gij} the name of a class which has\n-been compiled and put into a shared library on the class path.\n-\n-@c man end\n-\n-@c man begin OPTIONS gij\n-\n-@table @gcctabopt\n-@item -cp @var{path}\n-@itemx -classpath @var{path}\n-Set the initial class path.  The class path is used for finding\n-class and resource files.  If specified, this option overrides the\n-@code{CLASSPATH} environment variable.  Note that this option is\n-ignored if @code{-jar} is used.\n-\n-@item -D@var{name}[=@var{value}]\n-This defines a system property named @var{name} with value @var{value}.\n-If @var{value} is not specified then it defaults to the empty string.\n-These system properties are initialized at the program's startup and can\n-be retrieved at runtime using the @code{java.lang.System.getProperty}\n-method.\n-\n-@item -ms=@var{number}\n-Equivalent to @code{-Xms}.\n-\n-@item -mx=@var{number}\n-Equivalent to @code{-Xmx}.\n-\n-@item -noverify\n-Do not verify compliance of bytecode with the VM specification. In addition,\n-this option disables type verification which is otherwise performed on BC-ABI\n-compiled code.\n-\n-@item -X\n-@itemx -X@var{argument}\n-Supplying @code{-X} by itself will cause @code{gij} to list all the\n-supported @code{-X} options.  Currently these options are supported:\n-\n-@table @gcctabopt\n-@item -Xms@var{size}\n-Set the initial heap size.\n-\n-@item -Xmx@var{size}\n-Set the maximum heap size.\n-\n-@item -Xss@var{size}\n-Set the thread stack size.\n-@end table\n-\n-Unrecognized @code{-X} options are ignored, for compatibility with\n-other runtimes.\n-\n-@item -jar\n-This indicates that the name passed to @code{gij} should be interpreted\n-as the name of a jar file, not a class.\n-\n-@item --help\n-@itemx -?\n-Print help, then exit.\n-\n-@item --showversion\n-Print version number and continue.\n-\n-@item --fullversion\n-Print detailed version information, then exit.\n-\n-@item --version\n-Print version number, then exit.\n-\n-@item -verbose\n-@itemx -verbose:class\n-Each time a class is initialized, print a short message on standard error.\n-@end table\n-\n-@code{gij} also recognizes and ignores the following options, for\n-compatibility with existing application launch scripts:\n-@code{-client}, @code{-server}, @code{-hotspot}, @code{-jrockit},\n-@code{-agentlib}, @code{-agentpath}, @code{-debug}, @code{-d32},\n-@code{-d64}, @code{-javaagent}, @code{-noclassgc}, @code{-verify},\n-and @code{-verifyremote}.\n-\n-@c man end\n-\n-@node Invoking gcj-dbtool\n-@chapter Invoking gcj-dbtool.\n-\n-@c man title gcj-dbtool Manipulate class file mapping databases for libgcj\n-\n-@ignore\n-@c man begin SYNOPSIS gcj-dbtool\n-gcj-dbtool @option{OPTION} @var{DBFILE} [@option{MORE}] @dots{}\n-\n-gcj-dbtool [@option{-0}] [@option{-}] [@option{-n}] [@option{-a}] [@option{-f}]\n-  [@option{-t}] [@option{-l}] [@option{-p} [@var{LIBDIR}]]\n-  [@option{-v}] [@option{-m}] [@option{--version}] [@option{--help}]\n-\n-@c man end\n-@c man begin SEEALSO gcj-dbtool\n-gcc(1), gcj(1), gcjh(1), jcf-dump(1), gfdl(7),\n-and the Info entries for @file{gcj} and @file{gcc}.\n-@c man end\n-@end ignore\n-\n-@c man begin DESCRIPTION gcj-dbtool\n-\n-@code{gcj-dbtool} is a tool for creating and manipulating class file\n-mapping databases.  @code{libgcj} can use these databases to find a\n-shared library corresponding to the bytecode representation of a\n-class.  This functionality is useful for ahead-of-time compilation of\n-a program that has no knowledge of @code{gcj}.\n-\n-@code{gcj-dbtool} works best if all the jar files added to it are\n-compiled using @code{-findirect-dispatch}.\n-\n-Note that @code{gcj-dbtool} is currently available as ``preview\n-technology''.  We believe it is a reasonable way to allow\n-application-transparent ahead-of-time compilation, but this is an\n-unexplored area.  We welcome your comments.\n-\n-@c man end\n-\n-@c man begin OPTIONS gcj-dbtool\n-\n-@table @gcctabopt\n-@item -n @var{DBFILE} [@var{SIZE}]\n-This creates a new database.  Currently, databases cannot be resized;\n-you can choose a larger initial size if desired.  The default size is\n-32,749.\n-\n-@item -a @var{DBFILE} @var{JARFILE} @var{LIB}\n-@itemx -f @var{DBFILE} @var{JARFILE} @var{LIB}\n-This adds a jar file to the database.  For each class file in the jar,\n-a cryptographic signature of the bytecode representation of the class\n-is recorded in the database.  At runtime, a class is looked up by its\n-signature and the compiled form of the class is looked for in the\n-corresponding shared library.  The @option{-a} option will verify\n-that @var{LIB} exists before adding it to the database; @option{-f}\n-skips this check.\n-\n-@item [@option{-}][@option{-0}] -m @var{DBFILE} @var{DBFILE},[@var{DBFILE}]\n-Merge a number of databases.  The output database overwrites any\n-existing database.  To add databases into an existing database,\n-include the destination in the list of sources.\n-\n-If @option{-} or @option{-0} are used, the list of files to read is\n-taken from standard input instead of the command line.  For\n-@option{-0}, Input filenames are terminated by a null character\n-instead of by whitespace.  Useful when arguments might contain white\n-space.  The GNU find -print0 option produces input suitable for this\n-mode.\n-\n-@item -t @var{DBFILE}\n-Test a database.\n-\n-@item -l @var{DBFILE}\n-List the contents of a database.\n-\n-@item -p\n-Print the name of the default database.  If there is no default\n-database, this prints a blank line.  If @var{LIBDIR} is specified, use\n-it instead of the default library directory component of the database\n-name.\n-\n-@item --help\n-Print a help message, then exit.\n-\n-@item --version\n-@itemx -v\n-Print version information, then exit.\n-\n-@end table\n-\n-@c man end\n-\n-@node Invoking jv-convert\n-@chapter Invoking jv-convert\n-\n-@c man title jv-convert Convert file from one encoding to another\n-\n-@c man begin SYNOPSIS jv-convert\n-@command{jv-convert} [@option{OPTION}] @dots{} [@var{INPUTFILE} [@var{OUTPUTFILE}]]\n-@ignore\n-\n-  [@option{--encoding} @var{name}]\n-  [@option{--from} @var{name}]\n-  [@option{--to} @var{name}]\n-  [@option{-i} @var{file}] [@option{-o} @var{file}]\n-  [@option{--reverse}] [@option{--help}] [@option{--version}]\n-@end ignore\n-@c man end\n-\n-@c man begin DESCRIPTION jv-convert\n-\n-@command{jv-convert} is a utility included with @code{libgcj} which\n-converts a file from one encoding to another.  It is similar to the Unix\n-@command{iconv} utility.\n-\n-The encodings supported by @command{jv-convert} are platform-dependent.\n-Currently there is no way to get a list of all supported encodings.\n-\n-@c man end\n-\n-@c man begin OPTIONS jv-convert\n-\n-@table @gcctabopt\n-@item --encoding @var{name}\n-@itemx --from @var{name}\n-Use @var{name} as the input encoding.  The default is the current\n-locale's encoding.\n-\n-@item --to @var{name}\n-Use @var{name} as the output encoding.  The default is the\n-@code{JavaSrc} encoding; this is ASCII with @samp{\\u} escapes for\n-non-ASCII characters.\n-\n-@item -i @var{file}\n-Read from @var{file}.  The default is to read from standard input.\n-\n-@item -o @var{file}\n-Write to @var{file}.  The default is to write to standard output.\n-\n-@item --reverse\n-Swap the input and output encodings.\n-\n-@item --help\n-Print a help message, then exit.\n-\n-@item --version\n-Print version information, then exit.\n-@end table\n-\n-@c man end\n-\n-@node Invoking grmic\n-@chapter Invoking grmic\n-\n-@c man title grmic Generate stubs for Remote Method Invocation\n-\n-@c man begin SYNOPSIS grmic\n-@command{grmic} [@option{OPTION}] @dots{} @var{class} @dots{}\n-@ignore\n-  [@option{-keep}]\n-  [@option{-keepgenerated}]\n-  [@option{-v1.1}]\n-  [@option{-vcompat}]\n-  [@option{-v1.2}]\n-  [@option{-nocompile}]\n-  [@option{-verbose}]\n-  [@option{-d} @var{directory}]\n-  [@option{-help}]\n-  [@option{-version}]\n-@end ignore\n-@c man end\n-\n-@c man begin DESCRIPTION grmic\n-\n-@command{grmic} is a utility included with @code{libgcj} which generates\n-stubs for remote objects.\n-\n-@c FIXME: Add real information here.\n-@c This really isn't much more than the --help output.\n-\n-Note that this program isn't yet fully compatible with the JDK\n-@command{grmic}.  Some options, such as @option{-classpath}, are\n-recognized but currently ignored.  We have left these options\n-undocumented for now.\n-\n-Long options can also be given with a GNU-style leading @samp{--}.  For\n-instance, @option{--help} is accepted.\n-\n-@c man end\n-\n-@c man begin OPTIONS grmic\n-\n-@table @gcctabopt\n-@item -keep\n-@itemx -keepgenerated\n-By default, @command{grmic} deletes intermediate files.  Either of these\n-options causes it not to delete such files.\n-\n-@item -v1.1\n-Cause @command{grmic} to create stubs and skeletons for the 1.1\n-protocol version.\n-\n-@item -vcompat\n-Cause @command{grmic} to create stubs and skeletons compatible with both\n-the 1.1 and 1.2 protocol versions.  This is the default.\n-\n-@item -v1.2\n-Cause @command{grmic} to create stubs and skeletons for the 1.2\n-protocol version.\n-\n-@item -nocompile\n-Don't compile the generated files.\n-\n-@item -verbose\n-Print information about what @command{grmic} is doing.\n-\n-@item -d @var{directory}\n-Put output files in @var{directory}.  By default the files are put in\n-the current working directory.\n-\n-@item -help\n-Print a help message, then exit.\n-\n-@item -version\n-Print version information, then exit.\n-@end table\n-\n-@c man end\n-\n-\n-@node Invoking gc-analyze\n-@chapter Invoking gc-analyze\n-\n-@c man title gc-analyze Analyze Garbage Collector (GC) memory dumps\n-\n-@c man begin SYNOPSIS gc-analyze\n-@command{gc-analyze} [@option{OPTION}] @dots{} [@var{file}]\n-@ignore\n-  [@option{-v}]\n-  [@option{--verbose}]\n-  [@option{-p} @var{tool-prefix}]\n-  [@option{-d} @var{directory}]\n-  [@option{--version}]\n-  [@option{--help}]\n-@end ignore\n-@c man end\n-\n-@c man begin DESCRIPTION gc-analyze\n-\n-@command{gc-analyze} prints an analysis of a GC memory dump to\n-standard out.\n-\n-The memory dumps may be created by calling\n-@code{gnu.gcj.util.GCInfo.enumerate(String namePrefix)} from java\n-code.  A memory dump will be created on an out of memory condition if\n-@code{gnu.gcj.util.GCInfo.setOOMDump(String namePrefix)} is called\n-before the out of memory occurs.\n-\n-Running this program will create two files: @file{TestDump001} and\n-@file{TestDump001.bytes}.\n-\n-@example\n-import gnu.gcj.util.*;\n-import java.util.*;\n-\n-public class GCDumpTest\n-@{\n-    static public void main(String args[])\n-    @{\n-        ArrayList<String> l = new ArrayList<String>(1000);\n-\n-        for (int i = 1; i < 1500; i++) @{\n-            l.add(\"This is string #\" + i);\n-        @}\n-        GCInfo.enumerate(\"TestDump\");\n-    @}\n-@}\n-@end example\n-\n-The memory dump may then be displayed by running:\n-\n-@example\n-gc-analyze -v TestDump001\n-@end example\n-\n-@c FIXME: Add real information here.\n-@c This really isn't much more than the --help output.\n-\n-@c man end\n-\n-@c man begin OPTIONS gc-analyze\n-\n-@table @gcctabopt\n-@item --verbose\n-@itemx -v\n-Verbose output.\n-\n-@item -p @var{tool-prefix}\n-Prefix added to the names of the @command{nm} and @command{readelf} commands.\n-\n-@item -d @var{directory}\n-Directory that contains the executable and shared libraries used when\n-the dump was generated.\n-\n-@item --help\n-Print a help message, then exit.\n-\n-@item --version\n-Print version information, then exit.\n-@end table\n-\n-@c man end\n-\n-@node Invoking aot-compile\n-@chapter Invoking aot-compile\n-\n-@c man title aot-compile Compile bytecode to native and generate databases\n-\n-@ignore\n-\n-@c man begin SYNOPSIS aot-compile\n-aot-compile [@option{OPTION}] @dots{} @var{SRCDIR} @var{DSTDIR}\n-\n-aot-compile [@option{-M, --make}=@var{PATH}] [@option{-C, --gcj}=@var{PATH}]\n-  [@option{-D, --dbtool}=@var{PATH}] [@option{-m, --makeflags}=@var{FLAGS}] \n-  [@option{-c, --gcjflags}=@var{FLAGS}] [@option{-l, --ldflags}=@var{FLAGS}] \n-  [@option{-e, --exclude}=@var{PATH}]\n-@c man end\n-\n-@c man begin SEEALSO aot-compile\n-gcc(1), gcj(1), gcjh(1), jcf-dump(1), gfdl(7),\n-and the Info entries for @file{gcj} and @file{gcc}.\n-@c man end\n-\n-@end ignore\n-\n-@c man begin DESCRIPTION aot-compile\n-@code{aot-compile} is a script that searches a directory for Java bytecode\n-(as class files, or in jars) and uses @code{gcj} to compile it to native\n-code and generate the databases from it.\n-@c man end\n-\n-@c man begin OPTIONS aot-compile\n-@table @gcctabopt\n-@item -M, --make=@var{PATH}\n-Specify the path to the @code{make} executable to use.\n-\n-@item -C, --gcj=@var{PATH}\n-Specify the path to the @code{gcj} executable to use.\n-\n-@item -D, --dbtool=@var{PATH}\n-Specify the path to the @code{gcj-dbtool} executable to use.\n-\n-@item -m, --makeflags=@var{FLAGS}\n-Specify flags to pass to @code{make} during the build.\n-\n-@item -c, --gcjflags=@var{FLAGS}\n-Specify flags to pass to @code{gcj} during compilation, in addition to\n-'-fPIC -findirect-dispatch -fjni'.\n-\n-@item -l, --ldflags=@var{FLAGS}\n-Specify flags to pass to @code{gcj} during linking, in addition to\n-'-Wl,-Bsymbolic'.\n-\n-@item -e, --exclude=@var{PATH}\n-Do not compile @var{PATH}.\n-\n-@end table\n-\n-@c man end\n-\n-@node Invoking rebuild-gcj-db\n-@chapter Invoking rebuild-gcj-db\n-\n-@c man title rebuild-gcj-db Merge the per-solib databases made by aot-compile into one system-wide database.\n-@ignore\n-\n-@c man begin SYNOPSIS rebuild-gcj-db\n-rebuild-gcj-db\n-@c man end\n-\n-@c man begin SEEALSO rebuild-gcj-db\n-gcc(1), gcj(1), gcjh(1), jcf-dump(1), gfdl(7),\n-and the Info entries for @file{gcj} and @file{gcc}.\n-@c man end\n-\n-@end ignore\n-\n-@c man begin DESCRIPTION rebuild-gcj-db\n-@code{rebuild-gcj-db} is a script that merges the per-solib databases made by\n-@code{aot-compile} into one system-wide database so @code{gij} can find the \n-solibs.\n-@c man end\n-\n-@node About CNI\n-@chapter About CNI\n-\n-This documents CNI, the Compiled Native Interface,\n-which is is a convenient way to write Java native methods using C++.\n-This is a more efficient, more convenient, but less portable\n-alternative to the standard JNI (Java Native Interface).\n-\n-@menu\n-* Basic concepts::              Introduction to using CNI@.\n-* Packages::                    How packages are mapped to C++.\n-* Primitive types::             Handling primitive Java types in C++.\n-* Reference types::             Handling Java reference types in C++.\n-* Interfaces::                  How Java interfaces map to C++.\n-* Objects and Classes::         C++ and Java classes.\n-* Class Initialization::        How objects are initialized.\n-* Object allocation::           How to create Java objects in C++.\n-* Memory allocation::           How to allocate and free memory.\n-* Arrays::                      Dealing with Java arrays in C++.\n-* Methods::                     Java methods in C++.\n-* Strings::                     Information about Java Strings.\n-* Mixing with C++::             How CNI can interoperate with C++.\n-* Exception Handling::          How exceptions are handled.\n-* Synchronization::             Synchronizing between Java and C++.\n-* Invocation::                  Starting the Java runtime from C++.\n-* Reflection::                  Using reflection from C++.\n-@end menu\n-\n-\n-@node Basic concepts\n-@section Basic concepts\n-\n-In terms of languages features, Java is mostly a subset\n-of C++.  Java has a few important extensions, plus a powerful standard\n-class library, but on the whole that does not change the basic similarity.\n-Java is a hybrid object-oriented language, with a few native types,\n-in addition to class types.  It is class-based, where a class may have\n-static as well as per-object fields, and static as well as instance methods.\n-Non-static methods may be virtual, and may be overloaded.  Overloading is\n-resolved at compile time by matching the actual argument types against\n-the parameter types.  Virtual methods are implemented using indirect calls\n-through a dispatch table (virtual function table).  Objects are\n-allocated on the heap, and initialized using a constructor method.\n-Classes are organized in a package hierarchy.\n-\n-All of the listed attributes are also true of C++, though C++ has\n-extra features (for example in C++ objects may be allocated not just\n-on the heap, but also statically or in a local stack frame).  Because\n-@command{gcj} uses the same compiler technology as G++ (the GNU\n-C++ compiler), it is possible to make the intersection of the two\n-languages use the same ABI (object representation and calling\n-conventions).  The key idea in CNI is that Java objects are C++\n-objects, and all Java classes are C++ classes (but not the other way\n-around).  So the most important task in integrating Java and C++ is to\n-remove gratuitous incompatibilities.\n-\n-You write CNI code as a regular C++ source file.  (You do have to use\n-a Java/CNI-aware C++ compiler, specifically a recent version of G++.)\n-\n-@noindent A CNI C++ source file must have:\n-\n-@example\n-#include <gcj/cni.h>\n-@end example\n-\n-@noindent and then must include one header file for each Java class it uses, e.g.:\n-\n-@example\n-#include <java/lang/Character.h>\n-#include <java/util/Date.h>\n-#include <java/lang/IndexOutOfBoundsException.h>\n-@end example\n-\n-@noindent These header files are automatically generated by @code{gcjh}.\n-\n-\n-CNI provides some functions and macros to make using Java objects and\n-primitive types from C++ easier.  In general, these CNI functions and\n-macros start with the @code{Jv} prefix, for example the function\n-@code{JvNewObjectArray}.  This convention is used to avoid conflicts\n-with other libraries.  Internal functions in CNI start with the prefix\n-@code{_Jv_}.  You should not call these; if you find a need to, let us\n-know and we will try to come up with an alternate solution.\n-\n-\n-@subsection Limitations\n-\n-Whilst a Java class is just a C++ class that doesn't mean that you are\n-freed from the shackles of Java, a @acronym{CNI} C++ class must adhere to the\n-rules of the Java programming language.\n-\n-For example: it is not possible to declare a method in a CNI class\n-that will take a C string (@code{char*}) as an argument, or to declare a\n-member variable of some non-Java datatype.\n-\n-\n-@node Packages\n-@section Packages\n-\n-The only global names in Java are class names, and packages.  A\n-@dfn{package} can contain zero or more classes, and also zero or more\n-sub-packages.  Every class belongs to either an unnamed package or a\n-package that has a hierarchical and globally unique name.\n-\n-A Java package is mapped to a C++ @dfn{namespace}.  The Java class\n-@code{java.lang.String} is in the package @code{java.lang}, which is a\n-sub-package of @code{java}.  The C++ equivalent is the class\n-@code{java::lang::String}, which is in the namespace @code{java::lang}\n-which is in the namespace @code{java}.\n-\n-@noindent Here is how you could express this:\n-\n-@example\n-(// @r{Declare the class(es), possibly in a header file:}\n-namespace java @{\n-  namespace lang @{\n-    class Object;\n-    class String;\n-    ...\n-  @}\n-@}\n-\n-class java::lang::String : public java::lang::Object\n-@{\n-  ...\n-@};\n-@end example\n-\n-@noindent The @code{gcjh} tool automatically generates the necessary namespace\n-declarations.\n-\n-\n-@subsection Leaving out package names\n-\n-Always using the fully-qualified name of a java class can be\n-tiresomely verbose.  Using the full qualified name also ties the code\n-to a single package making code changes necessary should the class\n-move from one package to another.  The Java @code{package} declaration\n-specifies that the following class declarations are in the named\n-package, without having to explicitly name the full package\n-qualifiers.  The @code{package} declaration can be\n-followed by zero or more @code{import} declarations, which\n-allows either a single class or all the classes in a package to be\n-named by a simple identifier.  C++ provides something similar with the\n-@code{using} declaration and directive.\n-\n-@noindent In Java:\n-\n-@example\n-import @var{package-name}.@var{class-name};\n-@end example\n-\n-@noindent allows the program text to refer to @var{class-name} as a shorthand for \n-the fully qualified name: @code{@var{package-name}.@var{class-name}}.\n-\n-\n-@noindent To achieve the same effect C++, you have to do this:\n-\n-@example\n-using @var{package-name}::@var{class-name};\n-@end example\n-\n-\n-@noindent Java can also cause imports on demand, like this:\n-\n-@example\n-import @var{package-name}.*;\n-@end example\n-\n-@noindent Doing this allows any class from the package @var{package-name} to be\n-referred to only by its class-name within the program text.\n-\n-\n-@noindent The same effect can be achieved in C++ like this:\n-\n-@example\n-using namespace @var{package-name};\n-@end example\n-\n-\n-@node Primitive types\n-@section Primitive types\n-\n-Java provides 8 @dfn{primitives} types which represent integers, floats, \n-characters and booleans (and also the void type).  C++ has its own\n-very similar concrete types.  Such types in C++ however are not always\n-implemented in the same way (an int might be 16, 32 or 64 bits for example) \n-so CNI provides a special C++ type for each primitive Java type:\n-\n-@multitable @columnfractions .20 .25 .60\n-@item @strong{Java type}   @tab @strong{C/C++ typename} @tab @strong{Description}\n-@item @code{char}        @tab @code{jchar}          @tab 16 bit Unicode character\n-@item @code{boolean}     @tab @code{jboolean}       @tab logical (true or false) values\n-@item @code{byte}        @tab @code{jbyte}          @tab 8-bit signed integer\n-@item @code{short}       @tab @code{jshort}         @tab 16 bit signed integer\n-@item @code{int}         @tab @code{jint}           @tab 32 bit signed integer\n-@item @code{long}        @tab @code{jlong}          @tab 64 bit signed integer\n-@item @code{float}       @tab @code{jfloat}         @tab 32 bit IEEE floating point number\n-@item @code{double}      @tab @code{jdouble}        @tab 64 bit IEEE floating point number\n-@item @code{void}        @tab @code{void}           @tab no value\n-@end multitable\n-\n-When referring to a Java type You should always use these C++ typenames (e.g.: @code{jint})\n-to avoid disappointment.\n-\n-\n-@subsection Reference types associated with primitive types\n-\n-In Java each primitive type has an associated reference type, \n-e.g.: @code{boolean} has an associated @code{java.lang.Boolean.TYPE} class.\n-In order to make working with such classes easier GCJ provides the macro\n-@code{JvPrimClass}:\n-\n-@deffn macro JvPrimClass type\n-Return a pointer to the @code{Class} object corresponding to the type supplied.\n-\n-@example\n-JvPrimClass(void) @result{} java.lang.Void.TYPE\n-@end example\n-\n-@end deffn\n-\n-\n-@node Reference types\n-@section Reference types\n-\n-A Java reference type is treated as a class in C++.  Classes and\n-interfaces are handled this way.  A Java reference is translated to a\n-C++ pointer, so for instance a Java @code{java.lang.String} becomes,\n-in C++, @code{java::lang::String *}.\n-\n-CNI provides a few built-in typedefs for the most common classes:\n-@multitable @columnfractions .30 .25 .60\n-@item @strong{Java type} @tab @strong{C++ typename} @tab @strong{Description}\n-@item @code{java.lang.Object} @tab @code{jobject} @tab Object type\n-@item @code{java.lang.String} @tab @code{jstring} @tab String type\n-@item @code{java.lang.Class} @tab @code{jclass} @tab Class type\n-@end multitable\n-@cindex jobject\n-@cindex jstring\n-@cindex jclass\n-\n-Every Java class or interface has a corresponding @code{Class}\n-instance.  These can be accessed in CNI via the static @code{class$}\n-field of a class.  The @code{class$} field is of type @code{Class}\n-(and not @code{Class *}), so you will typically take the address of\n-it.\n-@cindex class$\n-\n-Here is how you can refer to the class of @code{String}, which in\n-Java would be written @code{String.class}:\n-\n-@example\n-using namespace java::lang;\n-doSomething (&String::class$);\n-@end example\n-\n-\n-@node Interfaces\n-@section Interfaces\n-\n-A Java class can @dfn{implement} zero or more\n-@dfn{interfaces}, in addition to inheriting from\n-a single base class. \n-\n-@acronym{CNI} allows CNI code to implement methods of interfaces.\n-You can also call methods through interface references, with some\n-limitations.\n-\n-@acronym{CNI} doesn't understand interface inheritance at all yet.  So,\n-you can only call an interface method when the declared type of the\n-field being called matches the interface which declares that\n-method.  The workaround is to cast the interface reference to the right\n-superinterface.\n-\n-For example if you have: \n-\n-@example \n-interface A \n-@{ \n-  void a(); \n-@} \n-\n-interface B extends A \n-@{ \n-  void b(); \n-@} \n-@end example\n-\n-and declare a variable of type @code{B} in C++, you can't call\n-@code{a()} unless you cast it to an @code{A} first.\n-\n-@node Objects and Classes\n-@section Objects and Classes\n-\n-@subsection Classes\n-\n-All Java classes are derived from @code{java.lang.Object}.  C++ does\n-not have a unique root class, but we use the C++ class\n-@code{java::lang::Object} as the C++ version of the\n-@code{java.lang.Object} Java class.  All other Java classes are mapped\n-into corresponding C++ classes derived from @code{java::lang::Object}.\n-\n-Interface inheritance (the @code{implements} keyword) is currently not\n-reflected in the C++ mapping.\n-\n-\n-@subsection Object fields\n-\n-Each object contains an object header, followed by the instance fields\n-of the class, in order.  The object header consists of a single\n-pointer to a dispatch or virtual function table.  (There may be extra\n-fields @emph{in front of} the object, for example for memory\n-management, but this is invisible to the application, and the\n-reference to the object points to the dispatch table pointer.)\n-\n-The fields are laid out in the same order, alignment, and size as in\n-C++.  Specifically, 8-bit and 16-bit native types (@code{byte},\n-@code{short}, @code{char}, and @code{boolean}) are @emph{not} widened\n-to 32 bits.  Note that the Java VM does extend 8-bit and 16-bit types\n-to 32 bits when on the VM stack or temporary registers.\n-\n-If you include the @code{gcjh}-generated header for a\n-class, you can access fields of Java classes in the @emph{natural}\n-way.  For example, given the following Java class:\n-\n-@example\n-public class Int\n-@{\n-  public int i;\n-  public Int (int i) @{ this.i = i; @}\n-  public static Int zero = new Int(0);\n-@}\n-@end example\n-\n-you can write:\n-\n-@example\n-#include <gcj/cni.h>;\n-#include <Int>;\n-\n-Int*\n-mult (Int *p, jint k)\n-@{\n-  if (k == 0)\n-    return Int::zero;  // @r{Static member access.}\n-  return new Int(p->i * k);\n-@}\n-@end example\n-\n-\n-@subsection Access specifiers\n-\n-CNI does not strictly enforce the Java access\n-specifiers, because Java permissions cannot be directly mapped\n-into C++ permission.  Private Java fields and methods are mapped\n-to private C++ fields and methods, but other fields and methods\n-are mapped to public fields and methods.\n-\n-\n-\n-@node Class Initialization\n-@section Class Initialization\n-\n-Java requires that each class be automatically initialized at the time \n-of the first active use.  Initializing a class involves \n-initializing the static fields, running code in class initializer \n-methods, and initializing base classes.  There may also be \n-some implementation specific actions, such as allocating \n-@code{String} objects corresponding to string literals in\n-the code.\n-\n-The GCJ compiler inserts calls to @code{JvInitClass} at appropriate\n-places to ensure that a class is initialized when required.  The C++\n-compiler does not insert these calls automatically---it is the\n-programmer's responsibility to make sure classes are initialized.\n-However, this is fairly painless because of the conventions assumed by\n-the Java system.\n-\n-First, @code{libgcj} will make sure a class is initialized before an\n-instance of that object is created.  This is one of the\n-responsibilities of the @code{new} operation.  This is taken care of\n-both in Java code, and in C++ code.  When G++ sees a @code{new} of a\n-Java class, it will call a routine in @code{libgcj} to allocate the\n-object, and that routine will take care of initializing the class.\n-Note however that this does not happen for Java arrays; you must\n-allocate those using the appropriate CNI function.  It follows that\n-you can access an instance field, or call an instance (non-static)\n-method and be safe in the knowledge that the class and all of its base\n-classes have been initialized.\n-\n-Invoking a static method is also safe.  This is because the\n-Java compiler adds code to the start of a static method to make sure\n-the class is initialized.  However, the C++ compiler does not\n-add this extra code.  Hence, if you write a native static method\n-using CNI, you are responsible for calling @code{JvInitClass}\n-before doing anything else in the method (unless you are sure\n-it is safe to leave it out).\n-\n-Accessing a static field also requires the class of the\n-field to be initialized.  The Java compiler will generate code\n-to call @code{JvInitClass} before getting or setting the field.\n-However, the C++ compiler will not generate this extra code,\n-so it is your responsibility to make sure the class is\n-initialized before you access a static field from C++.\n-\n-\n-@node Object allocation\n-@section Object allocation\n-\n-New Java objects are allocated using a\n-@dfn{class instance creation expression}, e.g.:\n-\n-@example\n-new @var{Type} ( ... )\n-@end example\n-\n-The same syntax is used in C++.  The main difference is that\n-C++ objects have to be explicitly deleted; in Java they are\n-automatically deleted by the garbage collector.\n-Using @acronym{CNI}, you can allocate a new Java object\n-using standard C++ syntax and the C++ compiler will allocate\n-memory from the garbage collector.  If you have overloaded\n-constructors, the compiler will choose the correct one\n-using standard C++ overload resolution rules.  \n-\n-@noindent For example:\n-\n-@example\n-java::util::Hashtable *ht = new java::util::Hashtable(120);\n-@end example\n-\n-\n-@node Memory allocation\n-@section Memory allocation\n-\n-When allocating memory in @acronym{CNI} methods it is best to handle\n-out-of-memory conditions by throwing a Java exception.  These\n-functions are provided for that purpose:\n-\n-@deftypefun void* JvMalloc (jsize @var{size})\n-Calls malloc.  Throws @code{java.lang.OutOfMemoryError} if allocation\n-fails.\n-@end deftypefun\n-\n-@deftypefun void* JvRealloc (void* @var{ptr}, jsize @var{size})\n-Calls realloc.  Throws @code{java.lang.OutOfMemoryError} if\n-reallocation fails.\n-@end deftypefun\n-\n-@deftypefun void JvFree (void* @var{ptr})\n-Calls free.\n-@end deftypefun\n-\n-@node Arrays\n-@section Arrays\n-\n-While in many ways Java is similar to C and C++, it is quite different\n-in its treatment of arrays.  C arrays are based on the idea of pointer\n-arithmetic, which would be incompatible with Java's security\n-requirements.  Java arrays are true objects (array types inherit from\n-@code{java.lang.Object}).  An array-valued variable is one that\n-contains a reference (pointer) to an array object.\n-\n-Referencing a Java array in C++ code is done using the\n-@code{JArray} template, which as defined as follows:\n-\n-@example\n-class __JArray : public java::lang::Object\n-@{\n-public:\n-  int length;\n-@};\n-\n-template<class T>\n-class JArray : public __JArray\n-@{\n-  T data[0];\n-public:\n-  T& operator[](jint i) @{ return data[i]; @}\n-@};\n-@end example\n-\n-\n-There are a number of @code{typedef}s which correspond to @code{typedef}s \n-from the @acronym{JNI}.  Each is the type of an array holding objects\n-of the relevant type:\n-\n-@example\n-typedef __JArray *jarray;\n-typedef JArray<jobject> *jobjectArray;\n-typedef JArray<jboolean> *jbooleanArray;\n-typedef JArray<jbyte> *jbyteArray;\n-typedef JArray<jchar> *jcharArray;\n-typedef JArray<jshort> *jshortArray;\n-typedef JArray<jint> *jintArray;\n-typedef JArray<jlong> *jlongArray;\n-typedef JArray<jfloat> *jfloatArray;\n-typedef JArray<jdouble> *jdoubleArray;\n-@end example\n-\n-\n-@deftypemethod {template<class T>} T* elements (JArray<T> @var{array})\n-This template function can be used to get a pointer to the elements of\n-the @code{array}.  For instance, you can fetch a pointer to the\n-integers that make up an @code{int[]} like so:\n-\n-@example\n-extern jintArray foo;\n-jint *intp = elements (foo);\n-@end example\n-\n-The name of this function may change in the future.\n-@end deftypemethod\n-\n-\n-@deftypefun jobjectArray JvNewObjectArray (jsize @var{length}, jclass @var{klass}, jobject @var{init})\n-This creates a new array whose elements have reference type.\n-@code{klass} is the type of elements of the array and\n-@code{init} is the initial value put into every slot in the array.\n-@end deftypefun\n-\n-@example\n-using namespace java::lang;\n-JArray<String *> *array\n-  = (JArray<String *> *) JvNewObjectArray(length, &String::class$, NULL);\n-@end example\n-\n-\n-@subsection Creating arrays\n-\n-For each primitive type there is a function which can be used to\n-create a new array of that type.  The name of the function is of the\n-form:\n-\n-@example\n-JvNew@var{Type}Array\n-@end example\n-\n-@noindent For example:\n-\n-@example\n-JvNewBooleanArray\n-@end example\n-\n-@noindent can be used to create an array of Java primitive boolean types.\n-\n-@noindent The following function definition is the template for all such functions:\n-\n-@deftypefun jbooleanArray JvNewBooleanArray (jint @var{length})\n-Creates an array @var{length} indices long.\n-@end deftypefun\n-\n-@deftypefun jsize JvGetArrayLength (jarray @var{array})\n-Returns the length of the @var{array}.\n-@end deftypefun\n-\n-\n-@node Methods\n-@section Methods\n-\n-Java methods are mapped directly into C++ methods.\n-The header files generated by @code{gcjh}\n-include the appropriate method definitions.\n-Basically, the generated methods have the same names and\n-@emph{corresponding} types as the Java methods,\n-and are called in the natural manner.\n-\n-@subsection Overloading\n-\n-Both Java and C++ provide method overloading, where multiple\n-methods in a class have the same name, and the correct one is chosen\n-(at compile time) depending on the argument types.\n-The rules for choosing the correct method are (as expected) more complicated\n-in C++ than in Java, but given a set of overloaded methods\n-generated by @code{gcjh} the C++ compiler will choose\n-the expected one.\n-\n-Common assemblers and linkers are not aware of C++ overloading,\n-so the standard implementation strategy is to encode the\n-parameter types of a method into its assembly-level name.\n-This encoding is called @dfn{mangling},\n-and the encoded name is the @dfn{mangled name}.\n-The same mechanism is used to implement Java overloading.\n-For C++/Java interoperability, it is important that both the Java\n-and C++ compilers use the @emph{same} encoding scheme.\n-\n-@subsection Static methods\n-\n-Static Java methods are invoked in @acronym{CNI} using the standard\n-C++ syntax, using the @code{::} operator rather\n-than the @code{.} operator.  \n-\n-@noindent For example:\n-\n-@example\n-jint i = java::lang::Math::round((jfloat) 2.3);\n-@end example\n-\n-@noindent C++ method definition syntax is used to define a static native method.\n-For example:\n-\n-@example\n-#include <java/lang/Integer>\n-java::lang::Integer*\n-java::lang::Integer::getInteger(jstring str)\n-@{\n-  ...\n-@}\n-@end example\n-\n-\n-@subsection Object Constructors\n-\n-Constructors are called implicitly as part of object allocation\n-using the @code{new} operator.  \n-\n-@noindent For example:\n-\n-@example\n-java::lang::Integer *x = new java::lang::Integer(234);\n-@end example\n-\n-Java does not allow a constructor to be a native method.\n-This limitation can be coded round however because a constructor\n-can @emph{call} a native method.\n-\n-\n-@subsection Instance methods\n-\n-Calling a Java instance method from a C++ @acronym{CNI} method is done \n-using the standard C++ syntax, e.g.:\n-\n-@example\n-// @r{First create the Java object.}\n-java::lang::Integer *x = new java::lang::Integer(234);\n-// @r{Now call a method.}\n-jint prim_value = x->intValue();\n-if (x->longValue == 0) \n-  ...\n-@end example\n-\n-@noindent Defining a Java native instance method is also done the natural way:\n-\n-@example\n-#include <java/lang/Integer.h>\n-\n-jdouble\n-java::lang:Integer::doubleValue()\n-@{\n-  return (jdouble) value;\n-@}\n-@end example\n-\n-\n-@subsection Interface methods\n-\n-In Java you can call a method using an interface reference.  This is\n-supported, but not completely.  @xref{Interfaces}.\n-\n-\n-\n-\n-@node Strings\n-@section Strings\n-\n-@acronym{CNI} provides a number of utility functions for\n-working with Java Java @code{String} objects.\n-The names and interfaces are analogous to those of @acronym{JNI}.\n-\n-\n-@deftypefun jstring JvNewString (const jchar* @var{chars}, jsize @var{len})\n-Returns a Java @code{String} object with characters from the array of \n-Unicode characters @var{chars} up to the index @var{len} in that array.\n-@end deftypefun\n-\n-@deftypefun jstring JvNewStringLatin1 (const char* @var{bytes}, jsize @var{len})\n-Returns a Java @code{String} made up of @var{len} bytes from @var{bytes}.\n-@end deftypefun\n-\n-\n-@deftypefun jstring JvNewStringLatin1 (const char* @var{bytes})\n-As above but the length of the @code{String} is @code{strlen(@var{bytes})}.\n-@end deftypefun\n-\n-@deftypefun jstring JvNewStringUTF (const char* @var{bytes})\n-Returns a @code{String} which is made up of the UTF encoded characters\n-present in the C string @var{bytes}.\n-@end deftypefun\n-\n-@deftypefun jchar* JvGetStringChars (jstring @var{str})\n-Returns a pointer to an array of characters making up the @code{String} @var{str}.\n-@end deftypefun\n-\n-@deftypefun int JvGetStringUTFLength (jstring @var{str})\n-Returns the number of bytes required to encode the contents of the\n-@code{String} @var{str} in UTF-8.\n-@end deftypefun\n-\n-@deftypefun jsize JvGetStringUTFRegion (jstring @var{str}, jsize @var{start}, jsize @var{len}, char* @var{buf})\n-Puts the UTF-8 encoding of a region of the @code{String} @var{str} into \n-the buffer @code{buf}.  The region to fetch is marked by @var{start} and @var{len}.\n-\n-Note that @var{buf} is a buffer, not a C string.  It is @emph{not} \n-null terminated.\n-@end deftypefun\n-\n-\n-@node Mixing with C++\n-@section Interoperating with C/C++\n-\n-Because @acronym{CNI} is designed to represent Java classes and methods it\n-cannot be mixed readily with C/C++ types.\n-\n-One important restriction is that Java classes cannot have non-Java\n-type instance or static variables and cannot have methods which take\n-non-Java types as arguments or return non-Java types.\n-\n-@noindent None of the following is possible with CNI:\n-\n-@example\n-\n-class ::MyClass : public java::lang::Object\n-@{\n-   char* variable;  // @r{char* is not a valid Java type.}\n-@}\n-\n-\n-uint\n-::SomeClass::someMethod (char *arg)\n-@{\n-  .\n-  .\n-  .\n-@}   // @r{@code{uint} is not a valid Java type, neither is @code{char*}}\n-@end example\n-\n-@noindent Of course, it is ok to use C/C++ types within the scope of a method:\n-\n-\n-@example\n-jint\n-::SomeClass::otherMethod (jstring str)\n-@{\n-   char *arg = ...\n-   .\n-   .\n-   .\n-@}\n-@end example\n-\n-@subsection RawData\n-\n-The above restriction can be problematic, so @acronym{CNI} includes the\n-@code{gnu.gcj.RawData} class.  The @code{RawData} class is a\n-@dfn{non-scanned reference} type.  In other words variables declared\n-of type @code{RawData} can contain any data and are not checked by the\n-compiler or memory manager in any way.\n-\n-This means that you can put C/C++ data structures (including classes)\n-in your @acronym{CNI} classes, as long as you use the appropriate cast.\n-\n-@noindent Here are some examples:\n-\n-@example\n-\n-class ::MyClass : public java::lang::Object\n-@{\n-   gnu.gcj.RawData string;\n-\n-   MyClass ();\n-   gnu.gcj.RawData getText ();\n-   void printText ();\n-@}\n-\n-::MyClass::MyClass ()\n-@{\n-   char* text = ...\n-   string = text;\n-@}\n-\n-gnu.gcj.RawData\n-::MyClass::getText ()\n-@{\n-   return string;\n-@}\n-\n-void\n-::MyClass::printText ()\n-@{\n-  printf(\"%s\\n\", (char*) string);\n-@}\n-@end example\n-\n-\n-@subsection RawDataManaged\n-\n-@code{gnu.gcj.RawDataManaged} is another type used to indicate special data used \n-by native code. Unlike the @code{RawData} type, fields declared as \n-@code{RawDataManaged} will be \"marked\" by the memory manager and \n-considered for garbage collection.  \n-\n-Native data which is allocated using CNI's @code{JvAllocBytes()}\n-function and stored in a @code{RawDataManaged} will be automatically \n-freed when the Java object it is associated with becomes unreachable.\n-\n-@subsection Native memory allocation\n-\n-@deftypefun void* JvAllocBytes (jsize @var{size})\n-Allocates @var{size} bytes from the heap.  The memory returned is zeroed.\n-This memory is not scanned for pointers by the garbage collector, but will \n-be freed if no references to it are discovered.\n-\n-This function can be useful if you need to associate some native data with a\n-Java object. Using a CNI's special @code{RawDataManaged} type, native data \n-allocated with @code{JvAllocBytes} will be automatically freed when the Java \n-object itself becomes unreachable.\n-@end deftypefun\n-\n-@subsection Posix signals\n-\n-On Posix based systems the @code{libgcj} library uses several signals\n-internally.  @acronym{CNI} code should not attempt to use the same\n-signals as doing so may cause @code{libgcj} and/or the @acronym{CNI}\n-code to fail.\n-\n-SIGSEGV is used on many systems to generate\n-@code{NullPointerExceptions}.  SIGCHLD is used internally by\n-@code{Runtime.exec()}.  Several other signals (that vary from platform to\n-platform) can be used by the memory manager and by\n-@code{Thread.interrupt()}.\n-\n-@node Exception Handling\n-@section Exception Handling\n-\n-While C++ and Java share a common exception handling framework,\n-things are not yet perfectly integrated.  The main issue is that the\n-run-time type information facilities of the two\n-languages are not integrated.\n-\n-Still, things work fairly well.  You can throw a Java exception from\n-C++ using the ordinary @code{throw} construct, and this\n-exception can be caught by Java code.  Similarly, you can catch an\n-exception thrown from Java using the C++ @code{catch}\n-construct.\n-\n-@noindent Here is an example:\n-\n-@example\n-if (i >= count)\n-   throw new java::lang::IndexOutOfBoundsException();\n-@end example\n-\n-Normally, G++ will automatically detect when you are writing C++\n-code that uses Java exceptions, and handle them appropriately.\n-However, if C++ code only needs to execute destructors when Java\n-exceptions are thrown through it, GCC will guess incorrectly.  Sample\n-problematic code:\n-\n-@example\n-struct S @{ ~S(); @};\n-\n-extern void bar();    // @r{Is implemented in Java and may throw exceptions.}\n-\n-void foo()\n-@{\n-  S s;\n-  bar();\n-@}\n-@end example\n-\n-The usual effect of an incorrect guess is a link failure, complaining of\n-a missing routine called @code{__gxx_personality_v0}.\n-\n-You can inform the compiler that Java exceptions are to be used in a\n-translation unit, irrespective of what it might think, by writing\n-@code{#pragma GCC java_exceptions} at the head of the\n-file.  This @code{#pragma} must appear before any\n-functions that throw or catch exceptions, or run destructors when\n-exceptions are thrown through them.\n-\n-@node Synchronization\n-@section Synchronization\n-\n-Each Java object has an implicit monitor.\n-The Java VM uses the instruction @code{monitorenter} to acquire\n-and lock a monitor, and @code{monitorexit} to release it.\n-\n-The corresponding CNI macros are @code{JvMonitorEnter} and \n-@code{JvMonitorExit} (JNI has similar  methods @code{MonitorEnter}\n-and @code{MonitorExit}).  \n-\n-\n-The Java source language does not provide direct access to these primitives.\n-Instead, there is a @code{synchronized} statement that does an\n-implicit @code{monitorenter} before entry to the block,\n-and does a @code{monitorexit} on exit from the block.\n-Note that the lock has to be released even when the block is abnormally\n-terminated by an exception, which means there is an implicit\n-@code{try finally} surrounding synchronization locks.\n-\n-From C++, it makes sense to use a destructor to release a lock.\n-@acronym{CNI} defines the following utility class:\n-\n-@example\n-class JvSynchronize() @{\n-  jobject obj;\n-  JvSynchronize(jobject o) @{ obj = o; JvMonitorEnter(o); @}\n-  ~JvSynchronize() @{ JvMonitorExit(obj); @}\n-@};\n-@end example\n-\n-So this Java code:\n-\n-@example\n-synchronized (OBJ)\n-@{\n-   CODE\n-@}\n-@end example\n-\n-@noindent might become this C++ code:\n-\n-@example\n-@{\n-   JvSynchronize dummy (OBJ);\n-   CODE;\n-@}\n-@end example\n-\n-Java also has methods with the @code{synchronized} attribute.\n-This is equivalent to wrapping the entire method body in a\n-@code{synchronized} statement.\n-(Alternatively, an implementation could require the caller to do\n-the synchronization.  This is not practical for a compiler, because\n-each virtual method call would have to test at run-time if\n-synchronization is needed.)  Since in @command{gcj}\n-the @code{synchronized} attribute is handled by the\n-method implementation, it is up to the programmer\n-of a synchronized native method to handle the synchronization\n-(in the C++ implementation of the method).\n-In other words, you need to manually add @code{JvSynchronize}\n-in a @code{native synchronized} method.\n-\n-@node Invocation\n-@section Invocation\n-\n-CNI permits C++ applications to make calls into Java classes, in addition to\n-allowing Java code to call into C++. Several functions, known as the \n-@dfn{invocation API}, are provided to support this.\n-\n-@deftypefun jint JvCreateJavaVM (JvVMInitArgs* @var{vm_args})\n-\n-Initializes the Java runtime. This function performs essential initialization\n-of the threads interface, garbage collector, exception handling and other key\n-aspects of the runtime. It must be called once by an application with\n-a non-Java @code{main()} function, before any other Java or CNI calls are made.\n-It is safe, but not recommended, to call @code{JvCreateJavaVM()} more than\n-once provided it is only called from a single thread.\n-The @var{vmargs} parameter can be used to specify initialization parameters \n-for the Java runtime. It may be @code{NULL}.\n-\n-JvVMInitArgs represents a list of virtual machine initialization\n-arguments. @code{JvCreateJavaVM()} ignores the version field.\n-\n-@example\n-typedef struct JvVMOption\n-@{\n-  // a VM initialization option\n-  char* optionString;\n-  // extra information associated with this option\n-  void* extraInfo;\n-@} JvVMOption;\n-\n-typedef struct JvVMInitArgs\n-@{\n-  // for compatibility with JavaVMInitArgs\n-  jint version;\n-\n-  // number of VM initialization options\n-  jint nOptions;\n-\n-  // an array of VM initialization options\n-  JvVMOption* options;\n-\n-  // true if the option parser should ignore unrecognized options\n-  jboolean ignoreUnrecognized;\n-@} JvVMInitArgs;\n-@end example\n-\n-@code{JvCreateJavaVM()} returns @code{0} upon success, or @code{-1} if\n-the runtime is already initialized.\n-\n-@emph{Note:} In GCJ 3.1, the @code{vm_args} parameter is ignored. It\n-is recognized and used as of release 4.0.\n-@end deftypefun\n-\n-@deftypefun java::lang::Thread* JvAttachCurrentThread (jstring @var{name}, java::lang::ThreadGroup* @var{group})\n-Registers an existing thread with the Java runtime.  This must be called once\n-from each thread, before that thread makes any other Java or CNI calls. It\n-must be called after @code{JvCreateJavaVM}.\n-@var{name} specifies a name for the thread. It may be @code{NULL}, in which \n-case a name will be generated.\n-@var{group} is the ThreadGroup in which this thread will be a member. If it\n-is @code{NULL}, the thread will be a member of the main thread group.\n-The return value is the Java @code{Thread} object that represents the thread.\n-It is safe to call @code{JvAttachCurrentThread()} more than once from the same\n-thread. If the thread is already attached, the call is ignored and the current\n-thread object is returned.\n-@end deftypefun\n-\n-@deftypefun jint JvDetachCurrentThread ()\n-Unregisters a thread from the Java runtime. This should be called by threads\n-that were attached using @code{JvAttachCurrentThread()}, after they have \n-finished making calls to Java code. This ensures that any resources associated\n-with the thread become eligible for garbage collection.\n-This function returns @code{0} upon success, or @code{-1} if the current thread\n-is not attached.\n-@end deftypefun\n-\n-@subsection Handling uncaught exceptions\n-\n-If an exception is thrown from Java code called using the invocation API, and\n-no handler for the exception can be found, the runtime will abort the\n-application. In order to make the application more robust, it is recommended \n-that code which uses the invocation API be wrapped by a top-level try/catch \n-block that catches all Java exceptions.\n-\n-@subsection Example\n-\n-The following code demonstrates the use of the invocation API. In this\n-example, the C++ application initializes the Java runtime and attaches\n-itself. The @code{java.lang.System} class is initialized in order to\n-access its @code{out} field, and a Java string is printed. Finally, the thread\n-is detached from the runtime once it has finished making Java calls. Everything\n-is wrapped with a try/catch block to provide a default handler for any uncaught \n-exceptions.\n-\n-The example can be compiled with @command{c++ -c test.cc; gcj test.o}.\n-\n-@example\n-// test.cc\n-#include <gcj/cni.h>\n-#include <java/lang/System.h>\n-#include <java/io/PrintStream.h>\n-#include <java/lang/Throwable.h>\n-\n-int main(int argc, char *argv[])\n-@{\n-  using namespace java::lang;\n-\n-  try\n-  @{\n-    JvCreateJavaVM(NULL);\n-    JvAttachCurrentThread(NULL, NULL);\n-\n-    String *message = JvNewStringLatin1(\"Hello from C++\");\n-    JvInitClass(&System::class$);\n-    System::out->println(message);\n-\n-    JvDetachCurrentThread();\n-  @}\n-  catch (Throwable *t)\n-  @{\n-    System::err->println(JvNewStringLatin1(\"Unhandled Java exception:\"));\n-    t->printStackTrace();\n-  @}\n-@}\n-@end example\n-\n-@node Reflection\n-@section Reflection\n-\n-Reflection is possible with CNI code, it functions similarly to how it\n-functions with JNI@.\n-\n-@c clean this up...  I mean, what are the types jfieldID and jmethodID in JNI?\n-The types @code{jfieldID} and @code{jmethodID}\n-are as in JNI@.\n-\n-@noindent The functions:\n-\n-@itemize\n-@item @code{JvFromReflectedField},\n-@item @code{JvFromReflectedMethod},\n-@item @code{JvToReflectedField}\n-@item @code{JvToFromReflectedMethod}\n-@end itemize\n-\n-@noindent will be added shortly, as will other functions corresponding to JNI@.\n-\n-\n-@node System properties\n-@chapter System properties\n-\n-The runtime behavior of the @code{libgcj} library can be modified by setting\n-certain system properties.  These properties can be compiled into the program\n-using the @code{-D@var{name}[=@var{value}]} option to @command{gcj} or by\n-setting them explicitly in the program by calling the\n-@code{java.lang.System.setProperty()} method.  Some system properties are only\n-used for informational purposes (like giving a version number or a user name).\n-A program can inspect the current value of a property by calling the\n-@code{java.lang.System.getProperty()} method.\n-\n-@menu\n-* Standard Properties::         Standard properties supported by @code{libgcj}\n-* GNU Classpath Properties::    Properties found in Classpath based libraries\n-* libgcj Runtime Properties::   Properties specific to @code{libgcj}\n-@end menu\n-\n-@node Standard Properties\n-@section Standard Properties\n-\n-The following properties are normally found in all implementations of the core\n-libraries for the Java language.\n-\n-@table @gcctabopt\n-\n-@item java.version\n-The @code{libgcj} version number.\n-\n-@item java.vendor\n-Set to @samp{The Free Software Foundation, Inc.}\n-\n-@item java.vendor.url\n-Set to @uref{http://gcc.gnu.org/java/}.\n-\n-@item java.home\n-The directory where @code{gcj} was installed.  Taken from the @code{--prefix}\n-option given to @command{configure}.\n-\n-@item java.class.version\n-The class format version number supported by the libgcj byte code interpreter.\n-(Currently @samp{46.0})\n-\n-@item java.vm.specification.version\n-The Virtual Machine Specification version implemented by @code{libgcj}.\n-(Currently @samp{1.0})\n-\n-@item java.vm.specification.vendor\n-The name of the Virtual Machine specification designer.\n-\n-@item java.vm.specification.name\n-The name of the Virtual Machine specification\n-(Set to @samp{Java Virtual Machine Specification}).\n-\n-@item java.vm.version\n-The @command{gcj} version number.\n-\n-@item java.vm.vendor\n-Set to @samp{The Free Software Foundation, Inc.}\n-\n-@item java.vm.name\n-Set to @samp{GNU libgcj}.\n-\n-@item java.specification.version\n-The Runtime Environment specification version implemented by @code{libgcj}.\n-(Currently set to @samp{1.3})\n-\n-@item java.specification.vendor\n-The Runtime Environment specification designer.\n-\n-@item java.specification.name\n-The name of the Runtime Environment specification\n-(Set to @samp{Java Platform API Specification}).\n-\n-@item java.class.path\n-The paths (jar files, zip files and directories) used for finding class files.\n-\n-@item java.library.path\n-Directory path used for finding native libraries.\n-\n-@item java.io.tmpdir\n-The directory used to put temporary files in.\n-\n-@item java.compiler\n-Name of the Just In Time compiler to use by the byte code interpreter.\n-Currently not used in @code{libgcj}.\n-\n-@item java.ext.dirs\n-Directories containing jar files with extra libraries.  Will be used when\n-resolving classes.\n-\n-@item java.protocol.handler.pkgs\n-A @samp{|} separated list of package names that is used to find classes that\n-implement handlers for @code{java.net.URL}.\n-\n-@item java.rmi.server.codebase\n-A list of URLs that is used by the @code{java.rmi.server.RMIClassLoader}\n-to load classes from.\n-\n-@item jdbc.drivers\n-A list of class names that will be loaded by the @code{java.sql.DriverManager}\n-when it starts up.\n-\n-@item file.separator\n-The separator used in when directories are included in a filename\n-(normally @samp{/} or @samp{\\} ).\n-\n-@item file.encoding\n-The default character encoding used when converting platform native files to\n-Unicode (usually set to @samp{8859_1}).\n-\n-@item path.separator\n-The standard separator used when a string contains multiple paths\n-(normally @samp{:} or @samp{;}), the string is usually not a valid character\n-to use in normal directory names.)\n-\n-@item line.separator\n-The default line separator used on the platform (normally @samp{\\n}, @samp{\\r}\n-or a combination of those two characters).\n-\n-@item policy.provider\n-The class name used for the default policy provider returned by\n-@code{java.security.Policy.getPolicy}.\n-\n-@item user.name\n-The name of the user running the program.  Can be the full name, the login name\n-or empty if unknown.\n-\n-@item user.home\n-The default directory to put user specific files in.\n-\n-@item user.dir\n-The current working directory from which the program was started.\n-\n-@item user.language\n-The default language as used by the @code{java.util.Locale} class.\n-\n-@item user.region\n-The default region as used by the @code{java.util.Local} class.\n-\n-@item user.variant\n-The default variant of the language and region local used.\n-\n-@item user.timezone\n-The default timezone as used by the @code{java.util.TimeZone} class.\n-\n-@item os.name\n-The operating system/kernel name that the program runs on.\n-\n-@item os.arch\n-The hardware that we are running on.\n-\n-@item os.version\n-The version number of the operating system/kernel.\n-\n-@item awt.appletWarning\n-The string to display when an untrusted applet is displayed.\n-Returned by @code{java.awt.Window.getWarningString()} when the window is\n-``insecure''.\n-\n-@item awt.toolkit\n-The class name used for initializing the default @code{java.awt.Toolkit}. \n-Defaults to @code{gnu.awt.gtk.GtkToolkit}.\n-\n-@item http.proxyHost\n-Name of proxy host for http connections.\n-\n-@item http.proxyPort\n-Port number to use when a proxy host is in use.\n-\n-@end table\n-\n-@node GNU Classpath Properties\n-@section GNU Classpath Properties\n-\n-@code{libgcj} is based on the GNU Classpath (Essential Libraries for Java) a\n-GNU project to create free core class libraries for use with virtual machines\n-and compilers for the Java language.  The following properties are common to\n-libraries based on GNU Classpath.\n-\n-@table @gcctabopt\n-\n-@item gcj.dumpobject\n-Enables printing serialization debugging by the @code{java.io.ObjectInput} and\n-@code{java.io.ObjectOutput} classes when set to something else then the empty\n-string.  Only used when running a debug build of the library.\n-\n-@item gnu.classpath.vm.shortname\n-This is a succinct name of the virtual machine.  For @code{libgcj},\n-this will always be @samp{libgcj}.\n-\n-@item gnu.classpath.home.url\n-A base URL used for finding system property files (e.g.,\n-@file{classpath.security}).  By default this is a @samp{file:} URL\n-pointing to the @file{lib} directory under @samp{java.home}.\n-\n-@end table\n-\n-@node libgcj Runtime Properties\n-@section libgcj Runtime Properties\n-\n-The following properties are specific to the @code{libgcj} runtime and will\n-normally not be found in other core libraries for the java language.\n-\n-@table @gcctabopt\n-\n-@item java.fullversion\n-The combination of @code{java.vm.name} and @code{java.vm.version}.\n-\n-@item java.vm.info\n-Same as @code{java.fullversion}.\n-\n-@item impl.prefix\n-Used by the @code{java.net.DatagramSocket} class when set to something else\n-then the empty string.  When set all newly created @code{DatagramSocket}s will\n-try to load a class @code{java.net.[impl.prefix]DatagramSocketImpl} instead of\n-the normal @code{java.net.PlainDatagramSocketImpl}.\n-\n-@item gnu.gcj.progname\n-The class or binary name that was used to invoke the program. This will be\n-the name of the \"main\" class in the case where the @code{gij} front end is\n-used, or the program binary name in the case where an application is compiled \n-to a native binary.\n-\n-@item gnu.gcj.user.realname\n-The real name of the user, as taken from the password file.  This may\n-not always hold only the user's name (as some sites put extra\n-information in this field).  Also, this property is not available on\n-all platforms.\n-\n-@item gnu.gcj.runtime.NameFinder.use_addr2line\n-Whether an external process, @command{addr2line}, should be used to determine\n-line number information when tracing the stack. Setting this to @code{false} \n-may suppress line numbers when printing stack traces and when using\n-the java.util.logging infrastructure. However, performance may improve\n-significantly for applications that print stack traces or make logging calls\n-frequently.\n-\n-@item gnu.gcj.runtime.NameFinder.show_raw\n-Whether the address of a stack frame should be printed when the line\n-number is unavailable. Setting this to @code{true} will cause the name\n-of the object and the offset within that object to be printed when no\n-line number is available.  This allows for off-line decoding of\n-stack traces if necessary debug information is available.  The default\n-is @code{false}, no raw addresses are printed.\n-\n-@item gnu.gcj.runtime.NameFinder.remove_unknown\n-Whether stack frames for non-java code should be included in a stack\n-trace.  The default value is @code{true}, stack frames for non-java\n-code are suppressed.  Setting this to @code{false} will cause any\n-non-java stack frames to be printed in addition to frames for the java\n-code.\n-\n-@item gnu.gcj.runtime.VMClassLoader.library_control\n-This controls how shared libraries are automatically loaded by the\n-built-in class loader.  If this property is set to @samp{full}, a full\n-search is done for each requested class.  If this property is set to\n-@samp{cache}, then any failed lookups are cached and not tried again.\n-If this property is set to @samp{never} (the default), then lookups\n-are never done.  For more information, @xref{Extensions}.\n-\n-@item gnu.gcj.runtime.endorsed.dirs\n-This is like the standard @code{java.endorsed.dirs}, property, but\n-specifies some extra directories which are searched after the standard\n-endorsed directories.  This is primarily useful for telling\n-@code{libgcj} about additional libraries which are ordinarily\n-incorporated into the JDK, and which should be loaded by the bootstrap\n-class loader, but which are not yet part of @code{libgcj} itself for\n-some reason.\n-\n-@item gnu.gcj.jit.compiler\n-@c FIXME we should probably have a whole node on this...\n-This is the full path to @command{gcj} executable which should be\n-used to compile classes just-in-time when\n-@code{ClassLoader.defineClass} is called.  If not set, @command{gcj}\n-will not be invoked by the runtime; this can also be controlled via\n-@code{Compiler.disable}.\n-\n-@item gnu.gcj.jit.options\n-This is a space-separated string of options which should be passed to\n-@command{gcj} when in JIT mode.  If not set, a sensible default is\n-chosen.\n-\n-@item gnu.gcj.jit.cachedir\n-This is the directory where cached shared library files are\n-stored.  If not set, JIT compilation is disabled.  This should never\n-be set to a directory that is writable by any other user.\n-\n-@item gnu.gcj.precompiled.db.path\n-This is a sequence of file names, each referring to a file created by\n-@command{gcj-dbtool}.  These files will be used by @code{libgcj} to\n-find shared libraries corresponding to classes that are loaded from\n-bytecode.  @code{libgcj} often has a built-in default database; it\n-can be queried using @code{gcj-dbtool -p}.\n-\n-@end table\n-\n-\n-@node Resources\n-@chapter Resources\n-\n-While writing @command{gcj} and @code{libgcj} we have, of course, relied\n-heavily on documentation from Sun Microsystems.  In particular we have\n-used The Java Language Specification (both first and second editions),\n-the Java Class Libraries (volumes one and two), and the Java Virtual\n-Machine Specification.  In addition we've used Sun's online documentation.\n-\n-The current @command{gcj} home page is\n-@uref{http://gcc.gnu.org/java/}.\n-\n-For more information on GCC, see @uref{http://gcc.gnu.org/}.\n-\n-Some @code{libgcj} testing is done using the Mauve test suite.  This is\n-a free software Java class library test suite which is being written\n-because the JCK is not free.  See\n-@uref{http://www.sourceware.org/mauve/} for more information.\n-\n-\n-@node Index\n-@unnumbered Index\n-\n-@printindex cp\n-\n-@bye"}, {"sha": "bc65e65a95999bb05e85a8e32f6c63e6bf3dfd6a", "filename": "gcc/java/java-except.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-except.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-except.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-except.h?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,67 +0,0 @@\n-/* Definitions for exception handling for use by the GNU compiler\n-   for the Java(TM) language compiler.\n-   Copyright (C) 1997-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-struct eh_range\n-  {\n-    /* The (byte-code PC) range of the handled block. */\n-    int start_pc;\n-    int end_pc;\n-\n-    /* A list of handlers.  For each element in the list,\n-       the TREE_PURPOSE is the handled class (NULL_EXPR for a finally block),\n-       and the TREE_VALUE is the LABEL_DECL of the handler. */\n-    tree handlers;\n-\n-    /* Surrounding handler, if any. */\n-    struct eh_range *outer;\n-\n-    /* The first child range.  It is nested inside this range\n-       (i.e. this.start_pc <= first_child.end_pc\n-       && this.end_pc >= first_child.end_pc).\n-       The children are linked together using next_sibling, and are sorted\n-       by increasing start_pc and end_pc (we do not support non-nested\n-       overlapping ranges). */\n-    struct eh_range *first_child;\n-\n-    /* The next child of outer, in address order. */\n-    struct eh_range *next_sibling;\n-\n-    /* True if this range has already been expanded. */\n-    int expanded;\n-\n-    /* The TRY_CATCH_EXPR for this EH range.  */\n-    tree stmt;\n-  };\n-\n-/* A dummy range that represents the entire method. */\n-extern struct eh_range whole_range;\n-\n-#define NULL_EH_RANGE (&whole_range)\n-\n-extern struct eh_range * find_handler (int);\n-extern void method_init_exceptions (void);\n-extern void maybe_start_try (int, int);\n-extern void add_handler (int, int, tree, tree);\n-extern void expand_end_java_handler (struct eh_range *);\n-extern bool sanity_check_exception_range (struct eh_range *);"}, {"sha": "c723cb665ceafdad8d8dcc8c21a3a6c6a2b6ccf1", "filename": "gcc/java/java-gimplify.c", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,172 +0,0 @@\n-/* Java(TM) language-specific gimplification routines.\n-   Copyright (C) 2003-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"function.h\"\n-#include \"basic-block.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"java-tree.h\"\n-#include \"dumpfile.h\"\n-#include \"gimplify.h\"\n-\n-static tree java_gimplify_block (tree);\n-static enum gimplify_status java_gimplify_modify_expr (tree *);\n-static enum gimplify_status java_gimplify_self_mod_expr (tree *, gimple_seq *,\n-\t\t\t\t\t\t\t gimple_seq *);\n-\n-static void dump_java_tree (enum tree_dump_index, tree);\n-\n-/* Convert a Java tree to GENERIC.  */\n-\n-void\n-java_genericize (tree fndecl)\n-{\n-  walk_tree (&DECL_SAVED_TREE (fndecl), java_replace_references, NULL, NULL);\n-  dump_java_tree (TDI_original, fndecl);\n-}\n-\n-/* Gimplify a Java tree.  */\n-\n-int\n-java_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n-{\n-  enum tree_code code = TREE_CODE (*expr_p);\n-\n-  switch (code)\n-    {\n-    case BLOCK:\n-      *expr_p = java_gimplify_block (*expr_p);\n-      break;\n-\n-    case MODIFY_EXPR:\n-      return java_gimplify_modify_expr (expr_p);\n-\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-      return java_gimplify_self_mod_expr (expr_p, pre_p, post_p);\n-      \n-    /* These should already be lowered before we get here.  */\n-    case URSHIFT_EXPR:\n-    case COMPARE_EXPR:\n-    case COMPARE_L_EXPR:\n-    case COMPARE_G_EXPR:\n-      gcc_unreachable ();\n-\n-    default:\n-      return GS_UNHANDLED;\n-    }\n-\n-  return GS_OK;\n-}\n-\n-static enum gimplify_status\n-java_gimplify_modify_expr (tree *modify_expr_p)\n-{\n-  tree modify_expr = *modify_expr_p;\n-  tree lhs = TREE_OPERAND (modify_expr, 0);\n-  tree rhs = TREE_OPERAND (modify_expr, 1);\n-  tree lhs_type = TREE_TYPE (lhs);\n-\n-  if (lhs_type != TREE_TYPE (rhs))\n-    /* Fix up type mismatches to make legal GIMPLE.  These are\n-       generated in several places, in particular null pointer\n-       assignment and subclass assignment.  */\n-    TREE_OPERAND (modify_expr, 1) = convert (lhs_type, rhs);\n-\n-  return GS_UNHANDLED;\n-}\n-\n-/*  Special case handling for volatiles: we need to generate a barrier\n-    between the reading and the writing.  */\n-\n-static enum gimplify_status\n-java_gimplify_self_mod_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED, \n-\t\t\t     gimple_seq *post_p ATTRIBUTE_UNUSED)\n-{\n-  tree lhs = TREE_OPERAND (*expr_p, 0);\n-\n-  if (TREE_CODE (lhs) == COMPONENT_REF\n-      && TREE_THIS_VOLATILE (TREE_OPERAND (lhs, 1)))\n-    TREE_THIS_VOLATILE (lhs) = 1;\n-\n-  return GS_UNHANDLED;\n-}\n-\n-    \n-/* Gimplify BLOCK into a BIND_EXPR.  */\n-\n-static tree\n-java_gimplify_block (tree java_block)\n-{\n-  tree decls = BLOCK_VARS (java_block);\n-  tree body = BLOCK_EXPR_BODY (java_block);\n-  gbind *outer = gimple_current_bind_expr ();\n-  tree block;\n-\n-  /* Don't bother with empty blocks.  */\n-  if (! body)\n-    return build_empty_stmt (input_location);\n-\n-  if (IS_EMPTY_STMT (body))\n-    return body;\n-\n-  /* Make a proper block.  Java blocks are unsuitable for BIND_EXPR\n-     because they use BLOCK_SUBBLOCKS for another purpose.  */\n-  block = make_node (BLOCK);\n-  BLOCK_VARS (block) = decls;\n-\n-  /* The TREE_USED flag on a block determines whether the debug output\n-     routines generate info for the variables in that block.  */\n-  TREE_USED (block) = 1;\n-\n-  if (outer != NULL)\n-    {\n-      tree b = gimple_bind_block (outer);\n-      BLOCK_SUBBLOCKS (b) = chainon (BLOCK_SUBBLOCKS (b), block);\n-    }\n-  BLOCK_EXPR_BODY (java_block) = NULL_TREE;\n-\n-  return build3 (BIND_EXPR, TREE_TYPE (java_block), decls, body, block);\n-}\n-\n-/* Dump a tree of some kind.  This is a convenience wrapper for the\n-   dump_* functions in tree-dump.c.  */\n-static void\n-dump_java_tree (enum tree_dump_index phase, tree t)\n-{\n-  FILE *stream;\n-  int flags;\n-\n-  stream = dump_begin (phase, &flags);\n-  flags |= TDF_SLIM;\n-  if (stream)\n-    {\n-      dump_node (t, flags, stream);\n-      dump_end (phase, stream);\n-    }\n-}"}, {"sha": "12b3a72f77f5dae948f4b296bb1db0f132eda55b", "filename": "gcc/java/java-opcodes.h", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-opcodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-opcodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-opcodes.h?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,6 +0,0 @@\n-enum java_opcode {\n-#define JAVAOP(NAME, CODE, KIND, TYPE, VALUE) OPCODE_##NAME = CODE,\n-#include \"javaop.def\"\n-#undef JAVAOP\n-LAST_AND_UNUSED_JAVA_OPCODE\n-};"}, {"sha": "63eac49895e1f425abfda92f2e153e0959ea8f72", "filename": "gcc/java/java-tree.def", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,38 +0,0 @@\n-/* This file contains the definitions and documentation for the\n-   extra tree codes used by gcj.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* Shift right, logical. */\n-DEFTREECODE (URSHIFT_EXPR, \"urshift_expr\", tcc_binary, 2)\n-\n-/* Return -1, 0, 1 depending on whether the first argument is\n-   less, equal, or greater to the second argument. */\n-DEFTREECODE (COMPARE_EXPR, \"compare_expr\", tcc_binary, 2)\n-\n-/* Same as COMPARE_EXPR, but if either value is NaN, the result is -1. */\n-DEFTREECODE (COMPARE_L_EXPR, \"compare_l_expr\", tcc_binary, 2)\n-/* Same as COMPARE_EXPR, but if either value is NaN, the result is 1. */\n-DEFTREECODE (COMPARE_G_EXPR, \"compare_g_expr\", tcc_binary, 2)\n-\n-/*\n-Local variables:\n-mode:c\n-End:\n-*/"}, {"sha": "d7ccbbe87687074d7d8fce591e1c8922ffb9841c", "filename": "gcc/java/java-tree.h", "status": "removed", "additions": 0, "deletions": 1527, "changes": 1527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,1527 +0,0 @@\n-/* Definitions for parsing and type checking for the GNU compiler for\n-   the Java(TM) language.\n-   Copyright (C) 1997-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n-\n-#ifndef GCC_JAVA_TREE_H\n-#define GCC_JAVA_TREE_H\n-\n-\n-struct JCF;\n-\n-/* Usage of TREE_LANG_FLAG_?:\n-   2: QUALIFIED_P (in IDENTIFIER_NODE)\n-      CLASS_FILE_P (in a TRANSLATION_UNIT_DECL in current_file_list)\n-   3: HAS_FINALIZER (in RECORD_TYPE)\n-   4: IS_A_COMMAND_LINE_FILENAME_P (in IDENTIFIER_NODE)\n-      IS_ARRAY_LENGTH_ACCESS (in INDIRECT_REF)\n-   5: HAS_BEEN_ALREADY_PARSED_P (in IDENTIFIER_NODE)\n-\n-   Usage of TYPE_LANG_FLAG_?:\n-   1: TYPE_ARRAY_P (in RECORD_TYPE).\n-   2: CLASS_PARSED_P (in RECORD_TYPE).\n-   4: CLASS_P (in RECORD_TYPE).\n-   5: CLASS_FROM_CURRENTLY_COMPILED_P (in RECORD_TYPE)\n-   6: CLASS_BEING_LAIDOUT (in RECORD_TYPE)\n-\n-   Usage of DECL_LANG_FLAG_?:\n-   0: METHOD_DEPRECATED (in FUNCTION_DECL).\n-      FIELD_DEPRECATED (in FIELD_DECL).\n-      CLASS_DEPRECATED (in TYPE_DECL).\n-   1: METHOD_PUBLIC (in FUNCTION_DECL).\n-      FIELD_PUBLIC (in FIELD_DECL).\n-      CLASS_PUBLIC (in TYPE_DECL).\n-   2: METHOD_STATIC (in FUNCTION_DECL).\n-      (But note that FIELD_STATIC uses TREE_STATIC!)\n-      FIELD_SYNTHETIC (in FIELD_DECL)\n-      CLASS_COMPLETE_P (in TYPE_DECL)\n-   3: METHOD_FINAL (in FUNCTION_DECL)\n-      FIELD_FINAL (in FIELD_DECL)\n-      CLASS_FINAL (in TYPE_DECL)\n-      DECL_FINAL (in any decl)\n-   4: METHOD_SYNCHRONIZED (in FUNCTION_DECL).\n-      CLASS_INTERFACE (in TYPE_DECL)\n-      FIELD_VOLATILE (int FIELD_DECL)\n-   5: METHOD_ABSTRACT (in FUNCTION_DECL).\n-      CLASS_ABSTRACT (in TYPE_DECL)\n-      FIELD_TRANSIENT (in FIELD_DECL)\n-   6: CLASS_SUPER (in TYPE_DECL, ACC_SUPER flag)\n-   7: DECL_CONSTRUCTOR_P (in FUNCTION_DECL).\n-      CLASS_STATIC (in TYPE_DECL)\n-*/\n-\n-#define VAR_OR_FIELD_CHECK(DECL) \\\n-  TREE_CHECK3 (DECL, FIELD_DECL, VAR_DECL, PARM_DECL)\n-\n-/* True if the class whose TYPE_BINFO this is has a superclass.\n-   (True of all classes except Object.) */\n-#define CLASS_HAS_SUPER_FLAG(BINFO) BINFO_FLAG_1 (BINFO)\n-#define CLASS_HAS_SUPER(TYPE) \\\n-  (TYPE_BINFO (TYPE) && CLASS_HAS_SUPER_FLAG (TYPE_BINFO (TYPE)))\n-\n-/* Return the supertype of class TYPE, or NULL_TREE is it has none. */\n-#define CLASSTYPE_SUPER(TYPE) (CLASS_HAS_SUPER (TYPE) \\\n-  ? BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (TYPE), 0)) \\\n-  : NULL_TREE)\n-\n-/* The class defined by the actual (main) file we are compiling. */\n-#define main_class \\\n-  java_global_trees[JTI_MAIN_CLASS]\n-\n-/* The class we use as the base for name resolution.  It's usually the\n-   class we're generating code for but sometimes it points to an inner\n-   class.  If you really want to know the class we're currently\n-   generating code for, use output_class instead.  */\n-#define current_class \\\n-  java_global_trees[JTI_CURRENT_CLASS]\n-\n-/* The class we are currently generating.  Really.  */\n-#define output_class \\\n-  java_global_trees[JTI_OUTPUT_CLASS]\n-\n-/* List of virtual decls referred to by this translation unit, used to\n-   generate virtual method offset symbol table.  */\n-\n-/* The virtual offset table.  This is emitted as uninitialized data of\n-   the required length, and filled out at run time during class\n-   linking. */\n-\n-/* The virtual offset symbol table. Used by the runtime to fill out\n-   the otable. */\n-\n-/* Resource name.  */\n-extern const char *resource_name;\n-\n-/* Turned to 1 if -Wall was encountered. See lang.c for their meanings.  */\n-extern int flag_wall;\n-\n-/* The Java .class file that provides main_class;  the main input file. */\n-extern GTY(()) struct JCF * current_jcf;\n-\n-/* Set to nonzero value in order to emit class initialization code\n-   before static field references.  */\n-extern int always_initialize_class_p;\n-\n-extern int flag_verify_invocations;\n-\n-/* Largest pc so far in this method that has been passed to lookup_label. */\n-extern int highest_label_pc_this_method;\n-\n-/* Base value for this method to add to pc to get generated label. */\n-extern int start_label_pc_this_method;\n-\n-typedef struct CPool constant_pool;\n-\n-#define CONSTANT_ResolvedFlag 16\n-\n-/* Don't eagerly resolve this entry.  When this flag is set, constant\n-   pool entries are resolved only at runtime when the entry is first\n-   referred to.  */\n-#define CONSTANT_LazyFlag 32\n-\n-/* The cpool->data[i] for a ResolvedString points to a STRING_CST. */\n-#define CONSTANT_ResolvedString    (CONSTANT_String+CONSTANT_ResolvedFlag)\n-\n-/* The cpool->data[i] for a ResolvedClass points to a RECORD_TYPE. */\n-#define CONSTANT_ResolvedClass     (CONSTANT_Class+CONSTANT_ResolvedFlag)\n-\n-#define CPOOL_UTF(CPOOL, INDEX) ((CPOOL)->data[INDEX].t)\n-\n-/* A NameAndType constant is represented as a TREE_LIST.\n-   The type is the signature string (as an IDENTIFIER_NODE).  */\n-\n-#define NAME_AND_TYPE_NAME(CPOOL, IDX) \\\n-  CPOOL_UTF(CPOOL, CPOOL_USHORT1(CPOOL, IDX))\n-#define NAME_AND_TYPE_SIGNATURE(CPOOL, IDX) \\\n-  CPOOL_UTF(CPOOL, CPOOL_USHORT2(CPOOL, IDX))\n-\n-/* A FieldRef, MethodRef or InterfaceMethodRef constant\n-   is represented as a TREE_LIST. */\n-\n-#define COMPONENT_REF_CLASS_INDEX(CPOOL, IDX) CPOOL_USHORT1(CPOOL, IDX)\n-#define COMPONENT_REF_NAME_AND_TYPE(CPOOL, IDX) CPOOL_USHORT2(CPOOL, IDX)\n-#define COMPONENT_REF_NAME(CPOOL, IDX) \\\n-  NAME_AND_TYPE_NAME (CPOOL, COMPONENT_REF_NAME_AND_TYPE(CPOOL, IDX))\n-#define COMPONENT_REF_SIGNATURE(CPOOL, IDX) \\\n-  NAME_AND_TYPE_SIGNATURE (CPOOL, COMPONENT_REF_NAME_AND_TYPE(CPOOL, IDX))\n-\n-extern GTY(()) tree java_lang_cloneable_identifier_node;\n-extern GTY(()) tree java_io_serializable_identifier_node;\n-extern GTY(()) tree gcj_abi_version;\n-\n-/* The decl for the .constants field of an instance of Class.  */\n-extern GTY(()) tree constants_field_decl_node;\n-\n-/* The decl for the .data field of an instance of Class.  */\n-extern GTY(()) tree constants_data_field_decl_node;\n-\n-enum java_tree_index\n-{\n-  JTI_PROMOTED_BYTE_TYPE_NODE,\n-  JTI_PROMOTED_SHORT_TYPE_NODE,\n-  JTI_PROMOTED_CHAR_TYPE_NODE,\n-  JTI_PROMOTED_BOOLEAN_TYPE_NODE,\n-\n-  JTI_BYTE_TYPE_NODE,\n-  JTI_SHORT_TYPE_NODE,\n-  JTI_INT_TYPE_NODE,\n-  JTI_LONG_TYPE_NODE,\n-  \n-  JTI_UNSIGNED_BYTE_TYPE_NODE,\n-  JTI_UNSIGNED_SHORT_TYPE_NODE,\n-  JTI_UNSIGNED_INT_TYPE_NODE,\n-  JTI_UNSIGNED_LONG_TYPE_NODE,\n-  \n-  JTI_DECIMAL_INT_MAX_NODE,\n-  JTI_DECIMAL_LONG_MAX_NODE,\n-\n-  JTI_OBJECT_TYPE_NODE,\n-  JTI_UNQUALIFIED_OBJECT_ID_NODE,\n-  JTI_OBJECT_PTR_TYPE_NODE,\n-  JTI_STRING_TYPE_NODE,\n-  JTI_STRING_PTR_TYPE_NODE,\n-  JTI_THROWABLE_TYPE_NODE,\n-  JTI_EXCEPTION_TYPE_NODE,\n-  JTI_RUNTIME_EXCEPTION_TYPE_NODE,\n-  JTI_ERROR_EXCEPTION_TYPE_NODE,\n-  JTI_RAWDATA_PTR_TYPE_NODE,\n-\n-  JTI_BYTE_ARRAY_TYPE_NODE,\n-  JTI_SHORT_ARRAY_TYPE_NODE,\n-  JTI_INT_ARRAY_TYPE_NODE,\n-  JTI_LONG_ARRAY_TYPE_NODE,\n-  JTI_BOOLEAN_ARRAY_TYPE_NODE,\n-  JTI_CHAR_ARRAY_TYPE_NODE,\n-  JTI_DOUBLE_ARRAY_TYPE_NODE,\n-  JTI_FLOAT_ARRAY_TYPE_NODE,\n-  JTI_ARRAY_ARRAY_TYPE_NODE,\n-  JTI_OBJECT_ARRAY_TYPE_NODE,\n-  JTI_STRING_ARRAY_TYPE_NODE,\n-  JTI_BOOLEAN_ARRAY_VTABLE,\n-  JTI_BYTE_ARRAY_VTABLE,\n-  JTI_CHAR_ARRAY_VTABLE,\n-  JTI_SHORT_ARRAY_VTABLE,\n-  JTI_INT_ARRAY_VTABLE,\n-  JTI_LONG_ARRAY_VTABLE,\n-  JTI_FLOAT_ARRAY_VTABLE,\n-  JTI_DOUBLE_ARRAY_VTABLE,\n-  JTI_TYPE_IDENTIFIER_NODE,      \n-  JTI_INIT_IDENTIFIER_NODE,      \n-  JTI_CLINIT_IDENTIFIER_NODE,      \n-  JTI_VOID_SIGNATURE_NODE,       \n-  JTI_FINALIZE_IDENTIFIER_NODE,\n-  JTI_THIS_IDENTIFIER_NODE,  \n-  JTI_ONE_ELT_ARRAY_DOMAIN_TYPE,\n-\n-  JTI_RETURN_ADDRESS_TYPE_NODE,\n-\n-  JTI_LONG_ZERO_NODE,\n-  JTI_FLOAT_ZERO_NODE,\n-  JTI_DOUBLE_ZERO_NODE,\n-  JTI_INTEGER_TWO_NODE,\n-  JTI_INTEGER_FOUR_NODE,\n-\n-  JTI_METHODTABLE_TYPE,\n-  JTI_METHODTABLE_PTR_TYPE,\n-\n-  JTI_UTF8CONST_TYPE,\n-  JTI_UTF8CONST_PTR_TYPE,\n-\n-  JTI_CLASS_TYPE_NODE,\n-  JTI_CLASS_PTR_TYPE,\n-  JTI_FIELD_TYPE_NODE,\n-  JTI_CONSTANTS_TYPE_NODE,\n-  JTI_DTABLE_TYPE, \n-  JTI_DTABLE_PTR_TYPE,\n-  JTI_FIELD_PTR_TYPE_NODE,\n-  JTI_FIELD_INFO_UNION_NODE,\n-  JTI_EXCEPTION_TYPE,\n-  JTI_EXCEPTION_PTR_TYPE,\n-  JTI_LINENUMBERENTRY_TYPE,\n-  JTI_LINENUMBERS_TYPE,\n-  JTI_METHOD_TYPE_NODE,\n-  JTI_METHOD_PTR_TYPE_NODE,\n-  JTI_OTABLE_TYPE,\n-  JTI_OTABLE_PTR_TYPE,\n-  JTI_ATABLE_TYPE,\n-  JTI_ATABLE_PTR_TYPE,\n-  JTI_ITABLE_TYPE,\n-  JTI_ITABLE_PTR_TYPE,\n-  JTI_SYMBOL_TYPE,\n-  JTI_SYMBOLS_ARRAY_TYPE,\n-  JTI_SYMBOLS_ARRAY_PTR_TYPE,\n-  JTI_ASSERTION_ENTRY_TYPE,\n-  JTI_ASSERTION_TABLE_TYPE,\n-\n-  JTI_END_PARAMS_NODE,\n-\n-  JTI_THROW_NODE,\n-  JTI_ALLOC_OBJECT_NODE,\n-  JTI_ALLOC_NO_FINALIZER_NODE,\n-  JTI_SOFT_INSTANCEOF_NODE,\n-  JTI_SOFT_CHECKCAST_NODE,\n-  JTI_SOFT_INITCLASS_NODE,\n-  JTI_SOFT_NEWARRAY_NODE,\n-  JTI_SOFT_ANEWARRAY_NODE,\n-  JTI_SOFT_MULTIANEWARRAY_NODE,\n-  JTI_SOFT_BADARRAYINDEX_NODE,\n-  JTI_SOFT_NULLPOINTER_NODE,\n-  JTI_SOFT_ABSTRACTMETHOD_NODE,\n-  JTI_SOFT_NOSUCHFIELD_NODE,\n-  JTI_SOFT_CHECKARRAYSTORE_NODE,\n-  JTI_SOFT_MONITORENTER_NODE,\n-  JTI_SOFT_MONITOREXIT_NODE,\n-  JTI_SOFT_LOOKUPINTERFACEMETHOD_NODE,\n-  JTI_SOFT_LOOKUPINTERFACEMETHODBYNAME_NODE,\n-  JTI_SOFT_LOOKUPJNIMETHOD_NODE,\n-  JTI_SOFT_GETJNIENVNEWFRAME_NODE,\n-  JTI_SOFT_JNIPOPSYSTEMFRAME_NODE,\n-  JTI_SOFT_UNWRAPJNI_NODE,\n-  JTI_SOFT_FMOD_NODE,\n-  JTI_SOFT_IDIV_NODE,\n-  JTI_SOFT_IREM_NODE,\n-  JTI_SOFT_LDIV_NODE,\n-  JTI_SOFT_LREM_NODE,\n-\n-  JTI_ACCESS_FLAGS_TYPE_NODE,\n-\n-  JTI_NATIVECODE_PTR_ARRAY_TYPE_NODE,\n-\n-  JTI_MAIN_CLASS,\n-  JTI_CURRENT_CLASS,\n-  JTI_OUTPUT_CLASS,\n-\n-  JTI_MAX\n-};\n-\n-extern GTY(()) tree java_global_trees[JTI_MAX];\n-\n-/* \"Promoted types\" that are used for primitive types smaller\n-   than int.  We could use int_type_node, but then we would lose\n-   type information (such as needed for debugging). */\n-#define promoted_byte_type_node \\\n-  java_global_trees[JTI_PROMOTED_BYTE_TYPE_NODE]\n-#define promoted_short_type_node \\\n-  java_global_trees[JTI_PROMOTED_SHORT_TYPE_NODE]\n-#define promoted_char_type_node \\\n-  java_global_trees[JTI_PROMOTED_CHAR_TYPE_NODE]\n-#define promoted_boolean_type_node \\\n-  java_global_trees[JTI_PROMOTED_BOOLEAN_TYPE_NODE]\n-\n-#define byte_type_node \\\n-  java_global_trees[JTI_BYTE_TYPE_NODE]\n-#define short_type_node \\\n-  java_global_trees[JTI_SHORT_TYPE_NODE]\n-#define int_type_node \\\n-  java_global_trees[JTI_INT_TYPE_NODE]\n-#define long_type_node \\\n-  java_global_trees[JTI_LONG_TYPE_NODE]\n-\n-#define unsigned_byte_type_node \\\n-  java_global_trees[JTI_UNSIGNED_BYTE_TYPE_NODE]\n-#define unsigned_short_type_node \\\n-  java_global_trees[JTI_UNSIGNED_SHORT_TYPE_NODE]\n-#define unsigned_int_type_node \\\n-  java_global_trees[JTI_UNSIGNED_INT_TYPE_NODE]\n-#define unsigned_long_type_node \\\n-  java_global_trees[JTI_UNSIGNED_LONG_TYPE_NODE]\n-\n-#define decimal_int_max \\\n-  java_global_trees[JTI_DECIMAL_INT_MAX_NODE]\n-#define decimal_long_max \\\n-  java_global_trees[JTI_DECIMAL_LONG_MAX_NODE]\n-\n-#define object_type_node \\\n-  java_global_trees[JTI_OBJECT_TYPE_NODE]\n-#define unqualified_object_id_node \\\n-  java_global_trees[JTI_UNQUALIFIED_OBJECT_ID_NODE]\n-#define object_ptr_type_node \\\n-  java_global_trees[JTI_OBJECT_PTR_TYPE_NODE]\n-#define string_type_node \\\n-  java_global_trees[JTI_STRING_TYPE_NODE]\n-#define string_ptr_type_node \\\n-  java_global_trees[JTI_STRING_PTR_TYPE_NODE]\n-#define throwable_type_node \\\n-  java_global_trees[JTI_THROWABLE_TYPE_NODE]\n-#define exception_type_node \\\n-  java_global_trees[JTI_EXCEPTION_TYPE_NODE]\n-#define runtime_exception_type_node \\\n-  java_global_trees[JTI_RUNTIME_EXCEPTION_TYPE_NODE]\n-#define error_exception_type_node \\\n-  java_global_trees[JTI_ERROR_EXCEPTION_TYPE_NODE]\n-#define rawdata_ptr_type_node \\\n-  java_global_trees[JTI_RAWDATA_PTR_TYPE_NODE]\n-\n-#define byte_array_type_node \\\n-  java_global_trees[JTI_BYTE_ARRAY_TYPE_NODE]\n-#define short_array_type_node \\\n-  java_global_trees[JTI_SHORT_ARRAY_TYPE_NODE]\n-#define int_array_type_node \\\n-  java_global_trees[JTI_INT_ARRAY_TYPE_NODE]\n-#define long_array_type_node \\\n-  java_global_trees[JTI_LONG_ARRAY_TYPE_NODE]\n-#define boolean_array_type_node \\\n-  java_global_trees[JTI_BOOLEAN_ARRAY_TYPE_NODE]\n-#define char_array_type_node \\\n-  java_global_trees[JTI_CHAR_ARRAY_TYPE_NODE]\n-#define double_array_type_node \\\n-  java_global_trees[JTI_DOUBLE_ARRAY_TYPE_NODE]\n-#define float_array_type_node \\\n-  java_global_trees[JTI_FLOAT_ARRAY_TYPE_NODE]\n-#define array_array_type_node \\\n-  java_global_trees[JTI_ARRAY_ARRAY_TYPE_NODE]\n-#define object_array_type_node \\\n-  java_global_trees[JTI_OBJECT_ARRAY_TYPE_NODE]\n-#define string_array_type_node \\\n-  java_global_trees[JTI_STRING_ARRAY_TYPE_NODE]\n-#define boolean_array_vtable \\\n-  java_global_trees[JTI_BOOLEAN_ARRAY_VTABLE]\n-#define byte_array_vtable \\\n-  java_global_trees[JTI_BYTE_ARRAY_VTABLE]\n-#define char_array_vtable \\\n-  java_global_trees[JTI_CHAR_ARRAY_VTABLE]\n-#define short_array_vtable \\\n-  java_global_trees[JTI_SHORT_ARRAY_VTABLE]\n-#define int_array_vtable \\\n-  java_global_trees[JTI_INT_ARRAY_VTABLE]\n-#define long_array_vtable \\\n-  java_global_trees[JTI_LONG_ARRAY_VTABLE]\n-#define float_array_vtable \\\n-  java_global_trees[JTI_FLOAT_ARRAY_VTABLE]\n-#define double_array_vtable \\\n-  java_global_trees[JTI_DOUBLE_ARRAY_VTABLE]\n-#define TYPE_identifier_node \\\n-  java_global_trees[JTI_TYPE_IDENTIFIER_NODE]      /* \"TYPE\" */\n-#define init_identifier_node \\\n-  java_global_trees[JTI_INIT_IDENTIFIER_NODE]      /* \"<init>\" */\n-#define clinit_identifier_node \\\n-  java_global_trees[JTI_CLINIT_IDENTIFIER_NODE]      /* \"<clinit>\" */\n-#define void_signature_node \\\n-  java_global_trees[JTI_VOID_SIGNATURE_NODE]       /* \"()V\" */\n-#define finalize_identifier_node \\\n-  java_global_trees[JTI_FINALIZE_IDENTIFIER_NODE]  /* \"finalize\" */\n-#define this_identifier_node \\\n-  java_global_trees[JTI_THIS_IDENTIFIER_NODE]  /* \"this\" */\n-#define one_elt_array_domain_type \\\n-  java_global_trees[JTI_ONE_ELT_ARRAY_DOMAIN_TYPE]\n-/* The type of the return address of a subroutine. */\n-#define return_address_type_node \\\n-  java_global_trees[JTI_RETURN_ADDRESS_TYPE_NODE]\n-\n-/* Integer constants not declared in tree.h. */\n-#define long_zero_node \\\n-  java_global_trees[JTI_LONG_ZERO_NODE]\n-#define float_zero_node \\\n-  java_global_trees[JTI_FLOAT_ZERO_NODE]\n-#define double_zero_node \\\n-  java_global_trees[JTI_DOUBLE_ZERO_NODE]\n-#define integer_two_node \\\n-  java_global_trees[JTI_INTEGER_TWO_NODE]\n-#define integer_four_node \\\n-  java_global_trees[JTI_INTEGER_FOUR_NODE]\n-\n-/* The type for struct methodtable. */\n-#define methodtable_type \\\n-  java_global_trees[JTI_METHODTABLE_TYPE]\n-#define methodtable_ptr_type \\\n-  java_global_trees[JTI_METHODTABLE_PTR_TYPE]\n-\n-#define utf8const_type \\\n-  java_global_trees[JTI_UTF8CONST_TYPE]\n-#define utf8const_ptr_type \\\n-  java_global_trees[JTI_UTF8CONST_PTR_TYPE]\n-\n-#define class_type_node \\\n-  java_global_trees[JTI_CLASS_TYPE_NODE]\n-#define class_ptr_type \\\n-  java_global_trees[JTI_CLASS_PTR_TYPE]\n-#define field_type_node \\\n-  java_global_trees[JTI_FIELD_TYPE_NODE]\n-#define constants_type_node \\\n-  java_global_trees[JTI_CONSTANTS_TYPE_NODE]\n-#define dtable_type \\\n-  java_global_trees[JTI_DTABLE_TYPE]\n-#define dtable_ptr_type \\\n-  java_global_trees[JTI_DTABLE_PTR_TYPE]\n-#define field_ptr_type_node \\\n-  java_global_trees[JTI_FIELD_PTR_TYPE_NODE]\n-#define field_info_union_node \\\n-  java_global_trees[JTI_FIELD_INFO_UNION_NODE]\n-#define jexception_type \\\n-  java_global_trees[JTI_EXCEPTION_TYPE]\n-#define jexception_ptr_type \\\n-  java_global_trees[JTI_EXCEPTION_PTR_TYPE]\n-#define lineNumberEntry_type \\\n-  java_global_trees[JTI_LINENUMBERENTRY_TYPE]\n-#define lineNumbers_type \\\n-  java_global_trees[JTI_LINENUMBERS_TYPE]\n-#define method_type_node \\\n-  java_global_trees[JTI_METHOD_TYPE_NODE]\n-#define method_ptr_type_node \\\n-  java_global_trees[JTI_METHOD_PTR_TYPE_NODE]\n-#define otable_type \\\n-  java_global_trees[JTI_OTABLE_TYPE]\n-#define atable_type \\\n-  java_global_trees[JTI_ATABLE_TYPE]\n-#define itable_type \\\n-  java_global_trees[JTI_ITABLE_TYPE]\n-#define otable_ptr_type \\\n-  java_global_trees[JTI_OTABLE_PTR_TYPE]\n-#define atable_ptr_type \\\n-  java_global_trees[JTI_ATABLE_PTR_TYPE]\n-#define itable_ptr_type \\\n-  java_global_trees[JTI_ITABLE_PTR_TYPE]\n-#define symbol_type \\\n-  java_global_trees[JTI_SYMBOL_TYPE]\n-#define symbols_array_type \\\n-  java_global_trees[JTI_SYMBOLS_ARRAY_TYPE]\n-#define symbols_array_ptr_type \\\n-  java_global_trees[JTI_SYMBOLS_ARRAY_PTR_TYPE]  \n-#define assertion_entry_type \\\n-  java_global_trees[JTI_ASSERTION_ENTRY_TYPE]\n-#define assertion_table_type \\\n-  java_global_trees[JTI_ASSERTION_TABLE_TYPE]\n-\n-#define end_params_node \\\n-  java_global_trees[JTI_END_PARAMS_NODE]\n-\n-/* References to internal libjava functions we use. */\n-#define throw_node \\\n-  java_global_trees[JTI_THROW_NODE]\n-#define alloc_object_node \\\n-  java_global_trees[JTI_ALLOC_OBJECT_NODE]\n-#define alloc_no_finalizer_node \\\n-  java_global_trees[JTI_ALLOC_NO_FINALIZER_NODE]\n-#define soft_instanceof_node \\\n-  java_global_trees[JTI_SOFT_INSTANCEOF_NODE]\n-#define soft_checkcast_node \\\n-  java_global_trees[JTI_SOFT_CHECKCAST_NODE]\n-#define soft_initclass_node \\\n-  java_global_trees[JTI_SOFT_INITCLASS_NODE]\n-#define soft_newarray_node \\\n-  java_global_trees[JTI_SOFT_NEWARRAY_NODE]\n-#define soft_anewarray_node \\\n-  java_global_trees[JTI_SOFT_ANEWARRAY_NODE]\n-#define soft_multianewarray_node \\\n-  java_global_trees[JTI_SOFT_MULTIANEWARRAY_NODE]\n-#define soft_badarrayindex_node \\\n-  java_global_trees[JTI_SOFT_BADARRAYINDEX_NODE]\n-#define soft_nullpointer_node \\\n-  java_global_trees[JTI_SOFT_NULLPOINTER_NODE]\n-#define soft_abstractmethod_node \\\n-  java_global_trees[JTI_SOFT_ABSTRACTMETHOD_NODE]\n-#define soft_nosuchfield_node \\\n-  java_global_trees[JTI_SOFT_NOSUCHFIELD_NODE]\n-#define soft_checkarraystore_node \\\n-  java_global_trees[JTI_SOFT_CHECKARRAYSTORE_NODE]\n-#define soft_monitorenter_node \\\n-  java_global_trees[JTI_SOFT_MONITORENTER_NODE]\n-#define soft_monitorexit_node \\\n-  java_global_trees[JTI_SOFT_MONITOREXIT_NODE]\n-#define soft_lookupinterfacemethod_node \\\n-  java_global_trees[JTI_SOFT_LOOKUPINTERFACEMETHOD_NODE]\n-#define soft_lookupinterfacemethodbyname_node \\\n-  java_global_trees[JTI_SOFT_LOOKUPINTERFACEMETHODBYNAME_NODE]\n-#define soft_lookupjnimethod_node \\\n-  java_global_trees[JTI_SOFT_LOOKUPJNIMETHOD_NODE]\n-#define soft_getjnienvnewframe_node \\\n-  java_global_trees[JTI_SOFT_GETJNIENVNEWFRAME_NODE]\n-#define soft_jnipopsystemframe_node \\\n-  java_global_trees[JTI_SOFT_JNIPOPSYSTEMFRAME_NODE]\n-#define soft_unwrapjni_node \\\n-  java_global_trees[JTI_SOFT_UNWRAPJNI_NODE]\n-#define soft_fmod_node \\\n-  java_global_trees[JTI_SOFT_FMOD_NODE]\n-#define soft_idiv_node \\\n-  java_global_trees[JTI_SOFT_IDIV_NODE]\n-#define soft_irem_node \\\n-  java_global_trees[JTI_SOFT_IREM_NODE]\n-#define soft_ldiv_node \\\n-  java_global_trees[JTI_SOFT_LDIV_NODE]\n-#define soft_lrem_node \\\n-  java_global_trees[JTI_SOFT_LREM_NODE]\n-\n-#define access_flags_type_node \\\n-  java_global_trees[JTI_ACCESS_FLAGS_TYPE_NODE]\n-\n-#define nativecode_ptr_array_type_node \\\n-  java_global_trees[JTI_NATIVECODE_PTR_ARRAY_TYPE_NODE]\n-\n-#define nativecode_ptr_type_node ptr_type_node\n-\n-/* The decl for \"_Jv_ResolvePoolEntry\".  */\n-extern GTY(()) tree soft_resolvepoolentry_node;\n-\n-struct GTY(()) lang_identifier {\n-  struct tree_identifier ignore;\n-  tree global_value;\n-  tree local_value;\n-\n-  /* If non-NULL:  An ADDR_REF to a VAR_DECL that contains\n-   * the Utf8Const representation of the identifier.  */\n-  tree utf8_ref;\n-};\n-\n-/* The resulting tree type.  */\n-union GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-       chain_next (\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n- \n-  lang_tree_node {\n-  union tree_node GTY ((tag (\"0\"), \n-\t\t\tdesc (\"tree_node_structure (&%h)\"))) \n-    generic;\n-  struct lang_identifier GTY ((tag (\"1\"))) identifier;\n-};\n-\n-/* Macros for access to language-specific slots in an identifier.  */\n-/* Unless specified, each of these slots contains a DECL node or null.  */\n-\n-/* This represents the value which the identifier has in the\n-   file-scope namespace.  */\n-#define IDENTIFIER_GLOBAL_VALUE(NODE)   \\\n-  (((struct lang_identifier *)(NODE))->global_value)\n-/* This represents the value which the identifier has in the current\n-   scope.  */\n-#define IDENTIFIER_LOCAL_VALUE(NODE)    \\\n-  (((struct lang_identifier *)(NODE))->local_value)\n-\n-/* Given an identifier NODE, get the corresponding class.\n-   E.g. IDENTIFIER_CLASS_VALUE(get_identifier (\"java.lang.Number\"))\n-   is the corresponding RECORD_TYPE. */\n-#define IDENTIFIER_CLASS_VALUE(NODE) IDENTIFIER_GLOBAL_VALUE(NODE)\n-\n-/* Given a signature of a reference (or array) type, or a method, return the\n-   corresponding type (if one has been allocated).\n-   Do not use for primitive types, since they may be ambiguous.\n-   (E.g. is \"I\" a signature or a class name?) */\n-#define IDENTIFIER_SIGNATURE_TYPE(NODE) IDENTIFIER_GLOBAL_VALUE(NODE)\n-\n-/* If non-NULL:  An ADDR_REF to a VAR_DECL that contains\n-   the Utf8Const representation of the identifier.  */\n-#define IDENTIFIER_UTF8_REF(NODE) \\\n-  (((struct lang_identifier *)(NODE))->utf8_ref)\n-\n-#define IDENTIFIER_UTF8_DECL(NODE) \\\n-  TREE_OPERAND((((struct lang_identifier *)(NODE))->utf8_ref), 0)\n-\n-/* For a FUNCTION_DECL, if we are compiling a .class file, then this is\n-   the position in the .class file of the method code.\n-   Specifically, this is the code itself, not the code attribute. */\n-#define DECL_CODE_OFFSET(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.code_offset)\n-/* Similarly, the length of the bytecode. */\n-#define DECL_CODE_LENGTH(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.code_length)\n-/* Similarly, the position of the LineNumberTable attribute. */\n-#define DECL_LINENUMBERS_OFFSET(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.f.linenumbers_offset)\n-/* Similarly, the position of the LocalVariableTable attribute\n-   (following the standard attribute header). */\n-#define DECL_LOCALVARIABLES_OFFSET(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.f.localvariables_offset)\n-\n-#define DECL_MAX_LOCALS(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.max_locals)\n-#define DECL_MAX_STACK(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.max_stack)\n-/* Number of local variable slots needed for the arguments of this function. */\n-#define DECL_ARG_SLOT_COUNT(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.f.arg_slot_count)\n-/* Source location of end of function. */\n-#define DECL_FUNCTION_LAST_LINE(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.last_line)\n-/* List of checked thrown exceptions, as specified with the `throws'\n-   keyword */\n-#define DECL_FUNCTION_THROWS(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.throws_list)\n-/* VAR_DECL containing the caught exception object.  */\n-#define DECL_FUNCTION_EXC_OBJ(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.exc_obj)\n-/* For each function decl, init_test_table contains a hash table whose\n-   entries are keyed on class names, and whose values are local\n-   boolean decls.  The variables are intended to be TRUE when the\n-   class has been initialized in this function, and FALSE otherwise.  */\n-#define DECL_FUNCTION_INIT_TEST_TABLE(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.f.init_test_table)\n-/* For each static function decl, itc contains a hash table whose\n-   entries are keyed on class named that are definitively initialized\n-   in DECL.  */\n-#define DECL_FUNCTION_INITIALIZED_CLASS_TABLE(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.f.ict)\n-\n-#define DECL_LOCAL_CNI_METHOD_P(NODE) \\\n-    (DECL_LANG_SPECIFIC (NODE)->u.f.local_cni)\n-\n-/* True when DECL (a field) is Synthetic.  */\n-#define FIELD_SYNTHETIC(DECL) DECL_LANG_FLAG_2 (VAR_OR_FIELD_CHECK (DECL))\n-\n-/* The slot number for this local variable. */\n-#define DECL_LOCAL_SLOT_NUMBER(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->u.v.slot_number)\n-/* The start (bytecode) pc for the valid range of this local variable. */\n-#define DECL_LOCAL_START_PC(NODE)  (DECL_LANG_SPECIFIC (NODE)->u.v.start_pc)\n-/* The end (bytecode) pc for the valid range of this local variable. */\n-#define DECL_LOCAL_END_PC(NODE)    (DECL_LANG_SPECIFIC (NODE)->u.v.end_pc)\n-/* For a VAR_DECL or PARM_DECL, used to chain decls with the same\n-   slot_number in decl_map. */\n-#define DECL_LOCAL_SLOT_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->u.v.slot_chain)\n-/* The class that's the owner of a dynamic binding table.  */\n-#define DECL_OWNER(NODE)            (DECL_LANG_SPECIFIC(NODE)->u.v.owner)\n-/* True if NODE is a class final field. */\n-#define FIELD_ENUM(DECL)\t    (DECL_LANG_SPECIFIC (DECL)->u.v.field_enum)\n-/* True if NODE is a variable that is out of scope.  */\n-#define LOCAL_VAR_OUT_OF_SCOPE_P(NODE) \\\n-    (DECL_LANG_SPECIFIC (NODE)->u.v.freed)\n-#define LOCAL_SLOT_P(NODE) \\\n-    (DECL_LANG_SPECIFIC (NODE)->u.v.local_slot)\n-\n-#define DECL_CLASS_FIELD_P(NODE) \\\n-    (DECL_LANG_SPECIFIC (NODE)->u.v.class_field)\n-#define DECL_VTABLE_P(NODE) \\\n-    (DECL_LANG_SPECIFIC (NODE)->u.v.vtable)\n-\n-/* Create a DECL_LANG_SPECIFIC if necessary. */\n-#define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)                       \\\n-  if (DECL_LANG_SPECIFIC (T) == NULL)                                \\\n-    {                                                                \\\n-      DECL_LANG_SPECIFIC ((T)) = ggc_cleared_alloc<struct lang_decl> (); \\\n-      DECL_LANG_SPECIFIC (T)->desc = LANG_DECL_VAR;                  \\\n-    }\n-\n-/* A ConstantExpression, after folding and name resolution. */\n-#define CONSTANT_VALUE_P(NODE) \\\n-  (TREE_CODE (NODE) == STRING_CST \\\n-   || (TREE_CODE (NODE) == INTEGER_CST \\\n-       && TREE_CODE (TREE_TYPE (NODE)) != POINTER_TYPE) \\\n-   || TREE_CODE (NODE) == REAL_CST)\n-\n-struct GTY((for_user)) treetreehash_entry {\n-  tree key;\n-  tree value;\n-};\n-\n-struct treetreehasher : ggc_ptr_hash<treetreehash_entry>\n-{\n-  typedef tree compare_type;\n-\n-  static hashval_t hash (treetreehash_entry *);\n-  static bool equal (treetreehash_entry *, tree);\n-};\n-\n-struct ict_hasher : ggc_ptr_hash<tree_node>\n-{\n-  static hashval_t hash (tree t) { return htab_hash_pointer (t); }\n-  static bool equal (tree a, tree b) { return a == b; }\n-};\n-\n-/* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n-struct GTY(()) lang_decl_func {\n-  /*  tree chain; not yet used. */\n-  long code_offset;\n-  int code_length;\n-  long linenumbers_offset;\n-  long localvariables_offset;\n-  int arg_slots;\n-  int max_locals;\n-  int max_stack;\n-  int arg_slot_count;\n-  source_location last_line;\t/* End line number for a function decl */\n-  vec<tree, va_gc> *throws_list;\t/* Exception specified by `throws' */\n-  tree exc_obj;\t\t\t/* Decl holding the exception object.  */\n-\n-  /* Class initialization test variables  */\n-  hash_table<treetreehasher> *init_test_table;\n-\t\t\t\t\n-  /* Initialized (static) Class Table */\n-  hash_table<ict_hasher> *ict;\n-\n-  unsigned int native : 1;\t/* Nonzero if this is a native method  */\n-  unsigned int strictfp : 1;\n-  unsigned int invisible : 1;\t/* Set for methods we generate\n-\t\t\t\t   internally but which shouldn't be\n-\t\t\t\t   written to the .class file.  */\n-  unsigned int dummy : 1;\n-  unsigned int local_cni : 1;\t/* Decl needs mangle_local_cni_method.  */\n-  unsigned int bridge : 1;\t/* Bridge method.  */\n-  unsigned int varargs : 1;\t/* Varargs method.  */\n-};\n-\n-/* These represent the possible assertion_codes that can be emitted in the\n-   type assertion table.  */\n-enum\n-{\n-  JV_ASSERT_END_OF_TABLE = 0,     /* Last entry in table.  */\n-  JV_ASSERT_TYPES_COMPATIBLE = 1, /* Operand A is assignable to Operand B.  */\n-  JV_ASSERT_IS_INSTANTIABLE = 2   /* Operand A is an instantiable class.  */\n-};\n-\n-/* Annotation types used in the reflection_data.  See\n-   java.lang.Class.getDeclaredAnnotations() in the runtime library for\n-   an example of how these are used.  */\n-\n-typedef enum\n-{\n-  JV_CLASS_ATTR,\n-  JV_METHOD_ATTR,\n-  JV_FIELD_ATTR,\n-  JV_DONE_ATTR\n-} jv_attr_type;\n-\n-typedef enum\n-{\n-  JV_INNER_CLASSES_KIND,\n-  JV_ENCLOSING_METHOD_KIND,\n-  JV_SIGNATURE_KIND,\n-  JV_ANNOTATIONS_KIND,\n-  JV_PARAMETER_ANNOTATIONS_KIND,\n-  JV_ANNOTATION_DEFAULT_KIND\n-} jv_attr_kind;\n-\n-typedef struct GTY((for_user)) type_assertion {\n-  int assertion_code; /* 'opcode' for the type of this assertion. */\n-  tree op1;           /* First operand. */\n-  tree op2;           /* Second operand. */\n-} type_assertion;\n-\n-struct type_assertion_hasher : ggc_ptr_hash<type_assertion>\n-{\n-  static hashval_t hash (type_assertion *);\n-  static bool equal (type_assertion *, type_assertion *);\n-};\n-\n-extern tree java_treetreehash_find (hash_table<treetreehasher> *, tree);\n-extern tree * java_treetreehash_new (hash_table<treetreehasher> *, tree);\n-extern hash_table<treetreehasher> *java_treetreehash_create (size_t size);\n-\n-/* DECL_LANG_SPECIFIC for VAR_DECL, PARM_DECL and sometimes FIELD_DECL\n-   (access methods on outer class fields) and final fields. */\n-struct GTY(()) lang_decl_var {\n-  int slot_number;\n-  int start_pc;\n-  int end_pc;\n-  tree slot_chain;\n-  tree owner;\n-  unsigned int freed : 1;\t\t/* Decl is no longer in scope.  */\n-  unsigned int local_slot : 1;\t/* Decl is a temporary in the stack frame.  */\n-  unsigned int class_field : 1; /* Decl needs mangle_class_field.  */\n-  unsigned int vtable : 1;\t/* Decl needs mangle_vtable.  */\n-  unsigned int field_enum:1;\t/* Field is an enum.  */\n-};\n-\n-/* This is what 'lang_decl' really points to.  */\n-\n-enum lang_decl_desc {LANG_DECL_FUNC, LANG_DECL_VAR};\n-\n-struct GTY(()) lang_decl {\n-  enum lang_decl_desc desc;\n-  union lang_decl_u\n-    {\n-      struct lang_decl_func GTY ((tag (\"LANG_DECL_FUNC\"))) f;\n-      struct lang_decl_var GTY ((tag (\"LANG_DECL_VAR\"))) v;\n-    } GTY ((desc (\"%0.desc\"))) u;\n-};\n-\n-/* Macro to access fields in `struct lang_type'.  */\n-\n-#define TYPE_SIGNATURE(T)\t(TYPE_LANG_SPECIFIC (T)->signature)\n-#define TYPE_JCF(T)\t\t(TYPE_LANG_SPECIFIC (T)->jcf)\n-#define TYPE_CPOOL(T)\t\t(TYPE_LANG_SPECIFIC (T)->cpool)\n-#define TYPE_CPOOL_DATA_REF(T)\t(TYPE_LANG_SPECIFIC (T)->cpool_data_ref)\n-#define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T) \\\n-  if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\\\n-     TYPE_LANG_SPECIFIC ((T)) = ggc_cleared_alloc<struct lang_type> ();\n-\n-#define TYPE_DUMMY(T)\t\t(TYPE_LANG_SPECIFIC(T)->dummy_class)\n-\n-#define TYPE_PACKAGE_LIST(T)     (TYPE_LANG_SPECIFIC (T)->package_list)\n-#define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC (T)->pic)\n-#define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC (T)->poic)\n-#define TYPE_STRICTFP(T) (TYPE_LANG_SPECIFIC (T)->strictfp)\n-#define TYPE_ENUM(T) \t\t(TYPE_LANG_SPECIFIC (T)->enum_class)\n-#define TYPE_SYNTHETIC(T)\t(TYPE_LANG_SPECIFIC (T)->synthetic)\n-#define TYPE_ANNOTATION(T)\t(TYPE_LANG_SPECIFIC (T)->annotation)\n-\n-#define TYPE_USES_ASSERTIONS(T) (TYPE_LANG_SPECIFIC (T)->assertions)\n-\n-#define TYPE_ATABLE_METHODS(T)   (TYPE_LANG_SPECIFIC (T)->atable_methods)\n-#define TYPE_ATABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC (T)->atable_syms_decl)\n-#define TYPE_ATABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->atable_decl)\n-\n-#define TYPE_OTABLE_METHODS(T)   (TYPE_LANG_SPECIFIC (T)->otable_methods)\n-#define TYPE_OTABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC (T)->otable_syms_decl)\n-#define TYPE_OTABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->otable_decl)\n-\n-#define TYPE_ITABLE_METHODS(T)   (TYPE_LANG_SPECIFIC (T)->itable_methods)\n-#define TYPE_ITABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC (T)->itable_syms_decl)\n-#define TYPE_ITABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->itable_decl)\n-\n-#define TYPE_CTABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->ctable_decl)\n-#define TYPE_CATCH_CLASSES(T)    (TYPE_LANG_SPECIFIC (T)->catch_classes)\n-\n-#define TYPE_TO_RUNTIME_MAP(T)   (TYPE_LANG_SPECIFIC (T)->type_to_runtime_map)\n-#define TYPE_ASSERTIONS(T)   \t (TYPE_LANG_SPECIFIC (T)->type_assertions)\n-#define TYPE_PACKAGE(T)     \t (TYPE_LANG_SPECIFIC (T)->package)\n-\n-#define TYPE_REFLECTION_DATA(T)\t (TYPE_LANG_SPECIFIC (T)->reflection_data)\n-#define TYPE_REFLECTION_DATASIZE(T)\t\t\t\t\t\\\n-\t\t\t\t(TYPE_LANG_SPECIFIC (T)->reflection_datasize)\n-\n-typedef struct GTY(()) method_entry_d {\n-  tree method;\n-  tree special;\n-} method_entry;\n-\n-\n-struct GTY(()) lang_type {\n-  tree signature;\n-  struct JCF *jcf;\n-  struct CPool *cpool;\n-  tree cpool_data_ref;\t\t/* Cached */\n-  tree package_list;\t\t/* List of package names, progressive */\n-\n-  vec<method_entry, va_gc> *otable_methods; /* List of static decls referred\n-\t\t\t\t\t   to by this class.  */\n-  tree otable_decl;\t\t/* The static address table.  */\n-  tree otable_syms_decl;\n-\n-  vec<method_entry, va_gc> *atable_methods; /* List of abstract methods\n-\t\t\t\t\t   referred to by this class.  */\n-  tree atable_decl;\t\t/* The static address table.  */\n-  tree atable_syms_decl;\n-\n-  vec<method_entry, va_gc> *itable_methods; /* List of interface methods\n-\t\t\t\t\t   referred to by this class.  */\n-  tree itable_decl;\t\t/* The interfaces table.  */\n-  tree itable_syms_decl;\n-\n-  tree ctable_decl;             /* The table of classes for the runtime\n-\t\t\t\t   type matcher.  */\n-  vec<constructor_elt, va_gc> *catch_classes;\n-\n-  hash_table<treetreehasher> *type_to_runtime_map;   \n-                                /* The mapping of classes to exception region\n-\t\t\t\t   markers.  */\n-\n-  hash_table<type_assertion_hasher> *type_assertions;\n-\t\t\t\t/* Table of type assertions to be evaluated \n-  \t\t\t\t   by the runtime when this class is loaded. */\n-\n-  tree package;\t\t\t/* IDENTIFIER_NODE for package this class is\n-  \t\t\t\t   a member of.  */\n-\n-  unsigned char* GTY((skip)) reflection_data;\t/* The raw reflection\n-\t\t\t\t\t\t   data for this\n-\t\t\t\t\t\t   class.  */\n-  long reflection_datasize;\t/* The size of the raw reflection data\n-\t\t\t\t   for this class, in bytes.  */\n-\n-  unsigned pic:1;\t\t/* Private Inner Class. */\n-  unsigned poic:1;\t\t/* Protected Inner Class. */\n-  unsigned strictfp:1;\t\t/* `strictfp' class.  */\n-  unsigned assertions:1;\t/* Any method uses `assert'.  */\n-  unsigned dummy_class:1;\t/* Not a real class, just a placeholder.  */\n-  unsigned enum_class:1;\t/* Class is an enum type.  */\n-  unsigned synthetic:1;\t\t/* Class is synthetic.  */\n-  unsigned annotation:1;\t/* Class is an annotation type.  */\n-};\n-\n-#define JCF_u4 unsigned long\n-#define JCF_u2 unsigned short\n-\n-/* Possible values to pass to lookup_argument_method_generic.  */\n-#define SEARCH_INTERFACE      1\n-#define SEARCH_SUPER          2\n-#define SEARCH_VISIBLE        4\n-\n-/* Defined in java-except.h  */\n-struct eh_range;\n-\n-extern void java_parse_file (void);\n-extern tree java_type_for_mode (machine_mode, int);\n-extern tree java_type_for_size (unsigned int, int);\n-extern tree java_truthvalue_conversion (tree);\n-extern void add_assume_compiled (const char *, int);\n-extern void add_enable_assert (const char *, int);\n-extern bool enable_assertions (tree);\n-extern tree lookup_class (tree);\n-extern tree lookup_java_constructor (tree, tree);\n-extern tree lookup_java_method (tree, tree, tree);\n-extern tree lookup_argument_method (tree, tree, tree);\n-extern tree lookup_argument_method_generic (tree, tree, tree, int);\n-extern int has_method (tree, tree);\n-extern tree promote_type (tree);\n-extern tree get_constant (struct JCF*, int);\n-extern tree get_name_constant (struct JCF*, int);\n-extern tree get_class_constant (struct JCF*, int);\n-extern tree parse_signature (struct JCF *jcf, int sig_index);\n-extern tree add_field (tree, tree, tree, int);\n-extern tree add_method (tree, int, tree, tree);\n-extern tree add_method_1 (tree, int, tree, tree);\n-extern void java_hide_decl (tree);\n-extern tree make_class (void);\n-extern tree push_class (tree, tree);\n-extern tree unmangle_classname (const char *name, int name_length);\n-extern tree parse_signature_string (const unsigned char *, int);\n-extern tree get_type_from_signature (tree);\n-extern void layout_class (tree);\n-extern int get_interface_method_index (tree, tree);\n-extern tree layout_class_method (tree, tree, tree, tree);\n-extern void layout_class_methods (tree);\n-extern void cache_this_class_ref (tree);\n-extern void uncache_this_class_ref (tree);\n-extern tree build_class_ref (tree);\n-extern tree build_dtable_decl (tree);\n-extern tree build_internal_class_name (tree);\n-extern tree build_constants_constructor (void);\n-extern tree build_constant_data_ref (bool);\n-extern tree build_ref_from_constant_pool (int);\n-extern tree build_utf8_ref (tree);\n-extern tree ident_subst (const char *, int, const char *, int, int,\n-\t\t\t const char *);\n-extern tree identifier_subst (const tree, const char *, int, int,\n-\t\t\t      const char *);\n-extern bool global_bindings_p (void);\n-extern tree getdecls (void);\n-extern void pushlevel (int);\n-extern tree poplevel (int,int, int);\n-extern tree pushdecl (tree);\n-extern void java_init_decl_processing (void);\n-extern void java_dup_lang_specific_decl (tree);\n-extern tree build_java_signature (tree);\n-extern tree build_java_argument_signature (tree);\n-extern void set_java_signature (tree, tree);\n-extern tree build_static_field_ref (tree);\n-extern tree build_address_of (tree);\n-extern tree find_local_variable (int index, tree type, int pc);\n-extern tree find_stack_slot (int index, tree type);\n-extern tree build_prim_array_type (tree, HOST_WIDE_INT);\n-extern tree build_java_array_type (tree, HOST_WIDE_INT);\n-extern int is_compiled_class (tree);\n-extern tree mangled_classname (const char *, tree);\n-extern tree lookup_label (int);\n-extern tree pop_type_0 (tree, char **);\n-extern tree pop_type (tree);\n-extern tree decode_newarray_type (int);\n-extern tree lookup_field (tree *, tree);\n-extern int is_array_type_p (tree);\n-extern HOST_WIDE_INT java_array_type_length (tree);\n-extern int read_class (tree);\n-extern void load_class (tree, int);\n-\n-extern tree check_for_builtin (tree, tree);\n-extern void initialize_builtins (void);\n-\n-extern tree lookup_name (tree);\n-extern bool special_method_p (tree);\n-extern void maybe_rewrite_invocation (tree *, vec<tree, va_gc> **, tree *,\n-\t\t\t\t      tree *);\n-extern tree build_known_method_ref (tree, tree, tree, tree, vec<tree, va_gc> *,\n-\t\t\t\t    tree);\n-extern tree build_class_init (tree, tree);\n-extern int attach_init_test_initialization_flags (treetreehash_entry **, tree);\n-extern tree build_invokevirtual (tree, tree, tree);\n-extern tree build_invokeinterface (tree, tree);\n-extern tree build_jni_stub (tree);\n-extern tree invoke_build_dtable (int, vec<tree, va_gc> *);\n-extern tree build_field_ref (tree, tree, tree);\n-extern tree java_modify_addr_for_volatile (tree);\n-extern void pushdecl_force_head (tree);\n-extern tree build_java_binop (enum tree_code, tree, tree, tree);\n-extern tree build_java_soft_divmod (enum tree_code, tree, tree, tree);\n-extern tree binary_numeric_promotion (tree, tree, tree *, tree *);\n-extern tree build_java_arrayaccess (tree, tree, tree);\n-extern tree build_java_arraystore_check (tree, tree);\n-extern tree build_newarray (int, tree);\n-extern tree build_anewarray (tree, tree);\n-extern tree build_new_array (tree, tree);\n-extern tree build_java_array_length_access (tree);\n-extern tree build_java_indirect_ref (tree, tree, int);\n-extern tree java_check_reference (tree, int);\n-extern tree build_get_class (tree);\n-extern tree build_instanceof (tree, tree);\n-extern tree create_label_decl (tree);\n-extern tree prepare_eh_table_type (tree);\n-extern void java_expand_catch_classes (tree);\n-extern tree build_exception_object_ref (tree);\n-extern tree generate_name (void);\n-extern const char *lang_printable_name (tree, int);\n-extern tree maybe_add_interface (tree, tree);\n-extern void set_super_info (int, tree, tree, int);\n-extern void set_class_decl_access_flags (int, tree);\n-extern int get_access_flags_from_decl (tree);\n-extern int interface_of_p (tree, tree);\n-extern int inherits_from_p (tree, tree);\n-extern int common_enclosing_context_p (tree, tree);\n-extern int common_enclosing_instance_p (tree, tree);\n-extern int enclosing_context_p (tree, tree);\n-extern tree build_result_decl (tree);\n-extern void set_method_index (tree decl, tree method_index);\n-extern tree get_method_index (tree decl);\n-extern void make_class_data (tree);\n-extern int alloc_name_constant (int, tree);\n-extern int alloc_constant_fieldref (tree, tree);\n-extern void emit_register_classes (tree *);\n-extern tree emit_symbol_table (tree, tree, vec<method_entry, va_gc> *,\n-\t\t\t       tree, tree, int);\n-extern void lang_init_source (int);\n-extern void write_classfile (tree);\n-extern char *print_int_node (tree);\n-extern void finish_class (void);\n-extern void check_for_initialization (tree, tree);\n-extern struct CPool *cpool_for_class (tree);\n-extern int find_class_or_string_constant (struct CPool *, int, tree);\n-\n-extern tree pushdecl_top_level (tree);\n-extern tree pushdecl_function_level (tree);\n-extern tree java_replace_references (tree *, int *, void *);\n-extern int alloc_class_constant (tree);\n-extern void init_expr_processing (void);\n-extern void push_super_field (tree, tree);\n-extern void init_class_processing (void);\n-extern void add_type_assertion (tree, int, tree, tree);\n-extern int can_widen_reference_to (tree, tree);\n-extern int class_depth (tree);\n-extern int verify_jvm_instructions_new (struct JCF *, const unsigned char *,\n-\t\t\t\t\tlong);\n-extern void maybe_pushlevels (int);\n-extern void maybe_poplevels (int);\n-extern void force_poplevels (int);\n-extern int process_jvm_instruction (int, const unsigned char *, long);\n-extern int maybe_adjust_start_pc (struct JCF *, int, int, int);\n-extern void set_local_type (int, tree);\n-extern int merge_type_state (tree);\n-extern int push_type_0 (tree);\n-extern void push_type (tree);\n-extern void add_interface (tree, tree);\n-extern tree java_create_object (tree);\n-extern int verify_constant_pool (struct JCF *);\n-extern void start_java_method (tree);\n-extern void end_java_method (void);\n-extern void give_name_to_locals (struct JCF *);\n-extern void note_instructions (struct JCF *, tree);\n-extern void expand_byte_code (struct JCF *, tree);\n-extern int open_in_zip (struct JCF *, const char *, const char *, int);\n-extern void set_constant_value (tree, tree);\n-#ifdef jword\n-extern int find_constant1 (struct CPool *, int, jword);\n-extern int find_constant2 (struct CPool *, int, jword, jword);\n-#endif\n-extern int find_utf8_constant (struct CPool *, tree);\n-extern int find_string_constant (struct CPool *, tree);\n-extern int find_class_constant (struct CPool *, tree);\n-extern int find_fieldref_index (struct CPool *, tree);\n-extern int find_methodref_index (struct CPool *, tree);\n-extern int find_methodref_with_class_index (struct CPool *, tree, tree);\n-extern void write_constant_pool (struct CPool *, unsigned char *, int);\n-extern int count_constant_pool_bytes (struct CPool *);\n-extern int encode_newarray_type (tree);\n-#ifdef uint64\n-extern void format_int (char *, jlong, int);\n-extern void format_uint (char *, uint64, int);\n-#endif\n-extern void jcf_trim_old_input (struct JCF *);\n-#ifdef BUFSIZ\n-extern void jcf_print_utf8 (FILE *, const unsigned char *, int);\n-extern void jcf_print_char (FILE *, int);\n-extern void jcf_print_utf8_replace (FILE *, const unsigned char *, int,\n-\t\t\t\t    int, int);\n-extern const char* open_class (const char *, struct JCF *, int, const char *);\n-#endif\n-extern void java_debug_context (void);\n-extern void safe_layout_class (tree);\n-\n-extern tree get_boehm_type_descriptor (tree);\n-extern bool uses_jv_markobj_p (tree);\n-extern bool class_has_finalize_method (tree);\n-extern void java_check_methods (tree);\n-\n-extern void java_mangle_decl (tree);\n-extern tree java_mangle_class_field (struct obstack *, tree);\n-extern tree java_mangle_vtable (struct obstack *, tree);\n-extern tree java_mangle_resource_name (const char *);\n-extern void append_gpp_mangled_name (const char *, int);\n-\n-extern void add_predefined_file (tree);\n-extern int predefined_filename_p (tree);\n-\n-extern tree decl_constant_value (tree);\n-\n-extern void java_mark_class_local (tree);\n-\n-extern void java_inlining_merge_static_initializers (tree, void *);\n-extern void java_inlining_map_static_initializers (tree, void *);\n-\n-extern void compile_resource_data (const char *name, const char *buffer, int);\n-extern void compile_resource_file (const char *, const char *);\n-extern void write_resource_constructor (tree *);\n-extern tree build_java_empty_stmt (void);\n-extern tree add_stmt_to_compound (tree, tree, tree);\n-extern tree java_add_stmt (tree);\n-extern tree java_add_local_var (tree decl);\n-extern tree *get_stmts (void);\n-extern void register_exception_range(struct eh_range *, int, int);\n-\n-extern void finish_method (tree);\n-extern void java_expand_body (tree);\n-\n-extern int get_symbol_table_index (tree, tree, vec<method_entry, va_gc> **);\n-\n-extern tree make_catch_class_record (tree, tree);\n-extern tree emit_catch_table (tree);\n-\n-extern void gen_indirect_dispatch_tables (tree type);\n-extern int split_qualified_name (tree *left, tree *right, tree source);\n-extern int in_same_package (tree, tree);\n-\n-extern void java_read_sourcefilenames (const char *fsource_filename);\n-\n-extern void rewrite_reflection_indexes (void *);\n-\n-int cxx_keyword_p (const char *name, int length);\n-\n-#define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n-\n-/* Access flags etc for a method (a FUNCTION_DECL): */\n-\n-#define METHOD_DUMMY(DECL) (DECL_LANG_SPECIFIC (DECL)->u.f.dummy)\n-\n-#define METHOD_PUBLIC(DECL) DECL_LANG_FLAG_1 (FUNCTION_DECL_CHECK (DECL))\n-#define METHOD_PRIVATE(DECL) TREE_PRIVATE (FUNCTION_DECL_CHECK (DECL))\n-#define METHOD_PROTECTED(DECL) TREE_PROTECTED (FUNCTION_DECL_CHECK (DECL))\n-#define METHOD_STATIC(DECL) DECL_LANG_FLAG_2 (FUNCTION_DECL_CHECK (DECL))\n-#define METHOD_FINAL(DECL) DECL_FINAL (FUNCTION_DECL_CHECK (DECL))\n-#define METHOD_SYNCHRONIZED(DECL) DECL_LANG_FLAG_4 (FUNCTION_DECL_CHECK (DECL))\n-#define METHOD_NATIVE(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.native)\n-#define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (FUNCTION_DECL_CHECK (DECL))\n-#define METHOD_STRICTFP(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.strictfp)\n-#define METHOD_INVISIBLE(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.invisible)\n-#define METHOD_BRIDGE(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.bridge)\n-#define METHOD_VARARGS(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.varargs)\n-\n-#define CLASS_FILE_P(NODE) TREE_LANG_FLAG_3 (NODE)\n-\n-/* Other predicates on method decls  */\n-\n-#define DECL_CONSTRUCTOR_P(DECL) DECL_LANG_FLAG_7 (FUNCTION_DECL_CHECK (DECL))\n-\n-#define DECL_INIT_P(DECL)   (ID_INIT_P (DECL_NAME (DECL)))\n-#define DECL_CLINIT_P(DECL) (ID_CLINIT_P (DECL_NAME (DECL)))\n-\n-/* Predicates on method identifiers. Kept close to other macros using\n-   them  */\n-#define ID_INIT_P(ID)   ((ID) == init_identifier_node)\n-#define ID_CLINIT_P(ID) ((ID) == clinit_identifier_node)\n-\n-/* Access flags etc for variable/field (FIELD_DECL, VAR_DECL, or PARM_DECL): */\n-\n-#define FIELD_PRIVATE(DECL)\tTREE_PRIVATE (VAR_OR_FIELD_CHECK (DECL))\n-#define FIELD_PROTECTED(DECL)\tTREE_PROTECTED (VAR_OR_FIELD_CHECK (DECL))\n-#define FIELD_PUBLIC(DECL)\tDECL_LANG_FLAG_1 (VAR_OR_FIELD_CHECK (DECL))\n-#define FIELD_STATIC(DECL)\tTREE_STATIC (VAR_OR_FIELD_CHECK (DECL))\n-#define FIELD_FINAL(DECL)\tDECL_FINAL (VAR_OR_FIELD_CHECK (DECL))\n-#define FIELD_VOLATILE(DECL)\tDECL_LANG_FLAG_4 (VAR_OR_FIELD_CHECK (DECL))\n-#define FIELD_TRANSIENT(DECL)\tDECL_LANG_FLAG_5 (VAR_OR_FIELD_CHECK (DECL))\n-\n-/* Access flags etc for a class (a TYPE_DECL): */\n-\n-#define CLASS_PUBLIC(DECL)\tDECL_LANG_FLAG_1 (TYPE_DECL_CHECK (DECL))\n-#define CLASS_FINAL(DECL)\tDECL_FINAL (TYPE_DECL_CHECK (DECL))\n-#define CLASS_INTERFACE(DECL)\tDECL_LANG_FLAG_4 (TYPE_DECL_CHECK (DECL))\n-#define CLASS_ABSTRACT(DECL)\tDECL_LANG_FLAG_5 (TYPE_DECL_CHECK (DECL))\n-#define CLASS_SUPER(DECL)\tDECL_LANG_FLAG_6 (TYPE_DECL_CHECK (DECL))\n-#define CLASS_STATIC(DECL)\tDECL_LANG_FLAG_7 (TYPE_DECL_CHECK (DECL))\n-#define CLASS_PRIVATE(DECL)\t(TYPE_PRIVATE_INNER_CLASS (TREE_TYPE (DECL)))\n-#define CLASS_PROTECTED(DECL)\t(TYPE_PROTECTED_INNER_CLASS (TREE_TYPE (DECL)))\n-#define CLASS_STRICTFP(DECL)\t(TYPE_STRICTFP (TREE_TYPE (DECL)))\n-#define CLASS_ENUM(DECL)\t(TYPE_ENUM (TREE_TYPE (DECL)))\n-#define CLASS_USES_ASSERTIONS(DECL) (TYPE_USES_ASSERTIONS (TREE_TYPE (DECL)))\n-#define CLASS_SYNTHETIC(DECL)   (TYPE_SYNTHETIC (TREE_TYPE (DECL)))\n-#define CLASS_ANNOTATION(DECL)  (TYPE_ANNOTATION (TREE_TYPE (DECL)))\n-\n-/* @deprecated marker flag on methods, fields and classes */\n-\n-#define METHOD_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n-#define FIELD_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n-#define CLASS_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n-#define DECL_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n-\n-/* The number of virtual methods in this class's dispatch table.\n-   Does not include initial two dummy entries (one points to the\n-   Class object, and the other is for G++ -fvtable-thunks compatibility). */\n-#define TYPE_NVIRTUALS(TYPE) BINFO_VIRTUALS (TYPE_BINFO (TYPE))\n-\n-/* A TREE_VEC (indexed by DECL_VINDEX) containing this class's\n-   virtual methods. */\n-#define TYPE_VTABLE(TYPE) BINFO_VTABLE(TYPE_BINFO (TYPE))\n-\n-/* Use CLASS_LOADED_P? FIXME */\n-#define CLASS_COMPLETE_P(DECL) DECL_LANG_FLAG_2 (DECL) \n-\n-/* A vector used to track type states for the current method.  */\n-extern vec<tree, va_gc> *type_states;\n-\n-/* This maps a bytecode offset (PC) to various flags,\n-   listed below (starting with BCODE_). */\n-extern char *instruction_bits;\n-\n-/* True iff the byte is the start of an instruction. */\n-#define BCODE_INSTRUCTION_START 1\n-\n-/* True iff there is a jump or a return to this location. */\n-#define BCODE_JUMP_TARGET 2\n-\n-/* True iff this is the start of an exception handler. */\n-#define BCODE_EXCEPTION_TARGET 16\n-\n-/* True iff there is a jump to this location (and it needs a label). */\n-#define BCODE_TARGET (BCODE_JUMP_TARGET| BCODE_EXCEPTION_TARGET)\n-\n-/* True iff there is an entry in the linenumber table for this location. */\n-#define BCODE_HAS_LINENUMBER 32\n-\n-/* True iff there is more than one entry in the linenumber table for\n-   this location.  (This probably does not make much sense.)  */\n-#define BCODE_HAS_MULTI_LINENUMBERS 64\n-\n-/* True if this instruction has been verified. */\n-#define BCODE_VERIFIED 8\n-\n-/* A pointer to the line number table of the current method. */\n-extern const unsigned char *linenumber_table;\n-/* The length (in items) of the line number table. */\n-extern int linenumber_count;\n-\n-/* In type_map, means the second half of a 64-bit double or long. */\n-#define TYPE_SECOND void_type_node\n-\n-/* In type_map, means the null type (i.e. type of a null reference). */ \n-#define TYPE_NULL ptr_type_node\n-\n-/* In a type map means the type the address subroutine return address. */\n-#define TYPE_RETURN_ADDR return_address_type_node\n-\n-/* A array mapping variable/stack slot index to the type current\n-   in that variable/stack slot.\n-   TYPE_SECOND and TYPE_NULL are special cases. */\n-extern tree *type_map;\n-\n-/* Map a stack index to the type currently in that slot. */\n-#define stack_type_map (type_map + DECL_MAX_LOCALS (current_function_decl))\n-\n-/* True iff TYPE takes two variable/stack slots. */\n-#define TYPE_IS_WIDE(TYPE) \\\n-  ((TYPE) == double_type_node || (TYPE) == long_type_node)\n-\n-/* True iff TYPE is a Java array type. */\n-#define TYPE_ARRAY_P(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n-\n-/* True for an INDIRECT_REF created from a 'ARRAY.length' operation. */\n-#define IS_ARRAY_LENGTH_ACCESS(NODE) TREE_LANG_FLAG_4 (NODE)\n-\n-/* If FUNCTION_TYPE or METHOD_TYPE: cache for build_java_argument_signature. */\n-#define TYPE_ARGUMENT_SIGNATURE(TYPE) \\\n-  (TYPE_MINVAL (TREE_CHECK2 (TYPE, FUNCTION_TYPE, METHOD_TYPE)))\n-\n-/* Given an array type, give the type of the elements. */\n-/* FIXME this use of TREE_TYPE conflicts with something or other. */\n-#define TYPE_ARRAY_ELEMENT(ATYPE) TREE_TYPE (ATYPE)\n-\n-/* True if class TYPE has been loaded (i.e. parsed plus laid out).\n-   (The check for CLASS_PARSED_P is needed because of Object and Class.) */\n-#define CLASS_LOADED_P(TYPE) (TYPE_SIZE (TYPE) != NULL_TREE \\\n-\t\t\t      && (CLASS_PARSED_P(TYPE) || TYPE_ARRAY_P(TYPE)))\n-\n-/* True if class TYPE has been parsed (first pass). */\n-#define CLASS_PARSED_P(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n-\n-/* True of a RECORD_TYPE of a class/interface type (not array type) */\n-#define CLASS_P(TYPE) TYPE_LANG_FLAG_4 (TYPE)\n-\n-/* True if class TYPE was requested (on command line) to be compiled.*/\n-#define CLASS_FROM_CURRENTLY_COMPILED_P(TYPE) TYPE_LANG_FLAG_5 (TYPE)\n-\n-/* True if class TYPE is currently being laid out. Helps in detection\n-   of inheritance cycle occurring as a side effect of performing the\n-   layout of a class.  */\n-#define CLASS_BEING_LAIDOUT(TYPE) TYPE_LANG_FLAG_6 (TYPE)\n-\n-/* True if ID is a qualified named (contains . or /) */\n-#define QUALIFIED_P(ID) TREE_LANG_FLAG_2 (ID)\n-\n-/* True if ID is a command-line specified filename */\n-#define IS_A_COMMAND_LINE_FILENAME_P(ID) TREE_LANG_FLAG_4 (ID)\n-\n-/* True if filename ID has already been parsed */\n-#define HAS_BEEN_ALREADY_PARSED_P(ID) TREE_LANG_FLAG_5 (ID)\n-\n-/* True if TYPE (a TREE_TYPE denoting a class type) was found to\n-   feature a finalizer method. */\n-#define HAS_FINALIZER_P(EXPR) TREE_LANG_FLAG_3 (EXPR)\n-\n-/* True if NODE belongs to an inner class TYPE_DECL node.\n-   Verifies that NODE as the attributes of a decl.  */\n-#define INNER_CLASS_DECL_P(NODE) (TYPE_NAME (TREE_TYPE (NODE)) == NODE\t\\\n-\t\t\t\t  && DECL_CONTEXT (NODE))\n-\n-/* True if NODE belongs to an inner class RECORD_TYPE node. Checks\n-   that TYPE_NAME bears a decl. An array type wouldn't.  */\n-#define INNER_CLASS_TYPE_P(NODE) (TREE_CODE (TYPE_NAME (NODE)) == TYPE_DECL \\\n-\t\t\t\t  && DECL_CONTEXT (TYPE_NAME (NODE)))\n-\n-/* True if the class type NODE was declared in an inner scope and is\n-   not a toplevel class */\n-#define PURE_INNER_CLASS_TYPE_P(NODE) \\\n-  (INNER_CLASS_TYPE_P (NODE) && !CLASS_STATIC (TYPE_NAME (NODE)))\n-\n-/* True if NODE (a TYPE_DECL or a RECORD_TYPE) is an inner class.  */\n-#define INNER_CLASS_P(NODE) (TREE_CODE (NODE) == TYPE_DECL ? \t\t      \\\n-\t\t\t     INNER_CLASS_DECL_P (NODE) :\t\t      \\\n-\t\t\t     (TREE_CODE (NODE) == RECORD_TYPE ? \t      \\\n-\t\t\t      INNER_CLASS_TYPE_P (NODE) : \t\t      \\\n-\t\t\t      (abort (), 0)))\n-\n-/* On a TYPE_DECL, hold the list of inner classes defined within the\n-   scope of TYPE_DECL.  */\n-#define DECL_INNER_CLASS_LIST(NODE) DECL_INITIAL (TYPE_DECL_CHECK (NODE))\n-\n-/* Add a FIELD_DECL to RECORD_TYPE RTYPE.\n-   The field has name NAME (a char*), a type FTYPE, and a location of LOC.\n-   Unless this is the first field, FIELD most hold the previous field.\n-   FIELD is set to the newly created FIELD_DECL.\n-\n-   We set DECL_ARTIFICIAL so these fields get skipped by make_class_data\n-   if compiling java.lang.Object or java.lang.Class. */\n-\n-#define PUSH_FIELD(LOC, RTYPE, FIELD, NAME, FTYPE) \\\n-{ tree _field = build_decl (LOC, FIELD_DECL, get_identifier ((NAME)), (FTYPE)); \\\n-  if (TYPE_FIELDS (RTYPE) == NULL_TREE)\t\\\n-    TYPE_FIELDS (RTYPE) = _field; \t\\\n-  else\t\t\t\t\t\\\n-    DECL_CHAIN(FIELD) = _field;\t\t\\\n-  DECL_CONTEXT (_field) = (RTYPE);\t\\\n-  DECL_ARTIFICIAL (_field) = 1;\t\t\\\n-  FIELD = _field; }\n-\n-#define FINISH_RECORD(RTYPE) layout_type (RTYPE)\n-\n-/* Start building a RECORD_TYPE constructor's elements in V.  The\n-   constructor will have type CTYPE.  */\n-#define START_RECORD_CONSTRUCTOR(V, CTYPE) \\\n-  do \\\n-    { \\\n-      vec_alloc (V, 0); \\\n-      CONSTRUCTOR_APPEND_ELT (V, TYPE_FIELDS (CTYPE), NULL); \\\n-    } \\\n-  while (0)\n-\n-/* Append a field initializer to V for the dummy field for the inherited\n-   fields.  The dummy field has the given VALUE, and the same type as the\n-   super-class.   Must be specified before calls to PUSH_FIELD_VALUE. */\n-#define PUSH_SUPER_VALUE(V, VALUE) \\\n-  do \\\n-    { \\\n-      constructor_elt *_elt___ = &(V)->last (); \\\n-      tree _next___ = DECL_CHAIN (_elt___->index); \\\n-      gcc_assert (!DECL_NAME (_elt___->index)); \\\n-      _elt___->value = VALUE; \\\n-      CONSTRUCTOR_APPEND_ELT (V, _next___, NULL); \\\n-    } \\\n-  while (0)\n-\n-/* Append a field initializer to V for a field with the given VALUE.\n-   NAME is a char* string used for error checking;\n-   the initializer must be specified in order. */\n-#define PUSH_FIELD_VALUE(V, NAME, VALUE) \t\t\t\t\\\n-  do \\\n-    { \\\n-      constructor_elt *_elt___ = &(V)->last (); \\\n-      tree _next___ = DECL_CHAIN (_elt___->index); \\\n-      gcc_assert (strcmp (IDENTIFIER_POINTER (DECL_NAME (_elt___->index)), \\\n-\t\t\t  NAME) == 0); \\\n-      _elt___->value = VALUE; \\\n-      CONSTRUCTOR_APPEND_ELT (V, _next___, NULL); \\\n-    } \\\n-  while (0)\n-\n-/* Finish creating a record CONSTRUCTOR CONS with type CTYPE and elements V.  */\n-#define FINISH_RECORD_CONSTRUCTOR(CONS, V, CTYPE)        \\\n-  do \\\n-    { \\\n-      V->pop (); \\\n-      CONS = build_constructor (CTYPE, V); \\\n-      TREE_CONSTANT (CONS) = 0; \\\n-    } \\\n-  while (0)\n-\n-#define BLOCK_EXPR_DECLS(NODE)  BLOCK_VARS(NODE)\n-#define BLOCK_EXPR_BODY(NODE)   BLOCK_SUBBLOCKS(NODE)\n-\n-#define BUILD_MONITOR_ENTER(WHERE, ARG)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build_call_nary (int_type_node,\t\t\t\t\\\n-\t\t\t       build_address_of (soft_monitorenter_node), \\\n-\t\t\t       1, (ARG));\t\t\t\t\\\n-    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\t\\\n-  }\n-\n-#define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build_call_nary (int_type_node,\t\t\t\t\\\n-\t\t\t       build_address_of (soft_monitorexit_node), \\\n-\t\t\t       1, (ARG));\t\t\t\t\\\n-    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\t\\\n-  }\n-\n-/* True when we can perform static class initialization optimization */\n-#define STATIC_CLASS_INIT_OPT_P() \\\n-  (flag_optimize_sci && (optimize >= 2))\n-\n-/* These are the possible values for the `state' field of the class\n-   structure.  This must be kept in sync with libgcj.  */\n-enum\n-{\n-  JV_STATE_NOTHING = 0,\t\t/* Set by compiler.  */\n-\n-  JV_STATE_PRELOADING = 1,\t/* Can do _Jv_FindClass.  */\n-  JV_STATE_LOADING = 3,\t\t/* Has super installed.  */\n-  JV_STATE_READ = 4,\t\t/* Has been completely defined.  */\n-  JV_STATE_LOADED = 5,\t\t/* Has Miranda methods defined.  */\n-\n-  JV_STATE_COMPILED = 6,\t/* This was a compiled class.  */\n-\n-  JV_STATE_PREPARED = 7,\t/* Layout & static init done.  */\n-  JV_STATE_LINKED = 9,\t\t/* Strings interned.  */\n-\n-  JV_STATE_IN_PROGRESS = 10,\t/* <Clinit> running.  */\n-  JV_STATE_ERROR = 12,\n-\n-  JV_STATE_DONE = 14\t\t/* Must be last.  */\n-};\n-\n-#undef DEBUG_JAVA_BINDING_LEVELS\n-\n-extern void java_genericize (tree);\n-extern int java_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n-\n-extern FILE *finput;\n-\n-#endif /* ! GCC_JAVA_TREE_H */"}, {"sha": "e42465cd6823d6ec44cdc0e7ae8f32e5ab72dc76", "filename": "gcc/java/javaop.def", "status": "removed", "additions": 0, "deletions": 314, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjavaop.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjavaop.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjavaop.def?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,314 +0,0 @@\n-/* Table of opcodes for byte codes defined by the Java(TM) virtual\n-   machine specification.\t\n-   Copyright (C) 1998-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.\n-\n-Written by Per Bothner <bothner@cygnus.com>, February 1996.\n-*/\n-\n-/* JAVAOP (OPNAME, OPCODE, OPKIND, OPERAND_TYPE, OPERAND_VALUE), where:\n-\tOPNAME is the name of the opcode.\n-\tOPCODE is the 1-byte opcode value.\n-\tOPKIND is the kind of operation.\n-\tOPERAND_TYPE is the type operands affected.\n-\tOPERAND_VALUE tells where to get the value.  (Its meaning\n-\t  depends on OPKIND.) */\n-\n-/* Various macro used in OPERAND_VALUE:\n-IMMEDIATE_s1:  An immediate signed 1-byte value in the byte-code stream.\n-IMMEDIATE_s2:  An immediate signed 2-byte value in the byte-code stream.\n-IMMEDIATE_u1:  An immediate unsigned 1-byte value in the byte-code stream.\n-IMMEDIATE_u2:  An immediate unsigned 2-byte value in the byte-code stream.\n-\n-CONST_INDEX_1:  An immediate unsigned 1-byte index into the constant pool.\n-CONST_INDEX_2:  An immediate unsigned 2-byte index into the constant pool.\n-*/\n-\n-/* More specifically, this is the meaning of the various OPKINDs:\n-\n-BINOP:\tbinary operation\n-\tOPERAND_TYPE is the argument type.\n-\tOPERAND_VALUE is PLUS, MINUS, MULT, TRUNC_DIV, RDIV, REM,\n-\t  LSHIFT, RSHIFT, URSHIFT, BIT_AND, BIT_IOR, BIT_XOR,\n-\t  COMPARE, COMPARE_L, or COMPARE_G.\n-\n-UNOP:\tunary operation\n-\tOPERAND_TYPE is the argument type.\n-\tOPERAND_VALUE is NEG.\n-\n-INVOKE: invoke operations\n-\tOPERAND_TYPE is VIRTUAL, SPECIAL, STATIC, or INTERFACE.\n-\tOPERAND_VALUE is 1 if interface, 0 otherwise.\n-\n-OBJECT:\tnew, checkcast, instanceof\n-\tOPERAND_TYPE is PTR.\n-\tOPERAND_VALUE is NEW, CHECKCAST, or INSTANCEOF.\n-\n-BRANCH: branch operations\n-\tOPERAND_TYPE is GOTO, CALL, or RETURN.\n-\tOPERAND_VALUE is IMMEDIATE_s2, VAR_INDEX_1, IMMEDIATE_s4,\n-\t  or VAR_INDEX_2.\n-\n-STACK:  Various stack operations.\n-\n-PUSHC:  Push a constant onto the operand stack.\n-\tOPERAND_VALUE maybe be the value to push,\n-\tor IMMEDIATE_s1 or IMMEDIATE_s2 if the constant is immediate,\n-\tor CONST_INDEX_1 or CONST_INDEX_2 for a constant pool index.\n-\n-LOAD: Push a value from a local variable onto the operand stack.\n-\tOPERAND_VALUE is the index of the local variable in the current\n-\tJava frame.  It can be a literal, or IMMEDIATE_i2.\n-\n-CONVERT: Convert top of stack value from one type to another.\n-\tOPERAND_TYPE is the argument type.\n-\tOPERAND_VALUE is the result type.\n-\n-TEST: Compares an integer (popped from the stack) against zero.\n-\tIf the test (in OPERAND_VALUE) is true, goto a relative\n-\toffset given by the next two bytes.\n-\n-COND:  Compares two values (popped from the stack) against each other.\n-\tIf the test (in OPERAND_VALUE) is true, goto a relative\n-\toffset given by the next two bytes.\n-\n-SWITCH:\n-\tOPERAND_VALUE is either TABLE or LOOKUP.\n-\n-ARRAY:\n-\tOPERAND_VALUE is LOAD, STORE, LENGTH, or NEW.\n-\n-FIELD: Extracts from or stores into a field.\n-\tOPERAND_TYPE is 1 for a static field, 0 for a regular field.\n-\tOPERAND_VALUE is 1 for a put operation, 0 for a get operation.\n-\n-SPECIAL:\n-\tRandom bunch of opcodes.\n-\n-*/\n-\n-JAVAOP (nop,             0, STACK,   POP,    0)\n-JAVAOP (aconst_null,     1, PUSHC,   PTR,    0)\n-JAVAOP (iconst_m1,       2, PUSHC,   INT,    -1)\n-JAVAOP (iconst_0,        3, PUSHC,   INT,    0)\n-JAVAOP (iconst_1,        4, PUSHC,   INT,    1)\n-JAVAOP (iconst_2,        5, PUSHC,   INT,    2)\n-JAVAOP (iconst_3,        6, PUSHC,   INT,    3)\n-JAVAOP (iconst_4,        7, PUSHC,   INT,    4)\n-JAVAOP (iconst_5,        8, PUSHC,   INT,    5)\n-JAVAOP (lconst_0,        9, PUSHC,   LONG,   0)\n-JAVAOP (lconst_1,       10, PUSHC,   LONG,   1)\n-JAVAOP (fconst_0,       11, PUSHC,   FLOAT,  0)\n-JAVAOP (fconst_1,       12, PUSHC,   FLOAT,  1)\n-JAVAOP (fconst_2,       13, PUSHC,   FLOAT,  2)\n-JAVAOP (dconst_0,       14, PUSHC,   DOUBLE, 0)\n-JAVAOP (dconst_1,       15, PUSHC,   DOUBLE, 1)\n-JAVAOP (bipush,         16, PUSHC,   INT,    IMMEDIATE_s1)\n-JAVAOP (sipush,         17, PUSHC,   INT,    IMMEDIATE_s2)\n-JAVAOP (ldc,            18, PUSHC,   INT,    CONST_INDEX_1)\n-JAVAOP (ldc_w,          19, PUSHC,   INT,    CONST_INDEX_2)\n-JAVAOP (ldc2_w,         20, PUSHC,   LONG,   CONST_INDEX_2)\n-JAVAOP (iload,          21, LOAD,    INT,    IMMEDIATE_u1)\n-JAVAOP (lload,          22, LOAD,    LONG,   IMMEDIATE_u1)\n-JAVAOP (fload,          23, LOAD,    FLOAT,  IMMEDIATE_u1)\n-JAVAOP (dload,          24, LOAD,    DOUBLE, IMMEDIATE_u1)\n-JAVAOP (aload,          25, LOAD,    PTR,    IMMEDIATE_u1)\n-JAVAOP (iload_0,        26, LOAD,    INT,    0)\n-JAVAOP (iload_1,        27, LOAD,    INT,    1)\n-JAVAOP (iload_2,        28, LOAD,    INT,    2)\n-JAVAOP (iload_3,        29, LOAD,    INT,    3)\n-JAVAOP (lload_0,        30, LOAD,    LONG,   0)\n-JAVAOP (lload_1,        31, LOAD,    LONG,   1)\n-JAVAOP (lload_2,        32, LOAD,    LONG,   2)\n-JAVAOP (lload_3,        33, LOAD,    LONG,   3)\n-JAVAOP (fload_0,        34, LOAD,    FLOAT,  0)\n-JAVAOP (fload_1,        35, LOAD,    FLOAT,  1)\n-JAVAOP (fload_2,        36, LOAD,    FLOAT,  2)\n-JAVAOP (fload_3,        37, LOAD,    FLOAT,  3)\n-JAVAOP (dload_0,        38, LOAD,    DOUBLE, 0)\n-JAVAOP (dload_1,        39, LOAD,    DOUBLE, 1)\n-JAVAOP (dload_2,        40, LOAD,    DOUBLE, 2)\n-JAVAOP (dload_3,        41, LOAD,    DOUBLE, 3)\n-JAVAOP (aload_0,        42, LOAD,    PTR,    0)\n-JAVAOP (aload_1,        43, LOAD,    PTR,    1)\n-JAVAOP (aload_2,        44, LOAD,    PTR,    2)\n-JAVAOP (aload_3,        45, LOAD,    PTR,    3)\n-JAVAOP (iaload,         46, ARRAY,   INT,    LOAD)\n-JAVAOP (laload,         47, ARRAY,   LONG,   LOAD)\n-JAVAOP (faload,         48, ARRAY,   FLOAT,  LOAD)\n-JAVAOP (daload,         49, ARRAY,   DOUBLE, LOAD)\n-JAVAOP (aaload,         50, ARRAY,   PTR,    LOAD)\n-JAVAOP (baload,         51, ARRAY,   BYTE,   LOAD)\n-JAVAOP (caload,         52, ARRAY,   CHAR,   LOAD)\n-JAVAOP (saload,         53, ARRAY,   SHORT,  LOAD)\n-JAVAOP (istore,         54, STORE,   INT,    IMMEDIATE_u1)\n-JAVAOP (lstore,         55, STORE,   LONG,   IMMEDIATE_u1)\n-JAVAOP (fstore,         56, STORE,   FLOAT,  IMMEDIATE_u1)\n-JAVAOP (dstore,         57, STORE,   DOUBLE, IMMEDIATE_u1)\n-JAVAOP (astore,         58, STORE,   PTR,    IMMEDIATE_u1)\n-JAVAOP (istore_0,       59, STORE,   INT,    0)\n-JAVAOP (istore_1,       60, STORE,   INT,    1)\n-JAVAOP (istore_2,       61, STORE,   INT,    2)\n-JAVAOP (istore_3,       62, STORE,   INT,    3)\n-JAVAOP (lstore_0,       63, STORE,   LONG,   0)\n-JAVAOP (lstore_1,       64, STORE,   LONG,   1)\n-JAVAOP (lstore_2,       65, STORE,   LONG,   2)\n-JAVAOP (lstore_3,       66, STORE,   LONG,   3)\n-JAVAOP (fstore_0,       67, STORE,   FLOAT,  0)\n-JAVAOP (fstore_1,       68, STORE,   FLOAT,  1)\n-JAVAOP (fstore_2,       69, STORE,   FLOAT,  2)\n-JAVAOP (fstore_3,       70, STORE,   FLOAT,  3)\n-JAVAOP (dstore_0,       71, STORE,   DOUBLE, 0)\n-JAVAOP (dstore_1,       72, STORE,   DOUBLE, 1)\n-JAVAOP (dstore_2,       73, STORE,   DOUBLE, 2)\n-JAVAOP (dstore_3,       74, STORE,   DOUBLE, 3)\n-JAVAOP (astore_0,       75, STORE,   PTR,    0)\n-JAVAOP (astore_1,       76, STORE,   PTR,    1)\n-JAVAOP (astore_2,       77, STORE,   PTR,    2)\n-JAVAOP (astore_3,       78, STORE,   PTR,    3)\n-JAVAOP (iastore,        79, ARRAY,   INT,    STORE)\n-JAVAOP (lastore,        80, ARRAY,   LONG,   STORE)\n-JAVAOP (fastore,        81, ARRAY,   FLOAT,  STORE)\n-JAVAOP (dastore,        82, ARRAY,   DOUBLE, STORE)\n-JAVAOP (aastore,        83, ARRAY,   PTR,    STORE)\n-JAVAOP (bastore,        84, ARRAY,   BYTE,   STORE)\n-JAVAOP (castore,        85, ARRAY,   CHAR,   STORE)\n-JAVAOP (sastore,        86, ARRAY,   SHORT,  STORE)\n-JAVAOP (pop,            87, STACK,   POP,    1)\n-JAVAOP (pop2,           88, STACK,   POP,    2)\n-JAVAOP (dup,            89, STACK,   DUP,    1)\n-JAVAOP (dup_x1,         90, STACK,   DUPx1,  1)\n-JAVAOP (dup_x2,         91, STACK,   DUPx2,  1)\n-JAVAOP (dup2,           92, STACK,   DUP,    2)\n-JAVAOP (dup2_x1,        93, STACK,   DUPx1,  2)\n-JAVAOP (dup2_x2,        94, STACK,   DUPx2,  2)\n-JAVAOP (swap,           95, STACK,   SWAP,   0)\n-JAVAOP (iadd,           96, BINOP,   INT,    PLUS)\n-JAVAOP (ladd,           97, BINOP,   LONG,   PLUS)\n-JAVAOP (fadd,           98, BINOP,   FLOAT,  PLUS)\n-JAVAOP (dadd,           99, BINOP,   DOUBLE, PLUS)\n-JAVAOP (isub,          100, BINOP,   INT,    MINUS)\n-JAVAOP (lsub,          101, BINOP,   LONG,   MINUS)\n-JAVAOP (fsub,          102, BINOP,   FLOAT,  MINUS)\n-JAVAOP (dsub,          103, BINOP,   DOUBLE, MINUS)\n-JAVAOP (imul,          104, BINOP,   INT,    MULT)\n-JAVAOP (lmul,          105, BINOP,   LONG,   MULT)\n-JAVAOP (fmul,          106, BINOP,   FLOAT,  MULT)\n-JAVAOP (dmul,          107, BINOP,   DOUBLE, MULT)\n-JAVAOP (idiv,          108, BINOP,   INT,    TRUNC_DIV)\n-JAVAOP (ldiv,          109, BINOP,   LONG,   TRUNC_DIV)\n-JAVAOP (fdiv,          110, BINOP,   FLOAT,  RDIV)\n-JAVAOP (ddiv,          111, BINOP,   DOUBLE, RDIV)\n-JAVAOP (irem,          112, BINOP,   INT,    REM)\n-JAVAOP (lrem,          113, BINOP,   LONG,   REM)\n-JAVAOP (frem,          114, BINOP,   FLOAT,  REM)\n-JAVAOP (drem,          115, BINOP,   DOUBLE, REM)\n-JAVAOP (ineg,          116, UNOP,    INT,    NEG)\n-JAVAOP (lneg,          117, UNOP,    LONG,   NEG)\n-JAVAOP (fneg,          118, UNOP,    FLOAT,  NEG)\n-JAVAOP (dneg,          119, UNOP,    DOUBLE, NEG)\n-JAVAOP (ishl,          120, BINOP,   INT,    LSHIFT)\n-JAVAOP (lshl,          121, BINOP,   LONG,   LSHIFT)\n-JAVAOP (ishr,          122, BINOP,   INT,    RSHIFT)\n-JAVAOP (lshr,          123, BINOP,   LONG,   RSHIFT)\n-JAVAOP (iushr,         124, BINOP,   INT,    URSHIFT)\n-JAVAOP (lushr,         125, BINOP,   LONG,   URSHIFT)\n-JAVAOP (iand,          126, BINOP,   INT,    BIT_AND)\n-JAVAOP (land,          127, BINOP,   LONG,   BIT_AND)\n-JAVAOP (ior,           128, BINOP,   INT,    BIT_IOR)\n-JAVAOP (lor,           129, BINOP,   LONG,   BIT_IOR)\n-JAVAOP (ixor,          130, BINOP,   INT,    BIT_XOR)\n-JAVAOP (lxor,          131, BINOP,   LONG,   BIT_XOR)\n-JAVAOP (iinc,          132, SPECIAL, INT,    IINC)\n-JAVAOP (i2l,           133, CONVERT, INT,    LONG)\n-JAVAOP (i2f,           134, CONVERT, INT,    FLOAT)\n-JAVAOP (i2d,           135, CONVERT, INT,    DOUBLE)\n-JAVAOP (l2i,           136, CONVERT, LONG,   INT)\n-JAVAOP (l2f,           137, CONVERT, LONG,   FLOAT)\n-JAVAOP (l2d,           138, CONVERT, LONG,   DOUBLE)\n-JAVAOP (f2i,           139, CONVERT, FLOAT,  INT)\n-JAVAOP (f2l,           140, CONVERT, FLOAT,  LONG)\n-JAVAOP (f2d,           141, CONVERT, FLOAT,  DOUBLE)\n-JAVAOP (d2i,           142, CONVERT, DOUBLE, INT)\n-JAVAOP (d2l,           143, CONVERT, DOUBLE, LONG)\n-JAVAOP (d2f,           144, CONVERT, DOUBLE, FLOAT)\n-JAVAOP (i2b,\t       145, CONVERT2, INT,    BYTE)\n-JAVAOP (i2c,           146, CONVERT2, INT,    CHAR)\n-JAVAOP (i2s,           147, CONVERT2, INT,    SHORT)\n-JAVAOP (lcmp,          148, BINOP,   LONG,   COMPARE)\n-JAVAOP (fcmpl,         149, BINOP,   FLOAT,  COMPARE_L)\n-JAVAOP (fcmpg,         150, BINOP,   FLOAT,  COMPARE_G)\n-JAVAOP (dcmpl,         151, BINOP,   DOUBLE, COMPARE_L)\n-JAVAOP (dcmpg,         152, BINOP,   DOUBLE, COMPARE_G)\n-JAVAOP (ifeq,          153, TEST,    INT,    EQ)\n-JAVAOP (ifne,          154, TEST,    INT,    NE)\n-JAVAOP (iflt,          155, TEST,    INT,    LT)\n-JAVAOP (ifge,          156, TEST,    INT,    GE)\n-JAVAOP (ifgt,          157, TEST,    INT,    GT)\n-JAVAOP (ifle,          158, TEST,    INT,    LE)\n-JAVAOP (if_icmpeq,     159, COND,    INT,    EQ)\n-JAVAOP (if_icmpne,     160, COND,    INT,    NE)\n-JAVAOP (if_icmplt,     161, COND,    INT,    LT)\n-JAVAOP (if_icmpge,     162, COND,    INT,    GE)\n-JAVAOP (if_icmpgt,     163, COND,    INT,    GT)\n-JAVAOP (if_icmple,     164, COND,    INT,    LE)\n-JAVAOP (if_acmpeq,     165, COND,    PTR,    EQ)\n-JAVAOP (if_acmpne,     166, COND,    PTR,    NE)\n-JAVAOP (goto,          167, BRANCH,  GOTO,   IMMEDIATE_s2)\n-JAVAOP (jsr,           168, JSR,     CALL,   IMMEDIATE_s2)\n-JAVAOP (ret,           169, RET,     RETURN, VAR_INDEX_1)\n-JAVAOP (tableswitch,   170, SWITCH,  INT,    TABLE)\n-JAVAOP (lookupswitch,  171, SWITCH,  INT,    LOOKUP)\n-JAVAOP (ireturn,       172, RETURN,  INT,    0)\n-JAVAOP (lreturn,       173, RETURN,  LONG,   0)\n-JAVAOP (freturn,       174, RETURN,  FLOAT,  0)\n-JAVAOP (dreturn,       175, RETURN,  DOUBLE, 0)\n-JAVAOP (areturn,       176, RETURN,  PTR,    0)\n-JAVAOP (return,        177, RETURN,  VOID,   0)\n-JAVAOP (getstatic,     178, FIELD,   1,      0)\n-JAVAOP (putstatic,     179, FIELD,   1,      1)\n-JAVAOP (getfield,      180, FIELD,   0,      0)\n-JAVAOP (putfield,      181, FIELD,   0,      1)\n-JAVAOP (invokevirtual, 182, INVOKE,  VIRTUAL,0)\n-JAVAOP (invokespecial, 183, INVOKE,  SPECIAL, 0)\n-JAVAOP (invokestatic,  184, INVOKE,  STATIC, 0)\n-JAVAOP (invokeinterface,185, INVOKE, INTERFACE, 1)\n-JAVAOP (invokedynamic, 186, INVOKE,  DYNAMIC, 1)\n-JAVAOP (new,           187, OBJECT,  PTR,    NEW)\n-JAVAOP (newarray,      188, ARRAY,   NUM,    NEW)\n-JAVAOP (anewarray,     189, ARRAY,   PTR,    NEW)\n-JAVAOP (arraylength,   190, ARRAY,   INT,    LENGTH)\n-JAVAOP (athrow,        191, SPECIAL, ANY,    THROW)\n-JAVAOP (checkcast,     192, OBJECT,  PTR,    CHECKCAST)\n-JAVAOP (instanceof,    193, OBJECT,  PTR,    INSTANCEOF)\n-JAVAOP (monitorenter,  194, SPECIAL, MONITOR, ENTER)\n-JAVAOP (monitorexit,   195, SPECIAL, MONITOR, EXIT)\n-JAVAOP (wide,          196, SPECIAL, ANY,    WIDE)\n-JAVAOP (multianewarray,197, ARRAY,   MULTI,  NEW)\n-JAVAOP (ifnull,        198, TEST,    PTR,    EQ)\n-JAVAOP (ifnonnull,     199, TEST,    PTR,    NE)\n-JAVAOP (goto_w,        200, BRANCH,  GOTO,   IMMEDIATE_s4)\n-JAVAOP (jsr_w,         201, JSR,     CALL,   IMMEDIATE_s4)\n-JAVAOP (breakpoint,    202, SPECIAL, ANY,    BREAK)\n-JAVAOP (ret_w,         209, RET,     RETURN, VAR_INDEX_2)\n-JAVAOP (impdep1,       254, IMPL,    ANY,    1)\n-JAVAOP (impdep2,       255, IMPL,    ANY,    2)"}, {"sha": "1c6b2d1b74fd0983cf37ca753732a8056030b554", "filename": "gcc/java/javaop.h", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjavaop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjavaop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjavaop.h?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,190 +0,0 @@\n-/* Utility macros to handle Java(TM) byte codes.\n-\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n-\n-#ifndef GCC_JAVAOP_H\n-#define GCC_JAVAOP_H\n-\n-typedef\tunsigned char\tuint8;\n-#ifndef int16\n-#if __SHRT_MAX__ == 32767\n-#define int16 short\n-#elif __INT_MAX__ == 32767\n-#define int16 int\n-#elif __LONG_MAX__ == 32767\n-#define int16 long\n-#else\n-#define int16 short\n-#endif\n-#endif\n-typedef unsigned int16\tuint16;\n-\n-#ifndef int32\n-#if __INT_MAX__ == 2147483647\n-#define int32 int\n-#elif __LONG_MAX__ == 2147483647\n-#define int32 long\n-#elif __SHRT_MAX__ == 2147483647\n-#define int32 short\n-#else\n-#define int32 int\n-#endif\n-#endif\n-typedef unsigned int32\tuint32;\n-\n-/* A signed 64-bit (or more) integral type, suitable for Java's 'long'.  */\n-#ifndef int64\n-#if __LONG_MAX__ == 9223372036854775807LL\n-#define int64 long\n-#elif __LONG_LONG_MAX__ == 9223372036854775807LL\n-#define int64 long long\n-#else\n-#define int64 long long\n-#endif\n-#endif\n-/* An unsigned 64-bit (or more) integral type, same length as int64. */\n-#ifndef uint64\n-#define uint64 unsigned int64\n-#endif\n-\n-typedef uint16\t\t\tjchar;\n-typedef\tsigned char\t\tjbyte;\n-typedef int16                   jshort;\n-typedef int32                   jint;\n-typedef int64                   jlong;\n-typedef void*                   jref;\n-\n-/* A 32-bit big-endian IEEE single-precision float. */\n-typedef struct _jfloat {\n-  unsigned int negative : 1;\n-  unsigned int exponent : 8;\n-  unsigned int mantissa : 23;\n-} jfloat;\n-#define JFLOAT_FINITE(f) ((f).exponent != 0xFF)\n-#define JFLOAT_QNAN_MASK 0x400000\n-#define JFLOAT_EXP_BIAS 0x7f\n-\n-/* A 32-bit big-endian IEEE double-precision float. */\n-typedef struct _jdouble {\n-  unsigned int negative : 1;\n-  unsigned int exponent : 11;\n-  unsigned int mantissa0: 20;\n-  unsigned int mantissa1: 32;\n-} jdouble;\n-#define JDOUBLE_FINITE(f) ((f).exponent != 0x7FF)\n-#define JDOUBLE_QNAN_MASK 0x80000  /* apply to mantissa0 */\n-#define JDOUBLE_EXP_BIAS 0x3ff\n-\n-/* A jword is an unsigned integral type big enough for a 32-bit jint\n-   or jfloat *or* a pointer.  It is the type appropriate for stack\n-   locations and local variables in a Java interpreter. */\n-\n-\n-#ifndef jword\n-#if defined (__LP64__) || defined (__alpha__) || defined (__MMIX__) \\\n-    || (defined (_ARCH_PPC) && defined (__64BIT__)) \\\n-    || defined (__powerpc64__) || defined (__s390x__) || defined (__x86_64__) \\\n-    || defined (__sparcv9) || (defined (__sparc__) && defined (__arch64__))\n-#define jword uint64\n-#else\n-#define jword uint32\n-#endif\n-#endif\n-\n-#ifndef IMMEDIATE_u1\n-#define IMMEDIATE_u1 (PC++, CHECK_PC_IN_RANGE(PC), BCODE[PC-1])\n-#endif\n-#ifndef IMMEDIATE_s1\n-#define IMMEDIATE_s1 (PC++, CHECK_PC_IN_RANGE(PC), (signed char)BCODE[PC-1])\n-#endif\n-#ifndef IMMEDIATE_s2\n-#define IMMEDIATE_s2 (PC+=2, CHECK_PC_IN_RANGE(PC), \\\n-  (signed char) BCODE[PC-2] * 256 + BCODE[PC-1])\n-#endif\n-#ifndef IMMEDIATE_u2\n-#define IMMEDIATE_u2 (PC+=2, CHECK_PC_IN_RANGE(PC),\\\n-  (BCODE[PC-2] * 256 + BCODE[PC-1]))\n-#endif\n-#ifndef IMMEDIATE_s4\n-#define IMMEDIATE_s4 (PC+=4, CHECK_PC_IN_RANGE(PC), \\\n-  (WORD_TO_INT((BCODE[PC-4] << 24) | (BCODE[PC-3] << 16) \\\n-         | (BCODE[PC-2] << 8) | (BCODE[PC-1]))))\n-#endif\n-\n-static inline jfloat\n-WORD_TO_FLOAT(jword w)\n-{\n-  jfloat f;\n-\n-  f.negative = (w & 0x80000000) >> 31;\n-  f.exponent = (w & 0x7f800000) >> 23;\n-  f.mantissa = (w & 0x007fffff);\n-\n-  return f;\n-} \n-\n-/* Sign extend w.  If the host on which this cross-compiler runs uses\n-   a 64-bit type for jword the appropriate sign extension is\n-   performed; if it's a 32-bit type the arithmetic does nothing but is\n-   harmless.  */\n-static inline jint\n-WORD_TO_INT(jword w)\n-{\n-  jint n = w & 0xffffffff; /* Mask lower 32 bits.  */\n-  n ^= (jint)1 << 31;\n-  n -= (uint32)1 << 31; /* Sign extend lower 32 bits to upper.  */\n-  return n;\n-} \n-\n-static inline jlong\n-WORDS_TO_LONG(jword hi, jword lo)\n-{\n-  return ((jlong) hi << 32) | ((jlong)lo & (((jlong)1 << 32) -1));\n-}\n-\n-static inline jdouble\n-WORDS_TO_DOUBLE(jword hi, jword lo)\n-{\n-  jdouble d;\n-\n-  d.negative  = (hi & 0x80000000) >> 31;\n-  d.exponent  = (hi & 0x7ff00000) >> 20;\n-  d.mantissa0 = (hi & 0x000fffff);\n-  d.mantissa1 = lo;\n-\n-  return d;\n-} \n-\n-/* If PREFIX_CHAR is the first character of the Utf8 encoding of a character,\n-   return the number of bytes taken by the encoding.\n-   Return -1 for a continuation character.  */\n-#define UT8_CHAR_LENGTH(PREFIX_CHAR) \\\n-  ((unsigned char)(PREFIX_CHAR) < 128 ? 1 \\\n-   : ((PREFIX_CHAR) & 0x40) == 0 ? -1 \\\n-   : ((PREFIX_CHAR) & 0x20) == 0 ? 2 \\\n-   : ((PREFIX_CHAR) & 0x10) == 0 ? 3 \\\n-   : ((PREFIX_CHAR) & 0x08) == 0 ? 4 : 5)\n-\n-#endif /* ! GCC_JAVAOP_H */"}, {"sha": "b5e850dfecccd5e3b209c2e3696e6574f48abd32", "filename": "gcc/java/jcf-depend.c", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-depend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-depend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-depend.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,140 +0,0 @@\n-/* Functions for handling dependency tracking when reading .class files.\n-\n-   Copyright (C) 1998-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Tom Tromey <tromey@cygnus.com>, October 1998.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"mkdeps.h\"\n-\n-#include \"jcf.h\"\n-\n-\f\n-\n-/* The dependency structure used for this invocation.  */\n-struct deps *dependencies;\n-\n-/* The output file, or NULL if we aren't doing dependency tracking.  */\n-static FILE *dep_out = NULL;\n-\n-/* Nonzero if system files should be added.  */\n-static int system_files;\n-\n-/* Nonzero if we are dumping out dummy dependencies.  */\n-static int print_dummies;\n-\n-\f\n-\n-/* Call this to reset the dependency module.  This is required if\n-   multiple dependency files are being generated from a single tool\n-   invocation.  FIXME: we should change our API or just completely use\n-   the one in mkdeps.h.  */\n-void\n-jcf_dependency_reset (void)\n-{\n-  if (dep_out != NULL)\n-    {\n-      if (dep_out != stdout)\n-\tfclose (dep_out);\n-      dep_out = NULL;\n-    }\n-\n-  if (dependencies != NULL)\n-    {\n-      deps_free (dependencies);\n-      dependencies = NULL;\n-    }\n-}\n-\n-void\n-jcf_dependency_set_target (const char *name)\n-{\n-  /* We just handle this the same as an `add_target'.  */\n-  if (dependencies != NULL && name != NULL)\n-    deps_add_target (dependencies, name, 1);\n-}\n-\n-void\n-jcf_dependency_add_target (const char *name)\n-{\n-  if (dependencies != NULL)\n-    deps_add_target (dependencies, name, 1);\n-}\n-\n-void\n-jcf_dependency_set_dep_file (const char *name)\n-{\n-  gcc_assert (dep_out != stdout);\n-  if (dep_out)\n-    fclose (dep_out);\n-  if (! strcmp (name, \"-\"))\n-    dep_out = stdout;\n-  else\n-    dep_out = fopen (name, \"w\");\n-}\n-\n-void\n-jcf_dependency_add_file (const char *filename ATTRIBUTE_UNUSED, int system_p)\n-{\n-  if (! dependencies)\n-    return;\n-\n-  /* Just omit system files.  */\n-  if (system_p && ! system_files)\n-    return;\n-\n-\n-  /* FIXME: Don't emit any dependencies.  In many cases we'll just see\n-     temporary files emitted by ecj... */\n-  /* deps_add_dep (dependencies, filename); */\n-}\n-\n-void\n-jcf_dependency_init (int system_p)\n-{\n-  gcc_assert (! dependencies);\n-  system_files = system_p;\n-  dependencies = deps_init ();\n-}\n-\n-void\n-jcf_dependency_print_dummies (void)\n-{\n-  print_dummies = 1;\n-}\n-\n-void\n-jcf_dependency_write (void)\n-{\n-  if (! dep_out)\n-    return;\n-\n-  gcc_assert (dependencies);\n-\n-  deps_write (dependencies, dep_out, 72);\n-  if (print_dummies)\n-    deps_phony_targets (dependencies, dep_out);\n-  fflush (dep_out);\n-}"}, {"sha": "8b00e57d24a960b332f26cef795ed9c1c783b892", "filename": "gcc/java/jcf-dump.c", "status": "removed", "additions": 0, "deletions": 1658, "changes": 1658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,1658 +0,0 @@\n-/* Program to dump out a Java(TM) .class file.\n-   Functionally similar to Sun's javap.\n-\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n-\n-/*\n-  jcf-dump is a program to print out the contents of class files.\n-  Usage:  jcf-dump [FLAGS] CLASS\n-  Each CLASS is either:\n-  + the name of a class in the CLASSPATH (e.g \"java.lang.String\"), or\n-  + the name of a class *file* (e.g. \"/home/me/work/package/Foo.class\").\n-  + The name of a .zip or .jar file (which prints all the classes in the\n-  archive).\n-\n-  OPTIONS:\n-  -c\n-\tDis-assemble each method.\n-  -classpath PATH\n-\tOverrides $CLASSPATH.\n-  --print-main\n-\tPrint nothing if there is no valid \"main\" method;\n-\totherwise, print only the class name.\n-  --javap\n-\tPrint output in the style of Sun's javap program.  VERY UNFINISHED.\n- */\n-    \n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree.h\"\n-#include \"diagnostic.h\"\n-#include \"intl.h\"\n-\n-#include \"jcf.h\"\n-#include \"java-tree.h\"\n-\n-#include \"version.h\"\n-\n-#include <getopt.h>\n-#include <math.h>\n-\n-/* Output file. */\n-FILE *out;\n-/* Name of output file, if NULL if stdout. */\n-char *output_file = NULL;\n-\n-int verbose = 0;\n-\n-int flag_disassemble_methods = 0;\n-int flag_print_class_info = 1;\n-int flag_print_constant_pool = 0;\n-int flag_print_fields = 1;\n-int flag_print_methods = 1;\n-int flag_print_attributes = 1;\n-\n-/* Print names of classes that have a \"main\" method. */\n-int flag_print_main = 0;\n-\n-/* Index in constant pool of this class. */\n-int this_class_index = 0;\n-\n-int class_access_flags = 0;\n-\n-/* Print in format similar to javap.  VERY INCOMPLETE. */\n-int flag_javap_compatible = 0;\n-\n-static void print_access_flags (FILE *, uint16, char);\n-static void print_constant_terse (FILE*, JCF*, int, int);\n-static void print_constant_terse_with_index (FILE *, JCF *, int, int);\n-static void print_constant (FILE *, JCF *, int, int);\n-static void print_constant_ref (FILE *, JCF *, int);\n-static void disassemble_method (JCF*, const unsigned char *, int);\n-static void print_name (FILE*, JCF*, int);\n-static void print_signature (FILE*, JCF*, int, int);\n-static int utf8_equal_string (struct JCF*, int, const char *);\n-static void usage (void) ATTRIBUTE_NORETURN;\n-static void help (void) ATTRIBUTE_NORETURN;\n-static void version (void) ATTRIBUTE_NORETURN;\n-static void process_class (struct JCF *);\n-static void print_constant_pool (struct JCF *);\n-static void print_exception_table (struct JCF *, const unsigned char *entries,\n-\t\t\t\t   int);\n-static void indent (FILE *, int);\n-static void print_element_value (FILE *, JCF *, int);\n-static void print_annotation (FILE *, JCF *, int);\n-static void print_annotations (FILE *, JCF *, int);\n-static void print_parameter_annotations (FILE *, JCF *, int);\n-\n-#define PRINT_SIGNATURE_RESULT_ONLY 1\n-#define PRINT_SIGNATURE_ARGS_ONLY 2\n-\n-static int\n-utf8_equal_string (JCF *jcf, int index, const char * value)\n-{\n-  if (CPOOL_INDEX_IN_RANGE (&jcf->cpool, index)\n-      && JPOOL_TAG (jcf, index) == CONSTANT_Utf8)\n-    {\n-      int len = strlen (value);\n-      if (JPOOL_UTF_LENGTH (jcf, index) == len\n-\t  && memcmp (JPOOL_UTF_DATA (jcf, index), value, len) == 0)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-#define HANDLE_MAGIC(MAGIC, MINOR, MAJOR) \\\n-  this_class_index = 0; \\\n-  if (flag_print_class_info) \\\n-    fprintf (out, \\\n-             \"Magic number: 0x%0lx, minor_version: %ld, major_version: %ld.\\n\",\\\n-\t     (unsigned long) MAGIC, (long) MINOR, (long) MAJOR)\n-\n-#define HANDLE_START_CONSTANT_POOL(COUNT) \\\n-  if (flag_print_constant_pool) \\\n-    fprintf (out, \"\\nConstant pool (count: %d):\\n\", COUNT)\n-\n-#define HANDLE_SOURCEFILE(INDEX) \\\n-{ fprintf (out, \"Attribute \"); \\\n-  print_constant_terse (out, jcf, attribute_name, CONSTANT_Utf8); \\\n-  fprintf (out, \", length:%ld, #%d=\", (long) attribute_length, INDEX); \\\n-  print_constant_terse (out, jcf, INDEX, CONSTANT_Utf8); fputc ('\\n', out); }\n-\n-#define HANDLE_CLASS_INFO(ACCESS_FLAGS, THIS, SUPER, INTERFACES_COUNT) \\\n-  this_class_index = THIS; \\\n-  class_access_flags = ACCESS_FLAGS; \\\n-  if (flag_print_class_info) \\\n-    { fprintf (out, \"\\nAccess flags: 0x%x\", ACCESS_FLAGS); \\\n-      print_access_flags (out, ACCESS_FLAGS, 'c'); \\\n-      fputc ('\\n', out); \\\n-      fprintf (out, \"This class: \"); \\\n-      print_constant_terse_with_index (out, jcf, THIS, CONSTANT_Class); \\\n-      if (flag_print_constant_pool || SUPER != 0) \\\n-        fprintf (out, \", super: \"); \\\n-      if (flag_print_constant_pool) \\\n-        { \\\n-          fprintf (out, \"%d\", SUPER); \\\n-          if (SUPER != 0) \\\n-            fputc ('=', out); \\\n-        } \\\n-      if (SUPER != 0) \\\n-        print_constant_terse (out, jcf, SUPER, CONSTANT_Class); \\\n-      fprintf (out, \"\\nInterfaces (count: %d):\\n\", INTERFACES_COUNT); \\\n-    }\n-\n-#define IGNORE_ATTRIBUTE(JCF, NAME, NAME_LENGTH) \\\n-  (flag_print_attributes <= 0)\n-\n-#define HANDLE_CLASS_INTERFACE(INDEX) \\\n-  if (flag_print_class_info) \\\n-    { fprintf (out, \"- Implements: \"); \\\n-      print_constant_terse_with_index (out, jcf, INDEX, CONSTANT_Class); \\\n-      fputc ('\\n', out); }\n-\n-#define HANDLE_START_FIELDS(FIELDS_COUNT) \\\n-  if (flag_print_fields) \\\n-    fprintf (out, \"\\nFields (count: %d):\\n\", FIELDS_COUNT)\n-\n-#define HANDLE_START_FIELD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n-  if (flag_print_fields) \\\n-    { fprintf (out, \"Field name:\"); \\\n-      print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n-      print_access_flags (out, ACCESS_FLAGS, 'f'); \\\n-      fprintf (out, \" Descriptor: \"); \\\n-      if (flag_print_constant_pool) \\\n-        fprintf (out, \"%d=\", SIGNATURE); \\\n-      print_signature (out, jcf, SIGNATURE, 0); \\\n-      fputc ('\\n', out); } \\\n-  else \\\n-    flag_print_attributes--;\n-\n-#define HANDLE_END_FIELD() \\\n-  if (! flag_print_fields) \\\n-    flag_print_attributes++;\n-\n-#define HANDLE_START_METHODS(METHODS_COUNT) \\\n-  if (flag_print_methods) \\\n-    fprintf (out, \"\\nMethods (count: %d):\\n\", METHODS_COUNT); \\\n-  else \\\n-    flag_print_attributes--;\n-\n-\n-#define HANDLE_END_METHODS() \\\n-  if (! flag_print_methods) \\\n-    flag_print_attributes++;\n-\n-#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n-{ \\\n-  if (flag_print_methods) \\\n-    { \\\n-      if (flag_javap_compatible) \\\n-        { \\\n-\t  fprintf (out, \"    \"); \\\n-\t  print_access_flags (out, ACCESS_FLAGS, 'm'); \\\n-\t  fputc (' ', out); \\\n-\t  print_signature (out, jcf, SIGNATURE, PRINT_SIGNATURE_RESULT_ONLY); \\\n-\t  fputc (' ', out); \\\n-\t  print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n-\t  print_signature (out, jcf, SIGNATURE, PRINT_SIGNATURE_ARGS_ONLY); \\\n-\t  fputc ('\\n', out); \\\n-\t} \\\n-      else \\\n-\t{ \\\n-\t  fprintf (out, \"\\nMethod name:\"); \\\n-\t  print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n-\t  print_access_flags (out, ACCESS_FLAGS, 'm'); \\\n-\t  fprintf (out, \" Descriptor: \"); \\\n-\t  if (flag_print_constant_pool) \\\n-\t    fprintf (out, \"%d=\", SIGNATURE); \\\n-\t  print_signature (out, jcf, SIGNATURE, 0); \\\n-\t  fputc ('\\n', out); \\\n-\t} \\\n-    } \\\n-  if (flag_print_main && ACCESS_FLAGS == (ACC_STATIC|ACC_PUBLIC) \\\n-      && utf8_equal_string (jcf, NAME, \"main\") \\\n-      && utf8_equal_string (jcf, SIGNATURE, \"([Ljava/lang/String;)V\") \\\n-      && this_class_index > 0 \\\n-      && (class_access_flags & ACC_PUBLIC)) \\\n-    { \\\n-      print_constant_terse(out, jcf, this_class_index, CONSTANT_Class); \\\n-      fputc  ('\\n', out); \\\n-   } \\\n-}\n-\n-#define COMMON_HANDLE_ATTRIBUTE(JCF, INDEX, LENGTH) \\\n-( fprintf (out, \"Attribute \"), \\\n-  print_constant_terse (out, jcf, INDEX, CONSTANT_Utf8), \\\n-  fprintf (out, \", length:%ld\", (long) LENGTH) )\n-\n-#define HANDLE_CONSTANTVALUE(VALUE_INDEX) \\\n-( COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length), \\\n-  fprintf (out, \", value: \"), \\\n-  print_constant_ref (out, jcf, VALUE_INDEX), \\\n-  fprintf (out, \"\\n\") )\n-\n-#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n-{ COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length); \\\n-  fprintf (out, \", max_stack:%ld, max_locals:%ld, code_length:%ld\\n\", \\\n-    (long) MAX_STACK, (long) MAX_LOCALS, (long) CODE_LENGTH); \\\n-  disassemble_method (jcf, jcf->read_ptr, CODE_LENGTH); }\n-\n-#define HANDLE_EXCEPTION_TABLE(ENTRIES, COUNT) \\\n-  print_exception_table (jcf, ENTRIES, COUNT)\n-\n-#define HANDLE_EXCEPTIONS_ATTRIBUTE(COUNT) \\\n-{ int n = (COUNT); int i; \\\n-  COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length); \\\n-  fprintf (out, \", count: %d\\n\", n); \\\n-  for (i = 0; i < n; i++) {\\\n-    int ex_index = JCF_readu2 (jcf); \\\n-    fprintf (out, \"%3d: \", i); \\\n-    print_constant_ref (out, jcf, ex_index); \\\n-    fputc ('\\n', out); } }\n-\n-#define HANDLE_LOCALVARIABLETABLE_ATTRIBUTE(COUNT) \\\n-{ int n = (COUNT); int i; \\\n-  COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length); \\\n-  fprintf (out, \", count: %d\\n\", n); \\\n-  for (i = 0; i < n; i++) {\\\n-    int start_pc = JCF_readu2 (jcf); \\\n-    int length = JCF_readu2 (jcf); \\\n-    int name_index = JCF_readu2 (jcf); \\\n-    int signature_index = JCF_readu2 (jcf); \\\n-    int slot = JCF_readu2 (jcf); \\\n-    fprintf (out, \"  slot#%d: name: \", slot); \\\n-    if (flag_print_constant_pool) \\\n-      fprintf (out, \"%d=\", name_index); \\\n-    print_name (out, jcf, name_index); \\\n-    fprintf (out, \", type: \"); \\\n-    if (flag_print_constant_pool) \\\n-      fprintf (out, \"%d=\", signature_index); \\\n-    print_signature (out, jcf, signature_index, 0); \\\n-    fprintf (out, \" (pc: %d length: %d)\\n\", start_pc, length); }}\n-\n-#define HANDLE_LOCALVARIABLETYPETABLE_ATTRIBUTE(COUNT)\t\t\t\\\n-{ int n = (COUNT); int i;\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(JCF, attribute_name, attribute_length);\t\\\n-  fprintf (out, \", count: %d\\n\", n);\t\t\t\t\t\\\n-  for (i = 0; i < n; i++) {\t\t\t\t\t\t\\\n-    int start_pc = JCF_readu2 (jcf);\t\t\t\t\t\\\n-    int length = JCF_readu2 (jcf);\t\t\t\t\t\\\n-    int name_index = JCF_readu2 (jcf);\t\t\t\t\t\\\n-    int signature_index = JCF_readu2 (jcf);\t\t\t\t\\\n-    int slot = JCF_readu2 (jcf);\t\t\t\t\t\\\n-    fprintf (out, \"  slot#%d: name: \", slot);\t\t\t\t\\\n-    if (flag_print_constant_pool)\t\t\t\t\t\\\n-      fprintf (out, \"%d=\", name_index);\t\t\t\t\t\\\n-    print_name (out, jcf, name_index);\t\t\t\t\t\\\n-    fprintf (out, \", type: \");\t\t\t\t\t\t\\\n-    if (flag_print_constant_pool)\t\t\t\t\t\\\n-      fprintf (out, \"%d=\", signature_index);\t\t\t\t\\\n-    print_signature (out, jcf, signature_index, 0);\t\t\t\\\n-    fprintf (out, \" (pc: %d length: %d)\\n\", start_pc, length); }}\n-\n-#define HANDLE_LINENUMBERTABLE_ATTRIBUTE(COUNT) \\\n-{ int n = (COUNT); int i; \\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length); \\\n-  fprintf (out, \", count: %d\\n\", n); \\\n-  if (flag_disassemble_methods) \\\n-    for (i = 0; i < n; i++) {\\\n-      int start_pc = JCF_readu2 (jcf); \\\n-      int line_number = JCF_readu2 (jcf); \\\n-      fprintf (out, \"  line: %d at pc: %d\\n\", line_number, start_pc); }\\\n-  else \\\n-    JCF_SKIP (jcf, 4 * n); }\n-\n-#define HANDLE_INNERCLASSES_ATTRIBUTE(COUNT)\t\t\t\t    \\\n-{ int n = (COUNT);\t\t\t\t\t\t\t    \\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t    \\\n-  while (n--)\t\t\t\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      uint16 inner_class_info_index = JCF_readu2 (jcf);\t\t\t    \\\n-      uint16 outer_class_info_index = JCF_readu2 (jcf);\t\t\t    \\\n-      uint16 inner_name_index = JCF_readu2 (jcf);\t\t\t    \\\n-      uint16 inner_class_access_flags = JCF_readu2 (jcf);\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-      if (flag_print_class_info)\t\t\t\t\t    \\\n-\t{\t\t\t\t\t\t\t\t    \\\n-\t  fprintf (out, \"\\n  inner: \");\t\t\t\t\t    \\\n-\t  if (inner_class_info_index == 0)\t\t\t\t    \\\n-\t    fprintf (out, \" (no inner info index)\");\t\t\t    \\\n-\t  else\t\t\t\t\t\t\t\t    \\\n-\t    print_constant_terse_with_index (out, jcf,\t\t\t    \\\n-\t\t\t\t\t     inner_class_info_index,\t    \\\n-\t\t\t\t\t     CONSTANT_Class);\t\t    \\\n-\t  if (inner_name_index == 0)\t\t\t\t\t    \\\n-\t    fprintf (out, \" (anonymous)\");\t\t\t\t    \\\n-\t  else if (verbose || flag_print_constant_pool)\t\t\t    \\\n-\t    {\t\t\t\t\t\t\t\t    \\\n-\t      fprintf (out, \" (\");\t\t\t\t\t    \\\n-\t      print_constant_terse_with_index (out, jcf, inner_name_index,  \\\n-\t\t\t\t\t       CONSTANT_Utf8);\t\t    \\\n-\t      fputc (')', out);\t\t\t\t\t\t    \\\n-\t    }\t\t\t\t\t\t\t\t    \\\n-\t  fprintf (out, \", access flags: 0x%x\", inner_class_access_flags);  \\\n-\t  print_access_flags (out, inner_class_access_flags, 'c');\t    \\\n-\t  fprintf (out, \", outer class: \");\t\t\t\t    \\\n-\t  if (outer_class_info_index == 0)\t\t\t\t    \\\n-\t    fprintf (out, \"(not a member)\");\t\t\t\t    \\\n-\t  else\t\t\t\t\t\t\t\t    \\\n-\t    print_constant_terse_with_index (out, jcf,\t\t\t    \\\n-\t\t\t\t\t     outer_class_info_index,\t    \\\n-\t\t\t\t\t     CONSTANT_Class);\t\t    \\\n-\t}\t\t\t\t\t\t\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-  if (flag_print_class_info)\t\t\t\t\t\t    \\\n-    fputc ('\\n', out);\t\t\t\t\t\t\t    \\\n-}\n-\n-#define HANDLE_SOURCEDEBUGEXTENSION_ATTRIBUTE(LENGTH) \\\n-{ int i, n = (LENGTH), c = 0;\t\t\t\t\t  \\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length); \\\n-  fputc ('\\n', out); \\\n-  for (i = 0;  i < n;  i++) { c = JCF_readu(jcf); fputc(c, out); } \\\n-  if (c != '\\r' && c != '\\n') fputc('\\n', out); }\n-\n-#define HANDLE_ENCLOSINGMETHOD_ATTRIBUTE()\t\t\t\t\\\n-  { uint16 class_index, method_index;\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  class_index = JCF_readu2 (jcf);\t\t\t\t\t\\\n-  method_index = JCF_readu2 (jcf);\t\t\t\t\t\\\n-  fprintf (out, \"\\n  Class: \");\t\t\t\t\t\t\\\n-  print_constant_terse_with_index (out, jcf, class_index, CONSTANT_Class); \\\n-  fprintf (out, \"\\n  Method: \");\t\t\t\t\t\\\n-  print_constant_terse_with_index (out, jcf, method_index,\t\t\\\n-\t\t\t\t   CONSTANT_NameAndType);\t\t\\\n-  fputc ('\\n', out);\t\t\t\t\t\t\t\\\n-}\n-\n-#define HANDLE_SIGNATURE_ATTRIBUTE()\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  uint16 signature;\t\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  signature = JCF_readu2 (jcf);\t\t\t\t\t\t\\\n-  fprintf (out, \"\\n  Value: \");\t\t\t\t\t\t\\\n-  print_constant_terse_with_index (out, jcf, signature, CONSTANT_Utf8);\t\\\n-  fputc ('\\n', out);\t\t\t\t\t\t\t\\\n-}\n-\n-#define HANDLE_RUNTIMEVISIBLEANNOTATIONS_ATTRIBUTE()\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  print_annotations (out, jcf, 1);\t\t\t\t\t\\\n-}\n-\n-#define HANDLE_RUNTIMEINVISIBLEANNOTATIONS_ATTRIBUTE()\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  print_annotations (out, jcf, 1);\t\t\t\t\t\\\n-}\n-\n-#define HANDLE_RUNTIMEVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE()\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  print_parameter_annotations (out, jcf, 1);\t\t\t\t\\\n-}\n-\n-#define HANDLE_RUNTIMEINVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE()\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  print_parameter_annotations (out, jcf, 1);\t\t\t\t\\\n-}\n-\n-#define HANDLE_ANNOTATIONDEFAULT_ATTRIBUTE()\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  print_element_value (out, jcf, 1);\t\t\t\t\t\\\n-}\n-\n-#define HANDLE_BOOTSTRAP_METHODS_ATTRIBUTE()\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  COMMON_HANDLE_ATTRIBUTE(jcf, attribute_name, attribute_length);\t\\\n-  fputc ('\\n', out); jcf_parse_bootstrap_methods (jcf, attribute_length); \\\n-}\n-\n-#define HANDLE_END_BOOTSTRAP_METHODS(NUM_METHODS)\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    int i;\t\t\t\t\t\t\t\t\\\n-    for (i = 0; i < NUM_METHODS; i++)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tbootstrap_method *m = &jcf->bootstrap_methods.methods[i];\t\\\n-\tfprintf (out, \"  %d: \", i);\t\t\t\t\t\\\n-\tprint_constant (out, jcf, m->method_ref, 1);\t\t\t\\\n-\tfprintf (out, \"\\n\");\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\n-\n-#define PROCESS_OTHER_ATTRIBUTE(JCF, INDEX, LENGTH) \\\n-{ COMMON_HANDLE_ATTRIBUTE(JCF, INDEX, LENGTH); \\\n-  fputc ('\\n', out); JCF_SKIP (JCF, LENGTH); }\n-\n-#define START_FINAL_ATTRIBUTES(ATTRIBUTES_COUNT) \\\n-  if (flag_print_attributes > 0) \\\n-    fprintf (out, \"\\nAttributes (count: %d):\\n\", attributes_count);\n-\n-\n-\f\n-\n-static void\n-indent (FILE *stream, int level)\n-{\n-  int i;\n-  for (i = 0; i < level; ++i)\n-    fprintf (stream, \"  \");\n-}\n-\n-static void\n-print_element_value (FILE *stream, JCF *jcf, int level)\n-{\n-  uint8 tag = JCF_readu (jcf);\n-  indent (stream, level);\n-  switch (tag)\n-    {\n-    case 'B':\n-    case 'C':\n-    case 'S':\n-    case 'Z':\n-    case 'I':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tprint_constant_terse_with_index (stream, jcf, cindex,\n-\t\t\t\t\t CONSTANT_Integer);\n-      }\n-      break;\n-    case 'D':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tprint_constant_terse_with_index (stream, jcf, cindex,\n-\t\t\t\t\t CONSTANT_Double);\n-      }\n-      break;\n-    case 'F':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tprint_constant_terse_with_index (stream, jcf, cindex,\n-\t\t\t\t\t CONSTANT_Float);\n-      }\n-      break;\n-    case 'J':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tprint_constant_terse_with_index (stream, jcf, cindex,\n-\t\t\t\t\t CONSTANT_Long);\n-      }\n-      break;\n-    case 's':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\t/* Despite what the JVM spec says, compilers generate a Utf8\n-\t   constant here, not a String.  */\n-\tprint_constant_terse_with_index (stream, jcf, cindex,\n-\t\t\t\t\t CONSTANT_Utf8);\n-      }\n-      break;\n-\n-    case 'e':\n-      {\n-\tuint16 type_name_index = JCF_readu2 (jcf);\n-\tuint16 const_name_index = JCF_readu2 (jcf);\n-\tfprintf (stream, \"enum class: \");\n-\tprint_constant_terse_with_index (stream, jcf, type_name_index,\n-\t\t\t\t\t CONSTANT_Utf8);\n-\tfprintf (stream, \"\\n\");\n-\tindent (stream, level);\n-\tfprintf (stream, \"Field: \");\n-\tprint_constant_terse_with_index (stream, jcf, const_name_index,\n-\t\t\t\t\t CONSTANT_Utf8);\n-      }\n-      break;\n-    case 'c':\n-      {\n-\tuint16 class_info_index = JCF_readu2 (jcf);\n-\tprint_constant_terse_with_index (stream, jcf, class_info_index,\n-\t\t\t\t\t CONSTANT_Utf8);\n-      }\n-      break;\n-    case '@':\n-      {\n-\tfprintf (stream, \"Annotation:\\n\");\n-\tprint_annotation (stream, jcf, level + 1);\n-      }\n-      break;\n-    case '[':\n-      {\n-\tuint16 n_array_elts = JCF_readu2 (jcf);\n-\tfprintf (stream, \"array[%d]: [\\n\", (int) n_array_elts);\n-\twhile (n_array_elts--)\n-\t  print_element_value (stream, jcf, level + 1);\n-\tindent (stream, level);\n-\tfprintf (stream, \"]\");\n-      }\n-      break;\n-    default:\n-      fprintf (stream, \"Unexpected tag value: %d\", (int) tag);\n-      break;\n-    }\n-  fputc ('\\n', stream);\n-}\n-\n-static void\n-print_annotation (FILE *stream, JCF *jcf, int level)\n-{\n-  uint16 type_index = JCF_readu2 (jcf);\n-  uint16 npairs = JCF_readu2 (jcf);\n-  fprintf (stream, \"\\n\");\n-  indent (stream, level);\n-  fprintf (stream, \"Annotation name: \");\n-  print_constant_terse_with_index (stream, jcf, type_index,\n-\t\t\t\t   CONSTANT_Utf8);\n-  if (npairs)\n-    {\n-      fprintf (stream, \"\\n\");\n-      while (npairs--)\n-\t{\n-\t  uint16 name_index = JCF_readu2 (jcf);\n-\t  indent (stream, level + 1);\n-\t  fprintf (stream, \"Name: \");\n-\t  print_constant_terse_with_index (stream, jcf, name_index,\n-\t\t\t\t\t   CONSTANT_Utf8);\n-\t  fprintf (stream, \"\\n\");\n-\t  print_element_value (stream, jcf, level + 2);\n-\t}\n-    }\n-}\n-\n-static void\n-print_annotations (FILE *stream, JCF *jcf, int level)\n-{\n-  uint16 num = JCF_readu2 (jcf);\n-  while (num--)\n-    print_annotation (stream, jcf, level);\n-}\n-\n-static void\n-print_parameter_annotations (FILE *stream, JCF *jcf, int level)\n-{\n-  uint8 nparams = JCF_readu (jcf);\n-  uint8 i;\n-  for (i = 0; i < nparams; ++i)\n-    {\n-      indent (stream, level);\n-      fprintf (stream, \"Parameter annotations (%d):\\n\", (int) i);\n-      print_annotations (stream, jcf, level + 1);\n-    }\n-}\n-\n-\f\n-\n-static void\n-print_constant_ref (FILE *stream, JCF *jcf, int index)\n-{\n-  if (index <= 0 || index >= JPOOL_SIZE(jcf))\n-    fprintf (stream, \"<out of range>\");\n-  else\n-    {\n-      if (flag_print_constant_pool)\n-\tfprintf (stream, \"#%d=\", index);\n-      fputc ('<', stream);\n-      print_constant (stream, jcf, index, 1);\n-      fputc ('>', stream);\n-    }\n-}\n-\n-/* Print the access flags given by FLAGS.\n-   The CONTEXT is one of 'c' (class flags), 'f' (field flags),\n-   or 'm' (method flags). */\n-\n-static void\n-print_access_flags (FILE *stream, uint16 flags, char context)\n-{\n-  if (flags & ACC_PUBLIC) fprintf (stream, \" public\");\n-  if (flags & ACC_PRIVATE) fprintf (stream, \" private\");\n-  if (flags & ACC_PROTECTED) fprintf (stream, \" protected\");\n-  if (flags & ACC_ABSTRACT) fprintf (stream, \" abstract\");\n-  if (flags & ACC_STATIC) fprintf (stream, \" static\");\n-  if (flags & ACC_FINAL) fprintf (stream, \" final\");\n-  if (flags & ACC_TRANSIENT)\n-    fprintf (stream, context == 'm' ? \" varargs\" : \" transient\");\n-  if (flags & ACC_VOLATILE)\n-    fprintf (stream, context == 'm' ? \" bridge\" : \" volatile\");\n-  if (flags & ACC_NATIVE) fprintf (stream, \" native\");\n-  if (flags & ACC_SYNCHRONIZED)\n-    {\n-      if (context == 'c')\n-\tfprintf (stream, \" super\");\n-      else\n-\tfprintf (stream, \" synchronized\");\n-    }\n-  if (flags & ACC_INTERFACE)\n-    fprintf (stream, (flags & ACC_ANNOTATION) ? \" @interface\" : \" interface\");\n-  if (flags & ACC_ENUM) fprintf (stream, \" enum\");\n-  if (flags & ACC_STRICT) fprintf (stream, \" strictfp\");\n-  if (flags & ACC_SYNTHETIC) fprintf (stream, \" synthetic\");\n-}\n-\n-\n-static void\n-print_name (FILE* stream, JCF* jcf, int name_index)\n-{\n-  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n-    fprintf (stream, \"<not a UTF8 constant>\");\n-  else\n-    jcf_print_utf8 (stream, JPOOL_UTF_DATA (jcf,name_index),\n-\t\t    JPOOL_UTF_LENGTH (jcf, name_index));\n-}\n-\n-/* If the type of the constant at INDEX matches EXPECTED,\n-   print it tersely, otherwise more verbosely. */\n-\n-static void\n-print_constant_terse (FILE *out, JCF *jcf, int index, int expected)\n-{\n-  if (! CPOOL_INDEX_IN_RANGE (&jcf->cpool, index))\n-    fprintf (out, \"<constant pool index %d not in range>\", index);\n-  else if (JPOOL_TAG (jcf, index) != expected)\n-    {\n-      fprintf (out, \"<Unexpected constant type \");\n-      print_constant (out, jcf, index, 1);\n-      fprintf (out, \">\");\n-    }\n-  else\n-    print_constant (out, jcf, index, 0);\n-}\n-\n-static void\n-print_constant_terse_with_index (FILE *out, JCF *jcf, int index, int expected)\n-{\n-  if (flag_print_constant_pool)\n-    fprintf (out, \"%d=\", index);\n-  print_constant_terse (out, jcf, index, expected);\n-}\n-\n-/* Print the constant at INDEX in JCF's constant pool.\n-   If verbosity==0, print very tersely (no extraneous text).\n-   If verbosity==1, prefix the type of the constant.\n-   If verbosity==2, add more descriptive text. */\n-\n-static void\n-print_constant (FILE *out, JCF *jcf, int index, int verbosity)\n-{\n-  int j, n;\n-  jlong num;\n-  const char *str;\n-  int kind = JPOOL_TAG (jcf, index);\n-  switch (kind)\n-    {\n-    case CONSTANT_Class:\n-      n = JPOOL_USHORT1 (jcf, index);\n-      if (verbosity > 0)\n-\t{\n-\t  if (verbosity > 1)\n-\t    fprintf (out, \"Class name: %d=\", n);\n-\t  else\n-\t    fprintf (out, \"Class \");\n-\t}\n-      if (! CPOOL_INDEX_IN_RANGE (&jcf->cpool, n))\n-\tfprintf (out, \"<out of range>\");\n-      else if (verbosity < 2 && JPOOL_TAG (jcf, n) == CONSTANT_Utf8)\n-\t{\n-\t  int len = JPOOL_UTF_LENGTH (jcf, n);\n-\t  jcf_print_utf8_replace (out, JPOOL_UTF_DATA(jcf,n), len, '/', '.');\n-\t}\n-      else\n-\tprint_constant_terse (out, jcf, n, CONSTANT_Utf8);\n-      break;\n-    case CONSTANT_Fieldref:\n-      str = \"Field\"; goto field_or_method;\n-    case CONSTANT_Methodref:\n-      str = \"Method\"; goto field_or_method;\n-    case CONSTANT_InterfaceMethodref:\n-      str = \"InterfaceMethod\"; goto field_or_method;\n-    field_or_method:\n-      {\n-\tuint16 tclass = JPOOL_USHORT1 (jcf, index);\n-\tuint16 name_and_type = JPOOL_USHORT2 (jcf, index);\n-\tif (verbosity == 2)\n-\t  fprintf (out, \"%sref class: %d=\", str, tclass);\n-\telse if (verbosity > 0)\n-\t    fprintf (out, \"%s \", str);\n-\tprint_constant_terse (out, jcf, tclass, CONSTANT_Class);\n-\tif (verbosity < 2)\n-\t  fprintf (out, \".\");\n-\telse\n-\t  fprintf (out, \" name_and_type: %d=<\", name_and_type);\n-\tprint_constant_terse (out, jcf, name_and_type, CONSTANT_NameAndType);\n-\tif (verbosity == 2)\n-\t  fputc ('>', out);\n-      }\n-      break;\n-    case CONSTANT_String:\n-      j = JPOOL_USHORT1 (jcf, index);\n-      if (verbosity > 0)\n-\t{\n-\t  if (verbosity > 1)\n-\t    fprintf (out, \"String %d=\", j);\n-\t  else\n-\t    fprintf (out, \"String \");\n-\t}\n-      print_constant_terse (out, jcf, j, CONSTANT_Utf8);\n-      break;\n-    case CONSTANT_Integer:\n-      if (verbosity > 0)\n-\tfprintf (out, \"Integer \");\n-      num = JPOOL_INT (jcf, index);\n-      goto integer;\n-    case CONSTANT_Long:\n-      if (verbosity > 0)\n-\tfprintf (out, \"Long \");\n-      num = JPOOL_LONG (jcf, index);\n-      goto integer;\n-    integer:\n-      {\n-\tchar buffer[25];\n-\tformat_int (buffer, num, 10);\n-\tfprintf (out, \"%s\", buffer);\n-\tif (verbosity > 1)\n-\t  {\n-\t    format_uint (buffer, (uint64)num, 16);\n-\t    fprintf (out, \"=0x%s\", buffer);\n-\t  }\n-      }\n-      break;\n-    case CONSTANT_Float:\n-      {\n-\tjfloat fnum = JPOOL_FLOAT (jcf, index);\n-\n-\tif (verbosity > 0)\n-\t  fputs (\"Float \", out);\n-\n-\tif (fnum.negative)\n-\t  putc ('-', out);\n-\n-\tif (JFLOAT_FINITE (fnum))\n-\t  {\n-\t    int dummy;\n-\t    int exponent = fnum.exponent - JFLOAT_EXP_BIAS;\n-\t    double f;\n-\t    uint32 mantissa = fnum.mantissa;\n-\t    if (fnum.exponent == 0)\n-\t      /* Denormal.  */\n-\t      exponent++;\n-\t    else\n-\t      /* Normal; add the implicit bit.  */\n-\t      mantissa |= ((uint32)1 << 23);\n-\t    \n-\t    f = frexp ((float) mantissa, &dummy);\n-\t    f = ldexp (f, exponent + 1);\n-\t    fprintf (out, \"%.10g\", f);\n-\t  }\n-\telse\n-\t  {\n-\t    if (fnum.mantissa == 0)\n-\t      fputs (\"Inf\", out);\n-\t    else if (fnum.mantissa & JFLOAT_QNAN_MASK)\n-\t      fprintf (out, \"QNaN(%u)\", (fnum.mantissa & ~JFLOAT_QNAN_MASK));\n-\t    else\n-\t      fprintf (out, \"SNaN(%u)\", (fnum.mantissa & ~JFLOAT_QNAN_MASK));\n-\t  }\n-\n-\tif (verbosity > 1)\n-\t  fprintf (out, \", bits = 0x%08lx\", (unsigned long) JPOOL_UINT (jcf, index));\n-\t\n-\tbreak;\n-      }\n-    case CONSTANT_Double:\n-      {\n-\tjdouble dnum = JPOOL_DOUBLE (jcf, index);\n-\n-\tif (verbosity > 0)\n-\t  fputs (\"Double \", out);\n-\n-\tif (dnum.negative)\n-\t  putc ('-', out);\n-\n-\tif (JDOUBLE_FINITE (dnum))\n-\t  {\n-\t    int dummy;\n-\t    int exponent = dnum.exponent - JDOUBLE_EXP_BIAS;\n-\t    double d;\n-\t    uint64 mantissa = ((((uint64) dnum.mantissa0) << 32)\n-\t\t\t       + dnum.mantissa1);\n-\t    if (dnum.exponent == 0)\n-\t      /* Denormal.  */\n-\t      exponent++;\n-\t    else\n-\t      /* Normal; add the implicit bit.  */\n-\t      mantissa |= ((uint64)1 << 52);\n-\n-\t    d = frexp ((double) mantissa, &dummy);\n-\t    d = ldexp (d, exponent + 1);\n-\t    fprintf (out, \"%.20g\", d);\n-\t  }\n-\telse\n-\t  {\n-\t    uint64 mantissa = dnum.mantissa0 & ~JDOUBLE_QNAN_MASK;\n-\t    mantissa = (mantissa << 32) + dnum.mantissa1;\n-\n-\t    if (dnum.mantissa0 == 0 && dnum.mantissa1 == 0)\n-\t      fputs (\"Inf\", out);\n-\t    else if (dnum.mantissa0 & JDOUBLE_QNAN_MASK)\n-\t      fprintf (out, \"QNaN(%\" HOST_LONG_LONG_FORMAT \"u)\",\n-                (unsigned long long)mantissa);\n-\t    else\n-\t      fprintf (out, \"SNaN(%\" HOST_LONG_LONG_FORMAT \"u)\",\n-                (unsigned long long)mantissa);\n-\t  }\n-\tif (verbosity > 1)\n-\t  {\n-\t    int32 hi, lo;\n-\t    hi = JPOOL_UINT (jcf, index);\n-\t    lo = JPOOL_UINT (jcf, index + 1);\n-\t    fprintf (out, \", bits = 0x%08lx%08lx\", (unsigned long) hi,\n-\t\t     (unsigned long) lo);\n-\t  }\n-\tbreak;\n-      }\n-    case CONSTANT_NameAndType:\n-      {\n-\tuint16 name = JPOOL_USHORT1 (jcf, index);\n-\tuint16 sig = JPOOL_USHORT2 (jcf, index);\n-\tif (verbosity > 0)\n-\t  {\n-\t    if (verbosity > 1)\n-\t      fprintf (out, \"NameAndType name: %d=\", name);\n-\t    else\n-\t      fprintf (out, \"NameAndType \");\n-\t  }\n-\tprint_name (out, jcf, name);\n-\tif (verbosity <= 1)\n-\t  fputc (' ', out);\n-\telse\n-\t  fprintf (out, \", signature: %d=\", sig);\n-\tprint_signature (out, jcf, sig, 0);\n-      }\n-      break;\n-    case CONSTANT_Utf8:\n-      {\n-\tconst unsigned char *str = JPOOL_UTF_DATA (jcf, index);\n-\tint length = JPOOL_UTF_LENGTH (jcf, index);\n-\tif (verbosity > 0)\n-\t  { /* Print as 8-bit bytes. */\n-\t    fputs (\"Utf8: \\\"\", out);\n-\t    while (--length >= 0)\n-\t      jcf_print_char (out, *str++);\n-\t  }\n-\telse\n-\t  { /* Print as Unicode. */\n-\t    fputc ('\\\"', out);\n-\t    jcf_print_utf8 (out, str, length);\n-\t  }\n-\tfputc ('\\\"', out);\n-      }\n-      break;\n-    case CONSTANT_MethodHandle:\n-      {\n-\tint kind = JPOOL_USHORT1 (jcf, index);\n-\tif (verbosity > 0)\n-\t  fprintf (out, \"MethodHandle kind: %d=\", kind);\n-\tswitch(kind) {\n-\tcase 1:\n-\tcase 2:\n-\tcase 3:\n-\tcase 4:\n-\t  if (verbosity > 0)\n-\t    fprintf (out, \"Fieldref: %ld=\", (long) JPOOL_USHORT2 (jcf, index));\n-\t  print_constant (out, jcf, JPOOL_USHORT2 (jcf, index), 0);\n-\t  break;\n-\tcase 5:\n-\tcase 6:\n-\tcase 7:\n-\tcase 8:\n-\t  if (verbosity > 0)\n-\t    fprintf (out, \"Methodref: %ld=\", (long) JPOOL_USHORT2 (jcf, index));\n-\t  print_constant (out, jcf, JPOOL_USHORT2 (jcf, index), 0);\n-\t  break;\n-\tcase 9:\n-\t  if (verbosity > 0)\n-\t    fprintf (out, \"InterfaceMethodref: %ld=\",\n-\t\t     (long) JPOOL_USHORT2 (jcf, index));\n-\t  print_constant (out, jcf, JPOOL_USHORT2 (jcf, index), 0);\n-\t  break;\n-\t}\n-\tbreak;\n-      }\n-    case CONSTANT_MethodType:\n-      if (verbosity > 0)\n-\tfprintf (out, \"MethodType %ld: \", (long) JPOOL_USHORT1 (jcf, index));\n-      print_signature (out, jcf, JPOOL_USHORT1 (jcf, index), 0);\n-      break;\n-    case CONSTANT_InvokeDynamic:\n-      {\n-\tuint16 name_and_type = JPOOL_USHORT2 (jcf, index);\n-\tif (verbosity > 0)\n-\t  fprintf (out, \"InvokeDynamic: \");\n-\tfprintf (out, \"bootstrap_method: %ld \",\n-\t\t (long) JPOOL_USHORT1 (jcf, index));\n-\tif (verbosity == 2)\n-\t  fprintf (out, \" name_and_type: %d=<\", name_and_type);\n-\tprint_constant_terse (out, jcf, name_and_type, CONSTANT_NameAndType);\n-\tif (verbosity == 2)\n-\t  fputc ('>', out);\n-\tbreak;\n-      }\n-    default:\n-      fprintf (out, \"(Unknown constant type %d)\", kind);\n-    }\n-}\n-\n-static void\n-print_constant_pool (JCF *jcf)\n-{\n-  int i;\n-  for (i = 1; i < JPOOL_SIZE(jcf); i++)\n-    {\n-      int kind = JPOOL_TAG (jcf, i);\n-      fprintf (out, \"#%d: \", i);\n-      print_constant (out, jcf, i, 2);\n-      fprintf (out, \"\\n\");\n-      if (kind == CONSTANT_Double || kind == CONSTANT_Long)\n-\ti++; /* These take up two slots in the constant table */\n-    }\n-}\n-\n-static void\n-print_signature_type (FILE* stream, const unsigned char **ptr,\n-\t\t      const unsigned char *limit)\n-{\n-  int array_size;\n-  if ((*ptr) >= limit)\n-    return;\n-  switch (*(*ptr))\n-    {\n-    case '[':\n-      array_size = -1;\n-      for ((*ptr)++; (*ptr) < limit && ISDIGIT (**ptr); (*ptr)++)\n-\t{\n-\t  array_size = (array_size < 0 ? 0 : 10 * array_size) + *(*ptr) - '0';\n-\t}\n-      print_signature_type (stream, ptr, limit);\n-      if (array_size == -1)\n-\tfprintf (stream, \"[]\");\n-      else\n-\tfprintf (stream, \"[%d]\", array_size);\n-      break;\n-    case '(':\n-      {\n-\tint nargs = 0;\n-\tfputc (*(*ptr)++, stream);\n-\tfor (; **ptr != ')' && *ptr < limit; nargs++)\n-\t  {\n-\t    if (nargs > 0)\n-\t      fputc (',', stream);\n-\t    print_signature_type (stream, ptr, limit);\n-\t  }\n-\tif (*ptr < limit)\n-\t  {\n-\t    fputc (*(*ptr)++, stream);\n-\t    print_signature_type (stream, ptr, limit);\n-\t  }\n-\telse\n-\t  fprintf (stream, \"???\");\n-      }\n-    break;\n-      \n-    case 'B':  fprintf (stream, \"byte\");  (*ptr)++;  break;\n-    case 'C':  fprintf (stream, \"char\");  (*ptr)++;  break;\n-    case 'D':  fprintf (stream, \"double\");  (*ptr)++;  break;\n-    case 'F':  fprintf (stream, \"float\");  (*ptr)++;  break;\n-    case 'S':  fprintf (stream, \"short\");  (*ptr)++;  break;\n-    case 'I':  fprintf (stream, \"int\");  (*ptr)++;  break;\n-    case 'J':  fprintf (stream, \"long\");  (*ptr)++;  break;\n-    case 'Z':  fprintf (stream, \"boolean\");  (*ptr)++;  break;\n-    case 'V':  fprintf (stream, \"void\");  (*ptr)++;  break;\n-\n-    case 'L':\n-      for ((*ptr)++; (*ptr)<limit && *(*ptr) != ';'; (*ptr)++)\n-\tjcf_print_char (stream, *(*ptr) == '/' ? '.' : *(*ptr));\n-      if (*(*ptr) == ';')\n-\t(*ptr)++;\n-      break;\n-    default:\n-      jcf_print_char (stream, *(*ptr)++);\n-    }\n-}\n-\n-static void\n-print_signature (FILE* stream, JCF *jcf, int signature_index, int options)\n-{\n-  if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)\n-    print_constant_terse (out, jcf, signature_index, CONSTANT_Utf8);\n-  else\n-    {\n-      const unsigned char *str = JPOOL_UTF_DATA (jcf, signature_index);\n-      int length = JPOOL_UTF_LENGTH (jcf, signature_index);\n-      const unsigned char *limit;\n-      limit = str + length;\n-      if (str >= limit)\n-\tfprintf (stream, \"<empty signature string>\");\n-      else\n-\t{\n-\t  if (options & PRINT_SIGNATURE_RESULT_ONLY)\n-\t    {\n-\t      while (str < limit && *str++ != ')') ;\n-\t    }\n-\t  if (options & PRINT_SIGNATURE_ARGS_ONLY)\n-\t    {\n-\t      str++;\n-\t      fputc ('(', stream);\n-\t      while (str < limit && *str != ')')\n-\t\t{\n-\t\t  print_signature_type (stream, &str, limit);\n-\t\t  if (*str != ')')\n-\t\t    fputs (\", \", stream);\n-\t\t}\n-\t      fputc (')', stream);\n-\t    }\n-\t  else\n-\t    {\n-\t      print_signature_type (stream, &str, limit);\n-\t      if (str < limit)\n-\t\t{\n-\t\t  fprintf (stream, \"<junk:\");\n-\t\t  jcf_print_utf8 (stream, str, limit - str);\n-\t\t  fputc ('>', stream);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-static void\n-print_exception_table (JCF *jcf, const unsigned char *entries, int count)\n-{\n-  /* Print exception table. */\n-  int i = count;\n-  if (i > 0)\n-    {\n-      const unsigned char *ptr = entries;\n-      fprintf (out, \"Exceptions (count: %d):\\n\", i);\n-      for (; --i >= 0;  ptr+= 8)\n-\t{\n-\t  int start_pc = GET_u2 (ptr);\n-\t  int end_pc = GET_u2 (ptr+2);\n-\t  int handler_pc = GET_u2 (ptr+4);\n-\t  int catch_type = GET_u2 (ptr+6);\n-\t  fprintf (out, \"  start: %d, end: %d, handler: %d, type: \",\n-\t\t   start_pc, end_pc, handler_pc);\n-\t  if (catch_type == 0)\n-\t    fputs (\"0 /* finally */\", out);\n-\t  else\n-\t    print_constant_terse_with_index (out, jcf,\n-\t\t\t\t\t     catch_type, CONSTANT_Class);\n-\t  fputc ('\\n', out);\n-\t}\n-    }\n-}\n-\n-#include \"jcf-reader.c\"\n-\n-static void\n-process_class (JCF *jcf)\n-{\n-  int code;\n-  if (jcf_parse_preamble (jcf) != 0)\n-    fprintf (stderr, _(\"Not a valid Java .class file.\\n\"));    \n-\n-  /* Parse and possibly print constant pool */\n-  code = jcf_parse_constant_pool (jcf);\n-  if (code != 0)\n-    {\n-      fprintf (stderr, _(\"error while parsing constant pool\\n\"));\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  code = verify_constant_pool (jcf);\n-  if (code > 0)\n-    {\n-      fprintf (stderr, _(\"error in constant pool entry #%d\\n\"), code);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  if (flag_print_constant_pool)\n-    print_constant_pool (jcf);\n-\n-  jcf_parse_class (jcf);\n-  code = jcf_parse_fields (jcf);\n-  if (code != 0)\n-    {\n-      fprintf (stderr, _(\"error while parsing fields\\n\"));\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  code = jcf_parse_methods (jcf);\n-  if (code != 0)\n-    {\n-      fprintf (stderr, _(\"error while parsing methods\\n\"));\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  code = jcf_parse_final_attributes (jcf);\n-  if (code != 0)\n-    {\n-      fprintf (stderr, _(\"error while parsing final attributes\\n\"));\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  jcf->filename = NULL;\n-}\n-\n-\f\n-\n-/* This is used to mark options with no short value.  */\n-#define LONG_OPT(Num)  ((Num) + 128)\n-\n-#define OPT_classpath     LONG_OPT (0)\n-#define OPT_CLASSPATH     OPT_classpath\n-#define OPT_bootclasspath LONG_OPT (1)\n-#define OPT_extdirs       LONG_OPT (2)\n-#define OPT_HELP          LONG_OPT (3)\n-#define OPT_VERSION       LONG_OPT (4)\n-#define OPT_JAVAP         LONG_OPT (5)\n-\n-static const struct option options[] =\n-{\n-  { \"classpath\",     required_argument, NULL, OPT_classpath },\n-  { \"bootclasspath\", required_argument, NULL, OPT_bootclasspath },\n-  { \"extdirs\",       required_argument, NULL, OPT_extdirs },\n-  { \"CLASSPATH\",     required_argument, NULL, OPT_CLASSPATH },\n-  { \"help\",          no_argument,       NULL, OPT_HELP },\n-  { \"verbose\",       no_argument,       NULL, 'v' },\n-  { \"version\",       no_argument,       NULL, OPT_VERSION },\n-  { \"javap\",         no_argument,       NULL, OPT_JAVAP },\n-  { \"print-main\",    no_argument,       &flag_print_main, 1 },\n-  { \"print-constants\", no_argument,     &flag_print_constant_pool, 1 },\n-  { NULL,            no_argument,       NULL, 0 }\n-};\n-\n-static void\n-usage (void)\n-{\n-  fprintf (stderr, _(\"Try 'jcf-dump --help' for more information.\\n\"));\n-  exit (1);\n-}\n-\n-static void\n-help (void)\n-{\n-  printf (_(\"Usage: jcf-dump [OPTION]... CLASS...\\n\\n\"));\n-  printf (_(\"Display contents of a class file in readable form.\\n\\n\"));\n-  printf (_(\"  -c                      Disassemble method bodies\\n\"));\n-  printf (_(\"  --javap                 Generate output in 'javap' format\\n\"));\n-  printf (\"\\n\");\n-  printf (_(\"  --classpath PATH        Set path to find .class files\\n\"));\n-  printf (_(\"  -IDIR                   Append directory to class path\\n\"));\n-  printf (_(\"  --bootclasspath PATH    Override built-in class path\\n\"));\n-  printf (_(\"  --extdirs PATH          Set extensions directory path\\n\"));\n-  printf (_(\"  -o FILE                 Set output file name\\n\"));\n-  printf (\"\\n\");\n-  printf (_(\"  --help                  Print this help, then exit\\n\"));\n-  printf (_(\"  --version               Print version number, then exit\\n\"));\n-  printf (_(\"  -v, --verbose           Print extra information while running\\n\"));\n-  printf (\"\\n\");\n-  printf (_(\"For bug reporting instructions, please see:\\n\"\n-\t    \"%s.\\n\"), bug_report_url);\n-  exit (0);\n-}\n-\n-static void\n-version (void)\n-{\n-  printf (\"jcf-dump %s%s\\n\\n\", pkgversion_string, version_string);\n-  printf (\"Copyright %s 2016 Free Software Foundation, Inc.\\n\", _(\"(C)\"));\n-  printf (_(\"This is free software; see the source for copying conditions.  There is NO\\n\"\n-\t    \"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"));\n-  exit (0);\n-}\n-\n-int\n-main (int argc, char** argv)\n-{\n-  JCF jcf[1];\n-  int argi, opt;\n-  const char *p;\n-\n-  p = argv[0] + strlen (argv[0]);\n-  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))\n-    --p;\n-  progname = p;\n-\n-  xmalloc_set_program_name (progname);\n-\n-  /* Unlock the stdio streams.  */\n-  unlock_std_streams ();\n-\n-  gcc_init_libintl ();\n-\n-  diagnostic_initialize (global_dc, 0);\n-\n-  if (argc <= 1)\n-    {\n-      fprintf (stderr, _(\"jcf-dump: no classes specified\\n\"));\n-      usage ();\n-    }\n-\n-  jcf_path_init ();\n-\n-  /* We use getopt_long_only to allow single `-' long options.  For\n-     some of our options this is more natural.  */\n-  while ((opt = getopt_long_only (argc, argv, \"o:I:vc\", options, NULL)) != -1)\n-    {\n-      switch (opt)\n-\t{\n-\tcase 0:\n-\t  /* Already handled.  */\n-\t  break;\n-\n-        case 'o':\n-\t  output_file = optarg;\n-\t  break;\n-\n-\tcase 'I':\n-\t  jcf_path_include_arg (optarg);\n-\t  break;\n-\n-\tcase 'v':\n-\t  verbose++;\n-\t  break;\n-\n-\tcase 'c':\n-\t  flag_disassemble_methods = 1;\n-\t  break;\n-\n-\tcase OPT_classpath:\n-\t  jcf_path_classpath_arg (optarg);\n-\t  break;\n-\n-\tcase OPT_bootclasspath:\n-\t  jcf_path_bootclasspath_arg (optarg);\n-\t  break;\n-\n-\tcase OPT_extdirs:\n-\t  jcf_path_extdirs_arg (optarg);\n-\t  break;\n-\n-\tcase OPT_HELP:\n-\t  help ();\n-\t  break;\n-\n-\tcase OPT_VERSION:\n-\t  version ();\n-\t  break;\n-\n-\tcase OPT_JAVAP:\n-\t  flag_javap_compatible++;\n-\t  flag_print_constant_pool = 0;\n-\t  flag_print_attributes = 0;\n-\t  break;\n-\n-\tdefault:\n-\t  usage ();\n-\t}\n-    }\n-\n-  if (verbose && ! flag_javap_compatible)\n-    flag_print_constant_pool = 1;\n-\n-  if (optind == argc)\n-    {\n-      fprintf (stderr, _(\"jcf-dump: no classes specified\\n\"));\n-      usage ();\n-    }\n-\n-  jcf_path_seal (verbose);\n-\n-  if (flag_print_main)\n-    {\n-      flag_print_fields = 0;\n-      flag_print_methods = 0;\n-      flag_print_constant_pool = 0;\n-      flag_print_attributes = 0;\n-      flag_print_class_info = 0;\n-    }\n-\n-  if (output_file)\n-    {\n-      out = fopen (output_file, \"w\");\n-      if (! out)\n-\t{\n-\t  fprintf (stderr, _(\"Cannot open '%s' for output.\\n\"), output_file);\n-\t  return FATAL_EXIT_CODE;\n-\t}\n-    }\n-  else\n-    out = stdout;\n-\n-  if (optind >= argc)\n-    {\n-      fprintf (out, \"Reading .class from <standard input>.\\n\");\n-      open_class (\"<stdio>\", jcf, 0, NULL);\n-      process_class (jcf);\n-    }\n-  else\n-    {\n-      for (argi = optind; argi < argc; argi++)\n-\t{\n-\t  char *arg = argv[argi];\n-\t  const char *class_filename = find_class (arg, strlen (arg), jcf);\n-\t  if (class_filename == NULL)\n-\t    class_filename = find_classfile (arg, jcf, NULL);\n-\t  if (class_filename == NULL)\n-\t    {\n-\t      perror (\"Could not find class\");\n-\t      return FATAL_EXIT_CODE;\n-\t    }\n-\t  JCF_FILL (jcf, 4);\n-\t  if (GET_u4 (jcf->read_ptr) == ZIPMAGIC)\n-\t    {\n-\t      long compressed_size, member_size;\n-\t      int compression_method, filename_length, extra_length;\n-\t      const char *filename;\n-\t      int total_length;\n-\t      if (flag_print_class_info)\n-\t\tfprintf (out, \"Reading classes from archive %s.\\n\",\n-\t\t\t class_filename);\n-\t      for (;;)\n-\t\t{\n-\t\t  int skip = 0;\n-\t\t  jcf_filbuf_t save_filbuf = jcf->filbuf;\n-\t\t  long magic = JCF_readu4_le (jcf);\n-\t\t  if (magic == 0x02014b50 || magic == 0x06054b50)\n-\t\t    break;  /* got to central directory */\n-\t\t  if (magic != 0x04034b50) /* ZIPMAGIC (little-endian) */\n-\t\t    {\n-\t\t      fprintf (stderr, _(\"bad format of .zip/.jar archive\\n\"));\n-\t\t      return FATAL_EXIT_CODE;\n-\t\t    }\n-\t\t  JCF_FILL (jcf, 26);\n-\t\t  JCF_SKIP (jcf, 2);\n-\t\t  (void) /* general_purpose_bits = */ JCF_readu2_le (jcf);\n-\t\t  compression_method = JCF_readu2_le (jcf);\n-\t\t  JCF_SKIP (jcf, 8);\n-\t\t  compressed_size = JCF_readu4_le (jcf);\n-\t\t  member_size = JCF_readu4_le (jcf);\n-\t\t  filename_length = JCF_readu2_le (jcf);\n-\t\t  extra_length = JCF_readu2_le (jcf);\n-\t\t  total_length = filename_length + extra_length\n-\t\t    + compressed_size;\n-\t\t  if (jcf->read_end - jcf->read_ptr < total_length)\n-\t\t    jcf_trim_old_input (jcf);\n-\t\t  JCF_FILL (jcf, total_length);\n-\t\t  filename = (const char *) jcf->read_ptr;\n-\t\t  JCF_SKIP (jcf, filename_length);\n-\t\t  JCF_SKIP (jcf, extra_length);\n-\t\t  if (filename_length > 0\n-\t\t      && filename[filename_length-1] == '/')\n-\t\t    {\n-\t\t      if (flag_print_class_info)\n-\t\t\tfprintf (out, \"[Skipping directory %.*s]\\n\",\n-\t\t\t\t filename_length, filename);\n-\t\t      skip = 1;\n-\t\t    }\n-\t\t  else if (compression_method != 0)\n-\t\t    {\n-\t\t      if (flag_print_class_info)\n-\t\t\tfprintf (out, \"[Skipping compressed file %.*s]\\n\",\n-\t\t\t\t filename_length, filename);\n-\t\t      skip = 1;\n-\t\t    }\n-\t\t  else if (member_size < 4\n-\t\t\t   || GET_u4 (jcf->read_ptr) != 0xcafebabe)\n-\t\t    {\n-\t\t      if (flag_print_class_info)\n-\t\t\tfprintf (out, \"[Skipping non-.class member %.*s]\\n\",\n-\t\t\t\t filename_length, filename);\n-\t\t      skip = 1;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (flag_print_class_info)\n-\t\t\tfprintf (out, \"Reading class member: %.*s.\\n\",\n-\t\t\t\t filename_length, filename);\n-\t\t    }\n-\t\t  if (skip)\n-\t\t    {\n-\t\t      JCF_SKIP (jcf, compressed_size);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      unsigned char *save_end;\n-\t\t      jcf->filbuf = jcf_unexpected_eof;\n-\t\t      save_end = jcf->read_end;\n-\t\t      jcf->read_end = jcf->read_ptr + compressed_size;\n-\t\t      process_class (jcf);\n-\t\t      jcf->filbuf = save_filbuf;\n-\t\t      jcf->read_end = save_end;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (flag_print_class_info)\n-\t\tfprintf (out, \"Reading .class from %s.\\n\", class_filename);\n-\t      process_class (jcf);\n-\t    }\n-\t  JCF_FINISH(jcf);\n-\t}\n-    }\n-\n-  return SUCCESS_EXIT_CODE;\n-}\n-\n-\f\n-\n-static void\n-disassemble_method (JCF* jcf, const unsigned char *byte_ops, int len)\n-{\n-#undef PTR\n-  int PC;\n-  int i;\n-  int saw_wide = 0;\n-  if (flag_disassemble_methods == 0)\n-    return;\n-#define BCODE byte_ops\n-  for (PC = 0; PC < len;)\n-    {\n-      int oldpc = PC;\n-      int saw_index;\n-      jint INT_temp;\n-      switch (byte_ops[PC++])\n-\t{\n-\n-/* This is the actual code emitted for each of opcodes in javaops.def.\n-   The actual opcode-specific stuff is handled by the OPKIND macro.\n-   I.e. for an opcode whose OPKIND is BINOP, the BINOP will be called.\n-   Those macros are defined below.  The OPKINDs that do not have any\n-   inline parameters (such as BINOP) and therefore do mot need anything\n-   else to me printed out just use an empty body. */\n-\n-#define JAVAOP(OPNAME, OPCODE, OPKIND, OPERAND_TYPE, OPERAND_VALUE) \\\n-        case OPCODE: \\\n-\t  fprintf (out, \"%3d: %s\", oldpc, #OPNAME); \\\n-\t  OPKIND(OPERAND_TYPE, OPERAND_VALUE); \\\n-\t  fputc ('\\n', out); \\\n-\t  break;\n-\n-#define CONST_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n-#define CONST_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n-#define VAR_INDEX_1 (saw_index = 1, IMMEDIATE_u1)\n-#define VAR_INDEX_2 (saw_index = 1, IMMEDIATE_u2)\n-\n-#define CHECK_PC_IN_RANGE(PC) (PC < 0 || PC > len ? \\\n-  (fprintf(stderr, _(\"Bad byte codes.\\n\")), exit(-1), 0) : 1)\n-\n-/* Print out operand (if not implied by the opcode) for PUSCH opcodes.\n-   These all push a constant onto the opcode stack. */\n-#define PUSHC(OPERAND_TYPE, OPERAND_VALUE) \\\n-  saw_index = 0, i = (OPERAND_VALUE); \\\n-  if (oldpc+1 == PC) /* nothing */; \\\n-  else if (saw_index) fprintf (out, \" \"), print_constant_ref (out, jcf, i); \\\n-  else fprintf (out, \" %d\", i);\n-\n-/* Print out operand (a local variable index) for LOAD opcodes.\n-   These all push local variable onto the opcode stack. */\n-#define LOAD(OPERAND_TYPE, OPERAND_VALUE) \\\n-  INT_temp = saw_wide ? IMMEDIATE_u2 : (OPERAND_VALUE); goto load_store;\n-\n-/* Handle STORE opcodes same as LOAD opcodes.\n-   These all store a value from the opcode stack in a local variable. */\n-#define STORE LOAD\n-\n-/* Handle more kind of opcodes. */\n-#define STACK(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n-#define UNOP(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n-#define BINOP(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n-#define CONVERT(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n-#define CONVERT2(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n-#define RETURN(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n-#define UNKNOWN(OPERAND_TYPE, OPERAND_VALUE) /* nothing */\n-\n-/* Handle putfield and getfield opcodes, with static versions. */\n-#define FIELD(MAYBE_STATIC, PUT_OR_GET) \\\n-  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2)\n-\n-/* Print operand for invoke opcodes. */\n-#define INVOKE(OPERAND_TYPE, OPERAND_VALUE) \\\n-  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2);\\\n-  if (OPERAND_VALUE) /* for invokeinterface */ \\\n-  { int nargs = IMMEDIATE_u1;  PC++; \\\n-    fprintf (out, \" nargs:%d\", nargs); }\n-\n-#define OBJECT(OPERAND_TYPE, OPERAND_VALUE) \\\n-  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2);\n-\n-#define ARRAY(OPERAND_TYPE, SUBOP) \\\n-  ARRAY_##SUBOP(OPERAND_TYPE)\n-/* Handle sub-categories of ARRAY opcodes. */\n-#define ARRAY_LOAD(TYPE) /* nothing */\n-#define ARRAY_STORE(TYPE) /* nothing */\n-#define ARRAY_LENGTH(TYPE) /* nothing */\n-#define ARRAY_NEW(TYPE) ARRAY_NEW_##TYPE\n-#define ARRAY_NEW_NUM \\\n- INT_temp = IMMEDIATE_u1; \\\n- { switch ((int) INT_temp) {  \\\n-    case  4: fputs (\" boolean\", out); break; \\\n-    case  5: fputs (\" char\", out); break; \\\n-    case  6: fputs (\" float\", out); break; \\\n-    case  7: fputs (\" double\", out); break; \\\n-    case  8: fputs (\" byte\", out); break; \\\n-    case  9: fputs (\" short\", out); break; \\\n-    case 10: fputs (\" int\", out); break; \\\n-    case 11: fputs (\" long\", out); break; \\\n-    default: fprintf (out, \" <unknown type code %ld>\", (long)INT_temp); break;\\\n-  } }\n-\n-#define ARRAY_NEW_PTR  \\\n-  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2);\n-\n-#define ARRAY_NEW_MULTI \\\n-  fputc (' ', out); print_constant_ref (out, jcf, IMMEDIATE_u2); \\\n-  fprintf (out, \" %d\", IMMEDIATE_u1); /* number of dimensions */\n-\n-#define TEST(OPERAND_TYPE, OPERAND_VALUE) \\\n-  fprintf (out, \" %d\", oldpc + IMMEDIATE_s2)\n-\n-#define BRANCH(OPERAND_TYPE, OPERAND_VALUE) \\\n-  saw_index = 0, INT_temp = (OPERAND_VALUE); \\\n-  fprintf (out, \" %ld\", (long) (saw_index ? INT_temp : oldpc + INT_temp))\n-\n-#define JSR(OPERAND_TYPE, OPERAND_VALUE) \\\n-  saw_index = 0, INT_temp = (OPERAND_VALUE); \\\n-  fprintf (out, \" %ld\", (long) (saw_index ? INT_temp : oldpc + INT_temp))\n-\n-#undef RET /* Defined by config/i386/i386.h */\n-#define RET(OPERAND_TYPE, OPERAND_VALUE) \\\n-  INT_temp = saw_wide ? IMMEDIATE_u2 : (OPERAND_VALUE); \\\n-  saw_wide = 0; \\\n-  fprintf (out, \" %ld\", (long) INT_temp);\n-\n-#define SWITCH(OPERAND_TYPE, TABLE_OR_LOOKUP) \\\n-  PC = (PC + 3) / 4 * 4; TABLE_OR_LOOKUP##_SWITCH\n-\n-#define LOOKUP_SWITCH \\\n-  { jint default_offset = IMMEDIATE_s4;  jint npairs = IMMEDIATE_s4; \\\n-    fprintf (out, \" npairs=%ld, default=%ld\", (long) npairs, (long) default_offset+oldpc); \\\n-    while (--npairs >= 0) { \\\n-     jint match = IMMEDIATE_s4; jint offset = IMMEDIATE_s4; \\\n-     fprintf (out, \"\\n%10ld: %ld\", (long)match, (long)(offset+oldpc)); } \\\n-  }\n-\n-#define TABLE_SWITCH \\\n-  { jint default_offset = IMMEDIATE_s4; \\\n-    jint low = IMMEDIATE_s4; jint high = IMMEDIATE_s4; \\\n-    fprintf (out, \" low=%ld, high=%ld, default=%ld\", \\\n-      (long) low, (long) high, (long) default_offset+oldpc); \\\n-    for (; low <= high; low++) { \\\n-     jint offset = IMMEDIATE_s4; \\\n-     fprintf (out, \"\\n%10ld: %ld\", (long)low, (long)(offset+oldpc)); } \\\n-  }\n-\n-#define SPECIAL(OPERAND_TYPE, OPERAND_VALUE) \\\n-  SPECIAL_##OPERAND_VALUE(OPERAND_TYPE)\n-\n-#define SPECIAL_IINC(OPERAND_TYPE) \\\n-  i = saw_wide ? IMMEDIATE_u2 : IMMEDIATE_u1; \\\n-  fprintf (out, \" %d\", i); \\\n-  i = saw_wide ? IMMEDIATE_s2 : IMMEDIATE_s1; \\\n-  saw_wide = 0; \\\n-  fprintf (out, \" %d\", i)\n-\n-#define SPECIAL_WIDE(OPERAND_TYPE) \\\n-  saw_wide = 1;\n-\n-#define SPECIAL_EXIT(OPERAND_TYPE) /* nothing */\n-#define SPECIAL_ENTER(OPERAND_TYPE) /* nothing */\n-#define SPECIAL_BREAK(OPERAND_TYPE) /* nothing */\n-#define SPECIAL_THROW(OPERAND_TYPE) /* nothing */\n-\n-#define IMPL(OPERAND_TYPE, OPERAND_VALUE) \\\n-  fprintf (out, \" %d\", IMMEDIATE_u##OPERAND_VALUE)\n-\n-#define COND(OPERAND_TYPE, OPERAND_VALUE) \\\n-   TEST(OPERAND_TYPE, OPERAND_VALUE)\n-\n-#include \"javaop.def\"\n-\n-\tload_store:\n-\t  if (oldpc+1 == PC) /* nothing - local index implied by opcode */;\n-\t  else\n-\t    {\n-\t      saw_wide = 0;\n-\t      fprintf (out, \" %ld\", (long) INT_temp);\n-\t    }\n-\t  fputc ('\\n', out);\n-\t  break;\n-\n-\tdefault:\n-\t  fprintf (out, \"%3d: unknown(%3d)\\n\", oldpc, byte_ops[PC]);\n-\t}\n-    }\n-}"}, {"sha": "cc8616b86381f9bc6ef15dc1bdd5b358700de29e", "filename": "gcc/java/jcf-io.c", "status": "removed", "additions": 0, "deletions": 566, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,566 +0,0 @@\n-/* Utility routines for finding and reading Java(TM) .class files.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-\n-#include \"jcf.h\"\n-#include <dirent.h>\n-\n-#include \"zlib.h\"\n-\n-int\n-jcf_unexpected_eof (JCF *jcf, int count ATTRIBUTE_UNUSED)\n-{\n-  if (jcf->filename)\n-    fprintf (stderr, \"Premature end of .class file %s.\\n\", jcf->filename);\n-  else\n-    fprintf (stderr, \"Premature end of .class file <stdin>.\\n\");\n-  exit (-1);\n-}\n-\n-void\n-jcf_trim_old_input (JCF *jcf)\n-{\n-  int count = jcf->read_ptr - jcf->buffer;\n-  if (count > 0)\n-    {\n-      memmove (jcf->buffer, jcf->read_ptr, jcf->read_end - jcf->read_ptr);\n-      jcf->read_ptr -= count;\n-      jcf->read_end -= count;\n-    }\n-}\n-\n-int\n-jcf_filbuf_from_stdio (JCF *jcf, int count)\n-{\n-  FILE *file = (FILE*) (jcf->read_state);\n-  if (count > jcf->buffer_end - jcf->read_ptr)\n-    {\n-      JCF_u4 old_read_ptr = jcf->read_ptr - jcf->buffer;\n-      JCF_u4 old_read_end = jcf->read_end - jcf->buffer;\n-      JCF_u4 old_size = jcf->buffer_end - jcf->buffer;\n-      JCF_u4 new_size = (old_size == 0 ? 2000 : 2 * old_size) + count;\n-      unsigned char *new_buffer\n-\t= jcf->buffer == NULL ? XNEWVAR (unsigned char, new_size)\n-\t: XRESIZEVAR (unsigned char, jcf->buffer, new_size);\n-      jcf->buffer = new_buffer;\n-      jcf->buffer_end = new_buffer + new_size;\n-      jcf->read_ptr = new_buffer + old_read_ptr;\n-      jcf->read_end = new_buffer + old_read_end;\n-    }\n-  count -= jcf->read_end - jcf->read_ptr;\n-  if (count <= 0)\n-    return 0;\n-  if ((int) fread (jcf->read_end, 1, count, file) != count)\n-    jcf_unexpected_eof (jcf, count);\n-  jcf->read_end += count;\n-  return 0;\n-}\n-\n-#include \"zipfile.h\"\n-\n-struct ZipFile *SeenZipFiles = NULL;\n-\n-/* Open a zip file with the given name, and cache directory and file\n-   descriptor.  If the file is missing, treat it as an empty archive.\n-   Return NULL if the .zip file is malformed.\n-*/\n-\n-ZipFile *\n-opendir_in_zip (const char *zipfile, int is_system)\n-{\n-  struct ZipFile* zipf;\n-  char magic [4];\n-  int fd;\n-  for (zipf = SeenZipFiles;  zipf != NULL;  zipf = zipf->next)\n-    {\n-      if (strcmp (zipf->name, zipfile) == 0)\n-\treturn zipf;\n-    }\n-\n-  zipf = XNEWVAR (struct ZipFile, sizeof (struct ZipFile) + strlen (zipfile) + 1);\n-  zipf->next = SeenZipFiles;\n-  zipf->name = (char*)(zipf+1);\n-  strcpy (zipf->name, zipfile);\n-  fd = open (zipfile, O_RDONLY | O_BINARY);\n-  zipf->fd = fd;\n-  if (fd < 0)\n-    {\n-      /* A missing zip file is not considered an error.\n-       We may want to re-consider that.  FIXME. */\n-      zipf->count = 0;\n-      zipf->dir_size = 0;\n-      zipf->central_directory = NULL;\n-    }\n-  else\n-    {\n-      jcf_dependency_add_file (zipfile, is_system);\n-      if (read (fd, magic, 4) != 4 || GET_u4 (magic) != (JCF_u4)ZIPMAGIC)\n-\t{\n-\t  free (zipf);\n-\t  close (fd);\n-\t  return NULL;\n-\t}\n-      lseek (fd, 0L, SEEK_SET);\n-      if (read_zip_archive (zipf) != 0)\n-\t{\n-\t  free (zipf);\n-\t  close (fd);\n-\t  return NULL;\n-\t}\n-    }\n-\n-  SeenZipFiles = zipf;  \n-  return zipf;\n-}\n-\n-/* Returns:\n-   0:  OK - zipmember found.\n-   -1: Not found.\n-   -2: Malformed archive.\n-*/\n-\n-int\n-open_in_zip (JCF *jcf, const char *zipfile, const char *zipmember,\n-\t     int is_system)\n-{\n-  ZipDirectory *zipd;\n-  int i, len;\n-  ZipFile *zipf = opendir_in_zip (zipfile, is_system);\n-\n-  if (zipf == NULL)\n-    return -2;\n-\n-  if (!zipmember)\n-    return 0;\n-\n-  len = strlen (zipmember);\n-  \n-  zipd = (struct ZipDirectory*) zipf->central_directory;\n-  for (i = 0; i < zipf->count; i++, zipd = ZIPDIR_NEXT (zipd))\n-    {\n-      if (len == zipd->filename_length &&\n-\t  strncmp (ZIPDIR_FILENAME (zipd), zipmember, len) == 0)\n-\t{\n-\t  JCF_ZERO (jcf);\n-\n-\t  jcf->filename = xstrdup (zipfile);\n-\t  jcf->classname = xstrdup (zipmember);\n-\t  return read_zip_member(jcf, zipd, zipf);\n-\t}\n-    }\n-  return -1;\n-}\n-\n-/* Read data from zip archive member. */\n-\n-int\n-read_zip_member (JCF *jcf,  ZipDirectory *zipd, ZipFile *zipf)\n-{\n-  jcf->filbuf = jcf_unexpected_eof;\n-  jcf->zipd = zipd;\n-\n-  if (zipd->compression_method == Z_NO_COMPRESSION)\n-    {\n-      jcf->buffer = XNEWVEC (unsigned char, zipd->size);\n-      jcf->buffer_end = jcf->buffer + zipd->size;\n-      jcf->read_ptr = jcf->buffer;\n-      jcf->read_end = jcf->buffer_end;\n-      if (lseek (zipf->fd, zipd->filestart, 0) < 0\n-\t  || read (zipf->fd, jcf->buffer, zipd->size) != (long) zipd->size)\n-\treturn -2;\n-    }\n-  else\n-    {\n-      char *buffer;\n-      z_stream d_stream; /* decompression stream */\n-      memset (&d_stream, 0, sizeof (d_stream));\n-\n-      jcf->buffer = XNEWVEC (unsigned char, zipd->uncompressed_size);\n-      d_stream.next_out = jcf->buffer;\n-      d_stream.avail_out = zipd->uncompressed_size;\n-      jcf->buffer_end = jcf->buffer + zipd->uncompressed_size;\n-      jcf->read_ptr = jcf->buffer;\n-      jcf->read_end = jcf->buffer_end;\n-      buffer = XNEWVEC (char, zipd->size);\n-      d_stream.next_in = (unsigned char *) buffer;\n-      d_stream.avail_in = zipd->size;\n-      if (lseek (zipf->fd, zipd->filestart, 0) < 0\n-\t  || read (zipf->fd, buffer, zipd->size) != (long) zipd->size)\n-\treturn -2;\n-      /* Handle NO_HEADER using undocumented zlib feature.\n-\t This is a very common hack.  */\n-      inflateInit2 (&d_stream, -MAX_WBITS);\n-      inflate (&d_stream, Z_NO_FLUSH);\n-      inflateEnd (&d_stream);\n-      free (buffer);\n-    }\n-\n-  return 0;\n-}\n-\n-const char *\n-open_class (const char *filename, JCF *jcf, int fd, const char *dep_name)\n-{\n-  if (jcf)\n-    {\n-      struct stat stat_buf;\n-      if (fstat (fd, &stat_buf) != 0\n-\t  || ! S_ISREG (stat_buf.st_mode))\n-\t{\n-\t  perror (\"Could not figure length of .class file\");\n-\t  return NULL;\n-\t}\n-      if (dep_name != NULL)\n-\tjcf_dependency_add_file (dep_name, 0);\n-      JCF_ZERO (jcf);\n-      jcf->buffer = XNEWVEC (unsigned char, stat_buf.st_size);\n-      jcf->buffer_end = jcf->buffer + stat_buf.st_size;\n-      jcf->read_ptr = jcf->buffer;\n-      jcf->read_end = jcf->buffer_end;\n-      jcf->read_state = NULL;\n-      jcf->filename = xstrdup (filename);\n-      if (read (fd, jcf->buffer, stat_buf.st_size) != stat_buf.st_size)\n-\t{\n-\t  perror (\"Failed to read .class file\");\n-\t  return NULL;\n-\t}\n-      close (fd);\n-      jcf->filbuf = jcf_unexpected_eof;\n-    }\n-  else\n-    close (fd);\n-  return filename;\n-}\n-\n-\n-const char *\n-find_classfile (char *filename, JCF *jcf, const char *dep_name)\n-{\n-  int fd = open (filename, O_RDONLY | O_BINARY);\n-  if (fd < 0)\n-    return NULL;\n-  return open_class (filename, jcf, fd, dep_name);\n-}\n-\n-/* A hash table keeping track of class names that were not found\n-   during class lookup.  (There is no need to cache the values\n-   associated with names that were found; they are saved in\n-   IDENTIFIER_CLASS_VALUE.)  */\n-static hash_table<nofree_string_hash> *memoized_class_lookups;\n-\n-/* Returns a freshly malloc'd string with the fully qualified pathname\n-   of the .class file for the class CLASSNAME.  CLASSNAME must be\n-   allocated in permanent storage; this function may retain a pointer\n-   to it.  Returns NULL on failure.  If JCF != NULL, it is suitably\n-   initialized.  SOURCE_OK is true if we should also look for .java\n-   file. */\n-\n-const char *\n-find_class (const char *classname, int classname_length, JCF *jcf)\n-{\n-  int fd;\n-  int i, k, klass = -1;\n-  struct stat class_buf;\n-  char *dep_file;\n-  void *entry;\n-  int buflen;\n-  char *buffer;\n-  hashval_t hash;\n-\n-  /* Create the hash table, if it does not already exist.  */\n-  if (!memoized_class_lookups)\n-    memoized_class_lookups = new hash_table<nofree_string_hash> (37);\n-\n-  /* Loop for this class in the hashtable.  If it is present, we've\n-     already looked for this class and failed to find it.  */\n-  hash = nofree_string_hash::hash (classname);\n-  if (memoized_class_lookups->find_with_hash (classname, hash))\n-    return NULL;\n-\n-  /* Allocate and zero out the buffer, since we don't explicitly put a\n-     null pointer when we're copying it below.  */\n-  buflen = jcf_path_max_len () + classname_length + 10;\n-  buffer = XNEWVAR (char, buflen);\n-  memset (buffer, 0, buflen);\n-\n-  for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))\n-    {\n-      const char *path_name = jcf_path_name (entry);\n-      if (klass != 0)\n-\t{\n-\t  int dir_len;\n-\n-\t  strcpy (buffer, path_name);\n-\t  i = strlen (buffer);\n-\n-\t  /* This is right because we know that `.zip' entries will have a\n-\t     trailing slash.  See jcf-path.c.  */\n-\t  dir_len = i - 1;\n-\n-\t  for (k = 0; k < classname_length; k++, i++)\n-\t    {\n-\t      char ch = classname[k];\n-\t      buffer[i] = ch == '.' ? '/' : ch;\n-\t    }\n-\t  strcpy (buffer+i, \".class\");\n-\n-\t  if (jcf_path_is_zipfile (entry))\n-\t    {\n-\t      int err_code;\n-\t      JCF _jcf;\n-\t      buffer[dir_len] = '\\0';\n-\t      SOURCE_FRONTEND_DEBUG \n-\t\t((\"Trying [...%s]:%s\", \n-\t\t  &buffer[dir_len-(dir_len > 15 ? 15 : dir_len)], \n-\t\t  buffer+dir_len+1));\n-\t      if (jcf == NULL)\n-\t\tjcf = &_jcf;\n-\t      err_code = open_in_zip (jcf, buffer, buffer+dir_len+1,\n-\t\t\t\t      jcf_path_is_system (entry));\n-\t      if (err_code == 0)\n-\t\t{\n-\t\t  /* Should we check if .zip is out-of-date wrt .java? */\n-\t\t  buffer[dir_len] = '(';\n-\t\t  strcpy (buffer+i, \".class)\");\n-\t\t  if (jcf == &_jcf)\n-\t\t    JCF_FINISH (jcf);\n-\t\t  return buffer;\n-\t\t}\n-\t      else\n-\t\tcontinue;\n-\t    }\n-\t  klass = stat (buffer, &class_buf);\n-\t}\n-    }\n-\n-  dep_file = buffer;\n-  if (!klass)\n-    {\n-      SOURCE_FRONTEND_DEBUG ((stderr, \"[Class selected: %s]\\n\",\n-\t\t\t      classname+classname_length-\n-\t\t\t      (classname_length <= 30 ? \n-\t\t\t       classname_length : 30)));\n-      fd = JCF_OPEN_EXACT_CASE (buffer, O_RDONLY | O_BINARY);\n-      if (fd >= 0)\n-\tgoto found;\n-    }\n-\n-  free (buffer);\n-\n-  /* Remember that this class could not be found so that we do not\n-     have to look again.  */\n-  *memoized_class_lookups->find_slot_with_hash (classname, hash, INSERT)\n-    = classname;\n-\n-  return NULL;\n- found:\n-  {\n-    const char *const tmp = open_class (buffer, jcf, fd, dep_file);\n-    jcf->classname = xstrdup (classname);\n-    return tmp;\n-  }\n-}\n-\n-void\n-jcf_print_char (FILE *stream, int ch)\n-{\n-  switch (ch)\n-    {\n-    case '\\'':\n-    case '\\\\':\n-    case '\\\"':\n-      fprintf (stream, \"\\\\%c\", ch);\n-      break;\n-    case '\\n':\n-      fprintf (stream, \"\\\\n\");\n-      break;\n-    case '\\t':\n-      fprintf (stream, \"\\\\t\");\n-      break;\n-    case '\\r':\n-      fprintf (stream, \"\\\\r\");\n-      break;\n-    default:\n-      if (ch >= ' ' && ch < 127)\n-\tputc (ch, stream);\n-      else if (ch < 256)\n-\tfprintf (stream, \"\\\\%03x\", ch);\n-      else\n-\tfprintf (stream, \"\\\\u%04x\", ch);\n-    }\n-}\n-\n-/* Print UTF8 string at STR of length LENGTH bytes to STREAM. */\n-\n-void\n-jcf_print_utf8 (FILE *stream, const unsigned char *str, int length)\n-{\n-  const unsigned char * limit = str + length;\n-  while (str < limit)\n-    {\n-      int ch = UTF8_GET (str, limit);\n-      if (ch < 0)\n-\t{\n-\t  fprintf (stream, \"\\\\<invalid>\");\n-\t  return;\n-\t}\n-      jcf_print_char (stream, ch);\n-    }\n-}\n-\n-/* Same as jcf_print_utf8, but print IN_CHAR as OUT_CHAR. */\n-\n-void\n-jcf_print_utf8_replace (FILE *stream, const unsigned char *str, int length,\n-\t\t\tint in_char, int out_char)\n-{\n-  const unsigned char *limit = str + length;\n-  while (str < limit)\n-    {\n-      int ch = UTF8_GET (str, limit);\n-      if (ch < 0)\n-\t{\n-\t  fprintf (stream, \"\\\\<invalid>\");\n-\t  return;\n-\t}\n-      jcf_print_char (stream, ch == in_char ? out_char : ch);\n-    }\n-}\n-\n-/* Check that all the cross-references in the constant pool are\n-   valid.  Returns 0 on success.\n-   Otherwise, returns the index of the (first) invalid entry.\n-   Only checks internal consistency, but does not check that\n-   any classes, fields, or methods are valid.*/\n-\n-int\n-verify_constant_pool (JCF *jcf)\n-{\n-  int i, n;\n-  for (i = 1; i < JPOOL_SIZE (jcf); i++)\n-    {\n-      switch (JPOOL_TAG (jcf, i))\n-\t{\n-\tcase CONSTANT_NameAndType:\n-\t  n = JPOOL_USHORT2 (jcf, i);\n-\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n-\t      || JPOOL_TAG (jcf, n) != CONSTANT_Utf8)\n-\t    return i;\n-\t  /* fall through */\n-\tcase CONSTANT_Class:\n-\tcase CONSTANT_String:\n-\t  n = JPOOL_USHORT1 (jcf, i);\n-\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n-\t      || JPOOL_TAG (jcf, n) != CONSTANT_Utf8)\n-\t    return i;\n-\t  break;\n-\tcase CONSTANT_Fieldref:\n-\tcase CONSTANT_Methodref:\n-\tcase CONSTANT_InterfaceMethodref:\n-\t  n = JPOOL_USHORT1 (jcf, i);\n-\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n-\t      || JPOOL_TAG (jcf, n) != CONSTANT_Class)\n-\t    return i;\n-\t  n = JPOOL_USHORT2 (jcf, i);\n-\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n-\t      || JPOOL_TAG (jcf, n) != CONSTANT_NameAndType)\n-\t    return i;\n-\t  break;\n-\tcase CONSTANT_Long:\n-\tcase CONSTANT_Double:\n-\t  i++;\n-\t  break;\n-\tcase CONSTANT_Float:\n-\tcase CONSTANT_Integer:\n-\tcase CONSTANT_Utf8:\n-\tcase CONSTANT_Unicode:\n-\t  break;\n-\tcase CONSTANT_MethodHandle:\n-\t  n = JPOOL_USHORT1 (jcf, i);\n-\t  if (n < 1 || n > 9)\n-\t    return i;\n-\t  n = JPOOL_USHORT2 (jcf, i);\n-\t  if (n <= 0 || n >= JPOOL_SIZE(jcf))\n-\t    return i;\n-\t  break;\n-\tcase CONSTANT_MethodType:\n-\t  n = JPOOL_USHORT1 (jcf, i);\n-\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n-\t      || JPOOL_TAG (jcf, n) != CONSTANT_Utf8)\n-\t    return i;\n-\t  break;\n-\tcase CONSTANT_InvokeDynamic:\n-\t  n = JPOOL_USHORT2 (jcf, i);\n-\t  if (n <= 0 || n >= JPOOL_SIZE(jcf)\n-\t      || JPOOL_TAG (jcf, n) != CONSTANT_NameAndType)\n-\t    return i;\n-\t  break;\n-\tdefault:\n-\t  return i;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-void\n-format_uint (char *buffer, uint64 value, int base)\n-{\n-#define WRITE_BUF_SIZE (4 + sizeof(uint64) * 8)\n-  char buf[WRITE_BUF_SIZE];\n-  char *buf_ptr = buf+WRITE_BUF_SIZE; /* End of buf. */\n-  int chars_written;\n-  int i;\n-\n-  /* Now do the actual conversion, placing the result at the *end* of buf. */\n-  /* Note this code does not pretend to be optimized. */\n-  do {\n-    int digit = value % base;\n-    static const char digit_chars[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n-    *--buf_ptr = digit_chars[digit];\n-    value /= base;\n-  } while (value != 0);\n-\n-  chars_written = buf+WRITE_BUF_SIZE - buf_ptr;\n-  for (i = 0; i < chars_written; i++)\n-    buffer[i] = *buf_ptr++;\n-  buffer[i] = 0;\n-}\n-\n-void\n-format_int (char *buffer, jlong value, int base)\n-{\n-  uint64 abs_value;\n-  if (value < 0)\n-    {\n-      abs_value = -(uint64)value;\n-      *buffer++ = '-';\n-    }\n-  else\n-    abs_value = (uint64) value;\n-  format_uint (buffer, abs_value, base);\n-}"}, {"sha": "ed3e32f9788411e63c38fb840f3e95127d36696d", "filename": "gcc/java/jcf-parse.c", "status": "removed", "additions": 0, "deletions": 2212, "changes": 2212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,2212 +0,0 @@\n-/* Parser for Java(TM) .class files.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Per Bothner <bothner@cygnus.com> */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"function.h\"\n-#include \"bitmap.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"diagnostic-core.h\"\n-#include \"javaop.h\"\n-#include \"java-tree.h\"\n-#include \"debug.h\"\n-#include \"toplev.h\"\n-\n-#ifdef HAVE_LOCALE_H\n-#include <locale.h>\n-#endif\n-\n-#ifdef HAVE_LANGINFO_CODESET\n-#include <langinfo.h>\n-#endif\n-\n-/* A CONSTANT_Utf8 element is converted to an IDENTIFIER_NODE at parse time. */\n-#define JPOOL_UTF(JCF, INDEX) CPOOL_UTF(&(JCF)->cpool, INDEX)\n-#define JPOOL_UTF_LENGTH(JCF, INDEX) IDENTIFIER_LENGTH (JPOOL_UTF (JCF, INDEX))\n-#define JPOOL_UTF_DATA(JCF, INDEX) \\\n-  ((const unsigned char *) IDENTIFIER_POINTER (JPOOL_UTF (JCF, INDEX)))\n-#define HANDLE_CONSTANT_Utf8(JCF, INDEX, LENGTH) \\\n-  do { \\\n-    unsigned char save;  unsigned char *text; \\\n-    JCF_FILL (JCF, (LENGTH)+1); /* Make sure we read 1 byte beyond string. */ \\\n-    text = (JCF)->read_ptr; \\\n-    save = text[LENGTH]; \\\n-    text[LENGTH] = 0; \\\n-    (JCF)->cpool.data[INDEX].t = get_identifier ((const char *) text); \\\n-    text[LENGTH] = save; \\\n-    JCF_SKIP (JCF, LENGTH); } while (0)\n-\n-#include \"jcf.h\"\n-\n-extern struct obstack temporary_obstack;\n-\n-static GTY(()) tree parse_roots[2];\n-\n-/* The FIELD_DECL for the current field.  */\n-#define current_field parse_roots[0]\n-\n-/* The METHOD_DECL for the current method.  */\n-#define current_method parse_roots[1]\n-\n-/* Line 0 in current file, if compiling from bytecode. */\n-static location_t file_start_location;\n-\n-/* The Java archive that provides main_class;  the main input file. */\n-static GTY(()) struct JCF * main_jcf;\n-\n-/* A list of all the class DECLs seen so far.  */\n-static GTY(()) vec<tree, va_gc> *all_class_list;\n-\n-/* The number of source files passed to us by -fsource-filename and an\n-   array of pointers to each name.  Used by find_sourcefile().  */\n-static int num_files = 0;\n-static char **filenames;\n-\n-static struct ZipFile *localToFile;\n-\n-/* A map of byte offsets in the reflection data that are fields which\n-   need renumbering.  */\n-bitmap field_offsets;\n-bitmap_obstack bit_obstack;\n-\n-/* Declarations of some functions used here.  */\n-static void handle_innerclass_attribute (int count, JCF *, int len);\n-static tree give_name_to_class (JCF *jcf, int index);\n-static char *compute_class_name (struct ZipDirectory *zdir);\n-static int classify_zip_file (struct ZipDirectory *zdir);\n-static void parse_zip_file_entries (void);\n-static void process_zip_dir (FILE *);\n-static void parse_class_file (void);\n-static void handle_deprecated (void);\n-static void set_source_filename (JCF *, int);\n-static void jcf_parse (struct JCF*);\n-static void load_inner_classes (tree);\n-static void handle_annotation (JCF *jcf, int level);\n-static void java_layout_seen_class_methods (void);\n-\n-/* Handle \"Deprecated\" attribute.  */\n-static void\n-handle_deprecated (void)\n-{\n-  if (current_field != NULL_TREE)\n-    FIELD_DEPRECATED (current_field) = 1;\n-  else if (current_method != NULL_TREE)\n-    METHOD_DEPRECATED (current_method) = 1;\n-  else if (current_class != NULL_TREE)\n-    CLASS_DEPRECATED (TYPE_NAME (current_class)) = 1;\n-  else\n-    {\n-      /* Shouldn't happen.  */\n-      gcc_unreachable ();\n-    }\n-}\n-\n-\f\n-\n-/* Reverse a string.  */\n-static char *\n-reverse (const char *s)\n-{\n-  if (s == NULL)\n-    return NULL;\n-  else\n-    {\n-      int len = strlen (s);\n-      char *d = XNEWVAR (char, len + 1);\n-      const char *sp;\n-      char *dp;\n-      \n-      d[len] = 0;\n-      for (dp = &d[0], sp = &s[len-1]; sp >= s; dp++, sp--)\n-\t*dp = *sp;\n-\n-      return d;\n-    }\n-}\n-\n-/* Compare two strings for qsort().  */\n-static int\n-cmpstringp (const void *p1, const void *p2)\n-{\n-  /* The arguments to this function are \"pointers to\n-     pointers to char\", but strcmp() arguments are \"pointers\n-     to char\", hence the following cast plus dereference */\n-\n-  return strcmp(*(const char *const*) p1, *(const char *const*) p2);\n-}\n-\n-/* Create an array of strings, one for each source file that we've\n-   seen.  fsource_filename can either be the name of a single .java\n-   file or a file that contains a list of filenames separated by\n-   newlines.  */\n-void \n-java_read_sourcefilenames (const char *fsource_filename)\n-{\n-  if (fsource_filename \n-      && filenames == 0\n-      && strlen (fsource_filename) > strlen (\".java\")\n-      && filename_cmp ((fsource_filename\n-\t\t       + strlen (fsource_filename)\n-\t\t       - strlen (\".java\")),\n-\t\t \".java\") != 0)\n-    {\n-/*       fsource_filename isn't a .java file but a list of filenames\n-       separated by newlines */\n-      FILE *finput = fopen (fsource_filename, \"r\");\n-      int len = 0;\n-      int longest_line = 0;\n-\n-      gcc_assert (finput);\n-\n-      /* Find out how many files there are, and how long the filenames are.  */\n-      while (! feof (finput))\n-\t{\n-\t  int ch = getc (finput);\n-\t  if (ch == '\\n')\n-\t    {\n-\t      num_files++;\n-\t      if (len > longest_line)\n-\t\tlongest_line = len;\n-\t      len = 0;\n-\t      continue;\n-\t    }\n-\t  if (ch == EOF)\n-\t    break;\n-\t  len++;\n-\t}\n-\n-      rewind (finput);\n-\n-      /* Read the filenames.  Put a pointer to each filename into the\n-\t array FILENAMES.  */\n-      {\n-\tchar *linebuf = (char *) alloca (longest_line + 1);\n-\tint i = 0;\n-\tint charpos;\n-\n-\tfilenames = XNEWVEC (char *, num_files);\n-\n-\tcharpos = 0;\n-\tfor (;;)\n-\t  {\n-\t    int ch = getc (finput);\n-\t    if (ch == EOF)\n-\t      break;\n-\t    if (ch == '\\n')\n-\t      {\n-\t\tlinebuf[charpos] = 0;\n-\t\tgcc_assert (i < num_files);\t\t\n-\t\t/* ???  Perhaps we should use lrealpath() here.  Doing\n-\t\t   so would tidy up things like /../ but the rest of\n-\t\t   gcc seems to assume relative pathnames, not\n-\t\t   absolute pathnames.  */\n-/* \t\trealname = lrealpath (linebuf); */\n-\t\tfilenames[i++] = reverse (linebuf);\n-\t\tcharpos = 0;\n-\t\tcontinue;\n-\t      }\n-\t    gcc_assert (charpos < longest_line);\n-\t    linebuf[charpos++] = ch;\n-\t  }\n-\n-\tif (num_files > 1)\n-\t  qsort (filenames, num_files, sizeof (char *), cmpstringp);\n-      }\n-      fclose (finput);\n-    }\n-  else\n-    {\n-      filenames = XNEWVEC (char *, 1);      \n-      filenames[0] = reverse (fsource_filename);\n-      num_files = 1;\n-    }\n-}\n-\n-/* Given a relative pathname such as foo/bar.java, attempt to find a\n-   longer pathname with the same suffix.  \n-\n-   This is a best guess heuristic; with some weird class hierarchies we\n-   may fail to pick the correct source file.  For example, if we have\n-   the filenames foo/bar.java and also foo/foo/bar.java, we do not\n-   have enough information to know which one is the right match for\n-   foo/bar.java.  */\n-\n-static const char *\n-find_sourcefile (const char *name)\n-{\n-  int i = 0, j = num_files-1;\n-  char *found = NULL;\n-  \n-  if (filenames)\n-    {\n-      char *revname = reverse (name);\n-\n-      do\n-\t{\n-\t  int k = (i+j) / 2;\n-\t  int cmp = strncmp (revname, filenames[k], strlen (revname));\n-\t  if (cmp == 0)\n-\t    {\n-\t      /*  OK, so we found one.  But is it a unique match?  */\n-\t      if ((k > i\n-\t\t   && strncmp (revname, filenames[k-1], strlen (revname)) == 0)\n-\t\t  || (k < j\n-\t\t      && (strncmp (revname, filenames[k+1], strlen (revname)) \n-\t\t\t  == 0)))\n-\t\t;\n-\t      else\n-\t\tfound = filenames[k];\n-\t      break;\n-\t    }\n-\t  if (cmp > 0)\n-\t    i = k+1;\n-\t  else\n-\t    j = k-1;\n-\t}\n-      while (i <= j);\n-\n-      free (revname);\n-    }\n-\n-  if (found && strlen (found) > strlen (name))\n-    return reverse (found);\n-  else\n-    return name;\n-}\n-\n-\f\n-\n-/* Handle \"SourceFile\" attribute. */\n-\n-static void\n-set_source_filename (JCF *jcf, int index)\n-{\n-  tree sfname_id = get_name_constant (jcf, index);\n-  const char *sfname = IDENTIFIER_POINTER (sfname_id);\n-  const char *old_filename = LOCATION_FILE (input_location);\n-  int new_len = IDENTIFIER_LENGTH (sfname_id);\n-  if (old_filename != NULL)\n-    {\n-      int old_len = strlen (old_filename);\n-      /* Use the filename from current input_location (derived from the\n-\t class name) if it has a directory prefix, but otherwise matches\n-\t sfname.  */\n-      if (old_len > new_len\n-\t  && filename_cmp (sfname, old_filename + old_len - new_len) == 0\n-\t  && (old_filename[old_len - new_len - 1] == '/'\n-\t      || old_filename[old_len - new_len - 1] == '\\\\'))\n-\treturn;\n-    }\n-  if (strchr (sfname, '/') == NULL && strchr (sfname, '\\\\') == NULL)\n-    {\n-      const char *class_name\n-\t= IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class)));\n-      const char *dot = strrchr (class_name, '.');\n-      if (dot != NULL)\n-\t{\n-\t  /* Length of prefix, not counting final dot. */\n-\t  int i = dot - class_name;\n-\t  /* Concatenate current package prefix with new sfname. */\n-\t  char *buf = XNEWVEC (char, i + new_len + 2); /* Space for '.' and '\\0'. */\n-\t  strcpy (buf + i + 1, sfname);\n-\t  /* Copy package from class_name, replacing '.' by DIR_SEPARATOR.\n-\t     Note we start at the end with the final package dot. */\n-\t  for (; i >= 0;  i--)\n-\t    {\n-\t      char c = class_name[i];\n-\t      if (c == '.')\n-\t\tc = DIR_SEPARATOR;\n-\t      buf[i] = c;\n-\t    }\n-\t  sfname_id = get_identifier (buf);\n-\t  free (buf);\n-\t  sfname = IDENTIFIER_POINTER (sfname_id);\n-\t}\n-    }\n-      \n-  sfname = find_sourcefile (sfname);\n-  LINEMAPS_LAST_ORDINARY_MAP (line_table)->to_file = sfname;\n-  if (current_class == main_class) main_input_filename = sfname;\n-}\n-\n-\n-\f\n-\n-/* Annotation handling.  \n-\n-   The technique we use here is to copy the annotation data directly\n-   from the input class file into the output file.  We don't decode the\n-   data at all, merely rewriting constant indexes whenever we come\n-   across them: this is necessary because the constant pool in the\n-   output file isn't the same as the constant pool in the input.\n-\n-   The main advantage of this technique is that the resulting\n-   annotation data is pointer-free, so it doesn't have to be relocated\n-   at startup time.  As a consequence of this, annotations have no\n-   performance impact unless they are used.  Also, this representation\n-   is very dense.  */\n-\n-\n-/* Expand TYPE_REFLECTION_DATA by DELTA bytes.  Return the address of\n-   the start of the newly allocated region.  */\n-\n-static unsigned char*\n-annotation_grow (int delta)\n-{\n-  unsigned char **data = &TYPE_REFLECTION_DATA (current_class);\n-  long *datasize = &TYPE_REFLECTION_DATASIZE (current_class);\n-  long len = *datasize;\n-\n-  if (*data == NULL)\n-    {\n-      *data = XNEWVAR (unsigned char, delta);\n-    }\n-  else\n-    {\n-      int newlen = *datasize + delta;\n-      if (floor_log2 (newlen) != floor_log2 (*datasize))\n-\t*data = XRESIZEVAR (unsigned char, *data,  2 << (floor_log2 (newlen)));\n-    }\n-  *datasize += delta;\n-  return *data + len;\n-}\n-\n-/* annotation_rewrite_TYPE.  Rewrite various int types at p.  Use Java\n-   byte order (i.e. big endian.)  */\n-\n-static void\n-annotation_rewrite_byte (unsigned int n, unsigned char *p)\n-{\n-  p[0] = n;\n-}\n-\n-static void\n-annotation_rewrite_short (unsigned int n, unsigned char *p)\n-{\n-  p[0] = n>>8;\n-  p[1] = n;\n-}\n-\n-static void\n-annotation_rewrite_int (unsigned int n, unsigned char *p)\n-{\n-  p[0] = n>>24;\n-  p[1] = n>>16;\n-  p[2] = n>>8;\n-  p[3] = n;\n-}\n-\n-/* Read a 16-bit unsigned int in Java byte order (i.e. big\n-   endian.)  */\n-\n-static uint16\n-annotation_read_short (unsigned char *p)\n-{\n-  uint16 tmp = p[0];\n-  tmp = (tmp << 8) | p[1];\n-  return tmp;\n-}\n-\n-/* annotation_write_TYPE.  Rewrite various int types, appending them\n-   to TYPE_REFLECTION_DATA.  Use Java byte order (i.e. big\n-   endian.)  */\n-\n-static void\n-annotation_write_byte (unsigned int n)\n-{\n-  annotation_rewrite_byte (n, annotation_grow (1));\n-}\n-\n-static void\n-annotation_write_short (unsigned int n)\n-{\n-  annotation_rewrite_short (n, annotation_grow (2));\n-}\n-\n-static void\n-annotation_write_int (unsigned int n)\n-{\n-  annotation_rewrite_int (n, annotation_grow (4));\n-}\n-\n-/* Create a 64-bit constant in the constant pool.\n-\n-   This is used for both integer and floating-point types.  As a\n-   consequence, it will not work if the target floating-point format\n-   is anything other than IEEE-754.  While this is arguably a bug, the\n-   runtime library makes exactly the same assumption and it's unlikely\n-   that Java will ever run on a non-IEEE machine.  */\n-\n-static int \n-handle_long_constant (JCF *jcf, CPool *cpool, enum cpool_tag kind,\n-\t\t    int index, bool big_endian)\n-{\n-  /* If we're on a 64-bit platform we can fit a long or double\n-     into the same space as a jword.  */\n-  if (POINTER_SIZE >= 64)\n-    index = find_constant1 (cpool, kind, JPOOL_LONG (jcf, index));\n-\n-  /* In a compiled program the constant pool is in native word\n-     order.  How weird is that???  */\n-  else if (big_endian)\n-    index = find_constant2 (cpool, kind,\n-\t\t\t    JPOOL_INT (jcf, index), \n-\t\t\t    JPOOL_INT (jcf, index+1));\n-  else\n-    index = find_constant2 (cpool, kind,\n-\t\t\t    JPOOL_INT (jcf, index+1), \n-\t\t\t    JPOOL_INT (jcf, index));\n-  \n-  return index;\n-}\n-\n-/* Given a class file and an index into its constant pool, create an\n-   entry in the outgoing constant pool for the same item.  */\n-\n-static uint16\n-handle_constant (JCF *jcf, int index, enum cpool_tag purpose)\n-{\n-  unsigned int kind;\n-  CPool *cpool = cpool_for_class (output_class);\n-  \n-  if (index == 0)\n-    return 0;\n-\n-  if (! CPOOL_INDEX_IN_RANGE (&jcf->cpool, index))\n-    error (\"<constant pool index %d not in range>\", index);\n-  \n-  kind = JPOOL_TAG (jcf, index);\n-\n-  if ((kind & ~CONSTANT_ResolvedFlag) != purpose)\n-    {\n-      if (purpose == CONSTANT_Class\n-\t  && kind == CONSTANT_Utf8)\n-\t;\n-      else\n-\terror (\"<constant pool index %d unexpected type\", index);\n-    }\n-\n-  switch (kind)\n-    {\n-    case CONSTANT_Class:\n-    case CONSTANT_ResolvedClass:\n-      {\n-\t/* For some reason I know not the what of, class names in\n-\t   annotations are UTF-8 strings in the constant pool but\n-\t   class names in EnclosingMethod attributes are real class\n-\t   references.  Set CONSTANT_LazyFlag here so that the VM\n-\t   doesn't attempt to resolve them at class initialization\n-\t   time.  */\n-\ttree resolved_class, class_name;\n-\tresolved_class = get_class_constant (jcf, index);\n-\tclass_name = build_internal_class_name (resolved_class);\n-\tindex = alloc_name_constant (CONSTANT_Class | CONSTANT_LazyFlag,\n-\t\t\t\t     (unmangle_classname \n-\t\t\t\t      (IDENTIFIER_POINTER(class_name),\n-\t\t\t\t       IDENTIFIER_LENGTH(class_name))));\n-\tbreak;\n-      }\n-    case CONSTANT_Utf8:\n-      {\n-\ttree utf8 = get_constant (jcf, index);\n-\tif (purpose == CONSTANT_Class)\n-\t  /* Create a constant pool entry for a type signature.  This\n-\t     one has '.' rather than '/' because it isn't going into a\n-\t     class file, it's going into a compiled object.\n-\t     \n-\t     This has to match the logic in\n-\t     _Jv_ClassReader::prepare_pool_entry().  */\n-\t  utf8 = unmangle_classname (IDENTIFIER_POINTER(utf8),\n-\t\t\t\t     IDENTIFIER_LENGTH(utf8));\n-\tindex = alloc_name_constant (kind, utf8);\n-      }\n-      break;\n-\n-    case CONSTANT_Long:\n-      index = handle_long_constant (jcf, cpool, CONSTANT_Long, index,\n-\t\t\t\t    targetm.words_big_endian ());\n-      break;\n-      \n-    case CONSTANT_Double:\n-      index = handle_long_constant (jcf, cpool, CONSTANT_Double, index,\n-\t\t\t\t    targetm.float_words_big_endian ());\n-      break;\n-\n-    case CONSTANT_Float:\n-    case CONSTANT_Integer:\n-      index = find_constant1 (cpool, kind, JPOOL_INT (jcf, index));\n-      break;\n-      \n-    case CONSTANT_NameAndType:\n-      {\n-\tuint16 name = JPOOL_USHORT1 (jcf, index);\n-\tuint16 sig = JPOOL_USHORT2 (jcf, index);\n-\tuint32 name_index = handle_constant (jcf, name, CONSTANT_Utf8);\n-\tuint32 sig_index = handle_constant (jcf, sig, CONSTANT_Class);\n-\tjword new_index = (name_index << 16) | sig_index;\n-\tindex = find_constant1 (cpool, kind, new_index);\n-      }\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-  \n-  return index;\n-}\n-\n-/* Read an element_value structure from an annotation in JCF.  Return\n-   the constant pool index for the resulting constant pool entry.  */\n-\n-static int\n-handle_element_value (JCF *jcf, int level)\n-{\n-  uint8 tag = JCF_readu (jcf);\n-  int index = 0;\n-\n-  annotation_write_byte (tag);\n-  switch (tag)\n-    {\n-    case 'B':\n-    case 'C':\n-    case 'S':\n-    case 'Z':\n-    case 'I':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tindex = handle_constant (jcf, cindex,\n-\t\t\t\t CONSTANT_Integer);\n-\tannotation_write_short (index);\n-      }\n-      break;\n-    case 'D':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tindex = handle_constant (jcf, cindex,\n-\t\t\t\t CONSTANT_Double);\n-\tannotation_write_short (index);\n-      }\n-      break;\n-    case 'F':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tindex = handle_constant (jcf, cindex,\n-\t\t\t\t CONSTANT_Float);\n-\tannotation_write_short (index);\n-      }\n-      break;\n-    case 'J':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\tindex = handle_constant (jcf, cindex,\n-\t\t\t\t CONSTANT_Long);\n-\tannotation_write_short (index);\n-      }\n-      break;\n-    case 's':\n-      {\n-\tuint16 cindex = JCF_readu2 (jcf);\n-\t/* Despite what the JVM spec says, compilers generate a Utf8\n-\t   constant here, not a String.  */\n-\tindex = handle_constant (jcf, cindex,\n-\t\t\t\t CONSTANT_Utf8);\n-\tannotation_write_short (index);\n-      }\n-      break;\n-\n-    case 'e':\n-      {\n-\tuint16 type_name_index = JCF_readu2 (jcf);\n-\tuint16 const_name_index = JCF_readu2 (jcf);\n-\tindex = handle_constant (jcf, type_name_index,\n-\t\t\t\t CONSTANT_Class);\n-\tannotation_write_short (index);\n-\tindex = handle_constant (jcf, const_name_index,\n-\t\t\t\t CONSTANT_Utf8);\n-\tannotation_write_short (index);\n-     }\n-      break;\n-    case 'c':\n-      {\n-\tuint16 class_info_index = JCF_readu2 (jcf);\n-\tindex = handle_constant (jcf, class_info_index,\n-\t\t\t\t CONSTANT_Class);\n-\tannotation_write_short (index);\n-      }\n-      break;\n-    case '@':\n-      {\n-\thandle_annotation (jcf, level + 1);\n-      }\n-      break;\n-    case '[':\n-      {\n-\tuint16 n_array_elts = JCF_readu2 (jcf);\n-\tannotation_write_short (n_array_elts);\n-\twhile (n_array_elts--)\n-\t  handle_element_value (jcf, level + 1);\n-      }\n-      break;\n-    default:\n-      abort();\n-      break;\n-    }\n-  return index;\n-}\n-\n-/* Read an annotation structure from JCF.  Write it to the\n-   reflection_data field of the outgoing class.  */\n-\n-static void\n-handle_annotation (JCF *jcf, int level)\n-{\n-  uint16 type_index = JCF_readu2 (jcf);\n-  uint16 npairs = JCF_readu2 (jcf);\n-  int index = handle_constant (jcf, type_index,\n-\t\t\t       CONSTANT_Class);\n-  annotation_write_short (index);\n-  annotation_write_short (npairs);\n-  while (npairs--)\n-    {\n-      uint16 name_index = JCF_readu2 (jcf);\n-      index = handle_constant (jcf, name_index,\n-\t\t\t       CONSTANT_Utf8);\n-      annotation_write_short (index);\n-      handle_element_value (jcf, level + 2);\n-    }\n-}\n-\n-/* Read an annotation count from JCF, and write the following\n-   annotations to the reflection_data field of the outgoing class.  */\n-\n-static void\n-handle_annotations (JCF *jcf, int level)\n-{\n-  uint16 num = JCF_readu2 (jcf);\n-  annotation_write_short (num);\n-  while (num--)\n-    handle_annotation (jcf, level);\n-}\n-\n-/* As handle_annotations(), but perform a sanity check that we write\n-   the same number of bytes that we were expecting.  */\n-\n-static void\n-handle_annotation_attribute (int ATTRIBUTE_UNUSED index, JCF *jcf, \n-\t\t\t     long length)\n-{\n-  long old_datasize = TYPE_REFLECTION_DATASIZE (current_class);\n-\n-  handle_annotations (jcf, 0);\n-\n-  gcc_assert (old_datasize + length\n-\t      == TYPE_REFLECTION_DATASIZE (current_class));\n-}\n-\n-/* gcj permutes its fields array after generating annotation_data, so\n-   we have to fixup field indexes for fields that have moved.  Given\n-   ARG, a VEC_int, fixup the field indexes in the reflection_data of\n-   the outgoing class.  We use field_offsets to tell us where the\n-   fixups must go.  */\n-\n-void\n-rewrite_reflection_indexes (void *arg)\n-{\n-  bitmap_iterator bi;\n-  unsigned int offset;\n-  vec<int> *map = (vec<int> *) arg;\n-  unsigned char *data = TYPE_REFLECTION_DATA (current_class);\n-\n-  if (map)\n-    {\n-      EXECUTE_IF_SET_IN_BITMAP (field_offsets, 0, offset, bi)\n-\t{\n-\t  uint16 index = annotation_read_short (data + offset);\n-\t  annotation_rewrite_short \n-\t    ((*map)[index], data + offset);\n-\t}\n-    }\n-}\n-\n-/* Read the RuntimeVisibleAnnotations from JCF and write them to the\n-   reflection_data of the outgoing class.  */\n-\n-static void\n-handle_member_annotations (int member_index, JCF *jcf, \n-\t\t\t   const unsigned char *name ATTRIBUTE_UNUSED, \n-\t\t\t   long len, jv_attr_type member_type)\n-{\n-  int new_len = len + 1;\n-  annotation_write_byte (member_type);\n-  if (member_type != JV_CLASS_ATTR)\n-    new_len += 2;\n-  annotation_write_int (new_len);\n-  annotation_write_byte (JV_ANNOTATIONS_KIND);\n-  if (member_type == JV_FIELD_ATTR)\n-    bitmap_set_bit (field_offsets, TYPE_REFLECTION_DATASIZE (current_class));\n-  if (member_type != JV_CLASS_ATTR)\n-    annotation_write_short (member_index);\n-  handle_annotation_attribute (member_index, jcf, len);\n-}\n-\n-/* Read the RuntimeVisibleParameterAnnotations from JCF and write them\n-   to the reflection_data of the outgoing class.  */\n-\n-static void\n-handle_parameter_annotations (int member_index, JCF *jcf, \n-\t\t\t      const unsigned char *name ATTRIBUTE_UNUSED, \n-\t\t\t      long len, jv_attr_type member_type)\n-{\n-  int new_len = len + 1;\n-  uint8 num;\n-  annotation_write_byte (member_type);\n-  if (member_type != JV_CLASS_ATTR)\n-    new_len += 2;\n-  annotation_write_int (new_len);\n-  annotation_write_byte (JV_PARAMETER_ANNOTATIONS_KIND);\n-  if (member_type != JV_CLASS_ATTR)\n-    annotation_write_short (member_index);\n-  num = JCF_readu (jcf);\n-  annotation_write_byte (num);\n-  while (num--)\n-    handle_annotations (jcf, 0);\n-}\n-\n-\n-/* Read the AnnotationDefault data from JCF and write them to the\n-   reflection_data of the outgoing class.  */\n-\n-static void\n-handle_default_annotation (int member_index, JCF *jcf, \n-\t\t\t   const unsigned char *name ATTRIBUTE_UNUSED, \n-\t\t\t   long len, jv_attr_type member_type)\n-{\n-  int new_len = len + 1;\n-  annotation_write_byte (member_type);\n-  if (member_type != JV_CLASS_ATTR)\n-    new_len += 2;\n-  annotation_write_int (new_len);\n-  annotation_write_byte (JV_ANNOTATION_DEFAULT_KIND);\n-  if (member_type != JV_CLASS_ATTR)\n-    annotation_write_short (member_index);\n-  handle_element_value (jcf, 0);\n-}\n-\n-/* As above, for the EnclosingMethod attribute.  */\n-\n-static void\n-handle_enclosingmethod_attribute (int member_index, JCF *jcf, \n-\t\t\t   const unsigned char *name ATTRIBUTE_UNUSED, \n-\t\t\t   long len, jv_attr_type member_type)\n-{\n-  int new_len = len + 1;\n-  uint16 index;\n-  annotation_write_byte (member_type);\n-  if (member_type != JV_CLASS_ATTR)\n-    new_len += 2;\n-  annotation_write_int (new_len);\n-  annotation_write_byte (JV_ENCLOSING_METHOD_KIND);\n-  if (member_type != JV_CLASS_ATTR)\n-    annotation_write_short (member_index);\n-\n-  index = JCF_readu2 (jcf);\n-  index = handle_constant (jcf, index, CONSTANT_Class);\n-  annotation_write_short (index);\n-\n-  index = JCF_readu2 (jcf);\n-  index = handle_constant (jcf, index, CONSTANT_NameAndType);\n-  annotation_write_short (index);\n-}\n-\n-/* As above, for the Signature attribute.  */\n-\n-static void\n-handle_signature_attribute (int member_index, JCF *jcf, \n-\t\t\t   const unsigned char *name ATTRIBUTE_UNUSED, \n-\t\t\t   long len, jv_attr_type member_type)\n-{\n-  int new_len = len + 1;\n-  uint16 index;\n-  annotation_write_byte (member_type);\n-  if (member_type != JV_CLASS_ATTR)\n-    new_len += 2;\n-  annotation_write_int (new_len);\n-  annotation_write_byte (JV_SIGNATURE_KIND);\n-  if (member_type != JV_CLASS_ATTR)\n-    annotation_write_short (member_index);\n-\n-  index = JCF_readu2 (jcf);\n-  index = handle_constant (jcf, index, CONSTANT_Utf8);\n-  annotation_write_short (index);\n-}\n-  \n-\f\n-\n-#define HANDLE_SOURCEFILE(INDEX) set_source_filename (jcf, INDEX)\n-\n-#define HANDLE_CLASS_INFO(ACCESS_FLAGS, THIS, SUPER, INTERFACES_COUNT) \\\n-{ tree super_class = SUPER==0 ? NULL_TREE : get_class_constant (jcf, SUPER); \\\n-  output_class = current_class = give_name_to_class (jcf, THIS); \\\n-  set_super_info (ACCESS_FLAGS, current_class, super_class, INTERFACES_COUNT);}\n-\n-#define HANDLE_CLASS_INTERFACE(INDEX) \\\n-  add_interface (current_class, get_class_constant (jcf, INDEX))\n-\n-#define HANDLE_START_FIELD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n-{ int sig_index = SIGNATURE; \\\n-  current_field = add_field (current_class, get_name_constant (jcf, NAME), \\\n-\t\t\t     parse_signature (jcf, sig_index), ACCESS_FLAGS); \\\n- set_java_signature (TREE_TYPE (current_field), JPOOL_UTF (jcf, sig_index)); \\\n- if ((ACCESS_FLAGS) & ACC_FINAL) \\\n-   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (current_field); \\\n-}\n-\n-#define HANDLE_END_FIELDS() \\\n-  (current_field = NULL_TREE)\n-\n-#define HANDLE_CONSTANTVALUE(INDEX) \\\n-{ tree constant;  int index = INDEX; \\\n-  if (JPOOL_TAG (jcf, index) == CONSTANT_String) { \\\n-    tree name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index)); \\\n-    constant = build_utf8_ref (name); \\\n-  } \\\n-  else \\\n-    constant = get_constant (jcf, index); \\\n-  set_constant_value (current_field, constant); }\n-\n-#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT) \\\n- (current_method = add_method (current_class, ACCESS_FLAGS, \\\n-\t\t\t       get_name_constant (jcf, NAME), \\\n-\t\t\t       get_name_constant (jcf, SIGNATURE)), \\\n-  DECL_LOCALVARIABLES_OFFSET (current_method) = 0, \\\n-  DECL_LINENUMBERS_OFFSET (current_method) = 0)\n-\n-#define HANDLE_END_METHODS() \\\n-{ current_method = NULL_TREE; }\n-\n-#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \\\n-{ DECL_MAX_STACK (current_method) = (MAX_STACK); \\\n-  DECL_MAX_LOCALS (current_method) = (MAX_LOCALS); \\\n-  DECL_CODE_LENGTH (current_method) = (CODE_LENGTH); \\\n-  DECL_CODE_OFFSET (current_method) = JCF_TELL (jcf); }\n-\n-#define HANDLE_LOCALVARIABLETABLE_ATTRIBUTE(COUNT) \\\n-{ int n = (COUNT); \\\n-  DECL_LOCALVARIABLES_OFFSET (current_method) = JCF_TELL (jcf) - 2; \\\n-  JCF_SKIP (jcf, n * 10); }\n-\n-#define HANDLE_LINENUMBERTABLE_ATTRIBUTE(COUNT) \\\n-{ int n = (COUNT); \\\n-  DECL_LINENUMBERS_OFFSET (current_method) = JCF_TELL (jcf) - 2; \\\n-  JCF_SKIP (jcf, n * 4); }\n-\n-#define HANDLE_EXCEPTIONS_ATTRIBUTE(COUNT) \\\n-{ \\\n-  int n = COUNT; \\\n-  vec<tree, va_gc> *v; \\\n-  vec_alloc (v, n); \\\n-  gcc_assert (!DECL_FUNCTION_THROWS (current_method)); \\\n-  while (--n >= 0) \\\n-    { \\\n-      tree thrown_class = get_class_constant (jcf, JCF_readu2 (jcf)); \\\n-      v->quick_push (thrown_class); \\\n-    } \\\n-  DECL_FUNCTION_THROWS (current_method) = v; \\\n-}\n-\n-#define HANDLE_DEPRECATED_ATTRIBUTE()  handle_deprecated ()\n-\n-/* Link seen inner classes to their outer context and register the\n-   inner class to its outer context. They will be later loaded.  */\n-#define HANDLE_INNERCLASSES_ATTRIBUTE(COUNT) \\\n-  handle_innerclass_attribute (COUNT, jcf, attribute_length)\n-\n-#define HANDLE_SYNTHETIC_ATTRIBUTE()\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* Irrelevant decls should have been nullified by the END macros.\t\\\n-     DECL_ARTIFICIAL on fields is used for something else (See\t\t\\\n-     PUSH_FIELD in java-tree.h) */\t\t\t\t\t\\\n-  if (current_method)\t\t\t\t\t\t\t\\\n-    DECL_ARTIFICIAL (current_method) = 1;\t\t\t\t\\\n-  else if (current_field)\t\t\t\t\t\t\\\n-    FIELD_SYNTHETIC (current_field) = 1;\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    TYPE_SYNTHETIC (current_class) = 1;\t\t\t\t\t\\\n-}\n-\n-#define HANDLE_GCJCOMPILED_ATTRIBUTE()\t\t\\\n-{ \t\t\t\t\t\t\\\n-  if (current_class == object_type_node)\t\\\n-    jcf->right_zip = 1;\t\t\t\t\\\n-}\n-\n-#define HANDLE_RUNTIMEVISIBLEANNOTATIONS_ATTRIBUTE()\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  handle_member_annotations (index, jcf, name_data, attribute_length, attr_type); \\\n-}\n-\n-#define HANDLE_RUNTIMEINVISIBLEANNOTATIONS_ATTRIBUTE()\t\\\n-{\t\t\t\t\t\t\t\\\n-  JCF_SKIP(jcf, attribute_length);\t\t\t\\\n-}\n-\n-#define HANDLE_RUNTIMEVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE()\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  handle_parameter_annotations (index, jcf, name_data, attribute_length, attr_type); \\\n-}\n-\n-#define HANDLE_RUNTIMEINVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE()\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  JCF_SKIP(jcf, attribute_length);\t\t\t\t\\\n-}\n-\n-#define HANDLE_ANNOTATIONDEFAULT_ATTRIBUTE()\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  handle_default_annotation (index, jcf, name_data, attribute_length, attr_type); \\\n-}\n-\n-#define HANDLE_ENCLOSINGMETHOD_ATTRIBUTE()\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  handle_enclosingmethod_attribute (index, jcf, name_data,\t\t\\\n-\t\t\t\t    attribute_length, attr_type);\t\\\n-}\n-\n-#define HANDLE_SIGNATURE_ATTRIBUTE()\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  handle_signature_attribute (index, jcf, name_data,\t\t\\\n-\t\t\t      attribute_length, attr_type);\t\\\n-}\n-\n-#include \"jcf-reader.c\"\n-\n-tree\n-parse_signature (JCF *jcf, int sig_index)\n-{\n-  gcc_assert (sig_index > 0\n-\t      && sig_index < JPOOL_SIZE (jcf)\n-\t      && JPOOL_TAG (jcf, sig_index) == CONSTANT_Utf8);\n-\n-  return parse_signature_string (JPOOL_UTF_DATA (jcf, sig_index),\n-\t\t\t\t JPOOL_UTF_LENGTH (jcf, sig_index));\n-}\n-\n-tree\n-get_constant (JCF *jcf, int index)\n-{\n-  tree value;\n-  int tag;\n-  if (index <= 0 || index >= JPOOL_SIZE(jcf))\n-    goto bad;\n-  tag = JPOOL_TAG (jcf, index);\n-  if ((tag & CONSTANT_ResolvedFlag) || tag == CONSTANT_Utf8)\n-    return jcf->cpool.data[index].t;\n-  switch (tag)\n-    {\n-    case CONSTANT_Integer:\n-      {\n-\tjint num = JPOOL_INT(jcf, index);\n-\tvalue = build_int_cst (int_type_node, num);\n-\tbreak;\n-      }\n-    case CONSTANT_Long:\n-      {\n-\tunsigned HOST_WIDE_INT num;\n-\n-\tnum = JPOOL_UINT (jcf, index);\n-\twide_int val = wi::lshift (wide_int::from (num, 64, SIGNED), 32);\n-\tnum = JPOOL_UINT (jcf, index + 1);\n-\tval |= num;\n-\n-\tvalue = wide_int_to_tree (long_type_node, val);\n-\tbreak;\n-      }\n-\n-    case CONSTANT_Float:\n-      {\n-\tjint num = JPOOL_INT(jcf, index);\n-\tlong buf = num;\n-\tREAL_VALUE_TYPE d;\n-\n-\treal_from_target (&d, &buf, &ieee_single_format);\n-\tvalue = build_real (float_type_node, d);\n-\tbreak;\n-      }\n-\n-    case CONSTANT_Double:\n-      {\n-\tlong buf[2], lo, hi;\n-\tREAL_VALUE_TYPE d;\n-\n-\thi = JPOOL_UINT (jcf, index);\n-\tlo = JPOOL_UINT (jcf, index+1);\n-\n-\tif (targetm.float_words_big_endian ())\n-\t  buf[0] = hi, buf[1] = lo;\n-\telse\n-\t  buf[0] = lo, buf[1] = hi;\n-\n-\treal_from_target (&d, buf, &ieee_double_format);\n-\tvalue = build_real (double_type_node, d);\n-\tbreak;\n-      }\n-\n-    case CONSTANT_String:\n-      {\n-\ttree name = get_name_constant (jcf, JPOOL_USHORT1 (jcf, index));\n-\tconst char *utf8_ptr = IDENTIFIER_POINTER (name);\n-\tint utf8_len = IDENTIFIER_LENGTH (name);\n-\tconst unsigned char *utf8;\n-\tint i;\n-\n-\t/* Check for a malformed Utf8 string.  */\n-\tutf8 = (const unsigned char *) utf8_ptr;\n-\ti = utf8_len;\n-\twhile (i > 0)\n-\t  {\n-\t    int char_len = UT8_CHAR_LENGTH (*utf8);\n-\t    if (char_len < 0 || char_len > 3 || char_len > i)\n- \t      fatal_error (input_location, \"bad string constant\");\n-\n-\t    utf8 += char_len;\n-\t    i -= char_len;\n-\t  }\n-\n-\t/* Allocate a new string value.  */\n-\tvalue = build_string (utf8_len, utf8_ptr);\n-\tTREE_TYPE (value) = build_pointer_type (string_type_node);\n-      }\n-      break;\n-    default:\n-      goto bad;\n-    }\n-  JPOOL_TAG (jcf, index) = tag | CONSTANT_ResolvedFlag;\n-  jcf->cpool.data[index].t = value;\n-  return value;\n- bad:\n-  fatal_error (input_location, \"bad value constant type %d, index %d\", \n-\t       JPOOL_TAG (jcf, index), index);\n-}\n-\n-tree\n-get_name_constant (JCF *jcf, int index)\n-{\n-  tree name = get_constant (jcf, index);\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n-  return name;\n-}\n-\n-/* Handle reading innerclass attributes. If a nonzero entry (denoting\n-   a non anonymous entry) is found, We augment the inner class list of\n-   the outer context with the newly resolved innerclass.  */\n-\n-static void\n-handle_innerclass_attribute (int count, JCF *jcf, int attribute_length)\n-{\n-  int c = count;\n-\n-  annotation_write_byte (JV_CLASS_ATTR);\n-  annotation_write_int (attribute_length+1);\n-  annotation_write_byte (JV_INNER_CLASSES_KIND);\n-  annotation_write_short (count);\n-\n-  while (c--)\n-    {\n-      /* Read inner_class_info_index. This may be 0 */\n-      int icii = JCF_readu2 (jcf);\n-      /* Read outer_class_info_index. If the innerclasses attribute\n-\t entry isn't a member (like an inner class) the value is 0. */\n-      int ocii = JCF_readu2 (jcf);\n-      /* Read inner_name_index. If the class we're dealing with is\n-\t an anonymous class, it must be 0. */\n-      int ini = JCF_readu2 (jcf);\n-      /* Read the access flag. */\n-      int acc = JCF_readu2 (jcf);\n-\n-      annotation_write_short (handle_constant (jcf, icii, CONSTANT_Class));\n-      annotation_write_short (handle_constant (jcf, ocii, CONSTANT_Class));\n-      annotation_write_short (handle_constant (jcf, ini, CONSTANT_Utf8));\n-      annotation_write_short (acc);\n-\n-      /* If icii is 0, don't try to read the class. */\n-      if (icii >= 0)\n-\t{\n-\t  tree klass = get_class_constant (jcf, icii);\n-\t  tree decl = TYPE_NAME (klass);\n-          /* Skip reading further if ocii is null */\n-          if (DECL_P (decl) && !CLASS_COMPLETE_P (decl) && ocii)\n-\t    {\n-\t      tree outer = TYPE_NAME (get_class_constant (jcf, ocii));\n-\t      tree alias = (ini ? get_name_constant (jcf, ini) : NULL_TREE);\n-\t      set_class_decl_access_flags (acc, decl);\n-\t      DECL_CONTEXT (decl) = outer;\n-\t      DECL_INNER_CLASS_LIST (outer) =\n-\t\ttree_cons (decl, alias, DECL_INNER_CLASS_LIST (outer));\n-\t      CLASS_COMPLETE_P (decl) = 1;\n-            }\n-\t}\n-    }\n-}\n-\n-static tree\n-give_name_to_class (JCF *jcf, int i)\n-{\n-  gcc_assert (i > 0\n-\t      && i < JPOOL_SIZE (jcf)\n-\t      && JPOOL_TAG (jcf, i) == CONSTANT_Class);\n-\n-    {\n-      tree package_name = NULL_TREE, tmp;\n-      tree this_class;\n-      int j = JPOOL_USHORT1 (jcf, i);\n-      /* verify_constant_pool confirmed that j is a CONSTANT_Utf8. */\n-      tree class_name = unmangle_classname ((const char *) JPOOL_UTF_DATA (jcf, j),\n-\t\t\t\t\t    JPOOL_UTF_LENGTH (jcf, j));\n-      this_class = lookup_class (class_name);\n-      {\n-      tree source_name = identifier_subst (class_name, \"\", '.', '/', \".java\");\n-      const char *sfname = find_sourcefile (IDENTIFIER_POINTER (source_name));\n-      linemap_add (line_table, LC_ENTER, false, sfname, 0);\n-      input_location = linemap_line_start (line_table, 0, 1);\n-      file_start_location = input_location;\n-      DECL_SOURCE_LOCATION (TYPE_NAME (this_class)) = input_location;\n-      if (main_input_filename == NULL && jcf == main_jcf)\n-\tmain_input_filename = sfname;\n-      }\n-\n-      jcf->cpool.data[i].t = this_class;\n-      JPOOL_TAG (jcf, i) = CONSTANT_ResolvedClass;\n-      split_qualified_name (&package_name, &tmp, \n-      \t\t\t    DECL_NAME (TYPE_NAME (this_class)));\n-      TYPE_PACKAGE (this_class) = package_name;\n-      return this_class;\n-    }\n-}\n-\n-/* Get the class of the CONSTANT_Class whose constant pool index is I. */\n-\n-tree\n-get_class_constant (JCF *jcf, int i)\n-{\n-  tree type;\n-  gcc_assert (i > 0\n-\t      && i < JPOOL_SIZE (jcf)\n-\t      && (JPOOL_TAG (jcf, i) & ~CONSTANT_ResolvedFlag) == CONSTANT_Class);\n-\n-  if (JPOOL_TAG (jcf, i) != CONSTANT_ResolvedClass)\n-    {\n-      int name_index = JPOOL_USHORT1 (jcf, i);\n-      /* verify_constant_pool confirmed that name_index is a CONSTANT_Utf8. */\n-      const char *name = (const char *) JPOOL_UTF_DATA (jcf, name_index);\n-      int nlength = JPOOL_UTF_LENGTH (jcf, name_index);\n-\n-      if (name[0] == '[')  /* Handle array \"classes\". */\n-\t  type = TREE_TYPE (parse_signature_string ((const unsigned char *) name, nlength));\n-      else\n-        { \n-          tree cname = unmangle_classname (name, nlength);\n-          type = lookup_class (cname);\n-\t}\n-      jcf->cpool.data[i].t = type;\n-      JPOOL_TAG (jcf, i) = CONSTANT_ResolvedClass;\n-    }\n-  else\n-    type = jcf->cpool.data[i].t;\n-  return type;\n-}\n-\n-/* Read a class with the fully qualified-name NAME.\n-   Return 1 iff we read the requested file.\n-   (It is still possible we failed if the file did not\n-   define the class it is supposed to.) */\n-\n-int\n-read_class (tree name)\n-{\n-  JCF this_jcf, *jcf;\n-  tree icv, klass = NULL_TREE;\n-  tree save_current_class = current_class;\n-  tree save_output_class = output_class;\n-  location_t save_location = input_location;\n-  JCF *save_current_jcf = current_jcf;\n-\n-  if ((icv = IDENTIFIER_CLASS_VALUE (name)) != NULL_TREE)\n-    {\n-      klass = TREE_TYPE (icv);\n-      jcf = TYPE_JCF (klass);\n-    }\n-  else\n-    jcf = NULL;\n-\n-  if (jcf == NULL)\n-    {\n-      const char* path_name;\n-      this_jcf.zipd = NULL;\n-      jcf = &this_jcf;\n-      \n-      path_name = find_class (IDENTIFIER_POINTER (name),\n-\t\t\t      IDENTIFIER_LENGTH (name),\n-\t\t\t      &this_jcf);\n-      if (path_name == 0)\n-\treturn 0;\n-      else\n-\tfree(CONST_CAST (char *, path_name));\n-    }\n-\n-  current_jcf = jcf;\n-\n-  if (klass == NULL_TREE || ! CLASS_PARSED_P (klass))\n-    {\n-      output_class = current_class = klass;\n-      if (JCF_SEEN_IN_ZIP (current_jcf))\n-\tread_zip_member(current_jcf,\n-\t\t\tcurrent_jcf->zipd, current_jcf->zipd->zipf);\n-      jcf_parse (current_jcf);\n-      /* Parsing might change the class, in which case we have to\n-\t put it back where we found it.  */\n-      if (current_class != klass && icv != NULL_TREE)\n-\tTREE_TYPE (icv) = current_class;\n-      klass = current_class;\n-    }\n-  layout_class (klass);\n-  load_inner_classes (klass);\n-\n-  output_class = save_output_class;\n-  current_class = save_current_class;\n-  input_location = save_location;\n-  current_jcf = save_current_jcf;\n-  return 1;\n-}\n-\n-/* Load CLASS_OR_NAME. CLASS_OR_NAME can be a mere identifier if\n-   called from the parser, otherwise it's a RECORD_TYPE node. If\n-   VERBOSE is 1, print error message on failure to load a class. */\n-void\n-load_class (tree class_or_name, int verbose)\n-{\n-  tree name, saved;\n-  int class_loaded = 0;\n-  tree class_decl = NULL_TREE;\n-  bool is_compiled_class = false;\n-\n-  /* We've already failed, don't try again.  */\n-  if (TREE_CODE (class_or_name) == RECORD_TYPE\n-      && TYPE_DUMMY (class_or_name))\n-    return;\n-\n-  /* class_or_name can be the name of the class we want to load */\n-  if (TREE_CODE (class_or_name) == IDENTIFIER_NODE)\n-    name = class_or_name;\n-  /* In some cases, it's a dependency that we process earlier that\n-     we though */\n-  else if (TREE_CODE (class_or_name) == TREE_LIST)\n-    name = TYPE_NAME (TREE_PURPOSE (class_or_name));\n-  /* Or it's a type in the making */\n-  else\n-    name = DECL_NAME (TYPE_NAME (class_or_name));\n-\n-  class_decl = IDENTIFIER_CLASS_VALUE (name);\n-  if (class_decl != NULL_TREE)\n-    {\n-      tree type = TREE_TYPE (class_decl);\n-      is_compiled_class\n-\t= ((TYPE_JCF (type) && JCF_SEEN_IN_ZIP (TYPE_JCF (type)))\n-\t   || CLASS_FROM_CURRENTLY_COMPILED_P (type));\n-    }\n-\n-  saved = name;\n-  \n-  /* If flag_verify_invocations is unset, we don't try to load a class\n-     unless we're looking for Object (which is fixed by the ABI) or\n-     it's a class that we're going to compile.  */\n-  if (flag_verify_invocations\n-      || class_or_name == object_type_node\n-      || is_compiled_class\n-      || TREE_CODE (class_or_name) == IDENTIFIER_NODE)\n-    {\n-      while (1)\n-\t{\n-\t  const char *separator;\n-\n-\t  /* We've already loaded it.  */\n-\t  if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE)\n-\t    {\n-\t      tree tmp_decl = IDENTIFIER_CLASS_VALUE (name);\n-\t      if (CLASS_PARSED_P (TREE_TYPE (tmp_decl)))\n-\t\tbreak;\n-\t    }\n-\t\n-\t  if (read_class (name))\n-\t    break;\n-\n-\t  /* We failed loading name. Now consider that we might be looking\n-\t     for an inner class.  */\n-\t  if ((separator = strrchr (IDENTIFIER_POINTER (name), '$'))\n-\t      || (separator = strrchr (IDENTIFIER_POINTER (name), '.')))\n-\t    name = get_identifier_with_length (IDENTIFIER_POINTER (name),\n-\t\t\t\t\t       (separator\n-\t\t\t\t\t\t- IDENTIFIER_POINTER (name)));\n-\t  /* Otherwise, we failed, we bail. */\n-\t  else\n-\t    break;\n-\t}\n-\n-      {\n-\t/* have we found the class we're looking for?  */\n-\ttree type_decl = IDENTIFIER_CLASS_VALUE (saved);\n-\ttree type = type_decl ? TREE_TYPE (type_decl) : NULL;\n-\tclass_loaded = type && CLASS_PARSED_P (type);\n-      }\t      \n-    }\n-  \n-  if (!class_loaded)\n-    {\n-      if (flag_verify_invocations || ! flag_indirect_dispatch)\n-\t{\n-\t  if (verbose)\n-\t    error (\"cannot find file for class %s\", IDENTIFIER_POINTER (saved));\n-\t}\n-      else if (verbose)\n-\t{\n-\t  /* This is just a diagnostic during testing, not a real problem.  */\n-\t  if (!quiet_flag)\n-\t    warning (0, \"cannot find file for class %s\", \n-\t\t     IDENTIFIER_POINTER (saved));\n-\t  \n-\t  /* Fake it.  */\n-\t  if (TREE_CODE (class_or_name) == RECORD_TYPE)\n-\t    {\n-\t      set_super_info (0, class_or_name, object_type_node, 0);\n-\t      TYPE_DUMMY (class_or_name) = 1;\n-\t      /* We won't be able to output any debug info for this class.  */\n-\t      DECL_IGNORED_P (TYPE_NAME (class_or_name)) = 1;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Parse the .class file JCF. */\n-\n-static void\n-jcf_parse (JCF* jcf)\n-{\n-  int i, code;\n-\n-  bitmap_clear (field_offsets);\n-\n-  if (jcf_parse_preamble (jcf) != 0)\n-    fatal_error (input_location, \"not a valid Java .class file\");\n-  code = jcf_parse_constant_pool (jcf);\n-  if (code != 0)\n-    fatal_error (input_location, \"error while parsing constant pool\");\n-  code = verify_constant_pool (jcf);\n-  if (code > 0)\n-    fatal_error (input_location, \"error in constant pool entry #%d\\n\", code);\n-\n-  jcf_parse_class (jcf);\n-  if (main_class == NULL_TREE)\n-    main_class = current_class;\n-  if (! quiet_flag && TYPE_NAME (current_class))\n-    fprintf (stderr, \" %s %s\",\n-\t     (jcf->access_flags & ACC_INTERFACE) ? \"interface\" : \"class\", \n-\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n-  if (CLASS_PARSED_P (current_class))\n-    {\n-      /* FIXME - where was first time */\n-      fatal_error (input_location,\n-\t\t   \"reading class %s for the second time from %s\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))),\n-\t\t   jcf->filename);\n-    }\n-  CLASS_PARSED_P (current_class) = 1;\n-\n-  for (i = 1; i < JPOOL_SIZE(jcf); i++)\n-    {\n-      switch (JPOOL_TAG (jcf, i))\n-\t{\n-\tcase CONSTANT_Class:\n-\t  get_class_constant (jcf, i);\n-\t  break;\n-\t}\n-    }\n-  \n-  code = jcf_parse_fields (jcf);\n-  if (code != 0)\n-    fatal_error (input_location, \"error while parsing fields\");\n-  code = jcf_parse_methods (jcf);\n-  if (code != 0)\n-    fatal_error (input_location, \"error while parsing methods\");\n-  code = jcf_parse_final_attributes (jcf);\n-  if (code != 0)\n-    fatal_error (input_location, \"error while parsing final attributes\");\n-\n-  if (TYPE_REFLECTION_DATA (current_class))\n-    annotation_write_byte (JV_DONE_ATTR);\n-\n-  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n-\n-  /* The fields of class_type_node are already in correct order. */\n-  if (current_class != class_type_node && current_class != object_type_node)\n-    TYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n-\n-  if (current_class == object_type_node)\n-    layout_class_methods (object_type_node);\n-  else\n-    vec_safe_push (all_class_list, TYPE_NAME (current_class));\n-}\n-\n-/* If we came across inner classes, load them now. */\n-static void\n-load_inner_classes (tree cur_class)\n-{\n-  tree current;\n-  for (current = DECL_INNER_CLASS_LIST (TYPE_NAME (cur_class)); current;\n-       current = TREE_CHAIN (current))\n-    {\n-      tree name = DECL_NAME (TREE_PURPOSE (current));\n-      tree decl = IDENTIFIER_GLOBAL_VALUE (name);\n-      if (decl && ! CLASS_LOADED_P (TREE_TYPE (decl))\n-\t  && !CLASS_BEING_LAIDOUT (TREE_TYPE (decl)))\n-\tload_class (name, 1);\n-    }\n-}\n-\n-static void\n-duplicate_class_warning (const char *filename)\n-{\n-  location_t warn_loc;\n-  linemap_add (line_table, LC_RENAME, 0, filename, 0);\n-  warn_loc = linemap_line_start (line_table, 0, 1);\n-  warning_at (warn_loc, 0, \"duplicate class will only be compiled once\");\n-}\n-\n-static void\n-java_layout_seen_class_methods (void)\n-{\n-  unsigned start = 0;\n-  unsigned end = vec_safe_length (all_class_list);\n-\n-  while (1)\n-    {\n-      unsigned ix;\n-      unsigned new_length;\n-\n-      for (ix = start; ix != end; ix++)\n-        {\n-\t  tree decl = (*all_class_list)[ix];\n-          tree cls = TREE_TYPE (decl);\n-\n-\t  input_location = DECL_SOURCE_LOCATION (decl);\n-\n-          if (! CLASS_LOADED_P (cls))\n-            load_class (cls, 0);\n-\n-          layout_class_methods (cls);\n-        }\n-\n-      /* Note that new classes might have been added while laying out\n-         methods, changing the value of all_class_list.  */\n-      new_length = vec_safe_length (all_class_list);\n-      if (end != new_length)\n-\t{\n-\t  start = end;\n-\t  end = new_length;\n-\t}\n-      else\n-\tbreak;\n-    }\n-}\n-\n-static void\n-parse_class_file (void)\n-{\n-  tree method;\n-  location_t save_location = input_location;\n-\n-  java_layout_seen_class_methods ();\n-\n-  input_location = DECL_SOURCE_LOCATION (TYPE_NAME (current_class));\n-  {\n-    /* Re-enter the current file.  */\n-    expanded_location loc = expand_location (input_location);\n-    linemap_add (line_table, LC_ENTER, 0, loc.file, loc.line);\n-  }\n-  file_start_location = input_location;\n-  (*debug_hooks->start_source_file) (LOCATION_LINE (input_location),\n-\t\t\t\t     LOCATION_FILE (input_location));\n-\n-  java_mark_class_local (current_class);\n-\n-  gen_indirect_dispatch_tables (current_class);\n-\n-  for (method = TYPE_METHODS (current_class);\n-       method != NULL_TREE; method = DECL_CHAIN (method))\n-    {\n-      JCF *jcf = current_jcf;\n-\n-      if (METHOD_ABSTRACT (method) || METHOD_DUMMY (method))\n-\tcontinue;\n-\n-      if (METHOD_NATIVE (method))\n-\t{\n-\t  tree arg;\n-\t  int  decl_max_locals;\n-\n-\t  if (! flag_jni)\n-\t    continue;\n-\t  /* We need to compute the DECL_MAX_LOCALS. We need to take\n-             the wide types into account too. */\n-\t  for (arg = TYPE_ARG_TYPES (TREE_TYPE (method)), decl_max_locals = 0; \n-\t       arg != end_params_node;\n-\t       arg = TREE_CHAIN (arg), decl_max_locals += 1)\n-\t    {\n-\t      if (TREE_VALUE (arg) && TYPE_IS_WIDE (TREE_VALUE (arg)))\n-\t\tdecl_max_locals += 1;\n-\t    }\n-\t  DECL_MAX_LOCALS (method) = decl_max_locals;\n-\t  start_java_method (method);\n-\t  give_name_to_locals (jcf);\n-\t  *get_stmts () = build_jni_stub (method);\n-\t  end_java_method ();\n-\t  continue;\n-\t}\n-\n-      if (DECL_CODE_OFFSET (method) == 0)\n-\t{\n-\t  current_function_decl = method;\n-\t  error (\"missing Code attribute\");\n-\t  continue;\n-\t}\n-\n-      input_location = DECL_SOURCE_LOCATION (TYPE_NAME (current_class));\n-      if (DECL_LINENUMBERS_OFFSET (method))\n-\t{\n-\t  int i;\n-\t  int min_line = 0;\n-\t  unsigned char *ptr;\n-\t  JCF_SEEK (jcf, DECL_LINENUMBERS_OFFSET (method));\n-\t  linenumber_count = i = JCF_readu2 (jcf);\n-\t  linenumber_table = ptr = jcf->read_ptr;\n-\n-\t  for (ptr += 2; --i >= 0; ptr += 4)\n-\t    {\n-\t      int line = GET_u2 (ptr);\n-\t      /* Set initial line of input_location to smallest\n-\t       * linenumber.\n-\t       * Needs to be set before init_function_start. */\n-\t      if (min_line == 0 || line < min_line)\n-\t\tmin_line = line;\n-\t    }\n-\t  if (min_line != 0)\n-\t    input_location = linemap_line_start (line_table, min_line, 1);\n-\t}\n-      else\n-\t{\n-\t  linenumber_table = NULL;\n-\t  linenumber_count = 0;\n-\t}\n-\n-      start_java_method (method);\n-\n-      note_instructions (jcf, method);\n-\n-      give_name_to_locals (jcf);\n-\n-      /* Bump up start_label_pc_this_method so we get a unique label number\n-\t and reset highest_label_pc_this_method. */\n-      if (highest_label_pc_this_method >= 0)\n-\t{\n-\t  /* We adjust to the next multiple of 1000.  This is just a frill\n-\t     so the last 3 digits of the label number match the bytecode\n-\t     offset, which might make debugging marginally more convenient. */\n-\t  start_label_pc_this_method\n-\t    = ((((start_label_pc_this_method + highest_label_pc_this_method)\n-\t\t / 1000)\n-\t\t+ 1)\n-\t       * 1000);\n-\t  highest_label_pc_this_method = -1;\n-\t}\n-\n-      /* Convert bytecode to trees.  */\n-      expand_byte_code (jcf, method);\n-\n-      end_java_method ();\n-    }\n-\n-  finish_class ();\n-\n-  (*debug_hooks->end_source_file) (LOCATION_LINE (save_location));\n-  input_location = save_location;\n-}\n-\n-static vec<tree, va_gc> *predefined_filenames;\n-\n-void\n-add_predefined_file (tree name)\n-{\n-  vec_safe_push (predefined_filenames, name);\n-}\n-\n-int\n-predefined_filename_p (tree node)\n-{\n-  unsigned ix;\n-  tree f;\n-\n-  FOR_EACH_VEC_SAFE_ELT (predefined_filenames, ix, f)\n-    if (f == node)\n-      return 1;\n-\n-  return 0;\n-}\n-\n-/* Generate a function that does all static initialization for this \n-   translation unit.  */\n-\n-static void\n-java_emit_static_constructor (void)\n-{\n-  tree body = NULL;\n-\n-  emit_register_classes (&body);\n-  write_resource_constructor (&body);\n-\n-  if (body)\n-    {\n-      tree name = get_identifier (\"_Jv_global_static_constructor\");\n-\n-      tree decl \n-\t= build_decl (input_location, FUNCTION_DECL, name,\n-\t\t      build_function_type_list (void_type_node, NULL_TREE));\n-\n-      tree resdecl = build_decl (input_location,\n-\t\t\t\t RESULT_DECL, NULL_TREE, void_type_node);\n-      DECL_ARTIFICIAL (resdecl) = 1;\n-      DECL_RESULT (decl) = resdecl;\n-      current_function_decl = decl;\n-      allocate_struct_function (decl, false);\n-\n-      TREE_STATIC (decl) = 1;\n-      TREE_USED (decl) = 1;\n-      DECL_ARTIFICIAL (decl) = 1;\n-      DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n-      DECL_SAVED_TREE (decl) = body;\n-      DECL_UNINLINABLE (decl) = 1;\n-\n-      DECL_INITIAL (decl) = make_node (BLOCK);\n-      BLOCK_SUPERCONTEXT (DECL_INITIAL (decl)) = decl;\n-      TREE_USED (DECL_INITIAL (decl)) = 1;\n-\n-      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-      java_genericize (decl);\n-      cgraph_node::finalize_function (decl, false);\n-    }\n-}\n-\n-\n-void\n-java_parse_file (void)\n-{\n-  int filename_count = 0;\n-  location_t save_location = input_location;\n-  char *file_list = NULL, *list, *next;\n-  tree node;\n-  FILE *finput = NULL;\n-  int in_quotes = 0;\n-  unsigned ix;\n- \n-  bitmap_obstack_initialize (&bit_obstack);\n-  field_offsets = BITMAP_ALLOC (&bit_obstack);\n-\n-  if (flag_filelist_file)\n-    {\n-      int avail = 2000;\n-      finput = fopen (main_input_filename, \"r\");\n-      if (finput == NULL)\n-\tfatal_error (input_location,\n-\t\t     \"can%'t open %s: %m\", LOCATION_FILE (input_location));\n-      list = XNEWVEC (char, avail);\n-      next = list;\n-      for (;;)\n-\t{\n-\t  int count;\n-\t  if (avail < 500)\n-\t    {\n-\t      count = next - list;\n-\t      avail = 2 * (count + avail);\n-\t      list = XRESIZEVEC (char, list, avail);\n-\t      next = list + count;\n-\t      avail = avail - count;\n-\t    }\n-\t  /* Subtract one to guarantee space for final '\\0'. */\n-\t  count = fread (next, 1, avail - 1, finput);\n-\t  if (count == 0)\n-\t    {\n-\t      if (! feof (finput))\n-\t\tfatal_error (input_location, \"error closing %s: %m\",\n-\t\t\t     LOCATION_FILE (input_location));\n-\t      *next = '\\0';\n-\t      break;\n-\t    }\n-\t  avail -= count;\n-\t  next += count;\n-\t}\n-      fclose (finput);\n-      finput = NULL;\n-      file_list = list;\n-    }\n-  else\n-    list = CONST_CAST (char *, main_input_filename);\n-\n-  while (list)\n-    {\n-      for (next = list; ; )\n-\t{\n-\t  char ch = *next;\n-\t  if (flag_filelist_file && ! in_quotes\n-\t      && (ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == ' '\n-\t\t  || ch == '&') /* FIXME */)\n-\t    {\n-\t      if (next == list)\n-\t\t{\n-\t\t  next++;\n-\t\t  list = next;\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  *next++ = '\\0';\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (flag_filelist_file && ch == '\"')\n-\t    {\n-\t      in_quotes = ! in_quotes;\n-\t      *next++ = '\\0';\n-\t      if (in_quotes) \n-\t\tlist = next;\n-\t      else \n-\t\tbreak;\n-\t    }\n-\t  if (ch == '\\0')\n-\t    {\n-\t      next = NULL;\n-\t      break;\n-\t    }\n-\t  next++;\n-\t}\n-\n-      /* Exclude .java files.  */\n-      if (strlen (list) > 5 && ! strcmp (list + strlen (list) - 5, \".java\"))\n-\t{\n-\t  /* Nothing. */\n-\t}\n-      else if (list[0]) \n-\t{\n-\t  node = get_identifier (list);\n-\n-\t  filename_count++;\n-\n-\t  /* Exclude file that we see twice on the command line. */\n-\t     \n-\t  if (IS_A_COMMAND_LINE_FILENAME_P (node))\n-\t    duplicate_class_warning (IDENTIFIER_POINTER (node));\n-\t  else\n-\t    {\n-\t      build_translation_unit_decl (node);\n-\t      IS_A_COMMAND_LINE_FILENAME_P (node) = 1;\n-\t    }\n-\t}\n-      list = next;\n-    }\n-\n-  free (file_list);\n-\n-  if (filename_count == 0)\n-    warning (0, \"no input file specified\");\n-\n-  if (resource_name)\n-    {\n-      const char *resource_filename;\n-      \n-      /* Only one resource file may be compiled at a time.  */\n-      gcc_assert (all_translation_units->length () == 1);\n-\n-      resource_filename\n-\t= IDENTIFIER_POINTER (DECL_NAME ((*all_translation_units)[0]));\n-      compile_resource_file (resource_name, resource_filename);\n-\n-      goto finish;\n-    }\n-\n-  current_jcf = main_jcf;\n-  FOR_EACH_VEC_ELT (*all_translation_units, ix, node)\n-    {\n-      unsigned char magic_string[4];\n-      char *real_path;\n-      uint32 magic = 0;\n-      tree name = DECL_NAME (node);\n-      tree real_file;\n-      const char *filename = IDENTIFIER_POINTER (name);\n-\n-      /* Skip already parsed files */\n-      real_path = lrealpath (filename);\n-      real_file = get_identifier (real_path);\n-      free (real_path);\n-      if (HAS_BEEN_ALREADY_PARSED_P (real_file))\n-\tcontinue;\n-\n-      /* Close previous descriptor, if any */\n-      if (finput && fclose (finput))\n-\tfatal_error (input_location,\n-\t\t     \"can%'t close input file %s: %m\", main_input_filename);\n-      \n-      finput = fopen (filename, \"rb\");\n-      if (finput == NULL)\n-\tfatal_error (input_location, \"can%'t open %s: %m\", filename);\n-\n-#ifdef IO_BUFFER_SIZE\n-      setvbuf (finput, xmalloc (IO_BUFFER_SIZE),\n-\t       _IOFBF, IO_BUFFER_SIZE);\n-#endif\n-\n-      /* Figure what kind of file we're dealing with */\n-      if (fread (magic_string, 1, 4, finput) == 4)\n-\t{\n-\t  fseek (finput, 0L, SEEK_SET);\n-\t  magic = GET_u4 (magic_string);\n-\t}\n-      if (magic == 0xcafebabe)\n-\t{\n-\t  CLASS_FILE_P (node) = 1;\n-\t  current_jcf = ggc_cleared_alloc<JCF> ();\n-\t  current_jcf->read_state = finput;\n-\t  current_jcf->filbuf = jcf_filbuf_from_stdio;\n-\t  jcf_parse (current_jcf);\n-\t  DECL_SOURCE_LOCATION (node) = file_start_location;\n-\t  TYPE_JCF (current_class) = current_jcf;\n-\t  if (CLASS_FROM_CURRENTLY_COMPILED_P (current_class))\n-\t    {\n-\t      /* We've already compiled this class.  */\n-\t      duplicate_class_warning (filename);\n-\t      continue;\n-\t    }\n-\t  CLASS_FROM_CURRENTLY_COMPILED_P (current_class) = 1;\n-\t  TREE_TYPE (node) = current_class;\n-\t}\n-      else if (magic == (JCF_u4)ZIPMAGIC)\n-\t{\n-\t  main_jcf = ggc_cleared_alloc<JCF> ();\n-\t  main_jcf->read_state = finput;\n-\t  main_jcf->filbuf = jcf_filbuf_from_stdio;\n-\t  linemap_add (line_table, LC_ENTER, false, filename, 0);\n-\t  input_location = linemap_line_start (line_table, 0, 1);\n-\t  if (open_in_zip (main_jcf, filename, NULL, 0) <  0)\n-\t    fatal_error (input_location, \"bad zip/jar file %s\", filename);\n-\t  localToFile = SeenZipFiles;\n-\t  /* Register all the classes defined there.  */\n-\t  process_zip_dir ((FILE *) main_jcf->read_state);\n-\t  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n-\t  parse_zip_file_entries ();\n-\t}\n-      else if (magic == (JCF_u4) ZIPEMPTYMAGIC)\n-\t{\n-\t  /* Ignore an empty input jar.  */\n-\t}\n-      else\n-\t{\n-\t  gcc_unreachable ();\n-#if 0\n-\t  java_push_parser_context ();\n-\t  java_parser_context_save_global ();\n-\n-\t  parse_source_file_1 (real_file, filename, finput);\n-\t  java_parser_context_restore_global ();\n-\t  java_pop_parser_context (1);\n-\t  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n-#endif\n-\t}\n-    }\n-\n-  FOR_EACH_VEC_ELT (*all_translation_units, ix, node)\n-    {\n-      input_location = DECL_SOURCE_LOCATION (node);\n-      if (CLASS_FILE_P (node))\n-\t{\n-\t  /* FIXME: These two flags really should be independent.  We\n-\t     should be able to compile fully binary compatible, but\n-\t     with flag_verify_invocations on.  */\n-\t  flag_verify_invocations = ! flag_indirect_dispatch;\n-\t  output_class = current_class = TREE_TYPE (node);\n-\n-\t  current_jcf = TYPE_JCF (current_class);\n-\t  layout_class (current_class);\n-\t  load_inner_classes (current_class);\n-\t  parse_class_file ();\n-\t  JCF_FINISH (current_jcf);\n-\t}\n-    }\n-  input_location = save_location;\n-\n-  bitmap_obstack_release (&bit_obstack);\n-\n- finish:\n-  /* Arrange for any necessary initialization to happen.  */\n-  java_emit_static_constructor ();\n-  gcc_assert (global_bindings_p ());\n-\n-  /* Do final processing on globals.  */\n-  global_decl_processing ();\n-}\n-\n-\n-/* Return the name of the class corresponding to the name of the file\n-   in this zip entry.  The result is newly allocated using ALLOC.  */\n-static char *\n-compute_class_name (struct ZipDirectory *zdir)\n-{\n-  char *class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n-  char *class_name;\n-  int i;\n-  int filename_length = zdir->filename_length;\n-\n-  while (filename_length > 2 && strncmp (class_name_in_zip_dir, \"./\", 2) == 0)\n-    {\n-      class_name_in_zip_dir += 2;\n-      filename_length -= 2;\n-    }\n-\n-  filename_length -= strlen (\".class\");\n-  class_name = XNEWVEC (char, filename_length + 1);\n-  memcpy (class_name, class_name_in_zip_dir, filename_length);\n-  class_name [filename_length] = '\\0';\n-\n-  for (i = 0; i < filename_length; i++)\n-    if (class_name[i] == '/')\n-      class_name[i] = '.';\n-\n-  return class_name;\n-}\n-\n-/* Return 0 if we should skip this entry, 1 if it is a .class file, 2\n-   if it is a property file of some sort.  */\n-static int\n-classify_zip_file (struct ZipDirectory *zdir)\n-{\n-  char *class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n-\n-  if (zdir->filename_length > 6\n-      && !strncmp (&class_name_in_zip_dir[zdir->filename_length - 6],\n-\t\t   \".class\", 6))\n-    return 1;\n-\n-  /* For now we drop the manifest, but not other information.  */\n-  if (zdir->filename_length == 20\n-      && !strncmp (class_name_in_zip_dir, \"META-INF/MANIFEST.MF\", 20))\n-    return 0;\n-\n-  /* Drop directory entries.  */\n-  if (zdir->filename_length > 0\n-      && class_name_in_zip_dir[zdir->filename_length - 1] == '/')\n-    return 0;\n-\n-  return 2;\n-}\n-\n-/* Process all class entries found in the zip file.  */\n-static void\n-parse_zip_file_entries (void)\n-{\n-  struct ZipDirectory *zdir;\n-  int i;\n-\n-  for (i = 0, zdir = (ZipDirectory *)localToFile->central_directory;\n-       i < localToFile->count; i++, zdir = ZIPDIR_NEXT (zdir))\n-    {\n-      tree klass;\n-\n-      switch (classify_zip_file (zdir))\n-\t{\n-\tcase 0:\n-\t  continue;\n-\n-\tcase 1:\n-\t  {\n-\t    char *class_name = compute_class_name (zdir);\n-\t    int previous_alias_set = -1;\n-\t    klass = lookup_class (get_identifier (class_name));\n-\t    FREE (class_name);\n-\t    current_jcf = TYPE_JCF (klass);\n-\t    output_class = current_class = klass;\n-\n-\t    /* This is a dummy class, and now we're compiling it for\n-\t       real.  */\n-\t    gcc_assert (! TYPE_DUMMY (klass));\n-\n-\t    /* This is for a corner case where we have a superclass\n-\t       but no superclass fields.\n-\n-\t       This can happen if we earlier failed to lay out this\n-\t       class because its superclass was still in the process\n-\t       of being laid out; this occurs when we have recursive\n-\t       class dependencies via inner classes.  We must record\n-\t       the previous alias set and restore it after laying out\n-\t       the class.\n-\n-\t       FIXME: this really is a kludge.  We should figure out a\n-\t       way to lay out the class properly before this\n-\t       happens.  */\n-\t    if (TYPE_SIZE (klass) && CLASSTYPE_SUPER (klass)\n-\t\t&& integer_zerop (TYPE_SIZE (klass)))\n-\t      {\n-\t\tTYPE_SIZE (klass) = NULL_TREE;\n-\t\tprevious_alias_set = TYPE_ALIAS_SET (klass);\n-\t\tTYPE_ALIAS_SET (klass) = -1;\n-\t      }\n-\n-\t    if (! CLASS_LOADED_P (klass))\n-\t      {\n-\t\tif (! CLASS_PARSED_P (klass))\n-\t\t  {\n-\t\t    read_zip_member (current_jcf, zdir, localToFile);\n-\t\t    jcf_parse (current_jcf);\n-\t\t  }\n-\t\tlayout_class (current_class);\n-\t\tload_inner_classes (current_class);\n-\t      }\n-\n-\t    if (previous_alias_set != -1)\n-\t      TYPE_ALIAS_SET (klass) = previous_alias_set;\n-\n-\t    if (TYPE_SIZE (current_class) != error_mark_node)\n-\t      {\n-\t\tparse_class_file ();\n-\t\tfree (current_jcf->buffer); /* No longer necessary */\n-\t\t/* Note: there is a way to free this buffer right after a\n-\t\t   class seen in a zip file has been parsed. The idea is the\n-\t\t   set its jcf in such a way that buffer will be reallocated\n-\t\t   the time the code for the class will be generated. FIXME. */\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tcase 2:\n-\t  {\n-\t    char *file_name, *class_name_in_zip_dir, *buffer;\n-\t    JCF *jcf;\n-\t    file_name = XNEWVEC (char, zdir->filename_length + 1);\n-\t    class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n-\t    strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n-\t    file_name[zdir->filename_length] = '\\0';\n-\t    jcf = XNEW (JCF);\n-\t    JCF_ZERO (jcf);\n-\t    jcf->read_state  = finput;\n-\t    jcf->filbuf      = jcf_filbuf_from_stdio;\n-\t    jcf->classname   = NULL;\n-\t    jcf->filename    = file_name;\n-\t    jcf->zipd        = zdir;\n-\n-\t    if (read_zip_member (jcf, zdir, localToFile) < 0)\n-\t      fatal_error (input_location,\n-\t\t\t   \"error while reading %s from zip file\", file_name);\n-\n-\t    buffer = XNEWVEC (char, zdir->filename_length + 1 +\n-\t\t\t    (jcf->buffer_end - jcf->buffer));\n-\t    strcpy (buffer, file_name);\n-\t    /* This is not a typo: we overwrite the trailing \\0 of the\n-\t       file name; this is just how the data is laid out.  */\n-\t    memcpy (buffer + zdir->filename_length,\n-\t\t    jcf->buffer, jcf->buffer_end - jcf->buffer);\n-\n-\t    compile_resource_data (file_name, buffer,\n-\t\t\t\t   jcf->buffer_end - jcf->buffer);\n-\t    JCF_FINISH (jcf);\n-\t    free (jcf);\n-\t    free (buffer);\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-}\n-\n-/* Read all the entries of the zip file, creates a class and a JCF. Sets the\n-   jcf up for further processing and link it to the created class.  */\n-\n-static void\n-process_zip_dir (FILE *finput)\n-{\n-  int i;\n-  ZipDirectory *zdir;\n-\n-  for (i = 0, zdir = (ZipDirectory *)localToFile->central_directory;\n-       i < localToFile->count; i++, zdir = ZIPDIR_NEXT (zdir))\n-    {\n-      char *class_name, *file_name, *class_name_in_zip_dir;\n-      tree klass;\n-      JCF  *jcf;\n-\n-      class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n-\n-      /* Here we skip non-class files; we handle them later.  */\n-      if (classify_zip_file (zdir) != 1)\n-\tcontinue;\n-\n-      class_name = compute_class_name (zdir);\n-      file_name  = XNEWVEC (char, zdir->filename_length+1);\n-      jcf = ggc_cleared_alloc<JCF> ();\n-\n-      strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n-      file_name [zdir->filename_length] = '\\0';\n-\n-      klass = lookup_class (get_identifier (class_name));\n-\n-      if (CLASS_FROM_CURRENTLY_COMPILED_P (klass))\n-\t{\n-\t  /* We've already compiled this class.  */\n-\t  duplicate_class_warning (file_name);\n-\t  continue;\n-\t}\n-      /* This function is only called when processing a zip file seen\n-\t on the command line.  */\n-      CLASS_FROM_CURRENTLY_COMPILED_P (klass) = 1;\n-\n-      jcf->read_state  = finput;\n-      jcf->filbuf      = jcf_filbuf_from_stdio;\n-      jcf->classname   = class_name;\n-      jcf->filename    = file_name;\n-      jcf->zipd        = zdir;\n-\n-      TYPE_JCF (klass) = jcf;\n-    }\n-}\n-\n-#include \"gt-java-jcf-parse.h\"\n-#include \"gtype-java.h\""}, {"sha": "2dd13851d2674c8e7f912990d80f94d7edcf884b", "filename": "gcc/java/jcf-path.c", "status": "removed", "additions": 0, "deletions": 516, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,516 +0,0 @@\n-/* Handle CLASSPATH, -classpath, and path searching.\n-   Copyright (C) 1998-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Tom Tromey <tromey@cygnus.com>, October 1998.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-\n-#include <dirent.h>\n-\n-#include \"jcf.h\"\n-\n-#ifndef DIR_UP\n-#define DIR_UP \"..\"\n-#endif\n-\n-\f\n-\n-/* Possible flag values.  */\n-#define FLAG_SYSTEM 1\n-#define FLAG_ZIP    2\n-\n-/* We keep linked lists of directory names.  A ``directory'' can be\n-   either an ordinary directory or a .zip file.  */\n-struct entry\n-{\n-  char *name;\n-  int flags;\n-  struct entry *next;\n-};\n-\n-static void free_entry (struct entry **);\n-static void append_entry (struct entry **, struct entry *);\n-static void add_entry (struct entry **, const char *, int);\n-static void add_path (struct entry **, const char *, int);\n-\n-/* We support several different ways to set the class path.\n-\n-   built-in system directory (only libgcj.jar)\n-   CLASSPATH environment variable\n-   -classpath option overrides $CLASSPATH\n-   -CLASSPATH option is a synonym for -classpath (for compatibility)\n-   -bootclasspath overrides built-in\n-   -extdirs sets the extensions directory path (overrides built-in)\n-   -I prepends path to list\n-\n-   We implement this by keeping several path lists, and then simply\n-   ignoring the ones which are not relevant.  */\n-\n-/* This holds all the -I directories.  */\n-static struct entry *include_dirs;\n-\n-/* This holds the CLASSPATH environment variable.  */\n-static struct entry *classpath_env;\n-\n-/* This holds the -classpath command-line option.  */\n-static struct entry *classpath_user;\n-\n-/* This holds the default directories.  Some of these will have the\n-   \"system\" flag set.  */\n-static struct entry *sys_dirs;\n-\n-/* This holds the extensions path entries.  */\n-static struct entry *extensions;\n-\n-/* This is the sealed list.  It is just a combination of other lists.  */\n-static struct entry *sealed;\n-\n-/* We keep track of the longest path we've seen.  */\n-static int longest_path = 0;\n-\n-\f\n-\n-static void\n-free_entry (struct entry **entp)\n-{\n-  struct entry *e, *n;\n-\n-  for (e = *entp; e; e = n)\n-    {\n-      n = e->next;\n-      free (e->name);\n-      free (e);\n-    }\n-  *entp = NULL;\n-}\n-\n-static void\n-append_entry (struct entry **entp, struct entry *ent)\n-{\n-  /* It doesn't matter if this is slow, since it is run only at\n-     startup, and then infrequently.  */\n-  struct entry *e;\n-\n-  /* Find end of list.  */\n-  for (e = *entp; e && e->next; e = e->next)\n-    ;\n-\n-  if (e)\n-    e->next = ent;\n-  else\n-    *entp = ent;\n-}\n-\n-static void\n-add_entry (struct entry **entp, const char *filename, int is_system)\n-{\n-  int len;\n-  struct entry *n;\n-\n-  n = XNEW (struct entry);\n-  n->flags = is_system ? FLAG_SYSTEM : 0;\n-  n->next = NULL;\n-\n-  len = strlen (filename);\n-\n-  if (len > 4 && (FILENAME_CMP (filename + len - 4, \".zip\") == 0\n-\t\t  || FILENAME_CMP (filename + len - 4, \".jar\") == 0))\n-    {\n-      n->flags |= FLAG_ZIP;\n-      /* If the user uses -classpath then he'll have to include\n-\t libgcj.jar in the value.  We check for this in a simplistic\n-\t way.  Symlinks will fool this test.  This is only used for\n-\t -MM and -MMD, so it probably isn't terribly important.  */\n-      if (! FILENAME_CMP (filename, LIBGCJ_ZIP_FILE))\n-\tn->flags |= FLAG_SYSTEM;\n-    }\n-\n-  /* Note that we add a trailing separator to `.zip' names as well.\n-     This is a little hack that lets the searching code in jcf-io.c\n-     work more easily.  Eww.  */\n-  if (! IS_DIR_SEPARATOR (filename[len - 1]))\n-    {\n-      char *f2 = (char *) alloca (len + 2);\n-      strcpy (f2, filename);\n-      f2[len] = DIR_SEPARATOR;\n-      f2[len + 1] = '\\0';\n-      n->name = xstrdup (f2);\n-      ++len;\n-    }\n-  else\n-    n->name = xstrdup (filename);\n-\n-  if (len > longest_path)\n-    longest_path = len;\n-\n-  append_entry (entp, n);\n-}\n-\n-static void\n-add_path (struct entry **entp, const char *cp, int is_system)\n-{\n-  const char *startp, *endp;\n-\n-  if (cp)\n-    {\n-      char *buf = (char *) alloca (strlen (cp) + 3);\n-      startp = endp = cp;\n-      while (1)\n-\t{\n-\t  if (! *endp || *endp == PATH_SEPARATOR)\n-\t    {\n-\t      if (endp == startp)\n-\t\t{\n-\t\t  buf[0] = '.';\n-\t\t  buf[1] = DIR_SEPARATOR;\n-\t\t  buf[2] = '\\0';\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  strncpy (buf, startp, endp - startp);\n-\t\t  buf[endp - startp] = '\\0';\n-\t\t}\n-\t      add_entry (entp, buf, is_system);\n-\t      if (! *endp)\n-\t\tbreak;\n-\t      ++endp;\n-\t      startp = endp;\n-\t    }\n-\t  else\n-\t    ++endp;\n-\t}\n-    }\n-}\n-\n-static int init_done = 0;\n-\n-/* Initialize the path module.  */\n-void\n-jcf_path_init (void)\n-{\n-  char *cp;\n-  char *attempt, sep[2];\n-  struct stat stat_b;\n-  int found = 0, len;\n-\n-  if (init_done)\n-    return;\n-  init_done = 1;\n-\n-  sep[0] = DIR_SEPARATOR;\n-  sep[1] = '\\0';\n-\n-  cp = getenv (\"GCC_EXEC_PREFIX\");\n-  if (cp)\n-    {\n-      attempt = (char *) alloca (strlen (cp) + 50);\n-      /* The exec prefix can be something like\n-\t /usr/local/bin/../lib/gcc-lib/.  We want to change this\n-\t into a pointer to the share/java directory.  We support two\n-\t configurations: one where prefix and exec-prefix are the\n-\t same, and one where exec-prefix is `prefix/SOMETHING'.  */\n-      strcpy (attempt, cp);\n-      strcat (attempt, DIR_UP);\n-      strcat (attempt, sep);\n-      strcat (attempt, DIR_UP);\n-      strcat (attempt, sep);\n-      len = strlen (attempt);\n-\n-      strcpy (attempt + len, \"share\");\n-      strcat (attempt, sep);\n-      strcat (attempt, \"java\");\n-      strcat (attempt, sep);\n-      strcat (attempt, \"libgcj-\" DEFAULT_TARGET_VERSION \".jar\");\n-      if (! stat (attempt, &stat_b))\n-\t{\n-\t  add_entry (&sys_dirs, attempt, 1);\n-\t  found = 1;\n-\t  strcpy (&attempt[strlen (attempt)\n-\t\t\t   - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n-\t\t  sep);\n-\t  strcat (attempt, \"ext\");\n-\t  strcat (attempt, sep);\n-\t  if (! stat (attempt, &stat_b))\n-\t    jcf_path_extdirs_arg (attempt);\n-\t}\n-      else\n-\t{\n-\t  strcpy (attempt + len, DIR_UP);\n-\t  strcat (attempt, sep);\n-\t  strcat (attempt, \"share\");\n-\t  strcat (attempt, sep);\n-\t  strcat (attempt, \"java\");\n-\t  strcat (attempt, sep);\n-\t  strcat (attempt, \"libgcj-\" DEFAULT_TARGET_VERSION \".jar\");\n-\t  if (! stat (attempt, &stat_b))\n-\t    {\n-\t      add_entry (&sys_dirs, attempt, 1);\n-\t      found = 1;\n-\t      strcpy (&attempt[strlen (attempt)\n-\t\t\t       - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n-\t\t      sep);\n-\t      strcat (attempt, \"ext\");\n-\t      strcat (attempt, sep);\n-\t      if (! stat (attempt, &stat_b))\n-\t\tjcf_path_extdirs_arg (attempt);\n-\t    }\n-\t}\n-    }\n-  if (! found)\n-    {\n-      /* Desperation: use the installed one.  */\n-      char *extdirs;\n-      add_entry (&sys_dirs, LIBGCJ_ZIP_FILE, 1);\n-      extdirs = (char *) alloca (strlen (LIBGCJ_ZIP_FILE) + 1);\n-      strcpy (extdirs, LIBGCJ_ZIP_FILE);\n-      strcpy (&extdirs[strlen (LIBGCJ_ZIP_FILE)\n-\t\t      - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n-\t      \"ext\");\n-      strcat (extdirs, sep);\n-      if (! stat (extdirs, &stat_b))\n-\tjcf_path_extdirs_arg (extdirs);\n-    }\n-\n-  cp = getenv (\"CLASSPATH\");\n-  add_path (&classpath_env, cp, 0);\n-}\n-\n-/* Call this when -classpath is seen on the command line.\n-   This overrides only the $CLASSPATH environment variable.\n- */\n-void\n-jcf_path_classpath_arg (const char *path)\n-{\n-  free_entry (&classpath_user);\n-  add_path (&classpath_user, path, 0);\n-}\n-\n-/* Call this when -bootclasspath is seen on the command line.\n- */\n-void\n-jcf_path_bootclasspath_arg (const char *path)\n-{\n-  free_entry (&sys_dirs);\n-  add_path (&sys_dirs, path, 1);\n-}\n-\n-/* Call this when -extdirs is seen on the command line.\n- */\n-void\n-jcf_path_extdirs_arg (const char *cp)\n-{\n-  const char *startp, *endp;\n-\n-  free_entry (&extensions);\n-\n-  if (cp)\n-    {\n-      char *buf = (char *) alloca (strlen (cp) + 3);\n-      startp = endp = cp;\n-      while (1)\n-\t{\n-\t  if (! *endp || *endp == PATH_SEPARATOR)\n-\t    {\n-\t      if (endp == startp)\n-\t\treturn;\n-\n-\t      strncpy (buf, startp, endp - startp);\n-\t      buf[endp - startp] = '\\0';\n-\n-\t      {  \n-\t\tDIR *dirp = NULL;\n-\t\tint dirname_length = strlen (buf);\n-\t\t\n-\t\tdirp = opendir (buf);\n-\t\tif (dirp == NULL)\n-\t\t  return;\n-\t\t\n-\t\tfor (;;)\n-\t\t  {\n-\t\t    struct dirent *direntp = readdir (dirp);\n-\t\t    \n-\t\t    if (!direntp)\n-\t\t      break;\n-\t\t    \n-\t\t    if (direntp->d_name[0] != '.')\n-\t\t      {\n-\t\t\tchar *name = (char *) alloca (dirname_length\n-\t\t\t\t\t     + strlen (direntp->d_name) + 2);\n-\t\t\tstrcpy (name, buf);\n-\t\t\tif (! IS_DIR_SEPARATOR (name[dirname_length-1]))\n-\t\t\t  {\n-\t\t\t    name[dirname_length] = DIR_SEPARATOR;\n-\t\t\t    name[dirname_length+1] = 0;\n-\t\t\t  }\n-\t\t\tstrcat (name, direntp->d_name);\n-\t\t\tadd_entry (&extensions, name, 0);\n-\t\t      }\n-\t\t  }\n-\t\tif (dirp)\n-\t\t  closedir (dirp);\n-\t      }\n-\n-\t      if (! *endp)\n-\t\tbreak;\n-\t      ++endp;\n-\t      startp = endp;\n-\t    }\n-\t  else\n-\t    ++endp;\n-\t}\n-    }\n-}\n-\n-/* Call this when -I is seen on the command line.  */\n-void\n-jcf_path_include_arg (const char *path)\n-{\n-  add_entry (&include_dirs, path, 0);\n-}\n-\n-/* We `seal' the path by linking everything into one big list.  Then\n-   we provide a way to iterate through the sealed list.  If PRINT is\n-   true then we print the final class path to stderr.  */\n-void\n-jcf_path_seal (int print)\n-{\n-  struct entry *secondary;\n-\n-  sealed = include_dirs;\n-  include_dirs = NULL;\n-\n-  if (classpath_user)\n-    {\n-      secondary = classpath_user;\n-      classpath_user = NULL;\n-    }\n-  else\n-    {\n-      if (! classpath_env)\n-\tadd_entry (&classpath_env, \".\", 0);\n-\n-      secondary = classpath_env;\n-      classpath_env = NULL;\n-    }\n-\n-\n-  free_entry (&classpath_user);\n-  free_entry (&classpath_env);\n-\n-  append_entry (&sealed, secondary);\n-  append_entry (&sealed, sys_dirs);\n-  append_entry (&sealed, extensions);\n-  sys_dirs = NULL;\n-  extensions = NULL;\n-\n-  if (print)\n-    {\n-      struct entry *ent;\n-      fprintf (stderr, \"Class path starts here:\\n\");\n-      for (ent = sealed; ent; ent = ent->next)\n-\t{\n-\t  fprintf (stderr, \"    %s\", ent->name);\n-\t  if ((ent->flags & FLAG_SYSTEM))\n-\t    fprintf (stderr, \" (system)\");\n-\t  if ((ent->flags & FLAG_ZIP))\n-\t    fprintf (stderr, \" (zip)\");\n-\t  fprintf (stderr, \"\\n\");\n-\t}\n-    }\n-}\n-\n-void *\n-jcf_path_start (void)\n-{\n-  return (void *) sealed;\n-}\n-\n-void *\n-jcf_path_next (void *x)\n-{\n-  struct entry *ent = (struct entry *) x;\n-  return (void *) ent->next;\n-}\n-\n-static const char\n-PATH_SEPARATOR_STR[] = {PATH_SEPARATOR, '\\0'};\n-\n-char *\n-jcf_path_compute (const char *prefix)\n-{\n-  struct entry *iter;\n-  char *result;\n-  int length = strlen (prefix) + 1;\n-  int first;\n-\n-  for (iter = sealed; iter != NULL; iter = iter->next)\n-    length += strlen (iter->name) + 1;\n-\n-  result = (char *) xmalloc (length);\n-  strcpy (result, prefix);\n-  first = 1;\n-  for (iter = sealed; iter != NULL; iter = iter->next)\n-    {\n-      if (! first)\n-\tstrcat (result, PATH_SEPARATOR_STR);\n-      first = 0;\n-      strcat (result, iter->name);\n-      /* Ugly: we want to strip the '/' from zip entries when\n-\t computing a string classpath.  */\n-      if ((iter->flags & FLAG_ZIP) != 0)\n-\tresult[strlen (result) - 1] = '\\0';\n-    }\n-\n-  return result;\n-}\n-\n-/* We guarantee that the return path will either be a zip file, or it\n-   will end with a directory separator.  */\n-char *\n-jcf_path_name (void *x)\n-{\n-  struct entry *ent = (struct entry *) x;\n-  return ent->name;\n-}\n-\n-int\n-jcf_path_is_zipfile (void *x)\n-{\n-  struct entry *ent = (struct entry *) x;\n-  return (ent->flags & FLAG_ZIP);\n-}\n-\n-int\n-jcf_path_is_system (void *x)\n-{\n-  struct entry *ent = (struct entry *) x;\n-  return (ent->flags & FLAG_SYSTEM);\n-}\n-\n-int\n-jcf_path_max_len (void)\n-{\n-  return longest_path;\n-}"}, {"sha": "27bf9b4dde21f76afce83294b38fbadfdb3bef1e", "filename": "gcc/java/jcf-reader.c", "status": "removed", "additions": 0, "deletions": 575, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,575 +0,0 @@\n-/* This file read a Java(TM) .class file.\n-   It is not stand-alone:  It depends on tons of macros, and the\n-   intent is you #include this file after you've defined the macros.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#include \"jcf.h\"\n-#include \"zipfile.h\"\n-\n-static int get_attribute (JCF *, int, jv_attr_type);\n-static int jcf_parse_preamble (JCF *);\n-static int jcf_parse_constant_pool (JCF *);\n-static void jcf_parse_class (JCF *);\n-static int jcf_parse_fields (JCF *);\n-static int jcf_parse_one_method (JCF *, int);\n-static int jcf_parse_methods (JCF *);\n-static int jcf_parse_final_attributes (JCF *);\n-static int jcf_parse_bootstrap_methods (JCF *, int) ATTRIBUTE_UNUSED;\n-#ifdef NEED_PEEK_ATTRIBUTE\n-static int peek_attribute (JCF *, int, const char *, int);\n-#endif\n-#ifdef NEED_SKIP_ATTRIBUTE\n-static void skip_attribute (JCF *, int);\n-#endif\n-\n-/* Go through all available attribute (ATTRIBUTE_NUMER) and try to\n-   identify PEEKED_NAME.  Return 1 if PEEKED_NAME was found, 0\n-   otherwise. JCF is restored to its initial position before\n-   returning.  */\n-\n-#ifdef NEED_PEEK_ATTRIBUTE\t/* Not everyone uses this function */\n-static int\n-peek_attribute (JCF *jcf, int attribute_number, const char *peeked_name,\n-\t\tint peeked_name_length)\n-{\n-  int to_return = 0;\n-  long absolute_offset = (long)JCF_TELL (jcf);\n-  int i;\n-\n-  for (i = 0; !to_return && i < attribute_number; i++)\n-    {\n-      uint16 attribute_name = (JCF_FILL (jcf, 6), JCF_readu2 (jcf));\n-      uint32 attribute_length = JCF_readu4 (jcf);\n-      int name_length;\n-      const unsigned char *name_data; \n-\n-      JCF_FILL (jcf, (long) attribute_length);\n-      if (attribute_name <= 0 || attribute_name >= JPOOL_SIZE(jcf)\n-\t  || JPOOL_TAG (jcf, attribute_name) != CONSTANT_Utf8)\n-\tcontinue;\n-\n-      name_length = JPOOL_UTF_LENGTH (jcf, attribute_name);\n-      name_data = JPOOL_UTF_DATA (jcf, attribute_name);\n-\n-      if (name_length == peeked_name_length \n-\t  && ! memcmp (name_data, peeked_name, peeked_name_length)) \n-\t{\n-\t  to_return = 1; \n-\t  break;\n-\t}\n-      \n-      JCF_SKIP (jcf, attribute_length);\n-    }\n-\n-  JCF_SEEK (jcf, absolute_offset);\n-  return to_return;\n-}\n-#endif\n-\n-#ifdef NEED_SKIP_ATTRIBUTE\t/* Not everyone uses this function */\n-static void\n-skip_attribute (JCF *jcf, int number_of_attribute)\n-{\n-  while (number_of_attribute--)\n-    {\n-      JCF_u4 N;\n-      JCF_FILL (jcf, 6);\n-      (void) JCF_readu2 (jcf);\n-      N = JCF_readu4 (jcf);\n-      JCF_SKIP (jcf, N);\n-    }\n-}\n-#endif\n-\n-static int\n-get_attribute (JCF *jcf, int index, \n-\t       jv_attr_type attr_type ATTRIBUTE_UNUSED)\n-{\n-  uint16 attribute_name = (JCF_FILL (jcf, 6), JCF_readu2 (jcf));\n-  uint32 attribute_length = JCF_readu4 (jcf);\n-  uint32 start_pos = JCF_TELL(jcf);\n-  int name_length;\n-  const unsigned char *name_data;\n-  JCF_FILL (jcf, (long) attribute_length);\n-  if (attribute_name <= 0 || attribute_name >= JPOOL_SIZE(jcf))\n-    return -2;\n-  if (JPOOL_TAG (jcf, attribute_name) != CONSTANT_Utf8)\n-    return -2;\n-  name_length = JPOOL_UTF_LENGTH (jcf, attribute_name);\n-  name_data = JPOOL_UTF_DATA (jcf, attribute_name);\n-\n-#define MATCH_ATTRIBUTE(S) \\\n-  (name_length == sizeof (S)-1 && memcmp (name_data, S, sizeof (S)-1) == 0)\n-\n-#ifdef IGNORE_ATTRIBUTE\n-   if (IGNORE_ATTRIBUTE (jcf, attribute_name, attribute_length))\n-     {\n-       JCF_SKIP (jcf, attribute_length);\n-     }\n-   else\n-#endif\n-#ifdef HANDLE_SOURCEFILE\n-  if (MATCH_ATTRIBUTE (\"SourceFile\"))\n-    {\n-      uint16 sourcefile_index = JCF_readu2 (jcf);\n-      HANDLE_SOURCEFILE(sourcefile_index);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_CONSTANTVALUE\n-  if (MATCH_ATTRIBUTE (\"ConstantValue\"))\n-    {\n-      uint16 constantvalue_index = JCF_readu2 (jcf);\n-      if (constantvalue_index <= 0 || constantvalue_index >= JPOOL_SIZE(jcf))\n-\treturn -2;\n-      HANDLE_CONSTANTVALUE(constantvalue_index);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_CODE_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"Code\"))\n-    {\n-      uint16 j;\n-      uint16 max_stack ATTRIBUTE_UNUSED = JCF_readu2 (jcf);\n-      uint16 max_locals ATTRIBUTE_UNUSED = JCF_readu2 (jcf);\n-      uint32 code_length = JCF_readu4 (jcf);\n-      uint16 exception_table_length, attributes_count;\n-      if (code_length + 12 > attribute_length)\n-\treturn -1;\n-      HANDLE_CODE_ATTRIBUTE(max_stack, max_locals, code_length);\n-      JCF_SKIP (jcf, code_length);\n-      exception_table_length = JCF_readu2 (jcf);\n-      if (code_length + 8 * exception_table_length + 12 > attribute_length)\n-\treturn -1;\n-#ifdef HANDLE_EXCEPTION_TABLE\n-      HANDLE_EXCEPTION_TABLE (jcf->read_ptr, exception_table_length);\n-#endif\n-      JCF_SKIP (jcf, 2 * 4 * exception_table_length);\n-      attributes_count = JCF_readu2 (jcf);\n-      for (j = 0; j < attributes_count; j++)\n-\t{\n-\t  int code = get_attribute (jcf, index, JV_METHOD_ATTR);\n-\t  if (code != 0)\n-\t    return code;\n-\t}\n-    }\n-  else\n-#endif /* HANDLE_CODE_ATTRIBUTE */\n-#ifdef HANDLE_EXCEPTIONS_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"Exceptions\"))\n-    {\n-      uint16 count = JCF_readu2 (jcf);\n-      HANDLE_EXCEPTIONS_ATTRIBUTE (count);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_LINENUMBERTABLE_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"LineNumberTable\"))\n-    {\n-      uint16 count = JCF_readu2 (jcf);\n-      HANDLE_LINENUMBERTABLE_ATTRIBUTE (count);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_LOCALVARIABLETABLE_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"LocalVariableTable\"))\n-    {\n-      uint16 count = JCF_readu2 (jcf);\n-      HANDLE_LOCALVARIABLETABLE_ATTRIBUTE (count);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_LOCALVARIABLETYPETABLE_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"LocalVariableTypeTable\"))\n-    {\n-      uint16 count = JCF_readu2 (jcf);\n-      HANDLE_LOCALVARIABLETYPETABLE_ATTRIBUTE (count);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_INNERCLASSES_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"InnerClasses\"))\n-    {\n-      uint16 count = JCF_readu2 (jcf);\n-      HANDLE_INNERCLASSES_ATTRIBUTE (count);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_SYNTHETIC_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"Synthetic\"))\n-    {\n-      HANDLE_SYNTHETIC_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_GCJCOMPILED_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"gnu.gcj.gcj-compiled\"))\n-    {\n-      HANDLE_GCJCOMPILED_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_DEPRECATED_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"Deprecated\"))\n-    {\n-      HANDLE_DEPRECATED_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_SOURCEDEBUGEXTENSION_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"SourceDebugExtension\")) /* JSR 45 */\n-    {\n-      HANDLE_SOURCEDEBUGEXTENSION_ATTRIBUTE (attribute_length);\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_ENCLOSINGMETHOD_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"EnclosingMethod\"))\n-    {\n-      HANDLE_ENCLOSINGMETHOD_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_SIGNATURE_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"Signature\"))\n-    {\n-      HANDLE_SIGNATURE_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_RUNTIMEVISIBLEANNOTATIONS_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"RuntimeVisibleAnnotations\"))\n-    {\n-      HANDLE_RUNTIMEVISIBLEANNOTATIONS_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_RUNTIMEINVISIBLEANNOTATIONS_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"RuntimeInvisibleAnnotations\"))\n-    {\n-      HANDLE_RUNTIMEINVISIBLEANNOTATIONS_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_RUNTIMEVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"RuntimeVisibleParameterAnnotations\"))\n-    {\n-      HANDLE_RUNTIMEVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_RUNTIMEINVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"RuntimeInvisibleParameterAnnotations\"))\n-    {\n-      HANDLE_RUNTIMEINVISIBLEPARAMETERANNOTATIONS_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-#ifdef HANDLE_ANNOTATIONDEFAULT_ATTRIBUTE\n-  if (MATCH_ATTRIBUTE (\"AnnotationDefault\"))\n-    {\n-      HANDLE_ANNOTATIONDEFAULT_ATTRIBUTE ();\n-    }\n-  else\n-#endif\n-  if (MATCH_ATTRIBUTE (\"BootstrapMethods\"))\n-    {\n-#ifdef HANDLE_BOOTSTRAP_METHODS_ATTRIBUTE\n-      HANDLE_BOOTSTRAP_METHODS_ATTRIBUTE();\n-#else\n-      JCF_SKIP (jcf, attribute_length);\n-#endif\n-    }\n-   else\n-    {\n-#ifdef PROCESS_OTHER_ATTRIBUTE\n-      PROCESS_OTHER_ATTRIBUTE(jcf, attribute_name, attribute_length);\n-#else\n-      JCF_SKIP (jcf, attribute_length);\n-#endif\n-    }\n-  if ((long) (start_pos + attribute_length) != JCF_TELL(jcf))\n-    return -1;\n-  return 0;\n-}\n-\n-/* Read and handle the pre-amble. */\n-static int\n-jcf_parse_preamble (JCF* jcf)\n-{\n-  uint32 magic = (JCF_FILL (jcf, 8), JCF_readu4 (jcf));\n-  uint16 minor_version ATTRIBUTE_UNUSED = JCF_readu2 (jcf);\n-  uint16 major_version ATTRIBUTE_UNUSED = JCF_readu2 (jcf);\n-#ifdef HANDLE_MAGIC\n-  HANDLE_MAGIC (magic, minor_version, major_version);\n-#endif\n-  if (magic != 0xcafebabe)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Read and handle the constant pool.\n-\n-   Return 0 if OK.\n-   Return -2 if a bad cross-reference (index of other constant) was seen.\n-*/\n-static int\n-jcf_parse_constant_pool (JCF* jcf)\n-{\n-  int i, n;\n-  JPOOL_SIZE (jcf) = (JCF_FILL (jcf, 2), JCF_readu2 (jcf));\n-  jcf->cpool.tags = (uint8 *) ggc_alloc_atomic (JPOOL_SIZE (jcf));\n-  jcf->cpool.data = (cpool_entry *) ggc_internal_cleared_alloc\n-    (sizeof (jword) * JPOOL_SIZE (jcf));\n-  jcf->cpool.tags[0] = 0;\n-#ifdef HANDLE_START_CONSTANT_POOL\n-  HANDLE_START_CONSTANT_POOL (JPOOL_SIZE (jcf));\n-#endif\n-  for (i = 1; i < (int) JPOOL_SIZE (jcf); i++)\n-    {\n-      int constant_kind;\n-       \n-      /* Make sure at least 9 bytes are available.  This is enough\n-\t for all fixed-sized constant pool entries (so we don't need many\n-\t more JCF_FILL calls below), but is small enough that\n-\t we are guaranteed to not hit EOF (in a valid .class file). */\n-      JCF_FILL (jcf, 9);\n-      constant_kind = JCF_readu (jcf);\n-      jcf->cpool.tags[i] = constant_kind;\n-      switch (constant_kind)\n-\t{\n-\tcase CONSTANT_String:\n-\tcase CONSTANT_Class:\n-\t  jcf->cpool.data[i].w = JCF_readu2 (jcf);\n-\t  break;\n-\tcase CONSTANT_Fieldref:\n-\tcase CONSTANT_Methodref:\n-\tcase CONSTANT_InterfaceMethodref:\n-\tcase CONSTANT_NameAndType:\n-\t  jcf->cpool.data[i].w = JCF_readu2 (jcf);\n-\t  jcf->cpool.data[i].w |= JCF_readu2 (jcf) << 16;\n-\t  break;\n-\tcase CONSTANT_Integer:\n-\tcase CONSTANT_Float:\n-\t  jcf->cpool.data[i].w = JCF_readu4 (jcf);\n-\t  break;\n-\tcase CONSTANT_Long:\n-\tcase CONSTANT_Double:\n-\t  jcf->cpool.data[i].w = JCF_readu4 (jcf);\n-\t  i++; /* These take up two spots in the constant pool */\n-\t  jcf->cpool.tags[i] = 0;\n-\t  jcf->cpool.data[i].w = JCF_readu4 (jcf);\n-\t  break;\n-\tcase CONSTANT_Utf8:\n-\t  n = JCF_readu2 (jcf);\n-\t  JCF_FILL (jcf, n);\n-#ifdef HANDLE_CONSTANT_Utf8\n-\t  HANDLE_CONSTANT_Utf8(jcf, i, n);\n-#else\n-\t  jcf->cpool.data[i].w = JCF_TELL(jcf) - 2;\n-\t  JCF_SKIP (jcf, n);\n-#endif\n-\t  break;\n-\tcase CONSTANT_MethodHandle:\n-\t  jcf->cpool.data[i].w = JCF_readu (jcf);\n-\t  jcf->cpool.data[i].w |= JCF_readu2 (jcf) << 16;\n-\t  break;\n-\tcase CONSTANT_MethodType:\n-\t  jcf->cpool.data[i].w = JCF_readu2 (jcf);\n-\t  break;\n-\tcase CONSTANT_InvokeDynamic:\n-\t  jcf->cpool.data[i].w = JCF_readu2 (jcf);\n-\t  jcf->cpool.data[i].w |= JCF_readu2 (jcf) << 16;\n-\t  break;\n-\tdefault:\n-\t  return i;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-/* Read various class flags and numbers. */\n-\n-static void\n-jcf_parse_class (JCF* jcf)\n-{\n-  int i;\n-  uint16 interfaces_count;\n-  JCF_FILL (jcf, 8);\n-  jcf->access_flags = JCF_readu2 (jcf);\n-  jcf->this_class = JCF_readu2 (jcf);\n-  jcf->super_class = JCF_readu2 (jcf);\n-  interfaces_count = JCF_readu2 (jcf);\n-\n-#ifdef HANDLE_CLASS_INFO\n-  HANDLE_CLASS_INFO(jcf->access_flags, jcf->this_class, jcf->super_class, interfaces_count);\n-#endif\n-\n-  JCF_FILL (jcf, 2 * interfaces_count);\n-\n-  /* Read interfaces. */\n-  for (i = 0; i < interfaces_count; i++)\n-    {\n-      uint16 index ATTRIBUTE_UNUSED = JCF_readu2 (jcf);\n-#ifdef HANDLE_CLASS_INTERFACE\n-      HANDLE_CLASS_INTERFACE (index);\n-#endif\n-    }\n-}\n-\n-/* Read fields. */\n-static int\n-jcf_parse_fields (JCF* jcf)\n-{\n-  int i, j;\n-  uint16 fields_count;\n-  JCF_FILL (jcf, 2);\n-  fields_count = JCF_readu2 (jcf);\n-\n-#ifdef HANDLE_START_FIELDS\n-  HANDLE_START_FIELDS (fields_count);\n-#endif\n-  for (i = 0; i < fields_count; i++)\n-    {\n-      uint16 access_flags = (JCF_FILL (jcf, 8), JCF_readu2 (jcf));\n-      uint16 name_index = JCF_readu2 (jcf);\n-      uint16 signature_index = JCF_readu2 (jcf);\n-      uint16 attribute_count = JCF_readu2 (jcf);\n-#ifdef HANDLE_START_FIELD\n-      HANDLE_START_FIELD (access_flags, name_index, signature_index,\n-\t\t\t  attribute_count);\n-#endif\n-      for (j = 0; j < attribute_count; j++)\n-\t{\n-\t  int code = get_attribute (jcf, i, JV_FIELD_ATTR);\n-\t  if (code != 0)\n-\t    return code;\n-\t}\n-#ifdef HANDLE_END_FIELD\n-      HANDLE_END_FIELD ();\n-#endif\n-    }\n-#ifdef HANDLE_END_FIELDS\n-  HANDLE_END_FIELDS ();\n-#endif\n-  return 0;\n-}\n-\n-/* Read methods. */\n-\n-static int\n-jcf_parse_one_method (JCF* jcf, int index)\n-{\n-  int i;\n-  uint16 access_flags = (JCF_FILL (jcf, 8), JCF_readu2 (jcf));\n-  uint16 name_index = JCF_readu2 (jcf);\n-  uint16 signature_index = JCF_readu2 (jcf);\n-  uint16 attribute_count = JCF_readu2 (jcf);\n-#ifdef HANDLE_METHOD\n-  HANDLE_METHOD(access_flags, name_index, signature_index, attribute_count);\n-#endif\n-  for (i = 0; i < attribute_count; i++)\n-    {\n-      int code = get_attribute (jcf, index, JV_METHOD_ATTR);\n-      if (code != 0)\n-\treturn code;\n-    }\n-#ifdef HANDLE_END_METHOD\n-  HANDLE_END_METHOD ();\n-#endif\n-  return 0;\n-}\n-\n-static int\n-jcf_parse_methods (JCF* jcf)\n-{\n-  int i;\n-  uint16 methods_count;\n-  JCF_FILL (jcf, 2);\n-  methods_count = JCF_readu2 (jcf);\n-#ifdef HANDLE_START_METHODS\n-  HANDLE_START_METHODS (methods_count);\n-#endif\n-  for (i = 0; i < methods_count; i++)\n-    {\n-      int code = jcf_parse_one_method (jcf, i);\n-      if (code != 0)\n-\treturn code;\n-    }\n-#ifdef HANDLE_END_METHODS\n-  HANDLE_END_METHODS ();\n-#endif\n-  return 0;\n-}\n-\n-/* Read attributes. */\n-static int\n-jcf_parse_final_attributes (JCF *jcf)\n-{\n-  int i;\n-  uint16 attributes_count = (JCF_FILL (jcf, 2), JCF_readu2 (jcf));\n-#ifdef START_FINAL_ATTRIBUTES\n-  START_FINAL_ATTRIBUTES (attributes_count)\n-#endif\n-  for (i = 0; i < attributes_count; i++)\n-    {\n-      int code = get_attribute (jcf, i, JV_CLASS_ATTR);\n-      if (code != 0)\n-\treturn code;\n-    }\n-  return 0;\n-}\n-\n-/* Read and handle the \"BootstrapMethods\" attribute.\n-\n-   Return 0 if OK.\n-*/\n-static int\n-jcf_parse_bootstrap_methods (JCF* jcf, int attribute_length ATTRIBUTE_UNUSED)\n-{\n-  int i;\n-  uint16 num_methods = JCF_readu2 (jcf);\n-  jcf->bootstrap_methods.count = num_methods;\n-  jcf->bootstrap_methods.methods = ggc_vec_alloc<bootstrap_method> (num_methods);\n-#ifdef HANDLE_START_BOOTSTRAP_METHODS\n-  HANDLE_START_BOOTSTRAP_METHODS (jcf, num_methods);\n-#endif\n-\n-  for (i = 0; i < num_methods; i++)\n-    {\n-      unsigned j;\n-      bootstrap_method *m = &jcf->bootstrap_methods.methods[i];\n-      m->method_ref = JCF_readu2 (jcf);\n-      m->num_arguments = JCF_readu2 (jcf);\n-      m->bootstrap_arguments = ggc_vec_alloc<unsigned> (m->num_arguments);\n-      for (j = 0; j < m->num_arguments; j++)\n-\tm->bootstrap_arguments[j] = JCF_readu2 (jcf);\n-    }\n-\n-#ifdef HANDLE_END_BOOTSTRAP_METHODS\n-  HANDLE_END_BOOTSTRAP_METHODS (num_methods);\n-#endif\n-\n-  return 0;\n-}"}, {"sha": "f14b2388db023a5517bd95ab105296fc9ad22425", "filename": "gcc/java/jcf.h", "status": "removed", "additions": 0, "deletions": 325, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,325 +0,0 @@\n-/* Utility macros to read Java(TM) .class files and byte codes.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Per Bothner <bothner@cygnus.com>, February 1996. */\n-\n-#ifndef GCC_JCF_H\n-#define GCC_JCF_H\n-#include \"javaop.h\"\n-\n-#ifndef JCF_u4\n-#define JCF_u4 unsigned long\n-#endif\n-#ifndef JCF_u2\n-#define JCF_u2 unsigned short\n-#endif\n-\n-#define ALLOC xmalloc\n-#define REALLOC xrealloc\n-#ifndef FREE\n-#define FREE(PTR) free(PTR)\n-#endif\n-\n-#ifdef JCF_word\n-#define JCF_word JCF_u4\n-#endif\n-\n-/* On case-insensitive file systems, we need to ensure that a request\n-   to open a .java or .class file is honored only if the file to be\n-   opened is of the exact case we are asking for. In other words, we\n-   want to override the inherent case insensitivity of the underlying\n-   file system. On other platforms, this macro becomes the vanilla\n-   open() call.\n-\n-   If you want to add another host, add your define to the list below\n-   (i.e. defined(WIN32) || defined(YOUR_HOST)) and add a host-specific\n-   .c file to Make-lang.in similar to win32-host.c.  */\n-#if defined(WIN32)\n-extern int\n-jcf_open_exact_case (const char* filename, int oflag);\n-#define JCF_OPEN_EXACT_CASE(X, Y) jcf_open_exact_case (X, Y)\n-#else\n-#define JCF_OPEN_EXACT_CASE open\n-#endif /* WIN32 */\n-\n-struct JCF;\n-typedef int (*jcf_filbuf_t) (struct JCF*, int needed);\n-\n-union GTY(()) cpool_entry {\n-  jword GTY ((tag (\"0\"))) w;\n-  tree GTY ((tag (\"1\"))) t;\n-};\n-\n-#define cpool_entry_is_tree(tag) \\\n-  (tag & CONSTANT_ResolvedFlag) || tag == CONSTANT_Utf8\n-\n-typedef struct GTY(()) CPool {\n-  /* Available number of elements in the constants array, before it\n-     must be re-allocated. */\n-  int capacity;\n-\n-  /* The constant_pool_count. */\n-  int\t\tcount;\n-\n-  uint8 * GTY((atomic)) tags;\n-\n-  union cpool_entry * GTY((length (\"%h.count\"),\n-\t\t\t   desc (\"cpool_entry_is_tree (%1.tags%a)\")))\tdata;\n-} CPool;\n-\n-typedef struct GTY(()) bootstrap_method {\n-  unsigned method_ref;\n-  unsigned num_arguments;\n-  unsigned * GTY((atomic)) bootstrap_arguments;\n-} bootstrap_method;\n-\n-typedef struct GTY(()) BootstrapMethods {\n-  unsigned count;\n-  bootstrap_method* GTY((length (\"%h.count\"))) methods;\n-} BootstrapMethods;\n-\n-struct ZipDirectory;\n-\n-/* JCF encapsulates the state of reading a Java Class File. */\n-\n-typedef struct GTY(()) JCF {\n-  unsigned char * GTY ((skip)) buffer;\n-  unsigned char * GTY ((skip)) buffer_end;\n-  unsigned char * GTY ((skip)) read_ptr;\n-  unsigned char * GTY ((skip)) read_end;\n-  unsigned int right_zip : 1;\n-  unsigned int finished : 1;\n-  jcf_filbuf_t filbuf;\n-  PTR GTY ((skip)) read_state;\n-  const char *filename;\n-  const char *classname;\n-  /* Directory entry where it was found.  */\n-  struct ZipDirectory * GTY ((skip)) zipd;\n-  JCF_u2 access_flags;\n-  JCF_u2 this_class;\n-  JCF_u2 super_class;\n-  CPool cpool;\n-  BootstrapMethods bootstrap_methods;\n-} JCF;\n-/*typedef JCF*  JCF_FILE;*/\n-\n-#define JCF_SEEN_IN_ZIP(JCF) ((JCF)->zipd != NULL)\n-\n-/* The CPOOL macros take a (pointer to a) CPool.\n-   The JPOOL macros take a (pointer to a) JCF.\n-   Some of the latter should perhaps be deprecated or removed. */\n-\n-#define CPOOL_COUNT(CPOOL) ((CPOOL)->count)\n-#define JPOOL_SIZE(JCF) CPOOL_COUNT(&(JCF)->cpool)\n-#define JPOOL_TAG(JCF, INDEX) ((JCF)->cpool.tags[INDEX])\n-/* The INDEX'th constant pool entry as a JCF_u4. */\n-#define CPOOL_UINT(CPOOL, INDEX) ((CPOOL)->data[INDEX].w)\n-#define JPOOL_UINT(JCF, INDEX) CPOOL_UINT(&(JCF)->cpool, INDEX) /*deprecated*/\n-/* The first uint16 of the INDEX'th constant pool entry. */\n-#define CPOOL_USHORT1(CPOOL, INDEX) ((CPOOL)->data[INDEX].w & 0xFFFF)\n-#define JPOOL_USHORT1(JCF, INDEX) CPOOL_USHORT1(&(JCF)->cpool, INDEX)\n-/* The second uint16 of the INDEX'th constant pool entry. */\n-#define CPOOL_USHORT2(CPOOL, INDEX) ((CPOOL)->data[INDEX].w >> 16)\n-#define JPOOL_USHORT2(JCF, INDEX) CPOOL_USHORT2(&(JCF)->cpool, INDEX)\n-#define JPOOL_LONG(JCF, INDEX) \\\n-  WORDS_TO_LONG (JPOOL_UINT(JCF, INDEX), JPOOL_UINT(JCF, (INDEX)+1))\n-#define JPOOL_DOUBLE(JCF, INDEX) \\\n-  WORDS_TO_DOUBLE  (JPOOL_UINT(JCF, INDEX), JPOOL_UINT(JCF, (INDEX)+1))\n-#ifndef JPOOL_UTF_LENGTH\n-#define JPOOL_UTF_LENGTH(JCF, INDEX) \\\n-  GET_u2 ((JCF)->buffer+JPOOL_UINT(JCF, INDEX))\n-#endif\n-#ifndef JPOOL_UTF_DATA\n-#define JPOOL_UTF_DATA(JCF, INDEX) \\\n-  ((JCF)->buffer+JPOOL_UINT(JCF, INDEX)+2)\n-#endif\n-#define JPOOL_INT(JCF, INDEX) (WORD_TO_INT(JPOOL_UINT (JCF, INDEX)))\n-#define JPOOL_FLOAT(JCF, INDEX) WORD_TO_FLOAT (JPOOL_UINT (JCF, INDEX))\n-\n-#define CPOOL_INDEX_IN_RANGE(CPOOL, INDEX) \\\n- ((INDEX) > 0 && (INDEX) < CPOOL_COUNT(CPOOL))\n-\n-#define CPOOL_FINISH(CPOOL) {\t\t\t\\\n-    (CPOOL)->tags = 0;\t\t\t\t\\\n-    (CPOOL)->data = 0;\t\t\t\t\\\n-  }\n-\n-#define JCF_FINISH(JCF) { \\\n-  CPOOL_FINISH(&(JCF)->cpool); \\\n-  if ((JCF)->buffer) free ((JCF)->buffer); \\\n-  if ((JCF)->filename) free (CONST_CAST (char *, (JCF)->filename)); \\\n-  if ((JCF)->classname) free (CONST_CAST (char *, (JCF)->classname)); \\\n-  (JCF)->finished = 1; }\n-  \n-#define CPOOL_INIT(CPOOL) \\\n-  ((CPOOL)->capacity = 0, (CPOOL)->count = 0, (CPOOL)->tags = 0, (CPOOL)->data = 0)\n-\n-#define CPOOL_REINIT(CPOOL) ((CPOOL)->count = 0)\n-\n-#define JCF_ZERO(JCF)  \\\n-  ((JCF)->buffer = (JCF)->buffer_end = (JCF)->read_ptr = (JCF)->read_end = 0,\\\n-   (JCF)->read_state = 0, (JCF)->filename = (JCF)->classname = 0, \\\n-   CPOOL_INIT(&(JCF)->cpool), (JCF)->zipd = 0, \\\n-   (JCF)->finished = 0)\n-\n-/* Given that PTR points to a 2-byte unsigned integer in network\n-   (big-endian) byte-order, return that integer. */\n-#define GET_u2(PTR) (((PTR)[0] << 8) | ((PTR)[1]))\n-/* Like GET_u2, but for little-endian format. */\n-#define GET_u2_le(PTR) (((PTR)[1] << 8) | ((PTR)[0]))\n-\n-/* Given that PTR points to a 4-byte unsigned integer in network\n-   (big-endian) byte-order, return that integer. */\n-#define GET_u4(PTR) (((JCF_u4)(PTR)[0] << 24) | ((JCF_u4)(PTR)[1] << 16) \\\n-  | ((JCF_u4)(PTR)[2] << 8) | ((JCF_u4)(PTR)[3]))\n-/* Like GET_u4, but for little-endian order. */\n-#define GET_u4_le(PTR) (((JCF_u4)(PTR)[3] << 24) | ((JCF_u4)(PTR)[2] << 16) \\\n-  | ((JCF_u4)(PTR)[1] << 8) | ((JCF_u4)(PTR)[0]))\n-\n-/* Make sure there are COUNT bytes readable. */\n-#define JCF_FILL(JCF, COUNT) \\\n-  ((JCF)->read_end-(JCF)->read_ptr >= (COUNT) ? 0 : (*(JCF)->filbuf)(JCF, COUNT))\n-#define JCF_GETC(JCF) (JCF_FILL(JCF, 1) ? -1 : *(JCF)->read_ptr++)\n-#define JCF_READ(JCF, BUFFER, N) \\\n-    (memcpy (BUFFER, (JCF)->read_ptr, N), (JCF)->read_ptr += (N))\n-#define JCF_SKIP(JCF,N) ((JCF)->read_ptr += (N))\n-#define JCF_readu(JCF) (*(JCF)->read_ptr++)\n-\n-/* Reads an unsigned 2-byte integer in network (big-endian) byte-order\n-   from JCF.  Returns that integer.\n-   Does not check for EOF (make sure to call JCF_FILL before-hand). */\n-#define JCF_readu2(JCF) ((JCF)->read_ptr += 2, GET_u2 ((JCF)->read_ptr-2))\n-#define JCF_readu2_le(JCF) ((JCF)->read_ptr += 2, GET_u2_le((JCF)->read_ptr-2))\n-\n-/* Like JCF_readu2, but read a 4-byte unsigned integer. */\n-#define JCF_readu4(JCF) ((JCF)->read_ptr += 4, GET_u4 ((JCF)->read_ptr-4))\n-#define JCF_readu4_le(JCF) ((JCF)->read_ptr += 4, GET_u4_le((JCF)->read_ptr-4))\n-\n-#define JCF_TELL(JCF) ((JCF)->read_ptr - (JCF)->buffer)\n-#define JCF_SEEK(JCF, POS) ((JCF)->read_ptr = (JCF)->buffer + (POS))\n-\n-#define ACC_PUBLIC 0x0001\n-#define ACC_PRIVATE 0x0002\n-#define ACC_PROTECTED 0x0004\n-#define ACC_STATIC 0x0008\n-#define ACC_FINAL 0x0010\n-#define ACC_SYNCHRONIZED 0x0020\n-#define ACC_SUPER 0x0020\n-#define ACC_BRIDGE 0x0040\n-#define ACC_VOLATILE 0x0040\n-#define ACC_TRANSIENT 0x0080\n-#define ACC_VARARGS 0x0080\n-#define ACC_NATIVE 0x0100\n-#define ACC_INTERFACE 0x0200\n-#define ACC_ABSTRACT 0x0400\n-#define ACC_STRICT 0x0800\n-#define ACC_SYNTHETIC 0x01000\n-#define ACC_ANNOTATION 0x02000\n-#define ACC_ENUM 0x04000\n-/* \"Invisible\" refers to Miranda methods inserted into an abstract\n-   class.  It is also used in the runtime.  */\n-#define ACC_INVISIBLE 0x8000\n-\n-#define ACC_VISIBILITY (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)\n-\n-enum cpool_tag\n-{\n-  CONSTANT_Class = 7,\n-  CONSTANT_Fieldref = 9,\n-  CONSTANT_Methodref = 10,\n-  CONSTANT_InterfaceMethodref = 11,\n-  CONSTANT_String = 8,\n-  CONSTANT_Integer = 3,\n-  CONSTANT_Float = 4,\n-  CONSTANT_Long = 5,\n-  CONSTANT_Double = 6,\n-  CONSTANT_NameAndType = 12,\n-  CONSTANT_Utf8 = 1,\n-  CONSTANT_Unicode = 2,\n-  CONSTANT_MethodHandle = 15,\n-  CONSTANT_MethodType = 16,\n-  CONSTANT_InvokeDynamic = 18,\n-\n-  CONSTANT_None = 0\n-};\n-\n-#define DEFAULT_CLASS_PATH \".\"\n-\n-extern const char *find_class (const char *, int, JCF *);\n-extern const char *find_classfile (char *, JCF*, const char *);\n-extern int jcf_filbuf_from_stdio (JCF *jcf, int count);\n-extern int jcf_unexpected_eof (JCF*, int) ATTRIBUTE_NORETURN;\n-\n-/* Extract a character from a Java-style Utf8 string.\n- * PTR points to the current character.\n- * LIMIT points to the end of the Utf8 string.\n- * PTR is incremented to point after the character that gets returned.\n- * On an error, -1 is returned. */\n-#define UTF8_GET(PTR, LIMIT) \\\n-  ((PTR) >= (LIMIT) ? -1 \\\n-   : *(PTR) < 128 ? *(PTR)++ \\\n-   : (*(PTR)&0xE0) == 0xC0 && ((PTR)+=2)<=(LIMIT) && ((PTR)[-1]&0xC0) == 0x80 \\\n-   ? (((PTR)[-2] & 0x1F) << 6) + ((PTR)[-1] & 0x3F) \\\n-   : (*(PTR) & 0xF0) == 0xE0 && ((PTR) += 3) <= (LIMIT) \\\n-   && ((PTR)[-2] & 0xC0) == 0x80 && ((PTR)[-1] & 0xC0) == 0x80 \\\n-   ? (((PTR)[-3]&0x0F) << 12) + (((PTR)[-2]&0x3F) << 6) + ((PTR)[-1]&0x3F) \\\n-   : ((PTR)++, -1))\n-\n-extern const char *jcf_write_base_directory;\n-\n-/* Debug macros, for the front end */\n-\n-#ifdef VERBOSE_SKELETON\n-#undef SOURCE_FRONTEND_DEBUG\n-#define SOURCE_FRONTEND_DEBUG(X)\t\t\t\t\\\n-  {if (!quiet_flag) {printf (\"* \"); printf X; putchar ('\\n');} }\n-#else\n-#define SOURCE_FRONTEND_DEBUG(X)\n-#endif\n-\n-/* Declarations for dependency code.  */\n-extern void jcf_dependency_reset (void);\n-extern void jcf_dependency_set_target (const char *);\n-extern void jcf_dependency_add_target (const char *);\n-extern void jcf_dependency_set_dep_file (const char *);\n-extern void jcf_dependency_add_file (const char *, int);\n-extern void jcf_dependency_write (void);\n-extern void jcf_dependency_init (int);\n-extern void jcf_dependency_print_dummies (void);\n-\n-/* Declarations for path handling code.  */\n-extern void jcf_path_init (void);\n-extern void jcf_path_classpath_arg (const char *);\n-extern void jcf_path_bootclasspath_arg (const char *);\n-extern void jcf_path_extdirs_arg (const char *);\n-extern void jcf_path_include_arg (const char *);\n-extern void jcf_path_seal (int);\n-extern void *jcf_path_start (void);\n-extern void *jcf_path_next (void *);\n-extern char *jcf_path_name (void *);\n-extern char *jcf_path_compute (const char *);\n-extern int jcf_path_is_zipfile (void *);\n-extern int jcf_path_is_system (void *);\n-extern int jcf_path_max_len (void);\n-\n-#endif /* ! GCC_JCF_H */"}, {"sha": "a451c6e018a8a71bb964c143cb6c64db78d1ccaf", "filename": "gcc/java/jvgenmain.c", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,197 +0,0 @@\n-/* Program to generate \"main\" a Java(TM) class containing a main method.\n-   Copyright (C) 1998-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Per Bothner <bothner@cygnus.com> */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree.h\"\n-#include \"diagnostic.h\"\n-#include \"java-tree.h\"\n-#include \"intl.h\"\n-\n-static char * do_mangle_classname (const char *string);\n-\n-struct obstack  name_obstack;\n-struct obstack *mangle_obstack = &name_obstack;\n-\n-static void usage (const char *) ATTRIBUTE_NORETURN;\n-\n-static void\n-usage (const char *name)\n-{\n-  fprintf (stderr, _(\"Usage: %s [OPTIONS]... CLASSNAMEmain [OUTFILE]\\n\"),\n-\t   name);\n-  exit (1);\n-}\n-\n-int\n-main (int argc, char **argv)\n-{\n-  char *classname, *p;\n-  FILE *stream;\n-  const char *mangled_classname;\n-  int i, last_arg;\n-  int indirect = 0;\n-  char *prog_name = argv[0];\n-\n-  p = argv[0] + strlen (argv[0]);\n-  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))\n-    --p;\n-  progname = p;\n-\n-  xmalloc_set_program_name (progname);\n-\n-  /* Unlock the stdio streams.  */\n-  unlock_std_streams ();\n-\n-  gcc_init_libintl ();\n-\n-  diagnostic_initialize (global_dc, 0);\n-\n-  if (argc > 1 && ! strcmp (argv[1], \"-findirect-dispatch\"))\n-    {\n-      indirect = 1;\n-      ++argv;\n-      --argc;\n-    }\n-\n-  if (argc < 2)\n-    usage (prog_name);\n-\n-  for (i = 1; i < argc; ++i)\n-    {\n-      if (! strncmp (argv[i], \"-D\", 2))\n-\t{\n-\t  /* Handled later.  Check \"-D XXX=YYY\".  */\n-\t  if (argv[i][2] == '\\0')\n-\t    i++;\n-\t}\n-      else\n-\tbreak;\n-    }\n-\n-  if (i < argc - 2 || i == argc)\n-    usage (prog_name);\n-  last_arg = i;\n-\n-  classname = argv[i];\n-\n-  /* gcj always appends `main' to classname.  We need to strip this here.  */\n-  p = strrchr (classname, 'm');\n-  if (p == NULL || p == classname || strcmp (p, \"main\") != 0)\n-    usage (prog_name);\n-  else\n-    *p = '\\0';\n-\n-  gcc_obstack_init (mangle_obstack);\n-  mangled_classname = do_mangle_classname (classname);\n-\n-  if (i < argc - 1 && strcmp (argv[i + 1], \"-\") != 0)\n-    {\n-      const char *outfile = argv[i + 1];\n-      stream = fopen (outfile, \"w\");\n-      if (stream == NULL)\n-\t{\n-\t  fprintf (stderr, _(\"%s: Cannot open output file: %s\\n\"),\n-\t\t   prog_name, outfile);\n-\t  exit (1);\n-\t}\n-    }\n-  else\n-    stream = stdout;\n-\n-  /* At this point every element of ARGV from 1 to LAST_ARG is a `-D'\n-     option.  Process them appropriately.  */\n-  fprintf (stream, \"extern const char **_Jv_Compiler_Properties;\\n\");\n-  if (indirect)\n-    fprintf (stream, \"extern void JvRunMainName ();\\n\");\n-  else\n-    fprintf (stream, \"extern void JvRunMain ();\\n\");\n-  fprintf (stream, \"static const char *props[] =\\n{\\n\");\n-  for (i = 1; i < last_arg; ++i)\n-    {\n-      const char *p;\n-\n-      if (strcmp (argv[i], \"-D\") == 0)\n-\tcontinue;\n-\n-      fprintf (stream, \"  \\\"\");\n-      for (p = argv[i]; *p; ++p)\n-\t{\n-\t  if (! ISPRINT (*p))\n-\t    fprintf (stream, \"\\\\%o\", *p);\n-\t  else if (*p == '\\\\' || *p == '\"')\n-\t    fprintf (stream, \"\\\\%c\", *p);\n-\t  else\n-\t    putc (*p, stream);\n-\t}\n-      fprintf (stream, \"\\\",\\n\");\n-    }\n-  fprintf (stream, \"  0\\n};\\n\\n\");\n-\n-  fprintf (stream, \"int main (int argc, const char **argv)\\n\");\n-  fprintf (stream, \"{\\n\");\n-  fprintf (stream, \"   _Jv_Compiler_Properties = props;\\n\");\n-  if (indirect)\n-    fprintf (stream, \"   JvRunMainName (\\\"%s\\\", argc, argv);\\n\", classname);\n-  else\n-    {\n-      fprintf (stream, \"   extern char %s;\\n\", mangled_classname);\n-      fprintf (stream, \"   JvRunMain (&%s, argc, argv);\\n\", mangled_classname);\n-    }\n-  fprintf (stream, \"}\\n\");\n-  if (stream != stdout && fclose (stream) != 0)\n-    {\n-      fprintf (stderr, _(\"%s: Failed to close output file %s\\n\"),\n-\t       prog_name, argv[2]);\n-      exit (1);\n-    }\n-  return 0;\n-}\n-\n-\n-static char *\n-do_mangle_classname (const char *string)\n-{\n-  const char *ptr;\n-  int count = 0;\n-\n-  obstack_grow (&name_obstack, \"_ZN\", 3);\n-\n-  for (ptr = string; *ptr; ptr++ )\n-    {\n-      if (*ptr == '.')\n-\t{\n-\t  append_gpp_mangled_name (ptr - count, count);\n-\t  count = 0;\n-\t}\n-      else\n-\tcount++;\n-    }\n-  append_gpp_mangled_name (&ptr [-count], count);\n-  obstack_grow (mangle_obstack, \"6class$E\", strlen (\"6class$E\"));\n-  obstack_1grow (mangle_obstack, '\\0');\n-  return XOBFINISH (mangle_obstack, char *);\n-}"}, {"sha": "6b138d4cce82b3ca30506464076adc1eb9b84aee", "filename": "gcc/java/jvspec.c", "status": "removed", "additions": 0, "deletions": 646, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,646 +0,0 @@\n-/* Specific flags and argument handling of the front-end of the \n-   GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"gcc.h\"\n-#include \"jcf.h\"\n-#include \"opts.h\"\n-\n-/* Name of spec file.  */\n-#define SPEC_FILE \"libgcj.spec\"\n-\n-/* This bit is set if we saw a `-xfoo' language specification.  */\n-#define LANGSPEC\t(1<<1)\n-/* True if this arg is a .java input file name. */\n-#define JAVA_FILE_ARG\t(1<<3)\n-/* True if this arg is a .class input file name. */\n-#define CLASS_FILE_ARG\t(1<<4)\n-/* True if this arg is a .zip or .jar input file name. */\n-#define ZIP_FILE_ARG\t(1<<5)\n-/* True if this arg is @FILE - where FILE contains a list of filenames. */\n-#define INDIRECT_FILE_ARG (1<<6)\n-/* True if this arg is a resource file.  */\n-#define RESOURCE_FILE_ARG (1<<7)\n-\n-static char *find_spec_file (const char *);\n-static int verify_class_name (const char *);\n-\n-static const char *main_class_name = NULL;\n-int lang_specific_extra_outfiles = 0;\n-\n-/* True if we should add -shared-libgcc to the command-line.  */\n-int shared_libgcc = 1;\n-\n-static const char jvgenmain_spec[] =\n-  \"jvgenmain %{findirect-dispatch} %{D*} %b %m.i |\\n\\\n-   cc1 %m.i %1 \\\n-\t\t   %{!Q:-quiet} -dumpbase %b.c %{d*} %{m*}\\\n-\t\t   %{g*} %{O*} %I \\\n-\t\t   %{v:-version} %{pg:-p} %{p}\\\n-\t\t   %<fbounds-check %<fno-bounds-check\\\n-\t\t   %<fassume-compiled* %<fno-assume-compiled*\\\n-\t\t   %<fcompile-resource* %<fassert %<fno-assert \\\n-\t\t   %<femit-class-file %<femit-class-files %<fencoding*\\\n-\t\t   %<fuse-boehm-gc %<fhash-synchronization %<fjni\\\n-\t\t   %<findirect-dispatch\\\n-\t\t   %<fno-store-check %<foutput-class-dir\\\n-\t\t   %<fclasspath* %<fbootclasspath*\\\n-\t\t   %<fextdirs*\\\n-\t\t   %<fuse-divide-subroutine %<fno-use-divide-subroutine\\\n-\t\t   %<fuse-atomic-builtins %<fno-use-atomic-builtins\\\n-\t\t   %<fcheck-references %<fno-check-references\\\n-\t\t   %<ffilelist-file %<fsaw-java-file %<fsource* %<ftarget*\\\n-\t\t   %{f*} -fdollars-in-identifiers\\\n-\t\t   %{aux-info*}\\\n-\t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n-\t\t   %{S:%W{o*}%{!o*:-o %b.s}}\\\n-   %(invoke_as)\";\n-\n-/* Return full path name of spec file if it is in DIR, or NULL if\n-   not.  */\n-static char *\n-find_spec_file (const char *dir)\n-{\n-  char *spec;\n-  struct stat sb;\n-\n-  spec = XNEWVEC (char, strlen (dir) + sizeof (SPEC_FILE) + 4);\n-  strcpy (spec, dir);\n-  strcat (spec, \"/\");\n-  strcat (spec, SPEC_FILE);\n-  if (! stat (spec, &sb))\n-    return spec;\n-  free (spec);\n-  return NULL;\n-}\n-\n-#define JAVA_START_CHAR_P(c) (c < 128 && (ISIDST (c) || c == '$'))\n-#define JAVA_PART_CHAR_P(c) (c < 128\t\t\t\t\t      \\\n-\t\t\t     && (ISIDNUM (c)\t\t\t\t      \\\n-\t\t\t\t || c == '$'\t\t\t\t      \\\n-\t\t\t\t || (c >= 0x00 && c <= 0x08)\t\t      \\\n-\t\t\t\t || (c >= 0x0e && c <= 0x1b)\t\t      \\\n-\t\t\t\t || c == 0x7f))\n-\n-/* Verify that NAME is a valid Java class name that might contain\n-   `main'.  Return 0 on failure.  */\n-static int\n-verify_class_name (const char *name)\n-{\n-  /* FIXME: what encoding do we use for command-line arguments?  For\n-     now we assume plain ASCII, which of course is wrong.  */\n-  while (*name)\n-    {\n-      int ch = *name++;\n-      if (ch < 0 || ! JAVA_START_CHAR_P (ch))\n-\treturn 0;\n-      while (*name)\n-\t{\n-\t  ch = *name++;\n-\t  if (ch < 0)\n-\t    return 0;\n-\t  /* We found a break between class names.  Next character\n-\t     must be an identifier start again.  */\n-\t  if (ch == '.')\n-\t    break;\n-\t  if (! JAVA_PART_CHAR_P (ch))\n-\t    return 0;\n-\t}\n-    }\n-\n-  return 1;\n-}\n-\n-void\n-lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n-\t\t      unsigned int *in_decoded_options_count,\n-\t\t      int *in_added_libraries)\n-{\n-  unsigned int i, j;\n-\n-  int saw_save_temps = 0;\n-\n-  /* This will be 0 if we encounter a situation where we should not\n-     link in libgcj.  */\n-  int library = 1;\n-\n-  /* This will be 1 if multiple input files (.class and/or .java)\n-     should be passed to a single jc1 invocation. */\n-  int combine_inputs = 0;\n-\n-  /* Number of .java and .class source file arguments seen. */\n-  int java_files_count = 0;\n-  int class_files_count = 0;\n-  /* Number of .zip or .jar file arguments seen. */\n-  int zip_files_count = 0;\n-  /* Number of '@FILES' arguments seen. */\n-  int indirect_files_count = 0;\n-\n-  /* Name of file containing list of files to compile. */\n-  char *filelist_filename = 0;\n-\n-  FILE *filelist_file = 0;\n-\n-  /* The number of arguments being added to what's in argv, other than\n-     libraries.  */\n-  int added = 2;\n-\n-  /* The new argument list will be contained in this.  */\n-  struct cl_decoded_option *new_decoded_options;\n-\n-  /* Nonzero if we saw a `-xfoo' language specification on the\n-     command line.  Used to avoid adding our own -xc++ if the user\n-     already gave a language for the file.  */\n-  int saw_speclang = 0;\n-\n-  /* Saw --resource, -C or -o options, respectively. */\n-  int saw_resource = 0;\n-  int saw_C = 0;\n-  int saw_o = 0;\n-\n-  /* Saw some -O* or -g* option, respectively. */\n-  int saw_O = 0;\n-  int saw_g = 0;\n-\n-  /* Saw a `-D' option.  */\n-  int saw_D = 0;\n-\n-  /* An array used to flag each argument that needs a bit set for\n-     LANGSPEC, MATHLIB, WITHLIBC, or GCLIB.  */\n-  int *args;\n-\n-  /* The total number of arguments with the new stuff.  */\n-  unsigned int argc;\n-\n-  /* The argument list.  */\n-  struct cl_decoded_option *decoded_options;\n-\n-  /* The number of libraries added in.  */\n-  int added_libraries;\n-\n-  /* The total number of arguments with the new stuff.  */\n-  unsigned int num_args = 1;\n-\n-  /* Nonzero if linking is supposed to happen.  */\n-  int will_link = 1;\n-\n-  /* Nonzero if we want to find the spec file.  */\n-  int want_spec_file = 1;\n-\n-  /* The argument we use to specify the spec file.  */\n-  char *spec_file = NULL;\n-\n-  /* If linking, nonzero if the BC-ABI is in use.  */\n-  int link_for_bc_abi = 0;\n-\n-  argc = *in_decoded_options_count;\n-  decoded_options = *in_decoded_options;\n-  added_libraries = *in_added_libraries;\n-\n-  args = XCNEWVEC (int, argc);\n-\n-  for (i = 1; i < argc; i++)\n-    {\n-      switch (decoded_options[i].opt_index)\n-\t{\n-\tcase OPT_nostdlib:\n-\tcase OPT_nodefaultlibs:\n-\t  library = 0;\n-\t  break;\n-\n-\tcase OPT_fmain_:\n-\t  main_class_name = decoded_options[i].arg;\n-\t  added--;\n-\t  break;\n-\n-\tcase OPT__help:\n-\t  want_spec_file = 0;\n-\t  break;\n-\n-\tcase OPT_v:\n-\t  if (argc == 2)\n-\t    {\n-\t      /* If they only gave us `-v', don't try to link\n-\t\t in libgcj.  */ \n-\t      library = 0;\n-\t    }\n-\t  break;\n-\n-\tcase OPT_x:\n-\t  saw_speclang = 1;\n-\t  break;\n-\n-\tcase OPT_C:\n-\t  saw_C = 1;\n-\t  want_spec_file = 0;\n-\t  if (library != 0)\n-\t    added -= 2;\n-\t  library = 0;\n-\t  will_link = 0;\n-\t  break;\n-\n-\tcase OPT_fcompile_resource_:\n-\t  saw_resource = 1;\n-\t  want_spec_file = 0;\n-\t  if (library != 0)\n-\t    --added;\n-\t  library = 0;\n-\t  will_link = 0;\n-\t  break;\n-\n-\tcase OPT_D:\n-\t  saw_D = 1;\n-\t  break;\n-\n-\tcase OPT_g:\n-\tcase OPT_gcoff:\n-\tcase OPT_gdwarf_:\n-\tcase OPT_ggdb:\n-\tcase OPT_gstabs:\n-\tcase OPT_gstabs_:\n-\tcase OPT_gvms:\n-\tcase OPT_gxcoff:\n-\tcase OPT_gxcoff_:\n-\t  saw_g = 1;\n-\t  break;\n-\n-\tcase OPT_O:\n-\tcase OPT_Os:\n-\tcase OPT_Ofast:\n-\t  saw_O = 1;\n-\t  break;\n-\n-\tcase OPT_o:\n-\t  saw_o = 1;\n-\t  break;\n-\n-\tcase OPT_fclasspath_:\n-\tcase OPT_fbootclasspath_:\n-\tcase OPT_extdirs:\n-\t  added -= 1;\n-\t  break;\n-\n-\tcase OPT_c:\n-\tcase OPT_S:\n-\tcase OPT_E:\n-\tcase OPT_M:\n-\tcase OPT_MM:\n-\t  /* Don't specify libraries if we won't link, since that would\n-\t     cause a warning.  */\n-\t  library = 0;\n-\t  added -= 2;\n-\n-\t  /* Remember this so we can confirm -fmain option.  */\n-\t  will_link = 0;\n-\t  break;\n-\n-\tcase OPT_fsyntax_only:\n-\t  library = 0;\n-\t  will_link = 0;\n-\t  continue;\n-\n-\tcase OPT_save_temps:\n-\t  saw_save_temps = 1;\n-\t  break;\n-\n-\tcase OPT_static_libgcc:\n-\tcase OPT_static:\n-\t  shared_libgcc = 0;\n-\t  break;\n-\n-\tcase OPT_findirect_dispatch:\n-\t  link_for_bc_abi = 1;\n-\t  break;\n-\n-\tcase OPT_SPECIAL_input_file:\n-\t  {\n-\t    const char *arg = decoded_options[i].arg;\n-\t    int len;\n-\n-\t    /* We don't do this anymore, since we don't get them with minus\n-\t       signs on them.  */\n-\t    if (arg[0] == '\\0' || arg[1] == '\\0')\n-\t      continue;\n-\n-\t    if (saw_speclang)\n-\t      {\n-\t\tsaw_speclang = 0;\n-\t\tcontinue;\n-\t      }\n-\n-\t    if (saw_resource)\n-\t      {\n-\t\targs[i] |= RESOURCE_FILE_ARG;\n-\t\tadded += 2;  /* for -xjava and -xnone */\n-\t      }\n-\n-\t    if (arg[0] == '@')\n-\t      {\n-\t\targs[i] |= INDIRECT_FILE_ARG;\n-\t\tindirect_files_count++;\n-\t\tadded += 2;  /* for -xjava and -xnone */\n-\t      }\n-\n-\t    len = strlen (arg);\n-\t    if (len > 5 && strcmp (arg + len - 5, \".java\") == 0)\n-\t      {\n-\t\targs[i] |= JAVA_FILE_ARG;\n-\t\tjava_files_count++;\n-\t      }\n-\t    if (len > 6 && strcmp (arg + len - 6, \".class\") == 0)\n-\t      {\n-\t\targs[i] |= CLASS_FILE_ARG;\n-\t\tclass_files_count++;\n-\t      }\n-\t    if (len > 4\n-\t\t&& (strcmp (arg + len - 4, \".zip\") == 0\n-\t\t    || strcmp (arg + len - 4, \".jar\") == 0))\n-\t      {\n-\t\targs[i] |= ZIP_FILE_ARG;\n-\t\tzip_files_count++;\n-\t      }\n-\t  }\n-\n-\tdefault:\n-\t  /* Pass other options through.  */\n-\t  continue;\n-\t}\n-    }\n-\n-  if (saw_D && ! main_class_name)\n-    fatal_error (input_location, \"can%'t specify %<-D%> without %<--main%>\");\n-\n-  if (main_class_name && ! verify_class_name (main_class_name))\n-    fatal_error (input_location,\n-\t\t \"%qs is not a valid class name\", main_class_name);\n-\n-  num_args = argc + added;\n-  if (saw_resource)\n-    {\n-      if (! saw_o)\n-\tfatal_error (input_location, \"--resource requires -o\");\n-    }\n-  if (saw_C)\n-    {\n-      num_args += 3;\n-      if (class_files_count + zip_files_count > 0)\n-\t{\n-\t  warning (0, \"already-compiled .class files ignored with -C\"); \n-\t  num_args -= class_files_count + zip_files_count;\n-\t  class_files_count = 0;\n-\t  zip_files_count = 0;\n-\t}\n-      num_args += 2;  /* For -o NONE. */\n-      if (saw_o)\n-\tfatal_error (input_location, \"cannot specify both -C and -o\");\n-    }\n-  if ((saw_o && java_files_count + class_files_count + zip_files_count > 1)\n-      || (saw_C && java_files_count > 1)\n-      || (indirect_files_count > 0\n-\t  && java_files_count + class_files_count + zip_files_count > 0))\n-    combine_inputs = 1;\n-\n-  if (combine_inputs)\n-    {\n-      filelist_filename = make_temp_file (\"jx\");\n-      if (filelist_filename == NULL)\n-\tfatal_error (input_location, \"cannot create temporary file\");\n-      record_temp_file (filelist_filename, ! saw_save_temps, 0);\n-      filelist_file = fopen (filelist_filename, \"w\");\n-      if (filelist_file == NULL)\n-\tpfatal_with_name (filelist_filename);\n-      num_args -= java_files_count + class_files_count + zip_files_count;\n-      num_args += 3;  /* for the combined arg \"-xjava\", and \"-xnone\" */\n-    }\n-\n-  if (main_class_name)\n-    {\n-      lang_specific_extra_outfiles++;\n-    }\n-  if (saw_g + saw_O == 0)\n-    num_args++;\n-  num_args++;\n-  /* An additional entry for the classpath.  */\n-  num_args++;\n-\n-  if (combine_inputs || indirect_files_count > 0)\n-    num_args += 1; /* for \"-ffilelist-file\" */\n-  if (combine_inputs && indirect_files_count > 0)\n-    fatal_error (input_location,\n-\t\t \"using both @FILE with multiple files not implemented\");\n-\n-  /* There's no point adding -shared-libgcc if we don't have a shared\n-     libgcc.  */\n-#ifndef ENABLE_SHARED_LIBGCC\n-  shared_libgcc = 0;\n-#endif  \n-  \n-  if (java_files_count > 0)\n-    ++num_args;\n-\n-  num_args += shared_libgcc;\n-\n-  num_args += link_for_bc_abi;\n-\n-  new_decoded_options = XNEWVEC (struct cl_decoded_option, num_args);\n-  j = 0;\n-\n-  new_decoded_options[j++] = decoded_options[0];\n-\n-  if (combine_inputs || indirect_files_count > 0)\n-    generate_option (OPT_ffilelist_file, NULL, 1, CL_DRIVER,\n-\t\t     &new_decoded_options[j++]);\n-\n-  if (combine_inputs)\n-    {\n-      generate_option (OPT_x, \"java\", 1, CL_DRIVER,\n-\t\t       &new_decoded_options[j++]);\n-      generate_option_input_file (filelist_filename,\n-\t\t\t\t  &new_decoded_options[j++]);\n-      generate_option (OPT_x, \"none\", 1, CL_DRIVER,\n-\t\t       &new_decoded_options[j++]);\n-    }\n-\n-  if (java_files_count > 0)\n-    generate_option (OPT_fsaw_java_file, NULL, 1, CL_DRIVER,\n-\t\t     &new_decoded_options[j++]);\n-\n-  jcf_path_init ();\n-  for (i = 1; i < argc; i++, j++)\n-    {\n-      new_decoded_options[j] = decoded_options[i];\n-\n-      if (decoded_options[i].errors & CL_ERR_MISSING_ARG)\n-\tcontinue;\n-\n-      if ((args[i] & RESOURCE_FILE_ARG) != 0)\n-\t{\n-\t  generate_option (OPT_x, \"java\", 1, CL_DRIVER,\n-\t\t\t   &new_decoded_options[j++]);\n-\t  new_decoded_options[j++] = decoded_options[i];\n-\t  generate_option (OPT_x, \"none\", 1, CL_DRIVER,\n-\t\t\t   &new_decoded_options[j]);\n-\t}\n-\n-      switch (decoded_options[i].opt_index)\n-\t{\n-\tcase OPT_I:\n-\t  jcf_path_include_arg (decoded_options[i].arg);\n-\t  --j;\n-\t  continue;\n-\n-\tcase OPT_fclasspath_:\n-\t  jcf_path_classpath_arg (decoded_options[i].arg);\n-\t  --j;\n-\t  continue;\n-\n-\tcase OPT_fbootclasspath_:\n-\t  jcf_path_bootclasspath_arg (decoded_options[i].arg);\n-\t  --j;\n-\t  continue;\n-\n-\tcase OPT_extdirs:\n-\t  jcf_path_extdirs_arg (decoded_options[i].arg);\n-\t  --j;\n-\t  continue;\n-\n-\tcase OPT_L:\n-\t  if (spec_file == NULL)\n-\t    spec_file = find_spec_file (decoded_options[i].arg);\n-\t  break;\n-\n-\tcase OPT_fmain_:\n-\t  if (! will_link)\n-\t    fatal_error (input_location,\n-\t\t\t \"cannot specify %<main%> class when not linking\");\n-\t  --j;\n-\t  continue;\n-\t}\n-\n-      if ((args[i] & INDIRECT_FILE_ARG) != 0)\n-\t{\n-\t  generate_option (OPT_x, \"java\", 1, CL_DRIVER,\n-\t\t\t   &new_decoded_options[j++]);\n-\t  /* Drop '@'.  */\n-\t  generate_option_input_file (decoded_options[i].arg + 1,\n-\t\t\t\t      &new_decoded_options[j++]);\n-\t  generate_option (OPT_x, \"none\", 1, CL_DRIVER,\n-\t\t\t   &new_decoded_options[j]);\n-\t}\n-\n-      if ((args[i] & (CLASS_FILE_ARG|ZIP_FILE_ARG)) && saw_C)\n-\t{\n-\t  --j;\n-\t  continue;\n-\t}\n-\n-      if (combine_inputs\n-\t  && (args[i] & (CLASS_FILE_ARG|JAVA_FILE_ARG|ZIP_FILE_ARG)) != 0)\n-\t{\n-\t  fputs (decoded_options[i].arg, filelist_file);\n-\t  fputc ('\\n', filelist_file);\n-\t  --j;\n-\t  continue;\n-\t}\n-  }\n-\n-  /* Handle classpath setting.  We specify the bootclasspath since\n-     that requires the fewest changes to our existing code...  */\n-  jcf_path_seal (0);\n-  generate_option (OPT_fbootclasspath_, jcf_path_compute (\"\"), 1,\n-\t\t   CL_DRIVER, &new_decoded_options[j++]);\n-\n-  if (combine_inputs)\n-    {\n-      if (fclose (filelist_file))\n-\tpfatal_with_name (filelist_filename);\n-    }\n-\n-  /* If we saw no -O or -g option, default to -g1, for javac compatibility. */\n-  if (saw_g + saw_O == 0)\n-    generate_option (OPT_g, \"1\", 1, CL_DRIVER, &new_decoded_options[j++]);\n-\n-  /* Read the specs file corresponding to libgcj.\n-     If we didn't find the spec file on the -L path, then we hope it\n-     is somewhere in the standard install areas.  */\n-  if (want_spec_file)\n-    generate_option (OPT_specs_, spec_file == NULL ? \"libgcj.spec\" : spec_file,\n-\t\t     1, CL_DRIVER, &new_decoded_options[j++]);\n-\n-  if (saw_C)\n-    {\n-      generate_option (OPT_fsyntax_only, NULL, 1, CL_DRIVER,\n-\t\t       &new_decoded_options[j++]);\n-      generate_option (OPT_femit_class_files, NULL, 1, CL_DRIVER,\n-\t\t       &new_decoded_options[j++]);\n-      generate_option (OPT_S, NULL, 1, CL_DRIVER, &new_decoded_options[j++]);\n-      generate_option (OPT_o, \"NONE\", 1, CL_DRIVER,\n-\t\t       &new_decoded_options[j++]);\n-    }\n-  \n-  if (shared_libgcc)\n-    generate_option (OPT_shared_libgcc, NULL, 1, CL_DRIVER,\n-\t\t     &new_decoded_options[j++]);\n-\n-  if (link_for_bc_abi)\n-    generate_option (OPT_s_bc_abi, NULL, 1, CL_DRIVER,\n-\t\t     &new_decoded_options[j++]);\n-\n-  *in_decoded_options_count = j;\n-  *in_decoded_options = new_decoded_options;\n-  *in_added_libraries = added_libraries;\n-}\n-\n-int\n-lang_specific_pre_link (void)\n-{\n-  int err;\n-  if (main_class_name == NULL)\n-    return 0;\n-  /* Append `main' to make the filename unique and allow\n-\n-\tgcj --main=hello -save-temps hello.java\n-\n-     to work.  jvgenmain needs to strip this `main' to arrive at the correct\n-     class name.  Append dummy `.c' that can be stripped by set_input so %b\n-     is correct.  */ \n-  set_input (concat (main_class_name, \"main.c\", NULL));\n-  err = do_spec (jvgenmain_spec);\n-  if (err == 0)\n-    {\n-      /* Shift the outfiles array so the generated main comes first.\n-\t This is important when linking against (non-shared) libraries,\n-\t since otherwise we risk (a) nothing getting linked or\n-\t (b) 'main' getting picked up from a library. */\n-      int i = n_infiles;\n-      const char *generated = outfiles[i];\n-      while (--i >= 0)\n-\toutfiles[i + 1] = outfiles[i];\n-      outfiles[0] = generated;\n-    }\n-  return err;\n-}"}, {"sha": "4c4c8fdc282e624244c38e73420ea4c5a3c0181d", "filename": "gcc/java/lang-specs.h", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-specs.h?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,62 +0,0 @@\n-/* Definitions for specs for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* This is the contribution to the `default_compilers' array in gcc.c for\n-   Java.  */\n-\n-  {\".java\",   \"@java\" , 0, 0, 0},\n-  {\".class\",  \"@java\" , 0, 0, 0},\n-  {\".zip\",    \"@java\" , 0, 0, 0},\n-  {\".jar\",    \"@java\" , 0, 0, 0},\n-  {\"@java\",\n-   \"%{fjni:%{femit-class-files:%e-fjni and -femit-class-files are incompatible}}\\\n-    %{fjni:%{femit-class-file:%e-fjni and -femit-class-file are incompatible}}\\\n-    %{femit-class-file:%{!fsyntax-only:%e-femit-class-file should used along with -fsyntax-only}}\\\n-    %{femit-class-files:%{!fsyntax-only:%e-femit-class-file should used along with -fsyntax-only}}\\\n-    %{E:%{e-E is not valid for gcj}}\\\n-    %{.java|fsaw-java-file:ecj1 %i %{W*} %{w} %{g*}\t\t\t\\\n-      %{fbootclasspath*}\t\t\t\t\t\t\\\n-      %{fenable-assertions*}\t\t\t\t\t\t\\\n-      %{fdisable-assertions*}\t\t\t\t\t\t\\\n-      %{fencoding*} %{ffilelist-file}\t\t\t\t\t\\\n-      %{foutput-class-dir*} %{g*}\t\t\t\t\t\\\n-      %{fsource*} %{!fsource*:-fsource=1.5}\t\t\t\t\\\n-      %{ftarget*} %{!femit-class-files|!ftarget*:-ftarget=1.5}\t\t\\\n-      %{!findirect-dispatch:-fzip-dependency %U.zip}\t\t\t\\\n-      %{!fsyntax-only:-fzip-target %U.jar}}\\n\t\t\t\t\\\n-    %{.class|.zip|.jar|!fsyntax-only:jc1\t\t\t\t\\\n-      %{.java|fsaw-java-file:%U.jar -fsource-filename=%i %<ffilelist-file} \\\n-      %{.class|.zip|.jar|ffilelist-file|fcompile-resource*:%i}\t\t\\\n-      %(jc1) %(cc1_options) %{I*} %{!findirect-dispatch:-faux-classpath %U.zip} \\\n-      %{MD:-MD_} %{MMD:-MMD_} %{M} %{MM} %{MA} %{MT*} %{MF*}\\\n-      %(invoke_as)}\",\n-      0, 0, 0},\n-\n-  /*\n-    FIXME: we don't use %|, even though we could, because we need the\n-    dependency zip to be ready early enough.  We could work around\n-    this by not having a dependency zip and instead teaching jc1 to\n-    read a special manifest file included in the sole zip, this\n-    manifest would say which files are to be compiled and which are\n-    not.\n-   */"}, {"sha": "65025eeeb72a8c5e45be4423c1b45bce89592b70", "filename": "gcc/java/lang.c", "status": "removed", "additions": 0, "deletions": 912, "changes": 912, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,912 +0,0 @@\n-/* Java(TM) language-specific utility routines.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"tree.h\"\n-#include \"diagnostic.h\"\n-#include \"java-tree.h\"\n-#include \"jcf.h\"\n-#include \"langhooks.h\"\n-#include \"langhooks-def.h\"\n-#include \"tree-dump.h\"\n-#include \"opts.h\"\n-#include \"context.h\"\n-\n-static bool java_init (void);\n-static void java_finish (void);\n-static unsigned int java_option_lang_mask (void);\n-static void java_init_options_struct (struct gcc_options *);\n-static void java_init_options (unsigned int, struct cl_decoded_option *);\n-static bool java_post_options (const char **);\n-\n-static bool java_handle_option (size_t, const char *, int, int, location_t,\n-\t\t\t\tconst struct cl_option_handlers *);\n-static void put_decl_string (const char *, int);\n-static void put_decl_node (tree, int);\n-static void java_print_error_function (diagnostic_context *, const char *,\n-\t\t\t\t       diagnostic_info *);\n-static bool java_dump_tree (void *, tree);\n-static void dump_compound_expr (dump_info_p, tree);\n-static bool java_decl_ok_for_sibcall (const_tree);\n-\n-static enum classify_record java_classify_record (tree type);\n-\n-static tree java_eh_personality (void);\n-\n-#ifndef TARGET_OBJECT_SUFFIX\n-# define TARGET_OBJECT_SUFFIX \".o\"\n-#endif\n-\n-/* Table of machine-independent attributes.  */\n-const struct attribute_spec java_attribute_table[] =\n-{\n- { \"nonnull\",                0, -1, false, true, true,\n-\t\t\t      NULL, false },\n-  { NULL,                     0, 0, false, false, false, NULL, false }\n-};\n-\n-/* Used to avoid printing error messages with bogus function\n-   prototypes.  Starts out false.  */\n-static bool inhibit_error_function_printing;\n-\n-const char *resource_name;\n-\n-/* When nonzero, -Wall was turned on.  */\n-int flag_wall = 0;\n-\n-/* When nonzero, report use of deprecated classes, methods, or fields.  */\n-int flag_deprecated = 1;\n-\n-/* When zero, don't optimize static class initialization. This flag shouldn't\n-   be tested alone, use STATIC_CLASS_INITIALIZATION_OPTIMIZATION_P instead.  */\n-/* FIXME: Make this work with gimplify.  */\n-/* int flag_optimize_sci = 0;  */\n-\n-/* Don't attempt to verify invocations.  */\n-int flag_verify_invocations = 0; \n-\n-/* When nonzero, print extra version information.  */\n-static int v_flag = 0;\n-\n-JCF *current_jcf;\n-\n-/* Variable controlling how dependency tracking is enabled in\n-   java_init.  */\n-static int dependency_tracking = 0;\n-\n-/* Flag values for DEPENDENCY_TRACKING.  */\n-#define DEPEND_SET_FILE 1\n-#define DEPEND_ENABLE   2\n-#define DEPEND_TARGET_SET 4\n-#define DEPEND_FILE_ALREADY_SET 8\n-\n-struct GTY(()) language_function {\n-  int unused;\n-};\n-\n-#undef LANG_HOOKS_NAME\n-#define LANG_HOOKS_NAME \"GNU Java\"\n-#undef LANG_HOOKS_INIT\n-#define LANG_HOOKS_INIT java_init\n-#undef LANG_HOOKS_FINISH\n-#define LANG_HOOKS_FINISH java_finish\n-#undef LANG_HOOKS_OPTION_LANG_MASK\n-#define LANG_HOOKS_OPTION_LANG_MASK java_option_lang_mask\n-#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n-#define LANG_HOOKS_INIT_OPTIONS_STRUCT java_init_options_struct\n-#undef LANG_HOOKS_INIT_OPTIONS\n-#define LANG_HOOKS_INIT_OPTIONS java_init_options\n-#undef LANG_HOOKS_HANDLE_OPTION\n-#define LANG_HOOKS_HANDLE_OPTION java_handle_option\n-#undef LANG_HOOKS_POST_OPTIONS\n-#define LANG_HOOKS_POST_OPTIONS java_post_options\n-#undef LANG_HOOKS_PARSE_FILE\n-#define LANG_HOOKS_PARSE_FILE java_parse_file\n-#undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL\n-#define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL java_dup_lang_specific_decl\n-#undef LANG_HOOKS_DECL_PRINTABLE_NAME\n-#define LANG_HOOKS_DECL_PRINTABLE_NAME lang_printable_name\n-#undef LANG_HOOKS_PRINT_ERROR_FUNCTION\n-#define LANG_HOOKS_PRINT_ERROR_FUNCTION\tjava_print_error_function\n-\n-#undef LANG_HOOKS_TYPE_FOR_MODE\n-#define LANG_HOOKS_TYPE_FOR_MODE java_type_for_mode\n-#undef LANG_HOOKS_TYPE_FOR_SIZE\n-#define LANG_HOOKS_TYPE_FOR_SIZE java_type_for_size\n-#undef LANG_HOOKS_CLASSIFY_RECORD\n-#define LANG_HOOKS_CLASSIFY_RECORD java_classify_record\n-\n-#undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n-#define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN java_dump_tree\n-\n-#undef LANG_HOOKS_GIMPLIFY_EXPR\n-#define LANG_HOOKS_GIMPLIFY_EXPR java_gimplify_expr\n-\n-#undef LANG_HOOKS_DECL_OK_FOR_SIBCALL\n-#define LANG_HOOKS_DECL_OK_FOR_SIBCALL java_decl_ok_for_sibcall\n-\n-#undef LANG_HOOKS_SET_DECL_ASSEMBLER_NAME\n-#define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME java_mangle_decl\n-\n-#undef LANG_HOOKS_ATTRIBUTE_TABLE\n-#define LANG_HOOKS_ATTRIBUTE_TABLE java_attribute_table\n-\n-#undef LANG_HOOKS_EH_PERSONALITY\n-#define LANG_HOOKS_EH_PERSONALITY java_eh_personality\n-\n-#undef LANG_HOOKS_EH_USE_CXA_END_CLEANUP\n-#define LANG_HOOKS_EH_USE_CXA_END_CLEANUP  true\n-\n-/* Each front end provides its own.  */\n-struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n-\n-/*\n- * process java-specific compiler command-line options\n- * return false, but do not complain if the option is not recognized.\n- */\n-static bool\n-java_handle_option (size_t scode, const char *arg, int value,\n-\t\t    int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n-\t\t    const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n-{\n-  enum opt_code code = (enum opt_code) scode;\n-\n-  switch (code)\n-    {\n-    case OPT_I:\n-      jcf_path_include_arg (arg);\n-      break;\n-\n-    case OPT_M:\n-      jcf_dependency_init (1);\n-      dependency_tracking |= DEPEND_ENABLE;\n-      break;\n-\n-    case OPT_MD_:\n-      jcf_dependency_init (1);\n-      dependency_tracking |= DEPEND_SET_FILE | DEPEND_ENABLE;\n-      break;\n-\n-    case OPT_MF:\n-      jcf_dependency_set_dep_file (arg);\n-      dependency_tracking |= DEPEND_FILE_ALREADY_SET;\n-      break;\n-\n-    case OPT_MM:\n-      jcf_dependency_init (0);\n-      dependency_tracking |= DEPEND_ENABLE;\n-      break;\n-\n-    case OPT_MMD_:\n-      jcf_dependency_init (0);\n-      dependency_tracking |= DEPEND_SET_FILE | DEPEND_ENABLE;\n-      break;\n-\n-    case OPT_MP:\n-      jcf_dependency_print_dummies ();\n-      break;\n-\n-    case OPT_MT:\n-      jcf_dependency_set_target (arg);\n-      dependency_tracking |= DEPEND_TARGET_SET;\n-      break;\n-\n-    case OPT_Wall:\n-      flag_wall = value;\n-      /* When -Wall given, enable -Wunused.  We do this because the C\n-\t compiler does it, and people expect it.  */\n-      warn_unused = value;\n-      break;\n-\n-    case OPT_fenable_assertions_:\n-      add_enable_assert (arg, value);\n-      break;\n-\n-    case OPT_fenable_assertions:\n-      add_enable_assert (\"\", value);\n-      break;\n-\n-    case OPT_fdisable_assertions_:\n-      add_enable_assert (arg, !value);\n-      break;\n-\n-    case OPT_fdisable_assertions:\n-      add_enable_assert (\"\", !value);\n-      break;\n-\n-    case OPT_fassume_compiled_:\n-      add_assume_compiled (arg, !value);\n-      break;\n-\n-    case OPT_fassume_compiled:\n-      add_assume_compiled (\"\", !value);\n-      break;\n-\n-    case OPT_fbootclasspath_:\n-      jcf_path_bootclasspath_arg (arg);\n-      break;\n-\n-    case OPT_faux_classpath:\n-    case OPT_fclasspath_:\n-      jcf_path_classpath_arg (arg);\n-      break;\n-\n-    case OPT_fcompile_resource_:\n-      resource_name = arg;\n-      break;\n-\n-    case OPT_fdump_:\n-      if (!g->get_dumps ()->dump_switch_p (arg))\n-\treturn false;\n-      break;\n-\n-    case OPT_fencoding_:\n-      /* Nothing.  */\n-      break;\n-\n-    case OPT_fextdirs_:\n-      jcf_path_extdirs_arg (arg);\n-      break;\n-\n-    case OPT_foutput_class_dir_:\n-      /* FIXME: remove; this is handled by ecj1 now.  */\n-      break;\n-\n-    case OPT_version:\n-      v_flag = 1;\n-      break;\n-      \n-    case OPT_fsource_filename_:\n-      java_read_sourcefilenames (arg);\n-      break;\n-      \n-    default:\n-      if (cl_options[code].flags & CL_Java)\n-\tbreak;\n-      gcc_unreachable ();\n-    }\n-\n-  return true;\n-}\n-\n-/* Global open file.  */\n-FILE *finput;\n-\n-static bool\n-java_init (void)\n-{\n-  /* FIXME: Indirect dispatch isn't yet compatible with static class\n-     init optimization.  */\n-  if (flag_indirect_dispatch)\n-    always_initialize_class_p = true;\n-\n-  if (!flag_indirect_dispatch)\n-    flag_indirect_classes = false;\n-\n-  jcf_path_seal (v_flag);\n-\n-  java_init_decl_processing ();\n-\n-  using_eh_for_cleanups ();\n-\n-  return true;\n-}\n-\n-static void\n-java_finish (void)\n-{\n-  jcf_dependency_write ();\n-}\n-\n-/* Buffer used by lang_printable_name. */\n-static char *decl_buf = NULL;\n-\n-/* Allocated size of decl_buf. */\n-static int decl_buflen = 0;\n-\n-/* Length of used part of decl_buf;  position for next character. */\n-static int decl_bufpos = 0;\n-\n-/* Append the string STR to decl_buf.\n-   It length is given by LEN;  -1 means the string is nul-terminated. */\n-\n-static void\n-put_decl_string (const char *str, int len)\n-{\n-  if (len < 0)\n-    len = strlen (str);\n-  if (decl_bufpos + len >= decl_buflen)\n-    {\n-      if (decl_buf == NULL)\n-\t{\n-\t  decl_buflen = len + 100;\n-\t  decl_buf = XNEWVEC (char, decl_buflen);\n-\t}\n-      else\n-\t{\n-\t  decl_buflen *= 2;\n-\t  decl_buf = XRESIZEVAR (char, decl_buf, decl_buflen);\n-\t}\n-    }\n-  strcpy (decl_buf + decl_bufpos, str);\n-  decl_bufpos += len;\n-}\n-\n-/* Append to decl_buf a printable name for NODE.\n-   Depending on VERBOSITY, more information about NODE\n-   is printed. Read the comments of decl_printable_name in\n-   langhooks.h for more.  */\n-\n-static void\n-put_decl_node (tree node, int verbosity)\n-{\n-  int was_pointer = 0;\n-  if (TREE_CODE (node) == POINTER_TYPE)\n-    {\n-      node = TREE_TYPE (node);\n-      was_pointer = 1;\n-    }\n-  if (DECL_P (node) && DECL_NAME (node) != NULL_TREE)\n-    {\n-      if (TREE_CODE (node) == FUNCTION_DECL)\n-\t{\n-\t  if (verbosity == 0 && DECL_NAME (node))\n-\t  /* We have been instructed to just print the bare name\n-\t     of the function.  */\n-\t    {\n-\t      put_decl_node (DECL_NAME (node), 0);\n-\t      return;\n-\t    }\n-\n-\t  /* We want to print the type the DECL belongs to. We don't do\n-\t     that when we handle constructors. */\n-\t  if (! DECL_CONSTRUCTOR_P (node)\n-\t      && ! DECL_ARTIFICIAL (node) && DECL_CONTEXT (node)\n-              /* We want to print qualified DECL names only\n-                 if verbosity is higher than 1.  */\n-              && verbosity >= 1)\n-\t    {\n-\t      put_decl_node (TREE_CODE (DECL_CONTEXT (node)) == FUNCTION_DECL\n-\t\t\t     ? DECL_CONTEXT (node)\n-\t\t\t     : TYPE_NAME (DECL_CONTEXT (node)),\n-                               verbosity);\n-\t      put_decl_string (\".\", 1);\n-\t    }\n-\t  if (! DECL_CONSTRUCTOR_P (node))\n-\t    put_decl_node (DECL_NAME (node), verbosity);\n-\t  if (TREE_TYPE (node) != NULL_TREE\n-              /* We want to print function parameters only if verbosity\n-                 is higher than 2.  */\n-              && verbosity >= 2)\n-\t    {\n-\t      int i = 0;\n-\t      tree args = TYPE_ARG_TYPES (TREE_TYPE (node));\n-\t      if (TREE_CODE (TREE_TYPE (node)) == METHOD_TYPE)\n-\t\targs = TREE_CHAIN (args);\n-\t      put_decl_string (\"(\", 1);\n-\t      for ( ; args != NULL_TREE && args != end_params_node;\n-\t\t   args = TREE_CHAIN (args), i++)\n-\t\t{\n-\t\t  if (i > 0)\n-\t\t    put_decl_string (\",\", 1);\n-\t\t  put_decl_node (TREE_VALUE (args), verbosity);\n-\t\t}\n-\t      put_decl_string (\")\", 1);\n-\t    }\n-\t}\n-      else\n-\tput_decl_node (DECL_NAME (node), verbosity);\n-    }\n-  else if (TYPE_P (node) && TYPE_NAME (node) != NULL_TREE)\n-    {\n-      if (TREE_CODE (node) == RECORD_TYPE && TYPE_ARRAY_P (node)\n-          /* Print detailed array information only if verbosity is higher\n-            than 2.  */\n-          && verbosity >= 2)\n-\t{\n-\t  put_decl_node (TYPE_ARRAY_ELEMENT (node), verbosity);\n-\t  put_decl_string(\"[]\", 2);\n-\t}\n-      else if (node == promoted_byte_type_node)\n-\tput_decl_string (\"byte\", 4);\n-      else if (node == promoted_short_type_node)\n-\tput_decl_string (\"short\", 5);\n-      else if (node == promoted_char_type_node)\n-\tput_decl_string (\"char\", 4);\n-      else if (node == promoted_boolean_type_node)\n-\tput_decl_string (\"boolean\", 7);\n-      else if (node == void_type_node && was_pointer)\n-\tput_decl_string (\"null\", 4);\n-      else\n-\tput_decl_node (TYPE_NAME (node), verbosity);\n-    }\n-  else if (TREE_CODE (node) == IDENTIFIER_NODE)\n-    put_decl_string (IDENTIFIER_POINTER (node), IDENTIFIER_LENGTH (node));\n-  else\n-    put_decl_string (\"<unknown>\", -1);\n-}\n-\n-/* Return a user-friendly name for DECL.\n-   The resulting string is only valid until the next call.\n-   The value of the hook decl_printable_name is this function,\n-   which is also called directly by java_print_error_function. */\n-\n-const char *\n-lang_printable_name (tree decl, int v)\n-{\n-  decl_bufpos = 0;\n-  put_decl_node (decl, v);\n-  put_decl_string (\"\", 1);\n-  return decl_buf;\n-}\n-\n-/* Print on stderr the current class and method context.  This function\n-   is the value of the hook print_error_function. */\n-\n-static GTY(()) tree last_error_function_context;\n-static GTY(()) tree last_error_function;\n-static void\n-java_print_error_function (diagnostic_context *context ATTRIBUTE_UNUSED,\n-\t\t\t   const char *file,\n-\t\t\t   diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n-{\n-  /* Don't print error messages with bogus function prototypes.  */\n-  if (inhibit_error_function_printing)\n-    return;\n-\n-  if (current_function_decl != NULL\n-      && DECL_CONTEXT (current_function_decl) != NULL\n-      && DECL_CONTEXT (current_function_decl) != last_error_function_context)\n-    {\n-      if (file)\n-\tfprintf (stderr, \"%s: \", file);\n-\n-      last_error_function_context = DECL_CONTEXT (current_function_decl);\n-      fprintf (stderr, \"In class '%s':\\n\",\n-\t       lang_printable_name (last_error_function_context, 0));\n-    }\n-  if (last_error_function != current_function_decl)\n-    {\n-      if (file)\n-\tfprintf (stderr, \"%s: \", file);\n-\n-      if (current_function_decl == NULL)\n-\tfprintf (stderr, \"At top level:\\n\");\n-      else\n-\t{\n-\t  const char *name = lang_printable_name (current_function_decl, 2);\n-\t  fprintf (stderr, \"In %s '%s':\\n\",\n-\t\t   (DECL_CONSTRUCTOR_P (current_function_decl) ? \"constructor\"\n-\t\t    : \"method\"),\n-\t\t   name);\n-\t}\n-\n-      last_error_function = current_function_decl;\n-    }\n-\n-}\n-\n-/* Called to install the PRINT_ERROR_FUNCTION hook differently\n-   according to LEVEL. LEVEL is 1 during early parsing, when function\n-   prototypes aren't fully resolved. java_print_error_function is set\n-   so it doesn't print incomplete function prototypes. When LEVEL is\n-   2, function prototypes are fully resolved and can be printed when\n-   reporting errors.  */\n-\n-void\n-lang_init_source (int level)\n-{\n-  inhibit_error_function_printing = (level == 1);\n-}\n-\n-static unsigned int\n-java_option_lang_mask (void)\n-{\n-  return CL_Java;\n-}\n-\n-/* Initialize options structure OPTS.  */\n-\n-static void\n-java_init_options_struct (struct gcc_options *opts)\n-{\n-  opts->x_flag_bounds_check = 1;\n-  opts->x_flag_exceptions = 1;\n-  opts->x_flag_non_call_exceptions = 1;\n-\n-  /* In Java floating point operations never trap.  */\n-  opts->x_flag_trapping_math = 0;\n-  opts->frontend_set_flag_trapping_math = true;\n-\n-  /* In Java arithmetic overflow always wraps around.  */\n-  opts->x_flag_wrapv = 1;\n-\n-  /* Java requires left-to-right evaluation of subexpressions.  */\n-  opts->x_flag_evaluation_order = 1;\n-\n-  /* Java catches NULL pointer exceptions, thus we can not necessarily\n-     rely on a pointer having a non-NULL value after a dereference.  */\n-  opts->x_flag_delete_null_pointer_checks = 0;\n-}\n-\n-static void\n-java_init_options (unsigned int decoded_options_count ATTRIBUTE_UNUSED,\n-\t\t   struct cl_decoded_option *decoded_options ATTRIBUTE_UNUSED)\n-{\n-  jcf_path_init ();\n-}\n-\n-/* Post-switch processing.  */\n-static bool\n-java_post_options (const char **pfilename)\n-{\n-  const char *filename = *pfilename;\n-\n-  /* Excess precision other than \"fast\" requires front-end\n-     support.  */\n-  if (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD)\n-    sorry (\"-fexcess-precision=standard for Java\");\n-  flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n-\n-  /* An absolute requirement: if we're not using indirect dispatch, we\n-     must always verify everything.  */\n-  if (! flag_indirect_dispatch)\n-    flag_verify_invocations = true;\n-\n-  if (flag_reduced_reflection)\n-    {\n-      if (flag_indirect_dispatch)\n-        error (\"-findirect-dispatch is incompatible \"\n-               \"with -freduced-reflection\");\n-      if (flag_jni)\n-        error (\"-fjni is incompatible with -freduced-reflection\");\n-    }\n-\n-  /* Open input file.  */\n-\n-  if (filename == 0 || !strcmp (filename, \"-\"))\n-    {\n-      finput = stdin;\n-      filename = \"stdin\";\n-\n-      if (dependency_tracking)\n-\terror (\"can%'t do dependency tracking with input from stdin\");\n-    }\n-  else\n-    {\n-      if (dependency_tracking)\n-\t{\n-\t  const char *dot;\n-\n-\t  /* If the target is set and the output filename is set, then\n-\t     there's no processing to do here.  Otherwise we must\n-\t     compute one or the other.  */\n-\t  if (! ((dependency_tracking & DEPEND_TARGET_SET)\n-\t\t && (dependency_tracking & DEPEND_FILE_ALREADY_SET)))\n-\t    {\n-\t      dot = strrchr (filename, '.');\n-\t      if (dot == NULL)\n-\t\terror (\"couldn%'t determine target name for dependency tracking\");\n-\t      else\n-\t\t{\n-\t\t  char *buf = XNEWVEC (char, dot - filename +\n-\t\t\t\t       3 + sizeof (TARGET_OBJECT_SUFFIX));\n-\t\t  strncpy (buf, filename, dot - filename);\n-\n-\t\t  /* If emitting class files, we might have multiple\n-\t\t     targets.  The class generation code takes care of\n-\t\t     registering them.  Otherwise we compute the\n-\t\t     target name here.  */\n-\t\t  if ((dependency_tracking & DEPEND_TARGET_SET))\n-\t\t    ; /* Nothing.  */\n-\t\t  else\n-\t\t    {\n-\t\t      strcpy (buf + (dot - filename), TARGET_OBJECT_SUFFIX);\n-\t\t      jcf_dependency_set_target (buf);\n-\t\t    }\n-\n-\t\t  if ((dependency_tracking & DEPEND_FILE_ALREADY_SET))\n-\t\t    ; /* Nothing.  */\n-\t\t  else if ((dependency_tracking & DEPEND_SET_FILE))\n-\t\t    {\n-\t\t      strcpy (buf + (dot - filename), \".d\");\n-\t\t      jcf_dependency_set_dep_file (buf);\n-\t\t    }\n-\t\t  else\n-\t\t    jcf_dependency_set_dep_file (\"-\");\n-\n-\t\t  free (buf);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  linemap_add (line_table, LC_ENTER, false, filename, 0);\n-  linemap_add (line_table, LC_RENAME, false, \"<built-in>\", 0);\n-\n-  /* Initialize the compiler back end.  */\n-  return false;\n-}\n-\n-/* Return either DECL or its known constant value (if it has one).  */\n-\n-tree\n-decl_constant_value (tree decl)\n-{\n-  if (/* Don't change a variable array bound or initial value to a constant\n-\t in a place where a variable is invalid.  */\n-      current_function_decl != 0\n-      && ! TREE_THIS_VOLATILE (decl)\n-      && TREE_READONLY (decl)\n-      && DECL_INITIAL (decl) != 0\n-      && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK\n-      /* This is invalid if initial value is not constant.\n-\t If it has either a function call, a memory reference,\n-\t or a variable, then re-evaluating it could give different results.  */\n-      && TREE_CONSTANT (DECL_INITIAL (decl))\n-      /* Check for cases where this is sub-optimal, even though valid.  */\n-      && TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR)\n-    return DECL_INITIAL (decl);\n-  return decl;\n-}\n-\n-/* Every call to a static constructor has an associated boolean\n-   variable which is in the outermost scope of the calling method.\n-   This variable is used to avoid multiple calls to the static\n-   constructor for each class.\n-\n-   It looks something like this:\n-\n-   foo ()\n-   {\n-      boolean dummy = OtherClass.is_initialized;\n-\n-     ...\n-\n-     if (! dummy)\n-       OtherClass.initialize();\n-\n-     ... use OtherClass.data ...\n-   }\n-\n-   Each of these boolean variables has an entry in the\n-   DECL_FUNCTION_INIT_TEST_TABLE of a method.  When inlining a method\n-   we must merge the DECL_FUNCTION_INIT_TEST_TABLE from the function\n-   being inlined and create the boolean variables in the outermost\n-   scope of the method being inlined into.  */\n-\n-/* Create a mapping from a boolean variable in a method being inlined\n-   to one in the scope of the method being inlined into.  */\n-\n-int\n-merge_init_test_initialization (treetreehash_entry **entry, void *x)\n-{\n-  struct treetreehash_entry *ite = *entry;\n-  splay_tree decl_map = (splay_tree)x;\n-  splay_tree_node n;\n-  tree *init_test_decl;\n-\n-  /* See if we have remapped this declaration.  If we haven't there's\n-     a bug in the inliner.  */\n-  n = splay_tree_lookup (decl_map, (splay_tree_key) ite->value);\n-  gcc_assert (n);\n-\n-  /* Create a new entry for the class and its remapped boolean\n-     variable.  If we already have a mapping for this class we've\n-     already initialized it, so don't overwrite the value.  */\n-  init_test_decl = java_treetreehash_new\n-    (DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl), ite->key);\n-  if (!*init_test_decl)\n-    *init_test_decl = (tree)n->value;\n-\n-  /* This fixes a weird case.\n-\n-  The front end assumes that once we have called a method that\n-  initializes some class, we can assume the class is initialized.  It\n-  does this by setting the DECL_INITIAL of the init_test_decl for that\n-  class, and no initializations are emitted for that class.\n-\n-  However, what if the method that is supposed to do the initialization\n-  is itself inlined in the caller?  When expanding the called method\n-  we'll assume that the class initialization has already been done,\n-  because the DECL_INITIAL of the init_test_decl is set.\n-\n-  To fix this we remove the DECL_INITIAL (in the caller scope) of all\n-  the init_test_decls corresponding to classes initialized by the\n-  inlined method.  This makes the caller no longer assume that the\n-  method being inlined does any class initializations.  */\n-  DECL_INITIAL (*init_test_decl) = NULL;\n-\n-  return true;\n-}\n-\n-/* Merge the DECL_FUNCTION_INIT_TEST_TABLE from the function we're\n-   inlining.  */\n-\n-void\n-java_inlining_merge_static_initializers (tree fn, void *decl_map)\n-{\n-    DECL_FUNCTION_INIT_TEST_TABLE (fn)\n-      ->traverse<void *, merge_init_test_initialization> (decl_map);\n-}\n-\n-/* Lookup a DECL_FUNCTION_INIT_TEST_TABLE entry in the method we're\n-   inlining into.  If we already have a corresponding entry in that\n-   class we don't need to create another one, so we create a mapping\n-   from the variable in the inlined class to the corresponding\n-   pre-existing one.  */\n-\n-int\n-inline_init_test_initialization (treetreehash_entry **entry, void *x)\n-{\n-  struct treetreehash_entry *ite = *entry;\n-  splay_tree decl_map = (splay_tree)x;\n-\n-  tree h = java_treetreehash_find\n-    (DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl), ite->key);\n-  if (! h)\n-    return true;\n-  splay_tree_insert (decl_map,\n-\t\t     (splay_tree_key) ite->value,\n-\t\t     (splay_tree_value) h);\n-  return true;\n-}\n-\n-/* Look up the boolean variables in the DECL_FUNCTION_INIT_TEST_TABLE\n-   of a method being inlined.  For each hone, if we already have a\n-   variable associated with the same class in the method being inlined\n-   into, create a new mapping for it.  */\n-\n-void\n-java_inlining_map_static_initializers (tree fn, void *decl_map)\n-{\n-  DECL_FUNCTION_INIT_TEST_TABLE (fn)\n-    ->traverse<void *, inline_init_test_initialization> (decl_map);\n-}\n-\n-/* Avoid voluminous output for deep recursion of compound exprs.  */\n-\n-static void\n-dump_compound_expr (dump_info_p di, tree t)\n-{\n-  int i;\n-\n-  for (i=0; i<2; i++)\n-    {\n-      switch (TREE_CODE (TREE_OPERAND (t, i)))\n-\t{\n-\tcase COMPOUND_EXPR:\n-\t  dump_compound_expr (di, TREE_OPERAND (t, i));\n-\t  break;\n-\n-\tdefault:\n-\t  dump_child (\"expr\", TREE_OPERAND (t, i));\n-\t}\n-    }\n-}\n-\n-static bool\n-java_dump_tree (void *dump_info, tree t)\n-{\n-  enum tree_code code;\n-  dump_info_p di = (dump_info_p) dump_info;\n-\n-  /* Figure out what kind of node this is.  */\n-  code = TREE_CODE (t);\n-\n-  switch (code)\n-    {\n-    case FUNCTION_DECL:\n-      dump_child (\"args\", DECL_ARGUMENTS (t));\n-      if (DECL_EXTERNAL (t))\n-\tdump_string (di, \"undefined\");\n-      if (TREE_PUBLIC (t))\n-\tdump_string (di, \"extern\");\n-      else\n-\tdump_string (di, \"static\");\n-      if (DECL_LANG_SPECIFIC (t) && !dump_flag (di, TDF_SLIM, t))\n-\tdump_child (\"inline body\", DECL_SAVED_TREE (t));\n-      return true;\n-\n-    case RETURN_EXPR:\n-      dump_child (\"expr\", TREE_OPERAND (t, 0));\n-      return true;\n-\n-    case GOTO_EXPR:\n-      dump_child (\"goto\", TREE_OPERAND (t, 0));\n-      return true;\n-\n-    case LABEL_EXPR:\n-      dump_child (\"label\", TREE_OPERAND (t, 0));\n-      return true;\n-\n-    case BLOCK:\n-      if (BLOCK_EXPR_BODY (t))\n-\t{\n-\t  tree local = BLOCK_VARS (t);\n-\t  while (local)\n-\t    {\n-\t      tree next = TREE_CHAIN (local);\n-\t      dump_child (\"var\", local);\n-\t      local = next;\n-\t    }\n-\n-\t  {\n-\t    tree block = BLOCK_EXPR_BODY (t);\n-\t    dump_child (\"body\", block);\n-\t    block = TREE_CHAIN (block);\n-\t  }\n-\t}\n-      return true;\n-\n-    case COMPOUND_EXPR:\n-      if (!dump_flag (di, TDF_SLIM, t))\n-\treturn false;\n-      dump_compound_expr (di, t);\n-      return true;\n-\n-    default:\n-      break;\n-    }\n-  return false;\n-}\n-\n-/* Java calls can't, in general, be sibcalls because we need an\n-   accurate stack trace in order to guarantee correct operation of\n-   methods such as Class.forName(String) and\n-   SecurityManager.getClassContext().  */\n-\n-static bool\n-java_decl_ok_for_sibcall (const_tree decl)\n-{\n-  return (decl != NULL && DECL_CONTEXT (decl) == output_class\n-          && !DECL_UNINLINABLE (decl));\n-}\n-\n-static enum classify_record\n-java_classify_record (tree type)\n-{\n-  if (! CLASS_P (type))\n-    return RECORD_IS_STRUCT;\n-\n-  if (CLASS_INTERFACE (TYPE_NAME (type)))\n-    return RECORD_IS_INTERFACE;\n-\n-  return RECORD_IS_CLASS;\n-}\n-\n-static GTY(()) tree java_eh_personality_decl;\n-\n-static tree\n-java_eh_personality (void)\n-{\n-  if (!java_eh_personality_decl)\n-    java_eh_personality_decl = build_personality_function (\"gcj\");\n-  return java_eh_personality_decl;\n-}\n-\n-#include \"gt-java-lang.h\""}, {"sha": "c077b6a97f8eff5684b93844bd8732f8116f1dab", "filename": "gcc/java/lang.opt", "status": "removed", "additions": 0, "deletions": 452, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.opt?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,452 +0,0 @@\n-; Options for the Java front end.\n-; Copyright (C) 2003-2016 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-; \n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-; \n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-; See the GCC internals manual for a description of this file's format.\n-\n-; Please try to keep this file in ASCII collating order.\n-\n-Language\n-Java\n-\n--CLASSPATH\n-Java Separate Alias(fclasspath=)\n-\n--all-warnings\n-Java Alias(Wall)\n-\n--bootclasspath\n-Java Separate Alias(fbootclasspath=)\n-\n--classpath\n-Java Separate Alias(fclasspath=)\n-\n--dependencies\n-Java Alias(M)\n-\n--encoding\n-Java Separate Alias(fencoding=)\n-\n--extdirs\n-Java Separate Alias(fextdirs=)\n-\n--include-directory\n-Java Separate Alias(I)\n-\n--include-directory=\n-Java Joined Alias(I)\n-\n--output-class-directory\n-Java Separate Alias(foutput-class-dir=)\n-\n--output-class-directory=\n-Java Joined Alias(foutput-class-dir=)\n-\n--resource\n-Java Separate Alias(fcompile-resource=)\n-\n--resource=\n-Java Joined Alias(fcompile-resource=)\n-\n--user-dependencies\n-Java Alias(MM)\n-\n-C\n-Driver\n-; Java driver option in fact distinct from C-family option with the same name.\n-\n-CLASSPATH\n-Java Separate Alias(fclasspath=)\n-\n-D\n-Driver Joined Separate\n-; Java driver option similar to C-family option.\n-\n-I\n-Java Joined Separate\n-; Documented for C\n-\n-M\n-Java\n-; Documented for C\n-\n-MD_\n-Java Undocumented RejectDriver\n-; Documented for C\n-\n-MF\n-Java Separate\n-; Documented for C\n-\n-MM\n-Java\n-; Documented for C\n-\n-MMD_\n-Java Undocumented RejectDriver\n-; Documented for C\n-\n-MP\n-Java\n-; Documented for C\n-\n-MT\n-Java Separate\n-; Documented for C\n-\n-Wall\n-Java\n-; Documented for C\n-\n-Wdeprecated\n-Java Var(warn_deprecated)\n-; Documented for C\n-\n-Wextraneous-semicolon\n-Java Var(flag_extraneous_semicolon)\n-Warn if deprecated empty statements are found.\n-\n-Wout-of-date\n-Java Var(flag_newer) Init(1)\n-Warn if .class files are out of date.\n-\n-Wredundant-modifiers\n-Java Var(flag_redundant)\n-Warn if modifiers are specified when not necessary.\n-\n-bootclasspath\n-Java Separate Alias(fbootclasspath=)\n-\n-classpath\n-Java Separate Alias(fclasspath=)\n-\n-d\n-Java Separate SeparateAlias Alias(foutput-class-dir=)\n-; Different from language-independent -d with joined argument.\n-\n-encoding\n-Java Separate Alias(fencoding=)\n-\n-extdirs\n-Driver Separate\n-\n-fCLASSPATH=\n-Java JoinedOrMissing RejectNegative Alias(fclasspath=)\n---CLASSPATH\tDeprecated; use --classpath instead.\n-\n-faux-classpath\n-Java Separate RejectNegative Undocumented\n-\n-fassert\n-Java Var(flag_assert) Init(1)\n-Permit the use of the assert keyword.\n-\n-fassume-compiled\n-Java\n-\n-fassume-compiled=\n-Java JoinedOrMissing\n-\n-fenable-assertions\n-Java\n-\n-fenable-assertions=\n-Java JoinedOrMissing\n-\n-fdisable-assertions\n-Java\n-\n-fdisable-assertions=\n-Java JoinedOrMissing\n-\n-fbootclasspath=\n-Java JoinedOrMissing RejectNegative\n---bootclasspath=<path>\tReplace system path.\n-\n-fcheck-references\n-Java Var(flag_check_references)\n-Generate checks for references to NULL.\n-\n-fclasspath=\n-Java JoinedOrMissing RejectNegative\n---classpath=<path>\tSet class path.\n-\n-fcompile-resource=\n-Java Joined RejectNegative\n-\n-femit-class-file\n-Java Var(flag_emit_class_files)\n-Output a class file.\n-\n-femit-class-files\n-Java Var(flag_emit_class_files)\n-Alias for -femit-class-file.\n-\n-fencoding=\n-Java Joined RejectNegative\n---encoding=<encoding>\tChoose input encoding (defaults from your locale).\n-\n-fextdirs=\n-Java Joined RejectNegative\n---extdirs=<path>\tSet the extension directory path.\n-\n-fmain=\n-Driver JoinedOrMissing RejectNegative\n-\n-fsource-filename=\n-Java Joined Undocumented \n-\n-ffilelist-file\n-Java Var(flag_filelist_file)\n-Input file is a file with a list of filenames to compile.\n-\n-fsaw-java-file\n-Java Undocumented RejectNegative\n-\n-fforce-classes-archive-check\n-Java Var(flag_force_classes_archive_check)\n-Always check for non gcj generated classes archives.\n-\n-fhash-synchronization\n-Java Var(flag_hash_synchronization)\n-Assume the runtime uses a hash table to map an object to its synchronization structure.\n-\n-findirect-classes\n-Java Var(flag_indirect_classes) Init(1)\n-Generate instances of Class at runtime.\n-\n-findirect-dispatch\n-Java Var(flag_indirect_dispatch)\n-Use offset tables for virtual method calls.\n-\n-finline-functions\n-Java\n-\n-fjni\n-Java Var(flag_jni)\n-Assume native functions are implemented using JNI.\n-\n-foptimize-static-class-initialization\n-Java Var(flag_optimize_sci)\n-Enable optimization of static class initialization code.\n-\n-foutput-class-dir=\n-Java Joined RejectNegative\n-\n-freduced-reflection\n-Java Var(flag_reduced_reflection)\n-Reduce the amount of reflection meta-data generated.\n-\n-fstore-check\n-Java Var(flag_store_check) Init(1)\n-Enable assignability checks for stores into object arrays.\n-\n-fuse-boehm-gc\n-Java Var(flag_use_boehm_gc)\n-Generate code for the Boehm GC.\n-\n-fuse-divide-subroutine\n-Java Var(flag_use_divide_subroutine) Init(1)\n-Call a library routine to do integer divisions.\n-\n-fuse-atomic-builtins\n-Java Var(flag_use_atomic_builtins) Init(0)\n-Generate code for built-in atomic operations.\n-\n-fbootstrap-classes\n-Java Var(flag_bootstrap_classes)\n-Generated should be loaded by bootstrap loader.\n-\n-fsource=\n-Java Joined\n-Set the source language version.\n-\n-ftarget=\n-Java Joined\n-Set the target VM version.\n-\n-s-bc-abi\n-Driver\n-\n-static-libgcj\n-Driver\n-\n-version\n-Java RejectDriver\n-\n-;\n-; Warnings handled by ecj.\n-; FIXME: document them\n-;\n-\n-Wconstructor-name\n-Java\n-\n-Wpkg-default-method\n-Java\n-\n-Wmasked-catch-block\n-Java\n-\n-Wall-deprecation\n-Java\n-\n-Wunused-local\n-Java\n-\n-Wunused-argument\n-Java\n-\n-Wunused-import\n-Java\n-\n-Wunused-private\n-Java\n-\n-Wunused-label\n-Java\n-\n-Wlocal-hiding\n-Java\n-\n-Wfield-hiding\n-Java\n-\n-Wspecial-param-hiding\n-Java\n-\n-Wcondition-assign\n-Java\n-\n-Wsynthetic-access\n-Java\n-\n-Wnls\n-Java\n-\n-Wstatic-receiver\n-Java\n-\n-Windirect-static\n-Java\n-\n-Wno-effect-assign\n-Java\n-\n-Wintf-non-inherited\n-Java\n-\n-Wchar-concat\n-Java\n-\n-Wserial\n-Java\n-\n-Wempty-block\n-Java\n-\n-Wuseless-type-check\n-Java\n-\n-Wuncheck\n-Java\n-\n-Wraw\n-Java\n-\n-Wfinal-bound\n-Java\n-\n-Wsuppress\n-Java\n-\n-Wwarning-token\n-Java\n-\n-Wunnecessary-else\n-Java\n-\n-Wjavadoc\n-Java\n-\n-Wall-javadoc\n-Java\n-\n-Wtasks\n-Java\n-\n-Wassert-identifier\n-Java\n-\n-Wenum-identifier\n-Java\n-\n-Wfinally\n-Java\n-\n-Wunused-thrown\n-Java\n-\n-Wunqualified-field\n-Java\n-\n-Wtype-hiding\n-Java\n-\n-Wvarargs-cast\n-Java\n-\n-Wnull\n-Java\n-\n-Wboxing\n-Java\n-\n-Wover-ann\n-Java\n-\n-Wdep-ann\n-Java\n-\n-Wintf-annotation\n-Java\n-\n-Wenum-switch\n-Java\n-\n-Whiding\n-Java\n-\n-Wstatic-access\n-Java\n-\n-Wunused\n-Java\n-\n-Wparam-assign\n-Java\n-\n-Wdiscouraged\n-Java\n-\n-Wforbidden\n-Java\n-\n-Wfallthrough\n-Java\n-"}, {"sha": "d61fc028ae0e54b98c577c8cc48ee4107ebf89c6", "filename": "gcc/java/mangle.c", "status": "removed", "additions": 0, "deletions": 725, "changes": 725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,725 +0,0 @@\n-/* Functions related to mangling class names for the GNU compiler\n-   for the Java(TM) language.\n-   Copyright (C) 1998-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Per Bothner <bothner@cygnus.com> */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"jcf.h\"\n-#include \"java-tree.h\"\n-#include \"langhooks-def.h\"\n-\n-static void mangle_class_field (tree);\n-static void mangle_vtable (tree);\n-static void mangle_field_decl (tree);\n-static void mangle_method_decl (tree);\n-static void mangle_local_cni_method_decl (tree);\n-\n-static void mangle_type (tree);\n-static void mangle_pointer_type (tree);\n-static void mangle_array_type (tree);\n-static int  mangle_record_type (tree, int);\n-\n-static int find_compression_pointer_match (tree);\n-static int find_compression_array_match (tree);\n-static int find_compression_record_match (tree, tree *);\n-static int find_compression_array_template_match (tree);\n-\n-static void set_type_package_list (tree);\n-static int  entry_match_pointer_p (tree, int);\n-static void emit_compression_string (int);\n-\n-static void init_mangling (void);\n-static tree finish_mangling (void);\n-static void compression_table_add (tree);\n-\n-static void mangle_member_name (tree);\n-\n-static struct obstack mangle_obstack_1;\n-struct obstack *mangle_obstack;\n-\n-#define MANGLE_RAW_STRING(S) \\\n-  obstack_grow (mangle_obstack, (S), sizeof (S)-1)\n-\n-/* atms: array template mangled string. */\n-static GTY(()) tree atms;\n-\n-/* This is the mangling interface: a decl, a class field (.class) and\n-   the vtable. */\n-\n-void\n-java_mangle_decl (tree decl)\n-{\n-  /* A copy of the check from the beginning of lhd_set_decl_assembler_name.  */\n-\n-  /* set_decl_assembler_name may be called on TYPE_DECL to record ODR\n-     name for C++ types.  By default types have no ODR names.  */\n-  if (TREE_CODE (decl) == TYPE_DECL)\n-    return;\n-\n-  /* The language-independent code should never use the\n-     DECL_ASSEMBLER_NAME for lots of DECLs.  Only FUNCTION_DECLs and\n-     VAR_DECLs for variables with static storage duration need a real\n-     DECL_ASSEMBLER_NAME.  */\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t      || (TREE_CODE (decl) == VAR_DECL\n-\t\t  && (TREE_STATIC (decl)\n-\t\t      || DECL_EXTERNAL (decl)\n-\t\t      || TREE_PUBLIC (decl))));\n-\n-  /* Mangling only applies to class members.  */\n-  if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n-    {\n-      init_mangling ();\n-      switch (TREE_CODE (decl))\n-\t{\n-\tcase VAR_DECL:\n-\t  if (DECL_LANG_SPECIFIC (decl))\n-\t    {\n-\t      if (DECL_CLASS_FIELD_P (decl))\n-\t\t{\n-\t\t  mangle_class_field (decl);\n-\t\t  break;\n-\t\t}\n-\t      else if (DECL_VTABLE_P (decl))\n-\t\t{\n-\t\t  mangle_vtable (DECL_CONTEXT (decl));\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  mangle_field_decl (decl);\n-\t  break;\n-\n-\tcase FUNCTION_DECL:\n-\t  if (DECL_LANG_SPECIFIC (decl) && DECL_LOCAL_CNI_METHOD_P (decl))\n-\t    mangle_local_cni_method_decl (decl);\n-\t  else\n-\t    mangle_method_decl (decl);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      SET_DECL_ASSEMBLER_NAME (decl, finish_mangling ());\n-    }\n-  else\n-    lhd_set_decl_assembler_name (decl);\n-}\n-\n-/* Beginning of the helper functions */\n-\n-static void\n-mangle_class_field (tree decl)\n-{\n-  tree type = DECL_CONTEXT (decl);\n-  mangle_record_type (type, /* for_pointer = */ 0);\n-  if (TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE)\n-    MANGLE_RAW_STRING (\"6class$\");\n-  else\n-    MANGLE_RAW_STRING (\"7class$$\");\n-  obstack_1grow (mangle_obstack, 'E');\n-}\n-\n-static void\n-mangle_vtable (tree type)\n-{\n-  MANGLE_RAW_STRING (\"TV\");\n-  mangle_record_type (type, /* for_pointer = */ 0);\n-  obstack_1grow (mangle_obstack, 'E');\n-}\n-\n-/* This mangles a field decl */\n-\n-static void\n-mangle_field_decl (tree decl)\n-{\n-  /* Mangle the name of the this the field belongs to */\n-  mangle_record_type (DECL_CONTEXT (decl), /* for_pointer = */ 0);\n-  \n-  /* Mangle the name of the field */\n-  mangle_member_name (DECL_NAME (decl));\n-\n-  /* Terminate the mangled name */\n-  obstack_1grow (mangle_obstack, 'E');\n-}\n-\n-/* This mangles a method decl, first mangling its name and then all\n-   its arguments. */\n-\n-static void\n-mangle_method_decl (tree mdecl)\n-{\n-  tree method_name = DECL_NAME (mdecl);\n-  tree arglist;\n-\n-  /* Mangle the name of the type that contains mdecl */\n-  mangle_record_type (DECL_CONTEXT (mdecl), /* for_pointer = */ 0);\n-\n-  /* Mangle the function name.  There are two cases:\n-       - mdecl is a constructor, use `C1' for its name, (denotes a\n-         complete object constructor.)\n-       - mdecl is not a constructor, standard mangling is performed.\n-     We terminate the mangled function name with a `E'. */\n-  if (ID_INIT_P (method_name))\n-    obstack_grow (mangle_obstack, \"C1\", 2);\n-  else\n-    mangle_member_name (method_name);\n-  obstack_1grow (mangle_obstack, 'E');\n-\n-  /* We mangled type.methodName. Now onto the arguments. */\n-  arglist = TYPE_ARG_TYPES (TREE_TYPE (mdecl));\n-  if (TREE_CODE (TREE_TYPE (mdecl)) == METHOD_TYPE)\n-    arglist = TREE_CHAIN (arglist);\n-  \n-  /* Output literal 'J' and mangle the return type IF not a \n-     constructor.  */\n-  if (!ID_INIT_P (method_name))\n-    {\n-      obstack_1grow (mangle_obstack, 'J');\n-      mangle_type(TREE_TYPE(TREE_TYPE(mdecl)));\n-    }\n-  \n-  /* No arguments is easy. We shortcut it. */\n-  if (arglist == end_params_node)\n-    obstack_1grow (mangle_obstack, 'v');\n-  else\n-    {\n-      tree arg;\n-      for (arg = arglist; arg != end_params_node;  arg = TREE_CHAIN (arg))\n-\tmangle_type (TREE_VALUE (arg));\n-    }\n-}\n-\n-/* This mangles a CNI method for a local class.  If the target supports\n-   hidden aliases, then G++ will have generated one for us.  It is the\n-   responsibility of java_mark_class_local to check target support, since\n-   we need to set DECL_VISIBILITY (or not) much earlier.  */\n-\n-static void\n-mangle_local_cni_method_decl (tree decl)\n-{\n-  MANGLE_RAW_STRING (\"GA\");\n-  mangle_method_decl (decl);\n-}\n-\n-/* This mangles a member name, like a function name or a field\n-   name. Handle cases were `name' is a C++ keyword.  Return a nonzero\n-   value if unicode encoding was required.  */\n-\n-static void\n-mangle_member_name (tree name)\n-{\n-  append_gpp_mangled_name (IDENTIFIER_POINTER (name),\n-\t\t\t   IDENTIFIER_LENGTH (name));\n-}\n-\n-/* Append the mangled name of TYPE onto OBSTACK.  */\n-\n-static void\n-mangle_type (tree type)\n-{\n-  switch (TREE_CODE (type))\n-    {\n-      char code;\n-    case BOOLEAN_TYPE: code = 'b';  goto primitive;\n-    case VOID_TYPE:    code = 'v';  goto primitive;\n-    case INTEGER_TYPE:\n-      if (type == char_type_node || type == promoted_char_type_node)\n-\t{\n-\t  code = 'w';\n-\t  goto primitive;\n-\t}\n-      /* Get the original type instead of the arguments promoted type.\n-\t Avoid symbol name clashes. Should call a function to do that.\n-\t FIXME.  */\n-      if (type == promoted_short_type_node)\n-\ttype = short_type_node;\n-      if (type == promoted_byte_type_node)\n-        type = byte_type_node;\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase  8:       code = 'c';  goto primitive;\n-\tcase 16:       code = 's';  goto primitive;\n-\tcase 32:       code = 'i';  goto primitive;\n-\tcase 64:       code = 'x';  goto primitive;\n-\tdefault:  goto bad_type;\n-\t}\n-    primitive:\n-      obstack_1grow (mangle_obstack, code);\n-      break;\n-\n-    case REAL_TYPE:\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase 32:       code = 'f';  goto primitive;\n-\tcase 64:       code = 'd';  goto primitive;\n-\tdefault:  goto bad_type;\n-\t}\n-    case POINTER_TYPE:\n-      if (TYPE_ARRAY_P (TREE_TYPE (type)))\n-\tmangle_array_type (type);\n-      else\n-\tmangle_pointer_type (type);\n-      break;\n-    bad_type:\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* The compression table is a vector that keeps track of things we've\n-   already seen, so they can be reused. For example, java.lang.Object\n-   would generate three entries: two package names and a type. If\n-   java.lang.String is presented next, the java.lang will be matched\n-   against the first two entries (and kept for compression as S0_), and\n-   type String would be added to the table. See mangle_record_type.\n-   COMPRESSION_NEXT is the index to the location of the next insertion\n-   of an element.  */\n-\n-static GTY(()) tree compression_table;\n-static int  compression_next;\n-\n-/* Find a POINTER_TYPE in the compression table. Use a special\n-   function to match pointer entries and start from the end */\n-\n-static int\n-find_compression_pointer_match (tree type)\n-{\n-  int i;\n-\n-  for (i = compression_next-1; i >= 0; i--)\n-    if (entry_match_pointer_p (type, i))\n-      return i;\n-  return -1;\n-}\n-\n-/* Already recorder arrays are handled like pointer as they're always\n-   associated with it.  */\n-\n-static int\n-find_compression_array_match (tree type)\n-{\n-  return find_compression_pointer_match (type);\n-}\n-\n-/* Match the table of type against STRING.  */\n-\n-static int\n-find_compression_array_template_match (tree string)\n-{\n-  int i;\n-  for (i = 0; i < compression_next; i++)\n-    if (TREE_VEC_ELT (compression_table, i) == string) \n-      return i;\n-  return -1;\n-}\n-\n-/* We go through the compression table and try to find a complete or\n-   partial match. The function returns the compression table entry\n-   that (eventually partially) matches TYPE. *NEXT_CURRENT can be set\n-   to the rest of TYPE to be mangled. */\n-\n-static int\n-find_compression_record_match (tree type, tree *next_current)\n-{\n-  int i, match = -1;\n-  tree current, saved_current = NULL_TREE;\n-\n-  current = TYPE_PACKAGE_LIST (type);\n-      \n-  for (i = 0; i < compression_next; i++)\n-    {\n-      tree compression_entry = TREE_VEC_ELT (compression_table, i);\n-      if (current && compression_entry == TREE_PURPOSE (current))\n-        {\n-\t  match = i;\n-\t  saved_current = current;\n-\t  current = TREE_CHAIN (current);\n-\t}\n-      else\n-\t/* We don't want to match an element that appears in the middle\n-\t   of a package name, so skip forward to the next complete type name.\n-\t   IDENTIFIER_NODEs (except for a \"6JArray\") are partial package\n-\t   names while RECORD_TYPEs represent complete type names. */\n-\twhile (i < compression_next \n-\t       && TREE_CODE (compression_entry) == IDENTIFIER_NODE\n-\t       && compression_entry != atms)\n-\t  compression_entry = TREE_VEC_ELT (compression_table, ++i);\n-    }\n-\n-  if (!next_current)\n-    return match;\n-\n-  /* If we have a match, set next_current to the item next to the last\n-     matched value. */\n-  if (match >= 0)\n-    *next_current = TREE_CHAIN (saved_current);\n-  /* We had no match: we'll have to start from the beginning. */\n-  if (match < 0)\n-    *next_current = TYPE_PACKAGE_LIST (type);\n-\n-  return match;\n-}\n-\n-/* Mangle a record type. If a nonzero value is returned, it means\n-   that a 'N' was emitted (so that a matching 'E' can be emitted if\n-   necessary.)  FOR_POINTER indicates that this element is for a pointer\n-   symbol, meaning it was preceded by a 'P'. */\n-\n-static int\n-mangle_record_type (tree type, int for_pointer)\n-{\n-  tree current;\n-  int match;\n-  int nadded_p = 0;\n-  int qualified;\n-  \n-  /* Does this name have a package qualifier? */\n-  qualified = QUALIFIED_P (DECL_NAME (TYPE_NAME (type)));\n-\n-#define ADD_N() \\\n-  do { obstack_1grow (mangle_obstack, 'N'); nadded_p = 1; } while (0)\n-\n-  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n-\n-  if (!TYPE_PACKAGE_LIST (type))\n-    set_type_package_list (type);\n-\n-  match = find_compression_record_match (type, &current);\n-  if (match >= 0)\n-    {\n-      /* If we had a pointer, and there's more, we need to emit\n-\t 'N' after 'P' (for_pointer tells us we already emitted it.) */\n-      if (for_pointer && current)\n-\tADD_N();\n-      emit_compression_string (match);\n-    }\n-  while (current)\n-    {\n-      /* Add the new type to the table */\n-      compression_table_add (TREE_PURPOSE (current));\n-      /* Add 'N' if we never got a chance to, but only if we have a qualified\n-         name.  For non-pointer elements, the name is always qualified. */\n-      if ((qualified || !for_pointer) && !nadded_p)\n-\tADD_N();\n-      /* Use the bare type name for the mangle. */\n-      append_gpp_mangled_name (IDENTIFIER_POINTER (TREE_VALUE (current)),\n-\t\t\t       IDENTIFIER_LENGTH (TREE_VALUE (current)));\n-      current = TREE_CHAIN (current);\n-    }\n-  return nadded_p;\n-#undef ADD_N\n-}\n-\n-/* Mangle a pointer type. There are two cases: the pointer is already\n-   in the compression table: the compression is emitted sans 'P'\n-   indicator. Otherwise, a 'P' is emitted and, depending on the type,\n-   a partial compression or/plus the rest of the mangling. */\n-\n-static void\n-mangle_pointer_type (tree type)\n-{\n-  int match;\n-  tree pointer_type;\n-\n-  /* Search for the type already in the compression table */\n-  if ((match = find_compression_pointer_match (type)) >= 0) \n-    {\n-      emit_compression_string (match);\n-      return;\n-    }\n-  \n-  /* This didn't work. We start by mangling the pointed-to type */\n-  pointer_type = type;\n-  type = TREE_TYPE (type);\n-  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n-  \n-  obstack_1grow (mangle_obstack, 'P');\n-  if (mangle_record_type (type, /* for_pointer = */ 1))\n-    obstack_1grow (mangle_obstack, 'E');\n-\n-  /* Don't forget to insert the pointer type in the table */\n-  compression_table_add (pointer_type);\n-}\n-\n-/* Mangle an array type. Search for an easy solution first, then go\n-   through the process of finding out whether the bare array type or even\n-   the template indicator were already used and compressed appropriately.\n-   It handles pointers. */\n-\n-static void\n-mangle_array_type (tree p_type)\n-{\n-  tree type, elt_type;\n-  int match;\n-\n-  type = TREE_TYPE (p_type);\n-  gcc_assert (type);\n-\n-  elt_type = TYPE_ARRAY_ELEMENT (type);\n-\n-  /* We cache a bit of the Jarray <> mangle. */\n-  if (!atms)\n-    {\n-      atms = get_identifier (\"6JArray\");\n-    }\n-\n-  /* Maybe we have what we're looking for in the compression table. */\n-  if ((match = find_compression_array_match (p_type)) >= 0)\n-    {\n-      emit_compression_string (match);\n-      return;\n-    }\n-\n-  /* We know for a fact that all arrays are pointers */\n-  obstack_1grow (mangle_obstack, 'P');\n-  /* Maybe we already have a Jarray<t> somewhere. PSx_ will be enough. */\n-  if ((match = find_compression_record_match (type, NULL)) > 0)\n-    {\n-      emit_compression_string (match);\n-      return;\n-    }\n-\n-  /* Maybe we already have just JArray somewhere */\n-  if ((match = find_compression_array_template_match (atms)) > 0)\n-    emit_compression_string (match);\n-  else\n-    {\n-      /* Start the template mangled name */\n-      obstack_grow (mangle_obstack, \n-\t\t    IDENTIFIER_POINTER (atms), IDENTIFIER_LENGTH (atms));\n-      /* Insert in the compression table */\n-      compression_table_add (atms);\n-    } \n-\n-  /* Mangle Jarray <elt_type> */\n-  obstack_1grow (mangle_obstack, 'I');\n-  mangle_type (elt_type);\n-  obstack_1grow (mangle_obstack, 'E');\n-\n-  /* Add `Jarray <elt_type>' and `Jarray <elt_type> *' to the table */\n-  compression_table_add (type);\n-  compression_table_add (p_type);\n-}\n-\n-/* Write a substitution string for entry I. Substitution string starts a\n-   -1 (encoded S_.) The base is 36, and the code shamelessly taken from\n-   cp/mangle.c.  */\n-\n-static void\n-emit_compression_string (int i)\n-{\n-  i -= 1;\t\t\t/* Adjust */\n-  obstack_1grow (mangle_obstack, 'S');\n-  if (i >= 0)\n-    {\n-      static const char digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-      unsigned HOST_WIDE_INT n;\n-      unsigned HOST_WIDE_INT m=1;\n-      /* How many digits for I in base 36? */\n-      for (n = i; n >= 36; n /= 36, m *=36);\n-      /* Write the digits out */\n-      while (m > 0)\n-\t{\n-\t  int digit = i / m;\n-\t  obstack_1grow (mangle_obstack, digits [digit]);\n-\t  i -= digit * m;\n-\t  m /= 36;\n-\t}\n-    }\n-  obstack_1grow (mangle_obstack, '_');\n-}\n-\n-/* If search the compression table at index I for a pointer type\n-   equivalent to TYPE (meaning that after all the indirection, which\n-   might all be unique, we find the same RECORD_TYPE.) */\n-\n-static int\n-entry_match_pointer_p (tree type, int i)\n-{\n-  tree t = TREE_VEC_ELT (compression_table, i);\n-  \n-  while (TREE_CODE (type) == POINTER_TYPE\n-\t && TREE_CODE (t) == POINTER_TYPE)\n-    {\n-      t = TREE_TYPE (t);\n-      type = TREE_TYPE (type);\n-    }\n-  return (TREE_CODE (type) == RECORD_TYPE\n-\t  && TREE_CODE (t) == RECORD_TYPE\n-\t  && t == type);\n-}\n-\n-/* Go through all qualification of type and build a list of list node\n-   elements containings as a purpose what should be used for a match and\n-   inserted in the compression table; and as it value the raw name of the\n-   part. The result is stored in TYPE_PACKAGE_LIST to be reused.  */\n-\n-static void\n-set_type_package_list (tree type)\n-{\n-  int i;\n-  const char *type_string = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-  const char *ptr;\n-  int qualifications;\n-  tree list = NULL_TREE, elt;\n-\n-  for (ptr = type_string, qualifications = 0; *ptr; ptr++)\n-    if (*ptr == '.')\n-      qualifications += 1;\n-\n-  for (ptr = type_string, i = 0; i < qualifications; ptr++)\n-    {\n-      if (ptr [0] == '.')\n-\t{\n-\t  tree const identifier\n-\t    = get_identifier_with_length (type_string, ptr - type_string);\n-\n-\t  elt = build_tree_list (identifier, identifier);\n-\t  TREE_CHAIN (elt) = list;\n-\t  list = elt;\n-\t  type_string = ptr+1;\n-\t  i += 1;\n-\t}\n-    }\n-\n-  elt = build_tree_list (type, get_identifier (type_string));\n-  TREE_CHAIN (elt) = list;\n-  list = elt;\n-  TYPE_PACKAGE_LIST (type) = nreverse (list);\n-}\n-\n-/* Add TYPE as the last element of the compression table. Resize the\n-   compression table if necessary.  */\n-\n-static void\n-compression_table_add (tree type)\n-{\n-  if (compression_next == TREE_VEC_LENGTH (compression_table))\n-    {\n-      tree new_table = make_tree_vec (2*compression_next);\n-      int i;\n-\n-      for (i = 0; i < compression_next; i++)\n-\tTREE_VEC_ELT (new_table, i) = TREE_VEC_ELT (compression_table, i);\n-\n-      compression_table = new_table;\n-    }\n-  TREE_VEC_ELT (compression_table, compression_next++) = type;\n-}\n-\n-/* Mangle an embedded resource file name.  \"_ZGr\" is the prefix.  A\n-   '_' is prepended to the name so that names starting with a digit\n-   can be demangled.  The length and then the resulting name itself\n-   are appended while escaping '$', '.', and '/' to: \"$$\", \"$_\", and\n-   \"$S\".  */\n-\n-tree\n-java_mangle_resource_name (const char *name)\n-{\n-  int len = strlen (name);\n-  char *buf = (char *) alloca (2 * len + 1);\n-  char *pos;\n-  const unsigned char *w1 = (const unsigned char *) name;\n-  const unsigned char *w2;\n-  const unsigned char *limit = w1 + len;\n-\n-  pos = buf;\n-\n-  init_mangling ();\n-  MANGLE_RAW_STRING (\"Gr\");\n-\n-  *pos++ = '_';\n-  while (w1 < limit)\n-    {\n-      int ch;\n-      w2 = w1;\n-      ch = UTF8_GET (w1, limit);\n-      gcc_assert (ch > 0);\n-      switch (ch)\n-\t{\n-\tcase '$':\n-\t  *pos++ = '$';\n-\t  *pos++ = '$';\n-\t  break;\n-\tcase '.':\n-\t  *pos++ = '$';\n-\t  *pos++ = '_';\n-\t  break;\n-\tcase '/':\n-\t  *pos++ = '$';\n-\t  *pos++ = 'S';\n-\t  break;\n-\tdefault:\n-\t  memcpy (pos, w2, w1 - w2);\n-\t  pos += w1 - w2;\n-\t  break;\n-\t}\n-    }\n-  append_gpp_mangled_name (buf, pos - buf);\n-\n-  return finish_mangling ();\n-}\n-\n-/* Mangling initialization routine.  */\n-\n-static void\n-init_mangling (void)\n-{\n-  if (!mangle_obstack)\n-    {\n-      mangle_obstack = &mangle_obstack_1;\n-      gcc_obstack_init (mangle_obstack);\n-    }\n-\n-  gcc_assert (compression_table == NULL);\n-  compression_table = make_tree_vec (10);\n-\n-  /* Mangled name are to be suffixed */\n-  MANGLE_RAW_STRING (\"_Z\");\n-}\n-\n-/* Mangling finalization routine. The mangled name is returned as a\n-   IDENTIFIER_NODE.  */\n-\n-static tree\n-finish_mangling (void)\n-{\n-  tree result;\n-\n-  gcc_assert (compression_table);\n-\n-  compression_table = NULL_TREE;\n-  compression_next = 0;\n-  obstack_1grow (mangle_obstack, '\\0');\n-  result = get_identifier ((char *) obstack_base (mangle_obstack));\n-  obstack_free (mangle_obstack, obstack_base (mangle_obstack));\n-\n-  return result;\n-}\n-\n-#include \"gt-java-mangle.h\""}, {"sha": "7627c5d5df30e558648d47b59a6ebb268e4e25fa", "filename": "gcc/java/mangle_name.c", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fmangle_name.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fmangle_name.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle_name.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,409 +0,0 @@\n-/* Shared functions related to mangling names for the GNU compiler\n-   for the Java(TM) language.\n-   Copyright (C) 2001-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. \n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* Written by Alexandre Petit-Bianco <apbianco@cygnus.com> */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"obstack.h\"\n-#include \"diagnostic-core.h\"\n-#include \"jcf.h\"\n-\n-static void append_unicode_mangled_name (const char *, int);\n-#ifndef HAVE_AS_UTF8\n-static int  unicode_mangling_length (const char *, int);\n-#endif\n-\n-extern struct obstack *mangle_obstack;\n-\n-static int\n-utf8_cmp (const unsigned char *str, int length, const char *name)\n-{\n-  const unsigned char *limit = str + length;\n-  int i;\n-\n-  for (i = 0; name[i]; ++i)\n-    {\n-      int ch = UTF8_GET (str, limit);\n-      if (ch != name[i])\n-\treturn ch - name[i];\n-    }\n-\n-  return str == limit ? 0 : 1;\n-}\n-\n-/* A sorted list of all C++ keywords.  If you change this, be sure\n-   also to change the list in\n-   libjava/classpath/tools/gnu/classpath/tools/javah/Keywords.java.  */\n-static const char *const cxx_keywords[] =\n-{\n-  \"_Complex\",\n-  \"__alignof\",\n-  \"__alignof__\",\n-  \"__asm\",\n-  \"__asm__\",\n-  \"__attribute\",\n-  \"__attribute__\",\n-  \"__builtin_va_arg\",\n-  \"__complex\",\n-  \"__complex__\",\n-  \"__const\",\n-  \"__const__\",\n-  \"__extension__\",\n-  \"__imag\",\n-  \"__imag__\",\n-  \"__inline\",\n-  \"__inline__\",\n-  \"__label__\",\n-  \"__null\",\n-  \"__real\",\n-  \"__real__\",\n-  \"__restrict\",\n-  \"__restrict__\",\n-  \"__signed\",\n-  \"__signed__\",\n-  \"__typeof\",\n-  \"__typeof__\",\n-  \"__volatile\",\n-  \"__volatile__\",\n-  \"and\",\n-  \"and_eq\",\n-  \"asm\",\n-  \"auto\",\n-  \"bitand\",\n-  \"bitor\",\n-  \"bool\",\n-  \"break\",\n-  \"case\",\n-  \"catch\",\n-  \"char\",\n-  \"class\",\n-  \"compl\",\n-  \"const\",\n-  \"const_cast\",\n-  \"continue\",\n-  \"default\",\n-  \"delete\",\n-  \"do\",\n-  \"double\",\n-  \"dynamic_cast\",\n-  \"else\",\n-  \"enum\",\n-  \"explicit\",\n-  \"export\",\n-  \"extern\",\n-  \"false\",\n-  \"float\",\n-  \"for\",\n-  \"friend\",\n-  \"goto\",\n-  \"if\",\n-  \"inline\",\n-  \"int\",\n-  \"long\",\n-  \"mutable\",\n-  \"namespace\",\n-  \"new\",\n-  \"not\",\n-  \"not_eq\",\n-  \"operator\",\n-  \"or\",\n-  \"or_eq\",\n-  \"private\",\n-  \"protected\",\n-  \"public\",\n-  \"register\",\n-  \"reinterpret_cast\",\n-  \"return\",\n-  \"short\",\n-  \"signed\",\n-  \"sizeof\",\n-  \"static\",\n-  \"static_cast\",\n-  \"struct\",\n-  \"switch\",\n-  \"template\",\n-  \"this\",      \n-  \"throw\",\n-  \"true\",\n-  \"try\",\n-  \"typedef\",\n-  \"typeid\",\n-  \"typename\",\n-  \"typeof\",\n-  \"union\",\n-  \"unsigned\",\n-  \"using\",\n-  \"virtual\",\n-  \"void\",\n-  \"volatile\",\n-  \"wchar_t\",\n-  \"while\",\n-  \"xor\",\n-  \"xor_eq\"\n-};\n-\n-/* Return true if NAME is a C++ keyword.  */\n-int\n-cxx_keyword_p (const char *name, int length)\n-{\n-  int last = ARRAY_SIZE (cxx_keywords);\n-  int first = 0;\n-  int mid = (last + first) / 2;\n-  int old = -1;\n-\n-  for (mid = (last + first) / 2;\n-       mid != old;\n-       old = mid, mid = (last + first) / 2)\n-    {\n-      int kwl = strlen (cxx_keywords[mid]);\n-      int min_length = kwl > length ? length : kwl;\n-      int r = utf8_cmp ((const unsigned char *) name, min_length, cxx_keywords[mid]);\n-\n-      if (r == 0)\n-\t{\n-\t  int i;\n-\t  /* We've found a match if all the remaining characters are `$'.  */\n-\t  for (i = min_length; i < length && name[i] == '$'; ++i)\n-\t    ;\n-\t  if (i == length)\n-\t    return 1;\n-\t  r = 1;\n-\t}\n-\n-      if (r < 0)\n-\tlast = mid;\n-      else\n-\tfirst = mid;\n-    }\n-  return 0;\n-}\n-\n-/* If NAME happens to be a C++ keyword, add `$'.  */\n-#define MANGLE_CXX_KEYWORDS(NAME, LEN)\t\t\t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (cxx_keyword_p ((NAME), (LEN)))\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tchar *tmp_buf = (char *)alloca ((LEN)+1);\t\\\n-\tmemcpy (tmp_buf, (NAME), (LEN));\t\t\\\n-\ttmp_buf[LEN]= '$';\t\t\t\t\\\n-\t(NAME) = tmp_buf;\t\t\t\t\\\n-\t(LEN)++;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-while (0)\n-\n-\n-/* If the assembler doesn't support UTF8 in symbol names, some\n-   characters might need to be escaped.  */\n-\n-#ifndef HAVE_AS_UTF8\n-\n-/* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n-   appropriately mangled (with Unicode escapes if needed) to\n-   MANGLE_OBSTACK.  Note that `java', `lang' and `Object' are used so\n-   frequently that they could be cached.  */\n-\n-void\n-append_gpp_mangled_name (const char *name, int len)\n-{\n-  int encoded_len, needs_escapes;\n-  /* Buffer large enough for INT_MIN.  */\n-  char buf[9];\n-\n-  MANGLE_CXX_KEYWORDS (name, len);\n-\n-  encoded_len = unicode_mangling_length (name, len);\n-  needs_escapes = encoded_len > 0;\n-\n-  sprintf (buf, \"%d\", (needs_escapes ? encoded_len : len));\n-  obstack_grow (mangle_obstack, buf, strlen (buf));\n-\n-  if (needs_escapes)\n-    append_unicode_mangled_name (name, len);\n-  else\n-    obstack_grow (mangle_obstack, name, len);\n-}\n-\n-/* Assuming (NAME, LEN) is a Utf8-encoded string, emit the string\n-   appropriately mangled (with Unicode escapes) to MANGLE_OBSTACK.\n-   Characters needing an escape are encoded `__UNN_' to `__UNNNN_', in\n-   which case `__U' will be mangled `__U_'.  */\n-\n-static void\n-append_unicode_mangled_name (const char *name, int len)\n-{\n-  const unsigned char *ptr;\n-  const unsigned char *limit = (const unsigned char *)name + len;\n-  int uuU = 0;\n-  for (ptr = (const unsigned char *) name;  ptr < limit;  )\n-    {\n-      int ch = UTF8_GET(ptr, limit);\n-\n-      if ((ISALNUM (ch) && ch != 'U') || ch == '$')\n-        {\n-\t  obstack_1grow (mangle_obstack, ch);\n-          uuU = 0;\n-        }\n-      /* Everything else needs encoding */\n-      else\n-\t{\n-\t  /* Buffer large enough for UINT_MAX plus the prefix.  */\n-\t  char buf [13];\n-\t  if (ch == '_' || ch == 'U')\n-\t    {\n-\t      /* Prepare to recognize __U */\n-\t      if (ch == '_' && (uuU < 3))\n-\t\t{\n-\t\t  uuU++;\n-\t\t  obstack_1grow (mangle_obstack, ch);\n-\t\t}\n-\t      /* We recognize __U that we wish to encode\n-                 __U_. Finish the encoding. */\n-\t      else if (ch == 'U' && (uuU == 2))\n-\t\t{\n-\t\t  uuU = 0;\n-\t\t  obstack_grow (mangle_obstack, \"U_\", 2);\n-\t\t}\n-\t      /* Otherwise, just reset uuU and emit the character we\n-                 have. */\n-\t      else\n-\t\t{\n-\t\t  uuU = 0;\n-\t\t  obstack_1grow (mangle_obstack, ch);\n-\t\t}\n-\t      continue;\n-\t    }\n-\t  sprintf (buf, \"__U%x_\", ch);\n-\t  obstack_grow (mangle_obstack, buf, strlen (buf));\n-\t  uuU = 0;\n-\t}\n-    }\n-}\n-\n-/* Assuming (NAME, LEN) is a Utf8-encoding string, calculate the\n-   length of the string as mangled (a la g++) including Unicode\n-   escapes.  If no escapes are needed, return 0.  */\n-\n-static int\n-unicode_mangling_length (const char *name, int len)\n-{\n-  const unsigned char *ptr;\n-  const unsigned char *limit = (const unsigned char *)name + len;\n-  int need_escapes = 0;\t\t/* Whether we need an escape or not */\n-  int num_chars = 0;\t\t/* Number of characters in the mangled name */\n-  int uuU = 0;\t\t\t/* Help us to find __U. 0: '_', 1: '__' */\n-  for (ptr = (const unsigned char *) name;  ptr < limit;  )\n-    {\n-      int ch = UTF8_GET(ptr, limit);\n-\n-      if (ch < 0)\n-\terror (\"internal error - invalid Utf8 name\");\n-      if ((ISALNUM (ch) && ch != 'U') || ch == '$')\n-\t{\n-\t  num_chars++;\n-\t  uuU = 0;\n-\t}\n-      /* Everything else needs encoding */\n-      else\n-\t{\n-\t  int encoding_length = 2;\n-\n-\t  if (ch == '_' || ch == 'U')\n-\t    {\n-\t      /* It's always at least one character. */\n-\t      num_chars++;\n-\n-\t      /* Prepare to recognize __U */\n-\t      if (ch == '_' && (uuU < 3))\n-\t\tuuU++;\n-\n-\t      /* We recognize __U that we wish to encode __U_, we\n-\t         count one more character. */\n-\t      else if (ch == 'U' && (uuU == 2))\n-\t\t{\n-\t\t  num_chars++;\n-\t\t  need_escapes = 1;\n-\t\t  uuU = 0;\n-\t\t}\n-\t      /* Otherwise, just reset uuU */\n-\t      else\n-\t\tuuU = 0;\n-\n-\t      continue;\n-\t    }\n-\t  \n-\t  if (ch > 0xff)\n-\t    encoding_length++;\n-\t  if (ch > 0xfff)\n-\t    encoding_length++;\n-\t  \n-\t  num_chars += (4 + encoding_length);\n-\t  need_escapes = 1;\n-\t  uuU = 0;\n-\t}\n-    }\n-  if (need_escapes)\n-    return num_chars;\n-  else\n-    return 0;\n-}\n-\n-#else\n-\n-/* The assembler supports UTF8, we don't use escapes. Mangling is\n-   simply <N>NAME. <N> is the number of UTF8 encoded characters that\n-   are found in NAME. Note that `java', `lang' and `Object' are used\n-   so frequently that they could be cached.  */\n-\n-void\n-append_gpp_mangled_name (const char *name, int len)\n-{\n-  const unsigned char *ptr;\n-  const unsigned char *limit;\n-  int encoded_len;\n-  char buf [6];\n-  \n-  MANGLE_CXX_KEYWORDS (name, len);\n-\n-  limit = (const unsigned char *)name + len;\n-\n-  /* Compute the length of the string we wish to mangle. */\n-  for (encoded_len =  0, ptr = (const unsigned char *) name;\n-       ptr < limit; encoded_len++)\n-    {\n-      int ch = UTF8_GET(ptr, limit);\n-\n-      if (ch < 0)\n-\terror (\"internal error - invalid Utf8 name\");\n-    }\n-\n-  sprintf (buf, \"%d\", encoded_len);\n-  obstack_grow (mangle_obstack, buf, strlen (buf));\n-  obstack_grow (mangle_obstack, name, len);\n-}\n-\n-#endif /* HAVE_AS_UTF8 */"}, {"sha": "644ca7409fb9e8f2644e3c3c8c22e520af0fb763", "filename": "gcc/java/parse.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,70 +0,0 @@\n-/* Language parser definitions for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1997-2016 Free Software Foundation, Inc.\n-   Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#ifndef GCC_JAVA_PARSE_H\n-#define GCC_JAVA_PARSE_H\n-\n-/* Extern global variable declarations */\n-extern struct obstack temporary_obstack;\n-\n-#ifdef VERBOSE_SKELETON\n-#undef SOURCE_FRONTEND_DEBUG\n-#define SOURCE_FRONTEND_DEBUG(X)\t\t\t\t\\\n-  {if (!quiet_flag) {printf (\"* \"); printf X; putchar ('\\n');} }\n-#else\n-#define SOURCE_FRONTEND_DEBUG(X)\n-#endif\n-\n-/* Types classification, according to the JLS, section 4.2 */\n-#define JFLOAT_TYPE_P(TYPE)      (TYPE && TREE_CODE ((TYPE)) == REAL_TYPE)\n-#define JINTEGRAL_TYPE_P(TYPE)   ((TYPE) \t\t\t\t   \\\n-\t\t\t\t  && (TREE_CODE ((TYPE)) == INTEGER_TYPE))\n-#define JNUMERIC_TYPE_P(TYPE)    ((TYPE)\t\t\t\t\\\n-\t\t\t\t  && (JFLOAT_TYPE_P ((TYPE))\t\t\\\n-\t\t\t\t      || JINTEGRAL_TYPE_P ((TYPE))))\n-#define JPRIMITIVE_TYPE_P(TYPE)  ((TYPE) \t\t\t\t  \\\n-\t\t\t\t  && (JNUMERIC_TYPE_P ((TYPE))\t\t  \\\n-\t\t\t\t  || TREE_CODE ((TYPE)) == BOOLEAN_TYPE))\n-\n-/* Not defined in the LRM */\n-#define JSTRING_TYPE_P(TYPE) ((TYPE) \t\t\t\t\t   \\\n-\t\t\t      && ((TYPE) == string_type_node ||\t\t   \\\n-\t\t\t\t  (TREE_CODE (TYPE) == POINTER_TYPE &&\t   \\\n-\t\t\t\t   TREE_TYPE (TYPE) == string_type_node)))\n-#define JREFERENCE_TYPE_P(TYPE) ((TYPE)\t\t\t\t\t      \\\n-\t\t\t\t && (TREE_CODE (TYPE) == RECORD_TYPE \t      \\\n-\t\t\t\t     ||\t(TREE_CODE (TYPE) == POINTER_TYPE     \\\n-\t\t\t\t\t &&  TREE_CODE (TREE_TYPE (TYPE)) ==  \\\n-\t\t\t\t\t RECORD_TYPE)))\n-\n-int java_report_errors (void);\n-extern tree do_resolve_class (tree, tree, tree, tree, tree);\n-\n-/* Always in use, no matter what you compile */\n-void java_push_parser_context (void);\n-void java_pop_parser_context (int);\n-extern void java_parser_context_save_global (void);\n-extern void java_parser_context_restore_global (void);\n-\n-#endif /* ! GCC_JAVA_PARSE_H */"}, {"sha": "3d500f6d487d68410a1137914bc74424b0f82d40", "filename": "gcc/java/resource.c", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=eae993948bae8b788c53772bcb9217c063716f93", "patch": "@@ -1,140 +0,0 @@\n-/* Functions related to building resource files.\n-   Copyright (C) 1996-2016 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"fold-const.h\"\n-#include \"stor-layout.h\"\n-#include \"java-tree.h\"\n-#include \"toplev.h\"\n-#include \"tree-iterator.h\"\n-\n-/* A list of all the resources files.  */\n-static GTY(()) vec<tree, va_gc> *resources;\n-\n-void\n-compile_resource_data (const char *name, const char *buffer, int length)\n-{\n-  tree rtype, field = NULL_TREE, data_type, rinit, data, decl;\n-  vec<constructor_elt, va_gc> *v = NULL;\n-\n-  data_type = build_prim_array_type (unsigned_byte_type_node,\n-\t\t\t\t     strlen (name) + length);\n-  rtype = make_node (RECORD_TYPE);\n-  PUSH_FIELD (input_location,\n-\t      rtype, field, \"name_length\", unsigned_int_type_node);\n-  PUSH_FIELD (input_location,\n-\t      rtype, field, \"resource_length\", unsigned_int_type_node);\n-  PUSH_FIELD (input_location, rtype, field, \"data\", data_type);\n-  FINISH_RECORD (rtype);\n-  START_RECORD_CONSTRUCTOR (v, rtype);\n-  PUSH_FIELD_VALUE (v, \"name_length\", \n-\t\t    build_int_cst (NULL_TREE, strlen (name)));\n-  PUSH_FIELD_VALUE (v, \"resource_length\", \n-\t\t    build_int_cst (NULL_TREE, length));\n-  data = build_string (strlen(name) + length, buffer);\n-  TREE_TYPE (data) = data_type;\n-  PUSH_FIELD_VALUE (v, \"data\", data);\n-  FINISH_RECORD_CONSTRUCTOR (rinit, v, rtype);\n-  TREE_CONSTANT (rinit) = 1;\n-\n-  decl = build_decl (input_location,\n-\t\t     VAR_DECL, java_mangle_resource_name (name), rtype);\n-  TREE_STATIC (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  java_hide_decl (decl);\n-  DECL_ARTIFICIAL (decl) = 1;\n-  DECL_IGNORED_P (decl) = 1;\n-  TREE_READONLY (decl) = 1;\n-  TREE_THIS_VOLATILE (decl) = 0;\n-  DECL_INITIAL (decl) = rinit;\n-  layout_decl (decl, 0);\n-  pushdecl (decl);\n-  rest_of_decl_compilation (decl, global_bindings_p (), 0);\n-  varpool_node::finalize_decl (decl);\n-\n-  vec_safe_push (resources, decl);\n-}\n-\n-void\n-write_resource_constructor (tree *list_p)\n-{\n-  tree decl, t, register_resource_fn;\n-  unsigned ix;\n-\n-  if (resources == NULL)\n-    return;\n-\n-  t = build_function_type_list (void_type_node, ptr_type_node, NULL);\n-  t = build_decl (input_location,\n-\t\t  FUNCTION_DECL, get_identifier (\"_Jv_RegisterResource\"), t);\n-  TREE_PUBLIC (t) = 1;\n-  DECL_EXTERNAL (t) = 1;\n-  register_resource_fn = t;\n-\n-  /* Write out entries in the same order in which they were defined.  */\n-  FOR_EACH_VEC_ELT (*resources, ix, decl)\n-    {\n-      t = build_fold_addr_expr (decl);\n-      t = build_call_expr (register_resource_fn, 1, t);\n-      append_to_statement_list (t, list_p);\n-    }\n-}\n-\n-/* Generate a byte array representing the contents of FILENAME.  The\n-   array is assigned a unique local symbol.  The array represents a\n-   compiled Java resource, which is accessed by the runtime using\n-   NAME.  */\n-void\n-compile_resource_file (const char *name, const char *filename)\n-{\n-  struct stat stat_buf;\n-  int fd;\n-  char *buffer;\n-\n-  fd = open (filename, O_RDONLY | O_BINARY);\n-  if (fd < 0)\n-    {\n-      perror (\"Failed to read resource file\");\n-      return;\n-    }\n-  if (fstat (fd, &stat_buf) != 0\n-      || ! S_ISREG (stat_buf.st_mode))\n-    {\n-      perror (\"Could not figure length of resource file\");\n-      return;\n-    }\n-  buffer = XNEWVEC (char, strlen (name) + stat_buf.st_size);\n-  strcpy (buffer, name);\n-  read (fd, buffer + strlen (name), stat_buf.st_size);\n-  close (fd);\n-\n-  compile_resource_data (name, buffer, stat_buf.st_size);\n-}\n-\n-#include \"gt-java-resource.h\""}, {"sha": "61394a982da5c18e61efa68e952ac2114ce1dae0", "filename": "gcc/java/typeck.c", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5921ac7cbb3a13e41ec42d51f262b8a195831bcd", "filename": "gcc/java/verify-glue.c", "status": "removed", "additions": 0, "deletions": 502, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fverify-glue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fverify-glue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-glue.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "08f1d41b85fa3e6076651aafcdd47660e7554dfc", "filename": "gcc/java/verify-impl.c", "status": "removed", "additions": 0, "deletions": 3308, "changes": 3308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fverify-impl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fverify-impl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-impl.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b807522d7e4ca5b83c6ec2fc3ff051da60f67cae", "filename": "gcc/java/verify.h", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fverify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fverify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.h?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "aeca6d9dc61fa0205fe0f62ce5d1b01b933e0a70", "filename": "gcc/java/win32-host.c", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fwin32-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fwin32-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fwin32-host.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "45327ae8f7b023e78410aad057eb555fe2891694", "filename": "gcc/java/zextract.c", "status": "removed", "additions": 0, "deletions": 394, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fzextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fzextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzextract.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "42c483327758dcd63771e14794c72cf331592208", "filename": "gcc/java/zipfile.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fzipfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/gcc%2Fjava%2Fzipfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzipfile.h?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d60c31a97a544b53039088d14fe9114583c0efc3", "filename": "libjava/COPYING", "status": "removed", "additions": 0, "deletions": 340, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FCOPYING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FCOPYING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FCOPYING?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f7c282f9bd1cfc0c130ef8e155c3e585a9356888", "filename": "libjava/ChangeLog", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f205833dca8414e651cdadd561cab0f94bd2d28d", "filename": "libjava/ChangeLog-1998", "status": "removed", "additions": 0, "deletions": 3601, "changes": 3601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-1998", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-1998", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-1998?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "540531b97b1203f9bc950b71b1e34c23e5dae900", "filename": "libjava/ChangeLog-1999", "status": "removed", "additions": 0, "deletions": 3507, "changes": 3507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-1999", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-1999", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-1999?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a2b57f625a18a1bd2c1fec6617c3cc41a1a4fdb9", "filename": "libjava/ChangeLog-2000", "status": "removed", "additions": 0, "deletions": 5077, "changes": 5077, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2000?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "52a2ae59491d6a5b184f60c315370ba4f437c5de", "filename": "libjava/ChangeLog-2001", "status": "removed", "additions": 0, "deletions": 4259, "changes": 4259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2001", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2001", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2001?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "da99a74819855e83205bc36363b58eba8dfac3f1", "filename": "libjava/ChangeLog-2002", "status": "removed", "additions": 0, "deletions": 6484, "changes": 6484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2002", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2002", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2002?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "df17e44de1a80965e157ad76d8c90e7fcaad90f0", "filename": "libjava/ChangeLog-2003", "status": "removed", "additions": 0, "deletions": 11323, "changes": 11323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2003", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2003", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2003?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2e6438f9941fd483e5a193cf32bba4c27f76cefd", "filename": "libjava/ChangeLog-2004", "status": "removed", "additions": 0, "deletions": 15948, "changes": 15948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2004", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2004", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2004?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8333f78dbf5ae26c8c033597414248af6d9ea5bb", "filename": "libjava/ChangeLog-2005", "status": "removed", "additions": 0, "deletions": 9053, "changes": 9053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2005", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2005", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2005?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "91932ac1178e7122998517debbcdeaa9a866ac92", "filename": "libjava/ChangeLog-2006", "status": "removed", "additions": 0, "deletions": 4211, "changes": 4211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2006", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2006", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2006?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "41b7a10d94085722fcab64ddb0852bc0da2b57b9", "filename": "libjava/ChangeLog-2007", "status": "removed", "additions": 0, "deletions": 2658, "changes": 2658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2007", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2007", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2007?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "451c87162619aadfe438f3bc71dad12e050b7e37", "filename": "libjava/ChangeLog-2008", "status": "removed", "additions": 0, "deletions": 1109, "changes": 1109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2008", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2008", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2008?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5a64e2534380d92fd851400041b2448f7288c88e", "filename": "libjava/ChangeLog-2009", "status": "removed", "additions": 0, "deletions": 514, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2009", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2009", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2009?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c53120d3086669de0297d1de5e253cd328b939b7", "filename": "libjava/ChangeLog-2010", "status": "removed", "additions": 0, "deletions": 723, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2010", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2010", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2010?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "841dfb753aebee48f11de558e0112f54dba95ecb", "filename": "libjava/ChangeLog-2011", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2011", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2011", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2011?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ff22755dbe1a574c4511127ee6e6fdb1c083541e", "filename": "libjava/ChangeLog-2012", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2012", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2012", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2012?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "005b168ea40586edf96428d6cb450051b3ea7f13", "filename": "libjava/ChangeLog-2013", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2013", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2013", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2013?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2b54ef3fc7591cd26a81eaac490aebbcf1d6c7b2", "filename": "libjava/ChangeLog-2014", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2014", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2014", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2014?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0d7519559e364c07eb2e4b08d438a264f4c44023", "filename": "libjava/ChangeLog-2015", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2015", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FChangeLog-2015", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog-2015?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "3e99bed0e5a82deaa1cd7f57c8bd8d3083d6695f", "filename": "libjava/HACKING", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FHACKING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FHACKING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FHACKING?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d89c581242e5ceb0bdc1cd783ca96e950859b804", "filename": "libjava/LIBGCJ_LICENSE", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FLIBGCJ_LICENSE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FLIBGCJ_LICENSE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FLIBGCJ_LICENSE?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "96a081571163edcf8762dc9f6f17f63ac9d2a2a7", "filename": "libjava/Makefile.am", "status": "removed", "additions": 0, "deletions": 1648, "changes": 1648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9aca8d639e29be95993c1cf230b44bd9085372b4", "filename": "libjava/Makefile.in", "status": "removed", "additions": 0, "deletions": 12843, "changes": 12843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f028b6fec569d06fc565e441e2409cdb25bc0737", "filename": "libjava/NEWS", "status": "removed", "additions": 0, "deletions": 621, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FNEWS?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9c9efc40f1607699c8d77146d0ee8fb31dc48ac5", "filename": "libjava/README", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FREADME?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "65d54c2814401089184627b3db34652d6a1cd9f5", "filename": "libjava/THANKS", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FTHANKS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2FTHANKS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FTHANKS?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a15cf8374fff4259f7b43793af6547d40d943f14", "filename": "libjava/aclocal.m4", "status": "removed", "additions": 0, "deletions": 1075, "changes": 1075, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Faclocal.m4?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "043fd0030ca620199e26c2939690d52e5d61070f", "filename": "libjava/boehm.cc", "status": "removed", "additions": 0, "deletions": 763, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2ec939f28d9a20a2b4bf217b936e46aa3990cc47", "filename": "libjava/classpath/.cdtproject", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.cdtproject", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.cdtproject", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.cdtproject?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ec7cfd1755f556c4beb6ae7fbe2351e098e7638e", "filename": "libjava/classpath/.classpath", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.classpath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.classpath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.classpath?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "422f3b45527e78115057ea9cea546719d8c0eecb", "filename": "libjava/classpath/.cvsignore", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.cvsignore?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a6051b111c31b0f07ac981c0e1c084892934bbfa", "filename": "libjava/classpath/.externalToolBuilders/Autogen.launch", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FAutogen.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FAutogen.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FAutogen.launch?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0c8481719eb0cd4acb1881b57daf601f0b9799dd", "filename": "libjava/classpath/.externalToolBuilders/ClasspathHeaders.launch", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathHeaders.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathHeaders.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathHeaders.launch?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "269e62c0e63a286f36342ecb5917d9da37ae82cd", "filename": "libjava/classpath/.externalToolBuilders/ClasspathJar.launch", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathJar.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathJar.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FClasspathJar.launch?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c6a6b9f06a950822d2a9d3715c8f6f8a4e8dacd8", "filename": "libjava/classpath/.externalToolBuilders/CompileNative.launch", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FCompileNative.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FCompileNative.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FCompileNative.launch?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d2347ae8428db34b6ba3a5cfffa9279b5e3fc2fa", "filename": "libjava/classpath/.externalToolBuilders/Configure.launch", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FConfigure.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FConfigure.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FConfigure.launch?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0610d24a5618879cfc7965762f1a82974b748ff0", "filename": "libjava/classpath/.externalToolBuilders/CreateLocaleData.launch", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FCreateLocaleData.launch", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.externalToolBuilders%2FCreateLocaleData.launch", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.externalToolBuilders%2FCreateLocaleData.launch?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ebc689daf2fecf922afbd9f9595c321a33e12c18", "filename": "libjava/classpath/.project", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.project", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.project", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.project?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "812e62a8400cf3a7812d0a4886b695ba3c53a1a0", "filename": "libjava/classpath/.settings/org.eclipse.jdt.core.prefs", "status": "removed", "additions": 0, "deletions": 243, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.settings%2Forg.eclipse.jdt.core.prefs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.settings%2Forg.eclipse.jdt.core.prefs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.settings%2Forg.eclipse.jdt.core.prefs?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "e03780f20c3967ebe2ea606e57e9eb4e3cd0da8c", "filename": "libjava/classpath/.settings/org.eclipse.jdt.ui.prefs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.settings%2Forg.eclipse.jdt.ui.prefs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2F.settings%2Forg.eclipse.jdt.ui.prefs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2F.settings%2Forg.eclipse.jdt.ui.prefs?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "19a2658b7e1d3a401051a01a75b99a77e2eb9088", "filename": "libjava/classpath/AUTHORS", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FAUTHORS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FAUTHORS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FAUTHORS?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "aa75439582c4431ea238d6051e8c000c1fd93345", "filename": "libjava/classpath/BUGS", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FBUGS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FBUGS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FBUGS?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5bb0601da533b9e72c46843fdb185d5e267e3327", "filename": "libjava/classpath/COPYING", "status": "removed", "additions": 0, "deletions": 340, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FCOPYING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FCOPYING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FCOPYING?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "fa49ad59bed83d5beab7efc88b5f16367330afff", "filename": "libjava/classpath/ChangeLog", "status": "removed", "additions": 0, "deletions": 7751, "changes": 7751, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "06035773701a40cd1a82b340a9d8a767307d21fe", "filename": "libjava/classpath/ChangeLog-2003", "status": "removed", "additions": 0, "deletions": 29107, "changes": 29107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2003", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2003", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog-2003?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0fdcff329c4537ac393aeee8fbc53d2b69b2886e", "filename": "libjava/classpath/ChangeLog-2004", "status": "removed", "additions": 0, "deletions": 19400, "changes": 19400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2004", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2004", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog-2004?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "03fdf5d75cd0006d6b31c723d3c9d00ebeddc89a", "filename": "libjava/classpath/ChangeLog-2005", "status": "removed", "additions": 0, "deletions": 32991, "changes": 32991, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2005", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2005", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog-2005?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b8cfb24e259b69d3f13b5b837be7ae1f504cf4c1", "filename": "libjava/classpath/ChangeLog-2006", "status": "removed", "additions": 0, "deletions": 37380, "changes": 37380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2006", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2006", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog-2006?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "821ff98e811de72bfe5d025fbaafc0050a3ae5c4", "filename": "libjava/classpath/ChangeLog-2007", "status": "removed", "additions": 0, "deletions": 4810, "changes": 4810, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2007", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2007", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog-2007?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ea6d9dcd7ea91e44599ce1db8cbc43836a758151", "filename": "libjava/classpath/ChangeLog-2008", "status": "removed", "additions": 0, "deletions": 4443, "changes": 4443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2008", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog-2008", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog-2008?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "10b28da9c7141a2e29a275d07ed9f3a6400f494c", "filename": "libjava/classpath/ChangeLog.gcj", "status": "removed", "additions": 0, "deletions": 904, "changes": 904, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.gcj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.gcj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gcj?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2f04e85a79814f67506f43cef1bd99186f9cdb4d", "filename": "libjava/classpath/ChangeLog.gnujaxp.1", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.gnujaxp.1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.gnujaxp.1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gnujaxp.1?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4437a1c9dfc7263440c68a06263388cd327c293f", "filename": "libjava/classpath/ChangeLog.gnujaxp.2", "status": "removed", "additions": 0, "deletions": 1944, "changes": 1944, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.gnujaxp.2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.gnujaxp.2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.gnujaxp.2?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d7f68fecbbbe3e5f62c96a43e8373beadf12ab53", "filename": "libjava/classpath/ChangeLog.libxmlj", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.libxmlj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.libxmlj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.libxmlj?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c0d43db6e04e88fd54db250ad0e0afd083208bf7", "filename": "libjava/classpath/ChangeLog.usermap", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.usermap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FChangeLog.usermap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog.usermap?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "cc5cee19d525905d03ed1b784758d146601e4af9", "filename": "libjava/classpath/HACKING", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FHACKING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FHACKING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FHACKING?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b39583e75af2bee2ded477e4b749acbd934f7734", "filename": "libjava/classpath/INSTALL", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FINSTALL", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FINSTALL", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FINSTALL?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4e3d8b86f6ec3cb3e22d4049320ba1bb642d2430", "filename": "libjava/classpath/LICENSE", "status": "removed", "additions": 0, "deletions": 396, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FLICENSE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FLICENSE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FLICENSE?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "454b2e9602363c44be385ddaffb34e9e56ae338c", "filename": "libjava/classpath/Makefile.am", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FMakefile.am?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8f554acb171a3ac3f3e863eaf92739fef6d262f4", "filename": "libjava/classpath/Makefile.in", "status": "removed", "additions": 0, "deletions": 700, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FMakefile.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0a7884a6fabb9a220d8e5da8dcc74b925fc8d03a", "filename": "libjava/classpath/NEWS", "status": "removed", "additions": 0, "deletions": 1389, "changes": 1389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FNEWS?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d2e38a5db11d4bf9ede8441798a536a9b91af360", "filename": "libjava/classpath/README", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FREADME?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "22314d1e74309778ef9bf8658909148ff41671d4", "filename": "libjava/classpath/THANKYOU", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FTHANKYOU", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FTHANKYOU", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FTHANKYOU?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "df7eed7d0acc1a6414f0044e9d3a9f5202a14c70", "filename": "libjava/classpath/TODO", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FTODO?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8c1d6d978527631e5cb232d46086eefef482ec29", "filename": "libjava/classpath/aclocal.m4", "status": "removed", "additions": 0, "deletions": 1110, "changes": 1110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Faclocal.m4?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "adb8f0c940880a96a7c2bb934f0caa1e668240d5", "filename": "libjava/classpath/autogen.sh", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fautogen.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fautogen.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fautogen.sh?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1b1d232169586b87050f08c303ffcc44676da397", "filename": "libjava/classpath/compile", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fcompile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fcompile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fcompile?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b02565c7b2fc163c5f63f330f962fd01226dbdce", "filename": "libjava/classpath/config.guess", "status": "removed", "additions": 0, "deletions": 1517, "changes": 1517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfig.guess", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfig.guess", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfig.guess?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b7f75cde451f7ac3b49be90533795c5e2eb98716", "filename": "libjava/classpath/config.rpath", "status": "removed", "additions": 0, "deletions": 667, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfig.rpath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfig.rpath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfig.rpath?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "59bb593f109c8d795df4cbb96b015222eed91c07", "filename": "libjava/classpath/config.sub", "status": "removed", "additions": 0, "deletions": 1779, "changes": 1779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfig.sub?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "6d46403a428714d41965bd76e8d0ccde61195932", "filename": "libjava/classpath/configure", "status": "removed", "additions": 0, "deletions": 29290, "changes": 29290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfigure?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "245e1df857074456bd03de3e83e0780ee9c136c1", "filename": "libjava/classpath/configure.ac", "status": "removed", "additions": 0, "deletions": 1277, "changes": 1277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfigure.ac?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "df8eea7e4ce8862105fcd7929b20bdb45488048b", "filename": "libjava/classpath/depcomp", "status": "removed", "additions": 0, "deletions": 630, "changes": 630, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdepcomp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdepcomp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdepcomp?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1c4ea81e2c8f7f15769b02f793f457fffd3cb835", "filename": "libjava/classpath/doc/.cvsignore", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2F.cvsignore?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "27a378d07be82293e4c855dfaa27cb0a25e57de8", "filename": "libjava/classpath/doc/Makefile.am", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2FMakefile.am?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1b4008e93133865caf33439e24c68ea2c5b340aa", "filename": "libjava/classpath/doc/Makefile.in", "status": "removed", "additions": 0, "deletions": 1074, "changes": 1074, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2FMakefile.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "afafb083c1957c4f35b9af77651dce9104160af5", "filename": "libjava/classpath/doc/README.jaxp", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2FREADME.jaxp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2FREADME.jaxp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2FREADME.jaxp?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "282522db0342d8750454b3dc162493b5fc709cc8", "filename": "libjava/classpath/doc/api/.cvsignore", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fapi%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fapi%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fapi%2F.cvsignore?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "76b35c5f8508387470b612899d750ca7ff8a6da4", "filename": "libjava/classpath/doc/api/Makefile.am", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.am?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5c86ee410cc7be44701a62e4d0717d291e38c742", "filename": "libjava/classpath/doc/api/Makefile.in", "status": "removed", "additions": 0, "deletions": 517, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2914c5be5cd9a155cb4715f015263a0c68ba222d", "filename": "libjava/classpath/doc/cp-hacking.texinfo", "status": "removed", "additions": 0, "deletions": 2081, "changes": 2081, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fcp-hacking.texinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fcp-hacking.texinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fcp-hacking.texinfo?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c3cc5ff8cdf45efa53f77896d966796bf8450192", "filename": "libjava/classpath/doc/cp-tools.texinfo", "status": "removed", "additions": 0, "deletions": 3290, "changes": 3290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fcp-tools.texinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fcp-tools.texinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fcp-tools.texinfo?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0b2d78c845c97e4d1bf9573e27bbeec314973870", "filename": "libjava/classpath/doc/cp-vmintegration.texinfo", "status": "removed", "additions": 0, "deletions": 1999, "changes": 1999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fcp-vmintegration.texinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Fcp-vmintegration.texinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fcp-vmintegration.texinfo?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "bef5644e5a89b644d5baaa35661a60f4038e7ff9", "filename": "libjava/classpath/doc/texi2pod.pl", "status": "removed", "additions": 0, "deletions": 478, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Ftexi2pod.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Ftexi2pod.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Ftexi2pod.pl?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "91408263bc9c8ab0ad735c0974872d2f1cf58dc0", "filename": "libjava/classpath/doc/texinfo.tex", "status": "removed", "additions": 0, "deletions": 9291, "changes": 9291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Ftexinfo.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fdoc%2Ftexinfo.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Ftexinfo.tex?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d79d635e81a5db6e3f56dacb5de9e6bc4882ae5a", "filename": "libjava/classpath/examples/.cvsignore", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2F.cvsignore?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ff47801247c9f2b45677eaaad073456b1a9467de", "filename": "libjava/classpath/examples/Makefile.am", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.am?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5449494228324349ef351c6502cad79dbb7ce38f", "filename": "libjava/classpath/examples/Makefile.in", "status": "removed", "additions": 0, "deletions": 634, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "dac22068c4dd8fb82876f111bf9f57aa44e1f83e", "filename": "libjava/classpath/examples/Makefile.java2d.in", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.java2d.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.java2d.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.java2d.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "aea41d4cb601e1f63a75d5836a6afe279e28b0c1", "filename": "libjava/classpath/examples/Makefile.jawt.in", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.jawt.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FMakefile.jawt.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.jawt.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f7bf599624a84802bbada4731391e1069fdfa5b8", "filename": "libjava/classpath/examples/README", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FREADME?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f71c24f2bbfbe3092940a51f11d6a22a2183b6e1", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/NamingService/Demo.java", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FNamingService%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FNamingService%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FNamingService%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "944f661910c254c31dae2c8f6e704fbf6bfeb77a", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/Demo.java", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d7b1a7771fbff8acba4faa5b74c81ad90da14b69", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/DemoServer.java", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2FDemoServer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2FDemoServer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2FDemoServer.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9af20d227abc83b51df1c363a7a214e8986df575", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/DemoServant.java", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDemoServant.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDemoServant.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDemoServant.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f3766f3251a930e1c965c7c9941ef85460ec5794", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/DemoTester.java", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDemoTester.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDemoTester.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDemoTester.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "843530de55bb3287ed785c695c207dc4409d1e75", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/DirectTest.java", "status": "removed", "additions": 0, "deletions": 344, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDirectTest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDirectTest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FDirectTest.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9c908e520cc73f7f41bc61e8c9cb1bca4b285122", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/RequestTest.java", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FRequestTest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FRequestTest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FRequestTest.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "eecf6f3a616c06c2adaed65525f0046010f1eca3", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/StructureToPass.java", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPass.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "155ad170bc48645c017ad6d7f7376bee7693cc54", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/StructureToPassHelper.java", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPassHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPassHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPassHelper.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5bbe6908e2738d50e3650b2393e4fe667082d99d", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/StructureToPassHolder.java", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPassHolder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPassHolder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToPassHolder.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2f497cba4726b2a301db8eb778917f87297fee5d", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/StructureToReturn.java", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturn.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturn.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturn.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "83f422c5273828be108efc4709aa7443d4ab6d99", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/StructureToReturnHelper.java", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturnHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturnHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturnHelper.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c70f9cfccdd323918b7f4056a43e007374900661", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/StructureToReturnHolder.java", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturnHolder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturnHolder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FStructureToReturnHolder.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4fb28345a758340c3daa3e6b14f668db994460cd", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/TreeNode.java", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNode.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "eac1c9a2415f3ecf3a88cb0dc4703a1b6d1e9c73", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/TreeNodeHelper.java", "status": "removed", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNodeHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNodeHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNodeHelper.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ec180ce579afa628b732b89ad2f84732536e6132", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/TreeNodeHolder.java", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNodeHolder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNodeHolder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FTreeNodeHolder.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "fcf632b328e1884ce891bb7e16732e92b4c76f46", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/WeThrowThisException.java", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FWeThrowThisException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FWeThrowThisException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FWeThrowThisException.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "23ebc825637124d319a2a7bde5591f3524d94704", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/WeThrowThisExceptionHelper.java", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FWeThrowThisExceptionHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FWeThrowThisExceptionHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2FWeThrowThisExceptionHelper.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "02e5e1a493782b33acb49dad94526ddbd7dd1dc1", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/_DemoTesterImplBase.java", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2F_DemoTesterImplBase.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2F_DemoTesterImplBase.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2F_DemoTesterImplBase.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "7481c4eade5541d106acb2a9d968cee9faa20692", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/SimpleCommunication/communication/_DemoTesterStub.java", "status": "removed", "additions": 0, "deletions": 429, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2F_DemoTesterStub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2F_DemoTesterStub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2FSimpleCommunication%2Fcommunication%2F_DemoTesterStub.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a3a9e62823eba968027478a8403f6d673a9d8b86", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/README.html", "status": "removed", "additions": 0, "deletions": 493, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2FREADME.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2FREADME.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2FREADME.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5ec902dbdf44df6bed7e0dc025d6afeaef016418", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/CanvasWorld.java", "status": "removed", "additions": 0, "deletions": 307, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FCanvasWorld.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FCanvasWorld.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FCanvasWorld.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5b3d7557b3c8bd43d89bfbbf6672fc3be4ff790e", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/ChatConstants.java", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FChatConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FChatConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FChatConstants.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "04b8dd976f8cbad148ee6d1e7b20f2d158149c2d", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/ClientFrame.java", "status": "removed", "additions": 0, "deletions": 417, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FClientFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FClientFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FClientFrame.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "3461f02842e02a71f3ab21ecef10cb551e20a2e8", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/Demo.java", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c08f49a7c816a1fb830f0526a8baf8c5f66eaae4", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/GameManager.java", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManager.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "cf305318a5d7bc8255227b65b92d1b147d9aec0c", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/GameManagerImpl.java", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManagerImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManagerImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FGameManagerImpl.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4afd47549b6a0fe44e90b8228fccd3bdc6c0acc2", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/IorReader.java", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FIorReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FIorReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FIorReader.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "54632658d4a40f382dffa0918e764e679f02ba7b", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/OrbStarter.java", "status": "removed", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FOrbStarter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FOrbStarter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FOrbStarter.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ced7d5d82310222012b8a42dda6b7232b77cb0c5", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/Player.java", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayer.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "30b32c4b68e61a73f77bc0630bd3afcfdc1debf1", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/PlayerImpl.java", "status": "removed", "additions": 0, "deletions": 275, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayerImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayerImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayerImpl.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "681d42e6ba00fdeb471571561c83a7bd9498d069", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/PlayingDesk.java", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayingDesk.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayingDesk.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FPlayingDesk.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a759225bb73df05a6671ff8e3ebc9f5f2a016627", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/State.java", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FState.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "516c701e1ee98b6f265964e9fbd23e7989a7c4e8", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/X5Server.java", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FX5Server.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FX5Server.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2FX5Server.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "54ef1e93b9d2cbddf2263d9a319a1f56e4aee2c2", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_GameManagerImpl_Tie.java", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManagerImpl_Tie.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManagerImpl_Tie.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManagerImpl_Tie.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "52fd103d6ea1dd94da55e3deca787a33bfaf57c7", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_GameManager_Stub.java", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManager_Stub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManager_Stub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_GameManager_Stub.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "bc2333c07f9d936e28b210ba0a1706fa2e4a326c", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_PlayerImpl_Tie.java", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_PlayerImpl_Tie.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_PlayerImpl_Tie.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_PlayerImpl_Tie.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c5a2089ee8f6d0b1a849d5038e8acda6bc1a2c8b", "filename": "libjava/classpath/examples/gnu/classpath/examples/CORBA/swing/x5/_Player_Stub.java", "status": "removed", "additions": 0, "deletions": 397, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_Player_Stub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_Player_Stub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2FCORBA%2Fswing%2Fx5%2F_Player_Stub.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "20cd5926ea8dcfb72c7f0d1e89860d038bef8921", "filename": "libjava/classpath/examples/gnu/classpath/examples/awt/AicasGraphicsBenchmark.java", "status": "removed", "additions": 0, "deletions": 1018, "changes": 1018, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FAicasGraphicsBenchmark.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FAicasGraphicsBenchmark.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FAicasGraphicsBenchmark.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "aea8cd4f68ee0339f924c389d3a43142d6ac165d", "filename": "libjava/classpath/examples/gnu/classpath/examples/awt/AnimationApplet.java", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FAnimationApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FAnimationApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FAnimationApplet.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "62bee8f5739982521280bac9890beef68d23056d", "filename": "libjava/classpath/examples/gnu/classpath/examples/awt/Demo.java", "status": "removed", "additions": 0, "deletions": 1189, "changes": 1189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5ba44f6d942538c0d40b96eb1e8782d62e413e2d", "filename": "libjava/classpath/examples/gnu/classpath/examples/awt/HintingDemo.java", "status": "removed", "additions": 0, "deletions": 420, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FHintingDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FHintingDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fawt%2FHintingDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "3bf9431a151c23ce33cf043336abc9266001eb98", "filename": "libjava/classpath/examples/gnu/classpath/examples/datatransfer/Demo.java", "status": "removed", "additions": 0, "deletions": 652, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fdatatransfer%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fdatatransfer%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fdatatransfer%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0a3c512bfbbc39415596465c3ecac766d0201a60", "filename": "libjava/classpath/examples/gnu/classpath/examples/html/Demo.java", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fhtml%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fhtml%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fhtml%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "dcf39654b9fee3b0669cdaff063c113d7127b288", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/aicas.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Faicas.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Faicas.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Faicas.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d320f26c65fcb350e5dd31541d098675b55f224d", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/back.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fback.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fback.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fback.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2f80ad9449b9b8b3abaab48f6fd99d69e3fc3de6", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/badge.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbadge.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbadge.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbadge.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "12ca146785588b3bda3e4c2eae855d85217c753a", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/big-fullscreen.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-fullscreen.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-fullscreen.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-fullscreen.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "3a8f055a0a39c575fd5851a7110fd102e79a2275", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/big-home.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-home.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-home.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-home.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "dc8c8a457c72892e7ca4ccd2dbedc3767e4ffbd7", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/big-warning.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-warning.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-warning.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fbig-warning.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "69479465594683e530af4a1be115a1ae4d5cce14", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/palme.gif", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fpalme.gif", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fpalme.gif", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fpalme.gif?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "04c57500211a95f5879793cc47ac82a8e45ad176", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/reload.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Freload.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Freload.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Freload.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f2f83e34c01d4c241e532a23190dd601cda756e6", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-copy.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-copy.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-copy.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-copy.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f887e15698f2f428e04037e3112abfc052a5b25a", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-cut.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-cut.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-cut.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-cut.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "bd5607c6b79e9cbdfc22a3c339b9a459e7ea2323", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-go-back.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-back.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-back.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-back.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c8f54fb919a106efbda7efc3896fb5be03bfd8a0", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-go-down.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-down.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-down.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-down.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "bc5bcc5196f013e76242b56f088a45410075aaff", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-go-forward.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-forward.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-forward.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-go-forward.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "62fc914c6cdf95f7f01fb3351322aa8256f15ac9", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-mic.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-mic.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-mic.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-mic.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "db8b0874877bb767f740f57ed374ac5496ba41eb", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-new.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-new.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-new.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-new.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b1b22e5ed8f5d9d8a80dbe3fd22e0b92dc286785", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-open.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-open.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-open.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-open.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "35f67d64789b4deefaaad3051b8e611786bf3522", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-paste.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-paste.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-paste.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-paste.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "60a6e40e6e50d99f0accb9dc16c5a46c844b04bf", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-quit.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-quit.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-quit.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-quit.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9d7f9a4cb6445eca62f1860af9d43282746afb57", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-save-as.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-save-as.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-save-as.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-save-as.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0bc44aba470655fdd51f3df5528c14939e404729", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-save.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-save.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-save.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-save.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "6f154fd9fde71be7689ae69516cbcec5bf2c28ec", "filename": "libjava/classpath/examples/gnu/classpath/examples/icons/stock-spell-check.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-spell-check.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-spell-check.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Ficons%2Fstock-spell-check.png?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4f6b9f4bd7f7c86d5b61c091b5c5419a06eeef61", "filename": "libjava/classpath/examples/gnu/classpath/examples/java2d/J2dBenchmark.java", "status": "removed", "additions": 0, "deletions": 1571, "changes": 1571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJ2dBenchmark.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJ2dBenchmark.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJ2dBenchmark.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ce12fa1f78f25f0605476542dd5ba8bf90bec193", "filename": "libjava/classpath/examples/gnu/classpath/examples/java2d/J2dBenchmarkGUI.java", "status": "removed", "additions": 0, "deletions": 891, "changes": 891, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJ2dBenchmarkGUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJ2dBenchmarkGUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJ2dBenchmarkGUI.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "49996499e5dd28fe4677782a90b7d9dc133fc232", "filename": "libjava/classpath/examples/gnu/classpath/examples/java2d/JNIOverhead.java", "status": "removed", "additions": 0, "deletions": 390, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJNIOverhead.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJNIOverhead.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2FJNIOverhead.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "e5b45aa1c15551e851f343200b2ff29d15554128", "filename": "libjava/classpath/examples/gnu/classpath/examples/java2d/bench.c", "status": "removed", "additions": 0, "deletions": 606, "changes": 606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2Fbench.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2Fbench.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2Fbench.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "aebd50a6785b4c7691a2eba823dba65f78261d40", "filename": "libjava/classpath/examples/gnu/classpath/examples/java2d/bench.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2Fbench.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2Fbench.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjava2d%2Fbench.h?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ee2d7bfec4a45a4ca93b80261ce1d2d38782e7a7", "filename": "libjava/classpath/examples/gnu/classpath/examples/jawt/DemoJAWT.c", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjawt%2FDemoJAWT.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjawt%2FDemoJAWT.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjawt%2FDemoJAWT.c?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "c8f931ece9c647ed01cd1540e1d08af56459cd3b", "filename": "libjava/classpath/examples/gnu/classpath/examples/jawt/DemoJAWT.java", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjawt%2FDemoJAWT.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjawt%2FDemoJAWT.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fjawt%2FDemoJAWT.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "381dca448709688536efa2cd04275cd726aa1b98", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestBeans.java", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestBeans.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestBeans.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestBeans.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8465510ac3a8ec56575284670e83f012913ace35", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestClassLoading.java", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestClassLoading.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestClassLoading.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestClassLoading.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b8c44752fd558b8e8bf8740d3f626f07aff9e6b5", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestCompilation.java", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestCompilation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestCompilation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestCompilation.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ddb22c30c8776748d7a9811468a892b32c743f4b", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestGarbageCollector.java", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestGarbageCollector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestGarbageCollector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestGarbageCollector.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "7a5065f14e98c208d1cd4c59d56bf7d31d1ce688", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestMemory.java", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemory.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8e98acd4c4b713cc826edd29e3a077948dad0729", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestMemoryManager.java", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemoryManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemoryManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemoryManager.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a5e24fd50f1a99176e5d55e07ba6585d17196be8", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestMemoryPool.java", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemoryPool.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemoryPool.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestMemoryPool.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "fe09346fd63ee557ddea4ecde8b9f5b73a394fda", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestOS.java", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestOS.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestOS.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestOS.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2a629ca83c6e59663468ff610d728cd4e014ee10", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestRuntime.java", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestRuntime.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestRuntime.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestRuntime.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ff57ee5fffed4da5d162b3a07dd67fca0c3d145f", "filename": "libjava/classpath/examples/gnu/classpath/examples/management/TestThread.java", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmanagement%2FTestThread.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "81c71dc11cb31c39cfe1b082fa765f724c9da0be", "filename": "libjava/classpath/examples/gnu/classpath/examples/midi/Demo.java", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmidi%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmidi%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fmidi%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "fb4d74373fdc4ae64f703bef56b3c2c69a2d53de", "filename": "libjava/classpath/examples/gnu/classpath/examples/print/Demo.java", "status": "removed", "additions": 0, "deletions": 391, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fprint%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fprint%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fprint%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4518e25b1fafd22c6296da3dafe0e2f308854412", "filename": "libjava/classpath/examples/gnu/classpath/examples/sound/AudioPlayerSample.java", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fsound%2FAudioPlayerSample.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fsound%2FAudioPlayerSample.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fsound%2FAudioPlayerSample.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a929683b8e976b123b5681ff5158cb673c9b619f", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/BrowserEditorKit.java", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FBrowserEditorKit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FBrowserEditorKit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FBrowserEditorKit.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8b05dac134776946ec1f3988f274024695314c6c", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/ButtonDemo.java", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FButtonDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FButtonDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FButtonDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "682af0bdd5b262422b702942d950e9193f2ecd2a", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/ComboBoxDemo.java", "status": "removed", "additions": 0, "deletions": 386, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FComboBoxDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FComboBoxDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FComboBoxDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "bed08d481d966bfa0189fcae54ca7ddf5c08fc21", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/Demo.java", "status": "removed", "additions": 0, "deletions": 629, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "edfaf36b22f72ce827c46789d5c4e83067368744", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/DemoDesktop.java", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemoDesktop.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemoDesktop.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemoDesktop.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0bbd0220a5e8959c2fd6f28d9063f55922025e35", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/DemoFactory.java", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemoFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemoFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDemoFactory.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "58db9911017e640b8aaed2a8d2a3030906b679f1", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/DocumentFilterDemo.java", "status": "removed", "additions": 0, "deletions": 288, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDocumentFilterDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDocumentFilterDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FDocumentFilterDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "444453bf55cae07e15462b952892aa9ebae55854", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/FileChooserDemo.java", "status": "removed", "additions": 0, "deletions": 264, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FFileChooserDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FFileChooserDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FFileChooserDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "20977b218545bfdd94a99cfe2934693521370095", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/HtmlDemo.java", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FHtmlDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FHtmlDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FHtmlDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8caa1dc6245a4b174d1ba8b19bd2b0f24cf74ddc", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/ListDemo.java", "status": "removed", "additions": 0, "deletions": 231, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FListDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FListDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FListDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1360f9b59da7f06277739992d205d29766916581", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/MetalThemeEditor.java", "status": "removed", "additions": 0, "deletions": 585, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FMetalThemeEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FMetalThemeEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FMetalThemeEditor.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "aa8424804524e555431c0c05e37270988a577778", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/MiniDemo.java", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FMiniDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FMiniDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FMiniDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "761c575280c3ab20c32b879897cc03a80b8001a8", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/NavigationFilterDemo.java", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FNavigationFilterDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FNavigationFilterDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FNavigationFilterDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1391a00baef28fc3625df5d729426afe6a54c054", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/ProgressBarDemo.java", "status": "removed", "additions": 0, "deletions": 239, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FProgressBarDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FProgressBarDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FProgressBarDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ac500d612892d6fdd94857cdee67ed7298bc0414", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/ScrollBarDemo.java", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FScrollBarDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FScrollBarDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FScrollBarDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "76d68c9849fac4199256b2916cde03927be96575", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/SliderDemo.java", "status": "removed", "additions": 0, "deletions": 287, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FSliderDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FSliderDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FSliderDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "abf72bce22c652460f8cc97d5e985e39fd52008d", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/SpinnerDemo.java", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FSpinnerDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FSpinnerDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FSpinnerDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "7cf02ce291c337cec7c422a7afdc32727319032f", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/TabbedPaneDemo.java", "status": "removed", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTabbedPaneDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTabbedPaneDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTabbedPaneDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "6aa9ba558a5b61d0ec52ae650769e785563bf514", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/TableDemo.java", "status": "removed", "additions": 0, "deletions": 410, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTableDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTableDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTableDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5381f7ead0b8d1fc8bebe02e71916660d215a049", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/TextAreaDemo.java", "status": "removed", "additions": 0, "deletions": 620, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTextAreaDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTextAreaDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTextAreaDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "e630228804f382028910f2aaeaf8dbe7b6a34b09", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/TextFieldDemo.java", "status": "removed", "additions": 0, "deletions": 594, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTextFieldDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTextFieldDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTextFieldDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "f8f7ae6b4db9acffc3239966b4a4e4c4663e3c86", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/TreeDemo.java", "status": "removed", "additions": 0, "deletions": 318, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTreeDemo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTreeDemo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2FTreeDemo.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "010a94c936069c349b8d5d4dd0fb1e539598475b", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/forms.html", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fforms.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fforms.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fforms.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b9150592fa7ece820286bbf4797efbbca851b7f2", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/frame1.html", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe1.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe1.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe1.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9dbf33c5a0bba5843de7d782d62de77bf4dc868c", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/frame2.html", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe2.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe2.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe2.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "e677bd6a10095554faf792ee70661008a5e553fb", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/frame3.html", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe3.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe3.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe3.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1da53b1017bdcb5ba0605aa26f7e94684c69d352", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/frame4.html", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe4.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe4.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframe4.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "e7e2bf87c9507eb5e73019e16393aa5b8b5e57d0", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/frames.html", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframes.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframes.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fframes.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "af908e1ab23f3b29e1a7b602c7e92997694de80d", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/tables.html", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Ftables.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Ftables.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Ftables.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "786e18b77b8344cd3c35a8eb0f37071d48c2687b", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/textstyles.html", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Ftextstyles.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Ftextstyles.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Ftextstyles.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "8bc987494c15f54f32acee9ed592e6593e8b92d2", "filename": "libjava/classpath/examples/gnu/classpath/examples/swing/welcome.html", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fwelcome.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fwelcome.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2Fgnu%2Fclasspath%2Fexamples%2Fswing%2Fwelcome.html?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "282522db0342d8750454b3dc162493b5fc709cc8", "filename": "libjava/classpath/external/.cvsignore", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2F.cvsignore?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2eeef805ad39c970208d60123f1f499de72ced4a", "filename": "libjava/classpath/external/Makefile.am", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2FMakefile.am?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "af088320c0619a389f047dfd6d5a9f522bf8d113", "filename": "libjava/classpath/external/Makefile.in", "status": "removed", "additions": 0, "deletions": 617, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2FMakefile.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d6d6491d62b56427a1a7f6eee6189d8b81672e6f", "filename": "libjava/classpath/external/README", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2FREADME?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "70845e08eb0b807b1022dc47cd27e67f726d4a0f", "filename": "libjava/classpath/external/jsr166/.cvsignore", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2F.cvsignore?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "30bf3f47450f41ca76d15901e7e8724d37f48962", "filename": "libjava/classpath/external/jsr166/IMPORTING", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FIMPORTING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FIMPORTING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FIMPORTING?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "fa2db2ebfd3801634a38d7fe928242424b4350e2", "filename": "libjava/classpath/external/jsr166/Makefile.am", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FMakefile.am?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "40a589bdea4376d0b8bb6cd1be9e69ebd1a2b649", "filename": "libjava/classpath/external/jsr166/Makefile.in", "status": "removed", "additions": 0, "deletions": 540, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2FMakefile.in?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "644df6c491d5d6264cb71f6b06c2a23b3792c2cd", "filename": "libjava/classpath/external/jsr166/java/util/AbstractQueue.java", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FAbstractQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FAbstractQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FAbstractQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a4bc75c993980297a21d40d0e279291dfe13d21a", "filename": "libjava/classpath/external/jsr166/java/util/ArrayDeque.java", "status": "removed", "additions": 0, "deletions": 839, "changes": 839, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FArrayDeque.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FArrayDeque.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FArrayDeque.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a769561dc0ab661338ce30f55c41a05cd66fee71", "filename": "libjava/classpath/external/jsr166/java/util/Deque.java", "status": "removed", "additions": 0, "deletions": 547, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FDeque.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FDeque.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FDeque.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a55f84bddd870abe56470b41159240080ac1ca73", "filename": "libjava/classpath/external/jsr166/java/util/NavigableMap.java", "status": "removed", "additions": 0, "deletions": 395, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FNavigableMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FNavigableMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FNavigableMap.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "e14fe347d71e6f64c9a0d8e4450fbe7620143c43", "filename": "libjava/classpath/external/jsr166/java/util/NavigableSet.java", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FNavigableSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FNavigableSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FNavigableSet.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "5711545b07b2c5d6d8184b71682779e30f30f784", "filename": "libjava/classpath/external/jsr166/java/util/Queue.java", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2FQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "ac15c501083d80d93fbb3f7261265808f2111539", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/AbstractExecutorService.java", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FAbstractExecutorService.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FAbstractExecutorService.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FAbstractExecutorService.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "3ce9ed859020b4b7c7334505eaf5fc13473f9872", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ArrayBlockingQueue.java", "status": "removed", "additions": 0, "deletions": 778, "changes": 778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FArrayBlockingQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FArrayBlockingQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FArrayBlockingQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d77a96555ad75ba721980cf549b5f6abda33a54d", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/BlockingDeque.java", "status": "removed", "additions": 0, "deletions": 613, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBlockingDeque.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBlockingDeque.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBlockingDeque.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b47cc98427352c47e559a67b4ed56b5a021b055f", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/BlockingQueue.java", "status": "removed", "additions": 0, "deletions": 344, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBlockingQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBlockingQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBlockingQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "3f93fbb9dc421aa122f7cffc4098ebff7e709eb0", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/BrokenBarrierException.java", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBrokenBarrierException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBrokenBarrierException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FBrokenBarrierException.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "abc4d04075a2e1e10b9d4c33fd6e67a6fe99ce9f", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/Callable.java", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCallable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCallable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCallable.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2c29544a0ea0e47a0e802fcf2698c7378d45242a", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/CancellationException.java", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCancellationException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCancellationException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCancellationException.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "df9f719c49db07447fc01db88a1a3987d038660c", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/CompletionService.java", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCompletionService.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCompletionService.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCompletionService.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9ad9ab25badf2e1a3a7140ee098d7b1960817bb3", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ConcurrentHashMap.java", "status": "removed", "additions": 0, "deletions": 1277, "changes": 1277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentHashMap.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "000f4a4c93a8540dfd9d47a4bd4fc4928cd6c280", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ConcurrentLinkedQueue.java", "status": "removed", "additions": 0, "deletions": 480, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentLinkedQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentLinkedQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentLinkedQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "6e5bd073880a4e9303042460d7d8f44128f00fa5", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ConcurrentMap.java", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentMap.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "7d86afb7034d169b172ad7e84c94631748aa64ee", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ConcurrentNavigableMap.java", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentNavigableMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentNavigableMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentNavigableMap.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "1ad9244548d5f8b2b4cc8e92ea74ffe3b37554e7", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ConcurrentSkipListMap.java", "status": "removed", "additions": 0, "deletions": 3114, "changes": 3114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentSkipListMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentSkipListMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentSkipListMap.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "7fd1c7608a06482975e53089446d8644000aed38", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ConcurrentSkipListSet.java", "status": "removed", "additions": 0, "deletions": 456, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentSkipListSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentSkipListSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FConcurrentSkipListSet.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "063636bd81ee225271379729c02444bfba153f8c", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/CopyOnWriteArraySet.java", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCopyOnWriteArraySet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCopyOnWriteArraySet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCopyOnWriteArraySet.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "016c1a7a55cbbe5f5bdad0561a99f966f00a14f2", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/CountDownLatch.java", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCountDownLatch.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCountDownLatch.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCountDownLatch.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "d5738c5ae8b9b77482121767c34145c015e742ef", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/CyclicBarrier.java", "status": "removed", "additions": 0, "deletions": 454, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCyclicBarrier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCyclicBarrier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FCyclicBarrier.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4ce7bc65217bb1ecc29bda3cdf310c76a991f4c8", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/DelayQueue.java", "status": "removed", "additions": 0, "deletions": 487, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FDelayQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FDelayQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FDelayQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "b1ff4eee5552d9bc9d709139962ce69ea8fe214e", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/Delayed.java", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FDelayed.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FDelayed.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FDelayed.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "fb917f4321eabccea6e806145a90cb3ff8833919", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/Exchanger.java", "status": "removed", "additions": 0, "deletions": 656, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExchanger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExchanger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExchanger.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "bc561e58ebb9380d713d4d93764ece39082efb29", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ExecutionException.java", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutionException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutionException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutionException.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "a61e9215291277cb2212da01f99f6d22cc72a16f", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/Executor.java", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutor.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9b7a0e027a02155760dcf26754484864e4d3f343", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ExecutorCompletionService.java", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutorCompletionService.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutorCompletionService.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutorCompletionService.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "77731926562e6e133d239e06a682157ef1d8e2bf", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/ExecutorService.java", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutorService.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutorService.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutorService.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "18e6b33cc9f535d795156ce757c89787857fa70a", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/Executors.java", "status": "removed", "additions": 0, "deletions": 666, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutors.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutors.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FExecutors.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "0459ee453f0ec8ff7880c09ad1bdaafe92f2ba2f", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/Future.java", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FFuture.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FFuture.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FFuture.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "94742405dec794c7ecd9f524e37cb1d50b8b78b3", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/FutureTask.java", "status": "removed", "additions": 0, "deletions": 325, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FFutureTask.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FFutureTask.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FFutureTask.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "2dc8fa8774a6261aabd8758eadbd0bbf8d513a4d", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/LinkedBlockingDeque.java", "status": "removed", "additions": 0, "deletions": 1021, "changes": 1021, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FLinkedBlockingDeque.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FLinkedBlockingDeque.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FLinkedBlockingDeque.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "62018096a501c1b63aeece5e6fe0c08011c52103", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/LinkedBlockingQueue.java", "status": "removed", "additions": 0, "deletions": 807, "changes": 807, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FLinkedBlockingQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FLinkedBlockingQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FLinkedBlockingQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "9466aa477a8068d2622dc9af7fd3146411633f60", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/PriorityBlockingQueue.java", "status": "removed", "additions": 0, "deletions": 563, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FPriorityBlockingQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FPriorityBlockingQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FPriorityBlockingQueue.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "30b043d6627649eb2b79c90b1bc67b35792e046e", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/RejectedExecutionException.java", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FRejectedExecutionException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FRejectedExecutionException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FRejectedExecutionException.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}, {"sha": "4b4bbeab1bb8da84d57d8c6d2cc1c7b3f70f4444", "filename": "libjava/classpath/external/jsr166/java/util/concurrent/RejectedExecutionHandler.java", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FRejectedExecutionHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eae993948bae8b788c53772bcb9217c063716f93/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FRejectedExecutionHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fjsr166%2Fjava%2Futil%2Fconcurrent%2FRejectedExecutionHandler.java?ref=eae993948bae8b788c53772bcb9217c063716f93"}]}