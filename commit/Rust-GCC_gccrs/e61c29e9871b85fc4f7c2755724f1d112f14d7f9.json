{"sha": "e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYxYzI5ZTk4NzFiODVmYzRmN2MyNzU1NzI0ZjFkMTEyZjE0ZDdmOQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-25T20:25:02Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-25T20:25:02Z"}, "message": "sparc.c (sparc_absnegfloat_split_legitimate): New function.\n\n\t* config/sparc/sparc.c (sparc_absnegfloat_split_legitimate): New\n\tfunction.\n\t* config/sparc/sparc.h: Declare it.\n\t* config/sparc/sparc.md (float abs/neg splits): Use it.\n\t(all other splits): Handle SUBREGs properly where necessary.\n\t(unnamed (1<<x)-1 V8PLUS pattern): Disable for now.\n\nFrom-SVN: r21981", "tree": {"sha": "2fcecc073475653fe8caf32bca4d6ed3dfcad58b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fcecc073475653fe8caf32bca4d6ed3dfcad58b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/comments", "author": null, "committer": null, "parents": [{"sha": "8e710788f53e0795287b4d66515df1fd6e4ccfa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e710788f53e0795287b4d66515df1fd6e4ccfa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e710788f53e0795287b4d66515df1fd6e4ccfa0"}], "stats": {"total": 182, "additions": 131, "deletions": 51}, "files": [{"sha": "8120c2547432cae517948aa0e27ddb0fd3e88c4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "patch": "@@ -1,3 +1,12 @@\n+Tue Aug 25 19:17:59 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (sparc_absnegfloat_split_legitimate): New\n+\tfunction.\n+\t* config/sparc/sparc.h: Declare it.\n+\t* config/sparc/sparc.md (float abs/neg splits): Use it.\n+\t(all other splits): Handle SUBREGs properly where necessary.\n+\t(unnamed (1<<x)-1 V8PLUS pattern): Disable for now.\n+\n Tue Aug 25 19:48:46 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* reorg.c (fill_simple_delay_slots): Do not abort if we encounter"}, {"sha": "9efc5ca151c5ae9c797b5896a1d36c172ee6c1e5", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "patch": "@@ -4743,7 +4743,7 @@ order_regs_for_local_alloc ()\n    mem<-->reg splits to be run.  */\n \n int\n-sparc_splitdi_legitimate(reg, mem)\n+sparc_splitdi_legitimate (reg, mem)\n      rtx reg;\n      rtx mem;\n {\n@@ -4767,6 +4767,27 @@ sparc_splitdi_legitimate(reg, mem)\n   return 1;\n }\n \n+/* Return 1 if x and y are some kind of REG and they refer to\n+   different hard registers.  This test is guarenteed to be\n+   run after reload.  */\n+\n+int\n+sparc_absnegfloat_split_legitimate (x, y)\n+     rtx x, y;\n+{\n+  if (GET_CODE (x) == SUBREG)\n+    x = alter_subreg (x);\n+  if (GET_CODE (x) != REG)\n+    return 0;\n+  if (GET_CODE (y) == SUBREG)\n+    y = alter_subreg (y);\n+  if (GET_CODE (y) != REG)\n+    return 0;\n+  if (REGNO (x) == REGNO (y))\n+    return 0;\n+  return 1;\n+}\n+\n /* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.\n    This makes them candidates for using ldd and std insns. \n "}, {"sha": "bc850a36ca5e95772f90aca3c957f90d0d7d9868", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "patch": "@@ -3243,6 +3243,7 @@ extern void sparc_emit_set_const32 ();\n extern void sparc_emit_set_const64 ();\n extern void sparc_emit_set_symbolic_const64 ();\n extern int sparc_splitdi_legitimate ();\n+extern int sparc_absnegfloat_split_legitimate ();\n \n extern char *output_cbranch ();\n extern char *output_return ();"}, {"sha": "ba5c6e9b3ab3f52c28286460d36ce719a0b4c9be", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 99, "deletions": 50, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61c29e9871b85fc4f7c2755724f1d112f14d7f9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e61c29e9871b85fc4f7c2755724f1d112f14d7f9", "patch": "@@ -2785,8 +2785,8 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n         (match_operand:SF 1 \"const_double_operand\" \"\"))]\n   \"TARGET_FPU\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) < 32\"\n+   && (GET_CODE (operands[0]) == REG\n+       && REGNO (operands[0]) < 32)\"\n   [(set (match_dup 0) (unspec:SF [(match_dup 1)] 12))\n    (set (match_dup 0) (unspec:SF [(match_dup 0) (match_dup 1)] 17))]\n   \"\n@@ -2906,8 +2906,8 @@\n         (match_operand:DF 1 \"const_double_operand\" \"\"))]\n   \"TARGET_FPU\n    && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) < 32\n+   && (GET_CODE (operands[0]) == REG\n+       && REGNO (operands[0]) < 32)\n    && reload_completed\"\n   [(clobber (const_int 0))]\n   \"\n@@ -2917,6 +2917,8 @@\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n   REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+  if (GET_CODE (operands[0]) == SUBREG)\n+    operands[0] = alter_subreg (operands[0]);\n   operands[0] = gen_rtx_raw_REG (DImode, REGNO (operands[0]));\n \n   emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n@@ -3096,8 +3098,11 @@\n         (match_operand:DF 1 \"register_operand\" \"\"))]\n   \"(! TARGET_V9\n     || (! TARGET_ARCH64\n-        && GET_CODE (operands[0]) == REG\n-        && REGNO (operands[0]) < 32))\n+        && ((GET_CODE (operands[0]) == REG\n+             && REGNO (operands[0]) < 32)\n+            || (GET_CODE (operands[0]) == SUBREG\n+                && GET_CODE (SUBREG_REG (operands[0])) == REG\n+                && REGNO (SUBREG_REG (operands[0])) < 32))))\n    && reload_completed\"\n   [(clobber (const_int 0))]\n   \"\n@@ -3137,8 +3142,11 @@\n \t(match_operand:DF 1 \"memory_operand\" \"\"))]\n   \"((! TARGET_V9\n      || (! TARGET_ARCH64\n-         && GET_CODE (operands[0]) == REG\n-         && REGNO (operands[0]) < 32))\n+         && ((GET_CODE (operands[0]) == REG\n+              && REGNO (operands[0]) < 32)\n+             || (GET_CODE (operands[0]) == SUBREG\n+                 && GET_CODE (SUBREG_REG (operands[0])) == REG\n+                 && REGNO (SUBREG_REG (operands[0])) < 32))))\n     && (reload_completed\n         && (((REGNO (operands[0])) % 2) != 0\n              || ! mem_min_alignment (operands[1], 8))\n@@ -3179,8 +3187,11 @@\n \t(match_operand:DF 1 \"register_operand\" \"\"))]\n   \"((! TARGET_V9\n      || (! TARGET_ARCH64\n-         && GET_CODE (operands[1]) == REG\n-         && REGNO (operands[1]) < 32))\n+         && ((GET_CODE (operands[1]) == REG\n+              && REGNO (operands[1]) < 32)\n+             || (GET_CODE (operands[1]) == SUBREG\n+                 && GET_CODE (SUBREG_REG (operands[1])) == REG\n+                 && REGNO (SUBREG_REG (operands[1])) < 32))))\n     && (reload_completed\n         && (((REGNO (operands[1])) % 2) != 0\n              || ! mem_min_alignment (operands[0], 8))\n@@ -5666,12 +5677,17 @@\n \t\t\t    (match_operand:DI 3 \"arith_double_operand\" \"\")]))]\n   \"! TARGET_ARCH64\n    && reload_completed\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) < 32\"\n+   && ((GET_CODE (operands[0]) == REG\n+        && REGNO (operands[0]) < 32)\n+       || (GET_CODE (operands[0]) == SUBREG\n+           && GET_CODE (SUBREG_REG (operands[0])) == REG\n+           && REGNO (SUBREG_REG (operands[0])) < 32))\"\n   [(set (match_dup 4) (match_op_dup:SI 1 [(match_dup 6) (match_dup 8)]))\n    (set (match_dup 5) (match_op_dup:SI 1 [(match_dup 7) (match_dup 9)]))]\n   \"\n {\n+  if (GET_CODE (operands[0]) == SUBREG)\n+    operands[0] = alter_subreg (operands[0]);\n   operands[4] = gen_highpart (SImode, operands[0]);\n   operands[5] = gen_lowpart (SImode, operands[0]);\n   operands[6] = gen_highpart (SImode, operands[2]);\n@@ -5705,11 +5721,16 @@\n                 (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"! TARGET_ARCH64\n    && reload_completed\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) < 32\"\n+   && ((GET_CODE (operands[0]) == REG\n+        && REGNO (operands[0]) < 32)\n+       || (GET_CODE (operands[0]) == SUBREG\n+           && GET_CODE (SUBREG_REG (operands[0])) == REG\n+           && REGNO (SUBREG_REG (operands[0])) < 32))\"\n   [(set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))\n    (set (match_dup 6) (and:SI (not:SI (match_dup 7)) (match_dup 8)))]\n-  \"operands[3] = gen_highpart (SImode, operands[0]);\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   operands[3] = gen_highpart (SImode, operands[0]);\n    operands[4] = gen_highpart (SImode, operands[1]);\n    operands[5] = gen_highpart (SImode, operands[2]);\n    operands[6] = gen_lowpart (SImode, operands[0]);\n@@ -5810,11 +5831,16 @@\n                 (match_operand:DI 2 \"register_operand\" \"\")))]\n   \"! TARGET_ARCH64\n    && reload_completed\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) < 32\"\n+   && ((GET_CODE (operands[0]) == REG\n+        && REGNO (operands[0]) < 32)\n+       || (GET_CODE (operands[0]) == SUBREG\n+           && GET_CODE (SUBREG_REG (operands[0])) == REG\n+           && REGNO (SUBREG_REG (operands[0])) < 32))\"\n   [(set (match_dup 3) (ior:SI (not:SI (match_dup 4)) (match_dup 5)))\n    (set (match_dup 6) (ior:SI (not:SI (match_dup 7)) (match_dup 8)))]\n-  \"operands[3] = gen_highpart (SImode, operands[0]);\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   operands[3] = gen_highpart (SImode, operands[0]);\n    operands[4] = gen_highpart (SImode, operands[1]);\n    operands[5] = gen_highpart (SImode, operands[2]);\n    operands[6] = gen_lowpart (SImode, operands[0]);\n@@ -5942,11 +5968,16 @@\n                         (match_operand:DI 2 \"register_operand\" \"\"))))]\n   \"! TARGET_ARCH64\n    && reload_completed\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) < 32\"\n+   && ((GET_CODE (operands[0]) == REG\n+        && REGNO (operands[0]) < 32)\n+       || (GET_CODE (operands[0]) == SUBREG\n+           && GET_CODE (SUBREG_REG (operands[0])) == REG\n+           && REGNO (SUBREG_REG (operands[0])) < 32))\"\n   [(set (match_dup 3) (not:SI (xor:SI (match_dup 4) (match_dup 5))))\n    (set (match_dup 6) (not:SI (xor:SI (match_dup 7) (match_dup 8))))]\n-  \"operands[3] = gen_highpart (SImode, operands[0]);\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   operands[3] = gen_highpart (SImode, operands[0]);\n    operands[4] = gen_highpart (SImode, operands[1]);\n    operands[5] = gen_highpart (SImode, operands[2]);\n    operands[6] = gen_lowpart (SImode, operands[0]);\n@@ -6275,11 +6306,16 @@\n         (not:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n   \"! TARGET_ARCH64\n    && reload_completed\n-   && GET_CODE (operands[0]) == REG\n-   && REGNO (operands[0]) < 32\"\n+   && ((GET_CODE (operands[0]) == REG\n+        && REGNO (operands[0]) < 32)\n+       || (GET_CODE (operands[0]) == SUBREG\n+           && GET_CODE (SUBREG_REG (operands[0])) == REG\n+           && REGNO (SUBREG_REG (operands[0])) < 32))\"\n   [(set (match_dup 2) (not:SI (xor:SI (match_dup 3) (const_int 0))))\n    (set (match_dup 4) (not:SI (xor:SI (match_dup 5) (const_int 0))))]\n-  \"operands[2] = gen_highpart (SImode, operands[0]);\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   operands[2] = gen_highpart (SImode, operands[0]);\n    operands[3] = gen_highpart (SImode, operands[1]);\n    operands[4] = gen_lowpart (SImode, operands[0]);\n    operands[5] = gen_lowpart (SImode, operands[1]);\")\n@@ -6526,14 +6562,16 @@\n \t(neg:TF (match_operand:TF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\n    && ! TARGET_V9\n-   && GET_CODE (operands[0]) == REG\n-   && GET_CODE (operands[1]) == REG\n-   && REGNO (operands[0]) != REGNO (operands[1])\n+   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 2) (neg:SF (match_dup 3)))\n    (set (match_dup 4) (match_dup 5))\n    (set (match_dup 6) (match_dup 7))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   if (GET_CODE (operands[1]) == SUBREG)\n+     operands[1] = alter_subreg (operands[1]);\n+   operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n    operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n    operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n    operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\n@@ -6556,13 +6594,15 @@\n \t(neg:TF (match_operand:TF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\n    && TARGET_V9\n-   && GET_CODE (operands[0]) == REG\n-   && GET_CODE (operands[1]) == REG\n-   && REGNO (operands[0]) != REGNO (operands[1])\n+   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 2) (neg:DF (match_dup 3)))\n    (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   if (GET_CODE (operands[1]) == SUBREG)\n+     operands[1] = alter_subreg (operands[1]);\n+   operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n    operands[3] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]));\n    operands[4] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n    operands[5] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\")\n@@ -6588,13 +6628,15 @@\n         (neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n   \"TARGET_FPU\n    && ! TARGET_V9\n-   && GET_CODE (operands[0]) == REG\n-   && GET_CODE (operands[1]) == REG\n-   && REGNO (operands[0]) != REGNO (operands[1])\n+   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 2) (neg:SF (match_dup 3)))\n    (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   if (GET_CODE (operands[1]) == SUBREG)\n+     operands[1] = alter_subreg (operands[1]);\n+   operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n    operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n    operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n    operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\")\n@@ -6637,14 +6679,16 @@\n \t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n   \"TARGET_FPU\n    && ! TARGET_V9\n-   && GET_CODE (operands[0]) == REG\n-   && GET_CODE (operands[1]) == REG\n-   && REGNO (operands[0]) != REGNO (operands[1])\n+   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 2) (abs:SF (match_dup 3)))\n    (set (match_dup 4) (match_dup 5))\n    (set (match_dup 6) (match_dup 7))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   if (GET_CODE (operands[1]) == SUBREG)\n+     operands[1] = alter_subreg (operands[1]);\n+   operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n    operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n    operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n    operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\n@@ -6667,13 +6711,15 @@\n \t(abs:TF (match_operand:TF 1 \"register_operand\" \"0,e\")))]\n   \"TARGET_FPU\n    && TARGET_V9\n-   && GET_CODE (operands[0]) == REG\n-   && GET_CODE (operands[1]) == REG\n-   && REGNO (operands[0]) != REGNO (operands[1])\n+   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 2) (abs:DF (match_dup 3)))\n    (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   if (GET_CODE (operands[1]) == SUBREG)\n+     operands[1] = alter_subreg (operands[1]);\n+   operands[2] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]));\n    operands[3] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]));\n    operands[4] = gen_rtx_raw_REG (DFmode, REGNO (operands[0]) + 2);\n    operands[5] = gen_rtx_raw_REG (DFmode, REGNO (operands[1]) + 2);\")\n@@ -6699,13 +6745,15 @@\n \t(abs:DF (match_operand:DF 1 \"register_operand\" \"0,e\")))]\n   \"TARGET_FPU\n    && ! TARGET_V9\n-   && GET_CODE (operands[0]) == REG\n-   && GET_CODE (operands[1]) == REG\n-   && REGNO (operands[0]) != REGNO (operands[1])\n+   && sparc_absnegfloat_split_legitimate (operands[0], operands[1])\n    && reload_completed\"\n   [(set (match_dup 2) (abs:SF (match_dup 3)))\n    (set (match_dup 4) (match_dup 5))]\n-  \"operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n+  \"if (GET_CODE (operands[0]) == SUBREG)\n+     operands[0] = alter_subreg (operands[0]);\n+   if (GET_CODE (operands[1]) == SUBREG)\n+     operands[1] = alter_subreg (operands[1]);\n+   operands[2] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]));\n    operands[3] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]));\n    operands[4] = gen_rtx_raw_REG (SFmode, REGNO (operands[0]) + 1);\n    operands[5] = gen_rtx_raw_REG (SFmode, REGNO (operands[1]) + 1);\")\n@@ -6811,13 +6859,14 @@\n   [(set_attr \"length\" \"5,5,6\")])\n \n ;; Optimize (1LL<<x)-1\n-;; XXX\n+;; XXX this also needs to be fixed to handle equal subregs\n+;; XXX first before we could re-enable it.\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(plus:DI (ashift:DI (const_int 1)\n \t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n \t\t (const_int -1)))]\n-  \"TARGET_V8PLUS\"\n+  \"0 && TARGET_V8PLUS\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == REG && REGNO (operands[2]) == REGNO (operands[0]))"}]}