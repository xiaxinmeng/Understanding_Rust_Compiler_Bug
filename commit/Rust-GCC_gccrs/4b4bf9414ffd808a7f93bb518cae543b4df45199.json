{"sha": "4b4bf9414ffd808a7f93bb518cae543b4df45199", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI0YmY5NDE0ZmZkODA4YTdmOTNiYjUxOGNhZTU0M2I0ZGY0NTE5OQ==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2004-07-09T03:29:35Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-07-09T03:29:35Z"}, "message": "alias.c (nonlocal_mentioned_p, [...]): Use, LABEL_P, JUMP_P, CALL_P, NONJUMP_INSN_P, INSN_P, NOTE_P, BARRIER_P.\n\n2004-07-08  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* alias.c (nonlocal_mentioned_p, nonlocal_referenced_p,\n\tnonlocal_set_p, init_alias_analysis): Use, LABEL_P, JUMP_P, CALL_P,\n\tNONJUMP_INSN_P, INSN_P, NOTE_P, BARRIER_P.\n\t* bb-reorder.c (mark_bb_for_unlikely_executed_section,\n\tadd_labels_and_missing_jumps, find_jump_block,\n\tfix_crossing_unconditional_branches, add_reg_crossing_jump_notes):\n\tLikewise.\n\t* bt-load.c (btr_referenced_p, compute_defs_uses_and_gen,\n\tlink_btr_uses, move_btr_def): Likewise.\n\t* builtins.c (expand_builtin_longjmp, expand_builtin_nonlocal_goto,\n\texpand_builtin_expect_jump): Likewise.\n\t* caller-save.c (save_call_clobbered_regs, insert_one_insn): Likewise.\n\t* calls.c (expand_call, emit_library_call_value_1): Likewise.\n\t* cfganal.c (forwarder_block_p): Likewise.\n\t* cfgbuild.c (inside_basic_block_p, count_basic_blocks,\n\tmake_label_edge, rtl_make_eh_edge, make_edges, find_basic_blocks_1,\n\tfind_bb_boundaries): Likewise.\n\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n\tmerge_blocks_move_predecessor_nojumps,\n\tmerge_blocks_move_successor_nojumps, insns_match_p,\n\tflow_find_cross_jump, outgoing_edges_match, try_crossjump_to_edge,\n\ttry_optimize_cfg): Likewise.\n\t* cfgexpand.c (expand_block, construct_exit_block): Likewise.\n\t* cfglayout.c (skip_insns_after_block, label_for_bb,\n\trecord_effective_endpoints, insn_locators_initialize,\n\tfixup_reorder_chain, update_unlikely_executed_notes): Likewise.\n\t* cfgmainloop.c (create_loop_notes): Likewise.\n\t* cfgrtl.c (delete_insn, delete_insn_chain,\n\tcreate_basic_block_structure, rtl_delete_block, free_bb_for_insn,\n\tupdate_bb_for_insn, rtl_merge_blocks, rtl_can_merge_blocks,\n\tblock_label, try_redirect_by_replacing_jump, last_loop_beg_note,\n\tredirect_branch_edge, force_nonfallthru_and_redirect,\n\trtl_tidy_fallthru_edge, back_edge_of_syntactic_loop_p,\n\trtl_split_edge, commit_one_edge_insertion, print_rtl_with_bb,\n\tupdate_br_prob_note, rtl_verify_flow_info_1, rtl_verify_flow_info,\n\tpurge_dead_edges, cfg_layout_redirect_edge_and_branch,\n\tcfg_layout_delete_block, cfg_layout_can_merge_blocks_p,\n\tcfg_layout_merge_blocks, rtl_block_ends_with_call_p,\n\tneed_fake_edge_p, rtl_flow_call_edges_add): Likewise.\n\t* combine.c (combine_instructions, can_combine_p, try_combine,\n\tfind_split_point, record_dead_and_set_regs, reg_dead_at_p,\n\tdistribute_notes, distribute_links, insn_cuid): Likewise.\n\t* cse.c (fold_rtx, cse_insn, cse_around_loop,\n\tinvalidate_skipped_block, cse_set_around_loop,\n\tcse_end_of_basic_block, cse_main, cse_basic_block,\n\tcse_condition_code_reg): Likewise.\n\t* cselib.c (cselib_process_insn): Likewise.\n\t* ddg.c (create_ddg): Likewise.\n\t* df.c (df_insn_refs_record, df_bb_rd_local_compute, df_insns_modify):\n\tLikewise.\n\t* dwarf2out.c (dwarf2out_stack_adjust, dwarf2out_frame_debug,\n\tgen_label_die, dwarf2out_var_location): Likewise.\n\t* emit-rtl.c (get_first_nonnote_insn, get_last_nonnote_insn,\n\tnext_insn, previous_insn, next_nonnote_insn, prev_nonnote_insn,\n\tlast_call_insn, active_insn_p, next_label, prev_label,\n\tlink_cc0_insns, next_cc0_user, try_split, add_insn_after,\n\tadd_insn_before, remove_insn, add_function_usage_to,\n\treorder_insns, find_line_note, remove_unnecessary_notes,\n\temit_insn_after_1, classify_insn): Likewise.\n\t* except.c (convert_from_eh_region_ranges_1, emit_to_new_bb_before,\n\tconnect_post_landing_pads, sjlj_mark_call_sites,\n\tsjlj_emit_function_enter, sjlj_emit_function_exit, reachable_handlers,\n\tcan_throw_internal, can_throw_external, set_nothrow_function_flags,\n\tconvert_to_eh_region_ranges): Likewise.\n\t* explow.c (optimize_save_area_alloca): Likewise.\n\t* expr.c (expand_expr_real): Likewise.\n\t* final.c (insn_current_reference_address, compute_alignments,\n\tshorten_branches, final, scan_ahead_for_unlikely_executed_note,\n\tfinal_scan_insn, output_asm_label, leaf_function_p): Likewise.\n\t* flow.c (first_insn_after_basic_block_note, delete_dead_jumptables,\n\tpropagate_block_delete_insn, propagate_one_insn,\n\tinit_propagate_block_info, propagate_block, libcall_dead_p,\n\tmark_set_1, attempt_auto_inc, find_auto_inc, try_pre_increment):\n\tLikewise.\n\t* function.c (instantiate_virtual_regs,\treorder_blocks_1,\n\texpand_function_start, expand_function_end, contains,\n\tthread_prologue_and_epilogue_insns,\n\treposition_prologue_and_epilogue_notes): Likewise.\n\t* gcse.c (constprop_register, bypass_conditional_jumps,\n\tinsert_insn_end_bb, gcse_after_reload): Likewise.\n\t* genemit.c (gen_expand, gen_split): Likewise.\n\t* genpeep.c (gen_peephole, main): Likewise.\n\t* global.c (build_insn_chain): Likewise.\n\t* graph.c (node_data, print_rtl_graph_with_bb): Likewise.\n\t* haifa-sched.c (unlink_other_notes, unlink_line_notes,\n\tget_block_head_tail, no_real_insns_p, rm_line_notes, save_line_notes,\n\trestore_line_notes, rm_redundant_line_notes, rm_other_notes,\n\tok_for_early_queue_removal, set_priorities, sched_init): Likewise.\n\t* ifcvt.c (count_bb_insns, first_active_insn, last_active_insn,\n\tcond_exec_process_insns, end_ifcvt_sequence, noce_process_if_block,\n\tmerge_if_block, block_jumps_and_fallthru_p, find_if_block,\n\tdead_or_predicable): Likewise.\n\t* integrate.c (try_constants): Likewise.\n\t* jump.c (rebuild_jump_labels, cleanup_barriers,\n\tpurge_line_number_notes, init_label_info, mark_all_labels,\n\tsqueeze_notes, get_label_before, get_label_after,\n\treversed_comparison_code_parts, simplejump_p, pc_set,\n\treturnjump_p, onlyjump_p, follow_jumps, mark_jump_label,\n\tdelete_barrier, delete_prior_computation, delete_computation,\n\tdelete_related_insns, delete_for_peephole, redirect_jump):\n\tLikewise.\n\t* lcm.c (optimize_mode_switching): Likewise.\n\t* local-alloc.c (validate_equiv_mem, update_equiv_regs, block_alloc):\n\tLikewise.\n\t* loop-doloop.c (doloop_valid_p, doloop_optimize): Likewise.\n\t* loop-invariant.c (find_exits, find_invariants_bb): Likewise.\n\t* loop-iv.c (simplify_using_assignment): Likewise.\n\t* loop.c (compute_luids, loop_optimize, scan_loop, libcall_other_reg,\n\tlibcall_benefit, skip_consec_insns, move_movables, prescan_loop,\n\tfind_and_verify_loops, labels_in_range_p, for_each_insn_in_loop,\n\tloop_bivs_init_find, strength_reduce, check_insn_for_bivs,\n\tcheck_insn_for_givs, check_final_value, update_giv_derive,\n\tbasic_induction_var, product_cheap_p, check_dbra_loop,\n\tloop_insn_first_p, last_use_this_basic_block,\n\tcanonicalize_condition, get_condition, loop_regs_scan, load_mems,\n\ttry_copy_prop, LOOP_BLOCK_NUM, loop_dump_aux): Likewise.\n\t* modulo-sched.c (doloop_register_get, find_line_note, sms_schedule,\n\tsms_schedule_by_order): Likewise.\n\t* optabs.c (emit_no_conflict_block, emit_libcall_block): Likewise.\n\t* postreload.c (reload_cse_simplify_operands, reload_combine,\n\treload_cse_move2add): Likewise.\n\t* predict.c (can_predict_insn_p, estimate_probability,\n\texpected_value_to_br_prob, process_note_predictions): Likewise.\n\t* print-rtl.c (print_rtx, print_rtl, print_rtl_single): Likewise.\n\t* profile.c (branch_prob): Likewise.\n\t* ra-build.c (live_out_1, livethrough_conflicts_bb,\n\tdetect_webs_set_in_cond_jump): Likewise.\n\t* ra-debug.c (ra_print_rtx_object, ra_debug_insns,\n\tra_print_rtl_with_bb): Likewise.\n\t* ra-rewrite.c (insert_stores, rewrite_program2): Likewise.\n\t* recog.c (next_insn_tests_no_inequality, find_single_use,\n\tsplit_all_insns, peephole2_optimize, if_test_bypass_p): Likewise.\n\t* reg-stack.c (next_flags_user, record_label_references,\n\temit_swap_insn, swap_rtx_condition, subst_stack_regs,\n\tcompensate_edge, convert_regs_1): Likewise.\n\t* regclass.c (scan_one_insn): Likewise.\n\t* regmove.c (optimize_reg_copy_1, optimize_reg_copy_2, fixup_match_2,\n\tregmove_optimize, fixup_match_1, single_set_for_csa,\n\tcombine_stack_adjustments_for_block): Likewise.\n\t* regrename.c (build_def_use, copyprop_hardreg_forward_1): Likewise.\n\t* reload.c (find_reloads, find_reloads_address_1, subst_reloads,\n\tfind_equiv_reg): Likewise.\n\t* reload1.c (reload, calculate_needs_all_insns, set_label_offsets,\n\treload_as_needed, emit_input_reload_insns, do_output_reload,\n\tdelete_output_reload, delete_address_reloads_1, fixup_abnormal_edges):\n\tLikewise.\n\t* reorg.c (find_end_label, emit_delay_sequence,\n\tdelete_from_delay_slot, delete_scheduled_jump, optimize_skip,\n\tget_jump_flags, rare_destination, mostly_true_jump,\n\ttry_merge_delay_insns, redundant_insn, own_thread_p,\n\tfill_simple_delay_slots, fill_slots_from_thread,\n\tfill_eager_delay_slots, relax_delay_slots, make_return_insns,\n\tdbr_schedule): Likewise.\n\t* resource.c (find_basic_block, next_insn_no_annul,\n\tfind_dead_or_set_registers, mark_target_live_regs): Likewise.\n\t* rtl.h (RTX_PREV): Likewise.\n\t* rtlanal.c (global_reg_mentioned_p, no_labels_between_p,\n\tno_jumps_between_p, reg_used_between_p, reg_referenced_between_p,\n\treg_set_p, find_last_value, dead_or_set_regno_p, find_reg_fusage,\n\tfind_regno_fusage, pure_call_p, replace_label, rtx_referenced_p_1,\n\ttablejump_p, computed_jump_p, insns_safe_to_move_p,\n\tfind_first_parameter_load, can_hoist_insn_p): Likewise.\n\t* sched-deps.c (get_condition, add_dependence, sched_analyze_2,\n\tsched_analyze_insn, sched_analyze, add_forward_dependence): Likewise.\n\t* sched-ebb.c (fix_basic_block_boundaries, add_deps_for_risky_insns,\n\tschedule_ebbs): Likewise.\n\t* sched-rgn.c (is_cfg_nonregular, find_conditional_protection,\n\tis_conditionally_protected, can_schedule_ready_p,\n\tadd_branch_dependences, debug_dependencies): Likewise.\n\t* stmt.c (emit_nop, expand_start_case, emit_jump_if_reachable):\n\tLikewise.\n\t* unroll.c (unroll_loop, copy_loop_body, back_branch_in_range_p,\n\treg_dead_after_loop, loop_find_equiv_value, loop_iterations,\n\tset_dominates_use, ujump_to_loop_cont): Likewise.\n\t* var-tracking.c (prologue_stack_adjust, vt_initialize): Likewise.\n\t* varasm.c (output_constant_pool_1): Likewise.\n\nFrom-SVN: r84341", "tree": {"sha": "6ef911acbe6f351441274664098acc17958f8cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ef911acbe6f351441274664098acc17958f8cc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b4bf9414ffd808a7f93bb518cae543b4df45199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4bf9414ffd808a7f93bb518cae543b4df45199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4bf9414ffd808a7f93bb518cae543b4df45199", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4bf9414ffd808a7f93bb518cae543b4df45199/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9eb809dec69b6280ed2f2830efd1ac8b7d9bcb8"}], "stats": {"total": 2103, "additions": 1133, "deletions": 970}, "files": [{"sha": "e49ec16147e2563a37b8e80c0c543870fba8909d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1,3 +1,182 @@\n+2004-07-08  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* alias.c (nonlocal_mentioned_p, nonlocal_referenced_p,\n+\tnonlocal_set_p, init_alias_analysis): Use, LABEL_P, JUMP_P, CALL_P,\n+\tNONJUMP_INSN_P, INSN_P, NOTE_P, BARRIER_P.\n+\t* bb-reorder.c (mark_bb_for_unlikely_executed_section,\n+\tadd_labels_and_missing_jumps, find_jump_block,\n+\tfix_crossing_unconditional_branches, add_reg_crossing_jump_notes):\n+\tLikewise.\n+\t* bt-load.c (btr_referenced_p, compute_defs_uses_and_gen,\n+\tlink_btr_uses, move_btr_def): Likewise.\n+\t* builtins.c (expand_builtin_longjmp, expand_builtin_nonlocal_goto,\n+\texpand_builtin_expect_jump): Likewise.\n+\t* caller-save.c (save_call_clobbered_regs, insert_one_insn): Likewise.\n+\t* calls.c (expand_call, emit_library_call_value_1): Likewise.\n+\t* cfganal.c (forwarder_block_p): Likewise.\n+\t* cfgbuild.c (inside_basic_block_p, count_basic_blocks,\n+\tmake_label_edge, rtl_make_eh_edge, make_edges, find_basic_blocks_1,\n+\tfind_bb_boundaries): Likewise.\n+\t* cfgcleanup.c (try_simplify_condjump, try_forward_edges,\n+\tmerge_blocks_move_predecessor_nojumps,\n+\tmerge_blocks_move_successor_nojumps, insns_match_p,\n+\tflow_find_cross_jump, outgoing_edges_match, try_crossjump_to_edge,\n+\ttry_optimize_cfg): Likewise.\n+\t* cfgexpand.c (expand_block, construct_exit_block): Likewise.\n+\t* cfglayout.c (skip_insns_after_block, label_for_bb,\n+\trecord_effective_endpoints, insn_locators_initialize,\n+\tfixup_reorder_chain, update_unlikely_executed_notes): Likewise.\n+\t* cfgmainloop.c (create_loop_notes): Likewise.\n+\t* cfgrtl.c (delete_insn, delete_insn_chain,\n+\tcreate_basic_block_structure, rtl_delete_block, free_bb_for_insn,\n+\tupdate_bb_for_insn, rtl_merge_blocks, rtl_can_merge_blocks,\n+\tblock_label, try_redirect_by_replacing_jump, last_loop_beg_note,\n+\tredirect_branch_edge, force_nonfallthru_and_redirect,\n+\trtl_tidy_fallthru_edge, back_edge_of_syntactic_loop_p,\n+\trtl_split_edge, commit_one_edge_insertion, print_rtl_with_bb,\n+\tupdate_br_prob_note, rtl_verify_flow_info_1, rtl_verify_flow_info,\n+\tpurge_dead_edges, cfg_layout_redirect_edge_and_branch,\n+\tcfg_layout_delete_block, cfg_layout_can_merge_blocks_p,\n+\tcfg_layout_merge_blocks, rtl_block_ends_with_call_p,\n+\tneed_fake_edge_p, rtl_flow_call_edges_add): Likewise.\n+\t* combine.c (combine_instructions, can_combine_p, try_combine,\n+\tfind_split_point, record_dead_and_set_regs, reg_dead_at_p,\n+\tdistribute_notes, distribute_links, insn_cuid): Likewise.\n+\t* cse.c (fold_rtx, cse_insn, cse_around_loop,\n+\tinvalidate_skipped_block, cse_set_around_loop,\n+\tcse_end_of_basic_block, cse_main, cse_basic_block,\n+\tcse_condition_code_reg): Likewise.\n+\t* cselib.c (cselib_process_insn): Likewise.\n+\t* ddg.c (create_ddg): Likewise.\n+\t* df.c (df_insn_refs_record, df_bb_rd_local_compute, df_insns_modify):\n+\tLikewise.\n+\t* dwarf2out.c (dwarf2out_stack_adjust, dwarf2out_frame_debug,\n+\tgen_label_die, dwarf2out_var_location): Likewise.\n+\t* emit-rtl.c (get_first_nonnote_insn, get_last_nonnote_insn,\n+\tnext_insn, previous_insn, next_nonnote_insn, prev_nonnote_insn,\n+\tlast_call_insn, active_insn_p, next_label, prev_label,\n+\tlink_cc0_insns, next_cc0_user, try_split, add_insn_after,\n+\tadd_insn_before, remove_insn, add_function_usage_to,\n+\treorder_insns, find_line_note, remove_unnecessary_notes,\n+\temit_insn_after_1, classify_insn): Likewise.\n+\t* except.c (convert_from_eh_region_ranges_1, emit_to_new_bb_before,\n+\tconnect_post_landing_pads, sjlj_mark_call_sites,\n+\tsjlj_emit_function_enter, sjlj_emit_function_exit, reachable_handlers,\n+\tcan_throw_internal, can_throw_external, set_nothrow_function_flags,\n+\tconvert_to_eh_region_ranges): Likewise.\n+\t* explow.c (optimize_save_area_alloca): Likewise.\n+\t* expr.c (expand_expr_real): Likewise.\n+\t* final.c (insn_current_reference_address, compute_alignments,\n+\tshorten_branches, final, scan_ahead_for_unlikely_executed_note,\n+\tfinal_scan_insn, output_asm_label, leaf_function_p): Likewise.\n+\t* flow.c (first_insn_after_basic_block_note, delete_dead_jumptables,\n+\tpropagate_block_delete_insn, propagate_one_insn,\n+\tinit_propagate_block_info, propagate_block, libcall_dead_p,\n+\tmark_set_1, attempt_auto_inc, find_auto_inc, try_pre_increment):\n+\tLikewise.\n+\t* function.c (instantiate_virtual_regs,\treorder_blocks_1,\n+\texpand_function_start, expand_function_end, contains,\n+\tthread_prologue_and_epilogue_insns,\n+\treposition_prologue_and_epilogue_notes): Likewise.\n+\t* gcse.c (constprop_register, bypass_conditional_jumps,\n+\tinsert_insn_end_bb, gcse_after_reload): Likewise.\n+\t* genemit.c (gen_expand, gen_split): Likewise.\n+\t* genpeep.c (gen_peephole, main): Likewise.\n+\t* global.c (build_insn_chain): Likewise.\n+\t* graph.c (node_data, print_rtl_graph_with_bb): Likewise.\n+\t* haifa-sched.c (unlink_other_notes, unlink_line_notes,\n+\tget_block_head_tail, no_real_insns_p, rm_line_notes, save_line_notes,\n+\trestore_line_notes, rm_redundant_line_notes, rm_other_notes,\n+\tok_for_early_queue_removal, set_priorities, sched_init): Likewise.\n+\t* ifcvt.c (count_bb_insns, first_active_insn, last_active_insn,\n+\tcond_exec_process_insns, end_ifcvt_sequence, noce_process_if_block,\n+\tmerge_if_block, block_jumps_and_fallthru_p, find_if_block,\n+\tdead_or_predicable): Likewise.\n+\t* integrate.c (try_constants): Likewise.\n+\t* jump.c (rebuild_jump_labels, cleanup_barriers,\n+\tpurge_line_number_notes, init_label_info, mark_all_labels,\n+\tsqueeze_notes, get_label_before, get_label_after,\n+\treversed_comparison_code_parts, simplejump_p, pc_set,\n+\treturnjump_p, onlyjump_p, follow_jumps, mark_jump_label,\n+\tdelete_barrier, delete_prior_computation, delete_computation,\n+\tdelete_related_insns, delete_for_peephole, redirect_jump):\n+\tLikewise.\n+\t* lcm.c (optimize_mode_switching): Likewise.\n+\t* local-alloc.c (validate_equiv_mem, update_equiv_regs, block_alloc):\n+\tLikewise.\n+\t* loop-doloop.c (doloop_valid_p, doloop_optimize): Likewise.\n+\t* loop-invariant.c (find_exits, find_invariants_bb): Likewise.\n+\t* loop-iv.c (simplify_using_assignment): Likewise.\n+\t* loop.c (compute_luids, loop_optimize, scan_loop, libcall_other_reg,\n+\tlibcall_benefit, skip_consec_insns, move_movables, prescan_loop,\n+\tfind_and_verify_loops, labels_in_range_p, for_each_insn_in_loop,\n+\tloop_bivs_init_find, strength_reduce, check_insn_for_bivs,\n+\tcheck_insn_for_givs, check_final_value, update_giv_derive,\n+\tbasic_induction_var, product_cheap_p, check_dbra_loop,\n+\tloop_insn_first_p, last_use_this_basic_block,\n+\tcanonicalize_condition, get_condition, loop_regs_scan, load_mems,\n+\ttry_copy_prop, LOOP_BLOCK_NUM, loop_dump_aux): Likewise.\n+\t* modulo-sched.c (doloop_register_get, find_line_note, sms_schedule,\n+\tsms_schedule_by_order): Likewise.\n+\t* optabs.c (emit_no_conflict_block, emit_libcall_block): Likewise.\n+\t* postreload.c (reload_cse_simplify_operands, reload_combine,\n+\treload_cse_move2add): Likewise.\n+\t* predict.c (can_predict_insn_p, estimate_probability,\n+\texpected_value_to_br_prob, process_note_predictions): Likewise.\n+\t* print-rtl.c (print_rtx, print_rtl, print_rtl_single): Likewise.\n+\t* profile.c (branch_prob): Likewise.\n+\t* ra-build.c (live_out_1, livethrough_conflicts_bb,\n+\tdetect_webs_set_in_cond_jump): Likewise.\n+\t* ra-debug.c (ra_print_rtx_object, ra_debug_insns,\n+\tra_print_rtl_with_bb): Likewise.\n+\t* ra-rewrite.c (insert_stores, rewrite_program2): Likewise.\n+\t* recog.c (next_insn_tests_no_inequality, find_single_use,\n+\tsplit_all_insns, peephole2_optimize, if_test_bypass_p): Likewise.\n+\t* reg-stack.c (next_flags_user, record_label_references,\n+\temit_swap_insn, swap_rtx_condition, subst_stack_regs,\n+\tcompensate_edge, convert_regs_1): Likewise.\n+\t* regclass.c (scan_one_insn): Likewise.\n+\t* regmove.c (optimize_reg_copy_1, optimize_reg_copy_2, fixup_match_2,\n+\tregmove_optimize, fixup_match_1, single_set_for_csa,\n+\tcombine_stack_adjustments_for_block): Likewise.\n+\t* regrename.c (build_def_use, copyprop_hardreg_forward_1): Likewise.\n+\t* reload.c (find_reloads, find_reloads_address_1, subst_reloads,\n+\tfind_equiv_reg): Likewise.\n+\t* reload1.c (reload, calculate_needs_all_insns, set_label_offsets,\n+\treload_as_needed, emit_input_reload_insns, do_output_reload,\n+\tdelete_output_reload, delete_address_reloads_1, fixup_abnormal_edges):\n+\tLikewise.\n+\t* reorg.c (find_end_label, emit_delay_sequence,\n+\tdelete_from_delay_slot, delete_scheduled_jump, optimize_skip,\n+\tget_jump_flags, rare_destination, mostly_true_jump,\n+\ttry_merge_delay_insns, redundant_insn, own_thread_p,\n+\tfill_simple_delay_slots, fill_slots_from_thread,\n+\tfill_eager_delay_slots, relax_delay_slots, make_return_insns,\n+\tdbr_schedule): Likewise.\n+\t* resource.c (find_basic_block, next_insn_no_annul,\n+\tfind_dead_or_set_registers, mark_target_live_regs): Likewise.\n+\t* rtl.h (RTX_PREV): Likewise.\n+\t* rtlanal.c (global_reg_mentioned_p, no_labels_between_p,\n+\tno_jumps_between_p, reg_used_between_p, reg_referenced_between_p,\n+\treg_set_p, find_last_value, dead_or_set_regno_p, find_reg_fusage,\n+\tfind_regno_fusage, pure_call_p, replace_label, rtx_referenced_p_1,\n+\ttablejump_p, computed_jump_p, insns_safe_to_move_p,\n+\tfind_first_parameter_load, can_hoist_insn_p): Likewise.\n+\t* sched-deps.c (get_condition, add_dependence, sched_analyze_2,\n+\tsched_analyze_insn, sched_analyze, add_forward_dependence): Likewise.\n+\t* sched-ebb.c (fix_basic_block_boundaries, add_deps_for_risky_insns,\n+\tschedule_ebbs): Likewise.\n+\t* sched-rgn.c (is_cfg_nonregular, find_conditional_protection,\n+\tis_conditionally_protected, can_schedule_ready_p,\n+\tadd_branch_dependences, debug_dependencies): Likewise.\n+\t* stmt.c (emit_nop, expand_start_case, emit_jump_if_reachable):\n+\tLikewise.\n+\t* unroll.c (unroll_loop, copy_loop_body, back_branch_in_range_p,\n+\treg_dead_after_loop, loop_find_equiv_value, loop_iterations,\n+\tset_dominates_use, ujump_to_loop_cont): Likewise.\n+\t* var-tracking.c (prologue_stack_adjust, vt_initialize): Likewise.\n+\t* varasm.c (output_constant_pool_1): Likewise.\n+\n 2004-07-08  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* tree-scalar-evolution.c: New file."}, {"sha": "1bf1d757cb40b852444faadd802d0483284c1aee", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -2495,7 +2495,7 @@ nonlocal_mentioned_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n-      if (GET_CODE (x) == CALL_INSN)\n+      if (CALL_P (x))\n \t{\n \t  if (! CONST_OR_PURE_CALL_P (x))\n \t    return 1;\n@@ -2589,7 +2589,7 @@ nonlocal_referenced_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n-      if (GET_CODE (x) == CALL_INSN)\n+      if (CALL_P (x))\n \t{\n \t  if (! CONST_OR_PURE_CALL_P (x))\n \t    return 1;\n@@ -2665,7 +2665,7 @@ nonlocal_set_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n-      if (GET_CODE (x) == CALL_INSN)\n+      if (CALL_P (x))\n \t{\n \t  if (! CONST_OR_PURE_CALL_P (x))\n \t    return 1;\n@@ -2953,7 +2953,7 @@ init_alias_analysis (void)\n \t\t    }\n \t\t}\n \t    }\n-\t  else if (GET_CODE (insn) == NOTE\n+\t  else if (NOTE_P (insn)\n \t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n \t    copying_arguments = false;\n \t}"}, {"sha": "c739eb6b54601fa9648f74cc59719d9813f25d5a", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1306,8 +1306,8 @@ mark_bb_for_unlikely_executed_section (basic_block bb)\n   \n   for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb)); \n        cur_insn = NEXT_INSN (cur_insn))\n-    if (GET_CODE (cur_insn) != NOTE\n-\t&& GET_CODE (cur_insn) != CODE_LABEL)\n+    if (!NOTE_P (cur_insn)\n+\t&& !LABEL_P (cur_insn))\n       {\n \tinsert_insn = cur_insn;\n \tbreak;\n@@ -1360,7 +1360,7 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n \t      \n  \t      if (src && (src != ENTRY_BLOCK_PTR)) \n  \t\t{\n-\t\t  if (GET_CODE (BB_END (src)) != JUMP_INSN)\n+\t\t  if (!JUMP_P (BB_END (src)))\n  \t\t    /* bb just falls through.  */\n  \t\t    {\n  \t\t      /* make sure there's only one successor */\n@@ -1556,14 +1556,14 @@ find_jump_block (basic_block jump_dest)\n \t   only one executable instruction, which is an unconditional jump.\n \t   If so, we can use it.  */\n \t\n-\tif (GET_CODE (BB_HEAD (src)) == CODE_LABEL)\n+\tif (LABEL_P (BB_HEAD (src)))\n \t  for (insn = BB_HEAD (src); \n \t       !INSN_P (insn) && insn != NEXT_INSN (BB_END (src));\n \t       insn = NEXT_INSN (insn))\n \t    {\n \t      if (INSN_P (insn)\n \t\t  && insn == BB_END (src)\n-\t\t  && GET_CODE (insn) == JUMP_INSN\n+\t\t  && JUMP_P (insn)\n \t\t  && !any_condjump_p (insn))\n \t\t{\n \t\t  source_bb = src;\n@@ -1763,7 +1763,7 @@ fix_crossing_unconditional_branches (void)\n       /* Check to see if bb ends in a crossing (unconditional) jump.  At\n          this point, no crossing jumps should be conditional.  */\n \n-      if (GET_CODE (last_insn) == JUMP_INSN\n+      if (JUMP_P (last_insn)\n \t  && succ->crossing_edge)\n \t{\n \t  rtx label2, table;\n@@ -1803,7 +1803,7 @@ fix_crossing_unconditional_branches (void)\n \t\t   cur_insn = NEXT_INSN (cur_insn))\n \t\t{\n \t\t  BLOCK_FOR_INSN (cur_insn) = cur_bb;\n-\t\t  if (GET_CODE (cur_insn) == JUMP_INSN)\n+\t\t  if (JUMP_P (cur_insn))\n \t\t    jump_insn = cur_insn;\n \t\t}\n \t      \n@@ -1833,7 +1833,7 @@ add_reg_crossing_jump_notes (void)\n   FOR_EACH_BB (bb)\n     for (e = bb->succ; e; e = e->succ_next)\n       if (e->crossing_edge\n-\t  && GET_CODE (BB_END (e->src)) == JUMP_INSN)\n+\t  && JUMP_P (BB_END (e->src)))\n \tREG_NOTES (BB_END (e->src)) = gen_rtx_EXPR_LIST (REG_CROSSING_JUMP, \n \t\t\t\t\t\t\t NULL_RTX, \n \t\t\t\t\t\t         REG_NOTES (BB_END "}, {"sha": "ea3d729603af17f177fbfe485bec860d13019c5e", "filename": "gcc/bt-load.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -225,7 +225,7 @@ insn_sets_btr_p (rtx insn, int check_const, int *regno)\n {\n   rtx set;\n \n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && (set = single_set (insn)))\n     {\n       rtx dest = SET_DEST (set);\n@@ -533,7 +533,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t\t      user->next = info.users_this_bb;\n \t\t      info.users_this_bb = user;\n \t\t    }\n-\t\t  if (GET_CODE (insn) == CALL_INSN)\n+\t\t  if (CALL_P (insn))\n \t\t    {\n \t\t      HARD_REG_SET *clobbered = &call_used_reg_set;\n \t\t      HARD_REG_SET call_saved;\n@@ -580,7 +580,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n \t  IOR_HARD_REG_SET (btrs_live_at_end[i], tmp);\n \t  can_throw = 1;\n \t}\n-      if (can_throw || GET_CODE (insn) == JUMP_INSN)\n+      if (can_throw || JUMP_P (insn))\n \t{\n \t  int regno;\n \n@@ -740,7 +740,7 @@ link_btr_uses (btr_def *def_array, btr_user *use_array, sbitmap *bb_out,\n \t\t  sbitmap_free (reaching_defs_of_reg);\n \t\t}\n \n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      if (CALL_P (insn))\n \t\t{\n \t\t  int regno;\n \n@@ -1135,7 +1135,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n   combine_btr_defs (def, btrs_live_in_range);\n   btr = def->btr;\n   add_btr_to_live_range (def);\n-  if (GET_CODE (insp) == CODE_LABEL)\n+  if (LABEL_P (insp))\n     insp = NEXT_INSN (insp);\n   /* N.B.: insp is expected to be NOTE_INSN_BASIC_BLOCK now.  Some\n      optimizations can result in insp being both first and last insn of\n@@ -1148,7 +1148,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n       for (insp = BB_END (b); ! INSN_P (insp); insp = PREV_INSN (insp))\n \tif (insp == BB_HEAD (b))\n \t  abort ();\n-      if (GET_CODE (insp) == JUMP_INSN || can_throw_internal (insp))\n+      if (JUMP_P (insp) || can_throw_internal (insp))\n \tinsp = PREV_INSN (insp);\n     }\n "}, {"sha": "26d4867e389d0a9bc972dea29eab10fc901edf1d", "filename": "gcc/builtins.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -766,13 +766,13 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n     {\n       if (insn == last)\n \tabort ();\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \t{\n \t  REG_NOTES (insn) = alloc_EXPR_LIST (REG_NON_LOCAL_GOTO, const0_rtx,\n \t\t\t\t\t      REG_NOTES (insn));\n \t  break;\n \t}\n-      else if (GET_CODE (insn) == CALL_INSN)\n+      else if (CALL_P (insn))\n \tbreak;\n     }\n }\n@@ -837,13 +837,13 @@ expand_builtin_nonlocal_goto (tree arglist)\n      non-local goto.  */\n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \t{\n \t  REG_NOTES (insn) = alloc_EXPR_LIST (REG_NON_LOCAL_GOTO,\n \t\t\t\t\t      const0_rtx, REG_NOTES (insn));\n \t  break;\n \t}\n-      else if (GET_CODE (insn) == CALL_INSN)\n+      else if (CALL_P (insn))\n \tbreak;\n     }\n \n@@ -4981,9 +4981,9 @@ expand_builtin_expect_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       ret = get_insns ();\n \n       drop_through_label = get_last_insn ();\n-      if (drop_through_label && GET_CODE (drop_through_label) == NOTE)\n+      if (drop_through_label && NOTE_P (drop_through_label))\n \tdrop_through_label = prev_nonnote_insn (drop_through_label);\n-      if (drop_through_label && GET_CODE (drop_through_label) != CODE_LABEL)\n+      if (drop_through_label && !LABEL_P (drop_through_label))\n \tdrop_through_label = NULL_RTX;\n       end_sequence ();\n \n@@ -4998,7 +4998,7 @@ expand_builtin_expect_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t{\n \t  rtx next = NEXT_INSN (insn);\n \n-\t  if (GET_CODE (insn) == JUMP_INSN && any_condjump_p (insn))\n+\t  if (JUMP_P (insn) && any_condjump_p (insn))\n \t    {\n \t      rtx ifelse = SET_SRC (pc_set (insn));\n \t      rtx then_dest = XEXP (ifelse, 1);\n@@ -5021,10 +5021,10 @@ expand_builtin_expect_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t      /* Otherwise check where we drop through.  */\n \t      else if (else_dest == pc_rtx)\n \t\t{\n-\t\t  if (next && GET_CODE (next) == NOTE)\n+\t\t  if (next && NOTE_P (next))\n \t\t    next = next_nonnote_insn (next);\n \n-\t\t  if (next && GET_CODE (next) == JUMP_INSN\n+\t\t  if (next && JUMP_P (next)\n \t\t      && any_uncondjump_p (next))\n \t\t    temp = XEXP (SET_SRC (pc_set (next)), 0);\n \t\t  else\n@@ -5039,10 +5039,10 @@ expand_builtin_expect_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t\t}\n \t      else if (then_dest == pc_rtx)\n \t\t{\n-\t\t  if (next && GET_CODE (next) == NOTE)\n+\t\t  if (next && NOTE_P (next))\n \t\t    next = next_nonnote_insn (next);\n \n-\t\t  if (next && GET_CODE (next) == JUMP_INSN\n+\t\t  if (next && JUMP_P (next)\n \t\t      && any_uncondjump_p (next))\n \t\t    temp = XEXP (SET_SRC (pc_set (next)), 0);\n \t\t  else"}, {"sha": "aa9b5845a41e7b40e36f3368a4b796d59a3ba1e3", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -484,7 +484,7 @@ save_call_clobbered_regs (void)\n \t  if (n_regs_saved)\n \t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t      if (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n-\t\tregno += insert_restore (chain, GET_CODE (insn) == JUMP_INSN,\n+\t\tregno += insert_restore (chain, JUMP_P (insn),\n \t\t\t\t\t regno, MOVE_MAX_WORDS, save_mode);\n \t}\n     }\n@@ -793,7 +793,7 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n      isn't a problem.  We do, however, assume here that CALL_INSNs don't\n      reference CC0.  Guard against non-INSN's like CODE_LABEL.  */\n \n-  if ((GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n+  if ((NONJUMP_INSN_P (insn) || JUMP_P (insn))\n       && before_p\n       && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n     chain = chain->prev, insn = chain->insn;"}, {"sha": "55fb4d75ccb9c89b271b5eda86439d2fdcc8b508", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -2838,7 +2838,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  /* Expansion of block moves possibly introduced a loop that may\n \t     not appear inside libcall block.  */\n \t  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-\t    if (GET_CODE (insn) == JUMP_INSN)\n+\t    if (JUMP_P (insn))\n \t      failed = true;\n \n \t  if (failed)\n@@ -2923,7 +2923,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t     than just a CALL_INSN above, so we must search for it here.  */\n \n \t  rtx last = get_last_insn ();\n-\t  while (GET_CODE (last) != CALL_INSN)\n+\t  while (!CALL_P (last))\n \t    {\n \t      last = PREV_INSN (last);\n \t      /* There was no CALL_INSN?  */\n@@ -3929,7 +3929,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t just a CALL_INSN above, so we must search for it here.  */\n \n       rtx last = get_last_insn ();\n-      while (GET_CODE (last) != CALL_INSN)\n+      while (!CALL_P (last))\n \t{\n \t  last = PREV_INSN (last);\n \t  /* There was no CALL_INSN?  */"}, {"sha": "0bfccae79ec3ac4c07eadaf7d42652df4dae9e93", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -93,7 +93,7 @@ forwarder_block_p (basic_block bb)\n       return false;\n \n   return (!INSN_P (insn)\n-\t  || (GET_CODE (insn) == JUMP_INSN && simplejump_p (insn))\n+\t  || (JUMP_P (insn) && simplejump_p (insn))\n \t  || !flow_active_insn_p (insn));\n }\n "}, {"sha": "3316f02418406d87ebbc6ea35d16a42bc613a04b", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -66,7 +66,7 @@ inside_basic_block_p (rtx insn)\n     case CODE_LABEL:\n       /* Avoid creating of basic block for jumptables.  */\n       return (NEXT_INSN (insn) == 0\n-\t      || GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t      || !JUMP_P (NEXT_INSN (insn))\n \t      || (GET_CODE (PATTERN (NEXT_INSN (insn))) != ADDR_VEC\n \t\t  && GET_CODE (PATTERN (NEXT_INSN (insn))) != ADDR_DIFF_VEC));\n \n@@ -148,7 +148,7 @@ count_basic_blocks (rtx f)\n     {\n       /* Code labels and barriers causes current basic block to be\n          terminated at previous real insn.  */\n-      if ((GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == BARRIER)\n+      if ((LABEL_P (insn) || BARRIER_P (insn))\n \t  && saw_insn)\n \tcount++, saw_insn = false;\n \n@@ -183,7 +183,7 @@ count_basic_blocks (rtx f)\n static void\n make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n {\n-  if (GET_CODE (label) != CODE_LABEL)\n+  if (!LABEL_P (label))\n     abort ();\n \n   /* If the label was never emitted, this insn is junk, but avoid a\n@@ -202,7 +202,7 @@ make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n void\n rtl_make_eh_edge (sbitmap *edge_cache, basic_block src, rtx insn)\n {\n-  int is_call = GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0;\n+  int is_call = CALL_P (insn) ? EDGE_ABNORMAL_CALL : 0;\n   rtx handlers, i;\n \n   handlers = reachable_handlers (insn);\n@@ -269,7 +269,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n       int force_fallthru = 0;\n       edge e;\n \n-      if (GET_CODE (BB_HEAD (bb)) == CODE_LABEL\n+      if (LABEL_P (BB_HEAD (bb))\n \t  && LABEL_ALT_ENTRY_P (BB_HEAD (bb)))\n \tcached_make_edge (NULL, ENTRY_BLOCK_PTR, bb, 0);\n \n@@ -394,7 +394,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t    break;\n \t  }\n       while (insn\n-\t     && GET_CODE (insn) == NOTE\n+\t     && NOTE_P (insn)\n \t     && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n \tinsn = NEXT_INSN (insn);\n \n@@ -437,7 +437,7 @@ find_basic_blocks_1 (rtx f)\n \n       next = NEXT_INSN (insn);\n \n-      if ((GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == BARRIER)\n+      if ((LABEL_P (insn) || BARRIER_P (insn))\n \t  && head)\n \t{\n \t  prev = create_basic_block_structure (head, end, bb_note, prev);\n@@ -579,7 +579,7 @@ find_bb_boundaries (basic_block bb)\n   if (insn == BB_END (bb))\n     return;\n \n-  if (GET_CODE (insn) == CODE_LABEL)\n+  if (LABEL_P (insn))\n     insn = NEXT_INSN (insn);\n \n   /* Scan insn chain and try to find new basic block boundaries.  */"}, {"sha": "9cccf0eb02cec2f6df50eeab992bc73d41d8a0d0", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -194,7 +194,7 @@ try_simplify_condjump (basic_block cbranch_block)\n        insn = next)\n     {\n       next = NEXT_INSN (insn);\n-      if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+      if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n \t{\n \t  if (insn == BB_END (jump_block))\n \t    {\n@@ -535,24 +535,24 @@ try_forward_edges (int mode, basic_block b)\n \t      rtx insn = (target->succ->flags & EDGE_FALLTHRU\n \t\t\t  ? BB_HEAD (target) : prev_nonnote_insn (BB_END (target)));\n \n-\t      if (GET_CODE (insn) != NOTE)\n+\t      if (!NOTE_P (insn))\n \t\tinsn = NEXT_INSN (insn);\n \n-\t      for (; insn && GET_CODE (insn) != CODE_LABEL && !INSN_P (insn);\n+\t      for (; insn && !LABEL_P (insn) && !INSN_P (insn);\n \t\t   insn = NEXT_INSN (insn))\n-\t\tif (GET_CODE (insn) == NOTE\n+\t\tif (NOTE_P (insn)\n \t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \t\t  break;\n \n-\t      if (GET_CODE (insn) == NOTE)\n+\t      if (NOTE_P (insn))\n \t\tbreak;\n \n \t      /* Do not clean up branches to just past the end of a loop\n \t\t at this time; it can mess up the loop optimizer's\n \t\t recognition of some patterns.  */\n \n \t      insn = PREV_INSN (BB_HEAD (target));\n-\t      if (insn && GET_CODE (insn) == NOTE\n+\t      if (insn && NOTE_P (insn)\n \t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \t\tbreak;\n \t    }\n@@ -690,7 +690,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n     return;\n \n   barrier = next_nonnote_insn (BB_END (a));\n-  if (GET_CODE (barrier) != BARRIER)\n+  if (!BARRIER_P (barrier))\n     abort ();\n   delete_insn (barrier);\n \n@@ -753,7 +753,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n \n   /* There had better have been a barrier there.  Delete it.  */\n   barrier = NEXT_INSN (BB_END (b));\n-  if (barrier && GET_CODE (barrier) == BARRIER)\n+  if (barrier && BARRIER_P (barrier))\n     delete_insn (barrier);\n \n   /* Move block and loop notes out of the chain so that we do not\n@@ -1000,7 +1000,7 @@ insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n      ??? We take the simple route for now and assume that if they're\n      equal, they were constructed identically.  */\n \n-  if (GET_CODE (i1) == CALL_INSN\n+  if (CALL_P (i1)\n       && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n \t\t        CALL_INSN_FUNCTION_USAGE (i2))\n \t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))\n@@ -1178,13 +1178,13 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n       while (last1 != BB_HEAD (bb1) && !INSN_P (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n \n-      if (last1 != BB_HEAD (bb1) && GET_CODE (PREV_INSN (last1)) == CODE_LABEL)\n+      if (last1 != BB_HEAD (bb1) && LABEL_P (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n \n       while (last2 != BB_HEAD (bb2) && !INSN_P (PREV_INSN (last2)))\n \tlast2 = PREV_INSN (last2);\n \n-      if (last2 != BB_HEAD (bb2) && GET_CODE (PREV_INSN (last2)) == CODE_LABEL)\n+      if (last2 != BB_HEAD (bb2) && LABEL_P (PREV_INSN (last2)))\n \tlast2 = PREV_INSN (last2);\n \n       *f1 = last1;\n@@ -1211,10 +1211,10 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n      unconditional jump, or a fake edge to exit.  */\n   if (bb1->succ && !bb1->succ->succ_next\n       && (bb1->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n-      && (GET_CODE (BB_END (bb1)) != JUMP_INSN || simplejump_p (BB_END (bb1))))\n+      && (!JUMP_P (BB_END (bb1)) || simplejump_p (BB_END (bb1))))\n     return (bb2->succ &&  !bb2->succ->succ_next\n \t    && (bb2->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)) == 0\n-\t    && (GET_CODE (BB_END (bb2)) != JUMP_INSN || simplejump_p (BB_END (bb2))));\n+\t    && (!JUMP_P (BB_END (bb2)) || simplejump_p (BB_END (bb2))));\n \n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n@@ -1642,10 +1642,10 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   /* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */\n \n   /* Skip possible basic block header.  */\n-  if (GET_CODE (newpos1) == CODE_LABEL)\n+  if (LABEL_P (newpos1))\n     newpos1 = NEXT_INSN (newpos1);\n \n-  if (GET_CODE (newpos1) == NOTE)\n+  if (NOTE_P (newpos1))\n     newpos1 = NEXT_INSN (newpos1);\n \n   redirect_from = split_block (src1, PREV_INSN (newpos1))->src;\n@@ -1835,15 +1835,15 @@ try_optimize_cfg (int mode)\n \t      if (b->pred->pred_next == NULL\n \t\t  && (b->pred->flags & EDGE_FALLTHRU)\n \t\t  && !(b->pred->flags & EDGE_COMPLEX)\n-\t\t  && GET_CODE (BB_HEAD (b)) == CODE_LABEL\n+\t\t  && LABEL_P (BB_HEAD (b))\n \t\t  /* If the previous block ends with a branch to this\n \t\t     block, we can't delete the label.  Normally this\n \t\t     is a condjump that is yet to be simplified, but\n \t\t     if CASE_DROPS_THRU, this can be a tablejump with\n \t\t     some element going to the same place as the\n \t\t     default (fallthru).  */\n \t\t  && (b->pred->src == ENTRY_BLOCK_PTR\n-\t\t      || GET_CODE (BB_END (b->pred->src)) != JUMP_INSN\n+\t\t      || !JUMP_P (BB_END (b->pred->src))\n \t\t      || ! label_is_jump_target_p (BB_HEAD (b),\n \t\t\t\t\t\t   BB_END (b->pred->src))))\n \t\t{\n@@ -1868,7 +1868,7 @@ try_optimize_cfg (int mode)\n \t      if (!(mode & CLEANUP_CFGLAYOUT)\n \t\t  && b->pred->pred_next == NULL\n \t\t  && (b->pred->flags & EDGE_FALLTHRU)\n-\t\t  && GET_CODE (BB_HEAD (b)) != CODE_LABEL\n+\t\t  && !LABEL_P (BB_HEAD (b))\n \t\t  && FORWARDER_BLOCK_P (b)\n \t\t  /* Note that forwarder_block_p true ensures that\n \t\t     there is a successor for this block.  */\n@@ -1910,7 +1910,7 @@ try_optimize_cfg (int mode)\n \t\t  else if (!(mode & CLEANUP_CFGLAYOUT)\n \t\t\t   /* If the jump insn has side effects,\n \t\t\t      we can't kill the edge.  */\n-\t\t\t   && (GET_CODE (BB_END (b)) != JUMP_INSN\n+\t\t\t   && (!JUMP_P (BB_END (b))\n \t\t\t       || (reload_completed\n \t\t\t\t   ? simplejump_p (BB_END (b))\n \t\t\t\t   : (onlyjump_p (BB_END (b))"}, {"sha": "500146268bc404b80b90614fefd3e46030eee2da", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -64,7 +64,7 @@ expand_block (basic_block bb, FILE * dump_file)\n       /* Java emits line number notes in the top of labels. \n          ??? Make this go away once line number notes are obsoleted.  */\n       BB_HEAD (bb) = NEXT_INSN (last);\n-      if (GET_CODE (BB_HEAD (bb)) == NOTE)\n+      if (NOTE_P (BB_HEAD (bb)))\n \tBB_HEAD (bb) = NEXT_INSN (BB_HEAD (bb));\n       bsi_next (&bsi);\n       note = emit_note_after (NOTE_INSN_BASIC_BLOCK, BB_HEAD (bb));\n@@ -150,7 +150,7 @@ expand_block (basic_block bb, FILE * dump_file)\n \t    expand_expr (else_exp, const0_rtx, VOIDmode, 0);\n \n \t    BB_END (bb) = last;\n-\t    if (GET_CODE (BB_END (bb)) == BARRIER)\n+\t    if (BARRIER_P (BB_END (bb)))\n \t      BB_END (bb) = PREV_INSN (BB_END (bb));\n \t    update_bb_for_insn (bb);\n \n@@ -163,7 +163,7 @@ expand_block (basic_block bb, FILE * dump_file)\n \t    new_edge = make_edge (new_bb, dest, 0);\n \t    new_edge->probability = REG_BR_PROB_BASE;\n \t    new_edge->count = new_bb->count;\n-\t    if (GET_CODE (BB_END (new_bb)) == BARRIER)\n+\t    if (BARRIER_P (BB_END (new_bb)))\n \t      BB_END (new_bb) = PREV_INSN (BB_END (new_bb));\n \t    update_bb_for_insn (new_bb);\n \n@@ -182,7 +182,7 @@ expand_block (basic_block bb, FILE * dump_file)\n           expand_expr_stmt (stmt);\n \t  for (last = NEXT_INSN (last); last; last = NEXT_INSN (last))\n \t    {\n-\t      if (GET_CODE (last) == CALL_INSN && SIBLING_CALL_P (last))\n+\t      if (CALL_P (last) && SIBLING_CALL_P (last))\n \t\t{\n \t\t  edge e;\n \t\t  int probability = 0;\n@@ -217,13 +217,13 @@ expand_block (basic_block bb, FILE * dump_file)\n \t\t     after the sibcall (to perform the function return).  These confuse the \n \t\t     find_sub_basic_blocks code, so we need to get rid of these.  */\n \t\t  last = NEXT_INSN (last);\n-\t\t  if (GET_CODE (last) != BARRIER)\n+\t\t  if (!BARRIER_P (last))\n \t\t    abort ();\n \t\t  while (NEXT_INSN (last))\n \t\t    {\n \t\t      /* For instance an sqrt builtin expander expands if with\n \t\t\t sibcall in the then and label for `else`.  */\n-\t\t      if (GET_CODE (NEXT_INSN (last)) == CODE_LABEL)\n+\t\t      if (LABEL_P (NEXT_INSN (last)))\n \t\t\tbreak;\n \t\t      delete_insn (NEXT_INSN (last));\n \t\t    }\n@@ -252,7 +252,7 @@ expand_block (basic_block bb, FILE * dump_file)\n   /* Find the the block tail.  The last insn is the block is the insn\n      before a barrier and/or table jump insn.  */\n   last = get_last_insn ();\n-  if (GET_CODE (last) == BARRIER)\n+  if (BARRIER_P (last))\n     last = PREV_INSN (last);\n   if (JUMP_TABLE_DATA_P (last))\n     last = PREV_INSN (PREV_INSN (last));\n@@ -330,7 +330,7 @@ construct_exit_block (void)\n   end = get_last_insn ();\n   if (head == end)\n     return;\n-  while (NEXT_INSN (head) && GET_CODE (NEXT_INSN (head)) == NOTE)\n+  while (NEXT_INSN (head) && NOTE_P (NEXT_INSN (head)))\n     head = NEXT_INSN (head);\n   exit_block = create_basic_block (NEXT_INSN (head), end, EXIT_BLOCK_PTR->prev_bb);\n   exit_block->frequency = EXIT_BLOCK_PTR->frequency;"}, {"sha": "457305c10874e912b61e8c4a8da4a1c313b7327b", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -119,7 +119,7 @@ skip_insns_after_block (basic_block bb)\n \n \tcase CODE_LABEL:\n \t  if (NEXT_INSN (insn)\n-\t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t      && JUMP_P (NEXT_INSN (insn))\n \t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n \t          || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n \t    {\n@@ -149,7 +149,7 @@ skip_insns_after_block (basic_block bb)\n   for (insn = last_insn; insn != BB_END (bb); insn = prev)\n     {\n       prev = PREV_INSN (insn);\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \tswitch (NOTE_LINE_NUMBER (insn))\n \t  {\n \t  case NOTE_INSN_LOOP_END:\n@@ -172,7 +172,7 @@ label_for_bb (basic_block bb)\n {\n   rtx label = BB_HEAD (bb);\n \n-  if (GET_CODE (label) != CODE_LABEL)\n+  if (!LABEL_P (label))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Emitting label for block %d\\n\", bb->index);\n@@ -195,7 +195,7 @@ record_effective_endpoints (void)\n \n   for (insn = get_insns ();\n        insn\n-       && GET_CODE (insn) == NOTE\n+       && NOTE_P (insn)\n        && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK;\n        insn = NEXT_INSN (insn))\n     continue;\n@@ -303,7 +303,7 @@ insn_locators_initialize (void)\n \tepilogue_locator = loc;\n       if (active_insn_p (insn))\n         INSN_LOCATOR (insn) = loc;\n-      else if (GET_CODE (insn) == NOTE)\n+      else if (NOTE_P (insn))\n \t{\n \t  switch (NOTE_LINE_NUMBER (insn))\n \t    {\n@@ -649,7 +649,7 @@ fixup_reorder_chain (void)\n \t  e_taken = e;\n \n       bb_end_insn = BB_END (bb);\n-      if (GET_CODE (bb_end_insn) == JUMP_INSN)\n+      if (JUMP_P (bb_end_insn))\n \t{\n \t  if (any_condjump_p (bb_end_insn))\n \t    {\n@@ -806,7 +806,7 @@ fixup_reorder_chain (void)\n \t\t\t\t\t   note);\n \t\t  NOTE_BASIC_BLOCK (new_note) = bb;\n \t\t}\n-\t      if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+\t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n \t\t  && bb->succ->crossing_edge )\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n@@ -829,7 +829,7 @@ fixup_reorder_chain (void)\n \t    fprintf (dump_file, \"duplicate of %i \",\n \t\t     bb->rbi->original->index);\n \t  else if (forwarder_block_p (bb)\n-\t\t   && GET_CODE (BB_HEAD (bb)) != CODE_LABEL)\n+\t\t   && !LABEL_P (BB_HEAD (bb)))\n \t    fprintf (dump_file, \"compensation \");\n \t  else\n \t    fprintf (dump_file, \"bb %i \", bb->index);\n@@ -875,7 +875,7 @@ update_unlikely_executed_notes (basic_block bb)\n \n   for (cur_insn = BB_HEAD (bb); cur_insn != BB_END (bb); \n        cur_insn = NEXT_INSN (cur_insn)) \n-    if (GET_CODE (cur_insn) == NOTE\n+    if (NOTE_P (cur_insn)\n \t&& NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n       NOTE_BASIC_BLOCK (cur_insn) = bb;\n }"}, {"sha": "da08e088c747d90e9da793a16e0ea686deae067e", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1256,7 +1256,7 @@ create_loop_notes (void)\n #ifdef ENABLE_CHECKING\n   /* Verify that there really are no loop notes.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE\n+    if (NOTE_P (insn)\n \t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n       abort ();\n #endif\n@@ -1297,11 +1297,11 @@ create_loop_notes (void)\n \t\t     front of the jump.  */\n \t\t  insn = PREV_INSN (BB_HEAD (first[loop->num]));\n \t\t  if (insn\n-\t\t      && GET_CODE (insn) == BARRIER)\n+\t\t      && BARRIER_P (insn))\n \t\t    insn = PREV_INSN (insn);\n \t\t  \n \t\t  if (insn\n-\t\t      && GET_CODE (insn) == JUMP_INSN\n+\t\t      && JUMP_P (insn)\n \t\t      && any_uncondjump_p (insn)\n \t\t      && onlyjump_p (insn))\n \t\t    {\n@@ -1322,7 +1322,7 @@ create_loop_notes (void)\n \t\t  /* Position the note correctly wrto barrier.  */\n \t\t  insn = BB_END (last[loop->num]);\n \t\t  if (NEXT_INSN (insn)\n-\t\t      && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n+\t\t      && BARRIER_P (NEXT_INSN (insn)))\n \t\t    insn = NEXT_INSN (insn);\n \t\t  \n \t\t  end = BB_END (last[loop->num]);"}, {"sha": "8d17d06642ab1c4618fb53387ededbdd72268fe9", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -118,7 +118,7 @@ delete_insn (rtx insn)\n   rtx note;\n   bool really_delete = true;\n \n-  if (GET_CODE (insn) == CODE_LABEL)\n+  if (LABEL_P (insn))\n     {\n       /* Some labels can't be directly removed from the INSN chain, as they\n          might be references via variables, constant pool etc.\n@@ -147,23 +147,23 @@ delete_insn (rtx insn)\n \n   /* If deleting a jump, decrement the use count of the label.  Deleting\n      the label itself should happen in the normal course of block merging.  */\n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && JUMP_LABEL (insn)\n-      && GET_CODE (JUMP_LABEL (insn)) == CODE_LABEL)\n+      && LABEL_P (JUMP_LABEL (insn)))\n     LABEL_NUSES (JUMP_LABEL (insn))--;\n \n   /* Also if deleting an insn that references a label.  */\n   else\n     {\n       while ((note = find_reg_note (insn, REG_LABEL, NULL_RTX)) != NULL_RTX\n-\t     && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n+\t     && LABEL_P (XEXP (note, 0)))\n \t{\n \t  LABEL_NUSES (XEXP (note, 0))--;\n \t  remove_note (insn, note);\n \t}\n     }\n \n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n     {\n@@ -179,7 +179,7 @@ delete_insn (rtx insn)\n \t  /* When deleting code in bulk (e.g. removing many unreachable\n \t     blocks) we can delete a label that's a target of the vector\n \t     before deleting the vector itself.  */\n-\t  if (GET_CODE (label) != NOTE)\n+\t  if (!NOTE_P (label))\n \t    LABEL_NUSES (label)--;\n \t}\n     }\n@@ -218,7 +218,7 @@ delete_insn_chain (rtx start, rtx finish)\n   while (1)\n     {\n       next = NEXT_INSN (start);\n-      if (GET_CODE (start) == NOTE && !can_delete_note_p (start))\n+      if (NOTE_P (start) && !can_delete_note_p (start))\n \t;\n       else\n \tnext = delete_insn (start);\n@@ -265,7 +265,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n \n       rtx after;\n \n-      if (GET_CODE (head) == CODE_LABEL)\n+      if (LABEL_P (head))\n \tafter = head;\n       else\n \t{\n@@ -285,7 +285,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n       if (!head && !end)\n \thead = end = bb_note\n \t  = emit_note_after (NOTE_INSN_BASIC_BLOCK, get_last_insn ());\n-      else if (GET_CODE (head) == CODE_LABEL && end)\n+      else if (LABEL_P (head) && end)\n \t{\n \t  bb_note = emit_note_after (NOTE_INSN_BASIC_BLOCK, head);\n \t  if (head == end)\n@@ -381,7 +381,7 @@ rtl_delete_block (basic_block b)\n \n   for (insn = PREV_INSN (BB_HEAD (b)); insn; insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) != NOTE)\n+      if (!NOTE_P (insn))\n \tbreak;\n       if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION\n \t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT)\n@@ -390,7 +390,7 @@ rtl_delete_block (basic_block b)\n \n   insn = BB_HEAD (b);\n \n-  if (GET_CODE (insn) == CODE_LABEL)\n+  if (LABEL_P (insn))\n     maybe_remove_eh_handler (insn);\n \n   /* Include any jump table following the basic block.  */\n@@ -400,7 +400,7 @@ rtl_delete_block (basic_block b)\n \n   /* Include any barrier that may follow the basic block.  */\n   tmp = next_nonnote_insn (end);\n-  if (tmp && GET_CODE (tmp) == BARRIER)\n+  if (tmp && BARRIER_P (tmp))\n     end = tmp;\n \n   /* Selectively delete the entire chain.  */\n@@ -436,7 +436,7 @@ free_bb_for_insn (void)\n {\n   rtx insn;\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) != BARRIER)\n+    if (!BARRIER_P (insn))\n       BLOCK_FOR_INSN (insn) = NULL;\n }\n \n@@ -456,7 +456,7 @@ update_bb_for_insn (basic_block bb)\n \n   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) != BARRIER)\n+      if (!BARRIER_P (insn))\n \tset_block_for_insn (insn, bb);\n       if (insn == BB_END (bb))\n \tbreak;\n@@ -539,7 +539,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n   int b_empty = 0;\n \n   /* If there was a CODE_LABEL beginning B, delete it.  */\n-  if (GET_CODE (b_head) == CODE_LABEL)\n+  if (LABEL_P (b_head))\n     {\n       /* Detect basic blocks with nothing but a label.  This can happen\n \t in particular at the end of a function.  */\n@@ -564,12 +564,12 @@ rtl_merge_blocks (basic_block a, basic_block b)\n     }\n \n   /* If there was a jump out of A, delete it.  */\n-  if (GET_CODE (a_end) == JUMP_INSN)\n+  if (JUMP_P (a_end))\n     {\n       rtx prev;\n \n       for (prev = PREV_INSN (a_end); ; prev = PREV_INSN (prev))\n-\tif (GET_CODE (prev) != NOTE\n+\tif (!NOTE_P (prev)\n \t    || NOTE_LINE_NUMBER (prev) == NOTE_INSN_BASIC_BLOCK\n \t    || prev == BB_HEAD (a))\n \t  break;\n@@ -592,7 +592,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n       a_end = PREV_INSN (del_first);\n     }\n-  else if (GET_CODE (NEXT_INSN (a_end)) == BARRIER)\n+  else if (BARRIER_P (NEXT_INSN (a_end)))\n     del_first = NEXT_INSN (a_end);\n \n   /* Delete everything marked above as well as crap that might be\n@@ -642,7 +642,7 @@ rtl_can_merge_blocks (basic_block a,basic_block b)\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */\n-\t  && (GET_CODE (BB_END (a)) != JUMP_INSN\n+\t  && (!JUMP_P (BB_END (a))\n \t      || (reload_completed\n \t\t  ? simplejump_p (BB_END (a)) : onlyjump_p (BB_END (a)))));\n }\n@@ -656,7 +656,7 @@ block_label (basic_block block)\n   if (block == EXIT_BLOCK_PTR)\n     return NULL_RTX;\n \n-  if (GET_CODE (BB_HEAD (block)) != CODE_LABEL)\n+  if (!LABEL_P (BB_HEAD (block)))\n     {\n       BB_HEAD (block) = emit_label_before (gen_label_rtx (), BB_HEAD (block));\n     }\n@@ -727,7 +727,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t  /* Remove barriers but keep jumptables.  */\n \t  while (insn)\n \t    {\n-\t      if (GET_CODE (insn) == BARRIER)\n+\t      if (BARRIER_P (insn))\n \t\t{\n \t\t  if (PREV_INSN (insn))\n \t\t    NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n@@ -736,7 +736,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t  if (NEXT_INSN (insn))\n \t\t    PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n \t\t}\n-\t      if (GET_CODE (insn) == CODE_LABEL)\n+\t      if (LABEL_P (insn))\n \t\tbreak;\n \t      insn = NEXT_INSN (insn);\n \t    }\n@@ -788,7 +788,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \tdelete_insn_chain (label, table);\n \n       barrier = next_nonnote_insn (BB_END (src));\n-      if (!barrier || GET_CODE (barrier) != BARRIER)\n+      if (!barrier || !BARRIER_P (barrier))\n \temit_barrier_after (BB_END (src));\n       else\n \t{\n@@ -830,7 +830,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \n   /* We don't want a block to end on a line-number note since that has\n      the potential of changing the code between -g and not -g.  */\n-  while (GET_CODE (BB_END (e->src)) == NOTE\n+  while (NOTE_P (BB_END (e->src))\n \t && NOTE_LINE_NUMBER (BB_END (e->src)) >= 0)\n     delete_insn (BB_END (e->src));\n \n@@ -853,7 +853,7 @@ last_loop_beg_note (rtx insn)\n {\n   rtx last = insn;\n \n-  for (insn = NEXT_INSN (insn); insn && GET_CODE (insn) == NOTE\n+  for (insn = NEXT_INSN (insn); insn && NOTE_P (insn)\n        && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK;\n        insn = NEXT_INSN (insn))\n     if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n@@ -875,7 +875,7 @@ redirect_branch_edge (edge e, basic_block target)\n   /* We can only redirect non-fallthru edges of jump insn.  */\n   if (e->flags & EDGE_FALLTHRU)\n     return NULL;\n-  else if (GET_CODE (insn) != JUMP_INSN)\n+  else if (!JUMP_P (insn))\n     return NULL;\n \n   /* Recognize a tablejump and adjust all matching cases.  */\n@@ -1103,15 +1103,15 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t      for (bb_note = BB_HEAD (jump_block); \n \t\t   bb_note && bb_note != NEXT_INSN (BB_END (jump_block));\n \t\t   bb_note = NEXT_INSN (bb_note))\n-\t\tif (GET_CODE (bb_note) == NOTE\n+\t\tif (NOTE_P (bb_note)\n \t\t    && NOTE_LINE_NUMBER (bb_note) == NOTE_INSN_BASIC_BLOCK)\n \t\t  break;\n \t      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n \t\t\t\t\t  bb_note);\n \t      NOTE_BASIC_BLOCK (new_note) = jump_block; \n \t      jump_block->partition = COLD_PARTITION;\n \t    }\n-\t  if (GET_CODE (BB_END (jump_block)) == JUMP_INSN\n+\t  if (JUMP_P (BB_END (jump_block))\n \t      && !any_condjump_p (BB_END (jump_block))\n \t      && jump_block->succ->crossing_edge )\n \t    REG_NOTES (BB_END (jump_block)) = gen_rtx_EXPR_LIST \n@@ -1212,7 +1212,7 @@ rtl_tidy_fallthru_edge (edge e)\n      If block B consisted only of this single jump, turn it into a deleted\n      note.  */\n   q = BB_END (b);\n-  if (GET_CODE (q) == JUMP_INSN\n+  if (JUMP_P (q)\n       && onlyjump_p (q)\n       && (any_uncondjump_p (q)\n \t  || (b->succ == e && e->succ_next == NULL)))\n@@ -1228,7 +1228,7 @@ rtl_tidy_fallthru_edge (edge e)\n \n       /* We don't want a block to end on a line-number note since that has\n \t the potential of changing the code between -g and not -g.  */\n-      while (GET_CODE (q) == NOTE && NOTE_LINE_NUMBER (q) >= 0)\n+      while (NOTE_P (q) && NOTE_LINE_NUMBER (q) >= 0)\n \tq = PREV_INSN (q);\n     }\n \n@@ -1262,7 +1262,7 @@ back_edge_of_syntactic_loop_p (basic_block bb1, basic_block bb2)\n \n   for (insn = BB_END (bb1); insn != BB_HEAD (bb2) && count >= 0;\n        insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE)\n+    if (NOTE_P (insn))\n       {\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \t  count++;\n@@ -1333,7 +1333,7 @@ rtl_split_edge (edge edge_in)\n \n   if (edge_in->dest != EXIT_BLOCK_PTR\n       && PREV_INSN (BB_HEAD (edge_in->dest))\n-      && GET_CODE (PREV_INSN (BB_HEAD (edge_in->dest))) == NOTE\n+      && NOTE_P (PREV_INSN (BB_HEAD (edge_in->dest)))\n       && (NOTE_LINE_NUMBER (PREV_INSN (BB_HEAD (edge_in->dest)))\n \t  == NOTE_INSN_LOOP_BEG)\n       && !back_edge_of_syntactic_loop_p (edge_in->dest, edge_in->src))\n@@ -1349,7 +1349,7 @@ rtl_split_edge (edge edge_in)\n     {\n       before = NEXT_INSN (BB_END (edge_in->src));\n       if (before\n-\t  && GET_CODE (before) == NOTE\n+\t  && NOTE_P (before)\n \t  && NOTE_LINE_NUMBER (before) == NOTE_INSN_LOOP_END)\n \tbefore = NEXT_INSN (before);\n       bb = create_basic_block (before, NULL, edge_in->src);\n@@ -1517,7 +1517,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n      its return value.  */\n   if (watch_calls && (e->flags & EDGE_FALLTHRU) && !e->dest->pred->pred_next\n       && e->src != ENTRY_BLOCK_PTR\n-      && GET_CODE (BB_END (e->src)) == CALL_INSN)\n+      && CALL_P (BB_END (e->src)))\n     {\n       rtx next = next_nonnote_insn (BB_END (e->src));\n \n@@ -1542,12 +1542,12 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t  /* Get the location correct wrt a code label, and \"nice\" wrt\n \t     a basic block note, and before everything else.  */\n \t  tmp = BB_HEAD (bb);\n-\t  if (GET_CODE (tmp) == CODE_LABEL)\n+\t  if (LABEL_P (tmp))\n \t    tmp = NEXT_INSN (tmp);\n \t  if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n \t    tmp = NEXT_INSN (tmp);\n \t  if (tmp \n-\t      && GET_CODE (tmp) == NOTE\n+\t      && NOTE_P (tmp)\n \t      && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n \t    tmp = NEXT_INSN (tmp);\n \t  if (tmp == BB_HEAD (bb))\n@@ -1572,9 +1572,9 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \n \t     We know this block has a single successor, so we can just emit\n \t     the queued insns before the jump.  */\n-\t  if (GET_CODE (BB_END (bb)) == JUMP_INSN)\n+\t  if (JUMP_P (BB_END (bb)))\n \t    for (before = BB_END (bb);\n-\t\t GET_CODE (PREV_INSN (before)) == NOTE\n+\t\t NOTE_P (PREV_INSN (before))\n \t\t && NOTE_LINE_NUMBER (PREV_INSN (before)) ==\n \t\t NOTE_INSN_LOOP_BEG; before = PREV_INSN (before))\n \t      ;\n@@ -1606,7 +1606,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      bb_note = NULL_RTX;\n \t      for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb));\n \t\t   cur_insn = NEXT_INSN (cur_insn))\n-\t\tif (GET_CODE (cur_insn) == NOTE\n+\t\tif (NOTE_P (cur_insn)\n \t\t    && NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_BASIC_BLOCK)\n \t\t  {\n \t\t    bb_note = cur_insn;\n@@ -1616,7 +1616,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      new_note = emit_note_after (NOTE_INSN_UNLIKELY_EXECUTED_CODE,\n \t\t\t\t\t  bb_note);\n \t      NOTE_BASIC_BLOCK (new_note) = bb;\n-\t      if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+\t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n \t\t  && bb->succ->crossing_edge )\n \t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n@@ -1655,7 +1655,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n       if (before)\n \tdelete_insn (before);\n     }\n-  else if (GET_CODE (last) == JUMP_INSN)\n+  else if (JUMP_P (last))\n     abort ();\n \n   /* Mark the basic block for find_sub_basic_blocks.  */\n@@ -1836,8 +1836,8 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n \t    }\n \n \t  if (in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB\n-\t      && GET_CODE (tmp_rtx) != NOTE\n-\t      && GET_CODE (tmp_rtx) != BARRIER)\n+\t      && !NOTE_P (tmp_rtx)\n+\t      && !BARRIER_P (tmp_rtx))\n \t    fprintf (outf, \";; Insn is not within a basic block\\n\");\n \t  else if (in_bb_p[INSN_UID (tmp_rtx)] == IN_MULTIPLE_BB)\n \t    fprintf (outf, \";; Insn is in multiple basic blocks\\n\");\n@@ -1874,7 +1874,7 @@ void\n update_br_prob_note (basic_block bb)\n {\n   rtx note;\n-  if (GET_CODE (BB_END (bb)) != JUMP_INSN)\n+  if (!JUMP_P (BB_END (bb)))\n     return;\n   note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);\n   if (!note || INTVAL (XEXP (note, 0)) == BRANCH_EDGE (bb)->probability)\n@@ -2013,7 +2013,7 @@ rtl_verify_flow_info_1 (void)\n \t  err = 1;\n \t}\n       if (n_branch\n-\t  && (GET_CODE (BB_END (bb)) != JUMP_INSN\n+\t  && (!JUMP_P (BB_END (bb))\n \t      || (n_branch > 1 && (any_uncondjump_p (BB_END (bb))\n \t\t\t\t   || any_condjump_p (BB_END (bb))))))\n \t{\n@@ -2036,14 +2036,14 @@ rtl_verify_flow_info_1 (void)\n \t  error (\"Wrong amount of branch edges after conditional jump %i\", bb->index);\n \t  err = 1;\n \t}\n-      if (n_call && GET_CODE (BB_END (bb)) != CALL_INSN)\n+      if (n_call && !CALL_P (BB_END (bb)))\n \t{\n \t  error (\"Call edges for non-call insn in bb %i\", bb->index);\n \t  err = 1;\n \t}\n       if (n_abnormal\n-\t  && (GET_CODE (BB_END (bb)) != CALL_INSN && n_call != n_abnormal)\n-\t  && (GET_CODE (BB_END (bb)) != JUMP_INSN\n+\t  && (!CALL_P (BB_END (bb)) && n_call != n_abnormal)\n+\t  && (!JUMP_P (BB_END (bb))\n \t      || any_condjump_p (BB_END (bb))\n \t      || any_uncondjump_p (BB_END (bb))))\n \t{\n@@ -2071,7 +2071,7 @@ rtl_verify_flow_info_1 (void)\n          block.  It ought to contain optional CODE_LABEL followed\n \t by NOTE_BASIC_BLOCK.  */\n       x = BB_HEAD (bb);\n-      if (GET_CODE (x) == CODE_LABEL)\n+      if (LABEL_P (x))\n \t{\n \t  if (BB_END (bb) == x)\n \t    {\n@@ -2149,10 +2149,10 @@ rtl_verify_flow_info (void)\n \t  rtx insn;\n \n \t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n-\t  for (insn = BB_END (bb); !insn || GET_CODE (insn) != BARRIER;\n+\t  for (insn = BB_END (bb); !insn || !BARRIER_P (insn);\n \t       insn = NEXT_INSN (insn))\n \t    if (!insn\n-\t\t|| (GET_CODE (insn) == NOTE\n+\t\t|| (NOTE_P (insn)\n \t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK))\n \t\t{\n \t\t  error (\"missing barrier after block %i\", bb->index);\n@@ -2175,7 +2175,7 @@ rtl_verify_flow_info (void)\n \t  else\n \t    for (insn = NEXT_INSN (BB_END (e->src)); insn != BB_HEAD (e->dest);\n \t\t insn = NEXT_INSN (insn))\n-\t      if (GET_CODE (insn) == BARRIER\n+\t      if (BARRIER_P (insn)\n #ifndef CASE_DROPS_THROUGH\n \t\t  || INSN_P (insn)\n #else\n@@ -2218,7 +2218,7 @@ rtl_verify_flow_info (void)\n \t    case CODE_LABEL:\n \t      /* An addr_vec is placed outside any basic block.  */\n \t      if (NEXT_INSN (x)\n-\t\t  && GET_CODE (NEXT_INSN (x)) == JUMP_INSN\n+\t\t  && JUMP_P (NEXT_INSN (x))\n \t\t  && (GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_DIFF_VEC\n \t\t      || GET_CODE (PATTERN (NEXT_INSN (x))) == ADDR_VEC))\n \t\tx = NEXT_INSN (x);\n@@ -2232,9 +2232,9 @@ rtl_verify_flow_info (void)\n \t}\n \n       if (INSN_P (x)\n-\t  && GET_CODE (x) == JUMP_INSN\n+\t  && JUMP_P (x)\n \t  && returnjump_p (x) && ! condjump_p (x)\n-\t  && ! (NEXT_INSN (x) && GET_CODE (NEXT_INSN (x)) == BARRIER))\n+\t  && ! (NEXT_INSN (x) && BARRIER_P (NEXT_INSN (x))))\n \t    fatal_insn (\"return not followed by barrier\", x);\n       if (curr_bb && x == BB_END (curr_bb))\n \tcurr_bb = NULL;\n@@ -2260,7 +2260,7 @@ purge_dead_edges (basic_block bb)\n   bool purged = false;\n \n   /* If this instruction cannot trap, remove REG_EH_REGION notes.  */\n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && (note = find_reg_note (insn, REG_EH_REGION, NULL)))\n     {\n       rtx eqnote;\n@@ -2282,7 +2282,7 @@ purge_dead_edges (basic_block bb)\n \t}\n       else if (e->flags & EDGE_ABNORMAL_CALL)\n \t{\n-\t  if (GET_CODE (BB_END (bb)) == CALL_INSN\n+\t  if (CALL_P (BB_END (bb))\n \t      && (! (note = find_reg_note (insn, REG_EH_REGION, NULL))\n \t\t  || INTVAL (XEXP (note, 0)) >= 0))\n \t    continue;\n@@ -2295,7 +2295,7 @@ purge_dead_edges (basic_block bb)\n       purged = true;\n     }\n \n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     {\n       rtx note;\n       edge b,f;\n@@ -2386,7 +2386,7 @@ purge_dead_edges (basic_block bb)\n \n       return purged;\n     }\n-  else if (GET_CODE (insn) == CALL_INSN && SIBLING_CALL_P (insn))\n+  else if (CALL_P (insn) && SIBLING_CALL_P (insn))\n     {\n       /* First, there should not be any EH or ABCALL edges resulting\n \t from non-local gotos and the like.  If there were, we shouldn't\n@@ -2524,7 +2524,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n   if (e->flags & EDGE_FALLTHRU)\n     {\n       /* Redirect any branch edges unified with the fallthru one.  */\n-      if (GET_CODE (BB_END (src)) == JUMP_INSN\n+      if (JUMP_P (BB_END (src))\n \t  && label_is_jump_target_p (BB_HEAD (e->dest),\n \t\t\t\t     BB_END (src)))\n \t{\n@@ -2602,7 +2602,7 @@ cfg_layout_delete_block (basic_block bb)\n       insn = bb->rbi->footer;\n       while (insn)\n \t{\n-\t  if (GET_CODE (insn) == BARRIER)\n+\t  if (BARRIER_P (insn))\n \t    {\n \t      if (PREV_INSN (insn))\n \t\tNEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n@@ -2611,7 +2611,7 @@ cfg_layout_delete_block (basic_block bb)\n \t      if (NEXT_INSN (insn))\n \t\tPREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n \t    }\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t  if (LABEL_P (insn))\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}\n@@ -2682,7 +2682,7 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n \t  && a != ENTRY_BLOCK_PTR && b != EXIT_BLOCK_PTR\n \t  /* If the jump insn has side effects,\n \t     we can't kill the edge.  */\n-\t  && (GET_CODE (BB_END (a)) != JUMP_INSN\n+\t  && (!JUMP_P (BB_END (a))\n \t      || (reload_completed\n \t\t  ? simplejump_p (BB_END (a)) : onlyjump_p (BB_END (a)))));\n }\n@@ -2697,14 +2697,14 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n #endif\n \n   /* If there was a CODE_LABEL beginning B, delete it.  */\n-  if (GET_CODE (BB_HEAD (b)) == CODE_LABEL)\n+  if (LABEL_P (BB_HEAD (b)))\n     delete_insn (BB_HEAD (b));\n \n   /* We should have fallthru edge in a, or we can do dummy redirection to get\n      it cleaned up.  */\n-  if (GET_CODE (BB_END (a)) == JUMP_INSN)\n+  if (JUMP_P (BB_END (a)))\n     try_redirect_by_replacing_jump (a->succ, b, true);\n-  if (GET_CODE (BB_END (a)) == JUMP_INSN)\n+  if (JUMP_P (BB_END (a)))\n     abort ();\n \n   /* Possible line number notes should appear in between.  */\n@@ -2805,11 +2805,11 @@ rtl_block_ends_with_call_p (basic_block bb)\n {\n   rtx insn = BB_END (bb);\n \n-  while (GET_CODE (insn) != CALL_INSN\n+  while (!CALL_P (insn)\n \t && insn != BB_HEAD (bb)\n \t && keep_with_call_p (insn))\n     insn = PREV_INSN (insn);\n-  return (GET_CODE (insn) == CALL_INSN);\n+  return (CALL_P (insn));\n }\n \n /* Return 1 if BB ends with a conditional branch, 0 otherwise.  */\n@@ -2829,7 +2829,7 @@ need_fake_edge_p (rtx insn)\n   if (!INSN_P (insn))\n     return false;\n \n-  if ((GET_CODE (insn) == CALL_INSN\n+  if ((CALL_P (insn)\n        && !SIBLING_CALL_P (insn)\n        && !find_reg_note (insn, REG_NORETURN, NULL)\n        && !find_reg_note (insn, REG_ALWAYS_RETURN, NULL)\n@@ -2930,7 +2930,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \n \t      /* Don't split the block between a call and an insn that should\n \t         remain in the same block as the call.  */\n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      if (CALL_P (insn))\n \t\twhile (split_at_insn != BB_END (bb)\n \t\t       && keep_with_call_p (NEXT_INSN (split_at_insn)))\n \t\t  split_at_insn = NEXT_INSN (split_at_insn);"}, {"sha": "97198b5df4f4f01889a3f5d7f715df9af52a47c4", "filename": "gcc/combine.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -738,7 +738,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t    INSN_UID (insn), uid_insn_cost[INSN_UID (insn)]);\n \t}\n \n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tlabel_tick++;\n     }\n \n@@ -760,7 +760,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t{\n \t  next = 0;\n \n-\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t  if (LABEL_P (insn))\n \t    label_tick++;\n \n \t  else if (INSN_P (insn))\n@@ -784,7 +784,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n \t\t  /* If the linked insn has been replaced by a note, then there\n \t\t     is no point in pursuing this chain any further.  */\n-\t\t  if (GET_CODE (link) == NOTE)\n+\t\t  if (NOTE_P (link))\n \t\t    continue;\n \n \t\t  for (nextlinks = LOG_LINKS (link);\n@@ -804,9 +804,9 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t We need this special code because data flow connections\n \t\t via CC0 do not get entered in LOG_LINKS.  */\n \n-\t      if (GET_CODE (insn) == JUMP_INSN\n+\t      if (JUMP_P (insn)\n \t\t  && (prev = prev_nonnote_insn (insn)) != 0\n-\t\t  && GET_CODE (prev) == INSN\n+\t\t  && NONJUMP_INSN_P (prev)\n \t\t  && sets_cc0_p (PATTERN (prev)))\n \t\t{\n \t\t  if ((next = try_combine (insn, prev,\n@@ -822,9 +822,9 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t}\n \n \t      /* Do the same for an insn that explicitly references CC0.  */\n-\t      if (GET_CODE (insn) == INSN\n+\t      if (NONJUMP_INSN_P (insn)\n \t\t  && (prev = prev_nonnote_insn (insn)) != 0\n-\t\t  && GET_CODE (prev) == INSN\n+\t\t  && NONJUMP_INSN_P (prev)\n \t\t  && sets_cc0_p (PATTERN (prev))\n \t\t  && GET_CODE (PATTERN (insn)) == SET\n \t\t  && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n@@ -845,11 +845,11 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t explicitly references CC0.  If so, try this insn, that insn,\n \t\t and its predecessor if it sets CC0.  */\n \t      for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t\tif (GET_CODE (XEXP (links, 0)) == INSN\n+\t\tif (NONJUMP_INSN_P (XEXP (links, 0))\n \t\t    && GET_CODE (PATTERN (XEXP (links, 0))) == SET\n \t\t    && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (XEXP (links, 0))))\n \t\t    && (prev = prev_nonnote_insn (XEXP (links, 0))) != 0\n-\t\t    && GET_CODE (prev) == INSN\n+\t\t    && NONJUMP_INSN_P (prev)\n \t\t    && sets_cc0_p (PATTERN (prev))\n \t\t    && (next = try_combine (insn, XEXP (links, 0),\n \t\t\t\t\t    prev, &new_direct_jump_p)) != 0)\n@@ -891,7 +891,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t\t    }\n \t\t}\n \n-\t      if (GET_CODE (insn) != NOTE)\n+\t      if (!NOTE_P (insn))\n \t\trecord_dead_and_set_regs (insn);\n \n \t    retry:\n@@ -1205,7 +1205,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n       /* Can't merge a function call.  */\n       || GET_CODE (src) == CALL\n       /* Don't eliminate a function call argument.  */\n-      || (GET_CODE (i3) == CALL_INSN\n+      || (CALL_P (i3)\n \t  && (find_reg_fusage (i3, USE, dest)\n \t      || (REG_P (dest)\n \t\t  && REGNO (dest) < FIRST_PSEUDO_REGISTER\n@@ -1342,7 +1342,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n #ifdef AUTO_INC_DEC\n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n     if (REG_NOTE_KIND (link) == REG_INC\n-\t&& (GET_CODE (i3) == JUMP_INSN\n+\t&& (JUMP_P (i3)\n \t    || reg_used_between_p (XEXP (link, 0), insn, i3)\n \t    || reg_overlap_mentioned_p (XEXP (link, 0), PATTERN (i3))))\n       return 0;\n@@ -1359,7 +1359,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n      but that would be much slower, and this ought to be equivalent.  */\n \n   p = prev_nonnote_insn (insn);\n-  if (p && p != pred && GET_CODE (p) == INSN && sets_cc0_p (PATTERN (p))\n+  if (p && p != pred && NONJUMP_INSN_P (p) && sets_cc0_p (PATTERN (p))\n       && ! all_adjacent)\n     return 0;\n #endif\n@@ -1688,7 +1688,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      where I2 and I3 are adjacent to avoid making difficult register\n      usage tests.  */\n \n-  if (i1 == 0 && GET_CODE (i3) == INSN && GET_CODE (PATTERN (i3)) == SET\n+  if (i1 == 0 && NONJUMP_INSN_P (i3) && GET_CODE (PATTERN (i3)) == SET\n       && REG_P (SET_SRC (PATTERN (i3)))\n       && REGNO (SET_SRC (PATTERN (i3))) >= FIRST_PSEUDO_REGISTER\n       && find_reg_note (i3, REG_DEAD, SET_SRC (PATTERN (i3)))\n@@ -2646,7 +2646,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      they are adjacent to each other or not.  */\n   {\n     rtx p = prev_nonnote_insn (i3);\n-    if (p && p != i2 && GET_CODE (p) == INSN && newi2pat\n+    if (p && p != i2 && NONJUMP_INSN_P (p) && newi2pat\n \t&& sets_cc0_p (newi2pat))\n       {\n \tundo_all ();\n@@ -2702,7 +2702,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n     INSN_CODE (i3) = insn_code_number;\n     PATTERN (i3) = newpat;\n \n-    if (GET_CODE (i3) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (i3))\n+    if (CALL_P (i3) && CALL_INSN_FUNCTION_USAGE (i3))\n       {\n \trtx call_usage = CALL_INSN_FUNCTION_USAGE (i3);\n \n@@ -2947,7 +2947,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \tmark_jump_label (PATTERN (i3), i3, 0);\n \n \tif ((temp = next_nonnote_insn (i3)) == NULL_RTX\n-\t    || GET_CODE (temp) != BARRIER)\n+\t    || !BARRIER_P (temp))\n \t  emit_barrier_after (i3);\n       }\n \n@@ -2958,7 +2958,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t*new_direct_jump_p = 1;\n \n \tif ((temp = next_nonnote_insn (undobuf.other_insn)) == NULL_RTX\n-\t    || GET_CODE (temp) != BARRIER)\n+\t    || !BARRIER_P (temp))\n \t  emit_barrier_after (undobuf.other_insn);\n       }\n \n@@ -3087,12 +3087,12 @@ find_split_point (rtx *loc, rtx insn)\n \t  if (seq\n \t      && NEXT_INSN (seq) != NULL_RTX\n \t      && NEXT_INSN (NEXT_INSN (seq)) == NULL_RTX\n-\t      && GET_CODE (seq) == INSN\n+\t      && NONJUMP_INSN_P (seq)\n \t      && GET_CODE (PATTERN (seq)) == SET\n \t      && SET_DEST (PATTERN (seq)) == reg\n \t      && ! reg_mentioned_p (reg,\n \t\t\t\t    SET_SRC (PATTERN (seq)))\n-\t      && GET_CODE (NEXT_INSN (seq)) == INSN\n+\t      && NONJUMP_INSN_P (NEXT_INSN (seq))\n \t      && GET_CODE (PATTERN (NEXT_INSN (seq))) == SET\n \t      && SET_DEST (PATTERN (NEXT_INSN (seq))) == reg\n \t      && memory_address_p (GET_MODE (x),\n@@ -10939,7 +10939,7 @@ record_dead_and_set_regs (rtx insn)\n \trecord_value_for_reg (XEXP (link, 0), insn, NULL_RTX);\n     }\n \n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n@@ -11321,7 +11321,7 @@ reg_dead_at_p (rtx reg, rtx insn)\n \n   /* Scan backwards until we find a REG_DEAD note, SET, CLOBBER, label, or\n      beginning of function.  */\n-  for (; insn && GET_CODE (insn) != CODE_LABEL && GET_CODE (insn) != BARRIER;\n+  for (; insn && !LABEL_P (insn) && !BARRIER_P (insn);\n        insn = prev_nonnote_insn (insn))\n     {\n       note_stores (PATTERN (insn), reg_dead_at_p_1, NULL);\n@@ -11740,19 +11740,19 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t  break;\n \n \tcase REG_NON_LOCAL_GOTO:\n-\t  if (GET_CODE (i3) == JUMP_INSN)\n+\t  if (JUMP_P (i3))\n \t    place = i3;\n-\t  else if (i2 && GET_CODE (i2) == JUMP_INSN)\n+\t  else if (i2 && JUMP_P (i2))\n \t    place = i2;\n \t  else\n \t    abort ();\n \t  break;\n \n \tcase REG_EH_REGION:\n \t  /* These notes must remain with the call or trapping instruction.  */\n-\t  if (GET_CODE (i3) == CALL_INSN)\n+\t  if (CALL_P (i3))\n \t    place = i3;\n-\t  else if (i2 && GET_CODE (i2) == CALL_INSN)\n+\t  else if (i2 && CALL_P (i2))\n \t    place = i2;\n \t  else if (flag_non_call_exceptions)\n \t    {\n@@ -11773,9 +11773,9 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \tcase REG_SETJMP:\n \t  /* These notes must remain with the call.  It should not be\n \t     possible for both I2 and I3 to be a call.  */\n-\t  if (GET_CODE (i3) == CALL_INSN)\n+\t  if (CALL_P (i3))\n \t    place = i3;\n-\t  else if (i2 && GET_CODE (i2) == CALL_INSN)\n+\t  else if (i2 && CALL_P (i2))\n \t    place = i2;\n \t  else\n \t    abort ();\n@@ -11883,19 +11883,19 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \n \t  /* Don't attach REG_LABEL note to a JUMP_INSN which has\n \t     JUMP_LABEL already.  Instead, decrement LABEL_NUSES.  */\n-\t  if (place && GET_CODE (place) == JUMP_INSN && JUMP_LABEL (place))\n+\t  if (place && JUMP_P (place) && JUMP_LABEL (place))\n \t    {\n \t      if (JUMP_LABEL (place) != XEXP (note, 0))\n \t\tabort ();\n-\t      if (GET_CODE (JUMP_LABEL (place)) == CODE_LABEL)\n+\t      if (LABEL_P (JUMP_LABEL (place)))\n \t\tLABEL_NUSES (JUMP_LABEL (place))--;\n \t      place = 0;\n \t    }\n-\t  if (place2 && GET_CODE (place2) == JUMP_INSN && JUMP_LABEL (place2))\n+\t  if (place2 && JUMP_P (place2) && JUMP_LABEL (place2))\n \t    {\n \t      if (JUMP_LABEL (place2) != XEXP (note, 0))\n \t\tabort ();\n-\t      if (GET_CODE (JUMP_LABEL (place2)) == CODE_LABEL)\n+\t      if (LABEL_P (JUMP_LABEL (place2)))\n \t\tLABEL_NUSES (JUMP_LABEL (place2))--;\n \t      place2 = 0;\n \t    }\n@@ -11912,7 +11912,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t  /* If the insn previously containing this note still exists,\n \t     put it back where it was.  Otherwise move it to the previous\n \t     insn.  Adjust the corresponding REG_LIBCALL note.  */\n-\t  if (GET_CODE (from_insn) != NOTE)\n+\t  if (!NOTE_P (from_insn))\n \t    place = from_insn;\n \t  else\n \t    {\n@@ -11932,7 +11932,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \n \tcase REG_LIBCALL:\n \t  /* This is handled similarly to REG_RETVAL.  */\n-\t  if (GET_CODE (from_insn) != NOTE)\n+\t  if (!NOTE_P (from_insn))\n \t    place = from_insn;\n \t  else\n \t    {\n@@ -11966,7 +11966,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t     use of A and put the death note there.  */\n \n \t  if (from_insn\n-\t      && GET_CODE (from_insn) == CALL_INSN\n+\t      && CALL_P (from_insn)\n \t      && find_reg_fusage (from_insn, USE, XEXP (note, 0)))\n \t    place = from_insn;\n \t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (i3)))\n@@ -12074,7 +12074,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t\t}\n \t\t    }\n \t\t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (tem))\n-\t\t\t   || (GET_CODE (tem) == CALL_INSN\n+\t\t\t   || (CALL_P (tem)\n \t\t\t       && find_reg_fusage (tem, USE, XEXP (note, 0))))\n \t\t    {\n \t\t      place = tem;\n@@ -12281,7 +12281,7 @@ distribute_links (rtx links)\n \t replace I3, I2, and I1 by I3 and I2.  But in that case the\n \t destination of I2 also remains unchanged.  */\n \n-      if (GET_CODE (XEXP (link, 0)) == NOTE\n+      if (NOTE_P (XEXP (link, 0))\n \t  || (set = single_set (XEXP (link, 0))) == 0)\n \tcontinue;\n \n@@ -12310,7 +12310,7 @@ distribute_links (rtx links)\n \t      place = insn;\n \t    break;\n \t  }\n-\telse if (GET_CODE (insn) == CALL_INSN\n+\telse if (CALL_P (insn)\n \t\t && find_reg_fusage (insn, USE, reg))\n \t  {\n \t    place = insn;\n@@ -12378,7 +12378,7 @@ static int\n insn_cuid (rtx insn)\n {\n   while (insn != 0 && INSN_UID (insn) > max_uid_cuid\n-\t && GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE)\n+\t && NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE)\n     insn = NEXT_INSN (insn);\n \n   if (INSN_UID (insn) > max_uid_cuid)"}, {"sha": "3d08ff0777c01b5df61000ea82fc7ee88321087d", "filename": "gcc/cse.c", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -3486,7 +3486,7 @@ fold_rtx (rtx x, rtx insn)\n \t    rtx label = XEXP (base, 0);\n \t    rtx table_insn = NEXT_INSN (label);\n \n-\t    if (table_insn && GET_CODE (table_insn) == JUMP_INSN\n+\t    if (table_insn && JUMP_P (table_insn)\n \t\t&& GET_CODE (PATTERN (table_insn)) == ADDR_VEC)\n \t      {\n \t\trtx table = PATTERN (table_insn);\n@@ -3497,7 +3497,7 @@ fold_rtx (rtx x, rtx insn)\n \t\t  return XVECEXP (table, 0,\n \t\t\t\t  offset / GET_MODE_SIZE (GET_MODE (table)));\n \t      }\n-\t    if (table_insn && GET_CODE (table_insn) == JUMP_INSN\n+\t    if (table_insn && JUMP_P (table_insn)\n \t\t&& GET_CODE (PATTERN (table_insn)) == ADDR_DIFF_VEC)\n \t      {\n \t\trtx table = PATTERN (table_insn);\n@@ -4589,7 +4589,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n      Also determine whether there is a CLOBBER that invalidates\n      all memory references, or all references at varying addresses.  */\n \n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       for (tem = CALL_INSN_FUNCTION_USAGE (insn); tem; tem = XEXP (tem, 1))\n \t{\n@@ -5597,7 +5597,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t{\n \t  /* Now emit a BARRIER after the unconditional jump.  */\n \t  if (NEXT_INSN (insn) == 0\n-\t      || GET_CODE (NEXT_INSN (insn)) != BARRIER)\n+\t      || !BARRIER_P (NEXT_INSN (insn)))\n \t    emit_barrier_after (insn);\n \n \t  /* We reemit the jump in as many cases as possible just in\n@@ -5628,7 +5628,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n \t      /* Now emit a BARRIER after the unconditional jump.  */\n \t      if (NEXT_INSN (insn) == 0\n-\t\t  || GET_CODE (NEXT_INSN (insn)) != BARRIER)\n+\t\t  || !BARRIER_P (NEXT_INSN (insn)))\n \t\temit_barrier_after (insn);\n \t    }\n \t  else\n@@ -5796,7 +5796,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n   /* Some registers are invalidated by subroutine calls.  Memory is\n      invalidated by non-constant calls.  */\n \n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       if (! CONST_OR_PURE_CALL_P (insn))\n \tinvalidate_memory ();\n@@ -5834,7 +5834,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n       }\n \n   /* A volatile ASM invalidates everything.  */\n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n       && MEM_VOLATILE_P (PATTERN (insn)))\n     flush_hash_table ();\n@@ -6101,7 +6101,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t    {\n \t      prev = PREV_INSN (prev);\n \t    }\n-\t  while (prev && GET_CODE (prev) == NOTE\n+\t  while (prev && NOTE_P (prev)\n \t\t && NOTE_LINE_NUMBER (prev) != NOTE_INSN_BASIC_BLOCK);\n \n \t  /* Do not swap the registers around if the previous instruction\n@@ -6116,7 +6116,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t     note.  We cannot do that because REG_EQUIV may provide an\n \t     uninitialized stack slot when REG_PARM_STACK_SPACE is used.  */\n \n-\t  if (prev != 0 && GET_CODE (prev) == INSN\n+\t  if (prev != 0 && NONJUMP_INSN_P (prev)\n \t      && GET_CODE (PATTERN (prev)) == SET\n \t      && SET_DEST (PATTERN (prev)) == SET_SRC (sets[0].rtl)\n \t      && ! find_reg_note (prev, REG_EQUIV, NULL_RTX))\n@@ -6147,7 +6147,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n      the condition being tested.  */\n \n   last_jump_equiv_class = 0;\n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && n_sets == 1 && GET_CODE (x) == SET\n       && GET_CODE (SET_SRC (x)) == IF_THEN_ELSE)\n     record_jump_equiv (insn, 0);\n@@ -6156,7 +6156,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n   /* If the previous insn set CC0 and this insn no longer references CC0,\n      delete the previous insn.  Here we use the fact that nothing expects CC0\n      to be valid over an insn, which is true until the final pass.  */\n-  if (prev_insn && GET_CODE (prev_insn) == INSN\n+  if (prev_insn && NONJUMP_INSN_P (prev_insn)\n       && (tem = single_set (prev_insn)) != 0\n       && SET_DEST (tem) == cc0_rtx\n       && ! reg_mentioned_p (cc0_rtx, x))\n@@ -6366,12 +6366,12 @@ cse_around_loop (rtx loop_start)\n   /* If the jump at the end of the loop doesn't go to the start, we don't\n      do anything.  */\n   for (insn = PREV_INSN (loop_start);\n-       insn && (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) >= 0);\n+       insn && (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) >= 0);\n        insn = PREV_INSN (insn))\n     ;\n \n   if (insn == 0\n-      || GET_CODE (insn) != NOTE\n+      || !NOTE_P (insn)\n       || NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG)\n     return;\n \n@@ -6405,9 +6405,9 @@ cse_around_loop (rtx loop_start)\n      accesses by not processing any instructions created after cse started.  */\n \n   for (insn = NEXT_INSN (loop_start);\n-       GET_CODE (insn) != CALL_INSN && GET_CODE (insn) != CODE_LABEL\n+       !CALL_P (insn) && !LABEL_P (insn)\n        && INSN_UID (insn) < max_insn_uid\n-       && ! (GET_CODE (insn) == NOTE\n+       && ! (NOTE_P (insn)\n \t     && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END);\n        insn = NEXT_INSN (insn))\n     {\n@@ -6466,13 +6466,13 @@ invalidate_skipped_block (rtx start)\n {\n   rtx insn;\n \n-  for (insn = start; insn && GET_CODE (insn) != CODE_LABEL;\n+  for (insn = start; insn && !LABEL_P (insn);\n        insn = NEXT_INSN (insn))\n     {\n       if (! INSN_P (insn))\n \tcontinue;\n \n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  if (! CONST_OR_PURE_CALL_P (insn))\n \t    invalidate_memory ();\n@@ -6547,8 +6547,8 @@ cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n \t\t a label or CALL_INSN.  */\n \n \t      for (p = prev_nonnote_insn (loop_start);\n-\t\t   p && GET_CODE (p) != CALL_INSN\n-\t\t   && GET_CODE (p) != CODE_LABEL;\n+\t\t   p && !CALL_P (p)\n+\t\t   && !LABEL_P (p);\n \t\t   p = prev_nonnote_insn  (p))\n \t\tif ((set = single_set (p)) != 0\n \t\t    && REG_P (SET_DEST (set))\n@@ -6676,7 +6676,7 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n     follow_jumps = skip_blocks = 0;\n \n   /* Scan to end of this basic block.  */\n-  while (p && GET_CODE (p) != CODE_LABEL)\n+  while (p && !LABEL_P (p))\n     {\n       /* Don't cse out the end of a loop.  This makes a difference\n \t only for the unusual loops that always execute at least once;\n@@ -6691,22 +6691,22 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n \t If we are running after loop.c has finished, we can ignore\n \t the NOTE_INSN_LOOP_END.  */\n \n-      if (! after_loop && GET_CODE (p) == NOTE\n+      if (! after_loop && NOTE_P (p)\n \t  && NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)\n \tbreak;\n \n       /* Don't cse over a call to setjmp; on some machines (eg VAX)\n \t the regs restored by the longjmp come from\n \t a later time than the setjmp.  */\n-      if (PREV_INSN (p) && GET_CODE (PREV_INSN (p)) == CALL_INSN\n+      if (PREV_INSN (p) && CALL_P (PREV_INSN (p))\n \t  && find_reg_note (PREV_INSN (p), REG_SETJMP, NULL))\n \tbreak;\n \n       /* A PARALLEL can have lots of SETs in it,\n \t especially if it is really an ASM_OPERANDS.  */\n       if (INSN_P (p) && GET_CODE (PATTERN (p)) == PARALLEL)\n \tnsets += XVECLEN (PATTERN (p), 0);\n-      else if (GET_CODE (p) != NOTE)\n+      else if (!NOTE_P (p))\n \tnsets += 1;\n \n       /* Ignore insns made by CSE; they cannot affect the boundaries of\n@@ -6739,24 +6739,24 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n \t registers set in the block when following the jump.  */\n \n       else if ((follow_jumps || skip_blocks) && path_size < PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH) - 1\n-\t       && GET_CODE (p) == JUMP_INSN\n+\t       && JUMP_P (p)\n \t       && GET_CODE (PATTERN (p)) == SET\n \t       && GET_CODE (SET_SRC (PATTERN (p))) == IF_THEN_ELSE\n \t       && JUMP_LABEL (p) != 0\n \t       && LABEL_NUSES (JUMP_LABEL (p)) == 1\n \t       && NEXT_INSN (JUMP_LABEL (p)) != 0)\n \t{\n \t  for (q = PREV_INSN (JUMP_LABEL (p)); q; q = PREV_INSN (q))\n-\t    if ((GET_CODE (q) != NOTE\n+\t    if ((!NOTE_P (q)\n \t\t || NOTE_LINE_NUMBER (q) == NOTE_INSN_LOOP_END\n-\t\t || (PREV_INSN (q) && GET_CODE (PREV_INSN (q)) == CALL_INSN\n+\t\t || (PREV_INSN (q) && CALL_P (PREV_INSN (q))\n \t\t     && find_reg_note (PREV_INSN (q), REG_SETJMP, NULL)))\n-\t\t&& (GET_CODE (q) != CODE_LABEL || LABEL_NUSES (q) != 0))\n+\t\t&& (!LABEL_P (q) || LABEL_NUSES (q) != 0))\n \t      break;\n \n \t  /* If we ran into a BARRIER, this code is an extension of the\n \t     basic block when the branch is taken.  */\n-\t  if (follow_jumps && q != 0 && GET_CODE (q) == BARRIER)\n+\t  if (follow_jumps && q != 0 && BARRIER_P (q))\n \t    {\n \t      /* Don't allow ourself to keep walking around an\n \t\t always-executed loop.  */\n@@ -6788,7 +6788,7 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n \t      PUT_MODE (NEXT_INSN (p), QImode);\n \t    }\n \t  /* Detect a branch around a block of code.  */\n-\t  else if (skip_blocks && q != 0 && GET_CODE (q) != CODE_LABEL)\n+\t  else if (skip_blocks && q != 0 && !LABEL_P (q))\n \t    {\n \t      rtx tmp;\n \n@@ -6808,7 +6808,7 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n \t      /* This is no_labels_between_p (p, q) with an added check for\n \t\t reaching the end of a function (in case Q precedes P).  */\n \t      for (tmp = NEXT_INSN (p); tmp && tmp != q; tmp = NEXT_INSN (tmp))\n-\t\tif (GET_CODE (tmp) == CODE_LABEL)\n+\t\tif (LABEL_P (tmp))\n \t\t  break;\n \n \t      if (tmp == q)\n@@ -6907,7 +6907,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n \n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) != NOTE\n+      if (!NOTE_P (insn)\n \t  || NOTE_LINE_NUMBER (insn) < 0)\n \tINSN_CUID (insn) = ++i;\n       else\n@@ -7024,7 +7024,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n   new_basic_block ();\n \n   /* TO might be a label.  If so, protect it from being deleted.  */\n-  if (to != 0 && GET_CODE (to) == CODE_LABEL)\n+  if (to != 0 && LABEL_P (to))\n     ++LABEL_NUSES (to);\n \n   for (insn = from; insn != to; insn = NEXT_INSN (insn))\n@@ -7115,7 +7115,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n \t    \n \t  /* If we haven't already found an insn where we added a LABEL_REF,\n \t     check this one.  */\n-\t  if (GET_CODE (insn) == INSN && ! recorded_label_ref\n+\t  if (NONJUMP_INSN_P (insn) && ! recorded_label_ref\n \t      && for_each_rtx (&PATTERN (insn), check_for_label_ref,\n \t\t\t       (void *) insn))\n \t    recorded_label_ref = 1;\n@@ -7155,7 +7155,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n \t want to count the use in that jump.  */\n \n       if (to != 0 && NEXT_INSN (insn) == to\n-\t  && GET_CODE (to) == CODE_LABEL && --LABEL_NUSES (to) == to_usage)\n+\t  && LABEL_P (to) && --LABEL_NUSES (to) == to_usage)\n \t{\n \t  struct cse_basic_block_data val;\n \t  rtx prev;\n@@ -7172,7 +7172,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n \t  /* If TO was preceded by a BARRIER we are done with this block\n \t     because it has no continuation.  */\n \t  prev = prev_nonnote_insn (to);\n-\t  if (prev && GET_CODE (prev) == BARRIER)\n+\t  if (prev && BARRIER_P (prev))\n \t    {\n \t      free (qty_table + max_reg);\n \t      return insn;\n@@ -7199,7 +7199,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n \t  to = val.last;\n \n \t  /* Prevent TO from being deleted if it is a label.  */\n-\t  if (to != 0 && GET_CODE (to) == CODE_LABEL)\n+\t  if (to != 0 && LABEL_P (to))\n \t    ++LABEL_NUSES (to);\n \n \t  /* Back up so we process the first insn in the extension.  */\n@@ -7219,8 +7219,8 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n   if ((cse_jumps_altered == 0\n        || (flag_cse_follow_jumps == 0 && flag_cse_skip_blocks == 0))\n       && around_loop && to != 0\n-      && GET_CODE (to) == NOTE && NOTE_LINE_NUMBER (to) == NOTE_INSN_LOOP_END\n-      && GET_CODE (insn) == JUMP_INSN\n+      && NOTE_P (to) && NOTE_LINE_NUMBER (to) == NOTE_INSN_LOOP_END\n+      && JUMP_P (insn)\n       && JUMP_LABEL (insn) != 0\n       && LABEL_NUSES (JUMP_LABEL (insn)) == 1)\n     cse_around_loop (JUMP_LABEL (insn));\n@@ -7830,7 +7830,7 @@ cse_condition_code_reg (void)\n \t to optimize.  */\n \n       last_insn = BB_END (bb);\n-      if (GET_CODE (last_insn) != JUMP_INSN)\n+      if (!JUMP_P (last_insn))\n \tcontinue;\n \n       if (reg_referenced_p (cc_reg_1, PATTERN (last_insn)))"}, {"sha": "6fd43177ecb7755cfdca33193e628f5005953d54", "filename": "gcc/cselib.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1341,10 +1341,10 @@ cselib_process_insn (rtx insn)\n   cselib_current_insn = insn;\n \n   /* Forget everything at a CODE_LABEL, a volatile asm, or a setjmp.  */\n-  if (GET_CODE (insn) == CODE_LABEL\n-      || (GET_CODE (insn) == CALL_INSN\n+  if (LABEL_P (insn)\n+      || (CALL_P (insn)\n \t  && find_reg_note (insn, REG_SETJMP, NULL))\n-      || (GET_CODE (insn) == INSN\n+      || (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n \t  && MEM_VOLATILE_P (PATTERN (insn))))\n     {\n@@ -1361,7 +1361,7 @@ cselib_process_insn (rtx insn)\n   /* If this is a call instruction, forget anything stored in a\n      call clobbered register, or, if this is not a const call, in\n      memory.  */\n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (call_used_regs[i])\n@@ -1384,7 +1384,7 @@ cselib_process_insn (rtx insn)\n \n   /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n      after we have processed the insn.  */\n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n       if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n \tcselib_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX, NULL);"}, {"sha": "34a5971b5a6544d33685cd990daa7f18e10f6067", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -477,12 +477,12 @@ create_ddg (basic_block bb, struct df *df, int closing_branch_deps)\n     {\n       if (! INSN_P (insn))\n \t{\n-\t  if (! first_note && GET_CODE (insn) == NOTE\n+\t  if (! first_note && NOTE_P (insn)\n \t      && NOTE_LINE_NUMBER (insn) !=  NOTE_INSN_BASIC_BLOCK)\n \t    first_note = insn;\n \t  continue;\n \t}\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \t{\n \t  if (g->closing_branch)\n \t    abort (); /* Found two branches in DDG.  */"}, {"sha": "cf3889dc0b0c45c114f2f5ce0e932a084a32f924", "filename": "gcc/df.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1168,7 +1168,7 @@ df_insn_refs_record (struct df *df, basic_block bb, rtx insn)\n \t      }\n \t  }\n \n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  rtx note;\n \t  rtx x;\n@@ -1204,7 +1204,7 @@ df_insn_refs_record (struct df *df, basic_block bb, rtx insn)\n       df_uses_record (df, &PATTERN (insn),\n \t\t      DF_REF_REG_USE, bb, insn, 0);\n \n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  rtx note;\n \n@@ -1654,7 +1654,7 @@ df_bb_rd_local_compute (struct df *df, basic_block bb, bitmap call_killed_defs)\n \t  bitmap_set_bit (seen, regno);\n \t}\n \n-      if (GET_CODE (insn) == CALL_INSN && (df->flags & DF_HARD_REGS))\n+      if (CALL_P (insn) && (df->flags & DF_HARD_REGS))\n \t{\n \t  bitmap_operation (bb_info->rd_kill, bb_info->rd_kill,\n \t\t\t    call_killed_defs, BITMAP_IOR);\n@@ -2911,9 +2911,9 @@ df_insns_modify (struct df *df, basic_block bb, rtx first_insn, rtx last_insn)\n       /* A non-const call should not have slipped through the net.  If\n \t it does, we need to create a new basic block.  Ouch.  The\n \t same applies for a label.  */\n-      if ((GET_CODE (insn) == CALL_INSN\n+      if ((CALL_P (insn)\n \t   && ! CONST_OR_PURE_CALL_P (insn))\n-\t  || GET_CODE (insn) == CODE_LABEL)\n+\t  || LABEL_P (insn))\n \tabort ();\n \n       uid = INSN_UID (insn);"}, {"sha": "109c8d0e66e6c5a5e0a52a68c165450f602f69a2", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1066,7 +1066,7 @@ dwarf2out_stack_adjust (rtx insn)\n   if (prologue_epilogue_contains (insn) || sibcall_epilogue_contains (insn))\n     return;\n \n-  if (!flag_asynchronous_unwind_tables && GET_CODE (insn) == CALL_INSN)\n+  if (!flag_asynchronous_unwind_tables && CALL_P (insn))\n     {\n       /* Extract the size of the args from the CALL rtx itself.  */\n       insn = PATTERN (insn);\n@@ -1086,7 +1086,7 @@ dwarf2out_stack_adjust (rtx insn)\n   else if (!flag_asynchronous_unwind_tables && cfa.reg != STACK_POINTER_REGNUM)\n     return;\n \n-  if (GET_CODE (insn) == BARRIER)\n+  if (BARRIER_P (insn))\n     {\n       /* When we see a BARRIER, we know to reset args_size to 0.  Usually\n \t the compiler will have already emitted a stack adjustment, but\n@@ -1814,7 +1814,7 @@ dwarf2out_frame_debug (rtx insn)\n       return;\n     }\n \n-  if (GET_CODE (insn) != INSN || clobbers_queued_reg_save (insn))\n+  if (!NONJUMP_INSN_P (insn) || clobbers_queued_reg_save (insn))\n     flush_queued_reg_saves ();\n \n   if (! RTX_FRAME_RELATED_P (insn))\n@@ -11592,8 +11592,8 @@ gen_label_die (tree decl, dw_die_ref context_die)\n \t eliminated because of various optimizations.  We still emit them\n \t here so that it is possible to put breakpoints on them.  */\n       if (insn\n-\t  && (GET_CODE (insn) == CODE_LABEL\n-\t      || ((GET_CODE (insn) == NOTE\n+\t  && (LABEL_P (insn)\n+\t      || ((NOTE_P (insn)\n \t           && NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL))))\n \t{\n \t  /* When optimization is enabled (via -O) some parts of the compiler\n@@ -13119,7 +13119,7 @@ dwarf2out_var_location (rtx loc_note)\n      last time.  */\n   if (last_insn != NULL_RTX\n       && last_insn == prev_insn\n-      && GET_CODE (prev_insn) == NOTE\n+      && NOTE_P (prev_insn)\n       && NOTE_LINE_NUMBER (prev_insn) == NOTE_INSN_VAR_LOCATION)\n     {\n       newloc->label = last_label;"}, {"sha": "abc16d5bec572322edd60a53cd2782aa7fd92a90", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -2863,7 +2863,7 @@ get_first_nonnote_insn (void)\n   while (insn)\n     {\n       insn = next_insn (insn);\n-      if (insn == 0 || GET_CODE (insn) != NOTE)\n+      if (insn == 0 || !NOTE_P (insn))\n \tbreak;\n     }\n \n@@ -2881,7 +2881,7 @@ get_last_nonnote_insn (void)\n   while (insn)\n     {\n       insn = previous_insn (insn);\n-      if (insn == 0 || GET_CODE (insn) != NOTE)\n+      if (insn == 0 || !NOTE_P (insn))\n \tbreak;\n     }\n \n@@ -2932,7 +2932,7 @@ next_insn (rtx insn)\n   if (insn)\n     {\n       insn = NEXT_INSN (insn);\n-      if (insn && GET_CODE (insn) == INSN\n+      if (insn && NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \tinsn = XVECEXP (PATTERN (insn), 0, 0);\n     }\n@@ -2949,7 +2949,7 @@ previous_insn (rtx insn)\n   if (insn)\n     {\n       insn = PREV_INSN (insn);\n-      if (insn && GET_CODE (insn) == INSN\n+      if (insn && NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \tinsn = XVECEXP (PATTERN (insn), 0, XVECLEN (PATTERN (insn), 0) - 1);\n     }\n@@ -2966,7 +2966,7 @@ next_nonnote_insn (rtx insn)\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n-      if (insn == 0 || GET_CODE (insn) != NOTE)\n+      if (insn == 0 || !NOTE_P (insn))\n \tbreak;\n     }\n \n@@ -2982,7 +2982,7 @@ prev_nonnote_insn (rtx insn)\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n-      if (insn == 0 || GET_CODE (insn) != NOTE)\n+      if (insn == 0 || !NOTE_P (insn))\n \tbreak;\n     }\n \n@@ -3032,7 +3032,7 @@ last_call_insn (void)\n   rtx insn;\n \n   for (insn = get_last_insn ();\n-       insn && GET_CODE (insn) != CALL_INSN;\n+       insn && !CALL_P (insn);\n        insn = PREV_INSN (insn))\n     ;\n \n@@ -3046,8 +3046,8 @@ last_call_insn (void)\n int\n active_insn_p (rtx insn)\n {\n-  return (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n-\t  || (GET_CODE (insn) == INSN\n+  return (CALL_P (insn) || JUMP_P (insn)\n+\t  || (NONJUMP_INSN_P (insn)\n \t      && (! reload_completed\n \t\t  || (GET_CODE (PATTERN (insn)) != USE\n \t\t      && GET_CODE (PATTERN (insn)) != CLOBBER))));\n@@ -3091,7 +3091,7 @@ next_label (rtx insn)\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n-      if (insn == 0 || GET_CODE (insn) == CODE_LABEL)\n+      if (insn == 0 || LABEL_P (insn))\n \tbreak;\n     }\n \n@@ -3106,7 +3106,7 @@ prev_label (rtx insn)\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n-      if (insn == 0 || GET_CODE (insn) == CODE_LABEL)\n+      if (insn == 0 || LABEL_P (insn))\n \tbreak;\n     }\n \n@@ -3137,7 +3137,7 @@ link_cc0_insns (rtx insn)\n {\n   rtx user = next_nonnote_insn (insn);\n \n-  if (GET_CODE (user) == INSN && GET_CODE (PATTERN (user)) == SEQUENCE)\n+  if (NONJUMP_INSN_P (user) && GET_CODE (PATTERN (user)) == SEQUENCE)\n     user = XVECEXP (PATTERN (user), 0, 0);\n \n   REG_NOTES (user) = gen_rtx_INSN_LIST (REG_CC_SETTER, insn,\n@@ -3163,7 +3163,7 @@ next_cc0_user (rtx insn)\n     return XEXP (note, 0);\n \n   insn = next_nonnote_insn (insn);\n-  if (insn && GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+  if (insn && NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     insn = XVECEXP (PATTERN (insn), 0, 0);\n \n   if (insn && INSN_P (insn) && reg_mentioned_p (cc0_rtx, PATTERN (insn)))\n@@ -3248,7 +3248,7 @@ try_split (rtx pat, rtx trial, int last)\n \n   /* If we are splitting a JUMP_INSN, it might be followed by a BARRIER.\n      We may need to handle this specially.  */\n-  if (after && GET_CODE (after) == BARRIER)\n+  if (after && BARRIER_P (after))\n     {\n       has_barrier = 1;\n       after = NEXT_INSN (after);\n@@ -3273,7 +3273,7 @@ try_split (rtx pat, rtx trial, int last)\n   /* Mark labels.  */\n   for (insn = insn_last; insn ; insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \t{\n \t  mark_jump_label (PATTERN (insn), insn, 0);\n \t  njumps++;\n@@ -3297,10 +3297,10 @@ try_split (rtx pat, rtx trial, int last)\n \n   /* If we are splitting a CALL_INSN, look for the CALL_INSN\n      in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */\n-  if (GET_CODE (trial) == CALL_INSN)\n+  if (CALL_P (trial))\n     {\n       for (insn = insn_last; insn ; insn = PREV_INSN (insn))\n-\tif (GET_CODE (insn) == CALL_INSN)\n+\tif (CALL_P (insn))\n \t  {\n \t    rtx *p = &CALL_INSN_FUNCTION_USAGE (insn);\n \t    while (*p)\n@@ -3319,7 +3319,7 @@ try_split (rtx pat, rtx trial, int last)\n \t  insn = insn_last;\n \t  while (insn != NULL_RTX)\n \t    {\n-\t      if (GET_CODE (insn) == CALL_INSN\n+\t      if (CALL_P (insn)\n \t\t  || (flag_non_call_exceptions\n \t\t      && may_trap_p (PATTERN (insn))))\n \t\tREG_NOTES (insn)\n@@ -3336,7 +3336,7 @@ try_split (rtx pat, rtx trial, int last)\n \t  insn = insn_last;\n \t  while (insn != NULL_RTX)\n \t    {\n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      if (CALL_P (insn))\n \t\tREG_NOTES (insn)\n \t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n \t\t\t\t       XEXP (note, 0),\n@@ -3349,7 +3349,7 @@ try_split (rtx pat, rtx trial, int last)\n \t  insn = insn_last;\n \t  while (insn != NULL_RTX)\n \t    {\n-\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t      if (JUMP_P (insn))\n \t\tREG_NOTES (insn)\n \t\t  = gen_rtx_EXPR_LIST (REG_NOTE_KIND (note),\n \t\t\t\t       XEXP (note, 0),\n@@ -3365,12 +3365,12 @@ try_split (rtx pat, rtx trial, int last)\n \n   /* If there are LABELS inside the split insns increment the\n      usage count so we don't delete the label.  */\n-  if (GET_CODE (trial) == INSN)\n+  if (NONJUMP_INSN_P (trial))\n     {\n       insn = insn_last;\n       while (insn != NULL_RTX)\n \t{\n-\t  if (GET_CODE (insn) == INSN)\n+\t  if (NONJUMP_INSN_P (insn))\n \t    mark_label_nuses (PATTERN (insn));\n \n \t  insn = PREV_INSN (insn);\n@@ -3512,7 +3512,7 @@ add_insn_after (rtx insn, rtx after)\n   if (next)\n     {\n       PREV_INSN (next) = insn;\n-      if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == SEQUENCE)\n+      if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n \tPREV_INSN (XVECEXP (PATTERN (next), 0, 0)) = insn;\n     }\n   else if (last_insn == after)\n@@ -3532,8 +3532,8 @@ add_insn_after (rtx insn, rtx after)\n \tabort ();\n     }\n \n-  if (GET_CODE (after) != BARRIER\n-      && GET_CODE (insn) != BARRIER\n+  if (!BARRIER_P (after)\n+      && !BARRIER_P (insn)\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       set_block_for_insn (insn, bb);\n@@ -3543,14 +3543,14 @@ add_insn_after (rtx insn, rtx after)\n \t either NOTE or LABEL.  */\n       if (BB_END (bb) == after\n \t  /* Avoid clobbering of structure when creating new BB.  */\n-\t  && GET_CODE (insn) != BARRIER\n-\t  && (GET_CODE (insn) != NOTE\n+\t  && !BARRIER_P (insn)\n+\t  && (!NOTE_P (insn)\n \t      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n \tBB_END (bb) = insn;\n     }\n \n   NEXT_INSN (after) = insn;\n-  if (GET_CODE (after) == INSN && GET_CODE (PATTERN (after)) == SEQUENCE)\n+  if (NONJUMP_INSN_P (after) && GET_CODE (PATTERN (after)) == SEQUENCE)\n     {\n       rtx sequence = PATTERN (after);\n       NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = insn;\n@@ -3577,7 +3577,7 @@ add_insn_before (rtx insn, rtx before)\n   if (prev)\n     {\n       NEXT_INSN (prev) = insn;\n-      if (GET_CODE (prev) == INSN && GET_CODE (PATTERN (prev)) == SEQUENCE)\n+      if (NONJUMP_INSN_P (prev) && GET_CODE (PATTERN (prev)) == SEQUENCE)\n \t{\n \t  rtx sequence = PATTERN (prev);\n \t  NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = insn;\n@@ -3600,8 +3600,8 @@ add_insn_before (rtx insn, rtx before)\n \tabort ();\n     }\n \n-  if (GET_CODE (before) != BARRIER\n-      && GET_CODE (insn) != BARRIER\n+  if (!BARRIER_P (before)\n+      && !BARRIER_P (insn)\n       && (bb = BLOCK_FOR_INSN (before)))\n     {\n       set_block_for_insn (insn, bb);\n@@ -3611,14 +3611,14 @@ add_insn_before (rtx insn, rtx before)\n \t either NOTE or LABEl.  */\n       if (BB_HEAD (bb) == insn\n \t  /* Avoid clobbering of structure when creating new BB.  */\n-\t  && GET_CODE (insn) != BARRIER\n-\t  && (GET_CODE (insn) != NOTE\n+\t  && !BARRIER_P (insn)\n+\t  && (!NOTE_P (insn)\n \t      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n \tabort ();\n     }\n \n   PREV_INSN (before) = insn;\n-  if (GET_CODE (before) == INSN && GET_CODE (PATTERN (before)) == SEQUENCE)\n+  if (NONJUMP_INSN_P (before) && GET_CODE (PATTERN (before)) == SEQUENCE)\n     PREV_INSN (XVECEXP (PATTERN (before), 0, 0)) = insn;\n }\n \n@@ -3634,7 +3634,7 @@ remove_insn (rtx insn)\n   if (prev)\n     {\n       NEXT_INSN (prev) = next;\n-      if (GET_CODE (prev) == INSN && GET_CODE (PATTERN (prev)) == SEQUENCE)\n+      if (NONJUMP_INSN_P (prev) && GET_CODE (PATTERN (prev)) == SEQUENCE)\n \t{\n \t  rtx sequence = PATTERN (prev);\n \t  NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = next;\n@@ -3660,7 +3660,7 @@ remove_insn (rtx insn)\n   if (next)\n     {\n       PREV_INSN (next) = prev;\n-      if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == SEQUENCE)\n+      if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n \tPREV_INSN (XVECEXP (PATTERN (next), 0, 0)) = prev;\n     }\n   else if (last_insn == insn)\n@@ -3679,7 +3679,7 @@ remove_insn (rtx insn)\n       if (stack == 0)\n \tabort ();\n     }\n-  if (GET_CODE (insn) != BARRIER\n+  if (!BARRIER_P (insn)\n       && (bb = BLOCK_FOR_INSN (insn)))\n     {\n       if (INSN_P (insn))\n@@ -3688,7 +3688,7 @@ remove_insn (rtx insn)\n \t{\n \t  /* Never ever delete the basic block note without deleting whole\n \t     basic block.  */\n-\t  if (GET_CODE (insn) == NOTE)\n+\t  if (NOTE_P (insn))\n \t    abort ();\n \t  BB_HEAD (bb) = next;\n \t}\n@@ -3702,7 +3702,7 @@ remove_insn (rtx insn)\n void\n add_function_usage_to (rtx call_insn, rtx call_fusage)\n {\n-  if (! call_insn || GET_CODE (call_insn) != CALL_INSN)\n+  if (! call_insn || !CALL_P (call_insn))\n     abort ();\n \n   /* Put the register usage information on the CALL.  If there is already\n@@ -3777,13 +3777,13 @@ reorder_insns (rtx from, rtx to, rtx after)\n \n   reorder_insns_nobb (from, to, after);\n \n-  if (GET_CODE (after) != BARRIER\n+  if (!BARRIER_P (after)\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       rtx x;\n       bb->flags |= BB_DIRTY;\n \n-      if (GET_CODE (from) != BARRIER\n+      if (!BARRIER_P (from)\n \t  && (bb2 = BLOCK_FOR_INSN (from)))\n \t{\n \t  if (BB_END (bb2) == to)\n@@ -3808,7 +3808,7 @@ find_line_note (rtx insn)\n     return 0;\n \n   for (; insn; insn = PREV_INSN (insn))\n-    if (GET_CODE (insn) == NOTE\n+    if (NOTE_P (insn)\n \t&& NOTE_LINE_NUMBER (insn) >= 0)\n       break;\n \n@@ -3834,7 +3834,7 @@ remove_unnecessary_notes (void)\n       next = NEXT_INSN (insn);\n \n       /* We're only interested in notes.  */\n-      if (GET_CODE (insn) != NOTE)\n+      if (!NOTE_P (insn))\n \tcontinue;\n \n       switch (NOTE_LINE_NUMBER (insn))\n@@ -3894,7 +3894,7 @@ remove_unnecessary_notes (void)\n \t\tbreak;\n \n \t      /* We're only interested in NOTEs.  */\n-\t      if (GET_CODE (tmp) != NOTE)\n+\t      if (!NOTE_P (tmp))\n \t\tcontinue;\n \n \t      if (NOTE_LINE_NUMBER (tmp) == NOTE_INSN_BLOCK_BEG)\n@@ -4153,14 +4153,14 @@ emit_insn_after_1 (rtx first, rtx after)\n   rtx after_after;\n   basic_block bb;\n \n-  if (GET_CODE (after) != BARRIER\n+  if (!BARRIER_P (after)\n       && (bb = BLOCK_FOR_INSN (after)))\n     {\n       bb->flags |= BB_DIRTY;\n       for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n-\tif (GET_CODE (last) != BARRIER)\n+\tif (!BARRIER_P (last))\n \t  set_block_for_insn (last, bb);\n-      if (GET_CODE (last) != BARRIER)\n+      if (!BARRIER_P (last))\n \tset_block_for_insn (last, bb);\n       if (BB_END (bb) == after)\n \tBB_END (bb) = last;\n@@ -4763,7 +4763,7 @@ set_unique_reg_note (rtx insn, enum reg_note kind, rtx datum)\n enum rtx_code\n classify_insn (rtx x)\n {\n-  if (GET_CODE (x) == CODE_LABEL)\n+  if (LABEL_P (x))\n     return CODE_LABEL;\n   if (GET_CODE (x) == CALL)\n     return CALL_INSN;"}, {"sha": "5321cd1f1efd239a41dce22710bbbd55a0349c8b", "filename": "gcc/except.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -887,7 +887,7 @@ convert_from_eh_region_ranges_1 (rtx *pinsns, int *orig_sp, int cur)\n   for (insn = *pinsns; insn ; insn = next)\n     {\n       next = NEXT_INSN (insn);\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \t{\n \t  int kind = NOTE_LINE_NUMBER (insn);\n \t  if (kind == NOTE_INSN_EH_REGION_BEG\n@@ -928,7 +928,7 @@ convert_from_eh_region_ranges_1 (rtx *pinsns, int *orig_sp, int cur)\n \t      /* Calls can always potentially throw exceptions, unless\n \t\t they have a REG_EH_REGION note with a value of 0 or less.\n \t\t Which should be the only possible kind so far.  */\n-\t      && (GET_CODE (insn) == CALL_INSN\n+\t      && (CALL_P (insn)\n \t\t  /* If we wanted exceptions for non-call insns, then\n \t\t     any may_trap_p instruction could throw.  */\n \t\t  || (flag_non_call_exceptions\n@@ -1464,7 +1464,7 @@ emit_to_new_bb_before (rtx seq, rtx insn)\n     if (e->flags & EDGE_FALLTHRU)\n       force_nonfallthru (e);\n   last = emit_insn_before (seq, insn);\n-  if (GET_CODE (last) == BARRIER)\n+  if (BARRIER_P (last))\n     last = PREV_INSN (last);\n   bb = create_basic_block (seq, last, BLOCK_FOR_INSN (insn)->prev_bb);\n   update_bb_for_insn (bb);\n@@ -1655,7 +1655,7 @@ connect_post_landing_pads (void)\n       end_sequence ();\n       barrier = emit_insn_before (seq, region->resume);\n       /* Avoid duplicate barrier.  */\n-      if (GET_CODE (barrier) != BARRIER)\n+      if (!BARRIER_P (barrier))\n \tabort ();\n       delete_insn (barrier);\n       delete_insn (region->resume);\n@@ -1880,7 +1880,7 @@ sjlj_mark_call_sites (struct sjlj_lp_info *lp_info)\n       rtx note, before, p;\n \n       /* Reset value tracking at extended basic block boundaries.  */\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tlast_call_site = -2;\n \n       if (! INSN_P (insn))\n@@ -1892,7 +1892,7 @@ sjlj_mark_call_sites (struct sjlj_lp_info *lp_info)\n \t  /* Calls (and trapping insns) without notes are outside any\n \t     exception handling region in this function.  Mark them as\n \t     no action.  */\n-\t  if (GET_CODE (insn) == CALL_INSN\n+\t  if (CALL_P (insn)\n \t      || (flag_non_call_exceptions\n \t\t  && may_trap_p (PATTERN (insn))))\n \t    this_call_site = -1;\n@@ -1914,7 +1914,7 @@ sjlj_mark_call_sites (struct sjlj_lp_info *lp_info)\n \n       /* Don't separate a call from it's argument loads.  */\n       before = insn;\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \tbefore = find_first_parameter_load (insn, NULL_RTX);\n \n       start_sequence ();\n@@ -1991,7 +1991,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n      can_throw_internal instructions.  */\n \n   for (fn_begin = get_insns (); ; fn_begin = NEXT_INSN (fn_begin))\n-    if (GET_CODE (fn_begin) == NOTE\n+    if (NOTE_P (fn_begin)\n \t&& (NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG\n \t    || NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_BASIC_BLOCK))\n       break;\n@@ -2001,7 +2001,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n     {\n       rtx last = BB_END (ENTRY_BLOCK_PTR->succ->dest);\n       for (; ; fn_begin = NEXT_INSN (fn_begin))\n-\tif ((GET_CODE (fn_begin) == NOTE\n+\tif ((NOTE_P (fn_begin)\n \t     && NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n \t    || fn_begin == last)\n \t  break;\n@@ -2056,7 +2056,7 @@ sjlj_emit_function_exit (void)\n       else\n \t{\n \t  insn = cfun->eh->sjlj_exit_after;\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t  if (LABEL_P (insn))\n \t    insn = NEXT_INSN (insn);\n \t  emit_insn_after (seq, insn);\n \t}\n@@ -2720,7 +2720,7 @@ reachable_handlers (rtx insn)\n   rtx handlers = NULL;\n   int region_number;\n \n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && GET_CODE (PATTERN (insn)) == RESX)\n     {\n       region_number = XINT (PATTERN (insn), 0);\n@@ -2784,12 +2784,12 @@ can_throw_internal (rtx insn)\n   if (! INSN_P (insn))\n     return false;\n \n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && GET_CODE (PATTERN (insn)) == RESX\n       && XINT (PATTERN (insn), 0) > 0)\n     return can_throw_internal_1 (XINT (PATTERN (insn), 0));\n \n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     insn = XVECEXP (PATTERN (insn), 0, 0);\n \n@@ -2836,7 +2836,7 @@ can_throw_external (rtx insn)\n   if (! INSN_P (insn))\n     return false;\n \n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     insn = XVECEXP (PATTERN (insn), 0, 0);\n \n@@ -2848,7 +2848,7 @@ can_throw_external (rtx insn)\n \t assume it might throw.  Given that the front end and middle\n \t ends mark known NOTHROW functions, this isn't so wildly\n \t inaccurate.  */\n-      return (GET_CODE (insn) == CALL_INSN\n+      return (CALL_P (insn)\n \t      || (flag_non_call_exceptions\n \t\t  && may_trap_p (PATTERN (insn))));\n     }\n@@ -2883,7 +2883,7 @@ set_nothrow_function_flags (void)\n       {\n         TREE_NOTHROW (current_function_decl) = 0;\n \n-\tif (GET_CODE (insn) != CALL_INSN || !SIBLING_CALL_P (insn))\n+\tif (!CALL_P (insn) || !SIBLING_CALL_P (insn))\n \t  {\n \t    cfun->all_throwers_are_sibcalls = 0;\n \t    return;\n@@ -2896,7 +2896,7 @@ set_nothrow_function_flags (void)\n       {\n         TREE_NOTHROW (current_function_decl) = 0;\n \n-\tif (GET_CODE (insn) != CALL_INSN || !SIBLING_CALL_P (insn))\n+\tif (!CALL_P (insn) || !SIBLING_CALL_P (insn))\n \t  {\n \t    cfun->all_throwers_are_sibcalls = 0;\n \t    return;\n@@ -3316,14 +3316,14 @@ convert_to_eh_region_ranges (void)\n \trtx this_landing_pad;\n \n \tinsn = iter;\n-\tif (GET_CODE (insn) == INSN\n+\tif (NONJUMP_INSN_P (insn)\n \t    && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t  insn = XVECEXP (PATTERN (insn), 0, 0);\n \n \tnote = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n \tif (!note)\n \t  {\n-\t    if (! (GET_CODE (insn) == CALL_INSN\n+\t    if (! (CALL_P (insn)\n \t\t   || (flag_non_call_exceptions\n \t\t       && may_trap_p (PATTERN (insn)))))\n \t      continue;"}, {"sha": "cfaadf3afa98d9bfa0af26100df126ca40579979", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1118,7 +1118,7 @@ optimize_save_area_alloca (void)\n     {\n       rtx note;\n \n-      if (GET_CODE (insn) != INSN)\n+      if (!NONJUMP_INSN_P (insn))\n \tcontinue;\n \n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))"}, {"sha": "c390f5453875c0ec0e334561a65d282694434145", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -6405,7 +6405,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t\t may_trap_p instruction may throw.  */\n \t      && GET_CODE (PATTERN (insn)) != CLOBBER\n \t      && GET_CODE (PATTERN (insn)) != USE\n-\t      && (GET_CODE (insn) == CALL_INSN || may_trap_p (PATTERN (insn))))\n+\t      && (CALL_P (insn) || may_trap_p (PATTERN (insn))))\n \t    {\n \t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_EH_REGION, GEN_INT (rn),\n \t\t\t\t\t\t  REG_NOTES (insn));"}, {"sha": "412d0faae7f547957da7cc703ece1e54bbcfdf91", "filename": "gcc/final.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -625,7 +625,7 @@ insn_current_reference_address (rtx branch)\n \n   seq = NEXT_INSN (PREV_INSN (branch));\n   seq_uid = INSN_UID (seq);\n-  if (GET_CODE (branch) != JUMP_INSN)\n+  if (!JUMP_P (branch))\n     /* This can happen for example on the PA; the objective is to know the\n        offset to address something in front of the start of the function.\n        Thus, we can treat it like a backward branch.\n@@ -678,7 +678,7 @@ compute_alignments (void)\n       int fallthru_frequency = 0, branch_frequency = 0, has_fallthru = 0;\n       edge e;\n \n-      if (GET_CODE (label) != CODE_LABEL\n+      if (!LABEL_P (label)\n \t  || probably_never_executed_bb_p (bb))\n \tcontinue;\n       max_log = LABEL_ALIGN (label);\n@@ -817,7 +817,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n              is separated by the former loop start insn from the\n \t     NOTE_INSN_LOOP_BEG.  */\n \t}\n-      else if (GET_CODE (insn) == CODE_LABEL)\n+      else if (LABEL_P (insn))\n \t{\n \t  rtx next;\n \n@@ -839,7 +839,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \t  /* ADDR_VECs only take room if read-only data goes into the text\n \t     section.  */\n \t  if (JUMP_TABLES_IN_TEXT_SECTION || !HAVE_READONLY_DATA_SECTION)\n-\t    if (next && GET_CODE (next) == JUMP_INSN)\n+\t    if (next && JUMP_P (next))\n \t      {\n \t\trtx nextbody = PATTERN (next);\n \t\tif (GET_CODE (nextbody) == ADDR_VEC\n@@ -858,13 +858,13 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \t  max_log = 0;\n \t  max_skip = 0;\n \t}\n-      else if (GET_CODE (insn) == BARRIER)\n+      else if (BARRIER_P (insn))\n \t{\n \t  rtx label;\n \n \t  for (label = insn; label && ! INSN_P (label);\n \t       label = NEXT_INSN (label))\n-\t    if (GET_CODE (label) == CODE_LABEL)\n+\t    if (LABEL_P (label))\n \t      {\n \t\tlog = LABEL_ALIGN_AFTER_BARRIER (insn);\n \t\tif (max_log < log)\n@@ -901,7 +901,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n     {\n       int uid = INSN_UID (seq);\n       int log;\n-      log = (GET_CODE (seq) == CODE_LABEL ? LABEL_TO_ALIGNMENT (seq) : 0);\n+      log = (LABEL_P (seq) ? LABEL_TO_ALIGNMENT (seq) : 0);\n       uid_align[uid] = align_tab[0];\n       if (log)\n \t{\n@@ -928,7 +928,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \t  int min_align;\n \t  addr_diff_vec_flags flags;\n \n-\t  if (GET_CODE (insn) != JUMP_INSN\n+\t  if (!JUMP_P (insn)\n \t      || GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n \t    continue;\n \t  pat = PATTERN (insn);\n@@ -977,7 +977,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \n       insn_lengths[uid] = 0;\n \n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \t{\n \t  int log = LABEL_TO_ALIGNMENT (insn);\n \t  if (log)\n@@ -990,8 +990,8 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \n       INSN_ADDRESSES (uid) = insn_current_address + insn_lengths[uid];\n \n-      if (GET_CODE (insn) == NOTE || GET_CODE (insn) == BARRIER\n-\t  || GET_CODE (insn) == CODE_LABEL)\n+      if (NOTE_P (insn) || BARRIER_P (insn)\n+\t  || LABEL_P (insn))\n \tcontinue;\n       if (INSN_DELETED_P (insn))\n \tcontinue;\n@@ -1082,7 +1082,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \n \t  uid = INSN_UID (insn);\n \n-\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t  if (LABEL_P (insn))\n \t    {\n \t      int log = LABEL_TO_ALIGNMENT (insn);\n \t      if (log > insn_current_align)\n@@ -1107,7 +1107,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \t  INSN_ADDRESSES (uid) = insn_current_address;\n \n #ifdef CASE_VECTOR_SHORTEN_MODE\n-\t  if (optimize && GET_CODE (insn) == JUMP_INSN\n+\t  if (optimize && JUMP_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n \t    {\n \t      rtx body = PATTERN (insn);\n@@ -1217,7 +1217,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \n \t  if (! (varying_length[uid]))\n \t    {\n-\t      if (GET_CODE (insn) == INSN\n+\t      if (NONJUMP_INSN_P (insn)\n \t\t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t\t{\n \t\t  int i;\n@@ -1239,7 +1239,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n \t      continue;\n \t    }\n \n-\t  if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t  if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t    {\n \t      int i;\n \n@@ -1517,7 +1517,7 @@ final (rtx first, FILE *file, int optimize, int prescan)\n     {\n       rtx last = 0;\n       for (insn = first; insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\tif (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n \t  {\n \t    if (last != 0\n #ifdef USE_MAPPED_LOCATION\n@@ -1543,7 +1543,7 @@ final (rtx first, FILE *file, int optimize, int prescan)\n #ifdef HAVE_cc0\n       /* If CC tracking across branches is enabled, record the insn which\n \t jumps to each branch only reached from one place.  */\n-      if (optimize && GET_CODE (insn) == JUMP_INSN)\n+      if (optimize && JUMP_P (insn))\n \t{\n \t  rtx lab = JUMP_LABEL (insn);\n \t  if (lab && LABEL_NUSES (lab) == 1)\n@@ -1566,7 +1566,7 @@ final (rtx first, FILE *file, int optimize, int prescan)\n \t{\n \t  /* This can be triggered by bugs elsewhere in the compiler if\n \t     new insns are created after init_insn_lengths is called.  */\n-\t  if (GET_CODE (insn) == NOTE)\n+\t  if (NOTE_P (insn))\n \t    insn_current_address = -1;\n \t  else\n \t    abort ();\n@@ -1641,10 +1641,10 @@ scan_ahead_for_unlikely_executed_note (rtx insn)\n \n   for (temp = insn; temp; temp = NEXT_INSN (temp))\n     {\n-      if (GET_CODE (temp) == NOTE\n+      if (NOTE_P (temp)\n \t  && NOTE_LINE_NUMBER (temp) == NOTE_INSN_UNLIKELY_EXECUTED_CODE)\n \treturn true;\n-      if (GET_CODE (temp) == NOTE\n+      if (NOTE_P (temp)\n \t  && NOTE_LINE_NUMBER (temp) == NOTE_INSN_BASIC_BLOCK)\n \t{\n \t  bb_note_count++;\n@@ -1902,10 +1902,10 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t     insn, and that branch is the only way to reach this label,\n \t     set the condition codes based on the branch and its\n \t     predecessor.  */\n-\t  if (barrier && GET_CODE (barrier) == BARRIER\n-\t      && jump && GET_CODE (jump) == JUMP_INSN\n+\t  if (barrier && BARRIER_P (barrier)\n+\t      && jump && JUMP_P (jump)\n \t      && (prev = prev_nonnote_insn (jump))\n-\t      && GET_CODE (prev) == INSN)\n+\t      && NONJUMP_INSN_P (prev))\n \t    {\n \t      NOTICE_UPDATE_CC (PATTERN (prev), prev);\n \t      NOTICE_UPDATE_CC (PATTERN (jump), jump);\n@@ -1925,7 +1925,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n       if (flag_reorder_blocks_and_partition)\n \t{\n \t  rtx tmp_table, tmp_label;\n-\t  if (GET_CODE (insn) == CODE_LABEL\n+\t  if (LABEL_P (insn)\n \t      && tablejump_p (NEXT_INSN (insn), &tmp_label, &tmp_table))\n \t    {\n \t      /* Do nothing; Do NOT change the current section.  */\n@@ -1945,7 +1945,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  app_on = 0;\n \t}\n       if (NEXT_INSN (insn) != 0\n-\t  && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN)\n+\t  && JUMP_P (NEXT_INSN (insn)))\n \t{\n \t  rtx nextbody = PATTERN (NEXT_INSN (insn));\n \n@@ -2214,7 +2214,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t       called function.  Hence we don't preserve any CC-setting\n \t       actions in these insns and the CC must be marked as being\n \t       clobbered by the function.  */\n-\t    if (GET_CODE (XVECEXP (body, 0, 0)) == CALL_INSN)\n+\t    if (CALL_P (XVECEXP (body, 0, 0)))\n \t      {\n \t\tCC_STATUS_INIT;\n \t      }\n@@ -2279,7 +2279,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t   will cause an improper number of delay insns to be written.  */\n \tif (final_sequence == 0\n \t    && prescan >= 0\n-\t    && GET_CODE (insn) == INSN && GET_CODE (body) == SET\n+\t    && NONJUMP_INSN_P (insn) && GET_CODE (body) == SET\n \t    && REG_P (SET_SRC (body))\n \t    && REG_P (SET_DEST (body))\n \t    && REGNO (SET_SRC (body)) == REGNO (SET_DEST (body)))\n@@ -2293,7 +2293,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t   do straightforwardly if the cc's were set up normally.  */\n \n \tif (cc_status.flags != 0\n-\t    && GET_CODE (insn) == JUMP_INSN\n+\t    && JUMP_P (insn)\n \t    && GET_CODE (body) == SET\n \t    && SET_DEST (body) == pc_rtx\n \t    && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE\n@@ -2342,7 +2342,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  {\n \t    rtx cond_rtx, then_rtx, else_rtx;\n \n-\t    if (GET_CODE (insn) != JUMP_INSN\n+\t    if (!JUMP_P (insn)\n \t\t&& GET_CODE (SET_SRC (set)) == IF_THEN_ELSE)\n \t      {\n \t\tcond_rtx = XEXP (SET_SRC (set), 0);\n@@ -2470,7 +2470,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tcurrent_output_insn = debug_insn = insn;\n \n #if defined (DWARF2_UNWIND_INFO)\n-\tif (GET_CODE (insn) == CALL_INSN && dwarf2out_do_frame ())\n+\tif (CALL_P (insn) && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn);\n #endif\n \n@@ -2495,7 +2495,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t\t prev != last_ignored_compare;\n \t\t prev = PREV_INSN (prev))\n \t      {\n-\t\tif (GET_CODE (prev) == NOTE)\n+\t\tif (NOTE_P (prev))\n \t\t  delete_insn (prev);\t/* Use delete_note.  */\n \t      }\n \n@@ -2536,7 +2536,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t   the unwind info.   We've already done this for delay slots\n \t   and call instructions.  */\n #if defined (DWARF2_UNWIND_INFO)\n-\tif (GET_CODE (insn) == INSN\n+\tif (NONJUMP_INSN_P (insn)\n #if !defined (HAVE_prologue)\n \t    && !ACCUMULATE_OUTGOING_ARGS\n #endif\n@@ -3196,8 +3196,8 @@ output_asm_label (rtx x)\n \n   if (GET_CODE (x) == LABEL_REF)\n     x = XEXP (x, 0);\n-  if (GET_CODE (x) == CODE_LABEL\n-      || (GET_CODE (x) == NOTE\n+  if (LABEL_P (x)\n+      || (NOTE_P (x)\n \t  && NOTE_LINE_NUMBER (x) == NOTE_INSN_DELETED_LABEL))\n     ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n   else\n@@ -3690,12 +3690,12 @@ leaf_function_p (void)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == CALL_INSN\n+      if (CALL_P (insn)\n \t  && ! SIBLING_CALL_P (insn))\n \treturn 0;\n-      if (GET_CODE (insn) == INSN\n+      if (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE\n-\t  && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN\n+\t  && CALL_P (XVECEXP (PATTERN (insn), 0, 0))\n \t  && ! SIBLING_CALL_P (XVECEXP (PATTERN (insn), 0, 0)))\n \treturn 0;\n     }\n@@ -3705,12 +3705,12 @@ leaf_function_p (void)\n     {\n       insn = XEXP (link, 0);\n \n-      if (GET_CODE (insn) == CALL_INSN\n+      if (CALL_P (insn)\n \t  && ! SIBLING_CALL_P (insn))\n \treturn 0;\n-      if (GET_CODE (insn) == INSN\n+      if (NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE\n-\t  && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == CALL_INSN\n+\t  && CALL_P (XVECEXP (PATTERN (insn), 0, 0))\n \t  && ! SIBLING_CALL_P (XVECEXP (PATTERN (insn), 0, 0)))\n \treturn 0;\n     }"}, {"sha": "bf8e61ce3f636f3850077db535b68fa221566c34", "filename": "gcc/flow.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -343,7 +343,7 @@ first_insn_after_basic_block_note (basic_block block)\n \n   if (insn == NULL_RTX)\n     return NULL_RTX;\n-  if (GET_CODE (insn) == CODE_LABEL)\n+  if (LABEL_P (insn))\n     insn = NEXT_INSN (insn);\n   if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n     abort ();\n@@ -832,9 +832,9 @@ delete_dead_jumptables (void)\n   for (insn = get_insns (); insn; insn = next)\n     {\n       next = NEXT_INSN (insn);\n-      if (GET_CODE (insn) == CODE_LABEL\n+      if (LABEL_P (insn)\n \t  && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n-\t  && GET_CODE (next) == JUMP_INSN\n+\t  && JUMP_P (next)\n \t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n \t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n \t{\n@@ -1474,7 +1474,7 @@ propagate_block_delete_insn (rtx insn)\n      real good way to fix up the reference to the deleted label\n      when the label is deleted, so we just allow it here.  */\n \n-  if (inote && GET_CODE (inote) == CODE_LABEL)\n+  if (inote && LABEL_P (inote))\n     {\n       rtx label = XEXP (inote, 0);\n       rtx next;\n@@ -1484,7 +1484,7 @@ propagate_block_delete_insn (rtx insn)\n \t jump following it, but not the label itself.  */\n       if (LABEL_NUSES (label) == 1 + LABEL_PRESERVE_P (label)\n \t  && (next = next_nonnote_insn (label)) != NULL\n-\t  && GET_CODE (next) == JUMP_INSN\n+\t  && JUMP_P (next)\n \t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n \t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n \t{\n@@ -1674,15 +1674,15 @@ propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n \t in a register clobbered by calls.  Find all regs now live and\n \t record this for them.  */\n \n-      if (GET_CODE (insn) == CALL_INSN && (flags & PROP_REG_INFO))\n+      if (CALL_P (insn) && (flags & PROP_REG_INFO))\n \tEXECUTE_IF_SET_IN_REG_SET (pbi->reg_live, 0, i,\n \t\t\t\t   { REG_N_CALLS_CROSSED (i)++; });\n \n       /* Record sets.  Do this even for dead instructions, since they\n \t would have killed the values if they hadn't been deleted.  */\n       mark_set_regs (pbi, PATTERN (insn), insn);\n \n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  regset live_at_end;\n \t  bool sibcall_p;\n@@ -1752,7 +1752,7 @@ propagate_one_insn (struct propagate_block_info *pbi, rtx insn)\n       prev = PREV_INSN (insn);\n #endif\n \n-      if (! insn_is_dead && GET_CODE (insn) == CALL_INSN)\n+      if (! insn_is_dead && CALL_P (insn))\n \t{\n \t  int i;\n \t  rtx note, cond;\n@@ -1824,7 +1824,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n   /* If this block ends in a conditional branch, for each register\n      live from one side of the branch and not the other, record the\n      register as conditionally dead.  */\n-  if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+  if (JUMP_P (BB_END (bb))\n       && any_condjump_p (BB_END (bb)))\n     {\n       regset_head diff_head;\n@@ -1932,7 +1932,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n     {\n       rtx insn, set;\n       for (insn = BB_END (bb); insn != BB_HEAD (bb); insn = PREV_INSN (insn))\n-\tif (GET_CODE (insn) == INSN\n+\tif (NONJUMP_INSN_P (insn)\n \t    && (set = single_set (insn))\n \t    && MEM_P (SET_DEST (set)))\n \t  {\n@@ -2026,7 +2026,7 @@ propagate_block (basic_block bb, regset live, regset local_set,\n       /* If this is a call to `setjmp' et al, warn if any\n \t non-volatile datum is live.  */\n       if ((flags & PROP_REG_INFO)\n-\t  && GET_CODE (insn) == CALL_INSN\n+\t  && CALL_P (insn)\n \t  && find_reg_note (insn, REG_SETJMP, NULL))\n \tIOR_REG_SET (regs_live_at_setjmp, pbi->reg_live);\n \n@@ -2272,7 +2272,7 @@ libcall_dead_p (struct propagate_block_info *pbi, rtx note, rtx insn)\n \t  int i;\n \n \t  /* Find the call insn.  */\n-\t  while (call != insn && GET_CODE (call) != CALL_INSN)\n+\t  while (call != insn && !CALL_P (call))\n \t    call = NEXT_INSN (call);\n \n \t  /* If there is none, do nothing special,\n@@ -2745,8 +2745,8 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t\t  if (y && (BLOCK_NUM (y) == blocknum)\n \t\t      && (regno_first >= FIRST_PSEUDO_REGISTER\n \t\t\t  || (asm_noperands (PATTERN (y)) < 0\n-\t\t\t      && ! ((GET_CODE (insn) == CALL_INSN\n-\t\t\t\t     || GET_CODE (y) == CALL_INSN)\n+\t\t\t      && ! ((CALL_P (insn)\n+\t\t\t\t     || CALL_P (y))\n \t\t\t\t    && global_regs[regno_first]))))\n \t\t    LOG_LINKS (y) = alloc_INSN_LIST (insn, LOG_LINKS (y));\n \t\t}\n@@ -3322,7 +3322,7 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n \t use of INCR_REG.  If a use of INCR_REG was just placed in\n \t the insn before INSN, make that the next use.\n \t Otherwise, invalidate it.  */\n-      if (GET_CODE (PREV_INSN (insn)) == INSN\n+      if (NONJUMP_INSN_P (PREV_INSN (insn))\n \t  && GET_CODE (PATTERN (PREV_INSN (insn))) == SET\n \t  && SET_SRC (PATTERN (PREV_INSN (insn))) == incr_reg)\n \tpbi->reg_next_use[regno] = PREV_INSN (insn);\n@@ -3345,7 +3345,7 @@ attempt_auto_inc (struct propagate_block_info *pbi, rtx inc, rtx insn,\n       /* If there are any calls between INSN and INCR, show\n \t that REGNO now crosses them.  */\n       for (temp = insn; temp != incr; temp = NEXT_INSN (temp))\n-\tif (GET_CODE (temp) == CALL_INSN)\n+\tif (CALL_P (temp))\n \t  REG_N_CALLS_CROSSED (regno)++;\n \n       /* Invalidate alias info for Q since we just changed its value.  */\n@@ -3418,7 +3418,7 @@ find_auto_inc (struct propagate_block_info *pbi, rtx x, rtx insn)\n   int regno;\n   int size = GET_MODE_SIZE (GET_MODE (x));\n \n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     return;\n \n   /* Here we detect use of an index register which might be good for\n@@ -4049,7 +4049,7 @@ try_pre_increment (rtx insn, rtx reg, HOST_WIDE_INT amount)\n      because if the incremented register is spilled and must be reloaded\n      there would be no way to store the incremented value back in memory.  */\n \n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     return 0;\n \n   use = 0;"}, {"sha": "6780e355da51651806cd6a837f118eea82b59d4a", "filename": "gcc/function.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -3641,7 +3641,7 @@ reorder_blocks_1 (rtx insns, tree current_block, varray_type *p_block_stack)\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \t{\n \t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n \t    {\n@@ -4201,7 +4201,7 @@ expand_function_start (tree subr)\n      as opposed to parm setup.  */\n   emit_note (NOTE_INSN_FUNCTION_BEG);\n \n-  if (GET_CODE (get_last_insn ()) != NOTE)\n+  if (!NOTE_P (get_last_insn ()))\n     emit_note (NOTE_INSN_DELETED);\n   parm_birth_insn = get_last_insn ();\n \n@@ -4339,7 +4339,7 @@ expand_function_end (void)\n       rtx insn, seq;\n \n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == CALL_INSN)\n+\tif (CALL_P (insn))\n \t  {\n \t    start_sequence ();\n \t    probe_stack_range (STACK_CHECK_PROTECT,\n@@ -4624,7 +4624,7 @@ contains (rtx insn, varray_type vec)\n {\n   int i, j;\n \n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     {\n       int count = 0;\n@@ -5119,14 +5119,14 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \n       /* Verify that there are no active instructions in the last block.  */\n       label = BB_END (last);\n-      while (label && GET_CODE (label) != CODE_LABEL)\n+      while (label && !LABEL_P (label))\n \t{\n \t  if (active_insn_p (label))\n \t    break;\n \t  label = PREV_INSN (label);\n \t}\n \n-      if (BB_HEAD (last) == label && GET_CODE (label) == CODE_LABEL)\n+      if (BB_HEAD (last) == label && LABEL_P (label))\n \t{\n \t  rtx epilogue_line_note = NULL_RTX;\n \n@@ -5135,7 +5135,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t  for (seq = get_last_insn ();\n \t       seq && ! active_insn_p (seq);\n \t       seq = PREV_INSN (seq))\n-\t    if (GET_CODE (seq) == NOTE && NOTE_LINE_NUMBER (seq) > 0)\n+\t    if (NOTE_P (seq) && NOTE_LINE_NUMBER (seq) > 0)\n \t      {\n \t\tepilogue_line_note = seq;\n \t\tbreak;\n@@ -5151,7 +5151,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t\tcontinue;\n \n \t      jump = BB_END (bb);\n-\t      if ((GET_CODE (jump) != JUMP_INSN) || JUMP_LABEL (jump) != label)\n+\t      if (!JUMP_P (jump) || JUMP_LABEL (jump) != label)\n \t\tcontinue;\n \n \t      /* If we have an unconditional jump, we can replace that\n@@ -5266,7 +5266,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       rtx i;\n       rtx newinsn;\n \n-      if (GET_CODE (insn) != CALL_INSN\n+      if (!CALL_P (insn)\n \t  || ! SIBLING_CALL_P (insn))\n \tcontinue;\n \n@@ -5308,7 +5308,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       for (insn = prologue_end; insn; insn = prev)\n \t{\n \t  prev = PREV_INSN (insn);\n-\t  if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\t  if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n \t    {\n \t      /* Note that we cannot reorder the first insn in the\n \t\t chain, since rest_of_compilation relies on that\n@@ -5323,7 +5323,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       for (insn = BB_END (ENTRY_BLOCK_PTR->next_bb);\n \t   insn != prologue_end && insn;\n \t   insn = PREV_INSN (insn))\n-\tif (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\tif (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n \t  break;\n \n       /* If we didn't find one, make a copy of the first line number\n@@ -5333,7 +5333,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t  for (insn = next_active_insn (prologue_end);\n \t       insn;\n \t       insn = PREV_INSN (insn))\n-\t    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\t    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n \t      {\n \t\temit_note_copy_after (insn, prologue_end);\n \t\tbreak;\n@@ -5354,7 +5354,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       for (insn = epilogue_end; insn; insn = next)\n \t{\n \t  next = NEXT_INSN (insn);\n-\t  if (GET_CODE (insn) == NOTE \n+\t  if (NOTE_P (insn) \n \t      && (NOTE_LINE_NUMBER (insn) > 0\n \t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG\n \t\t  || NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_END))\n@@ -5383,7 +5383,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t reorg has run.  */\n       for (insn = f; insn; insn = NEXT_INSN (insn))\n \t{\n-\t  if (GET_CODE (insn) == NOTE)\n+\t  if (NOTE_P (insn))\n \t    {\n \t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n \t\tnote = insn;\n@@ -5403,13 +5403,13 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t  if (note == 0)\n \t    {\n \t      for (note = last; (note = NEXT_INSN (note));)\n-\t\tif (GET_CODE (note) == NOTE\n+\t\tif (NOTE_P (note)\n \t\t    && NOTE_LINE_NUMBER (note) == NOTE_INSN_PROLOGUE_END)\n \t\t  break;\n \t    }\n \n \t  /* Avoid placing note between CODE_LABEL and BASIC_BLOCK note.  */\n-\t  if (GET_CODE (last) == CODE_LABEL)\n+\t  if (LABEL_P (last))\n \t    last = NEXT_INSN (last);\n \t  reorder_insns (note, note, last);\n \t}\n@@ -5424,7 +5424,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t reorg has run.  */\n       for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n \t{\n-\t  if (GET_CODE (insn) == NOTE)\n+\t  if (NOTE_P (insn))\n \t    {\n \t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n \t\tnote = insn;\n@@ -5444,7 +5444,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t  if (note == 0)\n \t    {\n \t      for (note = insn; (note = PREV_INSN (note));)\n-\t\tif (GET_CODE (note) == NOTE\n+\t\tif (NOTE_P (note)\n \t\t    && NOTE_LINE_NUMBER (note) == NOTE_INSN_EPILOGUE_BEG)\n \t\t  break;\n \t    }"}, {"sha": "d9773a14812e471a43e8292e241f6b41dc9f17ec", "filename": "gcc/gcse.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -3293,7 +3293,7 @@ constprop_register (rtx insn, rtx from, rtx to, int alter_jumps)\n     }\n \n   /* Handle normal insns next.  */\n-  if (GET_CODE (insn) == INSN\n+  if (NONJUMP_INSN_P (insn)\n       && try_replace_reg (from, to, insn))\n     return 1;\n \n@@ -4127,7 +4127,7 @@ bypass_conditional_jumps (void)\n \t  for (insn = BB_HEAD (bb);\n \t       insn != NULL && insn != NEXT_INSN (BB_END (bb));\n \t       insn = NEXT_INSN (insn))\n-\t    if (GET_CODE (insn) == INSN)\n+\t    if (NONJUMP_INSN_P (insn))\n \t      {\n \t\tif (setcc)\n \t\t  break;\n@@ -4427,7 +4427,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n      instructions in presence of non-call exceptions.  */\n \n   if (JUMP_P (insn)\n-      || (GET_CODE (insn) == INSN\n+      || (NONJUMP_INSN_P (insn)\n \t  && (bb->succ->succ_next || (bb->succ->flags & EDGE_ABNORMAL))))\n     {\n #ifdef HAVE_cc0\n@@ -4436,7 +4436,7 @@ insert_insn_end_bb (struct expr *expr, basic_block bb, int pre)\n       /* It should always be the case that we can put these instructions\n \t anywhere in the basic block with performing PRE optimizations.\n \t Check this.  */\n-      if (GET_CODE (insn) == INSN && pre\n+      if (NONJUMP_INSN_P (insn) && pre\n \t  && !TEST_BIT (antloc[bb->index], expr->bitmap_index)\n \t  && !TEST_BIT (transp[bb->index], expr->bitmap_index))\n \tabort ();\n@@ -7375,7 +7375,7 @@ gcse_after_reload (void)\n \t   insn = NEXT_INSN (insn))\n \t{\n \t  /* Is it a load - of the form (set (reg) (mem))?  */\n-\t  if (GET_CODE (insn) == INSN\n+\t  if (NONJUMP_INSN_P (insn)\n               && GET_CODE (PATTERN (insn)) == SET\n \t      && REG_P (SET_DEST (PATTERN (insn)))\n \t      && MEM_P (SET_SRC (PATTERN (insn))))"}, {"sha": "1198123fad13334c8aaf369fa06772dbe62aef92", "filename": "gcc/genemit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -536,7 +536,7 @@ gen_expand (rtx expand)\n \t       || (GET_CODE (next) == PARALLEL\n \t\t   && GET_CODE (XVECEXP (next, 0, 0)) == CALL))\n \tprintf (\"  emit_call_insn (\");\n-      else if (GET_CODE (next) == CODE_LABEL)\n+      else if (LABEL_P (next))\n \tprintf (\"  emit_label (\");\n       else if (GET_CODE (next) == MATCH_OPERAND\n \t       || GET_CODE (next) == MATCH_DUP\n@@ -646,7 +646,7 @@ gen_split (rtx split)\n \t       || (GET_CODE (next) == PARALLEL\n \t\t   && GET_CODE (XVECEXP (next, 0, 0)) == CALL))\n \tprintf (\"  emit_call_insn (\");\n-      else if (GET_CODE (next) == CODE_LABEL)\n+      else if (LABEL_P (next))\n \tprintf (\"  emit_label (\");\n       else if (GET_CODE (next) == MATCH_OPERAND\n \t       || GET_CODE (next) == MATCH_OPERATOR"}, {"sha": "6ed1307e77369710bb735d54a7d1e6eaffffc0a5", "filename": "gcc/genpeep.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -75,13 +75,13 @@ gen_peephole (rtx peep)\n \t  printf (\"  do { insn = NEXT_INSN (insn);\\n\");\n \t  printf (\"       if (insn == 0) goto L%d; }\\n\",\n \t\t  insn_code_number);\n-\t  printf (\"  while (GET_CODE (insn) == NOTE\\n\");\n-\t  printf (\"\\t || (GET_CODE (insn) == INSN\\n\");\n+\t  printf (\"  while (NOTE_P (insn)\\n\");\n+\t  printf (\"\\t || (NONJUMP_INSN_P (insn)\\n\");\n \t  printf (\"\\t     && (GET_CODE (PATTERN (insn)) == USE\\n\");\n \t  printf (\"\\t\\t || GET_CODE (PATTERN (insn)) == CLOBBER)));\\n\");\n \n-\t  printf (\"  if (GET_CODE (insn) == CODE_LABEL\\n\\\n-      || GET_CODE (insn) == BARRIER)\\n    goto L%d;\\n\",\n+\t  printf (\"  if (LABEL_P (insn)\\n\\\n+      || BARRIER_P (insn))\\n    goto L%d;\\n\",\n \t\t  insn_code_number);\n \t}\n \n@@ -391,7 +391,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n   /* Early out: no peepholes for insns followed by barriers.  */\n   printf (\"  if (NEXT_INSN (ins1)\\n\");\n-  printf (\"      && GET_CODE (NEXT_INSN (ins1)) == BARRIER)\\n\");\n+  printf (\"      && BARRIER_P (NEXT_INSN (ins1)))\\n\");\n   printf (\"    return 0;\\n\\n\");\n \n   /* Read the machine description.  */"}, {"sha": "24149d321596d06aecc268fb3bf0f039e2f1d856", "filename": "gcc/global.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1823,7 +1823,7 @@ build_insn_chain (rtx first)\n \t     });\n \t}\n \n-      if (GET_CODE (first) != NOTE && GET_CODE (first) != BARRIER)\n+      if (!NOTE_P (first) && !BARRIER_P (first))\n \t{\n \t  c = new_insn_chain ();\n \t  c->prev = prev;\n@@ -1886,7 +1886,7 @@ build_insn_chain (rtx first)\n \t\t&& ! ((GET_CODE (PATTERN (first)) == ADDR_VEC\n \t\t       || GET_CODE (PATTERN (first)) == ADDR_DIFF_VEC)\n \t\t      && prev_real_insn (first) != 0\n-\t\t      && GET_CODE (prev_real_insn (first)) == JUMP_INSN))\n+\t\t      && JUMP_P (prev_real_insn (first))))\n \t      abort ();\n \t  break;\n \t}"}, {"sha": "d751bd0bf4fca4503bea77d608727ae22930feae", "filename": "gcc/graph.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -128,11 +128,11 @@ edge: { sourcename: \\\"%s.0\\\" targetname: \\\"%s.%d\\\" }\\n\",\n       fprintf (fp, \"node: {\\n  title: \\\"%s.%d\\\"\\n  color: %s\\n  \\\n label: \\\"%s %d\\n\",\n \t       current_function_name (), XINT (tmp_rtx, 0),\n-\t       GET_CODE (tmp_rtx) == NOTE ? \"lightgrey\"\n-\t       : GET_CODE (tmp_rtx) == INSN ? \"green\"\n-\t       : GET_CODE (tmp_rtx) == JUMP_INSN ? \"darkgreen\"\n-\t       : GET_CODE (tmp_rtx) == CALL_INSN ? \"darkgreen\"\n-\t       : GET_CODE (tmp_rtx) == CODE_LABEL ?  \"\\\n+\t       NOTE_P (tmp_rtx) ? \"lightgrey\"\n+\t       : NONJUMP_INSN_P (tmp_rtx) ? \"green\"\n+\t       : JUMP_P (tmp_rtx) ? \"darkgreen\"\n+\t       : CALL_P (tmp_rtx) ? \"darkgreen\"\n+\t       : LABEL_P (tmp_rtx) ?  \"\\\n darkgrey\\n  shape: ellipse\" : \"white\",\n \t       GET_RTX_NAME (GET_CODE (tmp_rtx)), XINT (tmp_rtx, 0));\n       break;\n@@ -141,7 +141,7 @@ darkgrey\\n  shape: ellipse\" : \"white\",\n     }\n \n   /* Print the RTL.  */\n-  if (GET_CODE (tmp_rtx) == NOTE)\n+  if (NOTE_P (tmp_rtx))\n     {\n       const char *name = \"\";\n       if (NOTE_LINE_NUMBER (tmp_rtx) < 0)\n@@ -287,9 +287,9 @@ print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n \n \t  if (start[INSN_UID (tmp_rtx)] < 0 && end[INSN_UID (tmp_rtx)] < 0)\n \t    {\n-\t      if (GET_CODE (tmp_rtx) == BARRIER)\n+\t      if (BARRIER_P (tmp_rtx))\n \t\tcontinue;\n-\t      if (GET_CODE (tmp_rtx) == NOTE\n+\t      if (NOTE_P (tmp_rtx)\n \t\t  && (1 || in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB))\n \t\tcontinue;\n \t    }\n@@ -348,7 +348,7 @@ print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n \t    {\n \t      /* Don't print edges to barriers.  */\n \t      if (next_insn == 0\n-\t\t  || GET_CODE (next_insn) != BARRIER)\n+\t\t  || !BARRIER_P (next_insn))\n \t\tdraw_edge (fp, XINT (tmp_rtx, 0),\n \t\t\t   next_insn ? INSN_UID (next_insn) : 999999, 0, 0);\n \t      else\n@@ -359,8 +359,8 @@ print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n \t\t  do\n \t\t    next_insn = NEXT_INSN (next_insn);\n \t\t  while (next_insn\n-\t\t\t && (GET_CODE (next_insn) == NOTE\n-\t\t\t     || GET_CODE (next_insn) == BARRIER));\n+\t\t\t && (NOTE_P (next_insn)\n+\t\t\t     || BARRIER_P (next_insn)));\n \n \t\t  draw_edge (fp, XINT (tmp_rtx, 0),\n \t\t\t     next_insn ? INSN_UID (next_insn) : 999999, 0, 3);"}, {"sha": "6abcd40cdbbb422b4a81a59f6836dc5452aef71e", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1363,7 +1363,7 @@ unlink_other_notes (rtx insn, rtx tail)\n {\n   rtx prev = PREV_INSN (insn);\n \n-  while (insn != tail && GET_CODE (insn) == NOTE)\n+  while (insn != tail && NOTE_P (insn))\n     {\n       rtx next = NEXT_INSN (insn);\n       /* Delete the note from its current position.  */\n@@ -1399,7 +1399,7 @@ unlink_line_notes (rtx insn, rtx tail)\n {\n   rtx prev = PREV_INSN (insn);\n \n-  while (insn != tail && GET_CODE (insn) == NOTE)\n+  while (insn != tail && NOTE_P (insn))\n     {\n       rtx next = NEXT_INSN (insn);\n \n@@ -1435,11 +1435,11 @@ get_block_head_tail (int b, rtx *headp, rtx *tailp)\n      basic block, or notes at the ends of basic blocks.  */\n   while (head != tail)\n     {\n-      if (GET_CODE (head) == NOTE)\n+      if (NOTE_P (head))\n \thead = NEXT_INSN (head);\n-      else if (GET_CODE (tail) == NOTE)\n+      else if (NOTE_P (tail))\n \ttail = PREV_INSN (tail);\n-      else if (GET_CODE (head) == CODE_LABEL)\n+      else if (LABEL_P (head))\n \thead = NEXT_INSN (head);\n       else\n \tbreak;\n@@ -1456,7 +1456,7 @@ no_real_insns_p (rtx head, rtx tail)\n {\n   while (head != NEXT_INSN (tail))\n     {\n-      if (GET_CODE (head) != NOTE && GET_CODE (head) != CODE_LABEL)\n+      if (!NOTE_P (head) && !LABEL_P (head))\n \treturn 0;\n       head = NEXT_INSN (head);\n     }\n@@ -1481,7 +1481,7 @@ rm_line_notes (rtx head, rtx tail)\n       /* Farm out notes, and maybe save them in NOTE_LIST.\n          This is needed to keep the debugger from\n          getting completely deranged.  */\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \t{\n \t  prev = insn;\n \t  insn = unlink_line_notes (insn, next_tail);\n@@ -1515,7 +1515,7 @@ save_line_notes (int b, rtx head, rtx tail)\n   next_tail = NEXT_INSN (tail);\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n       line = insn;\n     else\n       LINE_NOTE (insn) = line;\n@@ -1542,19 +1542,19 @@ restore_line_notes (rtx head, rtx tail)\n      of this block.  If it happens to be the same, then we don't want to\n      emit another line number note here.  */\n   for (line = head; line; line = PREV_INSN (line))\n-    if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n+    if (NOTE_P (line) && NOTE_LINE_NUMBER (line) > 0)\n       break;\n \n   /* Walk the insns keeping track of the current line-number and inserting\n      the line-number notes as needed.  */\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n       line = insn;\n   /* This used to emit line number notes before every non-deleted note.\n      However, this confuses a debugger, because line notes not separated\n      by real instructions all end up at the same address.  I can find no\n      use for line number notes before other notes, so none are emitted.  */\n-    else if (GET_CODE (insn) != NOTE\n+    else if (!NOTE_P (insn)\n \t     && INSN_UID (insn) < old_max_uid\n \t     && (note = LINE_NOTE (insn)) != 0\n \t     && note != line\n@@ -1606,7 +1606,7 @@ rm_redundant_line_notes (void)\n      are already present.  The remainder tend to occur at basic\n      block boundaries.  */\n   for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-    if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+    if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n       {\n \t/* If there are no active insns following, INSN is redundant.  */\n \tif (active_insn == 0)\n@@ -1632,9 +1632,9 @@ rm_redundant_line_notes (void)\n \t  line = insn;\n \tactive_insn = 0;\n       }\n-    else if (!((GET_CODE (insn) == NOTE\n+    else if (!((NOTE_P (insn)\n \t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n-\t       || (GET_CODE (insn) == INSN\n+\t       || (NONJUMP_INSN_P (insn)\n \t\t   && (GET_CODE (PATTERN (insn)) == USE\n \t\t       || GET_CODE (PATTERN (insn)) == CLOBBER))))\n       active_insn++;\n@@ -1664,7 +1664,7 @@ rm_other_notes (rtx head, rtx tail)\n       /* Farm out notes, and maybe save them in NOTE_LIST.\n          This is needed to keep the debugger from\n          getting completely deranged.  */\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \t{\n \t  prev = insn;\n \n@@ -1849,7 +1849,7 @@ ok_for_early_queue_removal (rtx insn)\n \t      rtx dep_link = 0;\n \t      int dep_cost;\n \n-\t      if (GET_CODE (prev_insn) != NOTE)\n+\t      if (!NOTE_P (prev_insn))\n \t\t{\n \t\t  dep_link = find_insn_list (insn, INSN_DEPEND (prev_insn));\n \t\t  if (dep_link)\n@@ -2705,7 +2705,7 @@ set_priorities (rtx head, rtx tail)\n   sched_max_insns_priority = 0;\n   for (insn = tail; insn != prev_head; insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \tcontinue;\n \n       n_insn++;\n@@ -2799,7 +2799,7 @@ sched_init (FILE *dump_file)\n \t   schedule differently depending on whether or not there are\n \t   line-number notes, i.e., depending on whether or not we're\n \t   generating debugging information.  */\n-\tif (GET_CODE (insn) != NOTE)\n+\tif (!NOTE_P (insn))\n \t  ++luid;\n \n \tif (insn == BB_END (b))\n@@ -2825,7 +2825,7 @@ sched_init (FILE *dump_file)\n       FOR_EACH_BB (b)\n \t{\n \t  for (line = BB_HEAD (b); line; line = PREV_INSN (line))\n-\t    if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n+\t    if (NOTE_P (line) && NOTE_LINE_NUMBER (line) > 0)\n \t      {\n \t\tline_note_head[b->index] = line;\n \t\tbreak;\n@@ -2836,7 +2836,7 @@ sched_init (FILE *dump_file)\n \t    {\n \t      if (INSN_P (line))\n \t\tbreak;\n-\t      if (GET_CODE (line) == NOTE && NOTE_LINE_NUMBER (line) > 0)\n+\t      if (NOTE_P (line) && NOTE_LINE_NUMBER (line) > 0)\n \t\tline_note_head[b->index] = line;\n \t    }\n \t}\n@@ -2853,10 +2853,10 @@ sched_init (FILE *dump_file)\n \n   insn = BB_END (EXIT_BLOCK_PTR->prev_bb);\n   if (NEXT_INSN (insn) == 0\n-      || (GET_CODE (insn) != NOTE\n-\t  && GET_CODE (insn) != CODE_LABEL\n+      || (!NOTE_P (insn)\n+\t  && !LABEL_P (insn)\n \t  /* Don't emit a NOTE if it would end up before a BARRIER.  */\n-\t  && GET_CODE (NEXT_INSN (insn)) != BARRIER))\n+\t  && !BARRIER_P (NEXT_INSN (insn))))\n     {\n       emit_note_after (NOTE_INSN_DELETED, BB_END (EXIT_BLOCK_PTR->prev_bb));\n       /* Make insn to appear outside BB.  */"}, {"sha": "86774e45e07d2efc42d6dfdf6759b319f6ab1f44", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -150,7 +150,7 @@ count_bb_insns (basic_block bb)\n \n   while (1)\n     {\n-      if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == INSN)\n+      if (CALL_P (insn) || NONJUMP_INSN_P (insn))\n \tcount++;\n \n       if (insn == BB_END (bb))\n@@ -189,21 +189,21 @@ first_active_insn (basic_block bb)\n {\n   rtx insn = BB_HEAD (bb);\n \n-  if (GET_CODE (insn) == CODE_LABEL)\n+  if (LABEL_P (insn))\n     {\n       if (insn == BB_END (bb))\n \treturn NULL_RTX;\n       insn = NEXT_INSN (insn);\n     }\n \n-  while (GET_CODE (insn) == NOTE)\n+  while (NOTE_P (insn))\n     {\n       if (insn == BB_END (bb))\n \treturn NULL_RTX;\n       insn = NEXT_INSN (insn);\n     }\n \n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     return NULL_RTX;\n \n   return insn;\n@@ -217,18 +217,18 @@ last_active_insn (basic_block bb, int skip_use_p)\n   rtx insn = BB_END (bb);\n   rtx head = BB_HEAD (bb);\n \n-  while (GET_CODE (insn) == NOTE\n-\t || GET_CODE (insn) == JUMP_INSN\n+  while (NOTE_P (insn)\n+\t || JUMP_P (insn)\n \t || (skip_use_p\n-\t     && GET_CODE (insn) == INSN\n+\t     && NONJUMP_INSN_P (insn)\n \t     && GET_CODE (PATTERN (insn)) == USE))\n     {\n       if (insn == head)\n \treturn NULL_RTX;\n       insn = PREV_INSN (insn);\n     }\n \n-  if (GET_CODE (insn) == CODE_LABEL)\n+  if (LABEL_P (insn))\n     return NULL_RTX;\n \n   return insn;\n@@ -271,10 +271,10 @@ cond_exec_process_insns (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n \n   for (insn = start; ; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \tgoto insn_done;\n \n-      if (GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n+      if (!NONJUMP_INSN_P (insn) && !CALL_P (insn))\n \tabort ();\n \n       /* Remove USE insns that get in the way.  */\n@@ -326,7 +326,7 @@ cond_exec_process_insns (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n \n       validate_change (insn, &PATTERN (insn), pattern, 1);\n \n-      if (GET_CODE (insn) == CALL_INSN && prob_val)\n+      if (CALL_P (insn) && prob_val)\n \tvalidate_change (insn, &REG_NOTES (insn),\n \t\t\t alloc_EXPR_LIST (REG_BR_PROB, prob_val,\n \t\t\t\t\t  REG_NOTES (insn)), 1);\n@@ -726,7 +726,7 @@ end_ifcvt_sequence (struct noce_if_info *if_info)\n      As an exercise for the reader, build a general mechanism that\n      allows proper placement of required clobbers.  */\n   for (insn = seq; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == JUMP_INSN\n+    if (JUMP_P (insn)\n \t|| recog_memoized (insn) == -1)\n       return NULL_RTX;\n \n@@ -1959,7 +1959,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n \t COND_EARLIEST to JUMP.  Make sure the relevant data is still\n \t intact.  */\n       if (! insn_b\n-\t  || GET_CODE (insn_b) != INSN\n+\t  || !NONJUMP_INSN_P (insn_b)\n \t  || (set_b = single_set (insn_b)) == NULL_RTX\n \t  || ! rtx_equal_p (x, SET_DEST (set_b))\n \t  || reg_overlap_mentioned_p (x, SET_SRC (set_b))\n@@ -2231,7 +2231,7 @@ merge_if_block (struct ce_if_block * ce_info)\n \t{\n \t  if (find_reg_note (last, REG_NORETURN, NULL))\n \t    ;\n-\t  else if (GET_CODE (last) == INSN\n+\t  else if (NONJUMP_INSN_P (last)\n \t\t   && GET_CODE (PATTERN (last)) == TRAP_IF\n \t\t   && TRAP_CONDITION (PATTERN (last)) == const_true_rtx)\n \t    ;\n@@ -2241,10 +2241,10 @@ merge_if_block (struct ce_if_block * ce_info)\n \n       /* There should still be something at the end of the THEN or ELSE\n          blocks taking us to our final destination.  */\n-      else if (GET_CODE (last) == JUMP_INSN)\n+      else if (JUMP_P (last))\n \t;\n       else if (combo_bb->succ->dest == EXIT_BLOCK_PTR\n-\t       && GET_CODE (last) == CALL_INSN\n+\t       && CALL_P (last)\n \t       && SIBLING_CALL_P (last))\n \t;\n       else if ((combo_bb->succ->flags & EDGE_EH)\n@@ -2417,11 +2417,11 @@ block_jumps_and_fallthru_p (basic_block cur_bb, basic_block target_bb)\n \n   while (insn != NULL_RTX)\n     {\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \treturn -1;\n \n       if (INSN_P (insn)\n-\t  && GET_CODE (insn) != JUMP_INSN\n+\t  && !JUMP_P (insn)\n \t  && GET_CODE (PATTERN (insn)) != USE\n \t  && GET_CODE (PATTERN (insn)) != CLOBBER)\n \tn_insns++;\n@@ -2560,12 +2560,12 @@ find_if_block (struct ce_if_block * ce_info)\n \t  rtx last_insn = BB_END (then_bb);\n \n \t  while (last_insn\n-\t\t && GET_CODE (last_insn) == NOTE\n+\t\t && NOTE_P (last_insn)\n \t\t && last_insn != BB_HEAD (then_bb))\n \t    last_insn = PREV_INSN (last_insn);\n \n \t  if (last_insn\n-\t      && GET_CODE (last_insn) == JUMP_INSN\n+\t      && JUMP_P (last_insn)\n \t      && ! simplejump_p (last_insn))\n \t    return FALSE;\n \n@@ -3050,9 +3050,9 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   head = BB_HEAD (merge_bb);\n   end = BB_END (merge_bb);\n \n-  if (GET_CODE (head) == CODE_LABEL)\n+  if (LABEL_P (head))\n     head = NEXT_INSN (head);\n-  if (GET_CODE (head) == NOTE)\n+  if (NOTE_P (head))\n     {\n       if (head == end)\n \t{\n@@ -3062,7 +3062,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       head = NEXT_INSN (head);\n     }\n \n-  if (GET_CODE (end) == JUMP_INSN)\n+  if (JUMP_P (end))\n     {\n       if (head == end)\n \t{\n@@ -3126,7 +3126,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       /* Check for no calls or trapping operations.  */\n       for (insn = head; ; insn = NEXT_INSN (insn))\n \t{\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    return FALSE;\n \t  if (INSN_P (insn))\n \t    {"}, {"sha": "bd96be800821a6b84b75f7f453906ed7888f935e", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -636,7 +636,7 @@ try_constants (rtx insn, struct inline_remap *map)\n \n   /* Enforce consistency between the addresses in the regular insn flow\n      and the ones in CALL_INSN_FUNCTION_USAGE lists, if any.  */\n-  if (GET_CODE (insn) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (insn))\n+  if (CALL_P (insn) && CALL_INSN_FUNCTION_USAGE (insn))\n     {\n       subst_constants (&CALL_INSN_FUNCTION_USAGE (insn), insn, map, 1);\n       apply_change_group ();"}, {"sha": "8cd9da230099f1bd98aa77ed1e29e77a6f06e792", "filename": "gcc/jump.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -90,7 +90,7 @@ rebuild_jump_labels (rtx f)\n      count doesn't drop to zero.  */\n \n   for (insn = forced_labels; insn; insn = XEXP (insn, 1))\n-    if (GET_CODE (XEXP (insn, 0)) == CODE_LABEL)\n+    if (LABEL_P (XEXP (insn, 0)))\n       LABEL_NUSES (XEXP (insn, 0))++;\n   timevar_pop (TV_REBUILD_JUMP);\n }\n@@ -110,10 +110,10 @@ cleanup_barriers (void)\n   for (insn = get_insns (); insn; insn = next)\n     {\n       next = NEXT_INSN (insn);\n-      if (GET_CODE (insn) == BARRIER)\n+      if (BARRIER_P (insn))\n \t{\n \t  prev = prev_nonnote_insn (insn);\n-\t  if (GET_CODE (prev) == BARRIER)\n+\t  if (BARRIER_P (prev))\n \t    delete_barrier (insn);\n \t  else if (prev != PREV_INSN (insn))\n \t    reorder_insns (insn, insn, prev);\n@@ -132,7 +132,7 @@ purge_line_number_notes (rtx f)\n      even if it became empty.  */\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == NOTE)\n+    if (NOTE_P (insn))\n       {\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n \t  /* Any previous line note was for the prologue; gdb wants a new\n@@ -168,11 +168,11 @@ init_label_info (rtx f)\n   rtx insn;\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CODE_LABEL)\n+    if (LABEL_P (insn))\n       LABEL_NUSES (insn) = (LABEL_PRESERVE_P (insn) != 0);\n-    else if (GET_CODE (insn) == JUMP_INSN)\n+    else if (JUMP_P (insn))\n       JUMP_LABEL (insn) = 0;\n-    else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+    else if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n       {\n \trtx note, next;\n \n@@ -198,7 +198,7 @@ mark_all_labels (rtx f)\n     if (INSN_P (insn))\n       {\n \tmark_jump_label (PATTERN (insn), insn, 0);\n-\tif (! INSN_DELETED_P (insn) && GET_CODE (insn) == JUMP_INSN)\n+\tif (! INSN_DELETED_P (insn) && JUMP_P (insn))\n \t  {\n \t    /* When we know the LABEL_REF contained in a REG used in\n \t       an indirect jump, we'll have a REG_LABEL note so that\n@@ -242,7 +242,7 @@ squeeze_notes (rtx* startp, rtx* endp)\n   for (insn = start; insn != past_end; insn = next)\n     {\n       next = NEXT_INSN (insn);\n-      if (GET_CODE (insn) == NOTE\n+      if (NOTE_P (insn)\n \t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n@@ -289,7 +289,7 @@ get_label_before (rtx insn)\n      or make a new one if there is none.  */\n   label = prev_nonnote_insn (insn);\n \n-  if (label == 0 || GET_CODE (label) != CODE_LABEL)\n+  if (label == 0 || !LABEL_P (label))\n     {\n       rtx prev = PREV_INSN (insn);\n \n@@ -311,7 +311,7 @@ get_label_after (rtx insn)\n      or make a new one if there is none.  */\n   label = next_nonnote_insn (insn);\n \n-  if (label == 0 || GET_CODE (label) != CODE_LABEL)\n+  if (label == 0 || !LABEL_P (label))\n     {\n       label = gen_label_rtx ();\n       emit_label_after (label, insn);\n@@ -393,7 +393,7 @@ reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn\n \treturn UNKNOWN;\n \n       for (prev = prev_nonnote_insn (insn);\n-\t   prev != 0 && GET_CODE (prev) != CODE_LABEL;\n+\t   prev != 0 && !LABEL_P (prev);\n \t   prev = prev_nonnote_insn (prev))\n \t{\n \t  rtx set = set_of (arg0, prev);\n@@ -736,7 +736,7 @@ comparison_dominates_p (enum rtx_code code1, enum rtx_code code2)\n int\n simplejump_p (rtx insn)\n {\n-  return (GET_CODE (insn) == JUMP_INSN\n+  return (JUMP_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && GET_CODE (SET_DEST (PATTERN (insn))) == PC\n \t  && GET_CODE (SET_SRC (PATTERN (insn))) == LABEL_REF);\n@@ -813,7 +813,7 @@ rtx\n pc_set (rtx insn)\n {\n   rtx pat;\n-  if (GET_CODE (insn) != JUMP_INSN)\n+  if (!JUMP_P (insn))\n     return NULL_RTX;\n   pat = PATTERN (insn);\n \n@@ -903,7 +903,7 @@ returnjump_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n int\n returnjump_p (rtx insn)\n {\n-  if (GET_CODE (insn) != JUMP_INSN)\n+  if (!JUMP_P (insn))\n     return 0;\n   return for_each_rtx (&PATTERN (insn), returnjump_p_1, NULL);\n }\n@@ -916,7 +916,7 @@ onlyjump_p (rtx insn)\n {\n   rtx set;\n \n-  if (GET_CODE (insn) != JUMP_INSN)\n+  if (!JUMP_P (insn))\n     return 0;\n \n   set = single_set (insn);\n@@ -1003,12 +1003,12 @@ follow_jumps (rtx label)\n   for (depth = 0;\n        (depth < 10\n \t&& (insn = next_active_insn (value)) != 0\n-\t&& GET_CODE (insn) == JUMP_INSN\n+\t&& JUMP_P (insn)\n \t&& ((JUMP_LABEL (insn) != 0 && any_uncondjump_p (insn)\n \t     && onlyjump_p (insn))\n \t    || GET_CODE (PATTERN (insn)) == RETURN)\n \t&& (next = NEXT_INSN (insn))\n-\t&& GET_CODE (next) == BARRIER);\n+\t&& BARRIER_P (next));\n        depth++)\n     {\n       /* Don't chain through the insn that jumps into a loop\n@@ -1018,7 +1018,7 @@ follow_jumps (rtx label)\n       rtx tem;\n       if (!reload_completed)\n \tfor (tem = value; tem != insn; tem = NEXT_INSN (tem))\n-\t  if (GET_CODE (tem) == NOTE\n+\t  if (NOTE_P (tem)\n \t      && (NOTE_LINE_NUMBER (tem) == NOTE_INSN_LOOP_BEG\n \t\t  /* ??? Optional.  Disables some optimizations, but makes\n \t\t     gcov output more accurate with -O.  */\n@@ -1092,11 +1092,11 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n \n \t/* Ignore remaining references to unreachable labels that\n \t   have been deleted.  */\n-\tif (GET_CODE (label) == NOTE\n+\tif (NOTE_P (label)\n \t    && NOTE_LINE_NUMBER (label) == NOTE_INSN_DELETED_LABEL)\n \t  break;\n \n-\tif (GET_CODE (label) != CODE_LABEL)\n+\tif (!LABEL_P (label))\n \t  abort ();\n \n \t/* Ignore references to labels of containing functions.  */\n@@ -1109,7 +1109,7 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n \n \tif (insn)\n \t  {\n-\t    if (GET_CODE (insn) == JUMP_INSN)\n+\t    if (JUMP_P (insn))\n \t      JUMP_LABEL (insn) = label;\n \t    else\n \t      {\n@@ -1174,7 +1174,7 @@ delete_jump (rtx insn)\n void\n delete_barrier (rtx insn)\n {\n-  if (GET_CODE (insn) != BARRIER)\n+  if (!BARRIER_P (insn))\n     abort ();\n \n   delete_insn (insn);\n@@ -1191,15 +1191,15 @@ delete_prior_computation (rtx note, rtx insn)\n   rtx reg = XEXP (note, 0);\n \n   for (our_prev = prev_nonnote_insn (insn);\n-       our_prev && (GET_CODE (our_prev) == INSN\n-\t\t    || GET_CODE (our_prev) == CALL_INSN);\n+       our_prev && (NONJUMP_INSN_P (our_prev)\n+\t\t    || CALL_P (our_prev));\n        our_prev = prev_nonnote_insn (our_prev))\n     {\n       rtx pat = PATTERN (our_prev);\n \n       /* If we reach a CALL which is not calling a const function\n \t or the callee pops the arguments, then give up.  */\n-      if (GET_CODE (our_prev) == CALL_INSN\n+      if (CALL_P (our_prev)\n \t  && (! CONST_OR_PURE_CALL_P (our_prev)\n \t      || GET_CODE (pat) != SET || GET_CODE (SET_SRC (pat)) != CALL))\n \tbreak;\n@@ -1212,14 +1212,14 @@ delete_prior_computation (rtx note, rtx insn)\n \tbreak;\n \n       if (GET_CODE (pat) == USE\n-\t  && GET_CODE (XEXP (pat, 0)) == INSN)\n+\t  && NONJUMP_INSN_P (XEXP (pat, 0)))\n \t/* reorg creates USEs that look like this.  We leave them\n \t   alone because reorg needs them for its own purposes.  */\n \tbreak;\n \n       if (reg_set_p (reg, pat))\n \t{\n-\t  if (side_effects_p (pat) && GET_CODE (our_prev) != CALL_INSN)\n+\t  if (side_effects_p (pat) && !CALL_P (our_prev))\n \t    break;\n \n \t  if (GET_CODE (pat) == PARALLEL)\n@@ -1325,7 +1325,7 @@ delete_computation (rtx insn)\n \t will use them.  So if the previous insn\n \t exists to set the CC's, delete it\n \t (unless it performs auto-increments, etc.).  */\n-      if (prev && GET_CODE (prev) == INSN\n+      if (prev && NONJUMP_INSN_P (prev)\n \t  && sets_cc0_p (PATTERN (prev)))\n \t{\n \t  if (sets_cc0_p (PATTERN (prev)) > 0\n@@ -1365,7 +1365,7 @@ delete_computation (rtx insn)\n rtx\n delete_related_insns (rtx insn)\n {\n-  int was_code_label = (GET_CODE (insn) == CODE_LABEL);\n+  int was_code_label = (LABEL_P (insn));\n   rtx note;\n   rtx next = NEXT_INSN (insn), prev = PREV_INSN (insn);\n \n@@ -1381,13 +1381,13 @@ delete_related_insns (rtx insn)\n   /* If instruction is followed by a barrier,\n      delete the barrier too.  */\n \n-  if (next != 0 && GET_CODE (next) == BARRIER)\n+  if (next != 0 && BARRIER_P (next))\n     delete_insn (next);\n \n   /* If deleting a jump, decrement the count of the label,\n      and delete the label if it is now unused.  */\n \n-  if (GET_CODE (insn) == JUMP_INSN && JUMP_LABEL (insn))\n+  if (JUMP_P (insn) && JUMP_LABEL (insn))\n     {\n       rtx lab = JUMP_LABEL (insn), lab_next;\n \n@@ -1418,7 +1418,7 @@ delete_related_insns (rtx insn)\n \n   /* Likewise if we're deleting a dispatch table.  */\n \n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n     {\n@@ -1435,15 +1435,15 @@ delete_related_insns (rtx insn)\n     }\n \n   /* Likewise for an ordinary INSN / CALL_INSN with a REG_LABEL note.  */\n-  if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+  if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n     for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n       if (REG_NOTE_KIND (note) == REG_LABEL\n \t  /* This could also be a NOTE_INSN_DELETED_LABEL note.  */\n-\t  && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n+\t  && LABEL_P (XEXP (note, 0)))\n \tif (LABEL_NUSES (XEXP (note, 0)) == 0)\n \t  delete_related_insns (XEXP (note, 0));\n \n-  while (prev && (INSN_DELETED_P (prev) || GET_CODE (prev) == NOTE))\n+  while (prev && (INSN_DELETED_P (prev) || NOTE_P (prev)))\n     prev = PREV_INSN (prev);\n \n   /* If INSN was a label and a dispatch table follows it,\n@@ -1452,14 +1452,14 @@ delete_related_insns (rtx insn)\n \n   if (was_code_label\n       && NEXT_INSN (insn) != 0\n-      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+      && JUMP_P (NEXT_INSN (insn))\n       && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n \t  || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n     next = delete_related_insns (NEXT_INSN (insn));\n \n   /* If INSN was a label, delete insns following it if now unreachable.  */\n \n-  if (was_code_label && prev && GET_CODE (prev) == BARRIER)\n+  if (was_code_label && prev && BARRIER_P (prev))\n     {\n       enum rtx_code code;\n       while (next)\n@@ -1500,7 +1500,7 @@ delete_for_peephole (rtx from, rtx to)\n       rtx next = NEXT_INSN (insn);\n       rtx prev = PREV_INSN (insn);\n \n-      if (GET_CODE (insn) != NOTE)\n+      if (!NOTE_P (insn))\n \t{\n \t  INSN_DELETED_P (insn) = 1;\n \n@@ -1672,7 +1672,7 @@ redirect_jump (rtx jump, rtx nlabel, int delete_unused)\n      function, move the function end note so that -Wreturn-type works.  */\n   if (olabel && nlabel\n       && NEXT_INSN (olabel)\n-      && GET_CODE (NEXT_INSN (olabel)) == NOTE\n+      && NOTE_P (NEXT_INSN (olabel))\n       && NOTE_LINE_NUMBER (NEXT_INSN (olabel)) == NOTE_INSN_FUNCTION_END)\n     emit_note_after (NOTE_INSN_FUNCTION_END, nlabel);\n "}, {"sha": "5062356c39b07754749081f5aacb7b307cb8e772", "filename": "gcc/lcm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1201,7 +1201,7 @@ optimize_mode_switching (FILE *file)\n \t      if (eg->flags & EDGE_ABNORMAL)\n \t\t{\n \t\t  emited = true;\n-\t\t  if (GET_CODE (BB_END (src_bb)) == JUMP_INSN)\n+\t\t  if (JUMP_P (BB_END (src_bb)))\n \t\t    emit_insn_before (mode_set, BB_END (src_bb));\n \t\t  /* It doesn't make sense to switch to normal mode\n \t\t     after a CALL_INSN, so we're going to abort if we\n@@ -1214,7 +1214,7 @@ optimize_mode_switching (FILE *file)\n \t\t     the call (it wouldn't make sense, anyway).  In\n \t\t     the case of EH edges, EH entry points also start\n \t\t     in normal mode, so a similar reasoning applies.  */\n-\t\t  else if (GET_CODE (BB_END (src_bb)) == INSN)\n+\t\t  else if (NONJUMP_INSN_P (BB_END (src_bb)))\n \t\t    emit_insn_after (mode_set, BB_END (src_bb));\n \t\t  else\n \t\t    abort ();\n@@ -1266,7 +1266,7 @@ optimize_mode_switching (FILE *file)\n \t\t    continue;\n \n \t\t  emited = true;\n-\t\t  if (GET_CODE (ptr->insn_ptr) == NOTE\n+\t\t  if (NOTE_P (ptr->insn_ptr)\n \t\t      && (NOTE_LINE_NUMBER (ptr->insn_ptr)\n \t\t\t  == NOTE_INSN_BASIC_BLOCK))\n \t\t    emit_insn_after (mode_set, ptr->insn_ptr);"}, {"sha": "a9cf8e7b52408d4f8e74c9733c0b40d008a34043", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -484,7 +484,7 @@ validate_equiv_mem (rtx start, rtx reg, rtx memref)\n       if (find_reg_note (insn, REG_DEAD, reg))\n \treturn 1;\n \n-      if (GET_CODE (insn) == CALL_INSN && ! RTX_UNCHANGING_P (memref)\n+      if (CALL_P (insn) && ! RTX_UNCHANGING_P (memref)\n \t  && ! CONST_OR_PURE_CALL_P (insn))\n \treturn 0;\n \n@@ -985,7 +985,7 @@ update_equiv_regs (void)\n \t\t    if (REG_N_REFS (regno) == 2\n \t\t\t&& (rtx_equal_p (XEXP (note, 0), src)\n \t\t\t    || ! equiv_init_varies_p (src))\n-\t\t\t&& GET_CODE (insn) == INSN\n+\t\t\t&& NONJUMP_INSN_P (insn)\n \t\t\t&& equiv_init_movable_p (PATTERN (insn), regno))\n \t\t      reg_equiv[regno].replace = 1;\n \t\t}\n@@ -1190,7 +1190,7 @@ block_alloc (int b)\n   insn = BB_END (BASIC_BLOCK (b));\n   while (1)\n     {\n-      if (GET_CODE (insn) != NOTE)\n+      if (!NOTE_P (insn))\n \tif (++insn_count > max_uid)\n \t  abort ();\n       if (insn == BB_HEAD (BASIC_BLOCK (b)))\n@@ -1213,7 +1213,7 @@ block_alloc (int b)\n   insn = BB_HEAD (BASIC_BLOCK (b));\n   while (1)\n     {\n-      if (GET_CODE (insn) != NOTE)\n+      if (!NOTE_P (insn))\n \tinsn_number++;\n \n       if (INSN_P (insn))\n@@ -1353,7 +1353,7 @@ block_alloc (int b)\n \t\t  REG_P (r0))\n \t      && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n \t      && XEXP (link, 0) != 0\n-\t      && GET_CODE (XEXP (link, 0)) == INSN\n+\t      && NONJUMP_INSN_P (XEXP (link, 0))\n \t      && (set = single_set (XEXP (link, 0))) != 0\n \t      && SET_DEST (set) == r0 && SET_SRC (set) == r0\n \t      && (note = find_reg_note (XEXP (link, 0), REG_EQUAL,\n@@ -1428,7 +1428,7 @@ block_alloc (int b)\n \t     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT\n \t     block, so clear any register number that combined within it.  */\n \t  if ((note = find_reg_note (insn, REG_RETVAL, NULL_RTX)) != 0\n-\t      && GET_CODE (XEXP (note, 0)) == INSN\n+\t      && NONJUMP_INSN_P (XEXP (note, 0))\n \t      && GET_CODE (PATTERN (XEXP (note, 0))) == CLOBBER)\n \t    no_conflict_combined_regno = -1;\n \t}"}, {"sha": "e463eeab89963488dcade1c7276ef66150f5b9f9", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -189,7 +189,7 @@ doloop_valid_p (struct loop *loop, struct niter_desc *desc)\n \t{\n \t  /* A called function may clobber any special registers required for\n \t     low-overhead looping.  */\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Doloop: Function call in loop.\\n\");\n@@ -199,7 +199,7 @@ doloop_valid_p (struct loop *loop, struct niter_desc *desc)\n \n \t  /* Some targets (eg, PPC) use the count register for branch on table\n \t     instructions.  ??? This should be a target specific check.  */\n-\t  if (GET_CODE (insn) == JUMP_INSN\n+\t  if (JUMP_P (insn)\n \t      && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n \t    {\n@@ -514,7 +514,7 @@ doloop_optimize (struct loop *loop)\n     {\n       while (NEXT_INSN (doloop_pat) != NULL_RTX)\n \tdoloop_pat = NEXT_INSN (doloop_pat);\n-      if (GET_CODE (doloop_pat) == JUMP_INSN)\n+      if (JUMP_P (doloop_pat))\n \tdoloop_pat = PATTERN (doloop_pat);\n       else\n \tdoloop_pat = NULL_RTX;"}, {"sha": "9891c23087c763c6755afccf591f79d06c28f4a1", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -230,7 +230,7 @@ find_exits (struct loop *loop, basic_block *body,\n \t{\n \t  FOR_BB_INSNS (body[i], insn)\n \t    {\n-\t      if (GET_CODE (insn) == CALL_INSN\n+\t      if (CALL_P (insn)\n \t\t  && !CONST_OR_PURE_CALL_P (insn))\n \t\t{\n \t\t  has_call = true;\n@@ -525,7 +525,7 @@ find_invariants_bb (basic_block bb, bool always_reached, bool always_executed,\n       find_invariants_insn (insn, always_reached, always_executed, df);\n \n       if (always_reached\n-\t  && GET_CODE (insn) == CALL_INSN\n+\t  && CALL_P (insn)\n \t  && !CONST_OR_PURE_CALL_P (insn))\n \talways_reached = false;\n     }"}, {"sha": "965359c5931a30ead1c66d6c4b38b53f24da2685", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1371,7 +1371,7 @@ simplify_using_assignment (rtx insn, rtx *expr, regset altered)\n     ret = true;\n \n   note_stores (PATTERN (insn), mark_altered, altered);\n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       int i;\n "}, {"sha": "97d15710c15aaf1e0d923dcbebd076f83baa85d2", "filename": "gcc/loop.c", "status": "modified", "additions": 104, "deletions": 109, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -419,7 +419,7 @@ compute_luids (rtx start, rtx end, int prev_luid)\n \tcontinue;\n       /* Don't assign luids to line-number NOTEs, so that the distance in\n \t luids between two insns is not affected by -g.  */\n-      if (GET_CODE (insn) != NOTE\n+      if (!NOTE_P (insn)\n \t  || NOTE_LINE_NUMBER (insn) <= 0)\n \tuid_luid[INSN_UID (insn)] = ++i;\n       else\n@@ -457,7 +457,7 @@ loop_optimize (rtx f, FILE *dumpfile, int flags)\n   max_loop_num = 0;\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE\n+      if (NOTE_P (insn)\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \tmax_loop_num++;\n     }\n@@ -671,8 +671,8 @@ scan_loop (struct loop *loop, int flags)\n \n   for (p = NEXT_INSN (loop_start);\n        p != loop_end\n-\t && GET_CODE (p) != CODE_LABEL && ! INSN_P (p)\n-\t && (GET_CODE (p) != NOTE\n+\t && !LABEL_P (p) && ! INSN_P (p)\n+\t && (!NOTE_P (p)\n \t     || (NOTE_LINE_NUMBER (p) != NOTE_INSN_LOOP_BEG\n \t\t && NOTE_LINE_NUMBER (p) != NOTE_INSN_LOOP_END));\n        p = NEXT_INSN (p))\n@@ -698,7 +698,7 @@ scan_loop (struct loop *loop, int flags)\n      Start scan from there.\n      But record in LOOP->TOP the place where the end-test jumps\n      back to so we can scan that after the end of the loop.  */\n-  if (GET_CODE (p) == JUMP_INSN\n+  if (JUMP_P (p)\n       /* Loop entry must be unconditional jump (and not a RETURN)  */\n       && any_uncondjump_p (p)\n       && JUMP_LABEL (p) != 0\n@@ -723,7 +723,7 @@ scan_loop (struct loop *loop, int flags)\n      test above.  */\n \n   if (INSN_UID (loop->scan_start) >= max_uid_for_loop\n-      || GET_CODE (loop->scan_start) != CODE_LABEL)\n+      || !LABEL_P (loop->scan_start))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"\\nLoop from %d to %d is phony.\\n\\n\",\n@@ -765,7 +765,7 @@ scan_loop (struct loop *loop, int flags)\n     {\n       if (in_libcall && INSN_P (p) && find_reg_note (p, REG_RETVAL, NULL_RTX))\n \tin_libcall--;\n-      if (GET_CODE (p) == INSN)\n+      if (NONJUMP_INSN_P (p))\n \t{\n \t  temp = find_reg_note (p, REG_LIBCALL, NULL_RTX);\n \t  if (temp)\n@@ -1032,7 +1032,7 @@ scan_loop (struct loop *loop, int flags)\n \t\t Also, if the value loaded into the register\n \t\t depends on the same register, this cannot be done.  */\n \t      else if (SET_SRC (set) == const0_rtx\n-\t\t       && GET_CODE (NEXT_INSN (p)) == INSN\n+\t\t       && NONJUMP_INSN_P (NEXT_INSN (p))\n \t\t       && (set1 = single_set (NEXT_INSN (p)))\n \t\t       && GET_CODE (set1) == SET\n \t\t       && (GET_CODE (SET_DEST (set1)) == STRICT_LOW_PART)\n@@ -1102,25 +1102,25 @@ scan_loop (struct loop *loop, int flags)\n       /* Past a call insn, we get to insns which might not be executed\n \t because the call might exit.  This matters for insns that trap.\n \t Constant and pure call insns always return, so they don't count.  */\n-      else if (GET_CODE (p) == CALL_INSN && ! CONST_OR_PURE_CALL_P (p))\n+      else if (CALL_P (p) && ! CONST_OR_PURE_CALL_P (p))\n \tcall_passed = 1;\n       /* Past a label or a jump, we get to insns for which we\n \t can't count on whether or how many times they will be\n \t executed during each iteration.  Therefore, we can\n \t only move out sets of trivial variables\n \t (those not used after the loop).  */\n       /* Similar code appears twice in strength_reduce.  */\n-      else if ((GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN)\n+      else if ((LABEL_P (p) || JUMP_P (p))\n \t       /* If we enter the loop in the middle, and scan around to the\n \t\t  beginning, don't set maybe_never for that.  This must be an\n \t\t  unconditional jump, otherwise the code at the top of the\n \t\t  loop might never be executed.  Unconditional jumps are\n \t\t  followed by a barrier then the loop_end.  */\n-\t       && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop->top\n+\t       && ! (JUMP_P (p) && JUMP_LABEL (p) == loop->top\n \t\t     && NEXT_INSN (NEXT_INSN (p)) == loop_end\n \t\t     && any_uncondjump_p (p)))\n \tmaybe_never = 1;\n-      else if (GET_CODE (p) == NOTE)\n+      else if (NOTE_P (p))\n \t{\n \t  /* At the virtual top of a converted loop, insns are again known to\n \t     be executed: logically, the loop begins here even though the exit\n@@ -1171,7 +1171,7 @@ scan_loop (struct loop *loop, int flags)\n \t  loop_regs_scan (loop, 0);\n \t  for (update_start = loop_start;\n \t       PREV_INSN (update_start)\n-\t       && GET_CODE (PREV_INSN (update_start)) != CODE_LABEL;\n+\t       && !LABEL_P (PREV_INSN (update_start));\n \t       update_start = PREV_INSN (update_start))\n \t    ;\n \t  update_end = NEXT_INSN (loop_end);\n@@ -1198,7 +1198,7 @@ scan_loop (struct loop *loop, int flags)\n \n   for (update_start = loop_start;\n        PREV_INSN (update_start)\n-\t && GET_CODE (PREV_INSN (update_start)) != CODE_LABEL;\n+\t && !LABEL_P (PREV_INSN (update_start));\n        update_start = PREV_INSN (update_start))\n     ;\n   update_end = NEXT_INSN (loop_end);\n@@ -1208,7 +1208,7 @@ scan_loop (struct loop *loop, int flags)\n \n   if (flag_strength_reduce)\n     {\n-      if (update_end && GET_CODE (update_end) == CODE_LABEL)\n+      if (update_end && LABEL_P (update_end))\n \t/* Ensure our label doesn't go away.  */\n \tLABEL_NUSES (update_end)++;\n \n@@ -1217,7 +1217,7 @@ scan_loop (struct loop *loop, int flags)\n       reg_scan_update (update_start, update_end, loop_max_reg);\n       loop_max_reg = max_reg_num ();\n \n-      if (update_end && GET_CODE (update_end) == CODE_LABEL\n+      if (update_end && LABEL_P (update_end)\n \t  && --LABEL_NUSES (update_end) == 0)\n \tdelete_related_insns (update_end);\n     }\n@@ -1300,8 +1300,7 @@ libcall_other_reg (rtx insn, rtx equiv)\n \n   while (p != insn)\n     {\n-      if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n-\t  || GET_CODE (p) == CALL_INSN)\n+      if (INSN_P (p))\n \trecord_excess_regs (PATTERN (p), equiv, &output);\n       p = NEXT_INSN (p);\n     }\n@@ -1374,10 +1373,10 @@ libcall_benefit (rtx last)\n   for (insn = XEXP (find_reg_note (last, REG_RETVAL, NULL_RTX), 0);\n        insn != last; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \tbenefit += 10;\t\t/* Assume at least this many insns in a library\n \t\t\t\t   routine.  */\n-      else if (GET_CODE (insn) == INSN\n+      else if (NONJUMP_INSN_P (insn)\n \t       && GET_CODE (PATTERN (insn)) != USE\n \t       && GET_CODE (PATTERN (insn)) != CLOBBER)\n \tbenefit++;\n@@ -1398,13 +1397,13 @@ skip_consec_insns (rtx insn, int count)\n       /* If first insn of libcall sequence, skip to end.  */\n       /* Do this at start of loop, since INSN is guaranteed to\n \t be an insn here.  */\n-      if (GET_CODE (insn) != NOTE\n+      if (!NOTE_P (insn)\n \t  && (temp = find_reg_note (insn, REG_LIBCALL, NULL_RTX)))\n \tinsn = XEXP (temp, 0);\n \n       do\n \tinsn = NEXT_INSN (insn);\n-      while (GET_CODE (insn) == NOTE);\n+      while (NOTE_P (insn));\n     }\n \n   return insn;\n@@ -1962,14 +1961,14 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t    {\n \t\t      /* If this is the first insn of a library call sequence,\n \t\t\t something is very wrong.  */\n-\t\t      if (GET_CODE (p) != NOTE\n+\t\t      if (!NOTE_P (p)\n \t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n \t\t\tabort ();\n \n \t\t      /* If this is the last insn of a libcall sequence, then\n \t\t\t delete every insn in the sequence except the last.\n \t\t\t The last insn is handled in the normal manner.  */\n-\t\t      if (GET_CODE (p) != NOTE\n+\t\t      if (!NOTE_P (p)\n \t\t\t  && (temp = find_reg_note (p, REG_RETVAL, NULL_RTX)))\n \t\t\t{\n \t\t\t  temp = XEXP (temp, 0);\n@@ -1986,7 +1985,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t pointers, but when we skip over a NOTE we must fix\n \t\t\t it up.  Otherwise that code walks into the non-deleted\n \t\t\t insn stream.  */\n-\t\t      while (p && GET_CODE (p) == NOTE)\n+\t\t      while (p && NOTE_P (p))\n \t\t\tp = NEXT_INSN (temp) = NEXT_INSN (p);\n \n \t\t      if (m->insert_temp)\n@@ -2030,14 +2029,14 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t      /* If first insn of libcall sequence, skip to end.  */\n \t\t      /* Do this at start of loop, since p is guaranteed to\n \t\t\t be an insn here.  */\n-\t\t      if (GET_CODE (p) != NOTE\n+\t\t      if (!NOTE_P (p)\n \t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n \t\t\tp = XEXP (temp, 0);\n \n \t\t      /* If last insn of libcall sequence, move all\n \t\t\t insns except the last before the loop.  The last\n \t\t\t insn is handled in the normal manner.  */\n-\t\t      if (GET_CODE (p) != NOTE\n+\t\t      if (!NOTE_P (p)\n \t\t\t  && (temp = find_reg_note (p, REG_RETVAL, NULL_RTX)))\n \t\t\t{\n \t\t\t  rtx fn_address = 0;\n@@ -2052,7 +2051,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t      rtx n;\n \t\t\t      rtx next;\n \n-\t\t\t      if (GET_CODE (temp) == NOTE)\n+\t\t\t      if (NOTE_P (temp))\n \t\t\t\tcontinue;\n \n \t\t\t      body = PATTERN (temp);\n@@ -2061,9 +2060,9 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t\t not counting USE or NOTE insns.  */\n \t\t\t      for (next = NEXT_INSN (temp); next != p;\n \t\t\t\t   next = NEXT_INSN (next))\n-\t\t\t\tif (! (GET_CODE (next) == INSN\n+\t\t\t\tif (! (NONJUMP_INSN_P (next)\n \t\t\t\t       && GET_CODE (PATTERN (next)) == USE)\n-\t\t\t\t    && GET_CODE (next) != NOTE)\n+\t\t\t\t    && !NOTE_P (next))\n \t\t\t\t  break;\n \n \t\t\t      /* If that is the call, this may be the insn\n@@ -2077,7 +2076,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t\t function address into the register that the\n \t\t\t\t call insn will use.  flow.c will delete any\n \t\t\t\t redundant stores that we have created.  */\n-\t\t\t      if (GET_CODE (next) == CALL_INSN\n+\t\t\t      if (CALL_P (next)\n \t\t\t\t  && GET_CODE (body) == SET\n \t\t\t\t  && REG_P (SET_DEST (body))\n \t\t\t\t  && (n = find_reg_note (temp, REG_EQUAL,\n@@ -2092,14 +2091,14 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t      /* We have the call insn.\n \t\t\t\t If it uses the register we suspect it might,\n \t\t\t\t load it with the correct address directly.  */\n-\t\t\t      if (GET_CODE (temp) == CALL_INSN\n+\t\t\t      if (CALL_P (temp)\n \t\t\t\t  && fn_address != 0\n \t\t\t\t  && reg_referenced_p (fn_reg, body))\n \t\t\t\tloop_insn_emit_after (loop, 0, fn_address_insn,\n \t\t\t\t\t\t      gen_move_insn\n \t\t\t\t\t\t      (fn_reg, fn_address));\n \n-\t\t\t      if (GET_CODE (temp) == CALL_INSN)\n+\t\t\t      if (CALL_P (temp))\n \t\t\t\t{\n \t\t\t\t  i1 = loop_call_insn_hoist (loop, body);\n \t\t\t\t  /* Because the USAGE information potentially\n@@ -2146,7 +2145,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t  end_sequence ();\n \t\t\t  i1 = loop_insn_hoist (loop, sequence);\n \t\t\t}\n-\t\t      else if (GET_CODE (p) == CALL_INSN)\n+\t\t      else if (CALL_P (p))\n \t\t\t{\n \t\t\t  i1 = loop_call_insn_hoist (loop, PATTERN (p));\n \t\t\t  /* Because the USAGE information potentially\n@@ -2230,7 +2229,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t pointers, but when we skip over a NOTE we must fix\n \t\t\t it up.  Otherwise that code walks into the non-deleted\n \t\t\t insn stream.  */\n-\t\t      while (p && GET_CODE (p) == NOTE)\n+\t\t      while (p && NOTE_P (p))\n \t\t\tp = NEXT_INSN (temp) = NEXT_INSN (p);\n \n \t\t      if (m->insert_temp)\n@@ -2351,8 +2350,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n   /* Go through all the instructions in the loop, making\n      all the register substitutions scheduled in REG_MAP.  */\n   for (p = new_start; p != loop_end; p = NEXT_INSN (p))\n-    if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n-\t|| GET_CODE (p) == CALL_INSN)\n+    if (INSN_P (p))\n       {\n \treplace_regs (PATTERN (p), reg_map, nregs, 0);\n \treplace_regs (REG_NOTES (p), reg_map, nregs, 0);\n@@ -2542,10 +2540,10 @@ prescan_loop (struct loop *loop)\n   /* If loop opts run twice, this was set on 1st pass for 2nd.  */\n   loop_info->preconditioned = NOTE_PRECONDITIONED (end);\n \n-  for (insn = start; insn && GET_CODE (insn) != CODE_LABEL;\n+  for (insn = start; insn && !LABEL_P (insn);\n        insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  loop_info->pre_header_has_call = 1;\n \t  break;\n@@ -2662,7 +2660,7 @@ prescan_loop (struct loop *loop)\n \t  if (volatile_refs_p (PATTERN (insn)))\n \t    loop_info->has_volatile = 1;\n \n-\t  if (GET_CODE (insn) == JUMP_INSN\n+\t  if (JUMP_P (insn)\n \t      && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC))\n \t    loop_info->has_tablejump = 1;\n@@ -2756,7 +2754,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n   current_loop = NULL;\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \tswitch (NOTE_LINE_NUMBER (insn))\n \t  {\n \t  case NOTE_INSN_LOOP_BEG:\n@@ -2788,7 +2786,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t    break;\n \t  }\n \n-      if (GET_CODE (insn) == CALL_INSN\n+      if (CALL_P (insn)\n \t  && find_reg_note (insn, REG_SETJMP, NULL))\n \t{\n \t  /* In this case, we must invalidate our current loop and any\n@@ -2835,14 +2833,14 @@ find_and_verify_loops (rtx f, struct loops *loops)\n       {\n \tstruct loop *this_loop = uid_loop[INSN_UID (insn)];\n \n-\tif (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+\tif (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t  {\n \t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n \t    if (note)\n \t      invalidate_loops_containing_label (XEXP (note, 0));\n \t  }\n \n-\tif (GET_CODE (insn) != JUMP_INSN)\n+\tif (!JUMP_P (insn))\n \t  continue;\n \n \tmark_loop_jump (PATTERN (insn), this_loop);\n@@ -2865,10 +2863,10 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t    /* Go backwards until we reach the start of the loop, a label,\n \t       or a JUMP_INSN.  */\n \t    for (p = PREV_INSN (insn);\n-\t\t GET_CODE (p) != CODE_LABEL\n-\t\t && ! (GET_CODE (p) == NOTE\n+\t\t !LABEL_P (p)\n+\t\t && ! (NOTE_P (p)\n \t\t       && NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG)\n-\t\t && GET_CODE (p) != JUMP_INSN;\n+\t\t && !JUMP_P (p);\n \t\t p = PREV_INSN (p))\n \t      ;\n \n@@ -2889,7 +2887,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \n \t    /* Make sure that the target of P is within the current loop.  */\n \n-\t    if (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p)\n+\t    if (JUMP_P (p) && JUMP_LABEL (p)\n \t\t&& uid_loop[INSN_UID (JUMP_LABEL (p))] != this_loop)\n \t      outer_loop = this_loop;\n \n@@ -2903,7 +2901,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t       and move the block of code to the spot we found.  */\n \n \t    if (! outer_loop\n-\t\t&& GET_CODE (p) == JUMP_INSN\n+\t\t&& JUMP_P (p)\n \t\t&& JUMP_LABEL (p) != 0\n \t\t/* Just ignore jumps to labels that were never emitted.\n \t\t   These always indicate compilation errors.  */\n@@ -2924,30 +2922,30 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t\t/* Search for possible garbage past the conditional jumps\n \t\t   and look for the last barrier.  */\n \t\tfor (tmp = last_insn_to_move;\n-\t\t     tmp && GET_CODE (tmp) != CODE_LABEL; tmp = NEXT_INSN (tmp))\n-\t\t  if (GET_CODE (tmp) == BARRIER)\n+\t\t     tmp && !LABEL_P (tmp); tmp = NEXT_INSN (tmp))\n+\t\t  if (BARRIER_P (tmp))\n \t\t    last_insn_to_move = tmp;\n \n \t\tfor (loc = target; loc; loc = PREV_INSN (loc))\n-\t\t  if (GET_CODE (loc) == BARRIER\n+\t\t  if (BARRIER_P (loc)\n \t\t      /* Don't move things inside a tablejump.  */\n \t\t      && ((loc2 = next_nonnote_insn (loc)) == 0\n-\t\t\t  || GET_CODE (loc2) != CODE_LABEL\n+\t\t\t  || !LABEL_P (loc2)\n \t\t\t  || (loc2 = next_nonnote_insn (loc2)) == 0\n-\t\t\t  || GET_CODE (loc2) != JUMP_INSN\n+\t\t\t  || !JUMP_P (loc2)\n \t\t\t  || (GET_CODE (PATTERN (loc2)) != ADDR_VEC\n \t\t\t      && GET_CODE (PATTERN (loc2)) != ADDR_DIFF_VEC))\n \t\t      && uid_loop[INSN_UID (loc)] == target_loop)\n \t\t    break;\n \n \t\tif (loc == 0)\n \t\t  for (loc = target; loc; loc = NEXT_INSN (loc))\n-\t\t    if (GET_CODE (loc) == BARRIER\n+\t\t    if (BARRIER_P (loc)\n \t\t\t/* Don't move things inside a tablejump.  */\n \t\t\t&& ((loc2 = next_nonnote_insn (loc)) == 0\n-\t\t\t    || GET_CODE (loc2) != CODE_LABEL\n+\t\t\t    || !LABEL_P (loc2)\n \t\t\t    || (loc2 = next_nonnote_insn (loc2)) == 0\n-\t\t\t    || GET_CODE (loc2) != JUMP_INSN\n+\t\t\t    || !JUMP_P (loc2)\n \t\t\t    || (GET_CODE (PATTERN (loc2)) != ADDR_VEC\n \t\t\t\t&& GET_CODE (PATTERN (loc2)) != ADDR_DIFF_VEC))\n \t\t\t&& uid_loop[INSN_UID (loc)] == target_loop)\n@@ -3217,7 +3215,7 @@ labels_in_range_p (rtx insn, int end)\n {\n   while (insn && INSN_LUID (insn) <= end)\n     {\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \treturn 1;\n       insn = NEXT_INSN (insn);\n     }\n@@ -4327,7 +4325,7 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n          returns, exits the loop, is a jump to a location that is still\n          behind the label, or is a jump to the loop start.  */\n \n-      if (GET_CODE (p) == CODE_LABEL)\n+      if (LABEL_P (p))\n \t{\n \t  rtx insn = p;\n \n@@ -4348,7 +4346,7 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n \t\t    break;\n \t\t}\n \n-\t      if (GET_CODE (insn) == JUMP_INSN\n+\t      if (JUMP_P (insn)\n \t\t  && GET_CODE (PATTERN (insn)) != RETURN\n \t\t  && (!any_condjump_p (insn)\n \t\t      || (JUMP_LABEL (insn) != 0\n@@ -4365,7 +4363,7 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n          on whether they will be executed during each iteration.  */\n       /* This code appears twice in strength_reduce.  There is also similar\n          code in scan_loop.  */\n-      if (GET_CODE (p) == JUMP_INSN\n+      if (JUMP_P (p)\n       /* If we enter the loop in the middle, and scan around to the\n          beginning, don't set not_every_iteration for that.\n          This can be any kind of jump, since we want to know if insns\n@@ -4389,7 +4387,7 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n \t    not_every_iteration = 1;\n \t}\n \n-      else if (GET_CODE (p) == NOTE)\n+      else if (NOTE_P (p))\n \t{\n \t  /* At the virtual top of a converted loop, insns are again known to\n \t     be executed each iteration: logically, the loop begins here\n@@ -4415,7 +4413,7 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n          Note that LOOP_TOP is only set for rotated loops and we need\n          this check for all loops, so compare against the CODE_LABEL\n          which immediately follows LOOP_START.  */\n-      if (GET_CODE (p) == JUMP_INSN\n+      if (JUMP_P (p)\n \t  && JUMP_LABEL (p) == NEXT_INSN (loop->start))\n \tpast_loop_latch = 1;\n \n@@ -4431,7 +4429,7 @@ for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n \n       if (not_every_iteration\n \t  && !past_loop_latch\n-\t  && GET_CODE (p) == CODE_LABEL\n+\t  && LABEL_P (p)\n \t  && no_labels_between_p (p, loop->end)\n \t  && loop_insn_first_p (p, loop->cont))\n \tnot_every_iteration = 0;\n@@ -4499,13 +4497,13 @@ loop_bivs_init_find (struct loop *loop)\n      halting at first label.  Also record any test condition.  */\n \n   call_seen = 0;\n-  for (p = loop->start; p && GET_CODE (p) != CODE_LABEL; p = PREV_INSN (p))\n+  for (p = loop->start; p && !LABEL_P (p); p = PREV_INSN (p))\n     {\n       rtx test;\n \n       note_insn = p;\n \n-      if (GET_CODE (p) == CALL_INSN)\n+      if (CALL_P (p))\n \tcall_seen = 1;\n \n       if (INSN_P (p))\n@@ -4514,7 +4512,7 @@ loop_bivs_init_find (struct loop *loop)\n       /* Record any test of a biv that branches around the loop if no store\n \t between it and the start of loop.  We only care about tests with\n \t constants and registers and only certain of those.  */\n-      if (GET_CODE (p) == JUMP_INSN\n+      if (JUMP_P (p)\n \t  && JUMP_LABEL (p) != 0\n \t  && next_real_insn (JUMP_LABEL (p)) == next_real_insn (loop->end)\n \t  && (test = get_condition_for_loop (loop, p)) != 0\n@@ -5319,8 +5317,7 @@ strength_reduce (struct loop *loop, int flags)\n      register substitutions scheduled in REG_MAP.  */\n \n   for (p = loop->start; p != loop->end; p = NEXT_INSN (p))\n-    if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n-\t|| GET_CODE (p) == CALL_INSN)\n+    if (INSN_P (p))\n       {\n \treplace_regs (PATTERN (p), reg_map, reg_map_size, 0);\n \treplace_regs (REG_NOTES (p), reg_map, reg_map_size, 0);\n@@ -5384,7 +5381,7 @@ check_insn_for_bivs (struct loop *loop, rtx p, int not_every_iteration,\n   rtx mult_val;\n   rtx *location;\n \n-  if (GET_CODE (p) == INSN\n+  if (NONJUMP_INSN_P (p)\n       && (set = single_set (p))\n       && REG_P (SET_DEST (set)))\n     {\n@@ -5425,7 +5422,7 @@ check_insn_for_givs (struct loop *loop, rtx p, int not_every_iteration,\n \n   rtx set;\n   /* Look for a general induction variable in a register.  */\n-  if (GET_CODE (p) == INSN\n+  if (NONJUMP_INSN_P (p)\n       && (set = single_set (p))\n       && REG_P (SET_DEST (set))\n       && ! regs->array[REGNO (SET_DEST (set))].may_not_optimize)\n@@ -5482,14 +5479,13 @@ check_insn_for_givs (struct loop *loop, rtx p, int not_every_iteration,\n     }\n \n   /* Look for givs which are memory addresses.  */\n-  if (GET_CODE (p) == INSN)\n+  if (NONJUMP_INSN_P (p))\n     find_mem_givs (loop, PATTERN (p), p, not_every_iteration,\n \t\t   maybe_multiple);\n \n   /* Update the status of whether giv can derive other givs.  This can\n      change when we pass a label or an insn that updates a biv.  */\n-  if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n-      || GET_CODE (p) == CODE_LABEL)\n+  if (INSN_P (p))\n     update_giv_derive (loop, p);\n   return p;\n }\n@@ -5992,8 +5988,7 @@ check_final_value (const struct loop *loop, struct induction *v)\n \t  if (p == v->insn)\n \t    break;\n \n-\t  if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n-\t      || GET_CODE (p) == CALL_INSN)\n+\t  if (INSN_P (p))\n \t    {\n \t      /* It is possible for the BIV increment to use the GIV if we\n \t\t have a cycle.  Thus we must be sure to check each insn for\n@@ -6032,7 +6027,7 @@ check_final_value (const struct loop *loop, struct induction *v)\n \t      if (p == last_giv_use)\n \t\tbreak;\n \n-\t      if (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p)\n+\t      if (JUMP_P (p) && JUMP_LABEL (p)\n \t\t  && LABEL_NAME (JUMP_LABEL (p))\n \t\t  && ((loop_insn_first_p (JUMP_LABEL (p), v->insn)\n \t\t       && loop_insn_first_p (loop->start, JUMP_LABEL (p)))\n@@ -6110,7 +6105,7 @@ update_giv_derive (const struct loop *loop, rtx p)\n \n   for (bl = ivs->list; bl; bl = bl->next)\n     for (biv = bl->biv; biv; biv = biv->next_iv)\n-      if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n+      if (LABEL_P (p) || JUMP_P (p)\n \t  || biv->insn == p)\n \t{\n \t  /* Skip if location is the same as a previous one.  */\n@@ -6126,7 +6121,7 @@ update_giv_derive (const struct loop *loop, rtx p)\n \n \t      /* If this giv is conditionally set and we have passed a label,\n \t\t it cannot derive anything.  */\n-\t      if (GET_CODE (p) == CODE_LABEL && ! giv->always_computable)\n+\t      if (LABEL_P (p) && ! giv->always_computable)\n \t\tgiv->cant_derive = 1;\n \n \t      /* Skip givs that have mult_val == 0, since\n@@ -6163,8 +6158,8 @@ update_giv_derive (const struct loop *loop, rtx p)\n \t\t  else\n \t\t    giv->cant_derive = 1;\n \t\t}\n-\t      else if ((GET_CODE (p) == CODE_LABEL && ! biv->always_computable)\n-\t\t       || (GET_CODE (p) == JUMP_INSN && biv->maybe_multiple))\n+\t      else if ((LABEL_P (p) && ! biv->always_computable)\n+\t\t       || (JUMP_P (p) && biv->maybe_multiple))\n \t\tgiv->cant_derive = 1;\n \t    }\n \t}\n@@ -6292,7 +6287,7 @@ basic_induction_var (const struct loop *loop, rtx x, enum machine_mode mode,\n \t    {\n \t      insn = PREV_INSN (insn);\n \t    }\n-\t  while (insn && GET_CODE (insn) == NOTE\n+\t  while (insn && NOTE_P (insn)\n \t\t && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n \n \t  if (!insn)\n@@ -6367,7 +6362,7 @@ basic_induction_var (const struct loop *loop, rtx x, enum machine_mode mode,\n     case ASHIFTRT:\n       /* Similar, since this can be a sign extension.  */\n       for (insn = PREV_INSN (p);\n-\t   (insn && GET_CODE (insn) == NOTE\n+\t   (insn && NOTE_P (insn)\n \t    && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n \t   insn = PREV_INSN (insn))\n \t;\n@@ -7932,7 +7927,7 @@ product_cheap_p (rtx a, rtx b)\n \t  rtx next = NEXT_INSN (tmp);\n \n \t  if (++n_insns > 3\n-\t      || GET_CODE (tmp) != INSN\n+\t      || !NONJUMP_INSN_P (tmp)\n \t      || (GET_CODE (PATTERN (tmp)) == SET\n \t\t  && GET_CODE (SET_SRC (PATTERN (tmp))) == MULT)\n \t      || (GET_CODE (PATTERN (tmp)) == PARALLEL\n@@ -8024,7 +8019,7 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \n     rtx jump1;\n     if ((jump1 = prev_nonnote_insn (first_compare)) != loop->cont)\n-      if (GET_CODE (jump1) == JUMP_INSN)\n+      if (JUMP_P (jump1))\n \treturn 0;\n   }\n \n@@ -8095,9 +8090,9 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \t the loop, then we can safely optimize.  */\n       for (p = loop_start; p; p = PREV_INSN (p))\n \t{\n-\t  if (GET_CODE (p) == CODE_LABEL)\n+\t  if (LABEL_P (p))\n \t    break;\n-\t  if (GET_CODE (p) != JUMP_INSN)\n+\t  if (!JUMP_P (p))\n \t    continue;\n \n \t  before_comparison = get_condition_for_loop (loop, p);\n@@ -8512,7 +8507,7 @@ check_dbra_loop (struct loop *loop, int insn_count)\n \t      emit_jump_insn_before (tem, loop_end);\n \n \t      for (tem = PREV_INSN (loop_end);\n-\t\t   tem && GET_CODE (tem) != JUMP_INSN;\n+\t\t   tem && !JUMP_P (tem);\n \t\t   tem = PREV_INSN (tem))\n \t\t;\n \n@@ -8691,11 +8686,11 @@ loop_insn_first_p (rtx insn, rtx reference)\n \t P is a note.  */\n       if (INSN_UID (p) < max_uid_for_loop\n \t  && INSN_UID (q) < max_uid_for_loop\n-\t  && GET_CODE (p) != NOTE)\n+\t  && !NOTE_P (p))\n \treturn INSN_LUID (p) <= INSN_LUID (q);\n \n       if (INSN_UID (p) >= max_uid_for_loop\n-\t  || GET_CODE (p) == NOTE)\n+\t  || NOTE_P (p))\n \tp = NEXT_INSN (p);\n       if (INSN_UID (q) >= max_uid_for_loop)\n \tq = NEXT_INSN (q);\n@@ -9110,7 +9105,7 @@ last_use_this_basic_block (rtx reg, rtx insn)\n {\n   rtx n;\n   for (n = insn;\n-       n && GET_CODE (n) != CODE_LABEL && GET_CODE (n) != JUMP_INSN;\n+       n && !LABEL_P (n) && !JUMP_P (n);\n        n = NEXT_INSN (n))\n     {\n       if (REGNO_LAST_UID (REGNO (reg)) == INSN_UID (n))\n@@ -9246,7 +9241,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n       if (op0 == cc0_rtx)\n \t{\n \t  if ((prev = prev_nonnote_insn (prev)) == 0\n-\t      || GET_CODE (prev) != INSN\n+\t      || !NONJUMP_INSN_P (prev)\n \t      || (set = single_set (prev)) == 0\n \t      || SET_DEST (set) != cc0_rtx)\n \t    return 0;\n@@ -9273,7 +9268,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t we don't want to bother dealing with it.  */\n \n       if ((prev = prev_nonnote_insn (prev)) == 0\n-\t  || GET_CODE (prev) != INSN\n+\t  || !NONJUMP_INSN_P (prev)\n \t  || FIND_REG_INC_NOTE (prev, NULL_RTX))\n \tbreak;\n \n@@ -9461,7 +9456,7 @@ get_condition (rtx jump, rtx *earliest, int allow_cc_mode)\n   rtx set;\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n-  if (GET_CODE (jump) != JUMP_INSN\n+  if (!JUMP_P (jump)\n       || ! any_condjump_p (jump))\n     return 0;\n   set = pc_set (jump);\n@@ -9665,13 +9660,13 @@ loop_regs_scan (const struct loop *loop, int extra_size)\n \t    }\n \t}\n \n-      if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN)\n+      if (LABEL_P (insn) || JUMP_P (insn))\n \tmemset (last_set, 0, regs->num * sizeof (rtx));\n \n       /* Invalidate all registers used for function argument passing.\n \t We check rtx_varies_p for the same reason as below, to allow\n \t optimizing PIC calculations.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  rtx link;\n \t  for (link = CALL_INSN_FUNCTION_USAGE (insn);\n@@ -9753,7 +9748,7 @@ load_mems (const struct loop *loop)\n \n   /* We cannot use next_label here because it skips over normal insns.  */\n   end_label = next_nonnote_insn (loop->end);\n-  if (end_label && GET_CODE (end_label) != CODE_LABEL)\n+  if (end_label && !LABEL_P (end_label))\n     end_label = NULL_RTX;\n \n   /* Check to see if it's possible that some instructions in the loop are\n@@ -9763,16 +9758,16 @@ load_mems (const struct loop *loop)\n        p != NULL_RTX;\n        p = next_insn_in_loop (loop, p))\n     {\n-      if (GET_CODE (p) == CODE_LABEL)\n+      if (LABEL_P (p))\n \tmaybe_never = 1;\n-      else if (GET_CODE (p) == JUMP_INSN\n+      else if (JUMP_P (p)\n \t       /* If we enter the loop in the middle, and scan\n \t\t  around to the beginning, don't set maybe_never\n \t\t  for that.  This must be an unconditional jump,\n \t\t  otherwise the code at the top of the loop might\n \t\t  never be executed.  Unconditional jumps are\n \t\t  followed a by barrier then loop end.  */\n-\t       && ! (GET_CODE (p) == JUMP_INSN\n+\t       && ! (JUMP_P (p)\n \t\t     && JUMP_LABEL (p) == loop->top\n \t\t     && NEXT_INSN (NEXT_INSN (p)) == loop->end\n \t\t     && any_uncondjump_p (p)))\n@@ -9803,7 +9798,7 @@ load_mems (const struct loop *loop)\n \n   /* Find start of the extended basic block that enters the loop.  */\n   for (p = loop->start;\n-       PREV_INSN (p) && GET_CODE (p) != CODE_LABEL;\n+       PREV_INSN (p) && !LABEL_P (p);\n        p = PREV_INSN (p))\n     ;\n   prev_ebb_head = p;\n@@ -9938,7 +9933,7 @@ load_mems (const struct loop *loop)\n \n \t      /* If this is a call which uses / clobbers this memory\n \t\t location, we must not change the interface here.  */\n-\t      if (GET_CODE (p) == CALL_INSN\n+\t      if (CALL_P (p)\n \t\t  && reg_mentioned_p (loop_info->mems[i].mem,\n \t\t\t\t      CALL_INSN_FUNCTION_USAGE (p)))\n \t\t{\n@@ -9952,8 +9947,8 @@ load_mems (const struct loop *loop)\n \t\t\t\t   loop_info->mems[i].reg, written);\n \t    }\n \n-\t  if (GET_CODE (p) == CODE_LABEL\n-\t      || GET_CODE (p) == JUMP_INSN)\n+\t  if (LABEL_P (p)\n+\t      || JUMP_P (p))\n \t    maybe_never = 1;\n \t}\n \n@@ -10068,7 +10063,7 @@ load_mems (const struct loop *loop)\n      label with the new one.  */\n   if (label != NULL_RTX && end_label != NULL_RTX)\n     for (p = loop->start; p != loop->end; p = NEXT_INSN (p))\n-      if (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == end_label)\n+      if (JUMP_P (p) && JUMP_LABEL (p) == end_label)\n \tredirect_jump (p, label, false);\n \n   cselib_finish ();\n@@ -10115,7 +10110,7 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n \n       /* Only substitute within one extended basic block from the initializing\n          insn.  */\n-      if (GET_CODE (insn) == CODE_LABEL && init_insn)\n+      if (LABEL_P (insn) && init_insn)\n \tbreak;\n \n       if (! INSN_P (insn))\n@@ -10719,7 +10714,7 @@ debug_giv (const struct induction *v)\n \n /* The notes do not have an assigned block, so look at the next insn.  */\n #define LOOP_BLOCK_NUM(INSN) \\\n-((INSN) ? (GET_CODE (INSN) == NOTE \\\n+((INSN) ? (NOTE_P (INSN) \\\n             ? LOOP_BLOCK_NUM_1 (next_nonnote_insn (INSN)) \\\n             : LOOP_BLOCK_NUM_1 (INSN)) \\\n         : -1)\n@@ -10738,13 +10733,13 @@ loop_dump_aux (const struct loop *loop, FILE *file,\n   /* Print diagnostics to compare our concept of a loop with\n      what the loop notes say.  */\n   if (! PREV_INSN (BB_HEAD (loop->first))\n-      || GET_CODE (PREV_INSN (BB_HEAD (loop->first))) != NOTE\n+      || !NOTE_P (PREV_INSN (BB_HEAD (loop->first)))\n       || NOTE_LINE_NUMBER (PREV_INSN (BB_HEAD (loop->first)))\n       != NOTE_INSN_LOOP_BEG)\n     fprintf (file, \";;  No NOTE_INSN_LOOP_BEG at %d\\n\",\n \t     INSN_UID (PREV_INSN (BB_HEAD (loop->first))));\n   if (! NEXT_INSN (BB_END (loop->last))\n-      || GET_CODE (NEXT_INSN (BB_END (loop->last))) != NOTE\n+      || !NOTE_P (NEXT_INSN (BB_END (loop->last)))\n       || NOTE_LINE_NUMBER (NEXT_INSN (BB_END (loop->last)))\n       != NOTE_INSN_LOOP_END)\n     fprintf (file, \";;  No NOTE_INSN_LOOP_END at %d\\n\","}, {"sha": "731cbe7cb4a79da40b25478e8fa2b3b689b718f2", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -265,7 +265,7 @@ doloop_register_get (rtx insn, rtx *comp)\n {\n   rtx pattern, cmp, inc, reg, condition;\n \n-  if (GET_CODE (insn) != JUMP_INSN)\n+  if (!JUMP_P (insn))\n     return NULL_RTX;\n   pattern = PATTERN (insn);\n \n@@ -789,7 +789,7 @@ static rtx\n find_line_note (rtx insn)\n {\n   for (; insn; insn = PREV_INSN (insn))\n-    if (GET_CODE (insn) == NOTE\n+    if (NOTE_P (insn)\n \t&& NOTE_LINE_NUMBER (insn) >= 0)\n       break;\n \n@@ -938,19 +938,19 @@ sms_schedule (FILE *dump_file)\n \n       /* Don't handle BBs with calls or barriers, or !single_set insns.  */\n       for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == CALL_INSN\n-\t    || GET_CODE (insn) == BARRIER\n-\t    || (INSN_P (insn) && GET_CODE (insn) != JUMP_INSN\n+\tif (CALL_P (insn)\n+\t    || BARRIER_P (insn)\n+\t    || (INSN_P (insn) && !JUMP_P (insn)\n \t\t&& !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))\n \t  break;\n \n       if (insn != NEXT_INSN (tail))\n \t{\n \t  if (stats_file)\n \t    {\n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      if (CALL_P (insn))\n \t\tfprintf (stats_file, \"SMS loop-with-call\\n\");\n-\t      else if (GET_CODE (insn) == BARRIER)\n+\t      else if (BARRIER_P (insn))\n \t\tfprintf (stats_file, \"SMS loop-with-barrier\\n\");\n \t      else\n \t\tfprintf (stats_file, \"SMS loop-with-not-single-set\\n\");\n@@ -1245,7 +1245,7 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order, FILE *du\n \t  if (!INSN_P (insn))\n \t    continue;\n \n-\t  if (GET_CODE (insn) == JUMP_INSN) /* Closing branch handled later.  */\n+\t  if (JUMP_P (insn)) /* Closing branch handled later.  */\n \t    continue;\n \n \t  /* 1. compute sched window for u (start, end, step).  */"}, {"sha": "26ce3f48e2e4e78243b739003f8a1148fd457239", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -3292,7 +3292,7 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n     return emit_insn (insns);\n   else\n     for (insn = insns; insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) != INSN\n+      if (!NONJUMP_INSN_P (insn)\n \t  || find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n \treturn emit_insn (insns);\n \n@@ -3436,7 +3436,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n   if (flag_non_call_exceptions && may_trap_p (equiv))\n     {\n       for (insn = insns; insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == CALL_INSN)\n+\tif (CALL_P (insn))\n \t  {\n \t    rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n \n@@ -3450,7 +3450,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n      goto (unless there is already a REG_EH_REGION note, in which case\n      we update it).  */\n     for (insn = insns; insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n \n@@ -3503,7 +3503,7 @@ emit_libcall_block (rtx insns, rtx target, rtx result, rtx equiv)\n \n       /* Some ports use a loop to copy large arguments onto the stack.\n \t Don't move anything outside such a loop.  */\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tbreak;\n     }\n "}, {"sha": "c4ab4f229dfa886025b78e1c417576a2ffeae0de", "filename": "gcc/postreload.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -396,7 +396,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n       /* cselib blows up on CODE_LABELs.  Trying to fix that doesn't seem\n \t right, so avoid the problem here.  Likewise if we have a constant\n          and the insn pattern doesn't tell us the mode we need.  */\n-      if (GET_CODE (recog_data.operand[i]) == CODE_LABEL\n+      if (LABEL_P (recog_data.operand[i])\n \t  || (CONSTANT_P (recog_data.operand[i])\n \t      && recog_data.operand_mode[i] == VOIDmode))\n \tcontinue;\n@@ -721,7 +721,7 @@ reload_combine (void)\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       insn = BB_HEAD (bb);\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \t{\n \t  HARD_REG_SET live;\n \n@@ -752,9 +752,9 @@ reload_combine (void)\n       /* We cannot do our optimization across labels.  Invalidating all the use\n \t information we have would be costly, so we just note where the label\n \t is and then later disable any optimization that would cross it.  */\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tlast_label_ruid = reload_combine_ruid;\n-      else if (GET_CODE (insn) == BARRIER)\n+      else if (BARRIER_P (insn))\n \tfor (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n \t  if (! fixed_regs[r])\n \t      reg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n@@ -898,7 +898,7 @@ reload_combine (void)\n \n       note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n \n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  rtx link;\n \n@@ -932,7 +932,7 @@ reload_combine (void)\n \t     }\n \n \t}\n-      else if (GET_CODE (insn) == JUMP_INSN\n+      else if (JUMP_P (insn)\n \t       && GET_CODE (PATTERN (insn)) != RETURN)\n \t{\n \t  /* Non-spill registers might be used at the call destination in\n@@ -1192,7 +1192,7 @@ reload_cse_move2add (rtx first)\n     {\n       rtx pat, note;\n \n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \t{\n \t  move2add_last_label_luid = move2add_luid;\n \t  /* We're going to increment move2add_luid twice after a\n@@ -1398,7 +1398,7 @@ reload_cse_move2add (rtx first)\n \n       /* If this is a CALL_INSN, all call used registers are stored with\n \t unknown values.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \t{\n \t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n \t    {"}, {"sha": "08834f89cd94bb1ddd5c0b7ceb9f6295958b5ce7", "filename": "gcc/predict.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -247,7 +247,7 @@ tree_predict_edge (edge e, enum br_predictor predictor, int probability)\n static bool\n can_predict_insn_p (rtx insn)\n {\n-  return (GET_CODE (insn) == JUMP_INSN\n+  return (JUMP_P (insn)\n \t  && any_condjump_p (insn)\n \t  && BLOCK_FOR_INSN (insn)->succ->succ_next);\n }\n@@ -672,7 +672,7 @@ estimate_probability (struct loops *loops_info)\n \t\t messages.  */\n \t      for (insn = BB_HEAD (e->dest); insn != NEXT_INSN (BB_END (e->dest));\n \t\t   insn = NEXT_INSN (insn))\n-\t\tif (GET_CODE (insn) == CALL_INSN\n+\t\tif (CALL_P (insn)\n \t\t    /* Constant and pure calls are hardly used to signalize\n \t\t       something exceptional.  */\n \t\t    && ! CONST_OR_PURE_CALL_P (insn))\n@@ -774,7 +774,7 @@ estimate_probability (struct loops *loops_info)\n \n   /* Attach the combined probability to each conditional jump.  */\n   FOR_EACH_BB (bb)\n-    if (GET_CODE (BB_END (bb)) == JUMP_INSN\n+    if (JUMP_P (BB_END (bb))\n \t&& any_condjump_p (BB_END (bb))\n \t&& bb->succ->succ_next != NULL)\n       combine_predictions_for_insn (BB_END (bb), bb);\n@@ -1023,7 +1023,7 @@ expected_value_to_br_prob (void)\n \tcase JUMP_INSN:\n \t  /* Look for simple conditional branches.  If we haven't got an\n \t     expected value yet, no point going further.  */\n-\t  if (GET_CODE (insn) != JUMP_INSN || ev == NULL_RTX\n+\t  if (!JUMP_P (insn) || ev == NULL_RTX\n \t      || ! any_condjump_p (insn))\n \t    continue;\n \t  break;\n@@ -1155,15 +1155,15 @@ process_note_predictions (basic_block bb, int *heads)\n   for (insn = BB_END (bb); insn;\n        was_bb_head |= (insn == BB_HEAD (bb)), insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) != NOTE)\n+      if (!NOTE_P (insn))\n \t{\n \t  if (was_bb_head)\n \t    break;\n \t  else\n \t    {\n \t      /* Noreturn calls cause program to exit, therefore they are\n \t         always predicted as not taken.  */\n-\t      if (GET_CODE (insn) == CALL_INSN\n+\t      if (CALL_P (insn)\n \t\t  && find_reg_note (insn, REG_NORETURN, NULL))\n \t\tcontained_noreturn_call = 1;\n \t      continue;"}, {"sha": "e2febfa48cc0c23b92bd357fda6e51aa3e17fe1b", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -124,8 +124,8 @@ print_rtx (rtx in_rtx)\n   /* When printing in VCG format we write INSNs, NOTE, LABEL, and BARRIER\n      in separate nodes and therefore have to handle them special here.  */\n   if (dump_for_graph\n-      && (is_insn || GET_CODE (in_rtx) == NOTE\n-\t  || GET_CODE (in_rtx) == CODE_LABEL || GET_CODE (in_rtx) == BARRIER))\n+      && (is_insn || NOTE_P (in_rtx)\n+\t  || LABEL_P (in_rtx) || BARRIER_P (in_rtx)))\n     {\n       i = 3;\n       indent = 0;\n@@ -231,7 +231,7 @@ print_rtx (rtx in_rtx)\n \t      print_node_brief (outfile, \"\", decl, 0);\n \t  }\n #endif\n-\telse if (i == 4 && GET_CODE (in_rtx) == NOTE)\n+\telse if (i == 4 && NOTE_P (in_rtx))\n \t  {\n \t    switch (NOTE_LINE_NUMBER (in_rtx))\n \t      {\n@@ -385,7 +385,7 @@ print_rtx (rtx in_rtx)\n \t      fprintf(outfile, \" %s:%i\", insn_file (in_rtx), insn_line (in_rtx));\n #endif\n \t  }\n-\telse if (i == 6 && GET_CODE (in_rtx) == NOTE)\n+\telse if (i == 6 && NOTE_P (in_rtx))\n \t  {\n \t    /* This field is only used for NOTE_INSN_DELETED_LABEL, and\n \t       other times often contains garbage from INSN->NOTE death.  */\n@@ -421,7 +421,7 @@ print_rtx (rtx in_rtx)\n \t    else\n #endif\n \t      if (flag_dump_unnumbered\n-\t\t     && (is_insn || GET_CODE (in_rtx) == NOTE))\n+\t\t     && (is_insn || NOTE_P (in_rtx)))\n \t      fputc ('#', outfile);\n \t    else\n \t      fprintf (outfile, \" %d\", value);\n@@ -577,8 +577,8 @@ print_rtx (rtx in_rtx)\n     }\n \n   if (dump_for_graph\n-      && (is_insn || GET_CODE (in_rtx) == NOTE\n-\t  || GET_CODE (in_rtx) == CODE_LABEL || GET_CODE (in_rtx) == BARRIER))\n+      && (is_insn || NOTE_P (in_rtx)\n+\t  || LABEL_P (in_rtx) || BARRIER_P (in_rtx)))\n     sawclose = 0;\n   else\n     {\n@@ -717,7 +717,7 @@ print_rtl (FILE *outf, rtx rtx_first)\n       case BARRIER:\n \tfor (tmp_rtx = rtx_first; tmp_rtx != 0; tmp_rtx = NEXT_INSN (tmp_rtx))\n \t  if (! flag_dump_unnumbered\n-\t      || GET_CODE (tmp_rtx) != NOTE || NOTE_LINE_NUMBER (tmp_rtx) < 0)\n+\t      || !NOTE_P (tmp_rtx) || NOTE_LINE_NUMBER (tmp_rtx) < 0)\n \t    {\n \t      fputs (print_rtx_head, outfile);\n \t      print_rtx (tmp_rtx);\n@@ -740,7 +740,7 @@ print_rtl_single (FILE *outf, rtx x)\n   outfile = outf;\n   sawclose = 0;\n   if (! flag_dump_unnumbered\n-      || GET_CODE (x) != NOTE || NOTE_LINE_NUMBER (x) < 0)\n+      || !NOTE_P (x) || NOTE_LINE_NUMBER (x) < 0)\n     {\n       fputs (print_rtx_head, outfile);\n       print_rtx (x);"}, {"sha": "1d16b4368ac985d9989aa4e4dd7cb7255b1e10bc", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -907,7 +907,7 @@ branch_prob (void)\n \n \t  while (insn != BB_END (bb))\n \t    {\n-\t      if (GET_CODE (insn) == NOTE)\n+\t      if (NOTE_P (insn))\n \t\t{\n \t\t  /* Must ignore the line number notes that\n \t\t     immediately follow the end of an inline function"}, {"sha": "650caa11a16c1d128fc5260b77b1728306446ba6", "filename": "gcc/ra-build.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -711,7 +711,7 @@ live_out_1 (struct df *df ATTRIBUTE_UNUSED, struct curr_use *use, rtx insn)\n \n       /* We want to access the root webpart.  */\n       wp = find_web_part (wp);\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \twp->crosses_call = 1;\n       else if (copy_insn_p (insn, &s, NULL))\n \tsource_regno = REGNO (GET_CODE (s) == SUBREG ? SUBREG_REG (s) : s);\n@@ -1045,7 +1045,7 @@ livethrough_conflicts_bb (basic_block bb)\n \t    bitmap_set_bit (all_defs, DF_REF_ID (info.defs[n]));\n \t  if (TEST_BIT (insns_with_deaths, INSN_UID (insn)))\n \t    deaths++;\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    contains_call = 1;\n \t}\n       if (insn == BB_END (bb))\n@@ -2676,7 +2676,7 @@ detect_webs_set_in_cond_jump (void)\n {\n   basic_block bb;\n   FOR_EACH_BB (bb)\n-    if (GET_CODE (BB_END (bb)) == JUMP_INSN)\n+    if (JUMP_P (BB_END (bb)))\n       {\n \tstruct df_link *link;\n \tfor (link = DF_INSN_DEFS (df, BB_END (bb)); link; link = link->next)"}, {"sha": "d060e0487d3a73c911a1a40e4eba385f84e8f46b", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -317,10 +317,10 @@ ra_print_rtx_object (FILE *file, rtx x)\n       case LABEL_REF:\n \t\t  {\n \t\t    rtx sub = XEXP (x, 0);\n-\t\t    if (GET_CODE (sub) == NOTE\n+\t\t    if (NOTE_P (sub)\n \t\t\t&& NOTE_LINE_NUMBER (sub) == NOTE_INSN_DELETED_LABEL)\n \t\t      fprintf (file, \"(deleted uid=%d)\", INSN_UID (sub));\n-\t\t    else if (GET_CODE (sub) == CODE_LABEL)\n+\t\t    else if (LABEL_P (sub))\n \t\t      fprintf (file, \"L%d\", CODE_LABEL_NUMBER (sub));\n \t\t    else\n \t\t      fprintf (file, \"(nonlabel uid=%d)\", INSN_UID (sub));\n@@ -566,7 +566,7 @@ ra_debug_insns (rtx insn, int num)\n       insn = PREV_INSN (insn);\n   for (i = count; i > 0 && insn; insn = NEXT_INSN (insn), i--)\n     {\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tfprintf (stderr, \"\\n\");\n       ra_print_rtx_top (stderr, insn, (i == count || i == 1));\n     }\n@@ -586,7 +586,7 @@ ra_print_rtl_with_bb (FILE *file, rtx insn)\n   last_bb = NULL;\n   for (; insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == BARRIER)\n+      if (BARRIER_P (insn))\n \tbb = NULL;\n       else\n \tbb = BLOCK_FOR_INSN (insn);\n@@ -598,9 +598,9 @@ ra_print_rtl_with_bb (FILE *file, rtx insn)\n \t    fprintf (file, \";; Begin of basic block %d\\n\", bb->index);\n \t  last_bb = bb;\n \t}\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tfputc ('\\n', file);\n-      if (GET_CODE (insn) == NOTE)\n+      if (NOTE_P (insn))\n \t{\n \t  /* Ignore basic block and maybe other notes not referencing\n \t     deleted things.  */"}, {"sha": "d5176490105851594a45be5a844ec8273063fcf9", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -637,7 +637,7 @@ insert_stores (bitmap new_deaths)\n \n       /* If we reach a basic block border, which has more than one\n \t outgoing edge, we simply forget all already emitted stores.  */\n-      if (GET_CODE (insn) == BARRIER\n+      if (BARRIER_P (insn)\n \t  || JUMP_P (insn) || can_throw_internal (insn))\n \t{\n \t  last_slot = NULL_RTX;\n@@ -1252,7 +1252,7 @@ rewrite_program2 (bitmap new_deaths)\n \t     XXX Note, that sometimes reload barfs when we emit insns between\n \t     a call and the insn which copies the return register into a\n \t     pseudo.  */\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    ri.need_load = 1;\n \t  else if (INSN_P (insn))\n \t    for (n = 0; n < info.num_uses; n++)\n@@ -1339,7 +1339,7 @@ rewrite_program2 (bitmap new_deaths)\n \t\t  web->one_load = 0;\n \t      }\n \n-\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t  if (LABEL_P (insn))\n \t    break;\n \t}\n "}, {"sha": "9c9d0382ee10894ade7350668bc8a2f6f7550fc2", "filename": "gcc/recog.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -715,9 +715,7 @@ next_insn_tests_no_inequality (rtx insn)\n   if (next == 0)\n     return 0;\n \n-  return ((GET_CODE (next) == JUMP_INSN\n-\t   || GET_CODE (next) == INSN\n-\t   || GET_CODE (next) == CALL_INSN)\n+  return (INSN_P (next)\n \t  && ! inequality_comparisons_p (PATTERN (next)));\n }\n #endif\n@@ -850,7 +848,7 @@ find_single_use (rtx dest, rtx insn, rtx *ploc)\n     {\n       next = NEXT_INSN (insn);\n       if (next == 0\n-\t  || (GET_CODE (next) != INSN && GET_CODE (next) != JUMP_INSN))\n+\t  || (!NONJUMP_INSN_P (next) && !JUMP_P (next)))\n \treturn 0;\n \n       result = find_single_use_1 (dest, &PATTERN (next));\n@@ -864,7 +862,7 @@ find_single_use (rtx dest, rtx insn, rtx *ploc)\n     return 0;\n \n   for (next = next_nonnote_insn (insn);\n-       next != 0 && GET_CODE (next) != CODE_LABEL;\n+       next != 0 && !LABEL_P (next);\n        next = next_nonnote_insn (next))\n     if (INSN_P (next) && dead_or_set_p (next, dest))\n       {\n@@ -2740,7 +2738,7 @@ split_all_insns (int upd_life)\n \t\t\t BB boundary we are interested in will be set to\n \t\t\t previous one.  */\n \n-\t\t      while (GET_CODE (last) == BARRIER)\n+\t\t      while (BARRIER_P (last))\n \t\t\tlast = PREV_INSN (last);\n \t\t      SET_BIT (blocks, bb->index);\n \t\t      changed = true;\n@@ -3077,14 +3075,14 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t      if (j >= MAX_INSNS_PER_PEEP2 + 1)\n \t\t\tj -= MAX_INSNS_PER_PEEP2 + 1;\n \t\t      old_insn = peep2_insn_data[j].insn;\n-\t\t      if (GET_CODE (old_insn) != CALL_INSN)\n+\t\t      if (!CALL_P (old_insn))\n \t\t\tcontinue;\n \t\t      was_call = true;\n \n \t\t      new_insn = try;\n \t\t      while (new_insn != NULL_RTX)\n \t\t\t{\n-\t\t\t  if (GET_CODE (new_insn) == CALL_INSN)\n+\t\t\t  if (CALL_P (new_insn))\n \t\t\t    break;\n \t\t\t  new_insn = NEXT_INSN (new_insn);\n \t\t\t}\n@@ -3119,7 +3117,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t\t  if (j >= MAX_INSNS_PER_PEEP2 + 1)\n \t\t\t    j -= MAX_INSNS_PER_PEEP2 + 1;\n \t\t\t  old_insn = peep2_insn_data[j].insn;\n-\t\t\t  if (GET_CODE (old_insn) == CALL_INSN)\n+\t\t\t  if (CALL_P (old_insn))\n \t\t\t    abort ();\n \t\t\t}\n \t\t      break;\n@@ -3149,7 +3147,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t\t  break;\n \n \t\t      for (x = try ; x != before_try ; x = PREV_INSN (x))\n-\t\t\tif (GET_CODE (x) == CALL_INSN\n+\t\t\tif (CALL_P (x)\n \t\t\t    || (flag_non_call_exceptions\n \t\t\t\t&& may_trap_p (PATTERN (x))\n \t\t\t\t&& !find_reg_note (x, REG_EH_REGION, NULL)))\n@@ -3168,7 +3166,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t\t\tnfte = split_block (bb, x);\n \t\t\t\tflags = (eh_edge->flags\n \t\t\t\t\t & (EDGE_EH | EDGE_ABNORMAL));\n-\t\t\t\tif (GET_CODE (x) == CALL_INSN)\n+\t\t\t\tif (CALL_P (x))\n \t\t\t\t  flags |= EDGE_ABNORMAL_CALL;\n \t\t\t\tnehe = make_edge (nfte->src, eh_edge->dest,\n \t\t\t\t\t\t  flags);\n@@ -3236,7 +3234,7 @@ peephole2_optimize (FILE *dump_file ATTRIBUTE_UNUSED)\n \t\t  /* If we generated a jump instruction, it won't have\n \t\t     JUMP_LABEL set.  Recompute after we're done.  */\n \t\t  for (x = try; x != before_try; x = PREV_INSN (x))\n-\t\t    if (GET_CODE (x) == JUMP_INSN)\n+\t\t    if (JUMP_P (x))\n \t\t      {\n \t\t        do_rebuild_jump_labels = true;\n \t\t\tbreak;\n@@ -3342,7 +3340,7 @@ if_test_bypass_p (rtx out_insn, rtx in_insn)\n   in_set = single_set (in_insn);\n   if (! in_set)\n     {\n-      if (GET_CODE (in_insn) == JUMP_INSN || GET_CODE (in_insn) == CALL_INSN)\n+      if (JUMP_P (in_insn) || CALL_P (in_insn))\n \treturn false;\n       abort ();\n     }"}, {"sha": "5eb253ffe0f68dcae5cf3d3aa2d7db87de50bfd2", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -344,7 +344,7 @@ next_flags_user (rtx insn)\n       if (INSN_P (insn) && reg_mentioned_p (ix86_flags_rtx, PATTERN (insn)))\n \treturn insn;\n \n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \treturn NULL_RTX;\n     }\n   return NULL_RTX;\n@@ -506,7 +506,7 @@ record_label_references (rtx insn, rtx pat)\n       rtx label = XEXP (pat, 0);\n       rtx ref;\n \n-      if (GET_CODE (label) != CODE_LABEL)\n+      if (!LABEL_P (label))\n \tabort ();\n \n       /* If this is an undefined label, LABEL_REFS (label) contains\n@@ -986,10 +986,10 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n       rtx limit = PREV_INSN (BB_HEAD (current_block));\n       while (tmp != limit)\n \t{\n-\t  if (GET_CODE (tmp) == CODE_LABEL\n-\t      || GET_CODE (tmp) == CALL_INSN\n+\t  if (LABEL_P (tmp)\n+\t      || CALL_P (tmp)\n \t      || NOTE_INSN_BASIC_BLOCK_P (tmp)\n-\t      || (GET_CODE (tmp) == INSN\n+\t      || (NONJUMP_INSN_P (tmp)\n \t\t  && stack_regs_mentioned (tmp)))\n \t    {\n \t      i1 = tmp;\n@@ -1292,7 +1292,7 @@ swap_rtx_condition (rtx insn)\n \t  insn = NEXT_INSN (insn);\n \t  if (INSN_P (insn) && reg_mentioned_p (dest, insn))\n \t    break;\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    return 0;\n \t}\n \n@@ -2326,7 +2326,7 @@ subst_stack_regs (rtx insn, stack regstack)\n   bool control_flow_insn_deleted = false;\n   int i;\n \n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       int top = regstack->top;\n \n@@ -2388,7 +2388,7 @@ subst_stack_regs (rtx insn, stack regstack)\n   /* subst_stack_regs_pat may have deleted a no-op insn.  If so, any\n      REG_UNUSED will already have been dealt with, so just return.  */\n \n-  if (GET_CODE (insn) == NOTE || INSN_DELETED_P (insn))\n+  if (NOTE_P (insn) || INSN_DELETED_P (insn))\n     return control_flow_insn_deleted;\n \n   /* If there is a REG_UNUSED note on a stack register on this insn,\n@@ -2748,7 +2748,7 @@ compensate_edge (edge e, FILE *file)\n       tmpstack = regstack;\n \n       change_stack (BB_END (block), &tmpstack, target_stack,\n-\t\t    (GET_CODE (BB_END (block)) == JUMP_INSN\n+\t\t    (JUMP_P (BB_END (block))\n \t\t     ? EMIT_BEFORE : EMIT_AFTER));\n     }\n   else\n@@ -2870,7 +2870,7 @@ convert_regs_1 (FILE *file, basic_block block)\n       /* Don't bother processing unless there is a stack reg\n \t mentioned or if it's a CALL_INSN.  */\n       if (stack_regs_mentioned (insn)\n-\t  || GET_CODE (insn) == CALL_INSN)\n+\t  || CALL_P (insn))\n \t{\n \t  if (file)\n \t    {\n@@ -2894,7 +2894,7 @@ convert_regs_1 (FILE *file, basic_block block)\n     }\n \n   insn = BB_END (block);\n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     insn = PREV_INSN (insn);\n \n   /* If the function is declared to return a value, but it returns one"}, {"sha": "5bc6cc8051fa1f6ad555f004715197876e6408c9", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -1087,7 +1087,7 @@ scan_one_insn (rtx insn, int pass)\n \t We need not check for code_label here;\n \t while a basic block can start with a code_label,\n \t INSN could not be at the beginning of that block.  */\n-      if (previnsn == 0 || GET_CODE (previnsn) == JUMP_INSN)\n+      if (previnsn == 0 || JUMP_P (previnsn))\n \t{\n \t  basic_block b;\n \t  FOR_EACH_BB (b)"}, {"sha": "5816831dc6cd94786674a7a63e3d325dc211a74b", "filename": "gcc/regmove.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -491,7 +491,7 @@ optimize_reg_copy_1 (rtx insn, rtx dest, rtx src)\n \n \t      /* If the insn in which SRC dies is a CALL_INSN, don't count it\n \t\t as a call that has been crossed.  Otherwise, count it.  */\n-\t      if (q != p && GET_CODE (q) == CALL_INSN)\n+\t      if (q != p && CALL_P (q))\n \t\t{\n \t\t  /* Similarly, total calls for SREGNO, total calls beyond\n \t\t     the death note for DREGNO.  */\n@@ -620,7 +620,7 @@ optimize_reg_copy_2 (rtx insn, rtx dest, rtx src)\n \t\t  PATTERN (q) = replace_rtx (PATTERN (q), dest, src);\n \n \n-\t      if (GET_CODE (q) == CALL_INSN)\n+\t      if (CALL_P (q))\n \t\t{\n \t\t  REG_N_CALLS_CROSSED (dregno)--;\n \t\t  REG_N_CALLS_CROSSED (sregno)++;\n@@ -636,7 +636,7 @@ optimize_reg_copy_2 (rtx insn, rtx dest, rtx src)\n \n       if (reg_set_p (src, p)\n \t  || find_reg_note (p, REG_DEAD, dest)\n-\t  || (GET_CODE (p) == CALL_INSN && REG_N_CALLS_CROSSED (sregno) == 0))\n+\t  || (CALL_P (p) && REG_N_CALLS_CROSSED (sregno) == 0))\n \tbreak;\n     }\n }\n@@ -971,8 +971,8 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset, FILE *regmove_dump_file)\n #ifdef AUTO_INC_DEC\n \t      for (p = PREV_INSN (insn); p; p = PREV_INSN (p))\n \t\t{\n-\t\t  if (GET_CODE (p) == CODE_LABEL\n-\t\t      || GET_CODE (p) == JUMP_INSN)\n+\t\t  if (LABEL_P (p)\n+\t\t      || JUMP_P (p))\n \t\t    break;\n \t\t  if (! INSN_P (p))\n \t\t    continue;\n@@ -985,8 +985,8 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset, FILE *regmove_dump_file)\n \t\t}\n \t      for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n \t\t{\n-\t\t  if (GET_CODE (p) == CODE_LABEL\n-\t\t      || GET_CODE (p) == JUMP_INSN)\n+\t\t  if (LABEL_P (p)\n+\t\t      || JUMP_P (p))\n \t\t    break;\n \t\t  if (! INSN_P (p))\n \t\t    continue;\n@@ -1010,7 +1010,7 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset, FILE *regmove_dump_file)\n       /* reg_set_p is overly conservative for CALL_INSNS, thinks that all\n \t hard regs are clobbered.  Thus, we only use it for src for\n \t non-call insns.  */\n-      if (GET_CODE (p) == CALL_INSN)\n+      if (CALL_P (p))\n \t{\n \t  if (! dst_death)\n \t    num_calls++;\n@@ -1423,7 +1423,7 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n \t\t  /* If we have passed a call instruction, and the\n \t\t     pseudo-reg DST is not already live across a call,\n \t\t     then don't perform the optimization.  */\n-\t\t  if (GET_CODE (p) == CALL_INSN)\n+\t\t  if (CALL_P (p))\n \t\t    {\n \t\t      num_calls++;\n \n@@ -1702,7 +1702,7 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n \n   for (length = s_length = 0, p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n     {\n-      if (GET_CODE (p) == CALL_INSN)\n+      if (CALL_P (p))\n \treplace_in_call_usage (& CALL_INSN_FUNCTION_USAGE (p),\n \t\t\t       REGNO (dst), src, p);\n \n@@ -1839,7 +1839,7 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n \n       /* If we have passed a call instruction, and the pseudo-reg SRC is not\n \t already live across a call, then don't perform the optimization.  */\n-      if (GET_CODE (p) == CALL_INSN)\n+      if (CALL_P (p))\n \t{\n \t  if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n \t    break;\n@@ -1930,7 +1930,7 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n \t\t  q = 0;\n \t\t  break;\n \t\t}\n-\t      if (GET_CODE (p) == CALL_INSN)\n+\t      if (CALL_P (p))\n \t\tnum_calls2++;\n \t    }\n \t  if (q && set2 && SET_DEST (set2) == src && CONSTANT_P (SET_SRC (set2))\n@@ -2159,7 +2159,7 @@ single_set_for_csa (rtx insn)\n   if (tmp)\n     return tmp;\n \n-  if (GET_CODE (insn) != INSN\n+  if (!NONJUMP_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) != PARALLEL)\n     return NULL_RTX;\n \n@@ -2441,7 +2441,7 @@ combine_stack_adjustments_for_block (basic_block bb)\n \n       data.insn = insn;\n       data.memlist = memlist;\n-      if (GET_CODE (insn) != CALL_INSN && last_sp_set\n+      if (!CALL_P (insn) && last_sp_set\n \t  && !for_each_rtx (&PATTERN (insn), record_stack_memrefs, &data))\n \t{\n \t   memlist = data.memlist;\n@@ -2452,7 +2452,7 @@ combine_stack_adjustments_for_block (basic_block bb)\n       /* Otherwise, we were not able to process the instruction.\n \t Do not continue collecting data across such a one.  */\n       if (last_sp_set\n-\t  && (GET_CODE (insn) == CALL_INSN\n+\t  && (CALL_P (insn)\n \t      || reg_mentioned_p (stack_pointer_rtx, PATTERN (insn))))\n \t{\n \t  if (last_sp_set && last_sp_adjust == 0)"}, {"sha": "b4226bfd9ff541f77fcf9894ccb086d92693cd9b", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -824,7 +824,7 @@ build_def_use (basic_block bb)\n \t    *recog_data.operand_loc[i] = old_operands[i];\n \n \t  /* Step 2B: Can't rename function call argument registers.  */\n-\t  if (GET_CODE (insn) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (insn))\n+\t  if (CALL_P (insn) && CALL_INSN_FUNCTION_USAGE (insn))\n \t    scan_rtx (insn, &CALL_INSN_FUNCTION_USAGE (insn),\n \t\t      NO_REGS, terminate_all_read, OP_IN, 0);\n \n@@ -879,7 +879,7 @@ build_def_use (basic_block bb)\n \n \t  /* Step 4B: If this is a call, any chain live at this point\n \t     requires a caller-saved reg.  */\n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      struct du_chain *p;\n \t      for (p = open_chains; p; p = p->next_chain)\n@@ -934,7 +934,7 @@ build_def_use (basic_block bb)\n \t\t\t      recog_op_alt[i][alt].earlyclobber);\n \t\t  }\n \t    }\n-\t  else if (GET_CODE (insn) != CALL_INSN)\n+\t  else if (!CALL_P (insn))\n \t    for (i = 0; i < n_ops + recog_data.n_dups; i++)\n \t      {\n \t\tint opn = i < n_ops ? i : recog_data.dup_num[i - n_ops];\n@@ -1702,7 +1702,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \n     did_replacement:\n       /* Clobber call-clobbered registers.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n+      if (CALL_P (insn))\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t  if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t    kill_value_regno (i, vd);"}, {"sha": "4011f0f7a6122dd95accdb9d4bb1a84e3022cd38", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -2536,7 +2536,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   /* JUMP_INSNs and CALL_INSNs are not allowed to have any output reloads;\n      neither are insns that SET cc0.  Insns that use CC0 are not allowed\n      to have any input reloads.  */\n-  if (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == CALL_INSN)\n+  if (JUMP_P (insn) || CALL_P (insn))\n     no_output_reloads = 1;\n \n #ifdef HAVE_cc0\n@@ -4020,7 +4020,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t  /* If we're replacing an operand with a LABEL_REF, we need\n \t     to make sure that there's a REG_LABEL note attached to\n \t     this instruction.  */\n-\t  if (GET_CODE (insn) != JUMP_INSN\n+\t  if (!JUMP_P (insn)\n \t      && GET_CODE (substitution) == LABEL_REF\n \t      && !find_reg_note (insn, REG_LABEL, XEXP (substitution, 0)))\n \t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL,\n@@ -5528,7 +5528,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t\t   ? XEXP (x, 0)\n \t\t\t   : reg_equiv_mem[regno]);\n \t      int icode = (int) add_optab->handlers[(int) Pmode].insn_code;\n-\t      if (insn && GET_CODE (insn) == INSN && equiv\n+\t      if (insn && NONJUMP_INSN_P (insn) && equiv\n \t\t  && memory_operand (equiv, GET_MODE (equiv))\n #ifdef HAVE_cc0\n \t\t  && ! sets_cc0_p (PATTERN (insn))\n@@ -5954,7 +5954,7 @@ subst_reloads (rtx insn)\n \t     REG_LABEL note to indicate to flow which label this\n \t     register refers to.  */\n \t  if (GET_CODE (*r->where) == LABEL_REF\n-\t      && GET_CODE (insn) == JUMP_INSN)\n+\t      && JUMP_P (insn))\n \t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL,\n \t\t\t\t\t\t  XEXP (*r->where, 0),\n \t\t\t\t\t\t  REG_NOTES (insn));\n@@ -6460,11 +6460,11 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n     {\n       p = PREV_INSN (p);\n       num++;\n-      if (p == 0 || GET_CODE (p) == CODE_LABEL\n+      if (p == 0 || LABEL_P (p)\n \t  || num > PARAM_VALUE (PARAM_MAX_RELOAD_SEARCH_INSNS))\n \treturn 0;\n \n-      if (GET_CODE (p) == INSN\n+      if (NONJUMP_INSN_P (p)\n \t  /* If we don't want spill regs ...  */\n \t  && (! (reload_reg_p != 0\n \t\t && reload_reg_p != (short *) (HOST_WIDE_INT) 1)\n@@ -6655,7 +6655,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \n       /* Don't trust the conversion past a function call\n \t if either of the two is in a call-clobbered register, or memory.  */\n-      if (GET_CODE (p) == CALL_INSN)\n+      if (CALL_P (p))\n \t{\n \t  int i;\n \n@@ -6778,7 +6778,7 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class class, int other,\n \t\t}\n \t    }\n \n-\t  if (GET_CODE (p) == CALL_INSN && CALL_INSN_FUNCTION_USAGE (p))\n+\t  if (CALL_P (p) && CALL_INSN_FUNCTION_USAGE (p))\n \t    {\n \t      rtx link;\n "}, {"sha": "1fc55c33cfd5fdaee0062a8b576d925d2044ebec", "filename": "gcc/reload1.c", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -842,8 +842,7 @@ reload (rtx first, int global)\n      main reload loop in the most common case where register elimination\n      cannot be done.  */\n   for (insn = first; insn && num_eliminable; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n-\t|| GET_CODE (insn) == CALL_INSN)\n+    if (INSN_P (insn))\n       note_stores (PATTERN (insn), mark_not_eliminable, NULL);\n \n   maybe_fix_stack_asms ();\n@@ -1053,7 +1052,7 @@ reload (rtx first, int global)\n \t\t if an insn has a variable address, gets a REG_EH_REGION\n \t\t note added to it, and then gets converted into an load\n \t\t from a constant address.  */\n-\t      if (GET_CODE (equiv_insn) == NOTE\n+\t      if (NOTE_P (equiv_insn)\n \t\t  || can_throw_internal (equiv_insn))\n \t\t;\n \t      else if (reg_set_p (regno_reg_rtx[i], PATTERN (equiv_insn)))\n@@ -1162,7 +1161,7 @@ reload (rtx first, int global)\n       {\n \trtx *pnote;\n \n-\tif (GET_CODE (insn) == CALL_INSN)\n+\tif (CALL_P (insn))\n \t  replace_pseudos_in (& CALL_INSN_FUNCTION_USAGE (insn),\n \t\t\t      VOIDmode, CALL_INSN_FUNCTION_USAGE (insn));\n \n@@ -1436,7 +1435,7 @@ calculate_needs_all_insns (int global)\n \t include REG_LABEL), we need to see what effects this has on the\n \t known offsets at labels.  */\n \n-      if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == JUMP_INSN\n+      if (LABEL_P (insn) || JUMP_P (insn)\n \t  || (INSN_P (insn) && REG_NOTES (insn) != 0))\n \tset_label_offsets (insn, insn, 0);\n \n@@ -2130,7 +2129,7 @@ set_label_offsets (rtx x, rtx insn, int initial_p)\n \n       else if (x == insn\n \t       && (tem = prev_nonnote_insn (insn)) != 0\n-\t       && GET_CODE (tem) == BARRIER)\n+\t       && BARRIER_P (tem))\n \tset_offsets_for_label (insn);\n       else\n \t/* If neither of the above cases is true, compare each offset\n@@ -3788,7 +3787,7 @@ reload_as_needed (int live_known)\n \n       /* If we pass a label, copy the offsets from the label information\n \t into the current offsets of each elimination.  */\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tset_offsets_for_label (insn);\n \n       else if (INSN_P (insn))\n@@ -3811,7 +3810,7 @@ reload_as_needed (int live_known)\n \t  if ((num_eliminable || num_eliminable_invariants) && chain->need_elim)\n \t    {\n \t      eliminate_regs_in_insn (insn, 1);\n-\t      if (GET_CODE (insn) == NOTE)\n+\t      if (NOTE_P (insn))\n \t\t{\n \t\t  update_eliminable_offsets ();\n \t\t  continue;\n@@ -3901,7 +3900,7 @@ reload_as_needed (int live_known)\n \t  /* There may have been CLOBBER insns placed after INSN.  So scan\n \t     between INSN and NEXT and use them to forget old reloads.  */\n \t  for (x = NEXT_INSN (insn); x != old_next; x = NEXT_INSN (x))\n-\t    if (GET_CODE (x) == INSN && GET_CODE (PATTERN (x)) == CLOBBER)\n+\t    if (NONJUMP_INSN_P (x) && GET_CODE (PATTERN (x)) == CLOBBER)\n \t      note_stores (PATTERN (x), forget_old_reloads_1, NULL);\n \n #ifdef AUTO_INC_DEC\n@@ -4022,13 +4021,13 @@ reload_as_needed (int live_known)\n #endif\n \t}\n       /* A reload reg's contents are unknown after a label.  */\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tCLEAR_HARD_REG_SET (reg_reloaded_valid);\n \n       /* Don't assume a reload reg is still good after a call insn\n \t if it is a call-used reg, or if it contains a value that will\n          be partially clobbered by the call.  */\n-      else if (GET_CODE (insn) == CALL_INSN)\n+      else if (CALL_P (insn))\n \t{\n \tAND_COMPL_HARD_REG_SET (reg_reloaded_valid, call_used_reg_set);\n \tAND_COMPL_HARD_REG_SET (reg_reloaded_valid, reg_reloaded_call_part_clobbered);\n@@ -6351,10 +6350,10 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t\t\trl->when_needed, old, rl->out, j, 0))\n     {\n       rtx temp = PREV_INSN (insn);\n-      while (temp && GET_CODE (temp) == NOTE)\n+      while (temp && NOTE_P (temp))\n \ttemp = PREV_INSN (temp);\n       if (temp\n-\t  && GET_CODE (temp) == INSN\n+\t  && NONJUMP_INSN_P (temp)\n \t  && GET_CODE (PATTERN (temp)) == SET\n \t  && SET_DEST (PATTERN (temp)) == old\n \t  /* Make sure we can access insn_operand_constraint.  */\n@@ -6928,7 +6927,7 @@ do_output_reload (struct insn_chain *chain, struct reload *rl, int j)\n     return;\n \n   /* If is a JUMP_INSN, we can't support output reloads yet.  */\n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     abort ();\n \n   emit_output_reload_insns (chain, rld + j, j);\n@@ -7647,14 +7646,14 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n   for (i1 = NEXT_INSN (output_reload_insn);\n        i1 != insn; i1 = NEXT_INSN (i1))\n     {\n-      if (GET_CODE (i1) == CODE_LABEL || GET_CODE (i1) == JUMP_INSN)\n+      if (LABEL_P (i1) || JUMP_P (i1))\n \treturn;\n-      if ((GET_CODE (i1) == INSN || GET_CODE (i1) == CALL_INSN)\n+      if ((NONJUMP_INSN_P (i1) || CALL_P (i1))\n \t  && reg_mentioned_p (reg, PATTERN (i1)))\n \t{\n \t  /* If this is USE in front of INSN, we only have to check that\n \t     there are no more references than accounted for by inheritance.  */\n-\t  while (GET_CODE (i1) == INSN && GET_CODE (PATTERN (i1)) == USE)\n+\t  while (NONJUMP_INSN_P (i1) && GET_CODE (PATTERN (i1)) == USE)\n \t    {\n \t      n_occurrences += rtx_equal_p (reg, XEXP (PATTERN (i1), 0)) != 0;\n \t      i1 = NEXT_INSN (i1);\n@@ -7700,10 +7699,10 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n \t     since if they are the only uses, they are dead.  */\n \t  if (set != 0 && SET_DEST (set) == reg)\n \t    continue;\n-\t  if (GET_CODE (i2) == CODE_LABEL\n-\t      || GET_CODE (i2) == JUMP_INSN)\n+\t  if (LABEL_P (i2)\n+\t      || JUMP_P (i2))\n \t    break;\n-\t  if ((GET_CODE (i2) == INSN || GET_CODE (i2) == CALL_INSN)\n+\t  if ((NONJUMP_INSN_P (i2) || CALL_P (i2))\n \t      && reg_mentioned_p (reg, PATTERN (i2)))\n \t    {\n \t      /* Some other ref remains; just delete the output reload we\n@@ -7725,8 +7724,8 @@ delete_output_reload (rtx insn, int j, int last_reload_reg)\n \t      delete_address_reloads (i2, insn);\n \t      delete_insn (i2);\n \t    }\n-\t  if (GET_CODE (i2) == CODE_LABEL\n-\t      || GET_CODE (i2) == JUMP_INSN)\n+\t  if (LABEL_P (i2)\n+\t      || JUMP_P (i2))\n \t    break;\n \t}\n \n@@ -7837,7 +7836,7 @@ delete_address_reloads_1 (rtx dead_insn, rtx x, rtx current_insn)\n \t it might have been inherited.  */\n       for (i2 = NEXT_INSN (dead_insn); i2; i2 = NEXT_INSN (i2))\n \t{\n-\t  if (GET_CODE (i2) == CODE_LABEL)\n+\t  if (LABEL_P (i2))\n \t    break;\n \t  if (! INSN_P (i2))\n \t    continue;\n@@ -7861,7 +7860,7 @@ delete_address_reloads_1 (rtx dead_insn, rtx x, rtx current_insn)\n \t\t}\n \t      return;\n \t    }\n-\t  if (GET_CODE (i2) == JUMP_INSN)\n+\t  if (JUMP_P (i2))\n \t    break;\n \t  /* If DST is still live at CURRENT_INSN, check if it is used for\n \t     any reload.  Note that even if CURRENT_INSN sets DST, we still\n@@ -8059,7 +8058,7 @@ fixup_abnormal_edges (void)\n \t      == (EDGE_ABNORMAL | EDGE_EH))\n \t    break;\n \t}\n-      if (e && GET_CODE (BB_END (bb)) != CALL_INSN\n+      if (e && !CALL_P (BB_END (bb))\n \t  && !can_throw_internal (BB_END (bb)))\n \t{\n \t  rtx insn = BB_END (bb), stop = NEXT_INSN (BB_END (bb));\n@@ -8069,11 +8068,11 @@ fixup_abnormal_edges (void)\n \t      break;\n \t  /* Get past the new insns generated. Allow notes, as the insns may\n \t     be already deleted.  */\n-\t  while ((GET_CODE (insn) == INSN || GET_CODE (insn) == NOTE)\n+\t  while ((NONJUMP_INSN_P (insn) || NOTE_P (insn))\n \t\t && !can_throw_internal (insn)\n \t\t && insn != BB_HEAD (bb))\n \t    insn = PREV_INSN (insn);\n-\t  if (GET_CODE (insn) != CALL_INSN && !can_throw_internal (insn))\n+\t  if (!CALL_P (insn) && !can_throw_internal (insn))\n \t    abort ();\n \t  BB_END (bb) = insn;\n \t  inserted = true;"}, {"sha": "dbe075a98d695048260fee6d451134347a0eef93", "filename": "gcc/reorg.c", "status": "modified", "additions": 83, "deletions": 86, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -351,17 +351,17 @@ find_end_label (void)\n      label and we don't have to do anything else.  */\n \n   insn = get_last_insn ();\n-  while (GET_CODE (insn) == NOTE\n-\t || (GET_CODE (insn) == INSN\n+  while (NOTE_P (insn)\n+\t || (NONJUMP_INSN_P (insn)\n \t     && (GET_CODE (PATTERN (insn)) == USE\n \t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n     insn = PREV_INSN (insn);\n \n   /* When a target threads its epilogue we might already have a\n      suitable return insn.  If so put a label before it for the\n      end_of_function_label.  */\n-  if (GET_CODE (insn) == BARRIER\n-      && GET_CODE (PREV_INSN (insn)) == JUMP_INSN\n+  if (BARRIER_P (insn)\n+      && JUMP_P (PREV_INSN (insn))\n       && GET_CODE (PATTERN (PREV_INSN (insn))) == RETURN)\n     {\n       rtx temp = PREV_INSN (PREV_INSN (insn));\n@@ -375,7 +375,7 @@ find_end_label (void)\n       emit_label_after (end_of_function_label, temp);\n     }\n \n-  else if (GET_CODE (insn) == CODE_LABEL)\n+  else if (LABEL_P (insn))\n     end_of_function_label = insn;\n   else\n     {\n@@ -470,7 +470,7 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n   /* If INSN is followed by a BARRIER, delete the BARRIER since it will only\n      confuse further processing.  Update LAST in case it was the last insn.\n      We will put the BARRIER back in later.  */\n-  if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n+  if (NEXT_INSN (insn) && BARRIER_P (NEXT_INSN (insn)))\n     {\n       delete_related_insns (NEXT_INSN (insn));\n       last = get_last_insn ();\n@@ -534,7 +534,7 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n \n \t    case REG_LABEL:\n \t      /* Keep the label reference count up to date.  */\n-\t      if (GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n+\t      if (LABEL_P (XEXP (note, 0)))\n \t\tLABEL_NUSES (XEXP (note, 0)) ++;\n \t      break;\n \n@@ -550,13 +550,13 @@ emit_delay_sequence (rtx insn, rtx list, int length)\n      last insn in that SEQUENCE to point to us.  Similarly for the first\n      insn in the following insn if it is a SEQUENCE.  */\n \n-  if (PREV_INSN (seq_insn) && GET_CODE (PREV_INSN (seq_insn)) == INSN\n+  if (PREV_INSN (seq_insn) && NONJUMP_INSN_P (PREV_INSN (seq_insn))\n       && GET_CODE (PATTERN (PREV_INSN (seq_insn))) == SEQUENCE)\n     NEXT_INSN (XVECEXP (PATTERN (PREV_INSN (seq_insn)), 0,\n \t\t\tXVECLEN (PATTERN (PREV_INSN (seq_insn)), 0) - 1))\n       = seq_insn;\n \n-  if (NEXT_INSN (seq_insn) && GET_CODE (NEXT_INSN (seq_insn)) == INSN\n+  if (NEXT_INSN (seq_insn) && NONJUMP_INSN_P (NEXT_INSN (seq_insn))\n       && GET_CODE (PATTERN (NEXT_INSN (seq_insn))) == SEQUENCE)\n     PREV_INSN (XVECEXP (PATTERN (NEXT_INSN (seq_insn)), 0, 0)) = seq_insn;\n \n@@ -616,7 +616,7 @@ delete_from_delay_slot (rtx insn)\n   seq_insn = PREV_INSN (NEXT_INSN (trial));\n   seq = PATTERN (seq_insn);\n \n-  if (NEXT_INSN (seq_insn) && GET_CODE (NEXT_INSN (seq_insn)) == BARRIER)\n+  if (NEXT_INSN (seq_insn) && BARRIER_P (NEXT_INSN (seq_insn)))\n     had_barrier = 1;\n \n   /* Create a delay list consisting of all the insns other than the one\n@@ -641,9 +641,7 @@ delete_from_delay_slot (rtx insn)\n      annul flag.  */\n   if (delay_list)\n     trial = emit_delay_sequence (trial, delay_list, XVECLEN (seq, 0) - 2);\n-  else if (GET_CODE (trial) == JUMP_INSN\n-\t   || GET_CODE (trial) == CALL_INSN\n-\t   || GET_CODE (trial) == INSN)\n+  else if (INSN_P (trial))\n     INSN_ANNULLED_BRANCH_P (trial) = 0;\n \n   INSN_FROM_TARGET_P (insn) = 0;\n@@ -686,7 +684,7 @@ delete_scheduled_jump (rtx insn)\n \t     a delay slot.  It will be the last insn in the delay slot, if\n \t     it is.  */\n \t  rtx trial = previous_insn (insn);\n-\t  if (GET_CODE (trial) == NOTE)\n+\t  if (NOTE_P (trial))\n \t    trial = prev_nonnote_insn (trial);\n \t  if (sets_cc0_p (PATTERN (trial)) != 1\n \t      || FIND_REG_INC_NOTE (trial, NULL_RTX))\n@@ -768,7 +766,7 @@ optimize_skip (rtx insn)\n   flags = get_jump_flags (insn, JUMP_LABEL (insn));\n \n   if (trial == 0\n-      || GET_CODE (trial) != INSN\n+      || !NONJUMP_INSN_P (trial)\n       || GET_CODE (PATTERN (trial)) == SEQUENCE\n       || recog_memoized (trial) < 0\n       || (! eligible_for_annul_false (insn, 0, trial, flags)\n@@ -785,7 +783,7 @@ optimize_skip (rtx insn)\n   if ((next_trial == next_active_insn (JUMP_LABEL (insn))\n        && ! (next_trial == 0 && current_function_epilogue_delay_list != 0))\n       || (next_trial != 0\n-\t  && GET_CODE (next_trial) == JUMP_INSN\n+\t  && JUMP_P (next_trial)\n \t  && JUMP_LABEL (insn) == JUMP_LABEL (next_trial)\n \t  && (simplejump_p (next_trial)\n \t      || GET_CODE (PATTERN (next_trial)) == RETURN)))\n@@ -807,7 +805,7 @@ optimize_skip (rtx insn)\n \t branch, thread our jump to the target of that branch.  Don't\n \t change this into a RETURN here, because it may not accept what\n \t we have in the delay slot.  We'll fix this up later.  */\n-      if (next_trial && GET_CODE (next_trial) == JUMP_INSN\n+      if (next_trial && JUMP_P (next_trial)\n \t  && (simplejump_p (next_trial)\n \t      || GET_CODE (PATTERN (next_trial)) == RETURN))\n \t{\n@@ -851,7 +849,7 @@ get_jump_flags (rtx insn, rtx label)\n \n      If LABEL is zero, then there is no way to determine the branch\n      direction.  */\n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && (condjump_p (insn) || condjump_in_parallel_p (insn))\n       && INSN_UID (insn) <= max_uid\n       && label != 0\n@@ -867,7 +865,7 @@ get_jump_flags (rtx insn, rtx label)\n      determine the branch prediction.\n \n      Non conditional branches are predicted as very likely taken.  */\n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && (condjump_p (insn) || condjump_in_parallel_p (insn)))\n     {\n       int prediction;\n@@ -911,7 +909,7 @@ rare_destination (rtx insn)\n \n   for (; insn; insn = next)\n     {\n-      if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \tinsn = XVECEXP (PATTERN (insn), 0, 0);\n \n       next = NEXT_INSN (insn);\n@@ -997,7 +995,7 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n \t before the next real insn, we assume the branch is to the top of\n \t the loop.  */\n       for (insn = PREV_INSN (target_label);\n-\t   insn && GET_CODE (insn) == NOTE;\n+\t   insn && NOTE_P (insn);\n \t   insn = PREV_INSN (insn))\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n \t  return 2;\n@@ -1007,7 +1005,7 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n \t before the next real insn, we assume the branch is to the loop branch\n \t test.  */\n       for (insn = NEXT_INSN (target_label);\n-\t   insn && GET_CODE (insn) == NOTE;\n+\t   insn && NOTE_P (insn);\n \t   insn = PREV_INSN (insn))\n \tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP)\n \t  return 1;\n@@ -1506,7 +1504,7 @@ try_merge_delay_insns (rtx insn, rtx thread)\n       next_trial = next_nonnote_insn (trial);\n \n       /* TRIAL must be a CALL_INSN or INSN.  Skip USE and CLOBBER.  */\n-      if (GET_CODE (trial) == INSN\n+      if (NONJUMP_INSN_P (trial)\n \t  && (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER))\n \tcontinue;\n \n@@ -1554,7 +1552,7 @@ try_merge_delay_insns (rtx insn, rtx thread)\n   /* See if we stopped on a filled insn.  If we did, try to see if its\n      delay slots match.  */\n   if (slot_number != num_slots\n-      && trial && GET_CODE (trial) == INSN\n+      && trial && NONJUMP_INSN_P (trial)\n       && GET_CODE (PATTERN (trial)) == SEQUENCE\n       && ! INSN_ANNULLED_BRANCH_P (XVECEXP (PATTERN (trial), 0, 0)))\n     {\n@@ -1679,7 +1677,7 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n        trial && insns_to_search > 0;\n        trial = PREV_INSN (trial), --insns_to_search)\n     {\n-      if (GET_CODE (trial) == CODE_LABEL)\n+      if (LABEL_P (trial))\n \treturn 0;\n \n       if (! INSN_P (trial))\n@@ -1693,7 +1691,7 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n \t{\n \t  /* Stop for a CALL and its delay slots because it is difficult to\n \t     track its resource needs correctly.  */\n-\t  if (GET_CODE (XVECEXP (pat, 0, 0)) == CALL_INSN)\n+\t  if (CALL_P (XVECEXP (pat, 0, 0)))\n \t    return 0;\n \n \t  /* Stop for an INSN or JUMP_INSN with delayed effects and its delay\n@@ -1741,7 +1739,7 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n   mark_referenced_resources (insn, &needed, 1);\n \n   /* If TARGET is a SEQUENCE, get the main insn.  */\n-  if (GET_CODE (target) == INSN && GET_CODE (PATTERN (target)) == SEQUENCE)\n+  if (NONJUMP_INSN_P (target) && GET_CODE (PATTERN (target)) == SEQUENCE)\n     target_main = XVECEXP (PATTERN (target), 0, 0);\n \n   if (resource_conflicts_p (&needed, &set)\n@@ -1770,7 +1768,7 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n       delay_list = XEXP (delay_list, 1);\n     }\n \n-  if (GET_CODE (target) == INSN && GET_CODE (PATTERN (target)) == SEQUENCE)\n+  if (NONJUMP_INSN_P (target) && GET_CODE (PATTERN (target)) == SEQUENCE)\n     for (i = 1; i < XVECLEN (PATTERN (target), 0); i++)\n       if (insn_sets_resource_p (XVECEXP (PATTERN (target), 0, i), &needed, 1))\n \treturn 0;\n@@ -1780,11 +1778,10 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n \n   for (trial = PREV_INSN (target),\n \t insns_to_search = MAX_DELAY_SLOT_INSN_SEARCH;\n-       trial && GET_CODE (trial) != CODE_LABEL && insns_to_search > 0;\n+       trial && !LABEL_P (trial) && insns_to_search > 0;\n        trial = PREV_INSN (trial), --insns_to_search)\n     {\n-      if (GET_CODE (trial) != INSN && GET_CODE (trial) != CALL_INSN\n-\t  && GET_CODE (trial) != JUMP_INSN)\n+      if (!INSN_P (trial))\n \tcontinue;\n \n       pat = PATTERN (trial);\n@@ -1795,7 +1792,7 @@ redundant_insn (rtx insn, rtx target, rtx delay_list)\n \t{\n \t  /* If this is a CALL_INSN and its delay slots, it is hard to track\n \t     the resource needs properly, so give up.  */\n-\t  if (GET_CODE (XVECEXP (pat, 0, 0)) == CALL_INSN)\n+\t  if (CALL_P (XVECEXP (pat, 0, 0)))\n \t    return 0;\n \n \t  /* If this is an INSN or JUMP_INSN with delayed effects, it\n@@ -1879,7 +1876,7 @@ own_thread_p (rtx thread, rtx label, int allow_fallthrough)\n   active_insn = next_active_insn (PREV_INSN (thread));\n \n   for (insn = thread; insn != active_insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CODE_LABEL\n+    if (LABEL_P (insn)\n \t&& (insn != label || LABEL_NUSES (insn) != 1))\n       return 0;\n \n@@ -1888,11 +1885,11 @@ own_thread_p (rtx thread, rtx label, int allow_fallthrough)\n \n   /* Ensure that we reach a BARRIER before any insn or label.  */\n   for (insn = prev_nonnote_insn (thread);\n-       insn == 0 || GET_CODE (insn) != BARRIER;\n+       insn == 0 || !BARRIER_P (insn);\n        insn = prev_nonnote_insn (insn))\n     if (insn == 0\n-\t|| GET_CODE (insn) == CODE_LABEL\n-\t|| (GET_CODE (insn) == INSN\n+\t|| LABEL_P (insn)\n+\t|| (NONJUMP_INSN_P (insn)\n \t    && GET_CODE (PATTERN (insn)) != USE\n \t    && GET_CODE (PATTERN (insn)) != CLOBBER))\n       return 0;\n@@ -2061,10 +2058,10 @@ fill_simple_delay_slots (int non_jumps_p)\n       insn = unfilled_slots_base[i];\n       if (insn == 0\n \t  || INSN_DELETED_P (insn)\n-\t  || (GET_CODE (insn) == INSN\n+\t  || (NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t  || (GET_CODE (insn) == JUMP_INSN && non_jumps_p)\n-\t  || (GET_CODE (insn) != JUMP_INSN && ! non_jumps_p))\n+\t  || (JUMP_P (insn) && non_jumps_p)\n+\t  || (!JUMP_P (insn) && ! non_jumps_p))\n \tcontinue;\n \n       /* It may have been that this insn used to need delay slots, but\n@@ -2108,13 +2105,13 @@ fill_simple_delay_slots (int non_jumps_p)\n       slots_filled = 0;\n       delay_list = 0;\n \n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \tflags = get_jump_flags (insn, JUMP_LABEL (insn));\n       else\n \tflags = get_jump_flags (insn, NULL_RTX);\n \n       if ((trial = next_active_insn (insn))\n-\t  && GET_CODE (trial) == JUMP_INSN\n+\t  && JUMP_P (trial)\n \t  && simplejump_p (trial)\n \t  && eligible_for_delay (insn, slots_filled, trial, flags)\n \t  && no_labels_between_p (insn, trial)\n@@ -2221,7 +2218,7 @@ fill_simple_delay_slots (int non_jumps_p)\n #if defined(ANNUL_IFFALSE_SLOTS) || defined(ANNUL_IFTRUE_SLOTS)\n       if (slots_filled != slots_to_fill\n \t  && delay_list == 0\n-\t  && GET_CODE (insn) == JUMP_INSN\n+\t  && JUMP_P (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn)))\n \t{\n \t  delay_list = optimize_skip (insn);\n@@ -2265,7 +2262,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t     Presumably, we should also check to see if we could get\n \t     back to this function via `setjmp'.  */\n \t  && ! can_throw_internal (insn)\n-\t  && (GET_CODE (insn) != JUMP_INSN\n+\t  && (!JUMP_P (insn)\n \t      || ((condjump_p (insn) || condjump_in_parallel_p (insn))\n \t\t  && ! simplejump_p (insn)\n \t\t  && JUMP_LABEL (insn) != 0)))\n@@ -2279,7 +2276,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  CLEAR_RESOURCE (&needed);\n \t  CLEAR_RESOURCE (&set);\n \n-\t  if (GET_CODE (insn) == CALL_INSN)\n+\t  if (CALL_P (insn))\n \t    {\n \t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t      mark_referenced_resources (insn, &needed, 1);\n@@ -2289,7 +2286,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t    {\n \t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t      mark_referenced_resources (insn, &needed, 1);\n-\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t      if (JUMP_P (insn))\n \t\ttarget = JUMP_LABEL (insn);\n \t    }\n \n@@ -2298,8 +2295,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      {\n \t\tnext_trial = next_nonnote_insn (trial);\n \n-\t\tif (GET_CODE (trial) == CODE_LABEL\n-\t\t    || GET_CODE (trial) == BARRIER)\n+\t\tif (LABEL_P (trial)\n+\t\t    || BARRIER_P (trial))\n \t\t  break;\n \n \t\t/* We must have an INSN, JUMP_INSN, or CALL_INSN.  */\n@@ -2317,7 +2314,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\t  trial_delay = trial;\n \n \t\t/* Stop our search when seeing an unconditional jump.  */\n-\t\tif (GET_CODE (trial_delay) == JUMP_INSN)\n+\t\tif (JUMP_P (trial_delay))\n \t\t  break;\n \n \t\t/* See if we have a resource problem before we try to\n@@ -2357,8 +2354,8 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\tset.cc = 1;\n \n \t\t/* If this is a call or jump, we might not get here.  */\n-\t\tif (GET_CODE (trial_delay) == CALL_INSN\n-\t\t    || GET_CODE (trial_delay) == JUMP_INSN)\n+\t\tif (CALL_P (trial_delay)\n+\t\t    || JUMP_P (trial_delay))\n \t\t  maybe_never = 1;\n \t      }\n \n@@ -2369,13 +2366,13 @@ fill_simple_delay_slots (int non_jumps_p)\n \t     Don't do this if the insn at the branch target is a branch.  */\n \t  if (slots_to_fill != slots_filled\n \t      && trial\n-\t      && GET_CODE (trial) == JUMP_INSN\n+\t      && JUMP_P (trial)\n \t      && simplejump_p (trial)\n \t      && (target == 0 || JUMP_LABEL (trial) == target)\n \t      && (next_trial = next_active_insn (JUMP_LABEL (trial))) != 0\n-\t      && ! (GET_CODE (next_trial) == INSN\n+\t      && ! (NONJUMP_INSN_P (next_trial)\n \t\t    && GET_CODE (PATTERN (next_trial)) == SEQUENCE)\n-\t      && GET_CODE (next_trial) != JUMP_INSN\n+\t      && !JUMP_P (next_trial)\n \t      && ! insn_references_resource_p (next_trial, &set, 1)\n \t      && ! insn_sets_resource_p (next_trial, &set, 1)\n \t      && ! insn_sets_resource_p (next_trial, &needed, 1)\n@@ -2413,7 +2410,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \n       /* If this is an unconditional jump, then try to get insns from the\n \t target of the jump.  */\n-      if (GET_CODE (insn) == JUMP_INSN\n+      if (JUMP_P (insn)\n \t  && simplejump_p (insn)\n \t  && slots_filled != slots_to_fill)\n \tdelay_list\n@@ -2479,7 +2476,7 @@ fill_simple_delay_slots (int non_jumps_p)\n   for (trial = get_last_insn (); ! stop_search_p (trial, 1);\n        trial = PREV_INSN (trial))\n     {\n-      if (GET_CODE (trial) == NOTE)\n+      if (NOTE_P (trial))\n \tcontinue;\n       pat = PATTERN (trial);\n       if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n@@ -2607,7 +2604,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       rtx pat, old_trial;\n \n       /* If we have passed a label, we no longer own this thread.  */\n-      if (GET_CODE (trial) == CODE_LABEL)\n+      if (LABEL_P (trial))\n \t{\n \t  own_thread = 0;\n \t  continue;\n@@ -2728,12 +2725,12 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t\t\t label lest it be deleted by delete_related_insns.  */\n \t\t      note = find_reg_note (trial, REG_LABEL, 0);\n \t\t      /* REG_LABEL could be NOTE_INSN_DELETED_LABEL too.  */\n-\t\t      if (note && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n+\t\t      if (note && LABEL_P (XEXP (note, 0)))\n \t\t\tLABEL_NUSES (XEXP (note, 0))++;\n \n \t\t      delete_related_insns (trial);\n \n-\t\t      if (note && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n+\t\t      if (note && LABEL_P (XEXP (note, 0)))\n \t\t\tLABEL_NUSES (XEXP (note, 0))--;\n \t\t    }\n \t\t  else\n@@ -2800,14 +2797,14 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t a PRE_INC.  We also can't do this if there's overlap of source and\n \t destination.  Overlap may happen for larger-than-register-size modes.  */\n \n-      if (GET_CODE (trial) == INSN && GET_CODE (pat) == SET\n+      if (NONJUMP_INSN_P (trial) && GET_CODE (pat) == SET\n \t  && REG_P (SET_SRC (pat))\n \t  && REG_P (SET_DEST (pat))\n \t  && !reg_overlap_mentioned_p (SET_DEST (pat), SET_SRC (pat)))\n \t{\n \t  rtx next = next_nonnote_insn (trial);\n \n-\t  if (next && GET_CODE (next) == INSN\n+\t  if (next && NONJUMP_INSN_P (next)\n \t      && GET_CODE (PATTERN (next)) != USE\n \t      && ! reg_set_p (SET_DEST (pat), next)\n \t      && ! reg_set_p (SET_SRC (pat), next)\n@@ -2819,9 +2816,9 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \n   /* If we stopped on a branch insn that has delay slots, see if we can\n      steal some of the insns in those slots.  */\n-  if (trial && GET_CODE (trial) == INSN\n+  if (trial && NONJUMP_INSN_P (trial)\n       && GET_CODE (PATTERN (trial)) == SEQUENCE\n-      && GET_CODE (XVECEXP (PATTERN (trial), 0, 0)) == JUMP_INSN)\n+      && JUMP_P (XVECEXP (PATTERN (trial), 0, 0)))\n     {\n       /* If this is the `true' thread, we will want to follow the jump,\n \t so we can only do this if we have taken everything up to here.  */\n@@ -2854,7 +2851,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n      arithmetic insn after the jump insn and put the arithmetic insn in the\n      delay slot.  If we can't do this, return.  */\n   if (delay_list == 0 && likely && new_thread\n-      && GET_CODE (new_thread) == INSN\n+      && NONJUMP_INSN_P (new_thread)\n       && GET_CODE (PATTERN (new_thread)) != ASM_INPUT\n       && asm_noperands (PATTERN (new_thread)) < 0)\n     {\n@@ -2865,7 +2862,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       trial = new_thread;\n       pat = PATTERN (trial);\n \n-      if (GET_CODE (trial) != INSN\n+      if (!NONJUMP_INSN_P (trial)\n \t  || GET_CODE (pat) != SET\n \t  || ! eligible_for_delay (insn, 0, trial, flags)\n \t  || can_throw_internal (trial))\n@@ -2937,7 +2934,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n       if (! thread_if_true)\n \tabort ();\n \n-      if (new_thread && GET_CODE (new_thread) == JUMP_INSN\n+      if (new_thread && JUMP_P (new_thread)\n \t  && (simplejump_p (new_thread)\n \t      || GET_CODE (PATTERN (new_thread)) == RETURN)\n \t  && redirect_with_delay_list_safe_p (insn,\n@@ -2947,7 +2944,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \n       if (new_thread == 0)\n \tlabel = find_end_label ();\n-      else if (GET_CODE (new_thread) == CODE_LABEL)\n+      else if (LABEL_P (new_thread))\n \tlabel = new_thread;\n       else\n \tlabel = get_label_before (new_thread);\n@@ -2988,7 +2985,7 @@ fill_eager_delay_slots (void)\n       insn = unfilled_slots_base[i];\n       if (insn == 0\n \t  || INSN_DELETED_P (insn)\n-\t  || GET_CODE (insn) != JUMP_INSN\n+\t  || !JUMP_P (insn)\n \t  || ! (condjump_p (insn) || condjump_in_parallel_p (insn)))\n \tcontinue;\n \n@@ -3113,7 +3110,7 @@ relax_delay_slots (rtx first)\n       /* If this is a jump insn, see if it now jumps to a jump, jumps to\n \t the next insn, or jumps to a label that is not the last of a\n \t group of consecutive labels.  */\n-      if (GET_CODE (insn) == JUMP_INSN\n+      if (JUMP_P (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && (target_label = JUMP_LABEL (insn)) != 0)\n \t{\n@@ -3134,7 +3131,7 @@ relax_delay_slots (rtx first)\n \t  /* See if this jump branches around an unconditional jump.\n \t     If so, invert this jump and point it to the target of the\n \t     second jump.  */\n-\t  if (next && GET_CODE (next) == JUMP_INSN\n+\t  if (next && JUMP_P (next)\n \t      && (simplejump_p (next) || GET_CODE (PATTERN (next)) == RETURN)\n \t      && target_label\n \t      && next_active_insn (target_label) == next_active_insn (next)\n@@ -3177,7 +3174,7 @@ relax_delay_slots (rtx first)\n \t Don't do this if we expect the conditional branch to be true, because\n \t we would then be making the more common case longer.  */\n \n-      if (GET_CODE (insn) == JUMP_INSN\n+      if (JUMP_P (insn)\n \t  && (simplejump_p (insn) || GET_CODE (PATTERN (insn)) == RETURN)\n \t  && (other = prev_active_insn (insn)) != 0\n \t  && (condjump_p (other) || condjump_in_parallel_p (other))\n@@ -3194,7 +3191,7 @@ relax_delay_slots (rtx first)\n \t}\n \n       /* Now look only at cases where we have filled a delay slot.  */\n-      if (GET_CODE (insn) != INSN\n+      if (!NONJUMP_INSN_P (insn)\n \t  || GET_CODE (PATTERN (insn)) != SEQUENCE)\n \tcontinue;\n \n@@ -3221,7 +3218,7 @@ relax_delay_slots (rtx first)\n       if (optimize_size\n \t  && GET_CODE (PATTERN (delay_insn)) == RETURN\n \t  && next\n-\t  && GET_CODE (next) == JUMP_INSN\n+\t  && JUMP_P (next)\n \t  && GET_CODE (PATTERN (next)) == RETURN)\n \t{\n \t  rtx after;\n@@ -3255,7 +3252,7 @@ relax_delay_slots (rtx first)\n \t}\n \n       /* Now look only at the cases where we have a filled JUMP_INSN.  */\n-      if (GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) != JUMP_INSN\n+      if (!JUMP_P (XVECEXP (PATTERN (insn), 0, 0))\n \t  || ! (condjump_p (XVECEXP (PATTERN (insn), 0, 0))\n \t\t|| condjump_in_parallel_p (XVECEXP (PATTERN (insn), 0, 0))))\n \tcontinue;\n@@ -3308,7 +3305,7 @@ relax_delay_slots (rtx first)\n \t     delay list and that insn is redundant, thread the jump.  */\n \t  if (trial && GET_CODE (PATTERN (trial)) == SEQUENCE\n \t      && XVECLEN (PATTERN (trial), 0) == 2\n-\t      && GET_CODE (XVECEXP (PATTERN (trial), 0, 0)) == JUMP_INSN\n+\t      && JUMP_P (XVECEXP (PATTERN (trial), 0, 0))\n \t      && (simplejump_p (XVECEXP (PATTERN (trial), 0, 0))\n \t\t  || GET_CODE (PATTERN (XVECEXP (PATTERN (trial), 0, 0))) == RETURN)\n \t      && redundant_insn (XVECEXP (PATTERN (trial), 0, 1), insn, 0))\n@@ -3376,7 +3373,7 @@ relax_delay_slots (rtx first)\n       /* See if this is an unconditional jump around a single insn which is\n \t identical to the one in its delay slot.  In this case, we can just\n \t delete the branch and the insn in its delay slot.  */\n-      if (next && GET_CODE (next) == INSN\n+      if (next && NONJUMP_INSN_P (next)\n \t  && prev_label (next_active_insn (next)) == target_label\n \t  && simplejump_p (insn)\n \t  && XVECLEN (pat, 0) == 2\n@@ -3392,7 +3389,7 @@ relax_delay_slots (rtx first)\n \t annulled jumps, though.  Again, don't convert a jump to a RETURN\n \t here.  */\n       if (! INSN_ANNULLED_BRANCH_P (delay_insn)\n-\t  && next && GET_CODE (next) == JUMP_INSN\n+\t  && next && JUMP_P (next)\n \t  && (simplejump_p (next) || GET_CODE (PATTERN (next)) == RETURN)\n \t  && next_active_insn (target_label) == next_active_insn (next)\n \t  && no_labels_between_p (insn, next))\n@@ -3480,7 +3477,7 @@ make_return_insns (rtx first)\n      made for END_OF_FUNCTION_LABEL.  If so, set up anything we can't change\n      into a RETURN to jump to it.  */\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) == RETURN)\n+    if (JUMP_P (insn) && GET_CODE (PATTERN (insn)) == RETURN)\n       {\n \treal_return_label = get_label_before (insn);\n \tbreak;\n@@ -3499,9 +3496,9 @@ make_return_insns (rtx first)\n \n       /* Only look at filled JUMP_INSNs that go to the end of function\n \t label.  */\n-      if (GET_CODE (insn) != INSN\n+      if (!NONJUMP_INSN_P (insn)\n \t  || GET_CODE (PATTERN (insn)) != SEQUENCE\n-\t  || GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) != JUMP_INSN\n+\t  || !JUMP_P (XVECEXP (PATTERN (insn), 0, 0))\n \t  || JUMP_LABEL (XVECEXP (PATTERN (insn), 0, 0)) != end_of_function_label)\n \tcontinue;\n \n@@ -3617,7 +3614,7 @@ dbr_schedule (rtx first, FILE *file)\n     {\n       if (INSN_UID (insn) > max_uid)\n \tmax_uid = INSN_UID (insn);\n-      if (GET_CODE (insn) == NOTE\n+      if (NOTE_P (insn)\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n \tepilogue_insn = insn;\n     }\n@@ -3641,7 +3638,7 @@ dbr_schedule (rtx first, FILE *file)\n       INSN_FROM_TARGET_P (insn) = 0;\n \n       /* Skip vector tables.  We can't get attributes for them.  */\n-      if (GET_CODE (insn) == JUMP_INSN\n+      if (JUMP_P (insn)\n \t  && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n \tcontinue;\n@@ -3650,7 +3647,7 @@ dbr_schedule (rtx first, FILE *file)\n \tobstack_ptr_grow (&unfilled_slots_obstack, insn);\n \n       /* Ensure all jumps go to the last of a set of consecutive labels.  */\n-      if (GET_CODE (insn) == JUMP_INSN\n+      if (JUMP_P (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n \t  && JUMP_LABEL (insn) != 0\n \t  && ((target = skip_consecutive_labels (JUMP_LABEL (insn)))\n@@ -3686,7 +3683,7 @@ dbr_schedule (rtx first, FILE *file)\n     {\n       next = NEXT_INSN (insn);\n \n-      if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE\n+      if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE\n \t  && INSN_P (XEXP (PATTERN (insn), 0)))\n \tnext = delete_related_insns (insn);\n     }\n@@ -3743,7 +3740,7 @@ dbr_schedule (rtx first, FILE *file)\n       for (insn = first; insn; insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_DELETED_P (insn)\n-\t      && GET_CODE (insn) == INSN\n+\t      && NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) != USE\n \t      && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t    {\n@@ -3801,14 +3798,14 @@ dbr_schedule (rtx first, FILE *file)\n     {\n       int pred_flags;\n \n-      if (GET_CODE (insn) == INSN)\n+      if (NONJUMP_INSN_P (insn))\n \t{\n \t  rtx pat = PATTERN (insn);\n \n \t  if (GET_CODE (pat) == SEQUENCE)\n \t    insn = XVECEXP (pat, 0, 0);\n \t}\n-      if (GET_CODE (insn) != JUMP_INSN)\n+      if (!JUMP_P (insn))\n \tcontinue;\n \n       pred_flags = get_jump_flags (insn, JUMP_LABEL (insn));"}, {"sha": "a60e96296f33a50e824ceef239a24b5504c8b298", "filename": "gcc/resource.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -136,7 +136,7 @@ find_basic_block (rtx insn, int search_limit)\n   /* Scan backwards to the previous BARRIER.  Then see if we can find a\n      label that starts a basic block.  Return the basic block number.  */\n   for (insn = prev_nonnote_insn (insn);\n-       insn && GET_CODE (insn) != BARRIER && search_limit != 0;\n+       insn && !BARRIER_P (insn) && search_limit != 0;\n        insn = prev_nonnote_insn (insn), --search_limit)\n     ;\n \n@@ -151,7 +151,7 @@ find_basic_block (rtx insn, int search_limit)\n   /* See if any of the upcoming CODE_LABELs start a basic block.  If we reach\n      anything other than a CODE_LABEL or note, we can't find this code.  */\n   for (insn = next_nonnote_insn (insn);\n-       insn && GET_CODE (insn) == CODE_LABEL;\n+       insn && LABEL_P (insn);\n        insn = next_nonnote_insn (insn))\n     {\n       FOR_EACH_BB (bb)\n@@ -172,9 +172,7 @@ next_insn_no_annul (rtx insn)\n     {\n       /* If INSN is an annulled branch, skip any insns from the target\n \t of the branch.  */\n-      if ((GET_CODE (insn) == JUMP_INSN\n-\t   || GET_CODE (insn) == CALL_INSN\n-\t   || GET_CODE (insn) == INSN)\n+      if (INSN_P (insn)\n \t  && INSN_ANNULLED_BRANCH_P (insn)\n \t  && NEXT_INSN (PREV_INSN (insn)) != insn)\n \t{\n@@ -191,7 +189,7 @@ next_insn_no_annul (rtx insn)\n \t}\n \n       insn = NEXT_INSN (insn);\n-      if (insn && GET_CODE (insn) == INSN\n+      if (insn && NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \tinsn = XVECEXP (PATTERN (insn), 0, 0);\n     }\n@@ -495,7 +493,7 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t      for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n \t\t{\n \t\t  this_jump_insn = XVECEXP (PATTERN (insn), 0, i);\n-\t\t  if (GET_CODE (this_jump_insn) == JUMP_INSN)\n+\t\t  if (JUMP_P (this_jump_insn))\n \t\t    break;\n \t\t}\n \t    }\n@@ -504,7 +502,7 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t  break;\n \t}\n \n-      if (GET_CODE (this_jump_insn) == JUMP_INSN)\n+      if (JUMP_P (this_jump_insn))\n \t{\n \t  if (jump_count++ < 10)\n \t    {\n@@ -982,11 +980,11 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n       start_insn = (b == 0 ? insns : BB_HEAD (BASIC_BLOCK (b)));\n       stop_insn = target;\n \n-      if (GET_CODE (start_insn) == INSN\n+      if (NONJUMP_INSN_P (start_insn)\n \t  && GET_CODE (PATTERN (start_insn)) == SEQUENCE)\n \tstart_insn = XVECEXP (PATTERN (start_insn), 0, 0);\n \n-      if (GET_CODE (stop_insn) == INSN\n+      if (NONJUMP_INSN_P (stop_insn)\n \t  && GET_CODE (PATTERN (stop_insn)) == SEQUENCE)\n \tstop_insn = next_insn (PREV_INSN (stop_insn));\n \n@@ -1010,7 +1008,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t      && INSN_P (XEXP (PATTERN (insn), 0)))\n \t      real_insn = XEXP (PATTERN (insn), 0);\n \n-\t  if (GET_CODE (real_insn) == CALL_INSN)\n+\t  if (CALL_P (real_insn))\n \t    {\n \t      /* CALL clobbers all call-used regs that aren't fixed except\n \t\t sp, ap, and fp.  Do this before setting the result of the\n@@ -1030,11 +1028,11 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t     parameters.  But they might be early.  A CALL_INSN will usually\n \t     clobber registers used for parameters.  It isn't worth bothering\n \t     with the unlikely case when it won't.  */\n-\t  if ((GET_CODE (real_insn) == INSN\n+\t  if ((NONJUMP_INSN_P (real_insn)\n \t       && GET_CODE (PATTERN (real_insn)) != USE\n \t       && GET_CODE (PATTERN (real_insn)) != CLOBBER)\n-\t      || GET_CODE (real_insn) == JUMP_INSN\n-\t      || GET_CODE (real_insn) == CALL_INSN)\n+\t      || JUMP_P (real_insn)\n+\t      || CALL_P (real_insn))\n \t    {\n \t      for (link = REG_NOTES (real_insn); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_DEAD\n@@ -1071,7 +1069,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t\t  }\n \t    }\n \n-\t  else if (GET_CODE (real_insn) == CODE_LABEL)\n+\t  else if (LABEL_P (real_insn))\n \t    {\n \t      /* A label clobbers the pending dead registers since neither\n \t\t reload nor jump will propagate a value across a label.  */\n@@ -1082,7 +1080,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t  /* The beginning of the epilogue corresponds to the end of the\n \t     RTL chain when there are no epilogue insns.  Certain resources\n \t     are implicitly required at that point.  */\n-\t  else if (GET_CODE (real_insn) == NOTE\n+\t  else if (NOTE_P (real_insn)\n \t\t   && NOTE_LINE_NUMBER (real_insn) == NOTE_INSN_EPILOGUE_BEG)\n \t    IOR_HARD_REG_SET (current_live_regs, start_of_epilogue_needs.regs);\n \t}"}, {"sha": "f9495b53d231ab1a46ffb76b4cc92f5026025dc7", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -276,12 +276,10 @@ struct rtx_def GTY((chain_next (\"RTX_NEXT (&%h)\"),\n \n /* FIXME: the \"NEXT_INSN (PREV_INSN (X)) == X\" condition shouldn't be needed.\n  */\n-#define RTX_PREV(X) ((GET_CODE (X) == INSN              \\\n-                      || GET_CODE (X) == CALL_INSN      \\\n-                      || GET_CODE (X) == JUMP_INSN      \\\n-                      || GET_CODE (X) == NOTE           \\\n-                      || GET_CODE (X) == BARRIER        \\\n-                      || GET_CODE (X) == CODE_LABEL)    \\\n+#define RTX_PREV(X) ((INSN_P (X)       \t\t\t\\\n+                      || NOTE_P (X)       \t\t\\\n+                      || BARRIER_P (X)        \t\t\\\n+                      || LABEL_P (X))    \t\t\\\n                      && PREV_INSN (X) != NULL           \\\n                      && NEXT_INSN (PREV_INSN (X)) == X  \\\n                      ? PREV_INSN (X) : NULL)"}, {"sha": "b802e3f55d6b4ec44b33738e60bddcab73e79047", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -631,7 +631,7 @@ global_reg_mentioned_p (rtx x)\n {\n   if (INSN_P (x))\n     {\n-      if (GET_CODE (x) == CALL_INSN)\n+      if (CALL_P (x))\n \t{\n \t  if (! CONST_OR_PURE_CALL_P (x))\n \t    return 1;\n@@ -784,7 +784,7 @@ no_labels_between_p (rtx beg, rtx end)\n   if (beg == end)\n     return 0;\n   for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n-    if (GET_CODE (p) == CODE_LABEL)\n+    if (LABEL_P (p))\n       return 0;\n   return 1;\n }\n@@ -797,7 +797,7 @@ no_jumps_between_p (rtx beg, rtx end)\n {\n   rtx p;\n   for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n-    if (GET_CODE (p) == JUMP_INSN)\n+    if (JUMP_P (p))\n       return 0;\n   return 1;\n }\n@@ -816,7 +816,7 @@ reg_used_between_p (rtx reg, rtx from_insn, rtx to_insn)\n   for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn)\n \t&& (reg_overlap_mentioned_p (reg, PATTERN (insn))\n-\t   || (GET_CODE (insn) == CALL_INSN\n+\t   || (CALL_P (insn)\n \t      && (find_reg_fusage (insn, USE, reg)\n \t\t  || find_reg_fusage (insn, CLOBBER, reg)))))\n       return 1;\n@@ -915,7 +915,7 @@ reg_referenced_between_p (rtx reg, rtx from_insn, rtx to_insn)\n   for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn)\n \t&& (reg_referenced_p (reg, PATTERN (insn))\n-\t   || (GET_CODE (insn) == CALL_INSN\n+\t   || (CALL_P (insn)\n \t      && find_reg_fusage (insn, USE, reg))))\n       return 1;\n   return 0;\n@@ -946,7 +946,7 @@ reg_set_p (rtx reg, rtx insn)\n      check if a side-effect of the insn clobbers REG.  */\n   if (INSN_P (insn)\n       && (FIND_REG_INC_NOTE (insn, reg)\n-\t  || (GET_CODE (insn) == CALL_INSN\n+\t  || (CALL_P (insn)\n \t      /* We'd like to test call_used_regs here, but rtlanal.c can't\n \t\t reference that variable due to its use in genattrtab.  So\n \t\t we'll just be more conservative.\n@@ -1368,7 +1368,7 @@ find_last_value (rtx x, rtx *pinsn, rtx valid_to, int allow_hwreg)\n {\n   rtx p;\n \n-  for (p = PREV_INSN (*pinsn); p && GET_CODE (p) != CODE_LABEL;\n+  for (p = PREV_INSN (*pinsn); p && !LABEL_P (p);\n        p = PREV_INSN (p))\n     if (INSN_P (p))\n       {\n@@ -1782,7 +1782,7 @@ dead_or_set_regno_p (rtx insn, unsigned int test_regno)\n   if (find_regno_note (insn, REG_DEAD, test_regno))\n     return 1;\n \n-  if (GET_CODE (insn) == CALL_INSN\n+  if (CALL_P (insn)\n       && find_regno_fusage (insn, CLOBBER, test_regno))\n     return 1;\n \n@@ -1935,7 +1935,7 @@ find_reg_fusage (rtx insn, enum rtx_code code, rtx datum)\n {\n   /* If it's not a CALL_INSN, it can't possibly have a\n      CALL_INSN_FUNCTION_USAGE field, so don't bother checking.  */\n-  if (GET_CODE (insn) != CALL_INSN)\n+  if (!CALL_P (insn))\n     return 0;\n \n   if (! datum)\n@@ -1986,7 +1986,7 @@ find_regno_fusage (rtx insn, enum rtx_code code, unsigned int regno)\n      to pseudo registers, so don't bother checking.  */\n \n   if (regno >= FIRST_PSEUDO_REGISTER\n-      || GET_CODE (insn) != CALL_INSN )\n+      || !CALL_P (insn) )\n     return 0;\n \n   for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n@@ -2011,7 +2011,7 @@ pure_call_p (rtx insn)\n {\n   rtx link;\n \n-  if (GET_CODE (insn) != CALL_INSN || ! CONST_OR_PURE_CALL_P (insn))\n+  if (!CALL_P (insn) || ! CONST_OR_PURE_CALL_P (insn))\n     return 0;\n \n   /* Look for the note that differentiates const and pure functions.  */\n@@ -2711,7 +2711,7 @@ replace_label (rtx *x, void *data)\n   /* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL\n      field.  This is not handled by for_each_rtx because it doesn't\n      handle unprinted ('0') fields.  */\n-  if (GET_CODE (l) == JUMP_INSN && JUMP_LABEL (l) == old_label)\n+  if (JUMP_P (l) && JUMP_LABEL (l) == old_label)\n     JUMP_LABEL (l) = new_label;\n \n   if ((GET_CODE (l) == LABEL_REF\n@@ -2743,7 +2743,7 @@ rtx_referenced_p_1 (rtx *body, void *x)\n     return y == NULL_RTX;\n \n   /* Return true if a label_ref *BODY refers to label Y.  */\n-  if (GET_CODE (*body) == LABEL_REF && GET_CODE (y) == CODE_LABEL)\n+  if (GET_CODE (*body) == LABEL_REF && LABEL_P (y))\n     return XEXP (*body, 0) == y;\n \n   /* If *BODY is a reference to pool constant traverse the constant.  */\n@@ -2771,10 +2771,10 @@ tablejump_p (rtx insn, rtx *labelp, rtx *tablep)\n {\n   rtx label, table;\n \n-  if (GET_CODE (insn) == JUMP_INSN\n+  if (JUMP_P (insn)\n       && (label = JUMP_LABEL (insn)) != NULL_RTX\n       && (table = next_active_insn (label)) != NULL_RTX\n-      && GET_CODE (table) == JUMP_INSN\n+      && JUMP_P (table)\n       && (GET_CODE (PATTERN (table)) == ADDR_VEC\n \t  || GET_CODE (PATTERN (table)) == ADDR_DIFF_VEC))\n     {\n@@ -2849,7 +2849,7 @@ int\n computed_jump_p (rtx insn)\n {\n   int i;\n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     {\n       rtx pat = PATTERN (insn);\n \n@@ -3103,7 +3103,7 @@ insns_safe_to_move_p (rtx from, rtx to, rtx *new_to)\n \n   while (r)\n     {\n-      if (GET_CODE (r) == NOTE)\n+      if (NOTE_P (r))\n \t{\n \t  switch (NOTE_LINE_NUMBER (r))\n \t    {\n@@ -3411,14 +3411,14 @@ find_first_parameter_load (rtx call_insn, rtx boundary)\n \n       /* It is possible that some loads got CSEed from one call to\n          another.  Stop in that case.  */\n-      if (GET_CODE (before) == CALL_INSN)\n+      if (CALL_P (before))\n \tbreak;\n \n       /* Our caller needs either ensure that we will find all sets\n          (in case code has not been optimized yet), or take care\n          for possible labels in a way by setting boundary to preceding\n          CODE_LABEL.  */\n-      if (GET_CODE (before) == CODE_LABEL)\n+      if (LABEL_P (before))\n \t{\n \t  if (before != boundary)\n \t    abort ();\n@@ -3536,7 +3536,7 @@ can_hoist_insn_p (rtx insn, rtx val, regset live)\n     return false;\n   /* We can move CALL_INSN, but we need to check that all caller clobbered\n      regs are dead.  */\n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     return false;\n   /* In future we will handle hoisting of libcall sequences, but\n      give up for now.  */"}, {"sha": "7b8496c8c8e0f198a4765fe378da62c6baf06a0e", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -147,7 +147,7 @@ get_condition (rtx insn)\n     return 0;\n   if (GET_CODE (pat) == COND_EXEC)\n     return COND_EXEC_TEST (pat);\n-  if (GET_CODE (insn) != JUMP_INSN)\n+  if (!JUMP_P (insn))\n     return 0;\n   if (GET_CODE (pat) != SET || SET_SRC (pat) != pc_rtx)\n     return 0;\n@@ -199,15 +199,15 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n   /* We can get a dependency on deleted insns due to optimizations in\n      the register allocation and reloading or due to splitting.  Any\n      such dependency is useless and can be ignored.  */\n-  if (GET_CODE (elem) == NOTE)\n+  if (NOTE_P (elem))\n     return 0;\n \n   /* flow.c doesn't handle conditional lifetimes entirely correctly;\n      calls mess up the conditional lifetimes.  */\n   /* ??? add_dependence is the wrong place to be eliding dependencies,\n      as that forgets that the condition expressions themselves may\n      be dependent.  */\n-  if (GET_CODE (insn) != CALL_INSN && GET_CODE (elem) != CALL_INSN)\n+  if (!CALL_P (insn) && !CALL_P (elem))\n     {\n       cond1 = get_condition (insn);\n       cond2 = get_condition (elem);\n@@ -231,7 +231,7 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n      No need for interblock dependences with calls, since\n      calls are not moved between blocks.   Note: the edge where\n      elem is a CALL is still required.  */\n-  if (GET_CODE (insn) == CALL_INSN\n+  if (CALL_P (insn)\n       && (INSN_BB (elem) != INSN_BB (insn)))\n     return 0;\n #endif\n@@ -716,7 +716,7 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \t  }\n \n \tfor (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\t  if (GET_CODE (XEXP (u, 0)) != JUMP_INSN\n+\t  if (!JUMP_P (XEXP (u, 0))\n \t      || deps_may_trap_p (x))\n \t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n@@ -853,7 +853,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n     sched_analyze_2 (deps, x, insn);\n \n   /* Mark registers CLOBBERED or used by called function.  */\n-  if (GET_CODE (insn) == CALL_INSN)\n+  if (CALL_P (insn))\n     {\n       for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n \t{\n@@ -866,11 +866,11 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn, rtx loop_notes)\n \treg_pending_barrier = MOVE_BARRIER;\n     }\n \n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     {\n       rtx next;\n       next = next_nonnote_insn (insn);\n-      if (next && GET_CODE (next) == BARRIER)\n+      if (next && BARRIER_P (next))\n \treg_pending_barrier = TRUE_BARRIER;\n       else\n \t{\n@@ -1179,24 +1179,24 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n   /* Before reload, if the previous block ended in a call, show that\n      we are inside a post-call group, so as to keep the lifetimes of\n      hard registers correct.  */\n-  if (! reload_completed && GET_CODE (head) != CODE_LABEL)\n+  if (! reload_completed && !LABEL_P (head))\n     {\n       insn = prev_nonnote_insn (head);\n-      if (insn && GET_CODE (insn) == CALL_INSN)\n+      if (insn && CALL_P (insn))\n \tdeps->in_post_call_group_p = post_call_initial;\n     }\n   for (insn = head;; insn = NEXT_INSN (insn))\n     {\n       rtx link, end_seq, r0, set;\n \n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n+      if (NONJUMP_INSN_P (insn) || JUMP_P (insn))\n \t{\n \t  /* Clear out the stale LOG_LINKS from flow.  */\n \t  free_INSN_LIST_list (&LOG_LINKS (insn));\n \n \t  /* Make each JUMP_INSN a scheduling barrier for memory\n              references.  */\n-\t  if (GET_CODE (insn) == JUMP_INSN)\n+\t  if (JUMP_P (insn))\n \t    {\n \t      /* Keep the list a reasonable size.  */\n \t      if (deps->pending_flush_length++ > MAX_PENDING_LIST_LENGTH)\n@@ -1208,7 +1208,7 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \t  sched_analyze_insn (deps, PATTERN (insn), insn, loop_notes);\n \t  loop_notes = 0;\n \t}\n-      else if (GET_CODE (insn) == CALL_INSN)\n+      else if (CALL_P (insn))\n \t{\n \t  int i;\n \n@@ -1282,7 +1282,7 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n       /* See comments on reemit_notes as to why we do this.\n \t ??? Actually, the reemit_notes just say what is done, not why.  */\n \n-      if (GET_CODE (insn) == NOTE\n+      if (NOTE_P (insn)\n \t       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n@@ -1324,7 +1324,7 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n \t     the outermost libcall sequence.  */\n \t  && deps->libcall_block_tail_insn == 0\n \t  /* The sequence must start with a clobber of a register.  */\n-\t  && GET_CODE (insn) == INSN\n+\t  && NONJUMP_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) == CLOBBER\n           && (r0 = XEXP (PATTERN (insn), 0), REG_P (r0))\n \t  && REG_P (XEXP (PATTERN (insn), 0))\n@@ -1373,7 +1373,7 @@ add_forward_dependence (rtx from, rtx to, enum reg_note dep_type)\n \n      However, if we have enabled checking we might as well go\n      ahead and verify that add_dependence worked properly.  */\n-  if (GET_CODE (from) == NOTE\n+  if (NOTE_P (from)\n       || INSN_DELETED_P (from)\n       || (forward_dependency_cache != NULL\n \t  && bitmap_bit_p (&forward_dependency_cache[INSN_LUID (from)],"}, {"sha": "6cbdc0124b3b5ccf09642592e0b2bd24c89d7114", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -240,7 +240,7 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \n   for (; insn != aftertail; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tabort ();\n       /* Create new basic blocks just before first insn.  */\n       if (inside_basic_block_p (insn))\n@@ -250,7 +250,7 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t      rtx note;\n \n \t      /* Re-emit the basic block note for newly found BB header.  */\n-\t      if (GET_CODE (insn) == CODE_LABEL)\n+\t      if (LABEL_P (insn))\n \t\t{\n \t\t  note = emit_note_after (NOTE_INSN_BASIC_BLOCK, insn);\n \t\t  head = insn;\n@@ -314,7 +314,7 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t\t  delete_insn_chain (head, insn);\n \t\t  /* We keep some notes in the way that may split barrier from the\n \t\t     jump.  */\n-\t\t  if (GET_CODE (next) == BARRIER)\n+\t\t  if (BARRIER_P (next))\n \t\t     {\n \t\t       emit_barrier_after (prev_nonnote_insn (head));\n \t\t       delete_insn (next);\n@@ -328,7 +328,7 @@ fix_basic_block_boundaries (basic_block bb, basic_block last, rtx head,\n \t      BB_END (curr_bb) = insn;\n \t      add_missing_bbs (BB_HEAD (curr_bb), bb, curr_bb->prev_bb);\n \t    }\n-\t  note = GET_CODE (head) == CODE_LABEL ? NEXT_INSN (head) : head;\n+\t  note = LABEL_P (head) ? NEXT_INSN (head) : head;\n \t  NOTE_BASIC_BLOCK (note) = curr_bb;\n \t  update_bb_for_insn (curr_bb);\n \t  bb = curr_bb->next_bb;\n@@ -420,7 +420,7 @@ add_deps_for_risky_insns (rtx head, rtx tail)\n   basic_block last_block = NULL, bb;\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == JUMP_INSN)\n+    if (JUMP_P (insn))\n       {\n \tbb = BLOCK_FOR_INSN (insn);\n \tbb->aux = last_block;\n@@ -592,7 +592,7 @@ schedule_ebbs (FILE *dump_file)\n \t  edge e;\n \t  tail = BB_END (bb);\n \t  if (bb->next_bb == EXIT_BLOCK_PTR\n-\t      || GET_CODE (BB_HEAD (bb->next_bb)) == CODE_LABEL)\n+\t      || LABEL_P (BB_HEAD (bb->next_bb)))\n \t    break;\n \t  for (e = bb->succ; e; e = e->succ_next)\n \t    if ((e->flags & EDGE_FALLTHRU) != 0)\n@@ -608,11 +608,11 @@ schedule_ebbs (FILE *dump_file)\n \t a note or two.  */\n       while (head != tail)\n \t{\n-\t  if (GET_CODE (head) == NOTE)\n+\t  if (NOTE_P (head))\n \t    head = NEXT_INSN (head);\n-\t  else if (GET_CODE (tail) == NOTE)\n+\t  else if (NOTE_P (tail))\n \t    tail = PREV_INSN (tail);\n-\t  else if (GET_CODE (head) == CODE_LABEL)\n+\t  else if (LABEL_P (head))\n \t    head = NEXT_INSN (head);\n \t  else\n \t    break;"}, {"sha": "698cadd2ede63b0a9a3ec1b6ad4b69eaa70dc639", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -349,7 +349,7 @@ is_cfg_nonregular (void)\n \t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n \n \t    if (note\n-\t\t&& ! (GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t\t&& ! (JUMP_P (NEXT_INSN (insn))\n \t\t      && find_reg_note (NEXT_INSN (insn), REG_LABEL,\n \t\t\t\t\tXEXP (note, 0))))\n \t      return 1;\n@@ -1500,7 +1500,7 @@ find_conditional_protection (rtx insn, int load_insn_bb)\n \t  && IS_REACHABLE (INSN_BB (next), load_insn_bb)\n \t  && load_insn_bb != INSN_BB (next)\n \t  && GET_MODE (link) == VOIDmode\n-\t  && (GET_CODE (next) == JUMP_INSN\n+\t  && (JUMP_P (next)\n \t      || find_conditional_protection (next, load_insn_bb)))\n \treturn 1;\n     }\n@@ -1532,7 +1532,7 @@ is_conditionally_protected (rtx load_insn, int bb_src, int bb_trg)\n \n       /* Must be a DEF-USE dependence upon non-branch.  */\n       if (GET_MODE (link) != VOIDmode\n-\t  || GET_CODE (insn1) == JUMP_INSN)\n+\t  || JUMP_P (insn1))\n \tcontinue;\n \n       /* Must exist a path: region-entry -> ... -> bb_trg -> ... load_insn.  */\n@@ -1812,7 +1812,7 @@ init_ready_list (struct ready_list *ready)\n static int\n can_schedule_ready_p (rtx insn)\n {\n-  if (GET_CODE (insn) == JUMP_INSN)\n+  if (JUMP_P (insn))\n     last_was_jump = 1;\n \n   /* An interblock motion?  */\n@@ -2042,9 +2042,9 @@ add_branch_dependences (rtx head, rtx tail)\n \n   insn = tail;\n   last = 0;\n-  while (GET_CODE (insn) == CALL_INSN\n-\t || GET_CODE (insn) == JUMP_INSN\n-\t || (GET_CODE (insn) == INSN\n+  while (CALL_P (insn)\n+\t || JUMP_P (insn)\n+\t || (NONJUMP_INSN_P (insn)\n \t     && (GET_CODE (PATTERN (insn)) == USE\n \t\t || GET_CODE (PATTERN (insn)) == CLOBBER\n \t\t || can_throw_internal (insn)\n@@ -2053,9 +2053,9 @@ add_branch_dependences (rtx head, rtx tail)\n #endif\n \t\t || (!reload_completed\n \t\t     && sets_likely_spilled (PATTERN (insn)))))\n-\t || GET_CODE (insn) == NOTE)\n+\t || NOTE_P (insn))\n     {\n-      if (GET_CODE (insn) != NOTE)\n+      if (!NOTE_P (insn))\n \t{\n \t  if (last != 0 && !find_insn_list (insn, LOG_LINKS (last)))\n \t    {\n@@ -2315,7 +2315,7 @@ debug_dependencies (void)\n \t\t{\n \t\t  int n;\n \t\t  fprintf (sched_dump, \";;   %6d \", INSN_UID (insn));\n-\t\t  if (GET_CODE (insn) == NOTE)\n+\t\t  if (NOTE_P (insn))\n \t\t    {\n \t\t      n = NOTE_LINE_NUMBER (insn);\n \t\t      if (n < 0)"}, {"sha": "098efcb4a301fed1033880b2516ce537ef8c8eef", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -362,8 +362,8 @@ emit_nop (void)\n \n   last_insn = get_last_insn ();\n   if (!optimize\n-      && (GET_CODE (last_insn) == CODE_LABEL\n-\t  || (GET_CODE (last_insn) == NOTE\n+      && (LABEL_P (last_insn)\n+\t  || (NOTE_P (last_insn)\n \t      && prev_real_insn (last_insn) == 0)))\n     emit_insn (gen_nop ());\n }\n@@ -2817,7 +2817,7 @@ expand_start_case (int exit_flag, tree expr, tree type,\n \n   /* Make sure case_stmt.start points to something that won't\n      need any transformation before expand_end_case.  */\n-  if (GET_CODE (get_last_insn ()) != NOTE)\n+  if (!NOTE_P (get_last_insn ()))\n     emit_note (NOTE_INSN_DELETED);\n \n   thiscase->data.case_stmt.start = get_last_insn ();\n@@ -4104,7 +4104,7 @@ node_is_bounded (case_node_ptr node, tree index_type)\n static void\n emit_jump_if_reachable (rtx label)\n {\n-  if (GET_CODE (get_last_insn ()) != BARRIER)\n+  if (!BARRIER_P (get_last_insn ()))\n     emit_jump (label);\n }\n \f"}, {"sha": "690200296eb083e40d96a3f4eea34506fc45198b", "filename": "gcc/unroll.c", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -310,13 +310,13 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n       /* If the last instruction is not a BARRIER or a JUMP_INSN, then\n \t don't do anything.  */\n \n-      if (GET_CODE (last_loop_insn) == BARRIER)\n+      if (BARRIER_P (last_loop_insn))\n \t{\n \t  /* Delete the jump insn.  This will delete the barrier also.  */\n \t  last_loop_insn = PREV_INSN (last_loop_insn);\n \t}\n \n-      if (ujump && GET_CODE (last_loop_insn) == JUMP_INSN)\n+      if (ujump && JUMP_P (last_loop_insn))\n \t{\n #ifdef HAVE_cc0\n \t  rtx prev = PREV_INSN (last_loop_insn);\n@@ -441,9 +441,9 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t Just return without unrolling the loop in such cases.  */\n \n       insn = loop_start;\n-      while (GET_CODE (insn) != CODE_LABEL && GET_CODE (insn) != JUMP_INSN)\n+      while (!LABEL_P (insn) && !JUMP_P (insn))\n \tinsn = NEXT_INSN (insn);\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \treturn;\n     }\n \n@@ -464,9 +464,9 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n       insert_before = NEXT_INSN (last_loop_insn);\n \n       /* Set copy_end to the insn before the jump at the end of the loop.  */\n-      if (GET_CODE (last_loop_insn) == BARRIER)\n+      if (BARRIER_P (last_loop_insn))\n \tcopy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n-      else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n+      else if (JUMP_P (last_loop_insn))\n \t{\n \t  copy_end = PREV_INSN (last_loop_insn);\n #ifdef HAVE_cc0\n@@ -500,12 +500,12 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \n       /* Set insert_before to the jump insn at the end of the loop.\n \t Set copy_end to before the jump insn at the end of the loop.  */\n-      if (GET_CODE (last_loop_insn) == BARRIER)\n+      if (BARRIER_P (last_loop_insn))\n \t{\n \t  insert_before = PREV_INSN (last_loop_insn);\n \t  copy_end = PREV_INSN (insert_before);\n \t}\n-      else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n+      else if (JUMP_P (last_loop_insn))\n \t{\n \t  insert_before = last_loop_insn;\n #ifdef HAVE_cc0\n@@ -533,7 +533,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n       /* Normal case: Must copy the compare and branch instructions at the\n \t end of the loop.  */\n \n-      if (GET_CODE (last_loop_insn) == BARRIER)\n+      if (BARRIER_P (last_loop_insn))\n \t{\n \t  /* Loop ends with an unconditional jump and a barrier.\n \t     Handle this like above, don't copy jump and barrier.\n@@ -546,7 +546,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t  insert_before = PREV_INSN (last_loop_insn);\n \t  copy_end = PREV_INSN (insert_before);\n \t}\n-      else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n+      else if (JUMP_P (last_loop_insn))\n \t{\n \t  /* Set insert_before to immediately after the JUMP_INSN, so that\n \t     NOTEs at the end of the loop will be correctly handled by\n@@ -576,10 +576,10 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n       exit_label = gen_label_rtx ();\n \n       insn = loop_start;\n-      while (GET_CODE (insn) != CODE_LABEL && GET_CODE (insn) != JUMP_INSN)\n+      while (!LABEL_P (insn) && !JUMP_P (insn))\n \tinsn = NEXT_INSN (insn);\n \n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (JUMP_P (insn))\n \t{\n \t  /* The loop starts with a jump down to the exit condition test.\n \t     Start copying the loop after the barrier following this\n@@ -603,9 +603,9 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n   /* This should always be the first label in the loop.  */\n   start_label = NEXT_INSN (copy_start);\n   /* There may be a line number note and/or a loop continue note here.  */\n-  while (GET_CODE (start_label) == NOTE)\n+  while (NOTE_P (start_label))\n     start_label = NEXT_INSN (start_label);\n-  if (GET_CODE (start_label) != CODE_LABEL)\n+  if (!LABEL_P (start_label))\n     {\n       /* This can happen as a result of jump threading.  If the first insns in\n \t the loop test the same condition as the loop's backward jump, or the\n@@ -633,8 +633,8 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n     }\n \n   if (unroll_type == UNROLL_NAIVE\n-      && GET_CODE (last_loop_insn) == BARRIER\n-      && GET_CODE (PREV_INSN (last_loop_insn)) == JUMP_INSN\n+      && BARRIER_P (last_loop_insn)\n+      && JUMP_P (PREV_INSN (last_loop_insn))\n       && start_label != JUMP_LABEL (PREV_INSN (last_loop_insn)))\n     {\n       /* In this case, we must copy the jump and barrier, because they will\n@@ -645,7 +645,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n     }\n \n   if (unroll_type == UNROLL_NAIVE\n-      && GET_CODE (last_loop_insn) == JUMP_INSN\n+      && JUMP_P (last_loop_insn)\n       && start_label != JUMP_LABEL (last_loop_insn))\n     {\n       /* ??? The loop ends with a conditional branch that does not branch back\n@@ -692,9 +692,9 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n     {\n       rtx note;\n \n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tlocal_label[CODE_LABEL_NUMBER (insn)] = 1;\n-      else if (GET_CODE (insn) == JUMP_INSN)\n+      else if (JUMP_P (insn))\n \t{\n \t  if (JUMP_LABEL (insn))\n \t    set_label_in_map (map,\n@@ -758,13 +758,13 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \n       /* If a register is used in the jump insn, we must not duplicate it\n \t since it will also be used outside the loop.  */\n-      if (GET_CODE (copy_end) == JUMP_INSN)\n+      if (JUMP_P (copy_end))\n \tcopy_end_luid--;\n \n       /* If we have a target that uses cc0, then we also must not duplicate\n \t the insn that sets cc0 before the jump insn, if one is present.  */\n #ifdef HAVE_cc0\n-      if (GET_CODE (copy_end) == JUMP_INSN\n+      if (JUMP_P (copy_end)\n \t  && sets_cc0_p (PREV_INSN (copy_end)))\n \tcopy_end_luid--;\n #endif\n@@ -1029,9 +1029,9 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t     and then reset it inside the loop when get to the last\n \t     copy.  */\n \n-\t  if (GET_CODE (last_loop_insn) == BARRIER)\n+\t  if (BARRIER_P (last_loop_insn))\n \t    copy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n-\t  else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n+\t  else if (JUMP_P (last_loop_insn))\n \t    {\n \t      copy_end = PREV_INSN (last_loop_insn);\n #ifdef HAVE_cc0\n@@ -1073,7 +1073,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \n \t      if (i == unroll_number - 1)\n \t\t{\n-\t\t  if (GET_CODE (last_loop_insn) == BARRIER)\n+\t\t  if (BARRIER_P (last_loop_insn))\n \t\t    copy_end = PREV_INSN (PREV_INSN (last_loop_insn));\n \t\t  else\n \t\t    copy_end = last_loop_insn;\n@@ -1087,7 +1087,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t    }\n \t  emit_label_after (labels[0], PREV_INSN (loop_start));\n \n-\t  if (GET_CODE (last_loop_insn) == BARRIER)\n+\t  if (BARRIER_P (last_loop_insn))\n \t    {\n \t      insert_before = PREV_INSN (last_loop_insn);\n \t      copy_end = PREV_INSN (insert_before);\n@@ -1191,7 +1191,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n   if (unroll_type == UNROLL_MODULO)\n     {\n       insn = NEXT_INSN (copy_end);\n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n+      if (NONJUMP_INSN_P (insn) || JUMP_P (insn))\n \tPATTERN (insn) = remap_split_bivs (loop, PATTERN (insn));\n     }\n \n@@ -1270,8 +1270,8 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t associated LABEL_DECL to point to one of the new label instances.  */\n       /* ??? Likewise, we can't delete a NOTE_INSN_DELETED_LABEL note.  */\n       if (insn != start_label\n-\t  && ! (GET_CODE (insn) == CODE_LABEL && LABEL_NAME (insn))\n-\t  && ! (GET_CODE (insn) == NOTE\n+\t  && ! (LABEL_P (insn) && LABEL_NAME (insn))\n+\t  && ! (NOTE_P (insn)\n \t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL))\n \tinsn = delete_related_insns (insn);\n       else\n@@ -2125,7 +2125,7 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n \t\t    }\n \t\t}\n \n-\t      if (label && GET_CODE (label) == CODE_LABEL)\n+\t      if (label && LABEL_P (label))\n \t\tJUMP_LABEL (copy) = label;\n \t      else\n \t\t{\n@@ -2252,8 +2252,7 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n   do\n     {\n       insn = NEXT_INSN (insn);\n-      if ((GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n-\t   || GET_CODE (insn) == CALL_INSN)\n+      if (INSN_P (insn)\n \t  && map->insn_map[INSN_UID (insn)])\n \tfinal_reg_note_copy (&REG_NOTES (map->insn_map[INSN_UID (insn)]), map);\n     }\n@@ -2279,7 +2278,7 @@ copy_loop_body (struct loop *loop, rtx copy_start, rtx copy_end,\n \t     instructions before the last insn in the loop, COPY_NOTES_FROM\n \t     can be a NOTE_INSN_LOOP_CONT note if there is no VTOP note,\n \t     as in a do .. while loop.  */\n-\t  if (GET_CODE (insn) == NOTE\n+\t  if (NOTE_P (insn)\n \t      && ((NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n \t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n \t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_VTOP\n@@ -2330,7 +2329,7 @@ back_branch_in_range_p (const struct loop *loop, rtx insn)\n \n   /* Stop before we get to the backward branch at the end of the loop.  */\n   loop_end = prev_nonnote_insn (loop_end);\n-  if (GET_CODE (loop_end) == BARRIER)\n+  if (BARRIER_P (loop_end))\n     loop_end = PREV_INSN (loop_end);\n \n   /* Check in case insn has been deleted, search forward for first non\n@@ -2346,7 +2345,7 @@ back_branch_in_range_p (const struct loop *loop, rtx insn)\n \n   for (p = NEXT_INSN (insn); p != loop_end; p = NEXT_INSN (p))\n     {\n-      if (GET_CODE (p) == JUMP_INSN)\n+      if (JUMP_P (p))\n \t{\n \t  target_insn = JUMP_LABEL (p);\n \n@@ -2912,7 +2911,7 @@ reg_dead_after_loop (const struct loop *loop, rtx reg)\n \t      if (set && rtx_equal_p (SET_DEST (set), reg))\n \t\tbreak;\n \n-\t      if (GET_CODE (insn) == JUMP_INSN)\n+\t      if (JUMP_P (insn))\n \t\t{\n \t\t  if (GET_CODE (PATTERN (insn)) == RETURN)\n \t\t    break;\n@@ -3145,7 +3144,7 @@ loop_find_equiv_value (const struct loop *loop, rtx reg)\n   ret = reg;\n   for (insn = PREV_INSN (loop_start); insn; insn = PREV_INSN (insn))\n     {\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      if (LABEL_P (insn))\n \tbreak;\n \n       else if (INSN_P (insn) && reg_set_p (reg, insn))\n@@ -3282,7 +3281,7 @@ loop_iterations (struct loop *loop)\n   /* ??? We should probably try harder to find the jump insn\n      at the end of the loop.  The following code assumes that\n      the last loop insn is a jump to the top of the loop.  */\n-  if (GET_CODE (last_loop_insn) != JUMP_INSN)\n+  if (!JUMP_P (last_loop_insn))\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -3308,7 +3307,7 @@ loop_iterations (struct loop *loop)\n \n       do\n \t{\n-\t  if (GET_CODE (temp) == JUMP_INSN)\n+\t  if (JUMP_P (temp))\n \t    {\n \t      /* There are some kinds of jumps we can't deal with easily.  */\n \t      if (JUMP_LABEL (temp) == 0)\n@@ -3967,7 +3966,7 @@ set_dominates_use (int regno, int first_uid, int last_uid, rtx copy_start,\n \n   while (INSN_UID (p) != first_uid)\n     {\n-      if (GET_CODE (p) == JUMP_INSN)\n+      if (JUMP_P (p))\n \tpassed_jump = 1;\n       /* Could not find FIRST_UID.  */\n       if (p == copy_end)\n@@ -3987,7 +3986,7 @@ set_dominates_use (int regno, int first_uid, int last_uid, rtx copy_start,\n     {\n       /* If we see a CODE_LABEL between FIRST_UID and LAST_UID, then we\n \t can not be sure that FIRST_UID dominates LAST_UID.  */\n-      if (GET_CODE (p) == CODE_LABEL)\n+      if (LABEL_P (p))\n \treturn 0;\n       /* Could not find LAST_UID, but we reached the end of the loop, so\n \t it must be safe.  */\n@@ -4024,7 +4023,7 @@ ujump_to_loop_cont (rtx loop_start, rtx loop_cont)\n \n   /* Examine insn after loop continuation note.  Return if not a label.  */\n   label = next_nonnote_insn (loop_cont);\n-  if (label == 0 || GET_CODE (label) != CODE_LABEL)\n+  if (label == 0 || !LABEL_P (label))\n     return NULL_RTX;\n \n   /* Return the loop start if the branch label matches the code label.  */"}, {"sha": "f4eb356a5952405f79c670dbebc9f978c4b22393", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -503,7 +503,7 @@ prologue_stack_adjust (void)\n   end = NEXT_INSN (BB_END (bb));\n   for (insn = BB_HEAD (bb); insn != end; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == NOTE\n+      if (NOTE_P (insn)\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n \tbreak;\n \n@@ -2579,7 +2579,7 @@ vt_initialize (void)\n \t\t}\n \t      note_uses (&PATTERN (insn), count_uses_1, insn);\n \t      note_stores (PATTERN (insn), count_stores, insn);\n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      if (CALL_P (insn))\n \t\tVTI (bb)->n_mos++;\n \t    }\n \t}\n@@ -2629,7 +2629,7 @@ vt_initialize (void)\n \t\t    }\n \t\t}\n \n-\t      if (GET_CODE (insn) == CALL_INSN)\n+\t      if (CALL_P (insn))\n \t\t{\n \t\t  micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n "}, {"sha": "1e1a8d980dd7599e110c38eea6d38d257ab3117c", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b4bf9414ffd808a7f93bb518cae543b4df45199/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=4b4bf9414ffd808a7f93bb518cae543b4df45199", "patch": "@@ -3018,7 +3018,7 @@ output_constant_pool_1 (struct constant_descriptor_rtx *desc)\n     case LABEL_REF:\n       tmp = XEXP (x, 0);\n       if (INSN_DELETED_P (tmp)\n-\t  || (GET_CODE (tmp) == NOTE\n+\t  || (NOTE_P (tmp)\n \t      && NOTE_LINE_NUMBER (tmp) == NOTE_INSN_DELETED))\n \t{\n \t  abort ();"}]}