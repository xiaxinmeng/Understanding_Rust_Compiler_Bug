{"sha": "05f85dbb6d432b042168f029d5da62f1d4672844", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVmODVkYmI2ZDQzMmIwNDIxNjhmMDI5ZDVkYTYyZjFkNDY3Mjg0NA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2006-11-18T18:43:19Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2006-11-18T18:43:19Z"}, "message": "invoke.texi (core2): Add item.\n\n2006-11-18  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* doc/invoke.texi (core2): Add item.\n\n\t* config/i386/i386.h (TARGET_CORE2, TARGET_CPU_DEFAULT_core2): New\n\tmacros.\n\t(TARGET_CPU_CPP_BUILTINS): Add code for core2.\n\t(TARGET_CPU_DEFAULT_generic): Change value.\n\t(TARGET_CPU_DEFAULT_NAMES): Add core2.\n\t(processor_type): Add new constant PROCESSOR_CORE2.\n\n\t* config/i386/i386.md (cpu): Add core2.\n\n\t* config/i386/i386.c (core2_cost): New initialized variable.\n\t(m_CORE2): New macro.\n\t(x86_use_leave, x86_push_memory, x86_movx, x86_unroll_strlen,\n\tx86_deep_branch, x86_partial_reg_stall, x86_use_simode_fiop,\n\tx86_use_cltd, x86_promote_QImode, x86_sub_esp_4, x86_sub_esp_8,\n\tx86_add_esp_4, x86_add_esp_8, x86_integer_DFmode_moves,\n\tx86_partial_reg_dependency, x86_memory_mismatch_stall,\n\tx86_accumulate_outgoing_args, x86_prologue_using_move,\n\tx86_epilogue_using_move, x86_arch_always_fancy_math_387,\n\tx86_sse_partial_reg_dependency, x86_rep_movl_optimal,\n\tx86_use_incdec, x86_four_jump_limit, x86_schedule,\n\tx86_pad_returns): Add m_CORE2.\n\t(override_options): Add entries for Core2.\n\t(ix86_issue_rate): Add case for Core2.\n\nFrom-SVN: r118973", "tree": {"sha": "e3a1ae3abfd90fed9037bb41c11c4c9eb170e147", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3a1ae3abfd90fed9037bb41c11c4c9eb170e147"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05f85dbb6d432b042168f029d5da62f1d4672844", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f85dbb6d432b042168f029d5da62f1d4672844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05f85dbb6d432b042168f029d5da62f1d4672844", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05f85dbb6d432b042168f029d5da62f1d4672844/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a357b5ae8d079297527a84f6bbccf77dc25fc105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a357b5ae8d079297527a84f6bbccf77dc25fc105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a357b5ae8d079297527a84f6bbccf77dc25fc105"}], "stats": {"total": 161, "additions": 131, "deletions": 30}, "files": [{"sha": "13deaefb239a628605c2aa347a1d6baebffdc3a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05f85dbb6d432b042168f029d5da62f1d4672844", "patch": "@@ -1,3 +1,31 @@\n+2006-11-18  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/invoke.texi (core2): Add item.\n+\n+\t* config/i386/i386.h (TARGET_CORE2, TARGET_CPU_DEFAULT_core2): New\n+\tmacros.\n+\t(TARGET_CPU_CPP_BUILTINS): Add code for core2.\n+\t(TARGET_CPU_DEFAULT_generic): Change value.\n+\t(TARGET_CPU_DEFAULT_NAMES): Add core2.\n+\t(processor_type): Add new constant PROCESSOR_CORE2.\n+\n+\t* config/i386/i386.md (cpu): Add core2.\n+\n+\t* config/i386/i386.c (core2_cost): New initialized variable.\n+\t(m_CORE2): New macro.\n+\t(x86_use_leave, x86_push_memory, x86_movx, x86_unroll_strlen,\n+\tx86_deep_branch, x86_partial_reg_stall, x86_use_simode_fiop,\n+\tx86_use_cltd, x86_promote_QImode, x86_sub_esp_4, x86_sub_esp_8,\n+\tx86_add_esp_4, x86_add_esp_8, x86_integer_DFmode_moves,\n+\tx86_partial_reg_dependency, x86_memory_mismatch_stall,\n+\tx86_accumulate_outgoing_args, x86_prologue_using_move,\n+\tx86_epilogue_using_move, x86_arch_always_fancy_math_387,\n+\tx86_sse_partial_reg_dependency, x86_rep_movl_optimal,\n+\tx86_use_incdec, x86_four_jump_limit, x86_schedule,\n+\tx86_pad_returns): Add m_CORE2.\n+\t(override_options): Add entries for Core2.\n+\t(ix86_issue_rate): Add case for Core2.\n+\t\n 2006-11-18  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* doc/invoke.texi: Fix mno-isel typo."}, {"sha": "0428bfacea58fbfa8beb11172aefea93864d7fca", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 87, "deletions": 27, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=05f85dbb6d432b042168f029d5da62f1d4672844", "patch": "@@ -658,6 +658,58 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n };\n \n+static const\n+struct processor_costs core2_cost = {\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               HI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               SI */\n+   COSTS_N_INSNS (3),\t\t\t/*                               DI */\n+   COSTS_N_INSNS (3)},\t\t\t/*                               other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (22),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (22),\t\t\t/*                          HI */\n+   COSTS_N_INSNS (22),\t\t\t/*                          SI */\n+   COSTS_N_INSNS (22),\t\t\t/*                          DI */\n+   COSTS_N_INSNS (22)},\t\t\t/*                          other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  16,\t\t\t\t\t/* MOVE_RATIO */\n+  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {6, 6, 6},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {4, 4, 4},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  2,\t\t\t\t\t/* MMX or SSE register to integer */\n+  128,\t\t\t\t\t/* size of prefetch block */\n+  8,\t\t\t\t\t/* number of parallel prefetches */\n+  3,\t\t\t\t\t/* Branch cost */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (32),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (58),\t\t\t/* cost of FSQRT instruction.  */\n+};\n+\n /* Generic64 should produce code tuned for Nocona and K8.  */\n static const\n struct processor_costs generic64_cost = {\n@@ -787,26 +839,27 @@ const struct processor_costs *ix86_cost = &pentium_cost;\n #define m_K8  (1<<PROCESSOR_K8)\n #define m_ATHLON_K8  (m_K8 | m_ATHLON)\n #define m_NOCONA  (1<<PROCESSOR_NOCONA)\n+#define m_CORE2  (1<<PROCESSOR_CORE2)\n #define m_GENERIC32 (1<<PROCESSOR_GENERIC32)\n #define m_GENERIC64 (1<<PROCESSOR_GENERIC64)\n #define m_GENERIC (m_GENERIC32 | m_GENERIC64)\n \n /* Generic instruction choice should be common subset of supported CPUs\n-   (PPro/PENT4/NOCONA/Athlon/K8).  */\n+   (PPro/PENT4/NOCONA/CORE2/Athlon/K8).  */\n \n /* Leave is not affecting Nocona SPEC2000 results negatively, so enabling for\n    Generic64 seems like good code size tradeoff.  We can't enable it for 32bit\n    generic because it is not working well with PPro base chips.  */\n-const int x86_use_leave = m_386 | m_K6_GEODE | m_ATHLON_K8 | m_GENERIC64;\n-const int x86_push_memory = m_386 | m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n+const int x86_use_leave = m_386 | m_K6_GEODE | m_ATHLON_K8 | m_CORE2 | m_GENERIC64;\n+const int x86_push_memory = m_386 | m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n const int x86_zero_extend_with_and = m_486 | m_PENT;\n-const int x86_movx = m_ATHLON_K8 | m_PPRO | m_PENT4 | m_NOCONA | m_GENERIC | m_GEODE /* m_386 | m_K6 */;\n+const int x86_movx = m_ATHLON_K8 | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC | m_GEODE /* m_386 | m_K6 */;\n const int x86_double_with_add = ~m_386;\n const int x86_use_bit_test = m_386;\n-const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO | m_ATHLON_K8 | m_K6 | m_GENERIC;\n+const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO | m_ATHLON_K8 | m_K6 | m_CORE2 | m_GENERIC;\n const int x86_cmove = m_PPRO | m_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA;\n const int x86_3dnow_a = m_ATHLON_K8;\n-const int x86_deep_branch = m_PPRO | m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n+const int x86_deep_branch = m_PPRO | m_K6_GEODE | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n /* Branch hints were put in P4 based on simulation result. But\n    after P4 was made, no performance benefit was observed with\n    branch hints. It also increases the code size. As the result,\n@@ -822,15 +875,15 @@ const int x86_use_sahf = m_PPRO | m_K6_GEODE | m_PENT4 | m_NOCONA | m_GENERIC32;\n    with partial reg. dependencies used by Athlon/P4 based chips, it is better\n    to leave it off for generic32 for now.  */\n const int x86_partial_reg_stall = m_PPRO;\n-const int x86_partial_flag_reg_stall = m_GENERIC;\n+const int x86_partial_flag_reg_stall =  m_CORE2 | m_GENERIC;\n const int x86_use_himode_fiop = m_386 | m_486 | m_K6_GEODE;\n-const int x86_use_simode_fiop = ~(m_PPRO | m_ATHLON_K8 | m_PENT | m_GENERIC);\n+const int x86_use_simode_fiop = ~(m_PPRO | m_ATHLON_K8 | m_PENT | m_CORE2 | m_GENERIC);\n const int x86_use_mov0 = m_K6;\n-const int x86_use_cltd = ~(m_PENT | m_K6 | m_GENERIC);\n+const int x86_use_cltd = ~(m_PENT | m_K6 | m_CORE2 | m_GENERIC);\n const int x86_read_modify_write = ~m_PENT;\n const int x86_read_modify = ~(m_PENT | m_PPRO);\n const int x86_split_long_moves = m_PPRO;\n-const int x86_promote_QImode = m_K6_GEODE | m_PENT | m_386 | m_486 | m_ATHLON_K8 | m_GENERIC; /* m_PENT4 ? */\n+const int x86_promote_QImode = m_K6_GEODE | m_PENT | m_386 | m_486 | m_ATHLON_K8 | m_CORE2 | m_GENERIC; /* m_PENT4 ? */\n const int x86_fast_prefix = ~(m_PENT | m_486 | m_386);\n const int x86_single_stringop = m_386 | m_PENT4 | m_NOCONA;\n const int x86_qimode_math = ~(0);\n@@ -840,18 +893,18 @@ const int x86_promote_qi_regs = 0;\n    if our scheme for avoiding partial stalls was more effective.  */\n const int x86_himode_math = ~(m_PPRO);\n const int x86_promote_hi_regs = m_PPRO;\n-const int x86_sub_esp_4 = m_ATHLON_K8 | m_PPRO | m_PENT4 | m_NOCONA | m_GENERIC;\n-const int x86_sub_esp_8 = m_ATHLON_K8 | m_PPRO | m_386 | m_486 | m_PENT4 | m_NOCONA | m_GENERIC;\n-const int x86_add_esp_4 = m_ATHLON_K8 | m_K6_GEODE | m_PENT4 | m_NOCONA | m_GENERIC;\n-const int x86_add_esp_8 = m_ATHLON_K8 | m_PPRO | m_K6_GEODE | m_386 | m_486 | m_PENT4 | m_NOCONA | m_GENERIC;\n-const int x86_integer_DFmode_moves = ~(m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_GENERIC | m_GEODE);\n-const int x86_partial_reg_dependency = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n-const int x86_memory_mismatch_stall = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n-const int x86_accumulate_outgoing_args = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_GENERIC;\n-const int x86_prologue_using_move = m_ATHLON_K8 | m_PPRO | m_GENERIC;\n-const int x86_epilogue_using_move = m_ATHLON_K8 | m_PPRO | m_GENERIC;\n+const int x86_sub_esp_4 = m_ATHLON_K8 | m_PPRO | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_sub_esp_8 = m_ATHLON_K8 | m_PPRO | m_386 | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_add_esp_4 = m_ATHLON_K8 | m_K6_GEODE | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_add_esp_8 = m_ATHLON_K8 | m_PPRO | m_K6_GEODE | m_386 | m_486 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_integer_DFmode_moves = ~(m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC | m_GEODE);\n+const int x86_partial_reg_dependency = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_memory_mismatch_stall = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_accumulate_outgoing_args = m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;\n+const int x86_prologue_using_move = m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC;\n+const int x86_epilogue_using_move = m_ATHLON_K8 | m_PPRO | m_CORE2 | m_GENERIC;\n const int x86_shift1 = ~m_486;\n-const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n+const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n /* In Generic model we have an conflict here in between PPro/Pentium4 based chips\n    that thread 128bit SSE registers as single units versus K8 based chips that\n    divide SSE registers to two 64bit halves.\n@@ -861,7 +914,7 @@ const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO | m_ATHLON_K8 | m_PEN\n    this option on P4 brings over 20% SPECfp regression, while enabling it on\n    K8 brings roughly 2.4% regression that can be partly masked by careful scheduling\n    of moves.  */\n-const int x86_sse_partial_reg_dependency = m_PENT4 | m_NOCONA | m_PPRO | m_GENERIC;\n+const int x86_sse_partial_reg_dependency = m_PENT4 | m_NOCONA | m_PPRO | m_CORE2 | m_GENERIC;\n /* Set for machines where the type and dependencies are resolved on SSE\n    register parts instead of whole registers, so we may maintain just\n    lower part of scalar values in proper format leaving the upper part\n@@ -870,8 +923,8 @@ const int x86_sse_split_regs = m_ATHLON_K8;\n const int x86_sse_typeless_stores = m_ATHLON_K8;\n const int x86_sse_load0_by_pxor = m_PPRO | m_PENT4 | m_NOCONA;\n const int x86_use_ffreep = m_ATHLON_K8;\n-const int x86_rep_movl_optimal = m_386 | m_PENT | m_PPRO | m_K6_GEODE;\n-const int x86_use_incdec = ~(m_PENT4 | m_NOCONA | m_GENERIC);\n+const int x86_rep_movl_optimal = m_386 | m_PENT | m_PPRO | m_K6_GEODE | m_CORE2;\n+const int x86_use_incdec = ~(m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC);\n \n /* ??? Allowing interunit moves makes it all too easy for the compiler to put\n    integer data in xmm registers.  Which results in pretty abysmal code.  */\n@@ -880,8 +933,8 @@ const int x86_inter_unit_moves = 0 /* ~(m_ATHLON_K8) */;\n const int x86_ext_80387_constants = m_K6_GEODE | m_ATHLON | m_PENT4 | m_NOCONA | m_PPRO | m_GENERIC32;\n /* Some CPU cores are not able to predict more than 4 branch instructions in\n    the 16 byte window.  */\n-const int x86_four_jump_limit = m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n-const int x86_schedule = m_PPRO | m_ATHLON_K8 | m_K6_GEODE | m_PENT | m_GENERIC;\n+const int x86_four_jump_limit = m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_CORE2 | m_GENERIC;\n+const int x86_schedule = m_PPRO | m_ATHLON_K8 | m_K6_GEODE | m_PENT | m_CORE2 | m_GENERIC;\n const int x86_use_bt = m_ATHLON_K8;\n /* Compare and exchange was added for 80486.  */\n const int x86_cmpxchg = ~m_386;\n@@ -893,7 +946,7 @@ const int x86_cmpxchg16b = m_NOCONA;\n const int x86_xadd = ~m_386;\n /* Byteswap was added for 80486.  */\n const int x86_bswap = ~m_386;\n-const int x86_pad_returns = m_ATHLON_K8 | m_GENERIC;\n+const int x86_pad_returns = m_ATHLON_K8 | m_CORE2 | m_GENERIC;\n \n /* In case the average insn count for single function invocation is\n    lower than this constant, emit fast (but longer) prologue and\n@@ -1523,6 +1576,7 @@ override_options (void)\n       {&pentium4_cost, 0, 0, 0, 0, 0, 0, 0},\n       {&k8_cost, 0, 0, 16, 7, 16, 7, 16},\n       {&nocona_cost, 0, 0, 0, 0, 0, 0, 0},\n+      {&core2_cost, 0, 0, 16, 7, 16, 7, 16},\n       {&generic32_cost, 0, 0, 16, 7, 16, 7, 16},\n       {&generic64_cost, 0, 0, 16, 7, 16, 7, 16}\n     };\n@@ -1570,6 +1624,9 @@ override_options (void)\n \t\t\t\t        | PTA_MMX | PTA_PREFETCH_SSE},\n       {\"nocona\", PROCESSOR_NOCONA, PTA_SSE | PTA_SSE2 | PTA_SSE3 | PTA_64BIT\n \t\t\t\t        | PTA_MMX | PTA_PREFETCH_SSE},\n+      {\"core2\", PROCESSOR_CORE2, PTA_SSE | PTA_SSE2 | PTA_SSE3\n+                                        | PTA_64BIT | PTA_MMX\n+                                        | PTA_PREFETCH_SSE},\n       {\"geode\", PROCESSOR_GEODE, PTA_MMX | PTA_PREFETCH_SSE | PTA_3DNOW\n \t\t\t\t   | PTA_3DNOW_A},\n       {\"k6\", PROCESSOR_K6, PTA_MMX},\n@@ -13857,6 +13914,9 @@ ix86_issue_rate (void)\n     case PROCESSOR_GENERIC64:\n       return 3;\n \n+    case PROCESSOR_CORE2:\n+      return 4;\n+\n     default:\n       return 1;\n     }"}, {"sha": "039278c4ed66dffa660d0c5ff79a67a419cc9f2d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=05f85dbb6d432b042168f029d5da62f1d4672844", "patch": "@@ -137,6 +137,7 @@ extern const struct processor_costs *ix86_cost;\n #define TARGET_K8 (ix86_tune == PROCESSOR_K8)\n #define TARGET_ATHLON_K8 (TARGET_K8 || TARGET_ATHLON)\n #define TARGET_NOCONA (ix86_tune == PROCESSOR_NOCONA)\n+#define TARGET_CORE2 (ix86_tune == PROCESSOR_CORE2)\n #define TARGET_GENERIC32 (ix86_tune == PROCESSOR_GENERIC32)\n #define TARGET_GENERIC64 (ix86_tune == PROCESSOR_GENERIC64)\n #define TARGET_GENERIC (TARGET_GENERIC32 || TARGET_GENERIC64)\n@@ -403,6 +404,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \tbuiltin_define (\"__tune_pentium4__\");\t\t\t\\\n       else if (TARGET_NOCONA)\t\t\t\t\t\\\n \tbuiltin_define (\"__tune_nocona__\");\t\t\t\\\n+      else if (TARGET_CORE2)\t\t\t\t\t\\\n+\tbuiltin_define (\"__tune_core2__\");\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n       if (TARGET_MMX)\t\t\t\t\t\t\\\n \tbuiltin_define (\"__MMX__\");\t\t\t\t\\\n@@ -483,6 +486,11 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \t  builtin_define (\"__nocona\");\t\t\t\t\\\n \t  builtin_define (\"__nocona__\");\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n+      else if (ix86_arch == PROCESSOR_CORE2)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  builtin_define (\"__core2\");\t\t\t\t\\\n+\t  builtin_define (\"__core2__\");\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -504,14 +512,15 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_CPU_DEFAULT_pentium_m 15\n #define TARGET_CPU_DEFAULT_prescott 16\n #define TARGET_CPU_DEFAULT_nocona 17\n-#define TARGET_CPU_DEFAULT_generic 18\n+#define TARGET_CPU_DEFAULT_core2 18\n+#define TARGET_CPU_DEFAULT_generic 19\n \n #define TARGET_CPU_DEFAULT_NAMES {\"i386\", \"i486\", \"pentium\", \"pentium-mmx\",\\\n \t\t\t\t  \"pentiumpro\", \"pentium2\", \"pentium3\", \\\n                                   \"pentium4\", \"geode\", \"k6\", \"k6-2\", \"k6-3\", \\\n \t\t\t\t  \"athlon\", \"athlon-4\", \"k8\", \\\n \t\t\t\t  \"pentium-m\", \"prescott\", \"nocona\", \\\n-\t\t\t\t  \"generic\"}\n+\t\t\t\t  \"core2\", \"generic\"}\n \n #ifndef CC1_SPEC\n #define CC1_SPEC \"%(cc1_cpu) \"\n@@ -2073,6 +2082,7 @@ enum processor_type\n   PROCESSOR_PENTIUM4,\n   PROCESSOR_K8,\n   PROCESSOR_NOCONA,\n+  PROCESSOR_CORE2,\n   PROCESSOR_GENERIC32,\n   PROCESSOR_GENERIC64,\n   PROCESSOR_max"}, {"sha": "458ca0f2ba08b91453f5aa5f528e69667257fffb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=05f85dbb6d432b042168f029d5da62f1d4672844", "patch": "@@ -194,7 +194,7 @@\n \f\n ;; Processor type.  This attribute must exactly match the processor_type\n ;; enumeration in i386.h.\n-(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro,geode,k6,athlon,pentium4,k8,nocona,generic32,generic64\"\n+(define_attr \"cpu\" \"i386,i486,pentium,pentiumpro,geode,k6,athlon,pentium4,k8,nocona,core2,generic32,generic64\"\n   (const (symbol_ref \"ix86_tune\")))\n \n ;; A basic instruction type.  Refinements due to arguments to be"}, {"sha": "f47cb62b1cc853c2f67e65c095c26f17348a1331", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05f85dbb6d432b042168f029d5da62f1d4672844/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=05f85dbb6d432b042168f029d5da62f1d4672844", "patch": "@@ -9296,6 +9296,9 @@ set support.\n @item nocona\n Improved version of Intel Pentium4 CPU with 64-bit extensions, MMX, SSE,\n SSE2 and SSE3 instruction set support.\n+@item core2\n+Intel Core2 CPU with 64-bit extensions, MMX, SSE, SSE2, SSE3 and SSSE3\n+instruction set support.\n @item k6\n AMD K6 CPU with MMX instruction set support.\n @item k6-2, k6-3"}]}