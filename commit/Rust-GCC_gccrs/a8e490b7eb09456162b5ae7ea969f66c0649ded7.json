{"sha": "a8e490b7eb09456162b5ae7ea969f66c0649ded7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlNDkwYjdlYjA5NDU2MTYyYjVhZTdlYTk2OWY2NmMwNjQ5ZGVkNw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@act-europe.fr", "date": "2004-10-04T15:02:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-04T15:02:10Z"}, "message": "s-tassta.adb (Task_Wrapper): Make it Convention C...\n\n2004-10-04  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* s-tassta.adb (Task_Wrapper): Make it Convention C, which makes sense\n\tin general and triggers stack alignment adjustment for thread entry\n\tpoints on targets where this is necessary.\n\nFrom-SVN: r88509", "tree": {"sha": "ccccf3c269f0269a244901779cd14d6140155780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccccf3c269f0269a244901779cd14d6140155780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8e490b7eb09456162b5ae7ea969f66c0649ded7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e490b7eb09456162b5ae7ea969f66c0649ded7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e490b7eb09456162b5ae7ea969f66c0649ded7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e490b7eb09456162b5ae7ea969f66c0649ded7/comments", "author": null, "committer": null, "parents": [{"sha": "71c10a83a677e7caf5e9a0208e315bad3a5001ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c10a83a677e7caf5e9a0208e315bad3a5001ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71c10a83a677e7caf5e9a0208e315bad3a5001ac"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "03ddd63e56bfa5260aeefe5d99662ec0064da4be", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e490b7eb09456162b5ae7ea969f66c0649ded7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e490b7eb09456162b5ae7ea969f66c0649ded7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a8e490b7eb09456162b5ae7ea969f66c0649ded7", "patch": "@@ -1,3 +1,9 @@\n+2004-10-04  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* s-tassta.adb (Task_Wrapper): Make it Convention C, which makes sense\n+\tin general and triggers stack alignment adjustment for thread entry\n+\tpoints on targets where this is necessary.\n+\n 2004-10-04  Bernard Banner  <banner@gnat.com>\n \n \tPR ada/13897"}, {"sha": "784dade88d81c5d4ff8c00c0a425d0eefa3f2a66", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e490b7eb09456162b5ae7ea969f66c0649ded7/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e490b7eb09456162b5ae7ea969f66c0649ded7/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=a8e490b7eb09456162b5ae7ea969f66c0649ded7", "patch": "@@ -141,28 +141,32 @@ package body System.Tasking.Stages is\n    --  tracing purposes.\n \n    procedure Task_Wrapper (Self_ID : Task_Id);\n-   --  This is the procedure that is called by the GNULL from the\n-   --  new context when a task is created. It waits for activation\n-   --  and then calls the task body procedure. When the task body\n-   --  procedure completes, it terminates the task.\n+   pragma Convention (C, Task_Wrapper);\n+   --  This is the procedure that is called by the GNULL from the new context\n+   --  when a task is created. It waits for activation and then calls the task\n+   --  body procedure. When the task body procedure completes, it terminates\n+   --  the task.\n+   --\n+   --  The Task_Wrapper's address will be provided to the underlying threads\n+   --  library as the task entry point. Convention C is what makes most sense\n+   --  for that purpose (Export C would make the function globally visible,\n+   --  and affect the link name on which GDB depends). This will in addition\n+   --  trigger an automatic stack alignment suitable for GCC's assumptions if\n+   --  need be.\n \n    procedure Vulnerable_Complete_Task (Self_ID : Task_Id);\n-   --  Complete the calling task.\n-   --  This procedure must be called with abort deferred.\n-   --  It should only be called by Complete_Task and\n+   --  Complete the calling task. This procedure must be called with\n+   --  abort deferred. It should only be called by Complete_Task and\n    --  Finalizate_Global_Tasks (for the environment task).\n \n    procedure Vulnerable_Complete_Master (Self_ID : Task_Id);\n-   --  Complete the current master of the calling task.\n-   --  This procedure must be called with abort deferred.\n-   --  It should only be called by Vulnerable_Complete_Task and\n-   --  Complete_Master.\n+   --  Complete the current master of the calling task. This procedure\n+   --  must be called with abort deferred. It should only be called by\n+   --  Vulnerable_Complete_Task and Complete_Master.\n \n    procedure Vulnerable_Complete_Activation (Self_ID : Task_Id);\n-   --  Signal to Self_ID's activator that Self_ID has\n-   --  completed activation.\n-   --\n-   --  Call this procedure with abort deferred.\n+   --  Signal to Self_ID's activator that Self_ID has completed activation.\n+   --  This procedure must be called with abort deferred.\n \n    procedure Abort_Dependents (Self_ID : Task_Id);\n    --  Abort all the direct dependents of Self at its current master\n@@ -193,12 +197,11 @@ package body System.Tasking.Stages is\n \n    begin\n       C := All_Tasks_List;\n-\n       while C /= null loop\n          P := C.Common.Parent;\n-\n          while P /= null loop\n             if P = Self_ID then\n+\n                --  ??? C is supposed to take care of its own dependents, so\n                --  there should be no need to worry about them. Need to double\n                --  check this.\n@@ -277,9 +280,8 @@ package body System.Tasking.Stages is\n       All_Elaborated : Boolean := True;\n \n    begin\n-      --  If pragma Detect_Blocking is active must be checked whether\n-      --  this potentially blocking operation is called from a\n-      --  protected action.\n+      --  If pragma Detect_Blocking is active, then we must check whether this\n+      --  potentially blocking operation is called from a protected action.\n \n       if System.Tasking.Detect_Blocking\n         and then Self_ID.Common.Protected_Action_Nesting > 0\n@@ -295,16 +297,15 @@ package body System.Tasking.Stages is\n \n       pragma Assert (Self_ID.Common.Wait_Count = 0);\n \n-      --  Lock RTS_Lock, to prevent activated tasks\n-      --  from racing ahead before we finish activating the chain.\n+      --  Lock RTS_Lock, to prevent activated tasks from racing ahead before\n+      --  we finish activating the chain.\n \n       Lock_RTS;\n \n-      --  Check that all task bodies have been elaborated.\n+      --  Check that all task bodies have been elaborated\n \n       C := Chain_Access.T_ID;\n       Last_C := null;\n-\n       while C /= null loop\n          if C.Common.Elaborated /= null\n            and then not C.Common.Elaborated.all\n@@ -330,12 +331,10 @@ package body System.Tasking.Stages is\n            (Program_Error'Identity, \"Some tasks have not been elaborated\");\n       end if;\n \n-      --  Activate all the tasks in the chain.\n-      --  Creation of the thread of control was deferred until\n-      --  activation. So create it now.\n+      --  Activate all the tasks in the chain. Creation of the thread of\n+      --  control was deferred until activation. So create it now.\n \n       C := Chain_Access.T_ID;\n-\n       while C /= null loop\n          if C.Common.State /= Terminated then\n             pragma Assert (C.Common.State = Unactivated);\n@@ -455,6 +454,7 @@ package body System.Tasking.Stages is\n \n    procedure Complete_Activation is\n       Self_ID : constant Task_Id := STPO.Self;\n+\n    begin\n       Initialization.Defer_Abort_Nestable (Self_ID);\n \n@@ -484,10 +484,8 @@ package body System.Tasking.Stages is\n \n    procedure Complete_Master is\n       Self_ID : constant Task_Id := STPO.Self;\n-\n    begin\n       pragma Assert (Self_ID.Deferral_Level > 0);\n-\n       Vulnerable_Complete_Master (Self_ID);\n    end Complete_Master;\n \n@@ -499,6 +497,7 @@ package body System.Tasking.Stages is\n \n    procedure Complete_Task is\n       Self_ID  : constant Task_Id := STPO.Self;\n+\n    begin\n       pragma Assert (Self_ID.Deferral_Level > 0);\n \n@@ -570,7 +569,6 @@ package body System.Tasking.Stages is\n \n       begin\n          T := New_ATCB (Num_Entries);\n-\n       exception\n          when others =>\n             Initialization.Undefer_Abort_Nestable (Self_ID);\n@@ -591,8 +589,8 @@ package body System.Tasking.Stages is\n       if not Self_ID.Callable then\n          pragma Assert (Self_ID.Pending_ATC_Level = 0);\n          pragma Assert (Self_ID.Pending_Action);\n-         pragma Assert (Chain.T_ID = null\n-             or else Chain.T_ID.Common.State = Unactivated);\n+         pragma Assert\n+           (Chain.T_ID = null or else Chain.T_ID.Common.State = Unactivated);\n \n          Unlock (Self_ID);\n          Unlock_RTS;\n@@ -630,16 +628,14 @@ package body System.Tasking.Stages is\n          Len := 1;\n          T.Common.Task_Image (1) := Task_Image (Task_Image'First);\n \n-         for J in Task_Image'First + 1 .. Task_Image'Last loop\n-\n-            --  Remove unwanted blank space generated by 'Image\n+         --  Remove unwanted blank space generated by 'Image\n \n+         for J in Task_Image'First + 1 .. Task_Image'Last loop\n             if Task_Image (J) /= ' '\n               or else Task_Image (J - 1) /= '('\n             then\n                Len := Len + 1;\n                T.Common.Task_Image (Len) := Task_Image (J);\n-\n                exit when Len = T.Common.Task_Image'Last;\n             end if;\n          end loop;\n@@ -680,7 +676,6 @@ package body System.Tasking.Stages is\n \n    procedure Enter_Master is\n       Self_ID : constant Task_Id := STPO.Self;\n-\n    begin\n       Self_ID.Master_Within := Self_ID.Master_Within + 1;\n    end Enter_Master;\n@@ -689,7 +684,7 @@ package body System.Tasking.Stages is\n    -- Expunge_Unactivated_Tasks --\n    -------------------------------\n \n-   --  See procedure Close_Entries for the general case.\n+   --  See procedure Close_Entries for the general case\n \n    procedure Expunge_Unactivated_Tasks (Chain : in out Activation_Chain) is\n       Self_ID : constant Task_Id := STPO.Self;\n@@ -707,10 +702,9 @@ package body System.Tasking.Stages is\n       --  Experimentation has shown that abort is sometimes (but not\n       --  always) already deferred when this is called.\n \n-      --  That may indicate an error. Find out what is going on.\n+      --  That may indicate an error. Find out what is going on\n \n       C := Chain.T_ID;\n-\n       while C /= null loop\n          pragma Assert (C.Common.State = Unactivated);\n \n@@ -748,7 +742,7 @@ package body System.Tasking.Stages is\n    --  objects does anything with signals or the timer server, since\n    --  by that time those servers have terminated.\n \n-   --  It is hard to see how that would occur.\n+   --  It is hard to see how that would occur\n \n    --  However, a better solution might be to do all this finalization\n    --  using the global finalization chain.\n@@ -896,9 +890,11 @@ package body System.Tasking.Stages is\n       use type SSE.Storage_Offset;\n       use System.Standard_Library;\n \n-      Secondary_Stack : aliased SSE.Storage_Array\n-        (1 .. Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n-           SSE.Storage_Offset (Parameters.Sec_Stack_Ratio) / 100);\n+      Secondary_Stack :\n+        aliased SSE.Storage_Array\n+          (1 .. Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n+                  SSE.Storage_Offset (Parameters.Sec_Stack_Ratio) / 100);\n+\n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n \n    begin\n@@ -1041,14 +1037,13 @@ package body System.Tasking.Stages is\n \n       Master_of_Task := Self_ID.Master_of_Task;\n \n-      --  Check if the current task is an independent task\n-      --  If so, decrement the Independent_Task_Count value.\n+      --  Check if the current task is an independent task If so, decrement\n+      --  the Independent_Task_Count value.\n \n       if Master_of_Task = 2 then\n          if Single_Lock then\n             Utilities.Independent_Task_Count :=\n               Utilities.Independent_Task_Count - 1;\n-\n          else\n             Write_Lock (Environment_Task);\n             Utilities.Independent_Task_Count :=\n@@ -1072,8 +1067,7 @@ package body System.Tasking.Stages is\n       SSL.Destroy_TSD (Self_ID.Common.Compiler_Data);\n       Initialization.Final_Task_Unlock (Self_ID);\n \n-      --  WARNING\n-      --  past this point, this thread must assume that the ATCB\n+      --  WARNING: past this point, this thread must assume that the ATCB\n       --  has been deallocated. It should not be accessed again.\n \n       if Master_of_Task > 0 then\n@@ -1243,8 +1237,8 @@ package body System.Tasking.Stages is\n          end if;\n \n          Write_Lock (Self_ID);\n-         C := All_Tasks_List;\n \n+         C := All_Tasks_List;\n          while C /= null loop\n             if C.Common.Activator = Self_ID then\n                return False;\n@@ -1290,8 +1284,8 @@ package body System.Tasking.Stages is\n \n       Lock_RTS;\n       Write_Lock (Self_ID);\n-      C := All_Tasks_List;\n \n+      C := All_Tasks_List;\n       while C /= null loop\n          if C.Common.Activator = Self_ID then\n             pragma Assert (C.Common.State = Unactivated);\n@@ -1402,8 +1396,8 @@ package body System.Tasking.Stages is\n          pragma Assert (Self_ID.Common.Wait_Count = 0);\n \n          Write_Lock (Self_ID);\n-         C := All_Tasks_List;\n \n+         C := All_Tasks_List;\n          while C /= null loop\n             if C.Common.Parent = Self_ID and then C.Master_of_Task = CM then\n                Write_Lock (C);\n@@ -1428,7 +1422,7 @@ package body System.Tasking.Stages is\n             Unlock_RTS;\n          end if;\n \n-         --  Wait for all counted tasks to finish terminating themselves.\n+         --  Wait for all counted tasks to finish terminating themselves\n \n          Write_Lock (Self_ID);\n \n@@ -1457,7 +1451,6 @@ package body System.Tasking.Stages is\n \n       C := All_Tasks_List;\n       P := null;\n-\n       while C /= null loop\n          if C.Common.Parent = Self_ID and then C.Master_of_Task >= CM then\n             if P /= null then\n@@ -1479,7 +1472,7 @@ package body System.Tasking.Stages is\n \n       Unlock_RTS;\n \n-      --  Free all the ATCBs on the list To_Be_Freed.\n+      --  Free all the ATCBs on the list To_Be_Freed\n \n       --  The ATCBs in the list are no longer in All_Tasks_List, and after\n       --  any interrupt entries are detached from them they should no longer\n@@ -1666,6 +1659,8 @@ package body System.Tasking.Stages is\n       System.Task_Primitives.Operations.Finalize_TCB (T);\n    end Vulnerable_Free_Task;\n \n+--  Package elaboration code\n+\n begin\n    --  Establish the Adafinal softlink.\n "}]}