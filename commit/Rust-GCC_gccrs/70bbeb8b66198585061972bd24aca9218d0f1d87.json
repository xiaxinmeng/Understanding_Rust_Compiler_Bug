{"sha": "70bbeb8b66198585061972bd24aca9218d0f1d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBiYmViOGI2NjE5ODU4NTA2MTk3MmJkMjRhY2E5MjE4ZDBmMWQ4Nw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-11-27T11:43:32Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-11-27T11:43:32Z"}, "message": "In cselib, do not consider constants with different modes equivalent.\n\nFrom-SVN: r37792", "tree": {"sha": "996050d394a3a35c912470ab430f5912aada4aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/996050d394a3a35c912470ab430f5912aada4aa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70bbeb8b66198585061972bd24aca9218d0f1d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70bbeb8b66198585061972bd24aca9218d0f1d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70bbeb8b66198585061972bd24aca9218d0f1d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70bbeb8b66198585061972bd24aca9218d0f1d87/comments", "author": null, "committer": null, "parents": [{"sha": "f98251686f1e33a6698e9d118d7f1c6a600c0c23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98251686f1e33a6698e9d118d7f1c6a600c0c23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98251686f1e33a6698e9d118d7f1c6a600c0c23"}], "stats": {"total": 79, "additions": 65, "deletions": 14}, "files": [{"sha": "9858a21fcb248c27201b83f9c75b1734e1c1ded8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70bbeb8b66198585061972bd24aca9218d0f1d87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70bbeb8b66198585061972bd24aca9218d0f1d87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70bbeb8b66198585061972bd24aca9218d0f1d87", "patch": "@@ -1,3 +1,17 @@\n+2000-11-27  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* reload1.c (reload_cse_simplify_set): Pass down mode to cselib_lookup.\n+\t(reload_cse_simplify_operands): Do nothing about operands where both\n+\tthe operand and the match_operand fail to give us a mode.\n+\t* simplify-rtx.c (wrap_constant): New function.\n+\t(entry_and_rtx_equal_p): Except integer constants to come wrapped in a\n+\tCONST describing the proper mode.\n+\t(rtx_equal_for_cselib_p): Pass down modes to recursive calls of\n+\tcselib_lookup.\n+\t(cselib_lookup_mem): Call wrap_constant on the rtx that is passed to\n+\thtab_find_slot_with_hash.\n+\t(cselib_lookup): Likewise.\n+\n 2000-11-27  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* configure.in (extra_objs): Enclose extra_headers in quotes."}, {"sha": "44ff84ecaa538d4bfda8267009a9c7524f4249c5", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70bbeb8b66198585061972bd24aca9218d0f1d87/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70bbeb8b66198585061972bd24aca9218d0f1d87/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=70bbeb8b66198585061972bd24aca9218d0f1d87", "patch": "@@ -8093,7 +8093,7 @@ reload_cse_simplify_set (set, insn)\n     /* ???   */\n     old_cost = rtx_cost (src, SET);\n \n-  val = cselib_lookup (src, VOIDmode, 0);\n+  val = cselib_lookup (src, GET_MODE (SET_DEST (set)), 0);\n   if (! val)\n     return 0;\n   for (l = val->locs; l; l = l->next)\n@@ -8178,8 +8178,11 @@ reload_cse_simplify_operands (insn)\n       CLEAR_HARD_REG_SET (equiv_regs[i]);\n \n       /* cselib blows up on CODE_LABELs.  Trying to fix that doesn't seem\n-\t right, so avoid the problem here.  */\n-      if (GET_CODE (recog_data.operand[i]) == CODE_LABEL)\n+\t right, so avoid the problem here.  Likewise if we have a constant\n+         and the insn pattern doesn't tell us the mode we need.  */\n+      if (GET_CODE (recog_data.operand[i]) == CODE_LABEL\n+\t  || (CONSTANT_P (recog_data.operand[i])\n+\t      && recog_data.operand_mode[i] == VOIDmode))\n \tcontinue;\n \n       v = cselib_lookup (recog_data.operand[i], recog_data.operand_mode[i], 0);"}, {"sha": "d7b43d1ac9171ccbfd81577a26eac3e20a0b836e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70bbeb8b66198585061972bd24aca9218d0f1d87/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70bbeb8b66198585061972bd24aca9218d0f1d87/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=70bbeb8b66198585061972bd24aca9218d0f1d87", "patch": "@@ -115,6 +115,7 @@ static void clear_table\t\t\tPARAMS ((void));\n static int discard_useless_locs\t\tPARAMS ((void **, void *));\n static int discard_useless_values\tPARAMS ((void **, void *));\n static void remove_useless_values\tPARAMS ((void));\n+static rtx wrap_constant\t\tPARAMS ((enum machine_mode, rtx));\n static unsigned int hash_rtx\t\tPARAMS ((rtx, enum machine_mode, int));\n static cselib_val *new_cselib_val\tPARAMS ((unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n@@ -2221,7 +2222,9 @@ clear_table ()\n }\n \n /* The equality test for our hash table.  The first argument ENTRY is a table\n-   element (i.e. a cselib_val), while the second arg X is an rtx.  */\n+   element (i.e. a cselib_val), while the second arg X is an rtx.  We know\n+   that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a\n+   CONST of an appropriate mode.  */\n \n static int\n entry_and_rtx_equal_p (entry, x_arg)\n@@ -2230,7 +2233,20 @@ entry_and_rtx_equal_p (entry, x_arg)\n   struct elt_loc_list *l;\n   const cselib_val *v = (const cselib_val *) entry;\n   rtx x = (rtx) x_arg;\n+  enum machine_mode mode = GET_MODE (x);\n \n+  if (GET_CODE (x) == CONST_INT\n+      || (mode == VOIDmode && GET_CODE (x) == CONST_DOUBLE))\n+    abort ();\n+  if (mode != GET_MODE (v->u.val_rtx))\n+    return 0;\n+\n+  /* Unwrap X if necessary.  */\n+  if (GET_CODE (x) == CONST\n+      && (GET_CODE (XEXP (x, 0)) == CONST_INT\n+\t  || GET_CODE (XEXP (x, 0)) == CONST_DOUBLE))\n+    x = XEXP (x, 0);\n+  \n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n@@ -2366,15 +2382,15 @@ rtx_equal_for_cselib_p (x, y)\n   \n   if (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n     {\n-      cselib_val *e = cselib_lookup (x, VOIDmode, 0);\n+      cselib_val *e = cselib_lookup (x, GET_MODE (x), 0);\n \n       if (e)\n \tx = e->u.val_rtx;\n     }\n \n   if (GET_CODE (y) == REG || GET_CODE (y) == MEM)\n     {\n-      cselib_val *e = cselib_lookup (y, VOIDmode, 0);\n+      cselib_val *e = cselib_lookup (y, GET_MODE (y), 0);\n \n       if (e)\n \ty = e->u.val_rtx;\n@@ -2492,6 +2508,22 @@ rtx_equal_for_cselib_p (x, y)\n   return 1;\n }\n \n+/* We need to pass down the mode of constants through the hash table\n+   functions.  For that purpose, wrap them in a CONST of the appropriate\n+   mode.  */\n+static rtx\n+wrap_constant (mode, x)\n+     enum machine_mode mode;\n+     rtx x;\n+{\n+  if (GET_CODE (x) != CONST_INT\n+      && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n+    return x;\n+  if (mode == VOIDmode)\n+    abort ();\n+  return gen_rtx_CONST (mode, x);\n+}\n+\n /* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n    For registers and memory locations, we look up their cselib_val structure\n    and return its VALUE element.\n@@ -2690,31 +2722,33 @@ cselib_lookup_mem (x, create)\n      rtx x;\n      int create;\n {\n+  enum machine_mode mode = GET_MODE (x);\n   void **slot;\n   cselib_val *addr;\n   cselib_val *mem_elt;\n   struct elt_list *l;\n \n-  if (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode\n-      || (FLOAT_MODE_P (GET_MODE (x)) && flag_float_store))\n+  if (MEM_VOLATILE_P (x) || mode == BLKmode\n+      || (FLOAT_MODE_P (mode) && flag_float_store))\n     return 0;\n \n   /* Look up the value for the address.  */\n-  addr = cselib_lookup (XEXP (x, 0), GET_MODE (x), create);\n+  addr = cselib_lookup (XEXP (x, 0), mode, create);\n   if (! addr)\n     return 0;\n \n   /* Find a value that describes a value of our mode at that address.  */\n   for (l = addr->addr_list; l; l = l->next)\n-    if (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n+    if (GET_MODE (l->elt->u.val_rtx) == mode)\n       return l->elt;\n \n   if (! create)\n     return 0;\n \n-  mem_elt = new_cselib_val (++next_unknown_value, GET_MODE (x));\n+  mem_elt = new_cselib_val (++next_unknown_value, mode);\n   add_mem_for_addr (addr, mem_elt, x);\n-  slot = htab_find_slot_with_hash (hash_table, x, mem_elt->value, INSERT);\n+  slot = htab_find_slot_with_hash (hash_table, wrap_constant (mode, x),\n+\t\t\t\t   mem_elt->value, INSERT);\n   *slot = mem_elt;\n   return mem_elt;\n }\n@@ -2847,8 +2881,8 @@ cselib_lookup (x, mode, create)\n   if (! hashval)\n     return 0;\n \n-  slot = htab_find_slot_with_hash (hash_table, x, hashval,\n-\t\t\t\t   create ? INSERT : NO_INSERT);\n+  slot = htab_find_slot_with_hash (hash_table, wrap_constant (mode, x),\n+\t\t\t\t   hashval, create ? INSERT : NO_INSERT);\n   if (slot == 0)\n     return 0;\n "}]}