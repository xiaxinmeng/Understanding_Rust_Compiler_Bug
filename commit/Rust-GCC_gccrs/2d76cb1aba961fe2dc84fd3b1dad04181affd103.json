{"sha": "2d76cb1aba961fe2dc84fd3b1dad04181affd103", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ3NmNiMWFiYTk2MWZlMmRjODRmZDNiMWRhZDA0MTgxYWZmZDEwMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-08-17T21:23:12Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-08-17T21:23:12Z"}, "message": "sbitmap.c: Fix comment formatting.\n\n\t* sbitmap.c: Fix comment formatting.\n\t* sched-deps.c: Likewise.\n\t* sibcall.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\t* ssa.c: Likewise.\n\t* ssa-ccp.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* timevar.c: Likewise.\n\t* toplev.c: Likewise.\n\t* unwind-dw2.c: Likewise.\n\t* unwind-dw2-fde.c: Likewise.\n\t* varasm.c: Likewise.\n\nFrom-SVN: r44983", "tree": {"sha": "d04df8e015f11f7c3f1a689524aaa53d9d41c76a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d04df8e015f11f7c3f1a689524aaa53d9d41c76a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d76cb1aba961fe2dc84fd3b1dad04181affd103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d76cb1aba961fe2dc84fd3b1dad04181affd103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d76cb1aba961fe2dc84fd3b1dad04181affd103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d76cb1aba961fe2dc84fd3b1dad04181affd103/comments", "author": null, "committer": null, "parents": [{"sha": "171262081c9cd444023acbd55ef265e9cffcd47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/171262081c9cd444023acbd55ef265e9cffcd47b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/171262081c9cd444023acbd55ef265e9cffcd47b"}], "stats": {"total": 89, "additions": 52, "deletions": 37}, "files": [{"sha": "29ca30140e9cb70732089c5b4eb5add044bef465", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -1,3 +1,18 @@\n+2001-08-17  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* sbitmap.c: Fix comment formatting.\n+\t* sched-deps.c: Likewise.\n+\t* sibcall.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\t* ssa.c: Likewise.\n+\t* ssa-ccp.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* timevar.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* unwind-dw2.c: Likewise.\n+\t* unwind-dw2-fde.c: Likewise.\n+\t* varasm.c: Likewise.\n+\n 2001-08-17  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* pa.h (RETURN_IN_MEMORY): Return types with a size that is varable"}, {"sha": "ef9fcd1e7aebcdd4a5102d9f50ee92b0ccb4edf5", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -99,7 +99,7 @@ sbitmap_copy (dst, src)\n   memcpy (dst->elms, src->elms, sizeof (SBITMAP_ELT_TYPE) * dst->size);\n }\n \n-/* Determine if a == b. */\n+/* Determine if a == b.  */\n int\n sbitmap_equal (a, b)\n      sbitmap a, b;\n@@ -238,7 +238,7 @@ sbitmap_a_and_b (dst, a, b)\n }\n \n /* Set DST to be (A xor B)).\n-   Return non-zero if any change is made. */\n+   Return non-zero if any change is made.  */\n \n int\n sbitmap_a_xor_b (dst, a, b)"}, {"sha": "d7cb5490c27ab702b5ee45cecdf141812b0a04f0", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -63,15 +63,15 @@ static int reg_pending_sets_all;\n    Each insn has associated bitmaps for its dependencies.  Each bitmap\n    has enough entries to represent a dependency on any other insn in\n    the insn chain.  All bitmap for true dependencies cache is\n-   allocated then the rest two ones are also allocated. */\n+   allocated then the rest two ones are also allocated.  */\n static sbitmap *true_dependency_cache;\n static sbitmap *anti_dependency_cache;\n static sbitmap *output_dependency_cache;\n \n /* To speed up checking consistency of formed forward insn\n    dependencies we use the following cache.  Another possible solution\n    could be switching off checking duplication of insns in forward\n-   dependencies. */\n+   dependencies.  */\n #ifdef ENABLE_CHECKING\n static sbitmap *forward_dependency_cache;\n #endif\n@@ -299,7 +299,7 @@ add_dependence (insn, elem, dep_type)\n \t{\n #ifdef INSN_SCHEDULING\n \t  /* Clear corresponding cache entry because type of the link\n-             may be changed. */\n+             may be changed.  */\n \t  if (true_dependency_cache != NULL)\n \t    {\n \t      if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n@@ -321,7 +321,7 @@ add_dependence (insn, elem, dep_type)\n \t  \n #ifdef INSN_SCHEDULING\n \t  /* If we are adding a dependency to INSN's LOG_LINKs, then\n-\t     note that in the bitmap caches of dependency information. */\n+\t     note that in the bitmap caches of dependency information.  */\n \t  if (true_dependency_cache != NULL)\n \t    {\n \t      if ((int)REG_NOTE_KIND (link) == 0)\n@@ -347,7 +347,7 @@ add_dependence (insn, elem, dep_type)\n \n #ifdef INSN_SCHEDULING\n   /* If we are adding a dependency to INSN's LOG_LINKs, then note that\n-     in the bitmap caches of dependency information. */\n+     in the bitmap caches of dependency information.  */\n   if (true_dependency_cache != NULL)\n     {\n       if ((int)dep_type == 0)"}, {"sha": "a6638b7d2597d256e198155ea09682ead63ac134", "filename": "gcc/sibcall.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -408,7 +408,7 @@ uses_addressof (x)\n   if (code == MEM)\n     return 0;\n \n-  /* Scan all subexpressions. */\n+  /* Scan all subexpressions.  */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n@@ -518,7 +518,7 @@ purge_mem_unchanging_flag (x)\n       return;\n     }\n \n-  /* Scan all subexpressions. */\n+  /* Scan all subexpressions.  */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n@@ -553,7 +553,7 @@ replace_call_placeholder (insn, use)\n   if (XEXP (PATTERN (insn), 3))\n     LABEL_PRESERVE_P (XEXP (PATTERN (insn), 3)) = 0;\n   \n-  /* \"Delete\" the placeholder insn. */\n+  /* \"Delete\" the placeholder insn.  */\n   PUT_CODE (insn, NOTE);\n   NOTE_SOURCE_FILE (insn) = 0;\n   NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n@@ -703,7 +703,7 @@ optimize_sibling_and_tail_recursive_calls ()\n \t      || (call_block->succ->dest != EXIT_BLOCK_PTR\n \t\t  && call_block->succ->dest != alternate_exit)\n \t      /* If this call doesn't end the block, there are operations at\n-\t\t the end of the block which we must execute after returning. */\n+\t\t the end of the block which we must execute after returning.  */\n \t      || ! call_ends_block_p (insn, call_block->end))\n \t    sibcall = 0, tailrecursion = 0;\n "}, {"sha": "74e50c8f4cdf121e97a824d80b9ad709e01ce8ce", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -2415,7 +2415,7 @@ simplify_subreg (outermode, op, innermode, byte)\n       /* The SUBREG_BYTE represents offset, as if the value were stored\n \t in memory.  Irritating exception is paradoxical subreg, where\n \t we define SUBREG_BYTE to be 0.  On big endian machines, this\n-\t value should be negative.  For a moment, undo this exception. */\n+\t value should be negative.  For a moment, undo this exception.  */\n       if (byte == 0 && GET_MODE_SIZE (innermode) < GET_MODE_SIZE (outermode))\n \t{\n \t  int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n@@ -2538,7 +2538,7 @@ simplify_subreg (outermode, op, innermode, byte)\n       res = simplify_subreg (outermode, part, GET_MODE (part), final_offset);\n       if (res)\n \treturn res;\n-      /* We can at least simplify it by referring directly to the relevent part. */\n+      /* We can at least simplify it by referring directly to the relevent part.  */\n       return gen_rtx_SUBREG (outermode, part, final_offset);\n     }\n "}, {"sha": "0815f756f16276e18ba08b8815b3f393836eb71b", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -673,7 +673,7 @@ examine_flow_edges (void)\n \t  /* If we haven't looked at the next block, and it has a\n \t     single successor, add it onto the worklist.  This is because\n \t     if we only have one successor, we know it gets executed,\n-\t     so we don't have to wait for cprop to tell us. */\n+\t     so we don't have to wait for cprop to tell us.  */\n \t  if (succ_edge != NULL\n \t      && succ_edge->succ_next == NULL\n \t      && !TEST_BIT (executable_edges,"}, {"sha": "77357863e84953097e0a3611bc37b1e699bd353e", "filename": "gcc/ssa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -786,7 +786,7 @@ apply_delayed_renames (c)\n       if (r->prev_reg == NULL_RTX && !HARD_REGISTER_P (r->old_reg))\n \t{\n \t  r->new_reg = r->old_reg;\n-\t  /* We want to restore RENAME_NO_RTX rather than NULL_RTX. */\n+\t  /* We want to restore RENAME_NO_RTX rather than NULL_RTX.  */\n \t  r->prev_reg = RENAME_NO_RTX;\n \t}\n       else\n@@ -1602,14 +1602,14 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n \t\t    abort ();\n \n \t\t  /* If the alternatives aren't already in the same\n-\t\t     class ... */\n+\t\t     class ...  */\n \t\t  if (partition_find (reg_partition, REGNO (*alt)) \n \t\t      != partition_find (reg_partition, REGNO (*alt2)))\n \t\t    {\n \t\t      /* ... make them so.  */\n \t\t      if (conflicting_hard_regs_p (REGNO (*alt), REGNO (*alt2)))\n \t\t\t/* It is illegal to unify a hard register with\n-\t\t\t   a different register. */\n+\t\t\t   a different register.  */\n \t\t\tabort ();\n \n \t\t      partition_union (reg_partition, \n@@ -1698,7 +1698,7 @@ coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n {\n   int reg;\n \n-  /* Work only on SSA registers. */\n+  /* Work only on SSA registers.  */\n   if (!CONVERT_REGISTER_TO_SSA_P (reg1) || !CONVERT_REGISTER_TO_SSA_P (reg2))\n     return 0;\n "}, {"sha": "39c30c5a9127e7f720ba41c27778f355147ee909", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -274,7 +274,7 @@ int_mode_for_mode (mode)\n       if (mode == BLKmode)\n         break;\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case MODE_CC:\n     default:\n@@ -1303,11 +1303,11 @@ layout_type (type)\n \t of the language-specific code.  */\n       abort ();\n \n-    case BOOLEAN_TYPE:  /* Used for Java, Pascal, and Chill. */\n+    case BOOLEAN_TYPE:  /* Used for Java, Pascal, and Chill.  */\n       if (TYPE_PRECISION (type) == 0)\n-\tTYPE_PRECISION (type) = 1; /* default to one byte/boolean. */\n+\tTYPE_PRECISION (type) = 1; /* default to one byte/boolean.  */\n \n-      /* ... fall through ... */\n+      /* ... fall through ...  */\n \n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n@@ -1525,7 +1525,7 @@ layout_type (type)\n       }\n       break;\n \n-    case SET_TYPE:  /* Used by Chill and Pascal. */\n+    case SET_TYPE:  /* Used by Chill and Pascal.  */\n       if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST\n \t  || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST)\n \tabort();"}, {"sha": "09d453d52c8e8cf87411d78092c7b48fa809fb4f", "filename": "gcc/timevar.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -113,7 +113,7 @@ static int clocks_to_msec;\n \n /* See timevar.h for an explanation of timing variables.  */\n \n-/* This macro evaluates to non-zero if timing variables are enabled. */\n+/* This macro evaluates to non-zero if timing variables are enabled.  */\n #define TIMEVAR_ENABLE (time_report)\n \n /* A timing variable.  */\n@@ -279,7 +279,7 @@ timevar_push (timevar)\n     timevar_accumulate (&stack->timevar->elapsed, &start_time, &now);\n \n   /* Reset the start time; from now on, time is attributed to\n-     TIMEVAR. */\n+     TIMEVAR.  */\n   start_time = now;\n \n   /* See if we have a previously-allocated stack instance.  If so,\n@@ -441,7 +441,7 @@ timevar_print (fp)\n     timevar_accumulate (&stack->timevar->elapsed, &start_time, &now);\n \n   /* Reset the start time; from now on, time is attributed to\n-     TIMEVAR. */\n+     TIMEVAR.  */\n   start_time = now;\n \n   fputs (_(\"\\nExecution times (seconds)\\n\"), fp);"}, {"sha": "690a3bc556da7a118a83792a6acf835a23199d36", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -2902,7 +2902,7 @@ rest_of_compilation (decl)\n \n       if (flag_ssa_dce)\n \t{\n-\t  /* Remove dead code. */\n+\t  /* Remove dead code.  */\n \n \t  timevar_push (TV_SSA_DCE);\n \t  open_dump_file (DFI_ssa_dce, decl);"}, {"sha": "c9ead4af7764487b8fd46c01eab6a9caa0bf8e51", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -436,19 +436,19 @@ frame_heapsort (struct object *ob, fde_compare_t fde_compare,\n {\n   /* For a description of this algorithm, see:\n      Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,\n-     p. 60-61. */\n+     p. 60-61.  */\n   fde ** a = erratic->array;\n   /* A portion of the array is called a \"heap\" if for all i>=0:\n      If i and 2i+1 are valid indices, then a[i] >= a[2i+1].\n-     If i and 2i+2 are valid indices, then a[i] >= a[2i+2]. */\n+     If i and 2i+2 are valid indices, then a[i] >= a[2i+2].  */\n #define SWAP(x,y) do { fde * tmp = x; x = y; y = tmp; } while (0)\n   size_t n = erratic->count;\n   size_t m = n;\n   size_t i;\n \n   while (m > 0)\n     {\n-      /* Invariant: a[m..n-1] is a heap. */\n+      /* Invariant: a[m..n-1] is a heap.  */\n       m--;\n       for (i = m; 2*i+1 < n; )\n         {\n@@ -470,7 +470,7 @@ frame_heapsort (struct object *ob, fde_compare_t fde_compare,\n     }\n   while (n > 1)\n     {\n-      /* Invariant: a[0..n-1] is a heap. */\n+      /* Invariant: a[0..n-1] is a heap.  */\n       n--;\n       SWAP (a[0], a[n]);\n       for (i = 0; 2*i+1 < n; )\n@@ -494,7 +494,7 @@ frame_heapsort (struct object *ob, fde_compare_t fde_compare,\n #undef SWAP\n }\n \n-/* Merge V1 and V2, both sorted, and put the result into V1. */\n+/* Merge V1 and V2, both sorted, and put the result into V1.  */\n static inline void\n fde_merge (struct object *ob, fde_compare_t fde_compare,\n \t   struct fde_vector *v1, struct fde_vector *v2)"}, {"sha": "16f6bceb5c936e3d039a5e065192a0f5f43e3ff2", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -291,7 +291,7 @@ static _Unwind_Word\n execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t\t  struct _Unwind_Context *context, _Unwind_Word initial)\n {\n-  _Unwind_Word stack[64];\t/* ??? Assume this is enough. */\n+  _Unwind_Word stack[64];\t/* ??? Assume this is enough.  */\n   int stack_elt;\n \n   stack[0] = initial;"}, {"sha": "8b340624b8efc4c20f26696b42e08553e8df1888", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d76cb1aba961fe2dc84fd3b1dad04181affd103/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=2d76cb1aba961fe2dc84fd3b1dad04181affd103", "patch": "@@ -803,7 +803,7 @@ make_decl_rtl (decl, asmspec)\n \t\t     \"register name given for non-register variable `%s'\");\n \n   /* Specifying a section attribute on a variable forces it into a\n-     non-.bss section, and thus it cannot be common. */\n+     non-.bss section, and thus it cannot be common.  */\n   if (TREE_CODE (decl) == VAR_DECL\n       && DECL_SECTION_NAME (decl) != NULL_TREE\n       && DECL_INITIAL (decl) == NULL_TREE\n@@ -1754,7 +1754,7 @@ assemble_static_space (size)\n   {\n     /* Round size up to multiple of BIGGEST_ALIGNMENT bits\n        so that each uninitialized object starts on such a boundary.  */\n-    /* Variable `rounded' might or might not be used in ASM_OUTPUT_LOCAL. */\n+    /* Variable `rounded' might or might not be used in ASM_OUTPUT_LOCAL.  */\n     int rounded ATTRIBUTE_UNUSED\n       = ((size + (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1)\n \t / (BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n@@ -2473,7 +2473,7 @@ const_hash (exp)\n       return const_hash (TREE_OPERAND (exp, 0)) * 7 + 2;\n       \n     default:\n-      /* A language specific constant. Just hash the code. */\n+      /* A language specific constant. Just hash the code.  */\n       return (int) code % MAX_HASH_TABLE;\n     }\n \n@@ -4466,7 +4466,7 @@ output_constructor (exp, size)\n \n      There is always a maximum of one element in the chain LINK for unions\n      (even if the initializer in a source program incorrectly contains\n-     more one). */\n+     more one).  */\n   for (link = CONSTRUCTOR_ELTS (exp);\n        link;\n        link = TREE_CHAIN (link),"}]}