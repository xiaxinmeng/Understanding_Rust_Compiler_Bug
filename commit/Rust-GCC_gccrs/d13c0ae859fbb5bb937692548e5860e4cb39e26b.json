{"sha": "d13c0ae859fbb5bb937692548e5860e4cb39e26b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEzYzBhZTg1OWZiYjViYjkzNzY5MjU0OGU1ODYwZTRjYjM5ZTI2Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-24T19:50:29Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-24T19:56:59Z"}, "message": "c++: Cleanup some decl pushing apis\n\nIn cleaning up local decl handling, here's an initial patch that takes\nadvantage of C++'s default args for the is_friend parm of pushdecl,\nduplicate_decls and push_template_decl_real and the scope & tpl_header\nparms of xref_tag.  Then many of the calls simply not mention these.\nI also rename push_template_decl_real to push_template_decl, deleting\nthe original forwarding function.  This'll make my later patches\nchanging their types less intrusive.  There are 2 functional changes:\n\n1) push_template_decl requires is_friend to be correct, it doesn't go\nchecking for a friend function (an assert is added).\n\n2) debug_overload prints out Hidden and Using markers for the overload set.\n\n\tgcc/cp/\n\t* cp-tree.h (duplicate_decls): Default is_friend to false.\n\t(xref_tag): Default tag_scope & tpl_header_p to ts_current & false.\n\t(push_template_decl_real): Default is_friend to false.  Rename to\n\t...\n\t(push_template_decl): ... here.  Delete original decl.\n\t* name-lookup.h (pushdecl_namespace_level): Default is_friend to\n\tfalse.\n\t(pushtag): Default tag_scope to ts_current.\n\t* coroutines.cc (morph_fn_to_coro): Drop default args to xref_tag.\n\t* decl.c (start_decl): Drop default args to duplicate_decls.\n\t(start_enum): Drop default arg to pushtag & xref_tag.\n\t(start_preparsed_function): Pass DECL_FRIEND_P to\n\tpush_template_decl.\n\t(grokmethod): Likewise.\n\t* friend.c (do_friend): Rename push_template_decl_real calls.\n\t* lambda.c (begin_lamnbda_type): Drop default args to xref_tag.\n\t(vla_capture_type): Likewise.\n\t* name-lookup.c (maybe_process_template_type_declaration): Rename\n\tpush_template_decl_real call.\n\t(pushdecl_top_level_and_finish): Drop default arg to\n\tpushdecl_namespace_level.\n\t* pt.c (push_template_decl_real): Assert no surprising friend\n\tfunctions.  Rename to ...\n\t(push_template_decl): ... here.  Delete original function.\n\t(lookup_template_class_1): Drop default args from pushtag.\n\t(instantiate_class_template_1): Likewise.\n\t* ptree.c (debug_overload): Print hidden and using markers.\n\t* rtti.c (init_rtti_processing): Drop refault args from xref_tag.\n\t(build_dynamic_cast_1, tinfo_base_init): Likewise.\n\t* semantics.c (begin_class_definition): Drop default args to\n\tpushtag.\n\tgcc/objcp/\n\t* objcp-decl.c (objcp_start_struct): Drop default args to\n\txref_tag.\n\t(objcp_xref_tag): Likewise.\n\tlibcc1/\n\t* libcp1plugin.cc (supplement_binding): Drop default args to\n\tduplicate_decls.\n\t(safe_pushtag): Drop scope parm.  Drop default args to pushtag.\n\t(safe_pushdecl_maybe_friend): Rename to ...\n\t(safe_pushdecl): ... here. Drop is_friend parm.  Drop default args\n\tto pushdecl.\n\t(plugin_build_decl): Adjust safe_pushdecl & safe_pushtag calls.\n\t(plugin_build_constant): Adjust safe_pushdecl call.", "tree": {"sha": "a626f5797c0268417dbd9864fe484c1b06c0a1fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a626f5797c0268417dbd9864fe484c1b06c0a1fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d13c0ae859fbb5bb937692548e5860e4cb39e26b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d13c0ae859fbb5bb937692548e5860e4cb39e26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d13c0ae859fbb5bb937692548e5860e4cb39e26b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d13c0ae859fbb5bb937692548e5860e4cb39e26b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b6c89b37bc26791943ea79191891e77591de2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6c89b37bc26791943ea79191891e77591de2b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6c89b37bc26791943ea79191891e77591de2b8"}], "stats": {"total": 110, "additions": 52, "deletions": 58}, "files": [{"sha": "ba813454a0bec55e065ac87c68d0cd302680d824", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -4011,7 +4011,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* 2. Types we need to define or look up.  */\n \n   tree fr_name = get_fn_local_identifier (orig, \"frame\");\n-  tree coro_frame_type = xref_tag (record_type, fr_name, ts_current, false);\n+  tree coro_frame_type = xref_tag (record_type, fr_name);\n   DECL_CONTEXT (TYPE_NAME (coro_frame_type)) = current_scope ();\n   tree coro_frame_ptr = build_pointer_type (coro_frame_type);\n   tree act_des_fn_type"}, {"sha": "3ae48749b3ded42b39cfe174632fba25a40610ae", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -6461,7 +6461,8 @@ extern void note_iteration_stmt_body_end\t(bool);\n extern void determine_local_discriminator\t(tree);\n extern int decls_match\t\t\t\t(tree, tree, bool = true);\n extern bool maybe_version_functions\t\t(tree, tree, bool);\n-extern tree duplicate_decls\t\t\t(tree, tree, bool);\n+extern tree duplicate_decls\t\t\t(tree, tree,\n+\t\t\t\t\t\t bool is_friend = false);\n extern tree declare_local_label\t\t\t(tree);\n extern tree define_label\t\t\t(location_t, tree);\n extern void check_goto\t\t\t\t(tree);\n@@ -6501,7 +6502,9 @@ extern tree get_scope_of_declarator\t\t(const cp_declarator *);\n extern void grok_special_member_properties\t(tree);\n extern bool grok_ctor_properties\t\t(const_tree, const_tree);\n extern bool grok_op_properties\t\t\t(tree, bool);\n-extern tree xref_tag\t\t\t\t(enum tag_types, tree, tag_scope, bool);\n+extern tree xref_tag\t\t\t\t(tag_types, tree,\n+\t\t\t\t\t\t tag_scope = ts_current,\n+\t\t\t\t\t\t bool tpl_header_p = false);\n extern void xref_basetypes\t\t\t(tree, tree);\n extern tree start_enum\t\t\t\t(tree, tree, tree, tree, bool, bool *);\n extern void finish_enum_value_list\t\t(tree);\n@@ -6849,8 +6852,7 @@ extern void end_template_parm_list\t\t(void);\n extern void end_template_decl\t\t\t(void);\n extern tree maybe_update_decl_type\t\t(tree, tree);\n extern bool check_default_tmpl_args             (tree, tree, bool, bool, int);\n-extern tree push_template_decl\t\t\t(tree);\n-extern tree push_template_decl_real\t\t(tree, bool);\n+extern tree push_template_decl\t\t\t(tree, bool is_friend = false);\n extern tree add_inherited_template_parms\t(tree, tree);\n extern void template_parm_level_and_index\t(tree, int*, int*);\n extern bool redeclare_class_template\t\t(tree, tree, tree);"}, {"sha": "6019051ed12a334b71a45ceeb152d819ec64efb8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -5361,8 +5361,7 @@ start_decl (const cp_declarator *declarator,\n \t\t about this situation, and so we check here.  */\n \t      if (initialized && DECL_INITIALIZED_IN_CLASS_P (field))\n \t\terror (\"duplicate initialization of %qD\", decl);\n-\t      field = duplicate_decls (decl, field,\n-\t\t\t\t       /*newdecl_is_friend=*/false);\n+\t      field = duplicate_decls (decl, field);\n \t      if (field == error_mark_node)\n \t\treturn error_mark_node;\n \t      else if (field)\n@@ -5376,8 +5375,7 @@ start_decl (const cp_declarator *declarator,\n \t\t\t\t      ? current_template_parms\n \t\t\t\t      : NULL_TREE);\n \t  if (field && field != error_mark_node\n-\t      && duplicate_decls (decl, field,\n-\t\t\t\t /*newdecl_is_friend=*/false))\n+\t      && duplicate_decls (decl, field))\n \t    decl = field;\n \t}\n \n@@ -15476,7 +15474,7 @@ start_enum (tree name, tree enumtype, tree underlying_type,\n \t  || TREE_CODE (enumtype) != ENUMERAL_TYPE)\n \t{\n \t  enumtype = cxx_make_type (ENUMERAL_TYPE);\n-\t  enumtype = pushtag (name, enumtype, /*tag_scope=*/ts_current);\n+\t  enumtype = pushtag (name, enumtype);\n \n \t  /* std::byte aliases anything.  */\n \t  if (enumtype != error_mark_node\n@@ -15485,8 +15483,7 @@ start_enum (tree name, tree enumtype, tree underlying_type,\n \t    TYPE_ALIAS_SET (enumtype) = 0;\n \t}\n       else\n-\t  enumtype = xref_tag (enum_type, name, /*tag_scope=*/ts_current,\n-\t\t\t       false);\n+\t  enumtype = xref_tag (enum_type, name);\n \n       if (enumtype == error_mark_node)\n \treturn error_mark_node;\n@@ -16257,7 +16254,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n      by push_nested_class.)  */\n   if (processing_template_decl)\n     {\n-      tree newdecl1 = push_template_decl (decl1);\n+      tree newdecl1 = push_template_decl (decl1, DECL_FRIEND_P (decl1));\n       if (newdecl1 == error_mark_node)\n \t{\n \t  if (ctype || DECL_STATIC_FUNCTION_P (decl1))\n@@ -17362,7 +17359,7 @@ grokmethod (cp_decl_specifier_seq *declspecs,\n   /* We process method specializations in finish_struct_1.  */\n   if (processing_template_decl && !DECL_TEMPLATE_SPECIALIZATION (fndecl))\n     {\n-      fndecl = push_template_decl (fndecl);\n+      fndecl = push_template_decl (fndecl, DECL_FRIEND_P (fndecl));\n       if (fndecl == error_mark_node)\n \treturn fndecl;\n     }"}, {"sha": "e4841347141d783e07f63e7ff84f0433dc22dcf6", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -558,7 +558,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t  else if (class_template_depth)\n \t    /* We rely on tsubst_friend_function to check the\n \t       validity of the declaration later.  */\n-\t    decl = push_template_decl_real (decl, /*is_friend=*/true);\n+\t    decl = push_template_decl (decl, /*is_friend=*/true);\n \t  else\n \t    decl = check_classfn (ctype, decl,\n \t\t\t\t  template_member_p\n@@ -611,7 +611,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t       general, such a declaration depends on template\n \t       parameters.  Instead, we call pushdecl when the class\n \t       is instantiated.  */\n-\t    decl = push_template_decl_real (decl, /*is_friend=*/true);\n+\t    decl = push_template_decl (decl, /*is_friend=*/true);\n \t  else if (current_function_decl)\n \t    /* pushdecl will check there's a local decl already.  */\n \t    decl = pushdecl (decl, /*is_friend=*/true);"}, {"sha": "07a5401c97bd19b213d0caf5ca4b43ce414e2d60", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -134,8 +134,7 @@ begin_lambda_type (tree lambda)\n   IDENTIFIER_LAMBDA_P (name) = true;\n \n   /* Create the new RECORD_TYPE for this lambda.  */\n-  tree type = xref_tag (/*tag_code=*/record_type, name,\n-\t\t\t/*scope=*/ts_current, /*template_header_p=*/false);\n+  tree type = xref_tag (/*tag_code=*/record_type, name);\n   if (type == error_mark_node)\n     return error_mark_node;\n \n@@ -476,7 +475,7 @@ static GTY(()) tree max_id;\n static tree\n vla_capture_type (tree array_type)\n {\n-  tree type = xref_tag (record_type, make_anon_name (), ts_current, false);\n+  tree type = xref_tag (record_type, make_anon_name ());\n   xref_basetypes (type, NULL_TREE);\n   type = begin_class_definition (type);\n   if (!ptr_id)"}, {"sha": "e7764abff67997d02cc70f2add192d9da5ada4c6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -6723,11 +6723,11 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n \n       if (processing_template_decl)\n \t{\n-\t  /* This may change after the call to\n-\t     push_template_decl_real, but we want the original value.  */\n+\t  /* This may change after the call to push_template_decl, but\n+\t     we want the original value.  */\n \t  tree name = DECL_NAME (decl);\n \n-\t  decl = push_template_decl_real (decl, is_friend);\n+\t  decl = push_template_decl (decl, is_friend);\n \t  if (decl == error_mark_node)\n \t    return error_mark_node;\n \n@@ -7301,7 +7301,7 @@ pushdecl_top_level_and_finish (tree x, tree init)\n {\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   do_push_to_top_level ();\n-  x = pushdecl_namespace_level (x, false);\n+  x = pushdecl_namespace_level (x);\n   cp_finish_decl (x, init, false, NULL_TREE, 0);\n   do_pop_from_top_level ();\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);"}, {"sha": "76ec8f23a9fdb446d77b2ba11a5de74986a96a0b", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -341,7 +341,7 @@ extern tree lookup_qualified_name (tree scope, const char *name,\n \t\t\t\t   bool = true);\n extern bool is_local_extern (tree);\n extern bool pushdecl_class_level (tree);\n-extern tree pushdecl_namespace_level (tree, bool);\n+extern tree pushdecl_namespace_level (tree, bool is_friend = false);\n extern bool push_class_level_binding (tree, tree);\n extern tree get_local_decls ();\n extern int function_parm_depth (void);\n@@ -371,7 +371,7 @@ extern tree pushdecl (tree, bool is_friend = false);\n extern tree pushdecl_outermost_localscope (tree);\n extern tree pushdecl_top_level (tree, bool is_friend = false);\n extern tree pushdecl_top_level_and_finish (tree, tree);\n-extern tree pushtag (tree, tree, tag_scope);\n+extern tree pushtag (tree, tree, tag_scope = ts_current);\n extern int push_namespace (tree, bool make_inline = false);\n extern void pop_namespace (void);\n extern void push_nested_namespace (tree);"}, {"sha": "6f8dbc3bc7464658d1fec190db1868f8b2d03f19", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -5669,7 +5669,7 @@ template_parm_outer_level (tree t, void *data)\n    If IS_FRIEND is true, DECL is a friend declaration.  */\n \n tree\n-push_template_decl_real (tree decl, bool is_friend)\n+push_template_decl (tree decl, bool is_friend)\n {\n   tree tmpl;\n   tree args;\n@@ -5694,8 +5694,10 @@ push_template_decl_real (tree decl, bool is_friend)\n \t\t    && DECL_TEMPLATE_SPECIALIZATION (decl)\n \t\t    && TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (decl))));\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl))\n-    is_friend = true;\n+  /* No surprising friend functions.  */\n+  gcc_checking_assert (is_friend\n+\t\t       || !(TREE_CODE (decl) == FUNCTION_DECL\n+\t\t\t    && DECL_FRIEND_P (decl)));\n \n   if (is_friend)\n     /* For a friend, we want the context of the friend, not\n@@ -6096,12 +6098,6 @@ push_template_decl_real (tree decl, bool is_friend)\n   return DECL_TEMPLATE_RESULT (tmpl);\n }\n \n-tree\n-push_template_decl (tree decl)\n-{\n-  return push_template_decl_real (decl, false);\n-}\n-\n /* FN is an inheriting constructor that inherits from the constructor\n    template INHERITED; turn FN into a constructor template with a matching\n    template header.  */\n@@ -9943,7 +9939,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \n \t  /* A local class.  Make sure the decl gets registered properly.  */\n \t  if (context == current_function_decl)\n-\t    if (pushtag (DECL_NAME (gen_tmpl), t, /*tag_scope=*/ts_current)\n+\t    if (pushtag (DECL_NAME (gen_tmpl), t)\n \t\t== error_mark_node)\n \t      return error_mark_node;\n \n@@ -11897,7 +11893,7 @@ instantiate_class_template_1 (tree type)\n \t\t     tsubst_enum.  */\n \t\t  if (name)\n \t\t    SET_IDENTIFIER_TYPE_VALUE (name, newtag);\n-\t\t  pushtag (name, newtag, /*tag_scope=*/ts_current);\n+\t\t  pushtag (name, newtag);\n \t\t}\n \t    }\n \t  else if (DECL_DECLARES_FUNCTION_P (t))\n@@ -12077,6 +12073,7 @@ instantiate_class_template_1 (tree type)\n \t\t/* friend class C<T>;  */\n \t\tfriend_type = tsubst (friend_type, args,\n \t\t\t\t      tf_warning_or_error, NULL_TREE);\n+\t      \n \t      /* Otherwise it's\n \n \t\t   friend class C;"}, {"sha": "a28b722f5712f4f7edb1306c1c97461b8f51e3de", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -332,8 +332,12 @@ debug_overload (tree node)\n       tree decl = *iter;\n       auto xloc = expand_location (DECL_SOURCE_LOCATION (decl));\n       auto fullname = decl_as_string (decl, 0);\n+      bool using_p = iter.using_p ();\n+      bool hidden_p = iter.hidden_p ();\n \n-      fprintf (file, \"%p: %s:%d:%d \\\"%s\\\"\\n\", (void *)decl,\n+      fprintf (file, \"%p:%c%c %s:%d:%d \\\"%s\\\"\\n\", (void *)decl,\n+\t       hidden_p ? 'H' : '-',\n+\t       using_p ? 'U' : '-',\n \t       xloc.file, xloc.line, xloc.column, fullname);\n     }\n }"}, {"sha": "7c4bff76e8c9765da6d56b61d906cfeefc78e005", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -169,8 +169,7 @@ init_rtti_processing (void)\n   tree type_info_type;\n \n   push_nested_namespace (std_node);\n-  type_info_type = xref_tag (class_type, get_identifier (\"type_info\"),\n-\t\t\t     /*tag_scope=*/ts_current, false);\n+  type_info_type = xref_tag (class_type, get_identifier (\"type_info\"));\n   pop_nested_namespace (std_node);\n   const_type_info_type_node\n     = cp_build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n@@ -761,9 +760,7 @@ build_dynamic_cast_1 (location_t loc, tree type, tree expr,\n \n \t      push_abi_namespace ();\n \t      tinfo_ptr = xref_tag (class_type,\n-\t\t\t\t    get_identifier (\"__class_type_info\"),\n-\t\t\t\t    /*tag_scope=*/ts_current, false);\n-\n+\t\t\t\t    get_identifier (\"__class_type_info\"));\n \t      tinfo_ptr = build_pointer_type\n \t\t(cp_build_qualified_type\n \t\t (tinfo_ptr, TYPE_QUAL_CONST));\n@@ -948,10 +945,8 @@ tinfo_base_init (tinfo_s *ti, tree target)\n   vtable_ptr = ti->vtable;\n   if (!vtable_ptr)\n     {\n-      tree real_type;\n       push_abi_namespace ();\n-      real_type = xref_tag (class_type, ti->name,\n-\t\t\t    /*tag_scope=*/ts_current, false);\n+      tree real_type = xref_tag (class_type, ti->name);\n       pop_abi_namespace ();\n \n       if (!COMPLETE_TYPE_P (real_type))"}, {"sha": "b0930442bdada69ee94897e5219ad48be62c9d3f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -3216,13 +3216,13 @@ begin_class_definition (tree t)\n   if (t == error_mark_node || ! MAYBE_CLASS_TYPE_P (t))\n     {\n       t = make_class_type (RECORD_TYPE);\n-      pushtag (make_anon_name (), t, /*tag_scope=*/ts_current);\n+      pushtag (make_anon_name (), t);\n     }\n \n   if (TYPE_BEING_DEFINED (t))\n     {\n       t = make_class_type (TREE_CODE (t));\n-      pushtag (TYPE_IDENTIFIER (t), t, /*tag_scope=*/ts_current);\n+      pushtag (TYPE_IDENTIFIER (t), t);\n     }\n   maybe_process_partial_specialization (t);\n   pushclass (t);"}, {"sha": "087b5d50452289d3b100996b308f9f8558113ab9", "filename": "gcc/objcp/objcp-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fobjcp%2Fobjcp-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/gcc%2Fobjcp%2Fobjcp-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.c?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -41,7 +41,7 @@ objcp_start_struct (location_t loc ATTRIBUTE_UNUSED,\n   if (!name)\n     name = make_anon_name ();\n \n-  s = xref_tag (record_type, name, ts_global, 0);\n+  s = xref_tag (record_type, name, ts_global);\n   CLASSTYPE_DECLARED_CLASS (s) = 0;  /* this is a 'struct', not a 'class'.  */\n   xref_basetypes (s, NULL_TREE);     /* no base classes here!  */\n \n@@ -84,7 +84,7 @@ objcp_finish_function (void)\n tree\n objcp_xref_tag (enum tree_code code ATTRIBUTE_UNUSED, tree name)\n {\n-  return xref_tag (record_type, name, ts_global, false);\n+  return xref_tag (record_type, name, ts_global);\n }\n \n int"}, {"sha": "279bb8423934fb03502463dc73e7441f6e5e5a39", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d13c0ae859fbb5bb937692548e5860e4cb39e26b/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d13c0ae859fbb5bb937692548e5860e4cb39e26b/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=d13c0ae859fbb5bb937692548e5860e4cb39e26b", "patch": "@@ -407,7 +407,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n \t   && DECL_EXTERNAL (target_decl) && DECL_EXTERNAL (target_bval)\n \t   && !DECL_CLASS_SCOPE_P (target_decl))\n     {\n-      duplicate_decls (decl, binding->value, /*newdecl_is_friend=*/false);\n+      duplicate_decls (decl, binding->value);\n       ok = false;\n     }\n   else if (TREE_CODE (decl) == NAMESPACE_DECL\n@@ -785,29 +785,29 @@ safe_push_template_decl (tree decl)\n }\n \n static inline tree\n-safe_pushtag (tree name, tree type, tag_scope scope)\n+safe_pushtag (tree name, tree type)\n {\n   void (*save_oracle) (enum cp_oracle_request, tree identifier);\n \n   save_oracle = cp_binding_oracle;\n   cp_binding_oracle = NULL;\n \n-  tree ret = pushtag (name, type, scope);\n+  tree ret = pushtag (name, type);\n \n   cp_binding_oracle = save_oracle;\n \n   return ret;\n }\n \n static inline tree\n-safe_pushdecl_maybe_friend (tree decl, bool is_friend)\n+safe_pushdecl (tree decl)\n {\n   void (*save_oracle) (enum cp_oracle_request, tree identifier);\n \n   save_oracle = cp_binding_oracle;\n   cp_binding_oracle = NULL;\n \n-  tree ret = pushdecl (decl, is_friend);\n+  tree ret = pushdecl (decl);\n \n   cp_binding_oracle = save_oracle;\n \n@@ -1514,7 +1514,7 @@ plugin_build_decl (cc1_plugin::connection *self,\n   if (template_decl_p)\n     {\n       if (RECORD_OR_UNION_CODE_P (code))\n-\tsafe_pushtag (identifier, TREE_TYPE (decl), ts_current);\n+\tsafe_pushtag (identifier, TREE_TYPE (decl));\n       else\n \tdecl = safe_push_template_decl (decl);\n \n@@ -1533,11 +1533,11 @@ plugin_build_decl (cc1_plugin::connection *self,\n \tfinish_member_declaration (tdecl);\n     }\n   else if (RECORD_OR_UNION_CODE_P (code))\n-    safe_pushtag (identifier, TREE_TYPE (decl), ts_current);\n+    safe_pushtag (identifier, TREE_TYPE (decl));\n   else if (class_member_p)\n     finish_member_declaration (decl);\n   else\n-    decl = safe_pushdecl_maybe_friend (decl, false);\n+    decl = safe_pushdecl (decl);\n \n   if ((ctor || dtor)\n       /* Don't crash after a duplicate declaration of a cdtor.  */\n@@ -3608,7 +3608,7 @@ plugin_build_constant (cc1_plugin::connection *self, gcc_type type_in,\n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n   cp_finish_decl (decl, cst, true, NULL, LOOKUP_ONLYCONVERTING);\n-  safe_pushdecl_maybe_friend (decl, false);\n+  safe_pushdecl (decl);\n \n   return 1;\n }"}]}