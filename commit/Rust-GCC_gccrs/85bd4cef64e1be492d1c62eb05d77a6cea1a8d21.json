{"sha": "85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViZDRjZWY2NGUxYmU0OTJkMWM2MmViMDVkNzdhNmNlYTFhOGQyMQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-09T09:32:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-09T09:32:30Z"}, "message": "Merge #288\n\n288: Fix crash with zero length array r=philberty a=YizhePKU\n\nThis PR fixes the crash that results from zero-length arrays, such as `let arr = []`(issue #260). `ArrayExpr` now uses `ArrayElemsValues` to represent an empty array like that, instead of `nullptr`.\r\n\r\nHowever, currently such code still doesn't compile. Four tests were added, two of which report an error:\r\n\r\n```Rust\r\n// compilable/array_empty_list.rs\r\nfn main() {\r\n    let arr = [];\r\n}\r\n\r\n// rust1: error: unable to determine type: please give this a type: 24\r\n```\r\n\r\n```Rust\r\n// compilable/array_zero_length_fold.rs\r\nfn main() {\r\n    let arr = [\"Hello\"; 123 - 123];\r\n}\r\n\r\n// array_zero_length_fold.rs:2:25: fatal error: failed to fold capacity constant\r\n```\r\n\r\nI think these are best treated as separate bugs. We can merge first and fix later, or we can delay this PR. Either is OK.\n\nCo-authored-by: Yizhe <yizhe@pku.edu.cn>\nCo-authored-by: YizhePKU <yizhe@pku.edu.cn>\nCo-authored-by: YizhePKU <42838469+YizhePKU@users.noreply.github.com>", "tree": {"sha": "8bb52fa13b51bfbbd960f3d5ba5836204eb8cb2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bb52fa13b51bfbbd960f3d5ba5836204eb8cb2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgcB8uCRBK7hj4Ov3rIwAAdHIIAG/Z8XUhl3oTOUUVy2zOZZ4Q\ndaXEZSKWYQHnIzYE2MxyxNuhQSJ80Dv657KxuDTyqz+/4ElQe4Wvmqy7MhGeo6fg\nSKM/PGjDHcrvCw0brW1W1Q9nx3uKxrESXjE9EqJHlQ8Qefr5ItaBkzuGb8vwLgae\nf7GJNPxAqXMKArQ1l0pVkdkBbKGIzJx6amOJ5Znru/Mdv6uCb9Ow0mSiS0TDff++\naSZSX0NyE6uoFA94iNWgIDesP9IbjUpeW+epFKoQ18/wNXrSmBGXU8041Dni6iHA\nBsQFqrYvWn864NjRCe4wbSJJlCXLS1fpnYh8WDLFy1wQO7jeJCzo0whA+RcV3KY=\n=SKjc\n-----END PGP SIGNATURE-----\n", "payload": "tree 8bb52fa13b51bfbbd960f3d5ba5836204eb8cb2f\nparent 4937562f7ca354dc80369cc2e049c391838537f1\nparent 90d5337d97e6193a8728413e2b34fc6e0e998dd8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617960750 +0000\ncommitter GitHub <noreply@github.com> 1617960750 +0000\n\nMerge #288\n\n288: Fix crash with zero length array r=philberty a=YizhePKU\n\nThis PR fixes the crash that results from zero-length arrays, such as `let arr = []`(issue #260). `ArrayExpr` now uses `ArrayElemsValues` to represent an empty array like that, instead of `nullptr`.\r\n\r\nHowever, currently such code still doesn't compile. Four tests were added, two of which report an error:\r\n\r\n```Rust\r\n// compilable/array_empty_list.rs\r\nfn main() {\r\n    let arr = [];\r\n}\r\n\r\n// rust1: error: unable to determine type: please give this a type: 24\r\n```\r\n\r\n```Rust\r\n// compilable/array_zero_length_fold.rs\r\nfn main() {\r\n    let arr = [\"Hello\"; 123 - 123];\r\n}\r\n\r\n// array_zero_length_fold.rs:2:25: fatal error: failed to fold capacity constant\r\n```\r\n\r\nI think these are best treated as separate bugs. We can merge first and fix later, or we can delay this PR. Either is OK.\n\nCo-authored-by: Yizhe <yizhe@pku.edu.cn>\nCo-authored-by: YizhePKU <yizhe@pku.edu.cn>\nCo-authored-by: YizhePKU <42838469+YizhePKU@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4937562f7ca354dc80369cc2e049c391838537f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4937562f7ca354dc80369cc2e049c391838537f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4937562f7ca354dc80369cc2e049c391838537f1"}, {"sha": "90d5337d97e6193a8728413e2b34fc6e0e998dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d5337d97e6193a8728413e2b34fc6e0e998dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d5337d97e6193a8728413e2b34fc6e0e998dd8"}], "stats": {"total": 297, "additions": 166, "deletions": 131}, "files": [{"sha": "f17d269dee703edbd55e380d9893b7415c5905c2", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -2165,10 +2165,7 @@ ArrayExpr::as_string () const\n   str += append_attributes (inner_attrs, INNER);\n \n   str += \"\\n Array elems: \";\n-  if (!has_array_elems ())\n-    str += \"none\";\n-  else\n-    str += internal_elements->as_string ();\n+  str += internal_elements->as_string ();\n \n   return str;\n }"}, {"sha": "db900966ce6974317ed9839cd8fa78cd3437f7b3", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -1099,26 +1099,25 @@ class ArrayExpr : public ExprWithoutBlock\n     outer_attrs = std::move (new_attrs);\n   }\n \n-  // Returns whether array expr has array elems or if it is just empty.\n-  bool has_array_elems () const { return internal_elements != nullptr; }\n-\n   // Constructor requires ArrayElems pointer\n   ArrayExpr (std::unique_ptr<ArrayElems> array_elems,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n     : outer_attrs (std::move (outer_attribs)),\n       inner_attrs (std::move (inner_attribs)),\n       internal_elements (std::move (array_elems)), locus (locus)\n-  {}\n+  {\n+    rust_assert (internal_elements != nullptr);\n+  }\n \n   // Copy constructor requires cloning ArrayElems for polymorphism to hold\n   ArrayExpr (ArrayExpr const &other)\n     : ExprWithoutBlock (other), outer_attrs (other.outer_attrs),\n       inner_attrs (other.inner_attrs), locus (other.locus),\n       marked_for_strip (other.marked_for_strip)\n   {\n-    if (other.has_array_elems ())\n-      internal_elements = other.internal_elements->clone_array_elems ();\n+    internal_elements = other.internal_elements->clone_array_elems ();\n+    rust_assert (internal_elements != nullptr);\n   }\n \n   // Overload assignment operator to clone internal_elements\n@@ -1130,11 +1129,9 @@ class ArrayExpr : public ExprWithoutBlock\n     marked_for_strip = other.marked_for_strip;\n     outer_attrs = other.outer_attrs;\n \n-    if (other.has_array_elems ())\n-      internal_elements = other.internal_elements->clone_array_elems ();\n-    else\n-      internal_elements = nullptr;\n+    internal_elements = other.internal_elements->clone_array_elems ();\n \n+    rust_assert (internal_elements != nullptr);\n     return *this;\n   }\n "}, {"sha": "e52cb7b1e3f06630c094fa6a2c549814ea3c2221", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -727,8 +727,7 @@ class AttrVisitor : public AST::ASTVisitor\n \n     /* assuming you can't strip away the ArrayElems type, but can strip\n      * internal expressions and whatever */\n-    if (expr.has_array_elems ())\n-      expr.get_array_elems ()->accept_vis (*this);\n+    expr.get_array_elems ()->accept_vis (*this);\n   }\n   void visit (AST::ArrayIndexExpr &expr) override\n   {\n@@ -3264,8 +3263,8 @@ MacroExpander::expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc)\n     // how would errors be signalled? null fragment? something else?\n     // what about error vs just not having stuff in rules definition yet?\n \n-    /* replace macro invocation with ast frag. actually, don't have any context here. maybe attach ast \n-     * frag to macro invocation, and then have a method above get it? Or just return the ast frag from \n+    /* replace macro invocation with ast frag. actually, don't have any context here. maybe attach ast\n+     * frag to macro invocation, and then have a method above get it? Or just return the ast frag from\n      * this method. */\n   }\n #endif"}, {"sha": "96971697896eee5aece805c8e0c08f4e0ab377c3", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 110, "deletions": 105, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -20,6 +20,9 @@ along with GCC; see the file COPYING3.  If not see\n /* DO NOT INCLUDE ANYWHERE - this is automatically included with rust-parse.h\n  * This is also the reason why there are no include guards. */\n \n+#include \"rust-diagnostics.h\"\n+#include \"util/rust-make-unique.h\"\n+\n namespace Rust {\n // Left binding powers of operations.\n enum binding_powers\n@@ -402,7 +405,7 @@ Parser<ManagedTokenSource>::parse_crate ()\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse items\n-  std::vector<std::unique_ptr<AST::Item> > items;\n+  std::vector<std::unique_ptr<AST::Item>> items;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != END_OF_FILE)\n@@ -415,7 +418,7 @@ Parser<ManagedTokenSource>::parse_crate ()\n \t  add_error (std::move (error));\n \n \t  // TODO: should all items be cleared?\n-\t  items = std::vector<std::unique_ptr<AST::Item> > ();\n+\t  items = std::vector<std::unique_ptr<AST::Item>> ();\n \t  break;\n \t}\n \n@@ -874,7 +877,7 @@ Parser<ManagedTokenSource>::parse_delim_token_tree ()\n     }\n \n   // parse actual token tree vector - 0 or more\n-  std::vector<std::unique_ptr<AST::TokenTree> > token_trees_in_tree;\n+  std::vector<std::unique_ptr<AST::TokenTree>> token_trees_in_tree;\n \n   // repeat loop until finding the matching delimiter\n   t = lexer.peek_token ();\n@@ -979,10 +982,10 @@ Parser<ManagedTokenSource>::parse_token_tree ()\n  * individually is pretty simple and allows for better error diagnostics and\n  * detection. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::Item> >\n+std::vector<std::unique_ptr<AST::Item>>\n Parser<ManagedTokenSource>::parse_items ()\n {\n-  std::vector<std::unique_ptr<AST::Item> > items;\n+  std::vector<std::unique_ptr<AST::Item>> items;\n \n   // TODO: replace with do-while loop?\n   // infinite loop to save on comparisons (may be a tight loop) - breaks when\n@@ -1544,7 +1547,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n   lexer.skip_token ();\n \n   // parse actual token trees\n-  std::vector<std::unique_ptr<AST::TokenTree> > token_trees;\n+  std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n \n   t = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -1713,7 +1716,7 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n   lexer.skip_token ();\n \n   // parse actual macro matches\n-  std::vector<std::unique_ptr<AST::MacroMatch> > matches;\n+  std::vector<std::unique_ptr<AST::MacroMatch>> matches;\n \n   t = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -1883,7 +1886,7 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n   skip_token (DOLLAR_SIGN);\n   skip_token (LEFT_PAREN);\n \n-  std::vector<std::unique_ptr<AST::MacroMatch> > matches;\n+  std::vector<std::unique_ptr<AST::MacroMatch>> matches;\n \n   // parse required first macro match\n   std::unique_ptr<AST::MacroMatch> initial_match = parse_macro_match ();\n@@ -2091,7 +2094,7 @@ Parser<ManagedTokenSource>::parse_module (\n \tstd::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n \t// parse items\n-\tstd::vector<std::unique_ptr<AST::Item> > items;\n+\tstd::vector<std::unique_ptr<AST::Item>> items;\n \tconst_TokenPtr tok = lexer.peek_token ();\n \twhile (tok->get_id () != RIGHT_CURLY)\n \t  {\n@@ -2331,7 +2334,7 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n \n-\t    std::vector<std::unique_ptr<AST::UseTree> > use_trees;\n+\t    std::vector<std::unique_ptr<AST::UseTree>> use_trees;\n \n \t    const_TokenPtr t = lexer.peek_token ();\n \t    while (t->get_id () != RIGHT_CURLY)\n@@ -2409,7 +2412,7 @@ Parser<ManagedTokenSource>::parse_use_tree ()\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n \n-\t    std::vector<std::unique_ptr<AST::UseTree> > use_trees;\n+\t    std::vector<std::unique_ptr<AST::UseTree>> use_trees;\n \n \t    // TODO: think of better control structure\n \t    const_TokenPtr t = lexer.peek_token ();\n@@ -2523,7 +2526,7 @@ Parser<ManagedTokenSource>::parse_function (\n   Identifier function_name = function_name_tok->get_str ();\n \n   // parse generic params - if exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   if (!skip_token (LEFT_PAREN))\n@@ -2626,20 +2629,20 @@ Parser<ManagedTokenSource>::parse_function_qualifiers ()\n \n // Parses generic (lifetime or type) params inside angle brackets (optional).\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::GenericParam> >\n+std::vector<std::unique_ptr<AST::GenericParam>>\n Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n {\n   if (lexer.peek_token ()->get_id () != LEFT_ANGLE)\n     {\n       // seems to be no generic params, so exit with empty vector\n-      return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n     }\n   lexer.skip_token ();\n \n   // DEBUG:\n   fprintf (stderr, \"skipped left angle in generic param\\n\");\n \n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params (is_right_angle_tok);\n \n   // DEBUG:\n@@ -2652,7 +2655,7 @@ Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n       fprintf (stderr, \"failed to skip generics right angle - returning empty \"\n \t\t       \"generic params\\n\");\n \n-      return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n     }\n \n   return generic_params;\n@@ -2661,10 +2664,10 @@ Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n /* Parse generic (lifetime or type) params NOT INSIDE ANGLE BRACKETS!!! Almost\n  * always parse_generic_params_in_angles is what is wanted. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::GenericParam> >\n+std::vector<std::unique_ptr<AST::GenericParam>>\n Parser<ManagedTokenSource>::parse_generic_params ()\n {\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n \n   // can't parse lifetime and type params separately due to lookahead issues\n   // thus, parse them all here\n@@ -2748,12 +2751,12 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t    \"failed to parse identifier in type param in generic params\");\n \t  add_error (std::move (error));\n \n-\t  return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n \t}\n       Identifier ident = ident_tok->get_str ();\n \n       // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n       if (lexer.peek_token ()->get_id () == COLON)\n \t{\n \t  lexer.skip_token ();\n@@ -2777,7 +2780,7 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t\t\"failed to parse type in type param in generic params\");\n \t      add_error (std::move (error));\n \n-\t      return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+\t      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n \t    }\n \t}\n \n@@ -2811,7 +2814,7 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t\t       \"failed to parse type param in generic params\");\n \t  add_error (std::move (error));\n \n-\t  return std::vector<std::unique_ptr<AST::GenericParam> > ();\n+\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n \t}\n \n       // DEBUG\n@@ -2858,10 +2861,10 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n  * always parse_generic_params_in_angles is what is wanted. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::GenericParam> >\n+std::vector<std::unique_ptr<AST::GenericParam>>\n Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n \n   /* can't parse lifetime and type params separately due to lookahead issues\n    * thus, parse them all here */\n@@ -2929,7 +2932,7 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n       Identifier ident = ident_tok->get_str ();\n \n       // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n       if (lexer.peek_token ()->get_id () == COLON)\n \t{\n \t  lexer.skip_token ();\n@@ -3021,10 +3024,10 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n /* Parses lifetime generic parameters (pointers). Will also consume any trailing\n  * comma. No extra checks for end token. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::LifetimeParam> >\n+std::vector<std::unique_ptr<AST::LifetimeParam>>\n Parser<ManagedTokenSource>::parse_lifetime_params ()\n {\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > lifetime_params;\n+  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params;\n \n   while (lexer.peek_token ()->get_id () != END_OF_FILE)\n     {\n@@ -3055,10 +3058,10 @@ Parser<ManagedTokenSource>::parse_lifetime_params ()\n  * comma. Has extra is_end_token predicate checking. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::LifetimeParam> >\n+std::vector<std::unique_ptr<AST::LifetimeParam>>\n Parser<ManagedTokenSource>::parse_lifetime_params (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > lifetime_params;\n+  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params;\n \n   // if end_token is not specified, it defaults to EOF, so should work fine\n   while (!is_end_token (lexer.peek_token ()->get_id ()))\n@@ -3244,10 +3247,10 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n \n // Parses type generic parameters. Will also consume any trailing comma.\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::TypeParam> >\n+std::vector<std::unique_ptr<AST::TypeParam>>\n Parser<ManagedTokenSource>::parse_type_params ()\n {\n-  std::vector<std::unique_ptr<AST::TypeParam> > type_params;\n+  std::vector<std::unique_ptr<AST::TypeParam>> type_params;\n \n   // infinite loop with break on failure as no info on ending token\n   while (true)\n@@ -3276,10 +3279,10 @@ Parser<ManagedTokenSource>::parse_type_params ()\n // Parses type generic parameters. Will also consume any trailing comma.\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::TypeParam> >\n+std::vector<std::unique_ptr<AST::TypeParam>>\n Parser<ManagedTokenSource>::parse_type_params (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::TypeParam> > type_params;\n+  std::vector<std::unique_ptr<AST::TypeParam>> type_params;\n \n   while (!is_end_token (lexer.peek_token ()->get_id ()))\n     {\n@@ -3329,7 +3332,7 @@ Parser<ManagedTokenSource>::parse_type_param ()\n   lexer.skip_token ();\n \n   // parse type param bounds (if they exist)\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n   if (lexer.peek_token ()->get_id () == COLON)\n     {\n       lexer.skip_token ();\n@@ -3492,7 +3495,7 @@ Parser<ManagedTokenSource>::parse_where_clause ()\n \n   /* parse where clause items - this is not a separate rule in the reference so\n    * won't be here */\n-  std::vector<std::unique_ptr<AST::WhereClauseItem> > where_clause_items;\n+  std::vector<std::unique_ptr<AST::WhereClauseItem>> where_clause_items;\n \n   /* HACK: where clauses end with a right curly or semicolon or equals in all\n    * uses currently */\n@@ -3589,7 +3592,7 @@ Parser<ManagedTokenSource>::parse_type_bound_where_clause_item ()\n     }\n \n   // parse type param bounds if they exist\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds\n     = parse_type_param_bounds ();\n \n   return std::unique_ptr<AST::TypeBoundWhereClauseItem> (\n@@ -3637,10 +3640,10 @@ Parser<ManagedTokenSource>::parse_for_lifetimes ()\n \n // Parses type parameter bounds in where clause or generic arguments.\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::TypeParamBound> >\n+std::vector<std::unique_ptr<AST::TypeParamBound>>\n Parser<ManagedTokenSource>::parse_type_param_bounds ()\n {\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n \n   std::unique_ptr<AST::TypeParamBound> initial_bound\n     = parse_type_param_bound ();\n@@ -3677,10 +3680,10 @@ Parser<ManagedTokenSource>::parse_type_param_bounds ()\n  * token handling. */\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::TypeParamBound> >\n+std::vector<std::unique_ptr<AST::TypeParamBound>>\n Parser<ManagedTokenSource>::parse_type_param_bounds (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n \n   std::unique_ptr<AST::TypeParamBound> initial_bound\n     = parse_type_param_bound ();\n@@ -3917,7 +3920,7 @@ Parser<ManagedTokenSource>::parse_type_alias (\n   Identifier alias_name = alias_name_tok->get_str ();\n \n   // parse generic params, which may not exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // parse where clause, which may not exist\n@@ -3977,7 +3980,7 @@ Parser<ManagedTokenSource>::parse_struct (\n   Identifier struct_name = name_tok->get_str ();\n \n   // parse generic params, which may or may not exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // branch on next token - determines whether proper struct or tuple struct\n@@ -4285,7 +4288,7 @@ Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n   Identifier enum_name = enum_name_tok->get_str ();\n \n   // parse generic params (of enum container, not enum variants) if they exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // parse where clause if it exists\n@@ -4298,7 +4301,7 @@ Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n     }\n \n   // parse actual enum variant definitions\n-  std::vector<std::unique_ptr<AST::EnumItem> > enum_items\n+  std::vector<std::unique_ptr<AST::EnumItem>> enum_items\n     = parse_enum_items ([] (TokenId id) { return id == RIGHT_CURLY; });\n \n   if (!skip_token (RIGHT_CURLY))\n@@ -4315,10 +4318,10 @@ Parser<ManagedTokenSource>::parse_enum (AST::Visibility vis,\n \n // Parses the enum variants inside an enum definiton.\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::EnumItem> >\n+std::vector<std::unique_ptr<AST::EnumItem>>\n Parser<ManagedTokenSource>::parse_enum_items ()\n {\n-  std::vector<std::unique_ptr<AST::EnumItem> > items;\n+  std::vector<std::unique_ptr<AST::EnumItem>> items;\n \n   std::unique_ptr<AST::EnumItem> initial_item = parse_enum_item ();\n \n@@ -4351,10 +4354,10 @@ Parser<ManagedTokenSource>::parse_enum_items ()\n // Parses the enum variants inside an enum definiton.\n template <typename ManagedTokenSource>\n template <typename EndTokenPred>\n-std::vector<std::unique_ptr<AST::EnumItem> >\n+std::vector<std::unique_ptr<AST::EnumItem>>\n Parser<ManagedTokenSource>::parse_enum_items (EndTokenPred is_end_tok)\n {\n-  std::vector<std::unique_ptr<AST::EnumItem> > items;\n+  std::vector<std::unique_ptr<AST::EnumItem>> items;\n \n   std::unique_ptr<AST::EnumItem> initial_item = parse_enum_item ();\n \n@@ -4491,7 +4494,7 @@ Parser<ManagedTokenSource>::parse_union (\n   Identifier union_name = union_name_tok->get_str ();\n \n   // parse optional generic parameters\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // parse optional where clause\n@@ -4656,11 +4659,11 @@ Parser<ManagedTokenSource>::parse_trait (\n   Identifier ident = ident_tok->get_str ();\n \n   // parse generic parameters (if they exist)\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // create placeholder type param bounds in case they don't exist\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n \n   // parse type param bounds (if they exist)\n   if (lexer.peek_token ()->get_id () == COLON)\n@@ -4685,7 +4688,7 @@ Parser<ManagedTokenSource>::parse_trait (\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse trait items\n-  std::vector<std::unique_ptr<AST::TraitItem> > trait_items;\n+  std::vector<std::unique_ptr<AST::TraitItem>> trait_items;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_CURLY)\n@@ -4761,7 +4764,7 @@ Parser<ManagedTokenSource>::parse_trait_item ()\n \tIdentifier ident = ident_tok->get_str ();\n \n \t// parse generic params\n-\tstd::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+\tstd::vector<std::unique_ptr<AST::GenericParam>> generic_params\n \t  = parse_generic_params_in_angles ();\n \n \tif (!skip_token (LEFT_PAREN))\n@@ -4893,7 +4896,7 @@ Parser<ManagedTokenSource>::parse_trait_type (\n   const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n   Identifier ident = ident_tok->get_str ();\n \n-  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \n   // parse optional colon\n   if (lexer.peek_token ()->get_id () == COLON)\n@@ -4986,7 +4989,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n     }\n \n   // parse generic params (shared by trait and inherent impls)\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // Again, trait impl-only feature, but optional one, so can be used for\n@@ -5039,7 +5042,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n       // parse inherent impl items\n-      std::vector<std::unique_ptr<AST::InherentImplItem> > impl_items;\n+      std::vector<std::unique_ptr<AST::InherentImplItem>> impl_items;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () != RIGHT_CURLY)\n@@ -5114,7 +5117,7 @@ Parser<ManagedTokenSource>::parse_impl (AST::Visibility vis,\n       std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n       // parse trait impl items\n-      std::vector<std::unique_ptr<AST::TraitImplItem> > impl_items;\n+      std::vector<std::unique_ptr<AST::TraitImplItem>> impl_items;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () != RIGHT_CURLY)\n@@ -5296,7 +5299,7 @@ Parser<ManagedTokenSource>::parse_inherent_impl_function_or_method (\n   Identifier ident = ident_tok->get_str ();\n \n   // parse generic params\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   if (!skip_token (LEFT_PAREN))\n@@ -5531,7 +5534,7 @@ Parser<ManagedTokenSource>::parse_trait_impl_function_or_method (\n     \"about to start parsing generic params in trait impl function or method\\n\");\n \n   // parse generic params\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   // DEBUG:\n@@ -5689,7 +5692,7 @@ Parser<ManagedTokenSource>::parse_extern_block (\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse declarations inside extern block\n-  std::vector<std::unique_ptr<AST::ExternalItem> > extern_items;\n+  std::vector<std::unique_ptr<AST::ExternalItem>> extern_items;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_CURLY)\n@@ -5806,7 +5809,7 @@ Parser<ManagedTokenSource>::parse_external_item ()\n \tIdentifier ident = ident_tok->get_str ();\n \n \t// parse (optional) generic params\n-\tstd::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+\tstd::vector<std::unique_ptr<AST::GenericParam>> generic_params\n \t  = parse_generic_params_in_angles ();\n \n \tif (!skip_token (LEFT_PAREN))\n@@ -6132,7 +6135,7 @@ Parser<ManagedTokenSource>::parse_type_path ()\n     }\n \n   // create segment vector\n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n \n   // parse required initial segment\n   std::unique_ptr<AST::TypePathSegment> initial_segment\n@@ -6217,7 +6220,7 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n     }\n \n   // try to parse types second\n-  std::vector<std::unique_ptr<AST::Type> > type_args;\n+  std::vector<std::unique_ptr<AST::Type>> type_args;\n \n   // TODO: think of better control structure\n   t = lexer.peek_token ();\n@@ -6402,7 +6405,7 @@ Parser<ManagedTokenSource>::parse_type_path_function ()\n     }\n \n   // parse function inputs\n-  std::vector<std::unique_ptr<AST::Type> > inputs;\n+  std::vector<std::unique_ptr<AST::Type>> inputs;\n \n   while (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n     {\n@@ -6705,7 +6708,7 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_type ()\n     }\n \n   // parse path segments\n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n   segments.reserve (1);\n \n   // parse initial required segment\n@@ -6879,7 +6882,7 @@ Parser<ManagedTokenSource>::parse_method ()\n   Identifier method_name = ident_tok->get_str ();\n \n   // parse generic params - if exist\n-  std::vector<std::unique_ptr<AST::GenericParam> > generic_params\n+  std::vector<std::unique_ptr<AST::GenericParam>> generic_params\n     = parse_generic_params_in_angles ();\n \n   if (!skip_token (LEFT_PAREN))\n@@ -7282,7 +7285,7 @@ Parser<ManagedTokenSource>::parse_block_expr (\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse statements and expression\n-  std::vector<std::unique_ptr<AST::Stmt> > stmts;\n+  std::vector<std::unique_ptr<AST::Stmt>> stmts;\n   std::unique_ptr<AST::ExprWithoutBlock> expr = nullptr;\n \n   const_TokenPtr t = lexer.peek_token ();\n@@ -7894,7 +7897,7 @@ Parser<ManagedTokenSource>::parse_if_let_expr (\n   lexer.skip_token ();\n \n   // parse match arm patterns (which are required)\n-  std::vector<std::unique_ptr<AST::Pattern> > match_arm_patterns\n+  std::vector<std::unique_ptr<AST::Pattern>> match_arm_patterns\n     = parse_match_arm_patterns (EQUAL);\n   if (match_arm_patterns.empty ())\n     {\n@@ -8199,7 +8202,7 @@ Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n   lexer.skip_token ();\n \n   // parse predicate patterns\n-  std::vector<std::unique_ptr<AST::Pattern> > predicate_patterns\n+  std::vector<std::unique_ptr<AST::Pattern>> predicate_patterns\n     = parse_match_arm_patterns (EQUAL);\n   // TODO: have to ensure that there is at least 1 pattern?\n \n@@ -8522,7 +8525,7 @@ Parser<ManagedTokenSource>::parse_match_arm ()\n     }\n \n   // parse match arm patterns - at least 1 is required\n-  std::vector<std::unique_ptr<AST::Pattern> > match_arm_patterns\n+  std::vector<std::unique_ptr<AST::Pattern>> match_arm_patterns\n     = parse_match_arm_patterns (RIGHT_CURLY);\n   if (match_arm_patterns.empty ())\n     {\n@@ -8566,7 +8569,7 @@ Parser<ManagedTokenSource>::parse_match_arm ()\n  * that would exist after the patterns are done (e.g. '}' for match expr, '='\n  * for if let and while let). */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::Pattern> >\n+std::vector<std::unique_ptr<AST::Pattern>>\n Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n {\n   // skip optional leading '|'\n@@ -8576,7 +8579,7 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n    * If semantically different, I need a wrapped \"match arm patterns\" object for\n    * this. */\n \n-  std::vector<std::unique_ptr<AST::Pattern> > patterns;\n+  std::vector<std::unique_ptr<AST::Pattern>> patterns;\n \n   // quick break out if end_token_id\n   if (lexer.peek_token ()->get_id () == end_token_id)\n@@ -8717,9 +8720,12 @@ Parser<ManagedTokenSource>::parse_array_expr (\n       // no array elements\n       lexer.skip_token ();\n \n-      return std::unique_ptr<AST::ArrayExpr> (\n-\tnew AST::ArrayExpr (nullptr, std::move (inner_attrs),\n-\t\t\t    std::move (outer_attrs), locus));\n+      std::vector<std::unique_ptr<AST::Expr>> exprs;\n+      auto array_elems\n+\t= Rust::make_unique<AST::ArrayElemsValues> (std::move (exprs));\n+      return Rust::make_unique<AST::ArrayExpr> (std::move (array_elems),\n+\t\t\t\t\t\tstd::move (inner_attrs),\n+\t\t\t\t\t\tstd::move (outer_attrs), locus);\n     }\n   else\n     {\n@@ -8768,7 +8774,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n       else if (lexer.peek_token ()->get_id () == RIGHT_SQUARE)\n \t{\n \t  // single-element array expression\n-\t  std::vector<std::unique_ptr<AST::Expr> > exprs;\n+\t  std::vector<std::unique_ptr<AST::Expr>> exprs;\n \t  exprs.reserve (1);\n \t  exprs.push_back (std::move (initial_expr));\n \t  exprs.shrink_to_fit ();\n@@ -8785,7 +8791,7 @@ Parser<ManagedTokenSource>::parse_array_expr (\n       else if (lexer.peek_token ()->get_id () == COMMA)\n \t{\n \t  // multi-element array expression (or trailing comma)\n-\t  std::vector<std::unique_ptr<AST::Expr> > exprs;\n+\t  std::vector<std::unique_ptr<AST::Expr>> exprs;\n \t  exprs.push_back (std::move (initial_expr));\n \n \t  const_TokenPtr t = lexer.peek_token ();\n@@ -8905,7 +8911,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n \n       // create tuple with empty tuple elems\n       return std::unique_ptr<AST::TupleExpr> (\n-\tnew AST::TupleExpr (std::vector<std::unique_ptr<AST::Expr> > (),\n+\tnew AST::TupleExpr (std::vector<std::unique_ptr<AST::Expr>> (),\n \t\t\t    std::move (inner_attrs), std::move (outer_attrs),\n \t\t\t    locus));\n     }\n@@ -8936,7 +8942,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_expr (\n   else if (lexer.peek_token ()->get_id () == COMMA)\n     {\n       // tuple expr\n-      std::vector<std::unique_ptr<AST::Expr> > exprs;\n+      std::vector<std::unique_ptr<AST::Expr>> exprs;\n       exprs.push_back (std::move (first_expr));\n \n       // parse potential other tuple exprs\n@@ -9064,7 +9070,7 @@ Parser<ManagedTokenSource>::parse_type ()\n       case LIFETIME: {\n \t/* probably a lifetime bound, so probably type param bounds in\n \t * TraitObjectType */\n-\tstd::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n+\tstd::vector<std::unique_ptr<AST::TypeParamBound>> bounds\n \t  = parse_type_param_bounds ();\n \n \treturn std::unique_ptr<AST::TraitObjectType> (\n@@ -9129,7 +9135,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t    }\n \t    case PLUS: {\n \t      // type param bounds\n-\t      std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t      std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \n \t      // convert type path to trait bound\n \t      std::unique_ptr<AST::TraitBound> path_bound (\n@@ -9184,7 +9190,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t{\n \t  /* cannot be one bound because lifetime prevents it from being\n \t   * traitbound */\n-\t  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n+\t  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds\n \t    = parse_type_param_bounds ();\n \n \t  return std::unique_ptr<AST::ImplTraitType> (\n@@ -9221,7 +9227,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t    }\n \n \t  // parse additional type param bounds\n-\t  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \t  bounds.push_back (std::move (initial_bound));\n \t  while (t->get_id () == PLUS)\n \t    {\n@@ -9257,7 +9263,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  {\n \t    /* cannot be one bound because lifetime prevents it from being\n \t     * traitbound */\n-\t    std::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n+\t    std::vector<std::unique_ptr<AST::TypeParamBound>> bounds\n \t      = parse_type_param_bounds ();\n \n \t    return std::unique_ptr<AST::TraitObjectType> (\n@@ -9294,7 +9300,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t      }\n \n \t    // parse additional type param bounds\n-\t    std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t    std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \t    bounds.push_back (std::move (initial_bound));\n \t    while (t->get_id () == PLUS)\n \t      {\n@@ -9350,7 +9356,7 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n    * whether trailing comma happens */\n   const_TokenPtr t = lexer.peek_token ();\n   bool trailing_comma = true;\n-  std::vector<std::unique_ptr<AST::Type> > types;\n+  std::vector<std::unique_ptr<AST::Type>> types;\n \n   while (t->get_id () != RIGHT_PAREN)\n     {\n@@ -9389,7 +9395,7 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n       if (lexer.peek_token ()->get_id () == PLUS)\n \t{\n \t  // create type param bounds vector\n-\t  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\t  std::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \n \t  // HACK: convert type to traitbound and add to bounds\n \t  std::unique_ptr<AST::Type> released_ptr = std::move (types[0]);\n@@ -9514,7 +9520,7 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n \tstd::unique_ptr<AST::TraitBound> initial_bound (\n \t  new AST::TraitBound (std::move (path), for_locus, false, false,\n \t\t\t       std::move (for_lifetimes)));\n-\tstd::vector<std::unique_ptr<AST::TypeParamBound> > bounds;\n+\tstd::vector<std::unique_ptr<AST::TypeParamBound>> bounds;\n \tbounds.push_back (std::move (initial_bound));\n \n \twhile (t->get_id () == PLUS)\n@@ -10115,7 +10121,7 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type_no_bounds ()\n    * whether trailing comma happens */\n   const_TokenPtr t = lexer.peek_token ();\n   bool trailing_comma = true;\n-  std::vector<std::unique_ptr<AST::Type> > types;\n+  std::vector<std::unique_ptr<AST::Type>> types;\n \n   while (t->get_id () != RIGHT_PAREN)\n     {\n@@ -10672,7 +10678,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n       lexer.skip_token ();\n \n       // parse new patterns while next token is a comma\n-      std::vector<std::unique_ptr<AST::Pattern> > patterns;\n+      std::vector<std::unique_ptr<AST::Pattern>> patterns;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () == COMMA)\n@@ -10711,8 +10717,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n       // create ranged tuple pattern items with only upper items\n       std::unique_ptr<AST::TuplePatternItemsRanged> items (\n \tnew AST::TuplePatternItemsRanged (\n-\t  std::vector<std::unique_ptr<AST::Pattern> > (),\n-\t  std::move (patterns)));\n+\t  std::vector<std::unique_ptr<AST::Pattern>> (), std::move (patterns)));\n       return std::unique_ptr<AST::TuplePattern> (\n \tnew AST::TuplePattern (std::move (items), paren_locus));\n     }\n@@ -10743,7 +10748,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n \tlexer.skip_token ();\n \n \t// create vector of patterns\n-\tstd::vector<std::unique_ptr<AST::Pattern> > patterns;\n+\tstd::vector<std::unique_ptr<AST::Pattern>> patterns;\n \tpatterns.push_back (std::move (initial_pattern));\n \n \tt = lexer.peek_token ();\n@@ -10785,7 +10790,7 @@ Parser<ManagedTokenSource>::parse_grouped_or_tuple_pattern ()\n \t    lexer.skip_token ();\n \n \t    // parse upper patterns\n-\t    std::vector<std::unique_ptr<AST::Pattern> > upper_patterns;\n+\t    std::vector<std::unique_ptr<AST::Pattern>> upper_patterns;\n \t    t = lexer.peek_token ();\n \t    while (t->get_id () == COMMA)\n \t      {\n@@ -10863,7 +10868,7 @@ Parser<ManagedTokenSource>::parse_slice_pattern ()\n       return nullptr;\n     }\n \n-  std::vector<std::unique_ptr<AST::Pattern> > patterns;\n+  std::vector<std::unique_ptr<AST::Pattern>> patterns;\n   patterns.push_back (std::move (initial_pattern));\n \n   const_TokenPtr t = lexer.peek_token ();\n@@ -11112,7 +11117,7 @@ template <typename ManagedTokenSource>\n std::unique_ptr<AST::TupleStructItems>\n Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n {\n-  std::vector<std::unique_ptr<AST::Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<AST::Pattern>> lower_patterns;\n \n   // DEBUG\n   fprintf (stderr, \"started parsing tuple struct items\\n\");\n@@ -11126,7 +11131,7 @@ Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n       // DEBUG\n       fprintf (stderr, \"'..' at front in tuple struct items detected\\n\");\n \n-      std::vector<std::unique_ptr<AST::Pattern> > upper_patterns;\n+      std::vector<std::unique_ptr<AST::Pattern>> upper_patterns;\n \n       const_TokenPtr t = lexer.peek_token ();\n       while (t->get_id () == COMMA)\n@@ -11207,7 +11212,7 @@ Parser<ManagedTokenSource>::parse_tuple_struct_items ()\n \t// has an upper range that must be parsed separately\n \tlexer.skip_token ();\n \n-\tstd::vector<std::unique_ptr<AST::Pattern> > upper_patterns;\n+\tstd::vector<std::unique_ptr<AST::Pattern>> upper_patterns;\n \n \tt = lexer.peek_token ();\n \twhile (t->get_id () == COMMA)\n@@ -11252,7 +11257,7 @@ template <typename ManagedTokenSource>\n AST::StructPatternElements\n Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n {\n-  std::vector<std::unique_ptr<AST::StructPatternField> > fields;\n+  std::vector<std::unique_ptr<AST::StructPatternField>> fields;\n \n   std::vector<AST::Attribute> etc_attrs;\n   bool has_etc = false;\n@@ -11742,7 +11747,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \tlexer.skip_token ();\n \n \t// parse actual token trees\n-\tstd::vector<std::unique_ptr<AST::TokenTree> > token_trees;\n+\tstd::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n \n \tt3 = lexer.peek_token ();\n \t// parse token trees until the initial delimiter token is found again\n@@ -12057,7 +12062,7 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n   lexer.skip_token ();\n \n   // parse actual token trees\n-  std::vector<std::unique_ptr<AST::TokenTree> > token_trees;\n+  std::vector<std::unique_ptr<AST::TokenTree>> token_trees;\n \n   t3 = lexer.peek_token ();\n   // parse token trees until the initial delimiter token is found again\n@@ -14209,7 +14214,7 @@ Parser<ManagedTokenSource>::parse_method_call_expr (\n     }\n \n   // parse method params (if they exist)\n-  std::vector<std::unique_ptr<AST::Expr> > params;\n+  std::vector<std::unique_ptr<AST::Expr>> params;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)\n@@ -14255,7 +14260,7 @@ Parser<ManagedTokenSource>::parse_function_call_expr (\n   std::vector<AST::Attribute> outer_attrs, ParseRestrictions)\n {\n   // parse function params (if they exist)\n-  std::vector<std::unique_ptr<AST::Expr> > params;\n+  std::vector<std::unique_ptr<AST::Expr>> params;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)\n@@ -14366,7 +14371,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_struct_partial (\n \t// struct with struct expr fields\n \n \t// parse struct expr fields\n-\tstd::vector<std::unique_ptr<AST::StructExprField> > fields;\n+\tstd::vector<std::unique_ptr<AST::StructExprField>> fields;\n \n \twhile (t->get_id () != RIGHT_CURLY && t->get_id () != DOT_DOT)\n \t  {\n@@ -14480,7 +14485,7 @@ Parser<ManagedTokenSource>::parse_struct_expr_tuple_partial (\n \n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n-  std::vector<std::unique_ptr<AST::Expr> > exprs;\n+  std::vector<std::unique_ptr<AST::Expr>> exprs;\n \n   const_TokenPtr t = lexer.peek_token ();\n   while (t->get_id () != RIGHT_PAREN)"}, {"sha": "6e7dff87b36db650506ee14bcbba3318ae615e49", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -35,6 +35,9 @@ class TypeCheckExpr : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n+  /* Perform type checking on expr. Also runs type unification algorithm.\n+     Returns the unified type of expr.\n+     `inside_loop` acts as a context for BreakExpr, etc. May change later. */\n   static TyTy::BaseType *Resolve (HIR::Expr *expr, bool inside_loop)\n   {\n     TypeCheckExpr resolver (inside_loop);\n@@ -682,6 +685,7 @@ class TypeCheckExpr : public TypeCheckBase\n     HIR::ArrayElems *elements = expr.get_internal_elements ();\n     size_t num_elems = elements->get_num_elements ();\n \n+    // Check the type of array elements\n     elements->accept_vis (*this);\n     rust_assert (infered_array_elems != nullptr);\n \n@@ -698,14 +702,16 @@ class TypeCheckExpr : public TypeCheckBase\n       return true;\n     });\n \n-    infered_array_elems = types[0];\n-    for (size_t i = 1; i < types.size (); i++)\n+    infered_array_elems = TyTy::TyVar::get_implicit_infer_var ().get_tyty ();\n+\n+    for (auto &type : types)\n       {\n-\tinfered_array_elems = infered_array_elems->unify (types.at (i));\n+\tinfered_array_elems = infered_array_elems->unify (type);\n       }\n-\n     for (auto &elem : types)\n-      infered_array_elems->append_reference (elem->get_ref ());\n+      {\n+\tinfered_array_elems->append_reference (elem->get_ref ());\n+      }\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems) override\n@@ -991,7 +997,11 @@ class TypeCheckExpr : public TypeCheckBase\n     gcc_unreachable ();\n   }\n \n+  /* The return value of TypeCheckExpr::Resolve */\n   TyTy::BaseType *infered;\n+\n+  /* The return value of visit(ArrayElemsValues&) and visit(ArrayElemsCopied&)\n+     Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n \n   bool inside_loop;"}, {"sha": "cb0543c5b043919a104be236f7cda51f51496042", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -48,7 +48,7 @@ TyVar::get_tyty () const\n }\n \n TyVar\n-TyVar::get_implict_infer_var ()\n+TyVar::get_implicit_infer_var ()\n {\n   auto mappings = Analysis::Mappings::get ();\n   auto context = Resolver::TypeCheckContext::get ();"}, {"sha": "7b4197f16467ddf454e2d09d8ded63df1204b9f7", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -154,7 +154,7 @@ class TyVar\n \n   BaseType *get_tyty () const;\n \n-  static TyVar get_implict_infer_var ();\n+  static TyVar get_implicit_infer_var ();\n \n private:\n   HirId ref;\n@@ -560,7 +560,7 @@ class SubstitutionRef\n     std::vector<SubstitutionArg> args;\n     for (auto &sub : get_substs ())\n       {\n-\tTyVar infer_var = TyVar::get_implict_infer_var ();\n+\tTyVar infer_var = TyVar::get_implicit_infer_var ();\n \targs.push_back (SubstitutionArg (&sub, infer_var.get_tyty ()));\n       }\n "}, {"sha": "4698b7d966faa684f693664c8524418fd793e9ba", "filename": "gcc/rust/util/rust-make-unique.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Futil%2Frust-make-unique.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Frust%2Futil%2Frust-make-unique.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-make-unique.h?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -0,0 +1,17 @@\n+#ifndef RUST_MAKE_UNIQUE_H\n+#define RUST_MAKE_UNIQUE_H\n+\n+#include <memory>\n+\n+namespace Rust {\n+\n+template <typename T, typename... Ts>\n+std::unique_ptr<T>\n+make_unique (Ts &&... params)\n+{\n+  return std::unique_ptr<T> (new T (std::forward<Ts> (params)...));\n+}\n+\n+} // namespace Rust\n+\n+#endif // RUST_MAKE_UNIQUE_H"}, {"sha": "f6a6182521f12efa191e7a597a78e5e5be4bbf3a", "filename": "gcc/testsuite/rust.test/compile/array_type_infer.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farray_type_infer.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farray_type_infer.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farray_type_infer.rs?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let arr: [_; 5] = [1, 2, 3, 4, 5];\n+}"}, {"sha": "a3acc157046624d3dcfd14f907050a5cf21015e8", "filename": "gcc/testsuite/rust.test/compile/array_zero_length.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farray_zero_length.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farray_zero_length.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Farray_zero_length.rs?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let arr = [\"Hello\"; 0];\n+}"}, {"sha": "b647cea695a064353fa889fbf75be8c8673f4889", "filename": "gcc/testsuite/rust.test/xfail_compile/array_empty_list.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85bd4cef64e1be492d1c62eb05d77a6cea1a8d21/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs?ref=85bd4cef64e1be492d1c62eb05d77a6cea1a8d21", "patch": "@@ -0,0 +1,4 @@\n+// { dg-error \"unable to determine type\" \"\" { target { *-*-* } } 0 }\n+fn main() {\n+    let arr = [];\n+}"}]}