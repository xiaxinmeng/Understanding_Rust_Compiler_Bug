{"sha": "47ac041c930f67cad6259c88b14907f376c748ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhYzA0MWM5MzBmNjdjYWQ2MjU5Yzg4YjE0OTA3ZjM3NmM3NDhiYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "1999-12-08T08:00:51Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-08T08:00:51Z"}, "message": "sparc.c (sparc_emit_float_lib_cmp): New function.\n\n\t* config/sparc/sparc.c (sparc_emit_float_lib_cmp): New function.\n\t* config/sparc/sparc-protos.h (sparc_emit_float_lib_cmp): Prototype.\n\t* config/sparc/sparc.h (*_LIBCALL): Only use for _Q_*\n\troutines, _Qp_* cannot be handled like that now.\n\t(INIT_TARGET_OPTABS): Likewise.\n\t* config/sparc/sparc.md (cmptf): Accept soft float ARCH64.\n\t(seq, sne, sgt, sge, slt, sle, beq, bne, bgt, bge, blt, ble): Call\n\tsparc_emit_float_lib_cmp if ARCH64 and soft float.\n\t(extendsftf2, extenddftf2, trunctfsf2, trunctfdf2, floatsitf2,\n\tfloatditf2, fix_trunctfsi2, fix_trunctfdi2, addtf3, subtf3, multf3,\n\tdivtf3, sqrttf3): New expanders.\n\t(extendsftf2_hq, extenddftf2_hq, trunctfsf2_hq, trunctfdf2_hq,\n\tfloatsitf2_hq, floatditf2_hq, fix_trunctfsi2_hq, fix_trunctfdi2_hq,\n\taddtf3_hq, subtf3_hq, multf3_hq, divtf3_hq, sqrttf3_hq): Rename from\n\tnon-_hq patterns.\n\nFrom-SVN: r30824", "tree": {"sha": "03bb17e771e02fe076760cd6d33a5ffb5a9e49e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03bb17e771e02fe076760cd6d33a5ffb5a9e49e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47ac041c930f67cad6259c88b14907f376c748ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ac041c930f67cad6259c88b14907f376c748ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ac041c930f67cad6259c88b14907f376c748ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ac041c930f67cad6259c88b14907f376c748ba/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f63333cc92a1cf2c61f551e4bf987c0eeb1f3c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f63333cc92a1cf2c61f551e4bf987c0eeb1f3c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f63333cc92a1cf2c61f551e4bf987c0eeb1f3c3"}], "stats": {"total": 792, "additions": 727, "deletions": 65}, "files": [{"sha": "da3a78be4d63220f4859841aa8628618cf7508a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47ac041c930f67cad6259c88b14907f376c748ba", "patch": "@@ -15,6 +15,22 @@\n \t(clear_sf): Use const_double_operand.\n \t(clear_sfp, clear_dfp, clear_tf, clear_tfp): New patterns.\n \n+\t* config/sparc/sparc.c (sparc_emit_float_lib_cmp): New function.\n+\t* config/sparc/sparc-protos.h (sparc_emit_float_lib_cmp): Prototype.\n+\t* config/sparc/sparc.h (*_LIBCALL): Only use for _Q_*\n+\troutines, _Qp_* cannot be handled like that now.\n+\t(INIT_TARGET_OPTABS): Likewise.\n+\t* config/sparc/sparc.md (cmptf): Accept soft float ARCH64.\n+\t(seq, sne, sgt, sge, slt, sle, beq, bne, bgt, bge, blt, ble): Call\n+\tsparc_emit_float_lib_cmp if ARCH64 and soft float.\n+\t(extendsftf2, extenddftf2, trunctfsf2, trunctfdf2, floatsitf2,\n+\tfloatditf2, fix_trunctfsi2, fix_trunctfdi2, addtf3, subtf3, multf3,\n+\tdivtf3, sqrttf3): New expanders.\n+\t(extendsftf2_hq, extenddftf2_hq, trunctfsf2_hq, trunctfdf2_hq,\n+\tfloatsitf2_hq, floatditf2_hq, fix_trunctfsi2_hq, fix_trunctfdi2_hq,\n+\taddtf3_hq, subtf3_hq, multf3_hq, divtf3_hq, sqrttf3_hq): Rename from\n+\tnon-_hq patterns.\n+\n Tue Dec  7 19:22:06 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* loop.h (struct induction): Add multi_insn_incr."}, {"sha": "c7616696fb561ac9785d8af6ef27782fb595f3ac", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=47ac041c930f67cad6259c88b14907f376c748ba", "patch": "@@ -79,6 +79,7 @@ extern void sparc_flat_save_restore PARAMS ((FILE *, const char *,\n #ifdef RTX_CODE\n /* Define the function that build the compare insn for scc and bcc.  */\n extern rtx gen_compare_reg PARAMS ((enum rtx_code code, rtx, rtx));\n+extern void sparc_emit_float_lib_cmp PARAMS ((rtx, rtx, enum rtx_code));\n /* This function handles all v9 scc insns */\n extern int gen_v9_scc PARAMS ((enum rtx_code, rtx *));\n extern void sparc_initialize_trampoline PARAMS ((rtx, rtx, rtx));"}, {"sha": "b2219cc5a1c89938b32cc96217e881afe2920e8d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=47ac041c930f67cad6259c88b14907f376c748ba", "patch": "@@ -4689,6 +4689,77 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n   return string;\n }\n \n+/* Emit a library call comparison between floating point X and Y.\n+   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n+   TARGET_ARCH64 uses _Qp_* functions, which use pointers to TFmode\n+   values as arguments instead of the TFmode registers themselves,\n+   that's why we cannot call emit_float_lib_cmp.  */\n+void\n+sparc_emit_float_lib_cmp (x, y, comparison)\n+     rtx x, y;\n+     enum rtx_code comparison;\n+{\n+  const char *qpfunc;\n+  rtx slot0, slot1, result;\n+\n+  switch (comparison)\n+    {\n+    case EQ:\n+      qpfunc = \"_Qp_feq\";\n+      break;\n+\n+    case NE:\n+      qpfunc = \"_Qp_fne\";\n+      break;\n+\n+    case GT:\n+      qpfunc = \"_Qp_fgt\";\n+      break;\n+\n+    case GE:\n+      qpfunc = \"_Qp_fge\";\n+      break;\n+\n+    case LT:\n+      qpfunc = \"_Qp_flt\";\n+      break;\n+\n+    case LE:\n+      qpfunc = \"_Qp_fle\";\n+      break;\n+\n+    default:\n+      abort();\n+      break;\n+    }\n+\n+  if (GET_CODE (x) != MEM)\n+    {\n+      slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      emit_insn (gen_rtx_SET (VOIDmode, slot0, x));\n+    }\n+\n+  if (GET_CODE (y) != MEM)\n+    {\n+      slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      emit_insn (gen_rtx_SET (VOIDmode, slot1, y));\n+    }\n+\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, qpfunc), 1,\n+                     DImode, 2,\n+                     XEXP (slot0, 0), Pmode,\n+                     XEXP (slot1, 0), Pmode);\n+\n+  /* Immediately move the result of the libcall into a pseudo\n+     register so reload doesn't clobber the value if it needs\n+     the return register for a spill reg.  */\n+  result = gen_reg_rtx (DImode);\n+  emit_move_insn (result, hard_libcall_value (DImode));\n+\n+  emit_cmp_insn (result, const0_rtx, comparison,\n+                 NULL_RTX, DImode, 0, 0);\n+}\n+          \n /* Return the string to output a conditional branch to LABEL, testing\n    register REG.  LABEL is the operand number of the label; REG is the\n    operand number of the reg.  OP is the conditional expression.  The mode"}, {"sha": "c051c7848e2524f22c173d9358c2f9fc72448ada", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=47ac041c930f67cad6259c88b14907f376c748ba", "patch": "@@ -2680,60 +2680,62 @@ do {                                                                    \\\n #define MULSI3_LIBCALL \"*.umul\"\n \n /* Define library calls for quad FP operations.  These are all part of the\n-   SPARC ABI.\n-   ??? ARCH64 still does not work as the _Qp_* routines take pointers.  */\n-#define ADDTF3_LIBCALL (TARGET_ARCH64 ? \"_Qp_add\" : \"_Q_add\")\n-#define SUBTF3_LIBCALL (TARGET_ARCH64 ? \"_Qp_sub\" : \"_Q_sub\")\n-#define NEGTF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_neg\" : \"_Q_neg\")\n-#define MULTF3_LIBCALL (TARGET_ARCH64 ? \"_Qp_mul\" : \"_Q_mul\")\n-#define DIVTF3_LIBCALL (TARGET_ARCH64 ? \"_Qp_div\" : \"_Q_div\")\n-#define FLOATSITF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_itoq\" : \"_Q_itoq\")\n-#define FIX_TRUNCTFSI2_LIBCALL (TARGET_ARCH64 ? \"_Qp_qtoi\" : \"_Q_qtoi\")\n-#define FIXUNS_TRUNCTFSI2_LIBCALL (TARGET_ARCH64 ? \"_Qp_qtoui\" : \"_Q_qtou\")\n-#define EXTENDSFTF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_stoq\" : \"_Q_stoq\")\n-#define TRUNCTFSF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_qtos\" :  \"_Q_qtos\")\n-#define EXTENDDFTF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_dtoq\" : \"_Q_dtoq\")\n-#define TRUNCTFDF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_qtod\" : \"_Q_qtod\")\n-#define EQTF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_feq\" : \"_Q_feq\")\n-#define NETF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_fne\" : \"_Q_fne\")\n-#define GTTF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_fgt\" : \"_Q_fgt\")\n-#define GETF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_fge\" : \"_Q_fge\")\n-#define LTTF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_flt\" : \"_Q_flt\")\n-#define LETF2_LIBCALL (TARGET_ARCH64 ? \"_Qp_fle\" : \"_Q_fle\")\n+   SPARC 32bit ABI.  */\n+#define ADDTF3_LIBCALL \"_Q_add\"\n+#define SUBTF3_LIBCALL \"_Q_sub\"\n+#define NEGTF2_LIBCALL \"_Q_neg\"\n+#define MULTF3_LIBCALL \"_Q_mul\"\n+#define DIVTF3_LIBCALL \"_Q_div\"\n+#define FLOATSITF2_LIBCALL \"_Q_itoq\"\n+#define FIX_TRUNCTFSI2_LIBCALL \"_Q_qtoi\"\n+#define FIXUNS_TRUNCTFSI2_LIBCALL \"_Q_qtou\"\n+#define EXTENDSFTF2_LIBCALL \"_Q_stoq\"\n+#define TRUNCTFSF2_LIBCALL \"_Q_qtos\"\n+#define EXTENDDFTF2_LIBCALL \"_Q_dtoq\"\n+#define TRUNCTFDF2_LIBCALL \"_Q_qtod\"\n+#define EQTF2_LIBCALL \"_Q_feq\"\n+#define NETF2_LIBCALL \"_Q_fne\"\n+#define GTTF2_LIBCALL \"_Q_fgt\"\n+#define GETF2_LIBCALL \"_Q_fge\"\n+#define LTTF2_LIBCALL \"_Q_flt\"\n+#define LETF2_LIBCALL \"_Q_fle\"\n \n /* We can define the TFmode sqrt optab only if TARGET_FPU.  This is because\n    with soft-float, the SFmode and DFmode sqrt instructions will be absent,\n    and the compiler will notice and try to use the TFmode sqrt instruction\n    for calls to the builtin function sqrt, but this fails.  */\n #define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    add_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = init_one_libfunc (ADDTF3_LIBCALL);\t\t\t\t\\\n-    sub_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = init_one_libfunc (SUBTF3_LIBCALL);\t\t\t\t\\\n-    neg_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = init_one_libfunc (NEGTF2_LIBCALL);\t\t\t\t\\\n-    smul_optab->handlers[(int) TFmode].libfunc\t\t\t\t\\\n-      = init_one_libfunc (MULTF3_LIBCALL);\t\t\t\t\\\n-    flodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n-      = init_one_libfunc (DIVTF3_LIBCALL);\t\t\t\t\\\n-    eqtf2_libfunc = init_one_libfunc (EQTF2_LIBCALL);\t\t\t\\\n-    netf2_libfunc = init_one_libfunc (NETF2_LIBCALL);\t\t\t\\\n-    gttf2_libfunc = init_one_libfunc (GTTF2_LIBCALL);\t\t\t\\\n-    getf2_libfunc = init_one_libfunc (GETF2_LIBCALL);\t\t\t\\\n-    lttf2_libfunc = init_one_libfunc (LTTF2_LIBCALL);\t\t\t\\\n-    letf2_libfunc = init_one_libfunc (LETF2_LIBCALL);\t\t\t\\\n-    trunctfsf2_libfunc = init_one_libfunc (TRUNCTFSF2_LIBCALL);\t\t\\\n-    trunctfdf2_libfunc = init_one_libfunc (TRUNCTFDF2_LIBCALL);\t\t\\\n-    extendsftf2_libfunc = init_one_libfunc (EXTENDSFTF2_LIBCALL);\t\\\n-    extenddftf2_libfunc = init_one_libfunc (EXTENDDFTF2_LIBCALL);\t\\\n-    floatsitf_libfunc = init_one_libfunc (FLOATSITF2_LIBCALL);\t\t\\\n-    fixtfsi_libfunc = init_one_libfunc (FIX_TRUNCTFSI2_LIBCALL);\t\\\n-    fixunstfsi_libfunc\t\t\t\t\t\t\t\\\n-      = init_one_libfunc (FIXUNS_TRUNCTFSI2_LIBCALL);\t\t\t\\\n-    if (TARGET_FPU)\t\t\t\t\t\t\t\\\n-      sqrt_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n-\t= init_one_libfunc (\"_Q_sqrt\");\t\t\t\t\t\\\n+    if (TARGET_ARCH32)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tadd_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\t  = init_one_libfunc (ADDTF3_LIBCALL);\t\t\t\t\\\n+\tsub_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\t  = init_one_libfunc (SUBTF3_LIBCALL);\t\t\t\t\\\n+\tneg_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\t  = init_one_libfunc (NEGTF2_LIBCALL);\t\t\t\t\\\n+\tsmul_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\t  = init_one_libfunc (MULTF3_LIBCALL);\t\t\t\t\\\n+\tflodiv_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\t  = init_one_libfunc (DIVTF3_LIBCALL);\t\t\t\t\\\n+\teqtf2_libfunc = init_one_libfunc (EQTF2_LIBCALL);\t\t\\\n+\tnetf2_libfunc = init_one_libfunc (NETF2_LIBCALL);\t\t\\\n+\tgttf2_libfunc = init_one_libfunc (GTTF2_LIBCALL);\t\t\\\n+\tgetf2_libfunc = init_one_libfunc (GETF2_LIBCALL);\t\t\\\n+\tlttf2_libfunc = init_one_libfunc (LTTF2_LIBCALL);\t\t\\\n+\tletf2_libfunc = init_one_libfunc (LETF2_LIBCALL);\t\t\\\n+\ttrunctfsf2_libfunc = init_one_libfunc (TRUNCTFSF2_LIBCALL);\t\\\n+\ttrunctfdf2_libfunc = init_one_libfunc (TRUNCTFDF2_LIBCALL);\t\\\n+\textendsftf2_libfunc = init_one_libfunc (EXTENDSFTF2_LIBCALL);\t\\\n+\textenddftf2_libfunc = init_one_libfunc (EXTENDDFTF2_LIBCALL);\t\\\n+\tfloatsitf_libfunc = init_one_libfunc (FLOATSITF2_LIBCALL);\t\\\n+\tfixtfsi_libfunc = init_one_libfunc (FIX_TRUNCTFSI2_LIBCALL);\t\\\n+\tfixunstfsi_libfunc\t\t\t\t\t\t\\\n+\t  = init_one_libfunc (FIXUNS_TRUNCTFSI2_LIBCALL);\t\t\\\n+\tif (TARGET_FPU)\t\t\t\t\t\t\t\\\n+\t  sqrt_optab->handlers[(int) TFmode].libfunc\t\t\t\\\n+\t    = init_one_libfunc (\"_Q_sqrt\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n     INIT_SUBTARGET_OPTABS;\t\t\t\t\t\t\\\n   } while (0)\n "}, {"sha": "25951f07eccd86a8c2133861bfd2e74f082d0938", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 590, "deletions": 18, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ac041c930f67cad6259c88b14907f376c748ba/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=47ac041c930f67cad6259c88b14907f376c748ba", "patch": "@@ -629,7 +629,7 @@\n   [(set (reg:CCFP 96)\n \t(compare:CCFP (match_operand:TF 0 \"register_operand\" \"\")\n \t\t      (match_operand:TF 1 \"register_operand\" \"\")))]\n-  \"TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n   \"\n {\n   sparc_compare_op0 = operands[0];\n@@ -857,6 +857,12 @@\n       emit_insn (pat);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n+      emit_jump_insn (gen_sne (operands[0]));\n+      DONE;\n+    }\n   else if (TARGET_V9)\n     {\n       if (gen_v9_scc (EQ, operands))\n@@ -904,6 +910,12 @@\n       emit_insn (pat);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n+      emit_jump_insn (gen_sne (operands[0]));\n+      DONE;\n+    }\n   else if (TARGET_V9)\n     {\n       if (gen_v9_scc (NE, operands))\n@@ -919,7 +931,13 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (TARGET_V9)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n+      emit_jump_insn (gen_sne (operands[0]));\n+      DONE;\n+    }\n+  else if (TARGET_V9)\n     {\n       if (gen_v9_scc (GT, operands))\n \tDONE;\n@@ -934,7 +952,13 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (TARGET_V9)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n+      emit_jump_insn (gen_sne (operands[0]));\n+      DONE;\n+    }\n+  else if (TARGET_V9)\n     {\n       if (gen_v9_scc (LT, operands))\n \tDONE;\n@@ -949,7 +973,13 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (TARGET_V9)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n+      emit_jump_insn (gen_sne (operands[0]));\n+      DONE;\n+    }\n+  else if (TARGET_V9)\n     {\n       if (gen_v9_scc (GE, operands))\n \tDONE;\n@@ -964,7 +994,13 @@\n   \"! TARGET_LIVE_G0\"\n   \"\n {\n-  if (TARGET_V9)\n+  if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n+      emit_jump_insn (gen_sne (operands[0]));\n+      DONE;\n+    }\n+  else if (TARGET_V9)\n     {\n       if (gen_v9_scc (LE, operands))\n \tDONE;\n@@ -1592,6 +1628,12 @@\n       emit_v9_brxx_insn (EQ, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n   operands[1] = gen_compare_reg (EQ, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1610,6 +1652,12 @@\n       emit_v9_brxx_insn (NE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n   operands[1] = gen_compare_reg (NE, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1628,6 +1676,12 @@\n       emit_v9_brxx_insn (GT, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n   operands[1] = gen_compare_reg (GT, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1656,6 +1710,12 @@\n       emit_v9_brxx_insn (LT, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n   operands[1] = gen_compare_reg (LT, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1684,6 +1744,12 @@\n       emit_v9_brxx_insn (GE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n   operands[1] = gen_compare_reg (GE, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -1712,6 +1778,12 @@\n       emit_v9_brxx_insn (LE, sparc_compare_op0, operands[0]);\n       DONE;\n     }\n+  else if (GET_MODE (sparc_compare_op0) == TFmode && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n   operands[1] = gen_compare_reg (LE, sparc_compare_op0, sparc_compare_op1);\n }\")\n \n@@ -4515,7 +4587,34 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"extendsftf2\"\n+(define_expand \"extendsftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(float_extend:TF\n+\t (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[0];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_stoq\\\"), 0,\n+\t\t\t VOIDmode, 2,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t operands[1], SFmode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*extendsftf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(float_extend:TF\n \t (match_operand:SF 1 \"register_operand\" \"f\")))]\n@@ -4524,7 +4623,34 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"extenddftf2\"\n+(define_expand \"extenddftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(float_extend:TF\n+\t (match_operand:DF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[0];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_dtoq\\\"), 0,\n+\t\t\t VOIDmode, 2,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t operands[1], DFmode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*extenddftf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(float_extend:TF\n \t (match_operand:DF 1 \"register_operand\" \"e\")))]\n@@ -4542,7 +4668,33 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"trunctfsf2\"\n+(define_expand \"trunctfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF\n+\t (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n+\t}\n+      else\n+\tslot0 = operands[1];\n+\n+      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtos\\\"),\n+\t\t\t       operands[0], 0, SFmode, 1,\n+\t\t\t       XEXP (slot0, 0), Pmode);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*trunctfsf2_hq\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(float_truncate:SF\n \t (match_operand:TF 1 \"register_operand\" \"e\")))]\n@@ -4551,7 +4703,33 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"trunctfdf2\"\n+(define_expand \"trunctfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:DF\n+\t (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n+\t}\n+      else\n+\tslot0 = operands[1];\n+\n+      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtod\\\"),\n+\t\t\t       operands[0], 0, DFmode, 1,\n+\t\t\t       XEXP (slot0, 0), Pmode);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*trunctfdf2_hq\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n \t(float_truncate:DF\n \t (match_operand:TF 1 \"register_operand\" \"e\")))]\n@@ -4578,14 +4756,63 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"floatsitf2\"\n+(define_expand \"floatsitf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(float:TF (match_operand:SI 1 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[1]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[1];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_itoq\\\"), 0,\n+\t\t\t VOIDmode, 2,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t operands[1], SImode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*floatsitf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(float:TF (match_operand:SI 1 \"register_operand\" \"f\")))]\n   \"TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fitoq\\\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n+(define_expand \"floatunssitf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(unsigned_float:TF (match_operand:SI 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n+  \"\n+{\n+  rtx slot0;\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+  else\n+    slot0 = operands[1];\n+\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_uitoq\\\"), 0,\n+\t\t     VOIDmode, 2,\n+\t\t     XEXP (slot0, 0), Pmode,\n+\t\t     operands[1], SImode);\n+\n+  if (GET_CODE (operands[0]) != MEM)\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+  DONE;\n+}\")\n+\n ;; Now the same for 64 bit sources.\n \n (define_insn \"floatdisf2\"\n@@ -4604,14 +4831,63 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"floatditf2\"\n+(define_expand \"floatditf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(float:TF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && TARGET_V9 && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[1]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[1];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_xtoq\\\"), 0,\n+\t\t\t VOIDmode, 2,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t operands[1], DImode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*floatditf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(float:TF (match_operand:DI 1 \"register_operand\" \"e\")))]\n   \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fxtoq\\\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n+(define_expand \"floatunsditf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(unsigned_float:TF (match_operand:DI 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n+  \"\n+{\n+  rtx slot0;\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+  else\n+    slot0 = operands[1];\n+\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_uxtoq\\\"), 0,\n+\t\t     VOIDmode, 2,\n+\t\t     XEXP (slot0, 0), Pmode,\n+\t\t     operands[1], DImode);\n+\n+  if (GET_CODE (operands[0]) != MEM)\n+    emit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+  DONE;\n+}\")\n+\n ;; Convert a float to an actual integer.\n ;; Truncation is performed as part of the conversion.\n \n@@ -4631,14 +4907,61 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"fix_trunctfsi2\"\n+(define_expand \"fix_trunctfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n+\t}\n+      else\n+\tslot0 = operands[1];\n+\n+      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtoi\\\"),\n+\t\t\t       operands[0], 0, SImode, 1,\n+\t\t\t       XEXP (slot0, 0), Pmode);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*fix_trunctfsi2_hq\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n \t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n   \"TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fqtoi\\\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n+(define_expand \"fixuns_trunctfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(unsigned_fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n+  \"\n+{\n+  rtx slot0;\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n+    }\n+  else\n+    slot0 = operands[1];\n+\n+  emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtoui\\\"),\n+\t\t\t   operands[0], 0, SImode, 1,\n+\t\t\t   XEXP (slot0, 0), Pmode);\n+  DONE;\n+}\")\n+\n ;; Now the same, for V9 targets\n \n (define_insn \"fix_truncsfdi2\"\n@@ -4657,13 +4980,61 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"fix_trunctfdi2\"\n+(define_expand \"fix_trunctfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n+\t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  \"TARGET_V9 && TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0;\n+\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n+\t}\n+      else\n+\tslot0 = operands[1];\n+\n+      emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtox\\\"),\n+\t\t\t       operands[0], 0, DImode, 1,\n+\t\t\t       XEXP (slot0, 0), Pmode);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*fix_trunctfdi2_hq\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n \t(fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n   \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n   \"fqtox\\\\t%1, %0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n+\n+(define_expand \"fixuns_trunctfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(unsigned_fix:DI (fix:TF (match_operand:TF 1 \"register_operand\" \"e\"))))]\n+  \"TARGET_FPU && TARGET_ARCH64 && ! TARGET_HARD_QUAD\"\n+  \"\n+{\n+  rtx slot0;\n+\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      emit_insn (gen_rtx_SET (VOIDmode, slot0, operands[1]));\n+    }\n+  else\n+    slot0 = operands[1];\n+\n+  emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_qtoux\\\"),\n+\t\t\t   operands[0], 0, DImode, 1,\n+\t\t\t   XEXP (slot0, 0), Pmode);\n+  DONE;\n+}\")\n+\n \f\n ;;- arithmetic instructions\n \n@@ -6592,7 +6963,49 @@\n \f\n ;; Floating point arithmetic instructions.\n \n-(define_insn \"addtf3\"\n+(define_expand \"addtf3\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(plus:TF (match_operand:TF 1 \"general_operand\" \"\")\n+\t\t (match_operand:TF 2 \"general_operand\" \"\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0, slot1, slot2;\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[0];\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n+\t}\n+      else\n+\tslot1 = operands[1];\n+      if (GET_CODE (operands[2]) != MEM)\n+\t{\n+\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n+\t}\n+      else\n+\tslot2 = operands[2];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_add\\\"), 0,\n+\t\t\t VOIDmode, 3,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t XEXP (slot1, 0), Pmode,\n+\t\t\t XEXP (slot2, 0), Pmode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*addtf3_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(plus:TF (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t (match_operand:TF 2 \"register_operand\" \"e\")))]\n@@ -6619,7 +7032,49 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"subtf3\"\n+(define_expand \"subtf3\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(minus:TF (match_operand:TF 1 \"general_operand\" \"\")\n+\t\t  (match_operand:TF 2 \"general_operand\" \"\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0, slot1, slot2;\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[0];\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n+\t}\n+      else\n+\tslot1 = operands[1];\n+      if (GET_CODE (operands[2]) != MEM)\n+\t{\n+\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n+\t}\n+      else\n+\tslot2 = operands[2];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_sub\\\"), 0,\n+\t\t\t VOIDmode, 3,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t XEXP (slot1, 0), Pmode,\n+\t\t\t XEXP (slot2, 0), Pmode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*subtf3_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(minus:TF (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t  (match_operand:TF 2 \"register_operand\" \"e\")))]\n@@ -6646,7 +7101,49 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"multf3\"\n+(define_expand \"multf3\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(mult:TF (match_operand:TF 1 \"general_operand\" \"\")\n+\t\t (match_operand:TF 2 \"general_operand\" \"\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0, slot1, slot2;\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[0];\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n+\t}\n+      else\n+\tslot1 = operands[1];\n+      if (GET_CODE (operands[2]) != MEM)\n+\t{\n+\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n+\t}\n+      else\n+\tslot2 = operands[2];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_mul\\\"), 0,\n+\t\t\t VOIDmode, 3,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t XEXP (slot1, 0), Pmode,\n+\t\t\t XEXP (slot2, 0), Pmode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*multf3_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(mult:TF (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t (match_operand:TF 2 \"register_operand\" \"e\")))]\n@@ -6691,8 +7188,50 @@\n   [(set_attr \"type\" \"fpmul\")\n    (set_attr \"length\" \"1\")])\n \n+(define_expand \"divtf3\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(div:TF (match_operand:TF 1 \"general_operand\" \"\")\n+\t\t(match_operand:TF 2 \"general_operand\" \"\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0, slot1, slot2;\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[0];\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n+\t}\n+      else\n+\tslot1 = operands[1];\n+      if (GET_CODE (operands[2]) != MEM)\n+\t{\n+\t  slot2 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot2, operands[2]));\n+\t}\n+      else\n+\tslot2 = operands[2];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_div\\\"), 0,\n+\t\t\t VOIDmode, 3,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t XEXP (slot1, 0), Pmode,\n+\t\t\t XEXP (slot2, 0), Pmode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n ;; don't have timing for quad-prec. divide.\n-(define_insn \"divtf3\"\n+(define_insn \"*divtf3_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(div:TF (match_operand:TF 1 \"register_operand\" \"e\")\n \t\t(match_operand:TF 2 \"register_operand\" \"e\")))]\n@@ -6963,7 +7502,40 @@\n   [(set_attr \"type\" \"fpmove\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"sqrttf2\"\n+(define_expand \"sqrttf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n+\t(sqrt:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n+  \"TARGET_FPU && (TARGET_HARD_QUAD || TARGET_ARCH64)\"\n+  \"\n+{\n+  if (! TARGET_HARD_QUAD)\n+    {\n+      rtx slot0, slot1;\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\tslot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+      else\n+\tslot0 = operands[0];\n+      if (GET_CODE (operands[1]) != MEM)\n+\t{\n+\t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, slot1, operands[1]));\n+\t}\n+      else\n+\tslot1 = operands[1];\n+\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"_Qp_sqrt\\\"), 0,\n+\t\t\t VOIDmode, 2,\n+\t\t\t XEXP (slot0, 0), Pmode,\n+\t\t\t XEXP (slot1, 0), Pmode);\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], slot0));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*sqrttf2_hq\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n \t(sqrt:TF (match_operand:TF 1 \"register_operand\" \"e\")))]\n   \"TARGET_FPU && TARGET_HARD_QUAD\""}]}