{"sha": "b71bbbe2b22460ff9200613784e631496fcfc054", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcxYmJiZTJiMjI0NjBmZjkyMDA2MTM3ODRlNjMxNDk2ZmNmYzA1NA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-12-23T16:00:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-12-23T16:00:45Z"}, "message": "builtins.h (c_strlen_data): Add new fields and comments.\n\n\t* builtins.h (c_strlen_data): Add new fields and comments.\n\t* builtins.c (unterminated_array): Change field reference from\n\t\"len\" to \"minlen\" in c_strlen_data instance.\n\t* gimple-fold.c (get_range_strlen): Likewise.\n\t* gimple-ssa-sprintf.c (get_string_length): Likewise.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267378", "tree": {"sha": "a1a6d61bb5147081c7b610d4d5bd12d3a48a9814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1a6d61bb5147081c7b610d4d5bd12d3a48a9814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b71bbbe2b22460ff9200613784e631496fcfc054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b71bbbe2b22460ff9200613784e631496fcfc054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b71bbbe2b22460ff9200613784e631496fcfc054", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b71bbbe2b22460ff9200613784e631496fcfc054/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09aa5bd6df9ec0003f230ba29b8b5545c1b533e"}], "stats": {"total": 64, "additions": 54, "deletions": 10}, "files": [{"sha": "cd2a294c583dca4ad5d711eab15b7e2084ba79c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b71bbbe2b22460ff9200613784e631496fcfc054", "patch": "@@ -1,6 +1,12 @@\n 2018-12-23  Martin Sebor  <msebor@redhat.com>\n \t    Jeff Law  <law@redhat.com>\n \n+\t* builtins.h (c_strlen_data): Add new fields and comments.\n+\t* builtins.c (unterminated_array): Change field reference from\n+\t\"len\" to \"minlen\" in c_strlen_data instance.\n+\t* gimple-fold.c (get_range_strlen): Likewise.\n+\t* gimple-ssa-sprintf.c (get_string_length): Likewise.\n+\n \t* builtins.c (unterminated_array): Rename \"data\" to \"lendata\".  Fix\n \ta few comments.\n \t(expand_builtin_strnlen, expand_builtin_stpcpy_1): Likewise."}, {"sha": "b56577e450c9ed122fa9e106adf8759d7d8e0559", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b71bbbe2b22460ff9200613784e631496fcfc054", "patch": "@@ -577,11 +577,11 @@ unterminated_array (tree exp, tree *size /* = NULL */, bool *exact /* = NULL */)\n      structure if EXP references a unterminated array.  */\n   c_strlen_data lendata = { };\n   tree len = c_strlen (exp, 1, &lendata);\n-  if (len == NULL_TREE && lendata.len && lendata.decl)\n+  if (len == NULL_TREE && lendata.minlen && lendata.decl)\n      {\n        if (size)\n \t{\n-\t  len = lendata.len;\n+\t  len = lendata.minlen;\n \t  if (lendata.off)\n \t    {\n \t      /* Constant offsets are already accounted for in LENDATA.MINLEN,\n@@ -720,7 +720,7 @@ c_strlen (tree src, int only_value, c_strlen_data *data, unsigned eltsize)\n \t{\n \t  data->decl = decl;\n \t  data->off = byteoff;\n-\t  data->len = ssize_int (len);\n+\t  data->minlen = ssize_int (len);\n \t  return NULL_TREE;\n \t}\n \n@@ -794,7 +794,7 @@ c_strlen (tree src, int only_value, c_strlen_data *data, unsigned eltsize)\n     {\n       data->decl = decl;\n       data->off = byteoff;\n-      data->len = ssize_int (len);\n+      data->minlen = ssize_int (len);\n       return NULL_TREE;\n     }\n "}, {"sha": "472a86d9ad0cfedeeb0ba5ac0c7f300f553e5039", "filename": "gcc/builtins.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=b71bbbe2b22460ff9200613784e631496fcfc054", "patch": "@@ -57,10 +57,48 @@ extern bool get_pointer_alignment_1 (tree, unsigned int *,\n \t\t\t\t     unsigned HOST_WIDE_INT *);\n extern unsigned int get_pointer_alignment (tree);\n extern unsigned string_length (const void*, unsigned, unsigned);\n+\n struct c_strlen_data\n {\n+  /* [MINLEN, MAXBOUND, MAXLEN] is a range describing the length of\n+     one or more strings of possibly unknown length.  For a single\n+     string of known length the range is a constant where\n+     MINLEN == MAXBOUND == MAXLEN holds.\n+     For other strings, MINLEN is the length of the shortest known\n+     string.  MAXBOUND is the length of a string that could be stored\n+     in the largest array referenced by the expression.  MAXLEN is\n+     the length of the longest sequence of non-zero bytes\n+     in an object referenced by the expression.  For such strings,\n+     MINLEN <= MAXBOUND <= MAXLEN holds.  For example, given:\n+       struct A { char a[7], b[]; };\n+       extern struct A *p;\n+       n = strlen (p->a);\n+     the computed range will be [0, 6, ALL_ONES].\n+     However, for a conditional expression involving a string\n+     of known length and an array of unknown bound such as\n+       n = strlen (i ? p->b : \"123\");\n+     the range will be [3, 3, ALL_ONES].\n+     MINLEN != 0 && MAXLEN == ALL_ONES indicates that MINLEN is\n+     the length of the shortest known string and implies that\n+     the shortest possible string referenced by the expression may\n+     actually be the empty string.  This distinction is useful for\n+     diagnostics.  get_range_strlen() return value distinguishes\n+     between these two cases.\n+     As the tighter (and more optimistic) bound, MAXBOUND is suitable\n+     for diagnostics but not for optimization.\n+     As the more conservative bound, MAXLEN is intended to be used\n+     for optimization.  */\n+  tree minlen;\n+  tree maxlen;\n+  tree maxbound;\n+  /* When non-null, NONSTR refers to the declaration known to store\n+     an unterminated constant character array, as in:\n+     const char s[] = { 'a', 'b', 'c' };\n+     It is used to diagnose uses of such arrays in functions such as\n+     strlen() that expect a nul-terminated string as an argument.  */\n   tree decl;\n-  tree len;\n+  /* Non-constant offset from the beginning of a string not accounted\n+     for in the length range.  Used to improve diagnostics.  */\n   tree off;\n };\n "}, {"sha": "b1dd4416567173c60e118acc48e0d869e319301b", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=b71bbbe2b22460ff9200613784e631496fcfc054", "patch": "@@ -1343,8 +1343,8 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t  if (!val && lendata.decl)\n \t    {\n \t      *nonstr = lendata.decl;\n-\t      *minlen = lendata.len;\n-\t      *maxlen = lendata.len;\n+\t      *minlen = lendata.minlen;\n+\t      *maxlen = lendata.minlen;\n \t      return type == 0 ? false : true;\n \t    }\n \t}"}, {"sha": "8284c76b0f7689a2a83b37a8a3242db2743992a1", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b71bbbe2b22460ff9200613784e631496fcfc054/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=b71bbbe2b22460ff9200613784e631496fcfc054", "patch": "@@ -2015,12 +2015,12 @@ get_string_length (tree str, unsigned eltsize)\n     }\n   else if (!slen\n \t   && data.decl\n-\t   && data.len\n-\t   && TREE_CODE (data.len) == INTEGER_CST)\n+\t   && data.minlen\n+\t   && TREE_CODE (data.minlen) == INTEGER_CST)\n     {\n       /* STR was not properly NUL terminated, but we have\n \t length information about the unterminated string.  */\n-      fmtresult res (tree_to_shwi (data.len));\n+      fmtresult res (tree_to_shwi (data.minlen));\n       res.nonstr = data.decl;\n       return res;\n     }"}]}