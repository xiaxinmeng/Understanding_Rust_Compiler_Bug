{"sha": "beb72684810c1ae42dfc2051de1967ec972162c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmViNzI2ODQ4MTBjMWFlNDJkZmMyMDUxZGUxOTY3ZWM5NzIxNjJjNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-11-24T00:09:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-11-24T00:09:03Z"}, "message": "rtl.h (validate_subreg): Declare.\n\n        * rtl.h (validate_subreg): Declare.\n        * emit-rtl.c (validate_subreg): New.\n        (gen_rtx_SUBREG): Use it.\n        * simplify-rtx.c (simplify_subreg): Likewise.\n        (simplify_gen_subreg): Likewise.  Remove duplicate asserts.\n        * expr.c (emit_move_insn_1): Tidy complex move code.  Use memory\n        fallback whenever gen_realpart/gen_imagpart would not be able to\n        create SUBREGs.\n\nFrom-SVN: r91126", "tree": {"sha": "f29afe08ac5b976db829029ba56f881700677e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f29afe08ac5b976db829029ba56f881700677e6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beb72684810c1ae42dfc2051de1967ec972162c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb72684810c1ae42dfc2051de1967ec972162c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb72684810c1ae42dfc2051de1967ec972162c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb72684810c1ae42dfc2051de1967ec972162c7/comments", "author": null, "committer": null, "parents": [{"sha": "4e55a16271ec5ef8a17b2f95cbf9341fc3f392f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e55a16271ec5ef8a17b2f95cbf9341fc3f392f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e55a16271ec5ef8a17b2f95cbf9341fc3f392f4"}], "stats": {"total": 221, "additions": 147, "deletions": 74}, "files": [{"sha": "87fdf4f7cbd8870611d2adf71e8b65019f07101c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=beb72684810c1ae42dfc2051de1967ec972162c7", "patch": "@@ -1,3 +1,14 @@\n+2004-11-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (validate_subreg): Declare.\n+\t* emit-rtl.c (validate_subreg): New.\n+\t(gen_rtx_SUBREG): Use it.\n+\t* simplify-rtx.c (simplify_subreg): Likewise.\n+\t(simplify_gen_subreg): Likewise.  Remove duplicate asserts.\n+\t* expr.c (emit_move_insn_1): Tidy complex move code.  Use memory\n+\tfallback whenever gen_realpart/gen_imagpart would not be able to\n+\tcreate SUBREGs.\n+\n 2004-11-23  Richard Henderson  <rth@redhat.com>\n \n \t* expmed.c (extract_bit_field): Use simplify_gen_subreg instead of"}, {"sha": "98dec5f9c8d293a94da27e25b793d73afc7b2c8c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 89, "deletions": 11, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=beb72684810c1ae42dfc2051de1967ec972162c7", "patch": "@@ -607,20 +607,98 @@ gen_const_mem (enum machine_mode mode, rtx addr)\n   return mem;\n }\n \n-rtx\n-gen_rtx_SUBREG (enum machine_mode mode, rtx reg, int offset)\n+/* We want to create (subreg:OMODE (obj:IMODE) OFFSET).  Return true if\n+   this construct would be valid, and false otherwise.  */\n+\n+bool\n+validate_subreg (enum machine_mode omode, enum machine_mode imode,\n+\t\t rtx reg, unsigned int offset)\n {\n-  /* This is the most common failure type.\n-     Catch it early so we can see who does it.  */\n-  gcc_assert (!(offset % GET_MODE_SIZE (mode)));\n+  unsigned int isize = GET_MODE_SIZE (imode);\n+  unsigned int osize = GET_MODE_SIZE (omode);\n \n-  /* This check isn't usable right now because combine will\n-     throw arbitrary crap like a CALL into a SUBREG in\n-     gen_lowpart_for_combine so we must just eat it.  */\n-#if 0\n-  /* Check for this too.  */\n-  gcc_assert (offset < GET_MODE_SIZE (GET_MODE (reg)));\n+  /* All subregs must be aligned.  */\n+  if (offset % osize != 0)\n+    return false;\n+\n+  /* The subreg offset cannot be outside the inner object.  */\n+  if (offset >= isize)\n+    return false;\n+\n+  /* ??? This should not be here.  Temporarily continue to allow word_mode\n+     subregs of anything.  The most common offender is (subreg:SI (reg:DF)).\n+     Generally, backends are doing something sketchy but it'll take time to\n+     fix them all.  */\n+  if (omode == word_mode)\n+    ;\n+  /* ??? Similarly, e.g. with (subreg:DF (reg:TI)).  Though store_bit_field\n+     is the culprit here, and not the backends.  */\n+  else if (osize >= UNITS_PER_WORD && isize >= osize)\n+    ;\n+  /* Allow component subregs of complex and vector.  Though given the below\n+     extraction rules, it's not always clear what that means.  */\n+  else if ((COMPLEX_MODE_P (imode) || VECTOR_MODE_P (imode))\n+\t   && GET_MODE_INNER (imode) == omode)\n+    ;\n+  /* ??? x86 sse code makes heavy use of *paradoxical* vector subregs,\n+     i.e. (subreg:V4SF (reg:SF) 0).  This surely isn't the cleanest way to\n+     represent this.  It's questionable if this ought to be represented at\n+     all -- why can't this all be hidden in post-reload splitters that make\n+     arbitrarily mode changes to the registers themselves.  */\n+  else if (VECTOR_MODE_P (omode) && GET_MODE_INNER (omode) == imode)\n+    ;\n+  /* Subregs involving floating point modes are not allowed to\n+     change size.  Therefore (subreg:DI (reg:DF) 0) is fine, but\n+     (subreg:SI (reg:DF) 0) isn't.  */\n+  else if (FLOAT_MODE_P (imode) || FLOAT_MODE_P (omode))\n+    {\n+      if (isize != osize)\n+\treturn false;\n+    }\n+\n+  /* Paradoxical subregs must have offset zero.  */\n+  if (osize > isize)\n+    return offset == 0;\n+\n+  /* This is a normal subreg.  Verify that the offset is representable.  */\n+\n+  /* For hard registers, we already have most of these rules collected in\n+     subreg_offset_representable_p.  */\n+  if (reg && REG_P (reg) && HARD_REGISTER_P (reg))\n+    {\n+      unsigned int regno = REGNO (reg);\n+\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+      if ((COMPLEX_MODE_P (imode) || VECTOR_MODE_P (imode))\n+\t  && GET_MODE_INNER (imode) == omode)\n+\t;\n+      else if (REG_CANNOT_CHANGE_MODE_P (regno, imode, omode))\n+\treturn false;\n #endif\n+\n+      return subreg_offset_representable_p (regno, imode, offset, omode);\n+    }\n+\n+  /* For pseudo registers, we want most of the same checks.  Namely:\n+     If the register no larger than a word, the subreg must be lowpart.\n+     If the register is larger than a word, the subreg must be the lowpart\n+     of a subword.  A subreg does *not* perform arbitrary bit extraction.\n+     Given that we've already checked mode/offset alignment, we only have\n+     to check subword subregs here.  */\n+  if (osize < UNITS_PER_WORD)\n+    {\n+      enum machine_mode wmode = isize > UNITS_PER_WORD ? word_mode : imode;\n+      unsigned int low_off = subreg_lowpart_offset (omode, wmode);\n+      if (offset % UNITS_PER_WORD != low_off)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+rtx\n+gen_rtx_SUBREG (enum machine_mode mode, rtx reg, int offset)\n+{\n+  gcc_assert (validate_subreg (mode, GET_MODE (reg), reg, offset));\n   return gen_rtx_raw_SUBREG (mode, reg, offset);\n }\n "}, {"sha": "fb0c73ecd09ee6c1d0e989bfe157ee9654bcdbcc", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=beb72684810c1ae42dfc2051de1967ec972162c7", "patch": "@@ -2647,7 +2647,6 @@ emit_move_insn_1 (rtx x, rtx y)\n {\n   enum machine_mode mode = GET_MODE (x);\n   enum machine_mode submode;\n-  enum mode_class class = GET_MODE_CLASS (mode);\n \n   gcc_assert ((unsigned int) mode < (unsigned int) MAX_MACHINE_MODE);\n \n@@ -2656,20 +2655,21 @@ emit_move_insn_1 (rtx x, rtx y)\n       emit_insn (GEN_FCN (mov_optab->handlers[(int) mode].insn_code) (x, y));\n \n   /* Expand complex moves by moving real part and imag part, if possible.  */\n-  else if ((class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n+  else if (COMPLEX_MODE_P (mode)\n \t   && BLKmode != (submode = GET_MODE_INNER (mode))\n \t   && (mov_optab->handlers[(int) submode].insn_code\n \t       != CODE_FOR_nothing))\n     {\n+      unsigned int modesize = GET_MODE_SIZE (mode);\n+      unsigned int submodesize = GET_MODE_SIZE (submode);\n+\n       /* Don't split destination if it is a stack push.  */\n-      int stack = push_operand (x, GET_MODE (x));\n+      int stack = push_operand (x, mode);\n \n #ifdef PUSH_ROUNDING\n       /* In case we output to the stack, but the size is smaller than the\n \t machine can push exactly, we need to use move instructions.  */\n-      if (stack\n-\t  && (PUSH_ROUNDING (GET_MODE_SIZE (submode))\n-\t      != GET_MODE_SIZE (submode)))\n+      if (stack && PUSH_ROUNDING (submodesize) != submodesize)\n \t{\n \t  rtx temp;\n \t  HOST_WIDE_INT offset1, offset2;\n@@ -2683,21 +2683,18 @@ emit_move_insn_1 (rtx x, rtx y)\n \t\t\t       add_optab,\n #endif\n \t\t\t       stack_pointer_rtx,\n-\t\t\t       GEN_INT\n-\t\t\t\t (PUSH_ROUNDING\n-\t\t\t\t  (GET_MODE_SIZE (GET_MODE (x)))),\n+\t\t\t       GEN_INT (PUSH_ROUNDING (modesize)),\n \t\t\t       stack_pointer_rtx, 0, OPTAB_LIB_WIDEN);\n \n \t  if (temp != stack_pointer_rtx)\n \t    emit_move_insn (stack_pointer_rtx, temp);\n \n #ifdef STACK_GROWS_DOWNWARD\n \t  offset1 = 0;\n-\t  offset2 = GET_MODE_SIZE (submode);\n+\t  offset2 = submodesize;\n #else\n-\t  offset1 = -PUSH_ROUNDING (GET_MODE_SIZE (GET_MODE (x)));\n-\t  offset2 = (-PUSH_ROUNDING (GET_MODE_SIZE (GET_MODE (x)))\n-\t\t     + GET_MODE_SIZE (submode));\n+\t  offset1 = -PUSH_ROUNDING (modesize);\n+\t  offset2 = -PUSH_ROUNDING (modesize) + submodesize;\n #endif\n \n \t  emit_move_insn (change_address (x, submode,\n@@ -2748,42 +2745,32 @@ emit_move_insn_1 (rtx x, rtx y)\n \t     memory and reload.  FIXME, we should see about using extract and\n \t     insert on integer registers, but complex short and complex char\n \t     variables should be rarely used.  */\n-\t  if (GET_MODE_BITSIZE (mode) < 2 * BITS_PER_WORD\n-\t      && (reload_in_progress | reload_completed) == 0)\n+\t  if ((reload_in_progress | reload_completed) == 0\n+\t      && (!validate_subreg (submode, mode, NULL, submodesize)\n+\t\t  || !validate_subreg (submode, mode, NULL, 0)))\n \t    {\n-\t      int packed_dest_p\n-\t\t= (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER);\n-\t      int packed_src_p\n-\t\t= (REG_P (y) && REGNO (y) < FIRST_PSEUDO_REGISTER);\n-\n-\t      if (packed_dest_p || packed_src_p)\n+\t      if (REG_P (x) || REG_P (y))\n \t\t{\n-\t\t  enum mode_class reg_class = ((class == MODE_COMPLEX_FLOAT)\n-\t\t\t\t\t       ? MODE_FLOAT : MODE_INT);\n-\n+\t\t  rtx mem, cmem;\n \t\t  enum machine_mode reg_mode\n-\t\t    = mode_for_size (GET_MODE_BITSIZE (mode), reg_class, 1);\n+\t\t    = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 1);\n+\n+\t\t  gcc_assert (reg_mode != BLKmode);\n+\n+\t\t  mem = assign_stack_temp (reg_mode, modesize, 0);\n+\t\t  cmem = adjust_address (mem, mode, 0);\n \n-\t\t  if (reg_mode != BLKmode)\n+\t\t  if (REG_P (x))\n+\t\t    {\n+\t\t      rtx sreg = gen_rtx_SUBREG (reg_mode, x, 0);\n+\t\t      emit_move_insn_1 (cmem, y);\n+\t\t      return emit_move_insn_1 (sreg, mem);\n+\t\t    }\n+\t\t  else\n \t\t    {\n-\t\t      rtx mem = assign_stack_temp (reg_mode,\n-\t\t\t\t\t\t   GET_MODE_SIZE (mode), 0);\n-\t\t      rtx cmem = adjust_address (mem, mode, 0);\n-\n-\t\t      if (packed_dest_p)\n-\t\t\t{\n-\t\t\t  rtx sreg = gen_rtx_SUBREG (reg_mode, x, 0);\n-\n-\t\t\t  emit_move_insn_1 (cmem, y);\n-\t\t\t  return emit_move_insn_1 (sreg, mem);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  rtx sreg = gen_rtx_SUBREG (reg_mode, y, 0);\n-\n-\t\t\t  emit_move_insn_1 (mem, sreg);\n-\t\t\t  return emit_move_insn_1 (x, cmem);\n-\t\t\t}\n+\t\t      rtx sreg = gen_rtx_SUBREG (reg_mode, y, 0);\n+\t\t      emit_move_insn_1 (mem, sreg);\n+\t\t      return emit_move_insn_1 (x, cmem);\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "edb2913ac85704c5b66ab8a0ef58f864eb2cd792", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=beb72684810c1ae42dfc2051de1967ec972162c7", "patch": "@@ -1964,6 +1964,8 @@ extern rtx delete_insn_and_edges (rtx);\n extern void delete_insn_chain_and_edges (rtx, rtx);\n extern rtx gen_lowpart_SUBREG (enum machine_mode, rtx);\n extern rtx gen_const_mem (enum machine_mode, rtx);\n+extern bool validate_subreg (enum machine_mode, enum machine_mode,\n+\t\t\t     rtx, unsigned int);\n \n /* In combine.c */\n extern int combine_instructions (rtx, unsigned int);"}, {"sha": "52c0cffb87bb718ea18a944971044b6f1b9eede3", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb72684810c1ae42dfc2051de1967ec972162c7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=beb72684810c1ae42dfc2051de1967ec972162c7", "patch": "@@ -3642,12 +3642,14 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n \t}\n \n       /* Recurse for further possible simplifications.  */\n-      newx = simplify_subreg (outermode, SUBREG_REG (op),\n-\t\t\t     GET_MODE (SUBREG_REG (op)),\n-\t\t\t     final_offset);\n+      newx = simplify_subreg (outermode, SUBREG_REG (op), innermostmode,\n+\t\t\t      final_offset);\n       if (newx)\n \treturn newx;\n-      return gen_rtx_SUBREG (outermode, SUBREG_REG (op), final_offset);\n+      if (validate_subreg (outermode, innermostmode,\n+\t\t\t   SUBREG_REG (op), final_offset))\n+        return gen_rtx_SUBREG (outermode, SUBREG_REG (op), final_offset);\n+      return NULL_RTX;\n     }\n \n   /* SUBREG of a hard register => just change the register number\n@@ -3725,9 +3727,9 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n       res = simplify_subreg (outermode, part, GET_MODE (part), final_offset);\n       if (res)\n \treturn res;\n-      /* We can at least simplify it by referring directly to the\n-\t relevant part.  */\n-      return gen_rtx_SUBREG (outermode, part, final_offset);\n+      if (validate_subreg (outermode, GET_MODE (part), part, final_offset))\n+        return gen_rtx_SUBREG (outermode, part, final_offset);\n+      return NULL_RTX;\n     }\n \n   /* Optimize SUBREG truncations of zero and sign extended values.  */\n@@ -3775,17 +3777,6 @@ simplify_gen_subreg (enum machine_mode outermode, rtx op,\n \t\t     enum machine_mode innermode, unsigned int byte)\n {\n   rtx newx;\n-  /* Little bit of sanity checking.  */\n-  gcc_assert (innermode != VOIDmode);\n-  gcc_assert (outermode != VOIDmode);\n-  gcc_assert (innermode != BLKmode);\n-  gcc_assert (outermode != BLKmode);\n-\n-  gcc_assert (GET_MODE (op) == innermode\n-\t      || GET_MODE (op) == VOIDmode);\n-\n-  gcc_assert ((byte % GET_MODE_SIZE (outermode)) == 0);\n-  gcc_assert (byte < GET_MODE_SIZE (innermode));\n \n   newx = simplify_subreg (outermode, op, innermode, byte);\n   if (newx)\n@@ -3795,8 +3786,12 @@ simplify_gen_subreg (enum machine_mode outermode, rtx op,\n       || (REG_P (op) && REGNO (op) < FIRST_PSEUDO_REGISTER))\n     return NULL_RTX;\n \n-  return gen_rtx_SUBREG (outermode, op, byte);\n+  if (validate_subreg (outermode, innermode, op, byte))\n+    return gen_rtx_SUBREG (outermode, op, byte);\n+\n+  return NULL_RTX;\n }\n+\n /* Simplify X, an rtx expression.\n \n    Return the simplified expression or NULL if no simplifications"}]}