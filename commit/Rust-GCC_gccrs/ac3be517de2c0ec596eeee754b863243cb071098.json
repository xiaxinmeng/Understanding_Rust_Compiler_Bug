{"sha": "ac3be517de2c0ec596eeee754b863243cb071098", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMzYmU1MTdkZTJjMGVjNTk2ZWVlZTc1NGI4NjMyNDNjYjA3MTA5OA==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-22T13:59:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-22T13:59:00Z"}, "message": "Merge #640\n\n640: Optional Trait items constants r=philberty a=philberty\n\nThis adds more support for optional trait items such as constants.\r\nSome fixes come along with this PR such as improved query-based\r\ncompilation for trait items which is now a canonical implementation for\r\nqualified and normal paths in HIR.\r\n\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "9bef8c57466f78db9fd8444f33ed854c24187d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bef8c57466f78db9fd8444f33ed854c24187d16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac3be517de2c0ec596eeee754b863243cb071098", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhIlgkCRBK7hj4Ov3rIwAALb8IAB4p8A89R4X8CFP/kqVRORB+\nvn9TjpA/DXfjSjOL49AyGiUUrxLEZnR8Udygq5poGMzl0QekBR4/dwUS+igkdJI+\n6uRkyKi1yn1SMrJRXVIi0z3atwayBRbeNLIVBBRWXsENxvXaUTaJG4x9UvJZWvvo\nwoPZCdyx9TBFHWUgu6T/58Lwiak3haAP9CUWAeaLys0JScbhAgdamDYH0luYkOgV\n+2qZNBaj/k3uJPtw5lxnOKrvFXtePio2zqGVEVRzSNXjrWH16H03jXracjgCTrmg\nLmLPabu2rXkjbCcUMYCplQov/W5M3c8jt56IRo896ntjr8TUfCLKFTXeL0YUSdE=\n=K+b/\n-----END PGP SIGNATURE-----\n", "payload": "tree 9bef8c57466f78db9fd8444f33ed854c24187d16\nparent e9746f445cf57c12f70d0016722835ec504cc655\nparent 5a0e34b74aa6de092632bad2bee4883c5a23e036\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629640740 +0000\ncommitter GitHub <noreply@github.com> 1629640740 +0000\n\nMerge #640\n\n640: Optional Trait items constants r=philberty a=philberty\n\nThis adds more support for optional trait items such as constants.\r\nSome fixes come along with this PR such as improved query-based\r\ncompilation for trait items which is now a canonical implementation for\r\nqualified and normal paths in HIR.\r\n\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3be517de2c0ec596eeee754b863243cb071098", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac3be517de2c0ec596eeee754b863243cb071098", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3be517de2c0ec596eeee754b863243cb071098/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9746f445cf57c12f70d0016722835ec504cc655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9746f445cf57c12f70d0016722835ec504cc655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9746f445cf57c12f70d0016722835ec504cc655"}, {"sha": "5a0e34b74aa6de092632bad2bee4883c5a23e036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0e34b74aa6de092632bad2bee4883c5a23e036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0e34b74aa6de092632bad2bee4883c5a23e036"}], "stats": {"total": 1478, "additions": 871, "deletions": 607}, "files": [{"sha": "9c69b44e49037932636f7c03c72a432c4d36739d", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -84,6 +84,7 @@ GRS_OBJS = \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-lint-marklive.o \\\n+    rust/rust-hir-type-check-path.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "bdeda2200f50b31a7e11047df875bed9ea850f77", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 85, "deletions": 13, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -34,11 +34,25 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void Compile (TyTy::BaseType *self, HIR::ImplItem *item, Context *ctx,\n-\t\t       bool compile_fns, TyTy::BaseType *concrete = nullptr)\n+  static Bexpression *Compile (TyTy::BaseType *self, HIR::ImplItem *item,\n+\t\t\t       Context *ctx, bool compile_fns,\n+\t\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t\t       bool is_query_mode = false,\n+\t\t\t       Location ref_locus = Location ())\n   {\n-    CompileInherentImplItem compiler (self, ctx, compile_fns, concrete);\n+    CompileInherentImplItem compiler (self, ctx, compile_fns, concrete,\n+\t\t\t\t      ref_locus);\n     item->accept_vis (compiler);\n+\n+    if (is_query_mode\n+\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+      {\n+\trust_error_at (ref_locus, \"failed to compile impl item: %s\",\n+\t\t       item->as_string ().c_str ());\n+\trust_assert (\n+\t  !ctx->get_backend ()->is_error_expression (compiler.reference));\n+      }\n+    return compiler.reference;\n   }\n \n   void visit (HIR::ConstantItem &constant) override\n@@ -63,6 +77,8 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     ctx->push_const (const_expr);\n     ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+    reference = const_expr;\n   }\n \n   void visit (HIR::Function &function) override\n@@ -104,8 +120,13 @@ class CompileInherentImplItem : public HIRCompileBase\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n-\n+\t      {\n+\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n+\t\t\t\t\t   fntype);\n+\t      }\n+\t    reference\n+\t      = ctx->get_backend ()->function_code_expression (lookup,\n+\t\t\t\t\t\t\t       ref_locus);\n \t    return;\n \t  }\n       }\n@@ -281,32 +302,73 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     ctx->pop_fn ();\n-\n     ctx->push_function (fndecl);\n+\n+    reference\n+      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n   }\n \n private:\n   CompileInherentImplItem (TyTy::BaseType *self, Context *ctx, bool compile_fns,\n-\t\t\t   TyTy::BaseType *concrete)\n+\t\t\t   TyTy::BaseType *concrete, Location ref_locus)\n     : HIRCompileBase (ctx), self (self), compile_fns (compile_fns),\n-      concrete (concrete)\n+      concrete (concrete), reference (ctx->get_backend ()->error_expression ()),\n+      ref_locus (ref_locus)\n   {}\n \n   TyTy::BaseType *self;\n   bool compile_fns;\n   TyTy::BaseType *concrete;\n+  Bexpression *reference;\n+  Location ref_locus;\n };\n \n class CompileTraitItem : public HIRCompileBase\n {\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void Compile (TyTy::BaseType *self, HIR::TraitItem *item, Context *ctx,\n-\t\t       TyTy::BaseType *concrete)\n+  static Bexpression *Compile (TyTy::BaseType *self, HIR::TraitItem *item,\n+\t\t\t       Context *ctx, TyTy::BaseType *concrete,\n+\t\t\t       bool is_query_mode = false,\n+\t\t\t       Location ref_locus = Location ())\n   {\n-    CompileTraitItem compiler (self, ctx, concrete);\n+    CompileTraitItem compiler (self, ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n+\n+    if (is_query_mode\n+\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+      {\n+\trust_error_at (ref_locus, \"failed to compile trait item: %s\",\n+\t\t       item->as_string ().c_str ());\n+\trust_assert (\n+\t  !ctx->get_backend ()->is_error_expression (compiler.reference));\n+      }\n+    return compiler.reference;\n+  }\n+\n+  void visit (HIR::TraitItemConst &constant) override\n+  {\n+    rust_assert (concrete != nullptr);\n+    TyTy::BaseType *resolved_type = concrete;\n+\n+    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    Bexpression *value\n+      = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n+\n+    const Resolver::CanonicalPath *canonical_path = nullptr;\n+    rust_assert (ctx->get_mappings ()->lookup_canonical_path (\n+      constant.get_mappings ().get_crate_num (),\n+      constant.get_mappings ().get_nodeid (), &canonical_path));\n+\n+    std::string ident = canonical_path->get ();\n+    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+      type, constant.get_name (), value, constant.get_locus ());\n+\n+    ctx->push_const (const_expr);\n+    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+    reference = const_expr;\n   }\n \n   void visit (HIR::TraitItemFunc &func) override\n@@ -330,6 +392,9 @@ class CompileTraitItem : public HIRCompileBase\n \t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n \t\t\t\t\t   fntype);\n \t      }\n+\t    reference\n+\t      = ctx->get_backend ()->function_code_expression (lookup,\n+\t\t\t\t\t\t\t       ref_locus);\n \t    return;\n \t  }\n       }\n@@ -499,16 +564,23 @@ class CompileTraitItem : public HIRCompileBase\n \n     ctx->pop_fn ();\n     ctx->push_function (fndecl);\n+\n+    reference\n+      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n   }\n \n private:\n   CompileTraitItem (TyTy::BaseType *self, Context *ctx,\n-\t\t    TyTy::BaseType *concrete)\n-    : HIRCompileBase (ctx), self (self), concrete (concrete)\n+\t\t    TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), self (self), concrete (concrete),\n+      reference (ctx->get_backend ()->error_expression ()),\n+      ref_locus (ref_locus)\n   {}\n \n   TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n+  Bexpression *reference;\n+  Location ref_locus;\n };\n \n } // namespace Compile"}, {"sha": "eb7d9eff79dd1c12480b7752ddb7acb11994356e", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -33,14 +33,28 @@ namespace Compile {\n \n class CompileItem : public HIRCompileBase\n {\n+protected:\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void compile (HIR::Item *item, Context *ctx, bool compile_fns = true,\n-\t\t       TyTy::BaseType *concrete = nullptr)\n+  static Bexpression *compile (HIR::Item *item, Context *ctx,\n+\t\t\t       bool compile_fns = true,\n+\t\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t\t       bool is_query_mode = false,\n+\t\t\t       Location ref_locus = Location ())\n   {\n-    CompileItem compiler (ctx, compile_fns, concrete);\n+    CompileItem compiler (ctx, compile_fns, concrete, ref_locus);\n     item->accept_vis (compiler);\n+\n+    if (is_query_mode\n+\t&& ctx->get_backend ()->is_error_expression (compiler.reference))\n+      {\n+\trust_error_at (ref_locus, \"failed to compile item: %s\",\n+\t\t       item->as_string ().c_str ());\n+\trust_assert (\n+\t  !ctx->get_backend ()->is_error_expression (compiler.reference));\n+      }\n+    return compiler.reference;\n   }\n \n   void visit (HIR::StaticItem &var) override\n@@ -73,6 +87,8 @@ class CompileItem : public HIRCompileBase\n \n     ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n     ctx->push_var (static_global);\n+\n+    reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n   }\n \n   void visit (HIR::ConstantItem &constant) override\n@@ -98,6 +114,8 @@ class CompileItem : public HIRCompileBase\n \n     ctx->push_const (const_expr);\n     ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+    reference = const_expr;\n   }\n \n   void visit (HIR::Function &function) override\n@@ -139,8 +157,14 @@ class CompileItem : public HIRCompileBase\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n-\n+\t      {\n+\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n+\t\t\t\t\t   fntype);\n+\t      }\n+\n+\t    reference\n+\t      = ctx->get_backend ()->function_code_expression (lookup,\n+\t\t\t\t\t\t\t       ref_locus);\n \t    return;\n \t  }\n       }\n@@ -287,6 +311,9 @@ class CompileItem : public HIRCompileBase\n \n     ctx->pop_fn ();\n     ctx->push_function (fndecl);\n+\n+    reference\n+      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n   }\n \n   void visit (HIR::ImplBlock &impl_block) override\n@@ -319,13 +346,18 @@ class CompileItem : public HIRCompileBase\n       CompileItem::compile (item.get (), ctx, compile_fns);\n   }\n \n-private:\n-  CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete)\n-    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete)\n+protected:\n+  CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete,\n+\t       Location ref_locus)\n+    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete),\n+      reference (ctx->get_backend ()->error_expression ()),\n+      ref_locus (ref_locus)\n   {}\n \n   bool compile_fns;\n   TyTy::BaseType *concrete;\n+  Bexpression *reference;\n+  Location ref_locus;\n };\n \n } // namespace Compile"}, {"sha": "98c04dfe37920dcd0b61c052316eb8fdbf710aee", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 144, "deletions": 149, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -29,18 +29,18 @@ namespace Compile {\n void\n ResolvePathRef::visit (HIR::QualifiedPathInExpression &expr)\n {\n-  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n-\t   expr.get_locus (), true);\n+  resolved = resolve (expr.get_final_segment ().get_segment (),\n+\t\t      expr.get_mappings (), expr.get_locus (), true);\n }\n \n void\n ResolvePathRef::visit (HIR::PathInExpression &expr)\n {\n-  resolve (expr.get_final_segment ().get_segment (), expr.get_mappings (),\n-\t   expr.get_locus (), false);\n+  resolved = resolve (expr.get_final_segment ().get_segment (),\n+\t\t      expr.get_mappings (), expr.get_locus (), false);\n }\n \n-void\n+Bexpression *\n ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t const Analysis::NodeMapping &mappings,\n \t\t\t Location expr_locus, bool is_qualified_path)\n@@ -54,199 +54,194 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n \t{\n \t  rust_error_at (expr_locus, \"unknown reference for resolved name\");\n-\t  return;\n+\t  return ctx->get_backend ()->error_expression ();\n \t}\n       ref_node_id = def.parent;\n     }\n \n   // this can fail because it might be a Constructor for something\n   // in that case the caller should attempt ResolvePathType::Compile\n   if (ref_node_id == UNKNOWN_NODEID)\n-    return;\n+    {\n+      rust_error_at (expr_locus, \"unknown nodeid for path expr\");\n+      return ctx->get_backend ()->error_expression ();\n+    }\n \n   HirId ref;\n   if (!ctx->get_mappings ()->lookup_node_to_hir (mappings.get_crate_num (),\n \t\t\t\t\t\t ref_node_id, &ref))\n     {\n       rust_error_at (expr_locus, \"reverse call path lookup failure\");\n-      return;\n+      return ctx->get_backend ()->error_expression ();\n     }\n \n   // might be a constant\n-  if (ctx->lookup_const_decl (ref, &resolved))\n-    return;\n+  Bexpression *constant_expr;\n+  if (ctx->lookup_const_decl (ref, &constant_expr))\n+    return constant_expr;\n \n   // this might be a variable reference or a function reference\n   Bvariable *var = nullptr;\n   if (ctx->lookup_var_decl (ref, &var))\n-    {\n-      resolved = ctx->get_backend ()->var_expression (var, expr_locus);\n-      return;\n-    }\n+    return ctx->get_backend ()->var_expression (var, expr_locus);\n \n-  // must be a function call but it might be a generic function which needs to\n-  // be compiled first\n+  // it might be a function call\n   TyTy::BaseType *lookup = nullptr;\n   bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n   rust_assert (ok);\n-  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+  if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+      Bfunction *fn = nullptr;\n+      if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t{\n+\t  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+\t}\n+    }\n+\n+  // let the query system figure it out\n+  return query_compile (ref, lookup, final_segment, mappings, expr_locus,\n+\t\t\tis_qualified_path);\n+}\n \n-  Bfunction *fn = nullptr;\n-  if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n+Bexpression *\n+ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t\t       const HIR::PathIdentSegment &final_segment,\n+\t\t\t       const Analysis::NodeMapping &mappings,\n+\t\t\t       Location expr_locus, bool is_qualified_path)\n+{\n+  HIR::Item *resolved_item\n+    = ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (), ref);\n+  bool is_hir_item = resolved_item != nullptr;\n+  if (is_hir_item)\n+    {\n+      if (!lookup->has_subsititions_defined ())\n+\treturn CompileItem::compile (resolved_item, ctx, true, nullptr, true,\n+\t\t\t\t     expr_locus);\n+      else\n+\treturn CompileItem::compile (resolved_item, ctx, true, lookup, true,\n+\t\t\t\t     expr_locus);\n+    }\n+  else\n     {\n-      // it must resolve to some kind of HIR::Item or HIR::InheritImplItem\n-      HIR::Item *resolved_item\n-\t= ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (),\n-\t\t\t\t\t\t ref);\n-      if (resolved_item != nullptr)\n+      HirId parent_impl_id = UNKNOWN_HIRID;\n+      HIR::ImplItem *resolved_item\n+\t= ctx->get_mappings ()->lookup_hir_implitem (mappings.get_crate_num (),\n+\t\t\t\t\t\t     ref, &parent_impl_id);\n+      bool is_impl_item = resolved_item != nullptr;\n+      if (is_impl_item)\n \t{\n+\t  rust_assert (parent_impl_id != UNKNOWN_HIRID);\n+\t  HIR::Item *impl_ref\n+\t    = ctx->get_mappings ()->lookup_hir_item (mappings.get_crate_num (),\n+\t\t\t\t\t\t     parent_impl_id);\n+\t  rust_assert (impl_ref != nullptr);\n+\t  HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n+\n+\t  TyTy::BaseType *self = nullptr;\n+\t  bool ok = ctx->get_tyctx ()->lookup_type (\n+\t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n+\t  rust_assert (ok);\n+\n \t  if (!lookup->has_subsititions_defined ())\n-\t    CompileItem::compile (resolved_item, ctx);\n+\t    return CompileInherentImplItem::Compile (self, resolved_item, ctx,\n+\t\t\t\t\t\t     true, nullptr, true,\n+\t\t\t\t\t\t     expr_locus);\n \t  else\n-\t    CompileItem::compile (resolved_item, ctx, true, lookup);\n+\t    return CompileInherentImplItem::Compile (self, resolved_item, ctx,\n+\t\t\t\t\t\t     true, lookup, true,\n+\t\t\t\t\t\t     expr_locus);\n \t}\n       else\n \t{\n-\t  HirId parent_impl_id = UNKNOWN_HIRID;\n-\t  HIR::ImplItem *resolved_item\n-\t    = ctx->get_mappings ()->lookup_hir_implitem (\n-\t      mappings.get_crate_num (), ref, &parent_impl_id);\n-\n-\t  if (resolved_item == nullptr)\n+\t  // it might be resolved to a trait item\n+\t  HIR::TraitItem *trait_item\n+\t    = ctx->get_mappings ()->lookup_hir_trait_item (\n+\t      mappings.get_crate_num (), ref);\n+\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+\t    trait_item->get_mappings ().get_hirid ());\n+\n+\t  Resolver::TraitReference *trait_ref\n+\t    = &Resolver::TraitReference::error_node ();\n+\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+\t    trait->get_mappings ().get_defid (), &trait_ref);\n+\t  rust_assert (ok);\n+\n+\t  TyTy::BaseType *receiver = nullptr;\n+\t  ok = ctx->get_tyctx ()->lookup_receiver (mappings.get_hirid (),\n+\t\t\t\t\t\t   &receiver);\n+\t  rust_assert (ok);\n+\n+\t  if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n \t    {\n-\t      // it might be resolved to a trait item\n-\t      HIR::TraitItem *trait_item\n-\t\t= ctx->get_mappings ()->lookup_hir_trait_item (\n-\t\t  mappings.get_crate_num (), ref);\n-\t      HIR::Trait *trait\n-\t\t= ctx->get_mappings ()->lookup_trait_item_mapping (\n-\t\t  trait_item->get_mappings ().get_hirid ());\n-\n-\t      Resolver::TraitReference *trait_ref\n-\t\t= &Resolver::TraitReference::error_node ();\n-\t      bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n-\t\ttrait->get_mappings ().get_defid (), &trait_ref);\n-\t      rust_assert (ok);\n-\n-\t      TyTy::BaseType *receiver = nullptr;\n-\t      ok = ctx->get_tyctx ()->lookup_receiver (mappings.get_hirid (),\n-\t\t\t\t\t\t       &receiver);\n-\t      rust_assert (ok);\n+\t      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+\t      receiver = p->resolve ();\n+\t    }\n \n-\t      if (receiver->get_kind () == TyTy::TypeKind::PARAM)\n-\t\t{\n-\t\t  TyTy::ParamType *p\n-\t\t    = static_cast<TyTy::ParamType *> (receiver);\n-\t\t  receiver = p->resolve ();\n-\t\t}\n-\n-\t      // the type resolver can only resolve type bounds to their trait\n-\t      // item so its up to us to figure out if this path should resolve\n-\t      // to an trait-impl-block-item or if it can be defaulted to the\n-\t      // trait-impl-item's definition\n-\t      std::vector<Resolver::PathProbeCandidate> candidates;\n-\t      if (!is_qualified_path)\n-\t\t{\n-\t\t  candidates\n-\t\t    = Resolver::PathProbeType::Probe (receiver, final_segment,\n-\t\t\t\t\t\t      true, false, true);\n-\t\t}\n-\n-\t      if (candidates.size () == 0)\n-\t\t{\n-\t\t  // this means we are defaulting back to the trait_item if\n-\t\t  // possible\n-\t\t  Resolver::TraitItemReference *trait_item_ref = nullptr;\n-\t\t  bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n-\t\t\t\t\t\t\t      &trait_item_ref);\n-\t\t  rust_assert (ok); // found\n-\t\t  rust_assert (\n-\t\t    trait_item_ref->is_optional ()); // has definition\n-\n-\t\t  Analysis::NodeMapping trait_mappings\n-\t\t    = trait_item_ref->get_parent_trait_mappings ();\n-\t\t  auto associated_impl_id\n-\t\t    = ctx->get_tyctx ()\n-\t\t\t->lookup_associated_impl_mapping_for_self (\n-\t\t\t  trait_mappings.get_hirid (), receiver);\n-\n-\t\t  rust_assert (associated_impl_id != UNKNOWN_HIRID);\n-\n-\t\t  Resolver::AssociatedImplTrait *associated = nullptr;\n-\t\t  bool found_associated_trait_impl\n-\t\t    = ctx->get_tyctx ()->lookup_associated_trait_impl (\n-\t\t      associated_impl_id, &associated);\n-\t\t  rust_assert (found_associated_trait_impl);\n-\t\t  associated->setup_associated_types ();\n-\n-\t\t  CompileTraitItem::Compile (\n-\t\t    receiver, trait_item_ref->get_hir_trait_item (), ctx,\n-\t\t    fntype);\n-\n-\t\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-\t\t    {\n-\t\t      resolved = ctx->get_backend ()->error_expression ();\n-\t\t      rust_error_at (expr_locus,\n-\t\t\t\t     \"forward declaration was not compiled\");\n-\t\t      return;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  Resolver::PathProbeCandidate &candidate = candidates.at (0);\n-\t\t  rust_assert (candidate.is_impl_candidate ());\n-\n-\t\t  HIR::ImplBlock *impl = candidate.item.impl.parent;\n-\t\t  HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n-\n-\t\t  TyTy::BaseType *self = nullptr;\n-\t\t  bool ok = ctx->get_tyctx ()->lookup_type (\n-\t\t    impl->get_type ()->get_mappings ().get_hirid (), &self);\n-\t\t  rust_assert (ok);\n-\n-\t\t  if (!lookup->has_subsititions_defined ())\n-\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n-\t\t\t\t\t\t      true);\n-\t\t  else\n-\t\t    CompileInherentImplItem::Compile (self, impl_item, ctx,\n-\t\t\t\t\t\t      true, lookup);\n-\n-\t\t  lookup->set_ty_ref (\n-\t\t    impl_item->get_impl_mappings ().get_hirid ());\n-\t\t}\n+\t  // the type resolver can only resolve type bounds to their trait\n+\t  // item so its up to us to figure out if this path should resolve\n+\t  // to an trait-impl-block-item or if it can be defaulted to the\n+\t  // trait-impl-item's definition\n+\t  std::vector<Resolver::PathProbeCandidate> candidates\n+\t    = Resolver::PathProbeImplTrait::Probe (receiver, final_segment,\n+\t\t\t\t\t\t   trait_ref);\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      // this means we are defaulting back to the trait_item if\n+\t      // possible\n+\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n+\t\t\t\t\t\t\t  &trait_item_ref);\n+\t      rust_assert (ok);\t\t\t\t    // found\n+\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+\t      Analysis::NodeMapping trait_mappings\n+\t\t= trait_item_ref->get_parent_trait_mappings ();\n+\t      auto associated_impl_id\n+\t\t= ctx->get_tyctx ()->lookup_associated_impl_mapping_for_self (\n+\t\t  trait_mappings.get_hirid (), receiver);\n+\n+\t      rust_assert (associated_impl_id != UNKNOWN_HIRID);\n+\n+\t      Resolver::AssociatedImplTrait *associated = nullptr;\n+\t      bool found_associated_trait_impl\n+\t\t= ctx->get_tyctx ()->lookup_associated_trait_impl (\n+\t\t  associated_impl_id, &associated);\n+\t      rust_assert (found_associated_trait_impl);\n+\t      associated->setup_associated_types ();\n+\n+\t      return CompileTraitItem::Compile (\n+\t\treceiver, trait_item_ref->get_hir_trait_item (), ctx, lookup,\n+\t\ttrue, expr_locus);\n \t    }\n \t  else\n \t    {\n-\t      rust_assert (parent_impl_id != UNKNOWN_HIRID);\n-\t      HIR::Item *impl_ref = ctx->get_mappings ()->lookup_hir_item (\n-\t\tmappings.get_crate_num (), parent_impl_id);\n-\t      rust_assert (impl_ref != nullptr);\n-\t      HIR::ImplBlock *impl = static_cast<HIR::ImplBlock *> (impl_ref);\n+\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n+\t      rust_assert (candidate.is_impl_candidate ());\n+\n+\t      HIR::ImplBlock *impl = candidate.item.impl.parent;\n+\t      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n \n \t      TyTy::BaseType *self = nullptr;\n \t      bool ok = ctx->get_tyctx ()->lookup_type (\n \t\timpl->get_type ()->get_mappings ().get_hirid (), &self);\n \t      rust_assert (ok);\n \n \t      if (!lookup->has_subsititions_defined ())\n-\t\tCompileInherentImplItem::Compile (self, resolved_item, ctx,\n-\t\t\t\t\t\t  true);\n+\t\treturn CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t\t true, nullptr, true,\n+\t\t\t\t\t\t\t expr_locus);\n \t      else\n-\t\tCompileInherentImplItem::Compile (self, resolved_item, ctx,\n-\t\t\t\t\t\t  true, lookup);\n-\t    }\n-\t}\n+\t\treturn CompileInherentImplItem::Compile (self, impl_item, ctx,\n+\t\t\t\t\t\t\t true, lookup, true,\n+\t\t\t\t\t\t\t expr_locus);\n \n-      if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n-\t{\n-\t  resolved = ctx->get_backend ()->error_expression ();\n-\t  rust_error_at (expr_locus, \"forward declaration was not compiled\");\n-\t  return;\n+\t      lookup->set_ty_ref (impl_item->get_impl_mappings ().get_hirid ());\n+\t    }\n \t}\n     }\n \n-  resolved = ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+  return ctx->get_backend ()->error_expression ();\n }\n \n } // namespace Compile"}, {"sha": "2b50ec13fa18e7b344df8b7ec8e1dd1ac9e9dca9", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -54,9 +54,14 @@ class ResolvePathRef : public HIRCompileBase\n     : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n   {}\n \n-  void resolve (const HIR::PathIdentSegment &final_segment,\n-\t\tconst Analysis::NodeMapping &mappings, Location locus,\n-\t\tbool is_qualified_path);\n+  Bexpression *resolve (const HIR::PathIdentSegment &final_segment,\n+\t\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\t\tbool is_qualified_path);\n+\n+  Bexpression *query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t\t      const HIR::PathIdentSegment &final_segment,\n+\t\t\t      const Analysis::NodeMapping &mappings,\n+\t\t\t      Location expr_locus, bool is_qualified_path);\n \n   Bexpression *resolved;\n };"}, {"sha": "9d79b36c3688cbcf92ed99b56df57b61deaad61c", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -225,9 +225,6 @@ Resolver::lookup_definition (NodeId id, Definition *def)\n void\n Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n {\n-  auto it = resolved_names.find (refId);\n-  rust_assert (it == resolved_names.end ());\n-\n   resolved_names[refId] = defId;\n   get_name_scope ().append_reference_for_def (refId, defId);\n }"}, {"sha": "60cd98a5e5edde933ad860342057bf12ea708ea6", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -114,6 +114,7 @@ struct PathProbeCandidate\n \n class PathProbeType : public TypeCheckBase\n {\n+protected:\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n@@ -207,7 +208,7 @@ class PathProbeType : public TypeCheckBase\n       }\n   }\n \n-private:\n+protected:\n   void process_impl_items_for_candidates ()\n   {\n     mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n@@ -313,7 +314,7 @@ class PathProbeType : public TypeCheckBase\n       }\n   }\n \n-private:\n+protected:\n   PathProbeType (const TyTy::BaseType *receiver,\n \t\t const HIR::PathIdentSegment &query)\n     : TypeCheckBase (), receiver (receiver), search (query),\n@@ -404,6 +405,33 @@ class ReportMultipleCandidateError : private TypeCheckBase\n   RichLocation &r;\n };\n \n+class PathProbeImplTrait : public PathProbeType\n+{\n+public:\n+  static std::vector<PathProbeCandidate>\n+  Probe (const TyTy::BaseType *receiver,\n+\t const HIR::PathIdentSegment &segment_name,\n+\t const TraitReference *trait_reference)\n+  {\n+    PathProbeImplTrait probe (receiver, segment_name, trait_reference);\n+    // iterate all impls for this trait and receiver\n+    // then search for possible candidates using base class behaviours\n+    probe.process_trait_impl_items_for_candidates ();\n+    return probe.candidates;\n+  }\n+\n+private:\n+  void process_trait_impl_items_for_candidates ();\n+\n+  PathProbeImplTrait (const TyTy::BaseType *receiver,\n+\t\t      const HIR::PathIdentSegment &query,\n+\t\t      const TraitReference *trait_reference)\n+    : PathProbeType (receiver, query), trait_reference (trait_reference)\n+  {}\n+\n+  const TraitReference *trait_reference;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "c86892e79775a0ea196d00e262c807bdc9425186", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -335,6 +335,13 @@ class TraitReference\n       }\n   }\n \n+  bool is_equal (const TraitReference &other) const\n+  {\n+    DefId this_id = get_mappings ().get_defid ();\n+    DefId other_id = other.get_mappings ().get_defid ();\n+    return this_id == other_id;\n+  }\n+\n private:\n   const HIR::Trait *hir_trait_ref;\n   std::vector<TraitItemReference> item_refs;"}, {"sha": "aeedf7eb13a7d448138ab6d32391599529b29982", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -227,5 +227,27 @@ AssociatedImplTrait::get_projected_type (\n   return trait_item_tyty;\n }\n \n+// rust-hir-path-probe.h\n+\n+void\n+PathProbeImplTrait::process_trait_impl_items_for_candidates ()\n+{\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      // just need to check if this is an impl block for this trait the next\n+      // function checks the receiver\n+      if (!impl->has_trait_ref ())\n+\treturn true;\n+\n+      TraitReference *resolved\n+\t= TraitResolver::Lookup (*(impl->get_trait_ref ().get ()));\n+      if (!trait_reference->is_equal (*resolved))\n+\treturn true;\n+\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "0fe240650c217820e66321b4626c1171d871ade0", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -72,6 +72,12 @@ class TraitResolver : public TypeCheckBase\n     return resolver.go (path);\n   }\n \n+  static TraitReference *Lookup (HIR::TypePath &path)\n+  {\n+    TraitResolver resolver;\n+    return resolver.lookup_path (path);\n+  }\n+\n private:\n   TraitResolver () : TypeCheckBase () {}\n \n@@ -162,6 +168,40 @@ class TraitResolver : public TypeCheckBase\n     return tref;\n   }\n \n+  TraitReference *lookup_path (HIR::TypePath &path)\n+  {\n+    NodeId ref;\n+    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t\t &ref))\n+      {\n+\trust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n+\treturn &TraitReference::error_node ();\n+      }\n+\n+    HirId hir_node = UNKNOWN_HIRID;\n+    if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n+\t\t\t\t       &hir_node))\n+      {\n+\trust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n+\treturn &TraitReference::error_node ();\n+      }\n+\n+    HIR::Item *resolved_item\n+      = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n+\n+    rust_assert (resolved_item != nullptr);\n+    resolved_item->accept_vis (*this);\n+    rust_assert (trait_reference != nullptr);\n+\n+    TraitReference *tref = &TraitReference::error_node ();\n+    if (context->lookup_trait_reference (\n+\t  trait_reference->get_mappings ().get_defid (), &tref))\n+      {\n+\treturn tref;\n+      }\n+    return &TraitReference::error_node ();\n+  }\n+\n   HIR::Trait *trait_reference;\n \n public:"}, {"sha": "a95a4e91c787767033bfd3250677332c4726837c", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 5, "deletions": 429, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -925,169 +925,9 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = resolved->get_field_type ();\n   }\n \n-  void visit (HIR::QualifiedPathInExpression &expr) override\n-  {\n-    HIR::QualifiedPathType qual_path_type = expr.get_path_type ();\n-    TyTy::BaseType *root\n-      = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n-    if (root->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    if (!qual_path_type.has_as_clause ())\n-      {\n-\t// then this is just a normal path-in-expression\n-\tNodeId root_resolved_node_id = UNKNOWN_NODEID;\n-\tbool ok = resolver->lookup_resolved_type (\n-\t  qual_path_type.get_type ()->get_mappings ().get_nodeid (),\n-\t  &root_resolved_node_id);\n-\trust_assert (ok);\n-\n-\tresolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n-\t\t\t  expr.get_mappings (), expr.get_locus ());\n-      }\n-\n-    // Resolve the trait now\n-    TraitReference *trait_ref\n-      = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n-    if (trait_ref->is_error ())\n-      return;\n-\n-    // does this type actually implement this type-bound?\n-    if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n-      return;\n-\n-    // then we need to look at the next segment to create perform the correct\n-    // projection type\n-    if (expr.get_segments ().empty ())\n-      return;\n-\n-    // we need resolve to the impl block\n-    NodeId impl_resolved_id = UNKNOWN_NODEID;\n-    bool ok = resolver->lookup_resolved_name (\n-      qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n-    rust_assert (ok);\n-\n-    HirId impl_block_id;\n-    ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       impl_resolved_id, &impl_block_id);\n-    rust_assert (ok);\n-\n-    AssociatedImplTrait *lookup_associated = nullptr;\n-    bool found_impl_trait\n-      = context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t       &lookup_associated);\n-    rust_assert (found_impl_trait);\n-\n-    DefId resolved_item_id = UNKNOWN_DEFID;\n-    HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n-\n-    const TraitItemReference *trait_item_ref = nullptr;\n-    ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n-\t\t\t\t       &trait_item_ref);\n-    if (!ok)\n-      {\n-\trust_error_at (item_seg.get_locus (), \"unknown associated item\");\n-\treturn;\n-      }\n-    resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n-\n-    infered = lookup_associated->get_projected_type (\n-      trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n-      item_seg.get_locus ());\n-\n-    // turbo-fish segment path::<ty>\n-    if (item_seg.has_generic_args ())\n-      {\n-\tif (!infered->can_substitute ())\n-\t  {\n-\t    rust_error_at (item_seg.get_locus (),\n-\t\t\t   \"substitutions not supported for %s\",\n-\t\t\t   infered->as_string ().c_str ());\n-\t    infered = new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    return;\n-\t  }\n-\tinfered = SubstMapper::Resolve (infered, expr.get_locus (),\n-\t\t\t\t\t&item_seg.get_generic_args ());\n-      }\n-\n-    TyTy::ProjectionType *projection\n-      = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n-\t\t\t\t  TyTy::TyVar (root->get_ref ()), trait_ref,\n-\t\t\t\t  resolved_item_id, lookup_associated);\n-    context->insert_type (qual_path_type.get_mappings (), projection);\n-\n-    // continue on as a path-in-expression\n-    NodeId root_resolved_node_id\n-      = trait_item_ref->get_mappings ().get_nodeid ();\n-    bool fully_resolved = expr.get_segments ().size () <= 1;\n-\n-    if (fully_resolved)\n-      {\n-\t// lookup if the name resolver was able to canonically resolve this or\n-\t// not\n-\tNodeId path_resolved_id = UNKNOWN_NODEID;\n-\tif (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t    &path_resolved_id))\n-\t  {\n-\t    rust_assert (path_resolved_id == root_resolved_node_id);\n-\t  }\n-\t// check the type scope\n-\telse if (resolver->lookup_resolved_type (\n-\t\t   expr.get_mappings ().get_nodeid (), &path_resolved_id))\n-\t  {\n-\t    rust_assert (path_resolved_id == root_resolved_node_id);\n-\t  }\n-\telse\n-\t  {\n-\t    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t    root_resolved_node_id);\n-\t  }\n-\n-\tcontext->insert_receiver (expr.get_mappings ().get_hirid (), root);\n-\treturn;\n-      }\n-\n-    resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n-\t\t      expr.get_mappings (), expr.get_locus ());\n-  }\n-\n-  void visit (HIR::PathInExpression &expr) override\n-  {\n-    NodeId resolved_node_id = UNKNOWN_NODEID;\n-\n-    size_t offset = -1;\n-    TyTy::BaseType *tyseg\n-      = resolve_root_path (expr, &offset, &resolved_node_id);\n-\n-    if (tyseg == nullptr)\n-      {\n-\trust_debug_loc (expr.get_locus (), \"failed to resolve root_seg\");\n-      }\n-    rust_assert (tyseg != nullptr);\n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n \n-    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    if (expr.get_num_segments () == 1)\n-      {\n-\tLocation locus = expr.get_segments ().back ().get_locus ();\n-\n-\tbool is_big_self\n-\t  = expr.get_segments ().front ().get_segment ().as_string ().compare (\n-\t      \"Self\")\n-\t    == 0;\n-\tif (!is_big_self && tyseg->needs_generic_substitutions ())\n-\t  {\n-\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t  }\n-\n-\tinfered = tyseg;\n-\treturn;\n-      }\n-\n-    resolve_segments (resolved_node_id, expr.get_segments (), offset, tyseg,\n-\t\t      expr.get_mappings (), expr.get_locus ());\n-  }\n+  void visit (HIR::PathInExpression &expr) override;\n \n   void visit (HIR::LoopExpr &expr) override\n   {\n@@ -1235,277 +1075,13 @@ class TypeCheckExpr : public TypeCheckBase\n   // Beware: currently returns Tyty::ErrorType or nullptr in case of error.\n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n \t\t\t\t     size_t *offset,\n-\t\t\t\t     NodeId *root_resolved_node_id)\n-  {\n-    TyTy::BaseType *root_tyty = nullptr;\n-    *offset = 0;\n-    for (size_t i = 0; i < expr.get_num_segments (); i++)\n-      {\n-\tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n-\n-\tbool have_more_segments = (expr.get_num_segments () - 1 != i);\n-\tbool is_root = *offset == 0;\n-\tNodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n-\n-\t// then lookup the reference_node_id\n-\tNodeId ref_node_id = UNKNOWN_NODEID;\n-\tif (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-\t  {\n-\t    // these ref_node_ids will resolve to a pattern declaration but we\n-\t    // are interested in the definition that this refers to get the\n-\t    // parent id\n-\t    Definition def;\n-\t    if (!resolver->lookup_definition (ref_node_id, &def))\n-\t      {\n-\t\trust_error_at (expr.get_locus (),\n-\t\t\t       \"unknown reference for resolved name\");\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\t    ref_node_id = def.parent;\n-\t  }\n-\telse\n-\t  {\n-\t    resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n-\t  }\n-\n-\t// ref_node_id is the NodeId that the segments refers to.\n-\tif (ref_node_id == UNKNOWN_NODEID)\n-\t  {\n-\t    if (is_root)\n-\t      {\n-\t\trust_error_at (seg.get_locus (),\n-\t\t\t       \"failed to type resolve root segment\");\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\t    return root_tyty;\n-\t  }\n-\n-\t// node back to HIR\n-\tHirId ref;\n-\tif (!mappings->lookup_node_to_hir (\n-\t      expr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n-\t  {\n-\t    if (is_root)\n-\t      {\n-\t\trust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n-\t\trust_debug_loc (\n-\t\t  seg.get_locus (),\n-\t\t  \"failure with [%s] mappings [%s] ref_node_id [%u]\",\n-\t\t  seg.as_string ().c_str (),\n-\t\t  seg.get_mappings ().as_string ().c_str (), ref_node_id);\n-\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\n-\t    return root_tyty;\n-\t  }\n-\n-\tauto seg_is_module\n-\t  = (nullptr\n-\t     != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t\t ref));\n-\n-\tif (seg_is_module)\n-\t  {\n-\t    // A::B::C::this_is_a_module::D::E::F\n-\t    //          ^^^^^^^^^^^^^^^^\n-\t    //          Currently handling this.\n-\t    if (have_more_segments)\n-\t      {\n-\t\t(*offset)++;\n-\t\tcontinue;\n-\t      }\n-\n-\t    // In the case of :\n-\t    // A::B::C::this_is_a_module\n-\t    //          ^^^^^^^^^^^^^^^^\n-\t    // This is an error, we are not expecting a module.\n-\t    rust_error_at (seg.get_locus (), \"expected value\");\n-\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t  }\n-\n-\tTyTy::BaseType *lookup = nullptr;\n-\tif (!context->lookup_type (ref, &lookup))\n-\t  {\n-\t    if (is_root)\n-\t      {\n-\t\trust_error_at (seg.get_locus (),\n-\t\t\t       \"failed to resolve root segment\");\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\t    return root_tyty;\n-\t  }\n-\n-\t// if we have a previous segment type\n-\tif (root_tyty != nullptr)\n-\t  {\n-\t    // if this next segment needs substitution we must apply the\n-\t    // previous type arguments\n-\t    //\n-\t    // such as: GenericStruct::<_>::new(123, 456)\n-\t    if (lookup->needs_generic_substitutions ())\n-\t      {\n-\t\tif (!root_tyty->needs_generic_substitutions ())\n-\t\t  {\n-\t\t    auto used_args_in_prev_segment\n-\t\t      = GetUsedSubstArgs::From (root_tyty);\n-\t\t    lookup = SubstMapperInternal::Resolve (\n-\t\t      lookup, used_args_in_prev_segment);\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\t// turbo-fish segment path::<ty>\n-\tif (seg.has_generic_args ())\n-\t  {\n-\t    if (!lookup->can_substitute ())\n-\t      {\n-\t\trust_error_at (seg.get_locus (),\n-\t\t\t       \"substitutions not supported for %s\",\n-\t\t\t       lookup->as_string ().c_str ());\n-\t\treturn new TyTy::ErrorType (lookup->get_ref ());\n-\t      }\n-\t    lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n-\t\t\t\t\t   &seg.get_generic_args ());\n-\t  }\n-\n-\t*root_resolved_node_id = ref_node_id;\n-\t*offset = *offset + 1;\n-\troot_tyty = lookup;\n-      }\n-\n-    return root_tyty;\n-  }\n+\t\t\t\t     NodeId *root_resolved_node_id);\n \n   void resolve_segments (NodeId root_resolved_node_id,\n \t\t\t std::vector<HIR::PathExprSegment> &segments,\n \t\t\t size_t offset, TyTy::BaseType *tyseg,\n \t\t\t const Analysis::NodeMapping &expr_mappings,\n-\t\t\t Location expr_locus)\n-  {\n-    NodeId resolved_node_id = root_resolved_node_id;\n-    TyTy::BaseType *prev_segment = tyseg;\n-    for (size_t i = offset; i < segments.size (); i++)\n-      {\n-\tHIR::PathExprSegment &seg = segments.at (i);\n-\n-\tbool reciever_is_generic\n-\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool probe_bounds = true;\n-\tbool probe_impls = !reciever_is_generic;\n-\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n-\n-\t// probe the path\n-\tauto candidates\n-\t  = PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n-\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n-\tif (candidates.size () == 0)\n-\t  {\n-\t    rust_error_at (\n-\t      seg.get_locus (),\n-\t      \"failed to resolve path segment using an impl Probe\");\n-\t    return;\n-\t  }\n-\telse if (candidates.size () > 1)\n-\t  {\n-\t    ReportMultipleCandidateError::Report (candidates,\n-\t\t\t\t\t\t  seg.get_segment (),\n-\t\t\t\t\t\t  seg.get_locus ());\n-\t    return;\n-\t  }\n-\n-\tauto &candidate = candidates.at (0);\n-\tprev_segment = tyseg;\n-\ttyseg = candidate.ty;\n-\n-\tif (candidate.is_impl_candidate ())\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n-\t\t  .get_nodeid ();\n-\t  }\n-\telse\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n-\n-\t    // lookup the associated-impl-trait\n-\t    HIR::ImplBlock *impl = candidate.item.trait.impl;\n-\t    if (impl != nullptr)\n-\t      {\n-\t\tAssociatedImplTrait *lookup_associated = nullptr;\n-\t\tbool found_impl_trait = context->lookup_associated_trait_impl (\n-\t\t  impl->get_mappings ().get_hirid (), &lookup_associated);\n-\t\trust_assert (found_impl_trait);\n-\n-\t\tlookup_associated->setup_associated_types ();\n-\n-\t\t// we need a new ty_ref_id for this trait item\n-\t\ttyseg = tyseg->clone ();\n-\t\ttyseg->set_ty_ref (mappings->get_next_hir_id ());\n-\t      }\n-\t  }\n-\n-\tif (seg.has_generic_args ())\n-\t  {\n-\t    if (!tyseg->can_substitute ())\n-\t      {\n-\t\trust_error_at (expr_locus, \"substitutions not supported for %s\",\n-\t\t\t       tyseg->as_string ().c_str ());\n-\t\treturn;\n-\t      }\n-\n-\t    tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n-\t\t\t\t\t  &seg.get_generic_args ());\n-\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-      }\n-\n-    context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n-    if (tyseg->needs_generic_substitutions ())\n-      {\n-\tLocation locus = segments.back ().get_locus ();\n-\tif (!prev_segment->needs_generic_substitutions ())\n-\t  {\n-\t    auto used_args_in_prev_segment\n-\t      = GetUsedSubstArgs::From (prev_segment);\n-\t    if (!used_args_in_prev_segment.is_error ())\n-\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n-\t\t\t\t\t\t    used_args_in_prev_segment);\n-\t  }\n-\telse\n-\t  {\n-\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t  }\n-\n-\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-\n-    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n-\n-    // lookup if the name resolver was able to canonically resolve this or not\n-    NodeId path_resolved_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n-\t\t\t\t\t&path_resolved_id))\n-      {\n-\trust_assert (path_resolved_id == resolved_node_id);\n-      }\n-    // check the type scope\n-    else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n-\t\t\t\t\t     &path_resolved_id))\n-      {\n-\trust_assert (path_resolved_id == resolved_node_id);\n-      }\n-    else\n-      {\n-\tresolver->insert_resolved_name (expr_mappings.get_nodeid (),\n-\t\t\t\t\tresolved_node_id);\n-      }\n-\n-    infered = tyseg;\n-  }\n+\t\t\t Location expr_locus);\n \n   bool\n   validate_arithmetic_type (TyTy::BaseType *type,\n@@ -1569,7 +1145,7 @@ class TypeCheckExpr : public TypeCheckBase\n   Location root_array_expr_locus;\n \n   bool inside_loop;\n-}; // namespace Resolver\n+};\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "7b0e8aecb9c9f72e1203e804fe5d77fcae40d53e", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -0,0 +1,452 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  HIR::QualifiedPathType qual_path_type = expr.get_path_type ();\n+  TyTy::BaseType *root\n+    = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+  if (root->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  if (!qual_path_type.has_as_clause ())\n+    {\n+      // then this is just a normal path-in-expression\n+      NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+      bool ok = resolver->lookup_resolved_type (\n+\tqual_path_type.get_type ()->get_mappings ().get_nodeid (),\n+\t&root_resolved_node_id);\n+      rust_assert (ok);\n+\n+      resolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n+\t\t\texpr.get_mappings (), expr.get_locus ());\n+    }\n+\n+  // Resolve the trait now\n+  TraitReference *trait_ref\n+    = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+  if (trait_ref->is_error ())\n+    return;\n+\n+  // does this type actually implement this type-bound?\n+  if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n+    return;\n+\n+  // then we need to look at the next segment to create perform the correct\n+  // projection type\n+  if (expr.get_segments ().empty ())\n+    return;\n+\n+  // we need resolve to the impl block\n+  NodeId impl_resolved_id = UNKNOWN_NODEID;\n+  bool ok = resolver->lookup_resolved_name (\n+    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  rust_assert (ok);\n+\n+  HirId impl_block_id;\n+  ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t     impl_resolved_id, &impl_block_id);\n+  rust_assert (ok);\n+\n+  AssociatedImplTrait *lookup_associated = nullptr;\n+  bool found_impl_trait\n+    = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n+  rust_assert (found_impl_trait);\n+\n+  DefId resolved_item_id = UNKNOWN_DEFID;\n+  HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n+\n+  const TraitItemReference *trait_item_ref = nullptr;\n+  ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n+\t\t\t\t     &trait_item_ref);\n+  if (!ok)\n+    {\n+      rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n+      return;\n+    }\n+  resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n+\n+  infered = lookup_associated->get_projected_type (\n+    trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n+    item_seg.get_locus ());\n+\n+  // turbo-fish segment path::<ty>\n+  if (item_seg.has_generic_args ())\n+    {\n+      if (!infered->can_substitute ())\n+\t{\n+\t  rust_error_at (item_seg.get_locus (),\n+\t\t\t \"substitutions not supported for %s\",\n+\t\t\t infered->as_string ().c_str ());\n+\t  infered = new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t  return;\n+\t}\n+      infered = SubstMapper::Resolve (infered, expr.get_locus (),\n+\t\t\t\t      &item_seg.get_generic_args ());\n+    }\n+\n+  TyTy::ProjectionType *projection\n+    = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n+\t\t\t\tTyTy::TyVar (root->get_ref ()), trait_ref,\n+\t\t\t\tresolved_item_id, lookup_associated);\n+  context->insert_type (qual_path_type.get_mappings (), projection);\n+\n+  // continue on as a path-in-expression\n+  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n+  bool fully_resolved = expr.get_segments ().size () <= 1;\n+\n+  if (fully_resolved)\n+    {\n+      resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t      root_resolved_node_id);\n+      context->insert_receiver (expr.get_mappings ().get_hirid (), root);\n+      return;\n+    }\n+\n+  resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n+\t\t    expr.get_mappings (), expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::PathInExpression &expr)\n+{\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+\n+  size_t offset = -1;\n+  TyTy::BaseType *tyseg = resolve_root_path (expr, &offset, &resolved_node_id);\n+\n+  if (tyseg == nullptr)\n+    {\n+      rust_debug_loc (expr.get_locus (), \"failed to resolve root_seg\");\n+    }\n+  rust_assert (tyseg != nullptr);\n+\n+  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  if (expr.get_num_segments () == 1)\n+    {\n+      Location locus = expr.get_segments ().back ().get_locus ();\n+\n+      bool is_big_self\n+\t= expr.get_segments ().front ().get_segment ().as_string ().compare (\n+\t    \"Self\")\n+\t  == 0;\n+      if (!is_big_self && tyseg->needs_generic_substitutions ())\n+\t{\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t}\n+\n+      infered = tyseg;\n+      return;\n+    }\n+\n+  resolve_segments (resolved_node_id, expr.get_segments (), offset, tyseg,\n+\t\t    expr.get_mappings (), expr.get_locus ());\n+}\n+\n+TyTy::BaseType *\n+TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n+\t\t\t\t  NodeId *root_resolved_node_id)\n+{\n+  TyTy::BaseType *root_tyty = nullptr;\n+  *offset = 0;\n+  for (size_t i = 0; i < expr.get_num_segments (); i++)\n+    {\n+      HIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\n+      bool have_more_segments = (expr.get_num_segments () - 1 != i);\n+      bool is_root = *offset == 0;\n+      NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n+\n+      // then lookup the reference_node_id\n+      NodeId ref_node_id = UNKNOWN_NODEID;\n+      if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+\t{\n+\t  // these ref_node_ids will resolve to a pattern declaration but we\n+\t  // are interested in the definition that this refers to get the\n+\t  // parent id\n+\t  Definition def;\n+\t  if (!resolver->lookup_definition (ref_node_id, &def))\n+\t    {\n+\t      rust_error_at (expr.get_locus (),\n+\t\t\t     \"unknown reference for resolved name\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  ref_node_id = def.parent;\n+\t}\n+      else\n+\t{\n+\t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+\t}\n+\n+      // ref_node_id is the NodeId that the segments refers to.\n+      if (ref_node_id == UNKNOWN_NODEID)\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"failed to type resolve root segment\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // node back to HIR\n+      HirId ref;\n+      if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t\t ref_node_id, &ref))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n+\t      rust_debug_loc (\n+\t\tseg.get_locus (),\n+\t\t\"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\tseg.as_string ().c_str (),\n+\t\tseg.get_mappings ().as_string ().c_str (), ref_node_id);\n+\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\n+\t  return root_tyty;\n+\t}\n+\n+      auto seg_is_module\n+\t= (nullptr\n+\t   != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref));\n+\n+      if (seg_is_module)\n+\t{\n+\t  // A::B::C::this_is_a_module::D::E::F\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  //          Currently handling this.\n+\t  if (have_more_segments)\n+\t    {\n+\t      (*offset)++;\n+\t      continue;\n+\t    }\n+\n+\t  // In the case of :\n+\t  // A::B::C::this_is_a_module\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  // This is an error, we are not expecting a module.\n+\t  rust_error_at (seg.get_locus (), \"expected value\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t}\n+\n+      TyTy::BaseType *lookup = nullptr;\n+      if (!context->lookup_type (ref, &lookup))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"failed to resolve root segment\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // if we have a previous segment type\n+      if (root_tyty != nullptr)\n+\t{\n+\t  // if this next segment needs substitution we must apply the\n+\t  // previous type arguments\n+\t  //\n+\t  // such as: GenericStruct::<_>::new(123, 456)\n+\t  if (lookup->needs_generic_substitutions ())\n+\t    {\n+\t      if (!root_tyty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  auto used_args_in_prev_segment\n+\t\t    = GetUsedSubstArgs::From (root_tyty);\n+\t\t  lookup\n+\t\t    = SubstMapperInternal::Resolve (lookup,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t\t}\n+\t    }\n+\t}\n+\n+      // turbo-fish segment path::<ty>\n+      if (seg.has_generic_args ())\n+\t{\n+\t  if (!lookup->can_substitute ())\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     lookup->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (lookup->get_ref ());\n+\t    }\n+\t  lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t\t\t\t\t &seg.get_generic_args ());\n+\t}\n+\n+      *root_resolved_node_id = ref_node_id;\n+      *offset = *offset + 1;\n+      root_tyty = lookup;\n+    }\n+\n+  return root_tyty;\n+}\n+\n+void\n+TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n+\t\t\t\t std::vector<HIR::PathExprSegment> &segments,\n+\t\t\t\t size_t offset, TyTy::BaseType *tyseg,\n+\t\t\t\t const Analysis::NodeMapping &expr_mappings,\n+\t\t\t\t Location expr_locus)\n+{\n+  NodeId resolved_node_id = root_resolved_node_id;\n+  TyTy::BaseType *prev_segment = tyseg;\n+  for (size_t i = offset; i < segments.size (); i++)\n+    {\n+      HIR::PathExprSegment &seg = segments.at (i);\n+\n+      bool reciever_is_generic\n+\t= prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+      bool probe_bounds = true;\n+      bool probe_impls = !reciever_is_generic;\n+      bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+      // probe the path is done in two parts one where we search impls if no\n+      // candidate is found then we search extensions from traits\n+      auto candidates\n+\t= PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n+\t\t\t\tfalse, ignore_mandatory_trait_items);\n+      if (candidates.size () == 0)\n+\t{\n+\t  candidates\n+\t    = PathProbeType::Probe (prev_segment, seg.get_segment (), false,\n+\t\t\t\t    probe_bounds, ignore_mandatory_trait_items);\n+\t  if (candidates.size () == 0)\n+\t    {\n+\t      rust_error_at (\n+\t\tseg.get_locus (),\n+\t\t\"failed to resolve path segment using an impl Probe\");\n+\t      return;\n+\t    }\n+\t}\n+\n+      if (candidates.size () > 1)\n+\t{\n+\t  ReportMultipleCandidateError::Report (candidates, seg.get_segment (),\n+\t\t\t\t\t\tseg.get_locus ());\n+\t  return;\n+\t}\n+\n+      auto &candidate = candidates.at (0);\n+      prev_segment = tyseg;\n+      tyseg = candidate.ty;\n+\n+      if (candidate.is_impl_candidate ())\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();\n+\t}\n+      else\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+\t  // lookup the associated-impl-trait\n+\t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n+\t  if (impl != nullptr)\n+\t    {\n+\t      AssociatedImplTrait *lookup_associated = nullptr;\n+\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n+\t      rust_assert (found_impl_trait);\n+\n+\t      lookup_associated->setup_associated_types ();\n+\n+\t      // we need a new ty_ref_id for this trait item\n+\t      tyseg = tyseg->clone ();\n+\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n+\t    }\n+\t}\n+\n+      if (seg.has_generic_args ())\n+\t{\n+\t  if (!tyseg->can_substitute ())\n+\t    {\n+\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t     tyseg->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\n+\t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t&seg.get_generic_args ());\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n+\t}\n+    }\n+\n+  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+  if (tyseg->needs_generic_substitutions ())\n+    {\n+      Location locus = segments.back ().get_locus ();\n+      if (!prev_segment->needs_generic_substitutions ())\n+\t{\n+\t  auto used_args_in_prev_segment\n+\t    = GetUsedSubstArgs::From (prev_segment);\n+\t  if (!used_args_in_prev_segment.is_error ())\n+\t    tyseg\n+\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n+\t}\n+      else\n+\t{\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t}\n+\n+      if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+\n+  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+  // lookup if the name resolver was able to canonically resolve this or not\n+  NodeId path_resolved_id = UNKNOWN_NODEID;\n+  if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  // check the type scope\n+  else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t   &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  else\n+    {\n+      resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      resolved_node_id);\n+    }\n+\n+  infered = tyseg;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "c96615fa891fc0a6c4f5dd6f5dc82fc8d507a460", "filename": "gcc/testsuite/rust/execute/torture/trait2.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3be517de2c0ec596eeee754b863243cb071098/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait2.rs?ref=ac3be517de2c0ec596eeee754b863243cb071098", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-output \"Bar::A = 456\\n<Foo as Bar>::A = 456\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait Foo {\n+    const A: i32 = 123;\n+}\n+\n+struct Bar;\n+impl Foo for Bar {\n+    const A: i32 = 456;\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Bar::A;\n+\n+    unsafe {\n+        let _a = \"Bar::A = %i\\n\\0\";\n+        let _b = _a as *const str;\n+        let _c = _b as *const i8;\n+        printf(_c, a);\n+    }\n+\n+    let b;\n+    b = <Bar as Foo>::A;\n+\n+    unsafe {\n+        let _a = \"<Foo as Bar>::A = %i\\n\\0\";\n+        let _b = _a as *const str;\n+        let _c = _b as *const i8;\n+        printf(_c, b);\n+    }\n+\n+    0\n+}"}]}