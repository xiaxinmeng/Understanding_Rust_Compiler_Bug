{"sha": "3cad5f64a81355feef936483251875ab9a7900a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NhZDVmNjRhODEzNTVmZWVmOTM2NDgzMjUxODc1YWI5YTc5MDBhNg==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2015-06-19T22:58:58Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2015-06-19T22:58:58Z"}, "message": "re PR target/66591 ([SH] ICE: in get_reload_reg, at lra-constraints.c:633 with -mlra)\n\nPR target/66591\n* config/sh/sh.c (prepare_move_operands): Pre-allocate R0 for subreg\n  index term for base and index addressing when LRA is used.\n\nFrom-SVN: r224701", "tree": {"sha": "8a08b95aa317387d58a2280b13aa16585fbfd887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a08b95aa317387d58a2280b13aa16585fbfd887"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cad5f64a81355feef936483251875ab9a7900a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cad5f64a81355feef936483251875ab9a7900a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cad5f64a81355feef936483251875ab9a7900a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cad5f64a81355feef936483251875ab9a7900a6/comments", "author": null, "committer": null, "parents": [{"sha": "c1a569ef313db23d0563be35eefa05d4d7bde772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a569ef313db23d0563be35eefa05d4d7bde772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a569ef313db23d0563be35eefa05d4d7bde772"}], "stats": {"total": 28, "additions": 25, "deletions": 3}, "files": [{"sha": "3147eeb91e1b80c7540a2a13ce57e7f16e9797a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cad5f64a81355feef936483251875ab9a7900a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cad5f64a81355feef936483251875ab9a7900a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cad5f64a81355feef936483251875ab9a7900a6", "patch": "@@ -1,3 +1,9 @@\n+2015-06-19  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/66591\n+\t* config/sh/sh.c (prepare_move_operands): Replace subreg\n+\tindex term with R0 for base and index addressing.\n+\n 2015-06-19  Jim Wilson  <jim.wilson@linaro.org>\n \n \t* config/aarch64/aarch64.md (mov<mode>:GPF): Don't call force_reg if"}, {"sha": "6f03206ccb907ff232c5594cce7fc5b18d81320f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cad5f64a81355feef936483251875ab9a7900a6/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cad5f64a81355feef936483251875ab9a7900a6/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=3cad5f64a81355feef936483251875ab9a7900a6", "patch": "@@ -1775,18 +1775,23 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t target/55212.\n \t We split possible load/store to two move insns via r0 so as to\n \t shorten R0 live range.  It will make some codes worse but will\n-\t win on avarage for LRA.  */\n+\t win on average for LRA.\n+\t Also when base+index addressing is used and the index term is\n+\t a subreg, LRA assumes that more hard registers can be available\n+\t in some situation.  It isn't the case for SH in the problematic\n+\t case.  We can pre-allocate R0 for that index term to avoid\n+\t the issue.  See PR target/66591.  */\n       else if (sh_lra_p ()\n \t       && TARGET_SH1 && ! TARGET_SH2A\n-\t       && (mode == QImode || mode == HImode)\n \t       && ((REG_P (operands[0]) && MEM_P (operands[1]))\n \t\t   || (REG_P (operands[1]) && MEM_P (operands[0]))))\n \t{\n \t  bool load_p = REG_P (operands[0]);\n \t  rtx reg = operands[load_p ? 0 : 1];\n \t  rtx adr = XEXP (operands[load_p ? 1 : 0], 0);\n \n-\t  if (REGNO (reg) >= FIRST_PSEUDO_REGISTER\n+\t  if ((mode == QImode || mode == HImode)\n+\t      && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n \t      && GET_CODE (adr) == PLUS\n \t      && REG_P (XEXP (adr, 0))\n \t      && (REGNO (XEXP (adr, 0)) >= FIRST_PSEUDO_REGISTER)\n@@ -1798,6 +1803,17 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t      emit_move_insn (r0_rtx, operands[1]);\n \t      operands[1] = r0_rtx;\n \t    }\n+\t  if (REGNO (reg) >= FIRST_PSEUDO_REGISTER\n+\t      && GET_CODE (adr) == PLUS\n+\t      && REG_P (XEXP (adr, 0))\n+\t      && (REGNO (XEXP (adr, 0)) >= FIRST_PSEUDO_REGISTER)\n+\t      && SUBREG_P (XEXP (adr, 1))\n+\t      && REG_P (SUBREG_REG (XEXP (adr, 1))))\n+\t    {\n+\t      rtx r0_rtx = gen_rtx_REG (GET_MODE (XEXP (adr, 1)), R0_REG);\n+\t      emit_move_insn (r0_rtx, XEXP (adr, 1));\n+\t      XEXP (adr, 1) = r0_rtx;\n+\t    }\n \t}\n     }\n "}]}