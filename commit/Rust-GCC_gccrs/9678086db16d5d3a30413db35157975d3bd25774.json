{"sha": "9678086db16d5d3a30413db35157975d3bd25774", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY3ODA4NmRiMTZkNWQzYTMwNDEzZGIzNTE1Nzk3NWQzYmQyNTc3NA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-08-27T03:45:06Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-08-27T03:45:06Z"}, "message": "alias.c (memory_modified_1, [...]): Constify.\n\n\t* alias.c (memory_modified_1, memory_modified_in_insn_p):\n\tConstify.\n\t* basic-block.h (tree_predicted_by_p, rtl_predicted_by_p):\n\tLikewise.\n\t* bb-reorder.c (copy_bb_p): Likewise.\n\t* cfghooks.c (can_remove_branch_p, can_merge_blocks_p,\n\tpredicted_by_p, can_duplicate_block_p, block_ends_with_call_p,\n\tblock_ends_with_condjump_p): Likewise.\n\t* cfghooks.h (can_remove_branch_p, can_merge_blocks_p,\n\tpredicted_by_p, can_duplicate_block_p, block_ends_with_call_p,\n\tblock_ends_with_condjump_p): Likewise.\n\t* cfglayout.c (cfg_layout_can_duplicate_bb_p): Likewise.\n\t* cfgrtl.c (can_delete_note_p, can_delete_label_p,\n\trtl_can_merge_blocks, cfg_layout_can_merge_blocks_p,\n\trtl_block_ends_with_call_p, rtl_block_ends_with_condjump_p,\n\tneed_fake_edge_p, rtl_can_remove_branch_p): Likewise.\n\t* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Use\n\tdebug_true_const_tree instad of debug_true_tree.\n\t* debug.c (do_nothing_debug_hooks): Likewise.\n\t* debug.h (ignore_block, debug_true_const_tree): Constify.\n\t* dwarf2out.c (stack_adjust_offset, clobbers_queued_reg_save,\n\tdwarf2out_ignore_block, is_pseudo_reg, is_tagged_type,\n\tdecl_ultimate_origin, block_ultimate_origin, lookup_decl_loc,\n\tsame_dw_val_p, add_ranges, is_subrange_type, type_is_enum,\n\tdbx_reg_number, is_based_loc, field_type,\n\tsimple_type_align_in_bits, simple_decl_align_in_bits,\n\tsimple_type_size_in_bits, field_byte_offset, insert_float,\n\ttype_tag, member_declared_type, is_redundant_typedef,\n\tsecname_for_decl, is_inlined_entry_point): Likewise.\n\t* emit-rtl.c (const_next_insn, const_previous_insn,\n\tconst_next_nonnote_insn, const_prev_nonnote_insn,\n\tconst_next_real_insn, const_prev_real_insn,\n\tconst_next_active_insn, const_prev_active_insn, const_next_label,\n\tconst_prev_label): Likewise.\n\t* except.h (lookup_stmt_eh_region_fn, lookup_stmt_eh_region):\n\tLikewise.\n\t* haifa-sched.c (may_trap_exp, haifa_classify_insn,\n\tfind_set_reg_weight, no_real_insns_p, find_set_reg_weight,\n\tsched_insn_is_legitimate_for_speculation_p): Likewise.\n\t* jump.c (reversed_comparison_code_parts,\n\treversed_comparison_code, reversed_comparison, condjump_label):\n\tLikewise.\n\t* predict.c (rtl_predicted_by_p, tree_predicted_by_p): Likewise.\n\t* reg-stack.c (stack_regs_mentioned_p, stack_regs_mentioned):\n\tLikewise.\n\t* rtl.h (const_previous_insn, const_next_insn,\n\tconst_prev_nonnote_insn, const_next_nonnote_insn,\n\tconst_prev_real_insn, const_next_real_insn,\n\tconst_prev_active_insn, const_next_active_insn, const_prev_label,\n\tconst_next_label, modified_between_p, modified_in_p,\n\tconst_note_storeskeep_with_call_p, condjump_label,\n\treversed_comparison, reversed_comparison_code,\n\treversed_comparison_code_parts, memory_modified_in_insn_p,\n\tstack_regs_mentioned): Likewise.\n\t* rtlanal.c (modified_between_p, modified_in_p, const_note_stores,\n\tkeep_with_call_p): Likewise.\n\t* sched-deps.c (deps_may_trap_p, sched_get_condition,\n\tconditions_mutex_p, sched_insns_conditions_mutex_psd_next_list,\n\tsd_lists_size, sd_lists_empty_p): Likewise.\n\t* sched-int.h (sched_insns_conditions_mutex_p,\n\thaifa_classify_insn, no_real_insns_p,\n\tsched_insn_is_legitimate_for_speculation_p, sd_next_list,\n\tsd_lists_size, sd_lists_empty_p): Likewise.\n\t* sdbout.c (sdb_debug_hooks): Likewise.\n\t* tree-cfg.c (tree_can_merge_blocks_p, is_ctrl_altering_stmt,\n\tstmt_ends_bb_p, tree_can_remove_branch_p, tree_can_duplicate_bb_p,\n\t-tree_block_ends_with_call_p, tree_block_ends_with_condjump_p):\n\tLikewise.\n\t* tree-eh.c (lookup_stmt_eh_region_fn, lookup_stmt_eh_region,\n\ttree_can_throw_internal): Likewise.\n\t* tree-flow-inline.h (phi_nodes): Likewise.\n\t* tree-flow.h (phi_nodesstmt_ends_bb_p, is_ctrl_altering_stmt,\n\ttree_can_throw_internal, lookup_stmt_eh_region): Likewise.\n\t* tree-gimple.c (const_get_call_expr_in): Likewise.\n\t* tree-gimple.h (const_get_call_expr_in): Likewise.\n\t* tree.c (const_lookup_attribute, attribute_list_equal,\n\tattribute_list_contained): Likewise.\n\t* tree.h (attribute_list_equal, attribute_list_contained,\n\tconst_lookup_attribute): Likewise.\n\t* vmsdbgout.c (vmsdbgout_ignore_block): Likewise.\n\nFrom-SVN: r127824", "tree": {"sha": "8a5ea7b5e088c498bc8731f5ffea30732e00260f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a5ea7b5e088c498bc8731f5ffea30732e00260f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9678086db16d5d3a30413db35157975d3bd25774", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9678086db16d5d3a30413db35157975d3bd25774", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9678086db16d5d3a30413db35157975d3bd25774", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9678086db16d5d3a30413db35157975d3bd25774/comments", "author": null, "committer": null, "parents": [{"sha": "8a51fbfd2b68a886af6a672230fb3f47fdfa3bb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a51fbfd2b68a886af6a672230fb3f47fdfa3bb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a51fbfd2b68a886af6a672230fb3f47fdfa3bb9"}], "stats": {"total": 866, "additions": 551, "deletions": 315}, "files": [{"sha": "c41759d3236e3c876252e1ce54404285b9f64dab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -1,3 +1,86 @@\n+2007-08-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* alias.c (memory_modified_1, memory_modified_in_insn_p):\n+\tConstify.\n+\t* basic-block.h (tree_predicted_by_p, rtl_predicted_by_p):\n+\tLikewise.\n+\t* bb-reorder.c (copy_bb_p): Likewise.\n+\t* cfghooks.c (can_remove_branch_p, can_merge_blocks_p,\n+\tpredicted_by_p, can_duplicate_block_p, block_ends_with_call_p,\n+\tblock_ends_with_condjump_p): Likewise.\n+\t* cfghooks.h (can_remove_branch_p, can_merge_blocks_p,\n+\tpredicted_by_p, can_duplicate_block_p, block_ends_with_call_p,\n+\tblock_ends_with_condjump_p): Likewise.\n+\t* cfglayout.c (cfg_layout_can_duplicate_bb_p): Likewise.\n+\t* cfgrtl.c (can_delete_note_p, can_delete_label_p,\n+\trtl_can_merge_blocks, cfg_layout_can_merge_blocks_p,\n+\trtl_block_ends_with_call_p, rtl_block_ends_with_condjump_p,\n+\tneed_fake_edge_p, rtl_can_remove_branch_p): Likewise.\n+\t* dbxout.c (dbx_debug_hooks, xcoff_debug_hooks): Use\n+\tdebug_true_const_tree instad of debug_true_tree.\n+\t* debug.c (do_nothing_debug_hooks): Likewise.\n+\t* debug.h (ignore_block, debug_true_const_tree): Constify.\n+\t* dwarf2out.c (stack_adjust_offset, clobbers_queued_reg_save,\n+\tdwarf2out_ignore_block, is_pseudo_reg, is_tagged_type,\n+\tdecl_ultimate_origin, block_ultimate_origin, lookup_decl_loc,\n+\tsame_dw_val_p, add_ranges, is_subrange_type, type_is_enum,\n+\tdbx_reg_number, is_based_loc, field_type,\n+\tsimple_type_align_in_bits, simple_decl_align_in_bits,\n+\tsimple_type_size_in_bits, field_byte_offset, insert_float,\n+\ttype_tag, member_declared_type, is_redundant_typedef,\n+\tsecname_for_decl, is_inlined_entry_point): Likewise.\n+\t* emit-rtl.c (const_next_insn, const_previous_insn,\n+\tconst_next_nonnote_insn, const_prev_nonnote_insn,\n+\tconst_next_real_insn, const_prev_real_insn,\n+\tconst_next_active_insn, const_prev_active_insn, const_next_label,\n+\tconst_prev_label): Likewise.\n+\t* except.h (lookup_stmt_eh_region_fn, lookup_stmt_eh_region):\n+\tLikewise.\n+\t* haifa-sched.c (may_trap_exp, haifa_classify_insn,\n+\tfind_set_reg_weight, no_real_insns_p, find_set_reg_weight,\n+\tsched_insn_is_legitimate_for_speculation_p): Likewise.\n+\t* jump.c (reversed_comparison_code_parts,\n+\treversed_comparison_code, reversed_comparison, condjump_label):\n+\tLikewise.\n+\t* predict.c (rtl_predicted_by_p, tree_predicted_by_p): Likewise.\n+\t* reg-stack.c (stack_regs_mentioned_p, stack_regs_mentioned):\n+\tLikewise.\n+\t* rtl.h (const_previous_insn, const_next_insn,\n+\tconst_prev_nonnote_insn, const_next_nonnote_insn,\n+\tconst_prev_real_insn, const_next_real_insn,\n+\tconst_prev_active_insn, const_next_active_insn, const_prev_label,\n+\tconst_next_label, modified_between_p, modified_in_p,\n+\tconst_note_storeskeep_with_call_p, condjump_label,\n+\treversed_comparison, reversed_comparison_code,\n+\treversed_comparison_code_parts, memory_modified_in_insn_p,\n+\tstack_regs_mentioned): Likewise.\n+\t* rtlanal.c (modified_between_p, modified_in_p, const_note_stores,\n+\tkeep_with_call_p): Likewise.\n+\t* sched-deps.c (deps_may_trap_p, sched_get_condition,\n+\tconditions_mutex_p, sched_insns_conditions_mutex_psd_next_list,\n+\tsd_lists_size, sd_lists_empty_p): Likewise.\n+\t* sched-int.h (sched_insns_conditions_mutex_p,\n+\thaifa_classify_insn, no_real_insns_p,\n+\tsched_insn_is_legitimate_for_speculation_p, sd_next_list,\n+\tsd_lists_size, sd_lists_empty_p): Likewise.\n+\t* sdbout.c (sdb_debug_hooks): Likewise.\n+\t* tree-cfg.c (tree_can_merge_blocks_p, is_ctrl_altering_stmt,\n+\tstmt_ends_bb_p, tree_can_remove_branch_p, tree_can_duplicate_bb_p,\n+\t-tree_block_ends_with_call_p, tree_block_ends_with_condjump_p):\n+\tLikewise.\n+\t* tree-eh.c (lookup_stmt_eh_region_fn, lookup_stmt_eh_region,\n+\ttree_can_throw_internal): Likewise.\n+\t* tree-flow-inline.h (phi_nodes): Likewise.\n+\t* tree-flow.h (phi_nodesstmt_ends_bb_p, is_ctrl_altering_stmt,\n+\ttree_can_throw_internal, lookup_stmt_eh_region): Likewise.\n+\t* tree-gimple.c (const_get_call_expr_in): Likewise.\n+\t* tree-gimple.h (const_get_call_expr_in): Likewise.\n+\t* tree.c (const_lookup_attribute, attribute_list_equal,\n+\tattribute_list_contained): Likewise.\n+\t* tree.h (attribute_list_equal, attribute_list_contained,\n+\tconst_lookup_attribute): Likewise.\n+\t* vmsdbgout.c (vmsdbgout_ignore_block): Likewise.\n+\n 2007-08-26  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \t* tree-ssa-sccvn.c, tree-ssa-sccvn.h, tree-vn.c,"}, {"sha": "612139b3b0bbf8fe0a6656ea6a11e69165dd4284", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -167,7 +167,7 @@ static rtx adjust_offset_for_component_ref (tree, rtx);\n static int nonoverlapping_memrefs_p (const_rtx, const_rtx);\n static int write_dependence_p (const_rtx, const_rtx, int);\n \n-static void memory_modified_1 (rtx, const_rtx, void *);\n+static void memory_modified_1 (const_rtx, const_rtx, const void *);\n static void record_alias_subset (alias_set_type, alias_set_type);\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n@@ -2354,11 +2354,11 @@ init_alias_once (void)\n    to be memory reference.  */\n static bool memory_modified;\n static void\n-memory_modified_1 (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n+memory_modified_1 (const_rtx x, const_rtx pat ATTRIBUTE_UNUSED, const void *data)\n {\n   if (MEM_P (x))\n     {\n-      if (anti_dependence (x, (rtx)data) || output_dependence (x, (rtx)data))\n+      if (anti_dependence (x, (const_rtx)data) || output_dependence (x, (const_rtx)data))\n \tmemory_modified = true;\n     }\n }\n@@ -2367,12 +2367,12 @@ memory_modified_1 (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)\n /* Return true when INSN possibly modify memory contents of MEM\n    (i.e. address can be modified).  */\n bool\n-memory_modified_in_insn_p (rtx mem, rtx insn)\n+memory_modified_in_insn_p (const_rtx mem, const_rtx insn)\n {\n   if (!INSN_P (insn))\n     return false;\n   memory_modified = false;\n-  note_stores (PATTERN (insn), memory_modified_1, mem);\n+  const_note_stores (PATTERN (insn), memory_modified_1, mem);\n   return memory_modified;\n }\n "}, {"sha": "e2cd90211f1bc5021147f684d99f4ed168b4e9eb", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -830,8 +830,8 @@ extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n extern bool maybe_hot_bb_p (const_basic_block);\n extern bool probably_cold_bb_p (const_basic_block);\n extern bool probably_never_executed_bb_p (const_basic_block);\n-extern bool tree_predicted_by_p (basic_block, enum br_predictor);\n-extern bool rtl_predicted_by_p (basic_block, enum br_predictor);\n+extern bool tree_predicted_by_p (const_basic_block, enum br_predictor);\n+extern bool rtl_predicted_by_p (const_basic_block, enum br_predictor);\n extern void tree_predict_edge (edge, enum br_predictor, int);\n extern void rtl_predict_edge (edge, enum br_predictor, int);\n extern void predict_edge_def (edge, enum br_predictor, enum prediction);"}, {"sha": "9bf4086f5ae976faa09d8ae4f424c7056deb676b", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -176,7 +176,7 @@ static basic_block copy_bb (basic_block, edge, basic_block, int);\n static fibheapkey_t bb_to_key (basic_block);\n static bool better_edge_p (const_basic_block, const_edge, int, int, int, int, const_edge);\n static void connect_traces (int, struct trace *);\n-static bool copy_bb_p (basic_block, int);\n+static bool copy_bb_p (const_basic_block, int);\n static int get_uncond_jump_length (void);\n static bool push_to_next_round_p (const_basic_block, int, int, int, gcov_type);\n static void find_rarely_executed_basic_blocks_and_crossing_edges (edge **,\n@@ -1156,7 +1156,7 @@ connect_traces (int n_traces, struct trace *traces)\n    when code size is allowed to grow by duplication.  */\n \n static bool\n-copy_bb_p (basic_block bb, int code_may_grow)\n+copy_bb_p (const_basic_block bb, int code_may_grow)\n {\n   int size = 0;\n   int max_size = uncond_jump_length;"}, {"sha": "921bf6fe291e4836320ed5a9ded7c94ecc61ed70", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -321,7 +321,7 @@ redirect_edge_and_branch (edge e, basic_block dest)\n    to the destination of the other edge going from its source.  */\n \n bool\n-can_remove_branch_p (edge e)\n+can_remove_branch_p (const_edge e)\n {\n   if (!cfg_hooks->can_remove_branch_p)\n     internal_error (\"%s does not support can_remove_branch_p\",\n@@ -616,7 +616,7 @@ create_empty_bb (basic_block after)\n /* Checks whether we may merge blocks BB1 and BB2.  */\n \n bool\n-can_merge_blocks_p (basic_block bb1, basic_block bb2)\n+can_merge_blocks_p (const_basic_block bb1, const_basic_block bb2)\n {\n   bool ret;\n \n@@ -638,7 +638,7 @@ predict_edge (edge e, enum br_predictor predictor, int probability)\n }\n \n bool\n-predicted_by_p (basic_block bb, enum br_predictor predictor)\n+predicted_by_p (const_basic_block bb, enum br_predictor predictor)\n {\n   if (!cfg_hooks->predict_edge)\n     internal_error (\"%s does not support predicted_by_p\", cfg_hooks->name);\n@@ -839,7 +839,7 @@ tidy_fallthru_edges (void)\n /* Returns true if we can duplicate basic block BB.  */\n \n bool\n-can_duplicate_block_p (basic_block bb)\n+can_duplicate_block_p (const_basic_block bb)\n {\n   if (!cfg_hooks->can_duplicate_block_p)\n     internal_error (\"%s does not support can_duplicate_block_p\",\n@@ -938,7 +938,7 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n    instructions that must stay with the call, 0 otherwise.  */\n \n bool\n-block_ends_with_call_p (basic_block bb)\n+block_ends_with_call_p (const_basic_block bb)\n {\n   if (!cfg_hooks->block_ends_with_call_p)\n     internal_error (\"%s does not support block_ends_with_call_p\", cfg_hooks->name);\n@@ -949,7 +949,7 @@ block_ends_with_call_p (basic_block bb)\n /* Return 1 if BB ends with a conditional branch, 0 otherwise.  */\n \n bool\n-block_ends_with_condjump_p (basic_block bb)\n+block_ends_with_condjump_p (const_basic_block bb)\n {\n   if (!cfg_hooks->block_ends_with_condjump_p)\n     internal_error (\"%s does not support block_ends_with_condjump_p\","}, {"sha": "e305fd230ee7f2f54158742e731294f4eb2216ac", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -48,7 +48,7 @@ struct cfg_hooks\n \n   /* Returns true if it is possible to remove the edge by redirecting it\n      to the destination of the other edge going from its source.  */\n-  bool (*can_remove_branch_p) (edge);\n+  bool (*can_remove_branch_p) (const_edge);\n \n   /* Remove statements corresponding to a given basic block.  */\n   void (*delete_basic_block) (basic_block);\n@@ -61,7 +61,7 @@ struct cfg_hooks\n   bool (*move_block_after) (basic_block b, basic_block a);\n \n   /* Return true when blocks A and B can be merged into single basic block.  */\n-  bool (*can_merge_blocks_p) (basic_block a, basic_block b);\n+  bool (*can_merge_blocks_p) (const_basic_block a, const_basic_block b);\n \n   /* Merge blocks A and B.  */\n   void (*merge_blocks) (basic_block a, basic_block b);\n@@ -71,10 +71,10 @@ struct cfg_hooks\n \n   /* Return true if the one of outgoing edges is already predicted by\n      PREDICTOR.  */\n-  bool (*predicted_by_p) (basic_block bb, enum br_predictor predictor);\n+  bool (*predicted_by_p) (const_basic_block bb, enum br_predictor predictor);\n \n   /* Return true when block A can be duplicated.  */\n-  bool (*can_duplicate_block_p) (basic_block a);\n+  bool (*can_duplicate_block_p) (const_basic_block a);\n \n   /* Duplicate block A.  */\n   basic_block (*duplicate_block) (basic_block a);\n@@ -89,11 +89,11 @@ struct cfg_hooks\n \n   /* Say whether a block ends with a call, possibly followed by some\n      other code that must stay with the call.  */\n-  bool (*block_ends_with_call_p) (basic_block);\n+  bool (*block_ends_with_call_p) (const_basic_block);\n \n   /* Say whether a block ends with a conditional branch.  Switches\n      and unconditional branches do not qualify.  */\n-  bool (*block_ends_with_condjump_p) (basic_block);\n+  bool (*block_ends_with_condjump_p) (const_basic_block);\n \n   /* Add fake edges to the function exit for any non constant and non noreturn\n      calls, volatile inline assembly in the bitmap of blocks specified by\n@@ -141,7 +141,7 @@ extern void verify_flow_info (void);\n extern void dump_bb (basic_block, FILE *, int);\n extern edge redirect_edge_and_branch (edge, basic_block);\n extern basic_block redirect_edge_and_branch_force (edge, basic_block);\n-extern bool can_remove_branch_p (edge);\n+extern bool can_remove_branch_p (const_edge);\n extern void remove_branch (edge);\n extern void remove_edge (edge);\n extern edge split_block (basic_block, void *);\n@@ -151,18 +151,18 @@ extern void delete_basic_block (basic_block);\n extern basic_block split_edge (edge);\n extern basic_block create_basic_block (void *, void *, basic_block);\n extern basic_block create_empty_bb (basic_block);\n-extern bool can_merge_blocks_p (basic_block, basic_block);\n+extern bool can_merge_blocks_p (const_basic_block, const_basic_block);\n extern void merge_blocks (basic_block, basic_block);\n extern edge make_forwarder_block (basic_block, bool (*)(edge),\n \t\t\t\t  void (*) (basic_block));\n extern void tidy_fallthru_edge (edge);\n extern void tidy_fallthru_edges (void);\n extern void predict_edge (edge e, enum br_predictor predictor, int probability);\n-extern bool predicted_by_p (basic_block bb, enum br_predictor predictor);\n-extern bool can_duplicate_block_p (basic_block);\n+extern bool predicted_by_p (const_basic_block bb, enum br_predictor predictor);\n+extern bool can_duplicate_block_p (const_basic_block);\n extern basic_block duplicate_block (basic_block, edge, basic_block);\n-extern bool block_ends_with_call_p (basic_block bb);\n-extern bool block_ends_with_condjump_p (basic_block bb);\n+extern bool block_ends_with_call_p (const_basic_block bb);\n+extern bool block_ends_with_condjump_p (const_basic_block bb);\n extern int flow_call_edges_add (sbitmap);\n extern void execute_on_growing_pred (edge);\n extern void execute_on_shrinking_pred (edge);"}, {"sha": "c70348c9a4d65258a2e05762143205a85631be20", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -1019,10 +1019,10 @@ force_one_exit_fallthru (void)\n    only be used through the cfghooks interface, and we do not want to move\n    it to cfgrtl.c since it would require also moving quite a lot of related\n    code.  */\n-extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n+extern bool cfg_layout_can_duplicate_bb_p (const_basic_block);\n \n bool\n-cfg_layout_can_duplicate_bb_p (basic_block bb)\n+cfg_layout_can_duplicate_bb_p (const_basic_block bb)\n {\n   /* Do not attempt to duplicate tablejumps, as we need to unshare\n      the dispatch table.  This is difficult to do, as the instructions"}, {"sha": "74267383dce734f58e4b9b72674d9dd748643b55", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -62,8 +62,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"df.h\"\n \n-static int can_delete_note_p (rtx);\n-static int can_delete_label_p (rtx);\n+static int can_delete_note_p (const_rtx);\n+static int can_delete_label_p (const_rtx);\n static void commit_one_edge_insertion (edge);\n static basic_block rtl_split_edge (edge);\n static bool rtl_move_block_after (basic_block, basic_block);\n@@ -84,7 +84,7 @@ static void rtl_make_forwarder_block (edge);\n    so that we may simply delete it.  */\n \n static int\n-can_delete_note_p (rtx note)\n+can_delete_note_p (const_rtx note)\n {\n   return (NOTE_KIND (note) == NOTE_INSN_DELETED\n \t  || NOTE_KIND (note) == NOTE_INSN_BASIC_BLOCK);\n@@ -93,7 +93,7 @@ can_delete_note_p (rtx note)\n /* True if a given label can be deleted.  */\n \n static int\n-can_delete_label_p (rtx label)\n+can_delete_label_p (const_rtx label)\n {\n   return (!LABEL_PRESERVE_P (label)\n \t  /* User declared labels must be preserved.  */\n@@ -625,7 +625,8 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n /* Return true when block A and B can be merged.  */\n static bool\n-rtl_can_merge_blocks (basic_block a,basic_block b)\n+\n+rtl_can_merge_blocks (const_basic_block a, const_basic_block b)\n {\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -2530,7 +2531,7 @@ cfg_layout_delete_block (basic_block bb)\n \n /* Return true when blocks A and B can be safely merged.  */\n static bool\n-cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n+cfg_layout_can_merge_blocks_p (const_basic_block a, const_basic_block b)\n {\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -2686,7 +2687,7 @@ rtl_make_forwarder_block (edge fallthru ATTRIBUTE_UNUSED)\n    instructions that must stay with the call, 0 otherwise.  */\n \n static bool\n-rtl_block_ends_with_call_p (basic_block bb)\n+rtl_block_ends_with_call_p (const_basic_block bb)\n {\n   rtx insn = BB_END (bb);\n \n@@ -2700,7 +2701,7 @@ rtl_block_ends_with_call_p (basic_block bb)\n /* Return 1 if BB ends with a conditional branch, 0 otherwise.  */\n \n static bool\n-rtl_block_ends_with_condjump_p (basic_block bb)\n+rtl_block_ends_with_condjump_p (const_basic_block bb)\n {\n   return any_condjump_p (BB_END (bb));\n }\n@@ -2709,7 +2710,7 @@ rtl_block_ends_with_condjump_p (basic_block bb)\n    Helper function for rtl_flow_call_edges_add.  */\n \n static bool\n-need_fake_edge_p (rtx insn)\n+need_fake_edge_p (const_rtx insn)\n {\n   if (!INSN_P (insn))\n     return false;\n@@ -3012,11 +3013,11 @@ insert_insn_end_bb_new (rtx pat, basic_block bb)\n    it to the destination of the other edge from E->src.  */\n \n static bool\n-rtl_can_remove_branch_p (edge e)\n+rtl_can_remove_branch_p (const_edge e)\n {\n-  basic_block src = e->src;\n-  basic_block target = EDGE_SUCC (src, EDGE_SUCC (src, 0) == e)->dest;\n-  rtx insn = BB_END (src), set;\n+  const_basic_block src = e->src;\n+  const_basic_block target = EDGE_SUCC (src, EDGE_SUCC (src, 0) == e)->dest;\n+  const_rtx insn = BB_END (src), set;\n \n   /* The conditions are taken from try_redirect_by_replacing_jump.  */\n   if (target == EXIT_BLOCK_PTR)\n@@ -3082,7 +3083,7 @@ struct cfg_hooks rtl_cfg_hooks = {\n    should only be used through the cfghooks interface, and we do not want to\n    move them here since it would require also moving quite a lot of related\n    code.  They are in cfglayout.c.  */\n-extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n+extern bool cfg_layout_can_duplicate_bb_p (const_basic_block);\n extern basic_block cfg_layout_duplicate_bb (basic_block);\n \n struct cfg_hooks cfg_layout_rtl_cfg_hooks = {"}, {"sha": "1d47eed872494f1bb03f45f57411677c0b01d444", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -353,7 +353,7 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   dbxout_end_source_file,\n   dbxout_begin_block,\n   dbxout_end_block,\n-  debug_true_tree,\t\t         /* ignore_block */\n+  debug_true_const_tree,\t         /* ignore_block */\n   dbxout_source_line,\t\t         /* source_line */\n   dbxout_begin_prologue,\t         /* begin_prologue */\n   debug_nothing_int_charstar,\t         /* end_prologue */\n@@ -389,7 +389,7 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   dbxout_end_source_file,\n   xcoffout_begin_block,\n   xcoffout_end_block,\n-  debug_true_tree,\t\t         /* ignore_block */\n+  debug_true_const_tree,\t         /* ignore_block */\n   xcoffout_source_line,\n   xcoffout_begin_prologue,\t         /* begin_prologue */\n   debug_nothing_int_charstar,\t         /* end_prologue */"}, {"sha": "12a726f9509afa92bc17016885f03efda6fcc520", "filename": "gcc/debug.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -32,7 +32,7 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_int,\n   debug_nothing_int_int,\t         /* begin_block */\n   debug_nothing_int_int,\t         /* end_block */\n-  debug_true_tree,\t\t         /* ignore_block */\n+  debug_true_const_tree,\t         /* ignore_block */\n   debug_nothing_int_charstar,\t         /* source_line */\n   debug_nothing_int_charstar,\t         /* begin_prologue */\n   debug_nothing_int_charstar,\t         /* end_prologue */\n@@ -72,7 +72,7 @@ debug_nothing_tree_tree (tree t1 ATTRIBUTE_UNUSED,\n }\n \n bool\n-debug_true_tree (tree block ATTRIBUTE_UNUSED)\n+debug_true_const_tree (const_tree block ATTRIBUTE_UNUSED)\n {\n   return true;\n }"}, {"sha": "03c80412709ed166a8cfcbdbf7cb24828d1d1280", "filename": "gcc/debug.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -56,7 +56,7 @@ struct gcc_debug_hooks\n      instructions.  This may not be the case for blocks containing\n      nested functions, since we may actually call such a function even\n      though the BLOCK information is messed up.  Defaults to true.  */\n-  bool (* ignore_block) (tree);\n+  bool (* ignore_block) (const_tree);\n \n   /* Record a source file location at (FILE, LINE).  */\n   void (* source_line) (unsigned int line, const char *file);\n@@ -140,7 +140,7 @@ extern void debug_nothing_int_int (unsigned int, unsigned int);\n extern void debug_nothing_tree (tree);\n extern void debug_nothing_tree_int (tree, int);\n extern void debug_nothing_tree_tree (tree, tree);\n-extern bool debug_true_tree (tree);\n+extern bool debug_true_const_tree (const_tree);\n extern void debug_nothing_rtx (rtx);\n \n /* Hooks for various debug formats.  */"}, {"sha": "0463f1f03b4cb9aac3822e584de358b05092b788", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -354,12 +354,12 @@ static void reg_save (const char *, unsigned, unsigned, HOST_WIDE_INT);\n #ifdef DWARF2_UNWIND_INFO\n static void initial_return_save (rtx);\n #endif\n-static HOST_WIDE_INT stack_adjust_offset (rtx);\n+static HOST_WIDE_INT stack_adjust_offset (const_rtx);\n static void output_cfi (dw_cfi_ref, dw_fde_ref, int);\n static void output_call_frame_info (int);\n static void dwarf2out_stack_adjust (rtx, bool);\n static void flush_queued_reg_saves (void);\n-static bool clobbers_queued_reg_save (rtx);\n+static bool clobbers_queued_reg_save (const_rtx);\n static void dwarf2out_frame_debug_expr (rtx, const char *);\n \n /* Support for complex CFA locations.  */\n@@ -1025,10 +1025,10 @@ initial_return_save (rtx rtl)\n    contains.  */\n \n static HOST_WIDE_INT\n-stack_adjust_offset (rtx pattern)\n+stack_adjust_offset (const_rtx pattern)\n {\n-  rtx src = SET_SRC (pattern);\n-  rtx dest = SET_DEST (pattern);\n+  const_rtx src = SET_SRC (pattern);\n+  const_rtx dest = SET_DEST (pattern);\n   HOST_WIDE_INT offset = 0;\n   enum rtx_code code;\n \n@@ -1286,7 +1286,7 @@ flush_queued_reg_saves (void)\n    have a new location for?  */\n \n static bool\n-clobbers_queued_reg_save (rtx insn)\n+clobbers_queued_reg_save (const_rtx insn)\n {\n   struct queued_reg_save *q;\n \n@@ -3651,7 +3651,7 @@ static void dwarf2out_start_source_file (unsigned, const char *);\n static void dwarf2out_end_source_file (unsigned);\n static void dwarf2out_begin_block (unsigned, unsigned);\n static void dwarf2out_end_block (unsigned, unsigned);\n-static bool dwarf2out_ignore_block (tree);\n+static bool dwarf2out_ignore_block (const_tree);\n static void dwarf2out_global_decl (tree);\n static void dwarf2out_type_decl (tree, int);\n static void dwarf2out_imported_module_or_decl (tree, tree);\n@@ -4069,14 +4069,14 @@ static HOST_WIDE_INT frame_pointer_fb_offset;\n \n /* Forward declarations for functions defined in this file.  */\n \n-static int is_pseudo_reg (rtx);\n+static int is_pseudo_reg (const_rtx);\n static tree type_main_variant (tree);\n-static int is_tagged_type (tree);\n+static int is_tagged_type (const_tree);\n static const char *dwarf_tag_name (unsigned);\n static const char *dwarf_attr_name (unsigned);\n static const char *dwarf_form_name (unsigned);\n-static tree decl_ultimate_origin (tree);\n-static tree block_ultimate_origin (tree);\n+static tree decl_ultimate_origin (const_tree);\n+static tree block_ultimate_origin (const_tree);\n static tree decl_class_context (tree);\n static void add_dwarf_attr (dw_die_ref, dw_attr_ref);\n static inline enum dw_val_class AT_class (dw_attr_ref);\n@@ -4139,7 +4139,7 @@ static int decl_die_table_eq (const void *, const void *);\n static dw_die_ref lookup_decl_die (tree);\n static hashval_t decl_loc_table_hash (const void *);\n static int decl_loc_table_eq (const void *, const void *);\n-static var_loc_list *lookup_decl_loc (tree);\n+static var_loc_list *lookup_decl_loc (const_tree);\n static void equate_decl_number_to_die (tree, dw_die_ref);\n static void add_var_loc_to_decl (tree, struct var_loc_node *);\n static void print_spaces (FILE *);\n@@ -4151,7 +4151,7 @@ static void loc_checksum (dw_loc_descr_ref, struct md5_ctx *);\n static void attr_checksum (dw_attr_ref, struct md5_ctx *, int *);\n static void die_checksum (dw_die_ref, struct md5_ctx *, int *);\n static int same_loc_p (dw_loc_descr_ref, dw_loc_descr_ref, int *);\n-static int same_dw_val_p (dw_val_node *, dw_val_node *, int *);\n+static int same_dw_val_p (const dw_val_node *, const dw_val_node *, int *);\n static int same_attr_p (dw_attr_ref, dw_attr_ref, int *);\n static int same_die_p (dw_die_ref, dw_die_ref, int *);\n static int same_die_p_wrap (dw_die_ref, dw_die_ref);\n@@ -4191,18 +4191,18 @@ static void output_pubnames (VEC (pubname_entry,gc) *);\n static void add_arange (tree, dw_die_ref);\n static void output_aranges (void);\n static unsigned int add_ranges_num (int);\n-static unsigned int add_ranges (tree);\n+static unsigned int add_ranges (const_tree);\n static unsigned int add_ranges_by_labels (const char *, const char *);\n static void output_ranges (void);\n static void output_line_info (void);\n static void output_file_names (void);\n static dw_die_ref base_type_die (tree);\n static int is_base_type (tree);\n-static bool is_subrange_type (tree);\n+static bool is_subrange_type (const_tree);\n static dw_die_ref subrange_type_die (tree, dw_die_ref);\n static dw_die_ref modified_type_die (tree, int, int, dw_die_ref);\n-static int type_is_enum (tree);\n-static unsigned int dbx_reg_number (rtx);\n+static int type_is_enum (const_tree);\n+static unsigned int dbx_reg_number (const_rtx);\n static void add_loc_descr_op_piece (dw_loc_descr_ref *, int);\n static dw_loc_descr_ref reg_loc_descriptor (rtx, enum var_init_status);\n static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int, \n@@ -4212,7 +4212,7 @@ static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx,\n static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT,\n \t\t\t\t\t enum var_init_status);\n-static int is_based_loc (rtx);\n+static int is_based_loc (const_rtx);\n static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode,\n \t\t\t\t\t    enum var_init_status);\n static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n@@ -4221,18 +4221,18 @@ static dw_loc_descr_ref loc_descriptor (rtx, enum var_init_status);\n static dw_loc_descr_ref loc_descriptor_from_tree_1 (tree, int);\n static dw_loc_descr_ref loc_descriptor_from_tree (tree);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n-static tree field_type (tree);\n-static unsigned int simple_type_align_in_bits (tree);\n-static unsigned int simple_decl_align_in_bits (tree);\n-static unsigned HOST_WIDE_INT simple_type_size_in_bits (tree);\n-static HOST_WIDE_INT field_byte_offset (tree);\n+static tree field_type (const_tree);\n+static unsigned int simple_type_align_in_bits (const_tree);\n+static unsigned int simple_decl_align_in_bits (const_tree);\n+static unsigned HOST_WIDE_INT simple_type_size_in_bits (const_tree);\n+static HOST_WIDE_INT field_byte_offset (const_tree);\n static void add_AT_location_description\t(dw_die_ref, enum dwarf_attribute,\n \t\t\t\t\t dw_loc_descr_ref);\n static void add_data_member_location_attribute (dw_die_ref, tree);\n static void add_const_value_attribute (dw_die_ref, rtx);\n static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n-static void insert_float (rtx, unsigned char *);\n+static void insert_float (const_rtx, unsigned char *);\n static rtx rtl_for_decl_location (tree);\n static void add_location_or_const_value_attribute (dw_die_ref, tree,\n \t\t\t\t\t\t   enum dwarf_attribute);\n@@ -4256,8 +4256,8 @@ static inline int local_scope_p (dw_die_ref);\n static inline int class_or_namespace_scope_p (dw_die_ref);\n static void add_type_attribute (dw_die_ref, tree, int, int, dw_die_ref);\n static void add_calling_convention_attribute (dw_die_ref, tree);\n-static const char *type_tag (tree);\n-static tree member_declared_type (tree);\n+static const char *type_tag (const_tree);\n+static tree member_declared_type (const_tree);\n #if 0\n static const char *decl_start_label (tree);\n #endif\n@@ -4290,7 +4290,7 @@ static void gen_type_die (tree, dw_die_ref);\n static void gen_tagged_type_instantiation_die (tree, dw_die_ref);\n static void gen_block_die (tree, dw_die_ref, int);\n static void decls_for_scope (tree, dw_die_ref, int);\n-static int is_redundant_typedef (tree);\n+static int is_redundant_typedef (const_tree);\n static void gen_namespace_die (tree);\n static void gen_decl_die (tree, dw_die_ref);\n static dw_die_ref force_decl_die (tree);\n@@ -4437,7 +4437,7 @@ dwarf2out_set_demangle_name_func (const char *(*func) (const char *))\n /* Test if rtl node points to a pseudo register.  */\n \n static inline int\n-is_pseudo_reg (rtx rtl)\n+is_pseudo_reg (const_rtx rtl)\n {\n   return ((REG_P (rtl) && REGNO (rtl) >= FIRST_PSEUDO_REGISTER)\n \t  || (GET_CODE (rtl) == SUBREG\n@@ -4467,7 +4467,7 @@ type_main_variant (tree type)\n /* Return nonzero if the given type node represents a tagged type.  */\n \n static inline int\n-is_tagged_type (tree type)\n+is_tagged_type (const_tree type)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -4863,7 +4863,7 @@ dwarf_form_name (unsigned int form)\n    given block.  */\n \n static tree\n-decl_ultimate_origin (tree decl)\n+decl_ultimate_origin (const_tree decl)\n {\n   if (!CODE_CONTAINS_STRUCT (TREE_CODE (decl), TS_DECL_COMMON))\n     return NULL_TREE;\n@@ -4888,7 +4888,7 @@ decl_ultimate_origin (tree decl)\n    given block.  */\n \n static tree\n-block_ultimate_origin (tree block)\n+block_ultimate_origin (const_tree block)\n {\n   tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n \n@@ -5734,7 +5734,7 @@ decl_loc_table_eq (const void *x, const void *y)\n /* Return the var_loc list associated with a given declaration.  */\n \n static inline var_loc_list *\n-lookup_decl_loc (tree decl)\n+lookup_decl_loc (const_tree decl)\n {\n   return htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));\n }\n@@ -6099,7 +6099,7 @@ same_loc_p (dw_loc_descr_ref loc1, dw_loc_descr_ref loc2, int *mark)\n \n /* Do the values look the same?  */\n static int\n-same_dw_val_p (dw_val_node *v1, dw_val_node *v2, int *mark)\n+same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n {\n   dw_loc_descr_ref loc1, loc2;\n   rtx r1, r2;\n@@ -7667,7 +7667,7 @@ add_ranges_num (int num)\n    range terminator if BLOCK is NULL.  */\n \n static unsigned int\n-add_ranges (tree block)\n+add_ranges (const_tree block)\n {\n   return add_ranges_num (block ? BLOCK_NUMBER (block) : 0);\n }\n@@ -8515,7 +8515,7 @@ is_base_type (tree type)\n    ERROR_MARK node.  */\n \n static inline unsigned HOST_WIDE_INT\n-simple_type_size_in_bits (tree type)\n+simple_type_size_in_bits (const_tree type)\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return BITS_PER_WORD;\n@@ -8531,7 +8531,7 @@ simple_type_size_in_bits (tree type)\n    emitted as a subrange type.  */\n \n static inline bool\n-is_subrange_type (tree type)\n+is_subrange_type (const_tree type)\n {\n   tree subtype = TREE_TYPE (type);\n \n@@ -8757,15 +8757,15 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n    an enumerated type.  */\n \n static inline int\n-type_is_enum (tree type)\n+type_is_enum (const_tree type)\n {\n   return TREE_CODE (type) == ENUMERAL_TYPE;\n }\n \n /* Return the DBX register number described by a given RTL node.  */\n \n static unsigned int\n-dbx_reg_number (rtx rtl)\n+dbx_reg_number (const_rtx rtl)\n {\n   unsigned regno = REGNO (rtl);\n \n@@ -8991,7 +8991,7 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n /* Return true if this RTL expression describes a base+offset calculation.  */\n \n static inline int\n-is_based_loc (rtx rtl)\n+is_based_loc (const_rtx rtl)\n {\n   return (GET_CODE (rtl) == PLUS\n \t  && ((REG_P (XEXP (rtl, 0))\n@@ -9840,7 +9840,7 @@ ceiling (HOST_WIDE_INT value, unsigned int boundary)\n    ERROR_MARK node.  */\n \n static inline tree\n-field_type (tree decl)\n+field_type (const_tree decl)\n {\n   tree type;\n \n@@ -9859,13 +9859,13 @@ field_type (tree decl)\n    be an ERROR_MARK node.  */\n \n static inline unsigned\n-simple_type_align_in_bits (tree type)\n+simple_type_align_in_bits (const_tree type)\n {\n   return (TREE_CODE (type) != ERROR_MARK) ? TYPE_ALIGN (type) : BITS_PER_WORD;\n }\n \n static inline unsigned\n-simple_decl_align_in_bits (tree decl)\n+simple_decl_align_in_bits (const_tree decl)\n {\n   return (TREE_CODE (decl) != ERROR_MARK) ? DECL_ALIGN (decl) : BITS_PER_WORD;\n }\n@@ -9896,7 +9896,7 @@ round_up_to_align (HOST_WIDE_INT t, unsigned int align)\n    just yet).  */\n \n static HOST_WIDE_INT\n-field_byte_offset (tree decl)\n+field_byte_offset (const_tree decl)\n {\n   HOST_WIDE_INT object_offset_in_bits;\n   HOST_WIDE_INT bitpos_int;\n@@ -10162,7 +10162,7 @@ extract_int (const unsigned char *src, unsigned int size)\n /* Writes floating point values to dw_vec_const array.  */\n \n static void\n-insert_float (rtx rtl, unsigned char *array)\n+insert_float (const_rtx rtl, unsigned char *array)\n {\n   REAL_VALUE_TYPE rv;\n   long val[4];\n@@ -10622,7 +10622,7 @@ rtl_for_decl_location (tree decl)\n    XXX: If you split a variable across multiple sections, we won't notice.  */\n \n static const char *\n-secname_for_decl (tree decl)\n+secname_for_decl (const_tree decl)\n {\n   const char *secname;\n \n@@ -11488,7 +11488,7 @@ add_calling_convention_attribute (dw_die_ref subr_die, tree type)\n    was declared without a tag.  */\n \n static const char *\n-type_tag (tree type)\n+type_tag (const_tree type)\n {\n   const char *name = 0;\n \n@@ -11526,7 +11526,7 @@ type_tag (tree type)\n    for bit field types.  */\n \n static inline tree\n-member_declared_type (tree member)\n+member_declared_type (const_tree member)\n {\n   return (DECL_BIT_FIELD_TYPE (member)\n \t  ? DECL_BIT_FIELD_TYPE (member) : TREE_TYPE (member));\n@@ -12484,7 +12484,7 @@ add_call_src_coords_attributes (tree stmt, dw_die_ref die)\n    first subblock's abstract origin is the function's outermost block,\n    then we're looking at the main entry point.  */\n static bool\n-is_inlined_entry_point (tree stmt)\n+is_inlined_entry_point (const_tree stmt)\n {\n   tree decl, block;\n \n@@ -13339,7 +13339,7 @@ decls_for_scope (tree stmt, dw_die_ref context_die, int depth)\n /* Is this a typedef we can avoid emitting?  */\n \n static inline int\n-is_redundant_typedef (tree decl)\n+is_redundant_typedef (const_tree decl)\n {\n   if (TYPE_DECL_IS_STUB (decl))\n     return 1;\n@@ -13950,7 +13950,7 @@ dwarf2out_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int blocknum)\n    we may end up calling them anyway.  */\n \n static bool\n-dwarf2out_ignore_block (tree block)\n+dwarf2out_ignore_block (const_tree block)\n {\n   tree decl;\n "}, {"sha": "32dce933290b8b919af8ac41fc13992041fa9c3d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 182, "deletions": 72, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -2865,103 +2865,169 @@ get_max_uid (void)\n /* Return the next insn.  If it is a SEQUENCE, return the first insn\n    of the sequence.  */\n \n+#define NEXT_INSN_BODY do { \\\n+  if (insn) \\\n+    { \\\n+      insn = NEXT_INSN (insn); \\\n+      if (insn && NONJUMP_INSN_P (insn) \\\n+\t  && GET_CODE (PATTERN (insn)) == SEQUENCE) \\\n+\tinsn = XVECEXP (PATTERN (insn), 0, 0); \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n next_insn (rtx insn)\n {\n-  if (insn)\n-    {\n-      insn = NEXT_INSN (insn);\n-      if (insn && NONJUMP_INSN_P (insn)\n-\t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n-    }\n+  NEXT_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_next_insn (const_rtx insn)\n+{\n+  NEXT_INSN_BODY;\n }\n \n+#undef NEXT_INSN_BODY\n+\n /* Return the previous insn.  If it is a SEQUENCE, return the last insn\n    of the sequence.  */\n \n+#define PREVIOUS_INSN_BODY do { \\\n+  if (insn) \\\n+    { \\\n+      insn = PREV_INSN (insn); \\\n+      if (insn && NONJUMP_INSN_P (insn) \\\n+\t  && GET_CODE (PATTERN (insn)) == SEQUENCE) \\\n+\tinsn = XVECEXP (PATTERN (insn), 0, XVECLEN (PATTERN (insn), 0) - 1); \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n previous_insn (rtx insn)\n {\n-  if (insn)\n-    {\n-      insn = PREV_INSN (insn);\n-      if (insn && NONJUMP_INSN_P (insn)\n-\t  && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, XVECLEN (PATTERN (insn), 0) - 1);\n-    }\n+  PREVIOUS_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_previous_insn (const_rtx insn)\n+{\n+  PREVIOUS_INSN_BODY;\n }\n \n+#undef PREVIOUS_INSN_BODY\n+\n /* Return the next insn after INSN that is not a NOTE.  This routine does not\n    look inside SEQUENCEs.  */\n \n+#define NEXT_NONNOTE_INSN_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = NEXT_INSN (insn); \\\n+      if (insn == 0 || !NOTE_P (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n next_nonnote_insn (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = NEXT_INSN (insn);\n-      if (insn == 0 || !NOTE_P (insn))\n-\tbreak;\n-    }\n+  NEXT_NONNOTE_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_next_nonnote_insn (const_rtx insn)\n+{\n+  NEXT_NONNOTE_INSN_BODY;\n }\n \n+#undef NEXT_NONNOTE_INSN_BODY\n+\n /* Return the previous insn before INSN that is not a NOTE.  This routine does\n    not look inside SEQUENCEs.  */\n \n+#define PREV_NONNOTE_INSN_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = PREV_INSN (insn); \\\n+      if (insn == 0 || !NOTE_P (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n prev_nonnote_insn (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = PREV_INSN (insn);\n-      if (insn == 0 || !NOTE_P (insn))\n-\tbreak;\n-    }\n+  PREV_NONNOTE_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_prev_nonnote_insn (const_rtx insn)\n+{\n+  PREV_NONNOTE_INSN_BODY;\n }\n \n+#undef PREV_NONNOTE_INSN_BODY\n+\n /* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;\n    or 0, if there is none.  This routine does not look inside\n    SEQUENCEs.  */\n \n+#define NEXT_REAL_INSN_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = NEXT_INSN (insn); \\\n+      if (insn == 0 || INSN_P (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n next_real_insn (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = NEXT_INSN (insn);\n-      if (insn == 0 || INSN_P (insn))\n-\tbreak;\n-    }\n+  NEXT_REAL_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_next_real_insn (const_rtx insn)\n+{\n+  NEXT_REAL_INSN_BODY;\n }\n \n+#undef NEXT_REAL_INSN_BODY\n+\n /* Return the last INSN, CALL_INSN or JUMP_INSN before INSN;\n    or 0, if there is none.  This routine does not look inside\n    SEQUENCEs.  */\n \n+#define PREV_REAL_INSN_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = PREV_INSN (insn); \\\n+      if (insn == 0 || INSN_P (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n prev_real_insn (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = PREV_INSN (insn);\n-      if (insn == 0 || INSN_P (insn))\n-\tbreak;\n-    }\n+  PREV_REAL_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_prev_real_insn (const_rtx insn)\n+{\n+  PREV_REAL_INSN_BODY;\n }\n \n+#undef PREV_REAL_INSN_BODY\n+\n /* Return the last CALL_INSN in the current list, or 0 if there is none.\n    This routine does not look inside SEQUENCEs.  */\n \n@@ -2992,66 +3058,110 @@ active_insn_p (const_rtx insn)\n \t\t      && GET_CODE (PATTERN (insn)) != CLOBBER))));\n }\n \n+#define NEXT_ACTIVE_INSN_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = NEXT_INSN (insn); \\\n+      if (insn == 0 || active_insn_p (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn;\\\n+} while (0)\n+\n rtx\n next_active_insn (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = NEXT_INSN (insn);\n-      if (insn == 0 || active_insn_p (insn))\n-\tbreak;\n-    }\n+  NEXT_ACTIVE_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_next_active_insn (const_rtx insn)\n+{\n+  NEXT_ACTIVE_INSN_BODY;\n }\n \n+#undef NEXT_ACTIVE_INSN_BODY\n+\n /* Find the last insn before INSN that really does something.  This routine\n    does not look inside SEQUENCEs.  Until reload has completed, this is the\n    same as prev_real_insn.  */\n \n+#define PREV_ACTIVE_INSN_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = PREV_INSN (insn);\\\n+      if (insn == 0 || active_insn_p (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n prev_active_insn (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = PREV_INSN (insn);\n-      if (insn == 0 || active_insn_p (insn))\n-\tbreak;\n-    }\n+  PREV_ACTIVE_INSN_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_prev_active_insn (const_rtx insn)\n+{\n+  PREV_ACTIVE_INSN_BODY;\n }\n \n+#undef PREV_ACTIVE_INSN_BODY\n+\n /* Return the next CODE_LABEL after the insn INSN, or 0 if there is none.  */\n \n+#define NEXT_LABEL_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = NEXT_INSN (insn); \\\n+      if (insn == 0 || LABEL_P (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n next_label (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = NEXT_INSN (insn);\n-      if (insn == 0 || LABEL_P (insn))\n-\tbreak;\n-    }\n+  NEXT_LABEL_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_next_label (const_rtx insn)\n+{\n+  NEXT_LABEL_BODY;\n }\n \n+#undef NEXT_LABEL_BODY\n+\n /* Return the last CODE_LABEL before the insn INSN, or 0 if there is none.  */\n \n+#define PREV_LABEL_BODY do { \\\n+  while (insn) \\\n+    { \\\n+      insn = PREV_INSN (insn); \\\n+      if (insn == 0 || LABEL_P (insn)) \\\n+\tbreak; \\\n+    } \\\n+  return insn; \\\n+} while (0)\n+\n rtx\n prev_label (rtx insn)\n {\n-  while (insn)\n-    {\n-      insn = PREV_INSN (insn);\n-      if (insn == 0 || LABEL_P (insn))\n-\tbreak;\n-    }\n+  PREV_LABEL_BODY;\n+}\n \n-  return insn;\n+const_rtx\n+const_prev_label (const_rtx insn)\n+{\n+  PREV_LABEL_BODY;\n }\n \n+#undef PREV_LABEL_BODY\n+\n /* Return the last label to mark the same position as LABEL.  Return null\n    if LABEL itself is null.  */\n "}, {"sha": "3fb33809d85741a86e42c6315ddc7f625b5cabbb", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -112,8 +112,8 @@ extern int eh_region_outermost (struct function *, int, int);\n /* tree-eh.c */\n extern void add_stmt_to_eh_region_fn (struct function *, tree, int);\n extern bool remove_stmt_from_eh_region_fn (struct function *, tree);\n-extern int lookup_stmt_eh_region_fn (struct function *, tree);\n-extern int lookup_stmt_eh_region (tree);\n+extern int lookup_stmt_eh_region_fn (struct function *, const_tree);\n+extern int lookup_stmt_eh_region (const_tree);\n extern bool verify_eh_edges (tree);\n \n /* If non-NULL, this is a function that returns an expression to be"}, {"sha": "18a5efe03e2625b1368663451a4baeb9817b8e24", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -328,7 +328,7 @@ static int clock_var;\n /* Number of instructions in current scheduling region.  */\n static int rgn_n_insns;\n \n-static int may_trap_exp (rtx, int);\n+static int may_trap_exp (const_rtx, int);\n \n /* Nonzero iff the address is comprised from at most 1 register.  */\n #define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n@@ -342,7 +342,7 @@ static int may_trap_exp (rtx, int);\n    as found by analyzing insn's expression.  */\n \n static int\n-may_trap_exp (rtx x, int is_store)\n+may_trap_exp (const_rtx x, int is_store)\n {\n   enum rtx_code code;\n \n@@ -415,7 +415,7 @@ may_trap_exp (rtx x, int is_store)\n    being either PFREE or PRISKY.  */\n \n int\n-haifa_classify_insn (rtx insn)\n+haifa_classify_insn (const_rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   int tmp_class = TRAP_FREE;\n@@ -499,7 +499,7 @@ static int rank_for_schedule (const void *, const void *);\n static void swap_sort (rtx *, int);\n static void queue_insn (rtx, int);\n static int schedule_insn (rtx);\n-static int find_set_reg_weight (rtx);\n+static int find_set_reg_weight (const_rtx);\n static void find_insn_reg_weight (basic_block);\n static void find_insn_reg_weight1 (rtx);\n static void adjust_priority (rtx);\n@@ -1358,7 +1358,7 @@ get_ebb_head_tail (basic_block beg, basic_block end, rtx *headp, rtx *tailp)\n /* Return nonzero if there are no real insns in the range [ HEAD, TAIL ].  */\n \n int\n-no_real_insns_p (rtx head, rtx tail)\n+no_real_insns_p (const_rtx head, const_rtx tail)\n {\n   while (head != NEXT_INSN (tail))\n     {\n@@ -1408,7 +1408,7 @@ rm_other_notes (rtx head, rtx tail)\n    a new register is not needed.  */\n \n static int\n-find_set_reg_weight (rtx x)\n+find_set_reg_weight (const_rtx x)\n {\n   if (GET_CODE (x) == CLOBBER\n       && register_operand (SET_DEST (x), VOIDmode))\n@@ -4017,7 +4017,7 @@ change_pattern (rtx insn, rtx new_pat)\n \n /* Return true if INSN can potentially be speculated with type DS.  */\n bool\n-sched_insn_is_legitimate_for_speculation_p (rtx insn, ds_t ds)\n+sched_insn_is_legitimate_for_speculation_p (const_rtx insn, ds_t ds)\n {\n   if (HAS_INTERNAL_DEP (insn))\n     return false;"}, {"sha": "959b79af54b5866a7a313b3e46beaec9052245d5", "filename": "gcc/jump.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -233,7 +233,8 @@ mark_all_labels (rtx f)\n    description should define REVERSIBLE_CC_MODE and REVERSE_CONDITION macros\n    to help this function avoid overhead in these cases.  */\n enum rtx_code\n-reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn)\n+reversed_comparison_code_parts (enum rtx_code code, const_rtx arg0,\n+\t\t\t\tconst_rtx arg1, const_rtx insn)\n {\n   enum machine_mode mode;\n \n@@ -290,17 +291,17 @@ reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn\n \n   if (GET_MODE_CLASS (mode) == MODE_CC || CC0_P (arg0))\n     {\n-      rtx prev;\n+      const_rtx prev;\n       /* Try to search for the comparison to determine the real mode.\n          This code is expensive, but with sane machine description it\n          will be never used, since REVERSIBLE_CC_MODE will return true\n          in all cases.  */\n       if (! insn)\n \treturn UNKNOWN;\n \n-      for (prev = prev_nonnote_insn (insn);\n+      for (prev = const_prev_nonnote_insn (insn);\n \t   prev != 0 && !LABEL_P (prev);\n-\t   prev = prev_nonnote_insn (prev))\n+\t   prev = const_prev_nonnote_insn (prev))\n \t{\n \t  const_rtx set = set_of (arg0, prev);\n \t  if (set && GET_CODE (set) == SET\n@@ -346,7 +347,7 @@ reversed_comparison_code_parts (enum rtx_code code, rtx arg0, rtx arg1, rtx insn\n /* A wrapper around the previous function to take COMPARISON as rtx\n    expression.  This simplifies many callers.  */\n enum rtx_code\n-reversed_comparison_code (rtx comparison, rtx insn)\n+reversed_comparison_code (const_rtx comparison, const_rtx insn)\n {\n   if (!COMPARISON_P (comparison))\n     return UNKNOWN;\n@@ -358,7 +359,7 @@ reversed_comparison_code (rtx comparison, rtx insn)\n /* Return comparison with reversed code of EXP.\n    Return NULL_RTX in case we fail to do the reversal.  */\n rtx\n-reversed_comparison (rtx exp, enum machine_mode mode)\n+reversed_comparison (const_rtx exp, enum machine_mode mode)\n {\n   enum rtx_code reversed_code = reversed_comparison_code (exp, NULL_RTX);\n   if (reversed_code == UNKNOWN)\n@@ -789,7 +790,7 @@ any_condjump_p (const_rtx insn)\n /* Return the label of a conditional jump.  */\n \n rtx\n-condjump_label (rtx insn)\n+condjump_label (const_rtx insn)\n {\n   rtx x = pc_set (insn);\n "}, {"sha": "0cf6b9606bc3b5355f10218db4495f6f328f36ee", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -162,7 +162,7 @@ probably_never_executed_bb_p (const_basic_block bb)\n    PREDICTOR.  */\n \n bool\n-rtl_predicted_by_p (basic_block bb, enum br_predictor predictor)\n+rtl_predicted_by_p (const_basic_block bb, enum br_predictor predictor)\n {\n   rtx note;\n   if (!INSN_P (BB_END (bb)))\n@@ -183,7 +183,7 @@ static struct pointer_map_t *bb_predictions;\n    PREDICTOR.  */\n \n bool\n-tree_predicted_by_p (basic_block bb, enum br_predictor predictor)\n+tree_predicted_by_p (const_basic_block bb, enum br_predictor predictor)\n {\n   struct edge_prediction *i;\n   void **preds = pointer_map_contains (bb_predictions, bb);"}, {"sha": "1fbd322aaf43683b1b2987a748fd0b90be001549", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -249,7 +249,7 @@ static rtx not_a_num;\n \n /* Forward declarations */\n \n-static int stack_regs_mentioned_p (rtx pat);\n+static int stack_regs_mentioned_p (const_rtx pat);\n static void pop_stack (stack, int);\n static rtx *get_true_reg (rtx *);\n \n@@ -276,7 +276,7 @@ static rtx next_flags_user (rtx);\n /* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n \n static int\n-stack_regs_mentioned_p (rtx pat)\n+stack_regs_mentioned_p (const_rtx pat)\n {\n   const char *fmt;\n   int i;\n@@ -305,7 +305,7 @@ stack_regs_mentioned_p (rtx pat)\n /* Return nonzero if INSN mentions stacked registers, else return zero.  */\n \n int\n-stack_regs_mentioned (rtx insn)\n+stack_regs_mentioned (const_rtx insn)\n {\n   unsigned int uid, max;\n   int test;"}, {"sha": "500ea88294e48a0d2c13a7a10e432987c3e62741", "filename": "gcc/rtl.h", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -1593,16 +1593,26 @@ extern rtx make_jump_insn_raw (rtx);\n extern void add_function_usage_to (rtx, rtx);\n extern rtx last_call_insn (void);\n extern rtx previous_insn (rtx);\n+extern const_rtx const_previous_insn (const_rtx);\n extern rtx next_insn (rtx);\n+extern const_rtx const_next_insn (const_rtx);\n extern rtx prev_nonnote_insn (rtx);\n+extern const_rtx const_prev_nonnote_insn (const_rtx);\n extern rtx next_nonnote_insn (rtx);\n+extern const_rtx const_next_nonnote_insn (const_rtx);\n extern rtx prev_real_insn (rtx);\n+extern const_rtx const_prev_real_insn (const_rtx);\n extern rtx next_real_insn (rtx);\n+extern const_rtx const_next_real_insn (const_rtx);\n extern rtx prev_active_insn (rtx);\n+extern const_rtx const_prev_active_insn (const_rtx);\n extern rtx next_active_insn (rtx);\n+extern const_rtx const_next_active_insn (const_rtx);\n extern int active_insn_p (const_rtx);\n extern rtx prev_label (rtx);\n+extern const_rtx const_prev_label (const_rtx);\n extern rtx next_label (rtx);\n+extern const_rtx const_next_label (const_rtx);\n extern rtx skip_consecutive_labels (rtx);\n extern rtx next_cc0_user (rtx);\n extern rtx prev_cc0_setter (rtx);\n@@ -1708,9 +1718,9 @@ extern int reg_used_between_p (const_rtx, const_rtx, const_rtx);\n extern int reg_set_between_p (const_rtx, const_rtx, const_rtx);\n extern int commutative_operand_precedence (rtx);\n extern bool swap_commutative_operands_p (rtx, rtx);\n-extern int modified_between_p (rtx, rtx, rtx);\n+extern int modified_between_p (const_rtx, const_rtx, const_rtx);\n extern int no_labels_between_p (const_rtx, const_rtx);\n-extern int modified_in_p (rtx, rtx);\n+extern int modified_in_p (const_rtx, const_rtx);\n extern int reg_set_p (const_rtx, const_rtx);\n extern rtx single_set_2 (const_rtx, const_rtx);\n extern int multiple_sets (const_rtx);\n@@ -1721,6 +1731,7 @@ extern int refers_to_regno_p (unsigned int, unsigned int, const_rtx, rtx *);\n extern int reg_overlap_mentioned_p (const_rtx, const_rtx);\n extern const_rtx set_of (const_rtx, const_rtx);\n extern void note_stores (const_rtx, void (*) (rtx, const_rtx, void *), void *);\n+extern void const_note_stores (const_rtx, void (*) (const_rtx, const_rtx, const void *), const void *);\n extern void note_uses (rtx *, void (*) (rtx *, void *), void *);\n extern int dead_or_set_p (const_rtx, const_rtx);\n extern int dead_or_set_regno_p (const_rtx, unsigned int);\n@@ -1753,7 +1764,7 @@ extern int in_expr_list_p (const_rtx, const_rtx);\n extern void remove_node_from_expr_list (const_rtx, rtx *);\n extern int loc_mentioned_in_p (rtx *, const_rtx);\n extern rtx find_first_parameter_load (rtx, rtx);\n-extern bool keep_with_call_p (rtx);\n+extern bool keep_with_call_p (const_rtx);\n extern bool label_is_jump_target_p (const_rtx, const_rtx);\n extern int insn_rtx_cost (rtx);\n \n@@ -2028,7 +2039,7 @@ extern int condjump_p (const_rtx);\n extern int any_condjump_p (const_rtx);\n extern int any_uncondjump_p (const_rtx);\n extern rtx pc_set (const_rtx);\n-extern rtx condjump_label (rtx);\n+extern rtx condjump_label (const_rtx);\n extern int simplejump_p (const_rtx);\n extern int returnjump_p (rtx);\n extern int onlyjump_p (const_rtx);\n@@ -2043,10 +2054,10 @@ extern int redirect_jump_1 (rtx, rtx);\n extern void redirect_jump_2 (rtx, rtx, rtx, int, int);\n extern int redirect_jump (rtx, rtx, int);\n extern void rebuild_jump_labels (rtx);\n-extern rtx reversed_comparison (rtx, enum machine_mode);\n-extern enum rtx_code reversed_comparison_code (rtx, rtx);\n-extern enum rtx_code reversed_comparison_code_parts (enum rtx_code, rtx,\n-\t\t\t\t\t\t     rtx, rtx);\n+extern rtx reversed_comparison (const_rtx, enum machine_mode);\n+extern enum rtx_code reversed_comparison_code (const_rtx, const_rtx);\n+extern enum rtx_code reversed_comparison_code_parts (enum rtx_code, const_rtx,\n+\t\t\t\t\t\t     const_rtx, const_rtx);\n extern void delete_for_peephole (rtx, rtx);\n extern int condjump_in_parallel_p (const_rtx);\n \n@@ -2246,14 +2257,14 @@ extern int output_dependence (const_rtx, const_rtx);\n extern void init_alias_once (void);\n extern void init_alias_analysis (void);\n extern void end_alias_analysis (void);\n-extern bool memory_modified_in_insn_p (rtx, rtx);\n+extern bool memory_modified_in_insn_p (const_rtx, const_rtx);\n extern rtx find_base_term (rtx);\n extern rtx gen_hard_reg_clobber (enum machine_mode, unsigned int);\n extern rtx get_reg_known_value (unsigned int);\n extern bool get_reg_known_equiv_p (unsigned int);\n \n #ifdef STACK_REGS\n-extern int stack_regs_mentioned (rtx insn);\n+extern int stack_regs_mentioned (const_rtx insn);\n #endif\n \n /* In toplev.c */"}, {"sha": "4a4a62904b547ccc429adcb21c941822d3f018dc", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -844,9 +844,9 @@ reg_set_p (const_rtx reg, const_rtx insn)\n    X contains a MEM; this routine does usememory aliasing.  */\n \n int\n-modified_between_p (rtx x, rtx start, rtx end)\n+modified_between_p (const_rtx x, const_rtx start, const_rtx end)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  const enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n   int i, j;\n   rtx insn;\n@@ -907,9 +907,9 @@ modified_between_p (rtx x, rtx start, rtx end)\n    does use memory aliasing.  */\n \n int\n-modified_in_p (rtx x, rtx insn)\n+modified_in_p (const_rtx x, const_rtx insn)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  const enum rtx_code code = GET_CODE (x);\n   const char *fmt;\n   int i, j;\n \n@@ -1412,41 +1412,49 @@ reg_overlap_mentioned_p (const_rtx x, const_rtx in)\n   If the item being stored in or clobbered is a SUBREG of a hard register,\n   the SUBREG will be passed.  */\n \n+#define NOTE_STORES_BODY(NOTE_STORES_FN) do { \\\n+  int i; \\\n+  if (GET_CODE (x) == COND_EXEC) \\\n+    x = COND_EXEC_CODE (x); \\\n+  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER) \\\n+    { \\\n+      rtx dest = SET_DEST (x); \\\n+      while ((GET_CODE (dest) == SUBREG \\\n+\t      && (!REG_P (SUBREG_REG (dest)) \\\n+\t\t  || REGNO (SUBREG_REG (dest)) >= FIRST_PSEUDO_REGISTER)) \\\n+\t     || GET_CODE (dest) == ZERO_EXTRACT \\\n+\t     || GET_CODE (dest) == STRICT_LOW_PART) \\\n+\tdest = XEXP (dest, 0); \\\n+      /* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions, \\\n+\t each of whose first operand is a register.  */ \\\n+      if (GET_CODE (dest) == PARALLEL) \\\n+\t{ \\\n+\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--) \\\n+\t    if (XEXP (XVECEXP (dest, 0, i), 0) != 0) \\\n+\t      (*fun) (XEXP (XVECEXP (dest, 0, i), 0), x, data); \\\n+\t} \\\n+      else \\\n+\t(*fun) (dest, x, data); \\\n+    } \\\n+  else if (GET_CODE (x) == PARALLEL) \\\n+    for (i = XVECLEN (x, 0) - 1; i >= 0; i--) \\\n+      NOTE_STORES_FN (XVECEXP (x, 0, i), fun, data); \\\n+} while (0)\n+\n void\n note_stores (const_rtx x, void (*fun) (rtx, const_rtx, void *), void *data)\n {\n-  int i;\n+  NOTE_STORES_BODY(note_stores);\n+}\n \n-  if (GET_CODE (x) == COND_EXEC)\n-    x = COND_EXEC_CODE (x);\n+void\n+const_note_stores (const_rtx x, void (*fun) (const_rtx, const_rtx, const void *), const void *data)\n+{\n+  NOTE_STORES_BODY(const_note_stores);\n+}\n \n-  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n-    {\n-      rtx dest = SET_DEST (x);\n-\n-      while ((GET_CODE (dest) == SUBREG\n-\t      && (!REG_P (SUBREG_REG (dest))\n-\t\t  || REGNO (SUBREG_REG (dest)) >= FIRST_PSEUDO_REGISTER))\n-\t     || GET_CODE (dest) == ZERO_EXTRACT\n-\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\tdest = XEXP (dest, 0);\n-\n-      /* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions,\n-\t each of whose first operand is a register.  */\n-      if (GET_CODE (dest) == PARALLEL)\n-\t{\n-\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t    if (XEXP (XVECEXP (dest, 0, i), 0) != 0)\n-\t      (*fun) (XEXP (XVECEXP (dest, 0, i), 0), x, data);\n-\t}\n-      else\n-\t(*fun) (dest, x, data);\n-    }\n+#undef NOTE_STORES_BODY\n \n-  else if (GET_CODE (x) == PARALLEL)\n-    for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-      note_stores (XVECEXP (x, 0, i), fun, data);\n-}\n \f\n /* Like notes_stores, but call FUN for each expression that is being\n    referenced in PBODY, a pointer to the PATTERN of an insn.  We only call\n@@ -3363,7 +3371,7 @@ find_first_parameter_load (rtx call_insn, rtx boundary)\n    call instruction.  */\n \n bool\n-keep_with_call_p (rtx insn)\n+keep_with_call_p (const_rtx insn)\n {\n   rtx set;\n \n@@ -3384,7 +3392,7 @@ keep_with_call_p (rtx insn)\n \t if we can break or not.  */\n       if (SET_DEST (set) == stack_pointer_rtx)\n \t{\n-\t  rtx i2 = next_nonnote_insn (insn);\n+\t  const_rtx i2 = const_next_nonnote_insn (insn);\n \t  if (i2 && keep_with_call_p (i2))\n \t    return true;\n \t}"}, {"sha": "c0d9f5588e5d60c19f78170bdd35f2649741df35", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -418,7 +418,7 @@ static bitmap_head *anti_dependency_cache;\n static bitmap_head *spec_dependency_cache;\n static int cache_size;\n \n-static int deps_may_trap_p (rtx);\n+static int deps_may_trap_p (const_rtx);\n static void add_dependence_list (rtx, rtx, int, enum reg_note);\n static void add_dependence_list_and_free (rtx, rtx *, int, enum reg_note);\n static void delete_all_dependences (rtx);\n@@ -429,8 +429,8 @@ static void sched_analyze_1 (struct deps *, rtx, rtx);\n static void sched_analyze_2 (struct deps *, rtx, rtx);\n static void sched_analyze_insn (struct deps *, rtx, rtx);\n \n-static rtx sched_get_condition (rtx);\n-static int conditions_mutex_p (rtx, rtx);\n+static rtx sched_get_condition (const_rtx);\n+static int conditions_mutex_p (const_rtx, const_rtx);\n \n static enum DEPS_ADJUST_RESULT maybe_add_or_update_dep_1 (dep_t, bool,\n \t\t\t\t\t\t\t  rtx, rtx);\n@@ -446,13 +446,13 @@ static void check_dep (dep_t, bool);\n /* Return nonzero if a load of the memory reference MEM can cause a trap.  */\n \n static int\n-deps_may_trap_p (rtx mem)\n+deps_may_trap_p (const_rtx mem)\n {\n-  rtx addr = XEXP (mem, 0);\n+  const_rtx addr = XEXP (mem, 0);\n \n   if (REG_P (addr) && REGNO (addr) >= FIRST_PSEUDO_REGISTER)\n     {\n-      rtx t = get_reg_known_value (REGNO (addr));\n+      const_rtx t = get_reg_known_value (REGNO (addr));\n       if (t)\n \taddr = t;\n     }\n@@ -462,7 +462,7 @@ deps_may_trap_p (rtx mem)\n /* Find the condition under which INSN is executed.  */\n \n static rtx\n-sched_get_condition (rtx insn)\n+sched_get_condition (const_rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   rtx src;\n@@ -498,7 +498,7 @@ sched_get_condition (rtx insn)\n /* Return nonzero if conditions COND1 and COND2 can never be both true.  */\n \n static int\n-conditions_mutex_p (rtx cond1, rtx cond2)\n+conditions_mutex_p (const_rtx cond1, const_rtx cond2)\n {\n   if (COMPARISON_P (cond1)\n       && COMPARISON_P (cond2)\n@@ -512,7 +512,7 @@ conditions_mutex_p (rtx cond1, rtx cond2)\n /* Return true if insn1 and insn2 can never depend on one another because\n    the conditions under which they are executed are mutually exclusive.  */\n bool\n-sched_insns_conditions_mutex_p (rtx insn1, rtx insn2)\n+sched_insns_conditions_mutex_p (const_rtx insn1, const_rtx insn2)\n {\n   rtx cond1, cond2;\n \n@@ -542,7 +542,7 @@ sched_insns_conditions_mutex_p (rtx insn1, rtx insn2)\n    This function is used to switch sd_iterator to the next list.\n    !!! For internal use only.  Might consider moving it to sched-int.h.  */\n void\n-sd_next_list (rtx insn, sd_list_types_def *types_ptr,\n+sd_next_list (const_rtx insn, sd_list_types_def *types_ptr,\n \t      deps_list_t *list_ptr, bool *resolved_p_ptr)\n {\n   sd_list_types_def types = *types_ptr;\n@@ -587,7 +587,7 @@ sd_next_list (rtx insn, sd_list_types_def *types_ptr,\n \n /* Return the summary size of INSN's lists defined by LIST_TYPES.  */\n int\n-sd_lists_size (rtx insn, sd_list_types_def list_types)\n+sd_lists_size (const_rtx insn, sd_list_types_def list_types)\n {\n   int size = 0;\n \n@@ -605,7 +605,7 @@ sd_lists_size (rtx insn, sd_list_types_def list_types)\n \n /* Return true if INSN's lists defined by LIST_TYPES are all empty.  */\n bool\n-sd_lists_empty_p (rtx insn, sd_list_types_def list_types)\n+sd_lists_empty_p (const_rtx insn, sd_list_types_def list_types)\n {\n   return sd_lists_size (insn, list_types) == 0;\n }"}, {"sha": "d23fc82d80773f6d68860d68bb32a63c27f98fd4", "filename": "gcc/sched-int.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -811,7 +811,7 @@ enum INSN_TRAP_CLASS\n extern void print_insn (char *, rtx, int);\n \n /* Functions in sched-deps.c.  */\n-extern bool sched_insns_conditions_mutex_p (rtx, rtx);\n+extern bool sched_insns_conditions_mutex_p (const_rtx, const_rtx);\n extern void add_dependence (rtx, rtx, enum reg_note);\n extern void sched_analyze (struct deps *, rtx, rtx);\n extern bool deps_pools_are_empty_p (void);\n@@ -829,9 +829,9 @@ extern ds_t ds_merge (ds_t, ds_t);\n extern void debug_ds (ds_t);\n \n /* Functions in haifa-sched.c.  */\n-extern int haifa_classify_insn (rtx);\n+extern int haifa_classify_insn (const_rtx);\n extern void get_ebb_head_tail (basic_block, basic_block, rtx *, rtx *);\n-extern int no_real_insns_p (rtx, rtx);\n+extern int no_real_insns_p (const_rtx, const_rtx);\n \n extern void rm_other_notes (rtx, rtx);\n \n@@ -845,7 +845,7 @@ extern void sched_finish (void);\n \n extern int try_ready (rtx);\n extern void * xrecalloc (void *, size_t, size_t, size_t);\n-extern bool sched_insn_is_legitimate_for_speculation_p (rtx, ds_t);\n+extern bool sched_insn_is_legitimate_for_speculation_p (const_rtx, ds_t);\n extern void unlink_bb_notes (basic_block, basic_block);\n extern void add_block (basic_block, basic_block);\n extern rtx bb_note (basic_block);\n@@ -882,7 +882,7 @@ extern void debug_dependencies (rtx, rtx);\n /* A type to hold above flags.  */\n typedef int sd_list_types_def;\n \n-extern void sd_next_list (rtx, sd_list_types_def *, deps_list_t *, bool *);\n+extern void sd_next_list (const_rtx, sd_list_types_def *, deps_list_t *, bool *);\n \n /* Iterator to walk through, resolve and delete dependencies.  */\n struct _sd_iterator\n@@ -980,8 +980,8 @@ sd_iterator_next (sd_iterator_def *it_ptr)\n        sd_iterator_cond (&(ITER), &(DEP));\t\t\t\\\n        sd_iterator_next (&(ITER)))\n \n-extern int sd_lists_size (rtx, sd_list_types_def);\n-extern bool sd_lists_empty_p (rtx, sd_list_types_def);\n+extern int sd_lists_size (const_rtx, sd_list_types_def);\n+extern bool sd_lists_empty_p (const_rtx, sd_list_types_def);\n extern void sd_init_insn (rtx);\n extern void sd_finish_insn (rtx);\n extern dep_t sd_find_dep_between (rtx, rtx, bool);"}, {"sha": "6d9689ceff0a43db60d8d2bea339ba0a24fb8bb7", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -312,7 +312,7 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   sdbout_end_source_file,\t         /* end_source_file */\n   sdbout_begin_block,\t\t         /* begin_block */\n   sdbout_end_block,\t\t         /* end_block */\n-  debug_true_tree,\t\t         /* ignore_block */\n+  debug_true_const_tree,\t         /* ignore_block */\n   sdbout_source_line,\t\t         /* source_line */\n #ifdef MIPS_DEBUGGING_INFO\n   /* Defer on MIPS systems so that parameter descriptions follow"}, {"sha": "8e889fa0ecde4e5f058ecdf55a615c85589c70fe", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -104,7 +104,7 @@ static inline void change_bb_for_stmt (tree t, basic_block bb);\n \n /* Flowgraph optimization and cleanup.  */\n static void tree_merge_blocks (basic_block, basic_block);\n-static bool tree_can_merge_blocks_p (basic_block, basic_block);\n+static bool tree_can_merge_blocks_p (const_basic_block, const_basic_block);\n static void remove_bb (basic_block);\n static edge find_taken_edge_computed_goto (basic_block, tree);\n static edge find_taken_edge_cond_expr (basic_block, tree);\n@@ -1135,10 +1135,10 @@ group_case_labels (void)\n /* Checks whether we can merge block B into block A.  */\n \n static bool\n-tree_can_merge_blocks_p (basic_block a, basic_block b)\n+tree_can_merge_blocks_p (const_basic_block a, const_basic_block b)\n {\n-  tree stmt;\n-  block_stmt_iterator bsi;\n+  const_tree stmt;\n+  const_block_stmt_iterator bsi;\n   tree phi;\n \n   if (!single_succ_p (a))\n@@ -1158,7 +1158,7 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n \n   /* If A ends by a statement causing exceptions or something similar, we\n      cannot merge the blocks.  */\n-  stmt = last_stmt (a);\n+  stmt = const_last_stmt (a);\n   if (stmt && stmt_ends_bb_p (stmt))\n     return false;\n \n@@ -1184,9 +1184,9 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n     }\n \n   /* Do not remove user labels.  */\n-  for (bsi = bsi_start (b); !bsi_end_p (bsi); bsi_next (&bsi))\n+  for (bsi = cbsi_start (b); !cbsi_end_p (bsi); cbsi_next (&bsi))\n     {\n-      stmt = bsi_stmt (bsi);\n+      stmt = cbsi_stmt (bsi);\n       if (TREE_CODE (stmt) != LABEL_EXPR)\n \tbreak;\n       if (!DECL_ARTIFICIAL (LABEL_EXPR_LABEL (stmt)))\n@@ -2451,12 +2451,12 @@ is_ctrl_stmt (const_tree t)\n    (e.g., a call to a non-returning function).  */\n \n bool\n-is_ctrl_altering_stmt (tree t)\n+is_ctrl_altering_stmt (const_tree t)\n {\n-  tree call;\n+  const_tree call;\n \n   gcc_assert (t);\n-  call = get_call_expr_in (t);\n+  call = const_get_call_expr_in (t);\n   if (call)\n     {\n       /* A non-pure/const CALL_EXPR alters flow control if the current\n@@ -2558,7 +2558,7 @@ stmt_starts_bb_p (const_tree t, const_tree prev_t)\n /* Return true if T should end a basic block.  */\n \n bool\n-stmt_ends_bb_p (tree t)\n+stmt_ends_bb_p (const_tree t)\n {\n   return is_ctrl_stmt (t) || is_ctrl_altering_stmt (t);\n }\n@@ -4860,7 +4860,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n    it to the destination of the other edge from E->src.  */\n \n static bool\n-tree_can_remove_branch_p (edge e)\n+tree_can_remove_branch_p (const_edge e)\n {\n   if (e->flags & EDGE_ABNORMAL)\n     return false;\n@@ -4956,7 +4956,7 @@ tree_move_block_after (basic_block bb, basic_block after)\n /* Return true if basic_block can be duplicated.  */\n \n static bool\n-tree_can_duplicate_bb_p (basic_block bb ATTRIBUTE_UNUSED)\n+tree_can_duplicate_bb_p (const_basic_block bb ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n@@ -5917,20 +5917,20 @@ debug_loop_ir (void)\n    otherwise.  */\n \n static bool\n-tree_block_ends_with_call_p (basic_block bb)\n+tree_block_ends_with_call_p (const_basic_block bb)\n {\n-  block_stmt_iterator bsi = bsi_last (bb);\n-  return get_call_expr_in (bsi_stmt (bsi)) != NULL;\n+  const_block_stmt_iterator bsi = cbsi_last (bb);\n+  return const_get_call_expr_in (cbsi_stmt (bsi)) != NULL;\n }\n \n \n /* Return true if BB ends with a conditional branch.  Return false,\n    otherwise.  */\n \n static bool\n-tree_block_ends_with_condjump_p (basic_block bb)\n+tree_block_ends_with_condjump_p (const_basic_block bb)\n {\n-  tree stmt = last_stmt (bb);\n+  const_tree stmt = const_last_stmt (bb);\n   return (stmt && TREE_CODE (stmt) == COND_EXPR);\n }\n "}, {"sha": "8b195d7ad5c6cc1b5b867dd320e4730e030d420b", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -148,22 +148,24 @@ remove_stmt_from_eh_region (tree t)\n }\n \n int\n-lookup_stmt_eh_region_fn (struct function *ifun, tree t)\n+lookup_stmt_eh_region_fn (struct function *ifun, const_tree t)\n {\n   struct throw_stmt_node *p, n;\n \n   if (!get_eh_throw_stmt_table (ifun))\n     return -2;\n \n-  n.stmt = t;\n+  /* The CONST_CAST is okay because we don't modify n.stmt throughout\n+     its scope, or the scope of p.  */\n+  n.stmt = (tree) CONST_CAST (t);\n   p = (struct throw_stmt_node *) htab_find (get_eh_throw_stmt_table (ifun),\n                                             &n);\n \n   return (p ? p->region_nr : -1);\n }\n \n int\n-lookup_stmt_eh_region (tree t)\n+lookup_stmt_eh_region (const_tree t)\n {\n   /* We can get called from initialized data when -fnon-call-exceptions\n      is on; prevent crash.  */\n@@ -2032,7 +2034,7 @@ tree_could_throw_p (tree t)\n }\n \n bool\n-tree_can_throw_internal (tree stmt)\n+tree_can_throw_internal (const_tree stmt)\n {\n   int region_nr;\n   bool is_resx = false;"}, {"sha": "a5441fefacf6a8559b05d5b03b130d7dd57b81eb", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -611,7 +611,7 @@ addresses_taken (tree stmt)\n /* Return the PHI nodes for basic block BB, or NULL if there are no\n    PHI nodes.  */\n static inline tree\n-phi_nodes (basic_block bb)\n+phi_nodes (const_basic_block bb)\n {\n   gcc_assert (!(bb->flags & BB_RTL));\n   if (!bb->il.tree)"}, {"sha": "044a520b7105b1333ec7ed2efaad164489b75d18", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -545,7 +545,7 @@ struct edge_prediction GTY((chain_next (\"%h.ep_next\")))\n };\n \n /* Accessors for basic block annotations.  */\n-static inline tree phi_nodes (basic_block);\n+static inline tree phi_nodes (const_basic_block);\n static inline void set_phi_nodes (basic_block, tree);\n \n /*---------------------------------------------------------------------------\n@@ -721,9 +721,9 @@ extern void free_omp_regions (void);\n #define PENDING_STMT(e)\t((e)->insns.t)\n \n extern void delete_tree_cfg_annotations (void);\n-extern bool stmt_ends_bb_p (tree);\n+extern bool stmt_ends_bb_p (const_tree);\n extern bool is_ctrl_stmt (const_tree);\n-extern bool is_ctrl_altering_stmt (tree);\n+extern bool is_ctrl_altering_stmt (const_tree);\n extern bool computed_goto_p (const_tree);\n extern bool simple_goto_p (const_tree);\n extern bool tree_can_make_abnormal_goto (const_tree);\n@@ -1073,9 +1073,9 @@ static inline bool unmodifiable_var_p (const_tree);\n extern void make_eh_edges (tree);\n extern bool tree_could_trap_p (tree);\n extern bool tree_could_throw_p (tree);\n-extern bool tree_can_throw_internal (tree);\n+extern bool tree_can_throw_internal (const_tree);\n extern bool tree_can_throw_external (tree);\n-extern int lookup_stmt_eh_region (tree);\n+extern int lookup_stmt_eh_region (const_tree);\n extern void add_stmt_to_eh_region (tree, int);\n extern bool remove_stmt_from_eh_region (tree);\n extern bool maybe_clean_or_replace_eh_stmt (tree, tree);"}, {"sha": "42a29adf961ab3eb014049c821d082605921c31b", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -436,18 +436,28 @@ is_gimple_call_addr (tree t)\n /* If T makes a function call, return the corresponding CALL_EXPR operand.\n    Otherwise, return NULL_TREE.  */\n \n+#define GET_CALL_EXPR_IN_BODY do { \\\n+  /* FIXME tuples: delete the assertion below when conversion complete.  */ \\\n+  gcc_assert (TREE_CODE (t) != MODIFY_EXPR); \\\n+  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT) \\\n+    t = GIMPLE_STMT_OPERAND (t, 1); \\\n+  if (TREE_CODE (t) == WITH_SIZE_EXPR) \\\n+    t = TREE_OPERAND (t, 0); \\\n+  if (TREE_CODE (t) == CALL_EXPR) \\\n+    return t; \\\n+  return NULL_TREE; \\\n+} while (0)\n+\n tree\n get_call_expr_in (tree t)\n {\n-  /* FIXME tuples: delete the assertion below when conversion complete.  */\n-  gcc_assert (TREE_CODE (t) != MODIFY_EXPR);\n-  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n-    t = GIMPLE_STMT_OPERAND (t, 1);\n-  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-  if (TREE_CODE (t) == CALL_EXPR)\n-    return t;\n-  return NULL_TREE;\n+  GET_CALL_EXPR_IN_BODY;\n+}\n+\n+const_tree\n+const_get_call_expr_in (const_tree t)\n+{\n+  GET_CALL_EXPR_IN_BODY;\n }\n \n /* Given a memory reference expression T, return its base address."}, {"sha": "3a121c0791653bb13754b728542e3f18d3f69c6e", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -90,6 +90,7 @@ extern bool is_gimple_non_addressable (tree t);\n extern bool is_gimple_call_addr (tree);\n /* If T makes a function call, returns the CALL_EXPR operand.  */\n extern tree get_call_expr_in (tree t);\n+extern const_tree const_get_call_expr_in (const_tree t);\n \n extern void recalculate_side_effects (tree);\n "}, {"sha": "759c06aea90d760a83afe3f30407a6b8e3e2652b", "filename": "gcc/tree.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -3811,20 +3811,28 @@ is_attribute_p (const char *attr, const_tree ident)\n    returns the first occurrence; the TREE_CHAIN of the return value should\n    be passed back in if further occurrences are wanted.  */\n \n+#define LOOKUP_ATTRIBUTE_BODY(TYPE) do { \\\n+  TYPE l; \\\n+  size_t attr_len = strlen (attr_name); \\\n+  for (l = list; l; l = TREE_CHAIN (l)) \\\n+    { \\\n+      gcc_assert (TREE_CODE (TREE_PURPOSE (l)) == IDENTIFIER_NODE); \\\n+      if (is_attribute_with_length_p (attr_name, attr_len, TREE_PURPOSE (l))) \\\n+\treturn l; \\\n+    } \\\n+  return NULL_TREE; \\\n+} while (0)\n+\n tree\n lookup_attribute (const char *attr_name, tree list)\n {\n-  tree l;\n-  size_t attr_len = strlen (attr_name);\n-\n-  for (l = list; l; l = TREE_CHAIN (l))\n-    {\n-      gcc_assert (TREE_CODE (TREE_PURPOSE (l)) == IDENTIFIER_NODE);\n-      if (is_attribute_with_length_p (attr_name, attr_len, TREE_PURPOSE (l)))\n-\treturn l;\n-    }\n+  LOOKUP_ATTRIBUTE_BODY(tree);\n+}\n \n-  return NULL_TREE;\n+const_tree\n+const_lookup_attribute (const char *attr_name, const_tree list)\n+{\n+  LOOKUP_ATTRIBUTE_BODY(const_tree);\n }\n \n /* Remove any instances of attribute ATTR_NAME in LIST and return the\n@@ -4757,7 +4765,7 @@ attribute_hash_list (const_tree list, hashval_t hashcode)\n    equivalent to l1.  */\n \n int\n-attribute_list_equal (tree l1, tree l2)\n+attribute_list_equal (const_tree l1, const_tree l2)\n {\n   return attribute_list_contained (l1, l2)\n \t && attribute_list_contained (l2, l1);\n@@ -4772,9 +4780,9 @@ attribute_list_equal (tree l1, tree l2)\n    correctly.  */\n \n int\n-attribute_list_contained (tree l1, tree l2)\n+attribute_list_contained (const_tree l1, const_tree l2)\n {\n-  tree t1, t2;\n+  const_tree t1, t2;\n \n   /* First check the obvious, maybe the lists are identical.  */\n   if (l1 == l2)\n@@ -4793,11 +4801,11 @@ attribute_list_contained (tree l1, tree l2)\n \n   for (; t2 != 0; t2 = TREE_CHAIN (t2))\n     {\n-      tree attr;\n-      for (attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n+      const_tree attr;\n+      for (attr = const_lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n \t   attr != NULL_TREE;\n-\t   attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n-\t\t\t\t    TREE_CHAIN (attr)))\n+\t   attr = const_lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t\t  TREE_CHAIN (attr)))\n \t{\n \t  if (TREE_VALUE (t2) != NULL\n \t      && TREE_CODE (TREE_VALUE (t2)) == TREE_LIST"}, {"sha": "43f402146b43850472c25b4dfb5d148695f14120", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -3998,8 +3998,8 @@ extern bool range_in_array_bounds_p (tree);\n extern tree value_member (tree, tree);\n extern tree purpose_member (const_tree, tree);\n \n-extern int attribute_list_equal (tree, tree);\n-extern int attribute_list_contained (tree, tree);\n+extern int attribute_list_equal (const_tree, const_tree);\n+extern int attribute_list_contained (const_tree, const_tree);\n extern int tree_int_cst_equal (const_tree, const_tree);\n extern int tree_int_cst_lt (const_tree, const_tree);\n extern int tree_int_cst_compare (const_tree, const_tree);\n@@ -4143,6 +4143,7 @@ extern int is_attribute_p (const char *, const_tree);\n    of the attribute or NULL_TREE if not found.  */\n \n extern tree lookup_attribute (const char *, tree);\n+extern const_tree const_lookup_attribute (const char *, const_tree);\n \n /* Remove any instances of attribute ATTR_NAME in LIST and return the\n    modified list.  */"}, {"sha": "27197c17f7ea7b0f485fa8d2f19b960f89ffbfa1", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678086db16d5d3a30413db35157975d3bd25774/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=9678086db16d5d3a30413db35157975d3bd25774", "patch": "@@ -172,7 +172,7 @@ static void vmsdbgout_start_source_file (unsigned int, const char *);\n static void vmsdbgout_end_source_file (unsigned int);\n static void vmsdbgout_begin_block (unsigned int, unsigned int);\n static void vmsdbgout_end_block (unsigned int, unsigned int);\n-static bool vmsdbgout_ignore_block (tree);\n+static bool vmsdbgout_ignore_block (const_tree);\n static void vmsdbgout_source_line (unsigned int, const char *);\n static void vmsdbgout_begin_prologue (unsigned int, const char *);\n static void vmsdbgout_end_prologue (unsigned int, const char *);\n@@ -1363,7 +1363,7 @@ vmsdbgout_end_block (register unsigned line, register unsigned blocknum)\n /* Not implemented in VMS Debug.  */\n \n static bool\n-vmsdbgout_ignore_block (tree block)\n+vmsdbgout_ignore_block (const_tree block)\n {\n   bool retval = 0;\n "}]}