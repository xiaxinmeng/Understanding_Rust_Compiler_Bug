{"sha": "78bde837ec571ff83cb5c890c7e49c4144a6a1db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiZGU4MzdlYzU3MWZmODNjYjVjODkwYzdlNDljNDE0NGE2YTFkYg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-06-17T21:08:39Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-06-17T21:08:39Z"}, "message": "cfglayout.h: Remove.\n\n2012-06-17  Steven Bosscher  <steven@gcc.gnu.org>\n\n\t* cfglayout.h: Remove.\n\t* cfglayout.c: Remove.\n\t* function.h (struct function): Remove x_last_location field.\n\t* function.c: Do not include cfglayout.h.\n\t(expand_function_start): Do not call no-op force_next_line_note.\n\t(expand_function_end): Likewise.\n\t* cfgrtl.c: Do not include cfglayout.h.  Include gt-cfgrtl.h.\n\t(unlink_insn_chain): Moved here from cfglayout.c.\n\t(skip_insns_after_block, label_for_bb, record_effective_endpoints,\n\tinto_cfg_layout_mode, outof_cfg_layout_mode,\n\tpass_into_cfg_layout_mode, pass_outof_cfg_layout_mode,\n\trelink_block_chain, fixup_reorder_chain, verify_insn_chain,\n\tfixup_fallthru_exit_predecessor, force_one_exit_fallthru,\n\tcfg_layout_can_duplicate_bb_p, duplicate_insn_chain,\n\tcfg_layout_duplicate_bb, cfg_layout_initialize, break_superblocks,\n\tcfg_layout_finalize): Likewise.\n\t(rtl_can_remove_branch_p): Likewise.\n\t* rtl.h (insn_scope): Move prototype from cfglayout.h here.\n\t(duplicate_insn_chain): Likewise.\n\t(force_next_line_note): Remove prototype.\n\t* emit-rtl.c: Do not include tree-flow.h, egad.  Include vecprim.h.\n\t(last_location): Remove #define to emit.x_last_location.\n\t(force_next_line_note): Remove no-op function.\n\t(init_emit): Don't set x_last_location.\n\t(block_locators_locs, block_locators_blocks, locations_locators_locs,\n\tlocations_locators_vals, prologue_locator, epilogue_locator,\n\tcurr_location, last_location, curr_block, last_block, curr_rtl_loc):\n\tMove POD to here from cfglayout.c.\n\t(insn_locators_alloc, insn_locators_finalize, insn_locators_free,\n\tset_curr_insn_source_location, get_curr_insn_source_location,\n\tset_curr_insn_block, get_curr_insn_block, curr_insn_locator,\n\tlocator_scope, insn_scope, locator_location, locator_line, insn_line,\n\tlocator_file, insn_file, locator_eq): Move to here from cfglayout.c.\n\t* cfghooks.h: Remove double-include protection.\n\t(can_copy_bbs_p, copy_bbs): Move prototypes from cfglayout.h to here.\n\t* cfghooks.c (can_copy_bbs_p, copy_bbs): Move to here from cfglayout.c.\n\t* final.c: Do not include cfglayout.h.\n\t(choose_inner_scope, change_scope): Move to here from cfglayout.c.\n\t(reemit_insn_block_notes): Likewise.  Make static.\n\t* tree-flow.h (tree_could_trap_p, operation_could_trap_helper_p,\n\toperation_could_trap_p, tree_could_throw_p): Move from here...\n\t* tree.h: ... to here.\n\t* gengtype.c (open_base_files): Remove cfglayout.h from the list.\n\t* profile.c: Do not include cfghooks.h.\n\t* cfgloopmanip.c: Do not include cfglayout.h and cfghooks.h.\n\t* modulo-sched.c: Likewise.\n\t* loop-unswitch.c: Do not include cfglayout.h.\n\t* sched-ebb.c: Likewise.\n\t* tracer.c: Likewise.\n\t* ddg.c: Likewise.\n\t* tree-vect-loop-manip.c: Likewise.\n\t* loop-init.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* hw-doloop.c: Likewise.\n\t* loop-unroll.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* bb-reorder.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* tree-cfg.c: Likewise.\n\t* config/alpha/alpha.c: Likewise.\n\t* config/spu/spu.c: Likewise.\n\t* config/sparc/sparc.c: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/c6x/c6x.c: Likewise.\n\t* config/ia64/ia64.c: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/score/score.c: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/bfin/bfin.c: Likewise.\n\t* Makefile.in (CFGAYOUT_H): Remove, and fixup users.\n\t* config/rs6000/t-rs6000 (rs6000.o): Do not depend on cfglayout.h.\n\t* config/spu/t-spu-elf (spu.o: $): Likewise.\n\t* config/sparc/t-sparc (sparc.o): Do not depend on CFGLAYOUT_H.\n\nFrom-SVN: r188712", "tree": {"sha": "1716ec5f5eb641fe82e493441959f78d3212142b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1716ec5f5eb641fe82e493441959f78d3212142b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78bde837ec571ff83cb5c890c7e49c4144a6a1db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bde837ec571ff83cb5c890c7e49c4144a6a1db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bde837ec571ff83cb5c890c7e49c4144a6a1db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bde837ec571ff83cb5c890c7e49c4144a6a1db/comments", "author": null, "committer": null, "parents": [{"sha": "1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1"}], "stats": {"total": 3142, "additions": 1499, "deletions": 1643}, "files": [{"sha": "156a6b1f66839f34b29f7a698d55f867ad539460", "filename": "gcc/Makefile.in", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -896,7 +896,6 @@ SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H) \\\n SEL_SCHED_IR_H = sel-sched-ir.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) \\\n \t$(GGC_H) $(BITMAP_H) vecprim.h $(SCHED_INT_H) $(CFGLOOP_H) $(REGSET_H)\n SEL_SCHED_DUMP_H = sel-sched-dump.h $(SEL_SCHED_IR_H)\n-CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)\n CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) vecprim.h double-int.h \\\n \t$(BITMAP_H) sbitmap.h\n IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n@@ -1186,7 +1185,6 @@ OBJS = \\\n \tcfgcleanup.o \\\n \tcfgexpand.o \\\n \tcfghooks.o \\\n-\tcfglayout.o \\\n \tcfgloop.o \\\n \tcfgloopanal.o \\\n \tcfgloopmanip.o \\\n@@ -2172,7 +2170,7 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(INPUT_H) $(TREE_H) $(RTL_H) $(FUNCTION_H) insn-config.h $(EXPR_H) \\\n \thard-reg-set.h $(BASIC_BLOCK_H) cselib.h $(INSN_ADDR_H) $(OPTABS_H) \\\n \t$(LIBFUNCS_H) debug.h $(GGC_H) $(CGRAPH_H) $(TREE_FLOW_H) reload.h \\\n-\t$(CPP_ID_DATA_H) tree-chrec.h $(CFGLAYOUT_H) $(EXCEPT_H) output.h \\\n+\t$(CPP_ID_DATA_H) tree-chrec.h $(EXCEPT_H) output.h \\\n \t$(CFGLOOP_H) $(TARGET_H) $(IPA_PROP_H) $(LTO_STREAMER_H) \\\n \ttarget-globals.h\n \n@@ -2443,7 +2441,7 @@ tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TM_P_H) $(GGC_H) $(FLAGS_H) \\\n    $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(EXCEPT_H) langhooks.h $(CFGLOOP_H) $(TREE_PASS_H) \\\n-   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) \\\n+   $(BASIC_BLOCK_H) \\\n    value-prof.h tree-ssa-propagate.h $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)\n tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TM_P_H) $(GGC_H) $(FLAGS_H) \\\n@@ -2652,7 +2650,7 @@ tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(GIMPLE_PRETTY_PRINT_H) $(TARGET_H) $(TREE_DATA_REF_H)\n tree-vect-loop-manip.o: tree-vect-loop-manip.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) \\\n-   $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(CFGLAYOUT_H) $(DIAGNOSTIC_CORE_H) \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(DIAGNOSTIC_CORE_H) \\\n    $(SCEV_H) $(TREE_VECTORIZER_H) langhooks.h $(GIMPLE_PRETTY_PRINT_H)\n tree-vect-patterns.o: tree-vect-patterns.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(TARGET_H) $(BASIC_BLOCK_H) \\\n@@ -2756,7 +2754,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RECOG_H) Makefile toplev.h $(DWARF2OUT_H) sdbout.h dbxout.h $(EXPR_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(EXCEPT_H) $(REGS_H) $(TIMEVAR_H) \\\n    value-prof.h $(PARAMS_H) $(TM_P_H) reload.h ira.h dwarf2asm.h $(TARGET_H) \\\n-   langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \\\n+   langhooks.h insn-flags.h $(CFGLOOP_H) hosthooks.h \\\n    $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) \\\n    $(OPTS_H) params.def tree-mudflap.h $(TREE_PASS_H) $(GIMPLE_H) \\\n    tree-ssa-alias.h $(PLUGIN_H) realmpfr.h tree-diagnostic.h \\\n@@ -2807,7 +2805,7 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(CGRAPH_H) $(TARGET_DEF_H) tree-mudflap.h \\\n    pointer-set.h $(COMMON_TARGET_H)\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n-   $(TREE_H) $(CFGLAYOUT_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \\\n+   $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \\\n    $(OPTABS_H) $(LIBFUNCS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h  $(EXCEPT_H) $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n    gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(PREDICT_H) \\\n@@ -2880,7 +2878,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(LIBFUNCS_H) toplev.h $(DIAGNOSTIC_CORE_H) $(DWARF2OUT_H) reload.h \\\n    $(GGC_H) $(EXCEPT_H) dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) \\\n    gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) $(MD5_H) $(INPUT_H) $(FUNCTION_H) \\\n-   $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H) $(CFGLAYOUT_H) \\\n+   $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n    $(TREE_PRETTY_PRINT_H) $(COMMON_TARGET_H) $(OPTS_H)\n dwarf2cfi.o : dwarf2cfi.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    version.h $(RTL_H) $(EXPR_H) $(REGS_H) $(FUNCTION_H) output.h \\\n@@ -2897,10 +2895,10 @@ xcoffout.o : xcoffout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n godump.o : godump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) \\\n    $(TREE_H) $(GGC_H) pointer-set.h $(OBSTACK_H) debug.h gt-godump.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \\\n+   $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) vecprim.h \\\n    $(GGC_H) $(EXPR_H) hard-reg-set.h $(BITMAP_H) $(DIAGNOSTIC_CORE_H) $(BASIC_BLOCK_H) \\\n    $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h $(TREE_PASS_H) gt-emit-rtl.h \\\n-   $(DF_H) $(PARAMS_H) $(TARGET_H) $(TREE_FLOW_H)\n+   $(DF_H) $(PARAMS_H) $(TARGET_H)\n real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(REAL_H) dfp.h realmpfr.h\n realmpfr.o : realmpfr.c realmpfr.h $(CONFIG_H) $(SYSTEM_H) $(REAL_H) $(TREE_H)\n@@ -3135,7 +3133,7 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    pointer-set.h $(RECOG_H) $(TM_P_H) $(TREE_PRETTY_PRINT_H) $(ALIAS_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(REGS_H) $(EXPR_H) $(FUNCTION_H) $(BASIC_BLOCK_H) \\\n-   $(DIAGNOSTIC_CORE_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\\n+   $(DIAGNOSTIC_CORE_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h \\\n    $(CFGLOOP_H) $(TIMEVAR_H) $(TREE_PASS_H) profile.h\n mcf.o : mcf.c profile.h $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h \\\n    $(BASIC_BLOCK_H) langhooks.h $(GCOV_IO_H) $(TREE_H) \n@@ -3174,8 +3172,8 @@ cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    $(FUNCTION_H) $(EXCEPT_H) $(TM_P_H) $(INSN_ATTR_H) \\\n    insn-config.h $(EXPR_H) \\\n-   $(CFGLAYOUT_H) $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \\\n-   $(TREE_PASS_H) $(DF_H) $(GGC_H) $(COMMON_TARGET_H)\n+   $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \\\n+   $(TREE_PASS_H) $(DF_H) $(GGC_H) $(COMMON_TARGET_H) gt-cfgrtl.h\n cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(TM_P_H) \\\n    $(TIMEVAR_H) $(OBSTACK_H) $(DIAGNOSTIC_CORE_H) vecprim.h sbitmap.h \\\n@@ -3186,7 +3184,7 @@ cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TIMEVAR_H) hard-reg-set.h $(FLAGS_H) $(RECOG_H) \\\n    $(DIAGNOSTIC_CORE_H) insn-config.h cselib.h $(TARGET_H) $(TM_P_H) $(PARAMS_H) \\\n-   $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) $(TREE_PASS_H) $(CFGLOOP_H) $(EXPR_H) \\\n+   $(REGS_H) $(EMIT_RTL_H) $(FUNCTION_H) $(TREE_PASS_H) $(CFGLOOP_H) $(EXPR_H) \\\n    $(DF_H) $(DBGCNT_H) dce.h\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(FLAGS_H) $(FUNCTION_H) \\\n@@ -3205,17 +3203,17 @@ loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    coretypes.h $(TM_H) $(TM_P_H) $(FUNCTION_H) $(FLAGS_H) $(DF_H) \\\n    $(OBSTACK_H) $(HASHTAB_H) $(EXCEPT_H) $(PARAMS_H) $(REGS_H) ira.h\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n-   coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H) $(TREE_FLOW_H)\n+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) \\\n+   coretypes.h $(TM_H) $(OBSTACK_H) $(TREE_FLOW_H)\n loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(GGC_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) \\\n    coretypes.h $(TM_H) $(OBSTACK_H) $(TREE_PASS_H) $(TIMEVAR_H) $(FLAGS_H) \\\n    $(DF_H)\n loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(PARAMS_H) \\\n    $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H)\n loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(PARAMS_H) \\\n    $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H) \\\n    $(OBSTACK_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n@@ -3328,13 +3326,13 @@ compare-elim.o : compare-elim.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n ddg.o : ddg.c $(DDG_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) \\\n    $(DIAGNOSTIC_CORE_H) $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) \\\n-   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) $(BITMAP_H) \\\n+   $(SCHED_INT_H) $(CFGLOOP_H) $(EXPR_H) $(BITMAP_H) \\\n    hard-reg-set.h sbitmap.h $(TM_H)\n modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TARGET_H) $(DIAGNOSTIC_CORE_H) $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) \\\n-   $(SCHED_INT_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(EXPR_H) $(PARAMS_H) \\\n-   cfghooks.h $(GCOV_IO_H) hard-reg-set.h $(TM_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n+   $(SCHED_INT_H) $(CFGLOOP_H) $(EXPR_H) $(PARAMS_H) \\\n+   $(GCOV_IO_H) hard-reg-set.h $(TM_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(DF_H) $(DBGCNT_H)\n haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \\\n@@ -3348,12 +3346,12 @@ sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \\\n-   $(TM_P_H) sel-sched.h $(TARGET_H) $(CFGLAYOUT_H) $(TIMEVAR_H) $(TREE_PASS_H)  \\\n+   $(TM_P_H) sel-sched.h $(TARGET_H) $(TIMEVAR_H) $(TREE_PASS_H)  \\\n    $(DBGCNT_H)\n sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) $(TM_P_H) \\\n-   $(PARAMS_H) $(CFGLAYOUT_H) $(TARGET_H)\n+   $(PARAMS_H) $(TARGET_H)\n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H) \\\n    $(TREE_PASS_H) $(INSN_ATTR_H)\n@@ -3366,7 +3364,7 @@ sel-sched.o : sel-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n sel-sched-dump.o : sel-sched-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \\\n-   $(TM_P_H) $(TARGET_H) $(CFGLAYOUT_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n+   $(TM_P_H) $(TARGET_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(SEL_SCHED_DUMP_H) $(GGC_H) $(TREE_H) $(LANGHOOKS_DEF_H) $(SEL_SCHED_IR_H) \\\n    $(BASIC_BLOCK_H) cselib.h\n sel-sched-ir.o : sel-sched-ir.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -3380,7 +3378,7 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    insn-config.h $(INSN_ATTR_H) $(FUNCTION_H) output.h hard-reg-set.h \\\n    $(EXCEPT_H) debug.h xcoffout.h toplev.h $(DIAGNOSTIC_CORE_H) reload.h $(DWARF2OUT_H) \\\n    $(TREE_PASS_H) $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) \\\n-   $(CFGLAYOUT_H) dbxout.h $(TIMEVAR_H) $(CGRAPH_H) $(COVERAGE_H) \\\n+   dbxout.h $(TIMEVAR_H) $(CGRAPH_H) $(COVERAGE_H) \\\n    $(DF_H) vecprim.h $(GGC_H) $(CFGLOOP_H) $(PARAMS_H) $(TREE_FLOW_H) \\\n    $(TARGET_DEF_H) $(TREE_PRETTY_PRINT_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n@@ -3403,19 +3401,14 @@ predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n    $(RTL_H) $(GGC_H) gt-lists.h\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(RTL_H) $(FLAGS_H) $(TIMEVAR_H) output.h $(CFGLAYOUT_H) $(FIBHEAP_H) \\\n+   $(RTL_H) $(FLAGS_H) $(TIMEVAR_H) output.h $(FIBHEAP_H) \\\n    $(TARGET_H) $(FUNCTION_H) $(TM_P_H) $(OBSTACK_H) $(EXPR_H) $(REGS_H) \\\n    $(PARAMS_H) toplev.h $(DIAGNOSTIC_CORE_H) $(TREE_PASS_H) $(DF_H) \\\n    $(EXCEPT_H) bb-reorder.h\n tracer.o : tracer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLAYOUT_H) \\\n+   $(TREE_H) $(BASIC_BLOCK_H) hard-reg-set.h \\\n    $(FLAGS_H) $(TIMEVAR_H) $(PARAMS_H) $(COVERAGE_H) $(FIBHEAP_H) \\\n    $(TREE_PASS_H) $(TREE_FLOW_H) $(TREE_INLINE_H) $(CFGLOOP_H)\n-cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(RTL_H) $(TREE_H) insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n-   $(FUNCTION_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(TARGET_H) gt-cfglayout.h \\\n-   $(GGC_H) alloc-pool.h $(FLAGS_H) $(OBSTACK_H) $(TREE_PASS_H) vecprim.h \\\n-   $(DF_H) $(EMIT_RTL_H) $(COMMON_TARGET_H)\n timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) $(TIMEVAR_H)\n regcprop.o : regcprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n@@ -3451,7 +3444,7 @@ target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    lower-subreg.h\n hw-doloop.o : hw-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n-   $(DF_H) $(CFGLAYOUT_H) $(CFGLOOP_H) $(RECOG_H) $(TARGET_H) \\\n+   $(DF_H) $(CFGLOOP_H) $(RECOG_H) $(TARGET_H) \\\n    $(REGS_H) hw-doloop.h\n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\\n@@ -3741,7 +3734,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/gcse.c $(srcdir)/godump.c \\\n   $(srcdir)/lists.c $(srcdir)/optabs.c \\\n   $(srcdir)/profile.c $(srcdir)/mcf.c \\\n-  $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/cfglayout.h \\\n+  $(srcdir)/reg-stack.c $(srcdir)/cfgrtl.c \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(srcdir)/gimple.h $(srcdir)/gimple.c \\"}, {"sha": "143bdd0c16870fa9687fb6f05c316b8060193823", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -74,7 +74,6 @@\n #include \"flags.h\"\n #include \"timevar.h\"\n #include \"output.h\"\n-#include \"cfglayout.h\"\n #include \"fibheap.h\"\n #include \"target.h\"\n #include \"function.h\""}, {"sha": "909d3462d7454b1d941986f0ae3fc5cf1c65cadb", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -47,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n-#include \"cfglayout.h\"\n+#include \"function.h\" /* For inline functions in emit-rtl.h they need crtl.  */\n #include \"emit-rtl.h\"\n #include \"tree-pass.h\"\n #include \"cfgloop.h\""}, {"sha": "5b49d64f0905eca3ab6828dc2d1e68a21878cf34", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -1161,3 +1161,124 @@ lv_add_condition_to_bb (basic_block first, basic_block second,\n   gcc_assert (cfg_hooks->lv_add_condition_to_bb);\n   cfg_hooks->lv_add_condition_to_bb (first, second, new_block, cond);\n }\n+\n+/* Checks whether all N blocks in BBS array can be copied.  */\n+bool\n+can_copy_bbs_p (basic_block *bbs, unsigned n)\n+{\n+  unsigned i;\n+  edge e;\n+  int ret = true;\n+\n+  for (i = 0; i < n; i++)\n+    bbs[i]->flags |= BB_DUPLICATED;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      /* In case we should redirect abnormal edge during duplication, fail.  */\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n+\tif ((e->flags & EDGE_ABNORMAL)\n+\t    && (e->dest->flags & BB_DUPLICATED))\n+\t  {\n+\t    ret = false;\n+\t    goto end;\n+\t  }\n+\n+      if (!can_duplicate_block_p (bbs[i]))\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+    }\n+\n+end:\n+  for (i = 0; i < n; i++)\n+    bbs[i]->flags &= ~BB_DUPLICATED;\n+\n+  return ret;\n+}\n+\n+/* Duplicates N basic blocks stored in array BBS.  Newly created basic blocks\n+   are placed into array NEW_BBS in the same order.  Edges from basic blocks\n+   in BBS are also duplicated and copies of those of them\n+   that lead into BBS are redirected to appropriate newly created block.  The\n+   function assigns bbs into loops (copy of basic block bb is assigned to\n+   bb->loop_father->copy loop, so this must be set up correctly in advance)\n+   and updates dominators locally (LOOPS structure that contains the information\n+   about dominators is passed to enable this).\n+\n+   BASE is the superloop to that basic block belongs; if its header or latch\n+   is copied, we do not set the new blocks as header or latch.\n+\n+   Created copies of N_EDGES edges in array EDGES are stored in array NEW_EDGES,\n+   also in the same order.\n+\n+   Newly created basic blocks are put after the basic block AFTER in the\n+   instruction stream, and the order of the blocks in BBS array is preserved.  */\n+\n+void\n+copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n+\t  edge *edges, unsigned num_edges, edge *new_edges,\n+\t  struct loop *base, basic_block after)\n+{\n+  unsigned i, j;\n+  basic_block bb, new_bb, dom_bb;\n+  edge e;\n+\n+  /* Duplicate bbs, update dominators, assign bbs to loops.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      /* Duplicate.  */\n+      bb = bbs[i];\n+      new_bb = new_bbs[i] = duplicate_block (bb, NULL, after);\n+      after = new_bb;\n+      bb->flags |= BB_DUPLICATED;\n+      /* Possibly set loop header.  */\n+      if (bb->loop_father->header == bb && bb->loop_father != base)\n+\tnew_bb->loop_father->header = new_bb;\n+      /* Or latch.  */\n+      if (bb->loop_father->latch == bb && bb->loop_father != base)\n+\tnew_bb->loop_father->latch = new_bb;\n+    }\n+\n+  /* Set dominators.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      bb = bbs[i];\n+      new_bb = new_bbs[i];\n+\n+      dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      if (dom_bb->flags & BB_DUPLICATED)\n+\t{\n+\t  dom_bb = get_bb_copy (dom_bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, new_bb, dom_bb);\n+\t}\n+    }\n+\n+  /* Redirect edges.  */\n+  for (j = 0; j < num_edges; j++)\n+    new_edges[j] = NULL;\n+  for (i = 0; i < n; i++)\n+    {\n+      edge_iterator ei;\n+      new_bb = new_bbs[i];\n+      bb = bbs[i];\n+\n+      FOR_EACH_EDGE (e, ei, new_bb->succs)\n+\t{\n+\t  for (j = 0; j < num_edges; j++)\n+\t    if (edges[j] && edges[j]->src == bb && edges[j]->dest == e->dest)\n+\t      new_edges[j] = e;\n+\n+\t  if (!(e->dest->flags & BB_DUPLICATED))\n+\t    continue;\n+\t  redirect_edge_and_branch_force (e, get_bb_copy (e->dest));\n+\t}\n+    }\n+\n+  /* Clear information about duplicates.  */\n+  for (i = 0; i < n; i++)\n+    bbs[i]->flags &= ~BB_DUPLICATED;\n+}\n+"}, {"sha": "adf6a893b0085452d587a994a5b1bbf478647685", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -19,8 +19,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-#ifndef GCC_CFGHOOKS_H\n-#define GCC_CFGHOOKS_H\n+/* Only basic-block.h includes this.  */\n \n struct cfg_hooks\n {\n@@ -185,6 +184,14 @@ extern void lv_adjust_loop_header_phi (basic_block, basic_block, basic_block,\n extern void lv_add_condition_to_bb (basic_block, basic_block, basic_block,\n \t\t\t\t    void *);\n \n+extern bool can_copy_bbs_p (basic_block *, unsigned);\n+extern void copy_bbs (basic_block *, unsigned, basic_block *,\n+\t\t      edge *, unsigned, edge *, struct loop *,\n+\t\t      basic_block);\n+\n+extern void cfg_layout_initialize (unsigned int);\n+extern void cfg_layout_finalize (void);\n+\n /* Hooks containers.  */\n extern struct cfg_hooks gimple_cfg_hooks;\n extern struct cfg_hooks rtl_cfg_hooks;\n@@ -198,4 +205,3 @@ extern void gimple_register_cfg_hooks (void);\n extern struct cfg_hooks get_cfg_hooks (void);\n extern void set_cfg_hooks (struct cfg_hooks);\n \n-#endif  /* GCC_CFGHOOKS_H */"}, {"sha": "3ab0ec0a138271d5dda2324d87a61da23877b227", "filename": "gcc/cfglayout.c", "status": "removed", "additions": 0, "deletions": 1498, "changes": 1498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1", "patch": "@@ -1,1498 +0,0 @@\n-/* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"obstack.h\"\n-#include \"basic-block.h\"\n-#include \"insn-config.h\"\n-#include \"function.h\"\n-#include \"cfglayout.h\"\n-#include \"cfgloop.h\"\n-#include \"target.h\"\n-#include \"common/common-target.h\"\n-#include \"ggc.h\"\n-#include \"alloc-pool.h\"\n-#include \"flags.h\"\n-#include \"tree-pass.h\"\n-#include \"df.h\"\n-#include \"vecprim.h\"\n-#include \"emit-rtl.h\"\n-\n-/* Holds the interesting trailing notes for the function.  */\n-rtx cfg_layout_function_footer;\n-rtx cfg_layout_function_header;\n-\n-static rtx skip_insns_after_block (basic_block);\n-static void record_effective_endpoints (void);\n-static rtx label_for_bb (basic_block);\n-static void fixup_reorder_chain (void);\n-\n-static void change_scope (rtx, tree, tree);\n-\n-void verify_insn_chain (void);\n-static void fixup_fallthru_exit_predecessor (void);\n-\f\n-rtx\n-unlink_insn_chain (rtx first, rtx last)\n-{\n-  rtx prevfirst = PREV_INSN (first);\n-  rtx nextlast = NEXT_INSN (last);\n-\n-  PREV_INSN (first) = NULL;\n-  NEXT_INSN (last) = NULL;\n-  if (prevfirst)\n-    NEXT_INSN (prevfirst) = nextlast;\n-  if (nextlast)\n-    PREV_INSN (nextlast) = prevfirst;\n-  else\n-    set_last_insn (prevfirst);\n-  if (!prevfirst)\n-    set_first_insn (nextlast);\n-  return first;\n-}\n-\f\n-/* Skip over inter-block insns occurring after BB which are typically\n-   associated with BB (e.g., barriers). If there are any such insns,\n-   we return the last one. Otherwise, we return the end of BB.  */\n-\n-static rtx\n-skip_insns_after_block (basic_block bb)\n-{\n-  rtx insn, last_insn, next_head, prev;\n-\n-  next_head = NULL_RTX;\n-  if (bb->next_bb != EXIT_BLOCK_PTR)\n-    next_head = BB_HEAD (bb->next_bb);\n-\n-  for (last_insn = insn = BB_END (bb); (insn = NEXT_INSN (insn)) != 0; )\n-    {\n-      if (insn == next_head)\n-\tbreak;\n-\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase BARRIER:\n-\t  last_insn = insn;\n-\t  continue;\n-\n-\tcase NOTE:\n-\t  switch (NOTE_KIND (insn))\n-\t    {\n-\t    case NOTE_INSN_BLOCK_END:\n-\t      gcc_unreachable ();\n-\t      continue;\n-\t    default:\n-\t      continue;\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase CODE_LABEL:\n-\t  if (NEXT_INSN (insn)\n-\t      && JUMP_TABLE_DATA_P (NEXT_INSN (insn)))\n-\t    {\n-\t      insn = NEXT_INSN (insn);\n-\t      last_insn = insn;\n-\t      continue;\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      break;\n-    }\n-\n-  /* It is possible to hit contradictory sequence.  For instance:\n-\n-     jump_insn\n-     NOTE_INSN_BLOCK_BEG\n-     barrier\n-\n-     Where barrier belongs to jump_insn, but the note does not.  This can be\n-     created by removing the basic block originally following\n-     NOTE_INSN_BLOCK_BEG.  In such case reorder the notes.  */\n-\n-  for (insn = last_insn; insn != BB_END (bb); insn = prev)\n-    {\n-      prev = PREV_INSN (insn);\n-      if (NOTE_P (insn))\n-\tswitch (NOTE_KIND (insn))\n-\t  {\n-\t  case NOTE_INSN_BLOCK_END:\n-\t    gcc_unreachable ();\n-\t    break;\n-\t  case NOTE_INSN_DELETED:\n-\t  case NOTE_INSN_DELETED_LABEL:\n-\t  case NOTE_INSN_DELETED_DEBUG_LABEL:\n-\t    continue;\n-\t  default:\n-\t    reorder_insns (insn, insn, last_insn);\n-\t  }\n-    }\n-\n-  return last_insn;\n-}\n-\n-/* Locate or create a label for a given basic block.  */\n-\n-static rtx\n-label_for_bb (basic_block bb)\n-{\n-  rtx label = BB_HEAD (bb);\n-\n-  if (!LABEL_P (label))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Emitting label for block %d\\n\", bb->index);\n-\n-      label = block_label (bb);\n-    }\n-\n-  return label;\n-}\n-\n-/* Locate the effective beginning and end of the insn chain for each\n-   block, as defined by skip_insns_after_block above.  */\n-\n-static void\n-record_effective_endpoints (void)\n-{\n-  rtx next_insn;\n-  basic_block bb;\n-  rtx insn;\n-\n-  for (insn = get_insns ();\n-       insn\n-       && NOTE_P (insn)\n-       && NOTE_KIND (insn) != NOTE_INSN_BASIC_BLOCK;\n-       insn = NEXT_INSN (insn))\n-    continue;\n-  /* No basic blocks at all?  */\n-  gcc_assert (insn);\n-\n-  if (PREV_INSN (insn))\n-    cfg_layout_function_header =\n-\t    unlink_insn_chain (get_insns (), PREV_INSN (insn));\n-  else\n-    cfg_layout_function_header = NULL_RTX;\n-\n-  next_insn = get_insns ();\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx end;\n-\n-      if (PREV_INSN (BB_HEAD (bb)) && next_insn != BB_HEAD (bb))\n-\tBB_HEADER (bb) = unlink_insn_chain (next_insn,\n-\t\t\t\t\t      PREV_INSN (BB_HEAD (bb)));\n-      end = skip_insns_after_block (bb);\n-      if (NEXT_INSN (BB_END (bb)) && BB_END (bb) != end)\n-\tBB_FOOTER (bb) = unlink_insn_chain (NEXT_INSN (BB_END (bb)), end);\n-      next_insn = NEXT_INSN (BB_END (bb));\n-    }\n-\n-  cfg_layout_function_footer = next_insn;\n-  if (cfg_layout_function_footer)\n-    cfg_layout_function_footer = unlink_insn_chain (cfg_layout_function_footer, get_last_insn ());\n-}\n-\f\n-/* Data structures representing mapping of INSN_LOCATOR into scope blocks, line\n-   numbers and files.  In order to be GGC friendly we need to use separate\n-   varrays.  This also slightly improve the memory locality in binary search.\n-   The _locs array contains locators where the given property change.  The\n-   block_locators_blocks contains the scope block that is used for all insn\n-   locator greater than corresponding block_locators_locs value and smaller\n-   than the following one.  Similarly for the other properties.  */\n-static VEC(int,heap) *block_locators_locs;\n-static GTY(()) VEC(tree,gc) *block_locators_blocks;\n-static VEC(int,heap) *locations_locators_locs;\n-DEF_VEC_O(location_t);\n-DEF_VEC_ALLOC_O(location_t,heap);\n-static VEC(location_t,heap) *locations_locators_vals;\n-int prologue_locator;\n-int epilogue_locator;\n-\n-/* Hold current location information and last location information, so the\n-   datastructures are built lazily only when some instructions in given\n-   place are needed.  */\n-static location_t curr_location, last_location;\n-static tree curr_block, last_block;\n-static int curr_rtl_loc = -1;\n-\n-/* Allocate insn locator datastructure.  */\n-void\n-insn_locators_alloc (void)\n-{\n-  prologue_locator = epilogue_locator = 0;\n-\n-  block_locators_locs = VEC_alloc (int, heap, 32);\n-  block_locators_blocks = VEC_alloc (tree, gc, 32);\n-  locations_locators_locs = VEC_alloc (int, heap, 32);\n-  locations_locators_vals = VEC_alloc (location_t, heap, 32);\n-\n-  curr_location = UNKNOWN_LOCATION;\n-  last_location = UNKNOWN_LOCATION;\n-  curr_block = NULL;\n-  last_block = NULL;\n-  curr_rtl_loc = 0;\n-}\n-\n-/* At the end of emit stage, clear current location.  */\n-void\n-insn_locators_finalize (void)\n-{\n-  if (curr_rtl_loc >= 0)\n-    epilogue_locator = curr_insn_locator ();\n-  curr_rtl_loc = -1;\n-}\n-\n-/* Allocate insn locator datastructure.  */\n-void\n-insn_locators_free (void)\n-{\n-  prologue_locator = epilogue_locator = 0;\n-\n-  VEC_free (int, heap, block_locators_locs);\n-  VEC_free (tree,gc, block_locators_blocks);\n-  VEC_free (int, heap, locations_locators_locs);\n-  VEC_free (location_t, heap, locations_locators_vals);\n-}\n-\n-\n-/* Set current location.  */\n-void\n-set_curr_insn_source_location (location_t location)\n-{\n-  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n-     time locators are not initialized.  */\n-  if (curr_rtl_loc == -1)\n-    return;\n-  curr_location = location;\n-}\n-\n-/* Get current location.  */\n-location_t\n-get_curr_insn_source_location (void)\n-{\n-  return curr_location;\n-}\n-\n-/* Set current scope block.  */\n-void\n-set_curr_insn_block (tree b)\n-{\n-  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n-     time locators are not initialized.  */\n-  if (curr_rtl_loc == -1)\n-    return;\n-  if (b)\n-    curr_block = b;\n-}\n-\n-/* Get current scope block.  */\n-tree\n-get_curr_insn_block (void)\n-{\n-  return curr_block;\n-}\n-\n-/* Return current insn locator.  */\n-int\n-curr_insn_locator (void)\n-{\n-  if (curr_rtl_loc == -1 || curr_location == UNKNOWN_LOCATION)\n-    return 0;\n-  if (last_block != curr_block)\n-    {\n-      curr_rtl_loc++;\n-      VEC_safe_push (int, heap, block_locators_locs, curr_rtl_loc);\n-      VEC_safe_push (tree, gc, block_locators_blocks, curr_block);\n-      last_block = curr_block;\n-    }\n-  if (last_location != curr_location)\n-    {\n-      curr_rtl_loc++;\n-      VEC_safe_push (int, heap, locations_locators_locs, curr_rtl_loc);\n-      VEC_safe_push (location_t, heap, locations_locators_vals, &curr_location);\n-      last_location = curr_location;\n-    }\n-  return curr_rtl_loc;\n-}\n-\n-static unsigned int\n-into_cfg_layout_mode (void)\n-{\n-  cfg_layout_initialize (0);\n-  return 0;\n-}\n-\n-static unsigned int\n-outof_cfg_layout_mode (void)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->aux = bb->next_bb;\n-\n-  cfg_layout_finalize ();\n-\n-  return 0;\n-}\n-\n-struct rtl_opt_pass pass_into_cfg_layout_mode =\n-{\n- {\n-  RTL_PASS,\n-  \"into_cfglayout\",                     /* name */\n-  NULL,                                 /* gate */\n-  into_cfg_layout_mode,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CFG,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  PROP_cfglayout,                       /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n-};\n-\n-struct rtl_opt_pass pass_outof_cfg_layout_mode =\n-{\n- {\n-  RTL_PASS,\n-  \"outof_cfglayout\",                    /* name */\n-  NULL,                                 /* gate */\n-  outof_cfg_layout_mode,                /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_CFG,                               /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  PROP_cfglayout,                       /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n-};\n-\f\n-/* Return scope resulting from combination of S1 and S2.  */\n-static tree\n-choose_inner_scope (tree s1, tree s2)\n-{\n-   if (!s1)\n-     return s2;\n-   if (!s2)\n-     return s1;\n-   if (BLOCK_NUMBER (s1) > BLOCK_NUMBER (s2))\n-     return s1;\n-   return s2;\n-}\n-\f\n-/* Emit lexical block notes needed to change scope from S1 to S2.  */\n-\n-static void\n-change_scope (rtx orig_insn, tree s1, tree s2)\n-{\n-  rtx insn = orig_insn;\n-  tree com = NULL_TREE;\n-  tree ts1 = s1, ts2 = s2;\n-  tree s;\n-\n-  while (ts1 != ts2)\n-    {\n-      gcc_assert (ts1 && ts2);\n-      if (BLOCK_NUMBER (ts1) > BLOCK_NUMBER (ts2))\n-\tts1 = BLOCK_SUPERCONTEXT (ts1);\n-      else if (BLOCK_NUMBER (ts1) < BLOCK_NUMBER (ts2))\n-\tts2 = BLOCK_SUPERCONTEXT (ts2);\n-      else\n-\t{\n-\t  ts1 = BLOCK_SUPERCONTEXT (ts1);\n-\t  ts2 = BLOCK_SUPERCONTEXT (ts2);\n-\t}\n-    }\n-  com = ts1;\n-\n-  /* Close scopes.  */\n-  s = s1;\n-  while (s != com)\n-    {\n-      rtx note = emit_note_before (NOTE_INSN_BLOCK_END, insn);\n-      NOTE_BLOCK (note) = s;\n-      s = BLOCK_SUPERCONTEXT (s);\n-    }\n-\n-  /* Open scopes.  */\n-  s = s2;\n-  while (s != com)\n-    {\n-      insn = emit_note_before (NOTE_INSN_BLOCK_BEG, insn);\n-      NOTE_BLOCK (insn) = s;\n-      s = BLOCK_SUPERCONTEXT (s);\n-    }\n-}\n-\n-/* Return lexical scope block locator belongs to.  */\n-static tree\n-locator_scope (int loc)\n-{\n-  int max = VEC_length (int, block_locators_locs);\n-  int min = 0;\n-\n-  /* When block_locators_locs was initialized, the pro- and epilogue\n-     insns didn't exist yet and can therefore not be found this way.\n-     But we know that they belong to the outer most block of the\n-     current function.\n-     Without this test, the prologue would be put inside the block of\n-     the first valid instruction in the function and when that first\n-     insn is part of an inlined function then the low_pc of that\n-     inlined function is messed up.  Likewise for the epilogue and\n-     the last valid instruction.  */\n-  if (loc == prologue_locator || loc == epilogue_locator)\n-    return DECL_INITIAL (cfun->decl);\n-\n-  if (!max || !loc)\n-    return NULL;\n-  while (1)\n-    {\n-      int pos = (min + max) / 2;\n-      int tmp = VEC_index (int, block_locators_locs, pos);\n-\n-      if (tmp <= loc && min != pos)\n-\tmin = pos;\n-      else if (tmp > loc && max != pos)\n-\tmax = pos;\n-      else\n-\t{\n-\t  min = pos;\n-\t  break;\n-\t}\n-    }\n-  return VEC_index (tree, block_locators_blocks, min);\n-}\n-\n-/* Return lexical scope block insn belongs to.  */\n-tree\n-insn_scope (const_rtx insn)\n-{\n-  return locator_scope (INSN_LOCATOR (insn));\n-}\n-\n-/* Return line number of the statement specified by the locator.  */\n-location_t\n-locator_location (int loc)\n-{\n-  int max = VEC_length (int, locations_locators_locs);\n-  int min = 0;\n-\n-  while (1)\n-    {\n-      int pos = (min + max) / 2;\n-      int tmp = VEC_index (int, locations_locators_locs, pos);\n-\n-      if (tmp <= loc && min != pos)\n-\tmin = pos;\n-      else if (tmp > loc && max != pos)\n-\tmax = pos;\n-      else\n-\t{\n-\t  min = pos;\n-\t  break;\n-\t}\n-    }\n-  return *VEC_index (location_t, locations_locators_vals, min);\n-}\n-\n-/* Return source line of the statement that produced this insn.  */\n-int\n-locator_line (int loc)\n-{\n-  expanded_location xloc;\n-  if (!loc)\n-    return 0;\n-  else\n-    xloc = expand_location (locator_location (loc));\n-  return xloc.line;\n-}\n-\n-/* Return line number of the statement that produced this insn.  */\n-int\n-insn_line (const_rtx insn)\n-{\n-  return locator_line (INSN_LOCATOR (insn));\n-}\n-\n-/* Return source file of the statement specified by LOC.  */\n-const char *\n-locator_file (int loc)\n-{\n-  expanded_location xloc;\n-  if (!loc)\n-    return 0;\n-  else\n-    xloc = expand_location (locator_location (loc));\n-  return xloc.file;\n-}\n-\n-/* Return source file of the statement that produced this insn.  */\n-const char *\n-insn_file (const_rtx insn)\n-{\n-  return locator_file (INSN_LOCATOR (insn));\n-}\n-\n-/* Return true if LOC1 and LOC2 locators have the same location and scope.  */\n-bool\n-locator_eq (int loc1, int loc2)\n-{\n-  if (loc1 == loc2)\n-    return true;\n-  if (locator_location (loc1) != locator_location (loc2))\n-    return false;\n-  return locator_scope (loc1) == locator_scope (loc2);\n-}\n-\n-/* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based\n-   on the scope tree and the newly reordered instructions.  */\n-\n-void\n-reemit_insn_block_notes (void)\n-{\n-  tree cur_block = DECL_INITIAL (cfun->decl);\n-  rtx insn, note;\n-\n-  insn = get_insns ();\n-  if (!active_insn_p (insn))\n-    insn = next_active_insn (insn);\n-  for (; insn; insn = next_active_insn (insn))\n-    {\n-      tree this_block;\n-\n-      /* Avoid putting scope notes between jump table and its label.  */\n-      if (JUMP_TABLE_DATA_P (insn))\n-\tcontinue;\n-\n-      this_block = insn_scope (insn);\n-      /* For sequences compute scope resulting from merging all scopes\n-\t of instructions nested inside.  */\n-      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\t{\n-\t  int i;\n-\t  rtx body = PATTERN (insn);\n-\n-\t  this_block = NULL;\n-\t  for (i = 0; i < XVECLEN (body, 0); i++)\n-\t    this_block = choose_inner_scope (this_block,\n-\t\t\t\t\t insn_scope (XVECEXP (body, 0, i)));\n-\t}\n-      if (! this_block)\n-\tcontinue;\n-\n-      if (this_block != cur_block)\n-\t{\n-\t  change_scope (insn, cur_block, this_block);\n-\t  cur_block = this_block;\n-\t}\n-    }\n-\n-  /* change_scope emits before the insn, not after.  */\n-  note = emit_note (NOTE_INSN_DELETED);\n-  change_scope (note, cur_block, DECL_INITIAL (cfun->decl));\n-  delete_insn (note);\n-\n-  reorder_blocks ();\n-}\n-\f\n-\n-/* Link the basic blocks in the correct order, compacting the basic\n-   block queue while at it.  If STAY_IN_CFGLAYOUT_MODE is false, this\n-   function also clears the basic block header and footer fields.\n-\n-   This function is usually called after a pass (e.g. tracer) finishes\n-   some transformations while in cfglayout mode.  The required sequence\n-   of the basic blocks is in a linked list along the bb->aux field.\n-   This functions re-links the basic block prev_bb and next_bb pointers\n-   accordingly, and it compacts and renumbers the blocks.  */\n-\n-void\n-relink_block_chain (bool stay_in_cfglayout_mode)\n-{\n-  basic_block bb, prev_bb;\n-  int index;\n-\n-  /* Maybe dump the re-ordered sequence.  */\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Reordered sequence:\\n\");\n-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n-\t   bb;\n-\t   bb = (basic_block) bb->aux, index++)\n-\t{\n-\t  fprintf (dump_file, \" %i \", index);\n-\t  if (get_bb_original (bb))\n-\t    fprintf (dump_file, \"duplicate of %i \",\n-\t\t     get_bb_original (bb)->index);\n-\t  else if (forwarder_block_p (bb)\n-\t\t   && !LABEL_P (BB_HEAD (bb)))\n-\t    fprintf (dump_file, \"compensation \");\n-\t  else\n-\t    fprintf (dump_file, \"bb %i \", bb->index);\n-\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n-\t}\n-    }\n-\n-  /* Now reorder the blocks.  */\n-  prev_bb = ENTRY_BLOCK_PTR;\n-  bb = ENTRY_BLOCK_PTR->next_bb;\n-  for (; bb; prev_bb = bb, bb = (basic_block) bb->aux)\n-    {\n-      bb->prev_bb = prev_bb;\n-      prev_bb->next_bb = bb;\n-    }\n-  prev_bb->next_bb = EXIT_BLOCK_PTR;\n-  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n-\n-  /* Then, clean up the aux fields.  */\n-  FOR_ALL_BB (bb)\n-    {\n-      bb->aux = NULL;\n-      if (!stay_in_cfglayout_mode)\n-\tBB_HEADER (bb) = BB_FOOTER (bb) = NULL;\n-    }\n-\n-  /* Maybe reset the original copy tables, they are not valid anymore\n-     when we renumber the basic blocks in compact_blocks.  If we are\n-     are going out of cfglayout mode, don't re-allocate the tables.  */\n-  free_original_copy_tables ();\n-  if (stay_in_cfglayout_mode)\n-    initialize_original_copy_tables ();\n-\n-  /* Finally, put basic_block_info in the new order.  */\n-  compact_blocks ();\n-}\n-\f\n-\n-/* Given a reorder chain, rearrange the code to match.  */\n-\n-static void\n-fixup_reorder_chain (void)\n-{\n-  basic_block bb;\n-  rtx insn = NULL;\n-\n-  if (cfg_layout_function_header)\n-    {\n-      set_first_insn (cfg_layout_function_header);\n-      insn = cfg_layout_function_header;\n-      while (NEXT_INSN (insn))\n-\tinsn = NEXT_INSN (insn);\n-    }\n-\n-  /* First do the bulk reordering -- rechain the blocks without regard to\n-     the needed changes to jumps and labels.  */\n-\n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = (basic_block) bb->aux)\n-    {\n-      if (BB_HEADER (bb))\n-\t{\n-\t  if (insn)\n-\t    NEXT_INSN (insn) = BB_HEADER (bb);\n-\t  else\n-\t    set_first_insn (BB_HEADER (bb));\n-\t  PREV_INSN (BB_HEADER (bb)) = insn;\n-\t  insn = BB_HEADER (bb);\n-\t  while (NEXT_INSN (insn))\n-\t    insn = NEXT_INSN (insn);\n-\t}\n-      if (insn)\n-\tNEXT_INSN (insn) = BB_HEAD (bb);\n-      else\n-\tset_first_insn (BB_HEAD (bb));\n-      PREV_INSN (BB_HEAD (bb)) = insn;\n-      insn = BB_END (bb);\n-      if (BB_FOOTER (bb))\n-\t{\n-\t  NEXT_INSN (insn) = BB_FOOTER (bb);\n-\t  PREV_INSN (BB_FOOTER (bb)) = insn;\n-\t  while (NEXT_INSN (insn))\n-\t    insn = NEXT_INSN (insn);\n-\t}\n-    }\n-\n-  NEXT_INSN (insn) = cfg_layout_function_footer;\n-  if (cfg_layout_function_footer)\n-    PREV_INSN (cfg_layout_function_footer) = insn;\n-\n-  while (NEXT_INSN (insn))\n-    insn = NEXT_INSN (insn);\n-\n-  set_last_insn (insn);\n-#ifdef ENABLE_CHECKING\n-  verify_insn_chain ();\n-#endif\n-\n-  /* Now add jumps and labels as needed to match the blocks new\n-     outgoing edges.  */\n-\n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = (basic_block) bb->aux)\n-    {\n-      edge e_fall, e_taken, e;\n-      rtx bb_end_insn;\n-      rtx ret_label = NULL_RTX;\n-      basic_block nb, src_bb;\n-      edge_iterator ei;\n-\n-      if (EDGE_COUNT (bb->succs) == 0)\n-\tcontinue;\n-\n-      /* Find the old fallthru edge, and another non-EH edge for\n-\t a taken jump.  */\n-      e_taken = e_fall = NULL;\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  e_fall = e;\n-\telse if (! (e->flags & EDGE_EH))\n-\t  e_taken = e;\n-\n-      bb_end_insn = BB_END (bb);\n-      if (JUMP_P (bb_end_insn))\n-\t{\n-\t  ret_label = JUMP_LABEL (bb_end_insn);\n-\t  if (any_condjump_p (bb_end_insn))\n-\t    {\n-\t      /* This might happen if the conditional jump has side\n-\t\t effects and could therefore not be optimized away.\n-\t\t Make the basic block to end with a barrier in order\n-\t\t to prevent rtl_verify_flow_info from complaining.  */\n-\t      if (!e_fall)\n-\t\t{\n-\t\t  gcc_assert (!onlyjump_p (bb_end_insn)\n-\t\t\t      || returnjump_p (bb_end_insn));\n-\t\t  BB_FOOTER (bb) = emit_barrier_after (bb_end_insn);\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* If the old fallthru is still next, nothing to do.  */\n-\t      if (bb->aux == e_fall->dest\n-\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n-\t\tcontinue;\n-\n-\t      /* The degenerated case of conditional jump jumping to the next\n-\t\t instruction can happen for jumps with side effects.  We need\n-\t\t to construct a forwarder block and this will be done just\n-\t\t fine by force_nonfallthru below.  */\n-\t      if (!e_taken)\n-\t\t;\n-\n-\t      /* There is another special case: if *neither* block is next,\n-\t\t such as happens at the very end of a function, then we'll\n-\t\t need to add a new unconditional jump.  Choose the taken\n-\t\t edge based on known or assumed probability.  */\n-\t      else if (bb->aux != e_taken->dest)\n-\t\t{\n-\t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n-\n-\t\t  if (note\n-\t\t      && INTVAL (XEXP (note, 0)) < REG_BR_PROB_BASE / 2\n-\t\t      && invert_jump (bb_end_insn,\n-\t\t\t\t      (e_fall->dest == EXIT_BLOCK_PTR\n-\t\t\t\t       ? NULL_RTX\n-\t\t\t\t       : label_for_bb (e_fall->dest)), 0))\n-\t\t    {\n-\t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n-\t\t      gcc_checking_assert (could_fall_through\n-\t\t\t\t\t   (e_taken->src, e_taken->dest));\n-\t\t      e_taken->flags |= EDGE_FALLTHRU;\n-\t\t      update_br_prob_note (bb);\n-\t\t      e = e_fall, e_fall = e_taken, e_taken = e;\n-\t\t    }\n-\t\t}\n-\n-\t      /* If the \"jumping\" edge is a crossing edge, and the fall\n-\t\t through edge is non-crossing, leave things as they are.  */\n-\t      else if ((e_taken->flags & EDGE_CROSSING)\n-\t\t       && !(e_fall->flags & EDGE_CROSSING))\n-\t\tcontinue;\n-\n-\t      /* Otherwise we can try to invert the jump.  This will\n-\t\t basically never fail, however, keep up the pretense.  */\n-\t      else if (invert_jump (bb_end_insn,\n-\t\t\t\t    (e_fall->dest == EXIT_BLOCK_PTR\n-\t\t\t\t     ? NULL_RTX\n-\t\t\t\t     : label_for_bb (e_fall->dest)), 0))\n-\t\t{\n-\t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n-\t\t  gcc_checking_assert (could_fall_through\n-\t\t\t\t       (e_taken->src, e_taken->dest));\n-\t\t  e_taken->flags |= EDGE_FALLTHRU;\n-\t\t  update_br_prob_note (bb);\n-\t\t  if (LABEL_NUSES (ret_label) == 0\n-\t\t      && single_pred_p (e_taken->dest))\n-\t\t    delete_insn (ret_label);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  else if (extract_asm_operands (PATTERN (bb_end_insn)) != NULL)\n-\t    {\n-\t      /* If the old fallthru is still next or if\n-\t\t asm goto doesn't have a fallthru (e.g. when followed by\n-\t\t __builtin_unreachable ()), nothing to do.  */\n-\t      if (! e_fall\n-\t\t  || bb->aux == e_fall->dest\n-\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n-\t\tcontinue;\n-\n-\t      /* Otherwise we'll have to use the fallthru fixup below.  */\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise we have some return, switch or computed\n-\t\t jump.  In the 99% case, there should not have been a\n-\t\t fallthru edge.  */\n-\t      gcc_assert (returnjump_p (bb_end_insn) || !e_fall);\n-\t      continue;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* No fallthru implies a noreturn function with EH edges, or\n-\t     something similarly bizarre.  In any case, we don't need to\n-\t     do anything.  */\n-\t  if (! e_fall)\n-\t    continue;\n-\n-\t  /* If the fallthru block is still next, nothing to do.  */\n-\t  if (bb->aux == e_fall->dest)\n-\t    continue;\n-\n-\t  /* A fallthru to exit block.  */\n-\t  if (e_fall->dest == EXIT_BLOCK_PTR)\n-\t    continue;\n-\t}\n-\n-      /* We got here if we need to add a new jump insn. \n-\t Note force_nonfallthru can delete E_FALL and thus we have to\n-\t save E_FALL->src prior to the call to force_nonfallthru.  */\n-      src_bb = e_fall->src;\n-      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);\n-      if (nb)\n-\t{\n-\t  nb->aux = bb->aux;\n-\t  bb->aux = nb;\n-\t  /* Don't process this new block.  */\n-\t  bb = nb;\n-\n-\t  /* Make sure new bb is tagged for correct section (same as\n-\t     fall-thru source, since you cannot fall-thru across\n-\t     section boundaries).  */\n-\t  BB_COPY_PARTITION (src_bb, single_pred (bb));\n-\t  if (flag_reorder_blocks_and_partition\n-\t      && targetm_common.have_named_sections\n-\t      && JUMP_P (BB_END (bb))\n-\t      && !any_condjump_p (BB_END (bb))\n-\t      && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n-\t    add_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX);\n-\t}\n-    }\n-\n-  relink_block_chain (/*stay_in_cfglayout_mode=*/false);\n-\n-  /* Annoying special case - jump around dead jumptables left in the code.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      edge e = find_fallthru_edge (bb->succs);\n-\n-      if (e && !can_fallthru (e->src, e->dest))\n-\tforce_nonfallthru (e);\n-    }\n-\n-  /* Ensure goto_locus from edges has some instructions with that locus\n-     in RTL.  */\n-  if (!optimize)\n-    FOR_EACH_BB (bb)\n-      {\n-        edge e;\n-        edge_iterator ei;\n-\n-        FOR_EACH_EDGE (e, ei, bb->succs)\n-\t  if (e->goto_locus && !(e->flags & EDGE_ABNORMAL))\n-\t    {\n-\t      edge e2;\n-\t      edge_iterator ei2;\n-\t      basic_block dest, nb;\n-\t      rtx end;\n-\n-\t      insn = BB_END (e->src);\n-\t      end = PREV_INSN (BB_HEAD (e->src));\n-\t      while (insn != end\n-\t\t     && (!NONDEBUG_INSN_P (insn) || INSN_LOCATOR (insn) == 0))\n-\t\tinsn = PREV_INSN (insn);\n-\t      if (insn != end\n-\t\t  && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))\n-\t\tcontinue;\n-\t      if (simplejump_p (BB_END (e->src))\n-\t\t  && INSN_LOCATOR (BB_END (e->src)) == 0)\n-\t\t{\n-\t\t  INSN_LOCATOR (BB_END (e->src)) = e->goto_locus;\n-\t\t  continue;\n-\t\t}\n-\t      dest = e->dest;\n-\t      if (dest == EXIT_BLOCK_PTR)\n-\t\t{\n-\t\t  /* Non-fallthru edges to the exit block cannot be split.  */\n-\t\t  if (!(e->flags & EDGE_FALLTHRU))\n-\t\t    continue;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  insn = BB_HEAD (dest);\n-\t\t  end = NEXT_INSN (BB_END (dest));\n-\t\t  while (insn != end && !NONDEBUG_INSN_P (insn))\n-\t\t    insn = NEXT_INSN (insn);\n-\t\t  if (insn != end && INSN_LOCATOR (insn)\n-\t\t      && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))\n-\t\t    continue;\n-\t\t}\n-\t      nb = split_edge (e);\n-\t      if (!INSN_P (BB_END (nb)))\n-\t\tBB_END (nb) = emit_insn_after_noloc (gen_nop (), BB_END (nb),\n-\t\t\t\t\t\t     nb);\n-\t      INSN_LOCATOR (BB_END (nb)) = e->goto_locus;\n-\n-\t      /* If there are other incoming edges to the destination block\n-\t\t with the same goto locus, redirect them to the new block as\n-\t\t well, this can prevent other such blocks from being created\n-\t\t in subsequent iterations of the loop.  */\n-\t      for (ei2 = ei_start (dest->preds); (e2 = ei_safe_edge (ei2)); )\n-\t\tif (e2->goto_locus\n-\t\t    && !(e2->flags & (EDGE_ABNORMAL | EDGE_FALLTHRU))\n-\t\t    && locator_eq (e->goto_locus, e2->goto_locus))\n-\t\t  redirect_edge_and_branch (e2, nb);\n-\t\telse\n-\t\t  ei_next (&ei2);\n-\t    }\n-      }\n-}\n-\f\n-/* Perform sanity checks on the insn chain.\n-   1. Check that next/prev pointers are consistent in both the forward and\n-      reverse direction.\n-   2. Count insns in chain, going both directions, and check if equal.\n-   3. Check that get_last_insn () returns the actual end of chain.  */\n-\n-DEBUG_FUNCTION void\n-verify_insn_chain (void)\n-{\n-  rtx x, prevx, nextx;\n-  int insn_cnt1, insn_cnt2;\n-\n-  for (prevx = NULL, insn_cnt1 = 1, x = get_insns ();\n-       x != 0;\n-       prevx = x, insn_cnt1++, x = NEXT_INSN (x))\n-    gcc_assert (PREV_INSN (x) == prevx);\n-\n-  gcc_assert (prevx == get_last_insn ());\n-\n-  for (nextx = NULL, insn_cnt2 = 1, x = get_last_insn ();\n-       x != 0;\n-       nextx = x, insn_cnt2++, x = PREV_INSN (x))\n-    gcc_assert (NEXT_INSN (x) == nextx);\n-\n-  gcc_assert (insn_cnt1 == insn_cnt2);\n-}\n-\f\n-/* If we have assembler epilogues, the block falling through to exit must\n-   be the last one in the reordered chain when we reach final.  Ensure\n-   that this condition is met.  */\n-static void\n-fixup_fallthru_exit_predecessor (void)\n-{\n-  edge e;\n-  basic_block bb = NULL;\n-\n-  /* This transformation is not valid before reload, because we might\n-     separate a call from the instruction that copies the return\n-     value.  */\n-  gcc_assert (reload_completed);\n-\n-  e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n-  if (e)\n-    bb = e->src;\n-\n-  if (bb && bb->aux)\n-    {\n-      basic_block c = ENTRY_BLOCK_PTR->next_bb;\n-\n-      /* If the very first block is the one with the fall-through exit\n-\t edge, we have to split that block.  */\n-      if (c == bb)\n-\t{\n-\t  bb = split_block (bb, NULL)->dest;\n-\t  bb->aux = c->aux;\n-\t  c->aux = bb;\n-\t  BB_FOOTER (bb) = BB_FOOTER (c);\n-\t  BB_FOOTER (c) = NULL;\n-\t}\n-\n-      while (c->aux != bb)\n-\tc = (basic_block) c->aux;\n-\n-      c->aux = bb->aux;\n-      while (c->aux)\n-\tc = (basic_block) c->aux;\n-\n-      c->aux = bb;\n-      bb->aux = NULL;\n-    }\n-}\n-\n-/* In case there are more than one fallthru predecessors of exit, force that\n-   there is only one.  */\n-\n-static void\n-force_one_exit_fallthru (void)\n-{\n-  edge e, predecessor = NULL;\n-  bool more = false;\n-  edge_iterator ei;\n-  basic_block forwarder, bb;\n-\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-    if (e->flags & EDGE_FALLTHRU)\n-      {\n-\tif (predecessor == NULL)\n-\t  predecessor = e;\n-\telse\n-\t  {\n-\t    more = true;\n-\t    break;\n-\t  }\n-      }\n-\n-  if (!more)\n-    return;\n-\n-  /* Exit has several fallthru predecessors.  Create a forwarder block for\n-     them.  */\n-  forwarder = split_edge (predecessor);\n-  for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n-    {\n-      if (e->src == forwarder\n-\t  || !(e->flags & EDGE_FALLTHRU))\n-\tei_next (&ei);\n-      else\n-\tredirect_edge_and_branch_force (e, forwarder);\n-    }\n-\n-  /* Fix up the chain of blocks -- make FORWARDER immediately precede the\n-     exit block.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      if (bb->aux == NULL && bb != forwarder)\n-\t{\n-\t  bb->aux = forwarder;\n-\t  break;\n-\t}\n-    }\n-}\n-\f\n-/* Return true in case it is possible to duplicate the basic block BB.  */\n-\n-/* We do not want to declare the function in a header file, since it should\n-   only be used through the cfghooks interface, and we do not want to move\n-   it to cfgrtl.c since it would require also moving quite a lot of related\n-   code.  */\n-extern bool cfg_layout_can_duplicate_bb_p (const_basic_block);\n-\n-bool\n-cfg_layout_can_duplicate_bb_p (const_basic_block bb)\n-{\n-  /* Do not attempt to duplicate tablejumps, as we need to unshare\n-     the dispatch table.  This is difficult to do, as the instructions\n-     computing jump destination may be hoisted outside the basic block.  */\n-  if (tablejump_p (BB_END (bb), NULL, NULL))\n-    return false;\n-\n-  /* Do not duplicate blocks containing insns that can't be copied.  */\n-  if (targetm.cannot_copy_insn_p)\n-    {\n-      rtx insn = BB_HEAD (bb);\n-      while (1)\n-\t{\n-\t  if (INSN_P (insn) && targetm.cannot_copy_insn_p (insn))\n-\t    return false;\n-\t  if (insn == BB_END (bb))\n-\t    break;\n-\t  insn = NEXT_INSN (insn);\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n-rtx\n-duplicate_insn_chain (rtx from, rtx to)\n-{\n-  rtx insn, last, copy;\n-\n-  /* Avoid updating of boundaries of previous basic block.  The\n-     note will get removed from insn stream in fixup.  */\n-  last = emit_note (NOTE_INSN_DELETED);\n-\n-  /* Create copy at the end of INSN chain.  The chain will\n-     be reordered later.  */\n-  for (insn = from; insn != NEXT_INSN (to); insn = NEXT_INSN (insn))\n-    {\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase DEBUG_INSN:\n-\t  /* Don't duplicate label debug insns.  */\n-\t  if (TREE_CODE (INSN_VAR_LOCATION_DECL (insn)) == LABEL_DECL)\n-\t    break;\n-\t  /* FALLTHRU */\n-\tcase INSN:\n-\tcase CALL_INSN:\n-\tcase JUMP_INSN:\n-\t  /* Avoid copying of dispatch tables.  We never duplicate\n-\t     tablejumps, so this can hit only in case the table got\n-\t     moved far from original jump.  */\n-\t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n-\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n-\t    {\n-\t      /* Avoid copying following barrier as well if any\n-\t\t (and debug insns in between).  */\n-\t      rtx next;\n-\n-\t      for (next = NEXT_INSN (insn);\n-\t\t   next != NEXT_INSN (to);\n-\t\t   next = NEXT_INSN (next))\n-\t\tif (!DEBUG_INSN_P (next))\n-\t\t  break;\n-\t      if (next != NEXT_INSN (to) && BARRIER_P (next))\n-\t\tinsn = next;\n-\t      break;\n-\t    }\n-\t  copy = emit_copy_of_insn_after (insn, get_last_insn ());\n-\t  if (JUMP_P (insn) && JUMP_LABEL (insn) != NULL_RTX\n-\t      && ANY_RETURN_P (JUMP_LABEL (insn)))\n-\t    JUMP_LABEL (copy) = JUMP_LABEL (insn);\n-          maybe_copy_prologue_epilogue_insn (insn, copy);\n-\t  break;\n-\n-\tcase CODE_LABEL:\n-\t  break;\n-\n-\tcase BARRIER:\n-\t  emit_barrier ();\n-\t  break;\n-\n-\tcase NOTE:\n-\t  switch (NOTE_KIND (insn))\n-\t    {\n-\t      /* In case prologue is empty and function contain label\n-\t\t in first BB, we may want to copy the block.  */\n-\t    case NOTE_INSN_PROLOGUE_END:\n-\n-\t    case NOTE_INSN_DELETED:\n-\t    case NOTE_INSN_DELETED_LABEL:\n-\t    case NOTE_INSN_DELETED_DEBUG_LABEL:\n-\t      /* No problem to strip these.  */\n-\t    case NOTE_INSN_FUNCTION_BEG:\n-\t      /* There is always just single entry to function.  */\n-\t    case NOTE_INSN_BASIC_BLOCK:\n-\t      break;\n-\n-\t    case NOTE_INSN_EPILOGUE_BEG:\n-\t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n-\t      emit_note_copy (insn);\n-\t      break;\n-\n-\t    default:\n-\t      /* All other notes should have already been eliminated.  */\n-\t      gcc_unreachable ();\n-\t    }\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  insn = NEXT_INSN (last);\n-  delete_insn (last);\n-  return insn;\n-}\n-/* Create a duplicate of the basic block BB.  */\n-\n-/* We do not want to declare the function in a header file, since it should\n-   only be used through the cfghooks interface, and we do not want to move\n-   it to cfgrtl.c since it would require also moving quite a lot of related\n-   code.  */\n-extern basic_block cfg_layout_duplicate_bb (basic_block);\n-\n-basic_block\n-cfg_layout_duplicate_bb (basic_block bb)\n-{\n-  rtx insn;\n-  basic_block new_bb;\n-\n-  insn = duplicate_insn_chain (BB_HEAD (bb), BB_END (bb));\n-  new_bb = create_basic_block (insn,\n-\t\t\t       insn ? get_last_insn () : NULL,\n-\t\t\t       EXIT_BLOCK_PTR->prev_bb);\n-\n-  BB_COPY_PARTITION (new_bb, bb);\n-  if (BB_HEADER (bb))\n-    {\n-      insn = BB_HEADER (bb);\n-      while (NEXT_INSN (insn))\n-\tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (BB_HEADER (bb), insn);\n-      if (insn)\n-\tBB_HEADER (new_bb) = unlink_insn_chain (insn, get_last_insn ());\n-    }\n-\n-  if (BB_FOOTER (bb))\n-    {\n-      insn = BB_FOOTER (bb);\n-      while (NEXT_INSN (insn))\n-\tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (BB_FOOTER (bb), insn);\n-      if (insn)\n-\tBB_FOOTER (new_bb) = unlink_insn_chain (insn, get_last_insn ());\n-    }\n-\n-  return new_bb;\n-}\n-\n-\f\n-/* Main entry point to this module - initialize the datastructures for\n-   CFG layout changes.  It keeps LOOPS up-to-date if not null.\n-\n-   FLAGS is a set of additional flags to pass to cleanup_cfg().  */\n-\n-void\n-cfg_layout_initialize (unsigned int flags)\n-{\n-  rtx x;\n-  basic_block bb;\n-\n-  initialize_original_copy_tables ();\n-\n-  cfg_layout_rtl_register_cfg_hooks ();\n-\n-  record_effective_endpoints ();\n-\n-  /* Make sure that the targets of non local gotos are marked.  */\n-  for (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n-    {\n-      bb = BLOCK_FOR_INSN (XEXP (x, 0));\n-      bb->flags |= BB_NON_LOCAL_GOTO_TARGET;\n-    }\n-\n-  cleanup_cfg (CLEANUP_CFGLAYOUT | flags);\n-}\n-\n-/* Splits superblocks.  */\n-void\n-break_superblocks (void)\n-{\n-  sbitmap superblocks;\n-  bool need = false;\n-  basic_block bb;\n-\n-  superblocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (superblocks);\n-\n-  FOR_EACH_BB (bb)\n-    if (bb->flags & BB_SUPERBLOCK)\n-      {\n-\tbb->flags &= ~BB_SUPERBLOCK;\n-\tSET_BIT (superblocks, bb->index);\n-\tneed = true;\n-      }\n-\n-  if (need)\n-    {\n-      rebuild_jump_labels (get_insns ());\n-      find_many_sub_basic_blocks (superblocks);\n-    }\n-\n-  free (superblocks);\n-}\n-\n-/* Finalize the changes: reorder insn list according to the sequence specified\n-   by aux pointers, enter compensation code, rebuild scope forest.  */\n-\n-void\n-cfg_layout_finalize (void)\n-{\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-  force_one_exit_fallthru ();\n-  rtl_register_cfg_hooks ();\n-  if (reload_completed\n-#ifdef HAVE_epilogue\n-      && !HAVE_epilogue\n-#endif\n-      )\n-    fixup_fallthru_exit_predecessor ();\n-  fixup_reorder_chain ();\n-\n-  rebuild_jump_labels (get_insns ());\n-  delete_dead_jumptables ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_insn_chain ();\n-  verify_flow_info ();\n-#endif\n-}\n-\n-/* Checks whether all N blocks in BBS array can be copied.  */\n-bool\n-can_copy_bbs_p (basic_block *bbs, unsigned n)\n-{\n-  unsigned i;\n-  edge e;\n-  int ret = true;\n-\n-  for (i = 0; i < n; i++)\n-    bbs[i]->flags |= BB_DUPLICATED;\n-\n-  for (i = 0; i < n; i++)\n-    {\n-      /* In case we should redirect abnormal edge during duplication, fail.  */\n-      edge_iterator ei;\n-      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n-\tif ((e->flags & EDGE_ABNORMAL)\n-\t    && (e->dest->flags & BB_DUPLICATED))\n-\t  {\n-\t    ret = false;\n-\t    goto end;\n-\t  }\n-\n-      if (!can_duplicate_block_p (bbs[i]))\n-\t{\n-\t  ret = false;\n-\t  break;\n-\t}\n-    }\n-\n-end:\n-  for (i = 0; i < n; i++)\n-    bbs[i]->flags &= ~BB_DUPLICATED;\n-\n-  return ret;\n-}\n-\n-/* Duplicates N basic blocks stored in array BBS.  Newly created basic blocks\n-   are placed into array NEW_BBS in the same order.  Edges from basic blocks\n-   in BBS are also duplicated and copies of those of them\n-   that lead into BBS are redirected to appropriate newly created block.  The\n-   function assigns bbs into loops (copy of basic block bb is assigned to\n-   bb->loop_father->copy loop, so this must be set up correctly in advance)\n-   and updates dominators locally (LOOPS structure that contains the information\n-   about dominators is passed to enable this).\n-\n-   BASE is the superloop to that basic block belongs; if its header or latch\n-   is copied, we do not set the new blocks as header or latch.\n-\n-   Created copies of N_EDGES edges in array EDGES are stored in array NEW_EDGES,\n-   also in the same order.\n-\n-   Newly created basic blocks are put after the basic block AFTER in the\n-   instruction stream, and the order of the blocks in BBS array is preserved.  */\n-\n-void\n-copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n-\t  edge *edges, unsigned num_edges, edge *new_edges,\n-\t  struct loop *base, basic_block after)\n-{\n-  unsigned i, j;\n-  basic_block bb, new_bb, dom_bb;\n-  edge e;\n-\n-  /* Duplicate bbs, update dominators, assign bbs to loops.  */\n-  for (i = 0; i < n; i++)\n-    {\n-      /* Duplicate.  */\n-      bb = bbs[i];\n-      new_bb = new_bbs[i] = duplicate_block (bb, NULL, after);\n-      after = new_bb;\n-      bb->flags |= BB_DUPLICATED;\n-      /* Possibly set loop header.  */\n-      if (bb->loop_father->header == bb && bb->loop_father != base)\n-\tnew_bb->loop_father->header = new_bb;\n-      /* Or latch.  */\n-      if (bb->loop_father->latch == bb && bb->loop_father != base)\n-\tnew_bb->loop_father->latch = new_bb;\n-    }\n-\n-  /* Set dominators.  */\n-  for (i = 0; i < n; i++)\n-    {\n-      bb = bbs[i];\n-      new_bb = new_bbs[i];\n-\n-      dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-      if (dom_bb->flags & BB_DUPLICATED)\n-\t{\n-\t  dom_bb = get_bb_copy (dom_bb);\n-\t  set_immediate_dominator (CDI_DOMINATORS, new_bb, dom_bb);\n-\t}\n-    }\n-\n-  /* Redirect edges.  */\n-  for (j = 0; j < num_edges; j++)\n-    new_edges[j] = NULL;\n-  for (i = 0; i < n; i++)\n-    {\n-      edge_iterator ei;\n-      new_bb = new_bbs[i];\n-      bb = bbs[i];\n-\n-      FOR_EACH_EDGE (e, ei, new_bb->succs)\n-\t{\n-\t  for (j = 0; j < num_edges; j++)\n-\t    if (edges[j] && edges[j]->src == bb && edges[j]->dest == e->dest)\n-\t      new_edges[j] = e;\n-\n-\t  if (!(e->dest->flags & BB_DUPLICATED))\n-\t    continue;\n-\t  redirect_edge_and_branch_force (e, get_bb_copy (e->dest));\n-\t}\n-    }\n-\n-  /* Clear information about duplicates.  */\n-  for (i = 0; i < n; i++)\n-    bbs[i]->flags &= ~BB_DUPLICATED;\n-}\n-\n-#include \"gt-cfglayout.h\""}, {"sha": "deb985646a332f19ed2e2a5f046534e984a53492", "filename": "gcc/cfglayout.h", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=1c1ad7bbbcd5dc699a37a95d0e898c5d2ad072d1", "patch": "@@ -1,38 +0,0 @@\n-/* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000, 2003, 2004, 2007, 2011 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_CFGLAYOUT_H\n-#define GCC_CFGLAYOUT_H\n-\n-#include \"basic-block.h\"\n-\n-extern GTY(()) rtx cfg_layout_function_footer;\n-extern GTY(()) rtx cfg_layout_function_header;\n-\n-extern void cfg_layout_initialize (unsigned int);\n-extern void cfg_layout_finalize (void);\n-extern tree insn_scope (const_rtx);\n-extern void reemit_insn_block_notes (void);\n-extern bool can_copy_bbs_p (basic_block *, unsigned);\n-extern void copy_bbs (basic_block *, unsigned, basic_block *,\n-\t\t      edge *, unsigned, edge *, struct loop *,\n-\t\t      basic_block);\n-extern rtx duplicate_insn_chain (rtx, rtx);\n-\n-#endif /* GCC_CFGLAYOUT_H */"}, {"sha": "75d721d69562cec20a71f27e68d6b76db47053f4", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -27,8 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n-#include \"cfglayout.h\"\n-#include \"cfghooks.h\"\n #include \"tree-flow.h\"\n \n static void copy_loops_to (struct loop **, int,"}, {"sha": "69cf86dc9540fea3e6280b6cf2d1512002ab39f0", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 975, "deletions": 8, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -55,7 +55,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"insn-attr.h\"\n #include \"insn-config.h\"\n-#include \"cfglayout.h\"\n #include \"expr.h\"\n #include \"target.h\"\n #include \"common/common-target.h\"\n@@ -64,6 +63,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"df.h\"\n \n+/* Holds the interesting leading and trailing notes for the function.\n+   Only applicable if the CFG is in cfglayout mode.  */\n+static GTY(()) rtx cfg_layout_function_footer;\n+static GTY(()) rtx cfg_layout_function_header;\n+\n+static rtx skip_insns_after_block (basic_block);\n+static void record_effective_endpoints (void);\n+static rtx label_for_bb (basic_block);\n+static void fixup_reorder_chain (void);\n+\n+void verify_insn_chain (void);\n+static void fixup_fallthru_exit_predecessor (void);\n static int can_delete_note_p (const_rtx);\n static int can_delete_label_p (const_rtx);\n static basic_block rtl_split_edge (edge);\n@@ -2646,6 +2657,967 @@ fixup_abnormal_edges (void)\n \n   return inserted;\n }\n+\f\n+/* Cut the insns from FIRST to LAST out of the insns stream.  */\n+\n+rtx\n+unlink_insn_chain (rtx first, rtx last)\n+{\n+  rtx prevfirst = PREV_INSN (first);\n+  rtx nextlast = NEXT_INSN (last);\n+\n+  PREV_INSN (first) = NULL;\n+  NEXT_INSN (last) = NULL;\n+  if (prevfirst)\n+    NEXT_INSN (prevfirst) = nextlast;\n+  if (nextlast)\n+    PREV_INSN (nextlast) = prevfirst;\n+  else\n+    set_last_insn (prevfirst);\n+  if (!prevfirst)\n+    set_first_insn (nextlast);\n+  return first;\n+}\n+\f\n+/* Skip over inter-block insns occurring after BB which are typically\n+   associated with BB (e.g., barriers). If there are any such insns,\n+   we return the last one. Otherwise, we return the end of BB.  */\n+\n+static rtx\n+skip_insns_after_block (basic_block bb)\n+{\n+  rtx insn, last_insn, next_head, prev;\n+\n+  next_head = NULL_RTX;\n+  if (bb->next_bb != EXIT_BLOCK_PTR)\n+    next_head = BB_HEAD (bb->next_bb);\n+\n+  for (last_insn = insn = BB_END (bb); (insn = NEXT_INSN (insn)) != 0; )\n+    {\n+      if (insn == next_head)\n+\tbreak;\n+\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase BARRIER:\n+\t  last_insn = insn;\n+\t  continue;\n+\n+\tcase NOTE:\n+\t  switch (NOTE_KIND (insn))\n+\t    {\n+\t    case NOTE_INSN_BLOCK_END:\n+\t      gcc_unreachable ();\n+\t      continue;\n+\t    default:\n+\t      continue;\n+\t      break;\n+\t    }\n+\t  break;\n+\n+\tcase CODE_LABEL:\n+\t  if (NEXT_INSN (insn)\n+\t      && JUMP_TABLE_DATA_P (NEXT_INSN (insn)))\n+\t    {\n+\t      insn = NEXT_INSN (insn);\n+\t      last_insn = insn;\n+\t      continue;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      break;\n+    }\n+\n+  /* It is possible to hit contradictory sequence.  For instance:\n+\n+     jump_insn\n+     NOTE_INSN_BLOCK_BEG\n+     barrier\n+\n+     Where barrier belongs to jump_insn, but the note does not.  This can be\n+     created by removing the basic block originally following\n+     NOTE_INSN_BLOCK_BEG.  In such case reorder the notes.  */\n+\n+  for (insn = last_insn; insn != BB_END (bb); insn = prev)\n+    {\n+      prev = PREV_INSN (insn);\n+      if (NOTE_P (insn))\n+\tswitch (NOTE_KIND (insn))\n+\t  {\n+\t  case NOTE_INSN_BLOCK_END:\n+\t    gcc_unreachable ();\n+\t    break;\n+\t  case NOTE_INSN_DELETED:\n+\t  case NOTE_INSN_DELETED_LABEL:\n+\t  case NOTE_INSN_DELETED_DEBUG_LABEL:\n+\t    continue;\n+\t  default:\n+\t    reorder_insns (insn, insn, last_insn);\n+\t  }\n+    }\n+\n+  return last_insn;\n+}\n+\n+/* Locate or create a label for a given basic block.  */\n+\n+static rtx\n+label_for_bb (basic_block bb)\n+{\n+  rtx label = BB_HEAD (bb);\n+\n+  if (!LABEL_P (label))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Emitting label for block %d\\n\", bb->index);\n+\n+      label = block_label (bb);\n+    }\n+\n+  return label;\n+}\n+\n+/* Locate the effective beginning and end of the insn chain for each\n+   block, as defined by skip_insns_after_block above.  */\n+\n+static void\n+record_effective_endpoints (void)\n+{\n+  rtx next_insn;\n+  basic_block bb;\n+  rtx insn;\n+\n+  for (insn = get_insns ();\n+       insn\n+       && NOTE_P (insn)\n+       && NOTE_KIND (insn) != NOTE_INSN_BASIC_BLOCK;\n+       insn = NEXT_INSN (insn))\n+    continue;\n+  /* No basic blocks at all?  */\n+  gcc_assert (insn);\n+\n+  if (PREV_INSN (insn))\n+    cfg_layout_function_header =\n+\t    unlink_insn_chain (get_insns (), PREV_INSN (insn));\n+  else\n+    cfg_layout_function_header = NULL_RTX;\n+\n+  next_insn = get_insns ();\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx end;\n+\n+      if (PREV_INSN (BB_HEAD (bb)) && next_insn != BB_HEAD (bb))\n+\tBB_HEADER (bb) = unlink_insn_chain (next_insn,\n+\t\t\t\t\t      PREV_INSN (BB_HEAD (bb)));\n+      end = skip_insns_after_block (bb);\n+      if (NEXT_INSN (BB_END (bb)) && BB_END (bb) != end)\n+\tBB_FOOTER (bb) = unlink_insn_chain (NEXT_INSN (BB_END (bb)), end);\n+      next_insn = NEXT_INSN (BB_END (bb));\n+    }\n+\n+  cfg_layout_function_footer = next_insn;\n+  if (cfg_layout_function_footer)\n+    cfg_layout_function_footer = unlink_insn_chain (cfg_layout_function_footer, get_last_insn ());\n+}\n+\f\n+static unsigned int\n+into_cfg_layout_mode (void)\n+{\n+  cfg_layout_initialize (0);\n+  return 0;\n+}\n+\n+static unsigned int\n+outof_cfg_layout_mode (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      bb->aux = bb->next_bb;\n+\n+  cfg_layout_finalize ();\n+\n+  return 0;\n+}\n+\n+struct rtl_opt_pass pass_into_cfg_layout_mode =\n+{\n+ {\n+  RTL_PASS,\n+  \"into_cfglayout\",                     /* name */\n+  NULL,                                 /* gate */\n+  into_cfg_layout_mode,                 /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_CFG,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  PROP_cfglayout,                       /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ }\n+};\n+\n+struct rtl_opt_pass pass_outof_cfg_layout_mode =\n+{\n+ {\n+  RTL_PASS,\n+  \"outof_cfglayout\",                    /* name */\n+  NULL,                                 /* gate */\n+  outof_cfg_layout_mode,                /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_CFG,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  PROP_cfglayout,                       /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ }\n+};\n+\f\n+\n+/* Link the basic blocks in the correct order, compacting the basic\n+   block queue while at it.  If STAY_IN_CFGLAYOUT_MODE is false, this\n+   function also clears the basic block header and footer fields.\n+\n+   This function is usually called after a pass (e.g. tracer) finishes\n+   some transformations while in cfglayout mode.  The required sequence\n+   of the basic blocks is in a linked list along the bb->aux field.\n+   This functions re-links the basic block prev_bb and next_bb pointers\n+   accordingly, and it compacts and renumbers the blocks.  */\n+\n+void\n+relink_block_chain (bool stay_in_cfglayout_mode)\n+{\n+  basic_block bb, prev_bb;\n+  int index;\n+\n+  /* Maybe dump the re-ordered sequence.  */\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Reordered sequence:\\n\");\n+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n+\t   bb;\n+\t   bb = (basic_block) bb->aux, index++)\n+\t{\n+\t  fprintf (dump_file, \" %i \", index);\n+\t  if (get_bb_original (bb))\n+\t    fprintf (dump_file, \"duplicate of %i \",\n+\t\t     get_bb_original (bb)->index);\n+\t  else if (forwarder_block_p (bb)\n+\t\t   && !LABEL_P (BB_HEAD (bb)))\n+\t    fprintf (dump_file, \"compensation \");\n+\t  else\n+\t    fprintf (dump_file, \"bb %i \", bb->index);\n+\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n+\t}\n+    }\n+\n+  /* Now reorder the blocks.  */\n+  prev_bb = ENTRY_BLOCK_PTR;\n+  bb = ENTRY_BLOCK_PTR->next_bb;\n+  for (; bb; prev_bb = bb, bb = (basic_block) bb->aux)\n+    {\n+      bb->prev_bb = prev_bb;\n+      prev_bb->next_bb = bb;\n+    }\n+  prev_bb->next_bb = EXIT_BLOCK_PTR;\n+  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n+\n+  /* Then, clean up the aux fields.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      bb->aux = NULL;\n+      if (!stay_in_cfglayout_mode)\n+\tBB_HEADER (bb) = BB_FOOTER (bb) = NULL;\n+    }\n+\n+  /* Maybe reset the original copy tables, they are not valid anymore\n+     when we renumber the basic blocks in compact_blocks.  If we are\n+     are going out of cfglayout mode, don't re-allocate the tables.  */\n+  free_original_copy_tables ();\n+  if (stay_in_cfglayout_mode)\n+    initialize_original_copy_tables ();\n+\n+  /* Finally, put basic_block_info in the new order.  */\n+  compact_blocks ();\n+}\n+\f\n+\n+/* Given a reorder chain, rearrange the code to match.  */\n+\n+static void\n+fixup_reorder_chain (void)\n+{\n+  basic_block bb;\n+  rtx insn = NULL;\n+\n+  if (cfg_layout_function_header)\n+    {\n+      set_first_insn (cfg_layout_function_header);\n+      insn = cfg_layout_function_header;\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+    }\n+\n+  /* First do the bulk reordering -- rechain the blocks without regard to\n+     the needed changes to jumps and labels.  */\n+\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = (basic_block) bb->aux)\n+    {\n+      if (BB_HEADER (bb))\n+\t{\n+\t  if (insn)\n+\t    NEXT_INSN (insn) = BB_HEADER (bb);\n+\t  else\n+\t    set_first_insn (BB_HEADER (bb));\n+\t  PREV_INSN (BB_HEADER (bb)) = insn;\n+\t  insn = BB_HEADER (bb);\n+\t  while (NEXT_INSN (insn))\n+\t    insn = NEXT_INSN (insn);\n+\t}\n+      if (insn)\n+\tNEXT_INSN (insn) = BB_HEAD (bb);\n+      else\n+\tset_first_insn (BB_HEAD (bb));\n+      PREV_INSN (BB_HEAD (bb)) = insn;\n+      insn = BB_END (bb);\n+      if (BB_FOOTER (bb))\n+\t{\n+\t  NEXT_INSN (insn) = BB_FOOTER (bb);\n+\t  PREV_INSN (BB_FOOTER (bb)) = insn;\n+\t  while (NEXT_INSN (insn))\n+\t    insn = NEXT_INSN (insn);\n+\t}\n+    }\n+\n+  NEXT_INSN (insn) = cfg_layout_function_footer;\n+  if (cfg_layout_function_footer)\n+    PREV_INSN (cfg_layout_function_footer) = insn;\n+\n+  while (NEXT_INSN (insn))\n+    insn = NEXT_INSN (insn);\n+\n+  set_last_insn (insn);\n+#ifdef ENABLE_CHECKING\n+  verify_insn_chain ();\n+#endif\n+\n+  /* Now add jumps and labels as needed to match the blocks new\n+     outgoing edges.  */\n+\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = (basic_block) bb->aux)\n+    {\n+      edge e_fall, e_taken, e;\n+      rtx bb_end_insn;\n+      rtx ret_label = NULL_RTX;\n+      basic_block nb, src_bb;\n+      edge_iterator ei;\n+\n+      if (EDGE_COUNT (bb->succs) == 0)\n+\tcontinue;\n+\n+      /* Find the old fallthru edge, and another non-EH edge for\n+\t a taken jump.  */\n+      e_taken = e_fall = NULL;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  e_fall = e;\n+\telse if (! (e->flags & EDGE_EH))\n+\t  e_taken = e;\n+\n+      bb_end_insn = BB_END (bb);\n+      if (JUMP_P (bb_end_insn))\n+\t{\n+\t  ret_label = JUMP_LABEL (bb_end_insn);\n+\t  if (any_condjump_p (bb_end_insn))\n+\t    {\n+\t      /* This might happen if the conditional jump has side\n+\t\t effects and could therefore not be optimized away.\n+\t\t Make the basic block to end with a barrier in order\n+\t\t to prevent rtl_verify_flow_info from complaining.  */\n+\t      if (!e_fall)\n+\t\t{\n+\t\t  gcc_assert (!onlyjump_p (bb_end_insn)\n+\t\t\t      || returnjump_p (bb_end_insn));\n+\t\t  BB_FOOTER (bb) = emit_barrier_after (bb_end_insn);\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* If the old fallthru is still next, nothing to do.  */\n+\t      if (bb->aux == e_fall->dest\n+\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n+\t\tcontinue;\n+\n+\t      /* The degenerated case of conditional jump jumping to the next\n+\t\t instruction can happen for jumps with side effects.  We need\n+\t\t to construct a forwarder block and this will be done just\n+\t\t fine by force_nonfallthru below.  */\n+\t      if (!e_taken)\n+\t\t;\n+\n+\t      /* There is another special case: if *neither* block is next,\n+\t\t such as happens at the very end of a function, then we'll\n+\t\t need to add a new unconditional jump.  Choose the taken\n+\t\t edge based on known or assumed probability.  */\n+\t      else if (bb->aux != e_taken->dest)\n+\t\t{\n+\t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n+\n+\t\t  if (note\n+\t\t      && INTVAL (XEXP (note, 0)) < REG_BR_PROB_BASE / 2\n+\t\t      && invert_jump (bb_end_insn,\n+\t\t\t\t      (e_fall->dest == EXIT_BLOCK_PTR\n+\t\t\t\t       ? NULL_RTX\n+\t\t\t\t       : label_for_bb (e_fall->dest)), 0))\n+\t\t    {\n+\t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n+\t\t      gcc_checking_assert (could_fall_through\n+\t\t\t\t\t   (e_taken->src, e_taken->dest));\n+\t\t      e_taken->flags |= EDGE_FALLTHRU;\n+\t\t      update_br_prob_note (bb);\n+\t\t      e = e_fall, e_fall = e_taken, e_taken = e;\n+\t\t    }\n+\t\t}\n+\n+\t      /* If the \"jumping\" edge is a crossing edge, and the fall\n+\t\t through edge is non-crossing, leave things as they are.  */\n+\t      else if ((e_taken->flags & EDGE_CROSSING)\n+\t\t       && !(e_fall->flags & EDGE_CROSSING))\n+\t\tcontinue;\n+\n+\t      /* Otherwise we can try to invert the jump.  This will\n+\t\t basically never fail, however, keep up the pretense.  */\n+\t      else if (invert_jump (bb_end_insn,\n+\t\t\t\t    (e_fall->dest == EXIT_BLOCK_PTR\n+\t\t\t\t     ? NULL_RTX\n+\t\t\t\t     : label_for_bb (e_fall->dest)), 0))\n+\t\t{\n+\t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n+\t\t  gcc_checking_assert (could_fall_through\n+\t\t\t\t       (e_taken->src, e_taken->dest));\n+\t\t  e_taken->flags |= EDGE_FALLTHRU;\n+\t\t  update_br_prob_note (bb);\n+\t\t  if (LABEL_NUSES (ret_label) == 0\n+\t\t      && single_pred_p (e_taken->dest))\n+\t\t    delete_insn (ret_label);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  else if (extract_asm_operands (PATTERN (bb_end_insn)) != NULL)\n+\t    {\n+\t      /* If the old fallthru is still next or if\n+\t\t asm goto doesn't have a fallthru (e.g. when followed by\n+\t\t __builtin_unreachable ()), nothing to do.  */\n+\t      if (! e_fall\n+\t\t  || bb->aux == e_fall->dest\n+\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n+\t\tcontinue;\n+\n+\t      /* Otherwise we'll have to use the fallthru fixup below.  */\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise we have some return, switch or computed\n+\t\t jump.  In the 99% case, there should not have been a\n+\t\t fallthru edge.  */\n+\t      gcc_assert (returnjump_p (bb_end_insn) || !e_fall);\n+\t      continue;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* No fallthru implies a noreturn function with EH edges, or\n+\t     something similarly bizarre.  In any case, we don't need to\n+\t     do anything.  */\n+\t  if (! e_fall)\n+\t    continue;\n+\n+\t  /* If the fallthru block is still next, nothing to do.  */\n+\t  if (bb->aux == e_fall->dest)\n+\t    continue;\n+\n+\t  /* A fallthru to exit block.  */\n+\t  if (e_fall->dest == EXIT_BLOCK_PTR)\n+\t    continue;\n+\t}\n+\n+      /* We got here if we need to add a new jump insn. \n+\t Note force_nonfallthru can delete E_FALL and thus we have to\n+\t save E_FALL->src prior to the call to force_nonfallthru.  */\n+      src_bb = e_fall->src;\n+      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);\n+      if (nb)\n+\t{\n+\t  nb->aux = bb->aux;\n+\t  bb->aux = nb;\n+\t  /* Don't process this new block.  */\n+\t  bb = nb;\n+\n+\t  /* Make sure new bb is tagged for correct section (same as\n+\t     fall-thru source, since you cannot fall-thru across\n+\t     section boundaries).  */\n+\t  BB_COPY_PARTITION (src_bb, single_pred (bb));\n+\t  if (flag_reorder_blocks_and_partition\n+\t      && targetm_common.have_named_sections\n+\t      && JUMP_P (BB_END (bb))\n+\t      && !any_condjump_p (BB_END (bb))\n+\t      && (EDGE_SUCC (bb, 0)->flags & EDGE_CROSSING))\n+\t    add_reg_note (BB_END (bb), REG_CROSSING_JUMP, NULL_RTX);\n+\t}\n+    }\n+\n+  relink_block_chain (/*stay_in_cfglayout_mode=*/false);\n+\n+  /* Annoying special case - jump around dead jumptables left in the code.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e = find_fallthru_edge (bb->succs);\n+\n+      if (e && !can_fallthru (e->src, e->dest))\n+\tforce_nonfallthru (e);\n+    }\n+\n+  /* Ensure goto_locus from edges has some instructions with that locus\n+     in RTL.  */\n+  if (!optimize)\n+    FOR_EACH_BB (bb)\n+      {\n+        edge e;\n+        edge_iterator ei;\n+\n+        FOR_EACH_EDGE (e, ei, bb->succs)\n+\t  if (e->goto_locus && !(e->flags & EDGE_ABNORMAL))\n+\t    {\n+\t      edge e2;\n+\t      edge_iterator ei2;\n+\t      basic_block dest, nb;\n+\t      rtx end;\n+\n+\t      insn = BB_END (e->src);\n+\t      end = PREV_INSN (BB_HEAD (e->src));\n+\t      while (insn != end\n+\t\t     && (!NONDEBUG_INSN_P (insn) || INSN_LOCATOR (insn) == 0))\n+\t\tinsn = PREV_INSN (insn);\n+\t      if (insn != end\n+\t\t  && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))\n+\t\tcontinue;\n+\t      if (simplejump_p (BB_END (e->src))\n+\t\t  && INSN_LOCATOR (BB_END (e->src)) == 0)\n+\t\t{\n+\t\t  INSN_LOCATOR (BB_END (e->src)) = e->goto_locus;\n+\t\t  continue;\n+\t\t}\n+\t      dest = e->dest;\n+\t      if (dest == EXIT_BLOCK_PTR)\n+\t\t{\n+\t\t  /* Non-fallthru edges to the exit block cannot be split.  */\n+\t\t  if (!(e->flags & EDGE_FALLTHRU))\n+\t\t    continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  insn = BB_HEAD (dest);\n+\t\t  end = NEXT_INSN (BB_END (dest));\n+\t\t  while (insn != end && !NONDEBUG_INSN_P (insn))\n+\t\t    insn = NEXT_INSN (insn);\n+\t\t  if (insn != end && INSN_LOCATOR (insn)\n+\t\t      && locator_eq (INSN_LOCATOR (insn), (int) e->goto_locus))\n+\t\t    continue;\n+\t\t}\n+\t      nb = split_edge (e);\n+\t      if (!INSN_P (BB_END (nb)))\n+\t\tBB_END (nb) = emit_insn_after_noloc (gen_nop (), BB_END (nb),\n+\t\t\t\t\t\t     nb);\n+\t      INSN_LOCATOR (BB_END (nb)) = e->goto_locus;\n+\n+\t      /* If there are other incoming edges to the destination block\n+\t\t with the same goto locus, redirect them to the new block as\n+\t\t well, this can prevent other such blocks from being created\n+\t\t in subsequent iterations of the loop.  */\n+\t      for (ei2 = ei_start (dest->preds); (e2 = ei_safe_edge (ei2)); )\n+\t\tif (e2->goto_locus\n+\t\t    && !(e2->flags & (EDGE_ABNORMAL | EDGE_FALLTHRU))\n+\t\t    && locator_eq (e->goto_locus, e2->goto_locus))\n+\t\t  redirect_edge_and_branch (e2, nb);\n+\t\telse\n+\t\t  ei_next (&ei2);\n+\t    }\n+      }\n+}\n+\f\n+/* Perform sanity checks on the insn chain.\n+   1. Check that next/prev pointers are consistent in both the forward and\n+      reverse direction.\n+   2. Count insns in chain, going both directions, and check if equal.\n+   3. Check that get_last_insn () returns the actual end of chain.  */\n+\n+DEBUG_FUNCTION void\n+verify_insn_chain (void)\n+{\n+  rtx x, prevx, nextx;\n+  int insn_cnt1, insn_cnt2;\n+\n+  for (prevx = NULL, insn_cnt1 = 1, x = get_insns ();\n+       x != 0;\n+       prevx = x, insn_cnt1++, x = NEXT_INSN (x))\n+    gcc_assert (PREV_INSN (x) == prevx);\n+\n+  gcc_assert (prevx == get_last_insn ());\n+\n+  for (nextx = NULL, insn_cnt2 = 1, x = get_last_insn ();\n+       x != 0;\n+       nextx = x, insn_cnt2++, x = PREV_INSN (x))\n+    gcc_assert (NEXT_INSN (x) == nextx);\n+\n+  gcc_assert (insn_cnt1 == insn_cnt2);\n+}\n+\f\n+/* If we have assembler epilogues, the block falling through to exit must\n+   be the last one in the reordered chain when we reach final.  Ensure\n+   that this condition is met.  */\n+static void\n+fixup_fallthru_exit_predecessor (void)\n+{\n+  edge e;\n+  basic_block bb = NULL;\n+\n+  /* This transformation is not valid before reload, because we might\n+     separate a call from the instruction that copies the return\n+     value.  */\n+  gcc_assert (reload_completed);\n+\n+  e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n+  if (e)\n+    bb = e->src;\n+\n+  if (bb && bb->aux)\n+    {\n+      basic_block c = ENTRY_BLOCK_PTR->next_bb;\n+\n+      /* If the very first block is the one with the fall-through exit\n+\t edge, we have to split that block.  */\n+      if (c == bb)\n+\t{\n+\t  bb = split_block (bb, NULL)->dest;\n+\t  bb->aux = c->aux;\n+\t  c->aux = bb;\n+\t  BB_FOOTER (bb) = BB_FOOTER (c);\n+\t  BB_FOOTER (c) = NULL;\n+\t}\n+\n+      while (c->aux != bb)\n+\tc = (basic_block) c->aux;\n+\n+      c->aux = bb->aux;\n+      while (c->aux)\n+\tc = (basic_block) c->aux;\n+\n+      c->aux = bb;\n+      bb->aux = NULL;\n+    }\n+}\n+\n+/* In case there are more than one fallthru predecessors of exit, force that\n+   there is only one.  */\n+\n+static void\n+force_one_exit_fallthru (void)\n+{\n+  edge e, predecessor = NULL;\n+  bool more = false;\n+  edge_iterator ei;\n+  basic_block forwarder, bb;\n+\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+    if (e->flags & EDGE_FALLTHRU)\n+      {\n+\tif (predecessor == NULL)\n+\t  predecessor = e;\n+\telse\n+\t  {\n+\t    more = true;\n+\t    break;\n+\t  }\n+      }\n+\n+  if (!more)\n+    return;\n+\n+  /* Exit has several fallthru predecessors.  Create a forwarder block for\n+     them.  */\n+  forwarder = split_edge (predecessor);\n+  for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n+    {\n+      if (e->src == forwarder\n+\t  || !(e->flags & EDGE_FALLTHRU))\n+\tei_next (&ei);\n+      else\n+\tredirect_edge_and_branch_force (e, forwarder);\n+    }\n+\n+  /* Fix up the chain of blocks -- make FORWARDER immediately precede the\n+     exit block.  */\n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->aux == NULL && bb != forwarder)\n+\t{\n+\t  bb->aux = forwarder;\n+\t  break;\n+\t}\n+    }\n+}\n+\f\n+/* Return true in case it is possible to duplicate the basic block BB.  */\n+\n+static bool\n+cfg_layout_can_duplicate_bb_p (const_basic_block bb)\n+{\n+  /* Do not attempt to duplicate tablejumps, as we need to unshare\n+     the dispatch table.  This is difficult to do, as the instructions\n+     computing jump destination may be hoisted outside the basic block.  */\n+  if (tablejump_p (BB_END (bb), NULL, NULL))\n+    return false;\n+\n+  /* Do not duplicate blocks containing insns that can't be copied.  */\n+  if (targetm.cannot_copy_insn_p)\n+    {\n+      rtx insn = BB_HEAD (bb);\n+      while (1)\n+\t{\n+\t  if (INSN_P (insn) && targetm.cannot_copy_insn_p (insn))\n+\t    return false;\n+\t  if (insn == BB_END (bb))\n+\t    break;\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+rtx\n+duplicate_insn_chain (rtx from, rtx to)\n+{\n+  rtx insn, last, copy;\n+\n+  /* Avoid updating of boundaries of previous basic block.  The\n+     note will get removed from insn stream in fixup.  */\n+  last = emit_note (NOTE_INSN_DELETED);\n+\n+  /* Create copy at the end of INSN chain.  The chain will\n+     be reordered later.  */\n+  for (insn = from; insn != NEXT_INSN (to); insn = NEXT_INSN (insn))\n+    {\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase DEBUG_INSN:\n+\t  /* Don't duplicate label debug insns.  */\n+\t  if (TREE_CODE (INSN_VAR_LOCATION_DECL (insn)) == LABEL_DECL)\n+\t    break;\n+\t  /* FALLTHRU */\n+\tcase INSN:\n+\tcase CALL_INSN:\n+\tcase JUMP_INSN:\n+\t  /* Avoid copying of dispatch tables.  We never duplicate\n+\t     tablejumps, so this can hit only in case the table got\n+\t     moved far from original jump.  */\n+\t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+\t    {\n+\t      /* Avoid copying following barrier as well if any\n+\t\t (and debug insns in between).  */\n+\t      rtx next;\n+\n+\t      for (next = NEXT_INSN (insn);\n+\t\t   next != NEXT_INSN (to);\n+\t\t   next = NEXT_INSN (next))\n+\t\tif (!DEBUG_INSN_P (next))\n+\t\t  break;\n+\t      if (next != NEXT_INSN (to) && BARRIER_P (next))\n+\t\tinsn = next;\n+\t      break;\n+\t    }\n+\t  copy = emit_copy_of_insn_after (insn, get_last_insn ());\n+\t  if (JUMP_P (insn) && JUMP_LABEL (insn) != NULL_RTX\n+\t      && ANY_RETURN_P (JUMP_LABEL (insn)))\n+\t    JUMP_LABEL (copy) = JUMP_LABEL (insn);\n+          maybe_copy_prologue_epilogue_insn (insn, copy);\n+\t  break;\n+\n+\tcase CODE_LABEL:\n+\t  break;\n+\n+\tcase BARRIER:\n+\t  emit_barrier ();\n+\t  break;\n+\n+\tcase NOTE:\n+\t  switch (NOTE_KIND (insn))\n+\t    {\n+\t      /* In case prologue is empty and function contain label\n+\t\t in first BB, we may want to copy the block.  */\n+\t    case NOTE_INSN_PROLOGUE_END:\n+\n+\t    case NOTE_INSN_DELETED:\n+\t    case NOTE_INSN_DELETED_LABEL:\n+\t    case NOTE_INSN_DELETED_DEBUG_LABEL:\n+\t      /* No problem to strip these.  */\n+\t    case NOTE_INSN_FUNCTION_BEG:\n+\t      /* There is always just single entry to function.  */\n+\t    case NOTE_INSN_BASIC_BLOCK:\n+\t      break;\n+\n+\t    case NOTE_INSN_EPILOGUE_BEG:\n+\t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n+\t      emit_note_copy (insn);\n+\t      break;\n+\n+\t    default:\n+\t      /* All other notes should have already been eliminated.  */\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  insn = NEXT_INSN (last);\n+  delete_insn (last);\n+  return insn;\n+}\n+\n+/* Create a duplicate of the basic block BB.  */\n+\n+static basic_block\n+cfg_layout_duplicate_bb (basic_block bb)\n+{\n+  rtx insn;\n+  basic_block new_bb;\n+\n+  insn = duplicate_insn_chain (BB_HEAD (bb), BB_END (bb));\n+  new_bb = create_basic_block (insn,\n+\t\t\t       insn ? get_last_insn () : NULL,\n+\t\t\t       EXIT_BLOCK_PTR->prev_bb);\n+\n+  BB_COPY_PARTITION (new_bb, bb);\n+  if (BB_HEADER (bb))\n+    {\n+      insn = BB_HEADER (bb);\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+      insn = duplicate_insn_chain (BB_HEADER (bb), insn);\n+      if (insn)\n+\tBB_HEADER (new_bb) = unlink_insn_chain (insn, get_last_insn ());\n+    }\n+\n+  if (BB_FOOTER (bb))\n+    {\n+      insn = BB_FOOTER (bb);\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+      insn = duplicate_insn_chain (BB_FOOTER (bb), insn);\n+      if (insn)\n+\tBB_FOOTER (new_bb) = unlink_insn_chain (insn, get_last_insn ());\n+    }\n+\n+  return new_bb;\n+}\n+\n+\f\n+/* Main entry point to this module - initialize the datastructures for\n+   CFG layout changes.  It keeps LOOPS up-to-date if not null.\n+\n+   FLAGS is a set of additional flags to pass to cleanup_cfg().  */\n+\n+void\n+cfg_layout_initialize (unsigned int flags)\n+{\n+  rtx x;\n+  basic_block bb;\n+\n+  initialize_original_copy_tables ();\n+\n+  cfg_layout_rtl_register_cfg_hooks ();\n+\n+  record_effective_endpoints ();\n+\n+  /* Make sure that the targets of non local gotos are marked.  */\n+  for (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n+    {\n+      bb = BLOCK_FOR_INSN (XEXP (x, 0));\n+      bb->flags |= BB_NON_LOCAL_GOTO_TARGET;\n+    }\n+\n+  cleanup_cfg (CLEANUP_CFGLAYOUT | flags);\n+}\n+\n+/* Splits superblocks.  */\n+void\n+break_superblocks (void)\n+{\n+  sbitmap superblocks;\n+  bool need = false;\n+  basic_block bb;\n+\n+  superblocks = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (superblocks);\n+\n+  FOR_EACH_BB (bb)\n+    if (bb->flags & BB_SUPERBLOCK)\n+      {\n+\tbb->flags &= ~BB_SUPERBLOCK;\n+\tSET_BIT (superblocks, bb->index);\n+\tneed = true;\n+      }\n+\n+  if (need)\n+    {\n+      rebuild_jump_labels (get_insns ());\n+      find_many_sub_basic_blocks (superblocks);\n+    }\n+\n+  free (superblocks);\n+}\n+\n+/* Finalize the changes: reorder insn list according to the sequence specified\n+   by aux pointers, enter compensation code, rebuild scope forest.  */\n+\n+void\n+cfg_layout_finalize (void)\n+{\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+  force_one_exit_fallthru ();\n+  rtl_register_cfg_hooks ();\n+  if (reload_completed\n+#ifdef HAVE_epilogue\n+      && !HAVE_epilogue\n+#endif\n+      )\n+    fixup_fallthru_exit_predecessor ();\n+  fixup_reorder_chain ();\n+\n+  rebuild_jump_labels (get_insns ());\n+  delete_dead_jumptables ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_insn_chain ();\n+  verify_flow_info ();\n+#endif\n+}\n+\n \n /* Same as split_block but update cfg_layout structures.  */\n \n@@ -3283,13 +4255,6 @@ rtl_can_remove_branch_p (const_edge e)\n   return true;\n }\n \n-/* We do not want to declare these functions in a header file, since they\n-   should only be used through the cfghooks interface, and we do not want to\n-   move them here since it would require also moving quite a lot of related\n-   code.  They are in cfglayout.c.  */\n-extern bool cfg_layout_can_duplicate_bb_p (const_basic_block);\n-extern basic_block cfg_layout_duplicate_bb (basic_block);\n-\n static basic_block\n rtl_duplicate_bb (basic_block bb)\n {\n@@ -3369,3 +4334,5 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   rtl_extract_cond_bb_edges, /* extract_cond_bb_edges */\n   NULL\t\t/* flush_pending_stmts */\n };\n+\n+#include \"gt-cfgrtl.h\""}, {"sha": "7892bf088778b5c5b917489c2985e9d27fc55bf5", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -50,7 +50,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"langhooks.h\"\n #include \"splay-tree.h\"\n-#include \"cfglayout.h\"\n #include \"gimple.h\"\n #include \"tree-flow.h\"\n #include \"tree-stdarg.h\""}, {"sha": "a24ba9006a1add686ea4d377201b2675f36e36f2", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -51,7 +51,6 @@\n #include \"tm-constrs.h\"\n #include \"gt-bfin.h\"\n #include \"basic-block.h\"\n-#include \"cfglayout.h\"\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"sel-sched.h\""}, {"sha": "6f16c6920f1d9a6070a3a9660280461886e16a0b", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -43,7 +43,6 @@\n #include \"function.h\"\n #include \"diagnostic-core.h\"\n #include \"cgraph.h\"\n-#include \"cfglayout.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"target-def.h\""}, {"sha": "108050708bd8c90b7cc1b2cdb8357ed12a910d86", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -51,7 +51,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n-#include \"cfglayout.h\"\n #include \"gimple.h\"\n #include \"intl.h\"\n #include \"df.h\""}, {"sha": "6e0f39c1d1c19bfd5d797f9c5d66811d266a4cb9", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -51,7 +51,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"langhooks.h\"\n-#include \"cfglayout.h\"\n #include \"sched-int.h\"\n #include \"gimple.h\"\n #include \"bitmap.h\""}, {"sha": "0f23cd053d648b17e7527d20ed0fbab6a1925dec", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -52,7 +52,6 @@\n #include \"common/common-target.h\"\n #include \"langhooks.h\"\n #include \"reload.h\"\n-#include \"cfglayout.h\"\n #include \"cfgloop.h\"\n #include \"sched-int.h\"\n #include \"gimple.h\""}, {"sha": "100dccc7075ce068b641911e950aad3288c71052", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -27,7 +27,7 @@ rs6000.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(OBSTACK_H) $(TREE_H) $(EXPR_H) $(OPTABS_H) except.h function.h \\\n   output.h dbxout.h $(BASIC_BLOCK_H) toplev.h $(GGC_H) $(HASHTAB_H) \\\n   $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h gt-rs6000.h \\\n-  cfglayout.h cfgloop.h $(OPTS_H) $(COMMON_TARGET_H)\n+  cfgloop.h $(OPTS_H) $(COMMON_TARGET_H)\n \n rs6000-c.o: $(srcdir)/config/rs6000/rs6000-c.c \\\n     $(srcdir)/config/rs6000/rs6000-protos.h \\"}, {"sha": "3d7bf49f081ba8e7d0a95d5e9a4e1bd0b6e683c3", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -46,7 +46,6 @@\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"langhooks.h\"\n-#include \"cfglayout.h\"\n #include \"df.h\"\n #include \"opts.h\"\n "}, {"sha": "49a69abe04ae3b10ef80ca93992b37b1e303a513", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -46,7 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"basic-block.h\"\n #include \"df.h\"\n-#include \"cfglayout.h\"\n #include \"intl.h\"\n #include \"sched-int.h\"\n #include \"params.h\""}, {"sha": "08c9cc891b005ce8673c45aa23c5fdf31b01c215", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -49,7 +49,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"common/common-target.h\"\n-#include \"cfglayout.h\"\n #include \"gimple.h\"\n #include \"langhooks.h\"\n #include \"reload.h\""}, {"sha": "b7d4dacdcb6e9192ca7b4d13fea33b0295154eeb", "filename": "gcc/config/sparc/t-sparc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fsparc%2Ft-sparc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fsparc%2Ft-sparc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-sparc?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -23,7 +23,7 @@ sparc.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   insn-codes.h conditions.h output.h $(INSN_ATTR_H) $(FLAGS_H) \\\n   $(FUNCTION_H) $(EXCEPT_H) $(EXPR_H) $(OPTABS_H) $(RECOG_H) \\\n   $(DIAGNOSTIC_CORE_H) $(GGC_H) $(TM_P_H) debug.h $(TARGET_H) \\\n-  $(TARGET_DEF_H) $(COMMON_TARGET_H) $(CFGLAYOUT_H) $(GIMPLE_H) \\\n+  $(TARGET_DEF_H) $(COMMON_TARGET_H) $(GIMPLE_H) \\\n   langhooks.h reload.h $(PARAMS_H) $(DF_H) dwarf2out.h $(OPTS_H) \\\n   gt-sparc.h\n "}, {"sha": "0aa5cf4da1ad498a4d58dd823556684e5e3d3a14", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -43,7 +43,6 @@\n #include \"target-def.h\"\n #include \"langhooks.h\"\n #include \"reload.h\"\n-#include \"cfglayout.h\"\n #include \"sched-int.h\"\n #include \"params.h\"\n #include \"machmode.h\""}, {"sha": "0a0f7714a7d7aafa48b01a0dbf8ac0e6c462daba", "filename": "gcc/config/spu/t-spu-elf", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Ft-spu-elf?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -23,7 +23,7 @@ spu.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   real.h insn-config.h conditions.h insn-attr.h flags.h $(RECOG_H) \\\n   $(OBSTACK_H) $(TREE_H) $(EXPR_H) $(OPTABS_H) except.h function.h \\\n   output.h $(BASIC_BLOCK_H) $(GGC_H) $(HASHTAB_H) \\\n-  $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h cfglayout.h \\\n+  $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h \\\n   $(srcdir)/config/spu/spu-protos.h \\\n   $(srcdir)/config/spu/spu-builtins.def \n "}, {"sha": "853f5ea91840c2669ebe8ef81233ff1b58e63597", "filename": "gcc/ddg.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -37,7 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n #include \"sched-int.h\"\n #include \"target.h\"\n-#include \"cfglayout.h\"\n #include \"cfgloop.h\"\n #include \"sbitmap.h\"\n #include \"expr.h\""}, {"sha": "56730e31d28780a291d37f5b88e3e07c79761ad6", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -93,7 +93,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n #include \"tree-flow.h\"\n-#include \"cfglayout.h\" /* for insn_scope.  */\n #include \"opts.h\"\n \n static void dwarf2out_source_line (unsigned int, const char *, int, bool);"}, {"sha": "c82bd61c7e1fffd86156b761edfa41d3bbcade45", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 244, "deletions": 12, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"function.h\"\n #include \"expr.h\"\n+#include \"vecprim.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"hashtab.h\"\n@@ -59,7 +60,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"params.h\"\n #include \"target.h\"\n-#include \"tree-flow.h\"\n \n struct target_rtl default_target_rtl;\n #if SWITCHABLE_TARGET\n@@ -147,7 +147,6 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n \n #define cur_insn_uid (crtl->emit.x_cur_insn_uid)\n #define cur_debug_insn_uid (crtl->emit.x_cur_debug_insn_uid)\n-#define last_location (crtl->emit.x_last_location)\n #define first_label_num (crtl->emit.x_first_label_num)\n \n static rtx make_call_insn_raw (rtx);\n@@ -4927,15 +4926,6 @@ gen_use (rtx x)\n   return seq;\n }\n \n-/* Cause next statement to emit a line note even if the line number\n-   has not changed.  */\n-\n-void\n-force_next_line_note (void)\n-{\n-  last_location = -1;\n-}\n-\n /* Place a note of KIND on insn INSN with DATUM as the datum. If a\n    note of this type already exists, remove it first.  */\n \n@@ -5404,7 +5394,6 @@ init_emit (void)\n     cur_insn_uid = 1;\n   cur_debug_insn_uid = 1;\n   reg_rtx_no = LAST_VIRTUAL_REGISTER + 1;\n-  last_location = UNKNOWN_LOCATION;\n   first_label_num = label_num;\n   seq_stack = NULL;\n \n@@ -5929,4 +5918,247 @@ gen_hard_reg_clobber (enum machine_mode mode, unsigned int regno)\n \t    gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (mode, regno)));\n }\n \n+/* Data structures representing mapping of INSN_LOCATOR into scope blocks, line\n+   numbers and files.  In order to be GGC friendly we need to use separate\n+   varrays.  This also slightly improve the memory locality in binary search.\n+   The _locs array contains locators where the given property change.  The\n+   block_locators_blocks contains the scope block that is used for all insn\n+   locator greater than corresponding block_locators_locs value and smaller\n+   than the following one.  Similarly for the other properties.  */\n+static VEC(int,heap) *block_locators_locs;\n+static GTY(()) VEC(tree,gc) *block_locators_blocks;\n+static VEC(int,heap) *locations_locators_locs;\n+DEF_VEC_O(location_t);\n+DEF_VEC_ALLOC_O(location_t,heap);\n+static VEC(location_t,heap) *locations_locators_vals;\n+int prologue_locator;\n+int epilogue_locator;\n+\n+/* Hold current location information and last location information, so the\n+   datastructures are built lazily only when some instructions in given\n+   place are needed.  */\n+static location_t curr_location, last_location;\n+static tree curr_block, last_block;\n+static int curr_rtl_loc = -1;\n+\n+/* Allocate insn locator datastructure.  */\n+void\n+insn_locators_alloc (void)\n+{\n+  prologue_locator = epilogue_locator = 0;\n+\n+  block_locators_locs = VEC_alloc (int, heap, 32);\n+  block_locators_blocks = VEC_alloc (tree, gc, 32);\n+  locations_locators_locs = VEC_alloc (int, heap, 32);\n+  locations_locators_vals = VEC_alloc (location_t, heap, 32);\n+\n+  curr_location = UNKNOWN_LOCATION;\n+  last_location = UNKNOWN_LOCATION;\n+  curr_block = NULL;\n+  last_block = NULL;\n+  curr_rtl_loc = 0;\n+}\n+\n+/* At the end of emit stage, clear current location.  */\n+void\n+insn_locators_finalize (void)\n+{\n+  if (curr_rtl_loc >= 0)\n+    epilogue_locator = curr_insn_locator ();\n+  curr_rtl_loc = -1;\n+}\n+\n+/* Allocate insn locator datastructure.  */\n+void\n+insn_locators_free (void)\n+{\n+  prologue_locator = epilogue_locator = 0;\n+\n+  VEC_free (int, heap, block_locators_locs);\n+  VEC_free (tree,gc, block_locators_blocks);\n+  VEC_free (int, heap, locations_locators_locs);\n+  VEC_free (location_t, heap, locations_locators_vals);\n+}\n+\n+/* Set current location.  */\n+void\n+set_curr_insn_source_location (location_t location)\n+{\n+  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n+     time locators are not initialized.  */\n+  if (curr_rtl_loc == -1)\n+    return;\n+  curr_location = location;\n+}\n+\n+/* Get current location.  */\n+location_t\n+get_curr_insn_source_location (void)\n+{\n+  return curr_location;\n+}\n+\n+/* Set current scope block.  */\n+void\n+set_curr_insn_block (tree b)\n+{\n+  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n+     time locators are not initialized.  */\n+  if (curr_rtl_loc == -1)\n+    return;\n+  if (b)\n+    curr_block = b;\n+}\n+\n+/* Get current scope block.  */\n+tree\n+get_curr_insn_block (void)\n+{\n+  return curr_block;\n+}\n+\n+/* Return current insn locator.  */\n+int\n+curr_insn_locator (void)\n+{\n+  if (curr_rtl_loc == -1 || curr_location == UNKNOWN_LOCATION)\n+    return 0;\n+  if (last_block != curr_block)\n+    {\n+      curr_rtl_loc++;\n+      VEC_safe_push (int, heap, block_locators_locs, curr_rtl_loc);\n+      VEC_safe_push (tree, gc, block_locators_blocks, curr_block);\n+      last_block = curr_block;\n+    }\n+  if (last_location != curr_location)\n+    {\n+      curr_rtl_loc++;\n+      VEC_safe_push (int, heap, locations_locators_locs, curr_rtl_loc);\n+      VEC_safe_push (location_t, heap, locations_locators_vals, &curr_location);\n+      last_location = curr_location;\n+    }\n+  return curr_rtl_loc;\n+}\n+\f\n+\n+/* Return lexical scope block locator belongs to.  */\n+static tree\n+locator_scope (int loc)\n+{\n+  int max = VEC_length (int, block_locators_locs);\n+  int min = 0;\n+\n+  /* When block_locators_locs was initialized, the pro- and epilogue\n+     insns didn't exist yet and can therefore not be found this way.\n+     But we know that they belong to the outer most block of the\n+     current function.\n+     Without this test, the prologue would be put inside the block of\n+     the first valid instruction in the function and when that first\n+     insn is part of an inlined function then the low_pc of that\n+     inlined function is messed up.  Likewise for the epilogue and\n+     the last valid instruction.  */\n+  if (loc == prologue_locator || loc == epilogue_locator)\n+    return DECL_INITIAL (cfun->decl);\n+\n+  if (!max || !loc)\n+    return NULL;\n+  while (1)\n+    {\n+      int pos = (min + max) / 2;\n+      int tmp = VEC_index (int, block_locators_locs, pos);\n+\n+      if (tmp <= loc && min != pos)\n+\tmin = pos;\n+      else if (tmp > loc && max != pos)\n+\tmax = pos;\n+      else\n+\t{\n+\t  min = pos;\n+\t  break;\n+\t}\n+    }\n+  return VEC_index (tree, block_locators_blocks, min);\n+}\n+\n+/* Return lexical scope block insn belongs to.  */\n+tree\n+insn_scope (const_rtx insn)\n+{\n+  return locator_scope (INSN_LOCATOR (insn));\n+}\n+\n+/* Return line number of the statement specified by the locator.  */\n+location_t\n+locator_location (int loc)\n+{\n+  int max = VEC_length (int, locations_locators_locs);\n+  int min = 0;\n+\n+  while (1)\n+    {\n+      int pos = (min + max) / 2;\n+      int tmp = VEC_index (int, locations_locators_locs, pos);\n+\n+      if (tmp <= loc && min != pos)\n+\tmin = pos;\n+      else if (tmp > loc && max != pos)\n+\tmax = pos;\n+      else\n+\t{\n+\t  min = pos;\n+\t  break;\n+\t}\n+    }\n+  return *VEC_index (location_t, locations_locators_vals, min);\n+}\n+\n+/* Return source line of the statement that produced this insn.  */\n+int\n+locator_line (int loc)\n+{\n+  expanded_location xloc;\n+  if (!loc)\n+    return 0;\n+  else\n+    xloc = expand_location (locator_location (loc));\n+  return xloc.line;\n+}\n+\n+/* Return line number of the statement that produced this insn.  */\n+int\n+insn_line (const_rtx insn)\n+{\n+  return locator_line (INSN_LOCATOR (insn));\n+}\n+\n+/* Return source file of the statement specified by LOC.  */\n+const char *\n+locator_file (int loc)\n+{\n+  expanded_location xloc;\n+  if (!loc)\n+    return 0;\n+  else\n+    xloc = expand_location (locator_location (loc));\n+  return xloc.file;\n+}\n+\n+/* Return source file of the statement that produced this insn.  */\n+const char *\n+insn_file (const_rtx insn)\n+{\n+  return locator_file (INSN_LOCATOR (insn));\n+}\n+\n+/* Return true if LOC1 and LOC2 locators have the same location and scope.  */\n+bool\n+locator_eq (int loc1, int loc2)\n+{\n+  if (loc1 == loc2)\n+    return true;\n+  if (locator_location (loc1) != locator_location (loc2))\n+    return false;\n+  return locator_scope (loc1) == locator_scope (loc2);\n+}\n+\f\n #include \"gt-emit-rtl.h\""}, {"sha": "f940b641bc184139c85866df8bedb15d4cca2f53", "filename": "gcc/final.c", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -72,7 +72,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"targhooks.h\"\n #include \"debug.h\"\n #include \"expr.h\"\n-#include \"cfglayout.h\" /* for reemit_insn_block_notes */\n #include \"tree-pass.h\"\n #include \"tree-flow.h\"\n #include \"timevar.h\"\n@@ -1515,6 +1514,114 @@ dwarf2_debug_info_emitted_p (tree decl)\n   return true;\n }\n \n+/* Return scope resulting from combination of S1 and S2.  */\n+static tree\n+choose_inner_scope (tree s1, tree s2)\n+{\n+   if (!s1)\n+     return s2;\n+   if (!s2)\n+     return s1;\n+   if (BLOCK_NUMBER (s1) > BLOCK_NUMBER (s2))\n+     return s1;\n+   return s2;\n+}\n+\n+/* Emit lexical block notes needed to change scope from S1 to S2.  */\n+\n+static void\n+change_scope (rtx orig_insn, tree s1, tree s2)\n+{\n+  rtx insn = orig_insn;\n+  tree com = NULL_TREE;\n+  tree ts1 = s1, ts2 = s2;\n+  tree s;\n+\n+  while (ts1 != ts2)\n+    {\n+      gcc_assert (ts1 && ts2);\n+      if (BLOCK_NUMBER (ts1) > BLOCK_NUMBER (ts2))\n+\tts1 = BLOCK_SUPERCONTEXT (ts1);\n+      else if (BLOCK_NUMBER (ts1) < BLOCK_NUMBER (ts2))\n+\tts2 = BLOCK_SUPERCONTEXT (ts2);\n+      else\n+\t{\n+\t  ts1 = BLOCK_SUPERCONTEXT (ts1);\n+\t  ts2 = BLOCK_SUPERCONTEXT (ts2);\n+\t}\n+    }\n+  com = ts1;\n+\n+  /* Close scopes.  */\n+  s = s1;\n+  while (s != com)\n+    {\n+      rtx note = emit_note_before (NOTE_INSN_BLOCK_END, insn);\n+      NOTE_BLOCK (note) = s;\n+      s = BLOCK_SUPERCONTEXT (s);\n+    }\n+\n+  /* Open scopes.  */\n+  s = s2;\n+  while (s != com)\n+    {\n+      insn = emit_note_before (NOTE_INSN_BLOCK_BEG, insn);\n+      NOTE_BLOCK (insn) = s;\n+      s = BLOCK_SUPERCONTEXT (s);\n+    }\n+}\n+\n+/* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based\n+   on the scope tree and the newly reordered instructions.  */\n+\n+static void\n+reemit_insn_block_notes (void)\n+{\n+  tree cur_block = DECL_INITIAL (cfun->decl);\n+  rtx insn, note;\n+\n+  insn = get_insns ();\n+  if (!active_insn_p (insn))\n+    insn = next_active_insn (insn);\n+  for (; insn; insn = next_active_insn (insn))\n+    {\n+      tree this_block;\n+\n+      /* Avoid putting scope notes between jump table and its label.  */\n+      if (JUMP_TABLE_DATA_P (insn))\n+\tcontinue;\n+\n+      this_block = insn_scope (insn);\n+      /* For sequences compute scope resulting from merging all scopes\n+\t of instructions nested inside.  */\n+      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t{\n+\t  int i;\n+\t  rtx body = PATTERN (insn);\n+\n+\t  this_block = NULL;\n+\t  for (i = 0; i < XVECLEN (body, 0); i++)\n+\t    this_block = choose_inner_scope (this_block,\n+\t\t\t\t\t     insn_scope (XVECEXP (body, 0, i)));\n+\t}\n+      if (! this_block)\n+\tcontinue;\n+\n+      if (this_block != cur_block)\n+\t{\n+\t  change_scope (insn, cur_block, this_block);\n+\t  cur_block = this_block;\n+\t}\n+    }\n+\n+  /* change_scope emits before the insn, not after.  */\n+  note = emit_note (NOTE_INSN_DELETED);\n+  change_scope (note, cur_block, DECL_INITIAL (cfun->decl));\n+  delete_insn (note);\n+\n+  reorder_blocks ();\n+}\n+\n /* Output assembler code for the start of a function,\n    and initialize some of the variables in this file\n    for the new function.  The label for the function and associated"}, {"sha": "41305c8518ba7c2aed9527515f3033abd5a87f5b", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -57,7 +57,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"common/common-target.h\"\n-#include \"cfglayout.h\"\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n #include \"predict.h\"\n@@ -4852,9 +4851,6 @@ expand_function_start (tree subr)\n   /* If we are doing generic stack checking, the probe should go here.  */\n   if (flag_stack_check == GENERIC_STACK_CHECK)\n     stack_check_probe_note = emit_note (NOTE_INSN_DELETED);\n-\n-  /* Make sure there is a line number after the function entry setup code.  */\n-  force_next_line_note ();\n }\n \f\n /* Undo the effects of init_dummy_function_start.  */\n@@ -4999,7 +4995,6 @@ expand_function_end (void)\n \n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */\n-  force_next_line_note ();\n   set_curr_insn_source_location (input_location);\n \n   /* Before the return label (if any), clobber the return"}, {"sha": "1c471d24071249315bd114f802d85a7e625b93fc", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -70,10 +70,6 @@ struct GTY(()) emit_status {\n      --param min-nondebug-insn-uid=<value> is given with nonzero value.  */\n   int x_cur_debug_insn_uid;\n \n-  /* Location the last line-number NOTE emitted.\n-     This is used to avoid generating duplicates.  */\n-  location_t x_last_location;\n-\n   /* The length of the regno_pointer_align, regno_decl, and x_regno_reg_rtx\n      vectors.  Since these vectors are needed during the expansion phase when\n      the total number of registers in the function is not yet known, the"}, {"sha": "cd1a32c27e717b1b476d949495eea1f79f72f7ad", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -1563,7 +1563,7 @@ open_base_files (void)\n       \"hard-reg-set.h\", \"basic-block.h\", \"cselib.h\", \"insn-addr.h\",\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       \"tree-flow.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n-      \"cfglayout.h\", \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\",\n+      \"except.h\", \"output.h\", \"gimple.h\", \"cfgloop.h\",\n       \"target.h\", \"ipa-prop.h\", \"lto-streamer.h\", \"target-globals.h\",\n       \"ipa-inline.h\", \"dwarf2out.h\", NULL\n     };"}, {"sha": "ec1bedd4e4cd8cde963dae3c412270d7b9a3c46d", "filename": "gcc/hw-doloop.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fhw-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fhw-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhw-doloop.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -30,7 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"tm_p.h\"\n #include \"df.h\"\n-#include \"cfglayout.h\"\n #include \"cfgloop.h\"\n #include \"recog.h\"\n #include \"target.h\""}, {"sha": "ee3d80c94795c5a04d104a31fb274245995ac840", "filename": "gcc/loop-init.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -27,7 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n-#include \"cfglayout.h\"\n #include \"tree-pass.h\"\n #include \"timevar.h\"\n #include \"flags.h\""}, {"sha": "139ccee67027ffdbb018d3a8c0d7ba629e7a75a8", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -27,7 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n-#include \"cfglayout.h\"\n #include \"params.h\"\n #include \"expr.h\"\n #include \"hashtab.h\""}, {"sha": "041a117df37d3df73abc9fb5dab7162a5e29e7d0", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -27,7 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n-#include \"cfglayout.h\"\n #include \"params.h\"\n #include \"expr.h\"\n "}, {"sha": "953b78d763e4eddc2ca982ee5308482c3ab20788", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -37,9 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"recog.h\"\n #include \"sched-int.h\"\n #include \"target.h\"\n-#include \"cfglayout.h\"\n #include \"cfgloop.h\"\n-#include \"cfghooks.h\"\n #include \"expr.h\"\n #include \"params.h\"\n #include \"gcov-io.h\""}, {"sha": "ad3a2c317464235f04fc46c5fa28530ed59c2f06", "filename": "gcc/profile.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -63,7 +63,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coverage.h\"\n #include \"value-prof.h\"\n #include \"tree.h\"\n-#include \"cfghooks.h\"\n #include \"tree-flow.h\"\n #include \"timevar.h\"\n #include \"cfgloop.h\""}, {"sha": "4acc23b3c45b03b3d0334257541b38169b1aad74", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -1799,14 +1799,15 @@ extern rtx skip_consecutive_labels (rtx);\n extern rtx next_cc0_user (rtx);\n extern rtx prev_cc0_setter (rtx);\n \n-/* In cfglayout.c  */\n+/* In emit-rtl.c  */\n extern int insn_line (const_rtx);\n extern const char * insn_file (const_rtx);\n extern location_t locator_location (int);\n extern int locator_line (int);\n extern const char * locator_file (int);\n extern bool locator_eq (int, int);\n extern int prologue_locator, epilogue_locator;\n+extern tree insn_scope (const_rtx);\n \n /* In jump.c */\n extern enum rtx_code reverse_condition (enum rtx_code);\n@@ -2420,7 +2421,6 @@ extern void reorder_insns (rtx, rtx, rtx);\n extern void reorder_insns_nobb (rtx, rtx, rtx);\n extern int get_max_insn_count (void);\n extern int in_sequence_p (void);\n-extern void force_next_line_note (void);\n extern void init_emit (void);\n extern void init_emit_regs (void);\n extern void init_emit_once (void);\n@@ -2509,6 +2509,7 @@ extern int fixup_args_size_notes (rtx, rtx, int);\n \n /* In cfgrtl.c */\n extern void print_rtl_with_bb (FILE *, const_rtx);\n+extern rtx duplicate_insn_chain (rtx, rtx);\n \n /* In cfg.c.  */\n extern void dump_reg_info (FILE *);"}, {"sha": "372d1081b4fbd4507f1eacbc2b45bb02fd0d904d", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -36,7 +36,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr.h\"\n #include \"except.h\"\n #include \"recog.h\"\n-#include \"cfglayout.h\"\n #include \"params.h\"\n #include \"sched-int.h\"\n #include \"target.h\""}, {"sha": "71cb25ede1e443e51d64f372602442780e1b3381", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -60,7 +60,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr.h\"\n #include \"except.h\"\n #include \"recog.h\"\n-#include \"cfglayout.h\"\n #include \"params.h\"\n #include \"sched-int.h\"\n #include \"sel-sched.h\""}, {"sha": "7ea67fa0c5e2133448cdf8009ec76933250c15db", "filename": "gcc/tracer.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -42,7 +42,6 @@\n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n-#include \"cfglayout.h\"\n #include \"fibheap.h\"\n #include \"flags.h\"\n #include \"timevar.h\""}, {"sha": "d7ab090fe4b6b45b31f5e80350b56cb5b8ac1e00", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"except.h\"\n #include \"cfgloop.h\"\n-#include \"cfglayout.h\" /* for can_copy_bbs_p and copy_bbs */\n #include \"tree-ssa-propagate.h\"\n #include \"value-prof.h\"\n #include \"pointer-set.h\""}, {"sha": "cefc9c0f93401c34beb0a8f2cd0a996058b799cf", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -772,12 +772,7 @@ extern void make_eh_edges (gimple);\n extern bool make_eh_dispatch_edges (gimple);\n extern edge redirect_eh_edge (edge, basic_block);\n extern void redirect_eh_dispatch_edge (gimple, edge, basic_block);\n-extern bool tree_could_trap_p (tree);\n-extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,\n-\t\t\t\t\t   bool, tree, bool *);\n-extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);\n extern bool stmt_could_throw_p (gimple);\n-extern bool tree_could_throw_p (tree);\n extern bool stmt_can_throw_internal (gimple);\n extern bool stmt_can_throw_external (gimple);\n extern void add_stmt_to_eh_lp_fn (struct function *, gimple, int);"}, {"sha": "9ac0d9a04ebd50cb92a834de55c040652d275e36", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"tree-dump.h\"\n #include \"cfgloop.h\"\n-#include \"cfglayout.h\" /* for can_copy_bbs_p and copy_bbs */\n #include \"diagnostic-core.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\""}, {"sha": "924689339a2624050165491acec8db1b7d19cbf4", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bde837ec571ff83cb5c890c7e49c4144a6a1db/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=78bde837ec571ff83cb5c890c7e49c4144a6a1db", "patch": "@@ -5212,6 +5212,12 @@ extern void expand_return (tree);\n /* In tree-eh.c */\n extern void using_eh_for_cleanups (void);\n \n+extern bool tree_could_trap_p (tree);\n+extern bool operation_could_trap_helper_p (enum tree_code, bool, bool, bool,\n+\t\t\t\t\t   bool, tree, bool *);\n+extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);\n+extern bool tree_could_throw_p (tree);\n+\n /* Compare and hash for any structure which begins with a canonical\n    pointer.  Assumes all pointers are interchangeable, which is sort\n    of already assumed by gcc elsewhere IIRC.  */"}]}