{"sha": "71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFmYjRkYzhjODQxODYxNjhiYmI5N2VjNTRjZTViMjBiMTg5NDZlNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-03T08:07:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-03T08:07:31Z"}, "message": "[multiple changes]\n\n2012-10-03  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch6.adb: Minor typo fix.\n\n2012-10-03  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated):\n\tSet Top_Level properly (to False) for operand of range of\n\tmembership test.\n\t* exp_ch4.adb (Expand_Membership_Minimize_Eliminate_Overflow):\n\tFix crash with -gnato3 and membership operations.\n\t(Expand_Membership_Minimize_Eliminate_Overflow): Fix error message\n\tand wrong results for -gnato3 large expression and predicated\n\tsubtype.\n\t(Expand_Membership_Minimize_Eliminate_Overflow): Use\n\texpression action node to avoid using insert actions (bombs in\n\tsome cases).\n\t(Expand_Compare_Minimize_Eliminate_Overflow): Use expression action\n\tnode to avoid using insert actions (bombs in some cases).\n\n2012-10-03  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Set_CPP_Constructors_Old): Handle constructor of\n\tuntagged type that has all its parameters with defaults and hence it\n\tcovers the default constructor.\n\nFrom-SVN: r192027", "tree": {"sha": "8e08f1f9a0cbe578c53ca75b095a5273c2425339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e08f1f9a0cbe578c53ca75b095a5273c2425339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/comments", "author": null, "committer": null, "parents": [{"sha": "3ada950b1073e2b45550378fcb563ab83943684b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ada950b1073e2b45550378fcb563ab83943684b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ada950b1073e2b45550378fcb563ab83943684b"}], "stats": {"total": 359, "additions": 250, "deletions": 109}, "files": [{"sha": "9c8bab6e23ebad5f6c7855721fb8b9a4bcb6529c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "patch": "@@ -1,3 +1,29 @@\n+2012-10-03  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch6.adb: Minor typo fix.\n+\n+2012-10-03  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated):\n+\tSet Top_Level properly (to False) for operand of range of\n+\tmembership test.\n+\t* exp_ch4.adb (Expand_Membership_Minimize_Eliminate_Overflow):\n+\tFix crash with -gnato3 and membership operations.\n+\t(Expand_Membership_Minimize_Eliminate_Overflow): Fix error message\n+\tand wrong results for -gnato3 large expression and predicated\n+\tsubtype.\n+\t(Expand_Membership_Minimize_Eliminate_Overflow): Use\n+\texpression action node to avoid using insert actions (bombs in\n+\tsome cases).\n+\t(Expand_Compare_Minimize_Eliminate_Overflow): Use expression action\n+\tnode to avoid using insert actions (bombs in some cases).\n+\n+2012-10-03  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Set_CPP_Constructors_Old): Handle constructor of\n+\tuntagged type that has all its parameters with defaults and hence it\n+\tcovers the default constructor.\n+\n 2012-10-03  Yannick Moy  <moy@adacore.com>\n \n \t* checks.adb, sem_prag.adb, s-bignum.ads: Minor typo fixes."}, {"sha": "3e9ee563d21588a6e18b83a44ff6f306b789f78f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "patch": "@@ -1101,17 +1101,16 @@ package body Checks is\n \n       --  In all these cases, we will process at the higher level (and then\n       --  this node will be processed during the downwards recursion that\n-      --  is part of the processing in Minimize_Eliminate_Overflow_Checks.\n+      --  is part of the processing in Minimize_Eliminate_Overflow_Checks).\n \n       if Is_Signed_Integer_Arithmetic_Op (P)\n-        or else Nkind (Op) in N_Membership_Test\n-        or else Nkind (Op) in N_Op_Compare\n+        or else Nkind (P) in N_Membership_Test\n+        or else Nkind (P) in N_Op_Compare\n \n         --  We may also be a range operand in a membership test\n \n-        or else (Nkind (Op) = N_Range\n-                  and then Nkind (Parent (Op)) in N_Membership_Test)\n-\n+        or else (Nkind (P) = N_Range\n+                  and then Nkind (Parent (P)) in N_Membership_Test)\n       then\n          return;\n       end if;"}, {"sha": "223feaca45e52f9734ce5eee154b582a8896d9fc", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 160, "deletions": 101, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "patch": "@@ -2308,6 +2308,9 @@ package body Exp_Ch4 is\n    procedure Expand_Compare_Minimize_Eliminate_Overflow (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n \n+      Result_Type : constant Entity_Id := Etype (N);\n+      --  Capture result type (could be a derived boolean type)\n+\n       Llo, Lhi : Uint;\n       Rlo, Rhi : Uint;\n \n@@ -2452,22 +2455,22 @@ package body Exp_Ch4 is\n                   Right := Convert_To_Bignum (Right);\n                end if;\n \n-               --  We need a sequence that looks like\n-\n-               --    Bnn : Boolean;\n-\n-               --    declare\n-               --       M : Mark_Id := SS_Mark;\n-               --    begin\n-               --       Bnn := Big_xx (Left, Right); (xx = EQ, NT etc)\n-               --       SS_Release (M);\n-               --    end;\n+               --  We rewrite our node with:\n \n-               --  This block is inserted (using Insert_Actions), and then the\n-               --  node is replaced with a reference to Bnn.\n+               --    do\n+               --       Bnn : Result_Type;\n+               --       declare\n+               --          M : Mark_Id := SS_Mark;\n+               --       begin\n+               --          Bnn := Big_xx (Left, Right); (xx = EQ, NT etc)\n+               --          SS_Release (M);\n+               --       end;\n+               --    in\n+               --       Bnn\n+               --    end\n \n                declare\n-                  Blk : constant Node_Id  := Make_Bignum_Block (Loc);\n+                  Blk : constant Node_Id   := Make_Bignum_Block (Loc);\n                   Bnn : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n                   Ent : RE_Id;\n \n@@ -2481,7 +2484,7 @@ package body Exp_Ch4 is\n                      when N_Op_Ne => Ent := RE_Big_NE;\n                   end case;\n \n-                  --  Insert assignment to Bnn\n+                  --  Insert assignment to Bnn into the bignum block\n \n                   Insert_Before\n                     (First (Statements (Handled_Statement_Sequence (Blk))),\n@@ -2493,19 +2496,18 @@ package body Exp_Ch4 is\n                              New_Occurrence_Of (RTE (Ent), Loc),\n                            Parameter_Associations => New_List (Left, Right))));\n \n-                  --  Insert actions (declaration of Bnn and block)\n-\n-                  Insert_Actions (N, New_List (\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Bnn,\n-                      Object_Definition   =>\n-                        New_Occurrence_Of (Standard_Boolean, Loc)),\n-                    Blk));\n-\n-                  --  Rewrite node with reference to Bnn\n+                  --  Now do the rewrite with expression actions\n \n-                  Rewrite (N, New_Occurrence_Of (Bnn, Loc));\n-                  Analyze_And_Resolve (N);\n+                  Rewrite (N,\n+                    Make_Expression_With_Actions (Loc,\n+                      Actions    => New_List (\n+                        Make_Object_Declaration (Loc,\n+                          Defining_Identifier => Bnn,\n+                          Object_Definition   =>\n+                            New_Occurrence_Of (Result_Type, Loc)),\n+                        Blk),\n+                      Expression => New_Occurrence_Of (Bnn, Loc)));\n+                  Analyze_And_Resolve (N, Result_Type);\n                end;\n             end;\n \n@@ -3736,6 +3738,9 @@ package body Exp_Ch4 is\n       --  Despite the name, this routine applies only to N_In, not to\n       --  N_Not_In. The latter is always rewritten as not (X in Y).\n \n+      Result_Type : constant Entity_Id := Etype (N);\n+      --  Capture result type, may be a derived boolean type\n+\n       Loc : constant Source_Ptr := Sloc (N);\n       Lop : constant Node_Id    := Left_Opnd (N);\n       Rop : constant Node_Id    := Right_Opnd (N);\n@@ -3801,35 +3806,42 @@ package body Exp_Ch4 is\n             declare\n                Blk    : constant Node_Id   := Make_Bignum_Block (Loc);\n                Bnn    : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n+               L      : constant Entity_Id :=\n+                          Make_Defining_Identifier (Loc, Name_uL);\n                Lopnd  : constant Node_Id   := Convert_To_Bignum (Lop);\n                Lbound : constant Node_Id   :=\n                           Convert_To_Bignum (Low_Bound (Rop));\n                Hbound : constant Node_Id   :=\n                           Convert_To_Bignum (High_Bound (Rop));\n \n-            --  Now we insert code that looks like\n-\n-            --    Bnn : Boolean;\n-\n-            --    declare\n-            --       M : Mark_Id := SS_Mark;\n-            --       L : Bignum  := Lopnd;\n-            --    begin\n-            --       Bnn := Big_GE (L, Lbound) and then Big_LE (L, Hbound)\n-            --       SS_Release (M);\n-            --    end;\n-\n-            --  and rewrite the membership test as a reference to Bnn\n+            --  Now we rewrite the membership test node to look like\n+\n+            --    do\n+            --       Bnn : Result_Type;\n+            --       declare\n+            --          M : Mark_Id := SS_Mark;\n+            --          L : Bignum  := Lopnd;\n+            --       begin\n+            --          Bnn := Big_GE (L, Lbound) and then Big_LE (L, Hbound)\n+            --          SS_Release (M);\n+            --       end;\n+            --    in\n+            --       Bnn\n+            --    end\n \n             begin\n+               --  Insert declaration of L into declarations of bignum block\n+\n                Insert_After\n                  (Last (Declarations (Blk)),\n                   Make_Object_Declaration (Loc,\n-                    Defining_Identifier => Bnn,\n+                    Defining_Identifier => L,\n                     Object_Definition   =>\n                       New_Occurrence_Of (RTE (RE_Bignum), Loc),\n                     Expression          => Lopnd));\n \n+               --  Insert assignment to Bnn into expressions of bignum block\n+\n                Insert_Before\n                  (First (Statements (Handled_Statement_Sequence (Blk))),\n                   Make_Assignment_Statement (Loc,\n@@ -3840,22 +3852,29 @@ package body Exp_Ch4 is\n                           Make_Function_Call (Loc,\n                             Name                   =>\n                               New_Occurrence_Of (RTE (RE_Big_GE), Loc),\n-                            Parameter_Associations => New_List (Lbound)),\n+                            Parameter_Associations => New_List (\n+                              New_Occurrence_Of (L, Loc),\n+                              Lbound)),\n                         Right_Opnd =>\n                           Make_Function_Call (Loc,\n                             Name                   =>\n-                              New_Occurrence_Of (RTE (RE_Big_GE), Loc),\n-                            Parameter_Associations => New_List (Hbound)))));\n+                              New_Occurrence_Of (RTE (RE_Big_LE), Loc),\n+                            Parameter_Associations => New_List (\n+                              New_Occurrence_Of (L, Loc),\n+                              Hbound)))));\n \n-               Insert_Actions (N, New_List (\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Bnn,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Standard_Boolean, Loc)),\n-                 Blk));\n+               --  Now rewrite the node\n \n-               Rewrite (N, New_Occurrence_Of (Bnn, Loc));\n-               Analyze_And_Resolve (N);\n+               Rewrite (N,\n+                 Make_Expression_With_Actions (Loc,\n+                   Actions    => New_List (\n+                     Make_Object_Declaration (Loc,\n+                       Defining_Identifier => Bnn,\n+                       Object_Definition   =>\n+                         New_Occurrence_Of (Result_Type, Loc)),\n+                     Blk),\n+                   Expression => New_Occurrence_Of (Bnn, Loc)));\n+               Analyze_And_Resolve (N, Result_Type);\n                return;\n             end;\n \n@@ -3876,12 +3895,16 @@ package body Exp_Ch4 is\n \n             else\n                Convert_To_And_Rewrite (LLIB, Lop);\n-               Analyze_And_Resolve (Lop, LLIB, Suppress => All_Checks);\n+               Set_Analyzed (Lop, False);\n+               Analyze_And_Resolve (Lop, LLIB);\n+\n+               --  For the right operand, avoid unnecessary recursion into\n+               --  this routine, we know that overflow is not possible.\n \n                Convert_To_And_Rewrite (LLIB, Low_Bound (Rop));\n                Convert_To_And_Rewrite (LLIB, High_Bound (Rop));\n                Set_Analyzed (Rop, False);\n-               Analyze_And_Resolve (Rop, LLIB, Suppress => All_Checks);\n+               Analyze_And_Resolve (Rop, LLIB, Suppress => Overflow_Check);\n             end if;\n \n             --  Now the three operands are of the same signed integer type,\n@@ -3909,40 +3932,47 @@ package body Exp_Ch4 is\n \n          elsif Is_RTE (Etype (Lop), RE_Bignum) then\n \n-            --  For X in T, we want to insert code that looks like\n+            --  For X in T, we want to rewrite our node as\n \n-            --    Bnn : Boolean;\n+            --    do\n+            --       Bnn : Result_Type;\n \n-            --    declare\n-            --       M   : Mark_Id := SS_Mark;\n-            --       Lnn : Long_Long_Integer'Base\n-            --       Nnn : Bignum;\n+            --       declare\n+            --          M   : Mark_Id := SS_Mark;\n+            --          Lnn : Long_Long_Integer'Base\n+            --          Nnn : Bignum;\n \n-            --    begin\n-            --      Nnn := X;\n+            --       begin\n+            --         Nnn := X;\n \n-            --      if not Bignum_In_LLI_Range (Nnn) then\n-            --         Bnn := False;\n-            --      else\n-            --         Lnn := From_Bignum (Nnn);\n-            --         Bnn := Lnn in T'Base and then T'Base (Lnn) in T;\n-            --      end if;\n+            --         if not Bignum_In_LLI_Range (Nnn) then\n+            --            Bnn := False;\n+            --         else\n+            --            Lnn := From_Bignum (Nnn);\n+            --            Bnn :=\n+            --              Lnn in LLIB (T'Base'First) .. LLIB (T'Base'Last)\n+            --                and then T'Base (Lnn) in T;\n+            --         end if;\n             --\n-            --       SS_Release (M);\n-            --    end;\n+            --          SS_Release (M);\n+            --       end\n+            --   in\n+            --       Bnn\n+            --   end\n \n-            --  And then rewrite the original membership as a reference to Bnn.\n             --  A bit gruesome, but here goes.\n \n             declare\n                Blk : constant Node_Id   := Make_Bignum_Block (Loc);\n                Bnn : constant Entity_Id := Make_Temporary (Loc, 'B', N);\n                Lnn : constant Entity_Id := Make_Temporary (Loc, 'L', N);\n                Nnn : constant Entity_Id := Make_Temporary (Loc, 'N', N);\n+               T   : constant Entity_Id := Etype (Rop);\n+               TB  : constant Entity_Id := Base_Type (T);\n                Nin : Node_Id;\n \n             begin\n-               --  The last membership test is marked to prevent recursion\n+               --  Mark the last membership operation to prevent recursion\n \n                Nin :=\n                  Make_In (Loc,\n@@ -3976,12 +4006,14 @@ package body Exp_Ch4 is\n \n                     Make_If_Statement (Loc,\n                       Condition =>\n-                        Make_Function_Call (Loc,\n-                          Name =>\n-                            New_Occurrence_Of\n-                              (RTE (RE_Bignum_In_LLI_Range), Loc),\n-                          Parameter_Associations => New_List (\n-                            New_Occurrence_Of (Nnn, Loc))),\n+                        Make_Op_Not (Loc,\n+                          Right_Opnd =>\n+                            Make_Function_Call (Loc,\n+                              Name                   =>\n+                                New_Occurrence_Of\n+                                  (RTE (RE_Bignum_In_LLI_Range), Loc),\n+                              Parameter_Associations => New_List (\n+                                New_Occurrence_Of (Nnn, Loc)))),\n \n                       Then_Statements => New_List (\n                         Make_Assignment_Statement (Loc,\n@@ -4000,27 +4032,42 @@ package body Exp_Ch4 is\n                                   New_Occurrence_Of (Nnn, Loc)))),\n \n                         Make_Assignment_Statement (Loc,\n-                          Name => New_Occurrence_Of (Bnn, Loc),\n+                          Name       => New_Occurrence_Of (Bnn, Loc),\n                           Expression =>\n                             Make_And_Then (Loc,\n-                              Left_Opnd =>\n+                              Left_Opnd  =>\n                                 Make_In (Loc,\n-                                  Left_Opnd  =>\n-                                    New_Occurrence_Of (Lnn, Loc),\n+                                  Left_Opnd  => New_Occurrence_Of (Lnn, Loc),\n                                   Right_Opnd =>\n-                                    New_Occurrence_Of\n-                                      (Base_Type (Etype (Rop)), Loc)),\n+                                    Make_Range (Loc,\n+                                      Low_Bound  =>\n+                                        Convert_To (LLIB,\n+                                          Make_Attribute_Reference (Loc,\n+                                            Attribute_Name => Name_First,\n+                                            Prefix         =>\n+                                              New_Occurrence_Of (TB, Loc))),\n+\n+                                      High_Bound =>\n+                                        Convert_To (LLIB,\n+                                          Make_Attribute_Reference (Loc,\n+                                            Attribute_Name => Name_Last,\n+                                            Prefix         =>\n+                                              New_Occurrence_Of (TB, Loc))))),\n+\n                               Right_Opnd => Nin))))));\n \n-               Insert_Actions (N, New_List (\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Bnn,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Standard_Boolean, Loc)),\n-                 Blk));\n+               --  Now we can do the rewrite\n \n-               Rewrite (N, New_Occurrence_Of (Bnn, Loc));\n-               Analyze_And_Resolve (N);\n+               Rewrite (N,\n+                 Make_Expression_With_Actions (Loc,\n+                   Actions    => New_List (\n+                     Make_Object_Declaration (Loc,\n+                       Defining_Identifier => Bnn,\n+                       Object_Definition   =>\n+                         New_Occurrence_Of (Result_Type, Loc)),\n+                     Blk),\n+                   Expression => New_Occurrence_Of (Bnn, Loc)));\n+               Analyze_And_Resolve (N, Result_Type);\n                return;\n             end;\n \n@@ -4030,36 +4077,48 @@ package body Exp_Ch4 is\n          else\n             pragma Assert (Base_Type (Etype (Lop)) = LLIB);\n \n-            --  We rewrite the membership test as\n+            --  We rewrite the membership test as (where T is the type with\n+            --  the predicate, i.e. the type of the right operand)\n \n-            --    Lop in T'Base and then T'Base (Lop) in T\n+            --    Lop in LLIB (T'Base'First) .. LLIB (T'Base'Last)\n+            --      and then T'Base (Lop) in T\n \n             declare\n+               T   : constant Entity_Id := Etype (Rop);\n+               TB  : constant Entity_Id := Base_Type (T);\n                Nin : Node_Id;\n \n             begin\n                --  The last membership test is marked to prevent recursion\n \n                Nin :=\n                  Make_In (Loc,\n-                   Left_Opnd =>\n-                     Convert_To (Base_Type (Etype (Rop)),\n-                       Duplicate_Subexpr (Lop)),\n-                   Right_Opnd => New_Occurrence_Of (Etype (Rop), Loc));\n+                   Left_Opnd  => Convert_To (TB, Duplicate_Subexpr (Lop)),\n+                   Right_Opnd => New_Occurrence_Of (T, Loc));\n                Set_No_Minimize_Eliminate (Nin);\n \n                --  Now do the rewrite\n \n                Rewrite (N,\n                  Make_And_Then (Loc,\n-                   Left_Opnd =>\n+                   Left_Opnd  =>\n                      Make_In (Loc,\n                        Left_Opnd  => Lop,\n                        Right_Opnd =>\n-                         New_Occurrence_Of (Base_Type (Etype (Lop)), Loc)),\n+                         Make_Range (Loc,\n+                           Low_Bound  =>\n+                             Convert_To (LLIB,\n+                               Make_Attribute_Reference (Loc,\n+                                 Attribute_Name => Name_First,\n+                                 Prefix => New_Occurrence_Of (TB, Loc))),\n+                           High_Bound =>\n+                             Convert_To (LLIB,\n+                               Make_Attribute_Reference (Loc,\n+                                 Attribute_Name => Name_Last,\n+                                 Prefix => New_Occurrence_Of (TB, Loc))))),\n                    Right_Opnd => Nin));\n-\n-               Analyze_And_Resolve (N, Restype, Suppress => All_Checks);\n+               Set_Analyzed (N, False);\n+               Analyze_And_Resolve (N, Restype);\n             end;\n          end if;\n       end if;"}, {"sha": "6db86e14ef0e51abecf7569d90877c892674f1c8", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "patch": "@@ -8459,6 +8459,8 @@ package body Exp_Disp is\n          P     : Node_Id;\n          Parms : List_Id;\n \n+         Covers_Default_Constructor : Entity_Id := Empty;\n+\n       begin\n          --  Look for the constructor entities\n \n@@ -8490,7 +8492,8 @@ package body Exp_Disp is\n                            Make_Defining_Identifier (Loc,\n                              Chars (Defining_Identifier (P))),\n                          Parameter_Type =>\n-                           New_Copy_Tree (Parameter_Type (P))));\n+                           New_Copy_Tree (Parameter_Type (P)),\n+                         Expression => New_Copy_Tree (Expression (P))));\n                      Next (P);\n                   end loop;\n                end if;\n@@ -8508,6 +8511,17 @@ package body Exp_Disp is\n                Set_Convention     (Init, Convention_CPP);\n                Set_Is_Public      (Init);\n                Set_Has_Completion (Init);\n+\n+               --  If this constructor has parameters and all its parameters\n+               --  have defaults then it covers the default constructor. The\n+               --  semantic analyzer ensures that only one constructor with\n+               --  defaults covers the default constructor.\n+\n+               if Present (Parameter_Specifications (Parent (E)))\n+                 and then Needs_No_Actuals (E)\n+               then\n+                  Covers_Default_Constructor := Init;\n+               end if;\n             end if;\n \n             Next_Entity (E);\n@@ -8519,6 +8533,49 @@ package body Exp_Disp is\n          if not Found then\n             Set_Is_Abstract_Type (Typ);\n          end if;\n+\n+         --  Handle constructor that has all its parameters with defaults and\n+         --  hence it covers the default constructor. We generate a wrapper IP\n+         --  which calls the covering constructor.\n+\n+         if Present (Covers_Default_Constructor) then\n+            declare\n+               Body_Stmts        : List_Id;\n+               Wrapper_Id        : Entity_Id;\n+               Wrapper_Body_Node : Node_Id;\n+            begin\n+               Loc := Sloc (Covers_Default_Constructor);\n+\n+               Body_Stmts := New_List (\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (Covers_Default_Constructor, Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Identifier (Loc, Name_uInit))));\n+\n+               Wrapper_Id := Make_Defining_Identifier (Loc,\n+                 Make_Init_Proc_Name (Typ));\n+\n+               Wrapper_Body_Node :=\n+                 Make_Subprogram_Body (Loc,\n+                   Specification =>\n+                     Make_Procedure_Specification (Loc,\n+                       Defining_Unit_Name => Wrapper_Id,\n+                       Parameter_Specifications => New_List (\n+                         Make_Parameter_Specification (Loc,\n+                           Defining_Identifier =>\n+                             Make_Defining_Identifier (Loc, Name_uInit),\n+                           Parameter_Type =>\n+                             New_Reference_To (Typ, Loc)))),\n+                   Declarations => No_List,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => Body_Stmts,\n+                       Exception_Handlers => No_List));\n+\n+               Discard_Node (Wrapper_Body_Node);\n+               Set_Init_Proc (Typ, Wrapper_Id);\n+            end;\n+         end if;\n       end Set_CPP_Constructors_Old;\n \n       --  Local variables"}, {"sha": "4988661a081cab8aff94208e5f4fabcdb7f2e4fe", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71fb4dc8c84186168bbb97ec54ce5b20b18946e4/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=71fb4dc8c84186168bbb97ec54ce5b20b18946e4", "patch": "@@ -5764,7 +5764,7 @@ package body Sem_Ch6 is\n                     and then TSS_Name /= TSS_Stream_Output\n                   then\n                      --  Here we have a definite conformance error. It is worth\n-                     --  special casesing the error message for the case of a\n+                     --  special casing the error message for the case of a\n                      --  controlling formal (which excludes null).\n \n                      if Is_Controlling_Formal (New_Formal) then"}]}