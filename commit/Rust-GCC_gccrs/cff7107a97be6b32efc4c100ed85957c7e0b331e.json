{"sha": "cff7107a97be6b32efc4c100ed85957c7e0b331e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmNzEwN2E5N2JlNmIzMmVmYzRjMTAwZWQ4NTk1N2M3ZTBiMzMxZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:18:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:18:52Z"}, "message": "poly_int: alter_reg\n\nThis patch makes alter_reg cope with polynomial mode sizes.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* reload1.c (spill_stack_slot_width): Change element type\n\tfrom unsigned int to poly_uint64_pod.\n\t(alter_reg): Treat mode sizes as polynomial.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256160", "tree": {"sha": "9f51809c8a2ed51d25f59ccba8361d873a0b8367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f51809c8a2ed51d25f59ccba8361d873a0b8367"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cff7107a97be6b32efc4c100ed85957c7e0b331e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff7107a97be6b32efc4c100ed85957c7e0b331e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff7107a97be6b32efc4c100ed85957c7e0b331e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff7107a97be6b32efc4c100ed85957c7e0b331e/comments", "author": null, "committer": null, "parents": [{"sha": "65f914e714d985db7eaaa8e63a210b4fee17b13f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f914e714d985db7eaaa8e63a210b4fee17b13f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f914e714d985db7eaaa8e63a210b4fee17b13f"}], "stats": {"total": 43, "additions": 31, "deletions": 12}, "files": [{"sha": "2b47abc78f7c2d618b08b81edf00c89da79ca9a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7107a97be6b32efc4c100ed85957c7e0b331e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7107a97be6b32efc4c100ed85957c7e0b331e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cff7107a97be6b32efc4c100ed85957c7e0b331e", "patch": "@@ -1,3 +1,11 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* reload1.c (spill_stack_slot_width): Change element type\n+\tfrom unsigned int to poly_uint64_pod.\n+\t(alter_reg): Treat mode sizes as polynomial.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d9d099997e74b1716328c0db9c69cc81ae300e7e", "filename": "gcc/reload1.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff7107a97be6b32efc4c100ed85957c7e0b331e/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff7107a97be6b32efc4c100ed85957c7e0b331e/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cff7107a97be6b32efc4c100ed85957c7e0b331e", "patch": "@@ -200,7 +200,7 @@ static int last_spill_reg;\n static rtx spill_stack_slot[FIRST_PSEUDO_REGISTER];\n \n /* Width allocated so far for that stack slot.  */\n-static unsigned int spill_stack_slot_width[FIRST_PSEUDO_REGISTER];\n+static poly_uint64_pod spill_stack_slot_width[FIRST_PSEUDO_REGISTER];\n \n /* Record which pseudos needed to be spilled.  */\n static regset_head spilled_pseudos;\n@@ -2142,10 +2142,10 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n     {\n       rtx x = NULL_RTX;\n       machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n-      unsigned HOST_WIDE_INT inherent_size = PSEUDO_REGNO_BYTES (i);\n+      poly_uint64 inherent_size = GET_MODE_SIZE (mode);\n       unsigned int inherent_align = GET_MODE_ALIGNMENT (mode);\n       machine_mode wider_mode = wider_subreg_mode (mode, reg_max_ref_mode[i]);\n-      unsigned HOST_WIDE_INT total_size = GET_MODE_SIZE (wider_mode);\n+      poly_uint64 total_size = GET_MODE_SIZE (wider_mode);\n       unsigned int min_align = GET_MODE_BITSIZE (reg_max_ref_mode[i]);\n       poly_int64 adjust = 0;\n \n@@ -2174,10 +2174,15 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t{\n \t  rtx stack_slot;\n \n+\t  /* The sizes are taken from a subreg operation, which guarantees\n+\t     that they're ordered.  */\n+\t  gcc_checking_assert (ordered_p (total_size, inherent_size));\n+\n \t  /* No known place to spill from => no slot to reuse.  */\n \t  x = assign_stack_local (mode, total_size,\n \t\t\t\t  min_align > inherent_align\n-\t\t\t\t  || total_size > inherent_size ? -1 : 0);\n+\t\t\t\t  || maybe_gt (total_size, inherent_size)\n+\t\t\t\t  ? -1 : 0);\n \n \t  stack_slot = x;\n \n@@ -2189,7 +2194,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t      adjust = inherent_size - total_size;\n \t      if (maybe_ne (adjust, 0))\n \t\t{\n-\t\t  unsigned int total_bits = total_size * BITS_PER_UNIT;\n+\t\t  poly_uint64 total_bits = total_size * BITS_PER_UNIT;\n \t\t  machine_mode mem_mode\n \t\t    = int_mode_for_size (total_bits, 1).else_blk ();\n \t\t  stack_slot = adjust_address_nv (x, mem_mode, adjust);\n@@ -2203,9 +2208,10 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \n       /* Reuse a stack slot if possible.  */\n       else if (spill_stack_slot[from_reg] != 0\n-\t       && spill_stack_slot_width[from_reg] >= total_size\n-\t       && (GET_MODE_SIZE (GET_MODE (spill_stack_slot[from_reg]))\n-\t\t   >= inherent_size)\n+\t       && known_ge (spill_stack_slot_width[from_reg], total_size)\n+\t       && known_ge (GET_MODE_SIZE\n+\t\t\t    (GET_MODE (spill_stack_slot[from_reg])),\n+\t\t\t    inherent_size)\n \t       && MEM_ALIGN (spill_stack_slot[from_reg]) >= min_align)\n \tx = spill_stack_slot[from_reg];\n \n@@ -2221,16 +2227,21 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t      if (partial_subreg_p (mode,\n \t\t\t\t    GET_MODE (spill_stack_slot[from_reg])))\n \t\tmode = GET_MODE (spill_stack_slot[from_reg]);\n-\t      if (spill_stack_slot_width[from_reg] > total_size)\n-\t\ttotal_size = spill_stack_slot_width[from_reg];\n+\t      total_size = ordered_max (total_size,\n+\t\t\t\t\tspill_stack_slot_width[from_reg]);\n \t      if (MEM_ALIGN (spill_stack_slot[from_reg]) > min_align)\n \t\tmin_align = MEM_ALIGN (spill_stack_slot[from_reg]);\n \t    }\n \n+\t  /* The sizes are taken from a subreg operation, which guarantees\n+\t     that they're ordered.  */\n+\t  gcc_checking_assert (ordered_p (total_size, inherent_size));\n+\n \t  /* Make a slot with that size.  */\n \t  x = assign_stack_local (mode, total_size,\n \t\t\t\t  min_align > inherent_align\n-\t\t\t\t  || total_size > inherent_size ? -1 : 0);\n+\t\t\t\t  || maybe_gt (total_size, inherent_size)\n+\t\t\t\t  ? -1 : 0);\n \t  stack_slot = x;\n \n \t  /* Cancel the  big-endian correction done in assign_stack_local.\n@@ -2241,7 +2252,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t      adjust = GET_MODE_SIZE (mode) - total_size;\n \t      if (maybe_ne (adjust, 0))\n \t\t{\n-\t\t  unsigned int total_bits = total_size * BITS_PER_UNIT;\n+\t\t  poly_uint64 total_bits = total_size * BITS_PER_UNIT;\n \t\t  machine_mode mem_mode\n \t\t    = int_mode_for_size (total_bits, 1).else_blk ();\n \t\t  stack_slot = adjust_address_nv (x, mem_mode, adjust);"}]}