{"sha": "5692c7bc60a884946e782bb9c1fe72e919301557", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY5MmM3YmM2MGE4ODQ5NDZlNzgyYmI5YzFmZTcyZTkxOTMwMTU1Nw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-05-13T04:50:20Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-05-13T04:50:20Z"}, "message": "emit-rtl.c (global_rtl): Update comment.\n\n\t* emit-rtl.c (global_rtl): Update comment.\n\t(const_double_htab, const_double_htab_hash,\n\tconst_double_htab_hash, lookup_const_double): New.\n\t(const_int_htab_hash, const_int_htab_eq): Remove const\n\tqualifiers, which cause tons of warnings with RTL checking on.\n\t(gen_rtx_CONST_DOUBLE): Deleted.\n\t(const_double_from_real_value): New function - bears some\n\tresemblance to the former immed_real_const_1.\n\t(immed_double_const): Moved here from varasm.c and\n\tsimplified.\n\t(gen_rtx_REG): Make REGNO unsigned to squelch warnings.\n\t(gen_rtx_SUBREG): Use gen_rtx_raw_SUBREG.\n\t(gen_rtx): Use immed_double_const.\n\t(init_emit_once): Initialize the const_double_htab.  Use\n\tREAL_VALUE_FROM_INT where possible.  Can now use\n\tCONST_DOUBLE_FROM_REAL_VALUE when setting up const_tiny_rtx.\n\t* varasm.c (struct varasm_status): Remove x_const_double_chain.\n\t(const_double_chain, immed_real_const, clear_const_double_mem): Delete.\n\t(immed_double_const, immed_real_const_1): Moved to emit-rtl.c.\n\t(init_varasm_status, mark_varasm_status): Don't touch\n\tx_const_double_chain.\n\n\t* output.h: Delete prototype for clear_const_double_mem.\n\t* real.h: Make REAL_VALUE_TYPE a macro again.  Remove leading\n\t'0' slot from all CONST_DOUBLE_FORMAT definitions.  Prototype\n\tconst_double_from_real_value, not immed_real_const_1, and use\n\tit to define CONST_DOUBLE_FROM_REAL_VALUE.  Define new macro\n\tCONST_DOUBLE_ATOF.\n\t* rtl.h (CONST_DOUBLE_CHAIN): Kill.\n\t(CONST_DOUBLE_LOW, CONST_DOUBLE_HIGH): Adjust.\n\t(gen_rtx_CONST_DOUBLE, immed_real_const): Delete prototypes.\n\t(gen_rtx_REG): Second arg is unsigned.\n\n\t* gengenrtl.c (special_rtx): Take out CONST_DOUBLE.\n\t(excluded_rtx): New, return true for CONST_DOUBLE.\n\t(genmacro): Write nothing for excluded codes.\n\t* combine.c (combine_simplify_rtx): Use CONST_DOUBLE_FROM_REAL_VALUE.\n\t* expr.c (expand_expr): Likewise.\n\t* ggc-common.c (ggc_mark_rtx_children_1): Don't mark the\n\tCONST_DOUBLE_CHAIN.\n\t* toplev.c (rest_of_compilation): Don't call\n\tclear_const_double_mem.\n\n\t* config/rs6000/rs6000.c (rs6000_float_const): Delete.\n\t(rs6000_hash_constant): Remove CONST_DOUBLE special case.\n\t(toc_hash_eq): Remove CONST_DOUBLE and LABEL_REF special cases.\n\t* config/rs6000/rs6000-protos.h: Don't prototype rs6000_float_const.\n\t* config/c4x/c4x.md, config/rs6000/rs6000.md: Use CONST_DOUBLE_ATOF.\n\t* config/dsp16xx/dsp16xx.md, config/mips/mips.md,\n\tconfig/pa/pa.md: Use CONST_DOUBLE_FROM_REAL_VALUE.\n\t* config/sparc/sparc.md, config/sparc/sparc.c: Use immed_double_const.\n\nFrom-SVN: r53409", "tree": {"sha": "e4ab53634b284c98ed87220fcf4d28bcf380dd5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4ab53634b284c98ed87220fcf4d28bcf380dd5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5692c7bc60a884946e782bb9c1fe72e919301557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5692c7bc60a884946e782bb9c1fe72e919301557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5692c7bc60a884946e782bb9c1fe72e919301557", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5692c7bc60a884946e782bb9c1fe72e919301557/comments", "author": null, "committer": null, "parents": [{"sha": "31397a7b647de5fd81965c36a86ac04b1de7da57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31397a7b647de5fd81965c36a86ac04b1de7da57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31397a7b647de5fd81965c36a86ac04b1de7da57"}], "stats": {"total": 690, "additions": 324, "deletions": 366}, "files": [{"sha": "443aff9977b037e6771437ecb4a9bc4071729729", "filename": "gcc/ChangeLog", "status": "modified", "additions": 82, "deletions": 28, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -1,3 +1,57 @@\n+2002-05-12  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* emit-rtl.c (global_rtl): Update comment.\n+\t(const_double_htab, const_double_htab_hash,\n+\tconst_double_htab_hash, lookup_const_double): New.\n+\t(const_int_htab_hash, const_int_htab_eq): Remove const\n+\tqualifiers, which cause tons of warnings with RTL checking on.\n+\t(gen_rtx_CONST_DOUBLE): Deleted.\n+\t(const_double_from_real_value): New function - bears some\n+\tresemblance to the former immed_real_const_1.\n+\t(immed_double_const): Moved here from varasm.c and\n+\tsimplified.\n+\t(gen_rtx_REG): Make REGNO unsigned to squelch warnings.\n+\t(gen_rtx_SUBREG): Use gen_rtx_raw_SUBREG.\n+\t(gen_rtx): Use immed_double_const.\n+\t(init_emit_once): Initialize the const_double_htab.  Use\n+\tREAL_VALUE_FROM_INT where possible.  Can now use\n+\tCONST_DOUBLE_FROM_REAL_VALUE when setting up const_tiny_rtx.\n+\t* varasm.c (struct varasm_status): Remove x_const_double_chain.\n+\t(const_double_chain, immed_real_const, clear_const_double_mem): Delete.\n+\t(immed_double_const, immed_real_const_1): Moved to emit-rtl.c.\n+\t(init_varasm_status, mark_varasm_status): Don't touch\n+\tx_const_double_chain.\n+\n+\t* output.h: Delete prototype for clear_const_double_mem.\n+\t* real.h: Make REAL_VALUE_TYPE a macro again.  Remove leading\n+\t'0' slot from all CONST_DOUBLE_FORMAT definitions.  Prototype\n+\tconst_double_from_real_value, not immed_real_const_1, and use\n+\tit to define CONST_DOUBLE_FROM_REAL_VALUE.  Define new macro\n+\tCONST_DOUBLE_ATOF.\n+\t* rtl.h (CONST_DOUBLE_CHAIN): Kill.\n+\t(CONST_DOUBLE_LOW, CONST_DOUBLE_HIGH): Adjust.\n+\t(gen_rtx_CONST_DOUBLE, immed_real_const): Delete prototypes.\n+\t(gen_rtx_REG): Second arg is unsigned.\n+\n+\t* gengenrtl.c (special_rtx): Take out CONST_DOUBLE.\n+\t(excluded_rtx): New, return true for CONST_DOUBLE.\n+\t(genmacro): Write nothing for excluded codes.\n+\t* combine.c (combine_simplify_rtx): Use CONST_DOUBLE_FROM_REAL_VALUE.\n+\t* expr.c (expand_expr): Likewise.\n+\t* ggc-common.c (ggc_mark_rtx_children_1): Don't mark the\n+\tCONST_DOUBLE_CHAIN.\n+\t* toplev.c (rest_of_compilation): Don't call\n+\tclear_const_double_mem.\n+\n+\t* config/rs6000/rs6000.c (rs6000_float_const): Delete.\n+\t(rs6000_hash_constant): Remove CONST_DOUBLE special case.\n+\t(toc_hash_eq): Remove CONST_DOUBLE and LABEL_REF special cases.\n+\t* config/rs6000/rs6000-protos.h: Don't prototype rs6000_float_const.\n+\t* config/c4x/c4x.md, config/rs6000/rs6000.md: Use CONST_DOUBLE_ATOF.\n+\t* config/dsp16xx/dsp16xx.md, config/mips/mips.md,\n+\tconfig/pa/pa.md: Use CONST_DOUBLE_FROM_REAL_VALUE.\n+\t* config/sparc/sparc.md, config/sparc/sparc.c: Use immed_double_const.\n+\n 2002-05-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* mips/iris6.h (CPLUSPLUS_CPP_SPEC): Define.\n@@ -313,38 +367,38 @@ Thu May  9 14:52:45 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \t* final.c (end_final): Use C trees to output data structures for profiling.\n \n \t* Makefile.in (LIBGCC_DEPS): Added missing dependency on gcov-io.h\n-        (profile.o): New dependency profile.h\n-        (final.o): New dependency profile.h\n-        * profile.h: New file. New global structure profile_info.\n-        * final.h (count_edges_instrumented_now): Declare.\n-        (current_function_cfg_checksum): Declare.\n-        (function_list): New structure.\n-        (functions_head, functions_tail): New static variables.\n-        (end_final): Emits more data, removed some -ax stuff.\n-        (final): Stores function names and chcksums.\n-        * gcov-io.h (__write_gcov_string): New function.\n-        (__read_gcov_string): New function.\n-        * gcov.c (read_profile): New function.\n-        (create_program_flow_graph): Uses read_profile instead of reading\n+\t(profile.o): New dependency profile.h\n+\t(final.o): New dependency profile.h\n+\t* profile.h: New file. New global structure profile_info.\n+\t* final.h (count_edges_instrumented_now): Declare.\n+\t(current_function_cfg_checksum): Declare.\n+\t(function_list): New structure.\n+\t(functions_head, functions_tail): New static variables.\n+\t(end_final): Emits more data, removed some -ax stuff.\n+\t(final): Stores function names and chcksums.\n+\t* gcov-io.h (__write_gcov_string): New function.\n+\t(__read_gcov_string): New function.\n+\t* gcov.c (read_profile): New function.\n+\t(create_program_flow_graph): Uses read_profile instead of reading\n \tda_file.\n-        (read_files): Removed da_file checking, it's done by read_profile now.\n-        * libgcc2.c (bb_function_info): New structure.\n-        (bb): New field in structure, removed some -ax stuff.\n-        (__bb_exit_func): Changed structure of da_file.\n-        * profile.c (count_edges_instrumented_now): New global variable.\n-        (current_function_cfg_checksum): New global variable.\n-        (max_counter_in_program): New global variable.\n-        (get_exec_counts): New function.\n-        (compute_checksum): New function.\n-        (instrument_edges): Sets count_edges_instrumented_now.\n-        (compute_branch_probabilities): Uses get_exec_counts instead of\n+\t(read_files): Removed da_file checking, it's done by read_profile now.\n+\t* libgcc2.c (bb_function_info): New structure.\n+\t(bb): New field in structure, removed some -ax stuff.\n+\t(__bb_exit_func): Changed structure of da_file.\n+\t* profile.c (count_edges_instrumented_now): New global variable.\n+\t(current_function_cfg_checksum): New global variable.\n+\t(max_counter_in_program): New global variable.\n+\t(get_exec_counts): New function.\n+\t(compute_checksum): New function.\n+\t(instrument_edges): Sets count_edges_instrumented_now.\n+\t(compute_branch_probabilities): Uses get_exec_counts instead of\n \treading da_file.\n-        (branch_prob): Calls compute_checksum and writes extra data to bbg_file.\n-        (init_branch_prob): Removed da_file checking, done in get_exec_counts\n+\t(branch_prob): Calls compute_checksum and writes extra data to bbg_file.\n+\t(init_branch_prob): Removed da_file checking, done in get_exec_counts\n \tnow.\n-        (end_branch_prob): Removed da_file checking, done in get_exec_counts\n+\t(end_branch_prob): Removed da_file checking, done in get_exec_counts\n \tnow.\n-        * gcov.texi: Updated information about gcov file format.\n+\t* gcov.texi: Updated information about gcov file format.\n \n 2002-05-09  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "9415728d6307771834a90248c1e0c4b98507fe22", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -3773,7 +3773,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  if (temp == const0_rtx)\n \t    temp = CONST0_RTX (mode);\n \t  else\n-\t    temp = immed_real_const_1 (FLOAT_STORE_FLAG_VALUE (mode), mode);\n+\t    temp = CONST_DOUBLE_FROM_REAL_VALUE (FLOAT_STORE_FLAG_VALUE (mode),\n+\t\t\t\t\t\t mode);\n \t}\n #endif\n       break;"}, {"sha": "b9ac85cffe81b339977f205fb4ff4fce2e1fed7b", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -3714,8 +3714,7 @@\n   operands[4] = gen_reg_rtx (QFmode);\n   operands[5] = gen_reg_rtx (QFmode);\n   operands[6] = gen_reg_rtx (QFmode);\n-  emit_move_insn (operands[5], \n-   immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", QFmode), QFmode));\")\n+  emit_move_insn (operands[5], CONST_DOUBLE_ATOF (\\\"4294967296.0\\\", QFmode));\")\n \n (define_expand \"floatunsqihf2\"\n  [(set (match_dup 2) (match_dup 3))\n@@ -3737,8 +3736,7 @@\n   operands[4] = gen_reg_rtx (HFmode);\n   operands[5] = gen_reg_rtx (HFmode);\n   operands[6] = gen_reg_rtx (HFmode);\n-  emit_move_insn (operands[5], \n-   immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", HFmode), HFmode));\")\n+  emit_move_insn (operands[5], CONST_DOUBLE_ATOF (\\\"4294967296.0\\\", HFmode));\")\n \n (define_insn \"floatqihf2\"\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n@@ -3877,8 +3875,7 @@\n   operands[3] = gen_reg_rtx (QFmode);\n   operands[4] = gen_reg_rtx (QImode);\n   operands[5] = gen_reg_rtx (QFmode);\n-  emit_move_insn (operands[5],\n-   immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", QFmode), QFmode));\")\n+  emit_move_insn (operands[5], CONST_DOUBLE_ATOF (\\\"4294967296.0\\\", QFmode));\")\n \n (define_expand \"fixuns_trunchfqi2\"\n  [(parallel [(set (match_dup 2)\n@@ -3900,8 +3897,7 @@\n   operands[3] = gen_reg_rtx (HFmode);\n   operands[4] = gen_reg_rtx (QImode);\n   operands[5] = gen_reg_rtx (HFmode);\n-  emit_move_insn (operands[5],\n-   immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", HFmode), HFmode));\")\n+  emit_move_insn (operands[5], CONST_DOUBLE_ATOF (\\\"4294967296.0\\\", HFmode));\")\n \n (define_expand \"fixuns_truncqfhi2\"\n   [(parallel [(set (match_operand:HI 0 \"reg_operand\" \"\")\n@@ -3981,10 +3977,8 @@\n    operands[2] = gen_reg_rtx (QFmode);\n    operands[3] = gen_reg_rtx (QFmode);\n    operands[4] = gen_reg_rtx (QFmode);\n-   operands[5] = immed_real_const_1 (REAL_VALUE_ATOF (\\\"0.5\\\", QFmode),\n-                                     QFmode);\n-   operands[6] = immed_real_const_1 (REAL_VALUE_ATOF (\\\"1.5\\\", QFmode),\n-                                     QFmode);\")\n+   operands[5] = CONST_DOUBLE_ATOF (\\\"0.5\\\", QFmode);\n+   operands[6] = CONST_DOUBLE_ATOF (\\\"1.5\\\", QFmode);\")\n \n (define_expand \"sqrtqf2\"\n   [(parallel [(set (match_operand:QF 0 \"reg_operand\" \"\")\n@@ -6197,8 +6191,8 @@\n   operands[2] = gen_reg_rtx (HFmode);\n   operands[3] = gen_reg_rtx (HFmode);\n   operands[4] = gen_reg_rtx (HFmode);\n-  operands[5] = immed_real_const_1 (REAL_VALUE_ATOF (\\\"0.5\\\", HFmode), HFmode);\n-  operands[6] = immed_real_const_1 (REAL_VALUE_ATOF (\\\"1.5\\\", HFmode), HFmode);\n+  operands[5] = CONST_DOUBLE_ATOF (\\\"0.5\\\", HFmode);\n+  operands[6] = CONST_DOUBLE_ATOF (\\\"1.5\\\", HFmode);\n   \")\n \n "}, {"sha": "fc506b975a470a57fe75cf92822183b87d8acbba", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -1939,7 +1939,7 @@\n \n   if (reg1)\t\t\t/* turn off complaints about unreached code */\n     {\n-      emit_move_insn (reg1, immed_real_const_1 (offset, HFmode));\n+      emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, HFmode));\n       do_pending_stack_adjust ();\n \n       emit_insn (gen_cmphf (operands[1], reg1));"}, {"sha": "118c15984ed9b8da41a376612f816e36cce9ca6d", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -4509,7 +4509,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n   if (reg1)\t\t\t/* turn off complaints about unreached code */\n     {\n-      emit_move_insn (reg1, immed_real_const_1 (offset, DFmode));\n+      emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n       do_pending_stack_adjust ();\n \n       emit_insn (gen_cmpdf (operands[1], reg1));\n@@ -4553,7 +4553,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n   if (reg1)\t\t\t/* turn off complaints about unreached code */\n     {\n-      emit_move_insn (reg1, immed_real_const_1 (offset, DFmode));\n+      emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));\n       do_pending_stack_adjust ();\n \n       emit_insn (gen_cmpdf (operands[1], reg1));\n@@ -4597,7 +4597,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n   if (reg1)\t\t\t/* turn off complaints about unreached code */\n     {\n-      emit_move_insn (reg1, immed_real_const_1 (offset, SFmode));\n+      emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n       do_pending_stack_adjust ();\n \n       emit_insn (gen_cmpsf (operands[1], reg1));\n@@ -4641,7 +4641,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n   if (reg1)\t\t\t/* turn off complaints about unreached code */\n     {\n-      emit_move_insn (reg1, immed_real_const_1 (offset, SFmode));\n+      emit_move_insn (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));\n       do_pending_stack_adjust ();\n \n       emit_insn (gen_cmpsf (operands[1], reg1));"}, {"sha": "a81455465484bed29c28fae8ddb76a7a07345d83", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -4796,7 +4796,8 @@\n     emit_insn (gen_negdf2_fast (operands[0], operands[1]));\n   else\n     {\n-      operands[2] = force_reg (DFmode, immed_real_const_1 (dconstm1, DFmode));\n+      operands[2] = force_reg (DFmode,\n+\tCONST_DOUBLE_FROM_REAL_VALUE (dconstm1, DFmode));\n       emit_insn (gen_muldf3 (operands[0], operands[1], operands[2]));\n     }\n   DONE;\n@@ -4826,7 +4827,8 @@\n     emit_insn (gen_negsf2_fast (operands[0], operands[1]));\n   else\n     {\n-      operands[2] = force_reg (SFmode, immed_real_const_1 (dconstm1, SFmode));\n+      operands[2] = force_reg (SFmode,\n+\tCONST_DOUBLE_FROM_REAL_VALUE (dconstm1, SFmode));\n       emit_insn (gen_mulsf3 (operands[0], operands[1], operands[2]));\n     }\n   DONE;"}, {"sha": "954366334ba5d8bef08aa2dcc11a31da00d446a6", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -160,8 +160,6 @@ extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n extern void optimization_options PARAMS ((int, int));\n extern void rs6000_override_options PARAMS ((const char *));\n extern void rs6000_file_start PARAMS ((FILE *, const char *));\n-extern struct rtx_def *rs6000_float_const PARAMS ((const char *,\n-\t\t\t\t\t\t   enum machine_mode));\n extern int direct_return PARAMS ((void));\n extern union tree_node *rs6000_build_va_list PARAMS ((void));\n extern int first_reg_to_save PARAMS ((void));"}, {"sha": "44e70dbc3844a913c47343c0ed66054c87feb4df", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -702,19 +702,6 @@ rs6000_file_start (file, default_cpu)\n \tputc ('\\n', file);\n     }\n }\n-\n-\f\n-/* Create a CONST_DOUBLE from a string.  */\n-\n-struct rtx_def *\n-rs6000_float_const (string, mode)\n-     const char *string;\n-     enum machine_mode mode;\n-{\n-  REAL_VALUE_TYPE value;\n-  value = REAL_VALUE_ATOF (string, mode);\n-  return immed_real_const_1 (value, mode);\n-}\n \f\n /* Return non-zero if this function is known to have a null epilogue.  */\n \n@@ -10044,9 +10031,7 @@ rs6000_hash_constant (k)\n   if (GET_CODE (k) == LABEL_REF)\n     return result * 1231 + X0INT (XEXP (k, 0), 3);\n \n-  if (GET_CODE (k) == CONST_DOUBLE)\n-    fidx = 1;\n-  else if (GET_CODE (k) == CODE_LABEL)\n+  if (GET_CODE (k) == CODE_LABEL)\n     fidx = 3;\n   else\n     fidx = 0;\n@@ -10112,29 +10097,7 @@ toc_hash_eq (h1, h2)\n       != ((const struct toc_hash_struct *) h2)->key_mode)\n     return 0;\n \n-  /* Gotcha:  One of these const_doubles will be in memory.\n-     The other may be on the constant-pool chain.\n-     So rtx_equal_p will think they are different...  */\n-  if (r1 == r2)\n-    return 1;\n-  if (GET_CODE (r1) != GET_CODE (r2)\n-      || GET_MODE (r1) != GET_MODE (r2))\n-    return 0;\n-  if (GET_CODE (r1) == CONST_DOUBLE)\n-    {\n-      int format_len = strlen (GET_RTX_FORMAT (CONST_DOUBLE));\n-      int i;\n-      for (i = 1; i < format_len; i++)\n-\tif (XWINT (r1, i) != XWINT (r2, i))\n-\t  return 0;\n-      \n-      return 1;\n-    }\n-  else if (GET_CODE (r1) == LABEL_REF)\n-    return (CODE_LABEL_NUMBER (XEXP (r1, 0)) \n-\t    == CODE_LABEL_NUMBER (XEXP (r2, 0)));\n-  else\n-    return rtx_equal_p (r1, r2);\n+  return rtx_equal_p (r1, r2);\n }\n \n /* Mark the hash table-entry HASH_ENTRY.  */"}, {"sha": "423ecfd2a96ad3f0dbbed7f6b4527b144e89cb08", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -5253,7 +5253,7 @@\n   \"\n {\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n-  operands[3] = force_reg (DFmode, rs6000_float_const (\\\"4503601774854144\\\", DFmode));\n+  operands[3] = force_reg (DFmode, CONST_DOUBLE_ATOF (\\\"4503601774854144\\\", DFmode));\n   operands[4] = assign_stack_temp (DFmode, GET_MODE_SIZE (DFmode), 0);\n   operands[5] = gen_reg_rtx (DFmode);\n   operands[6] = gen_reg_rtx (SImode);\n@@ -5320,7 +5320,7 @@\n   \"\n {\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n-  operands[3] = force_reg (DFmode, rs6000_float_const (\\\"4503599627370496\\\", DFmode));\n+  operands[3] = force_reg (DFmode, CONST_DOUBLE_ATOF (\\\"4503599627370496\\\", DFmode));\n   operands[4] = assign_stack_temp (DFmode, GET_MODE_SIZE (DFmode), 0);\n   operands[5] = gen_reg_rtx (DFmode);\n }\")"}, {"sha": "ad1b3c0c65e6d1530aefde6c393e8b7811ed72c3", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -1379,9 +1379,8 @@ sparc_emit_set_const32 (op0, op1)\n \t  && (INTVAL (op1) & 0x80000000) != 0)\n \temit_insn (gen_rtx_SET\n \t\t   (VOIDmode, temp,\n-\t\t    gen_rtx_CONST_DOUBLE (VOIDmode,\n-\t\t\t\t\t  INTVAL (op1) & ~(HOST_WIDE_INT)0x3ff,\n-\t\t\t\t\t  0)));\n+\t\t    immed_double_const (INTVAL (op1) & ~(HOST_WIDE_INT)0x3ff,\n+\t\t\t\t\t0, DImode)));\n       else\n \temit_insn (gen_rtx_SET (VOIDmode, temp,\n \t\t\t\tGEN_INT (INTVAL (op1)\n@@ -1559,11 +1558,10 @@ static rtx gen_safe_XOR64 PARAMS ((rtx, HOST_WIDE_INT));\n #define GEN_INT64(__x)\t\t\tGEN_INT (__x)\n #else\n #define GEN_HIGHINT64(__x) \\\n-\tgen_rtx_CONST_DOUBLE (VOIDmode, (__x) & ~(HOST_WIDE_INT)0x3ff, 0)\n+\timmed_double_const ((__x) & ~(HOST_WIDE_INT)0x3ff, 0, DImode)\n #define GEN_INT64(__x) \\\n-\tgen_rtx_CONST_DOUBLE (VOIDmode, (__x) & 0xffffffff, \\\n-\t\t\t      ((__x) & 0x80000000 \\\n-\t\t\t       ? -1 : 0))\n+\timmed_double_const ((__x) & 0xffffffff, \\\n+\t\t\t    ((__x) & 0x80000000 ? -1 : 0), DImode)\n #endif\n \n /* The optimizer is not to assume anything about exactly\n@@ -2133,9 +2131,9 @@ sparc_emit_set_const64 (op0, op1)\n \t  negated_const = GEN_INT (((~low_bits) & 0xfffffc00) |\n \t\t\t\t   (((HOST_WIDE_INT)((~high_bits) & 0xffffffff))<<32));\n #else\n-\t  negated_const = gen_rtx_CONST_DOUBLE (DImode,\n-\t\t\t\t\t\t(~low_bits) & 0xfffffc00,\n-\t\t\t\t\t\t(~high_bits) & 0xffffffff);\n+\t  negated_const = immed_double_const ((~low_bits) & 0xfffffc00,\n+\t\t\t\t\t      (~high_bits) & 0xffffffff,\n+\t\t\t\t\t      DImode);\n #endif\n \t  sparc_emit_set_const64 (temp, negated_const);\n \t}"}, {"sha": "34ec9de765fea4573456477b2aa1e65857327ad8", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -3158,7 +3158,7 @@\n       emit_insn (gen_movdi (operands[0], GEN_INT (val)));\n #else\n       emit_insn (gen_movdi (operands[0],\n-                            gen_rtx_CONST_DOUBLE (VOIDmode, l[1], l[0])));\n+                            immed_double_const (l[1], l[0], DImode)));\n #endif\n     }\n   else"}, {"sha": "2e86dff09a4bdbfd5f4bc9c4e014ce8e95d406be", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 170, "deletions": 36, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -87,8 +87,8 @@ static int no_line_numbers;\n \n /* Commonly used rtx's, so that we only need space for one copy.\n    These are initialized once for the entire compilation.\n-   All of these except perhaps the floating-point CONST_DOUBLEs\n-   are unique; no other rtx-object will be equal to any of these.  */\n+   All of these are unique; no other rtx-object will be equal to any\n+   of these.  */\n \n rtx global_rtl[GR_MAX];\n \n@@ -148,6 +148,9 @@ static htab_t const_int_htab;\n /* A hash table storing memory attribute structures.  */\n static htab_t mem_attrs_htab;\n \n+/* A hash table storing all CONST_DOUBLEs.  */\n+static htab_t const_double_htab;\n+\n /* start_sequence and gen_sequence can make a lot of rtx expressions which are\n    shortly thrown away.  We use two mechanisms to prevent this waste:\n \n@@ -188,6 +191,10 @@ static void mark_label_nuses\t\tPARAMS ((rtx));\n static hashval_t const_int_htab_hash    PARAMS ((const void *));\n static int const_int_htab_eq            PARAMS ((const void *,\n \t\t\t\t\t\t const void *));\n+static hashval_t const_double_htab_hash PARAMS ((const void *));\n+static int const_double_htab_eq\t\tPARAMS ((const void *,\n+\t\t\t\t\t\t const void *));\n+static rtx lookup_const_double\t\tPARAMS ((rtx));\n static hashval_t mem_attrs_htab_hash    PARAMS ((const void *));\n static int mem_attrs_htab_eq            PARAMS ((const void *,\n \t\t\t\t\t\t const void *));\n@@ -208,7 +215,7 @@ static hashval_t\n const_int_htab_hash (x)\n      const void *x;\n {\n-  return (hashval_t) INTVAL ((const struct rtx_def *) x);\n+  return (hashval_t) INTVAL ((struct rtx_def *) x);\n }\n \n /* Returns non-zero if the value represented by X (which is really a\n@@ -220,7 +227,40 @@ const_int_htab_eq (x, y)\n      const void *x;\n      const void *y;\n {\n-  return (INTVAL ((const struct rtx_def *) x) == *((const HOST_WIDE_INT *) y));\n+  return (INTVAL ((rtx) x) == *((const HOST_WIDE_INT *) y));\n+}\n+\n+/* Returns a hash code for X (which is really a CONST_DOUBLE).  */\n+static hashval_t\n+const_double_htab_hash (x)\n+     const void *x;\n+{\n+  hashval_t h = 0;\n+  size_t i;\n+  rtx value = (rtx) x;\n+\n+  for (i = 0; i < sizeof(CONST_DOUBLE_FORMAT)-1; i++)\n+    h ^= XWINT (value, i);\n+  return h;\n+}\n+\n+/* Returns non-zero if the value represented by X (really a ...)\n+   is the same as that represented by Y (really a ...) */\n+static int\n+const_double_htab_eq (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  rtx a = (rtx)x, b = (rtx)y;\n+  size_t i;\n+\n+  if (GET_MODE (a) != GET_MODE (b))\n+    return 0;\n+  for (i = 0; i < sizeof(CONST_DOUBLE_FORMAT)-1; i++)\n+    if (XWINT (a, i) != XWINT (b, i))\n+      return 0;\n+\n+  return 1;\n }\n \n /* Returns a hash code for X (which is a really a mem_attrs *).  */\n@@ -363,32 +403,130 @@ gen_int_mode (c, mode)\n   return GEN_INT (trunc_int_for_mode (c, mode));\n }\n \n-/* CONST_DOUBLEs needs special handling because their length is known\n-   only at run-time.  */\n+/* CONST_DOUBLEs might be created from pairs of integers, or from\n+   REAL_VALUE_TYPEs.  Also, their length is known only at run time,\n+   so we cannot use gen_rtx_raw_CONST_DOUBLE.  */\n+\n+/* Determine whether REAL, a CONST_DOUBLE, already exists in the\n+   hash table.  If so, return its counterpart; otherwise add it\n+   to the hash table and return it.  */\n+static rtx\n+lookup_const_double (real)\n+     rtx real;\n+{\n+  void **slot = htab_find_slot (const_double_htab, real, INSERT);\n+  if (*slot == 0)\n+    *slot = real;\n+\n+  return (rtx) *slot;\n+}\n \n+/* Return a CONST_DOUBLE rtx for a floating-point value specified by\n+   VALUE in mode MODE.  */\n rtx\n-gen_rtx_CONST_DOUBLE (mode, arg0, arg1)\n+const_double_from_real_value (value, mode)\n+     REAL_VALUE_TYPE value;\n      enum machine_mode mode;\n-     HOST_WIDE_INT arg0, arg1;\n {\n-  rtx r = rtx_alloc (CONST_DOUBLE);\n-  int i;\n+  rtx real = rtx_alloc (CONST_DOUBLE);\n+  PUT_MODE (real, mode);\n+\n+  memcpy (&CONST_DOUBLE_LOW (real), &value, sizeof (REAL_VALUE_TYPE));\n+\n+  return lookup_const_double (real);\n+}\n+\n+/* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair\n+   of ints: I0 is the low-order word and I1 is the high-order word.\n+   Do not use this routine for non-integer modes; convert to\n+   REAL_VALUE_TYPE and use CONST_DOUBLE_FROM_REAL_VALUE.  */\n+\n+rtx\n+immed_double_const (i0, i1, mode)\n+     HOST_WIDE_INT i0, i1;\n+     enum machine_mode mode;\n+{\n+  rtx value;\n+  unsigned int i;\n+\n+  if (mode != VOIDmode)\n+    {\n+      int width;\n+      if (GET_MODE_CLASS (mode) != MODE_INT\n+\t  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n+\tabort ();\n+\n+      /* We clear out all bits that don't belong in MODE, unless they and\n+\t our sign bit are all one.  So we get either a reasonable negative\n+\t value or a reasonable unsigned value for this mode.  */\n+      width = GET_MODE_BITSIZE (mode);\n+      if (width < HOST_BITS_PER_WIDE_INT\n+\t  && ((i0 & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+\ti0 &= ((HOST_WIDE_INT) 1 << width) - 1, i1 = 0;\n+      else if (width == HOST_BITS_PER_WIDE_INT\n+\t       && ! (i1 == ~0 && i0 < 0))\n+\ti1 = 0;\n+      else if (width > 2 * HOST_BITS_PER_WIDE_INT)\n+\t/* We cannot represent this value as a constant.  */\n+\tabort ();\n+\n+      /* If this would be an entire word for the target, but is not for\n+\t the host, then sign-extend on the host so that the number will\n+\t look the same way on the host that it would on the target.\n+\n+\t For example, when building a 64 bit alpha hosted 32 bit sparc\n+\t targeted compiler, then we want the 32 bit unsigned value -1 to be\n+\t represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n+\t The latter confuses the sparc backend.  */\n+\n+      if (width < HOST_BITS_PER_WIDE_INT\n+\t  && (i0 & ((HOST_WIDE_INT) 1 << (width - 1))))\n+\ti0 |= ((HOST_WIDE_INT) (-1) << width);\n \n-  PUT_MODE (r, mode);\n-  X0EXP (r, 0) = NULL_RTX;\n-  XWINT (r, 1) = arg0;\n-  XWINT (r, 2) = arg1;\n+      /* If MODE fits within HOST_BITS_PER_WIDE_INT, always use a\n+\t CONST_INT.\n \n-  for (i = GET_RTX_LENGTH (CONST_DOUBLE) - 1; i > 2; --i)\n-    XWINT (r, i) = 0;\n+\t ??? Strictly speaking, this is wrong if we create a CONST_INT for\n+\t a large unsigned constant with the size of MODE being\n+\t HOST_BITS_PER_WIDE_INT and later try to interpret that constant\n+\t in a wider mode.  In that case we will mis-interpret it as a\n+\t negative number.\n \n-  return r;\n+\t Unfortunately, the only alternative is to make a CONST_DOUBLE for\n+\t any constant in any mode if it is an unsigned constant larger\n+\t than the maximum signed integer in an int on the host.  However,\n+\t doing this will break everyone that always expects to see a\n+\t CONST_INT for SImode and smaller.\n+\n+\t We have always been making CONST_INTs in this case, so nothing\n+\t new is being broken.  */\n+\n+      if (width <= HOST_BITS_PER_WIDE_INT)\n+\ti1 = (i0 < 0) ? ~(HOST_WIDE_INT) 0 : 0;\n+    }\n+\n+  /* If this integer fits in one word, return a CONST_INT.  */\n+  if ((i1 == 0 && i0 >= 0) || (i1 == ~0 && i0 < 0))\n+    return GEN_INT (i0);\n+\n+  /* We use VOIDmode for integers.  */\n+  value = rtx_alloc (CONST_DOUBLE);\n+  PUT_MODE (value, VOIDmode);\n+\n+  CONST_DOUBLE_LOW (value) = i0;\n+  CONST_DOUBLE_HIGH (value) = i1;\n+\n+  for (i = 2; i < (sizeof CONST_DOUBLE_FORMAT - 1); i++)\n+    XWINT (value, i) = 0;\n+\n+  return lookup_const_double (value);\n }\n \n rtx\n gen_rtx_REG (mode, regno)\n      enum machine_mode mode;\n-     int regno;\n+     unsigned int regno;\n {\n   /* In case the MD file explicitly references the frame pointer, have\n      all such references point to the same frame pointer.  This is\n@@ -463,7 +601,7 @@ gen_rtx_SUBREG (mode, reg, offset)\n   if (offset >= GET_MODE_SIZE (GET_MODE (reg)))\n     abort ();\n #endif\n-  return gen_rtx_fmt_ei (SUBREG, mode, reg, offset);\n+  return gen_rtx_raw_SUBREG (mode, reg, offset);\n }\n \n /* Generate a SUBREG representing the least-significant part of REG if MODE\n@@ -532,7 +670,7 @@ gen_rtx VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n \tHOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n \tHOST_WIDE_INT arg1 = va_arg (p, HOST_WIDE_INT);\n \n-\trt_val = gen_rtx_CONST_DOUBLE (mode, arg0, arg1);\n+        rt_val = immed_double_const (arg0, arg1, mode);\n       }\n       break;\n \n@@ -4849,11 +4987,16 @@ init_emit_once (line_numbers)\n   enum machine_mode mode;\n   enum machine_mode double_mode;\n \n-  /* Initialize the CONST_INT and memory attribute hash tables.  */\n+  /* Initialize the CONST_INT, CONST_DOUBLE, and memory attribute hash\n+     tables.  */\n   const_int_htab = htab_create (37, const_int_htab_hash,\n \t\t\t\tconst_int_htab_eq, NULL);\n   ggc_add_deletable_htab (const_int_htab, 0, 0);\n \n+  const_double_htab = htab_create (37, const_double_htab_hash,\n+\t\t\t\t   const_double_htab_eq, NULL);\n+  ggc_add_deletable_htab (const_double_htab, 0, 0);\n+\n   mem_attrs_htab = htab_create (37, mem_attrs_htab_hash,\n \t\t\t\tmem_attrs_htab_eq, NULL);\n   ggc_add_deletable_htab (mem_attrs_htab, 0, mem_attrs_mark);\n@@ -4937,10 +5080,10 @@ init_emit_once (line_numbers)\n   else\n     const_true_rtx = gen_rtx_CONST_INT (VOIDmode, STORE_FLAG_VALUE);\n \n-  dconst0 = REAL_VALUE_ATOF (\"0\", double_mode);\n-  dconst1 = REAL_VALUE_ATOF (\"1\", double_mode);\n-  dconst2 = REAL_VALUE_ATOF (\"2\", double_mode);\n-  dconstm1 = REAL_VALUE_ATOF (\"-1\", double_mode);\n+  REAL_VALUE_FROM_INT (dconst0,   0,  0, double_mode);\n+  REAL_VALUE_FROM_INT (dconst1,   1,  0, double_mode);\n+  REAL_VALUE_FROM_INT (dconst2,   2,  0, double_mode);\n+  REAL_VALUE_FROM_INT (dconstm1, -1, -1, double_mode);\n \n   for (i = 0; i <= 2; i++)\n     {\n@@ -4949,17 +5092,8 @@ init_emit_once (line_numbers)\n \n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n \t   mode = GET_MODE_WIDER_MODE (mode))\n-\t{\n-\t  rtx tem = rtx_alloc (CONST_DOUBLE);\n-\n-\t  /* Can't use CONST_DOUBLE_FROM_REAL_VALUE here; that uses the\n-\t     tables we're setting up right now.  */\n-\t  memcpy (&CONST_DOUBLE_LOW (tem), r, sizeof (REAL_VALUE_TYPE));\n-\t  CONST_DOUBLE_CHAIN (tem) = NULL_RTX;\n-\t  PUT_MODE (tem, mode);\n-\n-\t  const_tiny_rtx[i][(int) mode] = tem;\n-\t}\n+\tconst_tiny_rtx[i][(int) mode] =\n+\t  CONST_DOUBLE_FROM_REAL_VALUE (*r, mode);\n \n       const_tiny_rtx[i][(int) VOIDmode] = GEN_INT (i);\n "}, {"sha": "c40a6dfeed64d58b55c760b1cef85ddcd23cd922", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -6486,7 +6486,8 @@ expand_expr (exp, target, tmode, modifier)\n \t many insns, so we'd end up copying it to a register in any case.\n \n \t Now, we do the copying in expand_binop, if appropriate.  */\n-      return immed_real_const (exp);\n+      return CONST_DOUBLE_FROM_REAL_VALUE (TREE_REAL_CST (exp),\n+\t\t\t\t\t   TYPE_MODE (TREE_TYPE (exp)));\n \n     case COMPLEX_CST:\n     case STRING_CST:"}, {"sha": "3da601b141b8602a4fdbb55e7262cb7b0bc2272b", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -132,21 +132,31 @@ special_format (fmt)\n \t  || strchr (fmt, 'n') != 0);\n }\n \n-/* Return nonzero if the RTL code given by index IDX is one that we should not\n-   generate a gen_RTX_FOO function foo (because that function is present\n-   elsewhere in the compiler).  */\n+/* Return nonzero if the RTL code given by index IDX is one that we should\n+   generate a gen_rtx_raw_FOO macro for, not gen_rtx_FOO (because gen_rtx_FOO\n+   is a wrapper in emit-rtl.c).  */\n \n static int\n special_rtx (idx)\n      int idx;\n {\n   return (strcmp (defs[idx].enumname, \"CONST_INT\") == 0\n-\t  || strcmp (defs[idx].enumname, \"CONST_DOUBLE\") == 0\n \t  || strcmp (defs[idx].enumname, \"REG\") == 0\n \t  || strcmp (defs[idx].enumname, \"SUBREG\") == 0\n \t  || strcmp (defs[idx].enumname, \"MEM\") == 0);\n }\n \n+/* Return nonzero if the RTL code given by index IDX is one that we should\n+   generate no macro for at all (because gen_rtx_FOO is never used or\n+   cannot have the obvious interface).  */\n+\n+static int\n+excluded_rtx (idx)\n+     int idx;\n+{\n+  return (strcmp (defs[idx].enumname, \"CONST_DOUBLE\") == 0);\n+}\n+\n /* Place a list of all format specifiers we use into the array FORMAT.  */\n \n static void\n@@ -213,6 +223,10 @@ genmacro (idx)\n   /* We write a macro that defines gen_rtx_RTLCODE to be an equivalent to\n      gen_rtx_fmt_FORMAT where FORMAT is the RTX_FORMAT of RTLCODE.  */\n \n+  if (excluded_rtx (idx))\n+    /* Don't define a macro for this code.  */\n+    return;\n+\n   printf (\"#define gen_rtx_%s%s(MODE\",\n \t   special_rtx (idx) ? \"raw_\" : \"\", defs[idx].enumname);\n "}, {"sha": "57c193d5036a7bd6aece6efaa34ec7f48a0181e3", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -347,9 +347,6 @@ ggc_mark_rtx_children_1 (r)\n \tcase ADDRESSOF:\n \t  ggc_mark_tree (ADDRESSOF_DECL (r));\n \t  break;\n-\tcase CONST_DOUBLE:\n-\t  ggc_mark_rtx (CONST_DOUBLE_CHAIN (r));\n-\t  break;\n \tcase NOTE:\n \t  switch (NOTE_LINE_NUMBER (r))\n \t    {"}, {"sha": "a33f15b2c16a2f205f3ad0e5708eb3aa97117088", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -357,11 +357,6 @@ extern void assemble_real\t\tPARAMS ((REAL_VALUE_TYPE,\n #endif\n #endif\n \n-/* At the end of a function, forget the memory-constants\n-   previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.\n-   Also clear out real_constant_chain and clear out all the chain-pointers.  */\n-extern void clear_const_double_mem\tPARAMS ((void));\n-\n /* Start deferring output of subconstants.  */\n extern void defer_addressed_constants\tPARAMS ((void));\n "}, {"sha": "3de905dfddfed8c20cd80c231979abff6182a5ab", "filename": "gcc/real.h", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -89,7 +89,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    + (REAL_VALUE_TYPE_SIZE%HOST_BITS_PER_WIDE_INT ? 1 : 0)) /* round up */\n typedef struct {\n   HOST_WIDE_INT r[REAL_WIDTH];\n-} REAL_VALUE_TYPE;\n+} realvaluetype;\n+/* Various headers condition prototypes on #ifdef REAL_VALUE_TYPE, so it needs\n+   to be a macro.  */\n+#define REAL_VALUE_TYPE realvaluetype\n \n /* Calculate the format for CONST_DOUBLE.  We need as many slots as\n    are necessary to overlay a REAL_VALUE_TYPE on them.  This could be\n@@ -99,19 +102,19 @@ typedef struct {\n    slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n \n #if REAL_WIDTH == 1\n-# define CONST_DOUBLE_FORMAT\t \"0ww\"\n+# define CONST_DOUBLE_FORMAT\t \"ww\"\n #else\n # if REAL_WIDTH == 2\n-#  define CONST_DOUBLE_FORMAT\t \"0ww\"\n+#  define CONST_DOUBLE_FORMAT\t \"ww\"\n # else\n #  if REAL_WIDTH == 3\n-#   define CONST_DOUBLE_FORMAT\t \"0www\"\n+#   define CONST_DOUBLE_FORMAT\t \"www\"\n #  else\n #   if REAL_WIDTH == 4\n-#    define CONST_DOUBLE_FORMAT\t \"0wwww\"\n+#    define CONST_DOUBLE_FORMAT\t \"wwww\"\n #   else\n #    if REAL_WIDTH == 5\n-#     define CONST_DOUBLE_FORMAT \"0wwwww\"\n+#     define CONST_DOUBLE_FORMAT \"wwwww\"\n #    else\n       #error \"REAL_WIDTH > 5 not supported\"\n #    endif\n@@ -265,9 +268,14 @@ REAL_VALUE_TYPE real_value_from_int_cst\tPARAMS ((union tree_node *,\n \n /* Return a CONST_DOUBLE with value R and mode M.  */\n \n-#define CONST_DOUBLE_FROM_REAL_VALUE(r, m) immed_real_const_1 (r,  m)\n-extern struct rtx_def *immed_real_const_1\tPARAMS ((REAL_VALUE_TYPE,\n-\t\t\t\t\t\t       enum machine_mode));\n+#define CONST_DOUBLE_FROM_REAL_VALUE(r, m) \\\n+  const_double_from_real_value (r, m)\n+extern rtx const_double_from_real_value PARAMS ((REAL_VALUE_TYPE,\n+\t\t\t\t\t\t enum machine_mode));\n+\n+/* Shorthand; can be handy in machine descriptions.  */\n+#define CONST_DOUBLE_ATOF(s, m) \\\n+  CONST_DOUBLE_FROM_REAL_VALUE (REAL_VALUE_ATOF (s, m), m)\n \n /* Replace R by 1/R in the given machine mode, if the result is exact.  */\n extern int exact_real_inverse\tPARAMS ((enum machine_mode, REAL_VALUE_TYPE *));"}, {"sha": "ebcbd4482d0eceda60567392cdf6adaf780f575c", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -946,11 +946,8 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n    For a float, the number of ints varies,\n     and CONST_DOUBLE_LOW is the one that should come first *in memory*.\n     So use &CONST_DOUBLE_LOW(r) as the address of an array of ints.  */\n-#define CONST_DOUBLE_LOW(r) XCWINT (r, 1, CONST_DOUBLE)\n-#define CONST_DOUBLE_HIGH(r) XCWINT (r, 2, CONST_DOUBLE)\n-\n-/* Link for chain of all CONST_DOUBLEs in use in current function.  */\n-#define CONST_DOUBLE_CHAIN(r) XCEXP (r, 0, CONST_DOUBLE)\n+#define CONST_DOUBLE_LOW(r) XCWINT (r, 0, CONST_DOUBLE)\n+#define CONST_DOUBLE_HIGH(r) XCWINT (r, 1, CONST_DOUBLE)\n \n /* For a CONST_VECTOR, return element #n.  */\n #define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n@@ -1802,11 +1799,9 @@ extern rtx return_address_pointer_rtx;\n    add to this list, modify special_rtx in gengenrtl.c as well.  You\n    should also modify gen_rtx to use the special function.  */\n \n-extern rtx gen_rtx_CONST_DOUBLE PARAMS ((enum machine_mode,\n-\t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\n extern rtx gen_rtx_CONST_INT PARAMS ((enum machine_mode, HOST_WIDE_INT));\n extern rtx gen_raw_REG PARAMS ((enum machine_mode, int));\n-extern rtx gen_rtx_REG PARAMS ((enum machine_mode, int));\n+extern rtx gen_rtx_REG PARAMS ((enum machine_mode, unsigned));\n extern rtx gen_rtx_SUBREG PARAMS ((enum machine_mode, rtx, int));\n extern rtx gen_rtx_MEM PARAMS ((enum machine_mode, rtx));\n \n@@ -1883,7 +1878,6 @@ extern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n extern rtx find_next_ref\t\tPARAMS ((rtx, rtx));\n \n extern rtx output_constant_def\t\tPARAMS ((tree, int));\n-extern rtx immed_real_const\t\tPARAMS ((tree));\n \n /* Define a default value for STORE_FLAG_VALUE.  */\n "}, {"sha": "9213730f62932b94f233b3974e90cb7b758cafa4", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -3491,10 +3491,6 @@ rest_of_compilation (decl)\n      longer valid.  */\n   init_insn_lengths ();\n \n-  /* Clear out the real_constant_chain before some of the rtx's\n-     it runs through become garbage.  */\n-  clear_const_double_mem ();\n-\n   /* Show no temporary slots allocated.  */\n   init_temp_slots ();\n "}, {"sha": "1d9522e7546a8acb32a8b644a8a9198ecd9bb319", "filename": "gcc/varasm.c", "status": "modified", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5692c7bc60a884946e782bb9c1fe72e919301557/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5692c7bc60a884946e782bb9c1fe72e919301557", "patch": "@@ -95,18 +95,13 @@ struct varasm_status\n   /* Current offset in constant pool (does not include any machine-specific\n      header).  */\n   HOST_WIDE_INT x_pool_offset;\n-\n-  /* Chain of all CONST_DOUBLE rtx's constructed for the current function.\n-     They are chained through the CONST_DOUBLE_CHAIN.  */\n-  rtx x_const_double_chain;\n };\n \n #define const_rtx_hash_table (cfun->varasm->x_const_rtx_hash_table)\n #define const_rtx_sym_hash_table (cfun->varasm->x_const_rtx_sym_hash_table)\n #define first_pool (cfun->varasm->x_first_pool)\n #define last_pool (cfun->varasm->x_last_pool)\n #define pool_offset (cfun->varasm->x_pool_offset)\n-#define const_double_chain (cfun->varasm->x_const_double_chain)\n \n /* Number for making the label on the next\n    constant that is stored in memory.  */\n@@ -2104,190 +2099,6 @@ assemble_real (d, mode, align)\n     }\n }\n \f\n-/* Here we combine duplicate floating constants to make\n-   CONST_DOUBLE rtx's, and force those out to memory when necessary.  */\n-\n-/* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair of ints.\n-   For an integer, I0 is the low-order word and I1 is the high-order word.\n-   For a real number, I0 is the word with the low address\n-   and I1 is the word with the high address.  */\n-\n-rtx\n-immed_double_const (i0, i1, mode)\n-     HOST_WIDE_INT i0, i1;\n-     enum machine_mode mode;\n-{\n-  rtx r;\n-\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n-    {\n-      /* We clear out all bits that don't belong in MODE, unless they and our\n-\t sign bit are all one.  So we get either a reasonable negative value\n-\t or a reasonable unsigned value for this mode.  */\n-      int width = GET_MODE_BITSIZE (mode);\n-      if (width < HOST_BITS_PER_WIDE_INT\n-\t  && ((i0 & ((HOST_WIDE_INT) (-1) << (width - 1)))\n-\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n-\ti0 &= ((HOST_WIDE_INT) 1 << width) - 1, i1 = 0;\n-      else if (width == HOST_BITS_PER_WIDE_INT\n-\t       && ! (i1 == ~0 && i0 < 0))\n-\ti1 = 0;\n-      else if (width > 2 * HOST_BITS_PER_WIDE_INT)\n-\t/* We cannot represent this value as a constant.  */\n-\tabort ();\n-\n-      /* If this would be an entire word for the target, but is not for\n-\t the host, then sign-extend on the host so that the number will look\n-\t the same way on the host that it would on the target.\n-\n-\t For example, when building a 64 bit alpha hosted 32 bit sparc\n-\t targeted compiler, then we want the 32 bit unsigned value -1 to be\n-\t represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n-\t The later confuses the sparc backend.  */\n-\n-      if (width < HOST_BITS_PER_WIDE_INT\n-\t  && (i0 & ((HOST_WIDE_INT) 1 << (width - 1))))\n-\ti0 |= ((HOST_WIDE_INT) (-1) << width);\n-\n-      /* If MODE fits within HOST_BITS_PER_WIDE_INT, always use a CONST_INT.\n-\n-\t ??? Strictly speaking, this is wrong if we create a CONST_INT\n-\t for a large unsigned constant with the size of MODE being\n-\t HOST_BITS_PER_WIDE_INT and later try to interpret that constant in a\n-\t wider mode.  In that case we will mis-interpret it as a negative\n-\t number.\n-\n-\t Unfortunately, the only alternative is to make a CONST_DOUBLE\n-\t for any constant in any mode if it is an unsigned constant larger\n-\t than the maximum signed integer in an int on the host.  However,\n-\t doing this will break everyone that always expects to see a CONST_INT\n-\t for SImode and smaller.\n-\n-\t We have always been making CONST_INTs in this case, so nothing new\n-\t is being broken.  */\n-\n-      if (width <= HOST_BITS_PER_WIDE_INT)\n-\ti1 = (i0 < 0) ? ~(HOST_WIDE_INT) 0 : 0;\n-\n-      /* If this integer fits in one word, return a CONST_INT.  */\n-      if ((i1 == 0 && i0 >= 0)\n-\t  || (i1 == ~0 && i0 < 0))\n-\treturn GEN_INT (i0);\n-\n-      /* We use VOIDmode for integers.  */\n-      mode = VOIDmode;\n-    }\n-\n-  /* Search the chain for an existing CONST_DOUBLE with the right value.\n-     If one is found, return it.  */\n-  if (cfun != 0)\n-    for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n-      if (CONST_DOUBLE_LOW (r) == i0 && CONST_DOUBLE_HIGH (r) == i1\n-\t  && GET_MODE (r) == mode)\n-\treturn r;\n-\n-  /* No; make a new one and add it to the chain.  */\n-  r = gen_rtx_CONST_DOUBLE (mode, i0, i1);\n-\n-  /* Don't touch const_double_chain if not inside any function.  */\n-  if (current_function_decl != 0)\n-    {\n-      CONST_DOUBLE_CHAIN (r) = const_double_chain;\n-      const_double_chain = r;\n-    }\n-\n-  return r;\n-}\n-\n-/* Return a CONST_DOUBLE for a specified `double' value\n-   and machine mode.  */\n-\n-rtx\n-immed_real_const_1 (d, mode)\n-     REAL_VALUE_TYPE d;\n-     enum machine_mode mode;\n-{\n-  rtx r;\n-\n-  /* Detect special cases.  Check for NaN first, because some ports\n-     (specifically the i386) do not emit correct ieee-fp code by default, and\n-     thus will generate a core dump here if we pass a NaN to REAL_VALUES_EQUAL\n-     and if REAL_VALUES_EQUAL does a floating point comparison.  */\n-  if (! REAL_VALUE_ISNAN (d) && REAL_VALUES_IDENTICAL (dconst0, d))\n-    return CONST0_RTX (mode);\n-  else if (! REAL_VALUE_ISNAN (d) && REAL_VALUES_EQUAL (dconst1, d))\n-    return CONST1_RTX (mode);\n-  else if (! REAL_VALUE_ISNAN (d) && REAL_VALUES_EQUAL (dconst2, d))\n-    return CONST2_RTX (mode);\n-\n-  if (sizeof (REAL_VALUE_TYPE) == sizeof (HOST_WIDE_INT))\n-    return immed_double_const (d.r[0], 0, mode);\n-  if (sizeof (REAL_VALUE_TYPE) == 2 * sizeof (HOST_WIDE_INT))\n-    return immed_double_const (d.r[0], d.r[1], mode);\n-\n-  /* The rest of this function handles the case where\n-     a float value requires more than 2 ints of space.\n-     It will be deleted as dead code on machines that don't need it.  */\n-\n-  /* Search the chain for an existing CONST_DOUBLE with the right value.\n-     If one is found, return it.  */\n-  if (cfun != 0)\n-    for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n-      if (! memcmp ((char *) &CONST_DOUBLE_LOW (r), (char *) &d, sizeof d)\n-\t  && GET_MODE (r) == mode)\n-\treturn r;\n-\n-  /* No; make a new one and add it to the chain.\n-\n-     We may be called by an optimizer which may be discarding any memory\n-     allocated during its processing (such as combine and loop).  However,\n-     we will be leaving this constant on the chain, so we cannot tolerate\n-     freed memory.  */\n-  r = rtx_alloc (CONST_DOUBLE);\n-  PUT_MODE (r, mode);\n-  memcpy ((char *) &CONST_DOUBLE_LOW (r), (char *) &d, sizeof d);\n-\n-  /* If we aren't inside a function, don't put r on the\n-     const_double_chain.  */\n-  if (current_function_decl != 0)\n-    {\n-      CONST_DOUBLE_CHAIN (r) = const_double_chain;\n-      const_double_chain = r;\n-    }\n-  else\n-    CONST_DOUBLE_CHAIN (r) = NULL_RTX;\n-\n-  return r;\n-}\n-\n-/* Return a CONST_DOUBLE rtx for a value specified by EXP,\n-   which must be a REAL_CST tree node.  */\n-\n-rtx\n-immed_real_const (exp)\n-     tree exp;\n-{\n-  return immed_real_const_1 (TREE_REAL_CST (exp), TYPE_MODE (TREE_TYPE (exp)));\n-}\n-\n-/* At the end of a function, forget the memory-constants\n-   previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.\n-   Also clear out real_constant_chain and clear out all the chain-pointers.  */\n-\n-void\n-clear_const_double_mem ()\n-{\n-  rtx r, next;\n-\n-  for (r = const_double_chain; r; r = next)\n-    {\n-      next = CONST_DOUBLE_CHAIN (r);\n-      CONST_DOUBLE_CHAIN (r) = 0;\n-    }\n-  const_double_chain = 0;\n-}\n-\f\n /* Given an expression EXP with a constant value,\n    reduce it to the sum of an assembler symbol and an integer.\n    Store them both in the structure *VALUE.\n@@ -3470,7 +3281,6 @@ init_varasm_status (f)\n \n   p->x_first_pool = p->x_last_pool = 0;\n   p->x_pool_offset = 0;\n-  p->x_const_double_chain = 0;\n }\n \n /* Mark PC for GC.  */\n@@ -3498,7 +3308,6 @@ mark_varasm_status (p)\n     return;\n \n   mark_pool_constant (p->x_first_pool);\n-  ggc_mark_rtx (p->x_const_double_chain);\n }\n \n /* Clear out all parts of the state in F that can safely be discarded"}]}