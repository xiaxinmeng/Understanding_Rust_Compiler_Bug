{"sha": "35c78c6fc54721e067ed3a30ddd9184b45c5981d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVjNzhjNmZjNTQ3MjFlMDY3ZWQzYTMwZGRkOTE4NGI0NWM1OTgxZA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T18:41:16Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T23:28:04Z"}, "message": "Tweak location of non-null calls. revamp ranger debug output.\n\nrange_on_entry shouldnt be checking non-null, but we sometimes should\nafter calling it.\nchange the debug output a bit.\n\n\t* gimple-range.cc (gimple_ranger::range_of_expr): Non-null should be\n\tchecked only after range_of_stmt, not range_on_entry.\n\t(gimple_ranger::range_on_entry): Check for non-null in any\n\tpredecessor block, if it is not already non-null.\n\t(gimple_ranger::range_on_exit): DOnt check for non-null after\n\trange on entry call.\n\t(gimple_ranger::dump_bb): New.  Split from dump.\n\t(gimple_ranger::dump): Adjust.\n\t* gimple-range.h (class gimple_ranger): Adjust.", "tree": {"sha": "be9a19330dd956397a447d9aa71f7fa1b3baf159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be9a19330dd956397a447d9aa71f7fa1b3baf159"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35c78c6fc54721e067ed3a30ddd9184b45c5981d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c78c6fc54721e067ed3a30ddd9184b45c5981d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c78c6fc54721e067ed3a30ddd9184b45c5981d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c78c6fc54721e067ed3a30ddd9184b45c5981d/comments", "author": null, "committer": null, "parents": [{"sha": "10b286ce335cca135a45a92581b28146f3e3209b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b286ce335cca135a45a92581b28146f3e3209b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b286ce335cca135a45a92581b28146f3e3209b"}], "stats": {"total": 150, "additions": 74, "deletions": 76}, "files": [{"sha": "593ddb1c3f8984c23863bd3d2f969c24263c28f1", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35c78c6fc54721e067ed3a30ddd9184b45c5981d/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35c78c6fc54721e067ed3a30ddd9184b45c5981d/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=35c78c6fc54721e067ed3a30ddd9184b45c5981d", "patch": "@@ -976,23 +976,16 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n \n   // If name is defined in this block, try to get an range from S.\n   if (def_stmt && gimple_bb (def_stmt) == bb)\n-    range_of_stmt (r, def_stmt, expr);\n+    {\n+      range_of_stmt (r, def_stmt, expr);\n+      if (!cfun->can_throw_non_call_exceptions && r.varying_p () &&\n+\t  m_cache.m_non_null.non_null_deref_p (expr, bb))\n+\tr = range_nonzero (TREE_TYPE (expr));\n+    }\n   else\n     // Otherwise OP comes from outside this block, use range on entry.\n     range_on_entry (r, bb, expr);\n \n-  // No range yet, see if there is a dereference in the block.\n-  // We don't care if it's between the def and a use within a block\n-  // because the entire block must be executed anyway.\n-  // FIXME:?? For non-call exceptions we could have a statement throw\n-  // which causes an early block exit.\n-  // in which case we may need to walk from S back to the def/top of block\n-  // to make sure the deref happens between S and there before claiming\n-  // there is a deref.   Punt for now.\n-  if (!cfun->can_throw_non_call_exceptions && r.varying_p () &&\n-      m_cache.m_non_null.non_null_deref_p (expr, bb))\n-    r = range_nonzero (TREE_TYPE (expr));\n-\n   return true;\n }\n \n@@ -1010,6 +1003,10 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n   // Now see if there is any on_entry value which may refine it.\n   if (m_cache.block_range (entry_range, bb, name))\n     r.intersect (entry_range);\n+\n+  if (!cfun->can_throw_non_call_exceptions && r.varying_p () &&\n+      m_cache.m_non_null.non_null_deref_p (name, bb))\n+    r = range_nonzero (TREE_TYPE (name));\n }\n \n // Calculate the range for NAME at the end of block BB and return it in R.\n@@ -1032,13 +1029,7 @@ gimple_ranger::range_on_exit (irange &r, basic_block bb, tree name)\n   if (s)\n     range_of_expr (r, name, s);\n   else\n-    {\n-      range_on_entry (r, bb, name);\n-      // See if there was a deref in this block, if applicable\n-      if (!cfun->can_throw_non_call_exceptions && r.varying_p () &&\n-\t  m_cache.m_non_null.non_null_deref_p (name, bb))\n-\tr = range_nonzero (TREE_TYPE (name));\n-    }\n+    range_on_entry (r, bb, name);\n   gcc_checking_assert (r.undefined_p ()\n \t\t       || range_compatible_p (r.type (), TREE_TYPE (name)));\n }\n@@ -1166,80 +1157,86 @@ gimple_ranger::export_global_ranges ()\n // Print the known table values to file F.\n \n void\n-gimple_ranger::dump (FILE *f)\n+gimple_ranger::dump_bb (FILE *f, basic_block bb)\n {\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      unsigned x;\n-      edge_iterator ei;\n-      edge e;\n-      int_range_max range;\n-      fprintf (f, \"\\n=========== BB %d ============\\n\", bb->index);\n-      m_cache.dump (f, bb);\n+  unsigned x;\n+  edge_iterator ei;\n+  edge e;\n+  int_range_max range;\n+  fprintf (f, \"\\n=========== BB %d ============\\n\", bb->index);\n+  m_cache.dump (f, bb);\n \n-      dump_bb (f, bb, 4, TDF_NONE);\n+  ::dump_bb (f, bb, 4, TDF_NONE);\n \n-      // Now find any globals defined in this block.\n-      for (x = 1; x < num_ssa_names; x++)\n+  // Now find any globals defined in this block.\n+  for (x = 1; x < num_ssa_names; x++)\n+    {\n+      tree name = ssa_name (x);\n+      if (gimple_range_ssa_p (name) && SSA_NAME_DEF_STMT (name) &&\n+\t  gimple_bb (SSA_NAME_DEF_STMT (name)) == bb &&\n+\t  m_cache.get_global_range (range, name))\n \t{\n-\t  tree name = ssa_name (x);\n-\t  if (gimple_range_ssa_p (name) && SSA_NAME_DEF_STMT (name) &&\n-\t      gimple_bb (SSA_NAME_DEF_STMT (name)) == bb &&\n-\t      m_cache.get_global_range (range, name))\n+\t  if (!range.varying_p ())\n \t    {\n-\t      if (!range.varying_p ())\n-\t       {\n-\t\t print_generic_expr (f, name, TDF_SLIM);\n-\t\t fprintf (f, \" : \");\n-\t\t range.dump (f);\n-\t\t fprintf (f, \"\\n\");\n-\t       }\n-\n+\t      print_generic_expr (f, name, TDF_SLIM);\n+\t      fprintf (f, \" : \");\n+\t      range.dump (f);\n+\t      fprintf (f, \"\\n\");\n \t    }\n+\n \t}\n+    }\n \n-      // And now outgoing edges, if they define anything.\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n+  // And now outgoing edges, if they define anything.\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      for (x = 1; x < num_ssa_names; x++)\n \t{\n-\t  for (x = 1; x < num_ssa_names; x++)\n+\t  tree name = gimple_range_ssa_p (ssa_name (x));\n+\t  if (name && m_cache.outgoing_edge_range_p (range, e, name))\n \t    {\n-\t      tree name = gimple_range_ssa_p (ssa_name (x));\n-\t      if (name && m_cache.outgoing_edge_range_p (range, e, name))\n+\t      gimple *s = SSA_NAME_DEF_STMT (name);\n+\t      // Only print the range if this is the def block, or\n+\t      // the on entry cache for either end of the edge is\n+\t      // set.\n+\t      if ((s && bb == gimple_bb (s)) ||\n+\t\t  m_cache.block_range (range, bb, name, false) ||\n+\t\t  m_cache.block_range (range, e->dest, name, false))\n \t\t{\n-\t\t  gimple *s = SSA_NAME_DEF_STMT (name);\n-\t\t  // Only print the range if this is the def block, or\n-\t\t  // the on entry cache for either end of the edge is\n-\t\t  // set.\n-\t\t  if ((s && bb == gimple_bb (s)) ||\n-\t\t      m_cache.block_range (range, bb, name, false) ||\n-\t\t      m_cache.block_range (range, e->dest, name, false))\n+\t\t  range_on_edge (range, e, name);\n+\t\t  if (!range.varying_p ())\n \t\t    {\n-\t\t      range_on_edge (range, e, name);\n-\t\t      if (!range.varying_p ())\n-\t\t\t{\n-\t\t\t  fprintf (f, \"%d->%d \", e->src->index,\n-\t\t\t\t   e->dest->index);\n-\t\t\t  char c = ' ';\n-\t\t\t  if (e->flags & EDGE_TRUE_VALUE)\n-\t\t\t    fprintf (f, \" (T)%c\", c);\n-\t\t\t  else if (e->flags & EDGE_FALSE_VALUE)\n-\t\t\t    fprintf (f, \" (F)%c\", c);\n-\t\t\t  else\n-\t\t\t    fprintf (f, \"     \");\n-\t\t\t  print_generic_expr (f, name, TDF_SLIM);\n-\t\t\t  fprintf(f, \" : \\t\");\n-\t\t\t  range.dump(f);\n-\t\t\t  fprintf (f, \"\\n\");\n-\t\t\t}\n+\t\t      fprintf (f, \"%d->%d \", e->src->index,\n+\t\t\t       e->dest->index);\n+\t\t      char c = ' ';\n+\t\t      if (e->flags & EDGE_TRUE_VALUE)\n+\t\t\tfprintf (f, \" (T)%c\", c);\n+\t\t      else if (e->flags & EDGE_FALSE_VALUE)\n+\t\t\tfprintf (f, \" (F)%c\", c);\n+\t\t      else\n+\t\t\tfprintf (f, \"     \");\n+\t\t      print_generic_expr (f, name, TDF_SLIM);\n+\t\t      fprintf(f, \" : \\t\");\n+\t\t      range.dump(f);\n+\t\t      fprintf (f, \"\\n\");\n \t\t    }\n \t\t}\n \t    }\n \t}\n     }\n+}\n+\n+// Print the known table values to file F.\n+\n+void\n+gimple_ranger::dump (FILE *f)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    dump_bb (f, bb);\n \n-  m_cache.dump (dump_file, (dump_flags & TDF_DETAILS) != 0);\n+  m_cache.dump (f, false);\n }\n \n // If SCEV has any information about phi node NAME, return it as a range in R."}, {"sha": "08035a53238b427eb06ecbe8995bb6a4a87deeaa", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35c78c6fc54721e067ed3a30ddd9184b45c5981d/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35c78c6fc54721e067ed3a30ddd9184b45c5981d/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=35c78c6fc54721e067ed3a30ddd9184b45c5981d", "patch": "@@ -66,6 +66,7 @@ class gimple_ranger : public range_query\n   virtual void range_on_exit (irange &r, basic_block bb, tree name);\n   void export_global_ranges ();\n   void dump (FILE *f);\n+  void dump_bb (FILE *f, basic_block bb);\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n   ranger_cache m_cache;"}]}