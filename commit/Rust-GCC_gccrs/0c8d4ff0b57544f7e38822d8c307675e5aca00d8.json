{"sha": "0c8d4ff0b57544f7e38822d8c307675e5aca00d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM4ZDRmZjBiNTc1NDRmN2UzODgyMmQ4YzMwNzY3NWU1YWNhMDBkOA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-11T23:10:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-11T23:10:14Z"}, "message": "entered into RCS\n\nFrom-SVN: r446", "tree": {"sha": "57e94204ab78423b1c6bcb2ce1df188780e14c62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57e94204ab78423b1c6bcb2ce1df188780e14c62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c8d4ff0b57544f7e38822d8c307675e5aca00d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c8d4ff0b57544f7e38822d8c307675e5aca00d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c8d4ff0b57544f7e38822d8c307675e5aca00d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c8d4ff0b57544f7e38822d8c307675e5aca00d8/comments", "author": null, "committer": null, "parents": [{"sha": "18ca7dab53c81409ba0bf9e712b9585e554e5054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18ca7dab53c81409ba0bf9e712b9585e554e5054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18ca7dab53c81409ba0bf9e712b9585e554e5054"}], "stats": {"total": 226, "additions": 213, "deletions": 13}, "files": [{"sha": "a88c1c2df49c81ab6f55367eb6d245443892c3b2", "filename": "gcc/config/m68k/pbb.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c8d4ff0b57544f7e38822d8c307675e5aca00d8/gcc%2Fconfig%2Fm68k%2Fpbb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c8d4ff0b57544f7e38822d8c307675e5aca00d8/gcc%2Fconfig%2Fm68k%2Fpbb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpbb.h?ref=0c8d4ff0b57544f7e38822d8c307675e5aca00d8", "patch": "@@ -0,0 +1,154 @@\n+/* Definitions of target machine for GNU compiler.\n+\n+   Citicorp/TTI Unicom PBB version (using GAS with a %-register prefix)\n+\n+   Copyright (C) 1987, 1988, 1990 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Note:   This config uses a version of gas with a postprocessing stage that\n+   converts the output of gas to coff containing stab debug symbols.\n+   (See vasta@apollo.com or mb@soldev.tti.com) */\n+\n+#include \"m68k.h\"\n+\n+/* See m68k.h.  5 means 68020 without 68881.  */\n+\n+#define TARGET_DEFAULT 5\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.  */\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* Define __HAVE_68881__ in preprocessor if -m68881 is specified.\n+   This will control the use of inline 68881 insns in certain macros.  */\n+\n+#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dm68k -Dunix -DUnicomPBB -Dmc68k -Dmc68020 -Dmc68k32\"\n+\n+/* We want DBX format for use with gdb under COFF.  */\n+\n+#define DBX_DEBUGGING_INFO\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* -m68000 requires special flags to the assembler. */\n+\n+#define ASM_SPEC \\\n+ \" %{m68000:-mc68010}%{mc68000:-mc68010}\"\n+\n+/* we use /lib/libp/lib*  when profiling */\n+\n+#define LIB_SPEC \"%{p:-L/usr/lib/libp} %{pg:-L/usr/lib/libp} -lc\"\n+\n+\n+/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n+/*\n+ * The loader directive file gcc.ifile defines how to merge the constructor \n+ * sections into the data section.  Also, since gas only puts out those \n+ * sections in response to N_SETT stabs, and does not (yet) have a \n+ * \".sections\" directive, gcc.ifile also defines the list symbols \n+ * __DTOR_LIST__ and __CTOR_LIST__.\n+ * \n+ * Finally, we must explicitly specify the file from libgcc.a that defines\n+ * exit(), otherwise if the user specifies (for example) \"-lc_s\" on the \n+ * command line, the wrong exit() will be used and global destructors will \n+ * not get called .\n+ */\n+\n+#define STARTFILE_SPEC \\\n+\"%{!r: gcc.ifile%s} %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} \\\n+%{!r:_exit.o%s}\"\n+\n+#define ENDFILE_SPEC \"crtn.o%s\"\n+\n+/* cpp has to support a #sccs directive for the /usr/include files */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* GAS register prefix assembly syntax: */\n+\n+/* User labels have no prefix */\n+#undef  USER_LABEL_PREFIX \n+#define USER_LABEL_PREFIX \"\"\n+\n+/* local labels are prefixed with \".L\" */\n+#undef  LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX \".\"\n+\n+/* registers are prefixed with \"%\" */\n+#undef  REGISTER_PREFIX\n+#define REGISTER_PREFIX \"%\"\n+\n+#undef REGISTER_NAMES\n+#define REGISTER_NAMES \\\n+{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n+ \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\",\t\\\n+ \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n+\n+#undef FUNCTION_EXTRA_EPILOGUE\n+#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n+  { extern int current_function_returns_pointer;\t\t\t\\\n+    if ((current_function_returns_pointer) &&\t\t\t\t\\\n+      ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))        \\\n+      asm_fprintf (FILE, \"\\tmovl %Rd0,%Ra0\\n\"); } \n+\n+#define ASM_RETURN_CASE_JUMP   return \"jmp %%pc@(2,%0:w)\"\n+\n+/* Although the gas we use can create .ctor and .dtor sections from N_SETT\n+   stabs, it does not support section directives, so we need to have the loader\n+   define the lists.\n+ */\n+#define CTOR_LISTS_DEFINED_EXTERNALLY\n+\n+/* similar to default, but allows for the table defined by ld with gcc.ifile. \n+   nptrs is always 0.  So we need to instead check that __DTOR_LIST__[1] != 0.\n+   The old check is left in so that the same macro can be used if and when  \n+   a future version of gas does support section directives. */\n+\n+#define DO_GLOBAL_DTORS_BODY {int nptrs = *(int *)__DTOR_LIST__; int i; \\\n+  if (nptrs == -1 || (__DTOR_LIST__[0] == 0 && __DTOR_LIST__[1] != 0))  \\\n+    for (nptrs = 0; __DTOR_LIST__[nptrs + 1] != 0; nptrs++); \t\t\\\n+  for (i = nptrs; i >= 1; i--)\t\t\t\t\t\t\\\n+    __DTOR_LIST__[i] (); }\n+\n+/* \n+ * Here is an example gcc.ifile.  I've tested it on PBB 68k and on sco 386\n+ * systems. The NEXT(0x200000) works on just about all 386 and m68k systems, \n+ * but can be reduced to any power of 2 that is >= NBPS (0x10000 on a pbb).\n+\n+   SECTIONS {\n+       .text BIND(0x200200) BLOCK (0x200) : \n+\t\t{ *(.init) *(.text) vfork = fork; *(.fini) }\n+\n+      \tGROUP BIND( NEXT(0x200000) + ADDR(.text) + SIZEOF(.text)):\n+\t{      .data : { __CTOR_LIST__ = . ; . += 4; *(.ctor) . += 4 ;\n+\t\t       \t __DTOR_LIST__ = . ; . += 4; *(.dtor) . += 4 ; }\n+\t       .bss : { }\n+       }\n+  }\n+ */\n+\n+/*\n+Local variables:\n+version-control: t\n+End:\n+*/"}, {"sha": "1b75fe23144f0814589e9c0c516b7c0419aae442", "filename": "gcc/config/sparc/pbd.h", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c8d4ff0b57544f7e38822d8c307675e5aca00d8/gcc%2Fconfig%2Fsparc%2Fpbd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c8d4ff0b57544f7e38822d8c307675e5aca00d8/gcc%2Fconfig%2Fsparc%2Fpbd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpbd.h?ref=0c8d4ff0b57544f7e38822d8c307675e5aca00d8", "patch": "@@ -31,7 +31,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* We want DBX format for use with gdb under COFF.  */\n \n #define DBX_DEBUGGING_INFO\n-#define DBX_IN_COFF\n \n /* Generate calls to memcpy, memcmp and memset.  */\n \n@@ -40,25 +39,71 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* we use /lib/libp/lib*  when profiling */\n \n #undef LIB_SPEC\n-#define LIB_SPEC \"%{!shlib:%{p:-L/lib/libp} %{pg:-L/lib/libp} -lc} \\\n-   %{shlib:-lc_s crtn.o%s }\"\n+#define LIB_SPEC \"%{p:-L/usr/lib/libp} %{pg:-L/usr/lib/libp} -lc\"\n \n-/* shared libraries need to use crt1.o  */\n \n-#ifdef USE_GPLUS_IFILE\n-#define STARTFILE_SPEC \\\n-  \"g++.ifile%s %{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n-   %{shlib:crt1.o%s } \"\n-#else\n+/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n+/*\n+ * The loader directive file gcc.ifile defines how to merge the constructor \n+ * sections into the data section.  Also, since gas only puts out those \n+ * sections in response to N_SETT stabs, and does not (yet) have a \n+ * \".sections\" directive, gcc.ifile also defines the list symbols \n+ * __DTOR_LIST__ and __CTOR_LIST__.\n+ * \n+ * Finally, we must explicitly specify the file from libgcc.a that defines\n+ * exit(), otherwise if the user specifies (for example) \"-lc_s\" on the \n+ * command line, the wrong exit() will be used and global destructors will \n+ * not get called .\n+ */\n+\n #define STARTFILE_SPEC \\\n-  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n-   %{shlib:crt1.o%s } \"\n-#endif\n+\"%{!r: gcc.ifile%s} %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} \\\n+%{!r:_exit.o%s}\"\n+\n+#define ENDFILE_SPEC \"crtn.o%s\"\n \n /* cpp has to support a #sccs directive for the /usr/include files */\n \n #define SCCS_DIRECTIVE\n \n+/* LINK_SPEC is needed only for Sunos 4.  */\n+\n+#undef LINK_SPEC\n+\n+/* Although the gas we use can create .ctor and .dtor sections from N_SETT\n+   stabs, it does not support section directives, so we need to have the loader\n+   define the lists.\n+   */\n+#define CTOR_LISTS_DEFINED_EXTERNALLY\n+\n+/* similar to default, but allows for the table defined by ld with gcc.ifile. \n+   nptrs is always 0.  So we need to instead check that __DTOR_LIST__[1] != 0.\n+   The old check is left in so that the same macro can be used if and when  \n+   a future version of gas does support section directives. */\n+\n+#define DO_GLOBAL_DTORS_BODY {int nptrs = *(int *)__DTOR_LIST__; int i; \\\n+  if (nptrs == -1 || (__DTOR_LIST__[0] == 0 && __DTOR_LIST__[1] != 0))  \\\n+    for (nptrs = 0; __DTOR_LIST__[nptrs + 1] != 0; nptrs++); \t\t\\\n+  for (i = nptrs; i >= 1; i--)\t\t\t\t\t\t\\\n+    __DTOR_LIST__[i] (); }\n+\n+/* \n+ * Here is an example gcc.ifile.  I've tested it on PBD sparc\n+ * systems. The NEXT(0x200000) works on just about all 386 and m68k systems, \n+ * but can be reduced to any power of 2 that is >= NBPS (0x40000 on a pbd).\n+\n+   SECTIONS {\n+       .text BIND(0x41000200) BLOCK (0x200) : \n+\t\t{ *(.init) *(.text) vfork = fork; *(.fini) }\n+\n+      \tGROUP BIND( NEXT(0x200000) + ADDR(.text) + SIZEOF(.text)):\n+\t{      .data : { __CTOR_LIST__ = . ; . += 4; *(.ctor) . += 4 ;\n+\t\t       \t __DTOR_LIST__ = . ; . += 4; *(.dtor) . += 4 ; }\n+\t       .bss : { }\n+       }\n+  }\n+ */\n+\n #ifndef __GNUC__\n #define USE_C_ALLOCA\n #endif\n@@ -105,7 +150,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\t.word .L%d\\n\", VALUE)\n \n-/* Underscores are not used on Unicom PBB coff systems. */\n+/* Underscores are not used on Unicom PBD coff systems. */\n+/* This currently seems to only be needed for libgcc2.a */\n #define NO_UNDERSCORES\n \n /* Output assembler code to FILE to increment profiler label # LABELNO"}]}