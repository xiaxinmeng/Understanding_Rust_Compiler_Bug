{"sha": "e97e526319f2be937713348635bcafda87a19298", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk3ZTUyNjMxOWYyYmU5Mzc3MTMzNDg2MzViY2FmZGE4N2ExOTI5OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-11-11T03:42:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-11-11T03:42:37Z"}, "message": "pt.c (try_one_overload): Take orig_targs again.\n\n\t* pt.c (try_one_overload): Take orig_targs again.  Only check for\n\tmismatches against them; we don't care what a previous call found.\n\t(resolve_overloaded_unification): Adjust.\n\t* search.c (lookup_field): Don't return anything for a non-type\n\tfield from a dependent type.\n\t* decl.c (grokdeclarator): Resolve SCOPE_REFs of the current class\n\tin an array declarator.\n\t(start_decl): Push into the class before looking for the field.\n\nFrom-SVN: r23605", "tree": {"sha": "0c5b905b1308ff21d85ec67719928230a176a582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c5b905b1308ff21d85ec67719928230a176a582"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e97e526319f2be937713348635bcafda87a19298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e97e526319f2be937713348635bcafda87a19298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e97e526319f2be937713348635bcafda87a19298", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e97e526319f2be937713348635bcafda87a19298/comments", "author": null, "committer": null, "parents": [{"sha": "a8ec10c9124ba08cb6378f1748a33d9b3f294278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ec10c9124ba08cb6378f1748a33d9b3f294278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ec10c9124ba08cb6378f1748a33d9b3f294278"}], "stats": {"total": 49, "additions": 38, "deletions": 11}, "files": [{"sha": "475ada1c5ac2a4bb3e16232a37d4c005046bf5dd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e97e526319f2be937713348635bcafda87a19298", "patch": "@@ -1,3 +1,15 @@\n+1998-11-11  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (try_one_overload): Take orig_targs again.  Only check for\n+\tmismatches against them; we don't care what a previous call found.\n+\t(resolve_overloaded_unification): Adjust.\n+\n+\t* search.c (lookup_field): Don't return anything for a non-type\n+\tfield from a dependent type.\n+\t* decl.c (grokdeclarator): Resolve SCOPE_REFs of the current class\n+\tin an array declarator.\n+\t(start_decl): Push into the class before looking for the field.\n+\n 1998-11-08  Mark Mitchell  <mark@markmitchell.com>\n \n \t* method.c (build_overload_value): Handle REFERENCE_TYPE."}, {"sha": "8b9bb04aa62fb5609f6a4e09d4b2768e2b71735e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e97e526319f2be937713348635bcafda87a19298", "patch": "@@ -6658,6 +6658,8 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \n   if (context && TYPE_SIZE (complete_type (context)) != NULL_TREE)\n     {\n+      pushclass (context, 2);\n+\n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n \t  tree field = lookup_field (context, DECL_NAME (decl), 0, 0);\n@@ -6699,8 +6701,6 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n \tcp_pedwarn (\"declaration of `%#D' outside of class is not definition\",\n \t\t    decl);\n-\n-      pushclass (context, 2);\n     }\n \n #ifdef SET_DEFAULT_DECL_ATTRIBUTES\n@@ -9604,6 +9604,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t   constant, but we don't know what the value is yet.  */\n \t\tif (processing_template_decl)\n \t\t  {\n+\t\t    /* Resolve a qualified reference to an enumerator or\n+\t\t       static const data member of ours.  */\n+\t\t    if (TREE_CODE (size) == SCOPE_REF\n+\t\t\t&& TREE_OPERAND (size, 0) == current_class_type)\n+\t\t      {\n+\t\t\ttree t = lookup_field (current_class_type,\n+\t\t\t\t\t       TREE_OPERAND (size, 1), 0, 0);\n+\t\t\tif (t)\n+\t\t\t  size = t;\n+\t\t      }\n+\n \t\t    itype = make_node (INTEGER_TYPE);\n \t\t    TYPE_MIN_VALUE (itype) = size_zero_node;\n \t\t    TYPE_MAX_VALUE (itype) = build_min"}, {"sha": "5f3fbab967f5333bd61241afd4e3e53bc6b939c3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e97e526319f2be937713348635bcafda87a19298", "patch": "@@ -80,7 +80,7 @@ static int unify PROTO((tree, tree, tree, tree, int, int*));\n static int resolve_overloaded_unification PROTO((tree, tree, tree, tree,\n \t\t\t\t\t\t unification_kind_t, int,\n \t\t\t\t\t\t int*));\n-static int try_one_overload PROTO((tree, tree, tree, tree,\n+static int try_one_overload PROTO((tree, tree, tree, tree, tree,\n \t\t\t\t   unification_kind_t, int, int*));\n static int unify PROTO((tree, tree, tree, tree, int, int*));\n static void add_pending_template PROTO((tree));\n@@ -7031,15 +7031,15 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n \t  if (subargs)\n \t    {\n \t      elem = tsubst (TREE_TYPE (fn), subargs, NULL_TREE);\n-\t      good += try_one_overload (tparms, tempargs, parm, elem,\n+\t      good += try_one_overload (tparms, targs, tempargs, parm, elem,\n \t\t\t\t\tstrict, sub_strict, explicit_mask);\n \t    }\n \t}\n     }\n   else if (TREE_CODE (arg) == OVERLOAD)\n     {\n       for (; arg; arg = OVL_NEXT (arg))\n-\tgood += try_one_overload (tparms, tempargs, parm,\n+\tgood += try_one_overload (tparms, targs, tempargs, parm,\n \t\t\t\t  TREE_TYPE (OVL_CURRENT (arg)),\n \t\t\t\t  strict, sub_strict, explicit_mask);\n     }\n@@ -7073,9 +7073,9 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n    Returns 1 on success.  */\n \n static int\n-try_one_overload (tparms, targs, parm, arg, strict,\n+try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n \t\t  sub_strict, explicit_mask)\n-     tree tparms, targs, parm, arg;\n+     tree tparms, orig_targs, targs, parm, arg;\n      unification_kind_t strict;\n      int sub_strict;\n      int* explicit_mask;\n@@ -7107,11 +7107,11 @@ try_one_overload (tparms, targs, parm, arg, strict,\n     return 0;\n \n   /* First make sure we didn't deduce anything that conflicts with\n-     previously deduced/specified args.  */\n+     explicitly specified args.  */\n   for (i = nargs; i--; )\n     {\n       tree elt = TREE_VEC_ELT (tempargs, i);\n-      tree oldelt = TREE_VEC_ELT (targs, i);\n+      tree oldelt = TREE_VEC_ELT (orig_targs, i);\n \n       if (elt == NULL_TREE)\n \tcontinue;"}, {"sha": "4157a5dda2aa2a54b37877d5bade7afe3790540a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97e526319f2be937713348635bcafda87a19298/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e97e526319f2be937713348635bcafda87a19298", "patch": "@@ -1186,11 +1186,15 @@ lookup_field (xbasetype, name, protect, want_type)\n        template <class T> void S<T>::I::f() {}\n \n      will come through here to handle `S<T>::I'.  */\n-  if (rval && TREE_CODE (rval) == TYPE_DECL\n-      && processing_template_decl\n+  if (rval && processing_template_decl\n       && ! currently_open_class (BINFO_TYPE (rval_binfo))\n       && uses_template_parms (type))\n     {\n+      /* Don't return a non-type.  Actually, we ought to return something\n+\t so lookup_name_real can give a warning.  */\n+      if (TREE_CODE (rval) != TYPE_DECL)\n+\treturn NULL_TREE;\n+\n       binfo = rval_binfo;\n       for (; ; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n \tif (BINFO_INHERITANCE_CHAIN (binfo) == NULL_TREE"}]}