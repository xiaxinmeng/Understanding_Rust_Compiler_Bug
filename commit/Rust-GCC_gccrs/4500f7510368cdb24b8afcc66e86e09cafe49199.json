{"sha": "4500f7510368cdb24b8afcc66e86e09cafe49199", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUwMGY3NTEwMzY4Y2RiMjRiOGFmY2M2NmU4NmUwOWNhZmU0OTE5OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-07-05T08:39:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-07-05T08:39:13Z"}, "message": "except.c (emit_to_new_bb_before): Make sure to put a location on SEQ.\n\n\t* except.c (emit_to_new_bb_before): Make sure to put a location on SEQ.\n\t* tree-eh.c (replace_goto_queue_1) <GIMPLE_GOTO>: Propagate location.\n\t(emit_eh_dispatch): Delete.\n\t(lower_catch): Emit the eh_dispatch manually and set the location of\n\tthe first catch statement onto it.\n\t(lower_eh_filter): Emit the eh_dispatch manually and set location.\n\t(lower_eh_dispatch): Propagate location.\n\t* tree-outof-ssa.c (set_location_for_edge): Handle EH edges specially.\n\t(eliminate_build): Likewise.\n\nFrom-SVN: r273132", "tree": {"sha": "ef2fbd634046ad09eee8adc6a72055247524803a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef2fbd634046ad09eee8adc6a72055247524803a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4500f7510368cdb24b8afcc66e86e09cafe49199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4500f7510368cdb24b8afcc66e86e09cafe49199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4500f7510368cdb24b8afcc66e86e09cafe49199", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4500f7510368cdb24b8afcc66e86e09cafe49199/comments", "author": null, "committer": null, "parents": [{"sha": "ffdc40a90faec54d29af76b994c52790685a8e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffdc40a90faec54d29af76b994c52790685a8e58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffdc40a90faec54d29af76b994c52790685a8e58"}], "stats": {"total": 101, "additions": 82, "deletions": 19}, "files": [{"sha": "155c6b29ff9007435361a38a25b4f9eaefbf0c81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4500f7510368cdb24b8afcc66e86e09cafe49199", "patch": "@@ -1,4 +1,16 @@\n-2019-07-03  Eric Botcazou  <ebotcazou@adacore.com>\n+2019-07-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* except.c (emit_to_new_bb_before): Make sure to put a location on SEQ.\n+\t* tree-eh.c (replace_goto_queue_1) <GIMPLE_GOTO>: Propagate location.\n+\t(emit_eh_dispatch): Delete.\n+\t(lower_catch): Emit the eh_dispatch manually and set the location of\n+\tthe first catch statement onto it.\n+\t(lower_eh_filter): Emit the eh_dispatch manually and set location.\n+\t(lower_eh_dispatch): Propagate location.\n+\t* tree-outof-ssa.c (set_location_for_edge): Handle EH edges specially.\n+\t(eliminate_build): Likewise.\n+\n+2019-07-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-cfg.c (gimple_make_forwarder_block): Propagate location info on\n \tphi nodes if possible."}, {"sha": "b1f04ee6861c78f1e8e3ae4625eeb73cd8b4bfa4", "filename": "gcc/except.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4500f7510368cdb24b8afcc66e86e09cafe49199", "patch": "@@ -921,7 +921,7 @@ assign_filter_values (void)\n static basic_block\n emit_to_new_bb_before (rtx_insn *seq, rtx_insn *insn)\n {\n-  rtx_insn *last;\n+  rtx_insn *next, *last;\n   basic_block bb;\n   edge e;\n   edge_iterator ei;\n@@ -934,7 +934,16 @@ emit_to_new_bb_before (rtx_insn *seq, rtx_insn *insn)\n       force_nonfallthru (e);\n     else\n       ei_next (&ei);\n-  last = emit_insn_before (seq, insn);\n+\n+  /* Make sure to put the location of INSN or a subsequent instruction on SEQ\n+     to avoid inheriting the location of the previous instruction.  */\n+  next = insn;\n+  while (next && !NONDEBUG_INSN_P (next))\n+    next = NEXT_INSN (next);\n+  if (next)\n+    last = emit_insn_before_setloc (seq, insn, INSN_LOCATION (next));\n+  else\n+    last = emit_insn_before (seq, insn);\n   if (BARRIER_P (last))\n     last = PREV_INSN (last);\n   bb = create_basic_block (seq, last, BLOCK_FOR_INSN (insn)->prev_bb);"}, {"sha": "fb7d202fc6f9f76ffe586a757ef3b9c93ee175db", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=4500f7510368cdb24b8afcc66e86e09cafe49199", "patch": "@@ -503,7 +503,11 @@ replace_goto_queue_1 (gimple *stmt, struct leh_tf_state *tf,\n       seq = find_goto_replacement (tf, temp);\n       if (seq)\n \t{\n-\t  gsi_insert_seq_before (gsi, gimple_seq_copy (seq), GSI_SAME_STMT);\n+\t  gimple_stmt_iterator i;\n+\t  seq = gimple_seq_copy (seq);\n+\t  for (i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n+\t    gimple_set_location (gsi_stmt (i), gimple_location (stmt));\n+\t  gsi_insert_seq_before (gsi, seq, GSI_SAME_STMT);\n \t  gsi_remove (gsi, false);\n \t  return;\n \t}\n@@ -811,15 +815,6 @@ emit_resx (gimple_seq *seq, eh_region region)\n     record_stmt_eh_region (region->outer, x);\n }\n \n-/* Emit an EH_DISPATCH statement into SEQ for REGION.  */\n-\n-static void\n-emit_eh_dispatch (gimple_seq *seq, eh_region region)\n-{\n-  geh_dispatch *x = gimple_build_eh_dispatch (region->index);\n-  gimple_seq_add_stmt (seq, x);\n-}\n-\n /* Note that the current EH region may contain a throw, or a\n    call to a function which itself may contain a throw.  */\n \n@@ -1762,7 +1757,9 @@ lower_catch (struct leh_state *state, gtry *tp)\n   tree out_label;\n   gimple_seq new_seq, cleanup;\n   gimple *x;\n+  geh_dispatch *eh_dispatch;\n   location_t try_catch_loc = gimple_location (tp);\n+  location_t catch_loc = UNKNOWN_LOCATION;\n \n   if (flag_exceptions)\n     {\n@@ -1776,7 +1773,8 @@ lower_catch (struct leh_state *state, gtry *tp)\n     return gimple_try_eval (tp);\n \n   new_seq = NULL;\n-  emit_eh_dispatch (&new_seq, try_region);\n+  eh_dispatch = gimple_build_eh_dispatch (try_region->index);\n+  gimple_seq_add_stmt (&new_seq, eh_dispatch);\n   emit_resx (&new_seq, try_region);\n \n   this_state.cur_region = state->cur_region;\n@@ -1799,6 +1797,8 @@ lower_catch (struct leh_state *state, gtry *tp)\n       gimple_seq handler;\n \n       catch_stmt = as_a <gcatch *> (gsi_stmt (gsi));\n+      if (catch_loc == UNKNOWN_LOCATION)\n+\tcatch_loc = gimple_location (catch_stmt);\n       c = gen_eh_region_catch (try_region, gimple_catch_types (catch_stmt));\n \n       handler = gimple_catch_handler (catch_stmt);\n@@ -1822,6 +1822,10 @@ lower_catch (struct leh_state *state, gtry *tp)\n \tbreak;\n     }\n \n+  /* Try to set a location on the dispatching construct to avoid inheriting\n+     the location of the previous statement.  */\n+  gimple_set_location (eh_dispatch, catch_loc);\n+\n   gimple_try_set_cleanup (tp, new_seq);\n \n   gimple_seq new_eh_seq = eh_seq;\n@@ -1857,11 +1861,13 @@ lower_eh_filter (struct leh_state *state, gtry *tp)\n   if (!eh_region_may_contain_throw (this_region))\n     return gimple_try_eval (tp);\n \n-  new_seq = NULL;\n   this_state.cur_region = state->cur_region;\n   this_state.ehp_region = this_region;\n \n-  emit_eh_dispatch (&new_seq, this_region);\n+  new_seq = NULL;\n+  x = gimple_build_eh_dispatch (this_region->index);\n+  gimple_set_location (x, gimple_location (tp));\n+  gimple_seq_add_stmt (&new_seq, x);\n   emit_resx (&new_seq, this_region);\n \n   this_region->u.allowed.label = create_artificial_label (UNKNOWN_LOCATION);\n@@ -3752,13 +3758,15 @@ lower_eh_dispatch (basic_block src, geh_dispatch *stmt)\n \t    filter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)));\n \t    filter = make_ssa_name (filter, x);\n \t    gimple_call_set_lhs (x, filter);\n+\t    gimple_set_location (x, gimple_location (stmt));\n \t    gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \n \t    /* Turn the default label into a default case.  */\n \t    default_label = build_case_label (NULL, NULL, default_label);\n \t    sort_case_labels (labels);\n \n \t    x = gimple_build_switch (filter, default_label, labels);\n+\t    gimple_set_location (x, gimple_location (stmt));\n \t    gsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \t  }\n       }\n@@ -3775,6 +3783,7 @@ lower_eh_dispatch (basic_block src, geh_dispatch *stmt)\n \tfilter = create_tmp_var (TREE_TYPE (TREE_TYPE (fn)));\n \tfilter = make_ssa_name (filter, x);\n \tgimple_call_set_lhs (x, filter);\n+\tgimple_set_location (x, gimple_location (stmt));\n \tgsi_insert_before (&gsi, x, GSI_SAME_STMT);\n \n \tr->u.allowed.label = NULL;"}, {"sha": "d8c8249e8ac9116ede2842e40724bfd1840d0a13", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4500f7510368cdb24b8afcc66e86e09cafe49199/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=4500f7510368cdb24b8afcc66e86e09cafe49199", "patch": "@@ -171,14 +171,43 @@ struct elim_graph\n    use its location.  Otherwise search instructions in predecessors\n    of E for a location, and use that one.  That makes sense because\n    we insert on edges for PHI nodes, and effects of PHIs happen on\n-   the end of the predecessor conceptually.  */\n+   the end of the predecessor conceptually.  An exception is made\n+   for EH edges because we don't want to drag the source location\n+   of unrelated statements at the beginning of handlers; they would\n+   be further reused for various EH constructs, which would damage\n+   the coverage information.  */\n \n static void\n set_location_for_edge (edge e)\n {\n   if (e->goto_locus)\n+    set_curr_insn_location (e->goto_locus);\n+  else if (e->flags & EDGE_EH)\n     {\n-      set_curr_insn_location (e->goto_locus);\n+      basic_block bb = e->dest;\n+      gimple_stmt_iterator gsi;\n+\n+      do\n+\t{\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (is_gimple_debug (stmt))\n+\t\tcontinue;\n+\t      if (gimple_has_location (stmt) || gimple_block (stmt))\n+\t\t{\n+\t\t  set_curr_insn_location (gimple_location (stmt));\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  /* Nothing found in this basic block.  Make a half-assed attempt\n+\t     to continue with another block.  */\n+\t  if (single_succ_p (bb))\n+\t    bb = single_succ (bb);\n+\t  else\n+\t    bb = e->dest;\n+\t}\n+      while (bb != e->dest);\n     }\n   else\n     {\n@@ -564,7 +593,11 @@ eliminate_build (elim_graph *g)\n \tcontinue;\n \n       Ti = PHI_ARG_DEF (phi, g->e->dest_idx);\n-      locus = gimple_phi_arg_location_from_edge (phi, g->e);\n+      /* See set_location_for_edge for the rationale.  */\n+      if (g->e->flags & EDGE_EH)\n+\tlocus = UNKNOWN_LOCATION;\n+      else\n+\tlocus = gimple_phi_arg_location_from_edge (phi, g->e);\n \n       /* If this argument is a constant, or a SSA_NAME which is being\n \t left in SSA form, just queue a copy to be emitted on this"}]}