{"sha": "2206e9044ead9df0be5c7a9486ede05ebc524482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwNmU5MDQ0ZWFkOWRmMGJlNWM3YTk0ODZlZGUwNWViYzUyNDQ4Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:29:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:29:50Z"}, "message": "(extend{qihi,qisi,hisi}2): Allow unaligned memory as arg 1 and pass to extend_{q,h}idi2.\n\n(extend{qihi,qisi,hisi}2): Allow unaligned memory as arg 1 and pass to\nextend_{q,h}idi2.\n(unaligned_extend{q,h}idi): New patterns.\n(extend{q,h}idi2): If unaligned memory, call above new patterns.\n(ext{q,l,w}h recognizer): Update to proper RTL.\n(ext define_split): Comment out for now; wrong and maybe useless.\n(unaligned_{load,store}hi): Do similarly to QImode.\n(movhi, reload_{in,out}hi): Call unaligned case differently.\n\nFrom-SVN: r10882", "tree": {"sha": "47f41063c7a6d8fabfb7777107afccb378dbabcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f41063c7a6d8fabfb7777107afccb378dbabcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2206e9044ead9df0be5c7a9486ede05ebc524482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2206e9044ead9df0be5c7a9486ede05ebc524482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2206e9044ead9df0be5c7a9486ede05ebc524482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2206e9044ead9df0be5c7a9486ede05ebc524482/comments", "author": null, "committer": null, "parents": [{"sha": "442b16859cfb776f532d6cdb4908ce19e96924e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442b16859cfb776f532d6cdb4908ce19e96924e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442b16859cfb776f532d6cdb4908ce19e96924e2"}], "stats": {"total": 402, "additions": 243, "deletions": 159}, "files": [{"sha": "1517ea30da279d167f5e042cadeda15ffad37342", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 243, "deletions": 159, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2206e9044ead9df0be5c7a9486ede05ebc524482/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2206e9044ead9df0be5c7a9486ede05ebc524482/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=2206e9044ead9df0be5c7a9486ede05ebc524482", "patch": "@@ -821,72 +821,179 @@\n \n (define_expand \"extendqihi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:QI 1 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:QI 1 \"reg_or_unaligned_mem_operand\" \"\")\n \t\t   (const_int 56)))\n    (set (match_operand:HI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n   \"\n-{ operands[0] = gen_lowpart (DImode, operands[0]);\n+{\n+  /* If we have a MEM (must be unaligned), extend to DImode (which we do\n+\tspecially) and then copy to the result.  */\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx temp = gen_reg_rtx (DImode);\n+\n+      emit_insn (gen_extendqidi2 (temp, operands[1]));\n+      emit_move_insn (operands[0], gen_lowpart (HImode, temp));\n+      DONE;\n+    }\n+\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n   operands[1] = gen_lowpart (DImode, operands[1]);\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_expand \"extendqisi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:QI 1 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:QI 1 \"reg_or_unaligned_mem_operand\" \"\")\n \t\t   (const_int 56)))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n   \"\n-{ operands[0] = gen_lowpart (DImode, operands[0]);\n+{\n+  /* If we have a MEM (must be unaligned), extend to a DImode form of\n+     the result (which we do specially).  */\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx temp = gen_reg_rtx (DImode);\n+\n+      emit_insn (gen_extendqidi2 (temp, operands[1]));\n+      emit_move_insn (operands[0], gen_lowpart (SImode, temp));\n+      DONE;\n+    }\n+\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n   operands[1] = gen_lowpart (DImode, operands[1]);\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_expand \"extendqidi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:QI 1 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:QI 1 \"reg_or_unaligned_mem_operand\" \"\")\n \t\t   (const_int 56)))\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 56)))]\n   \"\"\n   \"\n-{ operands[1] = gen_lowpart (DImode, operands[1]);\n+{ extern rtx get_unaligned_address ();\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx seq\n+\t= gen_unaligned_extendqidi (operands[0],\n+\t\t\t\t    get_unaligned_address (operands[1], 1));\n+\n+      alpha_set_memflags (seq, operands[1]);\n+      emit_insn (seq);\n+      DONE;\n+    }\n+\n+  operands[1] = gen_lowpart (DImode, operands[1]);\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_expand \"extendhisi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:HI 1 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:HI 1 \"reg_or_unaligned_mem_operand\" \"\")\n \t\t   (const_int 48)))\n    (set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 48)))]\n   \"\"\n   \"\n-{ operands[0] = gen_lowpart (DImode, operands[0]);\n+{\n+  /* If we have a MEM (must be unaligned), extend to a DImode form of\n+     the result (which we do specially).  */\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx temp = gen_reg_rtx (DImode);\n+\n+      emit_insn (gen_extendhidi2 (temp, operands[1]));\n+      emit_move_insn (operands[0], gen_lowpart (SImode, temp));\n+      DONE;\n+    }\n+\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n   operands[1] = gen_lowpart (DImode, operands[1]);\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n (define_expand \"extendhidi2\"\n   [(set (match_dup 2)\n-\t(ashift:DI (match_operand:HI 1 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:HI 1 \"reg_or_unaligned_mem_operand\" \"\")\n \t\t   (const_int 48)))\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n \t(ashiftrt:DI (match_dup 2)\n \t\t     (const_int 48)))]\n   \"\"\n   \"\n-{ operands[1] = gen_lowpart (DImode, operands[1]);\n+{ extern rtx get_unaligned_address ();\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx seq\n+\t= gen_unaligned_extendhidi (operands[0],\n+\t\t\t\t    get_unaligned_address (operands[1], 2));\n+\n+      alpha_set_memflags (seq, operands[1]);\n+      emit_insn (seq);\n+      DONE;\n+    }\n+\n+  operands[1] = gen_lowpart (DImode, operands[1]);\n   operands[2] = gen_reg_rtx (DImode);\n }\")\n \n+;; Here's how we sign extend an unaligned byte and halfword.  Doing this\n+;; as a pattern saves one instruction.  The code is similar to that for\n+;; the unaligned loads (see below).\n+;;\n+;; Operand 1 is the address + 1 (+2 for HI), operand 0 is the result.\n+(define_expand \"unaligned_extendqidi\"\n+  [(set (match_dup 2) (match_operand:DI 1 \"address_operand\" \"\"))\n+   (set (match_dup 3)\n+\t(mem:DI (and:DI (plus:DI (match_dup 2) (const_int -1))\n+\t\t\t(const_int -8))))\n+   (set (match_dup 4)\n+\t(ashift:DI (match_dup 3)\n+\t\t   (minus:DI (const_int 56)\n+\t\t\t     (ashift:DI\n+\t\t\t      (and:DI (plus:DI (match_dup 2) (const_int -1))\n+\t\t\t\t      (const_int 7))\n+\t\t\t      (const_int 3)))))\n+   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t(ashiftrt:DI (match_dup 4) (const_int 56)))]\n+  \"\"\n+  \"\n+{ operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = gen_reg_rtx (DImode);\n+  operands[4] = gen_reg_rtx (DImode);\n+}\")\n+\n+(define_expand \"unaligned_extendhidi\"\n+  [(set (match_dup 2) (match_operand:DI 1 \"address_operand\" \"\"))\n+   (set (match_dup 3)\n+\t(mem:DI (and:DI (plus:DI (match_dup 2) (const_int -2))\n+\t\t\t(const_int -8))))\n+   (set (match_dup 4)\n+\t(ashift:DI (match_dup 3)\n+\t\t   (minus:DI (const_int 56)\n+\t\t\t     (ashift:DI\n+\t\t\t      (and:DI (plus:DI (match_dup 2) (const_int -1))\n+\t\t\t\t      (const_int 7))\n+\t\t\t      (const_int 3)))))\n+   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t(ashiftrt:DI (match_dup 4) (const_int 48)))]\n+  \"\"\n+  \"\n+{ operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = gen_reg_rtx (DImode);\n+  operands[4] = gen_reg_rtx (DImode);\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -907,70 +1014,87 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n-\t (zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (const_int 8)\n-\t\t\t  (ashift:DI\n-\t\t\t   (plus:DI\n-\t\t\t    (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n-\t\t\t    (const_int -1))\n-\t\t\t   (const_int 3)))\n-\t (const_int 56)))]\n+\t (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t  (minus:DI (const_int 56)\n+\t\t    (ashift:DI\n+\t\t     (and:DI\n+\t\t      (plus:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t       (const_int -1))\n+\t\t      (const_int 7))\n+\t\t     (const_int 3)))))]\n   \"\"\n   \"extqh %r1,%2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n-\t (zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (const_int 16)\n-\t\t\t  (ashift:DI\n-\t\t\t   (plus:DI\n-\t\t\t    (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n-\t\t\t    (const_int -2))\n-\t\t\t   (const_int 3)))\n-\t (const_int 48)))]\n+\t (and:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t (const_int 2147483647))\n+\t (minus:DI (const_int 56)\n+\t\t    (ashift:DI\n+\t\t     (and:DI\n+\t\t      (plus:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t       (const_int -1))\n+\t\t      (const_int 7))\n+\t\t     (const_int 3)))))]\n   \"\"\n-  \"extwh %r1,%2,%0\")\n+  \"extlh %r1,%2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n-\t (zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t  (const_int 32)\n-\t\t\t  (ashift:DI\n-\t\t\t   (plus:DI\n-\t\t\t    (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n-\t\t\t    (const_int -4))\n-\t\t\t   (const_int 3)))\n-\t (const_int 32)))]\n+\t (and:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t (const_int 65535))\n+\t (minus:DI (const_int 56)\n+\t\t    (ashift:DI\n+\t\t     (and:DI\n+\t\t      (plus:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t       (const_int -1))\n+\t\t      (const_int 7))\n+\t\t     (const_int 3)))))]\n   \"\"\n-  \"extlh %r1,%2,%0\")\n+  \"extwh %r1,%2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI\n+\t (and:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t (const_int 8))\n+\t (minus:DI (const_int 56)\n+\t\t    (ashift:DI\n+\t\t     (and:DI\n+\t\t      (plus:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t       (const_int -1))\n+\t\t      (const_int 7))\n+\t\t     (const_int 3)))))]\n+  \"\"\n+  \"extbh %r1,%2,%0\")\n \n ;; This converts an extXl into an extXh with an appropriate adjustment\n ;; to the address calculation.\n \n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ashift:DI (zero_extract:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t\t\t    (match_operand:DI 2 \"mode_width_operand\" \"\")\n-\t\t\t\t    (ashift:DI (match_operand:DI 3 \"\" \"\")\n-\t\t\t\t\t       (const_int 3)))\n-\t\t   (match_operand:DI 4 \"const_int_operand\" \"\")))\n-   (clobber (match_operand:DI 5 \"register_operand\" \"\"))]\n-  \"INTVAL (operands[4]) == 64 - INTVAL (operands[2])\"\n-  [(set (match_dup 5) (match_dup 6))\n-   (set (match_dup 0)\n-\t(ashift:DI (zero_extract:DI (match_dup 1) (match_dup 2)\n-\t\t\t\t    (ashift:DI (plus:DI (match_dup 5)\n-\t\t\t\t\t\t\t(match_dup 7))\n-\t\t\t\t\t       (const_int 3)))\n-\t\t   (match_dup 4)))]\n-  \"\n-{\n-  operands[6] = plus_constant (operands[3], \n-\t\t\t       INTVAL (operands[2]) / BITS_PER_UNIT);\n-  operands[7] = GEN_INT (- INTVAL (operands[2]) / BITS_PER_UNIT);\n-}\")\n+;;(define_split\n+;;  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+;;\t(ashift:DI (zero_extract:DI (match_operand:DI 1 \"register_operand\" \"\")\n+;;\t\t\t\t    (match_operand:DI 2 \"mode_width_operand\" \"\")\n+;;\t\t\t\t    (ashift:DI (match_operand:DI 3 \"\" \"\")\n+;;\t\t\t\t\t       (const_int 3)))\n+;;\t\t   (match_operand:DI 4 \"const_int_operand\" \"\")))\n+;;   (clobber (match_operand:DI 5 \"register_operand\" \"\"))]\n+;;  \"INTVAL (operands[4]) == 64 - INTVAL (operands[2])\"\n+;;  [(set (match_dup 5) (match_dup 6))\n+;;   (set (match_dup 0)\n+;;\t(ashift:DI (zero_extract:DI (match_dup 1) (match_dup 2)\n+;;\t\t\t\t    (ashift:DI (plus:DI (match_dup 5)\n+;;\t\t\t\t\t\t\t(match_dup 7))\n+;;\t\t\t\t\t       (const_int 3)))\n+;;\t\t   (match_dup 4)))]\n+;;  \"\n+;;{\n+;;  operands[6] = plus_constant (operands[3], \n+;;\t\t\t       INTVAL (operands[2]) / BITS_PER_UNIT);\n+;;  operands[7] = GEN_INT (- INTVAL (operands[2]) / BITS_PER_UNIT);\n+;;}\")\n   \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3230,16 +3354,10 @@\n   \"\"\n   \"\")\n   \n-;; Similar for unaligned loads.  For QImode, we use the sequence from the\n-;; Alpha Architecture manual.  However, for HImode, we do not.  HImode pointers\n-;; are normally aligned to the byte boundary, so an HImode object cannot\n-;; cross a longword boundary.  We could use a sequence similar to that for\n-;; QImode, but that would fail if the pointer, was, in fact, not aligned.\n-;; Instead, we clear bit 1 in the address and do an ldl.  If the low-order\n-;; bit was not aligned, this will trap and the trap handler will do what is\n-;; needed.\n+;; Similar for unaligned loads, where we use the sequence from the\n+;; Alpha Architecture manual.\n ;;\n-;; Here operand 1 is the address.  Operands 2 and 3 are temporaries, where\n+;; Operand 1 is the address.  Operands 2 and 3 are temporaries, where\n ;; operand 3 can overlap the input and output registers.\n \n (define_expand \"unaligned_loadqi\"\n@@ -3255,26 +3373,19 @@\n   \"\"\n   \"\")\n \n-;; For this, the address must already be in a register.  We also need two\n-;; DImode temporaries, neither of which may overlap the input (and hence the\n-;; output, since they might be the same register), but both of which may\n-;; be the same.\n-\n (define_expand \"unaligned_loadhi\"\n   [(set (match_operand:DI 2 \"register_operand\" \"\")\n-\t(and:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t(const_int -7)))\n+\t(mem:DI (and:DI (match_operand:DI 1 \"address_operand\" \"\")\n+\t\t\t(const_int -8))))\n    (set (match_operand:DI 3 \"register_operand\" \"\")\n-\t(mem:DI (match_dup 2)))\n-   (set (match_operand:DI 4 \"register_operand\" \"\")\n-\t(and:DI (match_dup 1) (const_int -2)))\n-   (set (subreg:DI (match_operand:HI 0 \"register_operand\" \"\") 0)\n-\t(zero_extract:DI (match_dup 3)\n+\t(match_dup 1))\n+   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t(zero_extract:DI (match_dup 2)\n \t\t\t (const_int 16)\n-\t\t\t (ashift:DI (match_dup 4) (const_int 3))))]\n+\t\t\t (ashift:DI (match_dup 3) (const_int 3))))]\n   \"\"\n   \"\")\n-       \n+\n ;; Storing an aligned byte or word requires two temporaries.  Operand 0 is the\n ;; aligned SImode MEM.  Operand 1 is the register containing the \n ;; byte or word to store.  Operand 2 is the number of bits within the word that\n@@ -3297,8 +3408,8 @@\n \t\t\t    << INTVAL (operands[2])));\n }\")\n \n-;; For the unaligned byte case, we use code similar to that in the\n-;; Architecture book, but reordered to lower the number of registers\n+;; For the unaligned byte and halfword cases, we use code similar to that\n+;; in the ;; Architecture book, but reordered to lower the number of registers\n ;; required.  Operand 0 is the address.  Operand 1 is the data to store.\n ;; Operands 2, 3, and 4 are DImode temporaries, where operands 2 and 4 may\n ;; be the same temporary, if desired.  If the address is in a register,\n@@ -3323,42 +3434,22 @@\n   \"\"\n   \"\")\n \n-;; This is the code for storing into an unaligned short.  It uses the same\n-;; trick as loading from an unaligned short.  It needs lots of temporaries.\n-;; However, during reload, we only have two registers available.  So we\n-;; repeat code so that only two temporaries are available.  During RTL\n-;; generation, we can use different pseudos for each temporary and CSE\n-;; will remove the redundancies.  During reload, we have to settle with\n-;; what we get.  Luckily, unaligned accesses of this kind produced during\n-;; reload are quite rare.\n-;;\n-;; Operand 0 is the address of the memory location.  Operand 1 contains the\n-;; data to store.  The rest of the operands are all temporaries, with\n-;; various overlap possibilities during reload.  See reload_outhi for\n-;; details of this use.\n-\n (define_expand \"unaligned_storehi\"\n-  [(set (match_operand:DI 2 \"register_operand\" \"\")\n-\t(match_operand:DI 0 \"address_operand\" \"\"))\n-   (set (match_operand:DI 3 \"register_operand\" \"\")\n-\t(and:DI (match_dup 2) (const_int -7)))\n-   (set (match_operand:DI 4 \"register_operand\" \"\")\n-\t(mem:DI (match_dup 3)))\n-   (set (match_operand:DI 10 \"register_operand\" \"\")\n-\t(and:DI (match_dup 2) (const_int -2)))\n-   (set (match_operand:DI 5 \"register_operand\" \"\")\n+  [(set (match_operand:DI 3 \"register_operand\" \"\")\n+\t(mem:DI (and:DI (match_operand:DI 0 \"address_operand\" \"\")\n+\t\t\t(const_int -8))))\n+   (set (match_operand:DI 2 \"register_operand\" \"\")\n+\t(match_dup 0))\n+   (set (match_dup 3)\n \t(and:DI (not:DI (ashift:DI (const_int 65535)\n-\t\t\t\t   (ashift:DI (match_dup 10) (const_int 3))))\n-\t\t(match_dup 4)))\n-   (set (match_operand:DI 6 \"register_operand\" \"\")\n+\t\t\t\t   (ashift:DI (match_dup 2) (const_int 3))))\n+\t\t(match_dup 3)))\n+   (set (match_operand:DI 4 \"register_operand\" \"\")\n \t(ashift:DI (zero_extend:DI (match_operand:HI 1 \"register_operand\" \"\"))\n-\t\t   (ashift:DI (match_dup 10) (const_int 3))))\n-   (set (match_operand:DI 7 \"register_operand\" \"\")\n-\t(ior:DI (match_dup 5) (match_dup 6)))\n-   (set (match_operand:DI 8 \"register_operand\" \"\") (match_dup 0))\n-   (set (match_operand:DI 9 \"register_operand\" \"\")\n-\t(and:DI (match_dup 8) (const_int -7)))\n-   (set (mem:DI (match_dup 9)) (match_dup 7))]\n+\t\t   (ashift:DI (match_dup 2) (const_int 3))))\n+   (set (match_dup 4) (ior:DI (match_dup 4) (match_dup 3)))\n+   (set (mem:DI (and:DI (match_dup 0) (const_int -8)))\n+\t(match_dup 4))]\n   \"\"\n   \"\")\n \f\n@@ -3410,9 +3501,10 @@\n \n \t  rtx temp1 = gen_reg_rtx (DImode);\n \t  rtx temp2 = gen_reg_rtx (DImode);\n-\t  rtx seq = gen_unaligned_loadqi (operands[0],\n-\t\t\t\t\t  get_unaligned_address (operands[1]),\n-\t\t\t\t\t  temp1, temp2);\n+\t  rtx seq\n+\t    = gen_unaligned_loadqi (operands[0],\n+\t\t\t\t    get_unaligned_address (operands[1], 0),\n+\t\t\t\t    temp1, temp2);\n \n \t  alpha_set_memflags (seq, operands[1]);\n \t  emit_insn (seq);\n@@ -3446,7 +3538,8 @@\n \t  rtx temp1 = gen_reg_rtx (DImode);\n \t  rtx temp2 = gen_reg_rtx (DImode);\n \t  rtx temp3 = gen_reg_rtx (DImode);\n-\t  rtx seq = gen_unaligned_storeqi (get_unaligned_address (operands[0]),\n+\t  rtx seq\n+\t    = gen_unaligned_storeqi (get_unaligned_address (operands[0], 0),\n \t\t\t\t\t   operands[1], temp1, temp2, temp3);\n \n \t  alpha_set_memflags (seq, operands[0]);\n@@ -3494,16 +3587,16 @@\n \t}\n       else\n \t{\n-\t  rtx addr\n-\t    = force_reg (DImode,\n-\t\t\t force_operand (get_unaligned_address (operands[1]),\n-\t\t\t\t\tNULL_RTX));\n-\t  rtx scratch1 = gen_reg_rtx (DImode);\n-\t  rtx scratch2 = gen_reg_rtx (DImode);\n-\t  rtx scratch3 = gen_reg_rtx (DImode);\n+\t  /* Don't pass these as parameters since that makes the generated\n+\t     code depend on parameter evaluation order which will cause\n+\t     bootstrap failures.  */\n \n-\t  rtx seq = gen_unaligned_loadhi (operands[0], addr, scratch1,\n-\t\t\t\t\t  scratch2, scratch3);\n+\t  rtx temp1 = gen_reg_rtx (DImode);\n+\t  rtx temp2 = gen_reg_rtx (DImode);\n+\t  rtx seq\n+\t    = gen_unaligned_loadhi (operands[0],\n+\t\t\t\t    get_unaligned_address (operands[1], 0),\n+\t\t\t\t    temp1, temp2);\n \n \t  alpha_set_memflags (seq, operands[1]);\n \t  emit_insn (seq);\n@@ -3537,17 +3630,9 @@\n \t  rtx temp1 = gen_reg_rtx (DImode);\n \t  rtx temp2 = gen_reg_rtx (DImode);\n \t  rtx temp3 = gen_reg_rtx (DImode);\n-\t  rtx temp4 = gen_reg_rtx (DImode);\n-\t  rtx temp5 = gen_reg_rtx (DImode);\n-\t  rtx temp6 = gen_reg_rtx (DImode);\n-\t  rtx temp7 = gen_reg_rtx (DImode);\n-\t  rtx temp8 = gen_reg_rtx (DImode);\n-\t  rtx temp9 = gen_reg_rtx (DImode);\n-\n-\t  rtx seq = gen_unaligned_storehi (get_unaligned_address (operands[0]),\n-\t\t\t\t\t   operands[1], temp1, temp2,temp3,\n-\t\t\t\t\t   temp4, temp5, temp6,temp7,\n-\t\t\t\t\t   temp8, temp9);\n+\t  rtx seq\n+\t    = gen_unaligned_storehi (get_unaligned_address (operands[0], 0),\n+\t\t\t\t     operands[1], temp1, temp2, temp3);\n \n \t  alpha_set_memflags (seq, operands[0]);\n \t  emit_insn (seq);\n@@ -3568,7 +3653,7 @@\n   \"\"\n   \"\n { extern rtx get_unaligned_address ();\n-  rtx addr = get_unaligned_address (operands[1]);\n+  rtx addr = get_unaligned_address (operands[1], 0);\n   /* It is possible that one of the registers we got for operands[2]\n      might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n@@ -3590,18 +3675,16 @@\n   \"\"\n   \"\n { extern rtx get_unaligned_address ();\n-  rtx addr = get_unaligned_address (operands[1]);\n-  rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n-  rtx scratch2 = gen_rtx (REG, DImode, REGNO (operands[2]) + 1);\n-  rtx seq;\n+  rtx addr = get_unaligned_address (operands[1], 0);\n+  /* It is possible that one of the registers we got for operands[2]\n+     might coincide with that of operands[0] (which is why we made\n+     it TImode).  Pick the other one to use as our scratch.  */\n+  rtx scratch = gen_rtx (REG, DImode,\n+\t\t\t REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t\t ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n+  rtx seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n+\t\t\t\t  gen_rtx (REG, DImode, REGNO (operands[0])));\n \n-  if (GET_CODE (addr) != REG)\n-    {\n-      emit_insn (gen_rtx (SET, VOIDmode, scratch2, addr));\n-      addr = scratch2;\n-    }\n-      \n-  seq = gen_unaligned_loadhi (operands[0], addr, scratch1, scratch1, scratch2);\n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n   DONE;\n@@ -3628,7 +3711,7 @@\n     }\n   else\n     {\n-      rtx addr = get_unaligned_address (operands[0]);\n+      rtx addr = get_unaligned_address (operands[0], 0);\n       rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n       rtx scratch2 = gen_rtx (REG, DImode, REGNO (operands[2]) + 1);\n       rtx scratch3 = scratch1;\n@@ -3667,16 +3750,17 @@\n     }\n   else\n     {\n-      rtx addr = get_unaligned_address (operands[0]);\n+      rtx addr = get_unaligned_address (operands[0], 0);\n       rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n       rtx scratch2 = gen_rtx (REG, DImode, REGNO (operands[2]) + 1);\n-      rtx scratch_a = GET_CODE (addr) == REG ? addr : scratch1;\n+      rtx scratch3 = scratch1;\n       rtx seq;\n \n-      seq = gen_unaligned_storehi (addr, operands[1], scratch_a,\n-\t\t\t\t   scratch2, scratch2, scratch2,\n-\t\t\t\t   scratch1, scratch2, scratch_a,\n-\t\t\t\t   scratch1, scratch_a);\n+      if (GET_CODE (addr) == REG)\n+\tscratch1 = addr;\n+\n+      seq = gen_unaligned_storehi (addr, operands[1], scratch1,\n+\t\t\t\t   scratch2, scratch3);\n       alpha_set_memflags (seq, operands[0]);\n       emit_insn (seq);\n     }"}]}