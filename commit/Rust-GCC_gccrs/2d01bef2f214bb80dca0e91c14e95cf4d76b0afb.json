{"sha": "2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "node_id": "C_kwDOANBUbNoAKDJkMDFiZWYyZjIxNGJiODBkY2EwZTkxYzE0ZTk1Y2Y0ZDc2YjBhZmI", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-11-03T09:38:21Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-11-03T13:00:46Z"}, "message": "Rename predicate class to ipa_predicate\n\n\tPR bootstrap/102828\n\ngcc/ChangeLog:\n\n\t* ipa-fnsummary.c (edge_predicate_pool): Rename predicate class to ipa_predicate.\n\t(ipa_fn_summary::account_size_time): Likewise.\n\t(edge_set_predicate): Likewise.\n\t(set_hint_predicate): Likewise.\n\t(add_freqcounting_predicate): Likewise.\n\t(evaluate_conditions_for_known_args): Likewise.\n\t(evaluate_properties_for_edge): Likewise.\n\t(remap_freqcounting_preds_after_dup): Likewise.\n\t(ipa_fn_summary_t::duplicate): Likewise.\n\t(set_cond_stmt_execution_predicate): Likewise.\n\t(set_switch_stmt_execution_predicate): Likewise.\n\t(compute_bb_predicates): Likewise.\n\t(will_be_nonconstant_expr_predicate): Likewise.\n\t(will_be_nonconstant_predicate): Likewise.\n\t(phi_result_unknown_predicate): Likewise.\n\t(predicate_for_phi_result): Likewise.\n\t(analyze_function_body): Likewise.\n\t(compute_fn_summary): Likewise.\n\t(summarize_calls_size_and_time): Likewise.\n\t(estimate_calls_size_and_time): Likewise.\n\t(ipa_call_context::estimate_size_and_time): Likewise.\n\t(remap_edge_summaries): Likewise.\n\t(remap_freqcounting_predicate): Likewise.\n\t(ipa_merge_fn_summary_after_inlining): Likewise.\n\t(ipa_update_overall_fn_summary): Likewise.\n\t(read_ipa_call_summary): Likewise.\n\t(inline_read_section): Likewise.\n\t* ipa-fnsummary.h (struct ipa_freqcounting_predicate): Likewise.\n\t* ipa-predicate.c (predicate::add_clause): Likewise.\n\t(ipa_predicate::add_clause): Likewise.\n\t(predicate::or_with): Likewise.\n\t(ipa_predicate::or_with): Likewise.\n\t(predicate::evaluate): Likewise.\n\t(ipa_predicate::evaluate): Likewise.\n\t(predicate::probability): Likewise.\n\t(ipa_predicate::probability): Likewise.\n\t(dump_condition): Likewise.\n\t(dump_clause): Likewise.\n\t(predicate::dump): Likewise.\n\t(ipa_predicate::dump): Likewise.\n\t(predicate::debug): Likewise.\n\t(ipa_predicate::debug): Likewise.\n\t(predicate::remap_after_duplication): Likewise.\n\t(ipa_predicate::remap_after_duplication): Likewise.\n\t(predicate::remap_after_inlining): Likewise.\n\t(ipa_predicate::remap_after_inlining): Likewise.\n\t(predicate::stream_in): Likewise.\n\t(ipa_predicate::stream_in): Likewise.\n\t(predicate::stream_out): Likewise.\n\t(ipa_predicate::stream_out): Likewise.\n\t(add_condition): Likewise.\n\t* ipa-predicate.h (class predicate): Likewise.\n\t(class ipa_predicate): Likewise.\n\t(add_condition): Likewise.", "tree": {"sha": "96326c428ba6b88cbc2dd16fedb033a8144ab749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96326c428ba6b88cbc2dd16fedb033a8144ab749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73658e70d9edfab77d7a50039b3ab7d2be3a41a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73658e70d9edfab77d7a50039b3ab7d2be3a41a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73658e70d9edfab77d7a50039b3ab7d2be3a41a0"}], "stats": {"total": 411, "additions": 208, "deletions": 203}, "files": [{"sha": "2cfa9a6d0e9c45873ddc6bd602a9cdae43375a42", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 119, "deletions": 115, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "patch": "@@ -94,7 +94,7 @@ fast_function_summary <ipa_size_summary *, va_heap> *ipa_size_summaries;\n fast_call_summary <ipa_call_summary *, va_heap> *ipa_call_summaries;\n \n /* Edge predicates goes here.  */\n-static object_allocator<predicate> edge_predicate_pool (\"edge predicates\");\n+static object_allocator<ipa_predicate> edge_predicate_pool (\"edge predicates\");\n \n \n /* Dump IPA hints.  */\n@@ -162,14 +162,14 @@ ipa_dump_hints (FILE *f, ipa_hints hints)\n \n void\n ipa_fn_summary::account_size_time (int size, sreal time,\n-\t\t\t\t   const predicate &exec_pred,\n-\t\t\t\t   const predicate &nonconst_pred_in,\n+\t\t\t\t   const ipa_predicate &exec_pred,\n+\t\t\t\t   const ipa_predicate &nonconst_pred_in,\n \t\t\t\t   bool call)\n {\n   size_time_entry *e;\n   bool found = false;\n   int i;\n-  predicate nonconst_pred;\n+  ipa_predicate nonconst_pred;\n   vec<size_time_entry> *table = call ? &call_size_time_table : &size_time_table;\n \n   if (exec_pred == false)\n@@ -271,7 +271,7 @@ redirect_to_unreachable (struct cgraph_edge *e)\n /* Set predicate for edge E.  */\n \n static void\n-edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n+edge_set_predicate (struct cgraph_edge *e, ipa_predicate *predicate)\n {\n   /* If the edge is determined to be never executed, redirect it\n      to BUILTIN_UNREACHABLE to make it clear to IPA passes the call will\n@@ -301,7 +301,7 @@ edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n /* Set predicate for hint *P.  */\n \n static void\n-set_hint_predicate (predicate **p, predicate new_predicate)\n+set_hint_predicate (ipa_predicate **p, ipa_predicate new_predicate)\n {\n   if (new_predicate == false || new_predicate == true)\n     {\n@@ -324,7 +324,7 @@ set_hint_predicate (predicate **p, predicate new_predicate)\n \n static void\n add_freqcounting_predicate (vec<ipa_freqcounting_predicate, va_gc> **v,\n-\t\t\t    const predicate &new_predicate, sreal add_freq,\n+\t\t\t    const ipa_predicate &new_predicate, sreal add_freq,\n \t\t\t    unsigned max_num_predicates)\n {\n   if (new_predicate == false || new_predicate == true)\n@@ -372,8 +372,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    clause_t *ret_clause,\n \t\t\t\t    clause_t *ret_nonspec_clause)\n {\n-  clause_t clause = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n-  clause_t nonspec_clause = 1 << predicate::not_inlined_condition;\n+  clause_t clause = inline_p ? 0 : 1 << ipa_predicate::not_inlined_condition;\n+  clause_t nonspec_clause = 1 << ipa_predicate::not_inlined_condition;\n   class ipa_fn_summary *info = ipa_fn_summaries->get (node);\n   int i;\n   struct condition *c;\n@@ -396,7 +396,7 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n       if (c->agg_contents)\n \t{\n-\t  if (c->code == predicate::changed\n+\t  if (c->code == ipa_predicate::changed\n \t      && !c->by_ref\n \t      && (avals->safe_sval_at(c->operand_num) == error_mark_node))\n \t    continue;\n@@ -413,27 +413,28 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       else\n \t{\n \t  val = avals->safe_sval_at (c->operand_num);\n-\t  if (val && val == error_mark_node && c->code != predicate::changed)\n+\t  if (val && val == error_mark_node\n+\t      && c->code != ipa_predicate::changed)\n \t    val = NULL_TREE;\n \t}\n \n       if (!val\n-\t  && (c->code == predicate::changed\n-\t      || c->code == predicate::is_not_constant))\n+\t  && (c->code == ipa_predicate::changed\n+\t      || c->code == ipa_predicate::is_not_constant))\n \t{\n-\t  clause |= 1 << (i + predicate::first_dynamic_condition);\n-\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t  clause |= 1 << (i + ipa_predicate::first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + ipa_predicate::first_dynamic_condition);\n \t  continue;\n \t}\n-      if (c->code == predicate::changed)\n+      if (c->code == ipa_predicate::changed)\n \t{\n-\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + ipa_predicate::first_dynamic_condition);\n \t  continue;\n \t}\n \n-      if (c->code == predicate::is_not_constant)\n+      if (c->code == ipa_predicate::is_not_constant)\n \t{\n-\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + ipa_predicate::first_dynamic_condition);\n \t  continue;\n \t}\n \n@@ -472,8 +473,9 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t    continue;\n \t  if (res && integer_onep (res))\n \t    {\n-\t      clause |= 1 << (i + predicate::first_dynamic_condition);\n-\t      nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t      clause |= 1 << (i + ipa_predicate::first_dynamic_condition);\n+\t      nonspec_clause\n+\t\t|= 1 << (i + ipa_predicate::first_dynamic_condition);\n \t      continue;\n \t    }\n \t}\n@@ -528,8 +530,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t    }\n \t}\n \n-      clause |= 1 << (i + predicate::first_dynamic_condition);\n-      nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n+      clause |= 1 << (i + ipa_predicate::first_dynamic_condition);\n+      nonspec_clause |= 1 << (i + ipa_predicate::first_dynamic_condition);\n     }\n   *ret_clause = clause;\n   if (ret_nonspec_clause)\n@@ -587,7 +589,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n   class ipa_edge_args *args;\n \n   if (clause_ptr)\n-    *clause_ptr = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n+    *clause_ptr = inline_p ? 0 : 1 << ipa_predicate::not_inlined_condition;\n \n   if (ipa_node_params_sum\n       && !e->call_stmt_cannot_inline_p\n@@ -785,7 +787,7 @@ remap_freqcounting_preds_after_dup (vec<ipa_freqcounting_predicate, va_gc> *v,\n   int len = res->length();\n   for (int i = len - 1; i >= 0; i--)\n     {\n-      predicate new_predicate\n+      ipa_predicate new_predicate\n \t= (*res)[i].predicate->remap_after_duplication (possible_truths);\n       /* We do not want to free previous predicate; it is used by node\n \t origin.  */\n@@ -823,7 +825,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       int count = ipa_get_param_count (parms_info);\n       int i, j;\n       clause_t possible_truths;\n-      predicate true_pred = true;\n+      ipa_predicate true_pred = true;\n       size_time_entry *e;\n       int optimized_out_size = 0;\n       bool inlined_to_p = false;\n@@ -860,8 +862,8 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n          to be true.  */\n       for (i = 0; src_info->size_time_table.iterate (i, &e); i++)\n \t{\n-\t  predicate new_exec_pred;\n-\t  predicate new_nonconst_pred;\n+\t  ipa_predicate new_exec_pred;\n+\t  ipa_predicate new_nonconst_pred;\n \t  new_exec_pred = e->exec_predicate.remap_after_duplication\n \t\t\t\t (possible_truths);\n \t  new_nonconst_pred = e->nonconst_predicate.remap_after_duplication\n@@ -877,7 +879,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n          Also copy constantness arrays.   */\n       for (edge = dst->callees; edge; edge = next)\n \t{\n-\t  predicate new_predicate;\n+\t  ipa_predicate new_predicate;\n \t  class ipa_call_summary *es = ipa_call_summaries->get (edge);\n \t  next = edge->next_callee;\n \n@@ -896,7 +898,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n          Also copy constantness arrays.   */\n       for (edge = dst->indirect_calls; edge; edge = next)\n \t{\n-\t  predicate new_predicate;\n+\t  ipa_predicate new_predicate;\n \t  class ipa_call_summary *es = ipa_call_summaries->get (edge);\n \t  next = edge->next_callee;\n \n@@ -944,13 +946,13 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       ipa_freqcounting_predicate *f;\n       for (int i = 0; vec_safe_iterate (info->loop_iterations, i, &f); i++)\n \t{\n-\t  predicate p = *f->predicate;\n+\t  ipa_predicate p = *f->predicate;\n \t  f->predicate = NULL;\n \t  set_hint_predicate (&f->predicate, p);\n \t}\n       for (int i = 0; vec_safe_iterate (info->loop_strides, i, &f); i++)\n \t{\n-\t  predicate p = *f->predicate;\n+\t  ipa_predicate p = *f->predicate;\n \t  f->predicate = NULL;\n \t  set_hint_predicate (&f->predicate, p);\n \t}\n@@ -1609,12 +1611,12 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t  if (this_code != ERROR_MARK\n \t      && !dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n \t    {\n-\t      predicate p\n+\t      ipa_predicate p\n \t\t= add_condition (summary, params_summary, index,\n \t\t\t       \t param_type, &aggpos,\n \t\t\t\t this_code, gimple_cond_rhs (last), param_ops);\n \t      e->aux = edge_predicate_pool.allocate ();\n-\t      *(predicate *) e->aux = p;\n+\t      *(ipa_predicate *) e->aux = p;\n \t    }\n \t}\n       vec_free (param_ops);\n@@ -1646,11 +1648,11 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n     add_builtin_constant_p_parm (summary, index);\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n-      predicate p = add_condition (summary, params_summary, index,\n+      ipa_predicate p = add_condition (summary, params_summary, index,\n \t\t     \t\t   param_type, &aggpos,\n-\t\t\t\t   predicate::is_not_constant, NULL_TREE);\n+\t\t\t\t   ipa_predicate::is_not_constant, NULL_TREE);\n       e->aux = edge_predicate_pool.allocate ();\n-      *(predicate *) e->aux = p;\n+      *(ipa_predicate *) e->aux = p;\n     }\n }\n \n@@ -1701,7 +1703,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       e->aux = edge_predicate_pool.allocate ();\n-      *(predicate *) e->aux = false;\n+      *(ipa_predicate *) e->aux = false;\n     }\n \n   e = gimple_switch_edge (cfun, last, 0);\n@@ -1718,7 +1720,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       tree cl = gimple_switch_label (last, case_idx);\n       tree min = CASE_LOW (cl);\n       tree max = CASE_HIGH (cl);\n-      predicate p;\n+      ipa_predicate p;\n \n       e = gimple_switch_edge (cfun, last, case_idx);\n \n@@ -1742,15 +1744,15 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t           &aggpos, EQ_EXPR, min, param_ops);\n       else\n \t{\n-\t  predicate p1, p2;\n+\t  ipa_predicate p1, p2;\n \t  p1 = add_condition (summary, params_summary, index, param_type,\n \t\t\t      &aggpos, GE_EXPR, min, param_ops);\n \t  p2 = add_condition (summary,  params_summary,index, param_type,\n \t\t\t      &aggpos, LE_EXPR, max, param_ops);\n \t  p = p1 & p2;\n \t}\n-      *(class predicate *) e->aux\n-\t= p.or_with (summary->conds, *(class predicate *) e->aux);\n+      *(ipa_predicate *) e->aux\n+\t= p.or_with (summary->conds, *(ipa_predicate *) e->aux);\n \n       /* If there are too many disjoint case ranges, predicate for default\n \t case might become too complicated.  So add a limit here.  */\n@@ -1796,13 +1798,13 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   e = gimple_switch_edge (cfun, last, 0);\n   if (bound_count > bound_limit)\n     {\n-      *(class predicate *) e->aux = true;\n+      *(ipa_predicate *) e->aux = true;\n       vec_free (param_ops);\n       return;\n     }\n \n-  predicate p_seg = true;\n-  predicate p_all = false;\n+  ipa_predicate p_seg = true;\n+  ipa_predicate p_all = false;\n \n   if (vr_type != VR_RANGE)\n     {\n@@ -1857,8 +1859,8 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n     }\n \n   p_all = p_all.or_with (summary->conds, p_seg);\n-  *(class predicate *) e->aux\n-    = p_all.or_with (summary->conds, *(class predicate *) e->aux);\n+  *(ipa_predicate *) e->aux\n+    = p_all.or_with (summary->conds, *(ipa_predicate *) e->aux);\n \n   vec_free (param_ops);\n }\n@@ -1886,7 +1888,7 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n   /* Entry block is always executable.  */\n   ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux\n     = edge_predicate_pool.allocate ();\n-  *(predicate *) ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux = true;\n+  *(ipa_predicate *) ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux = true;\n \n   /* A simple dataflow propagation of predicates forward in the CFG.\n      TODO: work in reverse postorder.  */\n@@ -1895,17 +1897,17 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n       done = true;\n       FOR_EACH_BB_FN (bb, my_function)\n \t{\n-\t  predicate p = false;\n+\t  ipa_predicate p = false;\n \t  edge e;\n \t  edge_iterator ei;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n \t      if (e->src->aux)\n \t\t{\n-\t\t  predicate this_bb_predicate\n-\t\t    = *(predicate *) e->src->aux;\n+\t\t  ipa_predicate this_bb_predicate\n+\t\t    = *(ipa_predicate *) e->src->aux;\n \t\t  if (e->aux)\n-\t\t    this_bb_predicate &= (*(class predicate *) e->aux);\n+\t\t    this_bb_predicate &= (*(ipa_predicate *) e->aux);\n \t\t  p = p.or_with (summary->conds, this_bb_predicate);\n \t\t  if (p == true)\n \t\t    break;\n@@ -1919,18 +1921,18 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t{\n \t\t  done = false;\n \t\t  bb->aux = edge_predicate_pool.allocate ();\n-\t\t  *((predicate *) bb->aux) = p;\n+\t\t  *((ipa_predicate *) bb->aux) = p;\n \t\t}\n-\t      else if (p != *(predicate *) bb->aux)\n+\t      else if (p != *(ipa_predicate *) bb->aux)\n \t\t{\n \t\t  /* This OR operation is needed to ensure monotonous data flow\n \t\t     in the case we hit the limit on number of clauses and the\n \t\t     and/or operations above give approximate answers.  */\n-\t\t  p = p.or_with (summary->conds, *(predicate *)bb->aux);\n-\t          if (p != *(predicate *) bb->aux)\n+\t\t  p = p.or_with (summary->conds, *(ipa_predicate *)bb->aux);\n+\t\t  if (p != *(ipa_predicate *)bb->aux)\n \t\t    {\n \t\t      done = false;\n-\t\t      *((predicate *) bb->aux) = p;\n+\t\t      *((ipa_predicate *)bb->aux) = p;\n \t\t    }\n \t\t}\n \n@@ -1950,15 +1952,16 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t{\n \t\t  done = false;\n \t\t  pdom_bb->aux = edge_predicate_pool.allocate ();\n-\t\t  *((predicate *) pdom_bb->aux) = p;\n+\t\t  *((ipa_predicate *)pdom_bb->aux) = p;\n \t\t}\n-\t      else if (p != *(predicate *) pdom_bb->aux)\n+\t      else if (p != *(ipa_predicate *)pdom_bb->aux)\n \t\t{\n-\t\t  p = p.or_with (summary->conds, *(predicate *)pdom_bb->aux);\n-\t\t  if (p != *(predicate *) pdom_bb->aux)\n+\t\t  p = p.or_with (summary->conds,\n+\t\t\t\t *(ipa_predicate *)pdom_bb->aux);\n+\t\t  if (p != *(ipa_predicate *)pdom_bb->aux)\n \t\t    {\n \t\t      done = false;\n-\t\t      *((predicate *) pdom_bb->aux) = p;\n+\t\t      *((ipa_predicate *)pdom_bb->aux) = p;\n \t\t    }\n \t\t}\n \t    }\n@@ -1970,12 +1973,12 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n /* Return predicate specifying when the STMT might have result that is not\n    a compile time constant.  */\n \n-static predicate\n+static ipa_predicate\n will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n \t\t\t\t    class ipa_fn_summary *summary,\n \t\t\t\t    class ipa_node_params *params_summary,\n \t\t\t\t    tree expr,\n-\t\t\t\t    vec<predicate> nonconstant_names)\n+\t\t\t\t    vec<ipa_predicate> nonconstant_names)\n {\n   tree parm;\n   int index;\n@@ -1986,22 +1989,22 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n   parm = unmodified_parm (fbi, NULL, expr, NULL);\n   if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n     return add_condition (summary, params_summary, index, TREE_TYPE (parm), NULL,\n-\t\t\t  predicate::changed, NULL_TREE);\n+\t\t\t  ipa_predicate::changed, NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n     return false;\n   if (TREE_CODE (expr) == SSA_NAME)\n     return nonconstant_names[SSA_NAME_VERSION (expr)];\n   if (BINARY_CLASS_P (expr) || COMPARISON_CLASS_P (expr))\n     {\n-      predicate p1\n+      ipa_predicate p1\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n \t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 0),\n \t\t\t\t\t      nonconstant_names);\n       if (p1 == true)\n \treturn p1;\n \n-      predicate p2\n+      ipa_predicate p2\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n \t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 1),\n@@ -2010,15 +2013,15 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n     }\n   else if (TREE_CODE (expr) == COND_EXPR)\n     {\n-      predicate p1\n+      ipa_predicate p1\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n \t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 0),\n \t\t\t\t\t      nonconstant_names);\n       if (p1 == true)\n \treturn p1;\n \n-      predicate p2\n+      ipa_predicate p2\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n \t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 1),\n@@ -2046,18 +2049,18 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n /* Return predicate specifying when the STMT might have result that is not\n    a compile time constant.  */\n \n-static predicate\n+static ipa_predicate\n will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \t\t\t       class ipa_fn_summary *summary,\n \t\t\t       class ipa_node_params *params_summary,\n \t\t\t       gimple *stmt,\n-\t\t\t       vec<predicate> nonconstant_names)\n+\t\t\t       vec<ipa_predicate> nonconstant_names)\n {\n-  predicate p = true;\n+  ipa_predicate p = true;\n   ssa_op_iter iter;\n   tree use;\n   tree param_type = NULL_TREE;\n-  predicate op_non_const;\n+  ipa_predicate op_non_const;\n   bool is_load;\n   int base_index;\n   struct agg_position_info aggpos;\n@@ -2109,7 +2112,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n     op_non_const =\n       add_condition (summary, params_summary,\n \t\t     base_index, param_type, &aggpos,\n-\t\t     predicate::changed, NULL_TREE);\n+\t\t     ipa_predicate::changed, NULL_TREE);\n   else\n     op_non_const = false;\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n@@ -2122,7 +2125,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \t  if (index != base_index)\n \t    p = add_condition (summary, params_summary, index,\n \t\t\t       TREE_TYPE (parm), NULL,\n-\t\t\t       predicate::changed, NULL_TREE);\n+\t\t\t       ipa_predicate::changed, NULL_TREE);\n \t  else\n \t    continue;\n \t}\n@@ -2315,8 +2318,8 @@ phi_result_unknown_predicate (ipa_func_body_info *fbi,\n \t\t\t      ipa_fn_summary *summary,\n \t\t\t      class ipa_node_params *params_summary,\n \t\t\t      basic_block bb,\n-\t\t\t      predicate *p,\n-\t\t\t      vec<predicate> nonconstant_names)\n+\t\t\t      ipa_predicate *p,\n+\t\t\t      vec<ipa_predicate> nonconstant_names)\n {\n   edge e;\n   edge_iterator ei;\n@@ -2374,8 +2377,8 @@ phi_result_unknown_predicate (ipa_func_body_info *fbi,\n \n static void\n predicate_for_phi_result (class ipa_fn_summary *summary, gphi *phi,\n-\t\t\t  predicate *p,\n-\t\t\t  vec<predicate> nonconstant_names)\n+\t\t\t  ipa_predicate *p,\n+\t\t\t  vec<ipa_predicate> nonconstant_names)\n {\n   unsigned i;\n \n@@ -2607,9 +2610,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n   ipa_node_params *params_summary\n     = early ? NULL : ipa_node_params_sum->get (node);\n-  predicate bb_predicate;\n+  ipa_predicate bb_predicate;\n   struct ipa_func_body_info fbi;\n-  vec<predicate> nonconstant_names = vNULL;\n+  vec<ipa_predicate> nonconstant_names = vNULL;\n   int nblocks, n;\n   int *order;\n   gimple *fix_builtin_expect_stmt;\n@@ -2664,7 +2667,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   bb_predicate = true;\n   info->account_size_time (0, 0, bb_predicate, bb_predicate);\n \n-  bb_predicate = predicate::not_inlined ();\n+  bb_predicate = ipa_predicate::not_inlined ();\n   info->account_size_time (opt_for_fn (node->decl,\n \t\t\t\tparam_uninlined_function_insns)\n \t\t\t   * ipa_fn_summary::size_scale,\n@@ -2695,7 +2698,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n       if (fbi.info)\n \t{\n \t  if (bb->aux)\n-\t    bb_predicate = *(predicate *) bb->aux;\n+\t    bb_predicate = *(ipa_predicate *)bb->aux;\n \t  else\n \t    bb_predicate = false;\n \t}\n@@ -2710,7 +2713,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \n       if (fbi.info && nonconstant_names.exists ())\n \t{\n-\t  predicate phi_predicate;\n+\t  ipa_predicate phi_predicate;\n \t  bool first_phi = true;\n \n \t  for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n@@ -2743,7 +2746,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  int this_size = estimate_num_insns (stmt, &eni_size_weights);\n \t  int this_time = estimate_num_insns (stmt, &eni_time_weights);\n \t  int prob;\n-\t  predicate will_be_nonconstant;\n+\t  ipa_predicate will_be_nonconstant;\n \n           /* This relation stmt should be folded after we remove\n              __builtin_expect call. Adjust the cost here.  */\n@@ -2776,7 +2779,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t  && gimple_call_lhs (stmt)\n \t\t  && TREE_CODE (gimple_call_lhs (stmt)) == SSA_NAME)\n \t\t{\n-\t\t  predicate false_p = false;\n+\t\t  ipa_predicate false_p = false;\n \t\t  nonconstant_names[SSA_NAME_VERSION (gimple_call_lhs (stmt))]\n \t\t    = false_p;\n \t\t}\n@@ -2853,7 +2856,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\t\\tWill be eliminated by inlining\\n\");\n \n-\t      class predicate p = bb_predicate & will_be_nonconstant;\n+\t      ipa_predicate p = bb_predicate & will_be_nonconstant;\n \n \t      /* We can ignore statement when we proved it is never going\n \t\t to happen, but we cannot do that for call statements\n@@ -2872,7 +2875,8 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t{\n \t\t  if (prob)\n \t\t    {\n-\t\t      predicate ip = bb_predicate & predicate::not_inlined ();\n+\t\t      ipa_predicate ip\n+\t\t\t= bb_predicate & ipa_predicate::not_inlined ();\n \t\t      info->account_size_time (this_size * prob,\n \t\t\t\t\t       (final_time * prob) / 2, ip,\n \t\t\t\t\t       p);\n@@ -2902,7 +2906,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t     || TREE_CODE (op) == ARRAY_RANGE_REF)\n \t\t    && TREE_CODE (TREE_OPERAND (op, 1)) == SSA_NAME)\n \t\t  {\n-\t\t    predicate p = bb_predicate;\n+\t\t    ipa_predicate p = bb_predicate;\n \t\t    if (fbi.info)\n \t\t      p = p & will_be_nonconstant_expr_predicate\n \t\t\t\t (&fbi, info, params_summary,\n@@ -2939,7 +2943,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n       scev_initialize ();\n       for (auto loop : loops_list (cfun, 0))\n \t{\n-\t  predicate loop_iterations = true;\n+\t  ipa_predicate loop_iterations = true;\n \t  sreal header_freq;\n \t  edge ex;\n \t  unsigned int j;\n@@ -2950,13 +2954,13 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  profile_count phdr_count = loop_preheader_edge (loop)->count ();\n \t  sreal phdr_freq = phdr_count.to_sreal_scale (entry_count);\n \n-\t  bb_predicate = *(predicate *) loop->header->aux;\n+\t  bb_predicate = *(ipa_predicate *)loop->header->aux;\n \t  auto_vec<edge> exits = get_loop_exit_edges (loop);\n \t  FOR_EACH_VEC_ELT (exits, j, ex)\n \t    if (number_of_iterations_exit (loop, ex, &niter_desc, false)\n \t\t&& !is_gimple_min_invariant (niter_desc.niter))\n \t    {\n-\t      predicate will_be_nonconstant\n+\t      ipa_predicate will_be_nonconstant\n \t\t= will_be_nonconstant_expr_predicate (&fbi, info,\n \t\t\t\t\t\t      params_summary,\n \t\t\t\t\t\t      niter_desc.niter,\n@@ -2977,7 +2981,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n       for (loop = loops_for_fn (cfun)->tree_root->inner;\n \t   loop != NULL; loop = loop->next)\n \t{\n-\t  predicate loop_stride = true;\n+\t  ipa_predicate loop_stride = true;\n \t  basic_block *body = get_loop_body (loop);\n \t  profile_count phdr_count = loop_preheader_edge (loop)->count ();\n \t  sreal phdr_freq = phdr_count.to_sreal_scale (entry_count);\n@@ -2987,7 +2991,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t      if (!body[i]->aux)\n \t\tcontinue;\n \n-\t      bb_predicate = *(predicate *) body[i]->aux;\n+\t      bb_predicate = *(ipa_predicate *)body[i]->aux;\n \t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi);\n \t\t   gsi_next (&gsi))\n \t\t{\n@@ -3007,7 +3011,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t      || is_gimple_min_invariant (iv.step))\n \t\t    continue;\n \n-\t\t  predicate will_be_nonconstant\n+\t\t  ipa_predicate will_be_nonconstant\n \t\t    = will_be_nonconstant_expr_predicate (&fbi, info,\n \t\t\t\t    \t\t\t  params_summary,\n \t\t\t\t   \t\t\t  iv.step,\n@@ -3031,12 +3035,12 @@ analyze_function_body (struct cgraph_node *node, bool early)\n       edge_iterator ei;\n \n       if (bb->aux)\n-\tedge_predicate_pool.remove ((predicate *)bb->aux);\n+\tedge_predicate_pool.remove ((ipa_predicate *)bb->aux);\n       bb->aux = NULL;\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->aux)\n-\t    edge_predicate_pool.remove ((predicate *) e->aux);\n+\t    edge_predicate_pool.remove ((ipa_predicate *)e->aux);\n \t  e->aux = NULL;\n \t}\n     }\n@@ -3092,7 +3096,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n   if (node->thunk)\n     {\n       ipa_call_summary *es = ipa_call_summaries->get_create (node->callees);\n-      predicate t = true;\n+      ipa_predicate t = true;\n \n       node->can_change_signature = false;\n       es->call_stmt_size = eni_size_weights.call_cost;\n@@ -3102,7 +3106,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n \t\t\t\t param_uninlined_function_thunk_insns),\n \t\t\t       opt_for_fn (node->decl,\n \t\t\t\t param_uninlined_function_thunk_time), t, t);\n-      t = predicate::not_inlined ();\n+      t = ipa_predicate::not_inlined ();\n       info->account_size_time (2 * ipa_fn_summary::size_scale, 0, t, t);\n       ipa_update_overall_fn_summary (node);\n       size_info->self_size = size_info->size;\n@@ -3335,7 +3339,7 @@ summarize_calls_size_and_time (struct cgraph_node *node,\n \n       estimate_edge_size_and_time (e, &size, NULL, &time, NULL, NULL);\n \n-      struct predicate pred = true;\n+      ipa_predicate pred = true;\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n \n       if (es->predicate)\n@@ -3348,7 +3352,7 @@ summarize_calls_size_and_time (struct cgraph_node *node,\n       sreal time = 0;\n \n       estimate_edge_size_and_time (e, &size, NULL, &time, NULL, NULL);\n-      struct predicate pred = true;\n+      ipa_predicate pred = true;\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n \n       if (es->predicate)\n@@ -3414,7 +3418,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n       /* Build summary if it is absent.  */\n       if (!sum->call_size_time_table.length ())\n \t{\n-\t  predicate true_pred = true;\n+\t  ipa_predicate true_pred = true;\n \t  sum->account_size_time (0, 0, true_pred, true_pred, true);\n \t  summarize_calls_size_and_time (node, sum);\n \t}\n@@ -3712,8 +3716,8 @@ ipa_call_context::estimate_size_and_time (ipa_call_estimates *estimates,\n       fprintf (dump_file, \"   Estimating body: %s\\n\"\n \t       \"   Known to be false: \", m_node->dump_name ());\n \n-      for (i = predicate::not_inlined_condition;\n-\t   i < (predicate::first_dynamic_condition\n+      for (i = ipa_predicate::not_inlined_condition;\n+\t   i < (ipa_predicate::first_dynamic_condition\n \t\t+ (int) vec_safe_length (info->conds)); i++)\n \tif (!(m_possible_truths & (1 << i)))\n \t  {\n@@ -3984,12 +3988,12 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \t\t      const vec<int> &operand_map,\n \t\t      const vec<HOST_WIDE_INT> &offset_map,\n \t\t      clause_t possible_truths,\n-\t\t      predicate *toplev_predicate)\n+\t\t      ipa_predicate *toplev_predicate)\n {\n   struct cgraph_edge *e, *next;\n   for (e = node->callees; e; e = next)\n     {\n-      predicate p;\n+      ipa_predicate p;\n       next = e->next_callee;\n \n       if (e->inline_failed)\n@@ -4018,7 +4022,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n   for (e = node->indirect_calls; e; e = next)\n     {\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n-      predicate p;\n+      ipa_predicate p;\n       next = e->next_callee;\n \n       remap_edge_params (inlined_edge, e);\n@@ -4045,13 +4049,13 @@ remap_freqcounting_predicate (class ipa_fn_summary *info,\n \t\t\t      const vec<int> &operand_map,\n \t\t\t      const vec<HOST_WIDE_INT> &offset_map,\n \t\t\t      clause_t possible_truths,\n-\t\t\t      predicate *toplev_predicate)\n+\t\t\t      ipa_predicate *toplev_predicate)\n \n {\n   ipa_freqcounting_predicate *fcp;\n   for (int i = 0; vec_safe_iterate (v, i, &fcp); i++)\n     {\n-      predicate p\n+      ipa_predicate p\n \t= fcp->predicate->remap_after_inlining (info, params_summary,\n \t\t\t\t\t\tcallee_info, operand_map,\n \t\t\t\t\t\toffset_map, possible_truths,\n@@ -4075,7 +4079,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   auto_vec<int, 8> operand_map;\n   auto_vec<HOST_WIDE_INT, 8> offset_map;\n   int i;\n-  predicate toplev_predicate;\n+  ipa_predicate toplev_predicate;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n   ipa_node_params *params_summary = (ipa_node_params_sum\n \t\t\t\t     ? ipa_node_params_sum->get (to) : NULL);\n@@ -4139,13 +4143,13 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   sreal freq = edge->sreal_frequency ();\n   for (i = 0; callee_info->size_time_table.iterate (i, &e); i++)\n     {\n-      predicate p;\n+      ipa_predicate p;\n       p = e->exec_predicate.remap_after_inlining\n \t\t\t     (info, params_summary,\n \t\t\t      callee_info, operand_map,\n \t\t\t      offset_map, clause,\n \t\t\t      toplev_predicate);\n-      predicate nonconstp;\n+      ipa_predicate nonconstp;\n       nonconstp = e->nonconst_predicate.remap_after_inlining\n \t\t\t\t     (info, params_summary,\n \t\t\t\t      callee_info, operand_map,\n@@ -4230,7 +4234,7 @@ ipa_update_overall_fn_summary (struct cgraph_node *node, bool reset)\n   if (node->callees || node->indirect_calls)\n     estimate_calls_size_and_time (node, &size_info->size, &info->min_size,\n \t\t\t\t  &info->time, NULL,\n-\t\t\t\t  ~(clause_t) (1 << predicate::false_condition),\n+\t\t\t\t  ~(clause_t) (1 << ipa_predicate::false_condition),\n \t\t\t\t  NULL);\n   size_info->size = RDIV (size_info->size, ipa_fn_summary::size_scale);\n   info->min_size = RDIV (info->min_size, ipa_fn_summary::size_scale);\n@@ -4318,7 +4322,7 @@ read_ipa_call_summary (class lto_input_block *ib, struct cgraph_edge *e,\n {\n   class ipa_call_summary *es = prevails\n \t\t\t\t? ipa_call_summaries->get_create (e) : NULL;\n-  predicate p;\n+  ipa_predicate p;\n   int length, i;\n \n   int size = streamer_read_uhwi (ib);\n@@ -4399,7 +4403,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       lto_symtab_encoder_t encoder;\n       struct bitpack_d bp;\n       struct cgraph_edge *e;\n-      predicate p;\n+      ipa_predicate p;\n \n       index = streamer_read_uhwi (&ib);\n       encoder = file_data->symtab_node_encoder;"}, {"sha": "fdfbd660e70ea49db951c6f91e1f7d0e2aa0380d", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "patch": "@@ -76,11 +76,11 @@ class size_time_entry\n {\n public:\n   /* Predicate for code to be executed.  */\n-  predicate exec_predicate;\n+  ipa_predicate exec_predicate;\n   /* Predicate for value to be constant and optimized out in a specialized copy.\n      When deciding on specialization this makes it possible to see how much\n      the executed code paths will simplify.  */\n-  predicate nonconst_predicate;\n+  ipa_predicate nonconst_predicate;\n   int size;\n   sreal time;\n };\n@@ -114,7 +114,7 @@ struct GTY(()) ipa_freqcounting_predicate\n   /* The described event happens with this frequency... */\n   sreal freq;\n   /* ...when this predicate evaluates to false. */\n-  class predicate * GTY((skip)) predicate;\n+  ipa_predicate * GTY((skip)) predicate;\n };\n \n /* Function inlining information.  */\n@@ -203,7 +203,8 @@ class GTY(()) ipa_fn_summary\n   int scc_no;\n \n   /* Record time and size under given predicates.  */\n-  void account_size_time (int, sreal, const predicate &, const predicate &,\n+  void account_size_time (int, sreal, const ipa_predicate &,\n+\t\t\t  const ipa_predicate &,\n \t\t  \t  bool call = false);\n \n   /* We keep values scaled up, so fractional sizes can be accounted.  */\n@@ -286,7 +287,7 @@ class ipa_call_summary\n   /* Default destructor.  */\n   ~ipa_call_summary ();\n \n-  class predicate *predicate;\n+  ipa_predicate *predicate;\n   /* Vector indexed by parameters.  */\n   vec<inline_param_summary> param;\n   /* Estimated size and time of the call statement.  */"}, {"sha": "48318cc60915458203ffb4c28fb5a79b8f89d9ac", "filename": "gcc/ipa-predicate.c", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "patch": "@@ -69,7 +69,7 @@ expr_eval_ops_equal_p (expr_eval_ops ops1, expr_eval_ops ops2)\n    sane.  */\n \n void\n-predicate::add_clause (conditions conditions, clause_t new_clause)\n+ipa_predicate::add_clause (conditions conditions, clause_t new_clause)\n {\n   int i;\n   int i2;\n@@ -81,7 +81,7 @@ predicate::add_clause (conditions conditions, clause_t new_clause)\n     return;\n \n   /* False clause makes the whole predicate false.  Kill the other variants.  */\n-  if (new_clause == (1 << predicate::false_condition))\n+  if (new_clause == (1 << ipa_predicate::false_condition))\n     {\n       *this = false;\n       return;\n@@ -90,7 +90,7 @@ predicate::add_clause (conditions conditions, clause_t new_clause)\n     return;\n \n   /* No one should be silly enough to add false into nontrivial clauses.  */\n-  gcc_checking_assert (!(new_clause & (1 << predicate::false_condition)));\n+  gcc_checking_assert (!(new_clause & (1 << ipa_predicate::false_condition)));\n \n   /* Look where to insert the new_clause.  At the same time prune out\n      new_clauses of P that are implied by the new new_clause and thus\n@@ -123,13 +123,13 @@ predicate::add_clause (conditions conditions, clause_t new_clause)\n   /* Look for clauses that are obviously true.  I.e.\n      op0 == 5 || op0 != 5.  */\n   if (conditions)\n-    for (c1 = predicate::first_dynamic_condition;\n+    for (c1 = ipa_predicate::first_dynamic_condition;\n \t c1 < num_conditions; c1++)\n       {\n \tcondition *cc1;\n \tif (!(new_clause & (1 << c1)))\n \t  continue;\n-\tcc1 = &(*conditions)[c1 - predicate::first_dynamic_condition];\n+\tcc1 = &(*conditions)[c1 - ipa_predicate::first_dynamic_condition];\n \t/* We have no way to represent !changed and !is_not_constant\n \t   and thus there is no point for looking for them.  */\n \tif (cc1->code == changed || cc1->code == is_not_constant)\n@@ -138,7 +138,7 @@ predicate::add_clause (conditions conditions, clause_t new_clause)\n \t  if (new_clause & (1 << c2))\n \t    {\n \t      condition *cc2 =\n-\t\t&(*conditions)[c2 - predicate::first_dynamic_condition];\n+\t\t&(*conditions)[c2 - ipa_predicate::first_dynamic_condition];\n \t      if (cc1->operand_num == cc2->operand_num\n \t\t  && vrp_operand_equal_p (cc1->val, cc2->val)\n \t\t  && cc2->code != is_not_constant\n@@ -170,8 +170,8 @@ predicate::add_clause (conditions conditions, clause_t new_clause)\n \n /* Do THIS &= P.  */\n \n-predicate &\n-predicate::operator &= (const predicate &p)\n+ipa_predicate &\n+ipa_predicate::operator &= (const ipa_predicate &p)\n {\n   /* Avoid busy work.  */\n   if (p == false || *this == true)\n@@ -184,13 +184,13 @@ predicate::operator &= (const predicate &p)\n \n   int i;\n \n-  /* See how far predicates match.  */\n+  /* See how far ipa_predicates match.  */\n   for (i = 0; m_clause[i] && m_clause[i] == p.m_clause[i]; i++)\n     {\n       gcc_checking_assert (i < max_clauses);\n     }\n \n-  /* Combine the predicates rest.  */\n+  /* Combine the ipa_predicates rest.  */\n   for (; p.m_clause[i]; i++)\n     {\n       gcc_checking_assert (i < max_clauses);\n@@ -203,9 +203,9 @@ predicate::operator &= (const predicate &p)\n \n /* Return THIS | P2.  */\n \n-predicate\n-predicate::or_with (conditions conditions,\n-\t            const predicate &p) const\n+ipa_predicate\n+ipa_predicate::or_with (conditions conditions,\n+\t\t\tconst ipa_predicate &p) const\n {\n   /* Avoid busy work.  */\n   if (p == false || *this == true || *this == p)\n@@ -214,7 +214,7 @@ predicate::or_with (conditions conditions,\n     return p;\n \n   /* OK, combine the predicates.  */\n-  predicate out = true;\n+  ipa_predicate out = true;\n \n   for (int i = 0; m_clause[i]; i++)\n     for (int j = 0; p.m_clause[j]; j++)\n@@ -230,15 +230,15 @@ predicate::or_with (conditions conditions,\n    if predicate P is known to be false.  */\n \n bool\n-predicate::evaluate (clause_t possible_truths) const\n+ipa_predicate::evaluate (clause_t possible_truths) const\n {\n   int i;\n \n   /* True remains true.  */\n   if (*this == true)\n     return true;\n \n-  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n+  gcc_assert (!(possible_truths & (1 << ipa_predicate::false_condition)));\n \n   /* See if we can find clause we can disprove.  */\n   for (i = 0; m_clause[i]; i++)\n@@ -254,7 +254,7 @@ predicate::evaluate (clause_t possible_truths) const\n    instruction will be recomputed per invocation of the inlined call.  */\n \n int\n-predicate::probability (conditions conds,\n+ipa_predicate::probability (conditions conds,\n \t                clause_t possible_truths,\n \t                vec<inline_param_summary> inline_param_summary) const\n {\n@@ -268,7 +268,7 @@ predicate::probability (conditions conds,\n   if (*this == false)\n     return 0;\n \n-  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n+  gcc_assert (!(possible_truths & (1 << ipa_predicate::false_condition)));\n \n   /* See if we can find clause we can disprove.  */\n   for (i = 0; m_clause[i]; i++)\n@@ -285,11 +285,11 @@ predicate::probability (conditions conds,\n \t  for (i2 = 0; i2 < num_conditions; i2++)\n \t    if ((m_clause[i] & possible_truths) & (1 << i2))\n \t      {\n-\t\tif (i2 >= predicate::first_dynamic_condition)\n+\t\tif (i2 >= ipa_predicate::first_dynamic_condition)\n \t\t  {\n \t\t    condition *c =\n-\t\t      &(*conds)[i2 - predicate::first_dynamic_condition];\n-\t\t    if (c->code == predicate::changed\n+\t\t      &(*conds)[i2 - ipa_predicate::first_dynamic_condition];\n+\t\t    if (c->code == ipa_predicate::changed\n \t\t\t&& (c->operand_num <\n \t\t\t    (int) inline_param_summary.length ()))\n \t\t      {\n@@ -318,13 +318,13 @@ void\n dump_condition (FILE *f, conditions conditions, int cond)\n {\n   condition *c;\n-  if (cond == predicate::false_condition)\n+  if (cond == ipa_predicate::false_condition)\n     fprintf (f, \"false\");\n-  else if (cond == predicate::not_inlined_condition)\n+  else if (cond == ipa_predicate::not_inlined_condition)\n     fprintf (f, \"not inlined\");\n   else\n     {\n-      c = &(*conditions)[cond - predicate::first_dynamic_condition];\n+      c = &(*conditions)[cond - ipa_predicate::first_dynamic_condition];\n       fprintf (f, \"op%i\", c->operand_num);\n       if (c->agg_contents)\n \tfprintf (f, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC \"]\",\n@@ -406,12 +406,12 @@ dump_condition (FILE *f, conditions conditions, int cond)\n \t  fprintf (f, \")\");\n \t}\n \n-      if (c->code == predicate::is_not_constant)\n+      if (c->code == ipa_predicate::is_not_constant)\n \t{\n \t  fprintf (f, \" not constant\");\n \t  return;\n \t}\n-      if (c->code == predicate::changed)\n+      if (c->code == ipa_predicate::changed)\n \t{\n \t  fprintf (f, \" changed\");\n \t  return;\n@@ -432,7 +432,7 @@ dump_clause (FILE *f, conditions conds, clause_t clause)\n   fprintf (f, \"(\");\n   if (!clause)\n     fprintf (f, \"true\");\n-  for (i = 0; i < predicate::num_conditions; i++)\n+  for (i = 0; i < ipa_predicate::num_conditions; i++)\n     if (clause & (1 << i))\n       {\n \tif (found)\n@@ -445,10 +445,10 @@ dump_clause (FILE *f, conditions conds, clause_t clause)\n \n \n /* Dump THIS to F.  CONDS a vector of conditions used when evaluating\n-   predicates.  When NL is true new line is output at the end of dump.  */\n+   ipa_predicates.  When NL is true new line is output at the end of dump.  */\n \n void\n-predicate::dump (FILE *f, conditions conds, bool nl) const\n+ipa_predicate::dump (FILE *f, conditions conds, bool nl) const\n {\n   int i;\n   if (*this == true)\n@@ -466,7 +466,7 @@ predicate::dump (FILE *f, conditions conds, bool nl) const\n \n \n void\n-predicate::debug (conditions conds) const\n+ipa_predicate::debug (conditions conds) const\n {\n   dump (stderr, conds);\n }\n@@ -476,11 +476,11 @@ predicate::debug (conditions conds) const\n    POSSIBLE_TRUTHS is clause of possible truths in the duplicated node,\n    INFO is inline summary of the duplicated node.  */\n \n-predicate\n-predicate::remap_after_duplication (clause_t possible_truths)\n+ipa_predicate\n+ipa_predicate::remap_after_duplication (clause_t possible_truths)\n {\n   int j;\n-  predicate out = true;\n+  ipa_predicate out = true;\n   for (j = 0; m_clause[j]; j++)\n     if (!(possible_truths & m_clause[j]))\n       return false;\n@@ -503,43 +503,42 @@ predicate::remap_after_duplication (clause_t possible_truths)\n    because they might not be preserved (and should be considered offset zero\n    for other purposes).  */\n \n-predicate\n-predicate::remap_after_inlining (class ipa_fn_summary *info,\n+ipa_predicate\n+ipa_predicate::remap_after_inlining (class ipa_fn_summary *info,\n \t\t\t\t class ipa_node_params *params_summary,\n \t\t\t\t class ipa_fn_summary *callee_info,\n \t\t\t\t const vec<int> &operand_map,\n \t\t\t\t const vec<HOST_WIDE_INT> &offset_map,\n \t\t\t\t clause_t possible_truths,\n-\t\t\t\t const predicate &toplev_predicate)\n+\t\t\t\t const ipa_predicate &toplev_predicate)\n {\n   int i;\n-  predicate out = true;\n+  ipa_predicate out = true;\n \n-  /* True predicate is easy.  */\n+  /* True ipa_predicate is easy.  */\n   if (*this == true)\n     return toplev_predicate;\n   for (i = 0; m_clause[i]; i++)\n     {\n       clause_t clause = m_clause[i];\n       int cond;\n-      predicate clause_predicate = false;\n+      ipa_predicate clause_predicate = false;\n \n       gcc_assert (i < max_clauses);\n \n       for (cond = 0; cond < num_conditions; cond++)\n \t/* Do we have condition we can't disprove?   */\n \tif (clause & possible_truths & (1 << cond))\n \t  {\n-\t    predicate cond_predicate;\n+\t    ipa_predicate cond_predicate;\n \t    /* Work out if the condition can translate to predicate in the\n \t       inlined function.  */\n-\t    if (cond >= predicate::first_dynamic_condition)\n+\t    if (cond >= ipa_predicate::first_dynamic_condition)\n \t      {\n \t\tstruct condition *c;\n \n-\t\tc = &(*callee_info->conds)[cond\n-\t\t\t\t\t   -\n-\t\t\t\t\t   predicate::first_dynamic_condition];\n+\t\tint index = cond - ipa_predicate::first_dynamic_condition;\n+\t\tc = &(*callee_info->conds)[index];\n \t\t/* See if we can remap condition operand to caller's operand.\n \t\t   Otherwise give up.  */\n \t\tif (!operand_map.exists ()\n@@ -576,7 +575,7 @@ predicate::remap_after_inlining (class ipa_fn_summary *info,\n \t    /* Fixed conditions remains same, construct single\n \t       condition predicate.  */\n \t    else\n-\t      cond_predicate = predicate::predicate_testing_cond (cond);\n+\t      cond_predicate = ipa_predicate::predicate_testing_cond (cond);\n \t    clause_predicate = clause_predicate.or_with (info->conds,\n \t\t\t\t\t                 cond_predicate);\n \t  }\n@@ -590,7 +589,7 @@ predicate::remap_after_inlining (class ipa_fn_summary *info,\n /* Read predicate from IB.  */\n \n void\n-predicate::stream_in (class lto_input_block *ib)\n+ipa_predicate::stream_in (class lto_input_block *ib)\n {\n   clause_t clause;\n   int k = 0;\n@@ -611,7 +610,7 @@ predicate::stream_in (class lto_input_block *ib)\n /* Write predicate P to OB.  */\n \n void\n-predicate::stream_out (struct output_block *ob)\n+ipa_predicate::stream_out (struct output_block *ob)\n {\n   int j;\n   for (j = 0; m_clause[j]; j++)\n@@ -629,7 +628,7 @@ predicate::stream_out (struct output_block *ob)\n    aggregate it is.  It can be NULL, which means this not a load from an\n    aggregate.  */\n \n-predicate\n+ipa_predicate\n add_condition (class ipa_fn_summary *summary,\n \t       class ipa_node_params *params_summary,\n \t       int operand_num,\n@@ -669,10 +668,10 @@ add_condition (class ipa_fn_summary *summary,\n \t  && c->agg_contents == agg_contents\n \t  && expr_eval_ops_equal_p (c->param_ops, param_ops)\n \t  && (!agg_contents || (c->offset == offset && c->by_ref == by_ref)))\n-\treturn predicate::predicate_testing_cond (i);\n+\treturn ipa_predicate::predicate_testing_cond (i);\n     }\n   /* Too many conditions.  Give up and return constant true.  */\n-  if (i == predicate::num_conditions - predicate::first_dynamic_condition)\n+  if (i == ipa_predicate::num_conditions - ipa_predicate::first_dynamic_condition)\n     return true;\n \n   new_cond.operand_num = operand_num;\n@@ -694,5 +693,5 @@ add_condition (class ipa_fn_summary *summary,\n \n   vec_safe_push (summary->conds, new_cond);\n \n-  return predicate::predicate_testing_cond (i);\n+  return ipa_predicate::predicate_testing_cond (i);\n }"}, {"sha": "190dcedc93f317ab36c44ff27fe9106c2c45f168", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01bef2f214bb80dca0e91c14e95cf4d76b0afb/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=2d01bef2f214bb80dca0e91c14e95cf4d76b0afb", "patch": "@@ -111,7 +111,7 @@ typedef vec<condition, va_gc> *conditions;\n    is not.  */\n \n typedef uint32_t clause_t;\n-class predicate\n+class ipa_predicate\n {\n public:\n   enum predicate_conditions\n@@ -138,7 +138,7 @@ class predicate\n \n \n   /* Initialize predicate either to true of false depending on P.  */\n-  inline predicate (bool p = true)\n+  inline ipa_predicate (bool p = true)\n     {\n       if (p)\n         /* True predicate.  */\n@@ -149,42 +149,42 @@ class predicate\n     }\n \n   /* Sanity check that we do not mix pointers to predicates with predicates.  */\n-  inline predicate (predicate *)\n+  inline ipa_predicate (ipa_predicate *)\n     {\n       gcc_unreachable ();\n     }\n \n   /* Return predicate testing condition I.  */\n-  static inline predicate predicate_testing_cond (int i)\n+  static inline ipa_predicate predicate_testing_cond (int i)\n     {\n-      class predicate p;\n+      ipa_predicate p;\n       p.set_to_cond (i + first_dynamic_condition);\n       return p;\n     }\n \n   /* Return predicate testing that function was not inlined.  */\n-  static predicate not_inlined (void)\n+  static ipa_predicate not_inlined (void)\n     {\n-      class predicate p;\n+      ipa_predicate p;\n       p.set_to_cond (not_inlined_condition);\n       return p;\n     }\n \n-  /* Compute logical and of predicates.  */\n-  predicate & operator &= (const predicate &);\n-  inline predicate operator &(const predicate &p) const\n+  /* Compute logical and of ipa_predicates.  */\n+  ipa_predicate & operator &= (const ipa_predicate &);\n+  inline ipa_predicate operator &(const ipa_predicate &p) const\n     {\n-      predicate ret = *this;\n+      ipa_predicate ret = *this;\n       ret &= p;\n       return ret;\n     }\n \n-  /* Compute logical or of predicates.  This is not operator because\n+  /* Compute logical or of ipa_predicates.  This is not operator because\n      extra parameter CONDITIONS is needed  */\n-  predicate or_with (conditions, const predicate &) const;\n+  ipa_predicate or_with (conditions, const ipa_predicate &) const;\n \n-  /* Return true if predicates are known to be equal.  */\n-  inline bool operator==(const predicate &p2) const\n+  /* Return true if ipa_predicates are known to be equal.  */\n+  inline bool operator==(const ipa_predicate &p2) const\n     {\n       int i;\n       for (i = 0; m_clause[i]; i++)\n@@ -215,7 +215,7 @@ class predicate\n       return false;\n     }\n \n-  inline bool operator!=(const predicate &p2) const\n+  inline bool operator!=(const ipa_predicate &p2) const\n     {\n       return !(*this == p2);\n     }\n@@ -236,18 +236,19 @@ class predicate\n   void dump (FILE *f, conditions, bool nl=true) const;\n   void DEBUG_FUNCTION debug (conditions) const;\n \n-  /* Return predicate equal to THIS after duplication.  */\n-  predicate remap_after_duplication (clause_t);\n+  /* Return ipa_predicate equal to THIS after duplication.  */\n+  ipa_predicate remap_after_duplication (clause_t);\n \n-  /* Return predicate equal to THIS after inlining.  */\n-  predicate remap_after_inlining (class ipa_fn_summary *,\n-\t\t  \t\t  class ipa_node_params *params_summary,\n-\t\t\t          class ipa_fn_summary *,\n-\t\t\t\t  const vec<int> &, const vec<HOST_WIDE_INT> &,\n-\t\t\t\t  clause_t, const predicate &);\n+  /* Return ipa_predicate equal to THIS after inlining.  */\n+  ipa_predicate remap_after_inlining (class ipa_fn_summary *,\n+\t\t\t\t      ipa_node_params *params_summary,\n+\t\t\t\t      ipa_fn_summary *,\n+\t\t\t\t      const vec<int> &,\n+\t\t\t\t      const vec<HOST_WIDE_INT> &,\n+\t\t\t\t      clause_t, const ipa_predicate &);\n \n-  void stream_in (class lto_input_block *);\n-  void stream_out (struct output_block *);\n+  void stream_in (lto_input_block *);\n+  void stream_out (output_block *);\n \n private:\n   static const int max_clauses = 8;\n@@ -264,9 +265,9 @@ class predicate\n };\n \n void dump_condition (FILE *f, conditions conditions, int cond);\n-predicate add_condition (class ipa_fn_summary *summary,\n-\t\t\t class ipa_node_params *params_summary,\n-\t       \t\t int operand_num,\n-\t\t\t tree type, struct agg_position_info *aggpos,\n-\t\t\t enum tree_code code, tree val,\n-\t\t\t expr_eval_ops param_ops = NULL);\n+ipa_predicate add_condition (ipa_fn_summary *summary,\n+\t\t\t     ipa_node_params *params_summary,\n+\t\t\t     int operand_num,\n+\t\t\t     tree type, struct agg_position_info *aggpos,\n+\t\t\t     enum tree_code code, tree val,\n+\t\t\t     expr_eval_ops param_ops = NULL);"}]}