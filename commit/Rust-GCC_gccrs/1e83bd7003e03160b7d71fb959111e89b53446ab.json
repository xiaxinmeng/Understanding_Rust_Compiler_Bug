{"sha": "1e83bd7003e03160b7d71fb959111e89b53446ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU4M2JkNzAwM2UwMzE2MGI3ZDcxZmI5NTkxMTFlODliNTM0NDZhYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-23T13:13:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-23T13:13:23Z"}, "message": "Convert inliner to new param infrastructure\n\n/bin/sh: :q: command not found\nThis patch adds opt_for_fn for all cross module params used by inliner\nso they can be modified at function granuality.  With inlining almost always\nthere are three functions to consider (callee and caller of the inlined edge\nand the outer function caller is inlined to).\n\nI always use the outer function params since that is how local parameters\nbehave.  I hope it is kind of what is also expected in most case: it is better\nto inline agressively into -O3 compiled code rather than inline agressively -O3\nfunctions into their callers.\n\nNew params infrastructure is nice.  One drawback is that is very hard to\nsearch for individual param uses since they all occupy global namespace.\nWith C++ world we had chance to do something like params.param_flag_name\nor params::param_flag_name instead...\n\nBootstrapped/regtested x86_64-linux, comitted.\n\n\t* cif-code.def (MAX_INLINE_INSNS_SINGLE_O2_LIMIT): Remove.\n\t* doc/invoke.texi (max-inline-insns-single-O2,\n\tinline-heuristics-hint-percent-O2, inline-min-speedup-O2,\n\tearly-inlining-insns-O2): Remove documentation.\n\t* ipa-fnsummary.c (analyze_function_body,\n\tcompute_fn_summary): Use opt_for_fn when accessing parameters.\n\t* ipa-inline.c (caller_growth_limits, can_inline_edge_p,\n\tinline_insns_auto, can_inline_edge_by_limits_p,\n\twant_early_inline_function_p, big_speedup_p,\n\twant_inline_small_function_p, want_inline_self_recursive_call_p,\n\trecursive_inlining, compute_max_insns, inline_small_functions):\n\tLikewise.\n\t* opts.c (default_options): Add -O3 defaults for\n\tOPT__param_early_inlining_insns_,\n\tOPT__param_inline_heuristics_hint_percent_,\n\tOPT__param_inline_min_speedup_, OPT__param_max_inline_insns_single_.\n\t* params.opt (-param=early-inlining-insns-O2=,\n\t-param=inline-heuristics-hint-percent-O2=,\n\t-param=inline-min-speedup-O2=, -param=max-inline-insns-single-O2=\n\t-param=early-inlining-insns=, -param=inline-heuristics-hint-percent=,\n\t-param=inline-min-speedup=, -param=inline-unit-growth=,\n\t-param=large-function-growth=, -param=large-stack-frame=,\n\t-param=large-stack-frame-growth=, -param=large-unit-insns=,\n\t-param=max-inline-insns-recursive=,\n\t-param=max-inline-insns-recursive-auto=,\n\t-param=max-inline-insns-single=,\n\t-param=max-inline-insns-size=, -param=max-inline-insns-small=,\n\t-param=max-inline-recursive-depth=,\n\t-param=max-inline-recursive-depth-auto=,\n\t-param=min-inline-recursive-probability=,\n\t-param=partial-inlining-entry-probability=,\n\t-param=uninlined-function-insns=, -param=uninlined-function-time=,\n\t-param=uninlined-thunk-insns=, -param=uninlined-thunk-time=): Add\n\tOptimization.\n\n\t* g++.dg/tree-ssa/pr53844.C: Drop -O2 from param name.\n\t* g++.dg/tree-ssa/pr61034.C: Likewise.\n\t* g++.dg/tree-ssa/pr8781.C: Likewise.\n\t* g++.dg/warn/Wstringop-truncation-1.C: Likewise.\n\t* gcc.dg/ipa/pr63416.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-thread-12.c: Likewise.\n\t* gcc.dg/vect/pr66142.c: Likewise.\n\t* gcc.dg/winline-3.c: Likewise.\n\t* gcc.target/powerpc/pr72804.c: Likewise.\n\nFrom-SVN: r278645", "tree": {"sha": "e47b52701e7f4829f4a54c50e7d9e53e2b27f181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e47b52701e7f4829f4a54c50e7d9e53e2b27f181"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e83bd7003e03160b7d71fb959111e89b53446ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e83bd7003e03160b7d71fb959111e89b53446ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e83bd7003e03160b7d71fb959111e89b53446ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e83bd7003e03160b7d71fb959111e89b53446ab/comments", "author": null, "committer": null, "parents": [{"sha": "9340d34599e6d5e7a6f3614de44b2c578b180c1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9340d34599e6d5e7a6f3614de44b2c578b180c1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9340d34599e6d5e7a6f3614de44b2c578b180c1b"}], "stats": {"total": 96, "additions": 45, "deletions": 51}, "files": [{"sha": "08612e79eb09c6314e0071313cad5102d234e0c2", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e83bd7003e03160b7d71fb959111e89b53446ab/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e83bd7003e03160b7d71fb959111e89b53446ab/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1e83bd7003e03160b7d71fb959111e89b53446ab", "patch": "@@ -178,13 +178,13 @@ caller_growth_limits (struct cgraph_edge *e)\n   if (limit < what_size_info->self_size)\n     limit = what_size_info->self_size;\n \n-  limit += limit * param_large_function_growth / 100;\n+  limit += limit * opt_for_fn (to->decl, param_large_function_growth) / 100;\n \n   /* Check the size after inlining against the function limits.  But allow\n      the function to shrink if it went over the limits by forced inlining.  */\n   newsize = estimate_size_after_inlining (to, e);\n   if (newsize >= ipa_size_summaries->get (what)->size\n-      && newsize > param_large_function_insns\n+      && newsize > opt_for_fn (to->decl, param_large_function_insns)\n       && newsize > limit)\n     {\n       e->inline_failed = CIF_LARGE_FUNCTION_GROWTH_LIMIT;\n@@ -200,7 +200,8 @@ caller_growth_limits (struct cgraph_edge *e)\n      on every invocation of the caller (i.e. its call statement dominates\n      exit block).  We do not track this information, yet.  */\n   stack_size_limit += ((gcov_type)stack_size_limit\n-\t\t       * param_stack_frame_growth / 100);\n+\t\t       * opt_for_fn (to->decl, param_stack_frame_growth)\n+\t\t       / 100);\n \n   inlined_stack = (ipa_get_stack_frame_offset (to)\n \t\t   + outer_info->estimated_self_stack_size\n@@ -213,7 +214,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \t This bit overoptimistically assume that we are good at stack\n \t packing.  */\n       && inlined_stack > ipa_fn_summaries->get (to)->estimated_stack_size\n-      && inlined_stack > param_large_stack_frame)\n+      && inlined_stack > opt_for_fn (to->decl, param_large_stack_frame))\n     {\n       e->inline_failed = CIF_LARGE_STACK_FRAME_GROWTH_LIMIT;\n       return false;\n@@ -395,20 +396,10 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n static int\n inline_insns_single (cgraph_node *n, bool hint)\n {\n-  if (opt_for_fn (n->decl, optimize) >= 3)\n-    {\n-      if (hint)\n-\treturn param_max_inline_insns_single\n-\t       * param_inline_heuristics_hint_percent / 100;\n-      return param_max_inline_insns_single;\n-    }\n-  else\n-    {\n-      if (hint)\n-\treturn param_max_inline_insns_single_o2\n-\t       * param_inline_heuristics_hint_percent_o2 / 100;\n-      return param_max_inline_insns_single_o2;\n-    }\n+  if (hint)\n+    return opt_for_fn (n->decl, param_max_inline_insns_single)\n+\t   * opt_for_fn (n->decl, param_inline_heuristics_hint_percent) / 100;\n+  return opt_for_fn (n->decl, param_max_inline_insns_single);\n }\n \n /* Return inlining_insns_auto limit for function N. If HINT is true\n@@ -419,7 +410,8 @@ inline_insns_auto (cgraph_node *n, bool hint)\n {\n   int max_inline_insns_auto = opt_for_fn (n->decl, param_max_inline_insns_auto);\n   if (hint)\n-    return max_inline_insns_auto * param_inline_heuristics_hint_percent / 100;\n+    return max_inline_insns_auto\n+\t   * opt_for_fn (n->decl, param_inline_heuristics_hint_percent) / 100;\n   return max_inline_insns_auto;\n }\n \n@@ -563,7 +555,7 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t       > opt_for_fn (caller->decl, optimize_size))\n \t{\n \t  int growth = estimate_edge_growth (e);\n-\t  if (growth > param_max_inline_insns_size\n+\t  if (growth > opt_for_fn (caller->decl, param_max_inline_insns_size)\n \t      && (!DECL_DECLARED_INLINE_P (callee->decl)\n \t\t  && growth >= MAX (inline_insns_single (caller, false),\n \t\t\t\t    inline_insns_auto (caller, false))))\n@@ -675,9 +667,7 @@ want_early_inline_function_p (struct cgraph_edge *e)\n       /* First take care of very large functions.  */\n       int min_growth = estimate_min_edge_growth (e), growth = 0;\n       int n;\n-      int early_inlining_insns = opt_for_fn (e->caller->decl, optimize) >= 3\n-\t\t\t\t ? param_early_inlining_insns\n-\t\t\t\t : param_early_inlining_insns_o2;\n+      int early_inlining_insns = param_early_inlining_insns;\n \n       if (min_growth > early_inlining_insns)\n \t{\n@@ -824,9 +814,7 @@ big_speedup_p (struct cgraph_edge *e)\n   cgraph_node *caller = (e->caller->inlined_to\n \t\t\t ? e->caller->inlined_to\n \t\t\t : e->caller);\n-  int limit = opt_for_fn (caller->decl, optimize) >= 3\n-\t      ? param_inline_min_speedup\n-\t      : param_inline_min_speedup_o2;\n+  int limit = opt_for_fn (caller->decl, param_inline_min_speedup);\n \n   if ((time - inlined_time) * 100 > time * limit)\n     return true;\n@@ -841,6 +829,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n {\n   bool want_inline = true;\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n+  cgraph_node *to  = (e->caller->inlined_to\n+\t\t      ? e->caller->inlined_to : e->caller);\n \n   /* Allow this function to be called before can_inline_edge_p,\n      since it's usually cheaper.  */\n@@ -876,9 +866,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t\t    ? CIF_MAX_INLINE_INSNS_SINGLE_LIMIT\n \t\t\t    : CIF_MAX_INLINE_INSNS_AUTO_LIMIT);\n       else\n-\te->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n-\t\t\t      ? CIF_MAX_INLINE_INSNS_SINGLE_O2_LIMIT\n-\t\t\t      : CIF_MAX_INLINE_INSNS_AUTO_LIMIT);\n+\te->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n       want_inline = false;\n     }\n   else\n@@ -890,7 +878,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t\t\t   | INLINE_HINT_loop_iterations\n \t\t\t\t   | INLINE_HINT_loop_stride));\n \n-      if (growth <= param_max_inline_insns_size)\n+      if (growth <= opt_for_fn (to->decl,\n+\t\t\t\tparam_max_inline_insns_size))\n \t;\n       /* Apply param_max_inline_insns_single limit.  Do not do so when\n \t hints suggests that inlining given function is very profitable.\n@@ -902,15 +891,13 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t   || growth >= inline_insns_single (e->caller, true)\n \t\t   || !big_speedup_p (e)))\n \t{\n-\t  if (opt_for_fn (e->caller->decl, optimize) >= 3)\n-            e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n-\t  else\n-            e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_O2_LIMIT;\n+          e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  want_inline = false;\n \t}\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !opt_for_fn (e->caller->decl, flag_inline_functions)\n-\t       && growth >= param_max_inline_insns_small)\n+\t       && growth >= opt_for_fn (to->decl,\n+\t\t\t\t\tparam_max_inline_insns_small))\n \t{\n \t  /* growth_positive_p is expensive, always test it last.  */\n           if (growth >= inline_insns_single (e->caller, false)\n@@ -951,7 +938,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n }\n \n /* EDGE is self recursive edge.\n-   We hand two cases - when function A is inlining into itself\n+   We handle two cases - when function A is inlining into itself\n    or when function A is being inlined into another inliner copy of function\n    A within function B.  \n \n@@ -970,10 +957,12 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   char const *reason = NULL;\n   bool want_inline = true;\n   sreal caller_freq = 1;\n-  int max_depth = param_max_inline_recursive_depth_auto;\n+  int max_depth = opt_for_fn (outer_node->decl,\n+\t\t\t      param_max_inline_recursive_depth_auto);\n \n   if (DECL_DECLARED_INLINE_P (edge->caller->decl))\n-    max_depth = param_max_inline_recursive_depth;\n+    max_depth = opt_for_fn (outer_node->decl,\n+\t\t\t    param_max_inline_recursive_depth);\n \n   if (!edge->maybe_hot_p ())\n     {\n@@ -1035,7 +1024,8 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n     {\n       if (edge->sreal_frequency () * 100\n           <= caller_freq\n-\t     * param_min_inline_recursive_probability)\n+\t     * opt_for_fn (outer_node->decl,\n+\t\t\t   param_min_inline_recursive_probability))\n \t{\n \t  reason = \"frequency of recursive call is too small\";\n \t  want_inline = false;\n@@ -1241,7 +1231,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t      /* ... or when early optimizers decided to split and edge\n \t\t frequency still indicates splitting is a win ... */\n \t      || (callee->split_part && !caller->split_part\n-\t\t  && freq * 100 < param_partial_inlining_entry_probability\n+\t\t  && freq * 100\n+\t\t\t < opt_for_fn (caller->decl,\n+\t\t\t\t       param_partial_inlining_entry_probability)\n \t\t  /* ... and do not overwrite user specified hints.   */\n \t\t  && (!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t\t      || DECL_DECLARED_INLINE_P (caller->decl)))))\n@@ -1599,7 +1591,10 @@ static bool\n recursive_inlining (struct cgraph_edge *edge,\n \t\t    vec<cgraph_edge *> *new_edges)\n {\n-  int limit = param_max_inline_insns_recursive_auto;\n+  cgraph_node *to  = (edge->caller->inlined_to\n+\t\t      ? edge->caller->inlined_to : edge->caller);\n+  int limit = opt_for_fn (to->decl,\n+\t\t\t  param_max_inline_insns_recursive_auto);\n   edge_heap_t heap (sreal::min ());\n   struct cgraph_node *node;\n   struct cgraph_edge *e;\n@@ -1612,7 +1607,7 @@ recursive_inlining (struct cgraph_edge *edge,\n     node = node->inlined_to;\n \n   if (DECL_DECLARED_INLINE_P (node->decl))\n-    limit = param_max_inline_insns_recursive;\n+    limit = opt_for_fn (to->decl, param_max_inline_insns_recursive);\n \n   /* Make sure that function is small enough to be considered for inlining.  */\n   if (estimate_size_after_inlining (node, edge)  >= limit)\n@@ -1735,14 +1730,14 @@ recursive_inlining (struct cgraph_edge *edge,\n    allow the unit to grow.  */\n \n static int\n-compute_max_insns (int insns)\n+compute_max_insns (cgraph_node *node, int insns)\n {\n   int max_insns = insns;\n-  if (max_insns < param_large_unit_insns)\n-    max_insns = param_large_unit_insns;\n+  if (max_insns < opt_for_fn (node->decl, param_large_unit_insns))\n+    max_insns = opt_for_fn (node->decl, param_large_unit_insns);\n \n   return ((int64_t) max_insns\n-\t  * (100 + param_inline_unit_growth) / 100);\n+\t  * (100 + opt_for_fn (node->decl, param_inline_unit_growth)) / 100);\n }\n \n \n@@ -1906,7 +1901,7 @@ inline_small_functions (void)\n   struct cgraph_edge *edge;\n   edge_heap_t edge_heap (sreal::min ());\n   auto_bitmap updated_nodes;\n-  int min_size, max_size;\n+  int min_size;\n   auto_vec<cgraph_edge *> new_indirect_edges;\n   int initial_size = 0;\n   struct cgraph_node **order = XCNEWVEC (cgraph_node *, symtab->cgraph_count);\n@@ -1973,7 +1968,6 @@ inline_small_functions (void)\n \t     initial_size);\n \n   overall_size = initial_size;\n-  max_size = compute_max_insns (overall_size);\n   min_size = overall_size;\n \n   /* Populate the heap with all edges we might inline.  */\n@@ -2141,7 +2135,9 @@ inline_small_functions (void)\n \t    edge_badness (edge, true);\n \t}\n \n-      if (overall_size + growth > max_size\n+      where = edge->caller;\n+\n+      if (overall_size + growth > compute_max_insns (where, min_size)\n \t  && !DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n \t{\n \t  edge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n@@ -2164,7 +2160,6 @@ inline_small_functions (void)\n \t specific inliner.  */\n       if (edge->recursive_p ())\n \t{\n-\t  where = edge->caller;\n \t  if (where->inlined_to)\n \t    where = where->inlined_to;\n \t  if (!recursive_inlining (edge,\n@@ -2278,7 +2273,6 @@ inline_small_functions (void)\n       if (min_size > overall_size)\n \t{\n \t  min_size = overall_size;\n-\t  max_size = compute_max_insns (min_size);\n \n \t  if (dump_file)\n \t    fprintf (dump_file, \"New minimal size reached: %i\\n\", min_size);"}]}