{"sha": "ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNiNjM2NDFmZmFiOWQ5ZTgwODYyMGMyZjZiNjhlYzA4ZTE4OGNmYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-11-27T06:36:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-11-27T06:36:52Z"}, "message": "re PR target/12900 (g++ ICE in rtl_verify_flow_info_1)\n\n\tPR target/12900\n\t* reg-stack (move_for_stack_reg): New prototype.  Return\n\twhether a control flow insn was deleted.\n\t(subst_stack_regs_pat): Likewise, using the information provided\n\tby move_for_stack_reg.\n\t(subst_stack_regs): Likewise, using the information provided\n\tby subst_stack_regs_pat.\n\t(convert_regs_1): Record whether a control flow insn was deleted,\n\tusing the information provided by subst_stack_regs.  Purge dead\n\tedges only if a control flow insn was deleted.\n\nFrom-SVN: r73977", "tree": {"sha": "2399061889033b7aca744577fc2100477d02145f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2399061889033b7aca744577fc2100477d02145f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "316d0b19813c17613fe2dd80f8bba4fd2001eca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/316d0b19813c17613fe2dd80f8bba4fd2001eca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/316d0b19813c17613fe2dd80f8bba4fd2001eca3"}], "stats": {"total": 132, "additions": 97, "deletions": 35}, "files": [{"sha": "419e698e57c31087271b5f738c9a179a36d4450f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "patch": "@@ -1,3 +1,16 @@\n+2003-11-27  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/12900\n+\t* reg-stack (move_for_stack_reg): New prototype.  Return\n+\twhether a control flow insn was deleted.\n+\t(subst_stack_regs_pat): Likewise, using the information provided\n+\tby move_for_stack_reg.\n+\t(subst_stack_regs): Likewise, using the information provided\n+\tby subst_stack_regs_pat.\n+\t(convert_regs_1): Record whether a control flow insn was deleted,\n+\tusing the information provided by subst_stack_regs.  Purge dead\n+\tedges only if a control flow insn was deleted.\n+\n 2003-11-27  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR middle-end/8028"}, {"sha": "fd9bdea96fb6181740ae91e09319c4b08bb4b89a", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "patch": "@@ -249,13 +249,13 @@ static void remove_regno_note (rtx, enum reg_note, unsigned int);\n static int get_hard_regnum (stack, rtx);\n static rtx emit_pop_insn (rtx, stack, rtx, enum emit_where);\n static void emit_swap_insn (rtx, stack, rtx);\n-static void move_for_stack_reg (rtx, stack, rtx);\n+static bool move_for_stack_reg (rtx, stack, rtx);\n static int swap_rtx_condition_1 (rtx);\n static int swap_rtx_condition (rtx);\n static void compare_for_stack_reg (rtx, stack, rtx);\n-static void subst_stack_regs_pat (rtx, stack, rtx);\n+static bool subst_stack_regs_pat (rtx, stack, rtx);\n static void subst_asm_stack_regs (rtx, stack);\n-static void subst_stack_regs (rtx, stack);\n+static bool subst_stack_regs (rtx, stack);\n static void change_stack (rtx, stack, stack, enum emit_where);\n static int convert_regs_entry (void);\n static void convert_regs_exit (void);\n@@ -1028,15 +1028,17 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n }\n \f\n /* Handle a move to or from a stack register in PAT, which is in INSN.\n-   REGSTACK is the current stack.  */\n+   REGSTACK is the current stack.  Return whether a control flow insn\n+   was deleted in the process.  */\n \n-static void\n+static bool\n move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n {\n   rtx *psrc =  get_true_reg (&SET_SRC (pat));\n   rtx *pdest = get_true_reg (&SET_DEST (pat));\n   rtx src, dest;\n   rtx note;\n+  bool control_flow_insn_deleted = false;\n \n   src = *psrc; dest = *pdest;\n \n@@ -1066,21 +1068,17 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n \t     If so, just pop the src.  */\n \n \t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n+\t    emit_pop_insn (insn, regstack, src, EMIT_AFTER);\n+\t  else\n \t    {\n-\t      emit_pop_insn (insn, regstack, src, EMIT_AFTER);\n-\n-\t      delete_insn (insn);\n-\t      return;\n+\t      regstack->reg[i] = REGNO (dest);\n+\t      SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n+\t      CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (src));\n \t    }\n \n-\t  regstack->reg[i] = REGNO (dest);\n-\n-\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n-\t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (src));\n-\n+\t  control_flow_insn_deleted |= control_flow_insn_p (insn);\n \t  delete_insn (insn);\n-\n-\t  return;\n+\t  return control_flow_insn_deleted;\n \t}\n \n       /* The source reg does not die.  */\n@@ -1095,8 +1093,9 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n \t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n \t    emit_pop_insn (insn, regstack, dest, EMIT_AFTER);\n \n+\t  control_flow_insn_deleted |= control_flow_insn_p (insn);\n \t  delete_insn (insn);\n-\t  return;\n+\t  return control_flow_insn_deleted;\n \t}\n \n       /* The destination ought to be dead.  */\n@@ -1165,6 +1164,8 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n     }\n   else\n     abort ();\n+\n+  return control_flow_insn_deleted;\n }\n \f\n /* Swap the condition on a branch, if there is one.  Return true if we\n@@ -1376,12 +1377,14 @@ compare_for_stack_reg (rtx insn, stack regstack, rtx pat_src)\n }\n \f\n /* Substitute new registers in PAT, which is part of INSN.  REGSTACK\n-   is the current register layout.  */\n+   is the current register layout.  Return whether a control flow insn\n+   was deleted in the process.  */\n \n-static void\n+static bool\n subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n {\n   rtx *dest, *src;\n+  bool control_flow_insn_deleted = false;\n \n   switch (GET_CODE (pat))\n     {\n@@ -1393,7 +1396,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t  && find_regno_note (insn, REG_DEAD, REGNO (*src)))\n \t{\n \t  emit_pop_insn (insn, regstack, *src, EMIT_AFTER);\n-\t  return;\n+\t  return control_flow_insn_deleted;\n \t}\n       /* ??? Uninitialized USE should not happen.  */\n       else if (get_hard_regnum (regstack, *src) == -1)\n@@ -1443,7 +1446,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t\t\t       FP_MODE_REG (REGNO (*dest), SFmode),\n \t\t\t\t       nan);\n \t\t    PATTERN (insn) = pat;\n-\t\t    move_for_stack_reg (insn, regstack, pat);\n+\t\t    control_flow_insn_deleted |= move_for_stack_reg (insn, regstack, pat);\n \t\t  }\n \t\tif (! note && COMPLEX_MODE_P (GET_MODE (*dest))\n \t\t    && get_hard_regnum (regstack, FP_MODE_REG (REGNO (*dest), DFmode)) == -1)\n@@ -1452,7 +1455,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t\t\t       FP_MODE_REG (REGNO (*dest) + 1, SFmode),\n \t\t\t\t       nan);\n \t\t    PATTERN (insn) = pat;\n-\t\t    move_for_stack_reg (insn, regstack, pat);\n+\t\t    control_flow_insn_deleted |= move_for_stack_reg (insn, regstack, pat);\n \t\t  }\n \t      }\n \t  }\n@@ -1475,7 +1478,7 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\t&& (GET_CODE (*src) == REG || GET_CODE (*src) == MEM\n \t\t    || GET_CODE (*src) == CONST_DOUBLE)))\n \t  {\n-\t    move_for_stack_reg (insn, regstack, pat);\n+\t    control_flow_insn_deleted |= move_for_stack_reg (insn, regstack, pat);\n \t    break;\n \t  }\n \n@@ -1879,6 +1882,8 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n     default:\n       break;\n     }\n+\n+  return control_flow_insn_deleted;\n }\n \f\n /* Substitute hard regnums for any stack regs in INSN, which has\n@@ -2176,12 +2181,14 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n /* Substitute stack hard reg numbers for stack virtual registers in\n    INSN.  Non-stack register numbers are not changed.  REGSTACK is the\n    current stack content.  Insns may be emitted as needed to arrange the\n-   stack for the 387 based on the contents of the insn.  */\n+   stack for the 387 based on the contents of the insn.  Return whether\n+   a control flow insn was deleted in the process.  */\n \n-static void\n+static bool\n subst_stack_regs (rtx insn, stack regstack)\n {\n   rtx *note_link, note;\n+  bool control_flow_insn_deleted = false;\n   int i;\n \n   if (GET_CODE (insn) == CALL_INSN)\n@@ -2222,25 +2229,27 @@ subst_stack_regs (rtx insn, stack regstack)\n \t     Any REG_UNUSED notes will be handled by subst_asm_stack_regs.  */\n \n \t  subst_asm_stack_regs (insn, regstack);\n-\t  return;\n+\t  return control_flow_insn_deleted;\n \t}\n \n       if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \tfor (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n \t  {\n \t    if (stack_regs_mentioned_p (XVECEXP (PATTERN (insn), 0, i)))\n-\t      subst_stack_regs_pat (insn, regstack,\n-\t\t\t\t    XVECEXP (PATTERN (insn), 0, i));\n+\t      control_flow_insn_deleted\n+\t\t|= subst_stack_regs_pat (insn, regstack,\n+\t\t\t\t\t XVECEXP (PATTERN (insn), 0, i));\n \t  }\n       else\n-\tsubst_stack_regs_pat (insn, regstack, PATTERN (insn));\n+\tcontrol_flow_insn_deleted\n+\t  |= subst_stack_regs_pat (insn, regstack, PATTERN (insn));\n     }\n \n   /* subst_stack_regs_pat may have deleted a no-op insn.  If so, any\n      REG_UNUSED will already have been dealt with, so just return.  */\n \n   if (GET_CODE (insn) == NOTE || INSN_DELETED_P (insn))\n-    return;\n+    return control_flow_insn_deleted;\n \n   /* If there is a REG_UNUSED note on a stack register on this insn,\n      the indicated reg must be popped.  The REG_UNUSED note is removed,\n@@ -2256,6 +2265,8 @@ subst_stack_regs (rtx insn, stack regstack)\n       }\n     else\n       note_link = &XEXP (note, 1);\n+\n+  return control_flow_insn_deleted;\n }\n \f\n /* Change the organization of the stack so that it fits a new basic\n@@ -2638,6 +2649,7 @@ convert_regs_1 (FILE *file, basic_block block)\n   int deleted, inserted, reg;\n   rtx insn, next;\n   edge e, beste = NULL;\n+  bool control_flow_insn_deleted = false;\n \n   inserted = 0;\n   deleted = 0;\n@@ -2726,8 +2738,7 @@ convert_regs_1 (FILE *file, basic_block block)\n \t\t       INSN_UID (insn));\n \t      print_stack (file, &regstack);\n \t    }\n-\t  subst_stack_regs (insn, &regstack);\n-\t  deleted |= (GET_CODE (insn) == NOTE || INSN_DELETED_P (insn));\n+\t  control_flow_insn_deleted |= subst_stack_regs (insn, &regstack);\n \t}\n     }\n   while (next);\n@@ -2766,8 +2777,7 @@ convert_regs_1 (FILE *file, basic_block block)\n \t  set = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, SFmode),\n \t\t\t     nan);\n \t  insn = emit_insn_after (set, insn);\n-\t  subst_stack_regs (insn, &regstack);\n-\t  deleted |= (GET_CODE (insn) == NOTE || INSN_DELETED_P (insn));\n+\t  control_flow_insn_deleted |= subst_stack_regs (insn, &regstack);\n \t}\n     }\n   \n@@ -2777,12 +2787,18 @@ convert_regs_1 (FILE *file, basic_block block)\n      called at the end of convert_regs.  The order in which we process the\n      blocks ensures that we never delete an already processed edge.\n \n+     Note that, at this point, the CFG may have been damaged by the emission\n+     of instructions after an abnormal call, which moves the basic block end\n+     (and is the reason why we call fixup_abnormal_edges later).  So we must\n+     be sure that the trapping insn has been deleted before trying to purge\n+     dead edges, otherwise we risk purging valid edges.\n+\n      ??? We are normally supposed not to delete trapping insns, so we pretend\n      that the insns deleted above don't actually trap.  It would have been\n      better to detect this earlier and avoid creating the EH edge in the first\n      place, still, but we don't have enough information at that time.  */\n \n-  if (deleted)\n+  if (control_flow_insn_deleted)\n     purge_dead_edges (block);\n \n   /* Something failed if the stack lives don't match.  If we had malformed"}, {"sha": "1f516a1e7964ab23cc7b946eeaafbb236afc9cfb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "patch": "@@ -1,3 +1,7 @@\n+2003-11-27  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* g++.dg/opt/reg-stack4.C: New test.\n+\n 2003-11-27  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.dg/builtin-apply2.c: New test."}, {"sha": "7b461d8a6f311465fbdfa7a0a1d67e071959615f", "filename": "gcc/testsuite/g++.dg/opt/reg-stack4.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Freg-stack4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb63641ffab9d9e808620c2f6b68ec08e188cfa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Freg-stack4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Freg-stack4.C?ref=ecb63641ffab9d9e808620c2f6b68ec08e188cfa", "patch": "@@ -0,0 +1,29 @@\n+// PR target/12900\n+// Origin: <snyder@fnal.gov>\n+\n+// This used to fail on x86 because the reg-stack pass\n+// deleted a valid edge.\n+\n+// { dg-do compile }\n+// { dg-options \"-mtune=i586 -O2\" { target i?86-*-* } }\n+\n+struct array {\n+  double data;\n+  virtual ~array();\n+};\n+\n+double glob;\n+double ext1(double);\n+int nmuons;\n+\n+void track_match()\n+{\n+  array vecdca;\n+  if (glob < 10) return;\n+  double p = glob*5;\n+  double phi = vecdca.data;\n+  ext1 (vecdca.data-glob);\n+  ext1 (phi*2);\n+  if (1 < p)\n+    ++nmuons; \n+}"}]}