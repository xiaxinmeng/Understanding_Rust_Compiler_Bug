{"sha": "bdeb029cbced910b00731c41b35b2c98b8791a5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlYjAyOWNiY2VkOTEwYjAwNzMxYzQxYjM1YjJjOThiODc5MWE1Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-12T11:22:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-12T11:22:52Z"}, "message": "i386.c (x86_sub_esp_4, [...]): New global variables.\n\n\t* i386.c (x86_sub_esp_4, x86_sub_esp_8, x86_add_esp_4, x86_add_esp_8):\n\tNew global variables.\n\t(ix86_emit_epilogue_adjustment): Do not attempt to use pop for the\n\tadjustment.\n\t* i386.h (x86_sub_esp_4, x86_sub_esp_8, x86_add_esp_4, x86_add_esp_8):\n\tDeclare,\n\t(TARGET_SUB_ESP_4, TARGET_SUB_ESP_8, TARGET_ADD_ESP_4,\n\t TARGET_ADD_ESP_8): New macros.\n\t* i386.md: Add peep2s to convert esp adjustments to push and pop\n\tinstructions.\n\t(pushsi_prologue, popsi_epilogue): New patterns.\n\nFrom-SVN: r33100", "tree": {"sha": "c2ec02d30e9c730f795ab46e046b1c669c8e1333", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2ec02d30e9c730f795ab46e046b1c669c8e1333"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdeb029cbced910b00731c41b35b2c98b8791a5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdeb029cbced910b00731c41b35b2c98b8791a5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdeb029cbced910b00731c41b35b2c98b8791a5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdeb029cbced910b00731c41b35b2c98b8791a5b/comments", "author": null, "committer": null, "parents": [{"sha": "2fc00b18ec8bc40ac6d42ff9d7798912422e06af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fc00b18ec8bc40ac6d42ff9d7798912422e06af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fc00b18ec8bc40ac6d42ff9d7798912422e06af"}], "stats": {"total": 228, "additions": 184, "deletions": 44}, "files": [{"sha": "6705abd45d98d7640acf1a9eef7407d0c60941f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdeb029cbced910b00731c41b35b2c98b8791a5b", "patch": "@@ -1,3 +1,17 @@\n+Fri Apr  7 12:23:04 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (x86_sub_esp_4, x86_sub_esp_8, x86_add_esp_4, x86_add_esp_8):\n+\tNew global variables.\n+\t(ix86_emit_epilogue_adjustment): Do not attempt to use pop for the\n+\tadjustment.\n+\t* i386.h (x86_sub_esp_4, x86_sub_esp_8, x86_add_esp_4, x86_add_esp_8):\n+\tDeclare,\n+\t(TARGET_SUB_ESP_4, TARGET_SUB_ESP_8, TARGET_ADD_ESP_4,\n+\t TARGET_ADD_ESP_8): New macros.\n+\t* i386.md: Add peep2s to convert esp adjustments to push and pop\n+\tinstructions.\n+\t(pushsi_prologue, popsi_epilogue): New patterns.\n+\n 2000-04-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* real.c (toe64): Remove stale #endif from the last change."}, {"sha": "85a7c6632f0966ff9b144e5f54e8f6f08f493246", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 44, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bdeb029cbced910b00731c41b35b2c98b8791a5b", "patch": "@@ -218,6 +218,10 @@ const int x86_qimode_math = ~(0);\n const int x86_promote_qi_regs = 0;\n const int x86_himode_math = ~(m_PPRO);\n const int x86_promote_hi_regs = m_PPRO;\n+const int x86_sub_esp_4 = m_ATHLON | m_PPRO;\n+const int x86_sub_esp_8 = m_ATHLON | m_PPRO | m_386 | m_486;\n+const int x86_add_esp_4 = m_ATHLON | m_K6;\n+const int x86_add_esp_8 = m_ATHLON | m_PPRO | m_K6 | m_386 | m_486;\n \n #define AT_BP(mode) (gen_rtx_MEM ((mode), hard_frame_pointer_rtx))\n \n@@ -1968,51 +1972,16 @@ static void\n ix86_emit_epilogue_esp_adjustment (tsize)\n      int tsize;\n {\n-  /* Intel's docs say that for 4 or 8 bytes of stack frame one should\n-     use `pop' and not `add'.  */\n-  int use_pop = tsize == 4;\n-  rtx edx = 0, ecx;\n-\n-  /* Use two pops only for the Pentium processors.  */\n-  if (tsize == 8 && !TARGET_386 && !TARGET_486)\n-    {\n-      rtx retval = current_function_return_rtx;\n-\n-      edx = gen_rtx_REG (SImode, 1);\n-\n-      /* This case is a bit more complex.  Since we cannot pop into\n-         %ecx twice we need a second register.  But this is only\n-         available if the return value is not of DImode in which\n-         case the %edx register is not available.  */\n-      use_pop = (retval == NULL\n-\t\t || !reg_overlap_mentioned_p (edx, retval));\n-    }\n-\n-  if (use_pop)\n-    {\n-      ecx = gen_rtx_REG (SImode, 2);\n-\n-      /* We have to prevent the two pops here from being scheduled.\n-         GCC otherwise would try in some situation to put other\n-         instructions in between them which has a bad effect.  */\n-      emit_insn (gen_blockage ());\n-      emit_insn (gen_popsi1 (ecx));\n-      if (tsize == 8)\n-\temit_insn (gen_popsi1 (edx));\n-    }\n+  /* If a frame pointer is present, we must be sure to tie the sp\n+     to the fp so that we don't mis-schedule.  */\n+  if (frame_pointer_needed)\n+    emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      GEN_INT (tsize),\n+\t\t\t\t\t      hard_frame_pointer_rtx));\n   else\n-    {\n-      /* If a frame pointer is present, we must be sure to tie the sp\n-\t to the fp so that we don't mis-schedule.  */\n-      if (frame_pointer_needed)\n-        emit_insn (gen_pro_epilogue_adjust_stack (stack_pointer_rtx,\n-\t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t  GEN_INT (tsize),\n-\t\t\t\t\t\t  hard_frame_pointer_rtx));\n-      else\n-        emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (tsize)));\n-    }\n+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   GEN_INT (tsize)));\n }\n \n /* Emit code to restore saved registers using MOV insns.  First register"}, {"sha": "50f08251420fa9e38c209bd56b24df855442d8a6", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=bdeb029cbced910b00731c41b35b2c98b8791a5b", "patch": "@@ -174,6 +174,7 @@ extern const int x86_read_modify, x86_split_long_moves;\n extern const int x86_promote_QImode, x86_single_stringop;\n extern const int x86_himode_math, x86_qimode_math, x86_promote_qi_regs;\n extern const int x86_promote_hi_regs;\n+extern const int x86_add_esp_4, x86_add_esp_8, x86_sub_esp_4, x86_sub_esp_8;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n #define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n@@ -201,6 +202,10 @@ extern const int x86_promote_hi_regs;\n #define TARGET_HIMODE_MATH (x86_himode_math & CPUMASK)\n #define TARGET_PROMOTE_QI_REGS (x86_promote_qi_regs & CPUMASK)\n #define TARGET_PROMOTE_HI_REGS (x86_promote_hi_regs & CPUMASK)\n+#define TARGET_ADD_ESP_4 (x86_add_esp_4 & CPUMASK)\n+#define TARGET_ADD_ESP_8 (x86_add_esp_8 & CPUMASK)\n+#define TARGET_SUB_ESP_4 (x86_sub_esp_4 & CPUMASK)\n+#define TARGET_SUB_ESP_8 (x86_sub_esp_8 & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n "}, {"sha": "090d0ebd44416f5d0a6cb42bb5cb4f617e66a043", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdeb029cbced910b00731c41b35b2c98b8791a5b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=bdeb029cbced910b00731c41b35b2c98b8791a5b", "patch": "@@ -1307,6 +1307,24 @@\n   \"push{l}\\\\t%1\"\n   [(set_attr \"type\" \"push\")])\n \n+(define_insn \"*pushsi2_prologue\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n+\t(match_operand:SI 1 \"general_no_elim_operand\" \"ri*m\"))\n+   (set (reg:SI 6) (reg:SI 6))]\n+  \"\"\n+  \"push{l}\\\\t%1\"\n+  [(set_attr \"type\" \"push\")])\n+\n+(define_insn \"*popsi1_epilogue\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r*m\")\n+\t(mem:SI (reg:SI 7)))\n+   (set (reg:SI 7)\n+\t(plus:SI (reg:SI 7) (const_int 4)))\n+   (set (reg:SI 6) (reg:SI 6))]\n+  \"\"\n+  \"pop{l}\\\\t%0\"\n+  [(set_attr \"type\" \"pop\")])\n+\n (define_insn \"popsi1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r*m\")\n \t(mem:SI (reg:SI 7)))\n@@ -9752,6 +9770,140 @@\n   [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")\n+\n+;; The ESP adjustments can be done by the push and pop instructions.  Resulting\n+;; code is shorter, since push is only 1 byte, while add imm, %esp 3 bytes.  On\n+;; many CPUs it is also faster, since special hardware to avoid esp\n+;; dependancies is present.\n+\n+;; While some of these converisons may be done using splitters, we use peepholes\n+;; in order to allow combine_stack_adjustments pass to see nonobfuscated RTL.\n+\n+;; Convert prologue esp substractions to push.\n+;; We need register to push.  In order to keep verify_flow_info happy we have\n+;; two choices\n+;; - use scratch and clobber it in order to avoid dependencies\n+;; - use already live register\n+;; We can't use the second way right now, since there is no reliable way how to\n+;; verify that given register is live.  First choice will also most likely in\n+;; fewer dependencies.  On the place of esp adjustments it is very likely that\n+;; call clobbered registers are dead.  We may want to use base pointer as an\n+;; alternative when no register is available later.\n+\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -4)))\n+\t      (set (reg:SI 6) (reg:SI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_4\"\n+  [(clobber (match_dup 0))\n+   (parallel [(set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))\n+\t      (set (reg:SI 6) (reg:SI 6))])])\n+\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -8)))\n+\t      (set (reg:SI 6) (reg:SI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_8\"\n+  [(clobber (match_dup 0))\n+   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))\n+   (parallel [(set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))\n+\t      (set (reg:SI 6) (reg:SI 6))])])\n+\n+;; Convert esp substractions to push.\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -4)))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_4\"\n+  [(clobber (match_dup 0))\n+   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))])\n+\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -8)))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_SUB_ESP_8\"\n+  [(clobber (match_dup 0))\n+   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))\n+   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))])\n+\n+;; Convert epilogue deallocator to pop.\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))\n+\t      (set (reg:SI 6) (reg:SI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_ADD_ESP_4\"\n+  [(parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))\n+\t      (set (reg:SI 6) (reg:SI 6))])]\n+  \"\")\n+\n+;; Two pops case is tricky, since pop causes dependency on destination register.\n+;; We use two registers if available.\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (match_scratch:SI 1 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 8)))\n+\t      (set (reg:SI 6) (reg:SI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size || !TARGET_ADD_ESP_8\"\n+  [(parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))\n+\t      (set (reg:SI 6) (reg:SI 6))])\n+   (parallel [(set (match_dup 1) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 8)))\n+\t      (set (reg:SI 6) (reg:SI 6))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size\"\n+  [(parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))\n+\t      (set (reg:SI 6) (reg:SI 6))])\n+   (parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))])]\n+  \"\")\n+\n+;; Convert esp additions to pop.\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))])]\n+  \"\")\n+\n+;; Two pops case is tricky, since pop causes dependency on destination register.\n+;; We use two registers if available.\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (match_scratch:SI 1 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 8)))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))])\n+   (parallel [(set (match_dup 1) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))])]\n+  \"\")\n+\n+(define_peephole2\n+  [(match_scratch:SI 0 \"r\")\n+   (parallel [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 8)))\n+\t      (clobber (reg:CC 17))])]\n+  \"optimize_size\"\n+  [(parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))])\n+   (parallel [(set (match_dup 0) (mem:SI (reg:SI 7)))\n+\t      (set (reg:SI 7) (plus:SI (reg:SI 7) (const_int 4)))])]\n+  \"\")\n \f\n ;; Call-value patterns last so that the wildcard operand does not\n ;; disrupt insn-recog's switch tables."}]}