{"sha": "da17cbb79b755dbc2beaa109450535bddd600481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGExN2NiYjc5Yjc1NWRiYzJiZWFhMTA5NDUwNTM1YmRkZDYwMDQ4MQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-12-15T17:15:25Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2010-12-15T17:15:25Z"}, "message": "PR 28105 Remove size<0 checks before calling malloc/realloc\n\nFrom-SVN: r167860", "tree": {"sha": "7800d9f04952aa47c46ca834ae6536c5fc3f9f36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7800d9f04952aa47c46ca834ae6536c5fc3f9f36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da17cbb79b755dbc2beaa109450535bddd600481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da17cbb79b755dbc2beaa109450535bddd600481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da17cbb79b755dbc2beaa109450535bddd600481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da17cbb79b755dbc2beaa109450535bddd600481/comments", "author": null, "committer": null, "parents": [{"sha": "be3ea0c8c9cfd2d71b0f843320be0cf5ae39cbd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3ea0c8c9cfd2d71b0f843320be0cf5ae39cbd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be3ea0c8c9cfd2d71b0f843320be0cf5ae39cbd2"}], "stats": {"total": 87, "additions": 17, "deletions": 70}, "files": [{"sha": "751bd5aee7c9b156a37c0228f26b8111a2de9134", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da17cbb79b755dbc2beaa109450535bddd600481/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da17cbb79b755dbc2beaa109450535bddd600481/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=da17cbb79b755dbc2beaa109450535bddd600481", "patch": "@@ -1,3 +1,10 @@\n+2010-12-15  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/28105\n+\t* trans.c (gfc_call_malloc): Improve comment.\n+\t(gfc_allocate_with_status): Remove size < 0 check.\n+\t(gfc_call_realloc): Likewise.\n+\n 2010-12-14  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/46937"}, {"sha": "f3914a1020970f7dffda3668ce5bf8b5128cdbcb", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 10, "deletions": 70, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da17cbb79b755dbc2beaa109450535bddd600481/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da17cbb79b755dbc2beaa109450535bddd600481/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=da17cbb79b755dbc2beaa109450535bddd600481", "patch": "@@ -519,7 +519,7 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n \n \n /* Call malloc to allocate size bytes of memory, with special conditions:\n-      + if size <= 0, return a malloced area of size 1,\n+      + if size == 0, return a malloced area of size 1,\n       + if malloc returns NULL, issue a runtime error.  */\n tree\n gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n@@ -584,37 +584,21 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       if (stat)\n \t*stat = 0;\n \n-      // The only time this can happen is the size wraps around.\n-      if (size < 0)\n+      newmem = malloc (MAX (size, 1));\n+      if (newmem == NULL)\n       {\n-\tif (stat)\n-\t{\n-\t  *stat = LIBERROR_ALLOCATION;\n-\t  newmem = NULL;\n-\t}\n-\telse\n-\t  runtime_error (\"Attempt to allocate negative amount of memory. \"\n-\t\t\t \"Possible integer overflow\");\n-      }\n-      else\n-      {\n-\tnewmem = malloc (MAX (size, 1));\n-\tif (newmem == NULL)\n-\t{\n-\t  if (stat)\n-\t    *stat = LIBERROR_ALLOCATION;\n-\t  else\n-\t    runtime_error (\"Out of memory\");\n-\t}\n+        if (stat)\n+          *stat = LIBERROR_ALLOCATION;\n+        else\n+\t  runtime_error (\"Out of memory\");\n       }\n-\n       return newmem;\n     }  */\n tree\n gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n {\n   stmtblock_t alloc_block;\n-  tree res, tmp, error, msg, cond;\n+  tree res, tmp, msg, cond;\n   tree status_type = status ? TREE_TYPE (TREE_TYPE (status)) : NULL_TREE;\n \n   /* Evaluate size only once, and make sure it has the right type.  */\n@@ -640,32 +624,6 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n-  /* Generate the block of code handling (size < 0).  */\n-  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n-\t\t\t(\"Attempt to allocate negative amount of memory. \"\n-\t\t\t \"Possible integer overflow\"));\n-  error = build_call_expr_loc (input_location,\n-\t\t\t   gfor_fndecl_runtime_error, 1, msg);\n-\n-  if (status != NULL_TREE && !integer_zerop (status))\n-    {\n-      /* Set the status variable if it's present.  */\n-      stmtblock_t set_status_block;\n-\n-      gfc_start_block (&set_status_block);\n-      gfc_add_modify (&set_status_block,\n-\t\t      fold_build1_loc (input_location, INDIRECT_REF,\n-\t\t\t\t       status_type, status),\n-\t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n-      gfc_add_modify (&set_status_block, res,\n-\t\t\t   build_int_cst (prvoid_type_node, 0));\n-\n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t     status, build_int_cst (TREE_TYPE (status), 0));\n-      error = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n-\t\t\t       error, gfc_finish_block (&set_status_block));\n-    }\n-\n   /* The allocation itself.  */\n   gfc_start_block (&alloc_block);\n   gfc_add_modify (&alloc_block, res,\n@@ -703,12 +661,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \t\t\t\t\t  build_int_cst (prvoid_type_node, 0)),\n \t\t\t tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&alloc_block, tmp);\n-\n-  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, size,\n-\t\t\t  build_int_cst (TREE_TYPE (size), 0));\n-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, error,\n-\t\t\t gfc_finish_block (&alloc_block));\n-  gfc_add_expr_to_block (block, tmp);\n+  gfc_add_expr_to_block (block, gfc_finish_block (&alloc_block));\n \n   return res;\n }\n@@ -1048,8 +1001,6 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n void *\n internal_realloc (void *mem, size_t size)\n {\n-  if (size < 0)\n-    runtime_error (\"Attempt to allocate a negative amount of memory.\");\n   res = realloc (mem, size);\n   if (!res && size != 0)\n     _gfortran_os_error (\"Out of memory\");\n@@ -1062,7 +1013,7 @@ internal_realloc (void *mem, size_t size)\n tree\n gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n {\n-  tree msg, res, negative, nonzero, zero, null_result, tmp;\n+  tree msg, res, nonzero, zero, null_result, tmp;\n   tree type = TREE_TYPE (mem);\n \n   size = gfc_evaluate_now (size, block);\n@@ -1073,17 +1024,6 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n   /* Create a variable to hold the result.  */\n   res = gfc_create_var (type, NULL);\n \n-  /* size < 0 ?  */\n-  negative = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, size,\n-\t\t\t      build_int_cst (size_type_node, 0));\n-  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n-      (\"Attempt to allocate a negative amount of memory.\"));\n-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, negative,\n-\t\t\t build_call_expr_loc (input_location,\n-\t\t\t\t\t    gfor_fndecl_runtime_error, 1, msg),\n-\t\t\t build_empty_stmt (input_location));\n-  gfc_add_expr_to_block (block, tmp);\n-\n   /* Call realloc and check the result.  */\n   tmp = build_call_expr_loc (input_location,\n \t\t\t built_in_decls[BUILT_IN_REALLOC], 2,"}]}