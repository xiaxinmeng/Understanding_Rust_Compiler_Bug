{"sha": "2708da920e03ce3dd4be2039d4377c50c2e1de29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcwOGRhOTIwZTAzY2UzZGQ0YmUyMDM5ZDQzNzdjNTBjMmUxZGUyOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-04T08:30:30Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-04T08:30:30Z"}, "message": "(cse_insn): Call `invalidate' also for STRICT_LOW_PART and ZERO_EXTRACT (three places).\n\n(cse_insn):  Call `invalidate' also for STRICT_LOW_PART and\nZERO_EXTRACT (three places).\n(invalidate_from_clobbers): Likewise (two places).\n(cse_around_loop): Likewise.\n(invalidate_skipped_set): Likewise.\n(cse_set_around_loop): Likewise.\n\nFrom-SVN: r5993", "tree": {"sha": "0a5a14c331916d8fb62d2e7a77f1ac00dbb5e62d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a5a14c331916d8fb62d2e7a77f1ac00dbb5e62d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2708da920e03ce3dd4be2039d4377c50c2e1de29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2708da920e03ce3dd4be2039d4377c50c2e1de29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2708da920e03ce3dd4be2039d4377c50c2e1de29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2708da920e03ce3dd4be2039d4377c50c2e1de29/comments", "author": null, "committer": null, "parents": [{"sha": "b8af45d0710697313e2f52170b7381cdd3f35f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8af45d0710697313e2f52170b7381cdd3f35f00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8af45d0710697313e2f52170b7381cdd3f35f00"}], "stats": {"total": 56, "additions": 44, "deletions": 12}, "files": [{"sha": "ea71b12873c54c1a11cb2b184504340fd337b40b", "filename": "gcc/cse.c", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2708da920e03ce3dd4be2039d4377c50c2e1de29/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2708da920e03ce3dd4be2039d4377c50c2e1de29/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2708da920e03ce3dd4be2039d4377c50c2e1de29", "patch": "@@ -5855,10 +5855,17 @@ cse_insn (insn, in_libcall_block)\n       for (i = 0; i < lim; i++)\n \t{\n \t  register rtx y = XVECEXP (x, 0, i);\n-\t  if (GET_CODE (y) == CLOBBER\n-\t      && (GET_CODE (XEXP (y, 0)) == REG\n-\t\t  || GET_CODE (XEXP (y, 0)) == SUBREG))\n-\t    invalidate (XEXP (y, 0));\n+\t  if (GET_CODE (y) == CLOBBER)\n+\t    {\n+\t      rtx clobbered = XEXP (y, 0);\n+\n+\t      if (GET_CODE (clobbered) == REG\n+\t\t  || GET_CODE (clobbered) == SUBREG)\n+\t\tinvalidate (clobbered);\n+\t      else if (GET_CODE (clobbered) == STRICT_LOW_PART\n+\t\t       || GET_CODE (clobbered) == ZERO_EXTRACT)\n+\t\tinvalidate (XEXP (clobbered, 0));\n+\t    }\n \t}\n \t    \n       for (i = 0; i < lim; i++)\n@@ -6717,6 +6724,9 @@ cse_insn (insn, in_libcall_block)\n \t  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n \t      || GET_CODE (dest) == MEM)\n \t    invalidate (dest);\n+\t  else if (GET_CODE (dest) == STRICT_LOW_PART\n+\t\t   || GET_CODE (dest) == ZERO_EXTRACT)\n+\t    invalidate (XEXP (dest, 0));\n \t  sets[i].rtl = 0;\n \t}\n \n@@ -6860,6 +6870,9 @@ cse_insn (insn, in_libcall_block)\n \tif (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n \t    || (! writes_memory.all && ! cse_rtx_addr_varies_p (dest)))\n \t  invalidate (dest);\n+\telse if (GET_CODE (dest) == STRICT_LOW_PART\n+\t\t || GET_CODE (dest) == ZERO_EXTRACT)\n+\t  invalidate (XEXP (dest, 0));\n       }\n \n   /* Make sure registers mentioned in destinations\n@@ -7176,10 +7189,15 @@ invalidate_from_clobbers (w, x)\n   if (GET_CODE (x) == CLOBBER)\n     {\n       rtx ref = XEXP (x, 0);\n-      if (ref\n-\t  && (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n-\t      || (GET_CODE (ref) == MEM && ! w->all)))\n-\tinvalidate (ref);\n+      if (ref)\n+\t{\n+\t  if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n+\t      || (GET_CODE (ref) == MEM && ! w->all))\n+\t    invalidate (ref);\n+\t  else if (GET_CODE (ref) == STRICT_LOW_PART\n+\t\t   || GET_CODE (ref) == ZERO_EXTRACT)\n+\t    invalidate (XEXP (ref, 0));\n+\t}\n     }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n@@ -7190,10 +7208,15 @@ invalidate_from_clobbers (w, x)\n \t  if (GET_CODE (y) == CLOBBER)\n \t    {\n \t      rtx ref = XEXP (y, 0);\n-\t      if (ref\n-\t\t  &&(GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n-\t\t     || (GET_CODE (ref) == MEM && !w->all)))\n-\t\tinvalidate (ref);\n+\t      if (ref)\n+\t\t{\n+\t\t  if (GET_CODE (ref) == REG || GET_CODE (ref) == SUBREG\n+\t\t      || (GET_CODE (ref) == MEM && !w->all))\n+\t\t    invalidate (ref);\n+\t\t  else if (GET_CODE (ref) == STRICT_LOW_PART\n+\t\t\t   || GET_CODE (ref) == ZERO_EXTRACT)\n+\t\t    invalidate (XEXP (ref, 0));\n+\t\t}\n \t    }\n \t}\n     }\n@@ -7322,6 +7345,9 @@ cse_around_loop (loop_start)\n       if (GET_CODE (p->exp) == MEM || GET_CODE (p->exp) == REG\n \t  || GET_CODE (p->exp) == SUBREG)\n \tinvalidate (p->exp);\n+      else if (GET_CODE (p->exp) == STRICT_LOW_PART\n+\t       || GET_CODE (p->exp) == ZERO_EXTRACT)\n+\tinvalidate (XEXP (p->exp, 0));\n \n   /* Process insns starting after LOOP_START until we hit a CALL_INSN or\n      a CODE_LABEL (we could handle a CALL_INSN, but it isn't worth it).\n@@ -7381,6 +7407,9 @@ invalidate_skipped_set (dest, set)\n   if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG\n       || (! skipped_writes_memory.all && ! cse_rtx_addr_varies_p (dest)))\n     invalidate (dest);\n+  else if (GET_CODE (dest) == STRICT_LOW_PART\n+\t   || GET_CODE (dest) == ZERO_EXTRACT)\n+    invalidate (XEXP (dest, 0));\n }\n \n /* Invalidate all insns from START up to the end of the function or the\n@@ -7533,6 +7562,9 @@ cse_set_around_loop (x, insn, loop_start)\n       || (GET_CODE (SET_DEST (x)) == MEM && ! writes_memory.all\n \t  && ! cse_rtx_addr_varies_p (SET_DEST (x))))\n     invalidate (SET_DEST (x));\n+  else if (GET_CODE (SET_DEST (x)) == STRICT_LOW_PART\n+\t   || GET_CODE (SET_DEST (x)) == ZERO_EXTRACT)\n+    invalidate (XEXP (SET_DEST (x), 0));\n }\n \f\n /* Find the end of INSN's basic block and return its range,"}]}