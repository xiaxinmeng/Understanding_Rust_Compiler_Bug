{"sha": "1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4M2I4YmZmMGJlN2U0MWFhNzIxZGRlNzlmOTBjYTA3NjNiZDRlMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:43Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:43Z"}, "message": "vect: Reuse reduction accumulators between loops\n\nThis patch adds support for reusing a main loop's reduction accumulator\nin an epilogue loop.  This in turn lets the loops share a single piece\nof vector->scalar reduction code.\n\nThe patch has the following restrictions:\n\n(1) The epilogue reduction can only operate on a single vector\n    (e.g. ncopies must be 1 for non-SLP reductions, and the group size\n    must be <= the element count for SLP reductions).\n\n(2) Both loops must use the same vector mode for their accumulators.\n    This means that the patch is restricted to targets that support\n    --param vect-partial-vector-usage=1.\n\n(3) The reduction must be a standard \u201ctree code\u201d reduction.\n\nHowever, these restrictions could be lifted in future.  For example,\nif the main loop operates on 128-bit vectors and the epilogue loop\noperates on 64-bit vectors, we could in future reduce the 128-bit\nvector by one stage and use the 64-bit result as the starting point\nfor the epilogue result.\n\nThe patch tries to handle chained SLP reductions, unchained SLP\nreductions and non-SLP reductions.  It also handles cases in which\nthe epilogue loop is entered directly (rather than via the main loop)\nand cases in which the epilogue loop can be skipped.\n\nvect_get_main_loop_result is a bit more general than the current\npatch needs.\n\ngcc/\n\t* tree-vectorizer.h (vect_reusable_accumulator): New structure.\n\t(_loop_vec_info::main_loop_edge): New field.\n\t(_loop_vec_info::skip_main_loop_edge): Likewise.\n\t(_loop_vec_info::skip_this_loop_edge): Likewise.\n\t(_loop_vec_info::reusable_accumulators): Likewise.\n\t(_stmt_vec_info::reduc_scalar_results): Likewise.\n\t(_stmt_vec_info::reused_accumulator): Likewise.\n\t(vect_get_main_loop_result): Declare.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Initialize\n\treduc_scalar_inputs.\n\t(vec_info::free_stmt_vec_info): Free reduc_scalar_inputs.\n\t* tree-vect-loop-manip.c (vect_get_main_loop_result): New function.\n\t(vect_do_peeling): Fill an epilogue loop's main_loop_edge,\n\tskip_main_loop_edge and skip_this_loop_edge fields.\n\t* tree-vect-loop.c (INCLUDE_ALGORITHM): Define.\n\t(vect_emit_reduction_init_stmts): New function.\n\t(get_initial_def_for_reduction): Use it.\n\t(get_initial_defs_for_reduction): Likewise.  Change the vinfo\n\tparameter to a loop_vec_info.\n\t(vect_create_epilog_for_reduction): Store the scalar results\n\tin the reduc_info.  If an epilogue loop is reusing an accumulator\n\tfrom the main loop, and if the epilogue loop can also be skipped,\n\ttry to place the reduction code in the join block.  Record\n\taccumulators that could potentially be reused by epilogue loops.\n\t(vect_transform_cycle_phi): When vectorizing epilogue loops,\n\ttry to reuse accumulators from the main loop.  Record the initial\n\tvalue in reduc_info for non-SLP reductions too.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/reduc_9.c: New test.\n\t* gcc.target/aarch64/sve/reduc_9_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_10.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_10_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_11.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_11_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_12.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_12_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_13.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_13_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_14.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_14_run.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_15.c: Likewise.\n\t* gcc.target/aarch64/sve/reduc_15_run.c: Likewise.", "tree": {"sha": "d2f95d2ac56f2508877f03cd54c3be109b1fed4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f95d2ac56f2508877f03cd54c3be109b1fed4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7670b6633e51afbbc4b3c8a5775accf7f2d887af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7670b6633e51afbbc4b3c8a5775accf7f2d887af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7670b6633e51afbbc4b3c8a5775accf7f2d887af"}], "stats": {"total": 1361, "additions": 1297, "deletions": 64}, "files": [{"sha": "fb817b73d77ab98ef44baf318ef101677c473b45", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_10.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_10.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-options \"-O3 --param vect-partial-vector-usage=1\" } */\n+\n+unsigned short __attribute__((noipa))\n+add_loop (unsigned short *x, int n)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res += x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+min_loop (unsigned short *x, int n)\n+{\n+  unsigned short res = ~0;\n+  for (int i = 0; i < n; ++i)\n+    res = res < x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+max_loop (unsigned short *x, int n)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res = res > x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+and_loop (unsigned short *x, int n)\n+{\n+  unsigned short res = ~0;\n+  for (int i = 0; i < n; ++i)\n+    res &= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+or_loop (unsigned short *x, int n)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res |= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+eor_loop (unsigned short *x, int n)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < n; ++i)\n+    res ^= x[i];\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuminv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tumaxv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\t} 1 } } */"}, {"sha": "1dd579be701d01957b6dd275931601330078c991", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_10_run.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_10_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_10_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_10_run.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 --param vect-partial-vector-usage=1\" } */\n+\n+#define N 0x1100\n+\n+#include \"reduc_10.c\"\n+\n+int\n+main (void)\n+{\n+  unsigned short x[N];\n+  for (int i = 0; i < N; ++i)\n+    x[i] = (i + 1) * (i + 2);\n+\n+  if (add_loop (x, 0) != 0\n+      || add_loop (x, 11) != 572\n+      || add_loop (x, 0x100) != 22016\n+      || add_loop (x, 0xfff) != 20480\n+      || max_loop (x, 0) != 0\n+      || max_loop (x, 11) != 132\n+      || max_loop (x, 0x100) != 65280\n+      || max_loop (x, 0xfff) != 65504\n+      || or_loop (x, 0) != 0\n+      || or_loop (x, 11) != 0xfe\n+      || or_loop (x, 0x80) != 0x7ffe\n+      || or_loop (x, 0xb4) != 0x7ffe\n+      || or_loop (x, 0xb5) != 0xfffe\n+      || eor_loop (x, 0) != 0\n+      || eor_loop (x, 11) != 0xe8\n+      || eor_loop (x, 0x100) != 0xcf00\n+      || eor_loop (x, 0xfff) != 0xa000)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ~x[i];\n+\n+  if (min_loop (x, 0) != 65535\n+      || min_loop (x, 11) != 65403\n+      || min_loop (x, 0x100) != 255\n+      || min_loop (x, 0xfff) != 31\n+      || and_loop (x, 0) != 0xffff\n+      || and_loop (x, 11) != 0xff01\n+      || and_loop (x, 0x80) != 0x8001\n+      || and_loop (x, 0xb4) != 0x8001\n+      || and_loop (x, 0xb5) != 1)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "f99ef4aa8653c353c5fd5145dee0b176c1e61e19", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_11.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_11.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+unsigned short __attribute__((noipa))\n+add_loop (unsigned short *x, unsigned short res)\n+{\n+  for (int i = 0; i < 0xfff; ++i)\n+    res += x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+min_loop (unsigned short *x, unsigned short res)\n+{\n+  for (int i = 0; i < 0xfff; ++i)\n+    res = res < x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+max_loop (unsigned short *x, unsigned short res)\n+{\n+  for (int i = 0; i < 0xfff; ++i)\n+    res = res > x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+and_loop (unsigned short *x, unsigned short res)\n+{\n+  for (int i = 0; i < 0xfff; ++i)\n+    res &= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+or_loop (unsigned short *x, unsigned short res)\n+{\n+  for (int i = 0; i < 0xfff; ++i)\n+    res |= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+eor_loop (unsigned short *x, unsigned short res)\n+{\n+  for (int i = 0; i < 0xfff; ++i)\n+    res ^= x[i];\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuminv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tumaxv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\t} 1 } } */"}, {"sha": "5b41560d2ef4165110d4cc1101f20883cdebac19", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_11_run.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_11_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_11_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_11_run.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target aarch64_sve256_hw } } */\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+#define N 0x1100\n+\n+#include \"reduc_11.c\"\n+\n+int\n+main (void)\n+{\n+  unsigned short x[N];\n+  for (int i = 0; i < N; ++i)\n+    x[i] = (i + 1) * (i + 2);\n+\n+  if (add_loop (x, 42) != 20522\n+      || max_loop (x, 65503) != 65504\n+      || max_loop (x, 65505) != 65505\n+      || or_loop (x, 0) != 0xfffe\n+      || or_loop (x, 1) != 0xffff\n+      || eor_loop (x, 0) != 0xa000\n+      || eor_loop (x, 0xbfff) != 0x1fff)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ~x[i];\n+\n+  if (min_loop (x, 32) != 31\n+      || min_loop (x, 30) != 30\n+      || and_loop (x, 0xff) != 1\n+      || and_loop (x, 0) != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "d32b81a61bc67f7a45e815682a0530a594cb0913", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_12.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_12.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-options \"-O3 --param vect-partial-vector-usage=1\" } */\n+\n+unsigned short __attribute__((noipa))\n+add_loop (unsigned short *x, int n, unsigned short res)\n+{\n+  for (int i = 0; i < n; ++i)\n+    res += x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+min_loop (unsigned short *x, int n, unsigned short res)\n+{\n+  for (int i = 0; i < n; ++i)\n+    res = res < x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+max_loop (unsigned short *x, int n, unsigned short res)\n+{\n+  for (int i = 0; i < n; ++i)\n+    res = res > x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+and_loop (unsigned short *x, int n, unsigned short res)\n+{\n+  for (int i = 0; i < n; ++i)\n+    res &= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+or_loop (unsigned short *x, int n, unsigned short res)\n+{\n+  for (int i = 0; i < n; ++i)\n+    res |= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+eor_loop (unsigned short *x, int n, unsigned short res)\n+{\n+  for (int i = 0; i < n; ++i)\n+    res ^= x[i];\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuminv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tumaxv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\t} 1 } } */"}, {"sha": "929b81a9705fd7fc7c2663a1980f07f626d1cef2", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_12_run.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_12_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_12_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_12_run.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O3 --param vect-partial-vector-usage=1\" } */\n+\n+#define N 0x1100\n+\n+#include \"reduc_12.c\"\n+\n+int\n+main (void)\n+{\n+  unsigned short x[N];\n+  for (int i = 0; i < N; ++i)\n+    x[i] = (i + 1) * (i + 2);\n+\n+  if (add_loop (x, 0, 10) != 10\n+      || add_loop (x, 11, 42) != 614\n+      || add_loop (x, 0x100, 84) != 22100\n+      || add_loop (x, 0xfff, 20) != 20500\n+      || max_loop (x, 0, 10) != 10\n+      || max_loop (x, 11, 131) != 132\n+      || max_loop (x, 11, 133) != 133\n+      || max_loop (x, 0x100, 65279) != 65280\n+      || max_loop (x, 0x100, 65281) != 65281\n+      || max_loop (x, 0xfff, 65503) != 65504\n+      || max_loop (x, 0xfff, 65505) != 65505\n+      || or_loop (x, 0, 0x71) != 0x71\n+      || or_loop (x, 11, 0) != 0xfe\n+      || or_loop (x, 11, 0xb3c) != 0xbfe\n+      || or_loop (x, 0x80, 0) != 0x7ffe\n+      || or_loop (x, 0x80, 1) != 0x7fff\n+      || or_loop (x, 0xb4, 0) != 0x7ffe\n+      || or_loop (x, 0xb4, 1) != 0x7fff\n+      || or_loop (x, 0xb5, 0) != 0xfffe\n+      || or_loop (x, 0xb5, 1) != 0xffff\n+      || eor_loop (x, 0, 0x3e) != 0x3e\n+      || eor_loop (x, 11, 0) != 0xe8\n+      || eor_loop (x, 11, 0x1ff) != 0x117\n+      || eor_loop (x, 0x100, 0) != 0xcf00\n+      || eor_loop (x, 0x100, 0xeee) != 0xc1ee\n+      || eor_loop (x, 0xfff, 0) != 0xa000\n+      || eor_loop (x, 0xfff, 0x8888) != 0x2888)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ~x[i];\n+\n+  if (min_loop (x, 0, 10000) != 10000\n+      || min_loop (x, 11, 65404) != 65403\n+      || min_loop (x, 11, 65402) != 65402\n+      || min_loop (x, 0x100, 256) != 255\n+      || min_loop (x, 0x100, 254) != 254\n+      || min_loop (x, 0xfff, 32) != 31\n+      || min_loop (x, 0xfff, 30) != 30\n+      || and_loop (x, 0, 0x1234) != 0x1234\n+      || and_loop (x, 11, 0xffff) != 0xff01\n+      || and_loop (x, 11, 0xcdef) != 0xcd01\n+      || and_loop (x, 0x80, 0xffff) != 0x8001\n+      || and_loop (x, 0x80, 0xfffe) != 0x8000\n+      || and_loop (x, 0xb4, 0xffff) != 0x8001\n+      || and_loop (x, 0xb4, 0xfffe) != 0x8000\n+      || and_loop (x, 0xb5, 0xffff) != 1\n+      || and_loop (x, 0xb5, 0xfffe) != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "ce2b8f2fcdcdbc899dcdbc19e5160643c72b39d0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_13.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_13.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+void __attribute__((noipa))\n+add_loop (unsigned int *x, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < 0x7ff; ++i)\n+    {\n+      res0 += x[i * 2];\n+      res1 += x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+min_loop (unsigned int *x, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < 0x7ff; ++i)\n+    {\n+      res0 = res0 < x[i * 2] ? res0 : x[i * 2];\n+      res1 = res1 < x[i * 2 + 1] ? res1 : x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+max_loop (unsigned int *x, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < 0x7ff; ++i)\n+    {\n+      res0 = res0 > x[i * 2] ? res0 : x[i * 2];\n+      res1 = res1 > x[i * 2 + 1] ? res1 : x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+and_loop (unsigned int *x, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < 0x7ff; ++i)\n+    {\n+      res0 &= x[i * 2];\n+      res1 &= x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+or_loop (unsigned int *x, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < 0x7ff; ++i)\n+    {\n+      res0 |= x[i * 2];\n+      res1 |= x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+eor_loop (unsigned int *x, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < 0x7ff; ++i)\n+    {\n+      res0 ^= x[i * 2];\n+      res1 ^= x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */"}, {"sha": "5514d8d6b3b8a7902b1fe5705aee1ffb41625ceb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_13_run.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_13_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_13_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_13_run.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run { target aarch64_sve256_hw } } */\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+#define N 0x1100\n+\n+#include \"reduc_13.c\"\n+\n+int\n+main (void)\n+{\n+  unsigned int x[N];\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ((i + 1) * (i + 2)) & 0xfffff;\n+\n+  unsigned int add_res[2] = { 42, 1111 };\n+  add_loop (x, add_res);\n+  if (add_res[0] != 968538154\n+      || add_res[1] != 964340823)\n+    __builtin_abort ();\n+\n+  unsigned int max_res1[2] = { 0, 0 };\n+  max_loop (x, max_res1);\n+  if (max_res1[0] != 1048150\n+      || max_res1[1] != 1045506)\n+    __builtin_abort ();\n+\n+  unsigned int max_res2[2] = { 1048151, 1045507 };\n+  max_loop (x, max_res2);\n+  if (max_res2[0] != 1048151\n+      || max_res2[1] != 1045507)\n+    __builtin_abort ();\n+\n+  unsigned int or_res[2] = { 0x1000000, 0x2000000 };\n+  or_loop (x, or_res);\n+  if (or_res[0] != 0x10ffffe\n+      || or_res[1] != 0x20ffffe)\n+    __builtin_abort ();\n+\n+  unsigned int eor_res[2] = { 0x1000000, 0x2000000 };\n+  eor_loop (x, eor_res);\n+  if (eor_res[0] != 0x1010000\n+      || eor_res[1] != 0x20b5000)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ~x[i] & 0xfffff;\n+\n+  unsigned int min_res1[2] = { 500, 4000 };\n+  min_loop (x, min_res1);\n+  if (min_res1[0] != 425\n+      || min_res1[1] != 3069)\n+    __builtin_abort ();\n+\n+  unsigned int min_res2[2] = { 424, 3068 };\n+  min_loop (x, min_res2);\n+  if (min_res2[0] != 424\n+      || min_res2[1] != 3068)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "3be611e4b37b8675207702991a330ccdc9d1d134", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_14.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_14.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-options \"-O3 --param vect-partial-vector-usage=1\" } */\n+\n+void __attribute__((noipa))\n+add_loop (unsigned int *x, int n, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res0 += x[i * 2];\n+      res1 += x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+min_loop (unsigned int *x, int n, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res0 = res0 < x[i * 2] ? res0 : x[i * 2];\n+      res1 = res1 < x[i * 2 + 1] ? res1 : x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+max_loop (unsigned int *x, int n, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res0 = res0 > x[i * 2] ? res0 : x[i * 2];\n+      res1 = res1 > x[i * 2 + 1] ? res1 : x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+and_loop (unsigned int *x, int n, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res0 &= x[i * 2];\n+      res1 &= x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+or_loop (unsigned int *x, int n, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res0 |= x[i * 2];\n+      res1 |= x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+void __attribute__((noipa))\n+eor_loop (unsigned int *x, int n, unsigned int *res)\n+{\n+  unsigned int res0 = res[0];\n+  unsigned int res1 = res[1];\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res0 ^= x[i * 2];\n+      res1 ^= x[i * 2 + 1];\n+    }\n+  res[0] = res0;\n+  res[1] = res1;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\t} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuminv\\t} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tumaxv\\t} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\t} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\t} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\t} 2 } } */"}, {"sha": "ccaa770e9b2b5fa572d0f84229332ab1ecd867d7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_14_run.c", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_14_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_14_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_14_run.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,187 @@\n+/* { dg-do run { target aarch64_sve256_hw } } */\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+#define N 0x1100\n+\n+#include \"reduc_14.c\"\n+\n+int\n+main (void)\n+{\n+  unsigned int x[N];\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ((i + 1) * (i + 2)) & 0xfffff;\n+\n+  unsigned int add_res1[2] = { 11, 22 };\n+  add_loop (x, 0, add_res1);\n+  if (add_res1[0] != 11\n+      || add_res1[1] != 22)\n+    __builtin_abort ();\n+\n+  unsigned int add_res2[2] = { 10, 20 };\n+  add_loop (x, 11, add_res2);\n+  if (add_res2[0] != 1902\n+      || add_res2[1] != 2176)\n+    __builtin_abort ();\n+\n+  unsigned int add_res3[2] = { 15, 30 };\n+  add_loop (x, 0x100, add_res3);\n+  if (add_res3[0] != 22435087\n+      || add_res3[1] != 22566686)\n+    __builtin_abort ();\n+\n+  unsigned int add_res4[2] = { 100, 200 };\n+  add_loop (x, 0x11f, add_res4);\n+  if (add_res4[0] != 31602244\n+      || add_res4[1] != 31767656)\n+    __builtin_abort ();\n+\n+  unsigned int max_res1[2] = { 461, 500 };\n+  max_loop (x, 11, max_res1);\n+  if (max_res1[0] != 462\n+      || max_res1[1] != 506)\n+    __builtin_abort ();\n+\n+  unsigned int max_res2[2] = { 463, 507 };\n+  max_loop (x, 11, max_res2);\n+  if (max_res2[0] != 463\n+      || max_res2[1] != 507)\n+    __builtin_abort ();\n+\n+  unsigned int max_res3[2] = { 1000000, 1000000 };\n+  max_loop (x, 0x200, max_res3);\n+  if (max_res3[0] != 1047552\n+      || max_res3[1] != 1045506)\n+    __builtin_abort ();\n+\n+  unsigned int max_res4[2] = { 1047553, 1045507 };\n+  max_loop (x, 0x200, max_res4);\n+  if (max_res4[0] != 1047553\n+      || max_res4[1] != 1045507)\n+    __builtin_abort ();\n+\n+  unsigned int max_res5[2] = { 300000, 30000 };\n+  max_loop (x, 0x11f, max_res5);\n+  if (max_res5[0] != 328902\n+      || max_res5[1] != 330050)\n+    __builtin_abort ();\n+\n+  unsigned int max_res6[2] = { 328903, 330051 };\n+  max_loop (x, 0x11f, max_res6);\n+  if (max_res6[0] != 328903\n+      || max_res6[1] != 330051)\n+    __builtin_abort ();\n+\n+  unsigned int or_res1[2] = { 11, 22 };\n+  or_loop (x, 0, or_res1);\n+  if (or_res1[0] != 11\n+      || or_res1[1] != 22)\n+    __builtin_abort ();\n+\n+  unsigned int or_res2[2] = { 0x200000, 0xe00000 };\n+  or_loop (x, 11, or_res2);\n+  if (or_res2[0] != 0x2001fe\n+      || or_res2[1] != 0xe001fe)\n+    __builtin_abort ();\n+\n+  unsigned int or_res3[2] = { 0x800000, 0x700000 };\n+  or_loop (x, 0x40, or_res3);\n+  if (or_res3[0] != 0x803ffe\n+      || or_res3[1] != 0x707ffe)\n+    __builtin_abort ();\n+\n+  unsigned int or_res4[2] = { 0x100001, 0x300000 };\n+  or_loop (x, 0x4f, or_res4);\n+  if (or_res4[0] != 0x107fff\n+      || or_res4[1] != 0x307ffe)\n+    __builtin_abort ();\n+\n+  unsigned int eor_res1[2] = { 11, 22 };\n+  eor_loop (x, 0, eor_res1);\n+  if (eor_res1[0] != 11\n+      || eor_res1[1] != 22)\n+    __builtin_abort ();\n+\n+  unsigned int eor_res2[2] = { 0x2000ff, 0xe000ff };\n+  eor_loop (x, 11, eor_res2);\n+  if (eor_res2[0] != 0x2001cf\n+      || eor_res2[1] != 0xe000b7)\n+    __builtin_abort ();\n+\n+  unsigned int eor_res3[2] = { 0x805000, 0x70f000 };\n+  eor_loop (x, 0x100, eor_res3);\n+  if (eor_res3[0] != 0x824200\n+      || eor_res3[1] != 0x77dc00)\n+    __builtin_abort ();\n+\n+  unsigned int eor_res4[2] = { 0x101201, 0x300f00 };\n+  eor_loop (x, 0x11f, eor_res4);\n+  if (eor_res4[0] != 0x178801\n+      || eor_res4[1] != 0x337240)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ~x[i] & 0xfffff;\n+\n+  unsigned int min_res1[2] = { 1048200, 1048100 };\n+  min_loop (x, 11, min_res1);\n+  if (min_res1[0] != 1048113\n+      || min_res1[1] != 1048069)\n+    __builtin_abort ();\n+\n+  unsigned int min_res2[2] = { 1048112, 1048068 };\n+  min_loop (x, 11, min_res2);\n+  if (min_res2[0] != 1048112\n+      || min_res2[1] != 1048068)\n+    __builtin_abort ();\n+\n+  unsigned int min_res3[2] = { 10000, 10000 };\n+  min_loop (x, 0x200, min_res3);\n+  if (min_res3[0] != 1023\n+      || min_res3[1] != 3069)\n+    __builtin_abort ();\n+\n+  unsigned int min_res4[2] = { 1022, 3068 };\n+  min_loop (x, 0x200, min_res4);\n+  if (min_res4[0] != 1022\n+      || min_res4[1] != 3068)\n+    __builtin_abort ();\n+\n+  unsigned int min_res5[2] = { 719680, 718530 };\n+  min_loop (x, 0x11f, min_res5);\n+  if (min_res5[0] != 719673\n+      || min_res5[1] != 718525)\n+    __builtin_abort ();\n+\n+  unsigned int min_res6[2] = { 719672, 718524 };\n+  min_loop (x, 0x11f, min_res6);\n+  if (min_res6[0] != 719672\n+      || min_res6[1] != 718524)\n+    __builtin_abort ();\n+\n+  unsigned int and_res1[2] = { 11, 22 };\n+  and_loop (x, 0, and_res1);\n+  if (and_res1[0] != 11\n+      || and_res1[1] != 22)\n+    __builtin_abort ();\n+\n+  unsigned int and_res2[2] = { 0xf5cff, 0xf78ff };\n+  and_loop (x, 11, and_res2);\n+  if (and_res2[0] != 0xf5c01\n+      || and_res2[1] != 0xf7801)\n+    __builtin_abort ();\n+\n+  unsigned int and_res3[2] = { 0x7efff, 0xecfff };\n+  and_loop (x, 0x40, and_res3);\n+  if (and_res3[0] != 0x7c001\n+      || and_res3[1] != 0xe8001)\n+    __builtin_abort ();\n+\n+  unsigned int and_res4[2] = { 0xffffff, 0xffffff };\n+  and_loop (x, 0x4f, and_res4);\n+  if (and_res4[0] != 0xf8001\n+      || and_res4[1] != 0xf8001)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "15b1ade30e22d14430e4244eb8c96e9e2fcac892", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_15.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_15.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-options \"-O3 --param vect-partial-vector-usage=1\" } */\n+\n+int __attribute__((noipa))\n+add_loop (int *x, int n, int res)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      res += x[i * 2];\n+      res += x[i * 2 + 1];\n+    }\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.s, p[0-7]/m, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\t} 1 } } */"}, {"sha": "3207fce5be35ede51f15be44d95724959ccc377a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_15_run.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_15_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_15_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_15_run.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run { target aarch64_sve256_hw } } */\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+#define N 0x1100\n+\n+#include \"reduc_15.c\"\n+\n+int\n+main (void)\n+{\n+  int x[N];\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ((i + 1) * (i + 2)) & 0xfffff;\n+\n+  if (add_loop (x, 0, 33) != 33\n+      || add_loop (x, 11, 30) != 4078\n+      || add_loop (x, 0x100, 45) != 45001773\n+      || add_loop (x, 0x11f, 300) != 63369900)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "b839821d6bbd0a6e35a204b50192b372525405ef", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_9.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_9.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+unsigned short __attribute__((noipa))\n+add_loop (unsigned short *x)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < 0xfff; ++i)\n+    res += x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+min_loop (unsigned short *x)\n+{\n+  unsigned short res = ~0;\n+  for (int i = 0; i < 0xfff; ++i)\n+    res = res < x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+max_loop (unsigned short *x)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < 0xfff; ++i)\n+    res = res > x[i] ? res : x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+and_loop (unsigned short *x)\n+{\n+  unsigned short res = ~0;\n+  for (int i = 0; i < 0xfff; ++i)\n+    res &= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+or_loop (unsigned short *x)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < 0xfff; ++i)\n+    res |= x[i];\n+  return res;\n+}\n+\n+unsigned short __attribute__((noipa))\n+eor_loop (unsigned short *x)\n+{\n+  unsigned short res = 0;\n+  for (int i = 0; i < 0xfff; ++i)\n+    res ^= x[i];\n+  return res;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tuaddv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumin\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tuminv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tumax\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tumaxv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tand\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tandv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torr\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\torv\\t} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.d, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teor\\tz[0-9]+\\.h, p[0-7]/m, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\teorv\\t} 1 } } */"}, {"sha": "aa248f53eaa77dcf30cecf3264c770045f93b373", "filename": "gcc/testsuite/gcc.target/aarch64/sve/reduc_9_run.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_9_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_9_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Freduc_9_run.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run { target aarch64_sve256_hw } } */\n+/* { dg-options \"-O3 -msve-vector-bits=256 --param vect-partial-vector-usage=1\" } */\n+\n+#define N 0x1100\n+\n+#include \"reduc_9.c\"\n+\n+int\n+main (void)\n+{\n+  unsigned short x[N];\n+  for (int i = 0; i < N; ++i)\n+    x[i] = (i + 1) * (i + 2);\n+\n+  if (add_loop (x) != 20480\n+      || max_loop (x) != 65504\n+      || or_loop (x) != 0xfffe\n+      || eor_loop (x) != 0xa000)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    x[i] = ~x[i];\n+\n+  if (min_loop (x) != 31\n+      || and_loop (x) != 1)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "c29ffb3356c3215d06de40a6d6ebcf6cdb9093b6", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -2457,6 +2457,28 @@ vect_update_epilogue_niters (loop_vec_info epilogue_vinfo,\n   return vect_determine_partial_vectors_and_peeling (epilogue_vinfo, true);\n }\n \n+/* LOOP_VINFO is an epilogue loop whose corresponding main loop can be skipped.\n+   Return a value that equals:\n+\n+   - MAIN_LOOP_VALUE when LOOP_VINFO is entered from the main loop and\n+   - SKIP_VALUE when the main loop is skipped.  */\n+\n+tree\n+vect_get_main_loop_result (loop_vec_info loop_vinfo, tree main_loop_value,\n+\t\t\t   tree skip_value)\n+{\n+  gcc_assert (loop_vinfo->main_loop_edge);\n+\n+  tree phi_result = make_ssa_name (TREE_TYPE (main_loop_value));\n+  basic_block bb = loop_vinfo->main_loop_edge->dest;\n+  gphi *new_phi = create_phi_node (phi_result, bb);\n+  add_phi_arg (new_phi, main_loop_value, loop_vinfo->main_loop_edge,\n+\t       UNKNOWN_LOCATION);\n+  add_phi_arg (new_phi, skip_value,\n+\t       loop_vinfo->skip_main_loop_edge, UNKNOWN_LOCATION);\n+  return phi_result;\n+}\n+\n /* Function vect_do_peeling.\n \n    Input:\n@@ -2986,6 +3008,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t\t\t\t\t   skip_vector ? anchor : guard_bb,\n \t\t\t\t\t   prob_epilog.invert (),\n \t\t\t\t\t   irred_flag);\n+\t  if (vect_epilogues)\n+\t    epilogue_vinfo->skip_this_loop_edge = guard_e;\n \t  slpeel_update_phi_nodes_for_guard2 (loop, epilog, guard_e,\n \t\t\t\t\t      single_exit (epilog));\n \t  /* Only need to handle basic block before epilog loop if it's not\n@@ -3057,6 +3081,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t  add_phi_arg (new_phi, build_zero_cst (TREE_TYPE (niters)), skip_e,\n \t\t       UNKNOWN_LOCATION);\n \t  niters = PHI_RESULT (new_phi);\n+\t  epilogue_vinfo->main_loop_edge = update_e;\n+\t  epilogue_vinfo->skip_main_loop_edge = skip_e;\n \t}\n \n       /* Set ADVANCE to the number of iterations performed by the previous"}, {"sha": "8c27d75f889190d21c14891f90b06639bb37fc27", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 249, "deletions": 58, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -19,6 +19,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_ALGORITHM\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -823,6 +824,10 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     th (0),\n     versioning_threshold (0),\n     vectorization_factor (0),\n+    main_loop_edge (nullptr),\n+    skip_main_loop_edge (nullptr),\n+    skip_this_loop_edge (nullptr),\n+    reusable_accumulators (),\n     max_vectorization_factor (0),\n     mask_skip_niters (NULL_TREE),\n     rgroup_compare_type (NULL_TREE),\n@@ -4607,7 +4612,32 @@ vect_model_reduction_cost (loop_vec_info loop_vinfo,\n                  prologue_cost, epilogue_cost);\n }\n \n+/* SEQ is a sequence of instructions that initialize the reduction\n+   described by REDUC_INFO.  Emit them in the appropriate place.  */\n \n+static void\n+vect_emit_reduction_init_stmts (loop_vec_info loop_vinfo,\n+\t\t\t\tstmt_vec_info reduc_info, gimple *seq)\n+{\n+  if (reduc_info->reused_accumulator)\n+    {\n+      /* When reusing an accumulator from the main loop, we only need\n+\t initialization instructions if the main loop can be skipped.\n+\t In that case, emit the initialization instructions at the end\n+\t of the guard block that does the skip.  */\n+      edge skip_edge = loop_vinfo->skip_main_loop_edge;\n+      gcc_assert (skip_edge);\n+      gimple_stmt_iterator gsi = gsi_last_bb (skip_edge->src);\n+      gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n+    }\n+  else\n+    {\n+      /* The normal case: emit the initialization instructions on the\n+\t preheader edge.  */\n+      class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), seq);\n+    }\n+}\n \n /* Function get_initial_def_for_reduction\n \n@@ -4675,36 +4705,30 @@ get_initial_def_for_reduction (loop_vec_info loop_vinfo,\n     }\n \n   if (stmts)\n-    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+    vect_emit_reduction_init_stmts (loop_vinfo, reduc_info, stmts);\n   return init_def;\n }\n \n-/* Get at the initial defs for the reduction PHIs for REDUC_INFO, whose\n-   associated SLP node is SLP_NODE.  NUMBER_OF_VECTORS is the number of vector\n-   defs to create.  If NEUTRAL_OP is nonnull, introducing extra elements of\n-   that value will not change the result.  */\n+/* Get at the initial defs for the reduction PHIs for REDUC_INFO,\n+   which performs a reduction involving GROUP_SIZE scalar statements.\n+   NUMBER_OF_VECTORS is the number of vector defs to create.  If NEUTRAL_OP\n+   is nonnull, introducing extra elements of that value will not change the\n+   result.  */\n \n static void\n-get_initial_defs_for_reduction (vec_info *vinfo,\n+get_initial_defs_for_reduction (loop_vec_info loop_vinfo,\n \t\t\t\tstmt_vec_info reduc_info,\n-\t\t\t\tslp_tree slp_node,\n \t\t\t\tvec<tree> *vec_oprnds,\n \t\t\t\tunsigned int number_of_vectors,\n-\t\t\t\tbool reduc_chain, tree neutral_op)\n+\t\t\t\tunsigned int group_size, tree neutral_op)\n {\n-  vec<stmt_vec_info> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+  vec<tree> &initial_values = reduc_info->reduc_initial_values;\n   unsigned HOST_WIDE_INT nunits;\n   unsigned j, number_of_places_left_in_vector;\n   tree vector_type = STMT_VINFO_VECTYPE (reduc_info);\n-  unsigned int group_size = stmts.length ();\n   unsigned int i;\n-  class loop *loop;\n-\n-  loop = (gimple_bb (reduc_info->stmt))->loop_father;\n-  gcc_assert (loop);\n-  edge pe = loop_preheader_edge (loop);\n \n-  gcc_assert (!reduc_chain || neutral_op);\n+  gcc_assert (group_size == initial_values.length () || neutral_op);\n \n   /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n      created vectors. It is greater than 1 if unrolling is performed.\n@@ -4734,18 +4758,13 @@ get_initial_defs_for_reduction (vec_info *vinfo,\n     {\n       tree op;\n       i = j % group_size;\n-      stmt_vec_info stmt_vinfo = stmts[i];\n \n       /* Get the def before the loop.  In reduction chain we have only\n \t one initial value.  Else we have as many as PHIs in the group.  */\n-      if (reduc_chain)\n-\top = j != 0 ? neutral_op : vect_phi_initial_value (stmt_vinfo);\n-      else if (((vec_oprnds->length () + 1) * nunits\n-\t\t- number_of_places_left_in_vector >= group_size)\n-\t       && neutral_op)\n+      if (i >= initial_values.length () || (j > i && neutral_op))\n \top = neutral_op;\n       else\n-\top = vect_phi_initial_value (stmt_vinfo);\n+\top = initial_values[i];\n \n       /* Create 'vect_ = {op0,op1,...,opn}'.  */\n       number_of_places_left_in_vector--;\n@@ -4781,8 +4800,8 @@ get_initial_defs_for_reduction (vec_info *vinfo,\n \t    {\n \t      /* First time round, duplicate ELTS to fill the\n \t\t required number of vectors.  */\n-\t      duplicate_and_interleave (vinfo, &ctor_seq, vector_type, elts,\n-\t\t\t\t\tnumber_of_vectors, *vec_oprnds);\n+\t      duplicate_and_interleave (loop_vinfo, &ctor_seq, vector_type,\n+\t\t\t\t\telts, number_of_vectors, *vec_oprnds);\n \t      break;\n \t    }\n \t  vec_oprnds->quick_push (init);\n@@ -4794,7 +4813,7 @@ get_initial_defs_for_reduction (vec_info *vinfo,\n \t}\n     }\n   if (ctor_seq != NULL)\n-    gsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n+    vect_emit_reduction_init_stmts (loop_vinfo, reduc_info, ctor_seq);\n }\n \n /* For a statement STMT_INFO taking part in a reduction operation return\n@@ -4823,6 +4842,99 @@ info_for_reduction (vec_info *vinfo, stmt_vec_info stmt_info)\n   return stmt_info;\n }\n \n+/* See if LOOP_VINFO is an epilogue loop whose main loop had a reduction that\n+   REDUC_INFO can build on.  Adjust REDUC_INFO and return true if so, otherwise\n+   return false.  */\n+\n+static bool\n+vect_find_reusable_accumulator (loop_vec_info loop_vinfo,\n+\t\t\t\tstmt_vec_info reduc_info)\n+{\n+  loop_vec_info main_loop_vinfo = LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo);\n+  if (!main_loop_vinfo)\n+    return false;\n+\n+  if (STMT_VINFO_REDUC_TYPE (reduc_info) != TREE_CODE_REDUCTION)\n+    return false;\n+\n+  unsigned int num_phis = reduc_info->reduc_initial_values.length ();\n+  auto_vec<tree, 16> main_loop_results (num_phis);\n+  auto_vec<tree, 16> initial_values (num_phis);\n+  if (edge main_loop_edge = loop_vinfo->main_loop_edge)\n+    {\n+      /* The epilogue loop can be entered either from the main loop or\n+\t from an earlier guard block.  */\n+      edge skip_edge = loop_vinfo->skip_main_loop_edge;\n+      for (tree incoming_value : reduc_info->reduc_initial_values)\n+\t{\n+\t  /* Look for:\n+\n+\t       INCOMING_VALUE = phi<MAIN_LOOP_RESULT(main loop),\n+\t\t\t\t    INITIAL_VALUE(guard block)>.  */\n+\t  gcc_assert (TREE_CODE (incoming_value) == SSA_NAME);\n+\n+\t  gphi *phi = as_a <gphi *> (SSA_NAME_DEF_STMT (incoming_value));\n+\t  gcc_assert (gimple_bb (phi) == main_loop_edge->dest);\n+\n+\t  tree from_main_loop = PHI_ARG_DEF_FROM_EDGE (phi, main_loop_edge);\n+\t  tree from_skip = PHI_ARG_DEF_FROM_EDGE (phi, skip_edge);\n+\n+\t  main_loop_results.quick_push (from_main_loop);\n+\t  initial_values.quick_push (from_skip);\n+\t}\n+    }\n+  else\n+    /* The main loop dominates the epilogue loop.  */\n+    main_loop_results.splice (reduc_info->reduc_initial_values);\n+\n+  /* See if the main loop has the kind of accumulator we need.  */\n+  vect_reusable_accumulator *accumulator\n+    = main_loop_vinfo->reusable_accumulators.get (main_loop_results[0]);\n+  if (!accumulator\n+      || num_phis != accumulator->reduc_info->reduc_scalar_results.length ()\n+      || !std::equal (main_loop_results.begin (), main_loop_results.end (),\n+\t\t      accumulator->reduc_info->reduc_scalar_results.begin ()))\n+    return false;\n+\n+  /* For now, only handle the case in which both loops are operating on the\n+     same vector types.  In future we could reduce wider vectors to narrower\n+     ones as well.  */\n+  tree vectype = STMT_VINFO_VECTYPE (reduc_info);\n+  tree old_vectype = TREE_TYPE (accumulator->reduc_input);\n+  if (!useless_type_conversion_p (old_vectype, vectype))\n+    return false;\n+\n+  /* Non-SLP reductions might apply an adjustment after the reduction\n+     operation, in order to simplify the initialization of the accumulator.\n+     If the epilogue loop carries on from where the main loop left off,\n+     it should apply the same adjustment to the final reduction result.\n+\n+     If the epilogue loop can also be entered directly (rather than via\n+     the main loop), we need to be able to handle that case in the same way,\n+     with the same adjustment.  (In principle we could add a PHI node\n+     to select the correct adjustment, but in practice that shouldn't be\n+     necessary.)  */\n+  tree main_adjustment\n+    = STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (accumulator->reduc_info);\n+  if (loop_vinfo->main_loop_edge && main_adjustment)\n+    {\n+      gcc_assert (num_phis == 1);\n+      tree initial_value = initial_values[0];\n+      /* Check that we can use INITIAL_VALUE as the adjustment and\n+\t initialize the accumulator with a neutral value instead.  */\n+      if (!operand_equal_p (initial_value, main_adjustment))\n+\treturn false;\n+      tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n+      initial_values[0] = neutral_op_for_reduction (TREE_TYPE (initial_value),\n+\t\t\t\t\t\t    code, initial_value);\n+    }\n+  STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info) = main_adjustment;\n+  reduc_info->reduc_initial_values.truncate (0);\n+  reduc_info->reduc_initial_values.splice (initial_values);\n+  reduc_info->reused_accumulator = accumulator;\n+  return true;\n+}\n+\n /* Function vect_create_epilog_for_reduction\n \n    Create code at the loop-epilog to finalize the result of a reduction\n@@ -4915,7 +5027,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   gimple *use_stmt;\n   auto_vec<tree> reduc_inputs;\n   int j, i;\n-  auto_vec<tree> scalar_results;\n+  vec<tree> &scalar_results = reduc_info->reduc_scalar_results;\n   unsigned int group_size = 1, k;\n   auto_vec<gimple *> phis;\n   /* SLP reduction without reduction chain, e.g.,\n@@ -4941,16 +5053,12 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n   gcc_assert (vectype);\n   mode = TYPE_MODE (vectype);\n \n-  tree initial_def = NULL;\n   tree induc_val = NULL_TREE;\n   tree adjustment_def = NULL;\n   if (slp_node)\n     ;\n   else\n     {\n-      /* Get at the scalar def before the loop, that defines the initial value\n-\t of the reduction variable.  */\n-      initial_def = vect_phi_initial_value (reduc_def_stmt);\n       /* Optimize: for induction condition reduction, if we can't use zero\n          for induc_val, use initial_def.  */\n       if (STMT_VINFO_REDUC_TYPE (reduc_info) == INTEGER_INDUC_COND_REDUCTION)\n@@ -5196,6 +5304,37 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       reduc_inputs.safe_push (single_input);\n     }\n \n+  tree orig_reduc_input = reduc_inputs[0];\n+\n+  /* If this loop is an epilogue loop that can be skipped after the\n+     main loop, we can only share a reduction operation between the\n+     main loop and the epilogue if we put it at the target of the\n+     skip edge.\n+\n+     We can still reuse accumulators if this check fails.  Doing so has\n+     the minor(?) benefit of making the epilogue loop's scalar result\n+     independent of the main loop's scalar result.  */\n+  bool unify_with_main_loop_p = false;\n+  if (reduc_info->reused_accumulator\n+      && loop_vinfo->skip_this_loop_edge\n+      && single_succ_p (exit_bb)\n+      && single_succ (exit_bb) == loop_vinfo->skip_this_loop_edge->dest)\n+    {\n+      unify_with_main_loop_p = true;\n+\n+      basic_block reduc_block = loop_vinfo->skip_this_loop_edge->dest;\n+      reduc_inputs[0] = make_ssa_name (vectype);\n+      gphi *new_phi = create_phi_node (reduc_inputs[0], reduc_block);\n+      add_phi_arg (new_phi, orig_reduc_input, single_succ_edge (exit_bb),\n+\t\t   UNKNOWN_LOCATION);\n+      add_phi_arg (new_phi, reduc_info->reused_accumulator->reduc_input,\n+\t\t   loop_vinfo->skip_this_loop_edge, UNKNOWN_LOCATION);\n+      exit_gsi = gsi_after_labels (reduc_block);\n+    }\n+\n+  /* Shouldn't be used beyond this point.  */\n+  exit_bb = nullptr;\n+\n   if (STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION\n       && reduc_fn != IFN_LAST)\n     {\n@@ -5405,6 +5544,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t     the same as initial_def already.  */\n \t  tree zcompare = build2 (EQ_EXPR, boolean_type_node, new_temp,\n \t\t\t\t  induc_val);\n+\t  tree initial_def = reduc_info->reduc_initial_values[0];\n \n \t  tmp = make_ssa_name (new_scalar_dest);\n \t  epilog_stmt = gimple_build_assign (tmp, COND_EXPR, zcompare,\n@@ -5425,9 +5565,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       gcc_assert (reduc_inputs.length () == 1);\n       gcc_assert (pow2p_hwi (group_size));\n \n-      slp_tree orig_phis_slp_node = slp_node_instance->reduc_phis;\n-      vec<stmt_vec_info> orig_phis\n-\t= SLP_TREE_SCALAR_STMTS (orig_phis_slp_node);\n       gimple_seq seq = NULL;\n \n       /* Build a vector {0, 1, 2, ...}, with the same number of elements\n@@ -5452,7 +5589,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t{\n \t  tree initial_value = NULL_TREE;\n \t  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-\t    initial_value = vect_phi_initial_value (orig_phis[0]);\n+\t    initial_value = reduc_info->reduc_initial_values[0];\n \t  neutral_op = neutral_op_for_reduction (TREE_TYPE (vectype), code,\n \t\t\t\t\t\t initial_value);\n \t}\n@@ -5466,7 +5603,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t     for MIN and MAX reduction, for example.  */\n \t  if (!neutral_op)\n \t    {\n-\t      tree scalar_value = vect_phi_initial_value (orig_phis[i]);\n+\t      tree scalar_value = reduc_info->reduc_initial_values[i];\n \t      scalar_value = gimple_convert (&seq, TREE_TYPE (vectype),\n \t\t\t\t\t     scalar_value);\n \t      vector_identity = gimple_build_vector_from_val (&seq, vectype,\n@@ -5780,6 +5917,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t     the same as initial_def already.  */\n \t  tree zcompare = build2 (EQ_EXPR, boolean_type_node, new_temp,\n \t\t\t\t  induc_val);\n+\t  tree initial_def = reduc_info->reduc_initial_values[0];\n \n \t  tree tmp = make_ssa_name (new_scalar_dest);\n \t  epilog_stmt = gimple_build_assign (tmp, COND_EXPR, zcompare,\n@@ -5819,6 +5957,11 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       scalar_results[0] = new_temp;\n     }\n \n+  /* Record this operation if it could be reused by the epilogue loop.  */\n+  if (STMT_VINFO_REDUC_TYPE (reduc_info) == TREE_CODE_REDUCTION)\n+    loop_vinfo->reusable_accumulators.put (scalar_results[0],\n+\t\t\t\t\t   { orig_reduc_input, reduc_info });\n+\n   if (double_reduc)\n     loop = outer_loop;\n \n@@ -5886,6 +6029,17 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n         {\n           /* Replace the uses:  */\n           orig_name = PHI_RESULT (exit_phi);\n+\n+\t  /* Look for a single use at the target of the skip edge.  */\n+\t  if (unify_with_main_loop_p)\n+\t    {\n+\t      use_operand_p use_p;\n+\t      gimple *user;\n+\t      if (!single_imm_use (orig_name, &use_p, &user))\n+\t\tgcc_unreachable ();\n+\t      orig_name = gimple_get_lhs (user);\n+\t    }\n+\n           scalar_result = scalar_results[k];\n           FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, orig_name)\n \t    {\n@@ -7421,23 +7575,40 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n       else\n \t{\n \t  gcc_assert (slp_node == slp_node_instance->reduc_phis);\n-\t  tree initial_value = NULL_TREE;\n+\t  vec<tree> &initial_values = reduc_info->reduc_initial_values;\n+\t  vec<stmt_vec_info> &stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n+\n+\t  unsigned int num_phis = stmts.length ();\n \t  if (REDUC_GROUP_FIRST_ELEMENT (reduc_stmt_info))\n-\t    initial_value = vect_phi_initial_value (phi);\n-\t  tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n-\t  tree neutral_op = neutral_op_for_reduction (TREE_TYPE (vectype_out),\n-\t\t\t\t\t\t      code, initial_value);\n-\t  get_initial_defs_for_reduction (loop_vinfo, reduc_info,\n-\t\t\t\t\t  slp_node_instance->reduc_phis,\n-\t\t\t\t\t  &vec_initial_defs, vec_num,\n-\t\t\t\t\t  initial_value != NULL, neutral_op);\n+\t    num_phis = 1;\n+\t  initial_values.reserve (num_phis);\n+\t  for (unsigned int i = 0; i < num_phis; ++i)\n+\t    {\n+\t      gphi *this_phi = as_a<gphi *> (stmts[i]->stmt);\n+\t      initial_values.quick_push (vect_phi_initial_value (this_phi));\n+\t    }\n+\t  if (vec_num == 1)\n+\t    vect_find_reusable_accumulator (loop_vinfo, reduc_info);\n+\t  if (!initial_values.is_empty ())\n+\t    {\n+\t      tree initial_value\n+\t\t= (num_phis == 1 ? initial_values[0] : NULL_TREE);\n+\t      tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n+\t      tree neutral_op\n+\t\t= neutral_op_for_reduction (TREE_TYPE (vectype_out),\n+\t\t\t\t\t    code, initial_value);\n+\t      get_initial_defs_for_reduction (loop_vinfo, reduc_info,\n+\t\t\t\t\t      &vec_initial_defs, vec_num,\n+\t\t\t\t\t      stmts.length (), neutral_op);\n+\t    }\n \t}\n     }\n   else\n     {\n       /* Get at the scalar def before the loop, that defines the initial\n \t value of the reduction variable.  */\n       tree initial_def = vect_phi_initial_value (phi);\n+      reduc_info->reduc_initial_values.safe_push (initial_def);\n       /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n \t and we can't use zero for induc_val, use initial_def.  Similarly\n \t for REDUC_MIN and initial_def larger than the base.  */\n@@ -7474,21 +7645,30 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \t\t\t\t\t   initial_def, initial_def);\n       else\n \t{\n-\t  enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n-\t  tree neutral_op = neutral_op_for_reduction (TREE_TYPE (initial_def),\n-\t\t\t\t\t\t      code, initial_def);\n-\t  gcc_assert (neutral_op);\n-\t  /* Try to simplify the vector initialization by applying an\n-\t     adjustment after the reduction has been performed.  */\n-\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n-\t      && !operand_equal_p (neutral_op, initial_def))\n+\t  if (ncopies == 1)\n+\t    vect_find_reusable_accumulator (loop_vinfo, reduc_info);\n+\t  if (!reduc_info->reduc_initial_values.is_empty ())\n \t    {\n-\t      STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info) = initial_def;\n-\t      initial_def = neutral_op;\n+\t      initial_def = reduc_info->reduc_initial_values[0];\n+\t      enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n+\t      tree neutral_op\n+\t\t= neutral_op_for_reduction (TREE_TYPE (initial_def),\n+\t\t\t\t\t    code, initial_def);\n+\t      gcc_assert (neutral_op);\n+\t      /* Try to simplify the vector initialization by applying an\n+\t\t adjustment after the reduction has been performed.  */\n+\t      if (!reduc_info->reused_accumulator\n+\t\t  && STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+\t\t  && !operand_equal_p (neutral_op, initial_def))\n+\t\t{\n+\t\t  STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info)\n+\t\t    = initial_def;\n+\t\t  initial_def = neutral_op;\n+\t\t}\n+\t      vec_initial_def\n+\t\t= get_initial_def_for_reduction (loop_vinfo, reduc_info,\n+\t\t\t\t\t\t initial_def, neutral_op);\n \t    }\n-\t  vec_initial_def\n-\t    = get_initial_def_for_reduction (loop_vinfo, reduc_info,\n-\t\t\t\t\t     initial_def, neutral_op);\n \t}\n     }\n \n@@ -7499,6 +7679,17 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \tvec_initial_defs.quick_push (vec_initial_def);\n     }\n \n+  if (auto *accumulator = reduc_info->reused_accumulator)\n+    {\n+      if (loop_vinfo->main_loop_edge)\n+\tvec_initial_defs[0]\n+\t  = vect_get_main_loop_result (loop_vinfo, accumulator->reduc_input,\n+\t\t\t\t       vec_initial_defs[0]);\n+      else\n+\tvec_initial_defs.safe_push (accumulator->reduc_input);\n+      gcc_assert (vec_initial_defs.length () == 1);\n+    }\n+\n   /* Generate the reduction PHIs upfront.  */\n   for (i = 0; i < vec_num; i++)\n     {"}, {"sha": "f1035a83826a2f0615de9a05155864b840d3c892", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -694,6 +694,8 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_SLP_VECT_ONLY (res) = false;\n   STMT_VINFO_SLP_VECT_ONLY_PATTERN (res) = false;\n   STMT_VINFO_VEC_STMTS (res) = vNULL;\n+  res->reduc_initial_values = vNULL;\n+  res->reduc_scalar_results = vNULL;\n \n   if (is_a <loop_vec_info> (this)\n       && gimple_code (stmt) == GIMPLE_PHI\n@@ -755,6 +757,8 @@ vec_info::free_stmt_vec_info (stmt_vec_info stmt_info)\n \trelease_ssa_name (lhs);\n     }\n \n+  stmt_info->reduc_initial_values.release ();\n+  stmt_info->reduc_scalar_results.release ();\n   STMT_VINFO_SIMD_CLONE_INFO (stmt_info).release ();\n   STMT_VINFO_VEC_STMTS (stmt_info).release ();\n   free (stmt_info);"}, {"sha": "d825b0c37231eddcf0aca1f38a23f7c2e13e58a9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1583b8bff0be7e41aa721dde79f90ca0763bd4e2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1583b8bff0be7e41aa721dde79f90ca0763bd4e2", "patch": "@@ -551,6 +551,18 @@ typedef auto_vec<rgroup_controls> vec_loop_lens;\n \n typedef auto_vec<std::pair<data_reference*, tree> > drs_init_vec;\n \n+/* Information about a reduction accumulator from the main loop that could\n+   conceivably be reused as the input to a reduction in an epilogue loop.  */\n+struct vect_reusable_accumulator {\n+  /* The final value of the accumulator, which forms the input to the\n+     reduction operation.  */\n+  tree reduc_input;\n+\n+  /* The stmt_vec_info that describes the reduction (i.e. the one for\n+     which is_reduc_info is true).  */\n+  stmt_vec_info reduc_info;\n+};\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n@@ -588,6 +600,26 @@ typedef class _loop_vec_info : public vec_info {\n   /* Unrolling factor  */\n   poly_uint64 vectorization_factor;\n \n+  /* If this loop is an epilogue loop whose main loop can be skipped,\n+     MAIN_LOOP_EDGE is the edge from the main loop to this loop's\n+     preheader.  SKIP_MAIN_LOOP_EDGE is then the edge that skips the\n+     main loop and goes straight to this loop's preheader.\n+\n+     Both fields are null otherwise.  */\n+  edge main_loop_edge;\n+  edge skip_main_loop_edge;\n+\n+  /* If this loop is an epilogue loop that might be skipped after executing\n+     the main loop, this edge is the one that skips the epilogue.  */\n+  edge skip_this_loop_edge;\n+\n+  /* The vectorized form of a standard reduction replaces the original\n+     scalar code's final result (a loop-closed SSA PHI) with the result\n+     of a vector-to-scalar reduction operation.  After vectorization,\n+     this variable maps these vector-to-scalar results to information\n+     about the reductions that generated them.  */\n+  hash_map<tree, vect_reusable_accumulator> reusable_accumulators;\n+\n   /* Maximum runtime vectorization factor, or MAX_VECTORIZATION_FACTOR\n      if there is no particular limit.  */\n   unsigned HOST_WIDE_INT max_vectorization_factor;\n@@ -1186,6 +1218,23 @@ class _stmt_vec_info {\n   /* The vector type for performing the actual reduction.  */\n   tree reduc_vectype;\n \n+  /* If IS_REDUC_INFO is true and if the vector code is performing\n+     N scalar reductions in parallel, this variable gives the initial\n+     scalar values of those N reductions.  */\n+  vec<tree> reduc_initial_values;\n+\n+  /* If IS_REDUC_INFO is true and if the vector code is performing\n+     N scalar reductions in parallel, this variable gives the vectorized code's\n+     final (scalar) result for each of those N reductions.  In other words,\n+     REDUC_SCALAR_RESULTS[I] replaces the original scalar code's loop-closed\n+     SSA PHI for reduction number I.  */\n+  vec<tree> reduc_scalar_results;\n+\n+  /* Only meaningful if IS_REDUC_INFO.  If non-null, the reduction is\n+     being performed by an epilogue loop and we have decided to reuse\n+     this accumulator from the main loop.  */\n+  vect_reusable_accumulator *reused_accumulator;\n+\n   /* Whether we force a single cycle PHI during reduction vectorization.  */\n   bool force_single_cycle;\n \n@@ -1382,12 +1431,6 @@ vect_phi_initial_value (gphi *phi)\n   return PHI_ARG_DEF_FROM_EDGE (phi, pe);\n }\n \n-static inline tree\n-vect_phi_initial_value (stmt_vec_info stmt_info)\n-{\n-  return vect_phi_initial_value (as_a <gphi *> (stmt_info->stmt));\n-}\n-\n /* Return true if STMT_INFO should produce a vector mask type rather than\n    a normal nonmask type.  */\n \n@@ -1818,6 +1861,7 @@ class loop *vect_loop_versioning (loop_vec_info, gimple *);\n extern class loop *vect_do_peeling (loop_vec_info, tree, tree,\n \t\t\t\t    tree *, tree *, tree *, int, bool, bool,\n \t\t\t\t    tree *);\n+extern tree vect_get_main_loop_result (loop_vec_info, tree, tree);\n extern void vect_prepare_for_masked_peels (loop_vec_info);\n extern dump_user_location_t find_loop_location (class loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);"}]}