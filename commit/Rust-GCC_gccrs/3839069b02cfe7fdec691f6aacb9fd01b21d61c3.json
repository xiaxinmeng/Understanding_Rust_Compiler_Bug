{"sha": "3839069b02cfe7fdec691f6aacb9fd01b21d61c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzOTA2OWIwMmNmZTdmZGVjNjkxZjZhYWNiOWZkMDFiMjFkNjFjMw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-23T18:06:22Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-23T18:06:22Z"}, "message": "simplify-rtx.c (SIGN_EXTEND): New macro.\n\n\t* simplify-rtx.c (SIGN_EXTEND): New macro.\n\t(simplify_unary_operation, simplify_binary_operation,\n\tsimplify_relational_operation): Use SIGN_EXTEND.  Make low\n\thalves of (low, high) pairs unsigned if they weren't already.\n\t(simplify_ternary_operation): Cast INTVAL to unsigned before\n\tcomparing to a MODE_BITSIZE.\n\nFrom-SVN: r34109", "tree": {"sha": "d74eeea151683cddca3288fc1c7051594936223e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d74eeea151683cddca3288fc1c7051594936223e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3839069b02cfe7fdec691f6aacb9fd01b21d61c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3839069b02cfe7fdec691f6aacb9fd01b21d61c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3839069b02cfe7fdec691f6aacb9fd01b21d61c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3839069b02cfe7fdec691f6aacb9fd01b21d61c3/comments", "author": null, "committer": null, "parents": [{"sha": "f31e826ba314bc910beec6de5bf534f2462a00c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31e826ba314bc910beec6de5bf534f2462a00c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31e826ba314bc910beec6de5bf534f2462a00c7"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "54b7927619e34099d1e7798df01f869700d411d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3839069b02cfe7fdec691f6aacb9fd01b21d61c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3839069b02cfe7fdec691f6aacb9fd01b21d61c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3839069b02cfe7fdec691f6aacb9fd01b21d61c3", "patch": "@@ -1,3 +1,12 @@\n+2000-05-23  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* simplify-rtx.c (SIGN_EXTEND): New macro.\n+\t(simplify_unary_operation, simplify_binary_operation, \n+\tsimplify_relational_operation): Use SIGN_EXTEND.  Make low\n+\thalves of (low, high) pairs unsigned if they weren't already.       \n+\t(simplify_ternary_operation): Cast INTVAL to unsigned before\n+\tcomparing to a MODE_BITSIZE.\n+\n 2000-05-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* aclocal.m4 (gcc_AC_CHECK_DECL, gcc_AC_CHECK_DECLS): New macros"}, {"sha": "88d02c1031ab6f4f7f3e688533c50796a45a43dd", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3839069b02cfe7fdec691f6aacb9fd01b21d61c3/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3839069b02cfe7fdec691f6aacb9fd01b21d61c3/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=3839069b02cfe7fdec691f6aacb9fd01b21d61c3", "patch": "@@ -92,6 +92,12 @@ Boston, MA 02111-1307, USA.  */\n \t   || XEXP (X, 0) == virtual_outgoing_args_rtx))\t\\\n    || GET_CODE (X) == ADDRESSOF)\n \n+/* Much code operates on (low, high) pairs; the low value is an\n+   unsigned wide int, the high value a signed wide int.  We\n+   occasionally need to sign extend from low to high as if low were a\n+   signed wide int.  */\n+#define SIGN_EXTEND(low) \\\n+ ((((HOST_WIDE_INT) low) < 0) ? ((HOST_WIDE_INT) -1) : ((HOST_WIDE_INT) 0))\n \n static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx, rtx));\n@@ -246,7 +252,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n       REAL_VALUE_TYPE d;\n \n       if (GET_CODE (op) == CONST_INT)\n-\tlv = INTVAL (op), hv = INTVAL (op) < 0 ? -1 : 0;\n+\tlv = INTVAL (op), hv = SIGN_EXTEND (lv);\n       else\n \tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n \n@@ -279,7 +285,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n       REAL_VALUE_TYPE d;\n \n       if (GET_CODE (op) == CONST_INT)\n-\tlv = INTVAL (op), hv = INTVAL (op) < 0 ? -1 : 0;\n+\tlv = INTVAL (op), hv = SIGN_EXTEND (lv);\n       else\n \tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n \n@@ -399,12 +405,13 @@ simplify_unary_operation (code, mode, op, op_mode)\n   else if (GET_MODE (op) == VOIDmode && width <= HOST_BITS_PER_INT * 2\n \t   && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n     {\n-      HOST_WIDE_INT l1, h1, lv, hv;\n+      unsigned HOST_WIDE_INT l1, lv;\n+      HOST_WIDE_INT h1, hv;\n \n       if (GET_CODE (op) == CONST_DOUBLE)\n \tl1 = CONST_DOUBLE_LOW (op), h1 = CONST_DOUBLE_HIGH (op);\n       else\n-\tl1 = INTVAL (op), h1 = l1 < 0 ? -1 : 0;\n+\tl1 = INTVAL (op), h1 = SIGN_EXTEND (l1);\n \n       switch (code)\n \t{\n@@ -458,7 +465,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t\t\t    << (GET_MODE_BITSIZE (op_mode) - 1))) != 0)\n \t\tlv -= (HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n \n-\t      hv = (lv < 0) ? ~ (HOST_WIDE_INT) 0 : 0;\n+\t      hv = SIGN_EXTEND (lv);\n \t    }\n \t  break;\n \n@@ -709,17 +716,18 @@ simplify_binary_operation (code, mode, op0, op1)\n       && (GET_CODE (op0) == CONST_DOUBLE || GET_CODE (op0) == CONST_INT)\n       && (GET_CODE (op1) == CONST_DOUBLE || GET_CODE (op1) == CONST_INT))\n     {\n-      HOST_WIDE_INT l1, l2, h1, h2, lv, hv;\n+      unsigned HOST_WIDE_INT l1, l2, lv;\n+      HOST_WIDE_INT h1, h2, hv;\n \n       if (GET_CODE (op0) == CONST_DOUBLE)\n \tl1 = CONST_DOUBLE_LOW (op0), h1 = CONST_DOUBLE_HIGH (op0);\n       else\n-\tl1 = INTVAL (op0), h1 = l1 < 0 ? -1 : 0;\n+\tl1 = INTVAL (op0), h1 = SIGN_EXTEND (l1);\n \n       if (GET_CODE (op1) == CONST_DOUBLE)\n \tl2 = CONST_DOUBLE_LOW (op1), h2 = CONST_DOUBLE_HIGH (op1);\n       else\n-\tl2 = INTVAL (op1), h2 = l2 < 0 ? -1 : 0;\n+\tl2 = INTVAL (op1), h2 = SIGN_EXTEND (l2);\n \n       switch (code)\n \t{\n@@ -803,7 +811,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t    l2 &= (GET_MODE_BITSIZE (mode) - 1), h2 = 0;\n #endif\n \n-\t  if (h2 != 0 || l2 < 0 || l2 >= GET_MODE_BITSIZE (mode))\n+\t  if (h2 != 0 || l2 >= GET_MODE_BITSIZE (mode))\n \t    return 0;\n \n \t  if (code == LSHIFTRT || code == ASHIFTRT)\n@@ -1752,7 +1760,7 @@ simplify_relational_operation (code, mode, op0, op1)\n       else\n \t{\n \t  l0u = l0s = INTVAL (op0);\n-\t  h0u = h0s = l0s < 0 ? -1 : 0;\n+\t  h0u = h0s = SIGN_EXTEND (l0s);\n \t}\n \t  \n       if (GET_CODE (op1) == CONST_DOUBLE)\n@@ -1763,13 +1771,13 @@ simplify_relational_operation (code, mode, op0, op1)\n       else\n \t{\n \t  l1u = l1s = INTVAL (op1);\n-\t  h1u = h1s = l1s < 0 ? -1 : 0;\n+\t  h1u = h1s = SIGN_EXTEND (l1s);\n \t}\n \n       /* If WIDTH is nonzero and smaller than HOST_BITS_PER_WIDE_INT,\n \t we have to sign or zero-extend the values.  */\n       if (width != 0 && width <= HOST_BITS_PER_WIDE_INT)\n-\th0u = h1u = 0, h0s = l0s < 0 ? -1 : 0, h1s = l1s < 0 ? -1 : 0;\n+\th0u = h1u = 0, h0s = SIGN_EXTEND (l0s), h1s = SIGN_EXTEND (l1s);\n \n       if (width != 0 && width < HOST_BITS_PER_WIDE_INT)\n \t{\n@@ -1904,7 +1912,8 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n       if (GET_CODE (op0) == CONST_INT\n \t  && GET_CODE (op1) == CONST_INT\n \t  && GET_CODE (op2) == CONST_INT\n-\t  && INTVAL (op1) + INTVAL (op2) <= GET_MODE_BITSIZE (op0_mode)\n+\t  && ((unsigned) INTVAL (op1) + (unsigned) INTVAL (op2)\n+\t      <= GET_MODE_BITSIZE (op0_mode))\n \t  && width <= (unsigned) HOST_BITS_PER_WIDE_INT)\n \t{\n \t  /* Extracting a bit-field from a constant */"}]}