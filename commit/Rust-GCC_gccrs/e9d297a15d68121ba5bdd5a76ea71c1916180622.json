{"sha": "e9d297a15d68121ba5bdd5a76ea71c1916180622", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlkMjk3YTE1ZDY4MTIxYmE1YmRkNWE3NmVhNzFjMTkxNjE4MDYyMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-09-29T18:20:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-09-29T18:20:41Z"}, "message": "sbitmap.c (bitmap_bit_in_range_p): New function.\n\n\t* sbitmap.c (bitmap_bit_in_range_p): New function.\n\t* sbitmap.h (bitmap_bit_in_range_p): Prototype.\n\t* tree-ssa-dse.c (live_bytes_read): New function.\n\t(dse_classify_store): Ignore reads of dead bytes.\n\n\t* testsuite/gcc.dg/tree-ssa/ssa-dse-26.c: New test.\n\nFrom-SVN: r253305", "tree": {"sha": "ec865a0c1b998f4757f69e3cea2d7245e66f6287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec865a0c1b998f4757f69e3cea2d7245e66f6287"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9d297a15d68121ba5bdd5a76ea71c1916180622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d297a15d68121ba5bdd5a76ea71c1916180622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d297a15d68121ba5bdd5a76ea71c1916180622", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d297a15d68121ba5bdd5a76ea71c1916180622/comments", "author": null, "committer": null, "parents": [{"sha": "79310774839953f17cc5aae75ab332c788784466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79310774839953f17cc5aae75ab332c788784466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79310774839953f17cc5aae75ab332c788784466"}], "stats": {"total": 152, "additions": 152, "deletions": 0}, "files": [{"sha": "1932390dd0aaa714b91b5a4aad25bdeab298fb82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9d297a15d68121ba5bdd5a76ea71c1916180622", "patch": "@@ -1,5 +1,10 @@\n 2017-09-29  Jeff Law  <law@redhat.com>\n \n+\t* sbitmap.c (bitmap_bit_in_range_p): New function.\n+\t* sbitmap.h (bitmap_bit_in_range_p): Prototype.\n+\t* tree-ssa-dse.c (live_bytes_read): New function.\n+\t(dse_classify_store): Ignore reads of dead bytes.\n+\n \t* config/i386/i386.c (ix86_adjust_stack_and_probe_stack_clash): Fix\n \ttypos and whitespace errors.\n \t* config/i386/predicates.md (address_no_seg_operand): Likewise."}, {"sha": "4bf13a11a1d2070ebf924f2ec7850d9da99a0c59", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=e9d297a15d68121ba5bdd5a76ea71c1916180622", "patch": "@@ -316,6 +316,59 @@ bitmap_set_range (sbitmap bmap, unsigned int start, unsigned int count)\n   bmap->elms[start_word] |= mask;\n }\n \n+/* Return TRUE if any bit between START and END inclusive is set within\n+   the simple bitmap BMAP.  Return FALSE otherwise.  */\n+\n+bool\n+bitmap_bit_in_range_p (const_sbitmap bmap, unsigned int start, unsigned int end)\n+{\n+  unsigned int start_word = start / SBITMAP_ELT_BITS;\n+  unsigned int start_bitno = start % SBITMAP_ELT_BITS;\n+\n+  /* Testing within a word, starting at the beginning of a word.  */\n+  if (start_bitno == 0 && (end - start) < SBITMAP_ELT_BITS)\n+    {\n+      SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << (end - start)) - 1;\n+      return (bmap->elms[start_word] & mask) != 0;\n+    }\n+\n+  unsigned int end_word = end / SBITMAP_ELT_BITS;\n+  unsigned int end_bitno = end % SBITMAP_ELT_BITS;\n+\n+  /* Testing starts somewhere in the middle of a word.  Test up to the\n+     end of the word or the end of the requested region, whichever comes\n+     first.  */\n+  if (start_bitno != 0)\n+    {\n+      unsigned int nbits = ((start_word == end_word)\n+\t\t\t    ? end_bitno - start_bitno\n+\t\t\t    : SBITMAP_ELT_BITS - start_bitno);\n+      SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << nbits) - 1;\n+      mask <<= start_bitno;\n+      if (bmap->elms[start_word] & mask)\n+\treturn true;\n+      start_word++;\n+    }\n+\n+  if (start_word > end_word)\n+    return false;\n+\n+  /* Now test words at a time until we hit a partial word.  */\n+  unsigned int nwords = (end_word - start_word);\n+  while (nwords)\n+    {\n+      if (bmap->elms[start_word])\n+\treturn true;\n+      start_word++;\n+      nwords--;\n+    }\n+\n+  /* Now handle residuals in the last word.  */\n+  SBITMAP_ELT_TYPE mask\n+    = ((SBITMAP_ELT_TYPE)1 << (SBITMAP_ELT_BITS - end_bitno)) - 1;\n+  return (bmap->elms[start_word] & mask) != 0;\n+}\n+\n #if GCC_VERSION < 3400\n /* Table of number of set bits in a character, indexed by value of char.  */\n static const unsigned char popcount_table[] ="}, {"sha": "ff52e939bf36c3e76fb40bc99f94c53debfacc8b", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=e9d297a15d68121ba5bdd5a76ea71c1916180622", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n      * set_difference\t\t: bitmap_and_compl\n      * set_disjuction\t\t: (not implemented)\n      * set_compare\t\t: bitmap_equal_p\n+     * bit_in_range_p\t\t: bitmap_bit_in_range_p\n \n    Some operations on 3 sets that occur frequently in data flow problems\n    are also implemented:\n@@ -253,6 +254,7 @@ extern bool bitmap_and (sbitmap, const_sbitmap, const_sbitmap);\n extern bool bitmap_ior (sbitmap, const_sbitmap, const_sbitmap);\n extern bool bitmap_xor (sbitmap, const_sbitmap, const_sbitmap);\n extern bool bitmap_subset_p (const_sbitmap, const_sbitmap);\n+extern bool bitmap_bit_in_range_p (const_sbitmap, unsigned int, unsigned int);\n \n extern int bitmap_first_set_bit (const_sbitmap);\n extern int bitmap_last_set_bit (const_sbitmap);"}, {"sha": "890063cf470db3b96ab305f7012c8b0c4484a08c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9d297a15d68121ba5bdd5a76ea71c1916180622", "patch": "@@ -1,3 +1,7 @@\n+2017-09-29  Jeff Law  <law@redhat.com>\n+\n+\t* testsuite/gcc.dg/tree-ssa/ssa-dse-26.c: New test.\n+\n 2017-09-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tP0683R1 - default member initializers for bit-fields"}, {"sha": "6605dfe0aaee019fb38d59cb83d69606b9aae5f0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-26.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-26.c?ref=e9d297a15d68121ba5bdd5a76ea71c1916180622", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-dse1-details\" } */\n+\n+enum constraint_expr_type\n+{\n+  SCALAR, DEREF, ADDRESSOF\n+};\n+typedef struct constraint_expr\n+{\n+  enum constraint_expr_type type;\n+  unsigned int var;\n+  long offset;\n+} constraint_expr ;\n+typedef struct constraint\n+{\n+  struct constraint_expr lhs;\n+  struct constraint_expr rhs;\n+} constraint;\n+static _Bool\n+constraint_expr_equal (struct constraint_expr x, struct constraint_expr y)\n+{\n+  return x.type == y.type && x.var == y.var && x.offset == y.offset;\n+}\n+\n+_Bool\n+constraint_equal (struct constraint a, struct constraint b)\n+{\n+  return constraint_expr_equal (a.lhs, b.lhs)\n+    && constraint_expr_equal (a.rhs, b.rhs);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Deleted dead store\" 2 \"dse1\" } } */\n+"}, {"sha": "1eca740598fc325554da3a359098268fa28fafac", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9d297a15d68121ba5bdd5a76ea71c1916180622/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=e9d297a15d68121ba5bdd5a76ea71c1916180622", "patch": "@@ -468,6 +468,36 @@ maybe_trim_partially_dead_store (ao_ref *ref, sbitmap live, gimple *stmt)\n     }\n }\n \n+/* Return TRUE if USE_REF reads bytes from LIVE where live is\n+   derived from REF, a write reference.\n+\n+   While this routine may modify USE_REF, it's passed by value, not\n+   location.  So callers do not see those modifications.  */\n+\n+static bool\n+live_bytes_read (ao_ref use_ref, ao_ref *ref, sbitmap live)\n+{\n+  /* We have already verified that USE_REF and REF hit the same object.\n+     Now verify that there's actually an overlap between USE_REF and REF.  */\n+  if (ranges_overlap_p (use_ref.offset, use_ref.size, ref->offset, ref->size))\n+    {\n+      normalize_ref (&use_ref, ref);\n+\n+      /* If USE_REF covers all of REF, then it will hit one or more\n+\t live bytes.   This avoids useless iteration over the bitmap\n+\t below.  */\n+      if (use_ref.offset <= ref->offset\n+\t  && use_ref.offset + use_ref.size >= ref->offset + ref->size)\n+\treturn true;\n+\n+      /* Now check if any of the remaining bits in use_ref are set in LIVE.  */\n+      unsigned int start = (use_ref.offset - ref->offset) / BITS_PER_UNIT;\n+      unsigned int end  = (use_ref.offset + use_ref.size) / BITS_PER_UNIT;\n+      return bitmap_bit_in_range_p (live, start, end);\n+    }\n+  return true;\n+}\n+\n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_ASSIGN in STMT that writes to REF, find a candidate\n    statement *USE_STMT that may prove STMT to be dead.\n@@ -547,6 +577,31 @@ dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n \t  /* If the statement is a use the store is not dead.  */\n \t  else if (ref_maybe_used_by_stmt_p (use_stmt, ref))\n \t    {\n+\t      /* Handle common cases where we can easily build a ao_ref\n+\t\t structure for USE_STMT and in doing so we find that the\n+\t\t references hit non-live bytes and thus can be ignored.  */\n+\t      if (live_bytes && (!gimple_vdef (use_stmt) || !temp))\n+\t\t{\n+\t\t  if (is_gimple_assign (use_stmt))\n+\t\t    {\n+\t\t      /* Other cases were noted as non-aliasing by\n+\t\t\t the call to ref_maybe_used_by_stmt_p.  */\n+\t\t      ao_ref use_ref;\n+\t\t      ao_ref_init (&use_ref, gimple_assign_rhs1 (use_stmt));\n+\t\t      if (valid_ao_ref_for_dse (&use_ref)\n+\t\t\t  && use_ref.base == ref->base\n+\t\t\t  && use_ref.size == use_ref.max_size\n+\t\t\t  && !live_bytes_read (use_ref, ref, live_bytes))\n+\t\t\t{\n+\t\t\t  /* If this statement has a VDEF, then it is the\n+\t\t\t     first store we have seen, so walk through it.  */\n+\t\t\t  if (gimple_vdef (use_stmt))\n+\t\t\t    temp = use_stmt;\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n \t      fail = true;\n \t      BREAK_FROM_IMM_USE_STMT (ui);\n \t    }"}]}