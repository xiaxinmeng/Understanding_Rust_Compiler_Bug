{"sha": "7905f799480de8a07eba4cde34bc6e57006cf112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkwNWY3OTk0ODBkZThhMDdlYmE0Y2RlMzRiYzZlNTcwMDZjZjExMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-11-28T09:38:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-11-28T09:38:43Z"}, "message": "ia64.md: Move all define_predicate's ...\n\n        * config/ia64/ia64.md: Move all define_predicate's ...\n        * config/ia64/predicates.md: ... here.  New file.\n\nFrom-SVN: r91414", "tree": {"sha": "6f3ff7f7e2b598b9bafa238ea3f375fe672dd599", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f3ff7f7e2b598b9bafa238ea3f375fe672dd599"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7905f799480de8a07eba4cde34bc6e57006cf112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7905f799480de8a07eba4cde34bc6e57006cf112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7905f799480de8a07eba4cde34bc6e57006cf112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7905f799480de8a07eba4cde34bc6e57006cf112/comments", "author": null, "committer": null, "parents": [{"sha": "ca6b99558d9cbd22bd88c922c629c34a76c27535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6b99558d9cbd22bd88c922c629c34a76c27535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca6b99558d9cbd22bd88c922c629c34a76c27535"}], "stats": {"total": 704, "additions": 360, "deletions": 344}, "files": [{"sha": "3984aaabf11a6a3b71898004ba5fbf2bb3184286", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7905f799480de8a07eba4cde34bc6e57006cf112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7905f799480de8a07eba4cde34bc6e57006cf112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7905f799480de8a07eba4cde34bc6e57006cf112", "patch": "@@ -1,3 +1,8 @@\n+2004-11-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.md: Move all define_predicate's ...\n+\t* config/ia64/predicates.md: ... here.  New file.\n+\n 2004-11-27  Per Bothner  <per@bothner.com>\n \n \tPR bootstrap/18142"}, {"sha": "15650c5c718c49b8ed4f2d77211f6c7a7c9a7b7a", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 1, "deletions": 344, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7905f799480de8a07eba4cde34bc6e57006cf112/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7905f799480de8a07eba4cde34bc6e57006cf112/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=7905f799480de8a07eba4cde34bc6e57006cf112", "patch": "@@ -90,347 +90,8 @@\n    (UNSPECV_PSAC_NORMAL\t\t6)\n    (UNSPECV_SETJMP_RECEIVER\t7)\n   ])\n-\f\n-;; ::::::::::::::::::::\n-;; ::\n-;; :: Predicates\n-;; ::\n-;; ::::::::::::::::::::\n-\n-;; True if OP is a valid operand for the MEM of a CALL insn.\n-(define_predicate \"call_operand\"\n-  (ior (match_code \"symbol_ref\")\n-       (match_operand 0 \"register_operand\")))\n-\n-;; True if OP refers to any kind of symbol.\n-;; For roughly the same reasons that pmode_register_operand exists, this\n-;; predicate ignores its mode argument.\n-(define_special_predicate \"symbolic_operand\" \n-   (match_code \"symbol_ref,const,label_ref\"))\n-\n-;; True if OP is a SYMBOL_REF which refers to a function.\n-(define_predicate \"function_operand\"\n-  (and (match_code \"symbol_ref\")\n-       (match_test \"SYMBOL_REF_FUNCTION_P (op)\")))\n-\n-;; True if OP refers to a symbol, and is appropriate for a GOT load.\n-(define_predicate \"got_symbolic_operand\" \n-  (match_operand 0 \"symbolic_operand\" \"\")\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case LABEL_REF:\n-      return true;\n-\n-    case SYMBOL_REF:\n-      /* This sort of load should not be used for things in sdata.  */\n-      return !SYMBOL_REF_SMALL_ADDR_P (op);\n-\n-    case CONST:\n-      /* Accept only (plus (symbol_ref) (const_int)).  */\n-      op = XEXP (op, 0);\n-      if (GET_CODE (op) != PLUS\n-\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n-          || GET_CODE (XEXP (op, 1)) != CONST_INT)\n-        return false;\n-\n-      /* Ok if we're not using GOT entries at all.  */\n-      if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n-        return true;\n-\n-      /* The low 14 bits of the constant have been forced to zero\n-\t by ia64_expand_load_address, so that we do not use up so\n-\t many GOT entries.  Prevent cse from undoing this.  */\n-      op = XEXP (op, 1);\n-      return (INTVAL (op) & 0x3fff) == 0;\n-\n-    default:\n-      abort ();\n-    }\n-})\n-\n-;; True if OP refers to a symbol in the sdata section.\n-(define_predicate \"sdata_symbolic_operand\" \n-  (match_code \"symbol_ref,const\")\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST:\n-      op = XEXP (op, 0);\n-      if (GET_CODE (op) != PLUS\n-\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n-\treturn false;\n-      op = XEXP (op, 0);\n-      /* FALLTHRU */\n-\n-    case SYMBOL_REF:\n-      if (CONSTANT_POOL_ADDRESS_P (op))\n-\treturn GET_MODE_SIZE (get_pool_mode (op)) <= ia64_section_threshold;\n-      else\n-\treturn SYMBOL_REF_LOCAL_P (op) && SYMBOL_REF_SMALL_P (op);\n-\n-    default:\n-      abort ();\n-    }\n-})\n-\n-;; Like nonimmediate_operand, but don't allow MEMs that try to use a\n-;; POST_MODIFY with a REG as displacement.\n-(define_predicate \"destination_operand\"\n-  (and (match_operand 0 \"nonimmediate_operand\")\n-       (match_test \"GET_CODE (op) != MEM\n-\t\t    || GET_CODE (XEXP (op, 0)) != POST_MODIFY\n-\t\t    || GET_CODE (XEXP (XEXP (XEXP (op, 0), 1), 1)) != REG\")))\n-\n-;; Like memory_operand, but don't allow post-increments.\n-(define_predicate \"not_postinc_memory_operand\"\n-  (and (match_operand 0 \"memory_operand\")\n-       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n-\n-;; True if OP is a general operand, excluding tls symbolic operands.\n-(define_predicate \"move_operand\"\n-  (and (match_operand 0 \"general_operand\")\n-       (not (match_test \n-\t     \"GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (op)\"))))\n-\n-;; True if OP is a register operand that is (or could be) a GR reg.\n-(define_predicate \"gr_register_operand\"\n-  (match_operand 0 \"register_operand\")\n-{\n-  unsigned int regno;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  regno = REGNO (op);\n-  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));\n-})\n-\n-;; True if OP is a register operand that is (or could be) an FR reg.\n-(define_predicate \"fr_register_operand\"\n-  (match_operand 0 \"register_operand\")\n-{\n-  unsigned int regno;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  regno = REGNO (op);\n-  return (regno >= FIRST_PSEUDO_REGISTER || FR_REGNO_P (regno));\n-})\n-\n-;; True if OP is a register operand that is (or could be) a GR/FR reg.\n-(define_predicate \"grfr_register_operand\"\n-  (match_operand 0 \"register_operand\")\n-{\n-  unsigned int regno;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  regno = REGNO (op);\n-  return (regno >= FIRST_PSEUDO_REGISTER\n-\t  || GENERAL_REGNO_P (regno)\n-\t  || FR_REGNO_P (regno));\n-})\n-\n-;; True if OP is a nonimmediate operand that is (or could be) a GR reg.\n-(define_predicate \"gr_nonimmediate_operand\"\n-  (match_operand 0 \"nonimmediate_operand\")\n-{\n-  unsigned int regno;\n-\n-  if (GET_CODE (op) == MEM)\n-    return true;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  regno = REGNO (op);\n-  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));\n-})\n-\n-;; True if OP is a nonimmediate operand that is (or could be) a FR reg.\n-(define_predicate \"fr_nonimmediate_operand\"\n-  (match_operand 0 \"nonimmediate_operand\")\n-{\n-  unsigned int regno;\n-\n-  if (GET_CODE (op) == MEM)\n-    return true;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  regno = REGNO (op);\n-  return (regno >= FIRST_PSEUDO_REGISTER || FR_REGNO_P (regno));\n-})\n-\n-;; True if OP is a nonimmediate operand that is (or could be) a GR/FR reg.\n-(define_predicate \"grfr_nonimmediate_operand\"\n-  (match_operand 0 \"nonimmediate_operand\")\n-{\n-  unsigned int regno;\n-\n-  if (GET_CODE (op) == MEM)\n-    return true;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  regno = REGNO (op);\n-  return (regno >= FIRST_PSEUDO_REGISTER\n-\t  || GENERAL_REGNO_P (regno)\n-\t  || FR_REGNO_P (regno));\n-})\n-\n-;; True if OP is a GR register operand, or zero.\n-(define_predicate \"gr_reg_or_0_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"op == const0_rtx\"))))\n-\n-;; True if OP is a GR register operand, or a 5 bit immediate operand.\n-(define_predicate \"gr_reg_or_5bit_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 32\"))))\n-\n-;; True if OP is a GR register operand, or a 6 bit immediate operand.\n-(define_predicate \"gr_reg_or_6bit_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_M (INTVAL (op))\"))))\n-\n-;; True if OP is a GR register operand, or an 8 bit immediate operand.\n-(define_predicate \"gr_reg_or_8bit_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n-\n-;; True if OP is a GR/FR register operand, or an 8 bit immediate operand.\n-(define_predicate \"grfr_reg_or_8bit_operand\"\n-  (ior (match_operand 0 \"grfr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n-\n-;; True if OP is a register operand, or an 8 bit adjusted immediate operand.\n-(define_predicate \"gr_reg_or_8bit_adjusted_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_L (INTVAL (op))\"))))\n-\n-;; True if OP is a register operand, or is valid for both an 8 bit\n-;; immediate and an 8 bit adjusted immediate operand.  This is necessary\n-;; because when we emit a compare, we don't know what the condition will be,\n-;; so we need the union of the immediates accepted by GT and LT.\n-(define_predicate \"gr_reg_or_8bit_and_adjusted_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\n-                         && CONST_OK_FOR_L (INTVAL (op))\"))))\n-\n-;; True if OP is a register operand, or a 14 bit immediate operand.\n-(define_predicate \"gr_reg_or_14bit_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_I (INTVAL (op))\"))))\n-\n-;;  True if OP is a register operand, or a 22 bit immediate operand.\n-(define_predicate \"gr_reg_or_22bit_operand\"\n-  (ior (match_operand 0 \"gr_register_operand\")\n-       (and (match_code \"const_int\")\n-\t    (match_test \"CONST_OK_FOR_J (INTVAL (op))\"))))\n-\n-;; True if OP is a 7 bit immediate operand.\n-(define_predicate \"dshift_count_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 128\")))\n-\n-;; True if OP is a 6 bit immediate operand.\n-(define_predicate \"shift_count_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"CONST_OK_FOR_M (INTVAL (op))\")))\n-\n-;; True if OP is a 5 bit immediate operand.\n-(define_predicate \"shift_32bit_count_operand\"\n-   (and (match_code \"const_int\")\n-        (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 32\")))\n-\n-;; True if OP is one of the immediate values 2, 4, 8, or 16.\n-(define_predicate \"shladd_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4 ||\n-\t            INTVAL (op) == 8 || INTVAL (op) == 16\")))\n-\n-;; True if OP is one of the immediate values  -16, -8, -4, -1, 1, 4, 8, 16.\n-(define_predicate \"fetchadd_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"INTVAL (op) == -16 || INTVAL (op) == -8 ||\n-                    INTVAL (op) == -4  || INTVAL (op) == -1 ||\n-                    INTVAL (op) == 1   || INTVAL (op) == 4  ||\n-                    INTVAL (op) == 8   || INTVAL (op) == 16\")))\n-\n-\n-;; True if OP is a floating-point constant zero, one, or a register.\n-(define_predicate \"fr_reg_or_fp01_operand\"\n-  (ior (match_operand 0 \"fr_register_operand\")\n-       (and (match_code \"const_double\")\n-\t    (match_test \"CONST_DOUBLE_OK_FOR_G (op)\"))))\n-\n-;; Like fr_reg_or_fp01_operand, but don't allow any SUBREGs.\n-(define_predicate \"xfreg_or_fp01_operand\"\n-  (and (match_operand 0 \"fr_reg_or_fp01_operand\")\n-       (not (match_code \"subreg\"))))\n-\n-;; True if this is a comparison operator, which accepts a normal 8-bit\n-;; signed immediate operand.\n-(define_predicate \"normal_comparison_operator\"\n-  (match_code \"eq,ne,gt,le,gtu,leu\"))\n-\n-;; True if this is a comparison operator, which accepts an adjusted 8-bit\n-;; signed immediate operand.\n-(define_predicate \"adjusted_comparison_operator\"\n-  (match_code \"lt,ge,ltu,geu\"))\n-\n-;; True if this is a signed inequality operator.\n-(define_predicate \"signed_inequality_operator\"\n-  (match_code \"ge,gt,le,lt\"))\n-\n-;; True if this operator is valid for predication.\n-(define_predicate \"predicate_operator\"\n-  (match_code \"eq,ne\"))\n-\n-;; True if this operator can be used in a conditional operation.\n-(define_predicate \"condop_operator\"\n-  (match_code \"plus,minus,ior,xor,and\"))\n-\n-;; These three are hardware registers that can only be addressed in\n-;; DImode.  It's not strictly necessary to test mode == DImode here,\n-;; but it makes decent insurance against someone writing a\n-;; match_operand wrong.\n-\n-;; True if this is the ar.lc register.\n-(define_predicate \"ar_lc_reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"mode == DImode && REGNO (op) == AR_LC_REGNUM\")))\n-\n-;; True if this is the ar.ccv register.\n-(define_predicate \"ar_ccv_reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"mode == DImode && REGNO (op) == AR_CCV_REGNUM\")))\n-\n-;; True if this is the ar.pfs register.\n-(define_predicate \"ar_pfs_reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"mode == DImode && REGNO (op) == AR_PFS_REGNUM\")))\n-\n-;; True if OP is valid as a base register in a reg + offset address.\n-;; ??? Should I copy the flag_omit_frame_pointer and cse_not_expected\n-;; checks from pa.c basereg_operand as well?  Seems to be OK without them\n-;; in test runs.\n-(define_predicate \"basereg_operand\"\n-  (match_operand 0 \"register_operand\")\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_POINTER (op);\n-})\n \n+(include \"predicates.md\")\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -501,7 +162,6 @@\n (define_attr \"empty\" \"no,yes\" (const_string \"no\"))\n \n \f\n-\n ;; DFA descriptions of ia64 processors used for insn scheduling and\n ;; bundling.\n \n@@ -512,9 +172,6 @@\n \n (automata_option \"w\")\n \n-;;(automata_option \"no-minimization\")\n-\n-\n (include \"itanium1.md\")\n (include \"itanium2.md\")\n "}, {"sha": "b66df845baa3c77522d978db72a4d3b4803a3595", "filename": "gcc/config/ia64/predicates.md", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7905f799480de8a07eba4cde34bc6e57006cf112/gcc%2Fconfig%2Fia64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7905f799480de8a07eba4cde34bc6e57006cf112/gcc%2Fconfig%2Fia64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fpredicates.md?ref=7905f799480de8a07eba4cde34bc6e57006cf112", "patch": "@@ -0,0 +1,354 @@\n+;; Predicate definitions for IA-64.\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; True if OP is a valid operand for the MEM of a CALL insn.\n+(define_predicate \"call_operand\"\n+  (ior (match_code \"symbol_ref\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; True if OP refers to any kind of symbol.\n+;; For roughly the same reasons that pmode_register_operand exists, this\n+;; predicate ignores its mode argument.\n+(define_special_predicate \"symbolic_operand\" \n+   (match_code \"symbol_ref,const,label_ref\"))\n+\n+;; True if OP is a SYMBOL_REF which refers to a function.\n+(define_predicate \"function_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_FUNCTION_P (op)\")))\n+\n+;; True if OP refers to a symbol, and is appropriate for a GOT load.\n+(define_predicate \"got_symbolic_operand\" \n+  (match_operand 0 \"symbolic_operand\" \"\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+      return true;\n+\n+    case SYMBOL_REF:\n+      /* This sort of load should not be used for things in sdata.  */\n+      return !SYMBOL_REF_SMALL_ADDR_P (op);\n+\n+    case CONST:\n+      /* Accept only (plus (symbol_ref) (const_int)).  */\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+          || GET_CODE (XEXP (op, 1)) != CONST_INT)\n+        return false;\n+\n+      /* Ok if we're not using GOT entries at all.  */\n+      if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n+        return true;\n+\n+      /* The low 14 bits of the constant have been forced to zero\n+\t by ia64_expand_load_address, so that we do not use up so\n+\t many GOT entries.  Prevent cse from undoing this.  */\n+      op = XEXP (op, 1);\n+      return (INTVAL (op) & 0x3fff) == 0;\n+\n+    default:\n+      abort ();\n+    }\n+})\n+\n+;; True if OP refers to a symbol in the sdata section.\n+(define_predicate \"sdata_symbolic_operand\" \n+  (match_code \"symbol_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n+\treturn false;\n+      op = XEXP (op, 0);\n+      /* FALLTHRU */\n+\n+    case SYMBOL_REF:\n+      if (CONSTANT_POOL_ADDRESS_P (op))\n+\treturn GET_MODE_SIZE (get_pool_mode (op)) <= ia64_section_threshold;\n+      else\n+\treturn SYMBOL_REF_LOCAL_P (op) && SYMBOL_REF_SMALL_P (op);\n+\n+    default:\n+      abort ();\n+    }\n+})\n+\n+;; Like nonimmediate_operand, but don't allow MEMs that try to use a\n+;; POST_MODIFY with a REG as displacement.\n+(define_predicate \"destination_operand\"\n+  (and (match_operand 0 \"nonimmediate_operand\")\n+       (match_test \"GET_CODE (op) != MEM\n+\t\t    || GET_CODE (XEXP (op, 0)) != POST_MODIFY\n+\t\t    || GET_CODE (XEXP (XEXP (XEXP (op, 0), 1), 1)) != REG\")))\n+\n+;; Like memory_operand, but don't allow post-increments.\n+(define_predicate \"not_postinc_memory_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n+\n+;; True if OP is a general operand, excluding tls symbolic operands.\n+(define_predicate \"move_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (not (match_test \n+\t     \"GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (op)\"))))\n+\n+;; True if OP is a register operand that is (or could be) a GR reg.\n+(define_predicate \"gr_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));\n+})\n+\n+;; True if OP is a register operand that is (or could be) an FR reg.\n+(define_predicate \"fr_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a register operand that is (or could be) a GR/FR reg.\n+(define_predicate \"grfr_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER\n+\t  || GENERAL_REGNO_P (regno)\n+\t  || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a nonimmediate operand that is (or could be) a GR reg.\n+(define_predicate \"gr_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  unsigned int regno;\n+\n+  if (GET_CODE (op) == MEM)\n+    return true;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));\n+})\n+\n+;; True if OP is a nonimmediate operand that is (or could be) a FR reg.\n+(define_predicate \"fr_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  unsigned int regno;\n+\n+  if (GET_CODE (op) == MEM)\n+    return true;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a nonimmediate operand that is (or could be) a GR/FR reg.\n+(define_predicate \"grfr_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  unsigned int regno;\n+\n+  if (GET_CODE (op) == MEM)\n+    return true;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER\n+\t  || GENERAL_REGNO_P (regno)\n+\t  || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a GR register operand, or zero.\n+(define_predicate \"gr_reg_or_0_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"op == const0_rtx\"))))\n+\n+;; True if OP is a GR register operand, or a 5 bit immediate operand.\n+(define_predicate \"gr_reg_or_5bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 32\"))))\n+\n+;; True if OP is a GR register operand, or a 6 bit immediate operand.\n+(define_predicate \"gr_reg_or_6bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_M (INTVAL (op))\"))))\n+\n+;; True if OP is a GR register operand, or an 8 bit immediate operand.\n+(define_predicate \"gr_reg_or_8bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n+\n+;; True if OP is a GR/FR register operand, or an 8 bit immediate operand.\n+(define_predicate \"grfr_reg_or_8bit_operand\"\n+  (ior (match_operand 0 \"grfr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n+\n+;; True if OP is a register operand, or an 8 bit adjusted immediate operand.\n+(define_predicate \"gr_reg_or_8bit_adjusted_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_L (INTVAL (op))\"))))\n+\n+;; True if OP is a register operand, or is valid for both an 8 bit\n+;; immediate and an 8 bit adjusted immediate operand.  This is necessary\n+;; because when we emit a compare, we don't know what the condition will be,\n+;; so we need the union of the immediates accepted by GT and LT.\n+(define_predicate \"gr_reg_or_8bit_and_adjusted_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\n+                         && CONST_OK_FOR_L (INTVAL (op))\"))))\n+\n+;; True if OP is a register operand, or a 14 bit immediate operand.\n+(define_predicate \"gr_reg_or_14bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_I (INTVAL (op))\"))))\n+\n+;;  True if OP is a register operand, or a 22 bit immediate operand.\n+(define_predicate \"gr_reg_or_22bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_J (INTVAL (op))\"))))\n+\n+;; True if OP is a 7 bit immediate operand.\n+(define_predicate \"dshift_count_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 128\")))\n+\n+;; True if OP is a 6 bit immediate operand.\n+(define_predicate \"shift_count_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"CONST_OK_FOR_M (INTVAL (op))\")))\n+\n+;; True if OP is a 5 bit immediate operand.\n+(define_predicate \"shift_32bit_count_operand\"\n+   (and (match_code \"const_int\")\n+        (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 32\")))\n+\n+;; True if OP is one of the immediate values 2, 4, 8, or 16.\n+(define_predicate \"shladd_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4 ||\n+\t            INTVAL (op) == 8 || INTVAL (op) == 16\")))\n+\n+;; True if OP is one of the immediate values  -16, -8, -4, -1, 1, 4, 8, 16.\n+(define_predicate \"fetchadd_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == -16 || INTVAL (op) == -8 ||\n+                    INTVAL (op) == -4  || INTVAL (op) == -1 ||\n+                    INTVAL (op) == 1   || INTVAL (op) == 4  ||\n+                    INTVAL (op) == 8   || INTVAL (op) == 16\")))\n+\n+\n+;; True if OP is a floating-point constant zero, one, or a register.\n+(define_predicate \"fr_reg_or_fp01_operand\"\n+  (ior (match_operand 0 \"fr_register_operand\")\n+       (and (match_code \"const_double\")\n+\t    (match_test \"CONST_DOUBLE_OK_FOR_G (op)\"))))\n+\n+;; Like fr_reg_or_fp01_operand, but don't allow any SUBREGs.\n+(define_predicate \"xfreg_or_fp01_operand\"\n+  (and (match_operand 0 \"fr_reg_or_fp01_operand\")\n+       (not (match_code \"subreg\"))))\n+\n+;; True if this is a comparison operator, which accepts a normal 8-bit\n+;; signed immediate operand.\n+(define_predicate \"normal_comparison_operator\"\n+  (match_code \"eq,ne,gt,le,gtu,leu\"))\n+\n+;; True if this is a comparison operator, which accepts an adjusted 8-bit\n+;; signed immediate operand.\n+(define_predicate \"adjusted_comparison_operator\"\n+  (match_code \"lt,ge,ltu,geu\"))\n+\n+;; True if this is a signed inequality operator.\n+(define_predicate \"signed_inequality_operator\"\n+  (match_code \"ge,gt,le,lt\"))\n+\n+;; True if this operator is valid for predication.\n+(define_predicate \"predicate_operator\"\n+  (match_code \"eq,ne\"))\n+\n+;; True if this operator can be used in a conditional operation.\n+(define_predicate \"condop_operator\"\n+  (match_code \"plus,minus,ior,xor,and\"))\n+\n+;; These three are hardware registers that can only be addressed in\n+;; DImode.  It's not strictly necessary to test mode == DImode here,\n+;; but it makes decent insurance against someone writing a\n+;; match_operand wrong.\n+\n+;; True if this is the ar.lc register.\n+(define_predicate \"ar_lc_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"mode == DImode && REGNO (op) == AR_LC_REGNUM\")))\n+\n+;; True if this is the ar.ccv register.\n+(define_predicate \"ar_ccv_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"mode == DImode && REGNO (op) == AR_CCV_REGNUM\")))\n+\n+;; True if this is the ar.pfs register.\n+(define_predicate \"ar_pfs_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"mode == DImode && REGNO (op) == AR_PFS_REGNUM\")))\n+\n+;; True if OP is valid as a base register in a reg + offset address.\n+;; ??? Should I copy the flag_omit_frame_pointer and cse_not_expected\n+;; checks from pa.c basereg_operand as well?  Seems to be OK without them\n+;; in test runs.\n+(define_predicate \"basereg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REG_POINTER (op);\n+})\n+"}]}