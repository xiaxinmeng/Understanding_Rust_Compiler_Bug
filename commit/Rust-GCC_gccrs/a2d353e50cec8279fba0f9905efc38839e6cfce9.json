{"sha": "a2d353e50cec8279fba0f9905efc38839e6cfce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJkMzUzZTUwY2VjODI3OWZiYTBmOTkwNWVmYzM4ODM5ZTZjZmNlOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-25T12:19:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-25T12:19:23Z"}, "message": "(find_reloads): Don't restrict class of multiword operand to preferred class.\n\n(find_reloads_address_1): Rework to use `switch'.\nReload a SUBREG of a hard reg as a unit.\n\nFrom-SVN: r6622", "tree": {"sha": "f281395f57292f9790841137ffcde384404c1f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f281395f57292f9790841137ffcde384404c1f27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2d353e50cec8279fba0f9905efc38839e6cfce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2d353e50cec8279fba0f9905efc38839e6cfce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2d353e50cec8279fba0f9905efc38839e6cfce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2d353e50cec8279fba0f9905efc38839e6cfce9/comments", "author": null, "committer": null, "parents": [{"sha": "8bffcaf6a039d6ab262ac2b90d8fa7174d764320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bffcaf6a039d6ab262ac2b90d8fa7174d764320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bffcaf6a039d6ab262ac2b90d8fa7174d764320"}], "stats": {"total": 330, "additions": 184, "deletions": 146}, "files": [{"sha": "37d3dd837c5074039b528881ac0af5f6c8622627", "filename": "gcc/reload.c", "status": "modified", "additions": 184, "deletions": 146, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2d353e50cec8279fba0f9905efc38839e6cfce9/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2d353e50cec8279fba0f9905efc38839e6cfce9/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a2d353e50cec8279fba0f9905efc38839e6cfce9", "patch": "@@ -2971,18 +2971,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     Don't bother with this if this alternative will accept this\n \t     operand.\n \n-\t     Don't do this for a multiword operand, if\n-\t     we have to worry about small classes, because making reg groups\n-\t     harder to allocate is asking for trouble.\n+\t     Don't do this for a multiword operand, since it is only a\n+\t     small win and has the risk of requiring more spill registers,\n+\t     which could cause a large loss.\n \n \t     Don't do this if the preferred class has only one register\n \t     because we might otherwise exhaust the class.  */\n \n \n \t  if (! win && this_alternative[i] != (int) NO_REGS\n-#ifdef SMALL_REGISTER_CLASSES\n \t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-#endif\n \t      && reg_class_size[(int) preferred_class[i]] > 1)\n \t    {\n \t      if (! reg_class_subset_p (this_alternative[i],\n@@ -4408,92 +4406,107 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n {\n   register RTX_CODE code = GET_CODE (x);\n \n-  if (code == PLUS)\n+  switch (code)\n     {\n-      register rtx orig_op0 = XEXP (x, 0);\n-      register rtx orig_op1 = XEXP (x, 1);\n-      register RTX_CODE code0 = GET_CODE (orig_op0);\n-      register RTX_CODE code1 = GET_CODE (orig_op1);\n-      register rtx op0 = orig_op0;\n-      register rtx op1 = orig_op1;\n-\n-      if (GET_CODE (op0) == SUBREG)\n-\t{\n-\t  op0 = SUBREG_REG (op0);\n-\t  code0 = GET_CODE (op0);\n-\t}\n-      if (GET_CODE (op1) == SUBREG)\n-\t{\n-\t  op1 = SUBREG_REG (op1);\n-\t  code1 = GET_CODE (op1);\n-\t}\n+    case PLUS:\n+      {\n+\tregister rtx orig_op0 = XEXP (x, 0);\n+\tregister rtx orig_op1 = XEXP (x, 1);\n+\tregister RTX_CODE code0 = GET_CODE (orig_op0);\n+\tregister RTX_CODE code1 = GET_CODE (orig_op1);\n+\tregister rtx op0 = orig_op0;\n+\tregister rtx op1 = orig_op1;\n+\n+\tif (GET_CODE (op0) == SUBREG)\n+\t  {\n+\t    op0 = SUBREG_REG (op0);\n+\t    code0 = GET_CODE (op0);\n+\t  }\n \n-      if (code0 == MULT || code0 == SIGN_EXTEND || code1 == MEM)\n-\t{\n-\t  find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n-\t\t\t\t  ind_levels);\n-\t  find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n-\t\t\t\t  ind_levels);\n-\t}\n-      else if (code1 == MULT || code1 == SIGN_EXTEND || code0 == MEM)\n-\t{\n-\t  find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n-\t\t\t\t  ind_levels);\n-\t  find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n-\t\t\t\t  ind_levels);\n-\t}\n-      else if (code0 == CONST_INT || code0 == CONST\n-\t       || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\tfind_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type, ind_levels);\n-      else if (code1 == CONST_INT || code1 == CONST\n-\t       || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\tfind_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type, ind_levels);\n-      else if (code0 == REG && code1 == REG)\n-\t{\n-\t  if (REG_OK_FOR_INDEX_P (op0)\n-\t      && REG_OK_FOR_BASE_P (op1))\n-\t    return 0;\n-\t  else if (REG_OK_FOR_INDEX_P (op1)\n-\t      && REG_OK_FOR_BASE_P (op0))\n-\t    return 0;\n-\t  else if (REG_OK_FOR_BASE_P (op1))\n-\t    find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type, \n+\tif (GET_CODE (op1) == SUBREG)\n+\t  {\n+\t    op1 = SUBREG_REG (op1);\n+\t    code1 = GET_CODE (op1);\n+\t  }\n+\n+\tif (code0 == MULT || code0 == SIGN_EXTEND || code1 == MEM)\n+\t  {\n+\t    find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n \t\t\t\t    ind_levels);\n-\t  else if (REG_OK_FOR_BASE_P (op0))\n-\t    find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n+\t    find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n \t\t\t\t    ind_levels);\n-\t  else if (REG_OK_FOR_INDEX_P (op1))\n+\t  }\n+\n+\telse if (code1 == MULT || code1 == SIGN_EXTEND || code0 == MEM)\n+\t  {\n \t    find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n \t\t\t\t    ind_levels);\n-\t  else if (REG_OK_FOR_INDEX_P (op0))\n-\t    find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n+\t    find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n \t\t\t\t    ind_levels);\n-\t  else\n-\t    {\n-\t      find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n-\t\t\t\t      ind_levels);\n-\t      find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n-\t\t\t\t      ind_levels);\n-\t    }\n-\t}\n-      else if (code0 == REG)\n-\t{\n-\t  find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n-\t\t\t\t  ind_levels);\n+\t  }\n+\n+\telse if (code0 == CONST_INT || code0 == CONST\n+\t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n \t  find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n \t\t\t\t  ind_levels);\n-\t}\n-      else if (code1 == REG)\n-\t{\n-\t  find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n-\t\t\t\t  ind_levels);\n+\n+\telse if (code1 == CONST_INT || code1 == CONST\n+\t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n \t  find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n \t\t\t\t  ind_levels);\n-\t}\n-    }\n-  else if (code == POST_INC || code == POST_DEC\n-\t   || code == PRE_INC || code == PRE_DEC)\n-    {\n+\n+\telse if (code0 == REG && code1 == REG)\n+\t  {\n+\t    if (REG_OK_FOR_INDEX_P (op0)\n+\t\t&& REG_OK_FOR_BASE_P (op1))\n+\t      return 0;\n+\t    else if (REG_OK_FOR_INDEX_P (op1)\n+\t\t     && REG_OK_FOR_BASE_P (op0))\n+\t      return 0;\n+\t    else if (REG_OK_FOR_BASE_P (op1))\n+\t      find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type, \n+\t\t\t\t      ind_levels);\n+\t    else if (REG_OK_FOR_BASE_P (op0))\n+\t      find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n+\t\t\t\t      ind_levels);\n+\t    else if (REG_OK_FOR_INDEX_P (op1))\n+\t      find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n+\t\t\t\t      ind_levels);\n+\t    else if (REG_OK_FOR_INDEX_P (op0))\n+\t    find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n+\t\t\t\t    ind_levels);\n+\t    else\n+\t      {\n+\t\tfind_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n+\t\t\t\t\tind_levels);\n+\t\tfind_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n+\t\t\t\t\tind_levels);\n+\t      }\n+\t  }\n+\n+\telse if (code0 == REG)\n+\t  {\n+\t    find_reloads_address_1 (orig_op0, 1, &XEXP (x, 0), opnum, type,\n+\t\t\t\t    ind_levels);\n+\t    find_reloads_address_1 (orig_op1, 0, &XEXP (x, 1), opnum, type,\n+\t\t\t\t    ind_levels);\n+\t  }\n+\n+\telse if (code1 == REG)\n+\t  {\n+\t    find_reloads_address_1 (orig_op1, 1, &XEXP (x, 1), opnum, type,\n+\t\t\t\t    ind_levels);\n+\t    find_reloads_address_1 (orig_op0, 0, &XEXP (x, 0), opnum, type,\n+\t\t\t\t    ind_levels);\n+\t  }\n+      }\n+\n+      return 0;\n+\n+    case POST_INC:\n+    case POST_DEC:\n+    case PRE_INC:\n+    case PRE_DEC:\n       if (GET_CODE (XEXP (x, 0)) == REG)\n \t{\n \t  register int regno = REGNO (XEXP (x, 0));\n@@ -4559,6 +4572,7 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n \t    }\n \t  return value;\n \t}\n+\n       else if (GET_CODE (XEXP (x, 0)) == MEM)\n \t{\n \t  /* This is probably the result of a substitution, by eliminate_regs,\n@@ -4591,95 +4605,119 @@ find_reloads_address_1 (x, context, loc, opnum, type, ind_levels)\n \n \t  return 1;\n \t}\n-    }\n-  else if (code == MEM)\n-    {\n-      /* This is probably the result of a substitution, by eliminate_regs,\n-\t of an equivalent address for a pseudo that was not allocated to a\n-\t hard register.  Verify that the specified address is valid and reload\n-\t it into a register.\n+      return 0;\n+\n+    case MEM:\n+      /* This is probably the result of a substitution, by eliminate_regs, of\n+\t an equivalent address for a pseudo that was not allocated to a hard\n+\t register.  Verify that the specified address is valid and reload it\n+\t into a register.\n \n-\t Since we know we are going to reload this item, don't decrement\n-\t for the indirection level.\n+\t Since we know we are going to reload this item, don't decrement for\n+\t the indirection level.\n \n \t Note that this is actually conservative:  it would be slightly more\n \t efficient to use the value of SPILL_INDIRECT_LEVELS from\n \t reload1.c here.  */\n \n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t    opnum, type, ind_levels);\n-\n       push_reload (*loc, NULL_RTX, loc, NULL_PTR,\n \t\t   context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n \t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n       return 1;\n-    }\n-  else if (code == REG)\n-    {\n-      register int regno = REGNO (x);\n \n-      if (reg_equiv_constant[regno] != 0)\n-\t{\n-\t  find_reloads_address_part (reg_equiv_constant[regno], loc, \n-\t\t\t\t     (context ? INDEX_REG_CLASS\n-\t\t\t\t      : BASE_REG_CLASS),\n-\t\t\t\t     GET_MODE (x), opnum, type, ind_levels);\n-\t  return 1;\n-\t}\n+    case REG:\n+      {\n+\tregister int regno = REGNO (x);\n+\n+\tif (reg_equiv_constant[regno] != 0)\n+\t  {\n+\t    find_reloads_address_part (reg_equiv_constant[regno], loc, \n+\t\t\t\t       (context ? INDEX_REG_CLASS\n+\t\t\t\t\t: BASE_REG_CLASS),\n+\t\t\t\t       GET_MODE (x), opnum, type, ind_levels);\n+\t    return 1;\n+\t  }\n \n #if 0 /* This might screw code in reload1.c to delete prior output-reload\n \t that feeds this insn.  */\n-      if (reg_equiv_mem[regno] != 0)\n-\t{\n-\t  push_reload (reg_equiv_mem[regno], NULL_RTX, loc, NULL_PTR,\n-\t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n-\t  return 1;\n-\t}\n+\tif (reg_equiv_mem[regno] != 0)\n+\t  {\n+\t    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, NULL_PTR,\n+\t\t\t context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n+\t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t    return 1;\n+\t  }\n #endif\n-      if (reg_equiv_address[regno] != 0)\n-\t{\n-\t  x = make_memloc (x, regno);\n-\t  find_reloads_address (GET_MODE (x), 0, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t\topnum, type, ind_levels);\n-\t}\n \n-      if (reg_renumber[regno] >= 0)\n-\tregno = reg_renumber[regno];\n-      if ((regno >= FIRST_PSEUDO_REGISTER\n-\t   || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n-\t\t: REGNO_OK_FOR_BASE_P (regno))))\n-\t{\n-\t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n-\t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n-\t  return 1;\n-\t}\n+\tif (reg_equiv_address[regno] != 0)\n+\t  {\n+\t    x = make_memloc (x, regno);\n+\t    find_reloads_address (GET_MODE (x), 0, XEXP (x, 0), &XEXP (x, 0),\n+\t\t\t\t  opnum, type, ind_levels);\n+\t  }\n \n-      /* If a register appearing in an address is the subject of a CLOBBER\n-\t in this insn, reload it into some other register to be safe.\n-\t The CLOBBER is supposed to make the register unavailable\n-\t from before this insn to after it.  */\n-      if (regno_clobbered_p (regno, this_insn))\n-\t{\n-\t  push_reload (x, NULL_RTX, loc, NULL_PTR,\n-\t\t       context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n-\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n-\t  return 1;\n-\t}\n-    }\n-  else\n-    {\n-      register char *fmt = GET_RTX_FORMAT (code);\n-      register int i;\n-      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\tif (reg_renumber[regno] >= 0)\n+\t  regno = reg_renumber[regno];\n+\n+\tif ((regno >= FIRST_PSEUDO_REGISTER\n+\t     || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n+\t\t  : REGNO_OK_FOR_BASE_P (regno))))\n+\t  {\n+\t    push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t\t\t context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n+\t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t    return 1;\n+\t  }\n+\n+\t/* If a register appearing in an address is the subject of a CLOBBER\n+\t   in this insn, reload it into some other register to be safe.\n+\t   The CLOBBER is supposed to make the register unavailable\n+\t   from before this insn to after it.  */\n+\tif (regno_clobbered_p (regno, this_insn))\n+\t  {\n+\t    push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t\t\t context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n+\t\t\t GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t    return 1;\n+\t  }\n+      }\n+      return 0;\n+\n+    case SUBREG:\n+      /* If this is a SUBREG of a hard register and the resulting register is\n+\t of the wrong class, reload the whole SUBREG.  This avoids needless\n+\t copies if SUBREG_REG is multi-word.  */\n+      if (GET_CODE (SUBREG_REG (x)) == REG\n+\t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  if (fmt[i] == 'e')\n-\t    find_reloads_address_1 (XEXP (x, i), context, &XEXP (x, i),\n-\t\t\t\t    opnum, type, ind_levels);\n+\t  int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\n+\t  if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n+\t\t : REGNO_OK_FOR_BASE_P (regno)))\n+\t    {\n+\t      push_reload (x, NULL_RTX, loc, NULL_PTR,\n+\t\t\t   context ? INDEX_REG_CLASS : BASE_REG_CLASS,\n+\t\t\t   GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n+\t      return 1;\n+\t    }\n \t}\n+      break;\n     }\n \n+  {\n+    register char *fmt = GET_RTX_FORMAT (code);\n+    register int i;\n+\n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+\tif (fmt[i] == 'e')\n+\t  find_reloads_address_1 (XEXP (x, i), context, &XEXP (x, i),\n+\t\t\t\t  opnum, type, ind_levels);\n+      }\n+  }\n+\n   return 0;\n }\n \f"}]}