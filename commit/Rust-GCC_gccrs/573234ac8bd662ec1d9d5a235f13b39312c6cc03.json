{"sha": "573234ac8bd662ec1d9d5a235f13b39312c6cc03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTczMjM0YWM4YmQ2NjJlYzFkOWQ1YTIzNWYxM2IzOTMxMmM2Y2MwMw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-07-05T15:18:26Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-07-05T15:18:26Z"}, "message": "re PR fortran/53732 (\"mismatching comparison operand types\" on compile)\n\nfortran/\n\tPR fortran/53732\n\t* trans-array.c (gfc_add_loop_ss_code): Disable self recursive calls\n\thandling nested loop(s) if the subscript flag is true.\n\ntestsuite/\n\tPR fortran/53732\n\t* gfortran.dg/inline_sum_4.f90: New test.\n\nFrom-SVN: r189292", "tree": {"sha": "1ca2c1ab5da74b67f394e1aa8407772a8b3c76a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ca2c1ab5da74b67f394e1aa8407772a8b3c76a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/573234ac8bd662ec1d9d5a235f13b39312c6cc03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573234ac8bd662ec1d9d5a235f13b39312c6cc03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/573234ac8bd662ec1d9d5a235f13b39312c6cc03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573234ac8bd662ec1d9d5a235f13b39312c6cc03/comments", "author": null, "committer": null, "parents": [{"sha": "44b9837c99f53c58a58bd90ddc0c3bbae4ce4f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b9837c99f53c58a58bd90ddc0c3bbae4ce4f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44b9837c99f53c58a58bd90ddc0c3bbae4ce4f2a"}], "stats": {"total": 40, "additions": 32, "deletions": 8}, "files": [{"sha": "3d85f29fd8226a122992ee05a150ee6622f5c10a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=573234ac8bd662ec1d9d5a235f13b39312c6cc03", "patch": "@@ -1,3 +1,9 @@\n+2012-07-05  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/53732\n+\t* trans-array.c (gfc_add_loop_ss_code): Disable self recursive calls\n+\thandling nested loop(s) if the subscript flag is true.\n+\n 2012-07-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR fortran/53449"}, {"sha": "d289ac30a9918b90999b2a4b94f26fd0f0c44de6", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=573234ac8bd662ec1d9d5a235f13b39312c6cc03", "patch": "@@ -2398,7 +2398,6 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n   gfc_ss_info *ss_info;\n   gfc_array_info *info;\n   gfc_expr *expr;\n-  bool skip_nested = false;\n   int n;\n \n   /* Don't evaluate the arguments for realloc_lhs_loop_for_fcn_call; otherwise,\n@@ -2487,12 +2486,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  /* Add the expressions for scalar and vector subscripts.  */\n \t  for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n \t    if (info->subscript[n])\n-\t      {\n-\t\tgfc_add_loop_ss_code (loop, info->subscript[n], true, where);\n-\t\t/* The recursive call will have taken care of the nested loops.\n-\t\t   No need to do it twice.  */\n-\t\tskip_nested = true;\n-\t      }\n+\t      gfc_add_loop_ss_code (loop, info->subscript[n], true, where);\n \n \t  set_vector_loop_bounds (ss);\n \t  break;\n@@ -2548,7 +2542,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t}\n     }\n \n-  if (!skip_nested)\n+  if (!subscript)\n     for (nested_loop = loop->nested; nested_loop;\n \t nested_loop = nested_loop->next)\n       gfc_add_loop_ss_code (nested_loop, nested_loop->ss, subscript, where);"}, {"sha": "d929153b5a95900b626998f1839fc25279dfcd5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=573234ac8bd662ec1d9d5a235f13b39312c6cc03", "patch": "@@ -1,3 +1,8 @@\n+2012-07-05  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/53732\n+\t* gfortran.dg/inline_sum_4.f90: New test.\n+\n 2012-07-05  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* gcc.c-torture/compile/20000326-1.c: Fix to not optimize to empty."}, {"sha": "c04510dd0e23da99fffe9c1284e4afb8fc42066b", "filename": "gcc/testsuite/gfortran.dg/inline_sum_4.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573234ac8bd662ec1d9d5a235f13b39312c6cc03/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_4.f90?ref=573234ac8bd662ec1d9d5a235f13b39312c6cc03", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+!\n+! PR fortran/53732\n+! this was leading to an internal \"mismatching comparison operand types\"\n+! error.\n+!\n+! Original testcase by minzastro <minzastro@googlemail.com>\n+! Fixed by Dominique Dhumieres <dominiq@lps.ens.fr>\n+\n+program test\n+implicit none\n+\n+real(8) arr(4,4,4,4)\n+\n+arr(:,:,:,:) = 1d0\n+\n+arr(1,:,:,:) = sum(arr, dim=1, mask=(arr(:,:,:,:) > 0d0))\n+\n+end program test"}]}