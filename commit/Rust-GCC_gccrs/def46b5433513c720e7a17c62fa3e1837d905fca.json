{"sha": "def46b5433513c720e7a17c62fa3e1837d905fca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVmNDZiNTQzMzUxM2M3MjBlN2ExN2M2MmZhM2UxODM3ZDkwNWZjYQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:19:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:19:04Z"}, "message": "s-osinte-lynxos-3.ads, [...]: Add missing pragma Convention C for subprogram pointers.\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\n\t* s-osinte-lynxos-3.ads, s-osinte-hpux.ads, s-osinte-solaris-posix.ads, \n\ts-osinte-freebsd.ads, s-osinte-lynxos.ads, s-osinte-tru64.ads, \n\ts-osinte-mingw.ads, s-osinte-aix.ads, s-osinte-hpux-dce.ads, \n\ts-osinte-irix.ads, s-osinte-solaris.ads, s-intman-vms.adb,\n\ts-osinte-vms.ads, s-osinte-vxworks6.ads, s-osinte-vxworks.ads,\n\ts-auxdec.ads, s-auxdec-vms_64.ads, s-osinte-darwin.ads, \n\ts-taprop-vms.adb, s-interr-sigaction.adb, s-osinte-linux-hppa.ads, \n\ti-vxwork-x86.ads, s-tpopde-vms.ads: Add missing pragma Convention C\n\tfor subprogram pointers.\n\n\t* g-ctrl_c.adb: New file.\n\n\t* g-ctrl_c.ads (Install_Handler): New body.\n\n\t* freeze.adb (Freeze_Subprogram): Use new flag Has_Pragma_Inline_Always\n\tinstead of obsolete function Is_Always_Inlined.\n\t(Freeze_Entity): check for tagged type in imported C subprogram\n\t(Freeze_Entity): check for 8-bit boolean in imported C subprogram\n\t(Freeze_Entity): check for convention Ada subprogram pointer in\n\timported C subprogram.\n\t(Freeze_Fixed_Point_Type): In the case of a base type where the low\n\tbound would be chopped off and go from negative to zero, force\n\tLoval_Excl_EP to be the same as Loval_Incl_EP (the included lower\n\tbound) so that the size computation for the base type will take\n\tnegative values into account.\n\nFrom-SVN: r130813", "tree": {"sha": "2d7d450cb2b59f3695b897cfe5157b878e24aa40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d7d450cb2b59f3695b897cfe5157b878e24aa40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/def46b5433513c720e7a17c62fa3e1837d905fca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/def46b5433513c720e7a17c62fa3e1837d905fca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/def46b5433513c720e7a17c62fa3e1837d905fca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/def46b5433513c720e7a17c62fa3e1837d905fca/comments", "author": null, "committer": null, "parents": [{"sha": "b41ab480565d08ba5535f219e9f607e15d9c47e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41ab480565d08ba5535f219e9f607e15d9c47e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41ab480565d08ba5535f219e9f607e15d9c47e0"}], "stats": {"total": 835, "additions": 621, "deletions": 214}, "files": [{"sha": "f39ac022d983aa3e6ab6ed51012a84b4c4641a04", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 322, "deletions": 168, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -243,11 +243,16 @@ package body Freeze is\n       O_Formal   : Entity_Id;\n       Param_Spec : Node_Id;\n \n+      Pref : Node_Id := Empty;\n+      --  If the renamed entity is a primitive operation given in prefix form,\n+      --  the prefix is the target object and it has to be added as the first\n+      --  actual in the generated call.\n+\n    begin\n-      --  Determine the entity being renamed, which is the target of the\n-      --  call statement. If the name is an explicit dereference, this is\n-      --  a renaming of a subprogram type rather than a subprogram. The\n-      --  name itself is fully analyzed.\n+      --  Determine the entity being renamed, which is the target of the call\n+      --  statement. If the name is an explicit dereference, this is a renaming\n+      --  of a subprogram type rather than a subprogram. The name itself is\n+      --  fully analyzed.\n \n       if Nkind (Nam) = N_Selected_Component then\n          Old_S := Entity (Selector_Name (Nam));\n@@ -271,8 +276,8 @@ package body Freeze is\n \n       if Is_Entity_Name (Nam) then\n \n-         --  If the renamed entity is a predefined operator, retain full\n-         --  name to ensure its visibility.\n+         --  If the renamed entity is a predefined operator, retain full name\n+         --  to ensure its visibility.\n \n          if Ekind (Old_S) = E_Operator\n            and then Nkind (Nam) = N_Expanded_Name\n@@ -283,17 +288,32 @@ package body Freeze is\n          end if;\n \n       else\n-         Call_Name := New_Copy (Name (N));\n+         if Nkind (Nam) = N_Selected_Component\n+           and then Present (First_Formal (Old_S))\n+           and then\n+             (Is_Controlling_Formal (First_Formal (Old_S))\n+                or else Is_Class_Wide_Type (Etype (First_Formal (Old_S))))\n+         then\n+\n+            --  Retrieve the target object, to be added as a first actual\n+            --  in the call.\n+\n+            Call_Name := New_Occurrence_Of (Old_S, Loc);\n+            Pref := Prefix (Nam);\n+\n+         else\n+            Call_Name := New_Copy (Name (N));\n+         end if;\n \n          --  The original name may have been overloaded, but\n          --  is fully resolved now.\n \n          Set_Is_Overloaded (Call_Name, False);\n       end if;\n \n-      --  For simple renamings, subsequent calls can be expanded directly\n-      --  as called to the renamed entity. The body must be generated in\n-      --  any case for calls they may appear elsewhere.\n+      --  For simple renamings, subsequent calls can be expanded directly as\n+      --  called to the renamed entity. The body must be generated in any case\n+      --  for calls they may appear elsewhere.\n \n       if (Ekind (Old_S) = E_Function\n            or else Ekind (Old_S) = E_Procedure)\n@@ -309,23 +329,55 @@ package body Freeze is\n \n       Formal := First_Formal (Defining_Entity (Decl));\n \n-      if Present (Formal) then\n+      if Present (Pref) then\n+         declare\n+            Pref_Type : constant Entity_Id := Etype (Pref);\n+            Form_Type : constant Entity_Id := Etype (First_Formal (Old_S));\n+\n+         begin\n+\n+            --  The controlling formal may be an access parameter, or the\n+            --  actual may be an access value, so ajust accordingly.\n+\n+            if Is_Access_Type (Pref_Type)\n+              and then not Is_Access_Type (Form_Type)\n+            then\n+               Actuals := New_List\n+                 (Make_Explicit_Dereference (Loc, Relocate_Node (Pref)));\n+\n+            elsif Is_Access_Type (Form_Type)\n+              and then not Is_Access_Type (Pref)\n+            then\n+               Actuals := New_List\n+                 (Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Access,\n+                   Prefix => Relocate_Node (Pref)));\n+            else\n+               Actuals := New_List (Pref);\n+            end if;\n+         end;\n+\n+      elsif Present (Formal) then\n          Actuals := New_List;\n \n+      else\n+         Actuals := No_List;\n+      end if;\n+\n+      if Present (Formal) then\n          while Present (Formal) loop\n             Append (New_Reference_To (Formal, Loc), Actuals);\n             Next_Formal (Formal);\n          end loop;\n       end if;\n \n-      --  If the renamed entity is an entry, inherit its profile. For\n-      --  other renamings as bodies, both profiles must be subtype\n-      --  conformant, so it is not necessary to replace the profile given\n-      --  in the declaration. However, default values that are aggregates\n-      --  are rewritten when partially analyzed, so we recover the original\n-      --  aggregate to insure that subsequent conformity checking works.\n-      --  Similarly, if the default expression was constant-folded, recover\n-      --  the original expression.\n+      --  If the renamed entity is an entry, inherit its profile. For other\n+      --  renamings as bodies, both profiles must be subtype conformant, so it\n+      --  is not necessary to replace the profile given in the declaration.\n+      --  However, default values that are aggregates are rewritten when\n+      --  partially analyzed, so we recover the original aggregate to insure\n+      --  that subsequent conformity checking works. Similarly, if the default\n+      --  expression was constant-folded, recover the original expression.\n \n       Formal := First_Formal (Defining_Entity (Decl));\n \n@@ -421,8 +473,8 @@ package body Freeze is\n       end if;\n \n       --  Link the body to the entity whose declaration it completes. If\n-      --  the body is analyzed when the renamed entity is frozen, it may be\n-      --  necessary to restore the proper scope (see package Exp_Ch13).\n+      --  the body is analyzed when the renamed entity is frozen, it may\n+      --  be necessary to restore the proper scope (see package Exp_Ch13).\n \n       if Nkind (N) =  N_Subprogram_Renaming_Declaration\n         and then Present (Corresponding_Spec (N))\n@@ -449,18 +501,16 @@ package body Freeze is\n       if Present (Addr) then\n          Expr := Expression (Addr);\n \n-         --  If we have no initialization of any kind, then we don't\n-         --  need to place any restrictions on the address clause, because\n-         --  the object will be elaborated after the address clause is\n-         --  evaluated. This happens if the declaration has no initial\n-         --  expression, or the type has no implicit initialization, or\n-         --  the object is imported.\n+         --  If we have no initialization of any kind, then we don't need to\n+         --  place any restrictions on the address clause, because the object\n+         --  will be elaborated after the address clause is evaluated. This\n+         --  happens if the declaration has no initial expression, or the type\n+         --  has no implicit initialization, or the object is imported.\n \n-         --  The same holds for all initialized scalar types and all\n-         --  access types. Packed bit arrays of size up to 64 are\n-         --  represented using a modular type with an initialization\n-         --  (to zero) and can be processed like other initialized\n-         --  scalar types.\n+         --  The same holds for all initialized scalar types and all access\n+         --  types. Packed bit arrays of size up to 64 are represented using a\n+         --  modular type with an initialization (to zero) and can be processed\n+         --  like other initialized scalar types.\n \n          --  If the type is controlled, code to attach the object to a\n          --  finalization chain is generated at the point of declaration,\n@@ -487,9 +537,9 @@ package body Freeze is\n          then\n             null;\n \n-         --  Otherwise, we require the address clause to be constant\n-         --  because the call to the initialization procedure (or the\n-         --  attach code) has to happen at the point of the declaration.\n+         --  Otherwise, we require the address clause to be constant because\n+         --  the call to the initialization procedure (or the attach code) has\n+         --  to happen at the point of the declaration.\n \n          else\n             Check_Constant_Address_Clause (Expr, E);\n@@ -587,8 +637,8 @@ package body Freeze is\n             elsif not Is_Constrained (T) then\n                return False;\n \n-            --  Don't do any recursion on type with error posted, since\n-            --  we may have a malformed type that leads us into a loop\n+            --  Don't do any recursion on type with error posted, since we may\n+            --  have a malformed type that leads us into a loop.\n \n             elsif Error_Posted (T) then\n                return False;\n@@ -597,8 +647,8 @@ package body Freeze is\n                return False;\n             end if;\n \n-            --  Check for all indexes static, and also compute possible\n-            --  size (in case it is less than 32 and may be packable).\n+            --  Check for all indexes static, and also compute possible size\n+            --  (in case it is less than 32 and may be packable).\n \n             declare\n                Esiz : Uint := Component_Size (T);\n@@ -648,8 +698,8 @@ package body Freeze is\n            and then not Is_Generic_Type (T)\n            and then Present (Underlying_Type (T))\n          then\n-            --  Don't do any recursion on type with error posted, since\n-            --  we may have a malformed type that leads us into a loop\n+            --  Don't do any recursion on type with error posted, since we may\n+            --  have a malformed type that leads us into a loop.\n \n             if Error_Posted (T) then\n                return False;\n@@ -672,8 +722,8 @@ package body Freeze is\n             then\n                return False;\n \n-            --  Don't do any recursion on type with error posted, since\n-            --  we may have a malformed type that leads us into a loop\n+            --  Don't do any recursion on type with error posted, since we may\n+            --  have a malformed type that leads us into a loop.\n \n             elsif Error_Posted (T) then\n                return False;\n@@ -682,16 +732,15 @@ package body Freeze is\n             --  Now look at the components of the record\n \n             declare\n-               --  The following two variables are used to keep track of\n-               --  the size of packed records if we can tell the size of\n-               --  the packed record in the front end. Packed_Size_Known\n-               --  is True if so far we can figure out the size. It is\n-               --  initialized to True for a packed record, unless the\n-               --  record has discriminants. The reason we eliminate the\n-               --  discriminated case is that we don't know the way the\n-               --  back end lays out discriminated packed records. If\n-               --  Packed_Size_Known is True, then Packed_Size is the\n-               --  size in bits so far.\n+               --  The following two variables are used to keep track of the\n+               --  size of packed records if we can tell the size of the packed\n+               --  record in the front end. Packed_Size_Known is True if so far\n+               --  we can figure out the size. It is initialized to True for a\n+               --  packed record, unless the record has discriminants. The\n+               --  reason we eliminate the discriminated case is that we don't\n+               --  know the way the back end lays out discriminated packed\n+               --  records. If Packed_Size_Known is True, then Packed_Size is\n+               --  the size in bits so far.\n \n                Packed_Size_Known : Boolean :=\n                                      Is_Packed (T)\n@@ -797,8 +846,8 @@ package body Freeze is\n                      end;\n                   end if;\n \n-                  --  Clearly size of record is not known if the size of\n-                  --  one of the components is not known.\n+                  --  Clearly size of record is not known if the size of one of\n+                  --  the components is not known.\n \n                   if not Size_Known (Ctyp) then\n                      return False;\n@@ -1063,12 +1112,11 @@ package body Freeze is\n \n          Set_Expression (Parent (E), New_Occurrence_Of (Temp, Loc));\n \n-         --  To prevent the temporary from being constant-folded (which\n-         --  would lead to the same piecemeal assignment on the original\n-         --  target) indicate to the back-end that the temporary  is a\n-         --  variable with real storage. See description of this flag\n-         --  in Einfo, and the notes on N_Assignment_Statement and\n-         --  N_Object_Declaration in Sinfo.\n+         --  To prevent the temporary from being constant-folded (which would\n+         --  lead to the same piecemeal assignment on the original target)\n+         --  indicate to the back-end that the temporary is a variable with\n+         --  real storage. See description of this flag in Einfo, and the notes\n+         --  on N_Assignment_Statement and N_Object_Declaration in Sinfo.\n \n          Set_Is_True_Constant (Temp, False);\n       end if;\n@@ -1091,10 +1139,10 @@ package body Freeze is\n       Decl  : Node_Id;\n \n       procedure Freeze_All_Ent (From : Entity_Id; After : in out Node_Id);\n-      --  This is the internal recursive routine that does freezing of\n-      --  entities (but NOT the analysis of default expressions, which\n-      --  should not be recursive, we don't want to analyze those till\n-      --  we are sure that ALL the types are frozen).\n+      --  This is the internal recursive routine that does freezing of entities\n+      --  (but NOT the analysis of default expressions, which should not be\n+      --  recursive, we don't want to analyze those till we are sure that ALL\n+      --  the types are frozen).\n \n       --------------------\n       -- Freeze_All_Ent --\n@@ -1109,8 +1157,8 @@ package body Freeze is\n          Lastn : Node_Id;\n \n          procedure Process_Flist;\n-         --  If freeze nodes are present, insert and analyze, and reset\n-         --  cursor for next insertion.\n+         --  If freeze nodes are present, insert and analyze, and reset cursor\n+         --  for next insertion.\n \n          -------------------\n          -- Process_Flist --\n@@ -1137,9 +1185,9 @@ package body Freeze is\n          while Present (E) loop\n \n             --  If the entity is an inner package which is not a package\n-            --  renaming, then its entities must be frozen at this point.\n-            --  Note that such entities do NOT get frozen at the end of\n-            --  the nested package itself (only library packages freeze).\n+            --  renaming, then its entities must be frozen at this point. Note\n+            --  that such entities do NOT get frozen at the end of the nested\n+            --  package itself (only library packages freeze).\n \n             --  Same is true for task declarations, where anonymous records\n             --  created for entry parameters must be frozen.\n@@ -1168,9 +1216,9 @@ package body Freeze is\n                End_Scope;\n \n             --  For a derived tagged type, we must ensure that all the\n-            --  primitive operations of the parent have been frozen, so\n-            --  that their addresses will be in the parent's dispatch table\n-            --  at the point it is inherited.\n+            --  primitive operations of the parent have been frozen, so that\n+            --  their addresses will be in the parent's dispatch table at the\n+            --  point it is inherited.\n \n             elsif Ekind (E) = E_Record_Type\n               and then Is_Tagged_Type (E)\n@@ -1207,13 +1255,12 @@ package body Freeze is\n                Process_Flist;\n             end if;\n \n-            --  If an incomplete type is still not frozen, this may be\n-            --  a premature freezing because of a body declaration that\n-            --  follows. Indicate where the freezing took place.\n+            --  If an incomplete type is still not frozen, this may be a\n+            --  premature freezing because of a body declaration that follows.\n+            --  Indicate where the freezing took place.\n \n-            --  If the freezing is caused by the end of the current\n-            --  declarative part, it is a Taft Amendment type, and there\n-            --  is no error.\n+            --  If the freezing is caused by the end of the current declarative\n+            --  part, it is a Taft Amendment type, and there is no error.\n \n             if not Is_Frozen (E)\n               and then Ekind (E) = E_Incomplete_Type\n@@ -1416,7 +1463,7 @@ package body Freeze is\n          begin\n             case Nkind (N) is\n                when N_Attribute_Reference =>\n-                  if  (Attribute_Name (N) = Name_Access\n+                  if (Attribute_Name (N) = Name_Access\n                         or else\n                       Attribute_Name (N) = Name_Unchecked_Access)\n                     and then Is_Entity_Name (Prefix (N))\n@@ -1831,16 +1878,16 @@ package body Freeze is\n                   end if;\n                end;\n \n-            --  If the component is an access type with an allocator as\n-            --  default value, the designated type will be frozen by the\n-            --  corresponding expression in init_proc. In order to place the\n-            --  freeze node for the designated type before that for the\n-            --  current record type, freeze it now.\n+            --  If the component is an access type with an allocator as default\n+            --  value, the designated type will be frozen by the corresponding\n+            --  expression in init_proc. In order to place the freeze node for\n+            --  the designated type before that for the current record type,\n+            --  freeze it now.\n \n             --  Same process if the component is an array of access types,\n             --  initialized with an aggregate. If the designated type is\n-            --  private, it cannot contain allocators, and it is premature to\n-            --  freeze the type, so we check for this as well.\n+            --  private, it cannot contain allocators, and it is premature\n+            --  to freeze the type, so we check for this as well.\n \n             elsif Is_Access_Type (Etype (Comp))\n               and then Present (Parent (Comp))\n@@ -1916,8 +1963,8 @@ package body Freeze is\n                Error_Msg_N\n                  (\"\\?since no component clauses were specified\", ADC);\n \n-            --  Here is where we do Ada 2005 processing for bit order (the\n-            --  Ada 95 case was already taken care of above).\n+            --  Here is where we do Ada 2005 processing for bit order (the Ada\n+            --  95 case was already taken care of above).\n \n             elsif Ada_Version >= Ada_05 then\n                Adjust_Record_For_Reverse_Bit_Order (Rec);\n@@ -1933,9 +1980,9 @@ package body Freeze is\n            and then Is_Packed (Rec)\n            and then not Unplaced_Component\n          then\n-            --  Reset packed status. Probably not necessary, but we do it\n-            --  so that there is no chance of the back end doing something\n-            --  strange with this redundant indication of packing.\n+            --  Reset packed status. Probably not necessary, but we do it so\n+            --  that there is no chance of the back end doing something strange\n+            --  with this redundant indication of packing.\n \n             Set_Is_Packed (Rec, False);\n \n@@ -2125,12 +2172,12 @@ package body Freeze is\n \n       --  Similarly, an inlined instance body may make reference to global\n       --  entities, but these references cannot be the proper freezing point\n-      --  for them, and in the absence of inlining freezing will take place\n-      --  in their own scope. Normally instance bodies are analyzed after\n-      --  the enclosing compilation, and everything has been frozen at the\n-      --  proper place, but with front-end inlining an instance body is\n-      --  compiled before the end of the enclosing scope, and as a result\n-      --  out-of-order freezing must be prevented.\n+      --  for them, and in the absence of inlining freezing will take place in\n+      --  their own scope. Normally instance bodies are analyzed after the\n+      --  enclosing compilation, and everything has been frozen at the proper\n+      --  place, but with front-end inlining an instance body is compiled\n+      --  before the end of the enclosing scope, and as a result out-of-order\n+      --  freezing must be prevented.\n \n       elsif Front_End_Inlining\n         and then In_Instance_Body\n@@ -2220,26 +2267,9 @@ package body Freeze is\n             if not Is_Internal (E) then\n                declare\n                   F_Type    : Entity_Id;\n+                  R_Type    : Entity_Id;\n                   Warn_Node : Node_Id;\n \n-                  function Is_Fat_C_Ptr_Type (T : Entity_Id) return Boolean;\n-                  --  Determines if given type entity is a fat pointer type\n-                  --  used as an argument type or return type to a subprogram\n-                  --  with C or C++ convention set.\n-\n-                  --------------------------\n-                  -- Is_Fat_C_Access_Type --\n-                  --------------------------\n-\n-                  function Is_Fat_C_Ptr_Type (T : Entity_Id) return Boolean is\n-                  begin\n-                     return (Convention (E) = Convention_C\n-                               or else\n-                             Convention (E) = Convention_CPP)\n-                       and then Is_Access_Type (T)\n-                       and then Esize (T) > Ttypes.System_Address_Size;\n-                  end Is_Fat_C_Ptr_Type;\n-\n                begin\n                   --  Loop through formals\n \n@@ -2277,22 +2307,72 @@ package body Freeze is\n                         end if;\n                      end if;\n \n-                     --  Check bad use of fat C pointer\n+                     --  Check suspicious parameter for C function. These tests\n+                     --  apply only to exported/imported suboprograms.\n \n-                     if Warn_On_Export_Import and then\n-                       Is_Fat_C_Ptr_Type (F_Type)\n+                     if Warn_On_Export_Import\n+                       and then (Convention (E) = Convention_C\n+                                   or else\n+                                 Convention (E) = Convention_CPP)\n+                       and then not Warnings_Off (E)\n+                       and then not Warnings_Off (F_Type)\n+                       and then not Warnings_Off (Formal)\n+                       and then (Is_Imported (E) or else Is_Exported (E))\n                      then\n                         Error_Msg_Qual_Level := 1;\n-                        Error_Msg_N\n-                           (\"?type of & does not correspond to C pointer\",\n-                            Formal);\n+\n+                        --  Check suspicious use of fat C pointer\n+\n+                        if Is_Access_Type (F_Type)\n+                          and then Esize (F_Type) > Ttypes.System_Address_Size\n+                        then\n+                           Error_Msg_N\n+                             (\"?type of & does not correspond \"\n+                              & \"to C pointer!\", Formal);\n+\n+                        --  Check suspicious return of boolean\n+\n+                        elsif Root_Type (F_Type) = Standard_Boolean\n+                          and then Convention (F_Type) = Convention_Ada\n+                        then\n+                           Error_Msg_N\n+                             (\"?& is an 8-bit Ada Boolean, \"\n+                              & \"use char in C!\", Formal);\n+\n+                        --  Check suspicious tagged type\n+\n+                        elsif (Is_Tagged_Type (F_Type)\n+                                or else (Is_Access_Type (F_Type)\n+                                           and then\n+                                             Is_Tagged_Type\n+                                               (Designated_Type (F_Type))))\n+                          and then Convention (E) = Convention_C\n+                        then\n+                           Error_Msg_N\n+                             (\"?& is a tagged type which does not \"\n+                              & \"correspond to any C type!\", Formal);\n+\n+                        --  Check wrong convention subprogram pointer\n+\n+                        elsif Ekind (F_Type) = E_Access_Subprogram_Type\n+                          and then not Has_Foreign_Convention (F_Type)\n+                        then\n+                           Error_Msg_N\n+                             (\"?subprogram pointer & should \"\n+                              & \"have foreign convention!\", Formal);\n+                           Error_Msg_Sloc := Sloc (F_Type);\n+                           Error_Msg_NE\n+                             (\"\\?add Convention pragma to declaration of &#\",\n+                              Formal, F_Type);\n+                        end if;\n+\n                         Error_Msg_Qual_Level := 0;\n                      end if;\n \n                      --  Check for unconstrained array in exported foreign\n                      --  convention case.\n \n-                     if Convention (E) in Foreign_Convention\n+                     if Has_Foreign_Convention (E)\n                        and then not Is_Imported (E)\n                        and then Is_Array_Type (F_Type)\n                        and then not Is_Constrained (F_Type)\n@@ -2365,22 +2445,75 @@ package body Freeze is\n                      Next_Formal (Formal);\n                   end loop;\n \n-                  --  Check return type\n+                  --  Case of function\n \n                   if Ekind (E) = E_Function then\n-                     Freeze_And_Append (Etype (E), Loc, Result);\n+\n+                     --  Freeze return type\n+\n+                     R_Type := Etype (E);\n+                     Freeze_And_Append (R_Type, Loc, Result);\n+\n+                     --  Check suspicious return type for C function\n \n                      if Warn_On_Export_Import\n-                       and then Is_Fat_C_Ptr_Type (Etype (E))\n+                       and then (Convention (E) = Convention_C\n+                                   or else\n+                                 Convention (E) = Convention_CPP)\n+                       and then not Warnings_Off (E)\n+                       and then not Warnings_Off (R_Type)\n+                       and then (Is_Imported (E) or else Is_Exported (E))\n                      then\n-                        Error_Msg_N\n-                          (\"?return type of& does not correspond to C pointer\",\n-                           E);\n+                        --  Check suspicious return of fat C pointer\n+\n+                        if Is_Access_Type (R_Type)\n+                          and then Esize (R_Type) > Ttypes.System_Address_Size\n+                        then\n+                           Error_Msg_N\n+                             (\"?return type of& does not \"\n+                              & \"correspond to C pointer!\", E);\n+\n+                        --  Check suspicious return of boolean\n+\n+                        elsif Root_Type (R_Type) = Standard_Boolean\n+                          and then Convention (R_Type) = Convention_Ada\n+                        then\n+                           Error_Msg_N\n+                             (\"?return type of & is an 8-bit \"\n+                              & \"Ada Boolean, use char in C!\", E);\n \n-                     elsif Is_Array_Type (Etype (E))\n+                        --  Check suspicious return tagged type\n+\n+                        elsif (Is_Tagged_Type (R_Type)\n+                                or else (Is_Access_Type (R_Type)\n+                                           and then\n+                                             Is_Tagged_Type\n+                                               (Designated_Type (R_Type))))\n+                          and then Convention (E) = Convention_C\n+                        then\n+                           Error_Msg_N\n+                             (\"?return type of & does not \"\n+                              & \"correspond to C type!\", E);\n+\n+                        --  Check return of wrong convention subprogram pointer\n+\n+                        elsif Ekind (R_Type) = E_Access_Subprogram_Type\n+                          and then not Has_Foreign_Convention (R_Type)\n+                        then\n+                           Error_Msg_N\n+                             (\"?& should return a foreign \"\n+                              & \"convention subprogram pointer\", E);\n+                           Error_Msg_Sloc := Sloc (R_Type);\n+                           Error_Msg_NE\n+                             (\"\\?add Convention pragma to declaration of& #\",\n+                              E, R_Type);\n+                        end if;\n+                     end if;\n+\n+                     if Is_Array_Type (Etype (E))\n                        and then not Is_Constrained (Etype (E))\n                        and then not Is_Imported (E)\n-                       and then Convention (E) in Foreign_Convention\n+                       and then Has_Foreign_Convention (E)\n                        and then Warn_On_Export_Import\n                      then\n                         Error_Msg_N\n@@ -2451,14 +2584,14 @@ package body Freeze is\n \n                Check_Address_Clause (E);\n \n-               --  For imported objects, set Is_Public unless there is also\n-               --  an address clause, which means that there is no external\n-               --  symbol needed for the Import (Is_Public may still be set\n-               --  for other unrelated reasons). Note that we delayed this\n-               --  processing till freeze time so that we can be sure not\n-               --  to set the flag if there is an address clause. If there\n-               --  is such a clause, then the only purpose of the Import\n-               --  pragma is to suppress implicit initialization.\n+               --  For imported objects, set Is_Public unless there is also an\n+               --  address clause, which means that there is no external symbol\n+               --  needed for the Import (Is_Public may still be set for other\n+               --  unrelated reasons). Note that we delayed this processing\n+               --  till freeze time so that we can be sure not to set the flag\n+               --  if there is an address clause. If there is such a clause,\n+               --  then the only purpose of the Import pragma is to suppress\n+               --  implicit initialization.\n \n                if Is_Imported (E)\n                  and then No (Address_Clause (E))\n@@ -2507,7 +2640,7 @@ package body Freeze is\n                then\n                   Error_Msg_N\n                     (\"stand alone atomic constant must be \" &\n-                     \"imported ('R'M C.6(13))\", E);\n+                     \"imported (RM C.6(13))\", E);\n \n                elsif Has_Rep_Pragma (E, Name_Volatile)\n                        or else\n@@ -2664,16 +2797,16 @@ package body Freeze is\n                end;\n             end if;\n \n-            --  If ancestor subtype present, freeze that first.\n-            --  Note that this will also get the base type frozen.\n+            --  If ancestor subtype present, freeze that first. Note that this\n+            --  will also get the base type frozen.\n \n             Atype := Ancestor_Subtype (E);\n \n             if Present (Atype) then\n                Freeze_And_Append (Atype, Loc, Result);\n \n-            --  Otherwise freeze the base type of the entity before\n-            --  freezing the entity itself (RM 13.14(15)).\n+            --  Otherwise freeze the base type of the entity before freezing\n+            --  the entity itself (RM 13.14(15)).\n \n             elsif E /= Base_Type (E) then\n                Freeze_And_Append (Base_Type (E), Loc, Result);\n@@ -2944,9 +3077,16 @@ package body Freeze is\n \n                   --  Size information of packed array type is copied to the\n                   --  array type, since this is really the representation. But\n-                  --  do not override explicit existing size values.\n+                  --  do not override explicit existing size values. If the\n+                  --  ancestor subtype is constrained the packed_array_type\n+                  --  will be inherited from it, but the size may have been\n+                  --  provided already, and must not be overridden either.\n \n-                  if not Has_Size_Clause (E) then\n+                  if not Has_Size_Clause (E)\n+                    and then\n+                      (No (Ancestor_Subtype (E))\n+                        or else not Has_Size_Clause (Ancestor_Subtype (E)))\n+                  then\n                      Set_Esize     (E, Esize     (Packed_Array_Type (E)));\n                      Set_RM_Size   (E, RM_Size   (Packed_Array_Type (E)));\n                   end if;\n@@ -2956,10 +3096,9 @@ package body Freeze is\n                   end if;\n                end if;\n \n-               --  For non-packed arrays set the alignment of the array\n-               --  to the alignment of the component type if it is unknown.\n-               --  Skip this in the atomic case, since atomic arrays may\n-               --  need larger alignments.\n+               --  For non-packed arrays set the alignment of the array to the\n+               --  alignment of the component type if it is unknown. Skip this\n+               --  in atomic case (atomic arrays may need larger alignments).\n \n                if not Is_Packed (E)\n                  and then Unknown_Alignment (E)\n@@ -3011,11 +3150,11 @@ package body Freeze is\n                end;\n             end if;\n \n-            --  The equivalent type associated with a class-wide subtype\n-            --  needs to be frozen to ensure that its layout is done.\n-            --  Class-wide subtypes are currently only frozen on targets\n-            --  requiring front-end layout (see New_Class_Wide_Subtype\n-            --  and Make_CW_Equivalent_Type in exp_util.adb).\n+            --  The equivalent type associated with a class-wide subtype needs\n+            --  to be frozen to ensure that its layout is done. Class-wide\n+            --  subtypes are currently only frozen on targets requiring\n+            --  front-end layout (see New_Class_Wide_Subtype and\n+            --  Make_CW_Equivalent_Type in exp_util.adb).\n \n             if Ekind (E) = E_Class_Wide_Subtype\n               and then Present (Equivalent_Type (E))\n@@ -3024,10 +3163,10 @@ package body Freeze is\n             end if;\n \n          --  For a record (sub)type, freeze all the component types (RM\n-         --  13.14(15). We test for E_Record_(sub)Type here, rather than\n-         --  using Is_Record_Type, because we don't want to attempt the\n-         --  freeze for the case of a private type with record extension\n-         --  (we will do that later when the full type is frozen).\n+         --  13.14(15). We test for E_Record_(sub)Type here, rather than using\n+         --  Is_Record_Type, because we don't want to attempt the freeze for\n+         --  the case of a private type with record extension (we will do that\n+         --  later when the full type is frozen).\n \n          elsif Ekind (E) = E_Record_Type\n            or else  Ekind (E) = E_Record_Subtype\n@@ -3148,8 +3287,8 @@ package body Freeze is\n                            Set_Entity (F_Node, E);\n \n                         else\n-                           --  {Incomplete,Private}_Subtypes\n-                           --  with Full_Views constrained by discriminants\n+                           --  {Incomplete,Private}_Subtypes with Full_Views\n+                           --  constrained by discriminants.\n \n                            Set_Has_Delayed_Freeze (E, False);\n                            Set_Freeze_Node (E, Empty);\n@@ -3172,7 +3311,7 @@ package body Freeze is\n                  Size_Known_At_Compile_Time (Full_View (E)));\n \n                --  Size information is copied from the full view to the\n-               --  incomplete or private view for consistency\n+               --  incomplete or private view for consistency.\n \n                --  We skip this is the full view is not a type. This is very\n                --  strange of course, and can only happen as a result of\n@@ -3215,7 +3354,7 @@ package body Freeze is\n             Freeze_Subprogram (E);\n \n             --  Ada 2005 (AI-326): Check wrong use of tag incomplete type\n-            --\n+\n             --    type T is tagged;\n             --    type Acc is access function (X : T) return T; -- ERROR\n \n@@ -3346,10 +3485,10 @@ package body Freeze is\n             --  AI-117), which will have occurred earlier (in Derive_Subprogram\n             --  and New_Overloaded_Entity). Here we set the convention of\n             --  primitives that are still convention Ada, which will ensure\n-            --  that any new primitives inherit the type's convention.\n-            --  Class-wide types can have a foreign convention inherited from\n-            --  their specific type, but are excluded from this since they\n-            --  don't have any associated primitives.\n+            --  that any new primitives inherit the type's convention. Class-\n+            --  wide types can have a foreign convention inherited from their\n+            --  specific type, but are excluded from this since they don't have\n+            --  any associated primitives.\n \n             if Is_Tagged_Type (E)\n               and then not Is_Class_Wide_Type (E)\n@@ -4255,6 +4394,19 @@ package body Freeze is\n \n             if UR_Is_Negative (Loval_Incl_EP) then\n                Loval_Excl_EP := Loval_Incl_EP + Small;\n+\n+               --  If the value went from negative to zero, then we have the\n+               --  case where Loval_Incl_EP is the model number just below\n+               --  zero, so we want to stick to the negative value for the\n+               --  base type to maintain the condition that the size will\n+               --  include signed values.\n+\n+               if Typ = Btyp\n+                 and then UR_Is_Zero (Loval_Excl_EP)\n+               then\n+                  Loval_Excl_EP := Loval_Incl_EP;\n+               end if;\n+\n             else\n                Loval_Excl_EP := Loval_Incl_EP;\n             end if;\n@@ -4874,7 +5026,9 @@ package body Freeze is\n       --  be inlined. This is consistent with the restriction against using\n       --  'Access or 'Address on an Inline_Always subprogram.\n \n-      if Is_Dispatching_Operation (E) and then Is_Always_Inlined (E) then\n+      if Is_Dispatching_Operation (E)\n+        and then Has_Pragma_Inline_Always (E)\n+      then\n          Error_Msg_N\n            (\"pragma Inline_Always not allowed for dispatching subprograms\", E);\n       end if;"}, {"sha": "17b1a9fda85655847e1918d4277c0fb2cb71493e", "filename": "gcc/ada/g-ctrl_c.adb", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fg-ctrl_c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fg-ctrl_c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-ctrl_c.adb?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -0,0 +1,57 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          G N A T . C T R L _ C                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                      Copyright (C) 2002-2007, AdaCore                    --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Ctrl_C is\n+\n+   type C_Handler_Type is access procedure;\n+   pragma Convention (C, C_Handler_Type);\n+\n+   Ada_Handler : Handler_Type;\n+\n+   procedure C_Handler;\n+   pragma Convention (C, C_Handler);\n+\n+   procedure C_Handler is\n+   begin\n+      Ada_Handler.all;\n+   end C_Handler;\n+\n+   procedure Install_Handler (Handler : Handler_Type) is\n+      procedure Internal (Handler : C_Handler_Type);\n+      pragma Import (C, Internal, \"__gnat_install_int_handler\");\n+   begin\n+      Ada_Handler := Handler;\n+      Internal (C_Handler'Access);\n+   end Install_Handler;\n+\n+end GNAT.Ctrl_C;"}, {"sha": "b7360866ac84540469751d08e1aa35621658d2cc", "filename": "gcc/ada/g-ctrl_c.ads", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fg-ctrl_c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fg-ctrl_c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-ctrl_c.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                      Copyright (C) 2002-2006, AdaCore                    --\n+--                      Copyright (C) 2002-2007, AdaCore                    --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,12 +42,6 @@\n --  The behavior of this package when using tasking depends on the interaction\n --  between sigaction() and the thread library.\n \n---  On most implementations, the interaction will be no different whether\n---  tasking is involved or not. An exception is GNU/Linux systems where\n---  each task/thread is considered as a separate process by the kernel,\n---  meaning in particular that a Ctrl-C from the keyboard will be sent to\n---  all tasks instead of only one, resulting in multiple calls to the handler.\n-\n package GNAT.Ctrl_C is\n \n    type Handler_Type is access procedure;\n@@ -63,6 +57,5 @@ package GNAT.Ctrl_C is\n    --  If Install_Handler has never been called, this procedure has no effect.\n \n private\n-   pragma Import (C, Install_Handler, \"__gnat_install_int_handler\");\n    pragma Import (C, Uninstall_Handler, \"__gnat_uninstall_int_handler\");\n end GNAT.Ctrl_C;"}, {"sha": "25d12a5219992e99140afdca2be5b0850b71b673", "filename": "gcc/ada/i-vxwork-x86.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fi-vxwork-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fi-vxwork-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-vxwork-x86.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   S p e c                                --\n --                                                                          --\n---                     Copyright (C) 1999-2006, AdaCore                     --\n+--                     Copyright (C) 1999-2007, AdaCore                     --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,6 +47,9 @@\n --  For complete documentation of the operations in this package, please\n --  consult the VxWorks Programmer's Manual and VxWorks Reference Manual.\n \n+pragma Warnings (Off, \"*foreign convention*\");\n+pragma Warnings (Off, \"*add Convention pragma*\");\n+\n with System.VxWorks;\n \n package Interfaces.VxWorks is"}, {"sha": "9d55cb8f50e2de1dcffafbbc6f5e8194cbda78f6", "filename": "gcc/ada/s-auxdec-vms_64.ads", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-auxdec-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-auxdec-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms_64.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -465,28 +465,109 @@ private\n    pragma Inline_Always (Fetch_From_Address);\n    pragma Inline_Always (Assign_To_Address);\n \n-   --  Synchronization related subprograms. These are declared to have\n-   --  convention C so that the critical parameters are passed by reference.\n+   --  Synchronization related subprograms. Mechanism is explicitly set\n+   --  so that the critical parameters are passed by reference.\n    --  Without this, the parameters are passed by copy, creating load/store\n    --  race conditions. We also inline them, since this seems more in the\n    --  spirit of the original (hardware intrinsic) routines.\n \n-   pragma Convention (C, Clear_Interlocked);\n+   pragma Export_Procedure\n+     (Clear_Interlocked,\n+      External        => \"system__aux_dec__clear_interlocked__1\",\n+      Parameter_Types => (Boolean, Boolean),\n+      Mechanism       => (Reference, Reference));\n+   pragma Export_Procedure\n+     (Clear_Interlocked,\n+      External        => \"system__aux_dec__clear_interlocked__2\",\n+      Parameter_Types => (Boolean, Boolean, Natural, Boolean),\n+      Mechanism       => (Reference, Reference, Value, Reference));\n    pragma Inline_Always (Clear_Interlocked);\n \n-   pragma Convention (C, Set_Interlocked);\n+   pragma Export_Procedure\n+     (Set_Interlocked,\n+      External        => \"system__aux_dec__set_interlocked__1\",\n+      Parameter_Types => (Boolean, Boolean),\n+      Mechanism       => (Reference, Reference));\n+   pragma Export_Procedure\n+     (Set_Interlocked,\n+      External        => \"system__aux_dec__set_interlocked__2\",\n+      Parameter_Types => (Boolean, Boolean, Natural, Boolean),\n+      Mechanism       => (Reference, Reference, Value, Reference));\n    pragma Inline_Always (Set_Interlocked);\n \n-   pragma Convention (C, Add_Interlocked);\n+   pragma Export_Procedure\n+     (Add_Interlocked,\n+      External        => \"system__aux_dec__add_interlocked__1\",\n+      Mechanism       => (Value, Reference, Reference));\n    pragma Inline_Always (Add_Interlocked);\n \n-   pragma Convention (C, Add_Atomic);\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__1\",\n+      Parameter_Types => (Aligned_Integer, Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__2\",\n+      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__3\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__4\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n+                          Long_Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n    pragma Inline_Always (Add_Atomic);\n \n-   pragma Convention (C, And_Atomic);\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External        => \"system__aux_dec__and_atomic__1\",\n+      Parameter_Types => (Aligned_Integer, Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External        => \"system__aux_dec__and_atomic__2\",\n+      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External        => \"system__aux_dec__and_atomic__3\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External        => \"system__aux_dec__and_atomic__4\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n+                          Long_Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n    pragma Inline_Always (And_Atomic);\n \n-   pragma Convention (C, Or_Atomic);\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__1\",\n+      Parameter_Types => (Aligned_Integer, Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__2\",\n+      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__3\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__4\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n+                          Long_Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n    pragma Inline_Always (Or_Atomic);\n \n    --  Provide proper unchecked conversion definitions for transfer"}, {"sha": "6e90f89852fcab2328eefd130e6a35aee42d9bd1", "filename": "gcc/ada/s-auxdec.ads", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-auxdec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-auxdec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -455,28 +455,109 @@ private\n    pragma Inline_Always (Fetch_From_Address);\n    pragma Inline_Always (Assign_To_Address);\n \n-   --  Synchronization related subprograms. These are declared to have\n-   --  convention C so that the critical parameters are passed by reference.\n+   --  Synchronization related subprograms. Mechanism is explicitly set\n+   --  so that the critical parameters are passed by reference.\n    --  Without this, the parameters are passed by copy, creating load/store\n    --  race conditions. We also inline them, since this seems more in the\n    --  spirit of the original (hardware intrinsic) routines.\n \n-   pragma Convention (C, Clear_Interlocked);\n+   pragma Export_Procedure\n+     (Clear_Interlocked,\n+      External        => \"system__aux_dec__clear_interlocked__1\",\n+      Parameter_Types => (Boolean, Boolean),\n+      Mechanism       => (Reference, Reference));\n+   pragma Export_Procedure\n+     (Clear_Interlocked,\n+      External        => \"system__aux_dec__clear_interlocked__2\",\n+      Parameter_Types => (Boolean, Boolean, Natural, Boolean),\n+      Mechanism       => (Reference, Reference, Value, Reference));\n    pragma Inline_Always (Clear_Interlocked);\n \n-   pragma Convention (C, Set_Interlocked);\n+   pragma Export_Procedure\n+     (Set_Interlocked,\n+      External        => \"system__aux_dec__set_interlocked__1\",\n+      Parameter_Types => (Boolean, Boolean),\n+      Mechanism       => (Reference, Reference));\n+   pragma Export_Procedure\n+     (Set_Interlocked,\n+      External        => \"system__aux_dec__set_interlocked__2\",\n+      Parameter_Types => (Boolean, Boolean, Natural, Boolean),\n+      Mechanism       => (Reference, Reference, Value, Reference));\n    pragma Inline_Always (Set_Interlocked);\n \n-   pragma Convention (C, Add_Interlocked);\n+   pragma Export_Procedure\n+     (Add_Interlocked,\n+      External        => \"system__aux_dec__add_interlocked__1\",\n+      Mechanism       => (Value, Reference, Reference));\n    pragma Inline_Always (Add_Interlocked);\n \n-   pragma Convention (C, Add_Atomic);\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__1\",\n+      Parameter_Types => (Aligned_Integer, Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__2\",\n+      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__3\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Add_Atomic,\n+      External        => \"system__aux_dec__add_atomic__4\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n+                          Long_Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n    pragma Inline_Always (Add_Atomic);\n \n-   pragma Convention (C, And_Atomic);\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External        => \"system__aux_dec__and_atomic__1\",\n+      Parameter_Types => (Aligned_Integer, Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External        => \"system__aux_dec__and_atomic__2\",\n+      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External => \"system__aux_dec__and_atomic__3\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n+      Mechanism => (Reference, Value));\n+   pragma Export_Procedure\n+     (And_Atomic,\n+      External        => \"system__aux_dec__and_atomic__4\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n+                          Long_Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n    pragma Inline_Always (And_Atomic);\n \n-   pragma Convention (C, Or_Atomic);\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__1\",\n+      Parameter_Types => (Aligned_Integer, Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__2\",\n+      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__3\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n+      Mechanism       => (Reference, Value));\n+   pragma Export_Procedure\n+     (Or_Atomic,\n+      External        => \"system__aux_dec__or_atomic__4\",\n+      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n+                          Long_Integer, Boolean),\n+      Mechanism       => (Reference, Value, Value, Reference, Reference));\n    pragma Inline_Always (Or_Atomic);\n \n    --  Provide proper unchecked conversion definitions for transfer"}, {"sha": "38428e5d7d6b78d9352f49bcea5936e20787b662", "filename": "gcc/ada/s-interr-sigaction.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-interr-sigaction.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-interr-sigaction.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-sigaction.adb?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -117,6 +117,7 @@ package body System.Interrupts is\n    --  that contain interrupt handlers.\n \n    procedure Signal_Handler (Sig : Interrupt_ID);\n+   pragma Convention (C, Signal_Handler);\n    --  This procedure is used to handle all the signals\n \n    --  Type and Head, Tail of the list containing Registered Interrupt\n@@ -142,6 +143,7 @@ package body System.Interrupts is\n    --  Always consider a null handler as registered.\n \n    type Handler_Ptr is access procedure (Sig : Interrupt_ID);\n+   pragma Convention (C, Handler_Ptr);\n \n    function TISR is new Ada.Unchecked_Conversion (Handler_Ptr, isr_address);\n "}, {"sha": "705b60ae725cbd5225b86f6a3958ee41d56bf7eb", "filename": "gcc/ada/s-intman-vms.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-intman-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-intman-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vms.adb?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -59,7 +59,7 @@ package body System.Interrupt_Management is\n \n       Sys_Crembx\n         (Status => Status,\n-         Prmflg => False,\n+         Prmflg => 0,\n          Chan   => Rcv_Interrupt_Chan,\n          Maxmsg => Interrupt_ID'Size,\n          Bufquo => Interrupt_Bufquo,"}, {"sha": "46caa9b688672ad7fb24b8b49e4d8ce7e2af0988", "filename": "gcc/ada/s-osinte-aix.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-aix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-aix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-aix.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -266,6 +266,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -506,8 +507,8 @@ package System.OS_Interface is\n    function pthread_getspecific (key : pthread_key_t) return System.Address;\n    pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n \n-   type destructor_pointer is access\n-      procedure (arg : System.Address);\n+   type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "17a48e89e62c2628648d39223c376f37d01fd076", "filename": "gcc/ada/s-osinte-darwin.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-darwin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-darwin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -239,6 +239,8 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n+\n    type pthread_t           is private;\n    subtype Thread_Id        is pthread_t;\n \n@@ -475,6 +477,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "86fe3f6ab7e41ddc882f12749953d66003005fcb", "filename": "gcc/ada/s-osinte-freebsd.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-freebsd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-freebsd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-freebsd.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -267,6 +267,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -572,8 +573,8 @@ package System.OS_Interface is\n    function pthread_getspecific (key : pthread_key_t) return System.Address;\n    pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n \n-   type destructor_pointer is access\n-      procedure (arg : System.Address);\n+   type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "ac268c5948080f1bad7e952571afaec13a134ba3", "filename": "gcc/ada/s-osinte-hpux-dce.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-hpux-dce.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-hpux-dce.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-hpux-dce.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -133,6 +133,7 @@ package System.OS_Interface is\n    type sigset_t is private;\n \n    type isr_address is access procedure (sig : int);\n+   pragma Convention (C, isr_address);\n \n    function intr_attach (sig : int; handler : isr_address) return long;\n \n@@ -238,6 +239,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -426,6 +428,7 @@ package System.OS_Interface is\n    --  DCE_THREADS has a nonstandard pthread_getspecific\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "61d0473e0574e0ac44ebdd599d7e949f516afc69", "filename": "gcc/ada/s-osinte-hpux.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-hpux.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -256,6 +256,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -489,6 +490,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "5c35032c2b755514a7c85aed6467a415262be8c9", "filename": "gcc/ada/s-osinte-irix.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-irix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-irix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-irix.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -243,6 +243,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -445,6 +446,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "00b79af1ad52ea0dd86332fcab494b750c1f9fb6", "filename": "gcc/ada/s-osinte-linux-hppa.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-linux-hppa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-linux-hppa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux-hppa.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -8,7 +8,7 @@\n --                          (GNU/Linux-HPPA Version)                        --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2007, Free Software Foundation, Inc.      --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -255,7 +255,7 @@ package System.OS_Interface is\n \n    function To_Target_Priority\n      (Prio : System.Any_Priority) return Interfaces.C.int;\n-   --  Maps System.Any_Priority to a POSIX priority.\n+   --  Maps System.Any_Priority to a POSIX priority\n \n    -------------\n    -- Process --\n@@ -275,6 +275,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -455,6 +456,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "eb775d2fcbd3c8484effa0aa26dfad29e2e8dbb6", "filename": "gcc/ada/s-osinte-lynxos-3.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos-3.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -211,7 +211,7 @@ package System.OS_Interface is\n \n    function To_Target_Priority\n      (Prio : System.Any_Priority) return Interfaces.C.int;\n-   --  Maps System.Any_Priority to a POSIX priority.\n+   --  Maps System.Any_Priority to a POSIX priority\n \n    -------------\n    -- Process --\n@@ -241,6 +241,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -266,7 +267,7 @@ package System.OS_Interface is\n    -----------\n \n    Stack_Base_Available : constant Boolean := False;\n-   --  Indicates wether the stack base is available on this target.\n+   --  Indicates wether the stack base is available on this target\n \n    function Get_Stack_Base (thread : pthread_t) return Address;\n    pragma Inline (Get_Stack_Base);\n@@ -484,6 +485,7 @@ package System.OS_Interface is\n    --  LynxOS has a non standard pthread_getspecific\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "cc28c19819c37734c4413aa6c059a8f0afa75df8", "filename": "gcc/ada/s-osinte-lynxos.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2007, Free Software Foundation, Inc.      --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -253,6 +253,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -275,7 +276,7 @@ package System.OS_Interface is\n    -----------\n \n    Stack_Base_Available : constant Boolean := False;\n-   --  Indicates whether the stack base is available on this target.\n+   --  Indicates whether the stack base is available on this target\n \n    function Get_Stack_Base (thread : pthread_t) return Address;\n    pragma Inline (Get_Stack_Base);\n@@ -484,6 +485,7 @@ package System.OS_Interface is\n    pragma Import (C, st_getspecific, \"st_getspecific\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function st_keycreate\n      (destructor : destructor_pointer;"}, {"sha": "e0a3edf3a188fba85f30649fc1217198cb59c135", "filename": "gcc/ada/s-osinte-mingw.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-mingw.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -133,6 +133,7 @@ package System.OS_Interface is\n    type sigset_t is private;\n \n    type isr_address is access procedure (sig : int);\n+   pragma Convention (C, isr_address);\n \n    function intr_attach (sig : int; handler : isr_address) return long;\n    pragma Import (C, intr_attach, \"signal\");\n@@ -206,6 +207,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);"}, {"sha": "d887f434f3f6a87a4d5b5bd0c50fc6fb0a07db6c", "filename": "gcc/ada/s-osinte-solaris-posix.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-solaris-posix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-solaris-posix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-solaris-posix.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -220,7 +220,7 @@ package System.OS_Interface is\n \n    function To_Target_Priority\n      (Prio : System.Any_Priority) return Interfaces.C.int;\n-   --  Maps System.Any_Priority to a POSIX priority.\n+   --  Maps System.Any_Priority to a POSIX priority\n \n    -------------\n    -- Process --\n@@ -247,6 +247,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -271,7 +272,7 @@ package System.OS_Interface is\n    -----------\n \n    Stack_Base_Available : constant Boolean := False;\n-   --  Indicates whether the stack base is available on this target.\n+   --  Indicates whether the stack base is available on this target\n \n    function Get_Stack_Base (thread : pthread_t) return Address;\n    pragma Inline (Get_Stack_Base);\n@@ -477,6 +478,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "9a4a4bab756f27119f324093cc715172fcbae850", "filename": "gcc/ada/s-osinte-solaris.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-solaris.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-solaris.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-solaris.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -299,6 +299,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);"}, {"sha": "98f20a6c0ae879739090011f837baebbca85e98d", "filename": "gcc/ada/s-osinte-tru64.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-tru64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-tru64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-tru64.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -247,6 +247,7 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n      Ada.Unchecked_Conversion (System.Address, Thread_Body);\n@@ -484,6 +485,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_getspecific, \"__pthread_getspecific\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "a572847e0660b87b9e35463893b5709892267610", "filename": "gcc/ada/s-osinte-vms.ads", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2007, Free Software Foundation, Inc.      --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -42,12 +42,13 @@\n \n with Interfaces.C;\n with Ada.Unchecked_Conversion;\n+with System.Aux_DEC;\n \n package System.OS_Interface is\n    pragma Preelaborate;\n \n    pragma Linker_Options (\"--for-linker=sys$library:pthread$rtl.exe\");\n-   --  Link in the DEC threads library.\n+   --  Link in the DEC threads library\n \n    --  pragma Linker_Options (\"--for-linker=/threads_enable\");\n    --  Enable upcalls and multiple kernel threads.\n@@ -80,7 +81,7 @@ package System.OS_Interface is\n \n    subtype Interrupt_Number_Type is unsigned_long;\n \n-   --  OpenVMS system services return values of type Cond_Value_Type.\n+   --  OpenVMS system services return values of type Cond_Value_Type\n \n    subtype Cond_Value_Type is unsigned_long;\n    subtype Short_Cond_Value_Type is unsigned_short;\n@@ -92,6 +93,7 @@ package System.OS_Interface is\n    end record;\n \n    type AST_Handler is access procedure (Param : Address);\n+   pragma Convention (C, AST_Handler);\n    No_AST_Handler : constant AST_Handler := null;\n \n    CMB_M_READONLY  : constant := 16#00000001#;\n@@ -173,7 +175,7 @@ package System.OS_Interface is\n    --\n    procedure Sys_Crembx\n      (Status : out Cond_Value_Type;\n-      Prmflg : Boolean;\n+      Prmflg : unsigned_char;\n       Chan   : out unsigned_short;\n       Maxmsg : unsigned_long := 0;\n       Bufquo : unsigned_long := 0;\n@@ -184,7 +186,7 @@ package System.OS_Interface is\n    pragma Interface (External, Sys_Crembx);\n    pragma Import_Valued_Procedure\n      (Sys_Crembx, \"SYS$CREMBX\",\n-      (Cond_Value_Type, Boolean,        unsigned_short,\n+      (Cond_Value_Type, unsigned_char,  unsigned_short,\n        unsigned_long,   unsigned_long,  unsigned_short,\n        unsigned_short,  String,         unsigned_long),\n       (Value,           Value,          Reference,\n@@ -360,9 +362,10 @@ package System.OS_Interface is\n \n    type Thread_Body is access\n      function (arg : System.Address) return System.Address;\n+   pragma Convention (C, Thread_Body);\n \n    function Thread_Body_Access is new\n-     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+     Ada.Unchecked_Conversion (System.Aux_DEC.Short_Address, Thread_Body);\n \n    type pthread_t           is private;\n    subtype Thread_Id        is pthread_t;\n@@ -569,6 +572,7 @@ package System.OS_Interface is\n    pragma Import (C, pthread_getspecific, \"PTHREAD_GETSPECIFIC\");\n \n    type destructor_pointer is access procedure (arg : System.Address);\n+   pragma Convention (C, destructor_pointer);\n \n    function pthread_key_create\n      (key        : access pthread_key_t;"}, {"sha": "9684e78ac77dbdde7b6714b6c23d1f128b57e83f", "filename": "gcc/ada/s-osinte-vxworks.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -137,6 +137,7 @@ package System.OS_Interface is\n    pragma Import (C, sigaction, \"sigaction\");\n \n    type isr_address is access procedure (sig : int);\n+   pragma Convention (C, isr_address);\n \n    function c_signal (sig : Signal; handler : isr_address) return isr_address;\n    pragma Import (C, c_signal, \"signal\");"}, {"sha": "ad523c3aa75bd98a7d4dca0dc3ed0dfeb0ba1191", "filename": "gcc/ada/s-osinte-vxworks6.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-vxworks6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-osinte-vxworks6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks6.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -179,6 +179,7 @@ package System.OS_Interface is\n    pragma Import (C, sigaction, \"sigaction\");\n \n    type isr_address is access procedure (sig : int);\n+   pragma Convention (C, isr_address);\n \n    function c_signal (sig : Signal; handler : isr_address) return isr_address;\n    pragma Import (C, c_signal, \"signal\");"}, {"sha": "7094ed5f978ec5d730f61351ae6adbd67838d5eb", "filename": "gcc/ada/s-taprop-vms.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -54,6 +54,9 @@ with System.Soft_Links;\n --  used for Get_Exc_Stack_Addr\n --           Abort_Defer/Undefer\n \n+with System.Aux_DEC;\n+--  used for Short_Address\n+\n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n \n@@ -147,6 +150,7 @@ package body System.Task_Primitives.Operations is\n    --  Replace System.Soft_Links.Get_Exc_Stack_Addr_NT\n \n    procedure Timer_Sleep_AST (ID : Address);\n+   pragma Convention (C, Timer_Sleep_AST);\n    --  Signal the condition variable when AST fires\n \n    procedure Timer_Sleep_AST (ID : Address) is\n@@ -822,7 +826,7 @@ package body System.Task_Primitives.Operations is\n       Result     : Interfaces.C.int;\n \n       function Thread_Body_Access is new\n-        Ada.Unchecked_Conversion (System.Address, Thread_Body);\n+        Ada.Unchecked_Conversion (System.Aux_DEC.Short_Address, Thread_Body);\n \n    begin\n       --  Since the initial signal mask of a thread is inherited from the"}, {"sha": "3e2c742caa9e8322f43add503266db860b613e59", "filename": "gcc/ada/s-tpopde-vms.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-tpopde-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/def46b5433513c720e7a17c62fa3e1837d905fca/gcc%2Fada%2Fs-tpopde-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopde-vms.ads?ref=def46b5433513c720e7a17c62fa3e1837d905fca", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 2000-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2000-2007, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,7 @@ with System.Aux_DEC;\n package System.Task_Primitives.Operations.DEC is\n \n    procedure Interrupt_AST_Handler (ID : Address);\n+   pragma Convention (C, Interrupt_AST_Handler);\n    --  Handles the AST for Ada95 Interrupts.\n \n    procedure RMS_AST_Handler (ID : Address);"}]}