{"sha": "865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY1YjRlYTczZmE1MTVjMGJkMTNkZDExNTdkNTlkZDNmOTFlYzFiYg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2001-01-05T08:23:51Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-01-05T08:23:51Z"}, "message": "PipedInputStream: Rewrote to be simpler and more correct.\n\n\t* java/io/PipedInputStream: Rewrote to be simpler and more correct.\n\t* java/io/PipedOutputStream: Updated to match new PipedInputStream.\n\t* java/io/PipedReader: New implementation based on new\n\tPipedInputStream.\n\t* java/io/PipedWriter: Updated to match new PipedOutputStream.\n\nFrom-SVN: r38708", "tree": {"sha": "9845cc2a1b1bd53fe09d7d8b815481b3e1f9ceba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9845cc2a1b1bd53fe09d7d8b815481b3e1f9ceba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/comments", "author": null, "committer": null, "parents": [{"sha": "a5a4ce3c3c0eee620f62210898d661a3b05f283a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a4ce3c3c0eee620f62210898d661a3b05f283a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5a4ce3c3c0eee620f62210898d661a3b05f283a"}], "stats": {"total": 2102, "additions": 862, "deletions": 1240}, "files": [{"sha": "d0ae121e49005b4386da2d3a5bf005be42eb3ed3", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "patch": "@@ -2,6 +2,12 @@\n \n \t* java/lang/Thread.java: Update comment.\n \n+\t* java/io/PipedInputStream: Rewrote to be simpler and more correct.\n+\t* java/io/PipedOutputStream: Updated to match new PipedInputStream.\n+\t* java/io/PipedReader: New implementation based on new \n+\tPipedInputStream.\n+\t* java/io/PipedWriter: Updated to match new PipedOutputStream.\n+\n 2001-01-03  Tom Tromey  <tromey@redhat.com>\n \n \t* java/awt/ScrollPane.java (setBlockIncrement): Throw error."}, {"sha": "f8de8b0077d7f2d12bb2a808f5f52301d552386e", "filename": "libjava/java/io/PipedInputStream.java", "status": "modified", "additions": 309, "deletions": 442, "changes": 751, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedInputStream.java?ref=865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "patch": "@@ -1,5 +1,5 @@\n-/* PipedInputStream.java -- Input stream that reads from an output stream\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+/* PipedInputStream.java -- Read portion of piped streams.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -24,467 +24,334 @@\n This exception does not however invalidate any other reasons why the\n executable file might be covered by the GNU General Public License. */\n \n+// NOTE: This implementation is very similar to that of PipedReader.  If you \n+// fix a bug in here, chances are you should make a similar change to the \n+// PipedReader code.\n \n package java.io;\n \n /**\n-  * This class is an input stream that reads its bytes from an output stream\n+  * An input stream that reads its bytes from an output stream\n   * to which it is connected. \n   * <p>\n   * Data is read and written to an internal buffer.  It is highly recommended\n   * that the <code>PipedInputStream</code> and connected <code>PipedOutputStream</code>\n-  * be part of different threads.  If they are not, there is a possibility\n-  * that the read and write operations could deadlock their thread.\n+  * be part of different threads.  If they are not, the read and write \n+  * operations could deadlock their thread.\n   *\n-  * @version 0.0\n+  * @specnote The JDK implementation appears to have some undocumented \n+  *           functionality where it keeps track of what thread is writing\n+  *           to pipe and throws an IOException if that thread susequently\n+  *           dies. This behaviour seems dubious and unreliable - we don't\n+  *           implement it.\n   *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public class PipedInputStream extends InputStream\n {\n-\n-/*************************************************************************/\n-\n-/*\n- * Class Variables\n- */\n-\n-/**\n-  * The size of the internal buffer used for input/output.  Note that this\n-  * can be overriden by setting the system property \n-  * <code>gnu.java.io.PipedInputStream.pipe_size</code> to the desired size shown \n-  * in bytes.  This is not a standard part of the class library.  Note that \n-  * since this variable is <code>final</code>, it cannot be changed to refect \n-  * the size specified in the property.\n-  * <p>\n-  * The value for this variable is 2048.\n-  */\n-protected static final int PIPE_SIZE = 2048;\n-\n-/**\n-  * This is the real pipe size.  It defaults to PIPE_SIZE, unless overridden\n-  * by use of the system property <code>gnu.java.io.PipedInputStream.pipe_size</code>.\n-  */\n-private static int pipe_size;\n-\n-static\n-{\n-  pipe_size = Integer.getInteger(\"gnu.java.io.PipedInputStream.pipe_size\",\n-                                 PIPE_SIZE).intValue();\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the internal circular buffer used for storing bytes written\n-  * to the pipe and from which bytes are read by this stream\n-  */\n-protected byte[] buffer = new byte[pipe_size];\n-\n-/**\n-  * The index into buffer where the bytes written byte the connected\n-  * <code>PipedOutputStream</code> will be written.  If this variables is less\n-  * than 0, then the buffer is empty.  If this variable is equal to \n-  * <code>out</code>, then the buffer is full\n-  */\n-protected int in = -1;\n-\n-/**\n-  * This index into the buffer where bytes will be read from.\n-  */\n-protected int out = 0;\n-\n-/**\n-  * This variable is <code>true</code> if this object has ever been connected\n-  * to a <code>PipedOutputStream</code>, and <code>false</code> otherwise.  It is used\n-  * to detect an attempt to connect an already connected stream or to\n-  * otherwise use the stream before it is connected.\n-  */\n-private boolean ever_connected = false;\n-\n-/**\n-  * This variable is set to <code>true</code> if the <code>close()</code> method is\n-  * called.  This value is checked prevents a caller from re-opening the\n-  * stream.\n-  */\n-private boolean closed = false;\n-\n-/**\n-  * This variable is the PipedOutputStream to which this stream is connected.\n-  */\n-PipedOutputStream src;\n-\n-/**\n-  * Used by <code>read()</code> to call an overloaded method\n-  */\n-private byte[] read_buf = new byte[1];\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This constructor creates a new <code>PipedInputStream</code> that is not \n-  * connected to a <code>PipedOutputStream</code>.  It must be connected before\n-  * bytes can be read from this stream.\n-  */\n-public\n-PipedInputStream()\n-{\n-  return;\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This constructor creates a new <code>PipedInputStream</code> and connects\n-  * it to the passed in <code>PipedOutputStream</code>. The stream is then read\n-  * for reading.\n-  *\n-  * @param src The <code>PipedOutputStream</code> to connect this stream to\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public\n-PipedInputStream(PipedOutputStream src) throws IOException\n-{\n-  connect(src);\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This method connects this stream to the passed in <code>PipedOutputStream</code>.\n-  * This stream is then ready for reading.  If this stream is already\n-  * connected or has been previously closed, then an exception is thrown\n-  *\n-  * @param src The <code>PipedOutputStream</code> to connect this stream to\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized void\n-connect(PipedOutputStream src) throws IOException\n-{\n-  if (src == this.src)\n-    return;\n-\n-  if (ever_connected)\n-    throw new IOException(\"Already connected\");\n-\n-  if (closed)\n-    throw new IOException(\"Stream is closed and cannot be reopened\");\n-\n-  src.connect(this);\n-\n-  ever_connected = true;\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This methods closes the stream so that no more data can be read\n-  * from it.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized void\n-close() throws IOException\n-{\n-  closed = true;\n-  notifyAll();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method returns the number of bytes that can be read from this stream\n-  * before blocking could occur.  This is the number of bytes that are\n-  * currently unread in the internal circular buffer.  Note that once this\n-  * many additional bytes are read, the stream may block on a subsequent\n-  * read, but it not guaranteed to block.\n-  *\n-  * @return The number of bytes that can be read before blocking might occur\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized int\n-available() throws IOException\n-{\n-  if (in == -1)\n-    return(0);\n-  else if (in > out)\n-    return(in - out);\n-  else\n-    return(in + (pipe_size - out));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Reads the next byte from the stream.  The byte read is returned as\n-  * and int in the range of 0-255.  If a byte cannot be read because of an\n-  * end of stream condition, -1 is returned.  If the stream is already\n-  * closed, an IOException will be thrown.\n-  *  <code>\n-  * This method will block if no bytes are available to be read.\n-  *\n-  * @return The byte read or -1 if end of stream.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized int\n-read() throws IOException\n-{\n-  // Method operates by calling the multibyte overloaded read method\n-  // Note that read_buf is an internal instance variable.  I allocate it\n-  // there to avoid constant reallocation overhead for applications that\n-  // call this method in a loop at the cost of some unneeded overhead\n-  // if this method is never called.\n- \n-  int bytes_read = read(read_buf, 0, read_buf.length);\n-\n-  if (bytes_read == -1)\n-    return(-1);\n-  else\n-    return((read_buf[0] & 0xFF));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads bytes from the stream into a caller supplied buffer.\n-  * It starts storing bytes at position <code>offset</code> into the buffer and\n-  * reads a maximum of <cod>>len</code> bytes.  Note that this method can actually\n-  * read fewer than <code>len</code> bytes.  The actual number of bytes read is\n-  * returned.  A -1 is returned to indicated that no bytes can be read\n-  * because the end of the stream was reached.  If the stream is already\n-  * closed, a -1 will again be returned to indicate the end of the stream.\n-  * <p>\n-  * This method will block if no bytes are available to be read.\n-  *\n-  * @param buf The buffer into which bytes will be stored\n-  * @param offset The index into the buffer at which to start writing.\n-  * @param len The maximum number of bytes to read.\n-  */\n-public synchronized int\n-read(byte[] buf, int offset, int len) throws IOException\n-{\n-  if (!ever_connected)\n-    throw new IOException(\"Not connected\"); \n-\n-  int bytes_read = 0;\n-  for (;;)\n-    {\n-      // If there are bytes, take them.\n-      if (in != -1)\n-        {\n-          int desired_bytes = len - bytes_read;\n-\n-          // We are in a \"wrap\" condition.\n-          if (out >= in)\n-            {\n-\t      desired_bytes = Math.min (desired_bytes, pipe_size - out);\n-\n-\t      System.arraycopy (buffer, out, buf, offset + bytes_read,\n-\t\t\t\tdesired_bytes);\n-\n-\t      bytes_read += desired_bytes;\n-\t      out += desired_bytes;\n-\t      desired_bytes = len - bytes_read;\n-\n-\t      if (out == pipe_size)\n-\t\t{\n-\t\t  out = 0;\n-\t\t  // OUT has wrapped.  Make sure that we don't falsely\n-\t\t  // indicate that the buffer is full.\n-\t\t  if (in == 0)\n-\t\t    in = -1;\n-\t\t}\n-\n-\t      notifyAll();\n-            }\n-\n-          // We are in a \"no wrap\".  This can be triggered by\n-          // fall-through from the above.\n-          if (in > out)\n-            {\n-\t      desired_bytes = Math.min (desired_bytes, in - out);\n-\n-              System.arraycopy(buffer, out, buf, offset + bytes_read, \n-                               desired_bytes);\n-\n-              bytes_read += desired_bytes;\n-              out += desired_bytes;\n-              desired_bytes = len - bytes_read;\n-\n-\t      if (out == in)\n-\t\t{\n-\t\t  // Don't falsely indicate that the buffer is full.\n-\t\t  out = 0;\n-\t\t  in = -1;\n-\t\t}\n-              else if (out == pipe_size)\n-                out = 0;\n-\n-              notifyAll();\n-            }\n-        }\n-\n-      // Return when we've read something.  A short return is ok.\n-      // Also return in the case where LEN==0.\n-      if (bytes_read > 0 || bytes_read == len)\n-\treturn(bytes_read);\n-\n-      // Handle the case where the end of stream was encountered.\n-      if (closed)\n-        {\n-\t  if (in == -1)\n-\t    {\n-\t      // The stream is closed and empty.  We've already\n-\t      // returned if bytes were read.  So we know EOF is the\n-\t      // only answer.\n-\t      return -1;\n-\t    }\n-\n-\t  // I think this shouldn't happen.  I don't think there is a\n-\t  // way to get here when nothing has been read but there are\n-\t  // bytes in the buffer.  Still...\n-\t  continue;\n-        }\n-\n-      // Wait for a byte to be received.\n-      try\n-        {\n-          wait();\n-        }\n-      catch(InterruptedException e) { ; }\n-    } \n-}\n-\n-/*************************************************************************/\n-\n-/**\n+  /** PipedOutputStream to which this is connected. Null only if this \n+    * InputStream hasn't been connected yet. */\n+  PipedOutputStream source;\n+\n+  /** Set to true if close() has been called on this InputStream. */\n+  boolean closed;\n+\n+  /**\n+    * The size of the internal buffer used for input/output.\n+    */\n+  protected static final int PIPE_SIZE = 2048;\n+\n+  /**\n+    * This is the internal circular buffer used for storing bytes written\n+    * to the pipe and from which bytes are read by this stream\n+    */\n+  protected byte[] buffer = new byte[PIPE_SIZE];\n+\n+  /**\n+    * The index into buffer where the next byte from the connected\n+    * <code>PipedOutputStream</code> will be written. If this variable is \n+    * equal to <code>out</code>, then the buffer is full. If set to < 0,\n+    * the buffer is empty.\n+    */\n+  protected int in = -1;\n+\n+  /**\n+    * This index into the buffer where bytes will be read from.\n+    */\n+  protected int out = 0;\n+\n+  /** Buffer used to implement single-argument read/receive */\n+  private byte[] read_buf = new byte[1];\n+\n+  /**\n+    * Creates a new <code>PipedInputStream</code> that is not connected to a \n+    * <code>PipedOutputStream</code>.  It must be connected before bytes can \n+    * be read from this stream.\n+    */\n+  public PipedInputStream()\n+  {\n+  }\n+\n+  /**\n+    * This constructor creates a new <code>PipedInputStream</code> and connects\n+    * it to the passed in <code>PipedOutputStream</code>. The stream is then \n+    * ready for reading.\n+    *\n+    * @param source The <code>PipedOutputStream</code> to connect this stream to\n+    *\n+    * @exception IOException If <code>source</code> is already connected.\n+    */\n+  public PipedInputStream(PipedOutputStream source) throws IOException\n+  {\n+    connect(source);\n+  }\n+\n+  /**\n+    * This method connects this stream to the passed in <code>PipedOutputStream</code>.\n+    * This stream is then ready for reading.  If this stream is already\n+    * connected or has been previously closed, then an exception is thrown\n+    *\n+    * @param src The <code>PipedOutputStream</code> to connect this stream to\n+    *\n+    * @exception IOException If this PipedInputStream or <code>source</code> \n+    *                        has been connected already.\n+    */\n+  public void connect(PipedOutputStream source) throws IOException\n+  {\n+    // The JDK (1.3) does not appear to check for a previously closed \n+    // connection here.\n+    \n+    if (this.source != null || source.sink != null)\n+      throw new IOException (\"Already connected\");\n+    \n+    source.sink = this;\n+    this.source = source;\n+  }\n+  \n+  /**\n   * This method receives a byte of input from the source PipedOutputStream.\n-  * If there is no data ready to be written, or if the internal circular\n-  * buffer is full, this method blocks.\n+  * If the internal circular buffer is full, this method blocks.\n   *\n   * @param byte_received The byte to write to this stream\n   *\n   * @exception IOException if error occurs\n-  *\n+  * @specnote Weird. This method must be some sort of accident.\n   */\n-protected synchronized void\n-receive(int byte_received) throws IOException\n-{\n-  // This is really slow, but it has the benefit of not duplicating\n-  // the complicated machinery in receive(byte[],int,int).\n-  byte[] buf = new byte[1];\n-  buf[0] = (byte) (byte_received & 0xff);\n-  receive (buf, 0, 1);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method is used by the connected <code>PipedOutputStream</code> to\n-  * write bytes into the buffer.  It uses this method instead of directly\n-  * writing the bytes in order to obtain ownership of the object's monitor\n-  * for the purposes of calling <code>notify</code>.\n-  *\n-  * @param buf The array containing bytes to write to this stream\n-  * @param offset The offset into the array to start writing from\n-  * @param len The number of bytes to write.\n+  protected synchronized void receive(int b) throws IOException\n+  {\n+    read_buf[0] = (byte) (b & 0xff);\n+    receive (read_buf, 0, 1);\n+  }\n+\n+  /**\n+    * This method is used by the connected <code>PipedOutputStream</code> to\n+    * write bytes into the buffer.\n+    *\n+    * @param buf The array containing bytes to write to this stream\n+    * @param offset The offset into the array to start writing from\n+    * @param len The number of bytes to write.\n+    *\n+    * @exception IOException If an error occurs\n+    * @specnote This code should be in PipedOutputStream.write, but we\n+    *           put it here in order to support that bizarre recieve(int)\n+    *           method.\n+    */  \n+  synchronized void receive(byte[] buf, int offset, int len)\n+    throws IOException\n+  {\n+    if (closed)\n+      throw new IOException (\"Pipe closed\");\n+\n+    int bufpos = offset;\n+    int copylen;\n+    \n+    while (len > 0)\n+      {\n+        try\n+\t  {\n+\t    while (in == out)\n+\t      {\n+\t\t// The pipe is full. Wake up any readers and wait for them.\n+\t\tnotifyAll();\n+\t\twait();\n+\t\t// The pipe could have been closed while we were waiting.\n+\t        if (closed)\n+\t\t  throw new IOException (\"Pipe closed\");\n+\t      }\n+\t  }\n+\tcatch (InterruptedException ix)\n+\t  {\n+            throw new InterruptedIOException ();\n+\t  }\n+\n+\tif (in < 0) // The pipe is empty.\n+\t  in = 0;\n+\t\n+\t// Figure out how many bytes from buf can be copied without \n+\t// overrunning out or going past the length of the buffer.\n+\tif (in < out)\n+\t  copylen = Math.min (len, out - in);\n+\telse\n+\t  copylen = Math.min (len, buffer.length - in);\n+\n+\t// Copy bytes until the pipe is filled, wrapping if neccessary.\n+\tSystem.arraycopy(buf, bufpos, buffer, in, copylen);\n+\tlen -= copylen;\n+\tbufpos += copylen;\n+\tin += copylen;\n+\tif (in == buffer.length)\n+\t  in = 0;\n+      }\n+    // Notify readers that new data is in the pipe.\n+    notifyAll();\n+  }\n+  \n+  /**\n+    * This method reads bytes from the stream into a caller supplied buffer.\n+    * It starts storing bytes at position <code>offset</code> into the buffer and\n+    * reads a maximum of <cod>>len</code> bytes.  Note that this method can actually\n+    * read fewer than <code>len</code> bytes.  The actual number of bytes read is\n+    * returned.  A -1 is returned to indicated that no bytes can be read\n+    * because the end of the stream was reached.  If the stream is already\n+    * closed, a -1 will again be returned to indicate the end of the stream.\n+    * <p>\n+    * This method will block if no bytes are available to be read.\n+    *\n+    * @param buf The buffer into which bytes will be stored\n+    * @param offset The index into the buffer at which to start writing.\n+    * @param len The maximum number of bytes to read.\n+    */\n+  public int read() throws IOException\n+  {\n+    // Method operates by calling the multibyte overloaded read method\n+    // Note that read_buf is an internal instance variable.  I allocate it\n+    // there to avoid constant reallocation overhead for applications that\n+    // call this method in a loop at the cost of some unneeded overhead\n+    // if this method is never called.\n+\n+    int r = read(read_buf, 0, 1);\n+\n+    if (r == -1)\n+      return -1;\n+    else\n+      return read_buf[0];\n+  }\n+  \n+  /**\n+    * This method reads bytes from the stream into a caller supplied buffer.\n+    * It starts storing bytes at position <code>offset</code> into the buffer and\n+    * reads a maximum of <cod>>len</code> bytes.  Note that this method can actually\n+    * read fewer than <code>len</code> bytes.  The actual number of bytes read is\n+    * returned.  A -1 is returned to indicated that no bytes can be read\n+    * because the end of the stream was reached - ie close() was called on the\n+    * connected PipedOutputStream.\n+    * <p>\n+    * This method will block if no bytes are available to be read.\n+    *\n+    * @param buf The buffer into which bytes will be stored\n+    * @param offset The index into the buffer at which to start writing.\n+    * @param len The maximum number of bytes to read.\n+    *\n+    * @exception IOException If <code>close()/code> was called on this Piped\n+    *                        InputStream.\n+    */  \n+  public synchronized int read(byte[] buf, int offset, int len)\n+    throws IOException\n+  {\n+    if (source == null)\n+      throw new IOException (\"Not connected\");\n+    if (closed)\n+      throw new IOException (\"Pipe closed\");\n+\n+    // If the buffer is empty, wait until there is something in the pipe \n+    // to read.\n+    try\n+      {\n+\twhile (in < 0)\n+\t  {\n+\t    if (source.closed)\n+\t      return -1;\n+\t    wait();\n+\t  }\n+      }\n+    catch (InterruptedException ix)\n+      {\n+        throw new InterruptedIOException();\n+      }\n+    \n+    int total = 0;\n+    int copylen;\n+    \n+    while (true)\n+      {\n+\t// Figure out how many bytes from the pipe can be copied without \n+\t// overrunning in or going past the length of buf.\n+\tif (out < in)\n+\t  copylen = Math.min (len, in - out);\n+\telse\n+\t  copylen = Math.min (len, buffer.length - out);\n+\n+        System.arraycopy (buffer, out, buf, offset, copylen);\n+\toffset += copylen;\n+\tlen -= copylen;\n+\tout += copylen;\n+\ttotal += copylen;\n+\t\n+\tif (out == buffer.length)\n+\t  out = 0;\n+\t\n+\tif (out == in)\n+\t  {\n+\t    // Pipe is now empty.\n+\t    in = -1;\n+\t    out = 0;\n+\t  }\n+\n+        // If output buffer is filled or the pipe is empty, we're done.\n+\tif (len == 0 || in == -1)\n+\t  {\n+\t    // Notify any waiting outputstream that there is now space\n+\t    // to write.\n+\t    notifyAll();\n+\t    return total;\n+\t  }\n+      }\n+  }\n+  \n+  /**\n+    * This method returns the number of bytes that can be read from this stream\n+    * before blocking could occur.  This is the number of bytes that are\n+    * currently unread in the internal circular buffer.  Note that once this\n+    * many additional bytes are read, the stream may block on a subsequent\n+    * read, but it not guaranteed to block.\n+    *\n+    * @return The number of bytes that can be read before blocking might occur\n+    *\n+    * @exception IOException If an error occurs\n+    */  \n+  public synchronized int available() throws IOException\n+  {\n+    // The JDK 1.3 implementation does not appear to check for the closed or \n+    // unconnected stream conditions here.\n+    \n+    if (in < 0)\n+      return 0;\n+    else if (out < in)\n+      return in - out;\n+    else\n+      return (buffer.length - out) + in;\n+  }\n+  \n+  /**\n+  * This methods closes the stream so that no more data can be read\n+  * from it.\n   *\n   * @exception IOException If an error occurs\n   */\n-synchronized void\n-receive(byte[] buf, int offset, int len) throws IOException\n-{\n-  if (len <= 0)\n-    return;\n-\n-  int total_written = 0;\n- outer:\n-  while (total_written < len)\n-    {\n-      // If the buffer is full, then wait.\n-      // Also, if we are at the end of the buffer and OUT is 0, wait.\n-      if (! (in == out\n-\t     || (in == pipe_size - 1 && out == 0)))\n-        {\n-          // This is the \"no wrap\" situation\n-\t  if (in > out)\n-            {\n-              int bytes_written = 0;\n-              if ((pipe_size - in) > (len - total_written))\n-                bytes_written = (len - total_written);\n-              else if (out == 0)\n-                bytes_written = (pipe_size - in) - 1;\n-              else \n-                bytes_written = (pipe_size - in);\n-\n-              if (bytes_written > 0) \n-\t\t{\n-\t\t  System.arraycopy(buf, offset + total_written, buffer, in, \n-\t\t\t\t   bytes_written);\n-\t\t  total_written += bytes_written;\n-\t\t  in += bytes_written;\n-\n-\t\t  if (in == pipe_size)\n-\t\t    in = 0;\n-\n-\t\t  notifyAll();\n-\t\t}\n-            }\n-\n-          // This is the \"wrap\" situtation\n-          if ((out > in) && (total_written != len))\n-            {\n-              int bytes_written = 0;\n-\n-              // Do special processing if we are at the beginning\n-              if (in == -1)\n-                {\n-                  in = 0;\n-\t\t  bytes_written = Math.min (len - total_written, pipe_size);\n-                }\n-              else\n-\t\t{\n-\t\t  bytes_written = Math.min (len - total_written,\n-\t\t\t\t\t    out - in);\n-\t\t}\n-\n-              System.arraycopy(buf, offset + total_written, buffer, in,\n-                               bytes_written);\n-              total_written += bytes_written;\n-              in += bytes_written;\n-\n-              if (in == pipe_size)\n-                in = 0;\n-\n-              notifyAll();\n-            }\n-        }\n-      // Wait for some reads to occur before we write anything.\n-      else\n-        {\n-          try\n-            {\n-              wait();\n-            }\n-          catch (InterruptedException e) { ; }\n-        }\n-    }\n+  public synchronized void close() throws IOException\n+  {\n+    closed = true;\n+    // Wake any thread which may be in receive() waiting to write data.\n+    notifyAll();\n+  }\n }\n-\n-} // class PipedInputStream"}, {"sha": "96b8e9e9812edad57062002c5cc0697101a77911", "filename": "libjava/java/io/PipedOutputStream.java", "status": "modified", "additions": 128, "deletions": 164, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedOutputStream.java?ref=865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "patch": "@@ -1,5 +1,5 @@\n /* PipedOutputStream.java -- Write portion of piped streams.\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -27,6 +27,10 @@\n \n package java.io;\n \n+// NOTE: This implementation is very similar to that of PipedWriter.  If you \n+// fix a bug in here, chances are you should make a similar change to the \n+// PipedWriter code.\n+\n /**\n   * This class writes its bytes to a <code>PipedInputStream</code> to \n   * which it is connected.\n@@ -36,171 +40,131 @@\n   * they are in the same thread, read and write operations could deadlock\n   * the thread.\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public class PipedOutputStream extends OutputStream\n {\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the <code>PipedInputStream</code> to which this object\n-  * is connected.\n-  */\n-private PipedInputStream snk;\n-\n-/**\n-  * This flag indicates whether or not this stream has ever been\n-  * connected to an input stream\n-  */\n-private boolean ever_connected;\n-\n-/**\n-  * This flag indicates whether the <code>close</code> method has ever\n-  * been called for this stream.\n-  */\n-private boolean closed;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a new <code>PipedOutputStream</code> instance.\n-  * This constructor creates an unconnected object.  It must be connected\n-  * to a <code>PipedInputStream</code> object using the <code>connect</code>\n-  * method prior to writing any data or an exception will be thrown.\n-  */\n-public\n-PipedOutputStream()\n-{\n-  ; // Do Nothing\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a new <code>PipedOutputStream</code> instance\n-  * to write to the specified <code>PipedInputStream</code>.  This stream\n-  * is then ready for writing.\n-  *\n-  * @param snk The <code>PipedInputStream</code> to connect this stream to.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public\n-PipedOutputStream(PipedInputStream snk) throws IOException\n-{\n-  connect(snk);\n-} \n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * This method connects this object to the specified \n-  * <code>PipedInputStream</code> object.  This stream will then be ready \n-  * for writing.  If this stream is already connected or has been \n-  * previously closed, then an exception is thrown.\n-  *\n-  * @param snk The <code>PipedInputStream</code> to connect this stream to\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized void\n-connect(PipedInputStream snk) throws IOException\n-{\n-  if (snk == this.snk)\n-    return;\n-\n-  if (ever_connected)\n-    throw new IOException(\"Already connected\");\n-\n-  if (closed)\n-    throw new IOException(\"Stream is closed and cannot be reopened\");\n-\n-  this.snk = snk;\n-  ever_connected = true;\n-  snk.src = this;\n-\n-  snk.connect(this);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method closes this stream so that no more data can be written\n-  * to it. Any further attempts to write to this stream may throw an\n-  * exception\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized void\n-close() throws IOException\n-{\n-  closed = true;\n-  snk.close();\n-  notifyAll();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a single byte of date to the stream.  Note that\n-  * this method will block if the <code>PipedInputStream</code> to which\n-  * this object is connected has a full buffer.\n-  *\n-  * @param b The byte of data to be written, passed as an <code>int</code>.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized void\n-write(int b) throws IOException\n-{\n-  snk.receive (b);\n+  /** Target PipedInputStream to which this is connected. Null only if this \n+    * OutputStream hasn't been connected yet. */\n+  PipedInputStream sink;\n+  \n+  /** Set to true if close() has been called on this OutputStream. */\n+  boolean closed;\n+  \n+  /** \n+    * Create an unconnected PipedOutputStream.  It must be connected\n+    * to a <code>PipedInputStream</code> using the <code>connect</code>\n+    * method prior to writing any data or an exception will be thrown.\n+    */\n+  public PipedOutputStream()\n+  {\n+  }\n+\n+  /**\n+     * Create a new <code>PipedOutputStream</code> instance\n+    * to write to the specified <code>PipedInputStream</code>.  This stream\n+    * is then ready for writing.\n+    *\n+    * @param sink The <code>PipedInputStream</code> to connect this stream to.\n+    *\n+    * @exception IOException If <code>sink</code> has already been connected \n+    *                        to a different PipedOutputStream.\n+    */\n+  public PipedOutputStream(PipedInputStream sink) throws IOException\n+  {\n+    sink.connect(this);\n+  }\n+\n+  /**\n+    * Connects this object to the specified <code>PipedInputStream</code> \n+    * object.  This stream will then be ready for writing.\n+    *\n+    * @param sink The <code>PipedInputStream</code> to connect this stream to\n+    *\n+    * @exception IOException If the stream has not been connected or has\n+    *                        been closed.\n+    */\n+  public void connect(PipedInputStream sink) throws IOException\n+  {\n+    if (sink != null)\n+      throw new IOException (\"Already connected\");\n+    sink.connect(this);\n+  }\n+\n+  /**\n+    * Write a single byte of date to the stream.  Note that this method will \n+    * block if the <code>PipedInputStream</code> to which this object is \n+    * connected has a full buffer.\n+    *\n+    * @param b The byte of data to be written, passed as an <code>int</code>.\n+    *\n+    * @exception IOException If the stream has not been connected or has\n+    *                        been closed.\n+    */  \n+  public void write(int b) throws IOException\n+  {\n+    if (sink == null)\n+      throw new IOException (\"Not connected\");\n+    if (closed)\n+      throw new IOException (\"Pipe closed\");\n+      \n+    sink.receive (b);\n+  }\n+  \n+  /**\n+    * This method writes <code>len</code> bytes of data from the byte array\n+    * <code>buf</code> starting at index <code>offset</code> in the array\n+    * to the stream.  Note that this method will block if the  \n+    * <code>PipedInputStream</code> to which this object is connected has\n+    * a buffer that cannot hold all of the bytes to be written.\n+    *\n+    * @param buf The array containing bytes to write to the stream.\n+    * @param offset The index into the array to start writing bytes from.\n+    * @param len The number of bytes to write.\n+    *\n+    * @exception IOException If the stream has not been connected or has\n+    *                        been closed.\n+    */\n+  public void write(byte[] b, int off, int len) throws IOException\n+  {\n+    if (sink == null)\n+      throw new IOException (\"Not connected\");\n+    if (closed)\n+      throw new IOException (\"Pipe closed\");\n+      \n+    sink.receive (b, off, len);\n+  }\n+\n+  /**\n+    * This method does nothing.\n+    *\n+    * @exception IOException If the stream is closed.\n+    * @specnote You'd think that this method would block until the sink\n+    *           had read all available data. Thats not the case - this method\n+    *           appears to be a no-op?\n+    */\n+  public void flush()\n+  {\n+  }\n+  \n+  /**\n+    * This method closes this stream so that no more data can be written\n+    * to it. Any further attempts to write to this stream may throw an\n+    * exception\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void close()\n+  {\n+    // A close call on an unconnected PipedOutputStream has no effect.\n+    if (sink != null)\n+      {\n+\tclosed = true;\n+\t// Notify any waiting readers that the stream is now closed.\n+\tsynchronized (sink)\n+\t{\t  \n+\t  sink.notifyAll();\n+\t}\n+      }\n+  }\n }\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes <code>len</code> bytes of data from the byte array\n-  * <code>buf</code> starting at index <code>offset</code> in the array\n-  * to the stream.  Note that this method will block if the  \n-  * <code>PipedInputStream</code> to which this object is connected has\n-  * a buffer that cannot hold all of the bytes to be written.\n-  *\n-  * @param buf The array containing bytes to write to thes stream.\n-  * @param offset The index into the array to start writing bytes from.\n-  * @param len The number of bytes to write.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(byte[] buf, int offset, int len) throws IOException\n-{\n-  snk.receive (buf, 0, len);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method flushes any unwritten bytes to the output and notifies\n-  * any waiting readers that the pipe is ready to be read.\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public void\n-flush() throws IOException\n-{\n-  return;\n-}\n-\n-} // class PipedOutputStream\n-"}, {"sha": "6e4e10422adfd7f900c61d3d2d79b0912a7040c6", "filename": "libjava/java/io/PipedReader.java", "status": "modified", "additions": 291, "deletions": 458, "changes": 749, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedReader.java?ref=865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "patch": "@@ -1,5 +1,5 @@\n-/* PipedReader.java -- Input stream that reads from an output stream\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+/* PipedReader.java -- Read portion of piped character streams.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -24,479 +24,312 @@\n This exception does not however invalidate any other reasons why the\n executable file might be covered by the GNU General Public License. */\n \n-\n package java.io;\n \n+// NOTE: This implementation is very similar to that of PipedInputStream. \n+// If you fix a bug in here, chances are you should make a similar change to \n+// the PipedInputStream code.\n+\n /**\n-  * This class is an input stream that reads its chars from an output stream\n-  * to which it is connected. \n+  * An input stream that reads characters from a piped writer to which it is \n+  * connected. \n   * <p>\n   * Data is read and written to an internal buffer.  It is highly recommended\n   * that the <code>PipedReader</code> and connected <code>PipedWriter</code>\n   * be part of different threads.  If they are not, there is a possibility\n   * that the read and write operations could deadlock their thread.\n   *\n-  * @version 0.0\n+  * @specnote The JDK implementation appears to have some undocumented \n+  *           functionality where it keeps track of what thread is writing\n+  *           to pipe and throws an IOException if that thread susequently\n+  *           dies. This behaviour seems dubious and unreliable - we don't\n+  *           implement it.\n   *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public class PipedReader extends Reader\n {\n-\n-/*************************************************************************/\n-\n-/*\n- * Class Variables\n- */\n-\n-/**\n-  * The size of the internal buffer used for input/output.  Note that this\n-  * can be overriden by setting the system property \n-  * <code>gnu.java.io.PipedReader.pipe_size</code> to the desired size shown \n-  * in chars.  This is not a standard part of the class library.  Note that \n-  * since this variable is <code>final</code>, it cannot be changed to refect \n-  * the size specified in the property.\n-  * <p>\n-  * The value for this variable is 2048.\n-  */\n-private static final int PIPE_SIZE = 2048;\n-\n-/**\n-  * This is the real pipe size.  It defaults to PIPE_SIZE, unless overridden\n-  * by use of the system property <code>gnu.java.io.PipedReader.pipe_size</code>.\n-  */\n-private static int pipe_size;\n-\n-static\n-{\n-  pipe_size =  Integer.getInteger(\"gnu.java.io.PipedReader.pipe_size\",\n-                                  PIPE_SIZE).intValue();\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the internal circular buffer used for storing chars written\n-  * to the pipe and from which chars are read by this stream\n-  */\n-private char[] buffer = new char[pipe_size];\n-\n-/**\n-  * The index into buffer where the chars written char the connected\n-  * <code>PipedWriter</code> will be written.  If this variables is less\n-  * than 0, then the buffer is empty.  If this variable is equal to \n-  * <code>out</code>, then the buffer is full\n-  */\n-private int in = -1;\n-\n-/**\n-  * This index into the buffer where chars will be read from.\n-  */\n-private int out = 0;\n-\n-/**\n-  * This variable is <code>true</code> if this object has ever been connected\n-  * to a <code>PipedWriter</code>, and <code>false</code> otherwise.  It is used\n-  * to detect an attempt to connect an already connected stream or to\n-  * otherwise use the stream before it is connected.\n-  */\n-private boolean ever_connected = false;\n-\n-/**\n-  * This variable is set to <code>true</code> if the <code>close()</code> method is\n-  * called.  This value is checked prevents a caller from re-opening the\n-  * stream.\n-  */\n-private boolean closed = false;\n-\n-/**\n-  * This variable is the PipedWriter to which this stream is connected.\n-  */\n-PipedWriter src;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This constructor creates a new <code>PipedReader</code> that is not \n-  * connected to a <code>PipedWriter</code>.  It must be connected before\n-  * chars can be read from this stream.\n-  */\n-public\n-PipedReader()\n-{\n-  return;\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This constructor creates a new <code>PipedReader</code> and connects\n-  * it to the passed in <code>PipedWriter</code>. The stream is then read\n-  * for reading.\n-  *\n-  * @param src The <code>PipedWriter</code> to connect this stream to\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public\n-PipedReader(PipedWriter src) throws IOException\n-{\n-  connect(src);\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This method connects this stream to the passed in <code>PipedWriter</code>.\n-  * This stream is then ready for reading.  If this stream is already\n-  * connected or has been previously closed, then an exception is thrown\n-  *\n-  * @param src The <code>PipedWriter</code> to connect this stream to\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-connect(PipedWriter src) throws IOException\n-{\n-  if (src == this.src)\n-    return;\n-\n-  if (ever_connected)\n-    throw new IOException(\"Already connected\");\n-\n-  if (closed)\n-    throw new IOException(\"Stream is closed and cannot be reopened\");\n-\n-  synchronized (lock)\n-    {\n-      src.connect(this);\n-\n-      ever_connected = true;\n-    } // synchronized\n-}\n-\n-/*************************************************************************/\n-\n-/**\n+  /** PipedWriter to which this is connected. Null only if this \n+    * Reader hasn't been connected yet. */\n+  PipedWriter source;\n+\n+  /** Set to true if close() has been called on this Reader. */\n+  boolean closed;\n+\n+  /**\n+    * The size of the internal buffer used for input/output.\n+    */\n+  static final int PIPE_SIZE = 2048;\n+\n+  /**\n+    * This is the internal circular buffer used for storing chars written\n+    * to the pipe and from which chars are read by this stream\n+    */\n+  char[] buffer = new char[PIPE_SIZE];\n+\n+  /**\n+    * The index into buffer where the next char from the connected\n+    * <code>PipedWriter</code> will be written. If this variable is \n+    * equal to <code>out</code>, then the buffer is full. If set to < 0,\n+    * the buffer is empty.\n+    */\n+  int in = -1;\n+\n+  /**\n+    * This index into the buffer where chars will be read from.\n+    */\n+  int out = 0;\n+\n+  /** Buffer used to implement single-argument read/receive */\n+  char[] read_buf = new char[1];\n+\n+  /**\n+    * Creates a new <code>PipedReader</code> that is not connected to a \n+    * <code>PipedWriter</code>.  It must be connected before chars can \n+    * be read from this stream.\n+    */\n+  public PipedReader()\n+  {\n+  }\n+\n+  /**\n+    * This constructor creates a new <code>PipedReader</code> and connects\n+    * it to the passed in <code>PipedWriter</code>. The stream is then \n+    * ready for reading.\n+    *\n+    * @param source The <code>PipedWriter</code> to connect this stream to\n+    *\n+    * @exception IOException If <code>source</code> is already connected.\n+    */\n+  public PipedReader(PipedWriter source) throws IOException\n+  {\n+    connect(source);\n+  }\n+\n+  /**\n+    * This method connects this stream to the passed in <code>PipedWriter</code>.\n+    * This stream is then ready for reading.  If this stream is already\n+    * connected or has been previously closed, then an exception is thrown\n+    *\n+    * @param src The <code>PipedWriter</code> to connect this stream to\n+    *\n+    * @exception IOException If this PipedReader or <code>source</code> \n+    *                        has been connected already.\n+    */\n+  public void connect(PipedWriter source) throws IOException\n+  {\n+    // The JDK (1.3) does not appear to check for a previously closed \n+    // connection here.\n+    \n+    if (this.source != null || source.sink != null)\n+      throw new IOException (\"Already connected\");\n+    \n+    source.sink = this;\n+    this.source = source;\n+  }\n+  \n+  /**\n+    * This method is used by the connected <code>PipedWriter</code> to\n+    * write chars into the buffer.\n+    *\n+    * @param buf The array containing chars to write to this stream\n+    * @param offset The offset into the array to start writing from\n+    * @param len The number of chars to write.\n+    *\n+    * @exception IOException If an error occurs\n+    * @specnote This code should be in PipedWriter.write, but we\n+    *           put it here in order to support that bizarre recieve(int)\n+    *           method.\n+    */  \n+  synchronized void receive(char[] buf, int offset, int len)\n+    throws IOException\n+  {\n+    if (closed)\n+      throw new IOException (\"Pipe closed\");\n+\n+    int bufpos = offset;\n+    int copylen;\n+    \n+    while (len > 0)\n+      {\n+        try\n+\t  {\n+\t    while (in == out)\n+\t      {\n+\t\t// The pipe is full. Wake up any readers and wait for them.\n+\t\tnotifyAll();\n+\t\twait();\n+\t\t// The pipe could have been closed while we were waiting.\n+\t        if (closed)\n+\t\t  throw new IOException (\"Pipe closed\");\n+\t      }\n+\t  }\n+\tcatch (InterruptedException ix)\n+\t  {\n+            throw new InterruptedIOException ();\n+\t  }\n+\n+\tif (in < 0) // The pipe is empty.\n+\t  in = 0;\n+\t\n+\t// Figure out how many chars from buf can be copied without \n+\t// overrunning out or going past the length of the buffer.\n+\tif (in < out)\n+\t  copylen = Math.min (len, out - in);\n+\telse\n+\t  copylen = Math.min (len, buffer.length - in);\n+\n+\t// Copy chars until the pipe is filled, wrapping if neccessary.\n+\tSystem.arraycopy(buf, bufpos, buffer, in, copylen);\n+\tlen -= copylen;\n+\tbufpos += copylen;\n+\tin += copylen;\n+\tif (in == buffer.length)\n+\t  in = 0;\n+      }\n+    // Notify readers that new data is in the pipe.\n+    notifyAll();\n+  }\n+  \n+  /**\n+    * This method reads chars from the stream into a caller supplied buffer.\n+    * It starts storing chars at position <code>offset</code> into the buffer and\n+    * reads a maximum of <cod>>len</code> chars.  Note that this method can actually\n+    * read fewer than <code>len</code> chars.  The actual number of chars read is\n+    * returned.  A -1 is returned to indicated that no chars can be read\n+    * because the end of the stream was reached.  If the stream is already\n+    * closed, a -1 will again be returned to indicate the end of the stream.\n+    * <p>\n+    * This method will block if no chars are available to be read.\n+    *\n+    * @param buf The buffer into which chars will be stored\n+    * @param offset The index into the buffer at which to start writing.\n+    * @param len The maximum number of chars to read.\n+    */\n+  public int read() throws IOException\n+  {\n+    // Method operates by calling the multichar overloaded read method\n+    // Note that read_buf is an internal instance variable.  I allocate it\n+    // there to avoid constant reallocation overhead for applications that\n+    // call this method in a loop at the cost of some unneeded overhead\n+    // if this method is never called.\n+\n+    int r = read(read_buf, 0, 1);\n+\n+    if (r == -1)\n+      return -1;\n+    else\n+      return read_buf[0];\n+  }\n+  \n+  /**\n+    * This method reads characters from the stream into a caller supplied buffer.\n+    * It starts storing chars at position <code>offset</code> into the buffer and\n+    * reads a maximum of <cod>>len</code> chars.  Note that this method can actually\n+    * read fewer than <code>len</code> chars.  The actual number of chars read is\n+    * returned.  A -1 is returned to indicated that no chars can be read\n+    * because the end of the stream was reached - ie close() was called on the\n+    * connected PipedWriter.\n+    * <p>\n+    * This method will block if no chars are available to be read.\n+    *\n+    * @param buf The buffer into which chars will be stored\n+    * @param offset The index into the buffer at which to start writing.\n+    * @param len The maximum number of chars to read.\n+    *\n+    * @exception IOException If <code>close()/code> was called on this Piped\n+    *                        Reader.\n+    */  \n+  public synchronized int read(char[] buf, int offset, int len)\n+    throws IOException\n+  {\n+    if (source == null)\n+      throw new IOException (\"Not connected\");\n+    if (closed)\n+      throw new IOException (\"Pipe closed\");\n+\n+    // If the buffer is empty, wait until there is something in the pipe \n+    // to read.\n+    try\n+      {\n+\twhile (in < 0)\n+\t  {\n+\t    if (source.closed)\n+\t      return -1;\n+\t    wait();\n+\t  }\n+      }\n+    catch (InterruptedException ix)\n+      {\n+        throw new InterruptedIOException();\n+      }\n+    \n+    int total = 0;\n+    int copylen;\n+    \n+    while (true)\n+      {\n+\t// Figure out how many chars from the pipe can be copied without \n+\t// overrunning in or going past the length of buf.\n+\tif (out < in)\n+\t  copylen = Math.min (len, in - out);\n+\telse\n+\t  copylen = Math.min (len, buffer.length - out);\n+\n+        System.arraycopy (buffer, out, buf, offset, copylen);\n+\toffset += copylen;\n+\tlen -= copylen;\n+\tout += copylen;\n+\ttotal += copylen;\n+\t\n+\tif (out == buffer.length)\n+\t  out = 0;\n+\t\n+\tif (out == in)\n+\t  {\n+\t    // Pipe is now empty.\n+\t    in = -1;\n+\t    out = 0;\n+\t  }\n+\n+        // If output buffer is filled or the pipe is empty, we're done.\n+\tif (len == 0 || in == -1)\n+\t  {\n+\t    // Notify any waiting Writer that there is now space\n+\t    // to write.\n+\t    notifyAll();\n+\t    return total;\n+\t  }\n+      }\n+  }\n+  \n+  public synchronized boolean ready() throws IOException\n+  {\n+    // The JDK 1.3 implementation does not appear to check for the closed or \n+    // unconnected stream conditions here.\n+    \n+    if (in < 0)\n+      return false;\n+    \n+    int count;\n+    if (out < in)\n+      count = in - out;\n+    else\n+      count = (buffer.length - out) - in;\n+    \n+    return (count > 0);\n+  }\n+  \n+  /**\n   * This methods closes the stream so that no more data can be read\n   * from it.\n   *\n   * @exception IOException If an error occurs\n   */\n-public void\n-close() throws IOException\n-{\n-  synchronized (lock)\n-    {\n-      closed = true;\n-      notifyAll();\n-    } // synchronized\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method determines whether or not this stream is ready to be read.\n-  * If this metho returns <code>false</code> an attempt to read may (but is\n-  * not guaranteed to) block.\n-  *\n-  * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public boolean\n-ready() throws IOException\n-{\n-  if (in == -1)\n-    return(false);\n-\n-  if (out == (in - 1))\n-    return(false);\n-\n-  if ((out == pipe_size) && (in == 0))\n-    return(false);\n-\n-  return(true);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a single char from the pipe and returns it as an\n-  * <code>int</code>.\n-  * <p>\n-  * This method will block if no chars are available to be read.\n-  *\n-  * @return An char read from the pipe, or -1 if the end of stream is \n-  * reached.\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public int\n-read() throws IOException\n-{\n-  char[] buf = new char[1];\n-\n-  return(read(buf, 0, buf.length));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads chars from the stream into a caller supplied buffer.\n-  * It starts storing chars at position <code>offset</code> into the buffer and\n-  * reads a maximum of <cod>>len</code> chars.  Note that this method can actually\n-  * read fewer than <code>len</code> chars.  The actual number of chars read is\n-  * returned.  A -1 is returned to indicated that no chars can be read\n-  * because the end of the stream was reached.  If the stream is already\n-  * closed, a -1 will again be returned to indicate the end of the stream.\n-  * <p>\n-  * This method will block if no chars are available to be read.\n-  *\n-  * @param buf The buffer into which chars will be stored\n-  * @param offset The index into the buffer at which to start writing.\n-  * @param len The maximum number of chars to read.\n-  */\n-public int\n-read(char[] buf, int offset, int len) throws IOException\n-{\n-  if (!ever_connected)\n-    throw new IOException(\"Not connected\"); \n-\n-  synchronized (lock)\n-    {\n-      int chars_read = 0;\n-      for (;;)\n-\t{\n-\t  // If there are chars, take them\n-\t  if (in != -1)\n-\t    {\n-\t      int desired_chars = len - chars_read;\n-\n-\t      // We are in a \"wrap\" condition\n-\t      if (out > in)\n-\t\t{\n-\t\t  if (desired_chars > (pipe_size - out))\n-\t\t    {\n-\t\t      if (in == 0)\n-\t\t\tdesired_chars = (pipe_size - out) - 1;\n-\t\t      else\n-\t\t\tdesired_chars = pipe_size - out;\n-\n-\t\t      System.arraycopy(buffer, out, buf, offset + chars_read,\n-\t\t\t\t       desired_chars);\n-\n-\t\t      chars_read += desired_chars;\n-\t\t      out += desired_chars;\n-\t\t      desired_chars = len - chars_read;\n-\n-\t\t      if (out == pipe_size)\n-\t\t\tout = 0;\n-\n-\t\t      notifyAll();\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if ((out + desired_chars) == in)\n-\t\t\t--desired_chars;\n-\n-\t\t      if (((out + desired_chars) == pipe_size) && (in == 0)) \n-\t\t\tdesired_chars = (pipe_size - out) - 1;\n-\n-\t\t      System.arraycopy(buffer, out, buf, offset + chars_read,\n-\t\t\t\t       desired_chars); \n-\n-\t\t      chars_read += desired_chars;\n-\t\t      out += desired_chars;\n-\t\t      desired_chars = len - chars_read;\n-\n-\t\t      if (out == pipe_size)\n-\t\t\tout = 0;\n-\n-\t\t      notifyAll();\n-\t\t    }\n-\t\t}\n- \n-\t      // We are in a \"no wrap\" or condition (can also be fall through\n-\t      // from above\n-\t      if (in > out)\n-\t\t{\n-\t\t  if (desired_chars >= ((in - out) - 1))\n-\t\t    desired_chars = (in - out) - 1;\n-\n-\t\t  System.arraycopy(buffer, out, buf, offset + chars_read, \n-\t\t\t\t   desired_chars);\n-\n-\t\t  chars_read += desired_chars;\n-\t\t  out += desired_chars;\n-\t\t  desired_chars = len - chars_read;\n-\n-\t\t  if (out == pipe_size)\n-\t\t    out = 0;\n-\n-\t\t  notifyAll();\n-\t\t}\n-\t    }\n-\n-\t  // If we are done, return\n-\t  if (chars_read == len)\n-\t    return(chars_read);\n-\n-\t  // Return a short count if necessary\n-\t  if (chars_read > 0 && chars_read < len)\n-\t    return(chars_read);\n-\n-\t  // Handle the case where the end of stream was encountered.\n-\t  if (closed)\n-\t    {\n-\t      // We never let in == out so there might be one last char\n-\t      // available that we have not copied yet.\n-\t      if (in != -1)\n-\t\t{\n-\t\t  buf[offset + chars_read] = buffer[out];\n-\t\t  in = -1;\n-\t\t  ++out;\n-\t\t  ++chars_read;\n-\t\t}\n-\n-\t      if (chars_read != 0)\n-\t\treturn(chars_read);\n-\t      else\n-\t\treturn(-1);\n-\t    }\n-\n-\t  // Wait for a char to be read\n-\t  try\n-\t    {\n-\t      wait();\n-\t    }\n-\t  catch(InterruptedException e) { ; }\n-\t} \n-    } // synchronized\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method is used by the connected <code>PipedWriter</code> to\n-  * write chars into the buffer.  It uses this method instead of directly\n-  * writing the chars in order to obtain ownership of the object's monitor\n-  * for the purposes of calling <code>notify</code>.\n-  *\n-  * @param buf The array containing chars to write to this stream\n-  * @param offset The offset into the array to start writing from\n-  * @param len The number of chars to write.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-write(char[] buf, int offset, int len) throws IOException\n-{\n-  if (len <= 0)\n-    return;\n-\n-  synchronized (lock)\n-    {\n-      int total_written = 0;\n-      while (total_written < len)\n-\t{\n-\t  // If we are not at the end of the buffer with out = 0\n-\t  if (!((in == (buffer.length - 1)) && (out == 0)))\n-\t    {\n-\t      // This is the \"no wrap\" situation\n-\t      if ((in - 1) >= out)\n-\t\t{\n-\t\t  int chars_written = 0;\n-\t\t  if ((buffer.length - in) > (len - total_written))\n-\t\t    chars_written = (len - total_written);\n-\t\t  else if (out == 0)\n-\t\t    chars_written = (buffer.length - in) - 1;\n-\t\t  else \n-\t\t    chars_written = (buffer.length - in);\n-\n-\t\t  if (chars_written > 0) \n-\t\t    System.arraycopy(buf, offset + total_written, buffer, in, \n-\t\t\t\t     chars_written);\n-\t\t  total_written += chars_written;\n-\t\t  in += chars_written;\n-\n-\t\t  if (in == buffer.length)\n-\t\t    in = 0;\n-\n-\t\t  notifyAll();\n-\t\t}\n-\t      // This is the \"wrap\" situtation\n-\t      if ((out > in) && (total_written != len))\n-\t\t{\n-\t\t  int chars_written = 0;\n-\n-\t\t  // Do special processing if we are at the beginning\n-\t\t  if (in == -1)\n-\t\t    {\n-\t\t      in = 0;\n-\n-\t\t      if (buffer.length > len)\n-\t\t\tchars_written = len;\n-\t\t      else\n-\t\t\tchars_written = buffer.length - 1;\n-\t\t    }\n-\t\t  else if (((out - in) - 1) < (len - total_written))\n-\t\t    {\n-\t\t      chars_written = (out - in) - 1;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      chars_written = len - total_written;\n-\t\t    }\n-\n-\t\t  // If the buffer is full, wait for it to empty out\n-\t\t  if ((out - 1) == in)\n-\t\t    {\n-\t\t      try\n-\t\t\t{         \n-\t\t\t  wait(); \n-\t\t\t}\n-\t\t      catch (InterruptedException e) \n-\t\t\t{ \n-\t\t\t  continue; \n-\t\t\t}\n-\t\t    }\n-\n-\t\t  System.arraycopy(buf, offset + total_written, buffer, in,\n-\t\t\t\t   chars_written);\n-\t\t  total_written += chars_written;\n-\t\t  in += chars_written;\n-\n-\t\t  if (in == buffer.length)\n-\t\t    in = 0;\n-\n-\t\t  notifyAll();\n-\t\t}\n-\t    }\n-\t  // Wait for some reads to occur before we write anything.\n-\t  else\n-\t    {\n-\t      try\n-\t\t{\n-\t\t  wait();\n-\t\t}\n-\t      catch (InterruptedException e) { ; }\n-\t    }\n-\t}\n-    } // synchronized\n+  public synchronized void close() throws IOException\n+  {\n+    closed = true;\n+    // Wake any thread which may be in receive() waiting to write data.\n+    notifyAll();\n+  }\n }\n-\n-} // class PipedReader\n-"}, {"sha": "a0a51d1d44bc7cc43496eedd627eff293fcac2cd", "filename": "libjava/java/io/PipedWriter.java", "status": "modified", "additions": 128, "deletions": 176, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb/libjava%2Fjava%2Fio%2FPipedWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedWriter.java?ref=865b4ea73fa515c0bd13dd1157d59dd3f91ec1bb", "patch": "@@ -1,5 +1,5 @@\n-/* PipedWriter.java -- Write portion of piped streams.\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+/* PipedWriter.java -- Write portion of piped character streams.\n+   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -27,6 +27,10 @@\n \n package java.io;\n \n+// NOTE: This implementation is very similar to that of PipedOutputStream. \n+// If you fix a bug in here, chances are you should make a similar change to \n+// the PipedOutputStream code.\n+\n /**\n   * This class writes its chars to a <code>PipedReader</code> to \n   * which it is connected.\n@@ -36,182 +40,130 @@\n   * they are in the same thread, read and write operations could deadlock\n   * the thread.\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public class PipedWriter extends Writer\n {\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the <code>PipedReader</code> to which this object\n-  * is connected.\n-  */\n-private PipedReader snk;\n-\n-/**\n-  * This flag indicates whether or not this stream has ever been\n-  * connected to an input stream\n-  */\n-private boolean ever_connected;\n-\n-/**\n-  * This flag indicates whether the <code>close</code> method has ever\n-  * been called for this stream.\n-  */\n-private boolean closed;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a new <code>PipedWriter</code> instance.\n-  * This constructor creates an unconnected object.  It must be connected\n-  * to a <code>PipedReader</code> object using the <code>connect</code>\n-  * method prior to writing any data or an exception will be thrown.\n-  */\n-public\n-PipedWriter()\n-{\n-  ; // Do Nothing\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a new <code>PipedWriter</code> instance\n-  * to write to the specified <code>PipedReader</code>.  This stream\n-  * is then ready for writing.\n-  *\n-  * @param snk The <code>PipedReader</code> to connect this stream to.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public\n-PipedWriter(PipedReader snk) throws IOException\n-{\n-  connect(snk);\n-} \n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * This method connects this object to the specified \n-  * <code>PipedReader</code> object.  This stream will then be ready \n-  * for writing.  If this stream is already connected or has been \n-  * previously closed, then an exception is thrown.\n-  *\n-  * @param snk The <code>PipedReader</code> to connect this stream to\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-connect(PipedReader snk) throws IOException\n-{\n-  if (snk == this.snk)\n-    return;\n-\n-  if (ever_connected)\n-    throw new IOException(\"Already connected\");\n-\n-  if (closed)\n-    throw new IOException(\"Stream is closed and cannot be reopened\");\n-\n-  synchronized (lock) {\n-\n-  this.snk = snk;\n-  ever_connected = true;\n-  snk.src = this;\n-\n-  snk.connect(this);\n-\n-  } // synchronized\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method closes this stream so that no more data can be written\n-  * to it. Any further attempts to write to this stream may throw an\n-  * exception\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-close() throws IOException\n-{\n-  synchronized (lock) {\n-\n-  closed = true;\n-  snk.close();\n-  notifyAll();\n-\n-  } // synchronized\n+  /** Target PipedReader to which this is connected. Null only if this \n+    * Writer hasn't been connected yet. */\n+  PipedReader sink;\n+  \n+  /** Set to true if close() has been called on this Writer. */\n+  boolean closed;\n+\n+  /** Buffer used to implement single-argument write */\n+  char[] read_buf = new char[1];\n+  \n+  /** \n+    * Create an unconnected PipedWriter.  It must be connected\n+    * to a <code>PipedReader</code> using the <code>connect</code>\n+    * method prior to writing any data or an exception will be thrown.\n+    */\n+  public PipedWriter()\n+  {\n+  }\n+\n+  /**\n+     * Create a new <code>PipedWriter</code> instance\n+    * to write to the specified <code>PipedReader</code>.  This stream\n+    * is then ready for writing.\n+    *\n+    * @param sink The <code>PipedReader</code> to connect this stream to.\n+    *\n+    * @exception IOException If <code>sink</code> has already been connected \n+    *                        to a different PipedWriter.\n+    */\n+  public PipedWriter(PipedReader sink) throws IOException\n+  {\n+    sink.connect(this);\n+  }\n+\n+  /**\n+    * Connects this object to the specified <code>PipedReader</code> \n+    * object.  This stream will then be ready for writing.\n+    *\n+    * @param sink The <code>PipedReader</code> to connect this stream to\n+    *\n+    * @exception IOException If the stream has not been connected or has\n+    *                        been closed.\n+    */\n+  public void connect(PipedReader sink) throws IOException\n+  {\n+    if (sink != null)\n+      throw new IOException (\"Already connected\");\n+    sink.connect(this);\n+  }\n+\n+  /**\n+    * Write a single char of date to the stream.  Note that this method will \n+    * block if the <code>PipedReader</code> to which this object is \n+    * connected has a full buffer.\n+    *\n+    * @param b The char of data to be written, passed as an <code>int</code>.\n+    *\n+    * @exception IOException If the stream has not been connected or has\n+    *                        been closed.\n+    */  \n+  public void write(char b) throws IOException\n+  {\n+    read_buf[0] = b;\n+    sink.receive (read_buf, 0, 1);\n+  }\n+  \n+  /**\n+    * This method writes <code>len</code> chars of data from the char array\n+    * <code>buf</code> starting at index <code>offset</code> in the array\n+    * to the stream.  Note that this method will block if the  \n+    * <code>PipedReader</code> to which this object is connected has\n+    * a buffer that cannot hold all of the chars to be written.\n+    *\n+    * @param buf The array containing chars to write to the stream.\n+    * @param offset The index into the array to start writing chars from.\n+    * @param len The number of chars to write.\n+    *\n+    * @exception IOException If the stream has not been connected or has\n+    *                        been closed.\n+    */\n+  public void write(char[] b, int off, int len) throws IOException\n+  {\n+    if (sink == null)\n+      throw new IOException (\"Not connected\");\n+    if (closed)\n+      throw new IOException (\"Pipe closed\");\n+      \n+    sink.receive (b, off, len);\n+  }\n+\n+  /**\n+    * This method does nothing.\n+    *\n+    * @exception IOException If the stream is closed.\n+    * @specnote You'd think that this method would block until the sink\n+    *           had read all available data. Thats not the case - this method\n+    *           appears to be a no-op?\n+    */\n+  public void flush()\n+  {\n+  }\n+  \n+  /**\n+    * This method closes this stream so that no more data can be written\n+    * to it. Any further attempts to write to this stream may throw an\n+    * exception\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void close()\n+  {\n+    // A close call on an unconnected PipedWriter has no effect.\n+    if (sink != null)\n+      {\n+\tclosed = true;\n+\t// Notify any waiting readers that the stream is now closed.\n+\tsynchronized (sink)\n+\t{\t  \n+\t  sink.notifyAll();\n+\t}\n+      }\n+  }\n }\n-\n-/*************************************************************************/\n-\n-/**\n-  * This methods writes a single byte of data to the pipe.  This call may\n-  * block if the pipe is full.\n-  *\n-  * @param c The <code>char</code> to write, passed as an <code>int</code>.\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public void\n-write(int c) throws IOException\n-{\n-  char[] buf = new char[1];\n-  buf[0] = (char)c;\n-\n-  write(buf, 0, buf.length);\n-} \n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes <code>len</code> chars of data from the char array\n-  * <code>buf</code> starting at index <code>offset</code> in the array\n-  * to the stream.  Note that this method will block if the  \n-  * <code>PipedReader</code> to which this object is connected has\n-  * a buffer that cannot hold all of the chars to be written.\n-  *\n-  * @param buf The array containing chars to write to thes stream.\n-  * @param offset The index into the array to start writing chars from.\n-  * @param len The number of chars to write.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(char[] buf, int offset, int len) throws IOException\n-{\n-  snk.write(buf, 0, len);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method flushes any unwritten chars to the underlying output\n-  * sink.  This method does nothing in this class because this class does\n-  * not buffer any chars.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-flush() throws IOException\n-{\n-  ; // Do Nothing\n-}\n-\n-} // class PipedWriter\n-"}]}