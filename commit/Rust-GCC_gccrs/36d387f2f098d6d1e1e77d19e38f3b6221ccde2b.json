{"sha": "36d387f2f098d6d1e1e77d19e38f3b6221ccde2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZkMzg3ZjJmMDk4ZDZkMWUxZTc3ZDE5ZTM4ZjNiNjIyMWNjZGUyYg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-10-07T18:41:17Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-10-07T18:41:17Z"}, "message": "i386-expand.c (ix86_expand_floorceildf_32, [...]): Reorder functions.\n\n\t* config/i386/i386-expand.c (ix86_expand_floorceildf_32,\n\tix86_expand_rounddf_32): Reorder functions.\n\t* config/i386/i386-protos.h: Update..\n\nFrom-SVN: r276668", "tree": {"sha": "253c0349180fd1f84186ec6022a4b74bb7da5956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/253c0349180fd1f84186ec6022a4b74bb7da5956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b/comments", "author": null, "committer": null, "parents": [{"sha": "8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8682b1a508e5ba9bd2e1b2b4d298bf7d07a37f80"}], "stats": {"total": 240, "additions": 124, "deletions": 116}, "files": [{"sha": "bbdce86a0f87f6a58db239957ecc9eaacd3754eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36d387f2f098d6d1e1e77d19e38f3b6221ccde2b", "patch": "@@ -1,3 +1,9 @@\n+2019-10-07  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-expand.c (ix86_expand_floorceildf_32,\n+\tix86_expand_rounddf_32): Reorder functions.\n+\t* config/i386/i386-protos.h: Update..\n+\n 2019-10-07  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* config.in: Regenerate.\n@@ -20,14 +26,14 @@\n \t\".lower\" prefix if -m{code,data}-region=lower have been passed.\n \t(msp430_output_aligned_decl_common): Emit common symbols when\n \t-mdata-region=lower is passed unless TARGET_USE_LOWER_REGION_PREFIX is\n-\tset. \n+\tset.\n \t(TARGET_ASM_FILE_END): Define.\n \t(msp430_file_end): New function.\n \t(msp430_do_not_relax_short_jumps): Allow relaxation when\n \tfunction will be in the lower region.\n \t(msp430_op_not_in_high_mem): New function.\n \t(msp430_print_operand): Check \"msp430_op_not_in_high_mem\" for\n-\tthe 'X' operand selector. \n+\tthe 'X' operand selector.\n \tClarify comment for 'x' operand selector.\n \t* config/msp430/msp430.h (LINK_SPEC): Propagate\n \t-m{code,data}-region to the linker via spec function\n@@ -74,9 +80,9 @@\n \t(mdata-region=): Likewise.\n \t(muse-lower-region-prefix): New option.\n \t* config/msp430/t-msp430 (MULTILIB_OPTIONS): Add\n-\tmdata-region=none multilib. \n+\tmdata-region=none multilib.\n \t(MULTILIB_MATCHES): Set mdata-region={upper,either} to match\n-\tmdata-region=none multilib. \n+\tmdata-region=none multilib.\n \tMULTILIB_EXCEPTIONS: Remove.\n \tMULTILIB_REQUIRED: Define.\n \t* configure: Regenerate."}, {"sha": "6d3d14c37dd6e22f718365ee01cb927c04bfec6c", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 111, "deletions": 109, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=36d387f2f098d6d1e1e77d19e38f3b6221ccde2b", "patch": "@@ -15903,71 +15903,8 @@ ix86_expand_rint (rtx operand0, rtx operand1)\n   emit_move_insn (operand0, res);\n }\n \n-/* Expand SSE2 sequence for computing floor or ceil from OPERAND1 storing\n-   into OPERAND0.  */\n-void\n-ix86_expand_floorceildf_32 (rtx operand0, rtx operand1, bool do_floor)\n-{\n-  /* C code for the stuff we expand below.\n-        double xa = fabs (x), x2;\n-        if (!isless (xa, TWO52))\n-          return x;\n-        xa = xa + TWO52 - TWO52;\n-        x2 = copysign (xa, x);\n-     Compensate.  Floor:\n-        if (x2 > x)\n-          x2 -= 1;\n-     Compensate.  Ceil:\n-        if (x2 < x)\n-          x2 += 1;\n-\tif (HONOR_SIGNED_ZEROS (mode))\n-\t  x2 = copysign (x2, x);\n-\treturn x2;\n-   */\n-  machine_mode mode = GET_MODE (operand0);\n-  rtx xa, TWO52, tmp, one, res, mask;\n-  rtx_code_label *label;\n-\n-  TWO52 = ix86_gen_TWO52 (mode);\n-\n-  /* Temporary for holding the result, initialized to the input\n-     operand to ease control flow.  */\n-  res = gen_reg_rtx (mode);\n-  emit_move_insn (res, operand1);\n-\n-  /* xa = abs (operand1) */\n-  xa = ix86_expand_sse_fabs (res, &mask);\n-\n-  /* if (!isless (xa, TWO52)) goto label; */\n-  label = ix86_expand_sse_compare_and_jump (UNLE, TWO52, xa, false);\n-\n-  /* xa = xa + TWO52 - TWO52; */\n-  xa = expand_simple_binop (mode, PLUS, xa, TWO52, NULL_RTX, 0, OPTAB_DIRECT);\n-  xa = expand_simple_binop (mode, MINUS, xa, TWO52, xa, 0, OPTAB_DIRECT);\n-\n-  /* xa = copysign (xa, operand1) */\n-  ix86_sse_copysign_to_positive (xa, xa, res, mask);\n-\n-  /* generate 1.0 */\n-  one = force_reg (mode, const_double_from_real_value (dconst1, mode));\n-\n-  /* Compensate: xa = xa - (xa > operand1 ? 1 : 0) */\n-  tmp = ix86_expand_sse_compare_mask (UNGT, xa, res, !do_floor);\n-  emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));\n-  tmp = expand_simple_binop (mode, do_floor ? MINUS : PLUS,\n-\t\t\t     xa, tmp, NULL_RTX, 0, OPTAB_DIRECT);\n-  if (!do_floor && HONOR_SIGNED_ZEROS (mode))\n-    ix86_sse_copysign_to_positive (tmp, tmp, res, mask);\n-  emit_move_insn (res, tmp);\n-\n-  emit_label (label);\n-  LABEL_NUSES (label) = 1;\n-\n-  emit_move_insn (operand0, res);\n-}\n-\n-/* Expand SSE2 sequence for computing floor or ceil from OPERAND1 storing\n-   into OPERAND0.  */\n+/* Expand SSE2 sequence for computing floor or ceil\n+   from OPERAND1 storing into OPERAND0.  */\n void\n ix86_expand_floorceil (rtx operand0, rtx operand1, bool do_floor)\n {\n@@ -16027,30 +15964,30 @@ ix86_expand_floorceil (rtx operand0, rtx operand1, bool do_floor)\n   emit_move_insn (operand0, res);\n }\n \n-/* Expand SSE sequence for computing round from OPERAND1 storing\n-   into OPERAND0.  Sequence that works without relying on DImode truncation\n-   via cvttsd2siq that is only available on 64bit targets.  */\n+/* Expand SSE2 sequence for computing floor or ceil from OPERAND1 storing\n+   into OPERAND0 without relying on DImode truncation via cvttsd2siq\n+   that is only available on 64bit targets.  */\n void\n-ix86_expand_rounddf_32 (rtx operand0, rtx operand1)\n+ix86_expand_floorceildf_32 (rtx operand0, rtx operand1, bool do_floor)\n {\n   /* C code for the stuff we expand below.\n-        double xa = fabs (x), xa2, x2;\n+        double xa = fabs (x), x2;\n         if (!isless (xa, TWO52))\n           return x;\n-     Using the absolute value and copying back sign makes\n-     -0.0 -> -0.0 correct.\n-        xa2 = xa + TWO52 - TWO52;\n-     Compensate.\n-\tdxa = xa2 - xa;\n-        if (dxa <= -0.5)\n-          xa2 += 1;\n-        else if (dxa > 0.5)\n-          xa2 -= 1;\n-        x2 = copysign (xa2, x);\n-        return x2;\n+        xa = xa + TWO52 - TWO52;\n+        x2 = copysign (xa, x);\n+     Compensate.  Floor:\n+        if (x2 > x)\n+          x2 -= 1;\n+     Compensate.  Ceil:\n+        if (x2 < x)\n+          x2 += 1;\n+\tif (HONOR_SIGNED_ZEROS (mode))\n+\t  x2 = copysign (x2, x);\n+\treturn x2;\n    */\n   machine_mode mode = GET_MODE (operand0);\n-  rtx xa, xa2, dxa, TWO52, tmp, half, mhalf, one, res, mask;\n+  rtx xa, TWO52, tmp, one, res, mask;\n   rtx_code_label *label;\n \n   TWO52 = ix86_gen_TWO52 (mode);\n@@ -16066,40 +16003,33 @@ ix86_expand_rounddf_32 (rtx operand0, rtx operand1)\n   /* if (!isless (xa, TWO52)) goto label; */\n   label = ix86_expand_sse_compare_and_jump (UNLE, TWO52, xa, false);\n \n-  /* xa2 = xa + TWO52 - TWO52; */\n-  xa2 = expand_simple_binop (mode, PLUS, xa, TWO52, NULL_RTX, 0, OPTAB_DIRECT);\n-  xa2 = expand_simple_binop (mode, MINUS, xa2, TWO52, xa2, 0, OPTAB_DIRECT);\n-\n-  /* dxa = xa2 - xa; */\n-  dxa = expand_simple_binop (mode, MINUS, xa2, xa, NULL_RTX, 0, OPTAB_DIRECT);\n+  /* xa = xa + TWO52 - TWO52; */\n+  xa = expand_simple_binop (mode, PLUS, xa, TWO52, NULL_RTX, 0, OPTAB_DIRECT);\n+  xa = expand_simple_binop (mode, MINUS, xa, TWO52, xa, 0, OPTAB_DIRECT);\n \n-  /* generate 0.5, 1.0 and -0.5 */\n-  half = force_reg (mode, const_double_from_real_value (dconsthalf, mode));\n-  one = expand_simple_binop (mode, PLUS, half, half, NULL_RTX, 0, OPTAB_DIRECT);\n-  mhalf = expand_simple_binop (mode, MINUS, half, one, NULL_RTX,\n-\t\t\t       0, OPTAB_DIRECT);\n+  /* xa = copysign (xa, operand1) */\n+  ix86_sse_copysign_to_positive (xa, xa, res, mask);\n \n-  /* Compensate.  */\n-  /* xa2 = xa2 - (dxa > 0.5 ? 1 : 0) */\n-  tmp = ix86_expand_sse_compare_mask (UNGT, dxa, half, false);\n-  emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, tmp, one)));\n-  xa2 = expand_simple_binop (mode, MINUS, xa2, tmp, NULL_RTX, 0, OPTAB_DIRECT);\n-  /* xa2 = xa2 + (dxa <= -0.5 ? 1 : 0) */\n-  tmp = ix86_expand_sse_compare_mask (UNGE, mhalf, dxa, false);\n-  emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, tmp, one)));\n-  xa2 = expand_simple_binop (mode, PLUS, xa2, tmp, NULL_RTX, 0, OPTAB_DIRECT);\n+  /* generate 1.0 */\n+  one = force_reg (mode, const_double_from_real_value (dconst1, mode));\n \n-  /* res = copysign (xa2, operand1) */\n-  ix86_sse_copysign_to_positive (res, xa2, force_reg (mode, operand1), mask);\n+  /* Compensate: xa = xa - (xa > operand1 ? 1 : 0) */\n+  tmp = ix86_expand_sse_compare_mask (UNGT, xa, res, !do_floor);\n+  emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));\n+  tmp = expand_simple_binop (mode, do_floor ? MINUS : PLUS,\n+\t\t\t     xa, tmp, NULL_RTX, 0, OPTAB_DIRECT);\n+  if (!do_floor && HONOR_SIGNED_ZEROS (mode))\n+    ix86_sse_copysign_to_positive (tmp, tmp, res, mask);\n+  emit_move_insn (res, tmp);\n \n   emit_label (label);\n   LABEL_NUSES (label) = 1;\n \n   emit_move_insn (operand0, res);\n }\n \n-/* Expand SSE sequence for computing trunc from OPERAND1 storing\n-   into OPERAND0.  */\n+/* Expand SSE sequence for computing trunc\n+   from OPERAND1 storing into OPERAND0.  */\n void\n ix86_expand_trunc (rtx operand0, rtx operand1)\n {\n@@ -16144,7 +16074,8 @@ ix86_expand_trunc (rtx operand0, rtx operand1)\n }\n \n /* Expand SSE sequence for computing trunc from OPERAND1 storing\n-   into OPERAND0.  */\n+   into OPERAND0 without relying on DImode truncation via cvttsd2siq\n+   that is only available on 64bit targets.  */\n void\n ix86_expand_truncdf_32 (rtx operand0, rtx operand1)\n {\n@@ -16201,8 +16132,8 @@ ix86_expand_truncdf_32 (rtx operand0, rtx operand1)\n   emit_move_insn (operand0, res);\n }\n \n-/* Expand SSE sequence for computing round from OPERAND1 storing\n-   into OPERAND0.  */\n+/* Expand SSE sequence for computing round\n+   from OPERAND1 storing into OPERAND0.  */\n void\n ix86_expand_round (rtx operand0, rtx operand1)\n {\n@@ -16251,6 +16182,77 @@ ix86_expand_round (rtx operand0, rtx operand1)\n   emit_move_insn (operand0, res);\n }\n \n+/* Expand SSE sequence for computing round from OPERAND1 storing\n+   into OPERAND0 without relying on DImode truncation via cvttsd2siq\n+   that is only available on 64bit targets.  */\n+void\n+ix86_expand_rounddf_32 (rtx operand0, rtx operand1)\n+{\n+  /* C code for the stuff we expand below.\n+        double xa = fabs (x), xa2, x2;\n+        if (!isless (xa, TWO52))\n+          return x;\n+     Using the absolute value and copying back sign makes\n+     -0.0 -> -0.0 correct.\n+        xa2 = xa + TWO52 - TWO52;\n+     Compensate.\n+\tdxa = xa2 - xa;\n+        if (dxa <= -0.5)\n+          xa2 += 1;\n+        else if (dxa > 0.5)\n+          xa2 -= 1;\n+        x2 = copysign (xa2, x);\n+        return x2;\n+   */\n+  machine_mode mode = GET_MODE (operand0);\n+  rtx xa, xa2, dxa, TWO52, tmp, half, mhalf, one, res, mask;\n+  rtx_code_label *label;\n+\n+  TWO52 = ix86_gen_TWO52 (mode);\n+\n+  /* Temporary for holding the result, initialized to the input\n+     operand to ease control flow.  */\n+  res = gen_reg_rtx (mode);\n+  emit_move_insn (res, operand1);\n+\n+  /* xa = abs (operand1) */\n+  xa = ix86_expand_sse_fabs (res, &mask);\n+\n+  /* if (!isless (xa, TWO52)) goto label; */\n+  label = ix86_expand_sse_compare_and_jump (UNLE, TWO52, xa, false);\n+\n+  /* xa2 = xa + TWO52 - TWO52; */\n+  xa2 = expand_simple_binop (mode, PLUS, xa, TWO52, NULL_RTX, 0, OPTAB_DIRECT);\n+  xa2 = expand_simple_binop (mode, MINUS, xa2, TWO52, xa2, 0, OPTAB_DIRECT);\n+\n+  /* dxa = xa2 - xa; */\n+  dxa = expand_simple_binop (mode, MINUS, xa2, xa, NULL_RTX, 0, OPTAB_DIRECT);\n+\n+  /* generate 0.5, 1.0 and -0.5 */\n+  half = force_reg (mode, const_double_from_real_value (dconsthalf, mode));\n+  one = expand_simple_binop (mode, PLUS, half, half, NULL_RTX, 0, OPTAB_DIRECT);\n+  mhalf = expand_simple_binop (mode, MINUS, half, one, NULL_RTX,\n+\t\t\t       0, OPTAB_DIRECT);\n+\n+  /* Compensate.  */\n+  /* xa2 = xa2 - (dxa > 0.5 ? 1 : 0) */\n+  tmp = ix86_expand_sse_compare_mask (UNGT, dxa, half, false);\n+  emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, tmp, one)));\n+  xa2 = expand_simple_binop (mode, MINUS, xa2, tmp, NULL_RTX, 0, OPTAB_DIRECT);\n+  /* xa2 = xa2 + (dxa <= -0.5 ? 1 : 0) */\n+  tmp = ix86_expand_sse_compare_mask (UNGE, mhalf, dxa, false);\n+  emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, tmp, one)));\n+  xa2 = expand_simple_binop (mode, PLUS, xa2, tmp, NULL_RTX, 0, OPTAB_DIRECT);\n+\n+  /* res = copysign (xa2, operand1) */\n+  ix86_sse_copysign_to_positive (res, xa2, force_reg (mode, operand1), mask);\n+\n+  emit_label (label);\n+  LABEL_NUSES (label) = 1;\n+\n+  emit_move_insn (operand0, res);\n+}\n+\n /* Expand SSE sequence for computing round\n    from OP1 storing into OP0 using sse4 round insn.  */\n void"}, {"sha": "c07dfe508557ebb21a9ffc88257404df9d3e5c17", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d387f2f098d6d1e1e77d19e38f3b6221ccde2b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=36d387f2f098d6d1e1e77d19e38f3b6221ccde2b", "patch": "@@ -193,11 +193,11 @@ extern void ix86_expand_lfloorceil (rtx, rtx, bool);\n extern void ix86_expand_rint (rtx, rtx);\n extern void ix86_expand_floorceil (rtx, rtx, bool);\n extern void ix86_expand_floorceildf_32 (rtx, rtx, bool);\n-extern void ix86_expand_round_sse4 (rtx, rtx);\n-extern void ix86_expand_round (rtx, rtx);\n-extern void ix86_expand_rounddf_32 (rtx, rtx);\n extern void ix86_expand_trunc (rtx, rtx);\n extern void ix86_expand_truncdf_32 (rtx, rtx);\n+extern void ix86_expand_round (rtx, rtx);\n+extern void ix86_expand_rounddf_32 (rtx, rtx);\n+extern void ix86_expand_round_sse4 (rtx, rtx);\n \n extern void ix86_expand_vecop_qihi (enum rtx_code, rtx, rtx, rtx);\n "}]}