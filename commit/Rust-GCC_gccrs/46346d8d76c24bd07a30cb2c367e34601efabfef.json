{"sha": "46346d8d76c24bd07a30cb2c367e34601efabfef", "node_id": "C_kwDOANBUbNoAKDQ2MzQ2ZDhkNzZjMjRiZDA3YTMwY2IyYzM2N2UzNDYwMWVmYWJmZWY", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2019-11-27T12:46:17Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T17:34:10Z"}, "message": "ifcvt: Improve costs handling for noce_convert_multiple.\n\nWhen noce_convert_multiple is called the original costs are not yet\ninitialized.  Therefore, up to now, costs were only ever unfairly\ncompared against COSTS_N_INSNS (2).  This would lead to\ndefault_noce_conversion_profitable_p () rejecting all but the most\ncontrived of sequences.\n\nThis patch temporarily initializes the original costs by counting\nadding costs for all sets inside the then_bb.\n\ngcc/ChangeLog:\n\n\t* ifcvt.cc (bb_ok_for_noce_convert_multiple_sets): Estimate insns costs.\n\t(noce_process_if_block): Use potential costs.", "tree": {"sha": "46c1ed9744d972dde2ea4dfcbf04ed8f7c71b556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46c1ed9744d972dde2ea4dfcbf04ed8f7c71b556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46346d8d76c24bd07a30cb2c367e34601efabfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46346d8d76c24bd07a30cb2c367e34601efabfef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46346d8d76c24bd07a30cb2c367e34601efabfef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46346d8d76c24bd07a30cb2c367e34601efabfef/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b8eaa282250ad260e01d164093b597579db00d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8eaa282250ad260e01d164093b597579db00d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b8eaa282250ad260e01d164093b597579db00d9"}], "stats": {"total": 31, "additions": 27, "deletions": 4}, "files": [{"sha": "27e42944b8cd9826ec2336448da40270dac9fdc2", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46346d8d76c24bd07a30cb2c367e34601efabfef/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46346d8d76c24bd07a30cb2c367e34601efabfef/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=46346d8d76c24bd07a30cb2c367e34601efabfef", "patch": "@@ -3414,14 +3414,17 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n    (SET (REG) (REG)) insns suitable for conversion to a series\n    of conditional moves.  Also check that we have more than one set\n    (other routines can handle a single set better than we would), and\n-   fewer than PARAM_MAX_RTL_IF_CONVERSION_INSNS sets.  */\n+   fewer than PARAM_MAX_RTL_IF_CONVERSION_INSNS sets.  While going\n+   through the insns store the sum of their potential costs in COST.  */\n \n static bool\n-bb_ok_for_noce_convert_multiple_sets (basic_block test_bb)\n+bb_ok_for_noce_convert_multiple_sets (basic_block test_bb, unsigned *cost)\n {\n   rtx_insn *insn;\n   unsigned count = 0;\n   unsigned param = param_max_rtl_if_conversion_insns;\n+  bool speed_p = optimize_bb_for_speed_p (test_bb);\n+  unsigned potential_cost = 0;\n \n   FOR_BB_INSNS (test_bb, insn)\n     {\n@@ -3457,9 +3460,13 @@ bb_ok_for_noce_convert_multiple_sets (basic_block test_bb)\n       if (!can_conditionally_move_p (GET_MODE (dest)))\n \treturn false;\n \n+      potential_cost += insn_cost (insn, speed_p);\n+\n       count++;\n     }\n \n+  *cost += potential_cost;\n+\n   /* If we would only put out one conditional move, the other strategies\n      this pass tries are better optimized and will be more appropriate.\n      Some targets want to strictly limit the number of conditional moves\n@@ -3507,18 +3514,34 @@ noce_process_if_block (struct noce_if_info *if_info)\n      to calculate a value for x.\n      ??? For future expansion, further expand the \"multiple X\" rules.  */\n \n-  /* First look for multiple SETS.  */\n+  /* First look for multiple SETS.  The original costs already include\n+     a base cost of COSTS_N_INSNS (2): one instruction for the compare\n+     (which we will be needing either way) and one instruction for the\n+     branch.  When comparing costs we want to use the branch instruction\n+     cost and the sets vs. the cmovs generated here.  Therefore subtract\n+     the costs of the compare before checking.\n+     ??? Actually, instead of the branch instruction costs we might want\n+     to use COSTS_N_INSNS (BRANCH_COST ()) as in other places.  */\n+\n+  unsigned potential_cost = if_info->original_cost - COSTS_N_INSNS (1);\n+  unsigned old_cost = if_info->original_cost;\n   if (!else_bb\n       && HAVE_conditional_move\n-      && bb_ok_for_noce_convert_multiple_sets (then_bb))\n+      && bb_ok_for_noce_convert_multiple_sets (then_bb, &potential_cost))\n     {\n+      /* Temporarily set the original costs to what we estimated so\n+\t we can determine if the transformation is worth it.  */\n+      if_info->original_cost = potential_cost;\n       if (noce_convert_multiple_sets (if_info))\n \t{\n \t  if (dump_file && if_info->transform_name)\n \t    fprintf (dump_file, \"if-conversion succeeded through %s\\n\",\n \t\t     if_info->transform_name);\n \t  return TRUE;\n \t}\n+\n+      /* Restore the original costs.  */\n+      if_info->original_cost = old_cost;\n     }\n \n   bool speed_p = optimize_bb_for_speed_p (test_bb);"}]}