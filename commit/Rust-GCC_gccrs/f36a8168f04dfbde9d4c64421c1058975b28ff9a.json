{"sha": "f36a8168f04dfbde9d4c64421c1058975b28ff9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM2YTgxNjhmMDRkZmJkZTlkNGM2NDQyMWMxMDU4OTc1YjI4ZmY5YQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-11T15:40:45Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-11T15:42:29Z"}, "message": "Move/correct offset adjustment (PR middle-end/96903).\n\nResolves:\nPR middle-end/96903 - bogus warning on memcpy at negative offset from array end\n\ngcc/ChangeLog:\n\n\tPR middle-end/96903\n\t* builtins.c (compute_objsize): Remove incorrect offset adjustment.\n\t(compute_objsize): Adjust offset range here instead.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/96903\n\t* gcc.dg/Wstringop-overflow-42.c:: Add comment.\n\t* gcc.dg/Wstringop-overflow-43.c: New test.", "tree": {"sha": "0a91d08d1d73d3cdd55bce00bfe8474576186b89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a91d08d1d73d3cdd55bce00bfe8474576186b89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f36a8168f04dfbde9d4c64421c1058975b28ff9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36a8168f04dfbde9d4c64421c1058975b28ff9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f36a8168f04dfbde9d4c64421c1058975b28ff9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36a8168f04dfbde9d4c64421c1058975b28ff9a/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1be7bf7dab86d2fb33561b7eac1d2f527aa98b2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be7bf7dab86d2fb33561b7eac1d2f527aa98b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be7bf7dab86d2fb33561b7eac1d2f527aa98b2c"}], "stats": {"total": 202, "additions": 194, "deletions": 8}, "files": [{"sha": "8b9a4a4d948b37a2aa438bc2a59d66b398850413", "filename": "gcc/builtins.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f36a8168f04dfbde9d4c64421c1058975b28ff9a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f36a8168f04dfbde9d4c64421c1058975b28ff9a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f36a8168f04dfbde9d4c64421c1058975b28ff9a", "patch": "@@ -4372,12 +4372,6 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \t      orng[0] = wi::to_offset (TYPE_MIN_VALUE (ptrdiff_type_node));\n \t      orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n \t    }\n-\t  else if (wi::lts_p (orng[1], orng[0]))\n-\t    /* The upper bound is less than the lower bound when the integer\n-\t       operand is the result of signed integer conversion to sizetype,\n-\t       as in P + OFF + CST where OFF > 0.\n-\t       Correct just the upper bound.  */\n-\t    orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n \n \t  pref->offrng[0] += orng[0];\n \t  pref->offrng[1] += orng[1];\n@@ -4403,7 +4397,8 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   return false;\n }\n \n-/* Convenience wrapper around the above.  */\n+/* A \"public\" wrapper around the above.  Clients should use this overload\n+   instead.  */\n \n static tree\n compute_objsize (tree ptr, int ostype, access_ref *pref,\n@@ -4420,6 +4415,15 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   if (!success)\n     return NULL_TREE;\n \n+  if (pref->offrng[1] < pref->offrng[0])\n+    {\n+      if (pref->offrng[1] < 0\n+\t  && pref->sizrng[1] <= pref->offrng[0])\n+\treturn size_zero_node;\n+\n+      return wide_int_to_tree (sizetype, pref->sizrng[1]);\n+    }\n+\n   if (pref->offrng[0] < 0)\n     {\n       if (pref->offrng[1] < 0)\n@@ -4428,7 +4432,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n       pref->offrng[0] = 0;\n     }\n \n-  if (pref->sizrng[1] < pref->offrng[0])\n+  if (pref->sizrng[1] <= pref->offrng[0])\n     return size_zero_node;\n \n   return wide_int_to_tree (sizetype, pref->sizrng[1] - pref->offrng[0]);"}, {"sha": "4bb22f2ecd3c922f3ed5f9d40fd9699db3fd2013", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-42.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f36a8168f04dfbde9d4c64421c1058975b28ff9a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f36a8168f04dfbde9d4c64421c1058975b28ff9a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-42.c?ref=f36a8168f04dfbde9d4c64421c1058975b28ff9a", "patch": "@@ -36,7 +36,11 @@ void cpy_sl_1_max (long i, const char *s)\n void cpy_ul_1_max (unsigned long i, const char *s)\n {\n   if (i < 1) i = 1;\n+\n   d = strcpy (a + i, s);      // { dg-warning \"writing 1 or more bytes into a region of size 0\" }\n+\n+  /* Because of integer wraparound the offset's range is [1, 0] so\n+     the overflow isn't diagnosed (yet).  */\n   d = strcpy (a + i + 1, s);  // { dg-warning \"writing 1 or more bytes into a region of size 0\" \"\" { xfail *-*-* } }\n }\n "}, {"sha": "3ac5a88e4b0828723e034ae8d348553a2101df46", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-43.c", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f36a8168f04dfbde9d4c64421c1058975b28ff9a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f36a8168f04dfbde9d4c64421c1058975b28ff9a/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c?ref=f36a8168f04dfbde9d4c64421c1058975b28ff9a", "patch": "@@ -0,0 +1,178 @@\n+/* PR 96903 - bogus warning on memcpy at negative offset from array end\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX    __INT_MAX__\n+#define INT_MIN    -(INT_MAX - 1)\n+#define UINT_MAX   (2U * INT_MAX + 1)\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* memset (void *, int, size_t);\n+\n+void sink (void*, ...);\n+\n+extern char a11[11];\n+struct S { char a11[11], b; };\n+extern struct S sa11;\n+\n+#define T2(dst, off1, off2, n) do {\t\t\\\n+    char *_p0 = dst;\t\t\t\t\\\n+    char *_p1 = _p0 + (off1);\t\t\t\\\n+    char *_p2 = _p1 + (off2);\t\t\t\\\n+    memset (_p2, 0, n);\t\t\t\t\\\n+    sink (dst, _p0, _p1, _p2);\t\t\t\\\n+  } while (0);\n+\n+#define T1(dst, off, n) T2 (dst, off, 0, n)\n+\n+\n+void nowarn_memset_array_cst (void)\n+{\n+  char *p = &a11[11];\n+\n+  T1 (p, -11, 11);\n+  T1 (p, -10, 10);\n+  T1 (p,  -9,  9);\n+  T1 (p,  -8,  8);\n+  T1 (p,  -3,  3);\n+  T1 (p,  -2,  2);\n+  T1 (p,  -1,  1);\n+  T1 (p,   0,  0);\n+\n+  T2 (p, -6, -5, 11);\n+  T2 (p, -6, -4, 10);\n+  T2 (p, -6, -3,  9);\n+  T2 (p, -6, -2,  8);\n+  T2 (p, -6, -1,  7);\n+  T2 (p, -5, -6, 11);\n+  T2 (p, -5, -5, 10);\n+}\n+\n+void nowarn_memset_array_rng_int (void)\n+{\n+  char *p = &a11[11];\n+\n+  int i11 = SR (11, INT_MAX);\n+  int i10 = SR (10, INT_MAX);\n+  int i9  = SR ( 9, INT_MAX);\n+  int i3  = SR ( 3, INT_MAX);\n+  int i2  = SR ( 2, INT_MAX);\n+  int i1  = SR ( 1, INT_MAX);\n+  int i0  = SR ( 0, INT_MAX);\n+\n+  int m11 = SR (INT_MIN, -11);\n+  int m10 = SR (INT_MIN, -10);\n+  int m9  = SR (INT_MIN,  -9);\n+  int m3  = SR (INT_MIN,  -3);\n+  int m2  = SR (INT_MIN,  -2);\n+  int m1  = SR (INT_MIN,  -1);\n+  int m0  = SR (INT_MIN,  -0);\n+\n+  T1 (p, m11, i11);\n+  T1 (p, m10, i10);\n+  T1 (p,  m9,  i9);\n+  T1 (p,  m3,  i3);\n+  T1 (p,  m2,  i2);\n+  T1 (p,  m1,  i1);\n+  T1 (p,  m0,  i0);\n+\n+  T1 (p, m11, i11);\n+  T1 (p, m10, i10);\n+  T1 (p,  m9,  i9);\n+  T1 (p,  m3,  i3);\n+  T1 (p,  m2,  i2);\n+  T1 (p,  m1,  i1);\n+  T1 (p,  m0,  i0);\n+}\n+\n+\n+void nowarn_memset_array_rng (void)\n+{\n+  char *p = &a11[11];\n+\n+  T2 (p, SR (-11, -10), SR ( -2,  -1), UR (11, 12));\n+  T2 (p, SR (-10,  -9), SR ( -1,   0), UR (11, 13));\n+  T2 (p, SR ( -9,  -8), SR ( -2,  -1), UR (11, 14));\n+  T2 (p, SR ( -8,  -7), SR ( -3,  -2), UR (11, 15));\n+  T2 (p, SR ( -7,  -6), SR ( -4,  -3), UR (11, 16));\n+  T2 (p, SR ( -6,  -5), SR ( -5,  -4), UR (11, 17));\n+  T2 (p, SR ( -5,  -4), SR ( -6,  -5), UR (11, 18));\n+  T2 (p, SR ( -4,  -3), SR ( -7,  -6), UR (11, 19));\n+  T2 (p, SR ( -3,  -2), SR ( -8,  -7), UR (11, INT_MAX));\n+  T2 (p, SR ( -2,  -1), SR ( -9,  -8), UR (11, UINT_MAX));\n+  T2 (p, SR ( -1,   0), SR (-10,  -9), UR (11, DIFF_MAX));\n+  T2 (p, SR (  0,   1), SR (-11, -10), UR (11, SIZE_MAX));\n+\n+  T2 (p, SR (DIFF_MIN, -10), SR (DIFF_MIN, -1), UR (10, 12));\n+\n+  T2 (p, SR (-11, -10), SR ( -3,  -1), UR (10, 12))\n+  T2 (p, SR (-11, -10), SR ( -3,  -1), UR (10, 12))\n+}\n+\n+\n+void warn_memset_array_rng (void)\n+{\n+  char *p = &a11[11];\n+  size_t n11_12 = UR (11, 12);\n+  size_t n10_12 = UR (10, 12);\n+\n+  T2 (p, SR (-11, -10), SR ( -3,  -2), n11_12);    // { dg-warning \"writing between 11 and 12 bytes into a region of size 0\" }\n+  T2 (p, SR (-11, -10), SR ( -3,  -2), n10_12);    // { dg-warning \"writing between 10 and 12 bytes into a region of size 0\" }\n+}\n+\n+\n+void nowarn_memset_anti_range (void)\n+{\n+  size_t n11 = UR (11, SIZE_MAX);\n+\n+  char *p = &a11[11];\n+\n+  T1 (p, (int)SAR (INT_MIN,      -12), n11);\n+  T1 (p, (int)SAR (    -13,      -13), n11);\n+  T1 (p, (int)SAR (    -13,      -12), n11);\n+  T1 (p, (int)SAR (    -10,        1), n11);\n+  T1 (p, (int)SAR (    -10,       11), n11);\n+  T1 (p, (int)SAR (    -10,  INT_MAX), n11);\n+  T1 (p, (int)SAR (     -1,       -1), n11);\n+  T1 (p, (int)SAR (     -1,        0), n11);\n+  T1 (p, (int)SAR (     -1,       11), n11);\n+  T1 (p, (int)SAR (     -1,  INT_MAX), n11);\n+\n+  T1 (p, SAR (DIFF_MIN,       -12), n11);\n+  T1 (p, SAR (     -13,       -13), n11);\n+  T1 (p, SAR (     -13,       -12), n11);\n+  T1 (p, SAR (     -10,         1), n11);   // { dg-bogus \"-Wstringop-overflow\" }\n+  T1 (p, SAR (     -10,        11), n11);   // { dg-bogus \"-Wstringop-overflow\" }\n+  T1 (p, SAR (     -10,  DIFF_MAX), n11);\n+  T1 (p, SAR (     -1,         -1), n11);   // { dg-bogus \"-Wstringop-overflow\" }\n+  T1 (p, SAR (     -1,          0), n11);   // { dg-bogus \"-Wstringop-overflow\" }\n+  T1 (p, SAR (     -1,         11), n11);   // { dg-bogus \"-Wstringop-overflow\" }\n+  T1 (p, SAR (     -1,   DIFF_MAX), n11);\n+}\n+\n+void warn_memset_reversed_range (void)\n+{\n+  size_t n11 = UR (11, SIZE_MAX);\n+\n+  char *p = &a11[11];\n+\n+  /* The below is represented as a true anti-range as opposed to a range\n+     with reversed bounds and the former aren't handled.  */\n+  T1 (p, SAR (INT_MIN, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  /* The following are represented as ordinary ranges with reversed bounds\n+     and those are handled. */\n+  T1 (p, SAR (INT_MIN,  11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n+  /* In ILP32 the offset in the following has no range info associated\n+     with it.  */\n+  T1 (p, SAR (INT_MIN,   1), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" \"pr?????\" { xfail ilp32 } }\n+  T1 (p, SAR (INT_MIN,   0), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n+  /* Also represented as a true anti-range.  */\n+  T1 (p, SAR (    -12, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+  T1 (p, SAR (    -12,  -1), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n+  T1 (p, SAR (    -11,   0), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n+  T1 (p, SAR (    -11,  11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n+}"}]}