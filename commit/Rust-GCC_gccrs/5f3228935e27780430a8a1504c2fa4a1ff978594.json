{"sha": "5f3228935e27780430a8a1504c2fa4a1ff978594", "node_id": "C_kwDOANBUbNoAKDVmMzIyODkzNWUyNzc4MDQzMGE4YTE1MDRjMmZhNGExZmY5Nzg1OTQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-04T19:21:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-05T06:21:41Z"}, "message": "Be even more conservative in intersection of NANs.\n\nIntersecting two ranges where one is a NAN is keeping the sign bit of\nthe NAN range.  This is not correct as the sign bits may not match.\n\nI think the only time we're absolutely sure about the intersection of\na NAN and something else, is when both are a NAN with exactly the same\nproperties (sign bit).  If we're intersecting two NANs of differing\nsign, we can decide later whether that's undefined or just a NAN with\nno known sign.  For now I've done the latter.\n\nI'm still mentally working on intersections involving NANs, especially\nif we want to keep track of signbits.  For now, let's be extra careful\nand only do things we're absolutely sure about.\n\nLater we may want to fold the intersect of [NAN,NAN] and say [3,5]\nwith the posibility of NAN, to a NAN, but I'm not 100% sure.  As I've\nsaid before, setting varying is always a safe choice, because it means\nwe know nothing and ranger won't attempt to optimize anything.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (early_nan_resolve): Remove.\n\t(frange::intersect): Handle NANs.", "tree": {"sha": "b9c2c7417150a1c9e4fe2e046298357815c09a3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9c2c7417150a1c9e4fe2e046298357815c09a3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f3228935e27780430a8a1504c2fa4a1ff978594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3228935e27780430a8a1504c2fa4a1ff978594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f3228935e27780430a8a1504c2fa4a1ff978594", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f3228935e27780430a8a1504c2fa4a1ff978594/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e070cf4bd085e10601195bb223dd1a0edeecf4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e070cf4bd085e10601195bb223dd1a0edeecf4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e070cf4bd085e10601195bb223dd1a0edeecf4d"}], "stats": {"total": 35, "additions": 16, "deletions": 19}, "files": [{"sha": "9c561415971df1b92eedbb73ce689142b1e8d35e", "filename": "gcc/value-range.cc", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f3228935e27780430a8a1504c2fa4a1ff978594/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f3228935e27780430a8a1504c2fa4a1ff978594/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=5f3228935e27780430a8a1504c2fa4a1ff978594", "patch": "@@ -444,24 +444,6 @@ frange::normalize_kind ()\n   return false;\n }\n \n-// If both operands are definitely NAN, do nothing as they combine\n-// perfectly.  If OTOH, only one is a NAN, set R to VARYING as they\n-// can't be neither unioned nor intersected.  Return TRUE if we\n-// changed anything.\n-\n-static inline bool\n-early_nan_resolve (frange &r, const frange &other)\n-{\n-  gcc_checking_assert (r.get_nan ().yes_p () || other.get_nan ().yes_p ());\n-\n-  // There's nothing to do for both NANs.\n-  if (r.get_nan ().yes_p () == other.get_nan ().yes_p ())\n-    return false;\n-  // ?? Perhaps the intersection of a NAN and anything is a NAN ??.\n-  r.set_varying (r.type ());\n-  return true;\n-}\n-\n bool\n frange::union_ (const vrange &v)\n {\n@@ -532,8 +514,23 @@ frange::intersect (const vrange &v)\n       *this = r;\n       return true;\n     }\n+\n+  // If two NANs are not exactly the same, drop to an unknown NAN,\n+  // otherwise there's nothing to do.\n+  if (get_nan ().yes_p () && r.get_nan ().yes_p ())\n+    {\n+      if (m_props == r.m_props)\n+\treturn false;\n+\n+      *this = frange_nan (m_type);\n+      return true;\n+    }\n+  // ?? Perhaps the intersection of a NAN and anything is a NAN ??.\n   if (get_nan ().yes_p () || r.get_nan ().yes_p ())\n-    return early_nan_resolve (*this, r);\n+    {\n+      set_varying (m_type);\n+      return true;\n+    }\n \n   bool changed = m_props.intersect (r.m_props);\n "}]}