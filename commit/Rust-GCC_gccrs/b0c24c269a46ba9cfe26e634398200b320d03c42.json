{"sha": "b0c24c269a46ba9cfe26e634398200b320d03c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjMjRjMjY5YTQ2YmE5Y2ZlMjZlNjM0Mzk4MjAwYjMyMGQwM2M0Mg==", "commit": {"author": {"name": "Manfred Hollstein", "email": "manfred@s-direktnet.de", "date": "1998-10-07T09:45:58Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-07T09:45:58Z"}, "message": "reload1.c (reload): Call free before clobbering the memory locations or constants pointers.\n\n\ufffd\n\t* reload1.c (reload): Call free before clobbering the memory\n\tlocations or constants pointers.\n\nFrom-SVN: r22885", "tree": {"sha": "b069f0ad6bdce0966cb6ec021a5491cd47d49dd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b069f0ad6bdce0966cb6ec021a5491cd47d49dd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c24c269a46ba9cfe26e634398200b320d03c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c24c269a46ba9cfe26e634398200b320d03c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c24c269a46ba9cfe26e634398200b320d03c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c24c269a46ba9cfe26e634398200b320d03c42/comments", "author": null, "committer": null, "parents": [{"sha": "9335e9a3a17d7efe7d095eb6ac7f8c45133159c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9335e9a3a17d7efe7d095eb6ac7f8c45133159c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9335e9a3a17d7efe7d095eb6ac7f8c45133159c2"}], "stats": {"total": 627, "additions": 296, "deletions": 331}, "files": [{"sha": "07884a77672fc0c1154b3ba81c27d979dc6b21f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c24c269a46ba9cfe26e634398200b320d03c42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c24c269a46ba9cfe26e634398200b320d03c42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0c24c269a46ba9cfe26e634398200b320d03c42", "patch": "@@ -1,3 +1,8 @@\n+1998-10-07  Manfred Hollstein  <manfred@s-direktnet.de>\n+\n+\t* reload1.c (reload): Call free before clobbering the memory\n+\tlocations or constants pointers.\n+\n Wed Oct  7 02:05:20 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \n \t* config/sparc/sol2-sld-64.h (TRANSFER_FROM_TRAMPOLINE): Rework"}, {"sha": "15a43eeca4100ef1f7f0d87783bc5a73472189a0", "filename": "gcc/reload1.c", "status": "modified", "additions": 291, "deletions": 331, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c24c269a46ba9cfe26e634398200b320d03c42/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c24c269a46ba9cfe26e634398200b320d03c42/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b0c24c269a46ba9cfe26e634398200b320d03c42", "patch": "@@ -406,6 +406,9 @@ static void emit_reload_insns\t\tPROTO((rtx, int));\n static void delete_output_reload\tPROTO((rtx, int, rtx));\n static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n+static void find_set_and_used_regs\tPROTO((rtx, int, int));\n+static void calc_reg_usage\t\tPROTO((rtx, int));\n+\n static void reload_cse_regs_1\t\tPROTO((rtx));\n static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx));\n@@ -417,8 +420,6 @@ static int reload_cse_simplify_set\tPROTO((rtx, rtx));\n static int reload_cse_simplify_operands\tPROTO((rtx));\n static void reload_cse_check_clobber\tPROTO((rtx, rtx));\n static void reload_cse_record_set\tPROTO((rtx, rtx));\n-static void reload_cse_delete_death_notes\tPROTO((rtx));\n-static void reload_cse_no_longer_dead\tPROTO((int, enum machine_mode));\n static void reload_combine PROTO((void));\n static void reload_combine_note_use PROTO((rtx *, rtx));\n static void reload_combine_note_store PROTO((rtx, rtx));\n@@ -1179,17 +1180,13 @@ reload (first, global, dumpfile)\n     }\n \n   /* Make a pass over all the insns and delete all USEs which we inserted\n-     only to tag a REG_EQUAL note on them; if PRESERVE_DEATH_INFO_REGNO_P\n-     is defined, also remove death notes for things that are no longer\n-     registers or no longer die in the insn (e.g., an input and output\n-     pseudo being tied).  */\n+     only to tag a REG_EQUAL note on them.  Also remove all REG_DEAD and\n+     REG_UNUSED notes.  */\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n       {\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\trtx note, next;\n-#endif\n+\trtx *pnote;\n \n \tif (GET_CODE (PATTERN (insn)) == USE\n \t    && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n@@ -1199,16 +1196,16 @@ reload (first, global, dumpfile)\n \t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t    continue;\n \t  }\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\tfor (note = REG_NOTES (insn); note; note = next)\n+\n+\tpnote = &REG_NOTES (insn);\n+\twhile (*pnote != 0)\n \t  {\n-\t    next = XEXP (note, 1);\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t&& (GET_CODE (XEXP (note, 0)) != REG\n-\t\t    || reg_set_p (XEXP (note, 0), PATTERN (insn))))\n-\t      remove_note (insn, note);\n+\t    if (REG_NOTE_KIND (*pnote) == REG_DEAD\n+\t\t|| REG_NOTE_KIND (*pnote) == REG_UNUSED)\n+\t      *pnote = XEXP (*pnote, 1);\n+\t    else\n+\t      pnote = &XEXP (*pnote, 1);\n \t  }\n-#endif\n       }\n \n   /* If we are doing stack checking, give a warning if this function's\n@@ -6755,28 +6752,6 @@ emit_reload_insns (insn, bb)\n \t\tgen_reload (reloadreg, oldequiv, reload_opnum[j],\n \t\t\t    reload_when_needed[j]);\n \n-#if defined(SECONDARY_INPUT_RELOAD_CLASS) && defined(PRESERVE_DEATH_INFO_REGNO_P)\n-\t      /* We may have to make a REG_DEAD note for the secondary reload\n-\t\t register in the insns we just made.  Find the last insn that\n-\t\t mentioned the register.  */\n-\t      if (! special && second_reload_reg\n-\t\t  && PRESERVE_DEATH_INFO_REGNO_P (REGNO (second_reload_reg)))\n-\t\t{\n-\t\t  rtx prev;\n-\n-\t\t  for (prev = get_last_insn (); prev;\n-\t\t       prev = PREV_INSN (prev))\n-\t\t    if (GET_RTX_CLASS (GET_CODE (prev) == 'i')\n-\t\t\t&& reg_overlap_mentioned_for_reload_p (second_reload_reg,\n-\t\t\t\t\t\t\t       PATTERN (prev)))\n-\t\t      {\n-\t\t\tREG_NOTES (prev) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t\t      second_reload_reg,\n-\t\t\t\t\t\t\t      REG_NOTES (prev));\n-\t\t\tbreak;\n-\t\t      }\n-\t\t}\n-#endif\n \t    }\n \n \t  this_reload_insn = get_last_insn ();\n@@ -6798,118 +6773,6 @@ emit_reload_insns (insn, bb)\n \t  reload_in[j]\n \t    = regno_reg_rtx[reg_reloaded_contents[reload_spill_index[j]]];\n \t}\n-      /* Add a note saying the input reload reg\n-\t dies in this insn, if anyone cares.  */\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-      if (old != 0\n-\t  && reload_reg_rtx[j] != old\n-\t  && reload_reg_rtx[j] != 0\n-\t  && reload_out[j] == 0\n-\t  && ! reload_inherited[j]\n-\t  && PRESERVE_DEATH_INFO_REGNO_P (REGNO (reload_reg_rtx[j])))\n-\t{\n-\t  register rtx reloadreg = reload_reg_rtx[j];\n-\n-#if 0\n-\t  /* We can't abort here because we need to support this for sched.c.\n-\t     It's not terrible to miss a REG_DEAD note, but we should try\n-\t     to figure out how to do this correctly.  */\n-\t  /* The code below is incorrect for address-only reloads.  */\n-\t  if (reload_when_needed[j] != RELOAD_OTHER\n-\t      && reload_when_needed[j] != RELOAD_FOR_INPUT)\n-\t    abort ();\n-#endif\n-\n-\t  /* Add a death note to this insn, for an input reload.  */\n-\n-\t  if ((reload_when_needed[j] == RELOAD_OTHER\n-\t       || reload_when_needed[j] == RELOAD_FOR_INPUT)\n-\t      && ! dead_or_set_p (insn, reloadreg))\n-\t    REG_NOTES (insn)\n-\t      = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t   reloadreg, REG_NOTES (insn));\n-\t}\n-\n-      /* When we inherit a reload, the last marked death of the reload reg\n-\t may no longer really be a death.  */\n-      if (reload_reg_rtx[j] != 0\n-\t  && PRESERVE_DEATH_INFO_REGNO_P (REGNO (reload_reg_rtx[j]))\n-\t  && reload_inherited[j])\n-\t{\n-\t  /* Handle inheriting an output reload.\n-\t     Remove the death note from the output reload insn.  */\n-\t  if (reload_spill_index[j] >= 0\n-\t      && GET_CODE (reload_in[j]) == REG\n-\t      && spill_reg_store[reload_spill_index[j]] != 0\n-\t      && find_regno_note (spill_reg_store[reload_spill_index[j]],\n-\t\t\t\t  REG_DEAD, REGNO (reload_reg_rtx[j])))\n-\t    remove_death (REGNO (reload_reg_rtx[j]),\n-\t\t\t  spill_reg_store[reload_spill_index[j]]);\n-\t  /* Likewise for input reloads that were inherited.  */\n-\t  else if (reload_spill_index[j] >= 0\n-\t\t   && GET_CODE (reload_in[j]) == REG\n-\t\t   && spill_reg_store[reload_spill_index[j]] == 0\n-\t\t   && reload_inheritance_insn[j] != 0\n-\t\t   && find_regno_note (reload_inheritance_insn[j], REG_DEAD,\n-\t\t\t\t       REGNO (reload_reg_rtx[j])))\n-\t    remove_death (REGNO (reload_reg_rtx[j]),\n-\t\t\t  reload_inheritance_insn[j]);\n-\t  else\n-\t    {\n-\t      rtx prev;\n-\n-\t      /* We got this register from find_equiv_reg.\n-\t\t Search back for its last death note and get rid of it.\n-\t\t But don't search back too far.\n-\t\t Don't go past a place where this reg is set,\n-\t\t since a death note before that remains valid.  */\n-\t      for (prev = PREV_INSN (insn);\n-\t\t   prev && GET_CODE (prev) != CODE_LABEL;\n-\t\t   prev = PREV_INSN (prev))\n-\t\tif (GET_RTX_CLASS (GET_CODE (prev)) == 'i'\n-\t\t    && dead_or_set_p (prev, reload_reg_rtx[j]))\n-\t\t  {\n-\t\t    if (find_regno_note (prev, REG_DEAD,\n-\t\t\t\t\t REGNO (reload_reg_rtx[j])))\n-\t\t      remove_death (REGNO (reload_reg_rtx[j]), prev);\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n-\n-      /* We might have used find_equiv_reg above to choose an alternate\n-\t place from which to reload.  If so, and it died, we need to remove\n-\t that death and move it to one of the insns we just made.  */\n-\n-      if (oldequiv_reg != 0\n-\t  && PRESERVE_DEATH_INFO_REGNO_P (true_regnum (oldequiv_reg)))\n-\t{\n-\t  rtx prev, prev1;\n-\n-\t  for (prev = PREV_INSN (insn); prev && GET_CODE (prev) != CODE_LABEL;\n-\t       prev = PREV_INSN (prev))\n-\t    if (GET_RTX_CLASS (GET_CODE (prev)) == 'i'\n-\t\t&& dead_or_set_p (prev, oldequiv_reg))\n-\t      {\n-\t\tif (find_regno_note (prev, REG_DEAD, REGNO (oldequiv_reg)))\n-\t\t  {\n-\t\t    for (prev1 = this_reload_insn;\n-\t\t\t prev1; prev1 = PREV_INSN (prev1))\n-\t\t      if (GET_RTX_CLASS (GET_CODE (prev1) == 'i')\n-\t\t\t&& reg_overlap_mentioned_for_reload_p (oldequiv_reg,\n-\t\t\t\t\t\t\t       PATTERN (prev1)))\n-\t\t      {\n-\t\t\tREG_NOTES (prev1) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t\t       oldequiv_reg,\n-\t\t\t\t\t\t\t       REG_NOTES (prev1));\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    remove_death (REGNO (oldequiv_reg), prev);\n-\t\t  }\n-\t\tbreak;\n-\t      }\n-\t}\n-#endif\n \n       /* If we are reloading a register that was recently stored in with an\n \t output-reload, see if we can prove there was\n@@ -7115,30 +6978,6 @@ emit_reload_insns (insn, bb)\n \t\t\t    reload_when_needed[j]);\n \t    }\n \n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\t  /* If final will look at death notes for this reg,\n-\t     put one on the last output-reload insn to use it.  Similarly\n-\t     for any secondary register.  */\n-\t  if (PRESERVE_DEATH_INFO_REGNO_P (REGNO (reloadreg)))\n-\t    for (p = get_last_insn (); p; p = PREV_INSN (p))\n-\t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t\t  && reg_overlap_mentioned_for_reload_p (reloadreg,\n-\t\t\t\t\t\t\t PATTERN (p)))\n-\t\tREG_NOTES (p) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t   reloadreg, REG_NOTES (p));\n-\n-#ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n-\t  if (! special && second_reloadreg\n-\t      && PRESERVE_DEATH_INFO_REGNO_P (REGNO (second_reloadreg)))\n-\t    for (p = get_last_insn (); p; p = PREV_INSN (p))\n-\t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t\t  && reg_overlap_mentioned_for_reload_p (second_reloadreg,\n-\t\t\t\t\t\t\t PATTERN (p)))\n-\t\tREG_NOTES (p) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t   second_reloadreg,\n-\t\t\t\t\t\t   REG_NOTES (p));\n-#endif\n-#endif\n \t  /* Look at all insns we emitted, just to be safe.  */\n \t  for (p = get_insns (); p; p = NEXT_INSN (p))\n \t    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n@@ -7263,50 +7102,6 @@ emit_reload_insns (insn, bb)\n         basic_block_end[bb] = PREV_INSN (following_insn);\n     }\n \n-  /* Move death notes from INSN\n-     to output-operand-address and output reload insns.  */\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-  {\n-    rtx insn1;\n-    /* Loop over those insns, last ones first.  */\n-    for (insn1 = PREV_INSN (following_insn); insn1 != insn;\n-\t insn1 = PREV_INSN (insn1))\n-      if (GET_CODE (insn1) == INSN && GET_CODE (PATTERN (insn1)) == SET)\n-\t{\n-\t  rtx source = SET_SRC (PATTERN (insn1));\n-\t  rtx dest = SET_DEST (PATTERN (insn1));\n-\n-\t  /* The note we will examine next.  */\n-\t  rtx reg_notes = REG_NOTES (insn);\n-\t  /* The place that pointed to this note.  */\n-\t  rtx *prev_reg_note = &REG_NOTES (insn);\n-\n-\t  /* If the note is for something used in the source of this\n-\t     reload insn, or in the output address, move the note.  */\n-\t  while (reg_notes)\n-\t    {\n-\t      rtx next_reg_notes = XEXP (reg_notes, 1);\n-\t      if (REG_NOTE_KIND (reg_notes) == REG_DEAD\n-\t\t  && GET_CODE (XEXP (reg_notes, 0)) == REG\n-\t\t  && ((GET_CODE (dest) != REG\n-\t\t       && reg_overlap_mentioned_for_reload_p (XEXP (reg_notes, 0),\n-\t\t\t\t\t\t\t      dest))\n-\t\t      || reg_overlap_mentioned_for_reload_p (XEXP (reg_notes, 0),\n-\t\t\t\t\t\t\t     source)))\n-\t\t{\n-\t\t  *prev_reg_note = next_reg_notes;\n-\t\t  XEXP (reg_notes, 1) = REG_NOTES (insn1);\n-\t\t  REG_NOTES (insn1) = reg_notes;\n-\t\t}\n-\t      else\n-\t\tprev_reg_note = &XEXP (reg_notes, 1);\n-\n-\t      reg_notes = next_reg_notes;\n-\t    }\n-\t}\n-  }\n-#endif\n-\n   /* For all the spill regs newly reloaded in this instruction,\n      record what they were reloaded from, so subsequent instructions\n      can inherit the reloads.\n@@ -8014,6 +7809,270 @@ count_occurrences (x, find)\n   return count;\n }\n \f\n+static HARD_REG_SET set_regs;\n+static HARD_REG_SET used_regs;\n+static HARD_REG_SET live_regs;\n+\n+/* Walk the rtx X recursively, calling WORKER for every sub-expression with\n+   the type of access as parameter.  */\n+static void\n+find_set_and_used_regs (x, read, written)\n+     rtx x;\n+     int read, written;\n+{\n+  enum rtx_code code;\n+  const char *fmt;\n+  int i, regno, nregs;\n+\n+  if (0 && x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+  if (code == SUBREG)\n+    {\n+      x = SUBREG_REG (x);\n+      code = GET_CODE (x);\n+    }\n+\n+  switch (code)\n+    {\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      return;\n+\n+    case REG:\n+      regno = REGNO (x);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\treturn;\n+      nregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+      while (nregs-- > 0)\n+\t{\n+\t  if (written)\n+\t    SET_HARD_REG_BIT (set_regs, regno + nregs);\n+\t  if (read)\n+\t    SET_HARD_REG_BIT (used_regs, regno + nregs);\n+\t}\n+      return;\n+\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+      find_set_and_used_regs (XEXP (x, 0), read, written);\n+      find_set_and_used_regs (XEXP (x, 1), 1, 0);\n+      find_set_and_used_regs (XEXP (x, 2), 1, 0);\n+      return;\n+      \n+    case PRE_DEC:\n+    case POST_DEC:\n+    case PRE_INC:\n+    case POST_INC:\n+      find_set_and_used_regs (XEXP (x, 0), 1, 1);\n+      return;\n+      \n+    case SET:\n+      find_set_and_used_regs (SET_SRC (x), 1, 0);\n+\n+      /* fall through */\n+    case CLOBBER:\n+      find_set_and_used_regs (SET_DEST (x), 0, 1);\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tfind_set_and_used_regs (XEXP (x, i), 1, 0);\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    find_set_and_used_regs (XVECEXP (x, i, j), 1, 0);\n+\t}\n+    }\n+}\n+\n+static void\n+calc_reg_usage (insn, make_notes)\n+     rtx insn;\n+     int make_notes;\n+{\n+  int i;\n+\n+  CLEAR_HARD_REG_SET (set_regs);\n+  CLEAR_HARD_REG_SET (used_regs);\n+  find_set_and_used_regs (PATTERN (insn), 0, 0);\n+\n+  if (GET_CODE (insn) == CALL_INSN)\n+    {\n+      rtx x;\n+      for (x = CALL_INSN_FUNCTION_USAGE (insn); x != 0; x = XEXP (x, 1))\n+\tfind_set_and_used_regs (XEXP (x, 0), 0, 0);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (call_used_regs[i] && ! fixed_regs[i] && ! global_regs[i])\n+\t  SET_HARD_REG_BIT (set_regs, i);\n+    }\n+\n+  if (! make_notes)\n+    return;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (TEST_HARD_REG_BIT (live_regs, i))\n+\tcontinue;\n+      if (TEST_HARD_REG_BIT (set_regs, i))\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t      gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t\t\t\t      REG_NOTES (insn));\n+      else if (TEST_HARD_REG_BIT (used_regs, i))\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t      gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t\t\t\t      REG_NOTES (insn));\n+    }\n+  AND_COMPL_HARD_REG_SET (live_regs, set_regs);\n+  IOR_HARD_REG_SET (live_regs, used_regs);\n+}\n+\n+/* Now that all pseudo registers have been eliminated, calculate hard register\n+   life information.  */\n+void\n+reload_life_analysis (first)\n+     rtx first;\n+{\n+  rtx insn, last;\n+  int b;\n+  int_list_ptr *s_preds, *s_succs;\n+  int *num_preds, *num_succs;\n+  HARD_REG_SET *block_sets;\n+  HARD_REG_SET *block_uses;\n+  HARD_REG_SET *live_at_start;\n+  HARD_REG_SET *live_at_end;\n+  int outside_block = 1;\n+\n+  s_preds = (int_list_ptr *) xmalloc (n_basic_blocks * sizeof (int_list_ptr));\n+  s_succs = (int_list_ptr *) xmalloc (n_basic_blocks * sizeof (int_list_ptr));\n+  num_preds = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+  num_succs = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+  block_sets = (HARD_REG_SET *) xmalloc (n_basic_blocks * sizeof (HARD_REG_SET));\n+  block_uses = (HARD_REG_SET *) xmalloc (n_basic_blocks * sizeof (HARD_REG_SET));\n+  live_at_start = (HARD_REG_SET *) xmalloc (n_basic_blocks * sizeof (HARD_REG_SET));\n+  live_at_end = (HARD_REG_SET *) xmalloc (n_basic_blocks * sizeof (HARD_REG_SET));\n+\n+  bzero (block_sets, n_basic_blocks * sizeof (HARD_REG_SET));\n+  bzero (block_uses, n_basic_blocks * sizeof (HARD_REG_SET));\n+  bzero (live_at_start, n_basic_blocks * sizeof (HARD_REG_SET));\n+  bzero (live_at_end, n_basic_blocks * sizeof (HARD_REG_SET));\n+\n+  compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n+\n+  b = n_basic_blocks;\n+  for (last = first; NEXT_INSN (last); last = NEXT_INSN (last))\n+    ;\n+  for (insn = last; insn; insn = PREV_INSN (insn))\n+    {\n+      enum rtx_code code = GET_CODE (insn);\n+\n+      /* Start with fresh live info at the end of every basic block.  */\n+      if (b > 0 && basic_block_end[b - 1] == insn)\n+\t{\n+\t  outside_block = 0;\n+\t  b--;\n+\t}\n+      if (GET_RTX_CLASS (code) == 'i' && outside_block)\n+\tabort ();\n+\n+      /* Clobbers are inserted during rtl expansion to show flow.c that some\n+\t values die when that is non-obvious.  Once all pseudos are converted\n+\t tohard regs, that information is no longer needed, and can in fact\n+\t be incorrect.  */\n+      if (GET_RTX_CLASS (code) == 'i' && GET_CODE (PATTERN (insn)) == CLOBBER)\n+\t{\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  code = NOTE;\n+\t}\n+      if (GET_RTX_CLASS (code) == 'i')\n+\t{\n+\t  calc_reg_usage (insn, 0);\n+\n+\t  IOR_HARD_REG_SET (block_sets[b], set_regs);\n+\t  AND_COMPL_HARD_REG_SET (block_sets[b], used_regs);\n+\n+\t  AND_COMPL_HARD_REG_SET (block_uses[b], set_regs);\n+\t  IOR_HARD_REG_SET (block_uses[b], used_regs);\n+\t}\n+\n+      if (insn == basic_block_head[b])\n+\t{\n+\t  outside_block = 1;\n+\t}\n+    }\n+  for (;;)\n+    {\n+      int something_changed = 0;\n+\n+      for (b = n_basic_blocks - 1; b >= 0; b--)\n+\t{\n+\t  int_list_ptr psucc;\n+\t  HARD_REG_SET tmp;\n+\n+\t  CLEAR_HARD_REG_SET (live_at_end[b]);\n+\t  for (psucc = s_succs[b]; psucc; psucc = psucc->next)\n+\t    IOR_HARD_REG_SET (live_at_end[b],\n+\t\t\t      live_at_start[INT_LIST_VAL (psucc)]);\n+\t  COPY_HARD_REG_SET (tmp, live_at_end[b]);\n+\t  AND_COMPL_HARD_REG_SET (tmp, block_sets[b]);\n+\t  IOR_HARD_REG_SET (tmp, block_uses[b]);\n+\t  GO_IF_HARD_REG_EQUAL (tmp, live_at_start[b], win);\n+\t  COPY_HARD_REG_SET (live_at_start[b], tmp);\n+\t  something_changed = 1;\n+\n+\twin:\n+\t  ;\n+\t}\n+      if (! something_changed)\n+\tbreak;\n+    }\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      int i;\n+      CLEAR_REG_SET (basic_block_live_at_start[b]);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (live_at_start[b], i))\n+\t  SET_REGNO_REG_SET (basic_block_live_at_start[b], i);\n+    }\n+  for (insn = last; insn; insn = PREV_INSN (insn))\n+    {\n+      enum rtx_code code = GET_CODE (insn);\n+\n+      /* Start with fresh live info at the end of every basic block.  */\n+      if (b > 0 && basic_block_end[b - 1] == insn)\n+\t{\n+\t  b--;\n+\t  COPY_HARD_REG_SET (live_regs, live_at_end[b]);\n+\t}\n+\n+      if (GET_RTX_CLASS (code) == 'i')\n+\tcalc_reg_usage (insn, 1);\n+    }\n+\n+  free (s_preds);\n+  free (s_succs);\n+  free (num_preds);\n+  free (num_succs);\n+  free (block_sets);\n+  free (block_uses);\n+  free (live_at_end);\n+  free (live_at_start);\n+}\n+\f\n /* This array holds values which are equivalent to a hard register\n    during reload_cse_regs.  Each array element is an EXPR_LIST of\n    values.  Each time a hard register is set, we set the corresponding\n@@ -8036,13 +8095,6 @@ static rtx *reg_values;\n \n static rtx invalidate_regno_rtx;\n \n-/* This is a set of registers for which we must remove REG_DEAD notes in\n-   previous insns, because our modifications made them invalid.  That can\n-   happen if we introduced the register into the current insn, or we deleted\n-   the current insn which used to set the register.  */\n-\n-static HARD_REG_SET no_longer_dead_regs;\n-\n /* Invalidate any entries in reg_values which depend on REGNO,\n    including those for REGNO itself.  This is called if REGNO is\n    changing.  If CLOBBER is true, then always forget anything we\n@@ -8245,55 +8297,6 @@ reload_cse_invalidate_rtx (dest, ignore)\n     reload_cse_invalidate_mem (dest);\n }\n \n-/* Possibly delete death notes on the insns before INSN if modifying INSN\n-   extended the lifespan of the registers.  */\n-\n-static void\n-reload_cse_delete_death_notes (insn)\n-     rtx insn;\n-{\n-  int dreg;\n-\n-  for (dreg = 0; dreg < FIRST_PSEUDO_REGISTER; dreg++)\n-    {\n-      rtx trial;\n-\n-      if (! TEST_HARD_REG_BIT (no_longer_dead_regs, dreg))\n-\tcontinue;\n-\n-      for (trial = prev_nonnote_insn (insn);\n-\t   (trial\n-\t    && GET_CODE (trial) != CODE_LABEL\n-\t    && GET_CODE (trial) != BARRIER);\n-\t   trial = prev_nonnote_insn (trial))\n-\t{\n-\t  if (find_regno_note (trial, REG_DEAD, dreg))\n-\t    {\n-\t      remove_death (dreg, trial);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Record that the current insn uses hard reg REGNO in mode MODE.  This\n-   will be used in reload_cse_delete_death_notes to delete prior REG_DEAD\n-   notes for this register.  */\n-\n-static void\n-reload_cse_no_longer_dead (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n-{\n-  int nregs = HARD_REGNO_NREGS (regno, mode);\n-  while (nregs-- > 0)\n-    {\n-      SET_HARD_REG_BIT (no_longer_dead_regs, regno);\n-      regno++;\n-    }\n-}\n-\n-\n /* Do a very simple CSE pass over the hard registers.\n \n    This function detects no-op moves where we happened to assign two\n@@ -8366,8 +8369,6 @@ reload_cse_regs_1 (first)\n       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n \tcontinue;\n \n-      CLEAR_HARD_REG_SET (no_longer_dead_regs);\n-\n       /* If this is a call instruction, forget anything stored in a\n \t call clobbered register, or, if this is not a const call, in\n \t memory.  */\n@@ -8408,20 +8409,18 @@ reload_cse_regs_1 (first)\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (insn) = 0;\n \t\t}\n-\t      reload_cse_delete_death_notes (insn);\n \n \t      /* We're done with this insn.  */\n \t      continue;\n \t    }\n \n \t  /* It's not a no-op, but we can try to simplify it.  */\n-\t  CLEAR_HARD_REG_SET (no_longer_dead_regs);\n \t  count += reload_cse_simplify_set (body, insn);\n \n-\t  if (count > 0 && apply_change_group ())\n-\t    reload_cse_delete_death_notes (insn);\n-\t  else if (reload_cse_simplify_operands (insn))\n-\t    reload_cse_delete_death_notes (insn);\n+\t  if (count > 0)\n+\t    apply_change_group ();\n+\t  else\n+\t    reload_cse_simplify_operands (insn);\n \t    \n \t  reload_cse_record_set (body, body);\n \t}\n@@ -8465,22 +8464,20 @@ reload_cse_regs_1 (first)\n \t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (insn) = 0;\n \t\t}\n-\t      reload_cse_delete_death_notes (insn);\n \n \t      /* We're done with this insn.  */\n \t      continue;\n \t    }\n \t  \n \t  /* It's not a no-op, but we can try to simplify it.  */\n-\t  CLEAR_HARD_REG_SET (no_longer_dead_regs);\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    if (GET_CODE (XVECEXP (body, 0, i)) == SET)\n \t      count += reload_cse_simplify_set (XVECEXP (body, 0, i), insn);\n \n-\t  if (count > 0 && apply_change_group ())\n-\t    reload_cse_delete_death_notes (insn);\n-\t  else if (reload_cse_simplify_operands (insn))\n-\t    reload_cse_delete_death_notes (insn);\n+\t  if (count > 0)\n+\t    apply_change_group ();\n+\t  else\n+\t    reload_cse_simplify_operands (insn);\n \n \t  /* Look through the PARALLEL and record the values being\n              set, if possible.  Also handle any CLOBBERs.  */\n@@ -8659,14 +8656,6 @@ reload_cse_noop_set_p (set, insn)\n \tret = 1;\n     }\n \n-  /* If we can delete this SET, then we need to look for an earlier\n-     REG_DEAD note on DREG, and remove it if it exists.  */\n-  if (ret && dreg >= 0)\n-    {\n-      if (! find_regno_note (insn, REG_UNUSED, dreg))\n-\treload_cse_no_longer_dead (dreg, dest_mode);\n-    }\n-\n   return ret;\n }\n \n@@ -8726,11 +8715,8 @@ reload_cse_simplify_set (set, insn)\n              storage.  */\n \t  push_obstacks (&reload_obstack, &reload_obstack);\n \n-\t  if (validated && ! find_regno_note (insn, REG_UNUSED, i))\n-\t    {\n-\t      reload_cse_no_longer_dead (i, dest_mode);\n-\t      return 1;\n-\t    }\n+\t  if (validated)\n+\t    return 1;\n \t}\n     }\n   return 0;\n@@ -8935,7 +8921,6 @@ reload_cse_simplify_operands (insn)\n   /* Substitute the operands as determined by op_alt_regno for the best\n      alternative.  */\n   j = alternative_order[0];\n-  CLEAR_HARD_REG_SET (no_longer_dead_regs);\n \n   /* Pop back to the real obstacks while changing the insn.  */\n   pop_obstacks ();\n@@ -8946,7 +8931,6 @@ reload_cse_simplify_operands (insn)\n       if (op_alt_regno[i][j] == -1)\n \tcontinue;\n \n-      reload_cse_no_longer_dead (op_alt_regno[i][j], mode);\n       validate_change (insn, recog_operand_loc[i],\n \t\t       gen_rtx_REG (mode, op_alt_regno[i][j]), 1);\n     }\n@@ -8959,7 +8943,6 @@ reload_cse_simplify_operands (insn)\n       if (op_alt_regno[op][j] == -1)\n \tcontinue;\n \n-      reload_cse_no_longer_dead (op_alt_regno[op][j], mode);\n       validate_change (insn, recog_dup_loc[i],\n \t\t       gen_rtx_REG (mode, op_alt_regno[op][j]), 1);\n     }\n@@ -9546,8 +9529,7 @@ static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n /* move2add_luid is linearily increased while scanning the instructions\n    from first to last.  It is used to set reg_set_luid in\n-   reload_cse_move2add and move2add_note_store, and to set reg_death_luid\n-   (local variable of reload_cse_move2add) .  */\n+   reload_cse_move2add and move2add_note_store.  */\n static int move2add_luid;\n \n static void\n@@ -9557,16 +9539,10 @@ reload_cse_move2add (first)\n   int i;\n   rtx insn;\n   int last_label_luid;\n-  /* reg_death and reg_death_luid are solely used to remove stale REG_DEAD\n-     notes.  */\n-  int reg_death_luid[FIRST_PSEUDO_REGISTER];\n-  rtx reg_death[FIRST_PSEUDO_REGISTER];\n \n   for (i = FIRST_PSEUDO_REGISTER-1; i >= 0; i--)\n-    {\n-      reg_set_luid[i] = 0;\n-      reg_death_luid[i] = 0;\n-    }\n+    reg_set_luid[i] = 0;\n+\n   last_label_luid = 0;\n   move2add_luid = 1;\n   for (insn = first; insn; insn = NEXT_INSN (insn), move2add_luid++)\n@@ -9621,8 +9597,6 @@ reload_cse_move2add (first)\n \t\t\t   && have_add2_insn (GET_MODE (reg)))\n \t\t    success = validate_change (insn, &PATTERN (insn),\n \t\t\t\t\t       gen_add2_insn (reg, new_src), 0);\n-\t\t  if (success && reg_death_luid[regno] > reg_set_luid[regno])\n-\t\t    remove_death (regno, reg_death[regno]);\n \t\t  reg_set_luid[regno] = move2add_luid;\n \t\t  reg_mode[regno] = GET_MODE (reg);\n \t\t  reg_offset[regno] = src;\n@@ -9672,8 +9646,6 @@ reload_cse_move2add (first)\n \t\t\t\t\t     gen_add2_insn (reg, new_src), 0);\n \t\t      if (success)\n \t\t\t{\n-\t\t\t  if (reg_death_luid[regno] > reg_set_luid[regno])\n-\t\t\t    remove_death (regno, reg_death[regno]);\n \t\t\t  /* INSN might be the first insn in a basic block\n \t\t\t     if the preceding insn is a conditional jump\n \t\t\t     or a possible-throwing call.  */\n@@ -9705,18 +9677,6 @@ reload_cse_move2add (first)\n \t\t  reg_offset[regno] = note;\n \t\t}\n \t    }\n-\t  /* Remember any REG_DEAD notes so that we can remove them\n-\t     later if necessary.  */\n-\t  else if (REG_NOTE_KIND (note) == REG_DEAD\n-\t      && GET_CODE (XEXP (note, 0)) == REG)\n-\t    {\n-\t      int regno = REGNO (XEXP (note, 0));\n-\t      if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t{\n-\t\t  reg_death[regno] = insn;\n-\t\t  reg_death_luid[regno] = move2add_luid;\n-\t\t}\n-\t    }\n \t}\n       note_stores (PATTERN (insn), move2add_note_store);\n       /* If this is a CALL_INSN, all call used registers are stored with"}]}