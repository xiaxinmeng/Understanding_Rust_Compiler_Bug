{"sha": "43aabfcfd4139e4c9e7b868199e09b97e66010bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNhYWJmY2ZkNDEzOWU0YzllN2I4NjgxOTllMDliOTdlNjYwMTBiYw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-07-15T09:04:57Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-07-15T09:04:57Z"}, "message": "tree-scalar-evolution.c (simple_iv_with_niters): New funcion.\n\n\t* tree-scalar-evolution.c (simple_iv_with_niters): New funcion.\n\t(derive_simple_iv_with_niters): New function.\n\t(simple_iv): Rewrite using simple_iv_with_niters.\n\t* tree-scalar-evolution.h (simple_iv_with_niters): New decl.\n\t* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions): New\n\tfunction.\n\t(number_of_iterations_exit): Rewrite using above function.\n\t* tree-ssa-loop-niter.h (number_of_iterations_exit_assumptions): New\n\tDecl.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/loop-41.c: New test.\n\nFrom-SVN: r238367", "tree": {"sha": "bf2cd011c65849144b67a4d65d74e9dc61f556d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf2cd011c65849144b67a4d65d74e9dc61f556d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43aabfcfd4139e4c9e7b868199e09b97e66010bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43aabfcfd4139e4c9e7b868199e09b97e66010bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43aabfcfd4139e4c9e7b868199e09b97e66010bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43aabfcfd4139e4c9e7b868199e09b97e66010bc/comments", "author": null, "committer": null, "parents": [{"sha": "afc89e58498ef6a275d4e018d26b6fca3940ef1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc89e58498ef6a275d4e018d26b6fca3940ef1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc89e58498ef6a275d4e018d26b6fca3940ef1e"}], "stats": {"total": 223, "additions": 170, "deletions": 53}, "files": [{"sha": "e9c1144ccf4d6b2a742850a14b0424c21eaf0382", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43aabfcfd4139e4c9e7b868199e09b97e66010bc", "patch": "@@ -1,3 +1,15 @@\n+2016-07-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-scalar-evolution.c (simple_iv_with_niters): New funcion.\n+\t(derive_simple_iv_with_niters): New function.\n+\t(simple_iv): Rewrite using simple_iv_with_niters.\n+\t* tree-scalar-evolution.h (simple_iv_with_niters): New decl.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions): New\n+\tfunction.\n+\t(number_of_iterations_exit): Rewrite using above function.\n+\t* tree-ssa-loop-niter.h (number_of_iterations_exit_assumptions): New\n+\tDecl.\n+\n 2016-07-15  Richard Biener  <rguenther@suse.de>\n \n \t* config/i386/i386.c (ix86_builtin_vectorization_cost): Adjust"}, {"sha": "f31c63eac798b3a07c802751409aef865b6f9433", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43aabfcfd4139e4c9e7b868199e09b97e66010bc", "patch": "@@ -1,3 +1,7 @@\n+2016-07-15  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/loop-41.c: New test.\n+\n 2016-07-15  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/71347"}, {"sha": "52ba96849acfdd06756d54dcfac659b185f755d6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-41.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-41.c?ref=43aabfcfd4139e4c9e7b868199e09b97e66010bc", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -ftree-vrp -fdump-tree-vrp-alias\" } */\n+\n+signed char arr[240];\n+void foo (void)\n+{\n+\n+  unsigned short i, length = 200;\n+\n+  for (i = 1; (int)i < (length - 1); i++)\n+    arr[i] = -1;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"RANGE \\\\\\[0, 65535\\\\\\]\" \"vrp1\" } } */"}, {"sha": "d8ed84af495f5dc6133ab9782415bc13f49f0495", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 88, "deletions": 6, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=43aabfcfd4139e4c9e7b868199e09b97e66010bc", "patch": "@@ -3393,6 +3393,55 @@ iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n   return false;\n }\n \n+/* Given EV with form of \"(type) {inner_base, inner_step}_loop\", this\n+   function tries to derive condition under which it can be simplified\n+   into \"{(type)inner_base, (type)inner_step}_loop\".  The condition is\n+   the maximum number that inner iv can iterate.  */\n+\n+static tree\n+derive_simple_iv_with_niters (tree ev, tree *niters)\n+{\n+  if (!CONVERT_EXPR_P (ev))\n+    return ev;\n+\n+  tree inner_ev = TREE_OPERAND (ev, 0);\n+  if (TREE_CODE (inner_ev) != POLYNOMIAL_CHREC)\n+    return ev;\n+\n+  tree init = CHREC_LEFT (inner_ev);\n+  tree step = CHREC_RIGHT (inner_ev);\n+  if (TREE_CODE (init) != INTEGER_CST\n+      || TREE_CODE (step) != INTEGER_CST || integer_zerop (step))\n+    return ev;\n+\n+  tree type = TREE_TYPE (ev);\n+  tree inner_type = TREE_TYPE (inner_ev);\n+  if (TYPE_PRECISION (inner_type) >= TYPE_PRECISION (type))\n+    return ev;\n+\n+  /* Type conversion in \"(type) {inner_base, inner_step}_loop\" can be\n+     folded only if inner iv won't overflow.  We compute the maximum\n+     number the inner iv can iterate before overflowing and return the\n+     simplified affine iv.  */\n+  tree delta;\n+  init = fold_convert (type, init);\n+  step = fold_convert (type, step);\n+  ev = build_polynomial_chrec (CHREC_VARIABLE (inner_ev), init, step);\n+  if (tree_int_cst_sign_bit (step))\n+    {\n+      tree bound = lower_bound_in_type (inner_type, inner_type);\n+      delta = fold_build2 (MINUS_EXPR, type, init, fold_convert (type, bound));\n+      step = fold_build1 (NEGATE_EXPR, type, step);\n+    }\n+  else\n+    {\n+      tree bound = upper_bound_in_type (inner_type, inner_type);\n+      delta = fold_build2 (MINUS_EXPR, type, fold_convert (type, bound), init);\n+    }\n+  *niters = fold_build2 (FLOOR_DIV_EXPR, type, delta, step);\n+  return ev;\n+}\n+\n /* Checks whether use of OP in USE_LOOP behaves as a simple affine iv with\n    respect to WRTO_LOOP and returns its base and step in IV if possible\n    (see analyze_scalar_evolution_in_loop for more details on USE_LOOP\n@@ -3410,13 +3459,29 @@ iv_can_overflow_p (struct loop *loop, tree type, tree base, tree step)\n    not wrap by some other argument.  Otherwise, this might introduce undefined\n    behavior, and\n \n-   for (i = iv->base; ; i = (type) ((unsigned type) i + (unsigned type) iv->step))\n+   i = iv->base;\n+   for (; ; i = (type) ((unsigned type) i + (unsigned type) iv->step))\n+\n+   must be used instead.\n+\n+   When IV_NITERS is not NULL, this function also checks case in which OP\n+   is a conversion of an inner simple iv of below form:\n+\n+     (outer_type){inner_base, inner_step}_loop.\n \n-   must be used instead.  */\n+   If type of inner iv has smaller precision than outer_type, it can't be\n+   folded into {(outer_type)inner_base, (outer_type)inner_step}_loop because\n+   the inner iv could overflow/wrap.  In this case, we derive a condition\n+   under which the inner iv won't overflow/wrap and do the simplification.\n+   The derived condition normally is the maximum number the inner iv can\n+   iterate, and will be stored in IV_NITERS.  This is useful in loop niter\n+   analysis, to derive break conditions when a loop must terminate, when is\n+   infinite.  */\n \n bool\n-simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n-\t   affine_iv *iv, bool allow_nonconstant_step)\n+simple_iv_with_niters (struct loop *wrto_loop, struct loop *use_loop,\n+\t\t       tree op, affine_iv *iv, tree *iv_niters,\n+\t\t       bool allow_nonconstant_step)\n {\n   enum tree_code code;\n   tree type, ev, base, e, stop;\n@@ -3446,8 +3511,14 @@ simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n       return true;\n     }\n \n-  if (TREE_CODE (ev) != POLYNOMIAL_CHREC\n-      || CHREC_VARIABLE (ev) != (unsigned) wrto_loop->num)\n+  /* If we can derive valid scalar evolution with assumptions.  */\n+  if (iv_niters && TREE_CODE (ev) != POLYNOMIAL_CHREC)\n+    ev = derive_simple_iv_with_niters (ev, iv_niters);\n+\n+  if (TREE_CODE (ev) != POLYNOMIAL_CHREC)\n+    return false;\n+\n+  if (CHREC_VARIABLE (ev) != (unsigned) wrto_loop->num)\n     return false;\n \n   iv->step = CHREC_RIGHT (ev);\n@@ -3544,6 +3615,17 @@ simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n   return true;\n }\n \n+/* Like simple_iv_with_niters, but return TRUE when OP behaves as a simple\n+   affine iv unconditionally.  */\n+\n+bool\n+simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n+\t   affine_iv *iv, bool allow_nonconstant_step)\n+{\n+  return simple_iv_with_niters (wrto_loop, use_loop, op, iv,\n+\t\t\t\tNULL, allow_nonconstant_step);\n+}\n+\n /* Finalize the scalar evolution analysis.  */\n \n void"}, {"sha": "a77e4525f6db6cf3d766b02ed6d16a5d033df995", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=43aabfcfd4139e4c9e7b868199e09b97e66010bc", "patch": "@@ -36,6 +36,8 @@ extern void gather_stats_on_scev_database (void);\n extern void final_value_replacement_loop (struct loop *);\n extern unsigned int scev_const_prop (void);\n extern bool expression_expensive_p (tree);\n+extern bool simple_iv_with_niters (struct loop *, struct loop *, tree,\n+\t\t\t\t   struct affine_iv *, tree *, bool);\n extern bool simple_iv (struct loop *, struct loop *, tree, struct affine_iv *,\n \t\t       bool);\n extern bool iv_can_overflow_p (struct loop *, tree, tree, tree);"}, {"sha": "d96c03b3993c1711651c130a899026ea4f5dd13d", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=43aabfcfd4139e4c9e7b868199e09b97e66010bc", "patch": "@@ -2176,20 +2176,17 @@ loop_only_exit_p (const struct loop *loop, const_edge exit)\n }\n \n /* Stores description of number of iterations of LOOP derived from\n-   EXIT (an exit edge of the LOOP) in NITER.  Returns true if some\n-   useful information could be derived (and fields of NITER has\n-   meaning described in comments at struct tree_niter_desc\n-   declaration), false otherwise.  If WARN is true and\n-   -Wunsafe-loop-optimizations was given, warn if the optimizer is going to use\n-   potentially unsafe assumptions.  \n+   EXIT (an exit edge of the LOOP) in NITER.  Returns true if some useful\n+   information could be derived (and fields of NITER have meaning described\n+   in comments at struct tree_niter_desc declaration), false otherwise.\n    When EVERY_ITERATION is true, only tests that are known to be executed\n-   every iteration are considered (i.e. only test that alone bounds the loop). \n+   every iteration are considered (i.e. only test that alone bounds the loop).\n  */\n \n bool\n-number_of_iterations_exit (struct loop *loop, edge exit,\n-\t\t\t   struct tree_niter_desc *niter,\n-\t\t\t   bool warn, bool every_iteration)\n+number_of_iterations_exit_assumptions (struct loop *loop, edge exit,\n+\t\t\t\t       struct tree_niter_desc *niter,\n+\t\t\t\t       bool every_iteration)\n {\n   gimple *last;\n   gcond *stmt;\n@@ -2241,9 +2238,16 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n       && !POINTER_TYPE_P (type))\n     return false;\n \n-  if (!simple_iv (loop, loop_containing_stmt (stmt), op0, &iv0, false))\n+  tree iv0_niters = NULL_TREE;\n+  if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),\n+\t\t\t      op0, &iv0, &iv0_niters, false))\n     return false;\n-  if (!simple_iv (loop, loop_containing_stmt (stmt), op1, &iv1, false))\n+  tree iv1_niters = NULL_TREE;\n+  if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),\n+\t\t\t      op1, &iv1, &iv1_niters, false))\n+    return false;\n+  /* Give up on complicated case.  */\n+  if (iv0_niters && iv1_niters)\n     return false;\n \n   /* We don't want to see undefined signed overflow warnings while\n@@ -2259,6 +2263,24 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n       return false;\n     }\n \n+  /* Incorporate additional assumption implied by control iv.  */\n+  tree iv_niters = iv0_niters ? iv0_niters : iv1_niters;\n+  if (iv_niters)\n+    {\n+      tree assumption = fold_build2 (LE_EXPR, boolean_type_node, niter->niter,\n+\t\t\t\t     fold_convert (TREE_TYPE (niter->niter),\n+\t\t\t\t\t\t   iv_niters));\n+\n+      if (!integer_nonzerop (assumption))\n+\tniter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t  niter->assumptions, assumption);\n+\n+      /* Refine upper bound if possible.  */\n+      if (TREE_CODE (iv_niters) == INTEGER_CST\n+\t  && niter->max > wi::to_widest (iv_niters))\n+\tniter->max = wi::to_widest (iv_niters);\n+    }\n+\n   if (optimize >= 3)\n     {\n       niter->assumptions = simplify_using_outer_evolutions (loop,\n@@ -2281,44 +2303,22 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   if (TREE_CODE (niter->niter) == INTEGER_CST)\n     niter->max = wi::to_widest (niter->niter);\n \n-  if (integer_onep (niter->assumptions))\n-    return true;\n-\n-  /* With -funsafe-loop-optimizations we assume that nothing bad can happen.\n-     But if we can prove that there is overflow or some other source of weird\n-     behavior, ignore the loop even with -funsafe-loop-optimizations.  */\n-  if (integer_zerop (niter->assumptions) || !single_exit (loop))\n-    return false;\n-\n-  if (flag_unsafe_loop_optimizations)\n-    niter->assumptions = boolean_true_node;\n+  return (!integer_zerop (niter->assumptions));\n+}\n \n-  if (warn)\n-    {\n-      const char *wording;\n-      location_t loc = gimple_location (stmt);\n-\n-      /* We can provide a more specific warning if one of the operator is\n-\t constant and the other advances by +1 or -1.  */\n-      if (!integer_zerop (iv1.step)\n-\t  ? (integer_zerop (iv0.step)\n-\t     && (integer_onep (iv1.step) || integer_all_onesp (iv1.step)))\n-\t  : (integer_onep (iv0.step) || integer_all_onesp (iv0.step)))\n-        wording =\n-          flag_unsafe_loop_optimizations\n-          ? N_(\"assuming that the loop is not infinite\")\n-          : N_(\"cannot optimize possibly infinite loops\");\n-      else\n-\twording =\n-\t  flag_unsafe_loop_optimizations\n-\t  ? N_(\"assuming that the loop counter does not overflow\")\n-\t  : N_(\"cannot optimize loop, the loop counter may overflow\");\n+/* Like number_of_iterations_exit, but return TRUE only if the niter\n+   information holds unconditionally.  */\n \n-      warning_at ((LOCATION_LINE (loc) > 0) ? loc : input_location,\n-\t\t  OPT_Wunsafe_loop_optimizations, \"%s\", gettext (wording));\n-    }\n+bool\n+number_of_iterations_exit (struct loop *loop, edge exit,\n+\t\t\t   struct tree_niter_desc *niter,\n+\t\t\t   bool, bool every_iteration)\n+{\n+  if (!number_of_iterations_exit_assumptions (loop, exit, niter,\n+\t\t\t\t\t      every_iteration))\n+    return false;\n \n-  return flag_unsafe_loop_optimizations;\n+  return (integer_nonzerop (niter->assumptions));\n }\n \n /* Try to determine the number of iterations of LOOP.  If we succeed,"}, {"sha": "1aea5801d00d6f6a9f0c3533dd92eaff24641907", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43aabfcfd4139e4c9e7b868199e09b97e66010bc/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=43aabfcfd4139e4c9e7b868199e09b97e66010bc", "patch": "@@ -27,6 +27,9 @@ extern bool loop_only_exit_p (const struct loop *, const_edge);\n extern bool number_of_iterations_exit (struct loop *, edge,\n \t\t\t\t       struct tree_niter_desc *niter, bool,\n \t\t\t\t       bool every_iteration = true);\n+extern bool number_of_iterations_exit_assumptions (struct loop *, edge,\n+\t\t\t\t\t\t   struct tree_niter_desc *,\n+\t\t\t\t\t\t   bool = true);\n extern tree find_loop_niter (struct loop *, edge *);\n extern bool finite_loop_p (struct loop *);\n extern tree loop_niter_by_eval (struct loop *, edge);"}]}