{"sha": "f29876bba06c24d6fe543941ad6f683c61910555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5ODc2YmJhMDZjMjRkNmZlNTQzOTQxYWQ2ZjY4M2M2MTkxMDU1NQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-04-11T14:51:25Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-04-11T14:51:25Z"}, "message": "close.c: Fix white space in pointer declarations and comment formats where applicable.\n\n2017-04-11  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\t* close.c: Fix white space in pointer declarations and comment\n\tformats where applicable.\n\t* fbuf.c: Likewise.\n\t* fbuf.h: Likewise.\n\t* format.c: Likewise.\n\t* inquire.c: Likewise.\n\t* intrinsics.c: Likewise.\n\t* list_read.c: Likewise.\n\t* lock.c: Likewise.\n\t* open.c: Likewise.\n\t* read.c: Likewise.\n\t* transfer.c: Likewise.\n\t* unit.c: Likewise.\n\t* unix.c: Likewise.\n\t* unix.h: Likewise.\n\t* write.c: Likewise.\n\nFrom-SVN: r246842", "tree": {"sha": "b52db026d1acf63cb18d292be3b1d27c43f2d29b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b52db026d1acf63cb18d292be3b1d27c43f2d29b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f29876bba06c24d6fe543941ad6f683c61910555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29876bba06c24d6fe543941ad6f683c61910555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29876bba06c24d6fe543941ad6f683c61910555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29876bba06c24d6fe543941ad6f683c61910555/comments", "author": null, "committer": null, "parents": [{"sha": "276ebde7b1bfd430f747e21a2c8345e35fc4e622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/276ebde7b1bfd430f747e21a2c8345e35fc4e622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/276ebde7b1bfd430f747e21a2c8345e35fc4e622"}], "stats": {"total": 497, "additions": 258, "deletions": 239}, "files": [{"sha": "ad8d95c1b192f8dc1295dad83f4ac7a66f33afa7", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -1,3 +1,22 @@\n+2017-04-11  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\t* close.c: Fix white space in pointer declarations and comment\n+\tformats where applicable.\n+\t* fbuf.c: Likewise.\n+\t* fbuf.h: Likewise.\n+\t* format.c: Likewise.\n+\t* inquire.c: Likewise.\n+\t* intrinsics.c: Likewise.\n+\t* list_read.c: Likewise.\n+\t* lock.c: Likewise.\n+\t* open.c: Likewise.\n+\t* read.c: Likewise.\n+\t* transfer.c: Likewise.\n+\t* unit.c: Likewise.\n+\t* unix.c: Likewise.\n+\t* unix.h: Likewise.\n+\t* write.c: Likewise.\n+\n 2017-03-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/78670"}, {"sha": "e40fd92b8bf5046bddbf9dbb717839a06a4e4a8d", "filename": "libgfortran/io/close.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fclose.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -46,7 +46,7 @@ st_close (st_parameter_close *clp)\n   close_status status;\n   gfc_unit *u;\n #if !HAVE_UNLINK_OPEN_FILE\n-  char * path;\n+  char *path;\n \n   path = NULL;\n #endif"}, {"sha": "944469d8cecf4d3e82a46c1d3113c60509edfc09", "filename": "libgfortran/io/fbuf.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Ffbuf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Ffbuf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffbuf.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -33,7 +33,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n \n void\n-fbuf_init (gfc_unit * u, int len)\n+fbuf_init (gfc_unit *u, int len)\n {\n   if (len == 0)\n     len = 512;\t\t\t/* Default size.  */\n@@ -46,7 +46,7 @@ fbuf_init (gfc_unit * u, int len)\n \n \n void\n-fbuf_destroy (gfc_unit * u)\n+fbuf_destroy (gfc_unit *u)\n {\n   if (u->fbuf == NULL)\n     return;\n@@ -58,7 +58,7 @@ fbuf_destroy (gfc_unit * u)\n \n static void\n #ifdef FBUF_DEBUG\n-fbuf_debug (gfc_unit * u, const char * format, ...)\n+fbuf_debug (gfc_unit *u, const char *format, ...)\n {\n   va_list args;\n   va_start(args, format);\n@@ -73,8 +73,8 @@ fbuf_debug (gfc_unit * u, const char * format, ...)\n   fprintf (stderr, \"''\\n\");\n }\n #else\n-fbuf_debug (gfc_unit * u __attribute__ ((unused)),\n-            const char * format __attribute__ ((unused)),\n+fbuf_debug (gfc_unit *u __attribute__ ((unused)),\n+            const char *format __attribute__ ((unused)),\n             ...) {}\n #endif\n \n@@ -85,7 +85,7 @@ fbuf_debug (gfc_unit * u __attribute__ ((unused)),\n    modified.  */\n \n int\n-fbuf_reset (gfc_unit * u)\n+fbuf_reset (gfc_unit *u)\n {\n   int seekval = 0;\n \n@@ -111,15 +111,15 @@ fbuf_reset (gfc_unit * u)\n    reallocating if necessary.  */\n \n char *\n-fbuf_alloc (gfc_unit * u, int len)\n+fbuf_alloc (gfc_unit *u, int len)\n {\n   int newlen;\n   char *dest;\n   fbuf_debug (u, \"fbuf_alloc len %d, \", len);\n   if (u->fbuf->pos + len > u->fbuf->len)\n     {\n       /* Round up to nearest multiple of the current buffer length.  */\n-      newlen = ((u->fbuf->pos + len) / u->fbuf->len + 1) * u->fbuf->len;\n+      newlen = ((u->fbuf->pos + len) / u->fbuf->len + 1) *u->fbuf->len;\n       u->fbuf->buf = xrealloc (u->fbuf->buf, newlen);\n       u->fbuf->len = newlen;\n     }\n@@ -136,7 +136,7 @@ fbuf_alloc (gfc_unit * u, int len)\n    mode. Return value is 0 for success, -1 on failure.  */\n \n int\n-fbuf_flush (gfc_unit * u, unit_mode mode)\n+fbuf_flush (gfc_unit *u, unit_mode mode)\n {\n   int nwritten;\n \n@@ -175,7 +175,7 @@ fbuf_flush (gfc_unit * u, unit_mode mode)\n    Return value is 0 for success, -1 on failure.  */\n \n int\n-fbuf_flush_list (gfc_unit * u, unit_mode mode)\n+fbuf_flush_list (gfc_unit *u, unit_mode mode)\n {\n   int nwritten;\n \n@@ -207,7 +207,7 @@ fbuf_flush_list (gfc_unit * u, unit_mode mode)\n \n \n int\n-fbuf_seek (gfc_unit * u, int off, int whence)\n+fbuf_seek (gfc_unit *u, int off, int whence)\n {\n   if (!u->fbuf)\n     return -1;\n@@ -248,7 +248,7 @@ fbuf_seek (gfc_unit * u, int off, int whence)\n    of bytes actually processed. */\n \n char *\n-fbuf_read (gfc_unit * u, int * len)\n+fbuf_read (gfc_unit *u, int *len)\n {\n   char *ptr;\n   int oldact, oldpos;\n@@ -279,7 +279,7 @@ fbuf_read (gfc_unit * u, int * len)\n    reading. Never call this function directly.  */\n \n int\n-fbuf_getc_refill (gfc_unit * u)\n+fbuf_getc_refill (gfc_unit *u)\n {\n   int nread;\n   char *p;"}, {"sha": "a0c571338b437a103307c67a014c17671ae550ff", "filename": "libgfortran/io/fbuf.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Ffbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Ffbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffbuf.h?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -53,7 +53,7 @@ internal_proto(fbuf_destroy);\n extern int fbuf_reset (gfc_unit *);\n internal_proto(fbuf_reset);\n \n-extern char * fbuf_alloc (gfc_unit *, int);\n+extern char *fbuf_alloc (gfc_unit *, int);\n internal_proto(fbuf_alloc);\n \n extern int fbuf_flush (gfc_unit *, unit_mode);\n@@ -65,23 +65,23 @@ internal_proto(fbuf_flush_list);\n extern int fbuf_seek (gfc_unit *, int, int);\n internal_proto(fbuf_seek);\n \n-extern char * fbuf_read (gfc_unit *, int *);\n+extern char *fbuf_read (gfc_unit *, int *);\n internal_proto(fbuf_read);\n \n /* Never call this function, only use fbuf_getc().  */\n extern int fbuf_getc_refill (gfc_unit *);\n internal_proto(fbuf_getc_refill);\n \n static inline int\n-fbuf_getc (gfc_unit * u)\n+fbuf_getc (gfc_unit *u)\n {\n   if (u->fbuf->pos < u->fbuf->act)\n     return (unsigned char) u->fbuf->buf[u->fbuf->pos++];\n   return fbuf_getc_refill (u);\n }\n \n static inline char *\n-fbuf_getptr (gfc_unit * u)\n+fbuf_getptr (gfc_unit *u)\n {\n   return (char*) (u->fbuf->buf + u->fbuf->pos);\n }"}, {"sha": "bd14ac37bb3e15da30d1a654949b4f96adc1a366", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -25,7 +25,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n \n /* format.c-- parse a FORMAT string into a binary format suitable for\n- * interpretation during I/O statements */\n+   interpretation during I/O statements.  */\n \n #include \"io.h\"\n #include \"format.h\"\n@@ -179,8 +179,8 @@ find_parsed_format (st_parameter_dt *dtp)\n \n \n /* next_char()-- Return the next character in the format string.\n- * Returns -1 when the string is done.  If the literal flag is set,\n- * spaces are significant, otherwise they are not. */\n+   Returns -1 when the string is done.  If the literal flag is set,\n+   spaces are significant, otherwise they are not. */\n \n static int\n next_char (format_data *fmt, int literal)\n@@ -209,8 +209,8 @@ next_char (format_data *fmt, int literal)\n \n \n /* get_fnode()-- Allocate a new format node, inserting it into the\n- * current singly linked list.  These are initially allocated from the\n- * static buffer. */\n+   current singly linked list.  These are initially allocated from the\n+   static buffer. */\n \n static fnode *\n get_fnode (format_data *fmt, fnode **head, fnode **tail, format_token t)\n@@ -286,8 +286,8 @@ free_format_data (format_data *fmt)\n \n \n /* format_lex()-- Simple lexical analyzer for getting the next token\n- * in a FORMAT string.  We support a one-level token pushback in the\n- * fmt->saved_token variable. */\n+   in a FORMAT string.  We support a one-level token pushback in the\n+   fmt->saved_token variable. */\n \n static format_token\n format_lex (format_data *fmt)\n@@ -605,8 +605,8 @@ format_lex (format_data *fmt)\n \n \n /* parse_format_list()-- Parse a format list.  Assumes that a left\n- * paren has already been seen.  Returns a list representing the\n- * parenthesis node which contains the rest of the list. */\n+   paren has already been seen.  Returns a list representing the\n+   parenthesis node which contains the rest of the list. */\n \n static fnode *\n parse_format_list (st_parameter_dt *dtp, bool *seen_dd)\n@@ -1196,13 +1196,13 @@ parse_format_list (st_parameter_dt *dtp, bool *seen_dd)\n \n \n /* format_error()-- Generate an error message for a format statement.\n- * If the node that gives the location of the error is NULL, the error\n- * is assumed to happen at parse time, and the current location of the\n- * parser is shown.\n- *\n- * We generate a message showing where the problem is.  We take extra\n- * care to print only the relevant part of the format if it is longer\n- * than a standard 80 column display. */\n+   If the node that gives the location of the error is NULL, the error\n+   is assumed to happen at parse time, and the current location of the\n+   parser is shown.\n+\n+   We generate a message showing where the problem is.  We take extra\n+   care to print only the relevant part of the format if it is longer\n+   than a standard 80 column display. */\n \n void\n format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n@@ -1254,11 +1254,11 @@ format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n \n \n /* revert()-- Do reversion of the format.  Control reverts to the left\n- * parenthesis that matches the rightmost right parenthesis.  From our\n- * tree structure, we are looking for the rightmost parenthesis node\n- * at the second level, the first level always being a single\n- * parenthesis node.  If this node doesn't exit, we use the top\n- * level. */\n+   parenthesis that matches the rightmost right parenthesis.  From our\n+   tree structure, we are looking for the rightmost parenthesis node\n+   at the second level, the first level always being a single\n+   parenthesis node.  If this node doesn't exit, we use the top\n+   level. */\n \n static void\n revert (st_parameter_dt *dtp)\n@@ -1360,12 +1360,12 @@ parse_format (st_parameter_dt *dtp)\n \n \n /* next_format0()-- Get the next format node without worrying about\n- * reversion.  Returns NULL when we hit the end of the list.\n- * Parenthesis nodes are incremented after the list has been\n- * exhausted, other nodes are incremented before they are returned. */\n+   reversion.  Returns NULL when we hit the end of the list.\n+   Parenthesis nodes are incremented after the list has been\n+   exhausted, other nodes are incremented before they are returned. */\n \n static const fnode *\n-next_format0 (fnode * f)\n+next_format0 (fnode *f)\n {\n   const fnode *r;\n \n@@ -1418,11 +1418,11 @@ next_format0 (fnode * f)\n \n \n /* next_format()-- Return the next format node.  If the format list\n- * ends up being exhausted, we do reversion.  Reversion is only\n- * allowed if we've seen a data descriptor since the\n- * initialization or the last reversion.  We return NULL if there\n- * are no more data descriptors to return (which is an error\n- * condition). */\n+   ends up being exhausted, we do reversion.  Reversion is only\n+   allowed if we've seen a data descriptor since the\n+   initialization or the last reversion.  We return NULL if there\n+   are no more data descriptors to return (which is an error\n+   condition).  */\n \n const fnode *\n next_format (st_parameter_dt *dtp)\n@@ -1455,7 +1455,7 @@ next_format (st_parameter_dt *dtp)\n \t}\n \n       /* Push the first reverted token and return a colon node in case\n-       * there are no more data items. */\n+\t there are no more data items.  */\n \n       fmt->saved_format = f;\n       return &colon_node;\n@@ -1475,11 +1475,11 @@ next_format (st_parameter_dt *dtp)\n \n \n /* unget_format()-- Push the given format back so that it will be\n- * returned on the next call to next_format() without affecting\n- * counts.  This is necessary when we've encountered a data\n- * descriptor, but don't know what the data item is yet.  The format\n- * node is pushed back, and we return control to the main program,\n- * which calls the library back with the data item (or not). */\n+   returned on the next call to next_format() without affecting\n+   counts.  This is necessary when we've encountered a data\n+   descriptor, but don't know what the data item is yet.  The format\n+   node is pushed back, and we return control to the main program,\n+   which calls the library back with the data item (or not). */\n \n void\n unget_format (st_parameter_dt *dtp, const fnode *f)"}, {"sha": "4cf87d339a7f249cd042b1f409944842f58044f2", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -36,7 +36,7 @@ static const char yes[] = \"YES\", no[] = \"NO\", undefined[] = \"UNDEFINED\";\n /* inquire_via_unit()-- Inquiry via unit number.  The unit might not exist. */\n \n static void\n-inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n+inquire_via_unit (st_parameter_inquire *iqp, gfc_unit *u)\n {\n   const char *p;\n   GFC_INTEGER_4 cf = iqp->common.flags;\n@@ -631,7 +631,7 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n \n \n /* inquire_via_filename()-- Inquiry via filename.  This subroutine is\n- * only used if the filename is *not* connected to a unit number. */\n+   only used if the filename is *not* connected to a unit number. */\n \n static void\n inquire_via_filename (st_parameter_inquire *iqp)"}, {"sha": "adf489c2abd324da1bf3955f4367f95fdfff17d1", "filename": "libgfortran/io/intrinsics.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fintrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fintrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fintrinsics.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -36,10 +36,10 @@ extern int PREFIX(fgetc) (const int *, char *, gfc_charlen_type);\n export_proto_np(PREFIX(fgetc));\n \n int\n-PREFIX(fgetc) (const int * unit, char * c, gfc_charlen_type c_len)\n+PREFIX(fgetc) (const int *unit, char *c, gfc_charlen_type c_len)\n {\n   int ret;\n-  gfc_unit * u = find_unit (*unit);\n+  gfc_unit *u = find_unit (*unit);\n \n   if (u == NULL)\n     return -1;\n@@ -70,7 +70,7 @@ PREFIX(fgetc) (const int * unit, char * c, gfc_charlen_type c_len)\n     (const int *, char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n   export_proto(fgetc_i ## kind ## _sub); \\\n   void fgetc_i ## kind ## _sub \\\n-  (const int * unit, char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+  (const int *unit, char *c, GFC_INTEGER_ ## kind *st, gfc_charlen_type c_len) \\\n     { if (st != NULL) \\\n         *st = PREFIX(fgetc) (unit, c, c_len); \\\n       else \\\n@@ -86,7 +86,7 @@ extern int PREFIX(fget) (char *, gfc_charlen_type);\n export_proto_np(PREFIX(fget));\n \n int\n-PREFIX(fget) (char * c, gfc_charlen_type c_len)\n+PREFIX(fget) (char *c, gfc_charlen_type c_len)\n {\n   return PREFIX(fgetc) (&five, c, c_len);\n }\n@@ -97,7 +97,7 @@ PREFIX(fget) (char * c, gfc_charlen_type c_len)\n     (char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n   export_proto(fget_i ## kind ## _sub); \\\n   void fget_i ## kind ## _sub \\\n-  (char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+  (char *c, GFC_INTEGER_ ## kind *st, gfc_charlen_type c_len) \\\n     { if (st != NULL) \\\n         *st = PREFIX(fgetc) (&five, c, c_len); \\\n       else \\\n@@ -114,11 +114,11 @@ extern int PREFIX(fputc) (const int *, char *, gfc_charlen_type);\n export_proto_np(PREFIX(fputc));\n \n int\n-PREFIX(fputc) (const int * unit, char * c,\n+PREFIX(fputc) (const int *unit, char *c,\n \t       gfc_charlen_type c_len __attribute__((unused)))\n {\n   ssize_t s;\n-  gfc_unit * u = find_unit (*unit);\n+  gfc_unit *u = find_unit (*unit);\n \n   if (u == NULL)\n     return -1;\n@@ -143,7 +143,7 @@ PREFIX(fputc) (const int * unit, char * c,\n     (const int *, char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n   export_proto(fputc_i ## kind ## _sub); \\\n   void fputc_i ## kind ## _sub \\\n-  (const int * unit, char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+  (const int *unit, char *c, GFC_INTEGER_ ## kind *st, gfc_charlen_type c_len) \\\n     { if (st != NULL) \\\n         *st = PREFIX(fputc) (unit, c, c_len); \\\n       else \\\n@@ -159,7 +159,7 @@ extern int PREFIX(fput) (char *, gfc_charlen_type);\n export_proto_np(PREFIX(fput));\n \n int\n-PREFIX(fput) (char * c, gfc_charlen_type c_len)\n+PREFIX(fput) (char *c, gfc_charlen_type c_len)\n {\n   return PREFIX(fputc) (&six, c, c_len);\n }\n@@ -170,7 +170,7 @@ PREFIX(fput) (char * c, gfc_charlen_type c_len)\n     (char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n   export_proto(fput_i ## kind ## _sub); \\\n   void fput_i ## kind ## _sub \\\n-  (char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+  (char *c, GFC_INTEGER_ ## kind *st, gfc_charlen_type c_len) \\\n     { if (st != NULL) \\\n         *st = PREFIX(fputc) (&six, c, c_len); \\\n       else \\\n@@ -236,9 +236,9 @@ extern void fseek_sub (int *, GFC_IO_INT *, int *, int *);\n export_proto(fseek_sub);\n \n void\n-fseek_sub (int * unit, GFC_IO_INT * offset, int * whence, int * status)\n+fseek_sub (int *unit, GFC_IO_INT *offset, int *whence, int *status)\n {\n-  gfc_unit * u = find_unit (*unit);\n+  gfc_unit *u = find_unit (*unit);\n   ssize_t result = -1;\n \n   if (u != NULL)\n@@ -259,7 +259,7 @@ fseek_sub (int * unit, GFC_IO_INT * offset, int * whence, int * status)\n static gfc_offset\n gf_ftell (int unit)\n {\n-  gfc_unit * u = find_unit (unit);\n+  gfc_unit *u = find_unit (unit);\n   if (u == NULL)\n     return -1;\n   int pos = fbuf_reset (u);\n@@ -275,7 +275,7 @@ extern GFC_IO_INT PREFIX(ftell) (int *);\n export_proto_np(PREFIX(ftell));\n \n GFC_IO_INT\n-PREFIX(ftell) (int * unit)\n+PREFIX(ftell) (int *unit)\n {\n   return gf_ftell (*unit);\n }\n@@ -285,7 +285,7 @@ PREFIX(ftell) (int * unit)\n   extern void ftell_i ## kind ## _sub (int *, GFC_INTEGER_ ## kind *); \\\n   export_proto(ftell_i ## kind ## _sub); \\\n   void \\\n-  ftell_i ## kind ## _sub (int * unit, GFC_INTEGER_ ## kind * offset) \\\n+  ftell_i ## kind ## _sub (int *unit, GFC_INTEGER_ ## kind *offset) \\\n   { \\\n     *offset = gf_ftell (*unit);\t\t\t\\\n   }\n@@ -346,7 +346,7 @@ extern void ttynam_sub (int *, char *, gfc_charlen_type);\n export_proto(ttynam_sub);\n \n void\n-ttynam_sub (int *unit, char * name, gfc_charlen_type name_len)\n+ttynam_sub (int *unit, char *name, gfc_charlen_type name_len)\n {\n   gfc_unit *u;\n   int nlen;\n@@ -373,7 +373,7 @@ extern void ttynam (char **, gfc_charlen_type *, int);\n export_proto(ttynam);\n \n void\n-ttynam (char ** name, gfc_charlen_type * name_len, int unit)\n+ttynam (char **name, gfc_charlen_type *name_len, int unit)\n {\n   gfc_unit *u;\n "}, {"sha": "9175a6bb677f3f2c7fd7992a225ed4eb7cf8eb9d", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -1506,7 +1506,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n    what it is right away.  */\n \n static void\n-read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n+read_complex (st_parameter_dt *dtp, void *dest, int kind, size_t size)\n {\n   char message[MSGLEN];\n   int c;\n@@ -1615,7 +1615,7 @@ read_complex (st_parameter_dt *dtp, void * dest, int kind, size_t size)\n /* Parse a real number with a possible repeat count.  */\n \n static void\n-read_real (st_parameter_dt *dtp, void * dest, int length)\n+read_real (st_parameter_dt *dtp, void *dest, int length)\n {\n   char message[MSGLEN];\n   int c;\n@@ -2382,11 +2382,11 @@ void namelist_read (st_parameter_dt *dtp)\n \t\t\t\tnamelist_info **prev_nl, char *, size_t)\n calls:\n       static void nml_untouch_nodes (st_parameter_dt *dtp)\n-      static namelist_info * find_nml_node (st_parameter_dt *dtp,\n-\t\t\t\t\t    char * var_name)\n-      static int nml_parse_qualifier(descriptor_dimension * ad,\n-\t\t\t\t     array_loop_spec * ls, int rank, char *)\n-      static void nml_touch_nodes (namelist_info * nl)\n+      static namelist_info *find_nml_node (st_parameter_dt *dtp,\n+\t\t\t\t\t   char *var_name)\n+      static int nml_parse_qualifier(descriptor_dimension *ad,\n+\t\t\t\t     array_loop_spec *ls, int rank, char *)\n+      static void nml_touch_nodes (namelist_info *nl)\n       static int nml_read_obj (namelist_info *nl, index_type offset,\n \t\t\t       namelist_info **prev_nl, char *, size_t,\n \t\t\t       index_type clow, index_type chigh)\n@@ -2671,9 +2671,9 @@ strcmp_extended_type (char *p, char *q)\n \n \n static namelist_info *\n-find_nml_node (st_parameter_dt *dtp, char * var_name)\n+find_nml_node (st_parameter_dt *dtp, char *var_name)\n {\n-  namelist_info * t = dtp->u.p.ionml;\n+  namelist_info *t = dtp->u.p.ionml;\n   while (t != NULL)\n     {\n       if (strcmp (var_name, t->var_name) == 0)\n@@ -2697,11 +2697,11 @@ find_nml_node (st_parameter_dt *dtp, char * var_name)\n    to default values  */\n \n static void\n-nml_touch_nodes (namelist_info * nl)\n+nml_touch_nodes (namelist_info *nl)\n {\n   index_type len = strlen (nl->var_name) + 1;\n   int dim;\n-  char * ext_name = xmalloc (len + 1);\n+  char *ext_name = xmalloc (len + 1);\n   memcpy (ext_name, nl->var_name, len-1);\n   memcpy (ext_name + len - 1, \"%\", 2);\n   for (nl = nl->next; nl; nl = nl->next)\n@@ -2730,7 +2730,7 @@ nml_touch_nodes (namelist_info * nl)\n static void\n nml_untouch_nodes (st_parameter_dt *dtp)\n {\n-  namelist_info * t;\n+  namelist_info *t;\n   for (t = dtp->u.p.ionml; t; t = t->next)\n     t->touched = 0;\n   return;\n@@ -2765,10 +2765,10 @@ nml_match_name (st_parameter_dt *dtp, const char *name, index_type len)\n static void\n nml_query (st_parameter_dt *dtp, char c)\n {\n-  gfc_unit * temp_unit;\n-  namelist_info * nl;\n+  gfc_unit *temp_unit;\n+  namelist_info *nl;\n   index_type len;\n-  char * p;\n+  char *p;\n #ifdef HAVE_CRLF\n   static const index_type endlen = 2;\n   static const char endl[] = \"\\r\\n\";\n@@ -2858,19 +2858,19 @@ nml_query (st_parameter_dt *dtp, char c)\n    error.  */\n \n static bool\n-nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n+nml_read_obj (st_parameter_dt *dtp, namelist_info *nl, index_type offset,\n \t      namelist_info **pprev_nl, char *nml_err_msg,\n \t      size_t nml_err_msg_size, index_type clow, index_type chigh)\n {\n-  namelist_info * cmp;\n-  char * obj_name;\n+  namelist_info *cmp;\n+  char *obj_name;\n   int nml_carry;\n   int len;\n   int dim;\n   index_type dlen;\n   index_type m;\n   size_t obj_name_len;\n-  void * pdata;\n+  void *pdata;\n \n   /* If we have encountered a previous read error or this object has not been\n      touched in name parsing, just return.  */\n@@ -3191,9 +3191,9 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \t\t  char *nml_err_msg, size_t nml_err_msg_size)\n {\n   int c;\n-  namelist_info * nl;\n-  namelist_info * first_nl = NULL;\n-  namelist_info * root_nl = NULL;\n+  namelist_info *nl;\n+  namelist_info *first_nl = NULL;\n+  namelist_info *root_nl = NULL;\n   int dim, parsed_rank;\n   int component_flag, qualifier_flag;\n   index_type clow, chigh;"}, {"sha": "8df7e7b349575077db7b93fc2d5a2d00351d2d87", "filename": "libgfortran/io/lock.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flock.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -41,7 +41,7 @@ library_start (st_parameter_common *cmp)\n void\n free_ionml (st_parameter_dt *dtp)\n {\n-  namelist_info * t1, *t2;\n+  namelist_info *t1, *t2;\n \n   /* Delete the namelist, if it exists.  */\n "}, {"sha": "9d3988a7c2180b8f11e1306a0c12d46e73567fd9", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -168,7 +168,7 @@ static const st_option async_opt[] =\n    AT_ENDFILE.  */\n \n static void\n-test_endfile (gfc_unit * u)\n+test_endfile (gfc_unit *u)\n {\n   if (u->endfile == NO_ENDFILE)\n     { \n@@ -183,7 +183,7 @@ test_endfile (gfc_unit * u)\n    changed.  */\n \n static void\n-edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n+edit_modes (st_parameter_open *opp, gfc_unit *u, unit_flags *flags)\n {\n   /* Complain about attempts to change the unchangeable.  */\n \n@@ -329,7 +329,7 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n /* Open an unused unit.  */\n \n gfc_unit *\n-new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n+new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags *flags)\n {\n   gfc_unit *u2;\n   stream *s;\n@@ -671,7 +671,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n    modes or closing what is there now and opening the new file.  */\n \n static void\n-already_open (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n+already_open (st_parameter_open *opp, gfc_unit *u, unit_flags *flags)\n {\n   if ((opp->common.flags & IOPARM_OPEN_HAS_FILE) == 0)\n     {"}, {"sha": "9eb21968079f2bd2e0a68453fd3e418190aa9126", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -565,7 +565,7 @@ read_a_char4 (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n }\n \n /* eat_leading_spaces()-- Given a character pointer and a width,\n- * ignore the leading spaces.  */\n+   ignore the leading spaces.  */\n \n static char *\n eat_leading_spaces (int *width, char *p)\n@@ -617,7 +617,7 @@ next_char (st_parameter_dt *dtp, char **p, int *w)\n \n \n /* read_decimal()-- Read a decimal integer value.  The values here are\n- * signed values. */\n+   signed values. */\n \n void\n read_decimal (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n@@ -722,9 +722,9 @@ read_decimal (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n \n \n /* read_radix()-- This function reads values for non-decimal radixes.\n- * The difference here is that we treat the values here as unsigned\n- * values for the purposes of overflow.  If minus sign is present and\n- * the top bit is set, the value will be incorrect. */\n+   The difference here is that we treat the values here as unsigned\n+   values for the purposes of overflow.  If minus sign is present and\n+   the top bit is set, the value will be incorrect. */\n \n void\n read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n@@ -1227,7 +1227,7 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n \n \n /* read_x()-- Deal with the X/TR descriptor.  We just read some data\n- * and never look at it. */\n+   and never look at it. */\n \n void\n read_x (st_parameter_dt *dtp, int n)"}, {"sha": "f16d8c55f6d01d130d2f87d10bf6c87a2e845ed6", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -223,7 +223,7 @@ current_mode (st_parameter_dt *dtp)\n /* Read sequential file - internal unit  */\n \n static char *\n-read_sf_internal (st_parameter_dt *dtp, int * length)\n+read_sf_internal (st_parameter_dt *dtp, int *length)\n {\n   static char *empty_string[0];\n   char *base = NULL;\n@@ -303,7 +303,7 @@ read_sf_internal (st_parameter_dt *dtp, int * length)\n /* Read sequential file - external unit */\n \n static char *\n-read_sf (st_parameter_dt *dtp, int * length)\n+read_sf (st_parameter_dt *dtp, int *length)\n {\n   static char *empty_string[0];\n   int q, q2;\n@@ -445,7 +445,7 @@ read_sf (st_parameter_dt *dtp, int * length)\n    short reads.  */\n \n void *\n-read_block_form (st_parameter_dt *dtp, int * nbytes)\n+read_block_form (st_parameter_dt *dtp, int *nbytes)\n {\n   char *source;\n   int norig;\n@@ -527,7 +527,7 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n    a character(kind=4) variable.  Note: Portions of this code borrowed from\n    read_sf_internal.  */\n void *\n-read_block_form4 (st_parameter_dt *dtp, int * nbytes)\n+read_block_form4 (st_parameter_dt *dtp, int *nbytes)\n {\n   static gfc_char4_t *empty_string[0];\n   gfc_char4_t *source;\n@@ -3584,7 +3584,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n    value is same as for POSIX write().  */\n \n static ssize_t\n-sset (stream * s, int c, ssize_t nbyte)\n+sset (stream *s, int c, ssize_t nbyte)\n {\n #define WRITE_CHUNK 256\n   char p[WRITE_CHUNK];\n@@ -3622,7 +3622,7 @@ next_record_cc (st_parameter_dt *dtp)\n   fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n   if (dtp->u.p.cc.len > 0)\n     {\n-      char * p = fbuf_alloc (dtp->u.p.current_unit, dtp->u.p.cc.len);\n+      char *p = fbuf_alloc (dtp->u.p.current_unit, dtp->u.p.cc.len);\n       if (!p)\n \tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n \n@@ -3795,7 +3795,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t  fbuf_seek (dtp->u.p.current_unit, 0, SEEK_END);\n \t  if (dtp->u.p.current_unit->flags.cc != CC_NONE)\n \t    {\n-\t      char * p = fbuf_alloc (dtp->u.p.current_unit, len);\n+\t      char *p = fbuf_alloc (dtp->u.p.current_unit, len);\n \t      if (!p)\n \t\tgoto io_error;\n #ifdef HAVE_CRLF\n@@ -4182,7 +4182,7 @@ st_wait (st_parameter_wait *wtp __attribute__((unused)))\n    in a linked list of namelist_info types.  */\n \n static void\n-set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n+set_nml_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n \t     GFC_INTEGER_4 len, gfc_charlen_type string_length,\n \t     GFC_INTEGER_4 dtype, void *dtio_sub, void *vtable)\n {\n@@ -4239,7 +4239,7 @@ extern void st_set_nml_var (st_parameter_dt *dtp, void *, char *,\n export_proto(st_set_nml_var);\n \n void\n-st_set_nml_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n+st_set_nml_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n \t\tGFC_INTEGER_4 len, gfc_charlen_type string_length,\n \t\tGFC_INTEGER_4 dtype)\n {\n@@ -4257,7 +4257,7 @@ export_proto(st_set_nml_dtio_var);\n \n \n void\n-st_set_nml_dtio_var (st_parameter_dt *dtp, void * var_addr, char * var_name,\n+st_set_nml_dtio_var (st_parameter_dt *dtp, void *var_addr, char *var_name,\n \t\t     GFC_INTEGER_4 len, gfc_charlen_type string_length,\n \t\t     GFC_INTEGER_4 dtype, void *dtio_sub, void *vtable)\n {\n@@ -4276,7 +4276,7 @@ st_set_nml_var_dim (st_parameter_dt *dtp, GFC_INTEGER_4 n_dim,\n \t\t    index_type stride, index_type lbound,\n \t\t    index_type ubound)\n {\n-  namelist_info * nml;\n+  namelist_info *nml;\n   int n;\n \n   n = (int)n_dim;\n@@ -4295,7 +4295,7 @@ st_set_nml_var_dim (st_parameter_dt *dtp, GFC_INTEGER_4 n_dim,\n    9.10.2 in F2003.  */\n \n void\n-hit_eof (st_parameter_dt * dtp)\n+hit_eof (st_parameter_dt *dtp)\n {\n   dtp->u.p.current_unit->flags.position = POSITION_APPEND;\n "}, {"sha": "bcc1e37e2e30a39a01ea1c5c79a16104904245e6", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -141,11 +141,11 @@ __gthread_mutex_t old_locale_lock;\n \n \n /* This implementation is based on Stefan Nilsson's article in the\n- * July 1997 Doctor Dobb's Journal, \"Treaps in Java\". */\n+   July 1997 Doctor Dobb's Journal, \"Treaps in Java\". */\n \n /* pseudo_random()-- Simple linear congruential pseudorandom number\n- * generator.  The period of this generator is 44071, which is plenty\n- * for our purposes.  */\n+   generator.  The period of this generator is 44071, which is plenty\n+   for our purposes.  */\n \n static int\n pseudo_random (void)\n@@ -160,7 +160,7 @@ pseudo_random (void)\n /* rotate_left()-- Rotate the treap left */\n \n static gfc_unit *\n-rotate_left (gfc_unit * t)\n+rotate_left (gfc_unit *t)\n {\n   gfc_unit *temp;\n \n@@ -175,7 +175,7 @@ rotate_left (gfc_unit * t)\n /* rotate_right()-- Rotate the treap right */\n \n static gfc_unit *\n-rotate_right (gfc_unit * t)\n+rotate_right (gfc_unit *t)\n {\n   gfc_unit *temp;\n \n@@ -257,15 +257,15 @@ insert_unit (int n)\n /* destroy_unit_mutex()-- Destroy the mutex and free memory of unit.  */\n \n static void\n-destroy_unit_mutex (gfc_unit * u)\n+destroy_unit_mutex (gfc_unit *u)\n {\n   __gthread_mutex_destroy (&u->lock);\n   free (u);\n }\n \n \n static gfc_unit *\n-delete_root (gfc_unit * t)\n+delete_root (gfc_unit *t)\n {\n   gfc_unit *temp;\n \n@@ -290,12 +290,12 @@ delete_root (gfc_unit * t)\n \n \n /* delete_treap()-- Delete an element from a tree.  The 'old' value\n- * does not necessarily have to point to the element to be deleted, it\n- * must just point to a treap structure with the key to be deleted.\n- * Returns the new root node of the tree. */\n+   does not necessarily have to point to the element to be deleted, it\n+   must just point to a treap structure with the key to be deleted.\n+   Returns the new root node of the tree. */\n \n static gfc_unit *\n-delete_treap (gfc_unit * old, gfc_unit * t)\n+delete_treap (gfc_unit *old, gfc_unit *t)\n {\n   int c;\n \n@@ -318,15 +318,15 @@ delete_treap (gfc_unit * old, gfc_unit * t)\n /* delete_unit()-- Delete a unit from a tree */\n \n static void\n-delete_unit (gfc_unit * old)\n+delete_unit (gfc_unit *old)\n {\n   unit_root = delete_treap (old, unit_root);\n }\n \n \n /* get_gfc_unit()-- Given an integer, return a pointer to the unit\n- * structure.  Returns NULL if the unit does not exist,\n- * otherwise returns a locked unit. */\n+   structure.  Returns NULL if the unit does not exist,\n+   otherwise returns a locked unit. */\n \n static gfc_unit *\n get_gfc_unit (int n, int do_create)\n@@ -560,7 +560,7 @@ stash_internal_unit (st_parameter_dt *dtp)\n gfc_unit *\n get_unit (st_parameter_dt *dtp, int do_create)\n {\n-  gfc_unit * unit;\n+  gfc_unit *unit;\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_INTERNAL_UNIT) != 0)\n     {\n@@ -852,7 +852,7 @@ close_units (void)\n    ftruncate, returns 0 on success, -1 on failure.  */\n \n int\n-unit_truncate (gfc_unit * u, gfc_offset pos, st_parameter_common * common)\n+unit_truncate (gfc_unit *u, gfc_offset pos, st_parameter_common *common)\n {\n   int ret;\n "}, {"sha": "c76b427387addfe588d952d7152f4cc7e3a2e2af", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -212,11 +212,11 @@ unix_stream;\n \n \n /* fix_fd()-- Given a file descriptor, make sure it is not one of the\n- * standard descriptors, returning a non-standard descriptor.  If the\n- * user specifies that system errors should go to standard output,\n- * then closes standard output, we don't want the system errors to a\n- * file that has been given file descriptor 1 or 0.  We want to send\n- * the error to the invalid descriptor. */\n+   standard descriptors, returning a non-standard descriptor.  If the\n+   user specifies that system errors should go to standard output,\n+   then closes standard output, we don't want the system errors to a\n+   file that has been given file descriptor 1 or 0.  We want to send\n+   the error to the invalid descriptor. */\n \n static int\n fix_fd (int fd)\n@@ -260,7 +260,7 @@ fix_fd (int fd)\n    corresponding C stream.  This is bugware for mixed C-Fortran codes\n    where the C code doesn't flush I/O before returning.  */\n void\n-flush_if_preconnected (stream * s)\n+flush_if_preconnected (stream *s)\n {\n   int fd;\n \n@@ -287,13 +287,13 @@ than size_t as for POSIX read/write.\n *********************************************************************/\n \n static int\n-raw_flush (unix_stream * s  __attribute__ ((unused)))\n+raw_flush (unix_stream *s  __attribute__ ((unused)))\n {\n   return 0;\n }\n \n static ssize_t\n-raw_read (unix_stream * s, void * buf, ssize_t nbyte)\n+raw_read (unix_stream *s, void *buf, ssize_t nbyte)\n {\n   /* For read we can't do I/O in a loop like raw_write does, because\n      that will break applications that wait for interactive I/O.  We\n@@ -308,7 +308,7 @@ raw_read (unix_stream * s, void * buf, ssize_t nbyte)\n }\n \n static ssize_t\n-raw_write (unix_stream * s, const void * buf, ssize_t nbyte)\n+raw_write (unix_stream *s, const void *buf, ssize_t nbyte)\n {\n   ssize_t trans, bytes_left;\n   char *buf_st;\n@@ -336,7 +336,7 @@ raw_write (unix_stream * s, const void * buf, ssize_t nbyte)\n }\n \n static gfc_offset\n-raw_seek (unix_stream * s, gfc_offset offset, int whence)\n+raw_seek (unix_stream *s, gfc_offset offset, int whence)\n {\n   while (true)\n     {\n@@ -348,7 +348,7 @@ raw_seek (unix_stream * s, gfc_offset offset, int whence)\n }\n \n static gfc_offset\n-raw_tell (unix_stream * s)\n+raw_tell (unix_stream *s)\n {\n   while (true)\n     {\n@@ -360,7 +360,7 @@ raw_tell (unix_stream * s)\n }\n \n static gfc_offset\n-raw_size (unix_stream * s)\n+raw_size (unix_stream *s)\n {\n   struct stat statbuf;\n   if (TEMP_FAILURE_RETRY (fstat (s->fd, &statbuf)) == -1)\n@@ -372,7 +372,7 @@ raw_size (unix_stream * s)\n }\n \n static int\n-raw_truncate (unix_stream * s, gfc_offset length)\n+raw_truncate (unix_stream *s, gfc_offset length)\n {\n #ifdef __MINGW32__\n   HANDLE h;\n@@ -418,7 +418,7 @@ raw_truncate (unix_stream * s, gfc_offset length)\n }\n \n static int\n-raw_close (unix_stream * s)\n+raw_close (unix_stream *s)\n {\n   int retval;\n   \n@@ -445,7 +445,7 @@ raw_close (unix_stream * s)\n }\n \n static int\n-raw_markeor (unix_stream * s __attribute__ ((unused)))\n+raw_markeor (unix_stream *s __attribute__ ((unused)))\n {\n   return 0;\n }\n@@ -463,7 +463,7 @@ static const struct stream_vtable raw_vtable = {\n };\n \n static int\n-raw_init (unix_stream * s)\n+raw_init (unix_stream *s)\n {\n   s->st.vptr = &raw_vtable;\n \n@@ -480,7 +480,7 @@ reading to writing and vice versa.\n *********************************************************************/\n \n static int\n-buf_flush (unix_stream * s)\n+buf_flush (unix_stream *s)\n {\n   int writelen;\n \n@@ -509,7 +509,7 @@ buf_flush (unix_stream * s)\n }\n \n static ssize_t\n-buf_read (unix_stream * s, void * buf, ssize_t nbyte)\n+buf_read (unix_stream *s, void *buf, ssize_t nbyte)\n {\n   if (s->active == 0)\n     s->buffer_offset = s->logical_offset;\n@@ -580,7 +580,7 @@ buf_read (unix_stream * s, void * buf, ssize_t nbyte)\n }\n \n static ssize_t\n-buf_write (unix_stream * s, const void * buf, ssize_t nbyte)\n+buf_write (unix_stream *s, const void *buf, ssize_t nbyte)\n {\n   if (s->ndirty == 0)\n     s->buffer_offset = s->logical_offset;\n@@ -640,15 +640,15 @@ buf_write (unix_stream * s, const void * buf, ssize_t nbyte)\n    when writing sequential unformatted.  */\n \n static int\n-buf_markeor (unix_stream * s)\n+buf_markeor (unix_stream *s)\n {\n   if (s->unbuffered || s->ndirty >= BUFFER_SIZE / 2)\n     return buf_flush (s);\n   return 0;\n }\n \n static gfc_offset\n-buf_seek (unix_stream * s, gfc_offset offset, int whence)\n+buf_seek (unix_stream *s, gfc_offset offset, int whence)\n {\n   switch (whence)\n     {\n@@ -673,19 +673,19 @@ buf_seek (unix_stream * s, gfc_offset offset, int whence)\n }\n \n static gfc_offset\n-buf_tell (unix_stream * s)\n+buf_tell (unix_stream *s)\n {\n   return buf_seek (s, 0, SEEK_CUR);\n }\n \n static gfc_offset\n-buf_size (unix_stream * s)\n+buf_size (unix_stream *s)\n {\n   return s->file_length;\n }\n \n static int\n-buf_truncate (unix_stream * s, gfc_offset length)\n+buf_truncate (unix_stream *s, gfc_offset length)\n {\n   int r;\n \n@@ -698,7 +698,7 @@ buf_truncate (unix_stream * s, gfc_offset length)\n }\n \n static int\n-buf_close (unix_stream * s)\n+buf_close (unix_stream *s)\n {\n   if (buf_flush (s) != 0)\n     return -1;\n@@ -719,7 +719,7 @@ static const struct stream_vtable buf_vtable = {\n };\n \n static int\n-buf_init (unix_stream * s)\n+buf_init (unix_stream *s)\n {\n   s->st.vptr = &buf_vtable;\n \n@@ -739,9 +739,9 @@ buf_init (unix_stream * s)\n *********************************************************************/\n \n char *\n-mem_alloc_r (stream * strm, int * len)\n+mem_alloc_r (stream *strm, int *len)\n {\n-  unix_stream * s = (unix_stream *) strm;\n+  unix_stream *s = (unix_stream *) strm;\n   gfc_offset n;\n   gfc_offset where = s->logical_offset;\n \n@@ -759,9 +759,9 @@ mem_alloc_r (stream * strm, int * len)\n \n \n char *\n-mem_alloc_r4 (stream * strm, int * len)\n+mem_alloc_r4 (stream *strm, int *len)\n {\n-  unix_stream * s = (unix_stream *) strm;\n+  unix_stream *s = (unix_stream *) strm;\n   gfc_offset n;\n   gfc_offset where = s->logical_offset;\n \n@@ -779,9 +779,9 @@ mem_alloc_r4 (stream * strm, int * len)\n \n \n char *\n-mem_alloc_w (stream * strm, int * len)\n+mem_alloc_w (stream *strm, int *len)\n {\n-  unix_stream * s = (unix_stream *) strm;\n+  unix_stream *s = (unix_stream *)strm;\n   gfc_offset m;\n   gfc_offset where = s->logical_offset;\n \n@@ -800,9 +800,9 @@ mem_alloc_w (stream * strm, int * len)\n \n \n gfc_char4_t *\n-mem_alloc_w4 (stream * strm, int * len)\n+mem_alloc_w4 (stream *strm, int *len)\n {\n-  unix_stream * s = (unix_stream *) strm;\n+  unix_stream *s = (unix_stream *)strm;\n   gfc_offset m;\n   gfc_offset where = s->logical_offset;\n   gfc_char4_t *result = (gfc_char4_t *) s->buffer;\n@@ -823,7 +823,7 @@ mem_alloc_w4 (stream * strm, int * len)\n /* Stream read function for character(kind=1) internal units.  */\n \n static ssize_t\n-mem_read (stream * s, void * buf, ssize_t nbytes)\n+mem_read (stream *s, void *buf, ssize_t nbytes)\n {\n   void *p;\n   int nb = nbytes;\n@@ -842,7 +842,7 @@ mem_read (stream * s, void * buf, ssize_t nbytes)\n /* Stream read function for chracter(kind=4) internal units.  */\n \n static ssize_t\n-mem_read4 (stream * s, void * buf, ssize_t nbytes)\n+mem_read4 (stream *s, void *buf, ssize_t nbytes)\n {\n   void *p;\n   int nb = nbytes;\n@@ -861,7 +861,7 @@ mem_read4 (stream * s, void * buf, ssize_t nbytes)\n /* Stream write function for character(kind=1) internal units.  */\n \n static ssize_t\n-mem_write (stream * s, const void * buf, ssize_t nbytes)\n+mem_write (stream *s, const void *buf, ssize_t nbytes)\n {\n   void *p;\n   int nb = nbytes;\n@@ -880,7 +880,7 @@ mem_write (stream * s, const void * buf, ssize_t nbytes)\n /* Stream write function for character(kind=4) internal units.  */\n \n static ssize_t\n-mem_write4 (stream * s, const void * buf, ssize_t nwords)\n+mem_write4 (stream *s, const void *buf, ssize_t nwords)\n {\n   gfc_char4_t *p;\n   int nw = nwords;\n@@ -898,9 +898,9 @@ mem_write4 (stream * s, const void * buf, ssize_t nwords)\n \n \n static gfc_offset\n-mem_seek (stream * strm, gfc_offset offset, int whence)\n+mem_seek (stream *strm, gfc_offset offset, int whence)\n {\n-  unix_stream * s = (unix_stream *) strm;\n+  unix_stream *s = (unix_stream *)strm;\n   switch (whence)\n     {\n     case SEEK_SET:\n@@ -935,29 +935,29 @@ mem_seek (stream * strm, gfc_offset offset, int whence)\n \n \n static gfc_offset\n-mem_tell (stream * s)\n+mem_tell (stream *s)\n {\n   return ((unix_stream *)s)->logical_offset;\n }\n \n \n static int\n-mem_truncate (unix_stream * s __attribute__ ((unused)), \n+mem_truncate (unix_stream *s __attribute__ ((unused)), \n \t      gfc_offset length __attribute__ ((unused)))\n {\n   return 0;\n }\n \n \n static int\n-mem_flush (unix_stream * s __attribute__ ((unused)))\n+mem_flush (unix_stream *s __attribute__ ((unused)))\n {\n   return 0;\n }\n \n \n static int\n-mem_close (unix_stream * s)\n+mem_close (unix_stream *s)\n {\n   free (s);\n \n@@ -1034,12 +1034,12 @@ open_internal4 (char *base, int length, gfc_offset offset)\n \n   s->st.vptr = &mem4_vtable;\n \n-  return (stream *) s;\n+  return (stream *)s;\n }\n \n \n /* fd_to_stream()-- Given an open file descriptor, build a stream\n- * around it. */\n+   around it. */\n \n static stream *\n fd_to_stream (int fd, bool unformatted)\n@@ -1150,7 +1150,7 @@ tempfile_open (const char *tempdir, char **fname)\n     slash = \"\";\n \n   /* Take care that the template is longer in the mktemp() branch.  */\n-  char * template = xmalloc (tempdirlen + 23);\n+  char *template = xmalloc (tempdirlen + 23);\n \n #ifdef HAVE_MKSTEMP\n   snprintf (template, tempdirlen + 23, \"%s%sgfortrantmpXXXXXX\", \n@@ -1220,11 +1220,11 @@ tempfile_open (const char *tempdir, char **fname)\n \n \n /* tempfile()-- Generate a temporary filename for a scratch file and\n- * open it.  mkstemp() opens the file for reading and writing, but the\n- * library mode prevents anything that is not allowed.  The descriptor\n- * is returned, which is -1 on error.  The template is pointed to by \n- * opp->file, which is copied into the unit structure\n- * and freed later. */\n+   open it.  mkstemp() opens the file for reading and writing, but the\n+   library mode prevents anything that is not allowed.  The descriptor\n+   is returned, which is -1 on error.  The template is pointed to by \n+   opp->file, which is copied into the unit structure\n+   and freed later. */\n \n static int\n tempfile (st_parameter_open *opp)\n@@ -1273,9 +1273,9 @@ tempfile (st_parameter_open *opp)\n \n \n /* regular_file2()-- Open a regular file.\n- * Change flags->action if it is ACTION_UNSPECIFIED on entry,\n- * unless an error occurs.\n- * Returns the descriptor, which is less than zero on error. */\n+   Change flags->action if it is ACTION_UNSPECIFIED on entry,\n+   unless an error occurs.\n+   Returns the descriptor, which is less than zero on error. */\n \n static int\n regular_file2 (const char *path, st_parameter_open *opp, unit_flags *flags)\n@@ -1486,8 +1486,8 @@ regular_file (st_parameter_open *opp, unit_flags *flags)\n }\n \n /* open_external()-- Open an external file, unix specific version.\n- * Change flags->action if it is ACTION_UNSPECIFIED on entry.\n- * Returns NULL on operating system error. */\n+   Change flags->action if it is ACTION_UNSPECIFIED on entry.\n+   Returns NULL on operating system error. */\n \n stream *\n open_external (st_parameter_open *opp, unit_flags *flags)\n@@ -1509,7 +1509,7 @@ open_external (st_parameter_open *opp, unit_flags *flags)\n   else\n     {\n       /* regular_file resets flags->action if it is ACTION_UNSPECIFIED and\n-       * if it succeeds */\n+         if it succeeds */\n       fd = regular_file (opp, flags);\n #ifndef O_CLOEXEC\n       set_close_on_exec (fd);\n@@ -1528,7 +1528,7 @@ open_external (st_parameter_open *opp, unit_flags *flags)\n \n \n /* input_stream()-- Return a stream pointer to the default input stream.\n- * Called on initialization. */\n+   Called on initialization. */\n \n stream *\n input_stream (void)\n@@ -1538,12 +1538,12 @@ input_stream (void)\n \n \n /* output_stream()-- Return a stream pointer to the default output stream.\n- * Called on initialization. */\n+   Called on initialization. */\n \n stream *\n output_stream (void)\n {\n-  stream * s;\n+  stream *s;\n \n #if defined(HAVE_CRLF) && defined(HAVE_SETMODE)\n   setmode (STDOUT_FILENO, O_BINARY);\n@@ -1555,12 +1555,12 @@ output_stream (void)\n \n \n /* error_stream()-- Return a stream pointer to the default error stream.\n- * Called on initialization. */\n+   Called on initialization. */\n \n stream *\n error_stream (void)\n {\n-  stream * s;\n+  stream *s;\n \n #if defined(HAVE_CRLF) && defined(HAVE_SETMODE)\n   setmode (STDERR_FILENO, O_BINARY);\n@@ -1572,8 +1572,8 @@ error_stream (void)\n \n \n /* compare_file_filename()-- Given an open stream and a fortran string\n- * that is a filename, figure out if the file is the same as the\n- * filename. */\n+   that is a filename, figure out if the file is the same as the\n+   filename. */\n \n int\n compare_file_filename (gfc_unit *u, const char *name, int len)\n@@ -1591,7 +1591,7 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n   char *path = fc_strdup (name, len);\n \n   /* If the filename doesn't exist, then there is no match with the\n-   * existing file. */\n+     existing file. */\n \n   if (TEMP_FAILURE_RETRY (stat (path, &st)) < 0)\n     {\n@@ -1682,7 +1682,7 @@ find_file0 (gfc_unit *u, FIND_FILE0_DECL)\n \n \n /* find_file()-- Take the current filename and see if there is a unit\n- * that has the file already open.  Returns a pointer to the unit if so. */\n+   that has the file already open.  Returns a pointer to the unit if so. */\n \n gfc_unit *\n find_file (const char *file, gfc_charlen_type file_len)\n@@ -1838,7 +1838,7 @@ close_share (gfc_unit *u __attribute__ ((unused)))\n \n \n /* file_exists()-- Returns nonzero if the current filename exists on\n- * the system */\n+   the system */\n \n int\n file_exists (const char *file, gfc_charlen_type file_len)\n@@ -1868,8 +1868,8 @@ file_size (const char *file, gfc_charlen_type file_len)\n static const char yes[] = \"YES\", no[] = \"NO\", unknown[] = \"UNKNOWN\";\n \n /* inquire_sequential()-- Given a fortran string, determine if the\n- * file is suitable for sequential access.  Returns a C-style\n- * string. */\n+   file is suitable for sequential access.  Returns a C-style\n+   string. */\n \n const char *\n inquire_sequential (const char *string, int len)\n@@ -1898,7 +1898,7 @@ inquire_sequential (const char *string, int len)\n \n \n /* inquire_direct()-- Given a fortran string, determine if the file is\n- * suitable for direct access.  Returns a C-style string. */\n+   suitable for direct access.  Returns a C-style string. */\n \n const char *\n inquire_direct (const char *string, int len)\n@@ -1927,7 +1927,7 @@ inquire_direct (const char *string, int len)\n \n \n /* inquire_formatted()-- Given a fortran string, determine if the file\n- * is suitable for formatted form.  Returns a C-style string. */\n+   is suitable for formatted form.  Returns a C-style string. */\n \n const char *\n inquire_formatted (const char *string, int len)\n@@ -1957,7 +1957,7 @@ inquire_formatted (const char *string, int len)\n \n \n /* inquire_unformatted()-- Given a fortran string, determine if the file\n- * is suitable for unformatted form.  Returns a C-style string. */\n+   is suitable for unformatted form.  Returns a C-style string. */\n \n const char *\n inquire_unformatted (const char *string, int len)\n@@ -1967,7 +1967,7 @@ inquire_unformatted (const char *string, int len)\n \n \n /* inquire_access()-- Given a fortran string, determine if the file is\n- * suitable for access. */\n+   suitable for access. */\n \n static const char *\n inquire_access (const char *string, int len, int mode)\n@@ -1985,7 +1985,7 @@ inquire_access (const char *string, int len, int mode)\n \n \n /* inquire_read()-- Given a fortran string, determine if the file is\n- * suitable for READ access. */\n+   suitable for READ access. */\n \n const char *\n inquire_read (const char *string, int len)\n@@ -1995,7 +1995,7 @@ inquire_read (const char *string, int len)\n \n \n /* inquire_write()-- Given a fortran string, determine if the file is\n- * suitable for READ access. */\n+   suitable for READ access. */\n \n const char *\n inquire_write (const char *string, int len)\n@@ -2005,7 +2005,7 @@ inquire_write (const char *string, int len)\n \n \n /* inquire_readwrite()-- Given a fortran string, determine if the file is\n- * suitable for read and write access. */\n+   suitable for read and write access. */\n \n const char *\n inquire_readwrite (const char *string, int len)\n@@ -2022,15 +2022,15 @@ stream_isatty (stream *s)\n \n int\n stream_ttyname (stream *s  __attribute__ ((unused)),\n-\t\tchar * buf  __attribute__ ((unused)),\n+\t\tchar *buf  __attribute__ ((unused)),\n \t\tsize_t buflen  __attribute__ ((unused)))\n {\n #ifdef HAVE_TTYNAME_R\n-  return ttyname_r (((unix_stream *) s)->fd, buf, buflen);\n+  return ttyname_r (((unix_stream *)s)->fd, buf, buflen);\n #elif defined HAVE_TTYNAME\n   char *p;\n   size_t plen;\n-  p = ttyname (((unix_stream *) s)->fd);\n+  p = ttyname (((unix_stream *)s)->fd);\n   if (!p)\n     return errno;\n   plen = strlen (p);"}, {"sha": "4ac92ee7cbfe456ac5c95639345b8b9b3af6a6a9", "filename": "libgfortran/io/unix.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.h?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -48,55 +48,55 @@ struct stream\n \n /* Inline functions for doing file I/O given a stream.  */\n static inline ssize_t\n-sread (stream * s, void * buf, ssize_t nbyte)\n+sread (stream *s, void *buf, ssize_t nbyte)\n {\n   return s->vptr->read (s, buf, nbyte);\n }\n \n static inline ssize_t\n-swrite (stream * s, const void * buf, ssize_t nbyte)\n+swrite (stream *s, const void *buf, ssize_t nbyte)\n {\n   return s->vptr->write (s, buf, nbyte);\n }\n \n static inline gfc_offset\n-sseek (stream * s, gfc_offset offset, int whence)\n+sseek (stream *s, gfc_offset offset, int whence)\n {\n   return s->vptr->seek (s, offset, whence);\n }\n \n static inline gfc_offset\n-stell (stream * s)\n+stell (stream *s)\n {\n   return s->vptr->tell (s);\n }\n \n static inline gfc_offset\n-ssize (stream * s)\n+ssize (stream *s)\n {\n   return s->vptr->size (s);\n }\n \n static inline int\n-struncate (stream * s, gfc_offset length)\n+struncate (stream *s, gfc_offset length)\n {\n   return s->vptr->trunc (s, length);\n }\n \n static inline int\n-sflush (stream * s)\n+sflush (stream *s)\n {\n   return s->vptr->flush (s);\n }\n \n static inline int\n-sclose (stream * s)\n+sclose (stream *s)\n {\n   return s->vptr->close (s);\n }\n \n static inline int\n-smarkeor (stream * s)\n+smarkeor (stream *s)\n {\n   return s->vptr->markeor (s);\n }\n@@ -114,16 +114,16 @@ internal_proto(open_internal);\n extern stream *open_internal4 (char *, int, gfc_offset);\n internal_proto(open_internal4);\n \n-extern char * mem_alloc_w (stream *, int *);\n+extern char *mem_alloc_w (stream *, int *);\n internal_proto(mem_alloc_w);\n \n-extern char * mem_alloc_r (stream *, int *);\n+extern char *mem_alloc_r (stream *, int *);\n internal_proto(mem_alloc_r);\n \n-extern gfc_char4_t * mem_alloc_w4 (stream *, int *);\n+extern gfc_char4_t *mem_alloc_w4 (stream *, int *);\n internal_proto(mem_alloc_w4);\n \n-extern char * mem_alloc_r4 (stream *, int *);\n+extern char *mem_alloc_r4 (stream *, int *);\n internal_proto(mem_alloc_r4);\n \n extern stream *input_stream (void);"}, {"sha": "8dbbb0912e3c0e9d8206e66cf8e7a7ff94a29216", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29876bba06c24d6fe543941ad6f683c61910555/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=f29876bba06c24d6fe543941ad6f683c61910555", "patch": "@@ -863,7 +863,7 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n \n   if (unlikely (is_char4_unit (dtp)))\n     {\n-      gfc_char4_t * p4 = (gfc_char4_t *) p;\n+      gfc_char4_t *p4 = (gfc_char4_t *)p;\n       if (nblank < 0)\n \t{\n \t  memset4 (p4, '*', w);\n@@ -2040,8 +2040,8 @@ namelist_write_newline (st_parameter_dt *dtp)\n \n \n static namelist_info *\n-nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n-\t       namelist_info * base, char * base_name)\n+nml_write_obj (st_parameter_dt *dtp, namelist_info *obj, index_type offset,\n+\t       namelist_info *base, char *base_name)\n {\n   int rep_ctr;\n   int num;\n@@ -2053,15 +2053,15 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n   size_t clen;\n   index_type elem_ctr;\n   size_t obj_name_len;\n-  void * p;\n+  void *p;\n   char cup;\n-  char * obj_name;\n-  char * ext_name;\n-  char * q;\n+  char *obj_name;\n+  char *ext_name;\n+  char *q;\n   size_t ext_name_len;\n   char rep_buff[NML_DIGITS];\n-  namelist_info * cmp;\n-  namelist_info * retval = obj->next;\n+  namelist_info *cmp;\n+  namelist_info *retval = obj->next;\n   size_t base_name_len;\n   size_t base_var_name_len;\n   size_t tot_len;\n@@ -2156,7 +2156,7 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n \n       if ((elem_ctr < (nelem - 1)) &&\n \t  (obj->type != BT_DERIVED) &&\n-\t  !memcmp (p, (void*)(p + obj_size ), obj_size ))\n+\t  !memcmp (p, (void *)(p + obj_size ), obj_size ))\n \t{\n \t  rep_ctr++;\n \t}\n@@ -2393,11 +2393,11 @@ nml_write_obj (st_parameter_dt *dtp, namelist_info * obj, index_type offset,\n void\n namelist_write (st_parameter_dt *dtp)\n {\n-  namelist_info * t1, *t2, *dummy = NULL;\n+  namelist_info *t1, *t2, *dummy = NULL;\n   index_type i;\n   index_type dummy_offset = 0;\n   char c;\n-  char * dummy_name = NULL;\n+  char *dummy_name = NULL;\n \n   /* Set the delimiter for namelist output.  */\n   switch (dtp->u.p.current_unit->delim_status)"}]}