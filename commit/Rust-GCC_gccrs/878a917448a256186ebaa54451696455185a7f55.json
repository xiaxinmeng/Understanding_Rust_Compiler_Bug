{"sha": "878a917448a256186ebaa54451696455185a7f55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc4YTkxNzQ0OGEyNTYxODZlYmFhNTQ0NTE2OTY0NTUxODVhN2Y1NQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2011-10-05T15:07:21Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-10-05T15:07:21Z"}, "message": "rx.opt (mpid): Define.\n\n\t* config/rx/rx.opt (mpid): Define.\n\t* config/rx/t-rx (MULTILIB_OPTIONS): Add -mpid\n\t(MULTILIB_DIRNAMES): Add pid.\n\t* config/rx/rx.c (rx_gp_base_regnum_val, rx_pid_base_regnum_val)\n\t(rx_num_interrupt_regs): New variable.\n\t(rx_gp_base_regnum): New function.  Returns the number of the\n\tsmall data area register.\n\t(rx_pid_base_regnum): New function.  Returns the number of the pid\n\tbase register.\n\t(rx_decl_for_addr): New function.  Returns the symbolic part of a\n\tMEM.\n\t(rx_pid_data_operand): New function.  Returns whether an object is\n\tin the position independent data area.\n\t(rx_legitimize_address): New function.  Puts undecided PID\n\tobjects in the PID data area.\n\t(rx_is_legitimate_address): Add support for PID operands.\n\t(rx_print_operand_address): Likewise.\n\t(rx_print_operand): Likewise.\n\t(rx_maybe_pidify_operand): New function.  Determine if an operand\n\tis suitable for PID addressing.\n\t(rx_gen_move_template): Add PID support.\n\t(rx_conditional_register_usage): Likewise.\n\t(rx_option_override): Initialise rx_num_interrupt_regs.\n\t(rx_is_legitimate_constant): Add support for PID constants.\n\t(TARGET_LEGITIMIZE_ADDRESS): Define.\n\t* config/rx/constraints.md (Rpid): Define.\n\t(Rpda): Define.\n\t* config/rx/rx.md (UNSPEC_PID_ADDR): Define.\n\t(tablejump): Add PID support.\n\t(mov<>): Likewise.\n\t(mov<>_internal): Likewise.\n\t(addsi3): Convert to an expander.  Add PID support.\n\t(pid_addr): New pattern.\n\t* config/rx/rx.h (CPP_SPEC): Define.\n\t(ASM_SPEC): Pass -mpid and -mint-register on to assembler.\n\t(CASE_VECTOR_PC_RELATIVE): Define.\n\t(JUMP_TABLES_IN_TEXT_SECTION): Enable for PID mode.\n\t* config/rx/rx-protos.h (rx_maybe_pidify_operand): Prototype.\n\t* doc/invoke.texi (RX Options): Document -mpid command line\n\toption.\n\nCo-Authored-By: Nick Clifton <nickc@redhat.com>\n\nFrom-SVN: r179558", "tree": {"sha": "e5fb262a785e8b7adabd978c621ce0fdb1684ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5fb262a785e8b7adabd978c621ce0fdb1684ad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/878a917448a256186ebaa54451696455185a7f55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878a917448a256186ebaa54451696455185a7f55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878a917448a256186ebaa54451696455185a7f55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878a917448a256186ebaa54451696455185a7f55/comments", "author": null, "committer": null, "parents": [{"sha": "c867aba0c04643ea47cec651cb270e6d09c17f28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c867aba0c04643ea47cec651cb270e6d09c17f28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c867aba0c04643ea47cec651cb270e6d09c17f28"}], "stats": {"total": 453, "additions": 412, "deletions": 41}, "files": [{"sha": "4bdda3dff023cdd36650fa974169db2e7b6930e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -1,3 +1,47 @@\n+2011-10-05  DJ Delorie  <dj@redhat.com>\n+\t    Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rx/rx.opt (mpid): Define.\n+\t* config/rx/t-rx (MULTILIB_OPTIONS): Add -mpid\n+\t(MULTILIB_DIRNAMES): Add pid.\n+\t* config/rx/rx.c (rx_gp_base_regnum_val, rx_pid_base_regnum_val)\n+\t(rx_num_interrupt_regs): New variable.\n+\t(rx_gp_base_regnum): New function.  Returns the number of the\n+\tsmall data area register.\n+\t(rx_pid_base_regnum): New function.  Returns the number of the pid\n+\tbase register.\n+\t(rx_decl_for_addr): New function.  Returns the symbolic part of a\n+\tMEM.\n+\t(rx_pid_data_operand): New function.  Returns whether an object is\n+\tin the position independent data area.\n+\t(rx_legitimize_address): New function.  Puts undecided PID\n+\tobjects in the PID data area.\n+\t(rx_is_legitimate_address): Add support for PID operands.\n+\t(rx_print_operand_address): Likewise.\n+\t(rx_print_operand): Likewise.\n+\t(rx_maybe_pidify_operand): New function.  Determine if an operand\n+\tis suitable for PID addressing.\n+\t(rx_gen_move_template): Add PID support.\n+\t(rx_conditional_register_usage): Likewise.\n+\t(rx_option_override): Initialise rx_num_interrupt_regs.\n+\t(rx_is_legitimate_constant): Add support for PID constants.\n+\t(TARGET_LEGITIMIZE_ADDRESS): Define.\n+\t* config/rx/constraints.md (Rpid): Define.\n+\t(Rpda): Define.\n+\t* config/rx/rx.md (UNSPEC_PID_ADDR): Define.\n+\t(tablejump): Add PID support.\n+\t(mov<>): Likewise.\n+\t(mov<>_internal): Likewise.\n+\t(addsi3): Convert to an expander.  Add PID support.\n+\t(pid_addr): New pattern.\n+\t* config/rx/rx.h (CPP_SPEC): Define.\n+\t(ASM_SPEC): Pass -mpid and -mint-register on to assembler.\n+\t(CASE_VECTOR_PC_RELATIVE): Define.\n+\t(JUMP_TABLES_IN_TEXT_SECTION): Enable for PID mode.\n+\t* config/rx/rx-protos.h (rx_maybe_pidify_operand): Prototype.\n+\t* doc/invoke.texi (RX Options): Document -mpid command line\n+\toption.\n+\n 2011-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/38885"}, {"sha": "7822914acbbfda85ce3b9064ac7f3ddee7d24db8", "filename": "gcc/config/rx/constraints.md", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fconstraints.md?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -1,5 +1,5 @@\n ;; Constraint definitions for Renesas RX.\n-;; Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n+;; Copyright (C) 2008, 2009, 2010. 2011 Free Software Foundation, Inc.\n ;; Contributed by Red Hat.\n ;;\n ;; This file is part of GCC.\n@@ -86,3 +86,23 @@\n        )\n   )\n )\n+\n+(define_constraint \"Rpid\"\n+  \"A MEM to a PID variable\"\n+  (and (match_code \"mem\")\n+       (and (match_code \"plus\" \"0\")\n+\t    (and (match_code \"reg,subreg\" \"00\")\n+\t\t (match_code \"unspec\" \"01\")\n+\t    )\n+       )\n+  )\n+)\n+\n+(define_constraint \"Rpda\"\n+  \"An address to a PID variable\"\n+  (and (match_code \"plus\" \"\")\n+       (and (match_code \"reg,subreg\" \"0\")\n+\t    (match_code \"unspec\" \"1\")\n+       )\n+  )\n+)"}, {"sha": "365bf66babd9f1316e8e15b71f59c5a5f4ad7f09", "filename": "gcc/config/rx/rx-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -35,6 +35,7 @@ extern bool\t\trx_is_legitimate_constant (enum machine_mode, rtx);\n extern bool\t\trx_is_restricted_memory_address (rtx,\n \t\t\t\t\t\t\t enum machine_mode);\n extern bool\t\trx_match_ccmode (rtx, enum machine_mode);\n+extern rtx\t\trx_maybe_pidify_operand (rtx, int);\n extern void\t\trx_notice_update_cc (rtx, rtx);\n extern void\t\trx_split_cbranch (enum machine_mode, enum rtx_code,\n \t\t\t\t\t  rtx, rtx, rtx);"}, {"sha": "6ff9418c9d8a078141da4dae1323af053b5d3997", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 234, "deletions": 12, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -51,7 +51,43 @@\n #include \"target-def.h\"\n #include \"langhooks.h\"\n #include \"opts.h\"\n+\n+static unsigned int rx_gp_base_regnum_val = INVALID_REGNUM;\n+static unsigned int rx_pid_base_regnum_val = INVALID_REGNUM;\n+static unsigned int rx_num_interrupt_regs;\n \f\n+static unsigned int\n+rx_gp_base_regnum (void)\n+{\n+  if (rx_gp_base_regnum_val == INVALID_REGNUM)\n+    gcc_unreachable ();\n+  return rx_gp_base_regnum_val;\n+}\n+\n+static unsigned int\n+rx_pid_base_regnum (void)\n+{\n+  if (rx_pid_base_regnum_val == INVALID_REGNUM)\n+    gcc_unreachable ();\n+  return rx_pid_base_regnum_val;\n+}\n+\n+/* Find a SYMBOL_REF in a \"standard\" MEM address and return its decl.  */\n+\n+static tree\n+rx_decl_for_addr (rtx op)\n+{\n+  if (GET_CODE (op) == MEM)\n+    op = XEXP (op, 0);\n+  if (GET_CODE (op) == CONST)\n+    op = XEXP (op, 0);\n+  while (GET_CODE (op) == PLUS)\n+    op = XEXP (op, 0);\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return SYMBOL_REF_DECL (op);\n+  return NULL_TREE;\n+}\n+\n static void rx_print_operand (FILE *, rtx, int);\n \n #define CC_FLAG_S\t(1 << 0)\n@@ -63,6 +99,67 @@ static void rx_print_operand (FILE *, rtx, int);\n static unsigned int flags_from_mode (enum machine_mode mode);\n static unsigned int flags_from_code (enum rtx_code code);\n \f\n+/* Return true if OP is a reference to an object in a PID data area.  */\n+\n+enum pid_type\n+{\n+  PID_NOT_PID = 0,\t/* The object is not in the PID data area.  */\n+  PID_ENCODED,\t\t/* The object is in the PID data area.  */\n+  PID_UNENCODED\t\t/* The object will be placed in the PID data area, but it has not been placed there yet.  */\n+};\n+\n+static enum pid_type\n+rx_pid_data_operand (rtx op)\n+{\n+  tree op_decl;\n+\n+  if (!TARGET_PID)\n+    return PID_NOT_PID;\n+\n+  if (GET_CODE (op) == PLUS\n+      && GET_CODE (XEXP (op, 0)) == REG\n+      && GET_CODE (XEXP (op, 1)) == CONST\n+      && GET_CODE (XEXP (XEXP (op, 1), 0)) == UNSPEC)\n+    return PID_ENCODED;\n+\n+  op_decl = rx_decl_for_addr (op);\n+\n+  if (op_decl)\n+    {\n+      if (TREE_READONLY (op_decl))\n+\treturn PID_UNENCODED;\n+    }\n+  else\n+    {\n+      /* Sigh, some special cases.  */\n+      if (GET_CODE (op) == SYMBOL_REF\n+\t  || GET_CODE (op) == LABEL_REF)\n+\treturn PID_UNENCODED;\n+    }\n+\n+  return PID_NOT_PID;\n+}\n+\n+static rtx\n+rx_legitimize_address (rtx x,\n+\t\t       rtx oldx ATTRIBUTE_UNUSED,\n+\t\t       enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (rx_pid_data_operand (x) == PID_UNENCODED)\n+    {\n+      rtx rv = gen_pid_addr (gen_rtx_REG (SImode, rx_pid_base_regnum ()), x);\n+      return rv;\n+    }\n+\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && REG_P (XEXP (XEXP (x, 0), 0)) \n+      && REG_P (XEXP (x, 1)))\n+    return force_reg (SImode, x);\n+\n+  return x;\n+}\n+\n /* Return true if OP is a reference to an object in a small data area.  */\n \n static bool\n@@ -93,6 +190,16 @@ rx_is_legitimate_address (enum machine_mode mode, rtx x,\n        Post-increment Register Indirect.  */\n     return RTX_OK_FOR_BASE (XEXP (x, 0), strict);\n \n+  switch (rx_pid_data_operand (x))\n+    {\n+    case PID_UNENCODED:\n+      return false;\n+    case PID_ENCODED:\n+      return true;\n+    default:\n+      break;\n+    }\n+\n   if (GET_CODE (x) == PLUS)\n     {\n       rtx arg1 = XEXP (x, 0);\n@@ -337,15 +444,17 @@ rx_print_operand_address (FILE * file, rtx addr)\n \t{\n \t  addr = XEXP (addr, 0);\n \t  gcc_assert (XINT (addr, 1) == UNSPEC_CONST);\n-      \n-\t  addr = XVECEXP (addr, 0, 0);\n+\n+\t  /* FIXME: Putting this case label here is an appalling abuse of the C language.  */\n+\tcase UNSPEC:\n+          addr = XVECEXP (addr, 0, 0);\n \t  gcc_assert (CONST_INT_P (addr));\n \t}\n       /* Fall through.  */\n     case LABEL_REF:\n     case SYMBOL_REF:\n       fprintf (file, \"#\");\n-\n+      /* Fall through.  */\n     default:\n       output_addr_const (file, addr);\n       break;\n@@ -389,9 +498,11 @@ rx_assemble_integer (rtx x, unsigned int size, int is_aligned)\n      %B  Print an integer comparison name.\n      %C  Print a control register name.\n      %F  Print a condition code flag name.\n+     %G  Register used for small-data-area addressing\n      %H  Print high part of a DImode register, integer or address.\n      %L  Print low part of a DImode register, integer or address.\n      %N  Print the negation of the immediate value.\n+     %P  Register used for PID addressing\n      %Q  If the operand is a MEM, then correctly generate\n          register indirect or register relative addressing.\n      %R  Like %Q but for zero-extending loads.  */\n@@ -400,6 +511,16 @@ static void\n rx_print_operand (FILE * file, rtx op, int letter)\n {\n   bool unsigned_load = false;\n+  bool print_hash = true;\n+\n+  if (letter == 'A'\n+      && ((GET_CODE (op) == CONST\n+\t   && GET_CODE (XEXP (op, 0)) == UNSPEC)\n+\t  || GET_CODE (op) == UNSPEC))\n+    {\n+      print_hash = false;\n+      letter = 0;\n+    }\n \n   switch (letter)\n     {\n@@ -538,6 +659,10 @@ rx_print_operand (FILE * file, rtx op, int letter)\n \t}\n       break;\n \n+    case 'G':\n+      fprintf (file, \"%s\", reg_names [rx_gp_base_regnum ()]);\n+      break;\n+\n     case 'H':\n       switch (GET_CODE (op))\n \t{\n@@ -599,6 +724,10 @@ rx_print_operand (FILE * file, rtx op, int letter)\n       rx_print_integer (file, - INTVAL (op));\n       break;\n \n+    case 'P':\n+      fprintf (file, \"%s\", reg_names [rx_pid_base_regnum ()]);\n+      break;\n+\n     case 'R':\n       gcc_assert (GET_MODE_SIZE (GET_MODE (op)) < 4);\n       unsigned_load = true;\n@@ -667,6 +796,24 @@ rx_print_operand (FILE * file, rtx op, int letter)\n       /* Fall through.  */\n \n     default:\n+      if (GET_CODE (op) == CONST\n+\t  && GET_CODE (XEXP (op, 0)) == UNSPEC)\n+\top = XEXP (op, 0);\n+      else if (GET_CODE (op) == CONST\n+\t       && GET_CODE (XEXP (op, 0)) == PLUS\n+\t       && GET_CODE (XEXP (XEXP (op, 0), 0)) == UNSPEC\n+\t       && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+\t{\n+\t  if (print_hash)\n+\t    fprintf (file, \"#\");\n+\t  fprintf (file, \"(\");\n+\t  rx_print_operand (file, XEXP (XEXP (op, 0), 0), 'A');\n+\t  fprintf (file, \" + \");\n+\t  output_addr_const (file, XEXP (XEXP (op, 0), 1));\n+\t  fprintf (file, \")\");\n+\t  return;\n+\t}\n+\n       switch (GET_CODE (op))\n \t{\n \tcase MULT:\n@@ -721,20 +868,52 @@ rx_print_operand (FILE * file, rtx op, int letter)\n \n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n \t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\t    fprintf (file, TARGET_AS100_SYNTAX ? \"#0%lxH\" : \"#0x%lx\", val);\n+\t    if (print_hash)\n+\t      fprintf (file, \"#\");\n+\t    fprintf (file, TARGET_AS100_SYNTAX ? \"0%lxH\" : \"0x%lx\", val);\n \t    break;\n \t  }\n \n \tcase CONST_INT:\n-\t  fprintf (file, \"#\");\n+\t  if (print_hash)\n+\t    fprintf (file, \"#\");\n \t  rx_print_integer (file, INTVAL (op));\n \t  break;\n \n-\tcase SYMBOL_REF:\n+\tcase UNSPEC:\n+\t  switch (XINT (op, 1))\n+\t    {\n+\t    case UNSPEC_PID_ADDR:\n+\t      {\n+\t\trtx sym, add;\n+\n+\t\tif (print_hash)\n+\t\t  fprintf (file, \"#\");\n+\t\tsym = XVECEXP (op, 0, 0);\n+\t\tadd = NULL_RTX;\n+\t\tfprintf (file, \"(\");\n+\t\tif (GET_CODE (sym) == PLUS)\n+\t\t  {\n+\t\t    add = XEXP (sym, 1);\n+\t\t    sym = XEXP (sym, 0);\n+\t\t  }\n+\t\toutput_addr_const (file, sym);\n+\t\tif (add != NULL_RTX)\n+\t\t  {\n+\t\t    fprintf (file, \"+\");\n+\t\t    output_addr_const (file, add);\n+\t\t  }\n+\t\tfprintf (file, \"-__pid_base\");\n+\t\tfprintf (file, \")\");\n+\t\treturn;\n+\t      }\n+\t    }\n+\t  /* Fall through */\n+\n \tcase CONST:\n+\tcase SYMBOL_REF:\n \tcase LABEL_REF:\n \tcase CODE_LABEL:\n-\tcase UNSPEC:\n \t  rx_print_operand_address (file, op);\n \t  break;\n \n@@ -745,6 +924,29 @@ rx_print_operand (FILE * file, rtx op, int letter)\n     }\n }\n \n+/* Maybe convert an operand into its PID format.  */\n+\n+rtx\n+rx_maybe_pidify_operand (rtx op, int copy_to_reg)\n+{\n+  if (rx_pid_data_operand (op) == PID_UNENCODED)\n+    {\n+      if (GET_CODE (op) == MEM)\n+\t{\n+\t  rtx a = gen_pid_addr (gen_rtx_REG (SImode, rx_pid_base_regnum ()), XEXP (op, 0));\n+\t  op = replace_equiv_address (op, a);\n+\t}\n+      else\n+\t{\n+\t  op = gen_pid_addr (gen_rtx_REG (SImode, rx_pid_base_regnum ()), op);\n+\t}\n+\n+      if (copy_to_reg)\n+\top = copy_to_mode_reg (GET_MODE (op), op);\n+    }\n+  return op;\n+}\n+\n /* Returns an assembler template for a move instruction.  */\n \n char *\n@@ -784,13 +986,15 @@ rx_gen_move_template (rtx * operands, bool is_movu)\n       gcc_unreachable ();\n     }\n \n-  if (MEM_P (src) && rx_small_data_operand (XEXP (src, 0)))\n-    src_template = \"%%gp(%A1)[r13]\";\n+  if (MEM_P (src) && rx_pid_data_operand (XEXP (src, 0)) == PID_UNENCODED)\n+    src_template = \"(%A1-__pid_base)[%P1]\";\n+  else if (MEM_P (src) && rx_small_data_operand (XEXP (src, 0)))\n+    src_template = \"%%gp(%A1)[%G1]\";\n   else\n     src_template = \"%1\";\n \n   if (MEM_P (dest) && rx_small_data_operand (XEXP (dest, 0)))\n-    dst_template = \"%%gp(%A0)[r13]\";\n+    dst_template = \"%%gp(%A0)[%G0]\";\n   else\n     dst_template = \"%0\";\n \n@@ -996,8 +1200,21 @@ rx_conditional_register_usage (void)\n {\n   static bool using_fixed_regs = false;\n \n+  if (TARGET_PID)\n+    {\n+      rx_pid_base_regnum_val = GP_BASE_REGNUM - rx_num_interrupt_regs;\n+      fixed_regs[rx_pid_base_regnum_val] = call_used_regs [rx_pid_base_regnum_val] = 1;\n+    }\n+\n   if (rx_small_data_limit > 0)\n-    fixed_regs[GP_BASE_REGNUM] = call_used_regs [GP_BASE_REGNUM] = 1;\n+    {\n+      if (TARGET_PID)\n+\trx_gp_base_regnum_val = rx_pid_base_regnum_val - 1;\n+      else\n+\trx_gp_base_regnum_val = GP_BASE_REGNUM - rx_num_interrupt_regs;\n+\n+      fixed_regs[rx_gp_base_regnum_val] = call_used_regs [rx_gp_base_regnum_val] = 1;\n+    }\n \n   if (use_fixed_regs != using_fixed_regs)\n     {\n@@ -2338,8 +2555,10 @@ rx_option_override (void)\n \t      fixed_regs[13] = call_used_regs [13] = 1;\n \t      /* Fall through.  */\n \t    case 0:\n+\t      rx_num_interrupt_regs = opt->value;\n \t      break;\n \t    default:\n+\t      rx_num_interrupt_regs = 0;\n \t      /* Error message already given because rx_handle_option\n \t\t returned false.  */\n \t      break;\n@@ -2444,7 +2663,7 @@ rx_is_legitimate_constant (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \t  return true;\n \n \tcase UNSPEC:\n-\t  return XINT (x, 1) == UNSPEC_CONST;\n+\t  return XINT (x, 1) == UNSPEC_CONST || XINT (x, 1) == UNSPEC_PID_ADDR;\n \n \tdefault:\n \t  /* FIXME: Can this ever happen ?  */\n@@ -3031,6 +3250,9 @@ rx_adjust_insn_length (rtx insn, int current_length)\n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P\t\trx_is_legitimate_constant\n \n+#undef  TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS\t\trx_legitimize_address\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rx.h\""}, {"sha": "10b16bda2616144353a953272f673127b569305c", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -63,13 +63,22 @@\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n \n+#undef  CPP_SPEC\n+#define CPP_SPEC \"\\\n+%{mpid:-D_RX_PID=1} \\\n+%{mint-register=*:-D_RX_INT_REGISTERS=%*} \\\n+%{msmall-data-limit*:-D_RX_SMALL_DATA} \\\n+\"\n+\n #undef  ASM_SPEC\n #define ASM_SPEC \"\\\n %{mbig-endian-data:-mbig-endian-data} \\\n %{m64bit-doubles:-m64bit-doubles} \\\n %{!m64bit-doubles:-m32bit-doubles} \\\n %{msmall-data-limit*:-msmall-data-limit} \\\n %{mrelax:-relax} \\\n+%{mpid} \\\n+%{mint-register=*} \\\n \"\n \n #undef  LIB_SPEC\n@@ -200,14 +209,17 @@ enum reg_class\n #define STRUCT_VAL_REGNUM\t\t15\n #define CC_REGNUM                       16\n \n-/* This is the register which is used to hold the address of the start\n-   of the small data area, if that feature is being used.  Note - this\n-   register must not be call_used because otherwise library functions\n-   that are compiled without small data support might clobber it.\n+/* This is the register which will probably be used to hold the address of\n+   the start of the small data area, if -msmall-data-limit is being used,\n+   or the address of the constant data area if -mpid is being used.  If both\n+   features are in use then two consecutive registers will be used.\n \n-   FIXME: The function gcc/config/rx/rx.c:rx_gen_move_template() has a\n-   built in copy of this register's name, rather than constructing the\n-   name from this #define.  */\n+   Note - these registers must not be call_used because otherwise library\n+   functions that are compiled without -msmall-data-limit/-mpid support\n+   might clobber them.\n+\n+   Note that the actual values used depends on other options; use\n+   rx_gp_base_regnum() and rx_pid_base_regnum() instead.  */\n #define GP_BASE_REGNUM\t\t\t13\n \n #define ELIMINABLE_REGS\t\t\t\t\t\\\n@@ -444,13 +456,15 @@ typedef unsigned int CUMULATIVE_ARGS;\n \t   VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n-   Note: The local label referenced by the \"3b\" below is emitted by\n+   Note: The local label referenced by the \"1b\" below is emitted by\n    the tablejump insn.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, TARGET_AS100_SYNTAX \\\n \t   ? \"\\t.LWORD L%d - ?-\\n\" : \"\\t.long .L%d - 1b\\n\", VALUE)\n \n+#define CASE_VECTOR_PC_RELATIVE\t(TARGET_PID)\n+\n #define ASM_OUTPUT_SIZE_DIRECTIVE(STREAM, NAME, SIZE)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -595,7 +609,7 @@ typedef unsigned int CUMULATIVE_ARGS;\n \n /* For PIC put jump tables into the text section so that the offsets that\n    they contain are always computed between two same-section symbols.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION\t(flag_pic)\n+#define JUMP_TABLES_IN_TEXT_SECTION\t(TARGET_PID || flag_pic)\n \f\n /* This is a version of REG_P that also returns TRUE for SUBREGs.  */\n #define RX_REG_P(rtl) (REG_P (rtl) || GET_CODE (rtl) == SUBREG)"}, {"sha": "708f9444ca95b3b13657e90fc3476249d1363710", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -73,6 +73,8 @@\n    (UNSPEC_BUILTIN_SAT     49)\n    (UNSPEC_BUILTIN_SETPSW  50)\n    (UNSPEC_BUILTIN_WAIT\t   51)\n+\n+   (UNSPEC_PID_ADDR\t   52)\n   ]\n )\n \n@@ -330,9 +332,9 @@\n \t(match_operand:SI          0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand  1 \"\" \"\")))]\n   \"\"\n-  { return flag_pic ? (TARGET_AS100_SYNTAX ? \"\\n?:\\tbra\\t%0\"\n-\t\t\t\t\t   : \"\\n1:\\tbra\\t%0\")\n-\t                                   : \"\\n1:jmp\\t%0\";\n+  { return TARGET_PID ? (TARGET_AS100_SYNTAX ? \"\\n?:\\tbra\\t%0\"\n+\t\t\t\t\t     : \"\\n1:\\tbra\\t%0\")\n+\t                                     : \"\\n1:jmp\\t%0\";\n   }\n   [(set_attr \"timings\" \"33\")\n    (set_attr \"length\" \"2\")]\n@@ -556,8 +558,18 @@\n \t(match_operand:register_modes 1 \"general_operand\"))]\n   \"\"\n   {\n-    if (MEM_P (operand0) && MEM_P (operand1))\n-      operands[1] = copy_to_mode_reg (<register_modes:MODE>mode, operand1);\n+    if (MEM_P (operands[0]) && MEM_P (operands[1]))\n+      operands[1] = copy_to_mode_reg (<register_modes:MODE>mode, operands[1]);\n+    operands[0] = rx_maybe_pidify_operand (operands[0], 0);\n+    operands[1] = rx_maybe_pidify_operand (operands[1], 0);\n+    if (GET_CODE (operands[0]) != REG\n+\t&& GET_CODE (operands[1]) == PLUS)\n+      operands[1] = copy_to_mode_reg (<register_modes:MODE>mode, operands[1]);\n+    if (GET_CODE (operands[1]) == PLUS && GET_MODE (operands[1]) == SImode)\n+      {\n+        emit_insn (gen_addsi3 (operands[0], XEXP (operands[1], 0), XEXP (operands[1], 1)));\n+        DONE;\n+      }\n     if (CONST_INT_P (operand1)\n         && ! rx_is_legitimate_constant (<register_modes:MODE>mode, operand1))\n       FAIL;\n@@ -566,13 +578,13 @@\n \n (define_insn \"*mov<register_modes:mode>_internal\"\n   [(set (match_operand:register_modes\n-\t 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,Q,Q,Q,Q\")\n+\t 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,Q,Q,Q,Q,r\")\n \t(match_operand:register_modes\n-\t 1 \"general_operand\" \"Int08,Sint16,Sint24,i,r,m,r,Int08,Sint16,Sint24,i\"))]\n+\t 1 \"general_operand\" \"Int08,Sint16,Sint24,i,r,m,r,Int08,Sint16,Sint24,i,RpdaRpid\"))]\n   \"\"\n   { return rx_gen_move_template (operands, false); }\n-  [(set_attr \"length\" \"3,4,5,6,2,4,6,5,6,7,8\")\n-   (set_attr \"timings\" \"11,11,11,11,11,12,11,11,11,11,11\")]\n+  [(set_attr \"length\" \"3,4,5,6,2,4,6,5,6,7,8,8\")\n+   (set_attr \"timings\" \"11,11,11,11,11,12,11,11,11,11,11,11\")]\n )\n \n (define_insn \"extend<small_int_modes:mode>si2\"\n@@ -830,7 +842,20 @@\n   [(set_attr \"length\" \"2,3\")]\n )\n \n-(define_insn \"addsi3\"\n+(define_expand \"addsi3\"\n+  [(parallel [(set (match_operand:SI          0 \"register_operand\"  \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"\")\n+\t\t (match_operand:SI 2 \"rx_source_operand\" \"\")))\n+    (clobber (reg:CC CC_REG))])]\n+  \"\"\n+  \"\n+      operands[0] = rx_maybe_pidify_operand (operands[0], 1);\n+      operands[1] = rx_maybe_pidify_operand (operands[1], 1);\n+      operands[2] = rx_maybe_pidify_operand (operands[2], 1);\n+  \"\n+)\n+\n+(define_insn \"addsi3_internal\"\n   [(set (match_operand:SI          0 \"register_operand\"  \"=r,r,r,r,r,r,r,r,r,r,r,r,r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,0,0,0,0,0,r,r,r,r,r,r,0\")\n \t\t (match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,NEGint4,Sint08,Sint16,Sint24,i,0,r,Sint08,Sint16,Sint24,i,Q\")))\n@@ -2583,3 +2608,10 @@\n   \"nop\"\n   [(set_attr \"length\" \"1\")]\n )\n+\n+(define_expand \"pid_addr\"\n+  [(plus:SI (match_operand:SI 0)\n+\t    (const:SI (unspec:SI [(match_operand:SI 1)] UNSPEC_PID_ADDR)))]\n+  \"\"\n+  \"\"\n+)"}, {"sha": "308bf0c8ada0474c9973134b43c52afa5b51d38b", "filename": "gcc/config/rx/rx.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Frx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.opt?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -112,3 +112,9 @@ Specifies the number of registers to reserve for interrupt handlers.\n msave-acc-in-interrupts\n Target Mask(SAVE_ACC_REGISTER)\n Specifies whether interrupt functions should save and restore the accumulator register.\n+\n+;---------------------------------------------------\n+\n+mpid\n+Target Mask(PID)\n+Enables Position-Independent-Data (PID) mode."}, {"sha": "ad667bcc5c9e7284a142aa3a2e8405787b2d0f30", "filename": "gcc/config/rx/t-rx", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Ft-rx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fconfig%2Frx%2Ft-rx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Ft-rx?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -20,8 +20,8 @@\n \n # Enable multilibs:\n \n-MULTILIB_OPTIONS    = m64bit-doubles  nofpu        mbig-endian-data \n-MULTILIB_DIRNAMES   =  64-bit-double  no-fpu-libs   big-endian-data \n+MULTILIB_OPTIONS    = m64bit-doubles  nofpu        mbig-endian-data  mpid\n+MULTILIB_DIRNAMES   =  64-bit-double  no-fpu-libs   big-endian-data   pid\n \n MULTILIB_MATCHES    = nofpu=mnofpu  nofpu=mcpu?rx200\n "}, {"sha": "df18871cfd28b850f236fd693493fd8c716d6c6e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878a917448a256186ebaa54451696455185a7f55/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878a917448a256186ebaa54451696455185a7f55/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=878a917448a256186ebaa54451696455185a7f55", "patch": "@@ -828,6 +828,7 @@ See RS/6000 and PowerPC Options.\n -mrelax@gol\n -mmax-constant-size=@gol\n -mint-register=@gol\n+-mpid@gol\n -msave-acc-in-interrupts}\n \n @emph{S/390 and zSeries Options}\n@@ -16576,10 +16577,11 @@ which can be placed into the small data area.  Using the small data\n area can lead to smaller and faster code, but the size of area is\n limited and it is up to the programmer to ensure that the area does\n not overflow.  Also when the small data area is used one of the RX's\n-registers (@code{r13}) is reserved for use pointing to this area, so\n-it is no longer available for use by the compiler.  This could result\n-in slower and/or larger code if variables which once could have been\n-held in @code{r13} are now pushed onto the stack.\n+registers (usually @code{r13}) is reserved for use pointing to this\n+area, so it is no longer available for use by the compiler.  This\n+could result in slower and/or larger code if variables which once\n+could have been held in the reserved register are now pushed onto the\n+stack.\n \n Note, common variables (variables which have not been initialised) and\n constants are not placed into the small data area as they are assigned\n@@ -16588,9 +16590,10 @@ to other sections in the output executable.\n The default value is zero, which disables this feature.  Note, this\n feature is not enabled by default with higher optimization levels\n (@option{-O2} etc) because of the potentially detrimental effects of\n-reserving register @code{r13}.  It is up to the programmer to\n-experiment and discover whether this feature is of benefit to their\n-program.\n+reserving a register.  It is up to the programmer to experiment and\n+discover whether this feature is of benefit to their program.  See the\n+description of the @option{-mpid} option for a description of how the\n+actual register to hold the small data area pointer is chosen.\n \n @item -msim\n @itemx -mno-sim\n@@ -16645,6 +16648,35 @@ the accumulator register, for example because it performs 64-bit\n multiplications.  The default is to ignore the accumulator as this\n makes the interrupt handlers faster.\n \n+@item -mpid\n+@itemx -mno-pid\n+@opindex mpid\n+@opindex mno-pid\n+Enables the generation of position independent data.  When enabled any\n+access to constant data will done via an offset from a base address\n+held in a register.  This allows the location of constant data to be\n+determined at run-time without requiring the executable to be\n+relocated, which is a benefit to embedded applications with tight\n+memory constraints.  Data that can be modified is not affected by this\n+option.\n+\n+Note, using this feature reserves a register, usually @code{r13}, for\n+the constant data base address.  This can result in slower and/or\n+larger code, especially in complicated functions.\n+\n+The actual register chosen to hold the constant data base address\n+depends upon whether the @option{-msmall-data-limit} and/or the\n+@option{-mint-register} command line options are enabled.  Starting\n+with register @code{r13} and proceeding downwards, registers are\n+allocated first to satisfy the requirements of @option{-mint-register},\n+then @option{-mpid} and finally @option{-msmall-data-limit}.  Thus it\n+is possible for the small data area register to be @code{r8} if both\n+@option{-mint-register=4} and @option{-mpid} are specified on the\n+command line.\n+\n+By default this feature is not enabled.  The default can be restored\n+via the @option{-mno-pid} command line option.\n+\n @end table\n \n @emph{Note:} The generic GCC command line @option{-ffixed-@var{reg}}"}]}