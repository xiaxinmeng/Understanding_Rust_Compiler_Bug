{"sha": "da9a8da809b84f398ad3357ca36d2c4402099eb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE5YThkYTgwOWI4NGYzOThhZDMzNTdjYTM2ZDJjNDQwMjA5OWViOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-02-01T22:03:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-02-01T22:03:57Z"}, "message": "re PR testsuite/68580 (FAIL: c-c++-common/tsan/pr65400-1.c -O0 execution test)\n\n\tPR tree-optimization/68580\n\t* params.def (FSM_MAXIMUM_PHI_ARGUMENTS): New param.\n\t* tree-ssa-threadbackward.c\n\t(fsm_find_control_statement_thread_paths): Do not try to walk\n\tthrough large PHI nodes.\n\nFrom-SVN: r233053", "tree": {"sha": "b5d9304a50509feb3392105ef9f8995096ece055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5d9304a50509feb3392105ef9f8995096ece055"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da9a8da809b84f398ad3357ca36d2c4402099eb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9a8da809b84f398ad3357ca36d2c4402099eb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9a8da809b84f398ad3357ca36d2c4402099eb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9a8da809b84f398ad3357ca36d2c4402099eb9/comments", "author": null, "committer": null, "parents": [{"sha": "800cb72aae9947e6496c3705986c421978b92e8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800cb72aae9947e6496c3705986c421978b92e8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/800cb72aae9947e6496c3705986c421978b92e8e"}], "stats": {"total": 449, "additions": 235, "deletions": 214}, "files": [{"sha": "60e229fa0edb5b7b76dad22f11a44c611b8f6ebe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9a8da809b84f398ad3357ca36d2c4402099eb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9a8da809b84f398ad3357ca36d2c4402099eb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da9a8da809b84f398ad3357ca36d2c4402099eb9", "patch": "@@ -1,3 +1,11 @@\n+2016-02-01  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/68580\n+\t* params.def (FSM_MAXIMUM_PHI_ARGUMENTS): New param.\n+\t* tree-ssa-threadbackward.c\n+\t(fsm_find_control_statement_thread_paths): Do not try to walk\n+\tthrough large PHI nodes.\n+\n 2016-02-01  Jakub Jelinek  <jakub@redhat.com>\n \n \t* ifcvt.c (bb_ok_for_noce_convert_multiple_sets): Return false"}, {"sha": "c0494fa2bd54f5d727643d092d2c0b60a8450f28", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9a8da809b84f398ad3357ca36d2c4402099eb9/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9a8da809b84f398ad3357ca36d2c4402099eb9/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=da9a8da809b84f398ad3357ca36d2c4402099eb9", "patch": "@@ -1150,6 +1150,11 @@ DEFPARAM (PARAM_FSM_SCALE_PATH_STMTS,\n \t  \"Scale factor to apply to the number of statements in a threading path when comparing to the number of (scaled) blocks.\",\n \t  2, 1, 10)\n \n+DEFPARAM (PARAM_FSM_MAXIMUM_PHI_ARGUMENTS,\n+\t  \"fsm-maximum-phi-arguments\",\n+\t  \"Maximum number of arguments a PHI may have before the FSM threader will not try to thread through its block.\",\n+\t  100, 1, 999999)\n+\n DEFPARAM (PARAM_FSM_SCALE_PATH_BLOCKS,\n \t  \"fsm-scale-path-blocks\",\n \t  \"Scale factor to apply to the number of blocks in a threading path when comparing to the number of (scaled) statements.\","}, {"sha": "55dbcaddf69f4e8e86159536c937b461a57b92b5", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 222, "deletions": 214, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9a8da809b84f398ad3357ca36d2c4402099eb9/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9a8da809b84f398ad3357ca36d2c4402099eb9/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=da9a8da809b84f398ad3357ca36d2c4402099eb9", "patch": "@@ -114,7 +114,9 @@ fsm_find_control_statement_thread_paths (tree name,\n      eventually one of the phi arguments will be an integer constant.  In the\n      future, this could be extended to also handle simple assignments of\n      arithmetic operations.  */\n-  if (gimple_code (def_stmt) != GIMPLE_PHI)\n+  if (gimple_code (def_stmt) != GIMPLE_PHI\n+      || (gimple_phi_num_args (def_stmt)\n+\t  >= (unsigned) PARAM_VALUE (PARAM_FSM_MAXIMUM_PHI_ARGUMENTS)))\n     return;\n \n   /* Avoid infinite recursion.  */\n@@ -200,247 +202,253 @@ fsm_find_control_statement_thread_paths (tree name,\n \n   /* Iterate over the arguments of PHI.  */\n   unsigned int i;\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+  if (gimple_phi_num_args (phi)\n+      < (unsigned) PARAM_VALUE (PARAM_FSM_MAXIMUM_PHI_ARGUMENTS))\n     {\n-      tree arg = gimple_phi_arg_def (phi, i);\n-      basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n-\n-      /* Skip edges pointing outside the current loop.  */\n-      if (!arg || var_bb->loop_father != bbi->loop_father)\n-\tcontinue;\n-\n-      if (TREE_CODE (arg) == SSA_NAME)\n+      for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t{\n-\t  vec_safe_push (path, bbi);\n-\t  /* Recursively follow SSA_NAMEs looking for a constant definition.  */\n-\t  fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n-\t\t\t\t\t\t   seen_loop_phi);\n+\t  tree arg = gimple_phi_arg_def (phi, i);\n+\t  basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n \n-\t  path->pop ();\n-\t  continue;\n-\t}\n+\t  /* Skip edges pointing outside the current loop.  */\n+\t  if (!arg || var_bb->loop_father != bbi->loop_father)\n+\t    continue;\n \n-      if (TREE_CODE (arg) != INTEGER_CST)\n-\tcontinue;\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      vec_safe_push (path, bbi);\n+\t      /* Recursively follow SSA_NAMEs looking for a constant\n+\t\t definition.  */\n+\t      fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n+\t\t\t\t\t\t       seen_loop_phi);\n+\n+\t      path->pop ();\n+\t      continue;\n+\t    }\n \n-      /* Note BBI is not in the path yet, hence the +1 in the test below\n-\t to make sure BBI is accounted for in the path length test.  */\n-      int path_length = path->length ();\n-      if (path_length + 1 > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the number of basic blocks on the path \"\n-\t\t     \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n-\t  continue;\n-\t}\n+\t  if (TREE_CODE (arg) != INTEGER_CST)\n+\t    continue;\n \n-      if (max_threaded_paths <= 0)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the number of previously recorded FSM paths to thread \"\n-\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n-\t  continue;\n-\t}\n+\t  /* Note BBI is not in the path yet, hence the +1 in the test below\n+\t     to make sure BBI is accounted for in the path length test.  */\n+\t  int path_length = path->length ();\n+\t  if (path_length + 1 > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t\t \"the number of basic blocks on the path \"\n+\t\t\t \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n+\t      continue;\n+\t    }\n \n-      /* Add BBI to the path.  */\n-      vec_safe_push (path, bbi);\n-      ++path_length;\n-\n-      int n_insns = 0;\n-      gimple_stmt_iterator gsi;\n-      int j;\n-      loop_p loop = (*path)[0]->loop_father;\n-      bool path_crosses_loops = false;\n-      bool threaded_through_latch = false;\n-      bool multiway_branch_in_path = false;\n-      bool threaded_multiway_branch = false;\n-\n-      /* Count the number of instructions on the path: as these instructions\n-\t will have to be duplicated, we will not record the path if there are\n-\t too many instructions on the path.  Also check that all the blocks in\n-\t the path belong to a single loop.  */\n-      for (j = 0; j < path_length; j++)\n-\t{\n-\t  basic_block bb = (*path)[j];\n-\n-\t  /* Remember, blocks in the path are stored in opposite order\n-\t     in the PATH array.  The last entry in the array represents\n-\t     the block with an outgoing edge that we will redirect to the\n-\t     jump threading path.  Thus we don't care about that block's\n-\t     loop father, nor how many statements are in that block because\n-\t     it will not be copied or whether or not it ends in a multiway\n-\t     branch.  */\n-\t  if (j < path_length - 1)\n+\t  if (max_threaded_paths <= 0)\n \t    {\n-\t      if (bb->loop_father != loop)\n-\t\t{\n-\t\t  path_crosses_loops = true;\n-\t\t  break;\n-\t\t}\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t\t \"the number of previously recorded FSM paths to \"\n+\t\t\t \"thread exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n+\t      continue;\n+\t    }\n \n-\t      for (gsi = gsi_after_labels (bb);\n-\t\t   !gsi_end_p (gsi);\n-\t\t   gsi_next_nondebug (&gsi))\n+\t  /* Add BBI to the path.  */\n+\t  vec_safe_push (path, bbi);\n+\t  ++path_length;\n+\n+\t  int n_insns = 0;\n+\t  gimple_stmt_iterator gsi;\n+\t  int j;\n+\t  loop_p loop = (*path)[0]->loop_father;\n+\t  bool path_crosses_loops = false;\n+\t  bool threaded_through_latch = false;\n+\t  bool multiway_branch_in_path = false;\n+\t  bool threaded_multiway_branch = false;\n+\n+\t  /* Count the number of instructions on the path: as these instructions\n+\t     will have to be duplicated, we will not record the path if there\n+\t     are too many instructions on the path.  Also check that all the\n+\t     blocks in the path belong to a single loop.  */\n+\t  for (j = 0; j < path_length; j++)\n+\t    {\n+\t      basic_block bb = (*path)[j];\n+\n+\t      /* Remember, blocks in the path are stored in opposite order\n+\t\t in the PATH array.  The last entry in the array represents\n+\t\t the block with an outgoing edge that we will redirect to the\n+\t\t jump threading path.  Thus we don't care about that block's\n+\t\t loop father, nor how many statements are in that block because\n+\t\t it will not be copied or whether or not it ends in a multiway\n+\t\t branch.  */\n+\t      if (j < path_length - 1)\n \t\t{\n-\t\t  gimple *stmt = gsi_stmt (gsi);\n-\t\t  /* Do not count empty statements and labels.  */\n-\t\t  if (gimple_code (stmt) != GIMPLE_NOP\n-\t\t      && !(gimple_code (stmt) == GIMPLE_ASSIGN\n-\t\t\t   && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n-\t\t      && !is_gimple_debug (stmt))\n-\t\t    ++n_insns;\n+\t\t  if (bb->loop_father != loop)\n+\t\t    {\n+\t\t      path_crosses_loops = true;\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  for (gsi = gsi_after_labels (bb);\n+\t\t       !gsi_end_p (gsi);\n+\t\t       gsi_next_nondebug (&gsi))\n+\t\t    {\n+\t\t      gimple *stmt = gsi_stmt (gsi);\n+\t\t      /* Do not count empty statements and labels.  */\n+\t\t      if (gimple_code (stmt) != GIMPLE_NOP\n+\t\t\t  && !(gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t\t       && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n+\t\t\t  && !is_gimple_debug (stmt))\n+\t\t\t++n_insns;\n+\t\t    }\n+\n+\t\t  /* We do not look at the block with the threaded branch\n+\t\t     in this loop.  So if any block with a last statement that\n+\t\t     is a GIMPLE_SWITCH or GIMPLE_GOTO is seen, then we have a\n+\t\t     multiway branch on our path.\n+\n+\t\t     The block in PATH[0] is special, it's the block were we're\n+\t\t     going to be able to eliminate its branch.  */\n+\t\t  gimple *last = last_stmt (bb);\n+\t\t  if (last && (gimple_code (last) == GIMPLE_SWITCH\n+\t\t\t       || gimple_code (last) == GIMPLE_GOTO))\n+\t\t    {\n+\t\t      if (j == 0)\n+\t\t\tthreaded_multiway_branch = true;\n+\t\t      else\n+\t\t\tmultiway_branch_in_path = true;\n+\t\t    }\n \t\t}\n \n-\t      /* We do not look at the block with the threaded branch\n-\t\t in this loop.  So if any block with a last statement that\n-\t\t is a GIMPLE_SWITCH or GIMPLE_GOTO is seen, then we have a\n-\t\t multiway branch on our path.\n-\n-\t\t The block in PATH[0] is special, it's the block were we're\n-\t\t going to be able to eliminate its branch.  */\n-\t      gimple *last = last_stmt (bb);\n-\t      if (last && (gimple_code (last) == GIMPLE_SWITCH\n-\t\t\t   || gimple_code (last) == GIMPLE_GOTO))\n-\t\t{\n-\t\t  if (j == 0)\n-\t\t    threaded_multiway_branch = true;\n-\t\t  else\n-\t\t    multiway_branch_in_path = true;\n-\t\t}\n+\t      /* Note if we thread through the latch, we will want to include\n+\t\t the last entry in the array when determining if we thread\n+\t\t through the loop latch.  */\n+\t      if (loop->latch == bb)\n+\t\tthreaded_through_latch = true;\n \t    }\n \n-\t  /* Note if we thread through the latch, we will want to include\n-\t     the last entry in the array when determining if we thread\n-\t     through the loop latch.  */\n-\t  if (loop->latch == bb)\n-\t    threaded_through_latch = true;\n-\t}\n+\t  gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n+\t  gcc_assert (stmt);\n+\t  /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n+\t     and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n+\t     we need to substitute, fold and simplify so we can determine\n+\t     the edge taken out of the last block.  */\n+\t  if (gimple_code (stmt) == GIMPLE_COND)\n+\t    {\n+\t      enum tree_code cond_code = gimple_cond_code (stmt);\n \n-      gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n-      gcc_assert (stmt);\n-      /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n-\t and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n-\t we need to substitute, fold and simplify so we can determine\n-\t the edge taken out of the last block.  */\n-      if (gimple_code (stmt) == GIMPLE_COND)\n-\t{\n-\t  enum tree_code cond_code = gimple_cond_code (stmt);\n+\t      /* We know the underyling format of the condition.  */\n+\t      arg = fold_binary (cond_code, boolean_type_node,\n+\t\t\t\t arg, gimple_cond_rhs (stmt));\n+\t    }\n \n-\t  /* We know the underyling format of the condition.  */\n-\t  arg = fold_binary (cond_code, boolean_type_node,\n-\t\t\t     arg, gimple_cond_rhs (stmt));\n-\t}\n+\t  /* If this path threaded through the loop latch back into the\n+\t     same loop and the destination does not dominate the loop\n+\t     latch, then this thread would create an irreducible loop.\n+\n+\t     We have to know the outgoing edge to figure this out.  */\n+\t  edge taken_edge = find_taken_edge ((*path)[0], arg);\n+\t  bool creates_irreducible_loop = false;\n+\t  if (threaded_through_latch\n+\t      && loop == taken_edge->dest->loop_father\n+\t      && (determine_bb_domination_status (loop, taken_edge->dest)\n+\t\t  == DOMST_NONDOMINATING))\n+\t    creates_irreducible_loop = true;\n+\n+\t  /* PHIs in the final target and only the final target will need\n+\t     to be duplicated.  So only count those against the number\n+\t     of statements.  */\n+\t  gphi_iterator gsip;\n+\t  for (gsip = gsi_start_phis (taken_edge->dest);\n+\t       !gsi_end_p (gsip);\n+\t       gsi_next (&gsip))\n+\t    {\n+\t      gphi *phi = gsip.phi ();\n+\t      tree dst = gimple_phi_result (phi);\n+\n+\t      /* We consider any non-virtual PHI as a statement since it\n+\t\t count result in a constant assignment or copy\n+\t\t operation.  */\n+\t      if (!virtual_operand_p (dst))\n+\t\t++n_insns;\n+\t    }\n \n-      /* If this path threaded through the loop latch back into the\n-\t same loop and the destination does not dominate the loop\n-\t latch, then this thread would create an irreducible loop.\n-\n-\t We have to know the outgoing edge to figure this out.  */\n-      edge taken_edge = find_taken_edge ((*path)[0], arg);\n-      bool creates_irreducible_loop = false;\n-      if (threaded_through_latch\n-\t  && loop == taken_edge->dest->loop_father\n-\t  && (determine_bb_domination_status (loop, taken_edge->dest)\n-\t      == DOMST_NONDOMINATING))\n-\tcreates_irreducible_loop = true;\n-\n-      /* PHIs in the final target and only the final target will need\n-\t to be duplicated.  So only count those against the number\n-\t of statements.  */\n-      gphi_iterator gsip;\n-      for (gsip = gsi_start_phis (taken_edge->dest);\n-\t   !gsi_end_p (gsip);\n-\t   gsi_next (&gsip))\n-\t{\n-\t  gphi *phi = gsip.phi ();\n-\t  tree dst = gimple_phi_result (phi);\n-\n-\t  /* We consider any non-virtual PHI as a statement since it\n-\t     count result in a constant assignment or copy\n-\t     operation.  */\n-\t  if (!virtual_operand_p (dst))\n-\t    ++n_insns;\n-\t}\n+\t  if (path_crosses_loops)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t\t \"the path crosses loops.\\n\");\n+\t      path->pop ();\n+\t      continue;\n+\t    }\n \n-      if (path_crosses_loops)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the path crosses loops.\\n\");\n-\t  path->pop ();\n-\t  continue;\n-\t}\n+\t  if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t\t \"the number of instructions on the path \"\n+\t\t\t \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n+\t      path->pop ();\n+\t      continue;\n+\t    }\n \n-      if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the number of instructions on the path \"\n-\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n-\t  path->pop ();\n-\t  continue;\n-\t}\n+\t  /* We avoid creating irreducible inner loops unless we thread through\n+\t     a multiway branch, in which case we have deemed it worth losing\n+\t     other loop optimizations later.\n \n-      /* We avoid creating irreducible inner loops unless we thread through\n-\t a multiway branch, in which case we have deemed it worth losing other\n-\t loop optimizations later.\n+\t     We also consider it worth creating an irreducible inner loop if\n+\t     the number of copied statement is low relative to the length of\n+\t     the path -- in that case there's little the traditional loop\n+\t     optimizer would have done anyway, so an irreducible loop is not\n+\t     so bad.  */\n+\t  if (!threaded_multiway_branch && creates_irreducible_loop\n+\t      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n+\t\t  > path_length * PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS)))\n \n-\t We also consider it worth creating an irreducible inner loop if\n-\t the number of copied statement is low relative to the length of\n-\t the path -- in that case there's little the traditional loop optimizer\n-\t would have done anyway, so an irreducible loop is not so bad.  */\n-      if (!threaded_multiway_branch && creates_irreducible_loop\n-\t  && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n-\t      > path_length * PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS)))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"FSM would create irreducible loop without threading \"\n+\t\t\t \"multiway branch.\\n\");\n+\t      path->pop ();\n+\t      continue;\n+\t    }\n \n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file,\n-\t\t     \"FSM would create irreducible loop without threading \"\n-\t\t     \"multiway branch.\\n\");\n-\t  path->pop ();\n-\t  continue;\n-\t}\n+\t  /* When there is a multi-way branch on the path, then threading can\n+\t     explode the CFG due to duplicating the edges for that multi-way\n+\t     branch.  So like above, only allow a multi-way branch on the path\n+\t     if we actually thread a multi-way branch.  */\n+\t  if (!threaded_multiway_branch && multiway_branch_in_path)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"FSM Thread through multiway branch without threading \"\n+\t\t\t \"a multiway branch.\\n\");\n+\t      path->pop ();\n+\t      continue;\n+\t    }\n \n-      /* When there is a multi-way branch on the path, then threading can\n-\t explode the CFG due to duplicating the edges for that multi-way\n-\t branch.  So like above, only allow a multi-way branch on the path\n-\t if we actually thread a multi-way branch.  */\n-      if (!threaded_multiway_branch && multiway_branch_in_path)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file,\n-\t\t     \"FSM Thread through multiway branch without threading \"\n-\t\t     \"a multiway branch.\\n\");\n-\t  path->pop ();\n-\t  continue;\n-\t}\n+\t  vec<jump_thread_edge *> *jump_thread_path\n+\t    = new vec<jump_thread_edge *> ();\n \n-      vec<jump_thread_edge *> *jump_thread_path\n-\t= new vec<jump_thread_edge *> ();\n+\t  /* Record the edges between the blocks in PATH.  */\n+\t  for (j = 0; j < path_length - 1; j++)\n+\t    {\n+\t      edge e = find_edge ((*path)[path_length - j - 1],\n+\t\t\t\t  (*path)[path_length - j - 2]);\n+\t      gcc_assert (e);\n+\t      jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n+\t      jump_thread_path->safe_push (x);\n+\t    }\n \n-      /* Record the edges between the blocks in PATH.  */\n-      for (j = 0; j < path_length - 1; j++)\n-\t{\n-\t  edge e = find_edge ((*path)[path_length - j - 1],\n-\t\t\t      (*path)[path_length - j - 2]);\n-\t  gcc_assert (e);\n-\t  jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n+\t  /* Add the edge taken when the control variable has value ARG.  */\n+\t  jump_thread_edge *x\n+\t    = new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n \t  jump_thread_path->safe_push (x);\n-\t}\n \n-      /* Add the edge taken when the control variable has value ARG.  */\n-      jump_thread_edge *x\n-\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n-      jump_thread_path->safe_push (x);\n+\t  register_jump_thread (jump_thread_path);\n+\t  --max_threaded_paths;\n \n-      register_jump_thread (jump_thread_path);\n-      --max_threaded_paths;\n-\n-      /* Remove BBI from the path.  */\n-      path->pop ();\n+\t  /* Remove BBI from the path.  */\n+\t  path->pop ();\n+\t}\n     }\n \n   /* Remove all the nodes that we added from NEXT_PATH.  */"}]}