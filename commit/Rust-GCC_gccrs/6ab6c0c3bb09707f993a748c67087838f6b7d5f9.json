{"sha": "6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFiNmMwYzNiYjA5NzA3Zjk5M2E3NDhjNjcwODc4MzhmNmI3ZDVmOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-08-23T06:27:54Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-08-23T06:27:54Z"}, "message": "re PR fortran/86863 ([OOP][F2008] type-bound module procedure name not recognized)\n\n2017-08-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/86863\n\t* resolve.c (resolve_typebound_call): If the TBP is not marked\n\tas a subroutine, check the specific symbol.\n\n2017-08-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/86863\n\t* gfortran.dg/submodule_32.f08: New test.\n\nFrom-SVN: r263799", "tree": {"sha": "7f33595b13c10f6fd3bd43c4e1e90953ca66ec41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f33595b13c10f6fd3bd43c4e1e90953ca66ec41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/comments", "author": null, "committer": null, "parents": [{"sha": "ba7a2ad8bdc51dbfaaa1a83b24b0417691a5a80d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba7a2ad8bdc51dbfaaa1a83b24b0417691a5a80d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba7a2ad8bdc51dbfaaa1a83b24b0417691a5a80d"}], "stats": {"total": 87, "additions": 84, "deletions": 3}, "files": [{"sha": "4cbdc68289a5a8f7b0c2dc674e283724ddb07891", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "patch": "@@ -1,3 +1,9 @@\n+2017-08-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/86863\n+\t* resolve.c (resolve_typebound_call): If the TBP is not marked\n+\tas a subroutine, check the specific symbol.\n+\n 2018-08-22  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* gfortran.texi: Mention that asynchronous I/O does"}, {"sha": "43a8470e748f2882cfc83f863193f287107af3d6", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "patch": "@@ -6266,9 +6266,17 @@ resolve_typebound_call (gfc_code* c, const char **name, bool *overridable)\n   /* Check that's really a SUBROUTINE.  */\n   if (!c->expr1->value.compcall.tbp->subroutine)\n     {\n-      gfc_error (\"%qs at %L should be a SUBROUTINE\",\n-\t\t c->expr1->value.compcall.name, &c->loc);\n-      return false;\n+      if (!c->expr1->value.compcall.tbp->is_generic\n+\t  && c->expr1->value.compcall.tbp->u.specific\n+\t  && c->expr1->value.compcall.tbp->u.specific->n.sym\n+\t  && c->expr1->value.compcall.tbp->u.specific->n.sym->attr.subroutine)\n+\tc->expr1->value.compcall.tbp->subroutine = 1;\n+      else\n+\t{\n+\t  gfc_error (\"%qs at %L should be a SUBROUTINE\",\n+\t\t     c->expr1->value.compcall.name, &c->loc);\n+\t  return false;\n+\t}\n     }\n \n   if (!check_typebound_baseobject (c->expr1))"}, {"sha": "d011aa73e380bb52918225717001449c1bbbbd61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "patch": "@@ -1,3 +1,8 @@\n+2017-08-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/86863\n+\t* gfortran.dg/submodule_32.f08: New test.\n+\n 2018-08-22  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/86935"}, {"sha": "529015b86ec978ec017b3c0fa276076528365b87", "filename": "gcc/testsuite/gfortran.dg/submodule_32.f08", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_32.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab6c0c3bb09707f993a748c67087838f6b7d5f9/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_32.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsubmodule_32.f08?ref=6ab6c0c3bb09707f993a748c67087838f6b7d5f9", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR86863, where the Type Bound Procedures were\n+! not flagged as subroutines thereby causing an error at the call\n+! statements.\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+module foo\n+  implicit none\n+  integer :: flag = 0\n+  type bar\n+  contains\n+    procedure, nopass :: foobar\n+    procedure, nopass :: barfoo\n+  end type\n+contains\n+  subroutine foobar\n+    flag = 1\n+  end subroutine\n+  subroutine barfoo\n+    flag = 0\n+  end subroutine\n+end module\n+\n+module foobartoo\n+  implicit none\n+  interface\n+    module subroutine set(object)\n+      use foo\n+      implicit none\n+      type(bar) object\n+    end subroutine\n+    module subroutine unset(object)\n+      use foo\n+      implicit none\n+      type(bar) object\n+    end subroutine\n+  end interface\n+contains\n+  module procedure unset\n+    use foo, only : bar\n+    call object%barfoo\n+  end procedure\n+end module\n+\n+submodule(foobartoo) subfoobar\n+contains\n+  module procedure set\n+    use foo, only : bar\n+    call object%foobar\n+  end procedure\n+end submodule\n+\n+  use foo\n+  use foobartoo\n+  type(bar) :: obj\n+  call set(obj)\n+  if (flag .ne. 1) stop 1\n+  call unset(obj)\n+  if (flag .ne. 0) stop 2\n+end"}]}