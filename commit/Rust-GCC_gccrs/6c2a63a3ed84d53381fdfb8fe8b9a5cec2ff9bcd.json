{"sha": "6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMyYTYzYTNlZDg0ZDUzMzgxZmRmYjhmZThiOWE1Y2VjMmZmOWJjZA==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2005-05-17T12:10:19Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2005-05-17T12:10:19Z"}, "message": "add tree-ssa-math-opts.c for real\n\nFrom-SVN: r99828", "tree": {"sha": "822339298f50c20ef2f0aed57294e6ce1f65434b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/822339298f50c20ef2f0aed57294e6ce1f65434b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "954cba2d6b5cf30c8f5311369a44a67db53b81bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954cba2d6b5cf30c8f5311369a44a67db53b81bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954cba2d6b5cf30c8f5311369a44a67db53b81bb"}], "stats": {"total": 169, "additions": 168, "deletions": 1}, "files": [{"sha": "93c58f74f48f4fc662ffd05d27c2e2a14d148613", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd", "patch": "@@ -1,3 +1,7 @@\n+2005-05-17  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* tree-ssa-math-opts.c: New file.\n+\n 2005-05-17  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* Makefile.in: Add tree-ssa-math-opts.c.\n@@ -6,7 +10,6 @@\n \t(fold_binary) <case PLUS_EXPR, case MINUS_EXPR>: Use it.\n \t* tree-pass.h (pass_cse_reciprocals): New.\n \t* tree-optimize.c (init_tree_optimization_passes): Run it.\n-\t* tree-ssa-math-opts.c: New file.\n \t* doc/passes.texi: Document the new pass.\n \n 2005-05-17  Richard Guenther  <rguenth@gcc.gnu.org>"}, {"sha": "1026704f06bfe21513af8287dde9fbb4c55361c1", "filename": "gcc/tree-ssa-math-opts.c", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=6c2a63a3ed84d53381fdfb8fe8b9a5cec2ff9bcd", "patch": "@@ -0,0 +1,164 @@\n+/* Global, SSA-based optimizations using mathematical identities.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Currently, the only mini-pass in this file tries to CSE reciprocal\n+   operations.  These are common in sequences such as this one:\n+\n+\tmodulus = sqrt(x*x + y*y + z*z);\n+\tx = x / modulus;\n+\ty = y / modulus;\n+\tz = z / modulus;\n+\n+   that can be optimized to\n+\n+\tmodulus = sqrt(x*x + y*y + z*z);\n+        rmodulus = 1.0 / modulus;\n+\tx = x * rmodulus;\n+\ty = y * rmodulus;\n+\tz = z * rmodulus;\n+\n+   We do this for loop invariant divisors, and with this pass whenever\n+   we notice that a division has the same divisor multiple times.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"tree-flow.h\"\n+#include \"real.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n+\n+static bool\n+gate_cse_reciprocals (void)\n+{\n+  return optimize && !optimize_size && flag_unsafe_math_optimizations;\n+}\n+\n+/* Check if DEF's uses include more than one floating-point division,\n+   and if so replace them by multiplications with the reciprocal.  If\n+   PHI is true, insert the reciprocal calculation before BSI, otherwise\n+   insert it after and move BSI to the new statement.\n+\n+   Does not check the type of DEF, nor that DEF is a GIMPLE register.\n+   This is done in the caller for speed, because otherwise this routine\n+   would be called for every definition and phi node.  */\n+static void\n+execute_cse_reciprocals_1 (block_stmt_iterator *bsi, tree def, bool phi)\n+{\n+  use_operand_p use_p;\n+  imm_use_iterator use_iter;\n+  tree t, new_stmt, type;\n+  int count = 0;\n+\n+  /* Find uses.  */\n+  FOR_EACH_IMM_USE_FAST (use_p, use_iter, def)\n+    {\n+      tree use_stmt = USE_STMT (use_p);\n+      if (TREE_CODE (use_stmt) == MODIFY_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == RDIV_EXPR\n+\t  && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 1) == def)\n+\t{\n+\t  if (++count == 2)\n+\t    break;\n+\t}\n+    }\n+\n+  if (count < 2)\n+    return;\n+\n+  /* Make a variable with the replacement and substitute it.  */\n+  type = TREE_TYPE (def);\n+  t = make_rename_temp (type, \"reciptmp\");\n+  new_stmt = build2 (MODIFY_EXPR, void_type_node, t,\n+\t\t     fold_build2 (RDIV_EXPR, type, build_real (type, dconst1),\n+\t\t\t\t  def));\n+\n+  if (phi)\n+    bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n+  else\n+    bsi_insert_after (bsi, new_stmt, BSI_NEW_STMT);\n+\n+  FOR_EACH_IMM_USE_SAFE (use_p, use_iter, def)\n+    {\n+      tree use_stmt = USE_STMT (use_p);\n+      if (use_stmt != new_stmt\n+\t  && TREE_CODE (use_stmt) == MODIFY_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (use_stmt, 1)) == RDIV_EXPR\n+\t  && TREE_OPERAND (TREE_OPERAND (use_stmt, 1), 1) == def)\n+\t{\n+\t  TREE_SET_CODE (TREE_OPERAND (use_stmt, 1), MULT_EXPR);\n+\t  SET_USE (use_p, t);\n+\t}\n+    }\n+}\n+\n+static void\n+execute_cse_reciprocals (void)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      tree phi, def;\n+      for (bsi = bsi_start (bb);\n+\t   !bsi_end_p (bsi) && TREE_CODE (bsi_stmt (bsi)) == LABEL_EXPR;\n+\t   bsi_next (&bsi))\n+        ;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  def = PHI_RESULT (phi);\n+\t  if (FLOAT_TYPE_P (TREE_TYPE (def))\n+\t      && is_gimple_reg (def))\n+\t    execute_cse_reciprocals_1 (&bsi, def, true);\n+\t}\n+\n+      for (; !bsi_end_p (bsi); bsi_next (&bsi))\n+        {\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && (def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF)) != NULL\n+\t      && FLOAT_TYPE_P (TREE_TYPE (def))\n+\t      && is_gimple_reg (def))\n+\t    execute_cse_reciprocals_1 (&bsi, def, false);\n+\t}\n+    }\n+}\n+\n+struct tree_opt_pass pass_cse_reciprocals =\n+{\n+  \"recip\",\t\t\t\t/* name */\n+  gate_cse_reciprocals,\t\t\t/* gate */\n+  execute_cse_reciprocals,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_update_ssa | TODO_verify_ssa\n+    | TODO_verify_stmts,                /* todo_flags_finish */\n+  0\t\t\t\t        /* letter */\n+};"}]}