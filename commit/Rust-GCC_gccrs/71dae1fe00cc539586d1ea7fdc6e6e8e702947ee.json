{"sha": "71dae1fe00cc539586d1ea7fdc6e6e8e702947ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkYWUxZmUwMGNjNTM5NTg2ZDFlYTdmZGM2ZTZlOGU3MDI5NDdlZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-03-28T23:55:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-03-28T23:55:47Z"}, "message": "re PR debug/48253 (Further .debug_aranges issues)\n\n\tPR debug/48253\n\t* dwarf2out.c (struct dw_fde_struct): Remove dw_fde_hot_section_label,\n\tdw_fde_hot_section_end_label, dw_fde_unlikely_section_label,\n\tdw_fde_unlikely_section_end_label, cold_in_std_section,\n\tdw_fde_switched_sections and dw_fde_switched_cold_to_hot fields.\n\tAdd dw_fde_second_begin, dw_fde_second_end and second_in_std_section\n\tfields.\n\t(output_fde): Use dw_fde_second_{begin,end} if second is\n\ttrue, otherwise dw_fde_{begin,end}.\n\t(output_call_frame_info): Test dw_fde_second_begin != NULL\n\tinstead of dw_fde_switched_sections.\n\t(dwarf2out_begin_prologue): Stop initializing removed dw_fde_struct\n\tfields, initialize new fields.  Initialize in_std_section\n\tunconditionally from the first partition.\n\t(dwarf2out_end_epilogue): Don't override dw_fde_end when\n\tdw_fde_second_begin is non-NULL.\n\t(dwarf2out_switch_text_section): Stop initializing removed\n\tdw_fde_struct fields, initialize new fields, initialize\n\talso dw_fde_end here.  Set dw_fde_switch_cfi even when\n\tdwarf2out_do_cfi_asm ().  Call var_location_switch_text_section.\n\t(struct var_loc_list_def): Add last_before_switch field.\n\t(arange_table, arange_table_allocated, arange_table_in_use,\n\tARANGE_TABLE_INCREMENT, add_arange): Removed.\n\t(size_of_aranges): Count !in_std_section and !second_in_std_section\n\thunks in fdes, instead of looking at arange_table_in_use.\n\t(output_aranges): Add aranges_length argument, don't call\n\tsize_of_aranges here.  Instead of using aranges_table*\n\temit ranges for fdes when !in_std_section resp.\n\t!second_in_std_section.\n\t(dw_loc_list): Break ranges crossing section switch.\n\t(convert_cfa_to_fb_loc_list): Likewise.  If switched sections,\n\tuse dw_fde_second_end instead of dw_fde_end as end of last\n\trange.\n\t(gen_subprogram_die): Don't call add_arange.  Use\n\tdw_fde_{begin,end} for first partition and if switched\n\tsection dw_fde_second_{begin,end} for the second.\n\t(var_location_switch_text_section_1,\n\tvar_location_switch_text_section): New functions.\n\t(dwarf2out_begin_function): Initialize cold_text_section even\n\twhen function_section () isn't text_section.\n\t(prune_unused_types): Don't walk arange_table.\n\t(dwarf2out_finish): Don't needlessly test\n\tflag_reorder_blocks_and_partition when testing cold_text_section_used.\n\tIf info_section_emitted, call size_of_aranges and if it indicates\n\tnon-empty .debug_aranges, call output_aranges with the computed\n\tsize.  Stop using removed dw_fde_struct fields, use\n\tdw_fde_{begin,end} for first partition and dw_fde_second_{begin,end}\n\tfor second.\n\nFrom-SVN: r171642", "tree": {"sha": "f976a5e6498a598e52b59e37b6c3993ad58594c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f976a5e6498a598e52b59e37b6c3993ad58594c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e867454908aaa8192f214865b3978a104671fe45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e867454908aaa8192f214865b3978a104671fe45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e867454908aaa8192f214865b3978a104671fe45"}], "stats": {"total": 527, "additions": 284, "deletions": 243}, "files": [{"sha": "3b84d4007f479db8232eb13f44430b24524886ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71dae1fe00cc539586d1ea7fdc6e6e8e702947ee", "patch": "@@ -1,5 +1,54 @@\n 2011-03-29  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR debug/48253\n+\t* dwarf2out.c (struct dw_fde_struct): Remove dw_fde_hot_section_label,\n+\tdw_fde_hot_section_end_label, dw_fde_unlikely_section_label,\n+\tdw_fde_unlikely_section_end_label, cold_in_std_section,\n+\tdw_fde_switched_sections and dw_fde_switched_cold_to_hot fields.\n+\tAdd dw_fde_second_begin, dw_fde_second_end and second_in_std_section\n+\tfields.\n+\t(output_fde): Use dw_fde_second_{begin,end} if second is\n+\ttrue, otherwise dw_fde_{begin,end}.\n+\t(output_call_frame_info): Test dw_fde_second_begin != NULL\n+\tinstead of dw_fde_switched_sections.\n+\t(dwarf2out_begin_prologue): Stop initializing removed dw_fde_struct\n+\tfields, initialize new fields.  Initialize in_std_section\n+\tunconditionally from the first partition.\n+\t(dwarf2out_end_epilogue): Don't override dw_fde_end when\n+\tdw_fde_second_begin is non-NULL.\n+\t(dwarf2out_switch_text_section): Stop initializing removed\n+\tdw_fde_struct fields, initialize new fields, initialize\n+\talso dw_fde_end here.  Set dw_fde_switch_cfi even when\n+\tdwarf2out_do_cfi_asm ().  Call var_location_switch_text_section.\n+\t(struct var_loc_list_def): Add last_before_switch field.\n+\t(arange_table, arange_table_allocated, arange_table_in_use,\n+\tARANGE_TABLE_INCREMENT, add_arange): Removed.\n+\t(size_of_aranges): Count !in_std_section and !second_in_std_section\n+\thunks in fdes, instead of looking at arange_table_in_use.\n+\t(output_aranges): Add aranges_length argument, don't call\n+\tsize_of_aranges here.  Instead of using aranges_table*\n+\temit ranges for fdes when !in_std_section resp.\n+\t!second_in_std_section.\n+\t(dw_loc_list): Break ranges crossing section switch.\n+\t(convert_cfa_to_fb_loc_list): Likewise.  If switched sections,\n+\tuse dw_fde_second_end instead of dw_fde_end as end of last\n+\trange.\n+\t(gen_subprogram_die): Don't call add_arange.  Use\n+\tdw_fde_{begin,end} for first partition and if switched\n+\tsection dw_fde_second_{begin,end} for the second.\n+\t(var_location_switch_text_section_1,\n+\tvar_location_switch_text_section): New functions.\n+\t(dwarf2out_begin_function): Initialize cold_text_section even\n+\twhen function_section () isn't text_section.\n+\t(prune_unused_types): Don't walk arange_table.\n+\t(dwarf2out_finish): Don't needlessly test\n+\tflag_reorder_blocks_and_partition when testing cold_text_section_used.\n+\tIf info_section_emitted, call size_of_aranges and if it indicates\n+\tnon-empty .debug_aranges, call output_aranges with the computed\n+\tsize.  Stop using removed dw_fde_struct fields, use\n+\tdw_fde_{begin,end} for first partition and dw_fde_second_{begin,end}\n+\tfor second.\n+\n \tPR debug/48203\n \t* cfgexpand.c (expand_debug_expr) <case SSA_NAME>: Only\n \tcreate ENTRY_VALUE if incoming or address of incoming's MEM"}, {"sha": "7803ab7f9c07fa37dd9740334bd63549995c7dde", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 235, "deletions": 243, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dae1fe00cc539586d1ea7fdc6e6e8e702947ee/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=71dae1fe00cc539586d1ea7fdc6e6e8e702947ee", "patch": "@@ -302,10 +302,8 @@ typedef struct GTY(()) dw_fde_struct {\n   const char *dw_fde_end;\n   const char *dw_fde_vms_end_prologue;\n   const char *dw_fde_vms_begin_epilogue;\n-  const char *dw_fde_hot_section_label;\n-  const char *dw_fde_hot_section_end_label;\n-  const char *dw_fde_unlikely_section_label;\n-  const char *dw_fde_unlikely_section_end_label;\n+  const char *dw_fde_second_begin;\n+  const char *dw_fde_second_end;\n   dw_cfi_ref dw_fde_cfi;\n   dw_cfi_ref dw_fde_switch_cfi; /* Last CFI before switching sections.  */\n   HOST_WIDE_INT stack_realignment;\n@@ -324,13 +322,9 @@ typedef struct GTY(()) dw_fde_struct {\n   unsigned drap_reg_saved: 1;\n   /* True iff dw_fde_begin label is in text_section or cold_text_section.  */\n   unsigned in_std_section : 1;\n-  /* True iff dw_fde_unlikely_section_label is in text_section or\n+  /* True iff dw_fde_second_begin label is in text_section or\n      cold_text_section.  */\n-  unsigned cold_in_std_section : 1;\n-  /* True iff switched sections.  */\n-  unsigned dw_fde_switched_sections : 1;\n-  /* True iff switching from cold to hot section.  */\n-  unsigned dw_fde_switched_cold_to_hot : 1;\n+  unsigned second_in_std_section : 1;\n }\n dw_fde_node;\n \n@@ -3628,28 +3622,8 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n     dw2_asm_output_offset (DWARF_OFFSET_SIZE, section_start_label,\n \t\t\t   debug_frame_section, \"FDE CIE offset\");\n \n-  if (!fde->dw_fde_switched_sections)\n-    {\n-      begin = fde->dw_fde_begin;\n-      end = fde->dw_fde_end;\n-    }\n-  else\n-    {\n-      /* For the first section, prefer dw_fde_begin over\n-\t dw_fde_{hot,cold}_section_label, as the latter\n-\t might be separated from the real start of the\n-\t function by alignment padding.  */\n-      if (!second)\n-\tbegin = fde->dw_fde_begin;\n-      else if (fde->dw_fde_switched_cold_to_hot)\n-\tbegin = fde->dw_fde_hot_section_label;\n-      else\n-\tbegin = fde->dw_fde_unlikely_section_label;\n-      if (second ^ fde->dw_fde_switched_cold_to_hot)\n-\tend = fde->dw_fde_unlikely_section_end_label;\n-      else\n-\tend = fde->dw_fde_hot_section_end_label;\n-    }\n+  begin = second ? fde->dw_fde_second_begin : fde->dw_fde_begin;\n+  end = second ? fde->dw_fde_second_end : fde->dw_fde_end;\n \n   if (for_eh)\n     {\n@@ -3710,7 +3684,7 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n   /* Loop through the Call Frame Instructions associated with\n      this FDE.  */\n   fde->dw_fde_current_label = begin;\n-  if (!fde->dw_fde_switched_sections)\n+  if (fde->dw_fde_second_begin == NULL)\n     for (cfi = fde->dw_fde_cfi; cfi != NULL; cfi = cfi->dw_cfi_next)\n       output_cfi (cfi, fde, for_eh);\n   else if (!second)\n@@ -3989,7 +3963,7 @@ output_call_frame_info (int for_eh)\n       if (for_eh && !fde_needed_for_eh_p (fde))\n \tcontinue;\n \n-      for (k = 0; k < (fde->dw_fde_switched_sections ? 2 : 1); k++)\n+      for (k = 0; k < (fde->dw_fde_second_begin ? 2 : 1); k++)\n \toutput_fde (fde, for_eh, k, section_start_label, fde_encoding,\n \t\t    augmentation, any_lsda_needed, lsda_encoding);\n     }\n@@ -4107,14 +4081,10 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde = &fde_table[fde_table_in_use++];\n   fde->decl = current_function_decl;\n   fde->dw_fde_begin = dup_label;\n-  fde->dw_fde_current_label = dup_label;\n-  fde->dw_fde_hot_section_label = NULL;\n-  fde->dw_fde_hot_section_end_label = NULL;\n-  fde->dw_fde_unlikely_section_label = NULL;\n-  fde->dw_fde_unlikely_section_end_label = NULL;\n-  fde->dw_fde_switched_sections = 0;\n-  fde->dw_fde_switched_cold_to_hot = 0;\n   fde->dw_fde_end = NULL;\n+  fde->dw_fde_current_label = dup_label;\n+  fde->dw_fde_second_begin = NULL;\n+  fde->dw_fde_second_end = NULL;\n   fde->dw_fde_vms_end_prologue = NULL;\n   fde->dw_fde_vms_begin_epilogue = NULL;\n   fde->dw_fde_cfi = NULL;\n@@ -4125,27 +4095,9 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->nothrow = crtl->nothrow;\n   fde->drap_reg = INVALID_REGNUM;\n   fde->vdrap_reg = INVALID_REGNUM;\n-  if (flag_reorder_blocks_and_partition)\n-    {\n-      section *unlikelysec;\n-      if (first_function_block_is_cold)\n-\tfde->in_std_section = 1;\n-      else\n-\tfde->in_std_section\n-\t  = (fnsec == text_section\n-\t     || (cold_text_section && fnsec == cold_text_section));\n-      unlikelysec = unlikely_text_section ();\n-      fde->cold_in_std_section\n-\t= (unlikelysec == text_section\n-\t   || (cold_text_section && unlikelysec == cold_text_section));\n-    }\n-  else\n-    {\n-      fde->in_std_section\n-\t= (fnsec == text_section\n-\t   || (cold_text_section && fnsec == cold_text_section));\n-      fde->cold_in_std_section = 0;\n-    }\n+  fde->in_std_section = (fnsec == text_section\n+\t\t\t || (cold_text_section && fnsec == cold_text_section));\n+  fde->second_in_std_section = 0;\n \n   args_size = old_args_size = 0;\n \n@@ -4241,7 +4193,8 @@ dwarf2out_end_epilogue (unsigned int line ATTRIBUTE_UNUSED,\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n   fde = current_fde ();\n   gcc_assert (fde != NULL);\n-  fde->dw_fde_end = xstrdup (label);\n+  if (fde->dw_fde_second_begin == NULL)\n+    fde->dw_fde_end = xstrdup (label);\n }\n \n void\n@@ -4288,20 +4241,29 @@ dwarf2out_note_section_used (void)\n     cold_text_section_used = true;\n }\n \n+static void var_location_switch_text_section (void);\n+\n void\n dwarf2out_switch_text_section (void)\n {\n+  section *sect;\n   dw_fde_ref fde = current_fde ();\n+  dw_cfi_ref cfi;\n \n-  gcc_assert (cfun && fde && !fde->dw_fde_switched_sections);\n-\n-  fde->dw_fde_switched_sections = 1;\n-  fde->dw_fde_switched_cold_to_hot = !in_cold_section_p;\n+  gcc_assert (cfun && fde && fde->dw_fde_second_begin == NULL);\n \n-  fde->dw_fde_hot_section_label = crtl->subsections.hot_section_label;\n-  fde->dw_fde_hot_section_end_label = crtl->subsections.hot_section_end_label;\n-  fde->dw_fde_unlikely_section_label = crtl->subsections.cold_section_label;\n-  fde->dw_fde_unlikely_section_end_label = crtl->subsections.cold_section_end_label;\n+  if (!in_cold_section_p)\n+    {\n+      fde->dw_fde_end = crtl->subsections.cold_section_end_label;\n+      fde->dw_fde_second_begin = crtl->subsections.hot_section_label;\n+      fde->dw_fde_second_end = crtl->subsections.hot_section_end_label;\n+    }\n+  else\n+    {\n+      fde->dw_fde_end = crtl->subsections.hot_section_end_label;\n+      fde->dw_fde_second_begin = crtl->subsections.cold_section_label;\n+      fde->dw_fde_second_end = crtl->subsections.cold_section_end_label;\n+    }\n   have_multiple_function_sections = true;\n \n   /* Reset the current label on switching text sections, so that we\n@@ -4316,7 +4278,12 @@ dwarf2out_switch_text_section (void)\n     fprintf (asm_out_file, \"\\t.cfi_endproc\\n\");\n \n   /* Now do the real section switch.  */\n-  switch_to_section (current_function_section ());\n+  sect = current_function_section ();\n+  switch_to_section (sect);\n+\n+  fde->second_in_std_section\n+    = (sect == text_section\n+       || (cold_text_section && sect == cold_text_section));\n \n   if (dwarf2out_do_cfi_asm ())\n     {\n@@ -4325,16 +4292,12 @@ dwarf2out_switch_text_section (void)\n \t again.  */\n       output_cfis (fde->dw_fde_cfi, true, fde, true);\n     }\n-  else\n-    {\n-      dw_cfi_ref cfi = fde->dw_fde_cfi;\n-\n-      cfi = fde->dw_fde_cfi;\n-      if (cfi)\n-\twhile (cfi->dw_cfi_next != NULL)\n-\t  cfi = cfi->dw_cfi_next;\n-      fde->dw_fde_switch_cfi = cfi;\n-    }\n+  cfi = fde->dw_fde_cfi;\n+  if (cfi)\n+    while (cfi->dw_cfi_next != NULL)\n+      cfi = cfi->dw_cfi_next;\n+  fde->dw_fde_switch_cfi = cfi;\n+  var_location_switch_text_section ();\n }\n \f\n /* And now, the subset of the debugging information support code necessary\n@@ -6122,6 +6085,11 @@ struct GTY (()) var_loc_list_def {\n      Do not mark it for GC because it is marked through the chain.  */\n   struct var_loc_node * GTY ((skip (\"%h\"))) last;\n \n+  /* Pointer to the last element before section switch,\n+     if NULL, either sections weren't switched or first\n+     is after section switch.  */\n+  struct var_loc_node * GTY ((skip (\"%h\"))) last_before_switch;\n+\n   /* DECL_UID of the variable decl.  */\n   unsigned int decl_id;\n };\n@@ -6212,19 +6180,6 @@ static GTY (()) VEC (pubname_entry, gc) * pubtype_table;\n    defines/undefines (and file start/end markers).  */\n static GTY (()) VEC (macinfo_entry, gc) * macinfo_table;\n \n-/* Array of dies for which we should generate .debug_arange info.  */\n-static GTY((length (\"arange_table_allocated\"))) dw_die_ref *arange_table;\n-\n-/* Number of elements currently allocated for arange_table.  */\n-static GTY(()) unsigned arange_table_allocated;\n-\n-/* Number of elements in arange_table currently in use.  */\n-static GTY(()) unsigned arange_table_in_use;\n-\n-/* Size (in elements) of increments by which we may expand the\n-   arange_table.  */\n-#define ARANGE_TABLE_INCREMENT 64\n-\n /* Array of dies for which we should generate .debug_ranges info.  */\n static GTY ((length (\"ranges_table_allocated\"))) dw_ranges_ref ranges_table;\n \n@@ -6432,8 +6387,7 @@ static void add_pubname (tree, dw_die_ref);\n static void add_pubname_string (const char *, dw_die_ref);\n static void add_pubtype (tree, dw_die_ref);\n static void output_pubnames (VEC (pubname_entry,gc) *);\n-static void add_arange (tree, dw_die_ref);\n-static void output_aranges (void);\n+static void output_aranges (unsigned long);\n static unsigned int add_ranges_num (int);\n static unsigned int add_ranges (const_tree);\n static void add_ranges_by_labels (dw_die_ref, const char *, const char *,\n@@ -10881,7 +10835,20 @@ size_of_aranges (void)\n     size += 2 * DWARF2_ADDR_SIZE;\n   if (cold_text_section_used)\n     size += 2 * DWARF2_ADDR_SIZE;\n-  size += 2 * DWARF2_ADDR_SIZE * arange_table_in_use;\n+  if (have_multiple_function_sections)\n+    {\n+      unsigned fde_idx = 0;\n+\n+      for (fde_idx = 0; fde_idx < fde_table_in_use; fde_idx++)\n+\t{\n+\t  dw_fde_ref fde = &fde_table[fde_idx];\n+\n+\t  if (!fde->in_std_section)\n+\t    size += 2 * DWARF2_ADDR_SIZE;\n+\t  if (fde->dw_fde_second_begin && !fde->second_in_std_section)\n+\t    size += 2 * DWARF2_ADDR_SIZE;\n+\t}\n+    }\n \n   /* Count the two zero words used to terminated the address range table.  */\n   size += 2 * DWARF2_ADDR_SIZE;\n@@ -11712,35 +11679,14 @@ output_pubnames (VEC (pubname_entry, gc) * names)\n   dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, NULL);\n }\n \n-/* Add a new entry to .debug_aranges if appropriate.  */\n-\n-static void\n-add_arange (tree decl, dw_die_ref die)\n-{\n-  if (! DECL_SECTION_NAME (decl))\n-    return;\n-\n-  if (arange_table_in_use == arange_table_allocated)\n-    {\n-      arange_table_allocated += ARANGE_TABLE_INCREMENT;\n-      arange_table = GGC_RESIZEVEC (dw_die_ref, arange_table,\n-\t\t\t\t    arange_table_allocated);\n-      memset (arange_table + arange_table_in_use, 0,\n-\t      ARANGE_TABLE_INCREMENT * sizeof (dw_die_ref));\n-    }\n-\n-  arange_table[arange_table_in_use++] = die;\n-}\n-\n /* Output the information that goes into the .debug_aranges table.\n    Namely, define the beginning and ending address range of the\n    text section generated for this compilation unit.  */\n \n static void\n-output_aranges (void)\n+output_aranges (unsigned long aranges_length)\n {\n   unsigned i;\n-  unsigned long aranges_length = size_of_aranges ();\n \n   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n@@ -11785,38 +11731,28 @@ output_aranges (void)\n \t\t\t    cold_text_section_label, \"Length\");\n     }\n \n-  for (i = 0; i < arange_table_in_use; i++)\n+  if (have_multiple_function_sections)\n     {\n-      dw_die_ref die = arange_table[i];\n-\n-      /* We shouldn't see aranges for DIEs outside of the main CU.  */\n-      gcc_assert (die->die_mark);\n+      unsigned fde_idx = 0;\n \n-      if (die->die_tag == DW_TAG_subprogram)\n-\t{\n-\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, get_AT_low_pc (die),\n-\t\t\t       \"Address\");\n-\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, get_AT_hi_pc (die),\n-\t\t\t\tget_AT_low_pc (die), \"Length\");\n-\t}\n-      else\n+      for (fde_idx = 0; fde_idx < fde_table_in_use; fde_idx++)\n \t{\n-\t  /* A static variable; extract the symbol from DW_AT_location.\n-\t     Note that this code isn't currently hit, as we only emit\n-\t     aranges for functions (jason 9/23/99).  */\n-\t  dw_attr_ref a = get_AT (die, DW_AT_location);\n-\t  dw_loc_descr_ref loc;\n-\n-\t  gcc_assert (a && AT_class (a) == dw_val_class_loc);\n-\n-\t  loc = AT_loc (a);\n-\t  gcc_assert (loc->dw_loc_opc == DW_OP_addr);\n-\n-\t  dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE,\n-\t\t\t\t   loc->dw_loc_oprnd1.v.val_addr, \"Address\");\n-\t  dw2_asm_output_data (DWARF2_ADDR_SIZE,\n-\t\t\t       get_AT_unsigned (die, DW_AT_byte_size),\n-\t\t\t       \"Length\");\n+\t  dw_fde_ref fde = &fde_table[fde_idx];\n+\n+\t  if (!fde->in_std_section)\n+\t    {\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde->dw_fde_begin,\n+\t\t\t\t   \"Address\");\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, fde->dw_fde_end,\n+\t\t\t\t    fde->dw_fde_begin, \"Length\");\n+\t    }\n+\t  if (fde->dw_fde_second_begin && !fde->second_in_std_section)\n+\t    {\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, fde->dw_fde_second_begin,\n+\t\t\t\t   \"Address\");\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, fde->dw_fde_second_end,\n+\t\t\t\t    fde->dw_fde_second_begin, \"Length\");\n+\t    }\n \t}\n     }\n \n@@ -15132,9 +15068,23 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n \t  }\n \tif (descr)\n \t  {\n+\t    bool range_across_switch = false;\n+\t    /* If section switch happens in between node->label\n+\t       and node->next->label (or end of function) and\n+\t       we can't emit it as a single entry list,\n+\t       emit two ranges, first one ending at the end\n+\t       of first partition and second one starting at the\n+\t       beginning of second partition.  */\n+\t    if (node == loc_list->last_before_switch\n+\t\t&& (node != loc_list->first || loc_list->first->next)\n+\t\t&& current_function_decl)\n+\t      {\n+\t\tendname = current_fde ()->dw_fde_end;\n+\t\trange_across_switch = true;\n+\t      }\n \t    /* The variable has a location between NODE->LABEL and\n \t       NODE->NEXT->LABEL.  */\n-\t    if (node->next)\n+\t    else if (node->next)\n \t      endname = node->next->label;\n \t    /* If the variable has a location at the last label\n \t       it keeps its location until the end of function.  */\n@@ -15149,6 +15099,30 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n \n \t    *listp = new_loc_list (descr, node->label, endname, secname);\n \t    listp = &(*listp)->dw_loc_next;\n+\n+\t    if (range_across_switch)\n+\t      {\n+\t\tif (GET_CODE (node->loc) == EXPR_LIST)\n+\t\t  descr = dw_sra_loc_expr (decl, node->loc);\n+\t\telse\n+\t\t  {\n+\t\t    initialized = NOTE_VAR_LOCATION_STATUS (node->loc);\n+\t\t    varloc = NOTE_VAR_LOCATION (node->loc);\n+\t\t    descr = dw_loc_list_1 (decl, varloc, want_address,\n+\t\t\t\t\t   initialized);\n+\t\t  }\n+\t\tgcc_assert (descr);\n+\t\t/* The variable has a location between NODE->LABEL and\n+\t\t   NODE->NEXT->LABEL.  */\n+\t\tif (node->next)\n+\t\t  endname = node->next->label;\n+\t\telse\n+\t\t  endname = current_fde ()->dw_fde_second_end;\n+\t\t*listp = new_loc_list (descr,\n+\t\t\t\t       current_fde ()->dw_fde_second_begin,\n+\t\t\t\t       endname, secname);\n+\t\tlistp = &(*listp)->dw_loc_next;\n+\t      }\n \t  }\n       }\n \n@@ -17234,33 +17208,61 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n   last_cfa = next_cfa;\n   last_label = start_label;\n \n+  if (fde->dw_fde_second_begin && fde->dw_fde_switch_cfi == NULL)\n+    {\n+      /* If the first partition contained no CFI adjustments, the\n+\t CIE opcodes apply to the whole first partition.  */\n+      *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n+\t\t\t\t fde->dw_fde_begin, fde->dw_fde_end, section);\n+      list_tail =&(*list_tail)->dw_loc_next;\n+      start_label = last_label = fde->dw_fde_second_begin;\n+    }\n+\n   for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n-    switch (cfi->dw_cfi_opc)\n-      {\n-      case DW_CFA_set_loc:\n-      case DW_CFA_advance_loc1:\n-      case DW_CFA_advance_loc2:\n-      case DW_CFA_advance_loc4:\n-\tif (!cfa_equal_p (&last_cfa, &next_cfa))\n-\t  {\n-\t    *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t       start_label, last_label, section);\n+    {\n+      switch (cfi->dw_cfi_opc)\n+\t{\n+\tcase DW_CFA_set_loc:\n+\tcase DW_CFA_advance_loc1:\n+\tcase DW_CFA_advance_loc2:\n+\tcase DW_CFA_advance_loc4:\n+\t  if (!cfa_equal_p (&last_cfa, &next_cfa))\n+\t    {\n+\t      *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n+\t\t\t\t\t start_label, last_label, section);\n \n-\t    list_tail = &(*list_tail)->dw_loc_next;\n-\t    last_cfa = next_cfa;\n-\t    start_label = last_label;\n-\t  }\n-\tlast_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n-\tbreak;\n+\t      list_tail = &(*list_tail)->dw_loc_next;\n+\t      last_cfa = next_cfa;\n+\t      start_label = last_label;\n+\t    }\n+\t  last_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n+\t  break;\n \n-      case DW_CFA_advance_loc:\n-\t/* The encoding is complex enough that we should never emit this.  */\n-\tgcc_unreachable ();\n+\tcase DW_CFA_advance_loc:\n+\t  /* The encoding is complex enough that we should never emit this.  */\n+\t  gcc_unreachable ();\n \n-      default:\n-\tlookup_cfa_1 (cfi, &next_cfa, &remember);\n-\tbreak;\n-      }\n+\tdefault:\n+\t  lookup_cfa_1 (cfi, &next_cfa, &remember);\n+\t  break;\n+\t}\n+      if (cfi == fde->dw_fde_switch_cfi)\n+\t{\n+\t  if (!cfa_equal_p (&last_cfa, &next_cfa))\n+\t    {\n+\t      *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n+\t\t\t\t\t start_label, last_label, section);\n+\n+\t      list_tail = &(*list_tail)->dw_loc_next;\n+\t      last_cfa = next_cfa;\n+\t      start_label = last_label;\n+\t    }\n+\t  *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n+\t\t\t\t     start_label, fde->dw_fde_end, section);\n+\t  list_tail = &(*list_tail)->dw_loc_next;\n+\t  start_label = last_label = fde->dw_fde_second_begin;\n+\t}\n+    }\n \n   if (!cfa_equal_p (&last_cfa, &next_cfa))\n     {\n@@ -17271,7 +17273,10 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n     }\n \n   *list_tail = new_loc_list (build_cfa_loc (&next_cfa, offset),\n-\t\t\t     start_label, fde->dw_fde_end, section);\n+\t\t\t     start_label,\n+\t\t\t     fde->dw_fde_second_begin\n+\t\t\t     ? fde->dw_fde_second_end : fde->dw_fde_end,\n+\t\t\t     section);\n \n   if (list && list->dw_loc_next)\n     gen_llsym (list);\n@@ -19196,14 +19201,13 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n #endif\n \n \t  add_pubname (decl, subr_die);\n-\t  add_arange (decl, subr_die);\n \t}\n       else\n \t{  /* Generate pubnames entries for the split function code\n \t      ranges.  */\n \t  dw_fde_ref fde = &fde_table[current_funcdef_fde];\n \n-\t  if (fde->dw_fde_switched_sections)\n+\t  if (fde->dw_fde_second_begin)\n \t    {\n \t      if (dwarf_version >= 3 || !dwarf_strict)\n \t\t{\n@@ -19212,28 +19216,11 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t     section, since the HOT/COLD labels might precede an \n \t\t     alignment offset.  */\n \t\t  bool range_list_added = false;\n-\t\t  if (fde->in_std_section)\n-\t\t    {\n-\t\t      add_ranges_by_labels (subr_die,\n-\t\t\t\t\t    fde->dw_fde_begin,\n-\t\t\t\t\t    fde->dw_fde_end,\n-\t\t\t\t\t    &range_list_added);\n-\t\t      add_ranges_by_labels (subr_die,\n-\t\t\t\t\t    fde->dw_fde_unlikely_section_label,\n-\t\t\t\t\t    fde->dw_fde_unlikely_section_end_label,\n-\t\t\t\t\t    &range_list_added);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      add_ranges_by_labels (subr_die,\n-\t\t\t\t\t    fde->dw_fde_begin,\n-\t\t\t\t\t    fde->dw_fde_end,\n-\t\t\t\t\t    &range_list_added);\n-\t\t      add_ranges_by_labels (subr_die,\n-\t\t\t\t\t    fde->dw_fde_hot_section_label,\n-\t\t\t\t\t    fde->dw_fde_hot_section_end_label,\n-\t\t\t\t\t    &range_list_added);\n-\t\t    }\n+\t\t  add_ranges_by_labels (subr_die, fde->dw_fde_begin,\n+\t\t\t\t\tfde->dw_fde_end, &range_list_added);\n+\t\t  add_ranges_by_labels (subr_die, fde->dw_fde_second_begin,\n+\t\t\t\t\tfde->dw_fde_second_end,\n+\t\t\t\t\t&range_list_added);\n \t\t  add_pubname (decl, subr_die);\n \t\t  if (range_list_added)\n \t\t    add_ranges (NULL);\n@@ -19258,7 +19245,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t\t\t fde->dw_fde_end);\n \t\t  /* Add it.   */\n \t\t  add_pubname (decl, subr_die);\n-\t\t  add_arange (decl, subr_die);\n \n \t\t  /* Build a minimal DIE for the secondary section.  */\n \t\t  seg_die = new_die (DW_TAG_subprogram,\n@@ -19276,38 +19262,25 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n \t\t      add_linkage_name (seg_die, decl);\n \t\t    }\n-\t\t  gcc_assert (name!=NULL);\n+\t\t  gcc_assert (name != NULL);\n \t\t  add_pure_or_virtual_attribute (seg_die, decl);\n \t\t  if (DECL_ARTIFICIAL (decl))\n \t\t    add_AT_flag (seg_die, DW_AT_artificial, 1);\n \n-\t\t  if (fde->in_std_section)\n-\t\t    {\n-\t\t      name = concat (\"__cold_sect_of_\", name, NULL); \n-\t\t      add_AT_lbl_id (seg_die, DW_AT_low_pc,\n-\t\t\t\t     fde->dw_fde_unlikely_section_label);\n-\t\t      add_AT_lbl_id (seg_die, DW_AT_high_pc,\n-\t\t\t\t     fde->dw_fde_unlikely_section_end_label); \n-\t\t    }\n-\t\t  else \n-\t\t    {\n-\t\t      name = concat (\"__hot_sect_of_\", name, NULL); \n-\t\t      add_AT_lbl_id (seg_die, DW_AT_low_pc,\n-\t\t\t\t     fde->dw_fde_hot_section_label);\n-\t\t      add_AT_lbl_id (seg_die, DW_AT_high_pc,\n-\t\t\t\t     fde->dw_fde_hot_section_end_label); \n-\t\t    }\n+\t\t  name = concat (\"__second_sect_of_\", name, NULL); \n+\t\t  add_AT_lbl_id (seg_die, DW_AT_low_pc,\n+\t\t\t\t fde->dw_fde_second_begin);\n+\t\t  add_AT_lbl_id (seg_die, DW_AT_high_pc,\n+\t\t\t\t fde->dw_fde_second_end);\n \t\t  add_name_attribute (seg_die, name);\n \t\t  add_pubname_string (name, seg_die);\n-\t\t  add_arange (decl, seg_die);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      add_AT_lbl_id (subr_die, DW_AT_low_pc, fde->dw_fde_begin);\n \t      add_AT_lbl_id (subr_die, DW_AT_high_pc, fde->dw_fde_end);\n \t      add_pubname (decl, subr_die);\n-\t      add_arange (decl, subr_die);\n \t    }\n \t}\n \n@@ -22034,6 +22007,29 @@ dwarf2out_var_location (rtx loc_note)\n   last_in_cold_section_p = in_cold_section_p;\n }\n \n+/* Note in one location list that text section has changed.  */\n+\n+static int\n+var_location_switch_text_section_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  var_loc_list *list = (var_loc_list *) *slot;\n+  if (list->first)\n+    list->last_before_switch\n+      = list->last->next ? list->last->next : list->last;\n+  return 1;\n+}\n+\n+/* Note in all location lists that text section has changed.  */\n+\n+static void\n+var_location_switch_text_section (void)\n+{\n+  if (decl_loc_table == NULL)\n+    return;\n+\n+  htab_traverse (decl_loc_table, var_location_switch_text_section_1, NULL);\n+}\n+\n /* We need to reset the locations at the beginning of each\n    function. We can't do this in the end_function hook, because the\n    declarations that use the locations won't have been output when\n@@ -22044,7 +22040,7 @@ dwarf2out_begin_function (tree fun)\n {\n   if (function_section (fun) != text_section)\n     have_multiple_function_sections = true;\n-  else if (flag_reorder_blocks_and_partition && !cold_text_section)\n+  if (flag_reorder_blocks_and_partition && !cold_text_section)\n     {\n       gcc_assert (current_function_decl == fun);\n       cold_text_section = unlikely_text_section ();\n@@ -22754,11 +22750,9 @@ prune_unused_types (void)\n     }\n \n   /* Also set the mark on nodes referenced from the\n-     pubname_table or arange_table.  */\n+     pubname_table.  */\n   FOR_EACH_VEC_ELT (pubname_entry, pubname_table, i, pub)\n     prune_unused_types_mark (pub->die, 1);\n-  for (i = 0; i < arange_table_in_use; i++)\n-    prune_unused_types_mark (arange_table[i], 1);\n \n   /* Get rid of nodes that aren't marked; and update the string counts.  */\n   if (debug_str_hash && debug_str_hash_forced)\n@@ -23561,30 +23555,20 @@ dwarf2out_finish (const char *filename)\n       if (text_section_used)\n \tadd_ranges_by_labels (comp_unit_die (), text_section_label,\n \t\t\t      text_end_label, &range_list_added);\n-      if (flag_reorder_blocks_and_partition && cold_text_section_used)\n+      if (cold_text_section_used)\n \tadd_ranges_by_labels (comp_unit_die (), cold_text_section_label,\n \t\t\t      cold_end_label, &range_list_added);\n \n       for (fde_idx = 0; fde_idx < fde_table_in_use; fde_idx++)\n \t{\n \t  dw_fde_ref fde = &fde_table[fde_idx];\n \n-\t  if (fde->dw_fde_switched_sections)\n-\t    {\n-\t      if (!fde->in_std_section)\n-\t\tadd_ranges_by_labels (comp_unit_die (),\n-\t\t\t\t      fde->dw_fde_hot_section_label,\n-\t\t\t\t      fde->dw_fde_hot_section_end_label,\n-\t\t\t\t      &range_list_added);\n-\t      if (!fde->cold_in_std_section)\n-\t\tadd_ranges_by_labels (comp_unit_die (),\n-\t\t\t\t      fde->dw_fde_unlikely_section_label,\n-\t\t\t\t      fde->dw_fde_unlikely_section_end_label,\n-\t\t\t\t      &range_list_added);\n-\t    }\n-\t  else if (!fde->in_std_section)\n+\t  if (!fde->in_std_section)\n \t    add_ranges_by_labels (comp_unit_die (), fde->dw_fde_begin,\n \t\t\t\t  fde->dw_fde_end, &range_list_added);\n+\t  if (fde->dw_fde_second_begin && !fde->second_in_std_section)\n+\t    add_ranges_by_labels (comp_unit_die (), fde->dw_fde_second_begin,\n+\t\t\t\t  fde->dw_fde_second_end, &range_list_added);\n \t}\n \n       if (range_list_added)\n@@ -23684,13 +23668,21 @@ dwarf2out_finish (const char *filename)\n \t}\n     }\n \n-  /* Output the address range information.  We only put functions in the arange\n-     table, so don't write it out if we don't have any.  */\n-  if ((text_section_used || cold_text_section_used || arange_table_in_use)\n-      && info_section_emitted)\n+  /* Output the address range information.  We only put functions in the\n+     arange table, so don't write it out if we don't have any.  */\n+  if (info_section_emitted)\n     {\n-      switch_to_section (debug_aranges_section);\n-      output_aranges ();\n+      unsigned long aranges_length = size_of_aranges ();\n+\n+      /* Empty .debug_aranges would contain just header and\n+\t terminating 0,0.  */\n+      if (aranges_length\n+\t  != (unsigned long) (DWARF_ARANGES_HEADER_SIZE\n+\t\t\t      + 2 * DWARF2_ADDR_SIZE))\n+\t{\n+\t  switch_to_section (debug_aranges_section);\n+\t  output_aranges (aranges_length);\n+\t}\n     }\n \n   /* Output ranges section if necessary.  */"}]}