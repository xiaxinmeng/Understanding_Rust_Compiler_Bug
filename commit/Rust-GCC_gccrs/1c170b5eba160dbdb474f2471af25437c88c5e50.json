{"sha": "1c170b5eba160dbdb474f2471af25437c88c5e50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMxNzBiNWViYTE2MGRiZGI0NzRmMjQ3MWFmMjU0MzdjODhjNWU1MA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-28T14:24:29Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-28T14:24:29Z"}, "message": "tree-ssa-loop-ivopts.c: Fix a comment typo.\n\n\t* tree-ssa-loop-ivopts.c: Fix a comment typo.\n\t* doc/invoke.texi: Fix a typo.\n\nFrom-SVN: r89759", "tree": {"sha": "1449ce3c84e030e8ae70a3924d19e8b33c026d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1449ce3c84e030e8ae70a3924d19e8b33c026d54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c170b5eba160dbdb474f2471af25437c88c5e50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c170b5eba160dbdb474f2471af25437c88c5e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c170b5eba160dbdb474f2471af25437c88c5e50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c170b5eba160dbdb474f2471af25437c88c5e50/comments", "author": null, "committer": null, "parents": [{"sha": "f340a501f7fc0856b317f48ac328af520e292001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f340a501f7fc0856b317f48ac328af520e292001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f340a501f7fc0856b317f48ac328af520e292001"}], "stats": {"total": 9, "additions": 7, "deletions": 2}, "files": [{"sha": "af012f43b9477e24f36b07756b851cd478005f5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c170b5eba160dbdb474f2471af25437c88c5e50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c170b5eba160dbdb474f2471af25437c88c5e50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c170b5eba160dbdb474f2471af25437c88c5e50", "patch": "@@ -1,3 +1,8 @@\n+2004-10-28  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-loop-ivopts.c: Fix a comment typo.\n+\t* doc/invoke.texi: Fix a typo.\n+\n 2004-10-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* Makefile.in (OBJS-common): Remove duplicates."}, {"sha": "c1d48eddfc6b1f96198f3b8f115a107e00ed1c85", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c170b5eba160dbdb474f2471af25437c88c5e50/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c170b5eba160dbdb474f2471af25437c88c5e50/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1c170b5eba160dbdb474f2471af25437c88c5e50", "patch": "@@ -5322,7 +5322,7 @@ default value, 0, implies that GCC will select the most appropriate\n size itself.\n \n @item sra-field-structure-ratio\n-The treshold ratio (as a percentage) between instantiated fields and\n+The threshold ratio (as a percentage) between instantiated fields and\n the complete structure size.  We say that if the ratio of the number\n of bytes in instantiated fields to the number of bytes in the complete\n structure exceeds this parameter, then block copies are not used.  The"}, {"sha": "58771cd6c4d1d0bf69af1b7b599381abbedd0d68", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c170b5eba160dbdb474f2471af25437c88c5e50/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c170b5eba160dbdb474f2471af25437c88c5e50/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=1c170b5eba160dbdb474f2471af25437c88c5e50", "patch": "@@ -3615,7 +3615,7 @@ try_add_cand_for (struct ivopts_data *data, bitmap ivs, bitmap inv,\n      just one generic biv.  If we added here many ivs specific to the uses,\n      the optimization algorithm later would be likely to get stuck in a local\n      minimum, thus causing us to create too many ivs.  The approach from\n-     few ivs to more seems more likely to be succesful -- starting from few\n+     few ivs to more seems more likely to be successful -- starting from few\n      ivs, replacing an expensive use by a specific iv should always be a\n      win.  */\n   EXECUTE_IF_SET_IN_BITMAP (data->important_candidates, 0, i, bi)"}]}