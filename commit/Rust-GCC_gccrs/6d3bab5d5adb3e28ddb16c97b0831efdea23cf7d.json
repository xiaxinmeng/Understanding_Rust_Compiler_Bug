{"sha": "6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQzYmFiNWQ1YWRiM2UyOGRkYjE2Yzk3YjA4MzFlZmRlYTIzY2Y3ZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-06T19:41:02Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-06T19:43:11Z"}, "message": "Improve warning suppression for inlined functions.\n\nResolves:\nPR middle-end/98871 - Cannot silence -Wmaybe-uninitialized at declaration site\nPR middle-end/98512 - #pragma GCC diagnostic ignored ineffective in conjunction with alias attribute\n\ngcc/ChangeLog:\n\n\t* builtins.c (warn_string_no_nul): Remove %G.\n\t(maybe_warn_for_bound): Same.\n\t(warn_for_access): Same.\n\t(check_access): Same.\n\t(check_strncat_sizes): Same.\n\t(expand_builtin_strncat): Same.\n\t(expand_builtin_strncmp): Same.\n\t(expand_builtin): Same.\n\t(expand_builtin_object_size): Same.\n\t(warn_dealloc_offset): Same.\n\t(maybe_emit_free_warning): Same.\n\t* calls.c (maybe_warn_alloc_args_overflow): Same.\n\t(maybe_warn_nonstring_arg): Same.\n\t(maybe_warn_rdwr_sizes): Same.\n\t* expr.c (expand_expr_real_1): Remove %K.\n\t* gimple-fold.c (gimple_fold_builtin_strncpy): Remove %G.\n\t(gimple_fold_builtin_strncat): Same.\n\t* gimple-ssa-sprintf.c (format_directive): Same.\n\t(handle_printf_call): Same.\n\t* gimple-ssa-warn-alloca.c (pass_walloca::execute): Same.\n\t* gimple-ssa-warn-restrict.c (maybe_diag_overlap): Same.\n\t(maybe_diag_access_bounds): Same.  Call gimple_location.\n\t(check_bounds_or_overlap): Same.\n\t* trans-mem.c (ipa_tm_scan_irr_block): Remove %K.  Simplify.\n\t* tree-ssa-ccp.c (pass_post_ipa_warn::execute): Remove %G.\n\t* tree-ssa-strlen.c (maybe_warn_overflow): Same.\n\t(maybe_diag_stxncpy_trunc): Same.\n\t(handle_builtin_stxncpy_strncat): Same.\n\t(maybe_warn_pointless_strcmp): Same.\n\t* tree-ssa-uninit.c (maybe_warn_operand): Same.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/Wobjsize-1.c: Prune expected output.\n\t* gcc.dg/Warray-bounds-71.c: New test.\n\t* gcc.dg/Warray-bounds-71.h: New test header.\n\t* gcc.dg/Warray-bounds-72.c: New test.\n\t* gcc.dg/Warray-bounds-73.c: New test.\n\t* gcc.dg/Warray-bounds-74.c: New test.\n\t* gcc.dg/Warray-bounds-75.c: New test.\n\t* gcc.dg/Wfree-nonheap-object-4.c: Adjust expected output.\n\t* gcc.dg/Wfree-nonheap-object-5.c: New test.\n\t* gcc.dg/Wfree-nonheap-object-6.c: New test.\n\t* gcc.dg/pragma-diag-10.c: New test.\n\t* gcc.dg/pragma-diag-9.c: New test.\n\t* gcc.dg/uninit-suppress_3.c: New test.\n\t* gcc.dg/pr79214.c: Xfail tests.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-27.c: New test.\n\t* gcc.dg/format/c90-printf-1.c: Adjust expected output.", "tree": {"sha": "e01626f7d19dbd576102341cc414accad07f4fbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e01626f7d19dbd576102341cc414accad07f4fbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03b634c8e0d3e8628ced79fc4f40873e12a3039c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b634c8e0d3e8628ced79fc4f40873e12a3039c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b634c8e0d3e8628ced79fc4f40873e12a3039c"}], "stats": {"total": 1260, "additions": 852, "deletions": 408}, "files": [{"sha": "e52fe4291c89b14a7e7e8b9e017dc0ff4270b482", "filename": "gcc/builtins.c", "status": "modified", "additions": 168, "deletions": 174, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -1126,30 +1126,30 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n \t{\n \t  if (wi::ltu_p (maxsiz, bndrng[0]))\n \t    warned = warning_at (loc, opt,\n-\t\t\t\t \"%K%qD specified bound %s exceeds \"\n+\t\t\t\t \"%qD specified bound %s exceeds \"\n \t\t\t\t \"maximum object size %E\",\n-\t\t\t\t expr, func, bndstr, maxobjsize);\n+\t\t\t\t func, bndstr, maxobjsize);\n \t  else\n \t    {\n \t      bool maybe = wi::to_wide (size) == bndrng[0];\n \t      warned = warning_at (loc, opt,\n \t\t\t\t   exact\n-\t\t\t\t   ? G_(\"%K%qD specified bound %s exceeds \"\n+\t\t\t\t   ? G_(\"%qD specified bound %s exceeds \"\n \t\t\t\t\t\"the size %E of unterminated array\")\n \t\t\t\t   : (maybe\n-\t\t\t\t      ? G_(\"%K%qD specified bound %s may \"\n+\t\t\t\t      ? G_(\"%qD specified bound %s may \"\n \t\t\t\t\t   \"exceed the size of at most %E \"\n \t\t\t\t\t   \"of unterminated array\")\n-\t\t\t\t      : G_(\"%K%qD specified bound %s exceeds \"\n+\t\t\t\t      : G_(\"%qD specified bound %s exceeds \"\n \t\t\t\t\t   \"the size of at most %E \"\n \t\t\t\t\t   \"of unterminated array\")),\n-\t\t\t\t   expr, func, bndstr, size);\n+\t\t\t\t   func, bndstr, size);\n \t    }\n \t}\n       else\n \twarned = warning_at (loc, opt,\n-\t\t\t     \"%K%qD argument missing terminating nul\",\n-\t\t\t     expr, func);\n+\t\t\t     \"%qD argument missing terminating nul\",\n+\t\t\t     func);\n     }\n   else\n     {\n@@ -3969,70 +3969,69 @@ maybe_warn_for_bound (opt_code opt, location_t loc, tree exp, tree func,\n \t    warned = (func\n \t\t      ? warning_at (loc, opt,\n \t\t\t\t    (maybe\n-\t\t\t\t     ? G_(\"%K%qD specified bound %E may \"\n+\t\t\t\t     ? G_(\"%qD specified bound %E may \"\n \t\t\t\t\t  \"exceed maximum object size %E\")\n-\t\t\t\t     : G_(\"%K%qD specified bound %E \"\n+\t\t\t\t     : G_(\"%qD specified bound %E \"\n \t\t\t\t\t  \"exceeds maximum object size %E\")),\n-\t\t\t\t    exp, func, bndrng[0], maxobjsize)\n+\t\t\t\t    func, bndrng[0], maxobjsize)\n \t\t      : warning_at (loc, opt,\n \t\t\t\t    (maybe\n-\t\t\t\t     ? G_(\"%Kspecified bound %E may \"\n+\t\t\t\t     ? G_(\"specified bound %E may \"\n \t\t\t\t\t  \"exceed maximum object size %E\")\n-\t\t\t\t     : G_(\"%Kspecified bound %E \"\n+\t\t\t\t     : G_(\"specified bound %E \"\n \t\t\t\t\t  \"exceeds maximum object size %E\")),\n-\t\t\t\t    exp, bndrng[0], maxobjsize));\n+\t\t\t\t    bndrng[0], maxobjsize));\n \t  else\n \t    warned = (func\n \t\t      ? warning_at (loc, opt,\n \t\t\t\t    (maybe\n-\t\t\t\t     ? G_(\"%K%qD specified bound [%E, %E] may \"\n+\t\t\t\t     ? G_(\"%qD specified bound [%E, %E] may \"\n \t\t\t\t\t  \"exceed maximum object size %E\")\n-\t\t\t\t     : G_(\"%K%qD specified bound [%E, %E] \"\n+\t\t\t\t     : G_(\"%qD specified bound [%E, %E] \"\n \t\t\t\t\t  \"exceeds maximum object size %E\")),\n-\t\t\t\t    exp, func,\n-\t\t\t\t    bndrng[0], bndrng[1], maxobjsize)\n+\t\t\t\t    func, bndrng[0], bndrng[1], maxobjsize)\n \t\t      : warning_at (loc, opt,\n \t\t\t\t    (maybe\n-\t\t\t\t     ? G_(\"%Kspecified bound [%E, %E] may \"\n+\t\t\t\t     ? G_(\"specified bound [%E, %E] may \"\n \t\t\t\t\t  \"exceed maximum object size %E\")\n-\t\t\t\t     : G_(\"%Kspecified bound [%E, %E] \"\n+\t\t\t\t     : G_(\"specified bound [%E, %E] \"\n \t\t\t\t\t  \"exceeds maximum object size %E\")),\n-\t\t\t\t    exp, bndrng[0], bndrng[1], maxobjsize));\n+\t\t\t\t    bndrng[0], bndrng[1], maxobjsize));\n \t}\n       else if (!size || tree_int_cst_le (bndrng[0], size))\n \treturn false;\n       else if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%K%qD specified bound %E may exceed \"\n+\t\t\t\t ? G_(\"%qD specified bound %E may exceed \"\n \t\t\t\t      \"source size %E\")\n-\t\t\t\t : G_(\"%K%qD specified bound %E exceeds \"\n+\t\t\t\t : G_(\"%qD specified bound %E exceeds \"\n \t\t\t\t      \"source size %E\")),\n-\t\t\t\texp, func, bndrng[0], size)\n+\t\t\t\tfunc, bndrng[0], size)\n \t\t  : warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%Kspecified bound %E may exceed \"\n+\t\t\t\t ? G_(\"specified bound %E may exceed \"\n \t\t\t\t      \"source size %E\")\n-\t\t\t\t : G_(\"%Kspecified bound %E exceeds \"\n+\t\t\t\t : G_(\"specified bound %E exceeds \"\n \t\t\t\t      \"source size %E\")),\n-\t\t\t\texp, bndrng[0], size));\n+\t\t\t\tbndrng[0], size));\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%K%qD specified bound [%E, %E] may \"\n+\t\t\t\t ? G_(\"%qD specified bound [%E, %E] may \"\n \t\t\t\t      \"exceed source size %E\")\n-\t\t\t\t : G_(\"%K%qD specified bound [%E, %E] exceeds \"\n+\t\t\t\t : G_(\"%qD specified bound [%E, %E] exceeds \"\n \t\t\t\t      \"source size %E\")),\n-\t\t\t\texp, func, bndrng[0], bndrng[1], size)\n+\t\t\t\tfunc, bndrng[0], bndrng[1], size)\n \t\t  : warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%Kspecified bound [%E, %E] may exceed \"\n+\t\t\t\t ? G_(\"specified bound [%E, %E] may exceed \"\n \t\t\t\t      \"source size %E\")\n-\t\t\t\t : G_(\"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t\t : G_(\"specified bound [%E, %E] exceeds \"\n \t\t\t\t      \"source size %E\")),\n-\t\t\t\texp, bndrng[0], bndrng[1], size));\n+\t\t\t\tbndrng[0], bndrng[1], size));\n       if (warned)\n \t{\n \t  if (pad && pad->src.ref)\n@@ -4057,70 +4056,69 @@ maybe_warn_for_bound (opt_code opt, location_t loc, tree exp, tree func,\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%K%qD specified size %E may \"\n+\t\t\t\t ? G_(\"%qD specified size %E may \"\n \t\t\t\t      \"exceed maximum object size %E\")\n-\t\t\t\t : G_(\"%K%qD specified size %E \"\n+\t\t\t\t : G_(\"%qD specified size %E \"\n \t\t\t\t      \"exceeds maximum object size %E\")),\n-\t\t\t\texp, func, bndrng[0], maxobjsize)\n+\t\t\t\tfunc, bndrng[0], maxobjsize)\n \t\t  : warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%Kspecified size %E may exceed \"\n+\t\t\t\t ? G_(\"specified size %E may exceed \"\n \t\t\t\t      \"maximum object size %E\")\n-\t\t\t\t : G_(\"%Kspecified size %E exceeds \"\n+\t\t\t\t : G_(\"specified size %E exceeds \"\n \t\t\t\t      \"maximum object size %E\")),\n-\t\t\t\texp, bndrng[0], maxobjsize));\n+\t\t\t\tbndrng[0], maxobjsize));\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%K%qD specified size between %E and %E \"\n+\t\t\t\t ? G_(\"%qD specified size between %E and %E \"\n \t\t\t\t      \"may exceed maximum object size %E\")\n-\t\t\t\t : G_(\"%K%qD specified size between %E and %E \"\n+\t\t\t\t : G_(\"%qD specified size between %E and %E \"\n \t\t\t\t      \"exceeds maximum object size %E\")),\n-\t\t\t\texp, func,\n-\t\t\t\tbndrng[0], bndrng[1], maxobjsize)\n+\t\t\t\tfunc, bndrng[0], bndrng[1], maxobjsize)\n \t\t  : warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%Kspecified size between %E and %E \"\n+\t\t\t\t ? G_(\"specified size between %E and %E \"\n \t\t\t\t      \"may exceed maximum object size %E\")\n-\t\t\t\t : G_(\"%Kspecified size between %E and %E \"\n+\t\t\t\t : G_(\"specified size between %E and %E \"\n \t\t\t\t      \"exceeds maximum object size %E\")),\n-\t\t\t\texp, bndrng[0], bndrng[1], maxobjsize));\n+\t\t\t\tbndrng[0], bndrng[1], maxobjsize));\n     }\n   else if (!size || tree_int_cst_le (bndrng[0], size))\n     return false;\n   else if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n     warned = (func\n \t      ? warning_at (loc, opt,\n \t\t\t    (maybe\n-\t\t\t     ? G_(\"%K%qD specified bound %E may exceed \"\n+\t\t\t     ? G_(\"%qD specified bound %E may exceed \"\n \t\t\t\t  \"destination size %E\")\n-\t\t\t     : G_(\"%K%qD specified bound %E exceeds \"\n+\t\t\t     : G_(\"%qD specified bound %E exceeds \"\n \t\t\t\t  \"destination size %E\")),\n-\t\t\t    exp, func, bndrng[0], size)\n+\t\t\t    func, bndrng[0], size)\n \t      : warning_at (loc, opt,\n \t\t\t    (maybe\n-\t\t\t     ? G_(\"%Kspecified bound %E may exceed \"\n+\t\t\t     ? G_(\"specified bound %E may exceed \"\n \t\t\t\t  \"destination size %E\")\n-\t\t\t     : G_(\"%Kspecified bound %E exceeds \"\n+\t\t\t     : G_(\"specified bound %E exceeds \"\n \t\t\t\t  \"destination size %E\")),\n-\t\t\t    exp, bndrng[0], size));\n+\t\t\t    bndrng[0], size));\n   else\n     warned = (func\n \t      ? warning_at (loc, opt,\n \t\t\t    (maybe\n-\t\t\t     ? G_(\"%K%qD specified bound [%E, %E] may exceed \"\n+\t\t\t     ? G_(\"%qD specified bound [%E, %E] may exceed \"\n \t\t\t\t  \"destination size %E\")\n-\t\t\t     : G_(\"%K%qD specified bound [%E, %E] exceeds \"\n+\t\t\t     : G_(\"%qD specified bound [%E, %E] exceeds \"\n \t\t\t\t  \"destination size %E\")),\n-\t\t\t    exp, func, bndrng[0], bndrng[1], size)\n+\t\t\t    func, bndrng[0], bndrng[1], size)\n \t      : warning_at (loc, opt,\n \t\t\t    (maybe\n-\t\t\t     ? G_(\"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t     ? G_(\"specified bound [%E, %E] exceeds \"\n \t\t\t\t  \"destination size %E\")\n-\t\t\t     : G_(\"%Kspecified bound [%E, %E] exceeds \"\n+\t\t\t     : G_(\"specified bound [%E, %E] exceeds \"\n \t\t\t\t  \"destination size %E\")),\n-\t\t\t    exp, bndrng[0], bndrng[1], size));\n+\t\t\t    bndrng[0], bndrng[1], size));\n \n   if (warned)\n     {\n@@ -4158,65 +4156,63 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n \twarned = (func\n \t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%K%qD may access %E byte in a region \"\n+\t\t\t\t? G_(\"%qD may access %E byte in a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%K%qD accessing %E byte in a region \"\n+\t\t\t\t: G_(\"%qD accessing %E byte in a region \"\n \t\t\t\t     \"of size %E\")),\n \t\t\t\t(maybe\n-\t\t\t\t ? G_ (\"%K%qD may access %E bytes in a region \"\n+\t\t\t\t ? G_ (\"%qD may access %E bytes in a region \"\n \t\t\t\t       \"of size %E\")\n-\t\t\t\t : G_ (\"%K%qD accessing %E bytes in a region \"\n+\t\t\t\t : G_ (\"%qD accessing %E bytes in a region \"\n \t\t\t\t       \"of size %E\")),\n-\t\t\t       exp, func, range[0], size)\n+\t\t\t       func, range[0], size)\n \t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%Kmay access %E byte in a region \"\n+\t\t\t\t? G_(\"may access %E byte in a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%Kaccessing %E byte in a region \"\n+\t\t\t\t: G_(\"accessing %E byte in a region \"\n \t\t\t\t     \"of size %E\")),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%Kmay access %E bytes in a region \"\n+\t\t\t\t? G_(\"may access %E bytes in a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%Kaccessing %E bytes in a region \"\n+\t\t\t\t: G_(\"accessing %E bytes in a region \"\n \t\t\t\t     \"of size %E\")),\n-\t\t\t       exp, range[0], size));\n+\t\t\t       range[0], size));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n \t\t    ? warning_at (loc, opt,\n \t\t\t\t  (maybe\n-\t\t\t\t   ? G_(\"%K%qD may access %E or more bytes \"\n+\t\t\t\t   ? G_(\"%qD may access %E or more bytes \"\n \t\t\t\t\t\"in a region of size %E\")\n-\t\t\t\t   : G_(\"%K%qD accessing %E or more bytes \"\n+\t\t\t\t   : G_(\"%qD accessing %E or more bytes \"\n \t\t\t\t\t\"in a region of size %E\")),\n-\t\t\t\t  exp, func, range[0], size)\n+\t\t\t\t  func, range[0], size)\n \t\t    : warning_at (loc, opt,\n \t\t\t\t  (maybe\n-\t\t\t\t   ? G_(\"%Kmay access %E or more bytes \"\n+\t\t\t\t   ? G_(\"may access %E or more bytes \"\n \t\t\t\t\t\"in a region of size %E\")\n-\t\t\t\t   : G_(\"%Kaccessing %E or more bytes \"\n+\t\t\t\t   : G_(\"accessing %E or more bytes \"\n \t\t\t\t\t\"in a region of size %E\")),\n-\t\t\t\t  exp, range[0], size));\n+\t\t\t\t  range[0], size));\n \t}\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%K%qD may access between %E and %E \"\n+\t\t\t\t ? G_(\"%qD may access between %E and %E \"\n \t\t\t\t      \"bytes in a region of size %E\")\n-\t\t\t\t : G_(\"%K%qD accessing between %E and %E \"\n+\t\t\t\t : G_(\"%qD accessing between %E and %E \"\n \t\t\t\t      \"bytes in a region of size %E\")),\n-\t\t\t\texp, func, range[0], range[1],\n-\t\t\t\tsize)\n+\t\t\t\tfunc, range[0], range[1], size)\n \t\t  : warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%Kmay access between %E and %E bytes \"\n+\t\t\t\t ? G_(\"may access between %E and %E bytes \"\n \t\t\t\t      \"in a region of size %E\")\n-\t\t\t\t : G_(\"%Kaccessing between %E and %E bytes \"\n+\t\t\t\t : G_(\"accessing between %E and %E bytes \"\n \t\t\t\t      \"in a region of size %E\")),\n-\t\t\t\texp, range[0], range[1],\n-\t\t\t\tsize));\n+\t\t\t\trange[0], range[1], size));\n       return warned;\n     }\n \n@@ -4226,69 +4222,67 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n \twarned = (func\n \t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%K%qD may write %E byte into a region \"\n+\t\t\t\t? G_(\"%qD may write %E byte into a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%K%qD writing %E byte into a region \"\n+\t\t\t\t: G_(\"%qD writing %E byte into a region \"\n \t\t\t\t     \"of size %E overflows the destination\")),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%K%qD may write %E bytes into a region \"\n+\t\t\t\t? G_(\"%qD may write %E bytes into a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%K%qD writing %E bytes into a region \"\n+\t\t\t\t: G_(\"%qD writing %E bytes into a region \"\n \t\t\t\t     \"of size %E overflows the destination\")),\n-\t\t\t       exp, func, range[0], size)\n+\t\t\t       func, range[0], size)\n \t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%Kmay write %E byte into a region \"\n+\t\t\t\t? G_(\"may write %E byte into a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%Kwriting %E byte into a region \"\n+\t\t\t\t: G_(\"writing %E byte into a region \"\n \t\t\t\t     \"of size %E overflows the destination\")),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%Kmay write %E bytes into a region \"\n+\t\t\t\t? G_(\"may write %E bytes into a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%Kwriting %E bytes into a region \"\n+\t\t\t\t: G_(\"writing %E bytes into a region \"\n \t\t\t\t     \"of size %E overflows the destination\")),\n-\t\t\t       exp, range[0], size));\n+\t\t\t       range[0], size));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n \t\t    ? warning_at (loc, opt,\n \t\t\t\t  (maybe\n-\t\t\t\t   ? G_(\"%K%qD may write %E or more bytes \"\n+\t\t\t\t   ? G_(\"%qD may write %E or more bytes \"\n \t\t\t\t\t\"into a region of size %E\")\n-\t\t\t\t   : G_(\"%K%qD writing %E or more bytes \"\n+\t\t\t\t   : G_(\"%qD writing %E or more bytes \"\n \t\t\t\t\t\"into a region of size %E overflows \"\n \t\t\t\t\t\"the destination\")),\n-\t\t\t\t  exp, func, range[0], size)\n+\t\t\t\t  func, range[0], size)\n \t\t    : warning_at (loc, opt,\n \t\t\t\t  (maybe\n-\t\t\t\t   ? G_(\"%Kmay write %E or more bytes into \"\n+\t\t\t\t   ? G_(\"may write %E or more bytes into \"\n \t\t\t\t\t\"a region of size %E\")\n-\t\t\t\t   : G_(\"%Kwriting %E or more bytes into \"\n+\t\t\t\t   : G_(\"writing %E or more bytes into \"\n \t\t\t\t\t\"a region of size %E overflows \"\n \t\t\t\t\t\"the destination\")),\n-\t\t\t\t  exp, range[0], size));\n+\t\t\t\t  range[0], size));\n \t}\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%K%qD may write between %E and %E bytes \"\n+\t\t\t\t ? G_(\"%qD may write between %E and %E bytes \"\n \t\t\t\t      \"into a region of size %E\")\n-\t\t\t\t : G_(\"%K%qD writing between %E and %E bytes \"\n+\t\t\t\t : G_(\"%qD writing between %E and %E bytes \"\n \t\t\t\t      \"into a region of size %E overflows \"\n \t\t\t\t      \"the destination\")),\n-\t\t\t\texp, func, range[0], range[1],\n-\t\t\t\tsize)\n+\t\t\t\tfunc, range[0], range[1], size)\n \t\t  : warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%Kmay write between %E and %E bytes \"\n+\t\t\t\t ? G_(\"may write between %E and %E bytes \"\n \t\t\t\t      \"into a region of size %E\")\n-\t\t\t\t : G_(\"%Kwriting between %E and %E bytes \"\n+\t\t\t\t : G_(\"writing between %E and %E bytes \"\n \t\t\t\t      \"into a region of size %E overflows \"\n \t\t\t\t      \"the destination\")),\n-\t\t\t\texp, range[0], range[1],\n-\t\t\t\tsize));\n+\t\t\t\trange[0], range[1], size));\n       return warned;\n     }\n \n@@ -4299,64 +4293,64 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n \t\t  ? warning_n (loc, OPT_Wstringop_overread,\n \t\t\t       tree_to_uhwi (range[0]),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%K%qD may read %E byte from a region \"\n+\t\t\t\t? G_(\"%qD may read %E byte from a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%K%qD reading %E byte from a region \"\n+\t\t\t\t: G_(\"%qD reading %E byte from a region \"\n \t\t\t\t     \"of size %E\")),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%K%qD may read %E bytes from a region \"\n+\t\t\t\t? G_(\"%qD may read %E bytes from a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%K%qD reading %E bytes from a region \"\n+\t\t\t\t: G_(\"%qD reading %E bytes from a region \"\n \t\t\t\t     \"of size %E\")),\n-\t\t\t       exp, func, range[0], size)\n+\t\t\t       func, range[0], size)\n \t\t  : warning_n (loc, OPT_Wstringop_overread,\n \t\t\t       tree_to_uhwi (range[0]),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%Kmay read %E byte from a region \"\n+\t\t\t\t? G_(\"may read %E byte from a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%Kreading %E byte from a region \"\n+\t\t\t\t: G_(\"reading %E byte from a region \"\n \t\t\t\t     \"of size %E\")),\n \t\t\t       (maybe\n-\t\t\t\t? G_(\"%Kmay read %E bytes from a region \"\n+\t\t\t\t? G_(\"may read %E bytes from a region \"\n \t\t\t\t     \"of size %E\")\n-\t\t\t\t: G_(\"%Kreading %E bytes from a region \"\n+\t\t\t\t: G_(\"reading %E bytes from a region \"\n \t\t\t\t     \"of size %E\")),\n-\t\t\t       exp, range[0], size));\n+\t\t\t       range[0], size));\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warned = (func\n \t\t    ? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t  (maybe\n-\t\t\t\t   ? G_(\"%K%qD may read %E or more bytes \"\n+\t\t\t\t   ? G_(\"%qD may read %E or more bytes \"\n \t\t\t\t\t\"from a region of size %E\")\n-\t\t\t\t   : G_(\"%K%qD reading %E or more bytes \"\n+\t\t\t\t   : G_(\"%qD reading %E or more bytes \"\n \t\t\t\t\t\"from a region of size %E\")),\n-\t\t\t\t  exp, func, range[0], size)\n+\t\t\t\t  func, range[0], size)\n \t\t    : warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t  (maybe\n-\t\t\t\t   ? G_(\"%Kmay read %E or more bytes \"\n+\t\t\t\t   ? G_(\"may read %E or more bytes \"\n \t\t\t\t\t\"from a region of size %E\")\n-\t\t\t\t   : G_(\"%Kreading %E or more bytes \"\n+\t\t\t\t   : G_(\"reading %E or more bytes \"\n \t\t\t\t\t\"from a region of size %E\")),\n-\t\t\t\t  exp, range[0], size));\n+\t\t\t\t  range[0], size));\n \t}\n       else\n \twarned = (func\n \t\t  ? warning_at (loc, OPT_Wstringop_overread,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%K%qD may read between %E and %E bytes \"\n+\t\t\t\t ? G_(\"%qD may read between %E and %E bytes \"\n \t\t\t\t      \"from a region of size %E\")\n-\t\t\t\t : G_(\"%K%qD reading between %E and %E bytes \"\n+\t\t\t\t : G_(\"%qD reading between %E and %E bytes \"\n \t\t\t\t      \"from a region of size %E\")),\n-\t\t\t\texp, func, range[0], range[1], size)\n+\t\t\t\tfunc, range[0], range[1], size)\n \t\t  : warning_at (loc, opt,\n \t\t\t\t(maybe\n-\t\t\t\t ? G_(\"%Kmay read between %E and %E bytes \"\n+\t\t\t\t ? G_(\"may read between %E and %E bytes \"\n \t\t\t\t      \"from a region of size %E\")\n-\t\t\t\t : G_(\"%Kreading between %E and %E bytes \"\n+\t\t\t\t : G_(\"reading between %E and %E bytes \"\n \t\t\t\t      \"from a region of size %E\")),\n-\t\t\t\texp, range[0], range[1], size));\n+\t\t\t\trange[0], range[1], size));\n \n       if (warned)\n \tsuppress_warning (exp, OPT_Wstringop_overread);\n@@ -4369,37 +4363,37 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n     warned = (func\n \t      ? warning_n (loc, OPT_Wstringop_overread,\n \t\t\t   tree_to_uhwi (range[0]),\n-\t\t\t   \"%K%qD expecting %E byte in a region of size %E\",\n-\t\t\t   \"%K%qD expecting %E bytes in a region of size %E\",\n-\t\t\t   exp, func, range[0], size)\n+\t\t\t   \"%qD expecting %E byte in a region of size %E\",\n+\t\t\t   \"%qD expecting %E bytes in a region of size %E\",\n+\t\t\t   func, range[0], size)\n \t      : warning_n (loc, OPT_Wstringop_overread,\n \t\t\t   tree_to_uhwi (range[0]),\n-\t\t\t   \"%Kexpecting %E byte in a region of size %E\",\n-\t\t\t   \"%Kexpecting %E bytes in a region of size %E\",\n-\t\t\t   exp, range[0], size));\n+\t\t\t   \"expecting %E byte in a region of size %E\",\n+\t\t\t   \"expecting %E bytes in a region of size %E\",\n+\t\t\t   range[0], size));\n   else if (tree_int_cst_sign_bit (range[1]))\n     {\n       /* Avoid printing the upper bound if it's invalid.  */\n       warned = (func\n \t\t? warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t      \"%K%qD expecting %E or more bytes in a region \"\n+\t\t\t      \"%qD expecting %E or more bytes in a region \"\n \t\t\t      \"of size %E\",\n-\t\t\t      exp, func, range[0], size)\n+\t\t\t      func, range[0], size)\n \t\t: warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t      \"%Kexpecting %E or more bytes in a region \"\n+\t\t\t      \"expecting %E or more bytes in a region \"\n \t\t\t      \"of size %E\",\n-\t\t\t      exp, range[0], size));\n+\t\t\t      range[0], size));\n     }\n   else\n     warned = (func\n \t      ? warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t    \"%K%qD expecting between %E and %E bytes in \"\n+\t\t\t    \"%qD expecting between %E and %E bytes in \"\n \t\t\t    \"a region of size %E\",\n-\t\t\t    exp, func, range[0], range[1], size)\n+\t\t\t    func, range[0], range[1], size)\n \t      : warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t    \"%Kexpecting between %E and %E bytes in \"\n+\t\t\t    \"expecting between %E and %E bytes in \"\n \t\t\t    \"a region of size %E\",\n-\t\t\t    exp, range[0], range[1], size));\n+\t\t\t    range[0], range[1], size));\n \n   if (warned)\n     suppress_warning (exp, OPT_Wstringop_overread);\n@@ -4759,7 +4753,7 @@ check_access (tree exp, tree dstwrite,\n       && TREE_CODE (range[0]) == INTEGER_CST\n       && tree_int_cst_lt (maxobjsize, range[0]))\n     {\n-      location_t loc = tree_inlined_location (exp);\n+      location_t loc = EXPR_LOCATION (exp);\n       maybe_warn_for_bound (OPT_Wstringop_overflow_, loc, exp, func, range,\n \t\t\t    NULL_TREE, pad);\n       return false;\n@@ -4787,7 +4781,7 @@ check_access (tree exp, tree dstwrite,\n \t\t  && warning_suppressed_p (pad->dst.ref, opt)))\n \t    return false;\n \n-\t  location_t loc = tree_inlined_location (exp);\n+\t  location_t loc = EXPR_LOCATION (exp);\n \t  bool warned = false;\n \t  if (dstwrite == slen && at_least_one)\n \t    {\n@@ -4796,15 +4790,15 @@ check_access (tree exp, tree dstwrite,\n \t\t at least one byte past the end of the destination.  */\n \t      warned = (func\n \t\t\t? warning_at (loc, opt,\n-\t\t\t\t      \"%K%qD writing %E or more bytes into \"\n+\t\t\t\t      \"%qD writing %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n-\t\t\t\t      exp, func, range[0], dstsize)\n+\t\t\t\t      func, range[0], dstsize)\n \t\t\t: warning_at (loc, opt,\n-\t\t\t\t      \"%Kwriting %E or more bytes into \"\n+\t\t\t\t      \"writing %E or more bytes into \"\n \t\t\t\t      \"a region of size %E overflows \"\n \t\t\t\t      \"the destination\",\n-\t\t\t\t      exp, range[0], dstsize));\n+\t\t\t\t      range[0], dstsize));\n \t    }\n \t  else\n \t    {\n@@ -4840,7 +4834,7 @@ check_access (tree exp, tree dstwrite,\n \t PAD is nonnull and BNDRNG is valid.  */\n       get_size_range (maxread, range, pad ? pad->src.bndrng : NULL);\n \n-      location_t loc = tree_inlined_location (exp);\n+      location_t loc = EXPR_LOCATION (exp);\n       tree size = dstsize;\n       if (pad && pad->mode == access_read_only)\n \tsize = wide_int_to_tree (sizetype, pad->src.sizrng[1]);\n@@ -4901,7 +4895,7 @@ check_access (tree exp, tree dstwrite,\n \t      && warning_suppressed_p (pad->src.ref, opt)))\n \treturn false;\n \n-      location_t loc = tree_inlined_location (exp);\n+      location_t loc = EXPR_LOCATION (exp);\n       const bool read\n \t= mode == access_read_only || mode == access_read_write;\n       const bool maybe = pad && pad->dst.parmarray;\n@@ -6481,10 +6475,10 @@ check_strncat_sizes (tree exp, tree objsize)\n   if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (objsize)\n       && tree_int_cst_equal (objsize, maxread))\n     {\n-      location_t loc = tree_inlined_location (exp);\n+      location_t loc = EXPR_LOCATION (exp);\n       warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t  \"%K%qD specified bound %E equals destination size\",\n-\t\t  exp, get_callee_fndecl (exp), maxread);\n+\t\t  \"%qD specified bound %E equals destination size\",\n+\t\t  get_callee_fndecl (exp), maxread);\n \n       return false;\n     }\n@@ -6554,10 +6548,10 @@ expand_builtin_strncat (tree exp, rtx)\n   if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (destsize)\n       && tree_int_cst_equal (destsize, maxread))\n     {\n-      location_t loc = tree_inlined_location (exp);\n+      location_t loc = EXPR_LOCATION (exp);\n       warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t  \"%K%qD specified bound %E equals destination size\",\n-\t\t  exp, get_callee_fndecl (exp), maxread);\n+\t\t  \"%qD specified bound %E equals destination size\",\n+\t\t  get_callee_fndecl (exp), maxread);\n \n       return NULL_RTX;\n     }\n@@ -7330,7 +7324,7 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n       || !check_nul_terminated_array (exp, arg2, arg3))\n     return NULL_RTX;\n \n-  location_t loc = tree_inlined_location (exp);\n+  location_t loc = EXPR_LOCATION (exp);\n   tree len1 = c_strlen (arg1, 1);\n   tree len2 = c_strlen (arg2, 1);\n \n@@ -10006,13 +10000,13 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n     case BUILT_IN_VA_ARG_PACK:\n       /* All valid uses of __builtin_va_arg_pack () are removed during\n \t inlining.  */\n-      error (\"%Kinvalid use of %<__builtin_va_arg_pack ()%>\", exp);\n+      error (\"invalid use of %<__builtin_va_arg_pack ()%>\");\n       return const0_rtx;\n \n     case BUILT_IN_VA_ARG_PACK_LEN:\n       /* All valid uses of __builtin_va_arg_pack_len () are removed during\n \t inlining.  */\n-      error (\"%Kinvalid use of %<__builtin_va_arg_pack_len ()%>\", exp);\n+      error (\"invalid use of %<__builtin_va_arg_pack_len ()%>\");\n       return const0_rtx;\n \n       /* Return the address of the first anonymous stack arg.  */\n@@ -12961,8 +12955,8 @@ expand_builtin_object_size (tree exp)\n \n   if (!validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     {\n-      error (\"%Kfirst argument of %qD must be a pointer, second integer constant\",\n-\t     exp, fndecl);\n+      error (\"first argument of %qD must be a pointer, second integer constant\",\n+\t     fndecl);\n       expand_builtin_trap ();\n       return const0_rtx;\n     }\n@@ -12974,8 +12968,8 @@ expand_builtin_object_size (tree exp)\n       || tree_int_cst_sgn (ost) < 0\n       || compare_tree_int (ost, 3) > 0)\n     {\n-      error (\"%Klast argument of %qD is not integer constant between 0 and 3\",\n-\t     exp, fndecl);\n+      error (\"last argument of %qD is not integer constant between 0 and 3\",\n+\t      fndecl);\n       expand_builtin_trap ();\n       return const0_rtx;\n     }\n@@ -13787,8 +13781,8 @@ warn_dealloc_offset (location_t loc, tree exp, const access_ref &aref)\n     }\n \n   if (!warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t   \"%K%qD called on pointer %qE with nonzero offset%s\",\n-\t\t   exp, dealloc_decl, aref.ref, offstr))\n+\t\t   \"%qD called on pointer %qE with nonzero offset%s\",\n+\t\t   dealloc_decl, aref.ref, offstr))\n     return false;\n \n   if (DECL_P (aref.ref))\n@@ -13843,15 +13837,15 @@ maybe_emit_free_warning (tree exp)\n     return;\n \n   tree dealloc_decl = get_callee_fndecl (exp);\n-  location_t loc = tree_inlined_location (exp);\n+  location_t loc = EXPR_LOCATION (exp);\n \n   if (DECL_P (ref) || EXPR_P (ref))\n     {\n       /* Diagnose freeing a declared object.  */\n       if (aref.ref_declared ()\n \t  && warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t\t \"%K%qD called on unallocated object %qD\",\n-\t\t\t exp, dealloc_decl, ref))\n+\t\t\t \"%qD called on unallocated object %qD\",\n+\t\t\t dealloc_decl, ref))\n \t{\n \t  loc = (DECL_P (ref)\n \t\t ? DECL_SOURCE_LOCATION (ref)\n@@ -13870,8 +13864,8 @@ maybe_emit_free_warning (tree exp)\n   else if (CONSTANT_CLASS_P (ref))\n     {\n       if (warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t      \"%K%qD called on a pointer to an unallocated \"\n-\t\t      \"object %qE\", exp, dealloc_decl, ref))\n+\t\t      \"%qD called on a pointer to an unallocated \"\n+\t\t      \"object %qE\", dealloc_decl, ref))\n \t{\n \t  if (TREE_CODE (ptr) == SSA_NAME)\n \t    {\n@@ -13909,18 +13903,18 @@ maybe_emit_free_warning (tree exp)\n \t\t     ? OPT_Wmismatched_new_delete\n \t\t     : OPT_Wmismatched_dealloc);\n \t\t  warned = warning_at (loc, opt,\n-\t\t\t\t       \"%K%qD called on pointer returned \"\n+\t\t\t\t       \"%qD called on pointer returned \"\n \t\t\t\t       \"from a mismatched allocation \"\n-\t\t\t\t       \"function\", exp, dealloc_decl);\n+\t\t\t\t       \"function\", dealloc_decl);\n \t\t}\n \t    }\n \t  else if (gimple_call_builtin_p (def_stmt, BUILT_IN_ALLOCA)\n \t    \t   || gimple_call_builtin_p (def_stmt,\n \t    \t\t\t\t     BUILT_IN_ALLOCA_WITH_ALIGN))\n \t    warned = warning_at (loc, OPT_Wfree_nonheap_object,\n-\t\t\t\t \"%K%qD called on pointer to \"\n+\t\t\t\t \"%qD called on pointer to \"\n \t\t\t\t \"an unallocated object\",\n-\t\t\t\t exp, dealloc_decl);\n+\t\t\t\t dealloc_decl);\n \t  else if (warn_dealloc_offset (loc, exp, aref))\n \t    return;\n "}, {"sha": "d2413a280cf117aa44fa15475e9e1149963dec4f", "filename": "gcc/calls.c", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -1435,8 +1435,8 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t  if (tree_int_cst_lt (args[i], integer_zero_node))\n \t    {\n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"%Kargument %i value %qE is negative\",\n-\t\t\t\t   exp, idx[i] + 1, args[i]);\n+\t\t\t\t   \"argument %i value %qE is negative\",\n+\t\t\t\t   idx[i] + 1, args[i]);\n \t    }\n \t  else if (integer_zerop (args[i]))\n \t    {\n@@ -1452,8 +1452,8 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t\t  : !lookup_attribute (\"returns_nonnull\",\n \t\t\t\t       TYPE_ATTRIBUTES (fntype)))\n \t\twarned = warning_at (loc, OPT_Walloc_zero,\n-\t\t\t\t     \"%Kargument %i value is zero\",\n-\t\t\t\t     exp, idx[i] + 1);\n+\t\t\t\t     \"argument %i value is zero\",\n+\t\t\t\t     idx[i] + 1);\n \t    }\n \t  else if (tree_int_cst_lt (maxobjsize, args[i]))\n \t    {\n@@ -1470,9 +1470,9 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t\tcontinue;\n \n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"%Kargument %i value %qE exceeds \"\n+\t\t\t\t   \"argument %i value %qE exceeds \"\n \t\t\t\t   \"maximum object size %E\",\n-\t\t\t\t   exp, idx[i] + 1, args[i], maxobjsize);\n+\t\t\t\t   idx[i] + 1, args[i], maxobjsize);\n \t    }\n \t}\n       else if (TREE_CODE (args[i]) == SSA_NAME\n@@ -1484,16 +1484,16 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t      && tree_int_cst_le (argrange[i][1], integer_zero_node))\n \t    {\n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"%Kargument %i range [%E, %E] is negative\",\n-\t\t\t\t   exp, idx[i] + 1,\n+\t\t\t\t   \"argument %i range [%E, %E] is negative\",\n+\t\t\t\t   idx[i] + 1,\n \t\t\t\t   argrange[i][0], argrange[i][1]);\n \t    }\n \t  else if (tree_int_cst_lt (maxobjsize, argrange[i][0]))\n \t    {\n \t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"%Kargument %i range [%E, %E] exceeds \"\n+\t\t\t\t   \"argument %i range [%E, %E] exceeds \"\n \t\t\t\t   \"maximum object size %E\",\n-\t\t\t\t   exp, idx[i] + 1,\n+\t\t\t\t   idx[i] + 1,\n \t\t\t\t   argrange[i][0], argrange[i][1],\n \t\t\t\t   maxobjsize);\n \t    }\n@@ -1521,15 +1521,15 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \n       if (vflow)\n \twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t     \"%Kproduct %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n \t\t\t     \"exceeds %<SIZE_MAX%>\",\n-\t\t\t     exp, argrange[0][0], argrange[1][0],\n+\t\t\t     argrange[0][0], argrange[1][0],\n \t\t\t     idx[0] + 1, idx[1] + 1);\n       else if (wi::ltu_p (wi::to_wide (maxobjsize, szprec), prod))\n \twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t     \"%Kproduct %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n \t\t\t     \"exceeds maximum object size %E\",\n-\t\t\t     exp, argrange[0][0], argrange[1][0],\n+\t\t\t     argrange[0][0], argrange[1][0],\n \t\t\t     idx[0] + 1, idx[1] + 1,\n \t\t\t     maxobjsize);\n \n@@ -1729,14 +1729,14 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \t  bool warned = false;\n \t  if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n \t    warned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t \"%K%qD specified bound %E \"\n+\t\t\t\t \"%qD specified bound %E \"\n \t\t\t\t \"exceeds maximum object size %E\",\n-\t\t\t\t exp, fndecl, bndrng[0], maxobjsize);\n+\t\t\t\t fndecl, bndrng[0], maxobjsize);\n \t  else\n \t    warned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t \"%K%qD specified bound [%E, %E] \"\n+\t\t\t\t \"%qD specified bound [%E, %E] \"\n \t\t\t\t \"exceeds maximum object size %E\",\n-\t\t\t\t exp, fndecl, bndrng[0], bndrng[1],\n+\t\t\t\t fndecl, bndrng[0], bndrng[1],\n \t\t\t\t maxobjsize);\n \t  if (warned)\n \t    suppress_warning (exp, OPT_Wstringop_overread);\n@@ -2068,16 +2068,16 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t\t= access.second.array_as_string (ptrtype);\n \n \t      if (warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t      \"%Kbound argument %i value %s is \"\n+\t\t\t      \"bound argument %i value %s is \"\n \t\t\t      \"negative for a variable length array \"\n \t\t\t      \"argument %i of type %s\",\n-\t\t\t      exp, sizidx + 1, sizstr,\n+\t\t\t      sizidx + 1, sizstr,\n \t\t\t      ptridx + 1, argtypestr.c_str ()))\n \t\targ_warned = OPT_Wstringop_overflow_;\n \t    }\n \t  else if (warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t       \"%Kargument %i value %s is negative\",\n-\t\t\t       exp, sizidx + 1, sizstr))\n+\t\t\t       \"argument %i value %s is negative\",\n+\t\t\t       sizidx + 1, sizstr))\n \t    arg_warned = OPT_Wstringop_overflow_;\n \n \t  if (arg_warned != no_warning)\n@@ -2124,31 +2124,29 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n \t\t    = access.second.array_as_string (ptrtype);\n \n \t\t  if (warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t  \"%Kargument %i of variable length \"\n+\t\t\t\t  \"argument %i of variable length \"\n \t\t\t\t  \"array %s is null but \"\n \t\t\t\t  \"the corresponding bound argument \"\n \t\t\t\t  \"%i value is %s\",\n-\t\t\t\t  exp, sizidx + 1, argtypestr.c_str (),\n+\t\t\t\t  sizidx + 1, argtypestr.c_str (),\n \t\t\t\t  ptridx + 1, sizstr))\n \t\t    arg_warned = OPT_Wnonnull;\n \t\t}\n \t      else if (warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t   \"%Kargument %i is null but \"\n+\t\t\t\t   \"argument %i is null but \"\n \t\t\t\t   \"the corresponding size argument \"\n \t\t\t\t   \"%i value is %s\",\n-\t\t\t\t   exp, ptridx + 1, sizidx + 1,\n-\t\t\t\t   sizstr))\n+\t\t\t\t   ptridx + 1, sizidx + 1, sizstr))\n \t\targ_warned = OPT_Wnonnull;\n \t    }\n \t  else if (access_size && access.second.static_p)\n \t    {\n \t      /* Warn about null pointers for [static N] array arguments\n \t\t but do not warn for ordinary (i.e., nonstatic) arrays.  */\n \t      if (warning_at (loc, OPT_Wnonnull,\n-\t\t\t      \"%Kargument %i to %<%T[static %E]%> \"\n+\t\t\t      \"argument %i to %<%T[static %E]%> \"\n \t\t\t      \"is null where non-null expected\",\n-\t\t\t      exp, ptridx + 1, argtype,\n-\t\t\t      access_size))\n+\t\t\t      ptridx + 1, argtype, access_size))\n \t\targ_warned = OPT_Wnonnull;\t\t\n \t    }\n "}, {"sha": "6a4368113c414625820eec796d2cb90f236ba9fb", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -11402,7 +11402,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       /* All valid uses of __builtin_va_arg_pack () are removed during\n \t inlining.  */\n       if (CALL_EXPR_VA_ARG_PACK (exp))\n-\terror (\"%Kinvalid use of %<__builtin_va_arg_pack ()%>\", exp);\n+\terror (\"invalid use of %<__builtin_va_arg_pack ()%>\");\n       {\n \ttree fndecl = get_callee_fndecl (exp), attr;\n \n@@ -11414,7 +11414,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\t\t\t DECL_ATTRIBUTES (fndecl))) != NULL)\n \t  {\n \t    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);\n-\t    error (\"%Kcall to %qs declared with attribute error: %s\", exp,\n+\t    error (\"call to %qs declared with attribute error: %s\",\n \t\t   identifier_to_locale (ident),\n \t\t   TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));\n \t  }\n@@ -11426,10 +11426,10 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\t\t\t DECL_ATTRIBUTES (fndecl))) != NULL)\n \t  {\n \t    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);\n-\t    warning_at (tree_nonartificial_location (exp),\n+\t    warning_at (EXPR_LOCATION (exp),\n \t\t\tOPT_Wattribute_warning,\n-\t\t\t\"%Kcall to %qs declared with attribute warning: %s\",\n-\t\t\texp, identifier_to_locale (ident),\n+\t\t\t\"call to %qs declared with attribute warning: %s\",\n+\t\t\tidentifier_to_locale (ident),\n \t\t\tTREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));\n \t  }\n "}, {"sha": "1401092aa9b7902587ba46605ecd1a55afea4187", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -2115,13 +2115,13 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n \t  tree slen = get_maxval_strlen (src, SRK_STRLEN);\n \t  if (slen && !integer_zerop (slen))\n \t    warning_at (loc, OPT_Wstringop_truncation,\n-\t\t\t\"%G%qD destination unchanged after copying no bytes \"\n+\t\t\t\"%qD destination unchanged after copying no bytes \"\n \t\t\t\"from a string of length %E\",\n-\t\t\tstmt, fndecl, slen);\n+\t\t\tfndecl, slen);\n \t  else\n \t    warning_at (loc, OPT_Wstringop_truncation,\n-\t\t\t\"%G%qD destination unchanged after copying no bytes\",\n-\t\t\tstmt, fndecl);\n+\t\t\t\"%qD destination unchanged after copying no bytes\",\n+\t\t\tfndecl);\n \t}\n \n       replace_call_with_value (gsi, dest);\n@@ -2498,11 +2498,11 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n \t  location_t loc = gimple_location (stmt);\n \t  nowarn = warning_at (loc, OPT_Wstringop_overflow_,\n \t\t\t       cmpdst == 0\n-\t\t\t       ? G_(\"%G%qD specified bound %E equals \"\n+\t\t\t       ? G_(\"%qD specified bound %E equals \"\n \t\t\t\t    \"destination size\")\n-\t\t\t       : G_(\"%G%qD specified bound %E exceeds \"\n+\t\t\t       : G_(\"%qD specified bound %E exceeds \"\n \t\t\t\t    \"destination size %wu\"),\n-\t\t\t       stmt, fndecl, len, dstsize);\n+\t\t\t       fndecl, len, dstsize);\n \t  if (nowarn)\n \t    suppress_warning (stmt, OPT_Wstringop_overflow_);\n \t}\n@@ -2518,8 +2518,8 @@ gimple_fold_builtin_strncat (gimple_stmt_iterator *gsi)\n \t of the destination is unknown (it's not an uncommon mistake\n \t to specify as the bound to strncpy the length of the source).  */\n       if (warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t      \"%G%qD specified bound %E equals source length\",\n-\t\t      stmt, fndecl, len))\n+\t\t      \"%qD specified bound %E equals source length\",\n+\t\t      fndecl, len))\n \tsuppress_warning (stmt, OPT_Wstringop_overflow_);\n     }\n "}, {"sha": "f38fb03f068e4aee8c25cd983f9f010e61f18d85", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -3115,9 +3115,8 @@ format_directive (const call_info &info,\n   if (fmtres.nullp)\n     {\n       fmtwarn (dirloc, argloc, NULL, info.warnopt (),\n-\t       \"%G%<%.*s%> directive argument is null\",\n-\t       info.callstmt, dirlen,\n-\t       target_to_host (hostdir, sizeof hostdir, dir.beg));\n+\t       \"%<%.*s%> directive argument is null\",\n+\t       dirlen, target_to_host (hostdir, sizeof hostdir, dir.beg));\n \n       /* Don't bother processing the rest of the format string.  */\n       res->warned = true;\n@@ -4620,8 +4619,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, pointer_query &ptr_qry)\n \t     is not constant.  */\n \t  location_t loc = gimple_location (info.callstmt);\n \t  warning_at (EXPR_LOC_OR_LOC (dstptr, loc),\n-\t\t      info.warnopt (), \"%Gnull destination pointer\",\n-\t\t      info.callstmt);\n+\t\t      info.warnopt (), \"null destination pointer\");\n \t  return false;\n \t}\n \n@@ -4650,8 +4648,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, pointer_query &ptr_qry)\n     {\n       location_t loc = gimple_location (info.callstmt);\n       warning_at (EXPR_LOC_OR_LOC (info.format, loc),\n-\t\t  info.warnopt (), \"%Gnull format string\",\n-\t\t  info.callstmt);\n+\t\t  info.warnopt (), \"null format string\");\n       return false;\n     }\n "}, {"sha": "4fc7125d378e0d26b4e42f42e656d38628cf5011", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -283,7 +283,7 @@ pass_walloca::execute (function *fun)\n \t    }\n \t  else if (warn_alloca)\n \t    {\n-\t      warning_at (loc, OPT_Walloca, \"%Guse of %<alloca%>\", stmt);\n+\t      warning_at (loc, OPT_Walloca, \"use of %<alloca%>\");\n \t      continue;\n \t    }\n \t  else if (warn_alloca_limit < 0)\n@@ -322,11 +322,10 @@ pass_walloca::execute (function *fun)\n \t\tauto_diagnostic_group d;\n \t\tif (warning_at (loc, wcode,\n \t\t\t\t(is_vla\n-\t\t\t\t ? G_(\"%Gargument to variable-length \"\n+\t\t\t\t ? G_(\"argument to variable-length \"\n \t\t\t\t      \"array may be too large\")\n-\t\t\t\t : G_(\"%Gargument to %<alloca%> may be too \"\n-\t\t\t\t      \"large\")),\n-\t\t\t\tstmt)\n+\t\t\t\t : G_(\"argument to %<alloca%> may be too \"\n+\t\t\t\t      \"large\")))\n \t\t    && t.limit != 0)\n \t\t  {\n \t\t    print_decu (t.limit, buff);\n@@ -342,10 +341,9 @@ pass_walloca::execute (function *fun)\n \t\tauto_diagnostic_group d;\n \t\tif (warning_at (loc, wcode,\n \t\t\t\t(is_vla\n-\t\t\t\t ? G_(\"%Gargument to variable-length\"\n+\t\t\t\t ? G_(\"argument to variable-length\"\n \t\t\t\t      \" array is too large\")\n-\t\t\t\t : G_(\"%Gargument to %<alloca%> is too large\")),\n-\t\t\t\tstmt)\n+\t\t\t\t : G_(\"argument to %<alloca%> is too large\")))\n \t\t    && t.limit != 0)\n \t\t  {\n \t\t    print_decu (t.limit, buff);\n@@ -361,22 +359,20 @@ pass_walloca::execute (function *fun)\n \n \t      warning_at (loc, wcode,\n \t\t\t  (is_vla\n-\t\t\t   ? G_(\"%Gunbounded use of variable-length array\")\n-\t\t\t   : G_(\"%Gunbounded use of %<alloca%>\")),\n-\t\t\t  stmt);\n+\t\t\t   ? G_(\"unbounded use of variable-length array\")\n+\t\t\t   : G_(\"unbounded use of %<alloca%>\")));\n \t      break;\n \t    case ALLOCA_IN_LOOP:\n \t      gcc_assert (!is_vla);\n \t      warning_at (loc, wcode,\n-\t\t\t  \"%Guse of %<alloca%> within a loop\", stmt);\n+\t\t\t  \"use of %<alloca%> within a loop\");\n \t      break;\n \t    case ALLOCA_ARG_IS_ZERO:\n \t      warning_at (loc, wcode,\n \t\t\t  (is_vla\n-\t\t\t   ? G_(\"%Gargument to variable-length array \"\n+\t\t\t   ? G_(\"argument to variable-length array \"\n \t\t\t\t\"is zero\")\n-\t\t\t   : G_(\"%Gargument to %<alloca%> is zero\")),\n-\t\t\t  stmt);\n+\t\t\t   : G_(\"argument to %<alloca%> is zero\")));\n \t      break;\n \t    default:\n \t      gcc_unreachable ();"}, {"sha": "efb8db98393acb2bbd2a281d8722f5351f90d94c", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -1494,36 +1494,36 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n \t    warning_at (loc, OPT_Wrestrict,\n \t\t\tsizrange[0] == 1\n \t\t\t? (ovlsiz[0] == 1\n-\t\t\t   ? G_(\"%G%qD accessing %wu byte at offsets %s \"\n+\t\t\t   ? G_(\"%qD accessing %wu byte at offsets %s \"\n \t\t\t\t\"and %s overlaps %wu byte at offset %s\")\n-\t\t\t   :  G_(\"%G%qD accessing %wu byte at offsets %s \"\n+\t\t\t   :  G_(\"%qD accessing %wu byte at offsets %s \"\n \t\t\t\t \"and %s overlaps %wu bytes at offset \"\n \t\t\t\t \"%s\"))\n \t\t\t: (ovlsiz[0] == 1\n-\t\t\t   ? G_(\"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t\t   ? G_(\"%qD accessing %wu bytes at offsets %s \"\n \t\t\t\t\"and %s overlaps %wu byte at offset %s\")\n-\t\t\t   : G_(\"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t\t   : G_(\"%qD accessing %wu bytes at offsets %s \"\n \t\t\t\t\"and %s overlaps %wu bytes at offset \"\n \t\t\t\t\"%s\")),\n-\t\t\tcall, func, sizrange[0],\n+\t\t\tfunc, sizrange[0],\n \t\t\toffstr[0], offstr[1], ovlsiz[0], offstr[2]);\n \t  else if (ovlsiz[1] >= 0 && ovlsiz[1] < maxobjsize.to_shwi ())\n \t    warning_n (loc, OPT_Wrestrict, sizrange[0],\n-\t\t       \"%G%qD accessing %wu byte at offsets %s \"\n+\t\t       \"%qD accessing %wu byte at offsets %s \"\n \t\t       \"and %s overlaps between %wu and %wu bytes \"\n \t\t       \"at offset %s\",\n-\t\t       \"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t       \"%qD accessing %wu bytes at offsets %s \"\n \t\t       \"and %s overlaps between %wu and %wu bytes \"\n \t\t       \"at offset %s\",\n-\t\t       call, func, sizrange[0], offstr[0], offstr[1],\n+\t\t       func, sizrange[0], offstr[0], offstr[1],\n \t\t       ovlsiz[0], ovlsiz[1], offstr[2]);\n \t  else\n \t    warning_n (loc, OPT_Wrestrict, sizrange[0],\n-\t\t       \"%G%qD accessing %wu byte at offsets %s and \"\n+\t\t       \"%qD accessing %wu byte at offsets %s and \"\n \t\t       \"%s overlaps %wu or more bytes at offset %s\",\n-\t\t       \"%G%qD accessing %wu bytes at offsets %s and \"\n+\t\t       \"%qD accessing %wu bytes at offsets %s and \"\n \t\t       \"%s overlaps %wu or more bytes at offset %s\",\n-\t\t       call, func, sizrange[0],\n+\t\t       func, sizrange[0],\n \t\t       offstr[0], offstr[1], ovlsiz[0], offstr[2]);\n \t  return true;\n \t}\n@@ -1532,28 +1532,28 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n \t{\n \t  if (ovlsiz[0] == ovlsiz[1])\n \t    warning_n (loc, OPT_Wrestrict, ovlsiz[0],\n-\t\t       \"%G%qD accessing between %wu and %wu bytes \"\n+\t\t       \"%qD accessing between %wu and %wu bytes \"\n \t\t       \"at offsets %s and %s overlaps %wu byte at \"\n \t\t       \"offset %s\",\n-\t\t       \"%G%qD accessing between %wu and %wu bytes \"\n+\t\t       \"%qD accessing between %wu and %wu bytes \"\n \t\t       \"at offsets %s and %s overlaps %wu bytes \"\n \t\t       \"at offset %s\",\n-\t\t       call, func, sizrange[0], sizrange[1],\n+\t\t       func, sizrange[0], sizrange[1],\n \t\t       offstr[0], offstr[1], ovlsiz[0], offstr[2]);\n \t  else if (ovlsiz[1] >= 0 && ovlsiz[1] < maxobjsize.to_shwi ())\n \t    warning_at (loc, OPT_Wrestrict,\n-\t\t\t\"%G%qD accessing between %wu and %wu bytes at \"\n+\t\t\t\"%qD accessing between %wu and %wu bytes at \"\n \t\t\t\"offsets %s and %s overlaps between %wu and %wu \"\n \t\t\t\"bytes at offset %s\",\n-\t\t\tcall, func, sizrange[0], sizrange[1],\n+\t\t\tfunc, sizrange[0], sizrange[1],\n \t\t\toffstr[0], offstr[1], ovlsiz[0], ovlsiz[1],\n \t\t\toffstr[2]);\n \t  else\n \t    warning_at (loc, OPT_Wrestrict,\n-\t\t\t\"%G%qD accessing between %wu and %wu bytes at \"\n+\t\t\t\"%qD accessing between %wu and %wu bytes at \"\n \t\t\t\"offsets %s and %s overlaps %wu or more bytes \"\n \t\t\t\"at offset %s\",\n-\t\t\tcall, func, sizrange[0], sizrange[1],\n+\t\t\tfunc, sizrange[0], sizrange[1],\n \t\t\toffstr[0], offstr[1], ovlsiz[0], offstr[2]);\n \t  return true;\n \t}\n@@ -1563,24 +1563,24 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n \n       if (ovlsiz[0] == ovlsiz[1])\n \twarning_n (loc, OPT_Wrestrict, ovlsiz[0],\n-\t\t   \"%G%qD accessing %wu or more bytes at offsets \"\n+\t\t   \"%qD accessing %wu or more bytes at offsets \"\n \t\t   \"%s and %s overlaps %wu byte at offset %s\",\n-\t\t   \"%G%qD accessing %wu or more bytes at offsets \"\n+\t\t   \"%qD accessing %wu or more bytes at offsets \"\n \t\t   \"%s and %s overlaps %wu bytes at offset %s\",\n-\t\t   call, func, sizrange[0], offstr[0], offstr[1],\n+\t\t   func, sizrange[0], offstr[0], offstr[1],\n \t\t   ovlsiz[0], offstr[2]);\n       else if (ovlsiz[1] >= 0 && ovlsiz[1] < maxobjsize.to_shwi ())\n \twarning_at (loc, OPT_Wrestrict,\n-\t\t    \"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t\t    \"%qD accessing %wu or more bytes at offsets %s \"\n \t\t    \"and %s overlaps between %wu and %wu bytes \"\n \t\t    \"at offset %s\",\n-\t\t    call, func, sizrange[0], offstr[0], offstr[1],\n+\t\t    func, sizrange[0], offstr[0], offstr[1],\n \t\t    ovlsiz[0], ovlsiz[1], offstr[2]);\n       else\n \twarning_at (loc, OPT_Wrestrict,\n-\t\t    \"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t\t    \"%qD accessing %wu or more bytes at offsets %s \"\n \t\t    \"and %s overlaps %wu or more bytes at offset %s\",\n-\t\t    call, func, sizrange[0], offstr[0], offstr[1],\n+\t\t    func, sizrange[0], offstr[0], offstr[1],\n \t\t    ovlsiz[0], offstr[2]);\n       return true;\n     }\n@@ -1606,36 +1606,36 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n \t{\n \t  if (open_range)\n \t    warning_n (loc, OPT_Wrestrict, sizrange[1],\n-\t\t       \"%G%qD accessing %wu byte may overlap \"\n+\t\t       \"%qD accessing %wu byte may overlap \"\n \t\t       \"%wu byte\",\n-\t\t       \"%G%qD accessing %wu bytes may overlap \"\n+\t\t       \"%qD accessing %wu bytes may overlap \"\n \t\t       \"%wu byte\",\n-\t\t       call, func, sizrange[1], ovlsiz[1]);\n+\t\t       func, sizrange[1], ovlsiz[1]);\n \t  else\n \t    warning_n (loc, OPT_Wrestrict, sizrange[1],\n-\t\t       \"%G%qD accessing %wu byte at offsets %s \"\n+\t\t       \"%qD accessing %wu byte at offsets %s \"\n \t\t       \"and %s may overlap %wu byte at offset %s\",\n-\t\t       \"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t       \"%qD accessing %wu bytes at offsets %s \"\n \t\t       \"and %s may overlap %wu byte at offset %s\",\n-\t\t       call, func, sizrange[1], offstr[0], offstr[1],\n+\t\t       func, sizrange[1], offstr[0], offstr[1],\n \t\t       ovlsiz[1], offstr[2]);\n \t  return true;\n \t}\n \n       if (open_range)\n \twarning_n (loc, OPT_Wrestrict, sizrange[1],\n-\t\t   \"%G%qD accessing %wu byte may overlap \"\n+\t\t   \"%qD accessing %wu byte may overlap \"\n \t\t   \"up to %wu bytes\",\n-\t\t   \"%G%qD accessing %wu bytes may overlap \"\n+\t\t   \"%qD accessing %wu bytes may overlap \"\n \t\t   \"up to %wu bytes\",\n-\t\t   call, func, sizrange[1], ovlsiz[1]);\n+\t\t   func, sizrange[1], ovlsiz[1]);\n       else\n \twarning_n (loc, OPT_Wrestrict, sizrange[1],\n-\t\t   \"%G%qD accessing %wu byte at offsets %s and \"\n+\t\t   \"%qD accessing %wu byte at offsets %s and \"\n \t\t   \"%s may overlap up to %wu bytes at offset %s\",\n-\t\t   \"%G%qD accessing %wu bytes at offsets %s and \"\n+\t\t   \"%qD accessing %wu bytes at offsets %s and \"\n \t\t   \"%s may overlap up to %wu bytes at offset %s\",\n-\t\t   call, func, sizrange[1], offstr[0], offstr[1],\n+\t\t   func, sizrange[1], offstr[0], offstr[1],\n \t\t   ovlsiz[1], offstr[2]);\n       return true;\n     }\n@@ -1644,30 +1644,30 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n     {\n       if (open_range)\n \twarning_n (loc, OPT_Wrestrict, ovlsiz[1],\n-\t\t   \"%G%qD accessing between %wu and %wu bytes \"\n+\t\t   \"%qD accessing between %wu and %wu bytes \"\n \t\t   \"may overlap %wu byte\",\n-\t\t   \"%G%qD accessing between %wu and %wu bytes \"\n+\t\t   \"%qD accessing between %wu and %wu bytes \"\n \t\t   \"may overlap up to %wu bytes\",\n-\t\t   call, func, sizrange[0], sizrange[1], ovlsiz[1]);\n+\t\t   func, sizrange[0], sizrange[1], ovlsiz[1]);\n       else\n \twarning_n (loc, OPT_Wrestrict, ovlsiz[1],\n-\t\t   \"%G%qD accessing between %wu and %wu bytes \"\n+\t\t   \"%qD accessing between %wu and %wu bytes \"\n \t\t   \"at offsets %s and %s may overlap %wu byte \"\n \t\t   \"at offset %s\",\n-\t\t   \"%G%qD accessing between %wu and %wu bytes \"\n+\t\t   \"%qD accessing between %wu and %wu bytes \"\n \t\t   \"at offsets %s and %s may overlap up to %wu \"\n \t\t   \"bytes at offset %s\",\n-\t\t   call, func, sizrange[0], sizrange[1],\n+\t\t   func, sizrange[0], sizrange[1],\n \t\t   offstr[0], offstr[1], ovlsiz[1], offstr[2]);\n       return true;\n     }\n \n   warning_n (loc, OPT_Wrestrict, ovlsiz[1],\n-\t     \"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t     \"%qD accessing %wu or more bytes at offsets %s \"\n \t     \"and %s may overlap %wu byte at offset %s\",\n-\t     \"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t     \"%qD accessing %wu or more bytes at offsets %s \"\n \t     \"and %s may overlap up to %wu bytes at offset %s\",\n-\t     call, func, sizrange[0], offstr[0], offstr[1],\n+\t     func, sizrange[0], offstr[0], offstr[1],\n \t     ovlsiz[1], offstr[2]);\n \n   return true;\n@@ -1689,7 +1689,7 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t\t\t  const builtin_memref &ref, offset_int wroff,\n \t\t\t  bool do_warn)\n {\n-  location_t loc = gimple_or_expr_nonartificial_location (call, ref.ptr);\n+  location_t loc = gimple_location (call);\n   const offset_int maxobjsize = ref.maxobjsize;\n \n   /* Check for excessive size first and regardless of warning options\n@@ -1709,15 +1709,15 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t{\n \t  if (ref.sizrange[0] == ref.sizrange[1])\n \t    warned = warning_at (loc, opt,\n-\t\t\t\t \"%G%qD specified bound %wu \"\n+\t\t\t\t \"%qD specified bound %wu \"\n \t\t\t\t \"exceeds maximum object size %wu\",\n-\t\t\t\t call, func, ref.sizrange[0].to_uhwi (),\n+\t\t\t\t func, ref.sizrange[0].to_uhwi (),\n \t\t\t\t maxobjsize.to_uhwi ());\n \t  else\n \t    warned = warning_at (loc, opt,\n-\t\t\t\t \"%G%qD specified bound between %wu and %wu \"\n+\t\t\t\t \"%qD specified bound between %wu and %wu \"\n \t\t\t\t \"exceeds maximum object size %wu\",\n-\t\t\t\t call, func, ref.sizrange[0].to_uhwi (),\n+\t\t\t\t func, ref.sizrange[0].to_uhwi (),\n \t\t\t\t ref.sizrange[1].to_uhwi (),\n \t\t\t\t maxobjsize.to_uhwi ());\n \t  return warned ? opt : no_warning;\n@@ -1776,25 +1776,25 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t{\n \t  auto_diagnostic_group d;\n \t  if (warning_at (loc, opt,\n-\t\t\t  \"%G%qD pointer overflow between offset %s \"\n+\t\t\t  \"%qD pointer overflow between offset %s \"\n \t\t\t  \"and size %s accessing array %qD with type %qT\",\n-\t\t\t  call, func, rangestr[0], rangestr[1], ref.base, type))\n+\t\t\t  func, rangestr[0], rangestr[1], ref.base, type))\n \t    {\n \t      inform (DECL_SOURCE_LOCATION (ref.base),\n \t\t      \"array %qD declared here\", ref.base);\n \t      warned = true;\n \t    }\n \t  else\n \t    warned = warning_at (loc, opt,\n-\t\t\t\t \"%G%qD pointer overflow between offset %s \"\n+\t\t\t\t \"%qD pointer overflow between offset %s \"\n \t\t\t\t \"and size %s\",\n-\t\t\t\t call, func, rangestr[0], rangestr[1]);\n+\t\t\t\t func, rangestr[0], rangestr[1]);\n \t}\n       else\n \twarned = warning_at (loc, opt,\n-\t\t\t     \"%G%qD pointer overflow between offset %s \"\n+\t\t\t     \"%qD pointer overflow between offset %s \"\n \t\t\t     \"and size %s\",\n-\t\t\t     call, func, rangestr[0], rangestr[1]);\n+\t\t\t     func, rangestr[0], rangestr[1]);\n     }\n   else if (oobref == ref.base)\n     {\n@@ -1809,20 +1809,20 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n \t  if ((ref.basesize < maxobjsize\n \t       && warning_at (loc, opt,\n \t\t\t      form\n-\t\t\t      ? G_(\"%G%qD forming offset %s is out of \"\n+\t\t\t      ? G_(\"%qD forming offset %s is out of \"\n \t\t\t\t   \"the bounds [0, %wu] of object %qD with \"\n \t\t\t\t   \"type %qT\")\n-\t\t\t      : G_(\"%G%qD offset %s is out of the bounds \"\n+\t\t\t      : G_(\"%qD offset %s is out of the bounds \"\n \t\t\t\t   \"[0, %wu] of object %qD with type %qT\"),\n-\t\t\t      call, func, rangestr[0], ref.basesize.to_uhwi (),\n+\t\t\t      func, rangestr[0], ref.basesize.to_uhwi (),\n \t\t\t      ref.base, TREE_TYPE (ref.base)))\n \t      || warning_at (loc, opt,\n \t\t\t     form\n-\t\t\t     ? G_(\"%G%qD forming offset %s is out of \"\n+\t\t\t     ? G_(\"%qD forming offset %s is out of \"\n \t\t\t\t  \"the bounds of object %qD with type %qT\")\n-\t\t\t     : G_(\"%G%qD offset %s is out of the bounds \"\n+\t\t\t     : G_(\"%qD offset %s is out of the bounds \"\n \t\t\t\t  \"of object %qD with type %qT\"),\n-\t\t\t     call, func, rangestr[0],\n+\t\t\t     func, rangestr[0],\n \t\t\t     ref.base, TREE_TYPE (ref.base)))\n \t    {\n \t      inform (DECL_SOURCE_LOCATION (ref.base),\n@@ -1833,17 +1833,17 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n       else if (ref.basesize < maxobjsize)\n \twarned = warning_at (loc, opt,\n \t\t\t     form\n-\t\t\t     ? G_(\"%G%qD forming offset %s is out \"\n+\t\t\t     ? G_(\"%qD forming offset %s is out \"\n \t\t\t\t  \"of the bounds [0, %wu]\")\n-\t\t\t     : G_(\"%G%qD offset %s is out \"\n+\t\t\t     : G_(\"%qD offset %s is out \"\n \t\t\t\t  \"of the bounds [0, %wu]\"),\n-\t\t\t     call, func, rangestr[0], ref.basesize.to_uhwi ());\n+\t\t\t     func, rangestr[0], ref.basesize.to_uhwi ());\n       else\n \twarned = warning_at (loc, opt,\n \t\t\t     form\n-\t\t\t     ? G_(\"%G%qD forming offset %s is out of bounds\")\n-\t\t\t     : G_(\"%G%qD offset %s is out of bounds\"),\n-\t\t\t     call, func, rangestr[0]);\n+\t\t\t     ? G_(\"%qD forming offset %s is out of bounds\")\n+\t\t\t     : G_(\"%qD offset %s is out of bounds\"),\n+\t\t\t     func, rangestr[0]);\n     }\n   else if (TREE_CODE (ref.ref) == MEM_REF)\n     {\n@@ -1854,9 +1854,9 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n       type = TYPE_MAIN_VARIANT (type);\n \n       if (warning_at (loc, opt,\n-\t\t      \"%G%qD offset %s from the object at %qE is out \"\n+\t\t      \"%qD offset %s from the object at %qE is out \"\n \t\t      \"of the bounds of %qT\",\n-\t\t      call, func, rangestr[0], ref.base, type))\n+\t\t      func, rangestr[0], ref.base, type))\n \t{\n \t  if (TREE_CODE (ref.ref) == COMPONENT_REF)\n \t    refop = TREE_OPERAND (ref.ref, 1);\n@@ -1872,10 +1872,10 @@ maybe_diag_access_bounds (gimple *call, tree func, int strict,\n       tree type = TYPE_MAIN_VARIANT (TREE_TYPE (ref.ref));\n \n       if (warning_at (loc, opt,\n-\t\t      \"%G%qD offset %s from the object at %qE is out \"\n+\t\t      \"%qD offset %s from the object at %qE is out \"\n \t\t      \"of the bounds of referenced subobject %qD with \"\n \t\t      \"type %qT at offset %wi\",\n-\t\t      call, func, rangestr[0], ref.base,\n+\t\t      func, rangestr[0], ref.base,\n \t\t      TREE_OPERAND (ref.ref, 1), type,\n \t\t      ref.refoff.to_shwi ()))\n \t{\n@@ -2065,7 +2065,7 @@ check_bounds_or_overlap (range_query *query,\n \t}\n     }\n \n-  location_t loc = gimple_or_expr_nonartificial_location (call, dst);\n+  location_t loc = gimple_location (call);\n   if (operand_equal_p (dst, src, 0))\n     {\n       /* Issue -Wrestrict unless the pointers are null (those do\n@@ -2075,8 +2075,8 @@ check_bounds_or_overlap (range_query *query,\n       if (!integer_zerop (dst) && !warning_suppressed_p (call, OPT_Wrestrict))\n \t{\n \t  warning_at (loc, OPT_Wrestrict,\n-\t\t      \"%G%qD source argument is the same as destination\",\n-\t\t      call, func);\n+\t\t      \"%qD source argument is the same as destination\",\n+\t\t      func);\n \t  suppress_warning (call, OPT_Wrestrict);\n \t  return OPT_Wrestrict;\n \t}"}, {"sha": "425bb12290908bbed2b11e47f0ed82c1ddcc6525", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-71.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-71.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-71.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-71.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that -Warray-bounds suppression via #pragma GCC diagnostic\n+   works at any call site in an inlining stack\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define IGNORE '1'\n+#include \"Warray-bounds-71.h\""}, {"sha": "89d1068a2662161b7314955016fbd99220f0954d", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-71.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-71.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-71.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-71.h?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,46 @@\n+/* Verify that -Warray-bounds suppression via #pragma GCC diagnostic\n+   works at any call site in an inlining stack\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+int a[4];\n+\n+void f1 (int *p, int i)\n+{\n+#pragma GCC diagnostic push\n+#if IGNORE == '1'\n+#  pragma GCC diagnostic ignored \"-Warray-bounds\"\n+#endif\n+  p[i + 1] = 0;\n+#pragma GCC diagnostic pop\n+}\n+\n+void f2 (int *p, int i)\n+{\n+#pragma GCC diagnostic push\n+#if IGNORE == '2'\n+#  pragma GCC diagnostic ignored \"-Warray-bounds\"\n+#endif\n+  f1 (p + 1, i + 1);\n+#pragma GCC diagnostic pop\n+}\n+\n+void f3 (int *p, int i)\n+{\n+#pragma GCC diagnostic push\n+#if IGNORE == '3'\n+#  pragma GCC diagnostic ignored \"-Warray-bounds\"\n+#endif\n+  f2 (p + 1, i + 1);\n+#pragma GCC diagnostic pop\n+}\n+\n+void f4 (void)\n+{\n+#pragma GCC diagnostic push\n+#if IGNORE == '4'\n+#  pragma GCC diagnostic ignored \"-Warray-bounds\"\n+#endif\n+  f3 (a, 1);\n+#pragma GCC diagnostic pop\n+}"}, {"sha": "eb3f664c0c8fe98ad9cb68bfc17e9ad77acb3247", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-72.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-72.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-72.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-72.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that -Warray-bounds suppression via #pragma GCC diagnostic\n+   works at any call site in an inlining stack\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define IGNORE '2'\n+#include \"Warray-bounds-71.h\""}, {"sha": "50e208352933ea5b9f45a8fb90dcb1c82a04eba4", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-73.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-73.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-73.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-73.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that -Warray-bounds suppression via #pragma GCC diagnostic\n+   works at any call site in an inlining stack\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define IGNORE '3'\n+#include \"Warray-bounds-71.h\""}, {"sha": "c59a876e0736327a0e163f3bb7905901afeca9d8", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-74.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-74.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-74.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-74.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that -Warray-bounds suppression via #pragma GCC diagnostic\n+   works at any call site in an inlining stack\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define IGNORE '4'\n+#include \"Warray-bounds-71.h\""}, {"sha": "306b1768b0ed487d4b3c6beb28950b0dd48326ca", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-75.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-75.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-75.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-75.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,12 @@\n+/* Sanity test for Warray-bounds-7[1-4].c.  Also verify the expected\n+   inlining stack.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"Warray-bounds-71.h\"\n+\n+// { dg-regexp \"In function 'f1',\" \"In function f1\" { target *-*-* } 0 }\n+// { dg-regexp \"inlined from 'f2' at \\[^\\\\n\\\\r\\]+\\[\\\\n\\\\r\\]\" \"inlined from f2\" { target *-*-* } 0 }\n+// { dg-regexp \"inlined from 'f3' at \\[^\\\\n\\\\r\\]+\\[\\\\n\\\\r\\]\" \"inlined from f3\" { target *-*-* } 0 }\n+// { dg-regexp \"inlined from 'f4' at \\[^\\\\n\\\\r\\]+\\[\\\\n\\\\r\\]\" \"inlined from f4\" { target *-*-* } 0 }\n+// { dg-message \"Warray-bounds-71.h:\\\\d+:\\\\d+: warning: array subscript 6 is outside array bounds of 'int\\\\\\[4]'\" \"warning\" { target *-*-* } 0 }"}, {"sha": "e459b247d23d9d366b3081baba828a9dbf34a68c", "filename": "gcc/testsuite/gcc.dg/Wfree-nonheap-object-4.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-4.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -10,23 +10,23 @@ struct A\n   void *p;\n };\n \n-void f0 (struct A *p, void *q) { p->p = q; }\n-void f1 (struct A *p, void *q) { f0 (p, q); }\n-void f2 (struct A *p, void *q) { f1 (p, q); }\n+static void f0 (struct A *p, void *q) { p->p = q; }\n+static void f1 (struct A *p, void *q) { f0 (p, q); }\n+static void f2 (struct A *p, void *q) { f1 (p, q); }\n \n-void g0 (struct A *p)\n+static void g0 (struct A *p)\n {\n   __builtin_free (p->p);      // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n }\n \n-void g1 (struct A *p) { g0 (p); }\n-void g2 (struct A *p) { g1 (p); }\n+static void g1 (struct A *p) { g0 (p); }\n+static void g2 (struct A *p) { g1 (p); }\n \n # 26 \"Wfree-nonheap-object-4.c\"\n \n #define NOIPA __attribute__ ((noipa))\n \n-extern int array[];\n+extern int array[];           // { dg-message \"declared here\" \"note on line 29\" }\n \n /* Verify the warning is issued even for calls in a system header inlined\n    into a function outside the header.  */\n@@ -39,7 +39,7 @@ NOIPA void warn_g0 (struct A *p)\n   g0 (p);\n }\n \n-// { dg-message \"inlined from 'warn_g0'\" \"\" { target *-*-* } 0 }\n+// { dg-message \"inlined from 'warn_g0'\" \"note on line 42\" { target *-*-* } 0 }\n \n \n /* Also verify the warning can be suppressed.  */\n@@ -65,8 +65,8 @@ NOIPA void warn_g1 (struct A *p)\n   g1 (p);\n }\n \n-// { dg-message \"inlined from 'g1'\" \"\" { target *-*-* } 0 }\n-// { dg-message \"inlined from 'warn_g1'\" \"\" { target *-*-* } 0 }\n+// { dg-message \"inlined from 'g1'\" \"note on line 68\" { target *-*-* } 0 }\n+// { dg-message \"inlined from 'warn_g1'\" \"note on line 69\" { target *-*-* } 0 }\n \n \n NOIPA void nowarn_g1 (struct A *p)\n@@ -90,8 +90,8 @@ NOIPA void warn_g2 (struct A *p)\n   g2 (p);\n }\n \n-// { dg-message \"inlined from 'g2'\" \"\" { target *-*-* } 0 }\n-// { dg-message \"inlined from 'warn_g2'\" \"\" { target *-*-* } 0 }\n+// { dg-message \"inlined from 'g2'\" \"note on line 93\" { target *-*-* } 0 }\n+// { dg-message \"inlined from 'warn_g2'\" \"note on line 94\" { target *-*-* } 0 }\n \n \n NOIPA void nowarn_g2 (struct A *p)"}, {"sha": "026cd45f0982ff67a8efab1e1fd30ee40605e468", "filename": "gcc/testsuite/gcc.dg/Wfree-nonheap-object-5.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-5.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,46 @@\n+/* Similar to Wfree-nonheap-object-4.c but without system headers:\n+   verify that warnings for the same call site from distinct callers\n+   include the correct function names in the inlining stack.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+struct A\n+{\n+  void *p;\n+};\n+\n+static void f0 (struct A *p)\n+{\n+  __builtin_free (p->p);      // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+// Expect two instances of the text below:\n+// { dg-regexp \"In function 'f0',\" \"first f0 prefix\" { target *-*-* } 0 }\n+// { dg-regexp \"In function 'f0',\" \"second f0 prefix\" { target *-*-* } 0 }\n+\n+static void f1 (struct A *p) { f0 (p); }\n+static void f2 (struct A *p) { f1 (p); }\n+\n+extern int array[];\n+// Also expect two instances of the note:\n+// { dg-regexp \"declared here\" \"first note on line 24\" { target *-*-* } .-2 }\n+// { dg-regexp \"declared here\" \"second note on line 24\" { target *-*-* } .-3 }\n+\n+void foo (struct A *p)\n+{\n+  p->p = array + 1;\n+  f0 (p);\n+}\n+\n+// { dg-regexp \" +inlined from 'foo' at \\[^:\\]+Wfree-nonheap-object-5.c:32:\\\\d+:\" \"note on line 32\" }\n+\n+\n+void bar (struct A *p)\n+{\n+  p->p = array + 2;\n+  f2 (p);\n+}\n+\n+// { dg-regexp \" +inlined from 'f1' at \\[^:\\]+Wfree-nonheap-object-5.c:21:\\\\d+,\" \"inlined from f1\" }\n+// { dg-regexp \" +inlined from 'f2' at \\[^:\\]+Wfree-nonheap-object-5.c:22:\\\\d+,\" \"inlined from f2\" }\n+// { dg-regexp \" +inlined from 'bar' at \\[^:\\]+Wfree-nonheap-object-5.c:41:\\\\d+:\" \"inlined from bar\" }"}, {"sha": "c109558838ba88861e46fe1ecbdaf967357e3f7b", "filename": "gcc/testsuite/gcc.dg/Wfree-nonheap-object-6.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWfree-nonheap-object-6.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,49 @@\n+/* Similar to Wfree-nonheap-object-5.c but with attribute artificial:\n+   verify that warnings for the same call site from distinct callers\n+   include the correct function names in the inlining stack.\n+   { dg-do compile }\n+   { dg-options \"-O1 -Wall\" } */\n+\n+struct A\n+{\n+  void *p;\n+};\n+\n+__attribute__ ((always_inline, artificial))\n+inline void f0 (struct A *p)\n+{\n+  __builtin_free (p->p);      // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+}\n+\n+// Expect two instances of the text below:\n+// { dg-regexp \"In function 'f0',\" \"first f0 prefix\" { target *-*-* } 0 }\n+// { dg-regexp \"In function 'f0',\" \"second f0 prefix\" { target *-*-* } 0 }\n+\n+__attribute__ ((always_inline, artificial))\n+inline void f1 (struct A *p) { f0 (p); }\n+__attribute__ ((always_inline, artificial))\n+inline void f2 (struct A *p) { f1 (p); }\n+\n+extern int array[];\n+// Also expect two instances of the note:\n+// { dg-regexp \"declared here\" \"first note for array\" { target *-*-* } .-2 }\n+// { dg-regexp \"declared here\" \"second note for array\" { target *-*-* } .-3 }\n+\n+void foo (struct A *p)\n+{\n+  p->p = array + 1;\n+  f0 (p);\n+}\n+\n+// { dg-regexp \" +inlined from 'foo' at \\[^:\\]+Wfree-nonheap-object-6.c:35:\\\\d+:\" \"inlined from foo\" }\n+\n+\n+void bar (struct A *p)\n+{\n+  p->p = array + 2;\n+  f2 (p);\n+}\n+\n+// { dg-regexp \" +inlined from 'f1' at \\[^:\\]+Wfree-nonheap-object-6.c:23:\\\\d+,\" \"inlined from f1\" }\n+// { dg-regexp \" +inlined from 'f2' at \\[^:\\]+Wfree-nonheap-object-6.c:25:\\\\d+,\" \"inlined from f2\" }\n+// { dg-regexp \" +inlined from 'bar' at \\[^:\\]+Wfree-nonheap-object-6.c:44:\\\\d+:\" \"inlined from bar\" }"}, {"sha": "2bd2f93897bd3413321966dd0810a1d397c29e4f", "filename": "gcc/testsuite/gcc.dg/Wobjsize-1.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -4,13 +4,17 @@\n #include \"Wobjsize-1.h\"\n \n char buf[6];\n-/* { dg-warning \"writing\" \"\" { target *-*-* } .-1 } */\n \n int main(int argc, char **argv)\n {\n-  strcpy (buf,\"hello \");\n+  strcpy (buf,\"hello \");    /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n   return 0;\n }\n \n-/* { dg-message \"file included\" \"included\" { target *-*-* } 0 } */\n-/* { dg-message \"inlined from\" \"inlined\" { target *-*-* } 0 } */\n+/* { dg-message \"file included\" \"included\" { target *-*-* } 0 }\n+   { dg-message \"inlined from\" \"inlined\" { target *-*-* } 0 }\n+\n+   The test might emit two warnings, one for the strcpy call and\n+   another for the inlined call to __builtin___strcpy_chk() called\n+   from strcpy().\n+   { dg-prune-output \"writing 7 bytes into a region of size 6\" } */"}, {"sha": "8ffd63ff58643407a82a1c23e5c02541652786cc", "filename": "gcc/testsuite/gcc.dg/format/c90-printf-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fc90-printf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fc90-printf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fc90-printf-1.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -240,7 +240,7 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   printf (\"%n\", cn); /* { dg-warning \"3:constant\" \"%n with const\" } */\n   printf ((const char *)L\"foo\"); /* { dg-warning \"25:wide\" \"wide string\" } */\n   printf (\"%n\", (int *)0); /* { dg-warning \"3:null\" \"%n with NULL\" } */\n-  printf (\"%s\", (char *)0); /* { dg-warning \"3:null\" \"%s with NULL\" } */\n+  printf (\"%s\", (char *)0); /* { dg-warning \"12:'%s' directive argument is null\" \"%s with NULL\" } */\n   /* Test for correct column locations within strings with embedded\n      escape sequences. */\n   printf (\"\\\\\\a\\n \\\"\\t%5n\\n\", n); /* { dg-warning \"25:width\" \"width with %n\" } */"}, {"sha": "2f93eed2789de3cb5c19b2dc9775fc16dc56cee6", "filename": "gcc/testsuite/gcc.dg/pr79214.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79214.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79214.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79214.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -22,67 +22,67 @@ static size_t range (void)\n \n void test_bzero (void)\n {\n-  bzero (d, range ());   /* { dg-warning \".__builtin_(bzero|memset). writing 4 or more bytes into a region of size 3 overflows the destination\" } */\n+  bzero (d, range ());   /* { dg-warning \".__builtin_(bzero|memset). writing 4 or more bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n void test_memcpy (void)\n {\n-  memcpy (d, s, range ());   /* { dg-warning \".__builtin_memcpy. writing 4 or more bytes into a region of size 3 overflows the destination\" } */\n+  memcpy (d, s, range ());   /* { dg-warning \".__builtin_memcpy. writing 4 or more bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n void test_memmove (void)\n {\n-  memmove (d, d + 1, range ());   /* { dg-warning \".__builtin_memmove. writing 4 or more bytes into a region of size 3 overflows the destination\" } */\n+  memmove (d, d + 1, range ());   /* { dg-warning \".__builtin_memmove. writing 4 or more bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n void test_mempcpy (void)\n {\n-  mempcpy (d, s, range ());   /* { dg-warning \".__builtin_mempcpy. writing 4 or more bytes into a region of size 3 overflows the destination\" } */\n+  mempcpy (d, s, range ());   /* { dg-warning \".__builtin_mempcpy. writing 4 or more bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n void test_memset (int n)\n {\n-  memset (d, n, range ());   /* { dg-warning \".__builtin_memset. writing 4 or more bytes into a region of size 3 overflows the destination\" } */\n+  memset (d, n, range ());   /* { dg-warning \".__builtin_memset. writing 4 or more bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n void test_strcat (int i)\n {\n   const char *s = i < 0 ? \"123\" : \"4567\";\n \n-  strcat (d, s);   /* { dg-warning \".__builtin_strcat. writing between 4 and 5 bytes into a region of size 3 overflows the destination\" } */\n+  strcat (d, s);   /* { dg-warning \".__builtin_strcat. writing between 4 and 5 bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n char* test_stpcpy (int i)\n {\n   const char *s = i < 0 ? \"123\" : \"4567\";\n \n-  return stpcpy (d, s);   /* { dg-warning \".__builtin_stpcpy. writing between 4 and 5 bytes into a region of size 3 overflows the destination\" } */\n+  return stpcpy (d, s);   /* { dg-warning \".__builtin_stpcpy. writing between 4 and 5 bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n char* test_stpncpy (int i)\n {\n   const char *s = i < 0 ? \"123\" : \"4567\";\n \n-  return stpncpy (d, s, range ());   /* { dg-warning \".__builtin_stpncpy. writing 4 or more bytes into a region of size 3 overflows the destination\" } */\n+  return stpncpy (d, s, range ());   /* { dg-warning \".__builtin_stpncpy. writing 4 or more bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n char* test_strcpy (int i)\n {\n   const char *s = i < 0 ? \"123\" : \"4567\";\n \n-  return strcpy (d, s);   /* { dg-warning \".__builtin_strcpy. writing between 4 and 5 bytes into a region of size 3 overflows the destination\" } */\n+  return strcpy (d, s);   /* { dg-warning \".__builtin_strcpy. writing between 4 and 5 bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n char* test_strncpy (int i)\n {\n   const char *s = i < 0 ? \"123\" : \"4567\";\n \n-  return strncpy (d, s, range ());   /* { dg-warning \".__builtin_strncpy. writing 4 or more bytes into a region of size 3 overflows the destination\" } */\n+  return strncpy (d, s, range ());   /* { dg-warning \".__builtin_strncpy. writing 4 or more bytes into a region of size 3 overflows the destination\" \"pr?????\" { xfail { *-*-* } } } */\n }\n \n char* test_strncat (int i)\n {\n   const char *s = i < 0 ? \"123\" : \"4567\";\n \n-  return strncat (d, s, range ());   /* { dg-warning \".__builtin_strncat. specified bound \\\\\\[4, \\[0-9\\]+] exceeds destination size 3\" } */\n+  return strncat (d, s, range ());   /* { dg-warning \".__builtin_strncat. specified bound \\\\\\[4, \\[0-9\\]+] exceeds destination size 3\" \"pr?????\" { xfail { *-*-* } } } */\n }"}, {"sha": "127b299939af9fbbc8c4dc31ba0896d27136afa9", "filename": "gcc/testsuite/gcc.dg/pragma-diag-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-10.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,20 @@\n+/* PR middle-end/98512 - #pragma GCC diagnostic ignored ineffective\n+   in conjunction with alias attribute\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+void *\n+__rawmemchr_ppc (const void *s, int c)\n+{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n+#pragma GCC diagnostic ignored \"-Wstringop-overread\"\n+  if (c != 0)\n+    return __builtin_memchr (s, c, (unsigned long)-1);    // { dg-bogus \"specified bound \\\\d+ exceeds maximum object size\" }\n+#pragma GCC diagnostic pop\n+\n+  return (char *)s + __builtin_strlen (s);\n+}\n+\n+extern __typeof (__rawmemchr_ppc) __EI___rawmemchr_ppc\n+  __attribute__((alias (\"__rawmemchr_ppc\")));"}, {"sha": "9aac379caf244e71124fae41b9a7a95e58e9ea5a", "filename": "gcc/testsuite/gcc.dg/pragma-diag-9.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-9.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,141 @@\n+/* Verify that #pragma GCC diagnostic down the inlining stack suppresses\n+   a warning that would otherwise be issued for inlined calls higher up\n+   the inlining stack.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+extern void* memset (void*, int, __SIZE_TYPE__);\n+\n+static void warn0 (int *p)\n+{\n+  memset (p, __LINE__, 3);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+static void warn1 (int *p)\n+{\n+  warn0 (p + 1);\n+}\n+\n+static void warn2 (int *p)\n+{\n+  warn1 (p + 1);\n+}\n+\n+int a2[2];                    // { dg-message \"at offset 12 into destination object 'a2' of size 8\" }\n+\n+void warn3 (void)\n+{\n+  warn2 (a2 + 1);\n+}\n+\n+\n+// Verify suppression at the innermost frame of the inlining stack.\n+\n+static void ignore0 (int *p)\n+{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n+  memset (p, __LINE__, 3);\n+#pragma GCC diagnostic pop\n+}\n+\n+static void nowarn1_ignore0 (int *p)\n+{\n+  ignore0 (p + 1);\n+}\n+\n+static void nowarn2_ignore0 (int *p)\n+{\n+  nowarn1_ignore0 (p + 1);\n+}\n+\n+int b2[2];\n+\n+void nowarn3_ignore0 (void)\n+{\n+  nowarn2_ignore0 (b2 + 1);\n+}\n+\n+\n+// Verify suppression at the second innermost frame of the inlining stack.\n+\n+static void nowarn0_ignore1 (int *p)\n+{\n+  memset (p, __LINE__, 3);\n+}\n+\n+static void ignore1 (int *p)\n+{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n+  nowarn0_ignore1 (p + 1);\n+#pragma GCC diagnostic pop\n+}\n+\n+void nowarn2_ignore1 (int *p)\n+{\n+  ignore1 (p + 1);\n+}\n+\n+int c2[2];\n+\n+void nowarn3_ignore1 (void)\n+{\n+  nowarn2_ignore1 (c2 + 1);\n+}\n+\n+\n+// Verify suppression at the third innermost frame of the inlining stack.\n+\n+static void nowarn0_ignore2 (int *p)\n+{\n+  memset (p, __LINE__, 3);\n+}\n+\n+static void nowarn1_ignore2 (int *p)\n+{\n+  nowarn0_ignore2 (p + 1);\n+}\n+\n+static void ignore2 (int *p)\n+{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n+  nowarn1_ignore2 (p + 1);\n+#pragma GCC diagnostic pop\n+}\n+\n+int d2[2];\n+\n+void nowarn3_ignore2 (void)\n+{\n+  ignore2 (c2 + 1);\n+}\n+\n+\n+// Verify suppression at the outermost frame of the inlining stack.\n+\n+static void nowarn0_ignore3 (int *p)\n+{\n+  memset (p, __LINE__, 3);\n+}\n+\n+static void nowarn1_ignore3 (int *p)\n+{\n+  nowarn0_ignore3 (p + 1);\n+}\n+\n+static void nowarn2_ignore3 (int *p)\n+{\n+  nowarn1_ignore3 (p + 1);\n+}\n+\n+int e2[2];\n+\n+void ignore3 (void)\n+{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n+  nowarn2_ignore3 (e2 + 1);\n+#pragma GCC diagnostic pop\n+}"}, {"sha": "8188dd8005f98c0b5400f90c648d47c4d6b76bba", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-27.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-27.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,20 @@\n+/* PR middle-end/100325 - missing warning with -O0 on sprintf overflow with\n+   pointer plus offset\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+#define S(n) (&\"0123456789\"[10 - n])\n+\n+extern int sprintf (char*, const char*, ...);\n+\n+char d[10];\n+\n+void nowarn_d10_s9 ()\n+{\n+  sprintf (d, \"%s\", S (9));     // { dg-bogus \"-Wformat-overflow\" }\n+}\n+\n+void warn_d10_s10 ()\n+{\n+  sprintf (d, \"%s\", S (10));    // { dg-warning \"-Wformat-overflow\" }\n+}"}, {"sha": "7bbe9edc605368db765b8b31b36d561168c6bff7", "filename": "gcc/testsuite/gcc.dg/uninit-suppress_3.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-suppress_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-suppress_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-suppress_3.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -0,0 +1,98 @@\n+/* PR middle-end/98871 - Cannot silence -Wmaybe-uninitialized at declaration\n+   site\n+   { dg-do compile }\n+   { dg-options \"-O1 -Wall\" } */\n+\n+struct A\n+{\n+  int x;\n+};\n+\n+// Verify that suppression works at every inlining level.\n+\n+static int f0 (int *x)\n+{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+\n+  return ++*x;\n+\n+#pragma GCC diagnostic pop\n+}\n+\n+static int f1 (int *p, int n)\n+{\n+  struct A a;\n+  for (int i = 0; i < n; ++i) {\n+    if (p[i] > 1) {\n+      a = (struct A){p[i]};\n+    }\n+  }\n+\t\n+  return f0 (&a.x);\n+}\n+\n+int f2 (void)\n+{\n+  int a[] = { 1, 2, 3, 4 };\n+  return f1 (a, 4);\n+}\n+\n+\n+static int g0 (int *x)\n+{\n+  return ++*x;\n+}\n+\n+static int g1 (int *p, int n)\n+{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+\n+  struct A a;\n+  for (int i = 0; i < n; ++i) {\n+    if (p[i] > 1) {\n+      a = (struct A){p[i]};\n+    }\n+  }\n+\t\n+  return g0 (&a.x);\n+\n+#pragma GCC diagnostic pop\n+}\n+\n+int g2 (void)\n+{\n+  int a[] = { 1, 2, 3, 4, 5 };\n+  return g1 (a, 5);\n+}\n+\n+\n+static int h0 (int *x)\n+{\n+  return ++*x;\n+}\n+\n+static int h1 (int *p, int n)\n+{\n+  struct A a;\n+  for (int i = 0; i < n; ++i) {\n+    if (p[i] > 1) {\n+      a = (struct A){p[i]};\n+    }\n+  }\n+\t\n+  return h0 (&a.x);\n+}\n+\n+int h2 (void)\n+{\n+  int a[] = { 1, 2, 3, 4, 5, 6 };\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n+\n+  return h1 (a, 6);\n+\n+#pragma GCC diagnostic pop\n+}"}, {"sha": "c270d039b151e7aaed22a624507782da6f1ee7ce", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -4413,12 +4413,8 @@ ipa_tm_scan_irr_block (basic_block bb)\n \t     is to wrap it in a __tm_waiver block.  This is not\n \t     yet implemented, so we can't check for it.  */\n \t  if (is_tm_safe (current_function_decl))\n-\t    {\n-\t      tree t = build1 (NOP_EXPR, void_type_node, size_zero_node);\n-\t      SET_EXPR_LOCATION (t, gimple_location (stmt));\n-\t      error (\"%K%<asm%> not allowed in %<transaction_safe%> function\",\n-\t\t     t);\n-\t    }\n+\t    error_at (gimple_location (stmt),\n+\t\t      \"%<asm%> not allowed in %<transaction_safe%> function\");\n \t  return true;\n \n \tdefault:"}, {"sha": "9ce6214d7e2adc6a56674d349c30515930aabce0", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -3563,7 +3563,7 @@ pass_post_ipa_warn::execute (function *fun)\n \t      if (argno == 0)\n \t\t{\n \t\t  if (warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t  \"%G%qs pointer is null\", stmt, \"this\")\n+\t\t\t\t  \"%qs pointer is null\", \"this\")\n \t\t      && fndecl)\n \t\t    inform (DECL_SOURCE_LOCATION (fndecl),\n \t\t\t    \"in a call to non-static member function %qD\",\n@@ -3572,8 +3572,8 @@ pass_post_ipa_warn::execute (function *fun)\n \t\t}\n \n \t      if (!warning_at (loc, OPT_Wnonnull,\n-\t\t\t       \"%Gargument %u null where non-null \"\n-\t\t\t       \"expected\", stmt, argno))\n+\t\t\t       \"argument %u null where non-null \"\n+\t\t\t       \"expected\", argno))\n \t\tcontinue;\n \n \t      tree fndecl = gimple_call_fndecl (stmt);"}, {"sha": "94257df1067bb1af1b3c4726f65188fe0150d8b5", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -2022,79 +2022,78 @@ maybe_warn_overflow (gimple *stmt, tree len, pointer_query &ptr_qry,\n \n       warned = (writefn\n \t\t? warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t      \"%G%qD writing one too many bytes into a region \"\n+\t\t\t      \"%qD writing one too many bytes into a region \"\n \t\t\t      \"of a size that depends on %<strlen%>\",\n-\t\t\t      stmt, writefn)\n+\t\t\t      writefn)\n \t\t: warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t      \"%Gwriting one too many bytes into a region \"\n-\t\t\t      \"of a size that depends on %<strlen%>\",\n-\t\t\t      stmt));\n+\t\t\t      \"writing one too many bytes into a region \"\n+\t\t\t      \"of a size that depends on %<strlen%>\"));\n     }\n   else if (lenrng[0] == lenrng[1])\n     {\n       if (spcrng[0] == spcrng[1])\n \twarned = (writefn\n \t\t  ? warning_n (loc, OPT_Wstringop_overflow_,\n \t\t\t       lenrng[0].to_uhwi (),\n-\t\t\t       \"%G%qD writing %wu byte into a region \"\n+\t\t\t       \"%qD writing %wu byte into a region \"\n \t\t\t       \"of size %wu\",\n-\t\t\t       \"%G%qD writing %wu bytes into a region \"\n+\t\t\t       \"%qD writing %wu bytes into a region \"\n \t\t\t       \"of size %wu\",\n-\t\t\t       stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t       writefn, lenrng[0].to_uhwi (),\n \t\t\t       spcrng[0].to_uhwi ())\n \t\t  : warning_n (loc, OPT_Wstringop_overflow_,\n \t\t\t       lenrng[0].to_uhwi (),\n-\t\t\t       \"%Gwriting %wu byte into a region \"\n+\t\t\t       \"writing %wu byte into a region \"\n \t\t\t       \"of size %wu\",\n-\t\t\t       \"%Gwriting %wu bytes into a region \"\n+\t\t\t       \"writing %wu bytes into a region \"\n \t\t\t       \"of size %wu\",\n-\t\t\t       stmt, lenrng[0].to_uhwi (),\n+\t\t\t       lenrng[0].to_uhwi (),\n \t\t\t       spcrng[0].to_uhwi ()));\n       else\n \twarned = (writefn\n \t\t  ? warning_n (loc, OPT_Wstringop_overflow_,\n \t\t\t       lenrng[0].to_uhwi (),\n-\t\t\t       \"%G%qD writing %wu byte into a region \"\n+\t\t\t       \"%qD writing %wu byte into a region \"\n \t\t\t       \"of size between %wu and %wu\",\n-\t\t\t       \"%G%qD writing %wu bytes into a region \"\n+\t\t\t       \"%qD writing %wu bytes into a region \"\n \t\t\t       \"of size between %wu and %wu\",\n-\t\t\t       stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t       writefn, lenrng[0].to_uhwi (),\n \t\t\t       spcrng[0].to_uhwi (), spcrng[1].to_uhwi ())\n \t\t  : warning_n (loc, OPT_Wstringop_overflow_,\n \t\t\t       lenrng[0].to_uhwi (),\n-\t\t\t       \"%Gwriting %wu byte into a region \"\n+\t\t\t       \"writing %wu byte into a region \"\n \t\t\t       \"of size between %wu and %wu\",\n-\t\t\t       \"%Gwriting %wu bytes into a region \"\n+\t\t\t       \"writing %wu bytes into a region \"\n \t\t\t       \"of size between %wu and %wu\",\n-\t\t\t       stmt, lenrng[0].to_uhwi (),\n+\t\t\t       lenrng[0].to_uhwi (),\n \t\t\t       spcrng[0].to_uhwi (), spcrng[1].to_uhwi ()));\n     }\n   else if (spcrng[0] == spcrng[1])\n     warned = (writefn\n \t      ? warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%G%qD writing between %wu and %wu bytes \"\n+\t\t\t    \"%qD writing between %wu and %wu bytes \"\n \t\t\t    \"into a region of size %wu\",\n-\t\t\t    stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t    writefn, lenrng[0].to_uhwi (),\n \t\t\t    lenrng[1].to_uhwi (),\n \t\t\t    spcrng[0].to_uhwi ())\n \t      : warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%Gwriting between %wu and %wu bytes \"\n+\t\t\t    \"writing between %wu and %wu bytes \"\n \t\t\t    \"into a region of size %wu\",\n-\t\t\t    stmt, lenrng[0].to_uhwi (),\n+\t\t\t    lenrng[0].to_uhwi (),\n \t\t\t    lenrng[1].to_uhwi (),\n \t\t\t    spcrng[0].to_uhwi ()));\n   else\n     warned = (writefn\n \t      ? warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%G%qD writing between %wu and %wu bytes \"\n+\t\t\t    \"%qD writing between %wu and %wu bytes \"\n \t\t\t    \"into a region of size between %wu and %wu\",\n-\t\t\t    stmt, writefn, lenrng[0].to_uhwi (),\n+\t\t\t    writefn, lenrng[0].to_uhwi (),\n \t\t\t    lenrng[1].to_uhwi (),\n \t\t\t    spcrng[0].to_uhwi (), spcrng[1].to_uhwi ())\n \t      : warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t    \"%Gwriting between %wu and %wu bytes \"\n+\t\t\t    \"writing between %wu and %wu bytes \"\n \t\t\t    \"into a region of size between %wu and %wu\",\n-\t\t\t    stmt, lenrng[0].to_uhwi (),\n+\t\t\t    lenrng[0].to_uhwi (),\n \t\t\t    lenrng[1].to_uhwi (),\n \t\t\t    spcrng[0].to_uhwi (), spcrng[1].to_uhwi ()));\n \n@@ -2985,13 +2984,13 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n       if (lenrange[0] == cntrange[1] && cntrange[0] == cntrange[1])\n \treturn warning_n (callloc, OPT_Wstringop_truncation,\n \t\t\t  cntrange[0].to_uhwi (),\n-\t\t\t  \"%G%qD output truncated before terminating \"\n+\t\t\t  \"%qD output truncated before terminating \"\n \t\t\t  \"nul copying %E byte from a string of the \"\n \t\t\t  \"same length\",\n-\t\t\t  \"%G%qD output truncated before terminating nul \"\n+\t\t\t  \"%qD output truncated before terminating nul \"\n \t\t\t  \"copying %E bytes from a string of the same \"\n \t\t\t  \"length\",\n-\t\t\t  stmt, func, cnt);\n+\t\t\t  func, cnt);\n       else if (!cat_dstlen_bounded)\n \t{\n \t  if (wi::geu_p (lenrange[0], cntrange[1]))\n@@ -3001,16 +3000,16 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n \t      if (cntrange[0] == cntrange[1])\n \t\treturn warning_n (callloc, OPT_Wstringop_truncation,\n \t\t\t\t  cntrange[0].to_uhwi (),\n-\t\t\t\t  \"%G%qD output truncated copying %E byte \"\n+\t\t\t\t  \"%qD output truncated copying %E byte \"\n \t\t\t\t  \"from a string of length %wu\",\n-\t\t\t\t  \"%G%qD output truncated copying %E bytes \"\n+\t\t\t\t  \"%qD output truncated copying %E bytes \"\n \t\t\t\t  \"from a string of length %wu\",\n-\t\t\t\t  stmt, func, cnt, lenrange[0].to_uhwi ());\n+\t\t\t\t  func, cnt, lenrange[0].to_uhwi ());\n \n \t      return warning_at (callloc, OPT_Wstringop_truncation,\n-\t\t\t\t \"%G%qD output truncated copying between %wu \"\n+\t\t\t\t \"%qD output truncated copying between %wu \"\n \t\t\t\t \"and %wu bytes from a string of length %wu\",\n-\t\t\t\t stmt, func, cntrange[0].to_uhwi (),\n+\t\t\t\t func, cntrange[0].to_uhwi (),\n \t\t\t\t cntrange[1].to_uhwi (), lenrange[0].to_uhwi ());\n \t    }\n \t  else if (wi::geu_p (lenrange[1], cntrange[1]))\n@@ -3020,16 +3019,16 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n \t      if (cntrange[0] == cntrange[1])\n \t\treturn warning_n (callloc, OPT_Wstringop_truncation,\n \t\t\t\t  cntrange[0].to_uhwi (),\n-\t\t\t\t  \"%G%qD output may be truncated copying %E \"\n+\t\t\t\t  \"%qD output may be truncated copying %E \"\n \t\t\t\t  \"byte from a string of length %wu\",\n-\t\t\t\t  \"%G%qD output may be truncated copying %E \"\n+\t\t\t\t  \"%qD output may be truncated copying %E \"\n \t\t\t\t  \"bytes from a string of length %wu\",\n-\t\t\t\t  stmt, func, cnt, lenrange[1].to_uhwi ());\n+\t\t\t\t  func, cnt, lenrange[1].to_uhwi ());\n \n \t      return warning_at (callloc, OPT_Wstringop_truncation,\n-\t\t\t\t \"%G%qD output may be truncated copying between \"\n+\t\t\t\t \"%qD output may be truncated copying between \"\n \t\t\t\t \"%wu and %wu bytes from a string of length %wu\",\n-\t\t\t\t stmt, func, cntrange[0].to_uhwi (),\n+\t\t\t\t func, cntrange[0].to_uhwi (),\n \t\t\t\t cntrange[1].to_uhwi (), lenrange[1].to_uhwi ());\n \t    }\n \t}\n@@ -3043,9 +3042,9 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n \t     the lower bound of the specified count but shorter than the\n \t     upper bound the copy may (but need not) be truncated.  */\n \t  return warning_at (callloc, OPT_Wstringop_truncation,\n-\t\t\t     \"%G%qD output may be truncated copying between \"\n+\t\t\t     \"%qD output may be truncated copying between \"\n \t\t\t     \"%wu and %wu bytes from a string of length %wu\",\n-\t\t\t     stmt, func, cntrange[0].to_uhwi (),\n+\t\t\t     func, cntrange[0].to_uhwi (),\n \t\t\t     cntrange[1].to_uhwi (), lenrange[0].to_uhwi ());\n \t}\n     }\n@@ -3072,8 +3071,8 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n \n       if (cntrange[0] == cntrange[1])\n \treturn warning_at (callloc, OPT_Wstringop_truncation,\n-\t\t\t   \"%G%qD specified bound %E equals destination size\",\n-\t\t\t   stmt, func, cnt);\n+\t\t\t   \"%qD specified bound %E equals destination size\",\n+\t\t\t   func, cnt);\n     }\n \n   return false;\n@@ -3197,9 +3196,9 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n       && sisrc == silen\n       && is_strlen_related_p (src, len)\n       && warning_at (callloc, OPT_Wstringop_truncation,\n-\t\t     \"%G%qD output truncated before terminating nul \"\n+\t\t     \"%qD output truncated before terminating nul \"\n \t\t     \"copying as many bytes from a string as its length\",\n-\t\t     stmt, func))\n+\t\t     func))\n     warned = true;\n   else if ((append_p || !dstsize || len == dstlenp1)\n \t   && silen && is_strlen_related_p (src, silen->ptr))\n@@ -3210,9 +3209,9 @@ handle_builtin_stxncpy_strncat (bool append_p, gimple_stmt_iterator *gsi)\n       opt_code opt = (append_p || dstsize\n \t\t      ? OPT_Wstringop_overflow_ : OPT_Wstringop_truncation);\n       warned = warning_at (callloc, opt,\n-\t\t\t   \"%G%qD specified bound depends on the length \"\n+\t\t\t   \"%qD specified bound depends on the length \"\n \t\t\t   \"of the source argument\",\n-\t\t\t   stmt, func);\n+\t\t\t   func);\n     }\n   if (warned)\n     {\n@@ -4141,24 +4140,24 @@ maybe_warn_pointless_strcmp (gimple *stmt, HOST_WIDE_INT bound,\n   if (siz <= minlen && bound == -1)\n     warned = warning_at (stmt_loc, OPT_Wstring_compare,\n \t\t\t (at_least\n-\t\t\t  ? G_(\"%G%qD of a string of length %wu or more and \"\n+\t\t\t  ? G_(\"%qD of a string of length %wu or more and \"\n \t\t\t       \"an array of size %wu evaluates to nonzero\")\n-\t\t\t  : G_(\"%G%qD of a string of length %wu and an array \"\n+\t\t\t  : G_(\"%qD of a string of length %wu and an array \"\n \t\t\t       \"of size %wu evaluates to nonzero\")),\n-\t\t\t stmt, callee, minlen, siz);\n+\t\t\t callee, minlen, siz);\n   else if (!at_least && siz <= HOST_WIDE_INT_MAX)\n     {\n       if (len[0] != HOST_WIDE_INT_MAX && len[1] != HOST_WIDE_INT_MAX)\n \twarned = warning_at (stmt_loc, OPT_Wstring_compare,\n-\t\t\t     \"%G%qD of strings of length %wu and %wu \"\n+\t\t\t     \"%qD of strings of length %wu and %wu \"\n \t\t\t     \"and bound of %wu evaluates to nonzero\",\n-\t\t\t     stmt, callee, len[0], len[1], bound);\n+\t\t\t     callee, len[0], len[1], bound);\n       else\n \twarned = warning_at (stmt_loc, OPT_Wstring_compare,\n-\t\t\t     \"%G%qD of a string of length %wu, an array \"\n+\t\t\t     \"%qD of a string of length %wu, an array \"\n \t\t\t     \"of size %wu and bound of %wu evaluates to \"\n \t\t\t     \"nonzero\",\n-\t\t\t     stmt, callee, minlen, siz, bound);\n+\t\t\t     callee, minlen, siz, bound);\n     }\n \n   if (!warned)"}, {"sha": "24ac031a693c3271f1ef2d78b40cd74aa00a0335", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=6d3bab5d5adb3e28ddb16c97b0831efdea23cf7d", "patch": "@@ -444,7 +444,7 @@ maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n   if (wlims.always_executed)\n     {\n       if (warning_at (location, OPT_Wuninitialized,\n-\t\t      \"%G%qE is used uninitialized\", stmt, rhs))\n+\t\t      \"%qE is used uninitialized\", rhs))\n \t{\n \t  /* ???  This is only effective for decls as in\n \t     gcc.dg/uninit-B-O0.c.  Avoid doing this for maybe-uninit\n@@ -457,7 +457,7 @@ maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n     }\n   else if (wlims.wmaybe_uninit)\n     warned = warning_at (location, OPT_Wmaybe_uninitialized,\n-\t\t\t \"%G%qE may be used uninitialized\", stmt, rhs);\n+\t\t\t \"%qE may be used uninitialized\", rhs);\n \n   return warned ? base : NULL_TREE;\n }"}]}