{"sha": "3435a71e724ffd4d0f7739cef4b99417d12b5b18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQzNWE3MWU3MjRmZmQ0ZDBmNzczOWNlZjRiOTk0MTdkMTJiNWIxOA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@verizon.net", "date": "2005-06-07T06:56:58Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-06-07T06:56:58Z"}, "message": "intrinsic.texi: Add documentation for\tdcmplx...\n\n2005-06-03  Jerry DeLisle <jvdelisle@verizon.net>\n\n\t* intrinsic.texi: Add documentation for\tdcmplx, digits,\n\tdim, idim, ddim, dot_product, dprod, dreal, and dtime.\n\nFrom-SVN: r100697", "tree": {"sha": "fbd8be64b173172c541731c91a4660d1761e2d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbd8be64b173172c541731c91a4660d1761e2d40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3435a71e724ffd4d0f7739cef4b99417d12b5b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3435a71e724ffd4d0f7739cef4b99417d12b5b18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3435a71e724ffd4d0f7739cef4b99417d12b5b18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3435a71e724ffd4d0f7739cef4b99417d12b5b18/comments", "author": null, "committer": null, "parents": [{"sha": "17e2915c2784aa8fc76147e603a7fdc543acd158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e2915c2784aa8fc76147e603a7fdc543acd158", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e2915c2784aa8fc76147e603a7fdc543acd158"}], "stats": {"total": 404, "additions": 373, "deletions": 31}, "files": [{"sha": "d9b73c5022d292e51dc05b962f075d3648301b67", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3435a71e724ffd4d0f7739cef4b99417d12b5b18/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3435a71e724ffd4d0f7739cef4b99417d12b5b18/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3435a71e724ffd4d0f7739cef4b99417d12b5b18", "patch": "@@ -1,3 +1,8 @@\n+2005-06-03  Jerry DeLisle <jvdelisle@verizon.net>\n+\n+\t* intrinsic.texi: Add documentation for\tdcmplx, digits,\n+\tdim, idim, ddim, dot_product, dprod, dreal, and dtime.\n+\n 2005-06-05  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/21912"}, {"sha": "a524885630060c5450cacced720ee5100d95df2b", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 368, "deletions": 31, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3435a71e724ffd4d0f7739cef4b99417d12b5b18/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3435a71e724ffd4d0f7739cef4b99417d12b5b18/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=3435a71e724ffd4d0f7739cef4b99417d12b5b18", "patch": "@@ -66,10 +66,17 @@ and editing.  All contributions and corrections are strongly encouraged.\n * @code{COSH}:          COSH,      Hyperbolic cosine function\n * @code{COUNT}:         COUNT,     Count occurences of .TRUE. in an array\n * @code{CPU_TIME}:      CPU_TIME,  CPU time subroutine\n-* @code{CSHIFT}:        CSHIFT,    Circular array shift\n+* @code{CSHIFT}:        CSHIFT,    Circular array shift function\n * @code{DATE_AND_TIME}: DATE_AND_TIME, Date and time subroutine\n-* @code{DBLE}:          DBLE,      Double precision conversion\n-* @code{DFLOAT}:        DFLOAT,    Double precision conversion\n+* @code{DBLE}:          DBLE,      Double precision conversion function\n+* @code{DCMPLX}:        DCMPLX,    Double complex conversion function\n+* @code{DFLOAT}:        DFLOAT,    Double precision conversion function\n+* @code{DIGITS}:        DIGITS,    Significant digits function\n+* @code{DIM}:           DIM,       Dim function\n+* @code{DOT_PRODUCT}:   DOT_PRODUCT, Dot product function\n+* @code{DPROD}:         DPROD,     Double product function\n+* @code{DREAL}:         DREAL,     Double real part function\n+* @code{DTIME}:         DTIME,     Execution time subroutine (or function)\n * @code{ERF}:           ERF,       Error function\n * @code{ERFC}:          ERFC,      Complementary error function\n * @code{EXP}:           EXP,       Cosine function\n@@ -98,7 +105,7 @@ the Fortran 95 standard.  Gfortran defines the default integer type and\n default real type by @code{INTEGER(KIND=4)} and @code{REAL(KIND=4)},\n respectively.  The standard mandates that both data types shall have\n another kind, which have more precision.  On typical target architectures\n-supports by @command{gfortran}, this kind type parameter is @code{KIND=8}.\n+supported by @command{gfortran}, this kind type parameter is @code{KIND=8}.\n Hence, @code{REAL(KIND=8)} and @code{DOUBLE PRECISION} are equivalent.\n In the description of generic intrinsic procedures, the kind type parameter\n will be specified by @code{KIND=*}, and in the description of specific\n@@ -113,7 +120,7 @@ and denotes such arguments by square brackets.\n @command{Gfortran} offers the @option{-std=f95} and @option{-std=gnu} options,\n which can be used to restrict the set of intrinsic procedures to a \n given standard.  By default, @command{gfortran} sets the @option{-std=gnu}\n-option, and so all intrinsic procedures describe here are accepted.  There\n+option, and so all intrinsic procedures described here are accepted.  There\n is one caveat.  For a select group of intrinsic procedures, @command{g77}\n implemented both a function and a subroutine.  Both classes \n have been implemented in @command{gfortran} for backwards compatibility\n@@ -449,7 +456,7 @@ f95, gnu\n elemental function\n \n @item @emph{Syntax}:\n-@code{X = AINT(X)} @*\n+@code{X = AINT(X)} \n @code{X = AINT(X, KIND)}\n \n @item @emph{Arguments}:\n@@ -506,7 +513,7 @@ f95, gnu\n transformational function\n \n @item @emph{Syntax}:\n-@code{L = ALL(MASK)} @*\n+@code{L = ALL(MASK)} \n @code{L = ALL(MASK, DIM)}\n \n @item @emph{Arguments}:\n@@ -613,7 +620,7 @@ f95, gnu\n elemental function\n \n @item @emph{Syntax}:\n-@code{X = ANINT(X)} @*\n+@code{X = ANINT(X)}\n @code{X = ANINT(X, KIND)}\n \n @item @emph{Arguments}:\n@@ -658,8 +665,8 @@ end program test_anint\n \n @table @asis\n @item @emph{Description}:\n-@code{ANY(MASK [, DIM])} determines if any of the values is true in @var{MASK}\n-in the array along dimension @var{DIM}.\n+@code{ANY(MASK [, DIM])} determines if any of the values in the logical array @var{MASK}\n+along dimension @var{DIM} are @code{.TRUE.}.\n \n @item @emph{Option}:\n f95, gnu\n@@ -668,7 +675,7 @@ f95, gnu\n transformational function\n \n @item @emph{Syntax}:\n-@code{L = ANY(MASK)} @*\n+@code{L = ANY(MASK)} \n @code{L = ANY(MASK, DIM)}\n \n @item @emph{Arguments}:\n@@ -782,7 +789,7 @@ f95, gnu\n inquiry function\n \n @item @emph{Syntax}:\n-@code{L = ASSOCIATED(PTR)} @*\n+@code{L = ASSOCIATED(PTR)} \n @code{L = ASSOCIATED(PTR [, TGT])}\n \n @item @emph{Arguments}:\n@@ -1771,7 +1778,7 @@ Unavailable time and date parameters return blanks.\n @var{VALUES} is @code{INTENT(OUT)} and provides the following:\n \n @multitable @columnfractions .15 .30 .60\n-@item @tab @code{VALUE(1)}: @tab The year\t\n+@item @tab @code{VALUE(1)}: @tab The year\n @item @tab @code{VALUE(2)}: @tab The month\n @item @tab @code{VALUE(3)}: @tab The day of the month\n @item @tab @code{VAlUE(4)}: @tab Time difference with UTC in minutes\n@@ -1790,13 +1797,12 @@ subroutine\n @item @emph{Syntax}:\n @code{CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])}\n \n-\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n @item @var{DATE}  @tab (Optional) The type shall be @code{CHARACTER(8)} or larger.\n @item @var{TIME}  @tab (OPtional) The type shall be @code{CHARACTER(10)} or larger.\n @item @var{ZONE}  @tab (Optional) The type shall be @code{CHARACTER(5)} or larger.\n-@item @var{VALUES}@tab (Optional) The type shall be @code{INTEGER(8)}\n+@item @var{VALUES}@tab (Optional) The type shall be @code{INTEGER(8)}.\n @end multitable\n \n @item @emph{Return value}:\n@@ -1863,6 +1869,54 @@ end program test_dble\n \n \n \n+@node DCMPLX\n+@section @code{DCMPLX} --- Double complex conversion function\n+@findex @code{DCMPLX} intrinsic\n+@cindex DCMPLX\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DCMPLX(X [,Y])} returns a double complex number where @var{X} is\n+converted to the real component.  If @var{Y} is present it is converted to the\n+imaginary component.  If @var{Y} is not present then the imaginary component is\n+set to 0.0.  If @var{X} is complex then @var{Y} must not be present.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{C = DCMPLX(X)}\n+@code{C = DCMPLX(X,Y)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type may be @code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.\n+@item @var{Y} @tab Optional if @var{X} is not @code{COMPLEX(*)}. May be @code{INTEGER(*)} or @code{REAL(*)}. \n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{COMPLEX(8)}\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_dcmplx\n+    integer :: i = 42\n+    real :: x = 3.14\n+    complex :: z\n+    z = cmplx(i, x)\n+    print *, dcmplx(i)\n+    print *, dcmplx(x)\n+    print *, dcmplx(z)\n+    print *, dcmplx(x,i)\n+end program test_dcmplx\n+@end smallexample\n+@end table\n+\n+\n+\n @node DFLOAT\n @section @code{DFLOAT} --- Double conversion function \n @findex @code{DFLOAT} intrinsic\n@@ -1876,6 +1930,305 @@ end program test_dble\n \n \n \n+@node DIGITS\n+@section @code{DIGITS} --- Significant digits function\n+@findex @code{DIGITS} intrinsic\n+@cindex digits, significant\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DIGITS(X)} returns the number of significant digits of the internal model\n+representation of @var{X}.  For example, on a system using a 32-bit\n+floating point representation, a default real number would likely return 24.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+inquiry function\n+\n+@item @emph{Syntax}:\n+@code{C = DIGITS(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type may be @code{INTEGER(*)} or @code{REAL(*)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_digits\n+    integer :: i = 12345\n+    real :: x = 3.143\n+    real(8) :: y = 2.33\n+    complex :: z = (23.0,45.6)\n+    print *, digits(i)\n+    print *, digits(x)\n+    print *, digits(y)\n+end program test_digits\n+@end smallexample\n+@end table\n+\n+\n+\n+@node DIM\n+@section @code{DIM} --- Dim function\n+@findex @code{DIM} intrinsic\n+@findex @code{IDIM} intrinsic\n+@findex @code{DDIM} intrinsic\n+@cindex dim\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DIM(X,Y)} returns the difference @code{X-Y} if the result is positive;\n+otherwise returns zero.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{X = DIM(X,Y)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{INTEGER(*)} or @code{REAL(*)}\n+@item @var{Y} @tab The type shall be the same type and kind as @var{X}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER(*)} or @code{REAL(*)}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_dim\n+    integer :: i\n+    real(8) :: x\n+    i = dim(4, 15)\n+    x = dim(4.345_8, 2.111_8)\n+    print *, i\n+    print *, x\n+end program test_dim\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .24 .24 .24 .24\n+@item Name            @tab Argument          @tab Return type       @tab Option\n+@item @code{IDIM(X,Y)} @tab @code{INTEGER(4) X,Y} @tab @code{INTEGER(4)} @tab gnu\n+@item @code{DDIM(X,Y)} @tab @code{REAL(8) X,Y}  @tab @code{REAL(8)} @tab gnu\n+@end multitable\n+@end table\n+\n+\n+\n+@node DOT_PRODUCT\n+@section @code{DOT_PRODUCT} --- Dot product function\n+@findex @code{DOT_PRODUCT} intrinsic\n+@cindex Dot product\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DOT_PRODUCT(X,Y)} computes the dot product multiplication of two vectors\n+@var{X} and @var{Y}.  The two vectors may be either numeric or logical\n+and must be arrays of rank one and of equal size. If the vectors are\n+@code{INTEGER(*)} or @code{REAL(*)}, the result is @code{SUM(X*Y)}. If the\n+vectors are @code{COMPLEX(*)}, the result is @code{SUM(CONJG(X)*Y)}. If the \n+vectors are @code{LOGICAL}, the result is @code{ANY(X.AND.Y)}.\n+\n+@item @emph{Option}:\n+f95\n+\n+@item @emph{Class}:\n+transformational function\n+\n+@item @emph{Syntax}:\n+@code{S = DOT_PRODUCT(X,Y)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be numeric or @code{LOGICAL}, rank 1.\n+@item @var{Y} @tab The type shall be numeric or @code{LOGICAL}, rank 1.\n+@end multitable\n+\n+@item @emph{Return value}:\n+If the arguments are numeric, the return value is a scaler of numeric type,\n+@code{INTEGER(*)}, @code{REAL(*)}, or @code{COMPLEX(*)}.  If the arguments are\n+@code{LOGICAL}, the return value is @code{.TRUE.} or @code{.FALSE.}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_dot_prod\n+    integer, dimension(3) :: a, b\n+    a = (/ 1, 2, 3 /)\n+    b = (/ 4, 5, 6 /)\n+    print '(3i3)', a\n+    print *\n+    print '(3i3)', b\n+    print *\n+    print *, dot_product(a,b)\n+end program test_dot_prod\n+@end smallexample\n+@end table\n+\n+\n+\n+@node DPROD\n+@section @code{DPROD} --- Double product function\n+@findex @code{DPROD} intrinsic\n+@cindex Double product\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DPROD(X,Y)} returns the product @code{X*Y}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{D = DPROD(X,Y)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{X} @tab The type shall be @code{REAL}.\n+@item @var{Y} @tab The type shall be @code{REAL}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{REAL(8)}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_dprod\n+    integer :: i\n+    real :: x = 5.2\n+    real :: y = 2.3\n+    real(8) :: d\n+    d = dprod(x,y)\n+    print *, d\n+end program test_dprod\n+@end smallexample\n+@end table\n+\n+\n+\n+@node DREAL\n+@section @code{DREAL} --- Double real part function\n+@findex @code{DREAL} intrinsic\n+@cindex Double real part\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DREAL(Z)} returns the real part of complex variable @var{Z}.\n+\n+@item @emph{Option}:\n+gnu\n+\n+@item @emph{Class}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{D = DREAL(Z)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{Z} @tab The type shall be @code{COMPLEX(8)}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{REAL(8)}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_dreal\n+    complex(8) :: z = (1.3_8,7.2_8)\n+    print *, dreal(z)\n+end program test_dreal\n+@end smallexample\n+@end table\n+\n+\n+\n+@node DTIME\n+@section @code{DTIME} --- Execution time subroutine (or function)\n+@findex @code{DTIME} intrinsic\n+@cindex dtime subroutine \n+\n+@table @asis\n+@item @emph{Description}:\n+@code{DTIME(TARRAY, RESULT)} initially returns the number of seconds of runtime\n+since the start of the process's execution in @var{RESULT}.  @var{TARRAY}\n+returns the user and system components of this time in @code{TARRAY(1)} and\n+@code{TARRAY(2)} respectively. @var{RESULT} is equal to @code{TARRAY(1) + TARRAY(2)}.\n+\n+Subsequent invocations of @code{DTIME} return values accumulated since the previous invocation.\n+\n+On some systems, the underlying timings are represented using types with\n+sufficiently small limits that overflows (wraparounds) are possible, such as\n+32-bit types. Therefore, the values returned by this intrinsic might be, or\n+become, negative, or numerically less than previous values, during a single\n+run of the compiled program.\n+\n+If @code{DTIME} is invoked as a function, it can not be invoked as a\n+subroutine, and vice versa.\n+\n+@var{TARRAY} and @var{RESULT} are @code{INTENT(OUT)} and provide the following:\n+\n+@multitable @columnfractions .15 .30 .60\n+@item @tab @code{TARRAY(1)}: @tab User time in seconds.\n+@item @tab @code{TARRAY(2)}: @tab System time in seconds.\n+@item @tab @code{RESULT}: @tab Run time since start in seconds.\n+@end multitable\n+\n+@item @emph{Option}:\n+gnu\n+\n+@item @emph{Class}:\n+subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL DTIME(TARRAY, RESULT)}\n+@code{RESULT = DTIME(TARRAY)}, (not recommended)\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{TARRAY}@tab The type shall be @code{REAL, DIMENSION(2)}.\n+@item @var{RESULT}@tab The type shall be @code{REAL}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+Elapsed time in seconds since the start of program execution.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_dtime\n+    integer(8) :: i, j\n+    real, dimension(2) :: tarray\n+    real :: result\n+    call dtime(tarray, result)\n+    print *, result\n+    print *, tarray(1)\n+    print *, tarray(2)   \n+    do i=1,100000000    ! Just a delay\n+        j = i * i - i\n+    end do\n+    call dtime(tarray, result)\n+    print *, result\n+    print *, tarray(1)\n+    print *, tarray(2)\n+end program test_dtime\n+@end smallexample\n+@end table\n+\n+\n+\n @node ERF\n @section @code{ERF} --- Error function \n @findex @code{ERF} intrinsic\n@@ -2356,22 +2709,6 @@ end program test_tanh\n \n \n \n-@comment gen   dcmplx\n-@comment \n-@comment gen   digits\n-@comment \n-@comment gen   dim\n-@comment       idim\n-@comment       ddim\n-@comment \n-@comment gen   dot_product\n-@comment \n-@comment gen   dprod\n-@comment \n-@comment gen   dreal \n-@comment \n-@comment sub   dtime\n-@comment \n @comment gen   eoshift\n @comment \n @comment gen   epsilon"}]}