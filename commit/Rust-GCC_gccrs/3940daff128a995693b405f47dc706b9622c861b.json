{"sha": "3940daff128a995693b405f47dc706b9622c861b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk0MGRhZmYxMjhhOTk1NjkzYjQwNWY0N2RjNzA2Yjk2MjJjODYxYg==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2020-11-24T22:45:59Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2020-12-01T11:03:30Z"}, "message": "Introduce can_vec_cmp_compare_p\n\nThis is the same as dcd2ca63ec5c (\"Introduce can_vcond_compare_p\nfunction\"), but for vec_cmp.  The reason it's needed is that since\n5d9ade39b872 (\"IBM Z: Fix PR97326: Enable fp compares in vec_cmp\")\nand 4acba4859013 (\"IBM Z: Restrict vec_cmp<m><n> on z13\") s390's vec_cmp\nexpander advertises that it supports floating point comparisons except\nsignaling ones on z13, but the common code ignores the latter\nrestriction.\n\ngcc/ChangeLog:\n\n2020-11-25  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\t* optabs-tree.c (vec_cmp_icode_p): New function.\n\t(vec_cmp_eq_icode_p): New function.\n\t(expand_vec_cmp_expr_p): Use vec_cmp_icode_p and\n\tvec_cmp_eq_icode_p.\n\t(vcond_icode_p): Use get_rtx_code_1, just to be uniform with\n\tvec_cmp_icode_p.\n\t* optabs.c (unsigned_optab_p): New function.\n\t(insn_predicate_matches_p): New function.\n\t(can_vec_cmp_compare_p): New function.\n\t(can_vcond_compare_p): Use unsigned_optab_p and\n\tinsn_predicate_matches_p.\n\t(get_rtx_code): Use get_rtx_code_1.\n\t(get_rtx_code_1): Version of get_rtx_code that returns UNKNOWN\n\tinstead of asserting.\n\t* optabs.h (can_vec_cmp_compare_p): New function.\n\t(get_rtx_code_1): New function.", "tree": {"sha": "de52504f33f2fccc221bd94ad8afc1d0cdb780e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de52504f33f2fccc221bd94ad8afc1d0cdb780e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3940daff128a995693b405f47dc706b9622c861b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3940daff128a995693b405f47dc706b9622c861b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3940daff128a995693b405f47dc706b9622c861b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3940daff128a995693b405f47dc706b9622c861b/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb378761f2c5eb906bf0a9698112dd65d4dc73b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb378761f2c5eb906bf0a9698112dd65d4dc73b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb378761f2c5eb906bf0a9698112dd65d4dc73b"}], "stats": {"total": 137, "additions": 109, "deletions": 28}, "files": [{"sha": "a8968f3dd1a243e5ab66d396323e6a3efca01360", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3940daff128a995693b405f47dc706b9622c861b/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3940daff128a995693b405f47dc706b9622c861b/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=3940daff128a995693b405f47dc706b9622c861b", "patch": "@@ -337,21 +337,44 @@ supportable_convert_operation (enum tree_code code,\n   return false;\n }\n \n+/* Return true iff vec_cmp_optab/vec_cmpu_optab can handle a vector comparison\n+   for code CODE, comparing operands of type VALUE_TYPE and producing a result\n+   of type MASK_TYPE.  */\n+\n+static bool\n+vec_cmp_icode_p (tree value_type, tree mask_type, enum tree_code code)\n+{\n+  enum rtx_code rcode = get_rtx_code_1 (code, TYPE_UNSIGNED (value_type));\n+  if (rcode == UNKNOWN)\n+    return false;\n+\n+  return can_vec_cmp_compare_p (rcode, TYPE_MODE (value_type),\n+\t\t\t\tTYPE_MODE (mask_type));\n+}\n+\n+/* Return true iff vec_cmpeq_optab can handle a vector comparison for code\n+   CODE, comparing operands of type VALUE_TYPE and producing a result of type\n+   MASK_TYPE.  */\n+\n+static bool\n+vec_cmp_eq_icode_p (tree value_type, tree mask_type, enum tree_code code)\n+{\n+  if (code != EQ_EXPR && code != NE_EXPR)\n+    return false;\n+\n+  return get_vec_cmp_eq_icode (TYPE_MODE (value_type), TYPE_MODE (mask_type))\n+\t != CODE_FOR_nothing;\n+}\n+\n /* Return TRUE if appropriate vector insn is available\n    for vector comparison expr with vector type VALUE_TYPE\n    and resulting mask with MASK_TYPE.  */\n \n bool\n expand_vec_cmp_expr_p (tree value_type, tree mask_type, enum tree_code code)\n {\n-  if (get_vec_cmp_icode (TYPE_MODE (value_type), TYPE_MODE (mask_type),\n-\t\t\t TYPE_UNSIGNED (value_type)) != CODE_FOR_nothing)\n-    return true;\n-  if ((code == EQ_EXPR || code == NE_EXPR)\n-      && (get_vec_cmp_eq_icode (TYPE_MODE (value_type), TYPE_MODE (mask_type))\n-\t  != CODE_FOR_nothing))\n-    return true;\n-  return false;\n+  return vec_cmp_icode_p (value_type, mask_type, code)\n+\t || vec_cmp_eq_icode_p (value_type, mask_type, code);\n }\n \n /* Return true iff vcond_optab/vcondu_optab can handle a vector\n@@ -361,8 +384,12 @@ expand_vec_cmp_expr_p (tree value_type, tree mask_type, enum tree_code code)\n static bool\n vcond_icode_p (tree value_type, tree cmp_op_type, enum tree_code code)\n {\n-  return can_vcond_compare_p (get_rtx_code (code, TYPE_UNSIGNED (cmp_op_type)),\n-\t\t\t      TYPE_MODE (value_type), TYPE_MODE (cmp_op_type));\n+  enum rtx_code rcode = get_rtx_code_1 (code, TYPE_UNSIGNED (cmp_op_type));\n+  if (rcode == UNKNOWN)\n+    return false;\n+\n+  return can_vcond_compare_p (rcode, TYPE_MODE (value_type),\n+\t\t\t      TYPE_MODE (cmp_op_type));\n }\n \n /* Return true iff vcondeq_optab can handle a vector comparison for code CODE,"}, {"sha": "8d89f08d2bdc804e6e4d0076372fd09eb43eb04a", "filename": "gcc/optabs.c", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3940daff128a995693b405f47dc706b9622c861b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3940daff128a995693b405f47dc706b9622c861b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=3940daff128a995693b405f47dc706b9622c861b", "patch": "@@ -4057,23 +4057,59 @@ can_compare_p (enum rtx_code code, machine_mode mode,\n   return 0;\n }\n \n-/* Return whether the backend can emit a vector comparison for code CODE,\n-   comparing operands of mode CMP_OP_MODE and producing a result with\n-   VALUE_MODE.  */\n+/* Return whether RTL code CODE corresponds to an unsigned optab.  */\n+\n+static bool\n+unsigned_optab_p (enum rtx_code code)\n+{\n+  return code == LTU || code == LEU || code == GTU || code == GEU;\n+}\n+\n+/* Return whether the backend-emitted comparison for code CODE, comparing\n+   operands of mode VALUE_MODE and producing a result with MASK_MODE, matches\n+   operand OPNO of pattern ICODE.  */\n+\n+static bool\n+insn_predicate_matches_p (enum insn_code icode, unsigned int opno,\n+\t\t\t  enum rtx_code code, machine_mode mask_mode,\n+\t\t\t  machine_mode value_mode)\n+{\n+  rtx reg1 = alloca_raw_REG (value_mode, LAST_VIRTUAL_REGISTER + 1);\n+  rtx reg2 = alloca_raw_REG (value_mode, LAST_VIRTUAL_REGISTER + 2);\n+  rtx test = alloca_rtx_fmt_ee (code, mask_mode, reg1, reg2);\n+  return insn_operand_matches (icode, opno, test);\n+}\n+\n+/* Return whether the backend can emit a vector comparison (vec_cmp/vec_cmpu)\n+   for code CODE, comparing operands of mode VALUE_MODE and producing a result\n+   with MASK_MODE.  */\n+\n+bool\n+can_vec_cmp_compare_p (enum rtx_code code, machine_mode value_mode,\n+\t\t       machine_mode mask_mode)\n+{\n+  enum insn_code icode\n+      = get_vec_cmp_icode (value_mode, mask_mode, unsigned_optab_p (code));\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n+\n+  return insn_predicate_matches_p (icode, 1, code, mask_mode, value_mode);\n+}\n+\n+/* Return whether the backend can emit a vector comparison (vcond/vcondu) for\n+   code CODE, comparing operands of mode CMP_OP_MODE and producing a result\n+   with VALUE_MODE.  */\n \n bool\n can_vcond_compare_p (enum rtx_code code, machine_mode value_mode,\n \t\t     machine_mode cmp_op_mode)\n {\n-  enum insn_code icode;\n-  bool unsigned_p = (code == LTU || code == LEU || code == GTU || code == GEU);\n-  rtx reg1 = alloca_raw_REG (cmp_op_mode, LAST_VIRTUAL_REGISTER + 1);\n-  rtx reg2 = alloca_raw_REG (cmp_op_mode, LAST_VIRTUAL_REGISTER + 2);\n-  rtx test = alloca_rtx_fmt_ee (code, value_mode, reg1, reg2);\n-\n-  return (icode = get_vcond_icode (value_mode, cmp_op_mode, unsigned_p))\n-\t != CODE_FOR_nothing\n-\t && insn_operand_matches (icode, 3, test);\n+  enum insn_code icode\n+      = get_vcond_icode (value_mode, cmp_op_mode, unsigned_optab_p (code));\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n+\n+  return insn_predicate_matches_p (icode, 3, code, value_mode, cmp_op_mode);\n }\n \n /* Return whether the backend can emit vector set instructions for inserting\n@@ -5626,11 +5662,11 @@ gen_cond_trap (enum rtx_code code, rtx op1, rtx op2, rtx tcode)\n   return insn;\n }\n \n-/* Return rtx code for TCODE. Use UNSIGNEDP to select signed\n+/* Return rtx code for TCODE or UNKNOWN.  Use UNSIGNEDP to select signed\n    or unsigned operation code.  */\n \n enum rtx_code\n-get_rtx_code (enum tree_code tcode, bool unsignedp)\n+get_rtx_code_1 (enum tree_code tcode, bool unsignedp)\n {\n   enum rtx_code code;\n   switch (tcode)\n@@ -5688,11 +5724,23 @@ get_rtx_code (enum tree_code tcode, bool unsignedp)\n       break;\n \n     default:\n-      gcc_unreachable ();\n+      code = UNKNOWN;\n+      break;\n     }\n   return code;\n }\n \n+/* Return rtx code for TCODE.  Use UNSIGNEDP to select signed\n+   or unsigned operation code.  */\n+\n+enum rtx_code\n+get_rtx_code (enum tree_code tcode, bool unsignedp)\n+{\n+  enum rtx_code code = get_rtx_code_1 (tcode, unsignedp);\n+  gcc_assert (code != UNKNOWN);\n+  return code;\n+}\n+\n /* Return a comparison rtx of mode CMP_MODE for COND.  Use UNSIGNEDP to\n    select signed or unsigned operators.  OPNO holds the index of the\n    first comparison operand for insn ICODE.  Do not generate the"}, {"sha": "84aaa7a9a0247e1921778d7cccdf72ebf780b8d5", "filename": "gcc/optabs.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3940daff128a995693b405f47dc706b9622c861b/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3940daff128a995693b405f47dc706b9622c861b/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=3940daff128a995693b405f47dc706b9622c861b", "patch": "@@ -244,9 +244,14 @@ enum can_compare_purpose\n extern int can_compare_p (enum rtx_code, machine_mode,\n \t\t\t  enum can_compare_purpose);\n \n-/* Return whether the backend can emit a vector comparison for code CODE,\n-   comparing operands of mode CMP_OP_MODE and producing a result with\n-   VALUE_MODE.  */\n+/* Return whether the backend can emit a vector comparison (vec_cmp/vec_cmpu)\n+   for code CODE, comparing operands of mode VALUE_MODE and producing a result\n+   with MASK_MODE.  */\n+extern bool can_vec_cmp_compare_p (enum rtx_code, machine_mode, machine_mode);\n+\n+/* Return whether the backend can emit a vector comparison (vcond/vcondu) for\n+   code CODE, comparing operands of mode CMP_OP_MODE and producing a result\n+   with VALUE_MODE.  */\n extern bool can_vcond_compare_p (enum rtx_code, machine_mode, machine_mode);\n \n /* Return whether the backend can emit vector set instructions for inserting\n@@ -366,6 +371,7 @@ extern void expand_insn (enum insn_code icode, unsigned int nops,\n extern void expand_jump_insn (enum insn_code icode, unsigned int nops,\n \t\t\t      class expand_operand *ops);\n \n+extern enum rtx_code get_rtx_code_1 (enum tree_code tcode, bool unsignedp);\n extern enum rtx_code get_rtx_code (enum tree_code tcode, bool unsignedp);\n extern rtx vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n \t\t\t       tree t_op0, tree t_op1, bool unsignedp,"}]}