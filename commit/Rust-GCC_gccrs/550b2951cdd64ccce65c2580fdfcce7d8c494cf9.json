{"sha": "550b2951cdd64ccce65c2580fdfcce7d8c494cf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwYjI5NTFjZGQ2NGNjY2U2NWMyNTgwZmRmY2NlN2Q4YzQ5NGNmOQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2001-11-16T22:24:23Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2001-11-16T22:24:23Z"}, "message": "vax.md (casesi): Swap arguments in \"(plus:SI (pc) (mult))\".\n\n\t* vax.md (casesi): Swap arguments in \"(plus:SI (pc) (mult))\". Reformat.\n\t(casesi1): Likewise.  Define new pattern which arises by simplification\n\twhen operand 1 is a constant int.  Correct pattern which arises by\n\tsimplification when operand 1 is zero.\n\nFrom-SVN: r47109", "tree": {"sha": "e9c6af6e4540df4a9a72efdc8f9bd65975599814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9c6af6e4540df4a9a72efdc8f9bd65975599814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550b2951cdd64ccce65c2580fdfcce7d8c494cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550b2951cdd64ccce65c2580fdfcce7d8c494cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550b2951cdd64ccce65c2580fdfcce7d8c494cf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550b2951cdd64ccce65c2580fdfcce7d8c494cf9/comments", "author": null, "committer": null, "parents": [{"sha": "2c47b56b0a994e91566d4cd9df7749278b4c261c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c47b56b0a994e91566d4cd9df7749278b4c261c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c47b56b0a994e91566d4cd9df7749278b4c261c"}], "stats": {"total": 83, "additions": 54, "deletions": 29}, "files": [{"sha": "fc249e5c5652b312b717408888ca534fca1af215", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550b2951cdd64ccce65c2580fdfcce7d8c494cf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550b2951cdd64ccce65c2580fdfcce7d8c494cf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=550b2951cdd64ccce65c2580fdfcce7d8c494cf9", "patch": "@@ -1,3 +1,10 @@\n+2001-11-16  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* vax.md (casesi): Swap arguments in \"(plus:SI (pc) (mult))\". Reformat.\n+\t(casesi1): Likewise.  Define new pattern which arises by simplification\n+\twhen operand 1 is a constant int.  Correct pattern which arises by\n+\tsimplification when operand 1 is zero.\n+\n 2001-11-16  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config.gcc (arm*-*-rtems*, arm-*-coff*, armel-*-coff*,"}, {"sha": "b985c5b6a5d28bd431fa9f9c106ee050474fbb14", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550b2951cdd64ccce65c2580fdfcce7d8c494cf9/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550b2951cdd64ccce65c2580fdfcce7d8c494cf9/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=550b2951cdd64ccce65c2580fdfcce7d8c494cf9", "patch": "@@ -1958,17 +1958,17 @@\n ;; and pass the first 4 along to the casesi1 pattern that really does the work.\n (define_expand \"casesi\"\n   [(set (pc)\n-\t(if_then_else (leu (minus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n-\t\t\t\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n-\t\t\t   (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t\t      (plus:SI (sign_extend:SI\n-\t\t\t\t(mem:HI\n-\t\t\t\t (plus:SI (pc)\n-\t\t\t\t\t  (mult:SI (minus:SI (match_dup 0)\n-\t\t\t\t\t\t\t     (match_dup 1))\n-\t\t\t\t\t\t   (const_int 2)))))\n-\t\t\t       (label_ref:SI (match_operand 3 \"\" \"\")))\n-\t\t      (pc)))\n+\t(if_then_else\n+\t (leu (minus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t(match_operand:SI 1 \"general_operand\" \"g\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t (plus:SI (sign_extend:SI\n+\t\t   (mem:HI (plus:SI (mult:SI (minus:SI (match_dup 0)\n+\t\t\t\t\t\t       (match_dup 1))\n+\t\t\t\t\t     (const_int 2))\n+\t\t\t\t    (pc))))\n+\t\t  (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t (pc)))\n    (match_operand 4 \"\" \"\")]\n   \"\"\n   \"\n@@ -1978,32 +1978,50 @@\n \n (define_insn \"casesi1\"\n   [(set (pc)\n-\t(if_then_else (leu (minus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n-\t\t\t\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n-\t\t\t   (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t\t      (plus:SI (sign_extend:SI\n-\t\t\t\t(mem:HI\n-\t\t\t\t (plus:SI (pc)\n-\t\t\t\t\t  (mult:SI (minus:SI (match_dup 0)\n-\t\t\t\t\t\t\t     (match_dup 1))\n-\t\t\t\t\t\t   (const_int 2)))))\n-\t\t\t       (label_ref:SI (match_operand 3 \"\" \"\")))\n-\t\t      (pc)))]\n+\t(if_then_else\n+\t (leu (minus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t(match_operand:SI 1 \"general_operand\" \"g\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t (plus:SI (sign_extend:SI\n+\t\t   (mem:HI (plus:SI (mult:SI (minus:SI (match_dup 0)\n+\t\t\t\t\t\t       (match_dup 1))\n+\t\t\t\t\t     (const_int 2))\n+\t\t\t\t    (pc))))\n+\t\t  (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t (pc)))]\n   \"\"\n   \"casel %0,%1,%2\")\n \n-;; This used to arise from the preceding by simplification\n-;; if operand 1 is zero.  Perhaps it is no longer necessary.\n+;; This can arise by simplification when operand 1 is a constant int.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (leu (plus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t       (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t (plus:SI (sign_extend:SI\n+\t\t   (mem:HI (plus:SI (mult:SI (plus:SI (match_dup 0)\n+\t\t\t\t\t\t      (match_dup 1))\n+\t\t\t\t\t     (const_int 2))\n+\t\t\t\t    (pc))))\n+\t\t  (label_ref:SI (match_operand 3 \"\" \"\")))\n+\t (pc)))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = GEN_INT (-INTVAL (operands[1]));\n+  return \\\"casel %0,%1,%2\\\";\n+}\")\n+\n+;; This can arise by simplification when the base for the case insn is zero.\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else (leu (match_operand:SI 0 \"general_operand\" \"g\")\n \t\t\t   (match_operand:SI 1 \"general_operand\" \"g\"))\n \t\t      (plus:SI (sign_extend:SI\n-\t\t\t\t(mem:HI\n-\t\t\t\t (plus:SI (pc)\n-\t\t\t\t\t  (mult:SI (minus:SI (match_dup 0)\n-\t\t\t\t\t\t\t     (const_int 0))\n-\t\t\t\t\t\t   (const_int 2)))))\n+\t\t\t\t(mem:HI (plus:SI (mult:SI (match_dup 0)\n+\t\t\t\t\t\t\t  (const_int 2))\n+\t\t\t\t\t(pc))))\n \t\t\t       (label_ref:SI (match_operand 2 \"\" \"\")))\n \t\t      (pc)))]\n   \"\""}]}