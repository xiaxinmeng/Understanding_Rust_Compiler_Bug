{"sha": "18a24fed724c9922c919563aa2bc7c94fd0a12ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhMjRmZWQ3MjRjOTkyMmM5MTk1NjNhYTJiYzdjOTRmZDBhMTJhZA==", "commit": {"author": {"name": "Tristan Gingold", "email": "gingold@adacore.com", "date": "2011-04-19T08:10:49Z"}, "committer": {"name": "Tristan Gingold", "email": "gingold@gcc.gnu.org", "date": "2011-04-19T08:10:49Z"}, "message": "config.gcc (-*-*-*vms): Added.\n\n2011-04-19  Tristan Gingold  <gingold@adacore.com>\n\n\t* config.gcc (-*-*-*vms): Added.\n\t(alpha64-dec-*vms*,alpha*-dec-*vms*, ia64-hp-*vms*): Common\n\tdefinitions moved.\n\t* config/vms/vms-ld.c: New file.\n\t* config/vms/vms-ar.c: New file.\n\t* config/vms/t-vmsnative: New file.\n\nFrom-SVN: r172695", "tree": {"sha": "dea71e8213cb17e26b6199f07444b01ceb890152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dea71e8213cb17e26b6199f07444b01ceb890152"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18a24fed724c9922c919563aa2bc7c94fd0a12ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a24fed724c9922c919563aa2bc7c94fd0a12ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a24fed724c9922c919563aa2bc7c94fd0a12ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a24fed724c9922c919563aa2bc7c94fd0a12ad/comments", "author": {"login": "gingold-adacore", "id": 16334725, "node_id": "MDQ6VXNlcjE2MzM0NzI1", "avatar_url": "https://avatars.githubusercontent.com/u/16334725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gingold-adacore", "html_url": "https://github.com/gingold-adacore", "followers_url": "https://api.github.com/users/gingold-adacore/followers", "following_url": "https://api.github.com/users/gingold-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/gingold-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/gingold-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gingold-adacore/subscriptions", "organizations_url": "https://api.github.com/users/gingold-adacore/orgs", "repos_url": "https://api.github.com/users/gingold-adacore/repos", "events_url": "https://api.github.com/users/gingold-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/gingold-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d4f8d0280ce63851f81888db1fe8c38ee03652c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d4f8d0280ce63851f81888db1fe8c38ee03652c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d4f8d0280ce63851f81888db1fe8c38ee03652c"}], "stats": {"total": 1387, "additions": 1372, "deletions": 15}, "files": [{"sha": "268b43a5ac1606dc9cbe852b12e31668fbefebce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18a24fed724c9922c919563aa2bc7c94fd0a12ad", "patch": "@@ -1,3 +1,12 @@\n+2011-04-19  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* config.gcc (-*-*-*vms): Added.\n+\t(alpha64-dec-*vms*,alpha*-dec-*vms*, ia64-hp-*vms*): Common\n+\tdefinitions moved.\n+\t* config/vms/vms-ld.c: New file.\n+\t* config/vms/vms-ar.c: New file.\n+\t* config/vms/t-vmsnative: New file.\n+\n 2011-04-18  Xinliang David Li  <davidxl@google.com>\n \n \t* final.c (dump_basic_block_info): Use ASM_COMMENT_START."}, {"sha": "7c318dea3a440a24e3a985216d9132bfb55211e0", "filename": "gcc/config.gcc", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=18a24fed724c9922c919563aa2bc7c94fd0a12ad", "patch": "@@ -668,6 +668,16 @@ case ${target} in\n *-*-solaris2*)\n   extra_options=\"${extra_options} sol2.opt\"\n   ;;\n+*-*-*vms*)\n+  extra_options=\"${extra_options} vms/vms.opt\"\n+  xmake_file=vms/x-vms\n+  tmake_file=\"vms/t-vms\"\n+  if test x$gnu_ld != xyes; then\n+    # Build wrappers for native case.\n+    extra_programs=\"ld\\$(exeext) ar\\$(exeext)\"\n+    tmake_file=\"$tmake_file vms/t-vmsnative\"\n+  fi\n+  ;;\n *-*-vxworks*)\n   tmake_file=t-vxworks\n   xm_defines=POSIX\n@@ -752,20 +762,12 @@ alpha*-dec-osf5.1*)\n alpha64-dec-*vms*)\n \ttm_file=\"${tm_file} alpha/vms.h alpha/vms64.h\"\n \txm_file=\"alpha/xm-vms.h vms/xm-vms64.h\"\n-\ttmake_file=\"alpha/t-alpha vms/t-vms alpha/t-vms alpha/t-ieee\"\n-\txmake_file=vms/x-vms\n-\texeext=.exe\n-\tinstall_headers_dir=install-headers-cp\n-\textra_options=\"${extra_options} vms/vms.opt\"\n+\ttmake_file=\"${tmake_file} alpha/t-alpha vms/t-vms64 alpha/t-vms alpha/t-ieee\"\n \t;;\n alpha*-dec-*vms*)\n \ttm_file=\"${tm_file} alpha/vms.h\"\n \txm_file=\"alpha/xm-vms.h\"\n-\ttmake_file=\"alpha/t-alpha vms/t-vms alpha/t-vms alpha/t-ieee\"\n-\txmake_file=vms/x-vms\n-\texeext=.exe\n-\tinstall_headers_dir=install-headers-cp\n-\textra_options=\"${extra_options} vms/vms.opt\"\n+\ttmake_file=\"${tmake_file} alpha/t-alpha alpha/t-vms alpha/t-ieee\"\n \t;;\n arm-wrs-vxworks)\n \ttm_file=\"elfos.h arm/elf.h arm/aout.h ${tm_file} vx-common.h vxworks.h arm/vxworks.h\"\n@@ -1582,16 +1584,13 @@ ia64*-*-hpux*)\n ia64-hp-*vms*)\n \ttm_file=\"${tm_file} elfos.h ia64/sysv4.h ia64/elf.h ia64/vms.h ia64/vms64.h\"\n \txm_file=\"vms/xm-vms.h vms/xm-vms64.h\"\n-\ttmake_file=\"vms/t-vms ia64/t-ia64 ia64/t-vms\"\n-\txmake_file=vms/x-vms\n+\ttmake_file=\"${tmake_file} vms/t-vms64 ia64/t-ia64 ia64/t-vms\"\n \ttarget_cpu_default=\"0\"\n \tif test x$gas = xyes\n \tthen\n \t\ttarget_cpu_default=\"${target_cpu_default}|MASK_GNU_AS\"\n \tfi\n-\texeext=.exe\n-\tinstall_headers_dir=install-headers-cp\n-\textra_options=\"${extra_options} vms/vms.opt ia64/vms.opt\"\n+\textra_options=\"${extra_options} ia64/vms.opt\"\n \t;;\n iq2000*-*-elf*)\n         tm_file=\"elfos.h newlib-stdint.h iq2000/iq2000.h\""}, {"sha": "a7fc031d4c1e5b44d1f3428f69b86abf35a375e4", "filename": "gcc/config/vms/t-vmsnative", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig%2Fvms%2Ft-vmsnative", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig%2Fvms%2Ft-vmsnative", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvms%2Ft-vmsnative?ref=18a24fed724c9922c919563aa2bc7c94fd0a12ad", "patch": "@@ -0,0 +1,30 @@\n+# Copyright (C) 2010\n+# Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+vms-ld.o: $(srcdir)/config/vms/vms-ld.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+ld$(exeext): vms-ld.o $(LIBIBERTY)\n+\t$(CC) -o $@ vms-ld.o $(LIBIBERTY)\n+\n+vms-ar.o: $(srcdir)/config/vms/vms-ar.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+ar$(exeext): vms-ar.o $(LIBIBERTY)\n+\t$(CC) -o $@ vms-ar.o $(LIBIBERTY)"}, {"sha": "d01a05299ac281f8b0ac5cca8f7d71bddd278b4b", "filename": "gcc/config/vms/vms-ar.c", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig%2Fvms%2Fvms-ar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig%2Fvms%2Fvms-ar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvms%2Fvms-ar.c?ref=18a24fed724c9922c919563aa2bc7c94fd0a12ad", "patch": "@@ -0,0 +1,351 @@\n+/* VMS archive wrapper.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by AdaCore.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#include \"libiberty.h\"\n+\n+#define FATAL_EXIT_CODE (44 | 0x10000000)\n+\n+/* Librarian arguments.  */\n+static int lib_arg_max = 0;\n+static const char **lib_args;\n+static int lib_arg_index = -1;\n+\n+/* Set for r/c/x/v command.  */\n+static int replace_mode = 0;\n+static int create_mode = 0;\n+static int extract_mode = 0;\n+static int verbose_mode = 0;\n+\n+static char modecmd[32];\n+static char libname[256];\n+\n+#define TEMP_FILE \"arXXXXXX\"\n+#define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)\n+#define SUFFIX \".com\"\n+#define SUFFIX_LEN (sizeof(SUFFIX) - 1)\n+\n+static char *to_host_file_spec (char *filespec);\n+static int is_regular_file (char *name);\n+\n+#ifdef VMS\n+static char new_host_filespec [255];\n+static char filename_buff [256];\n+\n+static int\n+translate_unix (char *name, int type)\n+{\n+  strcpy (filename_buff, name);\n+  return 0;\n+}\n+#endif\n+\n+static char *\n+to_host_file_spec (char *filespec)\n+{\n+#ifdef VMS\n+  if (strchr (filespec, ']') || strchr (filespec, ':'))\n+    return filespec;\n+  else\n+    {\n+      strcpy (filename_buff, filespec);\n+      decc$to_vms (filespec, translate_unix, 1, 1);\n+      strcpy (new_host_filespec, filename_buff);\n+      return new_host_filespec;\n+    }\n+#else\n+  return filespec;\n+#endif\n+}\n+\n+/* Check to see if the file named in NAME is a regular file, i.e. not a\n+   directory.  */\n+\n+static int\n+is_regular_file (char *name)\n+{\n+  int ret;\n+  struct stat statbuf;\n+\n+  ret = stat (name, &statbuf);\n+  return !ret && S_ISREG (statbuf.st_mode);\n+}\n+\n+/* Add the argument contained in STR to the list of arguments to pass to the\n+   archiver.  */\n+\n+static void\n+addarg (const char *str)\n+{\n+  if (++lib_arg_index >= lib_arg_max)\n+    {\n+      lib_arg_max += 1000;\n+      lib_args = XRESIZEVEC (const char *, lib_args, lib_arg_max);\n+    }\n+\n+  lib_args[lib_arg_index] = str;\n+}\n+\n+static void\n+usage (void)\n+{\n+  printf (\"usage: ar -r [-cv] archive file...\\n\");\n+  printf (\"       ar -c [-rv] archive file...\\n\");\n+  printf (\"       ar -x [-v] archive [module...]\\n\");\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i, nexti, iarg;\n+  FILE *comfile;\n+  int comfd;\n+  int outlen, maxoutlen = 4000;\n+  char *cwd;\n+  char temp_filename[] = TEMP_FILE SUFFIX;\n+  char command[256];\n+  int status;\n+\n+  cwd = getcwd (0, 1024);\n+\n+  if (argc < 2)\n+    {\n+      fprintf (stderr, \"ar: no command or archive\\n\");\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  if (argv[1][0] != '-')\n+    {\n+      int arglen = strlen (argv[1]);\n+\n+      /* Compatibility mode.  */\n+      for (i = 0; i < arglen; i++)\n+\t{\n+\t  if (argv[1][i] == 'r')\n+\t    {\n+\t      replace_mode = 1;\n+\t    }\n+\t  else if (argv[1][i] == 'c')\n+\t    {\n+\t      create_mode = 1;\n+\t    }\n+\t  else if (argv[1][i] == 'x')\n+\t    {\n+\t      extract_mode = 1;\n+\t    }\n+\t  else if (argv[1][i] == 'v')\n+\t    {\n+\t      verbose_mode = 1;\n+\t    }\n+          else\n+            {\n+              fprintf (stderr, \"ar: unknown command '%c'\\n\", argv[1][i]);\n+              exit (FATAL_EXIT_CODE);\n+            }\n+\t}\n+      nexti = 2;\n+    }\n+  else\n+    {\n+      /* Option mode.  */\n+      nexti = 1;\n+      for (i = 1; i < argc; i++)\n+\t{\n+\t  if (argv[i][0] != '-')\n+\t    {\n+\t      nexti = i;\n+\t      break;\n+\t    }\n+\t  else if (strcmp (argv[i], \"-r\") == 0)\n+\t    {\n+\t      replace_mode = 1;\n+\t    }\n+\t  else if (strcmp (argv[i], \"-c\") == 0)\n+\t    {\n+\t      create_mode = 1;\n+\t    }\n+\t  else if (strcmp (argv[i], \"-x\") == 0)\n+\t    {\n+\t      extract_mode = 1;\n+\t    }\n+\t  else if (strcmp (argv[i], \"-v\") == 0)\n+\t    {\n+\t      verbose_mode = 1;\n+\t    }\n+\t  else if (strcmp (argv[i], \"--help\") == 0)\n+\t    {\n+              usage ();\n+              exit (EXIT_SUCCESS);\n+\t    }\n+          else\n+            {\n+              fprintf (stderr, \"ar: unknown option %s\\n\", argv[i]);\n+              exit (FATAL_EXIT_CODE);\n+            }\n+\t}\n+    }\n+\n+  if (extract_mode)\n+    {\n+      do\n+        {\n+          char *lname = argv[nexti];\n+          int lnamelen;\n+\n+          /* Next argument is the archive name.  */\n+          if (is_regular_file (lname))\n+            {\n+              addarg (xstrdup (to_host_file_spec (lname)));\n+              break;\n+            }\n+\n+          /* If not found, try with .olb instead of .a.  */\n+          lnamelen = strlen (lname);\n+\n+\t  if (lnamelen > 2\n+              && strcmp (&lname [lnamelen - 2], \".a\") == 0)\n+\t    {\n+\t      char *nlibname;\n+\n+\t      nlibname = (char *)alloca (lnamelen + 3);\n+\t      strcpy (nlibname, lname);\n+\t      strcpy (&nlibname [lnamelen - 2], \".olb\");\n+\t      if (is_regular_file (nlibname))\n+                {\n+                  addarg (xstrdup (to_host_file_spec (nlibname)));\n+                  break;\n+                }\n+            }\n+\n+          fprintf (stderr, \"ar: file '%s' doesn't exist\\n\", lname);\n+          exit (FATAL_EXIT_CODE);\n+\t} while (0);\n+    }\n+  else\n+    strcpy (libname, to_host_file_spec (argv[nexti]));\n+\n+  nexti++;\n+\n+  /* Build command mode.  */\n+  if (replace_mode)\n+    {\n+      strcat (modecmd, \"/replace\");\n+\n+      if (!is_regular_file (libname) || !replace_mode)\n+        {\n+          /* Really create if the archive doesn't exist.  */\n+          strcat (modecmd, \"/create\");\n+        }\n+    }\n+  else if (extract_mode)\n+    {\n+      if (nexti == argc)\n+        {\n+          /* Extract all.  */\n+          strcat (modecmd, \"/extract=(*\");\n+        }\n+      else\n+        strcat (modecmd, \"/extract=(\");\n+    }\n+\n+  /* Add files.  */\n+  for (i = nexti; i < argc; i++)\n+    {\n+      if (extract_mode)\n+        {\n+          /* Convert to module name (remove extension) and quote it.  */\n+          char *module = argv[i];\n+          int module_len = strlen (module);\n+          char *newarg = (char *)xmalloc (module_len + 3);\n+          int l;\n+\n+          newarg[0] = '\"';\n+          memcpy (newarg + 1, module, module_len);\n+\n+          l = 1 + module_len;\n+          if (module_len > 4\n+              && strcmp (&module[module_len - 4], \".obj\") == 0)\n+            l -= 4;\n+\n+          newarg[l] = '\"';\n+          newarg[l + 1] = 0;\n+\n+          addarg (newarg);\n+        }\n+      else\n+        {\n+          /* Add the filename.  */\n+          addarg (xstrdup (to_host_file_spec (argv[i])));\n+        }\n+    }\n+\n+  if (extract_mode)\n+    addarg (\")\");\n+\n+  /* Create the command file name.  */\n+  strcpy (temp_filename, TEMP_FILE SUFFIX);\n+  comfd = mkstemps (temp_filename, SUFFIX_LEN);\n+  comfile = fdopen (comfd, \"w\");\n+\n+  /* Write the command file.\n+     We need to split to command into severals ones if it is too long.  */\n+  outlen = 0;\n+  for (iarg = 0; iarg <= lib_arg_index; iarg++)\n+    {\n+      if (outlen == 0)\n+        {\n+          fprintf (comfile, \"$ library %s %s -\\n\", modecmd, libname);\n+          if (create_mode && iarg == 0)\n+            strcpy (modecmd, \"/replace\");\n+        }\n+\n+      fprintf (comfile, \"%s\", lib_args [iarg]);\n+      outlen += strlen (lib_args [iarg]) + 2;\n+\n+      if (outlen > maxoutlen || iarg == lib_arg_index)\n+        {\n+          /* Will write a new command.  */\n+          fprintf (comfile, \"\\n\");\n+          outlen = 0;\n+        }\n+      else\n+        {\n+          /* Continuation line.  */\n+          fprintf (comfile, \",-\\n\");\n+        }\n+    }\n+\n+  fclose (comfile);\n+\n+  sprintf (command, \"@%s\", temp_filename);\n+\n+  status = system (command);\n+\n+  remove (temp_filename);\n+\n+  exit (status);\n+}"}, {"sha": "18776fa2e38b1c189d575b5e1e47e0b88b8ff010", "filename": "gcc/config/vms/vms-ld.c", "status": "added", "additions": 968, "deletions": 0, "changes": 968, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig%2Fvms%2Fvms-ld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18a24fed724c9922c919563aa2bc7c94fd0a12ad/gcc%2Fconfig%2Fvms%2Fvms-ld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvms%2Fvms-ld.c?ref=18a24fed724c9922c919563aa2bc7c94fd0a12ad", "patch": "@@ -0,0 +1,968 @@\n+/* VMS linker wrapper.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by AdaCore\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This program is a wrapper around the VMS linker.\n+   It translates Unix style command line options into corresponding\n+   VMS style qualifiers and then spawns the VMS linker.\n+\n+   It is possible to build this program on UNIX but only for the purpose of\n+   checking for errors.  */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+\n+#include \"libiberty.h\"\n+#include <safe-ctype.h>\n+#include <sys/stat.h>\n+\n+/* Macro for logicals.  */\n+#define LNM__STRING 2\n+#define LNM_C_NAMLENGTH 255\n+#define PSL_C_SUPER 2\n+#define PSL_C_USER 3\n+\n+/* Local variable declarations.  */\n+static int ld_nocall_debug = 0;\n+static int ld_mkthreads = 0;\n+static int ld_upcalls = 0;\n+\n+/* verbose = 1 if -v passed.  */\n+static int verbose = 0;\n+\n+/* save_temps = 1 if -save-temps passed.  */\n+static int save_temps = 0;\n+\n+/* By default don't generate executable file if there are errors\n+   in the link.  Override with --noinhibit-exec.  */\n+static int inhibit_exec = 1;\n+\n+/* debug = 1 if -g passed.  */\n+static int debug = 0;\n+\n+/* By default prefer to link with static libraries.  */\n+static int staticp = 1;\n+\n+/* By default generate an executable, not a shareable image library.\n+   Override with -shared.  */\n+static int share = 0;\n+\n+/* Linker command line.  */\n+static int link_cmd_maxlen = 0;\n+static char *link_cmd = 0;\n+static int link_cmd_len = 0;\n+\n+/* Keep track of filenames.  */\n+static char *sharebasename;\n+static const char *exefullfilename;\n+static const char *exefilename;\n+\n+/* Search dir list passed on command line (with -L).  */\n+static const char **search_dirs;\n+static int search_dirs_len;\n+\n+/* Local function declarations.  */\n+static void addarg (const char *);\n+static int is_regular_file (char *);\n+static char *to_host_file_spec (char *);\n+static char *locate_lib (char *);\n+static const char *expand_lib (char *);\n+static void preprocess_args (int, char **);\n+static void process_args (int, char **);\n+static void maybe_set_link_compat (void);\n+static int set_exe (const char *);\n+#ifdef VMS\n+static int translate_unix (char *, int);\n+#endif\n+\f\n+\n+/* Append STR to the command line to invoke the linker.\n+   Expand the line as necessary to accommodate.  */\n+\n+static void\n+addarg (const char *str)\n+{\n+  int l = strlen (str);\n+\n+  /* Extend the line.  */\n+  if (link_cmd_len + l >= link_cmd_maxlen)\n+    {\n+      link_cmd_maxlen = link_cmd_len + l + 1024;\n+      link_cmd = XRESIZEVEC (char, link_cmd, link_cmd_maxlen);\n+    }\n+\n+  memcpy (link_cmd + link_cmd_len, str, l);\n+  link_cmd_len += l;\n+}\n+\n+/* Check to see if NAME is a regular file, i.e. not a directory.  */\n+\n+static int\n+is_regular_file (char *name)\n+{\n+  int ret;\n+  struct stat statbuf;\n+\n+  ret = stat (name, &statbuf);\n+  return !ret && S_ISREG (statbuf.st_mode);\n+}\n+\n+#ifdef VMS\n+static char new_host_filespec [255];\n+static char filename_buff [256];\n+\n+/* Action routine called by decc$to_vms.  NAME is a file name or\n+   directory name.  TYPE is unused.  */\n+\n+static int\n+translate_unix (char *name, int type ATTRIBUTE_UNUSED)\n+{\n+  strcpy (filename_buff, name);\n+  return 0;\n+}\n+#endif\n+\n+/* Translate a Unix syntax file specification FILESPEC into VMS syntax.\n+   If indicators of VMS syntax found, return input string.\n+   Return a pointer to a static buffer.  */\n+\n+static char *\n+to_host_file_spec (char *filespec)\n+{\n+#ifdef VMS\n+  if (strchr (filespec, ']') || strchr (filespec, ':'))\n+    {\n+      /* Looks like a VMS path.  */\n+      return filespec;\n+    }\n+  else\n+    {\n+\n+      strcpy (filename_buff, filespec);\n+      decc$to_vms (filespec, translate_unix, 1, 1);\n+      strcpy (new_host_filespec, filename_buff);\n+      return new_host_filespec;\n+    }\n+#else\n+  return filespec;\n+#endif\n+}\n+\n+/* Locate library LIB_NAME on the library path.  */\n+\n+static char *\n+locate_lib (char *lib_name)\n+{\n+  int lib_len = strlen (lib_name);\n+  const char *exts[3];\n+  int i;\n+\n+  if (staticp)\n+    {\n+      /* For static links, look for shareable image libraries last.  */\n+      exts[0] = \".a\";\n+      exts[1] = \".olb\";\n+      exts[2] = \".exe\";\n+    }\n+  else\n+    {\n+      exts[0] = \".exe\";\n+      exts[1] = \".a\";\n+      exts[2] = \".olb\";\n+    }\n+\n+  for (i = 0; i < search_dirs_len; i++)\n+    {\n+      char *buf;\n+      int l;\n+      int j;\n+\n+      l = strlen (search_dirs[i]);\n+      buf = (char *)alloca (l + 4 + lib_len + 4 + 1);\n+      /* Put PATH/libLIB.  */\n+      memcpy (buf, search_dirs[i], l);\n+      memcpy (buf + l, \"/lib\", 4);\n+      l += 4;\n+      memcpy (buf + l, lib_name, lib_len);\n+      l += lib_len;\n+\n+      /* Look for files with the extensions.  */\n+      for (j = 0; j < 3; j++)\n+        {\n+\t  strcpy (buf + l, exts[j]);\n+\t  if (is_regular_file (buf))\n+\t    return xstrdup (to_host_file_spec (buf));\n+        }\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Given a library name NAME, i.e. foo,  Look for libfoo.lib and then\n+   libfoo.a in the set of directories we are allowed to search in.\n+   May return NULL if the library can be discarded.  */\n+\n+static const char *\n+expand_lib (char *name)\n+{\n+  char *lib_path;\n+\n+  /* Discard libc.  */\n+  if (strcmp (name, \"c\") == 0)\n+    return NULL;\n+\n+  /* Discard libm.  No separate library for math functions.  */\n+  if (strcmp (name, \"m\") == 0)\n+    return NULL;\n+\n+  /* Search on path.  */\n+  lib_path = locate_lib (name);\n+  if (lib_path)\n+    return lib_path;\n+\n+  fprintf (stderr,\n+\t   \"Couldn't locate library: lib%s.exe, lib%s.a or lib%s.olb\\n\",\n+\t   name, name, name);\n+\n+  exit (EXIT_FAILURE);\n+}\n+\n+/* Preprocess the number of args P_ARGC in ARGV.\n+   Look for special flags, etc. that must be handled first.  */\n+\n+static void\n+preprocess_args (int argc, char **argv)\n+{\n+  int i;\n+\n+  /* Scan for -shared.  */\n+  for (i = 1; i < argc; i++)\n+    if (strcmp (argv[i], \"-shared\") == 0)\n+      {\n+        share = 1;\n+        break;\n+      }\n+\n+  for (i = 1; i < argc; i++)\n+    if (strcmp (argv[i], \"-o\") == 0)\n+      {\n+\tint len;\n+\n+\ti++;\n+        exefilename = lbasename (argv[i]);\n+\texefullfilename = xstrdup (to_host_file_spec (argv[i]));\n+\n+\tif (share)\n+          addarg(\" /share=\");\n+\telse\n+\t  addarg (\" /exe=\");\n+        addarg (exefullfilename);\n+\n+\tif (share)\n+\t  {\n+            char *ptr;\n+\n+            /* Extract the basename.  */\n+\t    ptr = strchr (argv[i], ']');\n+            if (ptr == NULL)\n+              ptr = strchr (argv[i], ':');\n+            if (ptr == NULL)\n+              ptr = strchr (argv[i], '/');\n+            if (ptr == NULL)\n+\t      sharebasename = xstrdup (argv[i]);\n+            else\n+\t      sharebasename = xstrdup (ptr + 1);\n+\n+\t    len = strlen (sharebasename);\n+\t    if (strncasecmp (&sharebasename[len-4], \".exe\", 4) == 0)\n+\t      sharebasename[len - 4] = 0;\n+\n+            /* Convert to uppercase.  */\n+\t    for (ptr = sharebasename; *ptr; ptr++)\n+\t      *ptr = TOUPPER (*ptr);\n+\t  }\n+      }\n+\n+  if (exefullfilename == NULL && !share)\n+    {\n+      exefilename = \"a_out.exe\";\n+      exefullfilename = \"a_out.exe\";\n+      addarg (xstrdup (\" /exe=a_out.exe\"));\n+    }\n+}\n+\n+/* Preprocess the number of args ARGC in ARGV.  Look for\n+   special flags, etc. that must be handled for the VMS linker.  */\n+\n+static void\n+process_args (int argc, char **argv)\n+{\n+  int i;\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      if (strncmp (argv[i], \"-L\", 2) == 0)\n+\t{\n+          search_dirs = XRESIZEVEC(const char *, search_dirs,\n+                                   search_dirs_len + 1);\n+          search_dirs[search_dirs_len++] = &argv[i][2];\n+\t}\n+\n+      /* -v turns on verbose option here and is passed on to gcc.  */\n+      else if (strcmp (argv[i], \"-v\") == 0)\n+\tverbose++;\n+      else if (strcmp (argv[i], \"--version\") == 0)\n+\t{\n+\t  fprintf (stdout, \"VMS Linker\\n\");\n+          exit (EXIT_SUCCESS);\n+\t}\n+      else if (strcmp (argv[i], \"--help\") == 0)\n+\t{\n+\t  fprintf (stdout, \"VMS Linker\\n\");\n+          exit (EXIT_SUCCESS);\n+\t}\n+      else if (strcmp (argv[i], \"-g0\") == 0)\n+\taddarg (\"/notraceback\");\n+      else if (strncmp (argv[i], \"-g\", 2) == 0)\n+\t{\n+\t  addarg (\"/debug\");\n+\t  debug = 1;\n+\t}\n+      else if (strcmp (argv[i], \"-static\") == 0)\n+\tstaticp = 1;\n+      else if (strcmp (argv[i], \"-map\") == 0)\n+\t{\n+\t  char *buff, *ptr;\n+\n+\t  buff = (char *) xstrdup (exefullfilename);\n+\t  ptr = strrchr (buff, '.');\n+\t  if (ptr)\n+\t    *ptr = 0;\n+\n+\t  strcat (buff, \".map\");\n+\t  addarg (\"/map=\");\n+\t  addarg (buff);\n+          addarg (\".map\");\n+\t  addarg (\"/full\");\n+\n+          free (buff);\n+\t}\n+      else if (strcmp (argv[i], \"-save-temps\") == 0)\n+\tsave_temps = 1;\n+      else if (strcmp (argv[i], \"--noinhibit-exec\") == 0)\n+\tinhibit_exec = 0;\n+    }\n+}\n+\n+#ifdef VMS\n+typedef struct dsc\n+{\n+  unsigned short len, mbz;\n+  const char *adr;\n+} Descriptor;\n+\n+struct lst\n+{\n+  unsigned short buflen, item_code;\n+  const void *bufaddr;\n+  void *retlenaddr;\n+};\n+\n+static struct\n+{\n+  struct lst items [1];\n+  unsigned int terminator;\n+} item_lst1;\n+\n+static struct\n+{\n+  struct lst items [2];\n+  unsigned int terminator;\n+} item_lst2;\n+\n+/* Checks if logical names are defined for setting system library path and\n+   linker program to enable compatibility with earlier VMS versions.  */\n+\n+static void\n+maybe_set_link_compat (void)\n+{\n+  char lnm_buff [LNM_C_NAMLENGTH];\n+  unsigned int lnm_buff_len;\n+  int status;\n+  Descriptor tabledsc, linkdsc;\n+\n+  tabledsc.adr = \"LNM$JOB\";\n+  tabledsc.len = strlen (tabledsc.adr);\n+  tabledsc.mbz = 0;\n+\n+  linkdsc.adr = \"GCC_LD_SYS$LIBRARY\";\n+  linkdsc.len = strlen (linkdsc.adr);\n+  linkdsc.mbz = 0;\n+\n+  item_lst1.items[0].buflen = LNM_C_NAMLENGTH;\n+  item_lst1.items[0].item_code = LNM__STRING;\n+  item_lst1.items[0].bufaddr = lnm_buff;\n+  item_lst1.items[0].retlenaddr = &lnm_buff_len;\n+  item_lst1.terminator = 0;\n+\n+  status = SYS$TRNLNM\n+    (0,          /* attr */\n+     &tabledsc,  /* tabnam */\n+     &linkdsc,   /* lognam */\n+     0,          /* acmode */\n+     &item_lst1);\n+\n+  /* If GCC_LD_SYS$LIBRARY is defined, redefine SYS$LIBRARY to search\n+     the equivalence name first for system libraries, then the default\n+     system library directory */\n+\n+  if ((status & 1) == 1)\n+    {\n+      unsigned char acmode = PSL_C_USER; /* Don't retain after image exit */\n+      const char *syslib = \"SYS$SYSROOT:[SYSLIB]\"; /* Default SYS$LIBRARY */\n+\n+      /* Only visible to current and child processes */\n+      tabledsc.adr = \"LNM$PROCESS\";\n+      tabledsc.len = strlen (tabledsc.adr);\n+      tabledsc.mbz = 0;\n+\n+      linkdsc.adr = \"SYS$LIBRARY\";\n+      linkdsc.len = strlen (linkdsc.adr);\n+      linkdsc.mbz = 0;\n+\n+      item_lst2.items[0].buflen = lnm_buff_len;\n+      item_lst2.items[0].item_code = LNM__STRING;\n+      item_lst2.items[0].bufaddr = lnm_buff;\n+      item_lst2.items[0].retlenaddr = 0;\n+\n+      item_lst2.items[1].buflen = strlen (syslib);\n+      item_lst2.items[1].item_code = LNM__STRING;\n+      item_lst2.items[1].bufaddr = syslib;\n+      item_lst2.items[1].retlenaddr = 0;\n+      item_lst2.terminator = 0;\n+\n+      status = SYS$CRELNM\n+\t(0,          /* attr */\n+\t &tabledsc,  /* tabnam */\n+\t &linkdsc,   /* lognam */\n+\t &acmode,    /* acmode */\n+\t &item_lst2);\n+\n+    }\n+\n+  tabledsc.adr = \"LNM$JOB\";\n+  tabledsc.len = strlen (tabledsc.adr);\n+  tabledsc.mbz = 0;\n+\n+  linkdsc.adr = \"GCC_LD_LINK\";\n+  linkdsc.len = strlen (linkdsc.adr);\n+  linkdsc.mbz = 0;\n+\n+  item_lst1.items[0].buflen = LNM_C_NAMLENGTH;\n+  item_lst1.items[0].item_code = LNM__STRING;\n+  item_lst1.items[0].bufaddr = lnm_buff;\n+  item_lst1.items[0].retlenaddr = &lnm_buff_len;\n+  item_lst1.terminator = 0;\n+\n+  status = SYS$TRNLNM\n+    (0,          /* attr */\n+     &tabledsc,  /* tabnam */\n+     &linkdsc,   /* lognam */\n+     0,          /* acmode */\n+     &item_lst1);\n+\n+  /* If GCC_LD_LINK is defined, redefine LINK to use the equivalence name\n+     (sometimes the LINK program version is used by VMS to determine\n+     compatibility).  */\n+\n+  if ((status & 1) == 1)\n+    {\n+      unsigned char acmode = PSL_C_USER; /* Don't retain after image exit.  */\n+\n+      /* Only visible to current and child processes.  */\n+      tabledsc.adr = \"LNM$PROCESS\";\n+      tabledsc.len = strlen (tabledsc.adr);\n+      tabledsc.mbz = 0;\n+\n+      linkdsc.adr = \"LINK\";\n+      linkdsc.len = strlen (linkdsc.adr);\n+      linkdsc.mbz = 0;\n+\n+      item_lst1.items[0].buflen = lnm_buff_len;\n+      item_lst1.items[0].item_code = LNM__STRING;\n+      item_lst1.items[0].bufaddr = lnm_buff;\n+      item_lst1.items[0].retlenaddr = 0;\n+      item_lst1.terminator = 0;\n+\n+      status = SYS$CRELNM\n+\t(0,          /* attr */\n+\t &tabledsc,  /* tabnam */\n+\t &linkdsc,   /* lognam */\n+\t &acmode,    /* acmode */\n+\t &item_lst1);\n+    }\n+}\n+#else\n+static void\n+maybe_set_link_compat (void)\n+{\n+}\n+#endif\n+\n+/* Set environment defined executable attributes.  */\n+\n+static int\n+set_exe (const char *arg)\n+{\n+  char allargs [1024];\n+  int res;\n+\n+  snprintf (allargs, sizeof (allargs),\n+            \"$@gnu:[bin]set_exe %s %s\", exefullfilename, arg);\n+  if (verbose)\n+    printf (\"%s\\n\", allargs);\n+\n+  res = system (allargs);\n+  if (verbose > 1)\n+    printf (\"$!status = %d\\n\", res);\n+\n+  if ((res & 1) != 1)\n+    {\n+      fprintf (stderr, \"ld error: popen set_exe\\n\");\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* The main program.  Spawn the VMS linker after fixing up the Unix-like flags\n+   and args to be what the VMS linker wants.  */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  /* File specification for vms-dwarf2.o.  */\n+  char *vmsdwarf2spec = 0;\n+\n+  /* File specification for vms-dwarf2eh.o.  */\n+  char *vmsdwarf2ehspec = 0;\n+\n+  int i;\n+  char cwdev[128], *devptr;\n+  int cwdevlen;\n+  FILE *optfile;\n+  char *cwd, *ptr;\n+  char *optfilename;\n+  int status = 0;\n+\n+  /* Some linker options can be set with logicals.  */\n+  if (getenv (\"GNAT$LD_NOCALL_DEBUG\"))\n+    ld_nocall_debug = 1;\n+  if (getenv (\"GNAT$LD_MKTHREADS\"))\n+    ld_mkthreads = 1;\n+  if (getenv (\"GNAT$LD_UPCALLS\"))\n+    ld_upcalls = 1;\n+  if (getenv (\"GNAT$LD_SHARED_LIBS\"))\n+    staticp = 0;\n+\n+  /* Get current dir.  */\n+#ifdef VMS\n+  cwd = getcwd (0, 1024, 1);\n+#else\n+  cwd = getcwd (0, 1024);\n+  strcat (cwd, \"/\");\n+#endif\n+\n+  /* Extract device part of the path.  */\n+  devptr = strchr (cwd, ':');\n+  if (devptr)\n+    cwdevlen = (devptr - cwd) + 1;\n+  else\n+    cwdevlen = 0;\n+  memcpy (cwdev, cwd, cwdevlen);\n+  cwdev [cwdevlen] = '\\0';\n+\n+  maybe_set_link_compat ();\n+\n+  /* Linker command starts with the command name.  */\n+  addarg (\"$ link\");\n+\n+  /* Pass to find args that have to be append first.  */\n+  preprocess_args (argc , argv);\n+\n+  /* Pass to find the rest of the args.  */\n+  process_args (argc , argv);\n+\n+  if (!verbose)\n+    addarg (\"/noinform\");\n+\n+  /* Create a temp file to hold args, otherwise we can easily exceed the VMS\n+     command line length limits.  */\n+  optfilename = (char *) xmalloc (strlen (exefilename) + 13);\n+  strcpy (optfilename, exefilename);\n+  ptr = strrchr (optfilename, '.');\n+  if (ptr)\n+    *ptr = 0;\n+  strcat (optfilename, \".opt_tmpfile\");\n+  optfile = fopen (optfilename, \"w\");\n+\n+  /* Write out the IDENTIFICATION argument first so that it can be overridden\n+     by an options file.  */\n+  for (i = 1; i < argc; i++)\n+    {\n+      int arg_len = strlen (argv[i]);\n+\n+      if (arg_len > 6 && strncasecmp (argv[i], \"IDENT=\", 6) == 0)\n+\t{\n+\t  /* Comes from command line. If present will always appear before\n+\t     --identification=... and will override.  */\n+          break;\n+\t}\n+      else if (arg_len > 17\n+\t       && strncasecmp (argv[i], \"--identification=\", 17) == 0)\n+\t{\n+\t  /* Comes from pragma Ident ().  */\n+          fprintf (optfile, \"case_sensitive=yes\\n\");\n+          fprintf (optfile, \"IDENTIFICATION=\\\"%15.15s\\\"\\n\", &argv[i][17]);\n+          fprintf (optfile, \"case_sensitive=NO\\n\");\n+\t}\n+    }\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      int arg_len = strlen (argv[i]);\n+\n+      if (strcmp (argv[i], \"-o\") == 0)\n+        {\n+          /* Already handled.  */\n+          i++;\n+        }\n+      else if (arg_len > 2 && strncmp (argv[i], \"-l\", 2) == 0)\n+\t{\n+\t  const char *libname;\n+\n+          libname = expand_lib (&argv[i][2]);\n+\t  if (libname != NULL)\n+\t    {\n+              int len = strlen (libname);\n+              const char *ext;\n+\n+\t      if (len > 4 && strcasecmp (&libname [len-4], \".exe\") == 0)\n+\t\text = \"/shareable\";\n+\t      else\n+\t\text = \"/library\";\n+\n+\t      if (libname[0] == '[')\n+                fprintf (optfile, \"%s%s%s\\n\", cwdev, libname, ext);\n+\t      else\n+                fprintf (optfile, \"%s%s\\n\", libname, ext);\n+\t    }\n+\t}\n+      else if (strcmp (argv[i], \"-v\" ) == 0\n+\t       || strncmp (argv[i], \"-g\", 2 ) == 0\n+\t       || strcmp (argv[i], \"-static\" ) == 0\n+\t       || strcmp (argv[i], \"-map\" ) == 0\n+\t       || strcmp (argv[i], \"-save-temps\") == 0\n+\t       || strcmp (argv[i], \"--noinhibit-exec\") == 0\n+\t       || (arg_len > 2 && strncmp (argv[i], \"-L\", 2) == 0)\n+\t       || (arg_len >= 6 && strncmp (argv[i], \"-share\", 6) == 0))\n+        {\n+          /* Already handled.  */\n+        }\n+      else if (strncmp (argv[i], \"--opt=\", 6) == 0)\n+\tfprintf (optfile, \"%s\\n\", argv[i] + 6);\n+      else if (arg_len > 1 && argv[i][0] == '@')\n+\t{\n+          /* Read response file (in fact a single line of filenames).  */\n+\t  FILE *atfile;\n+\t  char *ptr, *ptr1;\n+\t  struct stat statbuf;\n+\t  char *buff;\n+\t  int len;\n+\n+\t  if (stat (&argv[i][1], &statbuf))\n+\t    {\n+\t      fprintf (stderr, \"Couldn't open linker response file: %s\\n\",\n+\t\t       &argv[i][1]);\n+\t      exit (EXIT_FAILURE);\n+\t    }\n+\n+          /* Read the line.  */\n+\t  buff = (char *) xmalloc (statbuf.st_size + 1);\n+\t  atfile = fopen (&argv[i][1], \"r\");\n+\t  fgets (buff, statbuf.st_size + 1, atfile);\n+\t  fclose (atfile);\n+\n+          /* Remove trailing \\n.  */\n+\t  len = strlen (buff);\n+\t  if (buff [len - 1] == '\\n')\n+\t    {\n+\t      buff [len - 1] = 0;\n+\t      len--;\n+\t    }\n+\n+          /* Put the filenames to the opt file.  */\n+\t  ptr = buff;\n+\t  do\n+\t  {\n+\t     ptr1 = strchr (ptr, ' ');\n+\t     if (ptr1)\n+\t       *ptr1 = 0;\n+\n+             /* Add device name if a path is present.  */\n+\t     ptr = to_host_file_spec (ptr);\n+\t     if (ptr[0] == '[')\n+\t       fprintf (optfile, \"%s%s\\n\", cwdev, ptr);\n+\t     else\n+\t       fprintf (optfile, \"%s\\n\", ptr);\n+\n+\t     ptr = ptr1 + 1;\n+\t  }\n+          while (ptr1);\n+\t}\n+      else if ((argv[i][0] == '/') && (strchr (&argv[i][1], '/') == 0))\n+        {\n+          /* Unix style file specs and VMS style switches look alike,\n+             so assume an arg consisting of one and only one slash,\n+             and that being first, is really a switch.  */\n+          addarg (argv[i]);\n+        }\n+      else if (arg_len > 4\n+\t       && strncasecmp (&argv[i][arg_len-4], \".opt\", 4) == 0)\n+\t{\n+          /* Read option file.  */\n+\t  FILE *optfile1;\n+\t  char buff[256];\n+\n+\t  /* Disable __UNIX_FOPEN redefinition in case user supplied .opt\n+\t     file is not stream oriented. */\n+\n+\t  optfile1 = (fopen) (argv[i], \"r\");\n+\t  if (optfile1 == 0)\n+\t    {\n+\t      perror (argv[i]);\n+\t      status = 1;\n+\t      goto cleanup_and_exit;\n+\t    }\n+\n+\t  while (fgets (buff, sizeof (buff), optfile1))\n+\t    fputs (buff, optfile);\n+\n+\t  fclose (optfile1);\n+\t}\n+      else if (arg_len > 7 && strncasecmp (argv[i], \"GSMATCH\", 7) == 0)\n+\tfprintf (optfile, \"%s\\n\", argv[i]);\n+      else if (arg_len > 6 && strncasecmp (argv[i], \"IDENT=\", 6) == 0)\n+\t{\n+\t  /* Comes from command line and will override pragma.  */\n+\t  fprintf (optfile, \"case_sensitive=yes\\n\");\n+\t  fprintf (optfile, \"IDENT=\\\"%15.15s\\\"\\n\", &argv[i][6]);\n+\t  fprintf (optfile, \"case_sensitive=NO\\n\");\n+\t}\n+      else if (arg_len > 17\n+\t       && strncasecmp (argv[i], \"--identification=\", 17) == 0)\n+        {\n+          /* Already handled.  */\n+        }\n+      else\n+\t{\n+\t  /* Assume filename arg.  */\n+          const char *file;\n+\t  const char *addswitch = NULL;\n+\t  char *buff;\n+\t  int buff_len;\n+\t  int is_cld = 0;\n+\n+\t  file = to_host_file_spec (argv[i]);\n+\t  arg_len = strlen (file);\n+\n+\t  /* Handle shareable image libraries.  */\n+\t  if (arg_len > 4 && strcasecmp (&file[arg_len - 4], \".exe\") == 0)\n+\t    addswitch = \"/shareable\";\n+\t  else if (arg_len > 4 && strcasecmp (&file[arg_len - 4], \".cld\") == 0)\n+\t    {\n+\t      addswitch = \"/shareable\";\n+\t      is_cld = 1;\n+\t    }\n+\n+\t  /* Handle object libraries.  */\n+\t  else if (arg_len > 2 && strcasecmp (&file[arg_len - 2], \".a\") == 0)\n+\t    addswitch = \"/lib\";\n+\t  else if (arg_len > 4 && strcasecmp (&file[arg_len - 4], \".olb\") == 0)\n+\t    addswitch = \"/lib\";\n+\n+\t  /* Absolutize file location.  */\n+\t  if (file[0] == '[')\n+\t    {\n+\t      buff = (char *) xmalloc (cwdevlen + arg_len + 1);\n+\t      sprintf (buff, \"%s%s\", cwdev, file);\n+\t    }\n+\t  else if (strchr (file, ':'))\n+\t    {\n+\t      buff = xstrdup (file);\n+\t    }\n+\t  else\n+\t    {\n+\t      buff = (char *) xmalloc (strlen (cwd) + arg_len + 1);\n+\t      sprintf (buff, \"%s%s\", cwd, file);\n+\t    }\n+\n+\t  buff_len = strlen (buff);\n+\n+\t  if (buff_len >= 15\n+\t      && strcasecmp (&buff[buff_len - 14], \"vms-dwarf2eh.o\") == 0)\n+\t    {\n+              /* Remind of it.  */\n+              vmsdwarf2ehspec = xstrdup (buff);\n+\t    }\n+\t  else if (buff_len >= 13\n+                   && strcasecmp (&buff[buff_len - 12], \"vms-dwarf2.o\") == 0)\n+            {\n+              /* Remind of it.  */\n+              vmsdwarf2spec = xstrdup (buff);\n+            }\n+\t  else if (is_cld)\n+\t    {\n+              /* Command line definition file.  */\n+              addarg (buff);\n+              addarg (addswitch);\n+\t      addarg (\",\");\n+\t    }\n+\t  else\n+\t    {\n+              fprintf (optfile, \"%s%s\\n\",\n+                       buff, addswitch != NULL ? addswitch : \"\");\n+\t    }\n+          free (buff);\n+\t}\n+    }\n+\n+  if (vmsdwarf2ehspec)\n+    {\n+      /* Sequentialize exception handling info.  */\n+\n+      fprintf (optfile, \"case_sensitive=yes\\n\");\n+      fprintf (optfile, \"cluster=DWARF2eh,,,%s\\n\", vmsdwarf2ehspec);\n+      fprintf (optfile, \"collect=DWARF2eh,eh_frame\\n\");\n+      fprintf (optfile, \"case_sensitive=NO\\n\");\n+    }\n+\n+  if (debug && vmsdwarf2spec)\n+    {\n+      /* Sequentialize the debug info.  */\n+\n+      fprintf (optfile, \"case_sensitive=yes\\n\");\n+      fprintf (optfile, \"cluster=DWARF2debug,,,%s\\n\", vmsdwarf2spec);\n+      fprintf (optfile, \"collect=DWARF2debug,debug_abbrev,debug_aranges,-\\n\");\n+      fprintf (optfile, \" debug_frame,debug_info,debug_line,debug_loc,-\\n\");\n+      fprintf (optfile, \" debug_macinfo,debug_pubnames,debug_str,-\\n\");\n+      fprintf (optfile, \" debug_zzzzzz\\n\");\n+      fprintf (optfile, \"case_sensitive=NO\\n\");\n+    }\n+\n+  if (debug && share && vmsdwarf2spec)\n+    {\n+      /* Sequentialize the shared library debug info.  */\n+\n+      fprintf (optfile, \"case_sensitive=yes\\n\");\n+      fprintf (optfile, \"symbol_vector=(-\\n\");\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_ABBREV/$dwarf2.debug_abbrev=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_ARANGES/$dwarf2.debug_aranges=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_FRAME/$dwarf2.debug_frame=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_INFO/$dwarf2.debug_info=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_LINE/$dwarf2.debug_line=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_LOC/$dwarf2.debug_loc=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_MACINFO/$dwarf2.debug_macinfo=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile,\n+\t       \"%s$DWARF2.DEBUG_PUBNAMES/$dwarf2.debug_pubnames=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_STR/$dwarf2.debug_str=DATA,-\\n\",\n+\t       sharebasename);\n+      fprintf (optfile, \"%s$DWARF2.DEBUG_ZZZZZZ/$dwarf2.debug_zzzzzz=DATA)\\n\",\n+\t       sharebasename);\n+      fprintf (optfile, \"case_sensitive=NO\\n\");\n+    }\n+\n+  fprintf (optfile, \"PSECT_ATTR=LIB$INITIALIZE,GBL\\n\");\n+  fclose (optfile);\n+\n+  /* Append opt file.  */\n+  addarg (\" \");\n+  addarg (optfilename);\n+  addarg (\"/opt\");\n+\n+  if (verbose)\n+    printf (\"%s\\n\", link_cmd);\n+\n+  status = system (link_cmd);\n+  if (verbose > 1)\n+    printf (\"$!status = %d\\n\", status);\n+\n+  if ((status & 1) != 1)\n+    {\n+      status = 1;\n+      goto cleanup_and_exit;\n+    }\n+\n+  if (debug && !share && ld_nocall_debug)\n+    {\n+      status = set_exe (\"/flags=nocall_debug\");\n+      if (status != 0)\n+        goto cleanup_and_exit;\n+    }\n+\n+  if (!share && ld_mkthreads)\n+    {\n+      status = set_exe (\"/flags=mkthreads\");\n+      if (status != 0)\n+        goto cleanup_and_exit;\n+    }\n+\n+  if (!share && ld_upcalls)\n+    {\n+      status = set_exe (\"/flags=upcalls\");\n+      if (status != 0)\n+        goto cleanup_and_exit;\n+    }\n+\n+  status = 0;\n+\n+ cleanup_and_exit:\n+  if (!save_temps)\n+    remove (optfilename);\n+\n+  if (status == 0)\n+    exit (EXIT_SUCCESS);\n+\n+  if (exefullfilename && inhibit_exec == 1)\n+    remove (exefullfilename);\n+\n+  exit (EXIT_FAILURE);\n+}"}]}