{"sha": "ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM1ZDAwODgxNDhkMWQ2MjE4ZjVmNTAzZDFjOGU2N2E1MjlkZmFjZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-06-30T20:39:50Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-06-30T20:39:50Z"}, "message": "jit: add switch statements\n\ngcc/ChangeLog:\n\t* typed-splay-tree.h: New file.\n\ngcc/jit/ChangeLog:\n\t* docs/cp/topics/functions.rst (Blocks): Add switch statements to\n\tlist of ways to terminate a block.\n\t(gccjit::block::end_with_switch): Add function description.\n\t(gccjit::case_): Add class.\n\t(gccjit::context::new_case): Add function description.\n\t* docs/cp/topics/objects.rst: Add \"case_\" to class hierarchy.\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_3): New.\n\t* docs/topics/functions.rst (Blocks): Add switch statements to\n\tlist of ways to terminate a block.\n\t(gcc_jit_block_end_with_switch): Add function description.\n\t(gcc_jit_case): Add type.\n\t(gcc_jit_context_new_case): Add function description.\n\t(gcc_jit_case_as_object): Add function description.\n\t* docs/topics/objects.rst: Add gcc_jit_case to class hierarchy.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\t* jit-common.h (gcc::jit::recording::case_): Add forward decl.\n\t(gcc::jit::playback::case_): Add forward decl.\n\t* jit-playback.c (add_case): New function.\n\t(gcc::jit::playback::block::add_switch): New function.\n\t* jit-playback.h (gcc::jit::playback::case_): New struct.\n\t(gcc::jit::playback::block::get_function): New method.\n\t(gcc::jit::playback::block::add_switch): New method.\n\t* jit-recording.c: Within namespace gcc::jit...\n\t(recording::context::new_case): New method.\n\t(recording::function::validate): Update for change to\n\tget_successor_blocks.\n\t(recording::block::end_with_switch): New method.\n\t(recording::block::get_successor_blocks): Update to support an\n\tarbitrary number of successor blocks.\n\t(recording::block::dump_edges_to_dot): Likewise.\n\t(memento_of_new_rvalue_from_const <int>::get_wide_int): New.\n\t(memento_of_new_rvalue_from_const <long>::get_wide_int): New.\n\t(memento_of_new_rvalue_from_const <double>::get_wide_int): New.\n\t(memento_of_new_rvalue_from_const <void *>::get_wide_int): New.\n\t(recording::statement::get_successor_blocks): Update to support an\n\tarbitrary number of successor blocks.\n\t(recording::conditional::get_successor_blocks): Likewise.\n\t(recording::jump::get_successor_blocks): Likewise.\n\t(recording::return_::get_successor_blocks): Likewise.\n\t(recording::case_::write_reproducer): New.\n\t(recording::case_::make_debug_string): New.\n\t(recording::switch_::switch_): New.\n\t(recording::switch_::replay_into): New.\n\t(recording::switch_::get_successor_blocks): New.\n\t(recording::switch_::make_debug_string): New.\n\t(recording::switch_::write_reproducer): New.\n\t* jit-recording.h: Within namespace gcc::jit::recording...\n\t(context::new_case): New.\n\t(rvalue::is_constant): New.\n\t(rvalue::get_wide_int): New.\n\t(block::end_with_switch): New.\n\t(block::get_successor_blocks): Update to support an arbitrary\n\tnumber of successor blocks.\n\t(memento_of_new_rvalue_from_const::is_constant): New.\n\t(memento_of_new_rvalue_from_const::get_wide_int): New.\n\t(statement::get_successor_blocks): Update to support an arbitrary\n\tnumber of successor blocks.\n\t(conditional::get_successor_blocks): Likewise.\n\t(jump::get_successor_blocks): Likewise.\n\t(return_::get_successor_blocks): Likewise.\n\t(case_): New subclass of memento.\n\t(switch_): New subclass of statement.\n\t* libgccjit++.h (gccjit::case_): New subclass of gccjit::object.\n\t(gccjit::context::new_case): New method.\n\t(gccjit::block::end_with_switch): New method.\n\t(gccjit::case_::case): New ctors.\n\t(gccjit::case_::get_inner_case): New method.\n\t* libgccjit.c: Include \"typed-splay-tree.h\"\n\t(struct gcc_jit_case): New.\n\t(gcc_jit_context_new_case): New function.\n\t(gcc_jit_case_as_object): New function.\n\t(valid_dest_for_switch): New function.\n\t(valid_case_for_switch): New function.\n\t(class api_call_validator): New class.\n\t(class case_range_validator): New class.\n\t(case_range_validator::case_range_validator): New.\n\t(case_range_validator::validate): New.\n\t(case_range_validator::case_compare): New.\n\t(case_range_validator::get_wide_int): new.\n\t(gcc_jit_block_end_with_switch): New.\n\t* libgccjit.h: Add gcc_jit_case to class hierarchy comment.\n\t(gcc_jit_case): New typedef.\n\t(gcc_jit_context_new_case): New function.\n\t(gcc_jit_case_as_object): New function.\n\t(gcc_jit_block_end_with_switch): New function.\n\t(LIBGCCJIT_HAVE_SWITCH_STATEMENTS): New.\n\t* libgccjit.map: Add gcc_jit_block_end_with_switch,\n\tgcc_jit_case_as_object and gcc_jit_context_new_case.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/all-non-failing-tests.h: Add test-switch.c.\n\t* jit.dg/test-error-gcc_jit_block_end_with_switch-NULL-case.c: New\n\ttestcase.\n\t* jit.dg/test-error-gcc_jit_block_end_with_switch-mismatching-case-type.c:\n\tNew testcase.\n\t* jit.dg/test-error-gcc_jit_block_end_with_switch-overlapping-ranges.c:\n\tNew testcase.\n\t* jit.dg/test-error-gcc_jit_context_new_case-non-const-label.c:\n\tNew testcase.\n\t* jit.dg/test-error-gcc_jit_context_new_case-non-integer-type.c:\n\tNew testcase.\n\t* jit.dg/test-error-gcc_jit_context_new_case-reversed-endpoints.c:\n\tNew testcase.\n\t* jit.dg/test-switch.c: New testcase.\n\t* jit.dg/test-switch.cc: New testcase.\n\nFrom-SVN: r225207", "tree": {"sha": "c7cf3f33890bd8579a8afa8a850a326bc0b1fd58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7cf3f33890bd8579a8afa8a850a326bc0b1fd58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a3603e356e14096e9554ceef57916fd03d9072b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a3603e356e14096e9554ceef57916fd03d9072b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a3603e356e14096e9554ceef57916fd03d9072b"}], "stats": {"total": 3204, "additions": 2867, "deletions": 337}, "files": [{"sha": "6772150d8c31b099eb69ad97ebbceef8df87d8c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -1,3 +1,7 @@\n+2015-06-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* typed-splay-tree.h: New file.\n+\n 2015-06-30  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR debug/66691"}, {"sha": "325f3b8883ffc7baeff784267c414a1b29393b0e", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -1,3 +1,94 @@\n+2015-06-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/cp/topics/functions.rst (Blocks): Add switch statements to\n+\tlist of ways to terminate a block.\n+\t(gccjit::block::end_with_switch): Add function description.\n+\t(gccjit::case_): Add class.\n+\t(gccjit::context::new_case): Add function description.\n+\t* docs/cp/topics/objects.rst: Add \"case_\" to class hierarchy.\n+\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_3): New.\n+\t* docs/topics/functions.rst (Blocks): Add switch statements to\n+\tlist of ways to terminate a block.\n+\t(gcc_jit_block_end_with_switch): Add function description.\n+\t(gcc_jit_case): Add type.\n+\t(gcc_jit_context_new_case): Add function description.\n+\t(gcc_jit_case_as_object): Add function description.\n+\t* docs/topics/objects.rst: Add gcc_jit_case to class hierarchy.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* jit-common.h (gcc::jit::recording::case_): Add forward decl.\n+\t(gcc::jit::playback::case_): Add forward decl.\n+\t* jit-playback.c (add_case): New function.\n+\t(gcc::jit::playback::block::add_switch): New function.\n+\t* jit-playback.h (gcc::jit::playback::case_): New struct.\n+\t(gcc::jit::playback::block::get_function): New method.\n+\t(gcc::jit::playback::block::add_switch): New method.\n+\t* jit-recording.c: Within namespace gcc::jit...\n+\t(recording::context::new_case): New method.\n+\t(recording::function::validate): Update for change to\n+\tget_successor_blocks.\n+\t(recording::block::end_with_switch): New method.\n+\t(recording::block::get_successor_blocks): Update to support an\n+\tarbitrary number of successor blocks.\n+\t(recording::block::dump_edges_to_dot): Likewise.\n+\t(memento_of_new_rvalue_from_const <int>::get_wide_int): New.\n+\t(memento_of_new_rvalue_from_const <long>::get_wide_int): New.\n+\t(memento_of_new_rvalue_from_const <double>::get_wide_int): New.\n+\t(memento_of_new_rvalue_from_const <void *>::get_wide_int): New.\n+\t(recording::statement::get_successor_blocks): Update to support an\n+\tarbitrary number of successor blocks.\n+\t(recording::conditional::get_successor_blocks): Likewise.\n+\t(recording::jump::get_successor_blocks): Likewise.\n+\t(recording::return_::get_successor_blocks): Likewise.\n+\t(recording::case_::write_reproducer): New.\n+\t(recording::case_::make_debug_string): New.\n+\t(recording::switch_::switch_): New.\n+\t(recording::switch_::replay_into): New.\n+\t(recording::switch_::get_successor_blocks): New.\n+\t(recording::switch_::make_debug_string): New.\n+\t(recording::switch_::write_reproducer): New.\n+\t* jit-recording.h: Within namespace gcc::jit::recording...\n+\t(context::new_case): New.\n+\t(rvalue::is_constant): New.\n+\t(rvalue::get_wide_int): New.\n+\t(block::end_with_switch): New.\n+\t(block::get_successor_blocks): Update to support an arbitrary\n+\tnumber of successor blocks.\n+\t(memento_of_new_rvalue_from_const::is_constant): New.\n+\t(memento_of_new_rvalue_from_const::get_wide_int): New.\n+\t(statement::get_successor_blocks): Update to support an arbitrary\n+\tnumber of successor blocks.\n+\t(conditional::get_successor_blocks): Likewise.\n+\t(jump::get_successor_blocks): Likewise.\n+\t(return_::get_successor_blocks): Likewise.\n+\t(case_): New subclass of memento.\n+\t(switch_): New subclass of statement.\n+\t* libgccjit++.h (gccjit::case_): New subclass of gccjit::object.\n+\t(gccjit::context::new_case): New method.\n+\t(gccjit::block::end_with_switch): New method.\n+\t(gccjit::case_::case): New ctors.\n+\t(gccjit::case_::get_inner_case): New method.\n+\t* libgccjit.c: Include \"typed-splay-tree.h\"\n+\t(struct gcc_jit_case): New.\n+\t(gcc_jit_context_new_case): New function.\n+\t(gcc_jit_case_as_object): New function.\n+\t(valid_dest_for_switch): New function.\n+\t(valid_case_for_switch): New function.\n+\t(class api_call_validator): New class.\n+\t(class case_range_validator): New class.\n+\t(case_range_validator::case_range_validator): New.\n+\t(case_range_validator::validate): New.\n+\t(case_range_validator::case_compare): New.\n+\t(case_range_validator::get_wide_int): new.\n+\t(gcc_jit_block_end_with_switch): New.\n+\t* libgccjit.h: Add gcc_jit_case to class hierarchy comment.\n+\t(gcc_jit_case): New typedef.\n+\t(gcc_jit_context_new_case): New function.\n+\t(gcc_jit_case_as_object): New function.\n+\t(gcc_jit_block_end_with_switch): New function.\n+\t(LIBGCCJIT_HAVE_SWITCH_STATEMENTS): New.\n+\t* libgccjit.map: Add gcc_jit_block_end_with_switch,\n+\tgcc_jit_case_as_object and gcc_jit_context_new_case.\n+\n 2015-06-30  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/66546"}, {"sha": "212df10ff05a547e561009f73977d95b9df3a605", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 687, "deletions": 275, "changes": 962, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd"}, {"sha": "57b6298bc8376cb17c0403ac535db2f6a0ff4297", "filename": "gcc/jit/docs/cp/topics/functions.rst", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -98,7 +98,8 @@ Blocks\n    be the entrypoint.\n \n    Each basic block that you create within a function must be\n-   terminated, either with a conditional, a jump, or a return.\n+   terminated, either with a conditional, a jump, a return, or\n+   a switch.\n \n    It's legal to have multiple basic blocks that return within\n    one function.\n@@ -241,3 +242,82 @@ Statements\n    .. code-block:: c\n \n       return;\n+\n+.. function:: void\\\n+              gccjit::block::end_with_switch (gccjit::rvalue expr,\\\n+                                              gccjit::block default_block,\\\n+                                              std::vector <gccjit::case_> cases,\\\n+                                              gccjit::location loc)\n+\n+   Terminate a block by adding evalation of an rvalue, then performing\n+   a multiway branch.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     switch (expr)\n+       {\n+       default:\n+         goto default_block;\n+\n+       case C0.min_value ... C0.max_value:\n+         goto C0.dest_block;\n+\n+       case C1.min_value ... C1.max_value:\n+         goto C1.dest_block;\n+\n+       ...etc...\n+\n+       case C[N - 1].min_value ... C[N - 1].max_value:\n+         goto C[N - 1].dest_block;\n+     }\n+\n+   ``expr`` must be of the same integer type as all of the ``min_value``\n+   and ``max_value`` within the cases.\n+\n+   The ranges of the cases must not overlap (or have duplicate\n+   values).\n+\n+   The API entrypoints relating to switch statements and cases:\n+\n+      * :func:`gccjit::block::end_with_switch`\n+\n+      * :func:`gccjit::context::new_case`\n+\n+   were added in :ref:`LIBGCCJIT_ABI_3`; you can test for their presence\n+   using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n+\n+   .. class:: gccjit::case_\n+\n+   A `gccjit::case_` represents a case within a switch statement, and\n+   is created within a particular :class:`gccjit::context` using\n+   :func:`gccjit::context::new_case`.  It is a subclass of\n+   :class:`gccjit::object`.\n+\n+   Each case expresses a multivalued range of integer values.  You\n+   can express single-valued cases by passing in the same value for\n+   both `min_value` and `max_value`.\n+\n+   .. function:: gccjit::case_ *\\\n+                 gccjit::context::new_case (gccjit::rvalue min_value,\\\n+                                            gccjit::rvalue max_value,\\\n+                                            gccjit::block dest_block)\n+\n+      Create a new gccjit::case for use in a switch statement.\n+      `min_value` and `max_value` must be constants of an integer type,\n+      which must match that of the expression of the switch statement.\n+\n+      `dest_block` must be within the same function as the switch\n+      statement.\n+\n+   Here's an example of creating a switch statement:\n+\n+     .. literalinclude:: ../../../../testsuite/jit.dg/test-switch.cc\n+       :start-after: /* Quote from here in docs/cp/topics/functions.rst.  */\n+       :end-before: /* Quote up to here in docs/cp/topics/functions.rst.  */\n+       :language: c++"}, {"sha": "8d99bd40df8228ddbd4cb011d62ff571540fdfb7", "filename": "gcc/jit/docs/cp/topics/objects.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -46,6 +46,7 @@ The C++ class hierarchy within the ``gccjit`` namespace looks like this::\n       +- rvalue\n           +- lvalue\n              +- param\n+      +- case_\n \n The :class:`gccjit::object` base class has the following operations:\n "}, {"sha": "37e28665e709bc0d2d843d85210cd1aa9b2fe6d9", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -47,7 +47,6 @@ from metadata by using ``objdump``:\n        0x00824161 0x00 04 LIBGCCJIT_ABI_1\n        0x00824160 0x00 03 LIBGCCJIT_ABI_0\n      required from libc.so.6:\n-       0x09691a75 0x00 02 GLIBC_2.2.5\n \n You can see the symbol tags provided by libgccjit.so using ``objdump``:\n \n@@ -95,3 +94,16 @@ continue to work, with this being handled transparently by the linker\n -------------------\n ``LIBGCCJIT_ABI_2`` covers the addition of\n :func:`gcc_jit_context_set_bool_allow_unreachable_blocks`\n+\n+.. _LIBGCCJIT_ABI_3:\n+\n+``LIBGCCJIT_ABI_3``\n+-------------------\n+``LIBGCCJIT_ABI_3`` covers the addition of switch statements via API\n+entrypoints:\n+\n+  * :func:`gcc_jit_block_end_with_switch`\n+\n+  * :func:`gcc_jit_case_as_object`\n+\n+  * :func:`gcc_jit_context_new_case`"}, {"sha": "94db471615c75b23fe9b879d9cb10e780f287cbe", "filename": "gcc/jit/docs/topics/functions.rst", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -153,7 +153,8 @@ Blocks\n    be the entrypoint.\n \n    Each basic block that you create within a function must be\n-   terminated, either with a conditional, a jump, or a return.\n+   terminated, either with a conditional, a jump, a return, or a\n+   switch.\n \n    It's legal to have multiple basic blocks that return within\n    one function.\n@@ -313,3 +314,96 @@ Statements\n    .. code-block:: c\n \n       return;\n+\n+.. function:: void\\\n+              gcc_jit_block_end_with_switch (gcc_jit_block *block,\\\n+                                             gcc_jit_location *loc,\\\n+                                             gcc_jit_rvalue *expr,\\\n+                                             gcc_jit_block *default_block,\\\n+                                             int num_cases,\\\n+                                             gcc_jit_case **cases)\n+\n+   Terminate a block by adding evalation of an rvalue, then performing\n+   a multiway branch.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     switch (expr)\n+       {\n+       default:\n+         goto default_block;\n+\n+       case C0.min_value ... C0.max_value:\n+         goto C0.dest_block;\n+\n+       case C1.min_value ... C1.max_value:\n+         goto C1.dest_block;\n+\n+       ...etc...\n+\n+       case C[N - 1].min_value ... C[N - 1].max_value:\n+         goto C[N - 1].dest_block;\n+     }\n+\n+   ``block``, ``expr``, ``default_block`` and ``cases`` must all be\n+   non-NULL.\n+\n+   ``expr`` must be of the same integer type as all of the ``min_value``\n+   and ``max_value`` within the cases.\n+\n+   ``num_cases`` must be >= 0.\n+\n+   The ranges of the cases must not overlap (or have duplicate\n+   values).\n+\n+   The API entrypoints relating to switch statements and cases:\n+\n+      * :c:func:`gcc_jit_block_end_with_switch`\n+\n+      * :c:func:`gcc_jit_case_as_object`\n+\n+      * :c:func:`gcc_jit_context_new_case`\n+\n+   were added in :ref:`LIBGCCJIT_ABI_3`; you can test for their presence\n+   using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n+\n+   .. type:: gcc_jit_case\n+\n+   A `gcc_jit_case` represents a case within a switch statement, and\n+   is created within a particular :c:type:`gcc_jit_context` using\n+   :c:func:`gcc_jit_context_new_case`.\n+\n+   Each case expresses a multivalued range of integer values.  You\n+   can express single-valued cases by passing in the same value for\n+   both `min_value` and `max_value`.\n+\n+   .. function:: gcc_jit_case *\\\n+                 gcc_jit_context_new_case (gcc_jit_context *ctxt,\\\n+                                           gcc_jit_rvalue *min_value,\\\n+                                           gcc_jit_rvalue *max_value,\\\n+                                           gcc_jit_block *dest_block)\n+\n+      Create a new gcc_jit_case instance for use in a switch statement.\n+      `min_value` and `max_value` must be constants of an integer type,\n+      which must match that of the expression of the switch statement.\n+\n+      `dest_block` must be within the same function as the switch\n+      statement.\n+\n+   .. function:: gcc_jit_object *\\\n+                 gcc_jit_case_as_object (gcc_jit_case *case_)\n+\n+      Upcast from a case to an object.\n+\n+   Here's an example of creating a switch statement:\n+\n+     .. literalinclude:: ../../../testsuite/jit.dg/test-switch.c\n+       :start-after: /* Quote from here in docs/topics/functions.rst.  */\n+       :end-before: /* Quote up to here in docs/topics/functions.rst.  */\n+       :language: c"}, {"sha": "85c783ca2bbeda19b6849e7fd808b3f6ed0e736d", "filename": "gcc/jit/docs/topics/objects.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fobjects.rst?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -47,6 +47,7 @@ looks like this::\n       +- gcc_jit_rvalue\n           +- gcc_jit_lvalue\n              +- gcc_jit_param\n+      +- gcc_jit_case\n \n There are casting methods for upcasting from subclasses to parent classes.\n For example, :c:func:`gcc_jit_type_as_object`:"}, {"sha": "3397215bc9136b46a64032f7b0161841e63a68d0", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -129,6 +129,7 @@ namespace recording {\n \tclass global;\n         class param;\n     class statement;\n+    class case_;\n \n   /* End of recording types. */\n }\n@@ -150,6 +151,7 @@ namespace playback {\n     class source_file;\n     class source_line;\n     class location;\n+    class case_;\n \n   /* End of playback types. */\n }"}, {"sha": "c9d7c8c607adf91805fd1c90481874d217169fa1", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -1576,6 +1576,80 @@ add_return (location *loc,\n   add_stmt (return_stmt);\n }\n \n+/* Helper function for playback::block::add_switch.\n+   Construct a case label for the given range, followed by a goto stmt\n+   to the given block, appending them to stmt list *ptr_t_switch_body.  */\n+\n+static void\n+add_case (tree *ptr_t_switch_body,\n+\t  tree t_low_value,\n+\t  tree t_high_value,\n+\t  playback::block *dest_block)\n+{\n+  tree t_label = create_artificial_label (UNKNOWN_LOCATION);\n+  DECL_CONTEXT (t_label) = dest_block->get_function ()->as_fndecl ();\n+\n+  tree t_case_label =\n+    build_case_label (t_low_value, t_high_value, t_label);\n+  append_to_statement_list (t_case_label, ptr_t_switch_body);\n+\n+  tree t_goto_stmt =\n+    build1 (GOTO_EXPR, void_type_node, dest_block->as_label_decl ());\n+  append_to_statement_list (t_goto_stmt, ptr_t_switch_body);\n+}\n+\n+/* Add a switch statement to the function's statement list.\n+\n+   My initial attempt at implementing this constructed a TREE_VEC\n+   of the cases and set it as SWITCH_LABELS (switch_expr).  However,\n+   gimplify.c:gimplify_switch_expr is set up to deal with SWITCH_BODY, and\n+   doesn't have any logic for gimplifying SWITCH_LABELS.\n+\n+   Hence we create a switch body, and populate it with case labels, each\n+   followed by a goto to the desired block.  */\n+\n+void\n+playback::block::\n+add_switch (location *loc,\n+\t    rvalue *expr,\n+\t    block *default_block,\n+\t    const auto_vec <case_> *cases)\n+{\n+  /* Compare with:\n+     - c/c-typeck.c: c_start_case\n+     - c-family/c-common.c:c_add_case_label\n+     - java/expr.c:expand_java_switch and expand_java_add_case\n+     We've already rejected overlaps and duplicates in\n+     libgccjit.c:case_range_validator::validate.  */\n+\n+  tree t_expr = expr->as_tree ();\n+  tree t_type = TREE_TYPE (t_expr);\n+\n+  tree t_switch_body = alloc_stmt_list ();\n+\n+  int i;\n+  case_ *c;\n+  FOR_EACH_VEC_ELT (*cases, i, c)\n+    {\n+      tree t_low_value = c->m_min_value->as_tree ();\n+      tree t_high_value = c->m_max_value->as_tree ();\n+      add_case (&t_switch_body,\n+\t\tt_low_value,\n+\t\tt_high_value,\n+\t\tc->m_dest_block);\n+    }\n+  /* Default label. */\n+  add_case (&t_switch_body,\n+\t    NULL_TREE, NULL_TREE,\n+\t    default_block);\n+\n+  tree switch_stmt = build3 (SWITCH_EXPR, t_type, t_expr,\n+\t\t\t     t_switch_body, NULL_TREE);\n+  if (loc)\n+    set_tree_location (switch_stmt, loc);\n+  add_stmt (switch_stmt);\n+}\n+\n /* Constructor for gcc::jit::playback::block.  */\n \n playback::block::"}, {"sha": "13cc748135f26a7f2fe8535e0de439becba4b5dc", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -437,6 +437,19 @@ class function : public wrapper\n   vec<block *> m_blocks;\n };\n \n+struct case_\n+{\n+  case_ (rvalue *min_value, rvalue *max_value, block *dest_block)\n+  : m_min_value (min_value),\n+    m_max_value (max_value),\n+    m_dest_block (dest_block)\n+  {}\n+\n+  rvalue *m_min_value;\n+  rvalue *m_max_value;\n+  block *m_dest_block;\n+};\n+\n class block : public wrapper\n {\n public:\n@@ -447,6 +460,8 @@ class block : public wrapper\n \n   tree as_label_decl () const { return m_label_decl; }\n \n+  function *get_function () const { return m_func; }\n+\n   void\n   add_eval (location *loc,\n \t    rvalue *rvalue);\n@@ -478,6 +493,12 @@ class block : public wrapper\n   add_return (location *loc,\n \t      rvalue *rvalue);\n \n+  void\n+  add_switch (location *loc,\n+\t      rvalue *expr,\n+\t      block *default_block,\n+\t      const auto_vec <case_> *cases);\n+\n private:\n   void\n   set_tree_location (tree t, location *loc)"}, {"sha": "a653205040ebbb9d6ef50793b45c46192d01ce0b", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 272, "deletions": 50, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -1084,6 +1084,22 @@ recording::context::new_array_access (recording::location *loc,\n   return result;\n }\n \n+/* Create a recording::case_ instance and add it to this context's list\n+   of mementos.\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_context_new_case.  */\n+\n+recording::case_ *\n+recording::context::new_case (recording::rvalue *min_value,\n+\t\t\t      recording::rvalue *max_value,\n+\t\t\t      recording::block *block)\n+{\n+  recording::case_ *result = new case_ (this, min_value, max_value, block);\n+  record (result);\n+  return result;\n+}\n+\n /* Set the given string option for this context, or add an error if\n    it's not recognized.\n \n@@ -3505,23 +3521,13 @@ recording::function::validate ()\n \n \t  /* Add successor blocks that aren't yet marked to the worklist.  */\n \t  /* We checked that each block has a terminating statement above .  */\n-\t  block *next1, *next2;\n-\t  int n = b->get_successor_blocks (&next1, &next2);\n-\t  switch (n)\n-\t    {\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    case 2:\n-\t      if (!next2->m_is_reachable)\n-\t\tworklist.safe_push (next2);\n-\t      /* fallthrough */\n-\t    case 1:\n-\t      if (!next1->m_is_reachable)\n-\t\tworklist.safe_push (next1);\n-\t      break;\n-\t    case 0:\n-\t      break;\n-\t    }\n+\t  vec <block *> successors = b->get_successor_blocks ();\n+\t  int i;\n+\t  block *succ;\n+\t  FOR_EACH_VEC_ELT (successors, i, succ)\n+\t    if (!succ->m_is_reachable)\n+\t      worklist.safe_push (succ);\n+\t  successors.release ();\n \t}\n \n       /* Now complain about any blocks that haven't been marked.  */\n@@ -3769,6 +3775,30 @@ recording::block::end_with_return (recording::location *loc,\n   return result;\n }\n \n+/* Create a recording::switch_ instance and add it to\n+   the block's context's list of mementos, and to the block's\n+   list of statements.\n+\n+   Implements the heart of gcc_jit_block_end_with_switch.  */\n+\n+recording::statement *\n+recording::block::end_with_switch (recording::location *loc,\n+\t\t\t\t   recording::rvalue *expr,\n+\t\t\t\t   recording::block *default_block,\n+\t\t\t\t   int num_cases,\n+\t\t\t\t   recording::case_ **cases)\n+{\n+  statement *result = new switch_ (this, loc,\n+\t\t\t\t   expr,\n+\t\t\t\t   default_block,\n+\t\t\t\t   num_cases,\n+\t\t\t\t   cases);\n+  m_ctxt->record (result);\n+  m_statements.safe_push (result);\n+  m_has_been_terminated = true;\n+  return result;\n+}\n+\n /* Override the default implementation of\n    recording::memento::write_to_dump for blocks by writing\n    an unindented block name as a label, followed by the indented\n@@ -3846,24 +3876,20 @@ recording::block::get_last_statement () const\n     return NULL;\n }\n \n-/* Assuming that this block has been terminated, get the number of\n-   successor blocks, which will be 0, 1 or 2, for return, unconditional\n-   jump, and conditional jump respectively.\n-   NEXT1 and NEXT2 must be non-NULL.  The first successor block (if any)\n-   is written to NEXT1, and the second (if any) to NEXT2.\n+/* Assuming that this block has been terminated, get the successor blocks\n+   as a vector.  Ownership of the vector transfers to the caller, which\n+   must call its release () method.\n \n    Used when validating functions, and when dumping dot representations\n    of them.  */\n \n-int\n-recording::block::get_successor_blocks (block **next1, block **next2) const\n+vec <recording::block *>\n+recording::block::get_successor_blocks () const\n {\n   gcc_assert (m_has_been_terminated);\n-  gcc_assert (next1);\n-  gcc_assert (next2);\n   statement *last_statement = get_last_statement ();\n   gcc_assert (last_statement);\n-  return last_statement->get_successor_blocks (next1, next2);\n+  return last_statement->get_successor_blocks ();\n }\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -3941,12 +3967,14 @@ recording::block::dump_to_dot (pretty_printer *pp)\n void\n recording::block::dump_edges_to_dot (pretty_printer *pp)\n {\n-  block *next[2];\n-  int num_succs = get_successor_blocks (&next[0], &next[1]);\n-  for (int i = 0; i < num_succs; i++)\n+  vec <block *> successors = get_successor_blocks ();\n+  int i;\n+  block *succ;\n+  FOR_EACH_VEC_ELT (successors, i, succ)\n     pp_printf (pp,\n \t       \"\\tblock_%d:s -> block_%d:n;\\n\",\n-\t       m_index, next[i]->m_index);\n+\t       m_index, succ->m_index);\n+  successors.release ();\n }\n \n /* The implementation of class gcc::jit::recording::global.  */\n@@ -4091,6 +4119,16 @@ memento_of_new_rvalue_from_const <int>::make_debug_string ()\n \t\t\t      m_value);\n }\n \n+/* The get_wide_int specialization for <int>.  */\n+\n+template <>\n+bool\n+memento_of_new_rvalue_from_const <int>::get_wide_int (wide_int *out) const\n+{\n+  *out = wi::shwi (m_value, sizeof (m_value) * 8);\n+  return true;\n+}\n+\n /* The write_reproducer specialization for <int>.  */\n \n template <>\n@@ -4123,6 +4161,16 @@ memento_of_new_rvalue_from_const <long>::make_debug_string ()\n \t\t\t      m_value);\n }\n \n+/* The get_wide_int specialization for <long>.  */\n+\n+template <>\n+bool\n+memento_of_new_rvalue_from_const <long>::get_wide_int (wide_int *out) const\n+{\n+  *out = wi::shwi (m_value, sizeof (m_value) * 8);\n+  return true;\n+}\n+\n /* The write_reproducer specialization for <long>.  */\n \n template <>\n@@ -4176,6 +4224,15 @@ memento_of_new_rvalue_from_const <double>::make_debug_string ()\n \t\t\t      m_value);\n }\n \n+/* The get_wide_int specialization for <double>.  */\n+\n+template <>\n+bool\n+memento_of_new_rvalue_from_const <double>::get_wide_int (wide_int *) const\n+{\n+  return false;\n+}\n+\n /* The write_reproducer specialization for <double>.  */\n \n template <>\n@@ -4215,6 +4272,15 @@ memento_of_new_rvalue_from_const <void *>::make_debug_string ()\n \t\t\t\tm_type->get_debug_string ());\n }\n \n+/* The get_wide_int specialization for <void *>.  */\n+\n+template <>\n+bool\n+memento_of_new_rvalue_from_const <void *>::get_wide_int (wide_int *) const\n+{\n+  return false;\n+}\n+\n /* Implementation of recording::memento::write_reproducer for <void *>\n    values. */\n \n@@ -5213,14 +5279,15 @@ recording::local::write_reproducer (reproducer &r)\n    since this vfunc must only ever be called on terminator\n    statements.  */\n \n-int\n-recording::statement::get_successor_blocks (block **/*out_next1*/,\n-\t\t\t\t\t    block **/*out_next2*/) const\n+vec <recording::block *>\n+recording::statement::get_successor_blocks () const\n {\n   /* The base class implementation is for non-terminating statements,\n      and thus should never be called.  */\n   gcc_unreachable ();\n-  return 0;\n+  vec <block *> result;\n+  result.create (0);\n+  return result;\n }\n \n /* Extend the default implementation of\n@@ -5429,13 +5496,14 @@ recording::conditional::replay_into (replayer *r)\n \n    A conditional jump has 2 successor blocks.  */\n \n-int\n-recording::conditional::get_successor_blocks (block **out_next1,\n-\t\t\t\t\t      block **out_next2) const\n+vec <recording::block *>\n+recording::conditional::get_successor_blocks () const\n {\n-  *out_next1 = m_on_true;\n-  *out_next2 = m_on_false;\n-  return 2;\n+  vec <block *> result;\n+  result.create (2);\n+  result.quick_push (m_on_true);\n+  result.quick_push (m_on_false);\n+  return result;\n }\n \n /* Implementation of recording::memento::make_debug_string for\n@@ -5493,12 +5561,13 @@ recording::jump::replay_into (replayer *r)\n \n    An unconditional jump has 1 successor block.  */\n \n-int\n-recording::jump::get_successor_blocks (block **out_next1,\n-\t\t\t\t       block **/*out_next2*/) const\n+vec <recording::block *>\n+recording::jump::get_successor_blocks () const\n {\n-  *out_next1 = m_target;\n-  return 1;\n+  vec <block *> result;\n+  result.create (1);\n+  result.quick_push (m_target);\n+  return result;\n }\n \n /* Implementation of recording::memento::make_debug_string for\n@@ -5544,11 +5613,12 @@ recording::return_::replay_into (replayer *r)\n \n    A return statement has no successor block.  */\n \n-int\n-recording::return_::get_successor_blocks (block **/*out_next1*/,\n-\t\t\t\t\t  block **/*out_next2*/) const\n+vec <recording::block *>\n+recording::return_::get_successor_blocks () const\n {\n-  return 0;\n+  vec <block *> result;\n+  result.create (0);\n+  return result;\n }\n \n /* Implementation of recording::memento::make_debug_string for\n@@ -5586,6 +5656,158 @@ recording::return_::write_reproducer (reproducer &r)\n \t     r.get_identifier (get_loc ()));\n }\n \n+/* The implementation of class gcc::jit::recording::case_.  */\n+\n+void\n+recording::case_::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"case\");\n+  const char *fmt =\n+    \"  gcc_jit_case *%s = \\n\"\n+    \"    gcc_jit_context_new_case (%s, /*gcc_jit_context *ctxt */\\n\"\n+    \"                              %s, /* gcc_jit_rvalue *min_value */\\n\"\n+    \"                              %s, /* gcc_jit_rvalue *max_value */\\n\"\n+    \"                              %s); /* gcc_jit_block *dest_block */\\n\";\n+  r.write (fmt,\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier_as_rvalue (m_min_value),\n+\t   r.get_identifier_as_rvalue (m_max_value),\n+\t   r.get_identifier (m_dest_block));\n+}\n+\n+recording::string *\n+recording::case_::make_debug_string ()\n+{\n+  return string::from_printf (get_context (),\n+\t\t\t      \"case %s ... %s: goto %s;\",\n+\t\t\t      m_min_value->get_debug_string (),\n+\t\t\t      m_max_value->get_debug_string (),\n+\t\t\t      m_dest_block->get_debug_string ());\n+}\n+\n+/* The implementation of class gcc::jit::recording::switch_.  */\n+\n+/* gcc::jit::recording::switch_'s constructor.  */\n+\n+recording::switch_::switch_ (block *b,\n+\t\t\t     location *loc,\n+\t\t\t     rvalue *expr,\n+\t\t\t     block *default_block,\n+\t\t\t     int num_cases,\n+\t\t\t     case_ **cases)\n+: statement (b, loc),\n+  m_expr (expr),\n+  m_default_block (default_block)\n+{\n+  m_cases.reserve_exact (num_cases);\n+  for (int i = 0; i< num_cases; i++)\n+    m_cases.quick_push (cases[i]);\n+}\n+\n+/* Implementation of pure virtual hook recording::memento::replay_into\n+   for recording::switch_.  */\n+\n+void\n+recording::switch_::replay_into (replayer *r)\n+{\n+  auto_vec <playback::case_> pcases;\n+  int i;\n+  recording::case_ *rcase;\n+  pcases.reserve_exact (m_cases.length ());\n+  FOR_EACH_VEC_ELT (m_cases, i, rcase)\n+    {\n+      playback::case_ pcase (rcase->get_min_value ()->playback_rvalue (),\n+\t\t\t     rcase->get_max_value ()->playback_rvalue (),\n+\t\t\t     rcase->get_dest_block ()->playback_block ());\n+      pcases.safe_push (pcase);\n+    }\n+  playback_block (get_block ())\n+    ->add_switch (playback_location (r),\n+\t\t  m_expr->playback_rvalue (),\n+\t\t  m_default_block->playback_block (),\n+\t\t  &pcases);\n+}\n+\n+/* Override the poisoned default implementation of\n+   gcc::jit::recording::statement::get_successor_blocks\n+\n+   A switch statement has (NUM_CASES + 1) successor blocks.  */\n+\n+vec <recording::block *>\n+recording::switch_::get_successor_blocks () const\n+{\n+  vec <block *> result;\n+  result.create (m_cases.length () + 1);\n+  result.quick_push (m_default_block);\n+  int i;\n+  case_ *c;\n+  FOR_EACH_VEC_ELT (m_cases, i, c)\n+    result.quick_push (c->get_dest_block ());\n+  return result;\n+}\n+\n+/* Implementation of recording::memento::make_debug_string for\n+   a switch statement.  */\n+\n+recording::string *\n+recording::switch_::make_debug_string ()\n+{\n+  auto_vec <char> cases_str;\n+  int i;\n+  case_ *c;\n+  FOR_EACH_VEC_ELT (m_cases, i, c)\n+    {\n+      size_t len = strlen (c->get_debug_string ());\n+      unsigned idx = cases_str.length ();\n+      cases_str.safe_grow (idx + 1 + len);\n+      cases_str[idx] = ' ';\n+      memcpy (&(cases_str[idx + 1]),\n+\t      c->get_debug_string (),\n+\t      len);\n+    }\n+  cases_str.safe_push ('\\0');\n+\n+  return string::from_printf (m_ctxt,\n+\t\t\t      \"switch (%s) {default: goto %s;%s}\",\n+\t\t\t      m_expr->get_debug_string (),\n+\t\t\t      m_default_block->get_debug_string (),\n+\t\t\t      &cases_str[0]);\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for\n+   switch statements.  */\n+\n+void\n+recording::switch_::write_reproducer (reproducer &r)\n+{\n+  r.make_identifier (this, \"switch\");\n+  int i;\n+  case_ *c;\n+  const char *cases_id =\n+    r.make_tmp_identifier (\"cases_for\", this);\n+  r.write (\"  gcc_jit_case *%s[%i] = {\\n\",\n+\t   cases_id,\n+\t   m_cases.length ());\n+  FOR_EACH_VEC_ELT (m_cases, i, c)\n+    r.write (\"    %s,\\n\", r.get_identifier (c));\n+  r.write (\"  };\\n\");\n+  const char *fmt =\n+    \"  gcc_jit_block_end_with_switch (%s, /*gcc_jit_block *block */\\n\"\n+    \"                                 %s, /* gcc_jit_location *loc */\\n\"\n+    \"                                 %s, /* gcc_jit_rvalue *expr */\\n\"\n+    \"                                 %s, /* gcc_jit_block *default_block */\\n\"\n+    \"                                 %i, /* int num_cases */\\n\"\n+    \"                                 %s); /* gcc_jit_case **cases */\\n\";\n+    r.write (fmt,\n+\t     r.get_identifier (get_block ()),\n+\t     r.get_identifier (get_loc ()),\n+\t     r.get_identifier_as_rvalue (m_expr),\n+\t     r.get_identifier (m_default_block),\n+\t     m_cases.length (),\n+\t     cases_id);\n+}\n+\n } // namespace gcc::jit\n \n } // namespace gcc"}, {"sha": "acd69e9b78c29fa49021ca2f267569cde18a185a", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -183,6 +183,11 @@ class context : public log_user\n \t\t    rvalue *ptr,\n \t\t    rvalue *index);\n \n+  case_ *\n+  new_case (rvalue *min_value,\n+\t    rvalue *max_value,\n+\t    block *block);\n+\n   void\n   set_str_option (enum gcc_jit_str_option opt,\n \t\t  const char *value);\n@@ -954,6 +959,9 @@ class rvalue : public memento\n   const char *\n   get_debug_string_parens (enum precedence outer_prec);\n \n+  virtual bool is_constant () const { return false; }\n+  virtual bool get_wide_int (wide_int *) const { return false; }\n+\n private:\n   virtual enum precedence get_precedence () const = 0;\n \n@@ -1152,6 +1160,13 @@ class block : public memento\n   end_with_return (location *loc,\n \t\t   rvalue *rvalue);\n \n+  statement *\n+  end_with_switch (location *loc,\n+\t\t   rvalue *expr,\n+\t\t   block *default_block,\n+\t\t   int num_cases,\n+\t\t   case_ **cases);\n+\n   playback::block *\n   playback_block () const\n   {\n@@ -1167,7 +1182,7 @@ class block : public memento\n   statement *get_first_statement () const;\n   statement *get_last_statement () const;\n \n-  int get_successor_blocks (block **next1, block **next2) const;\n+  vec <block *> get_successor_blocks () const;\n \n private:\n   string * make_debug_string ();\n@@ -1233,6 +1248,10 @@ class memento_of_new_rvalue_from_const : public rvalue\n \n   void visit_children (rvalue_visitor *) {}\n \n+  bool is_constant () const { return true; }\n+\n+  bool get_wide_int (wide_int *out) const;\n+\n private:\n   string * make_debug_string ();\n   void write_reproducer (reproducer &r);\n@@ -1596,8 +1615,7 @@ class local : public lvalue\n class statement : public memento\n {\n public:\n-  virtual int get_successor_blocks (block **out_next1,\n-\t\t\t\t    block **out_next2) const;\n+  virtual vec <block *> get_successor_blocks () const;\n \n   void write_to_dump (dump &d);\n \n@@ -1721,8 +1739,7 @@ class conditional : public statement\n \n   void replay_into (replayer *r);\n \n-  int get_successor_blocks (block **out_next1,\n-\t\t\t    block **out_next2) const;\n+  vec <block *> get_successor_blocks () const;\n \n private:\n   string * make_debug_string ();\n@@ -1745,8 +1762,7 @@ class jump : public statement\n \n   void replay_into (replayer *r);\n \n-  int get_successor_blocks (block **out_next1,\n-\t\t\t    block **out_next2) const;\n+  vec <block *> get_successor_blocks () const;\n \n private:\n   string * make_debug_string ();\n@@ -1767,8 +1783,7 @@ class return_ : public statement\n \n   void replay_into (replayer *r);\n \n-  int get_successor_blocks (block **out_next1,\n-\t\t\t    block **out_next2) const;\n+  vec <block *> get_successor_blocks () const;\n \n private:\n   string * make_debug_string ();\n@@ -1778,6 +1793,60 @@ class return_ : public statement\n   rvalue *m_rvalue;\n };\n \n+class case_ : public memento\n+{\n+ public:\n+  case_ (context *ctxt,\n+\t rvalue *min_value,\n+\t rvalue *max_value,\n+\t block *dest_block)\n+  : memento (ctxt),\n+    m_min_value (min_value),\n+    m_max_value (max_value),\n+    m_dest_block (dest_block)\n+  {}\n+\n+  rvalue *get_min_value () const { return m_min_value; }\n+  rvalue *get_max_value () const { return m_max_value; }\n+  block *get_dest_block () const { return m_dest_block; }\n+\n+  void replay_into (replayer *) { /* empty */ }\n+\n+  void write_reproducer (reproducer &r);\n+\n+private:\n+  string * make_debug_string ();\n+\n+ private:\n+  rvalue *m_min_value;\n+  rvalue *m_max_value;\n+  block *m_dest_block;\n+};\n+\n+class switch_ : public statement\n+{\n+public:\n+  switch_ (block *b,\n+\t   location *loc,\n+\t   rvalue *expr,\n+\t   block *default_block,\n+\t   int num_cases,\n+\t   case_ **cases);\n+\n+  void replay_into (replayer *r);\n+\n+  vec <block *> get_successor_blocks () const;\n+\n+private:\n+  string * make_debug_string ();\n+  void write_reproducer (reproducer &r);\n+\n+private:\n+  rvalue *m_expr;\n+  block *m_default_block;\n+  auto_vec <case_ *> m_cases;\n+};\n+\n } // namespace gcc::jit::recording\n \n /* Create a recording::memento_of_new_rvalue_from_const instance and add"}, {"sha": "01579bd7312c0601342fa654bb636819720bd15a", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -45,6 +45,7 @@ namespace gccjit\n     class rvalue;\n      class lvalue;\n        class param;\n+    class case_;\n \n   /* Errors within the API become C++ exceptions of this class.  */\n   class error\n@@ -297,6 +298,10 @@ namespace gccjit\n \t\t\t     rvalue index,\n \t\t\t     location loc = location ());\n \n+    case_ new_case (rvalue min_value,\n+\t\t    rvalue max_value,\n+\t\t    block dest_block);\n+\n   private:\n     gcc_jit_context *m_inner_ctxt;\n   };\n@@ -421,6 +426,10 @@ namespace gccjit\n \t\t\t  location loc = location ());\n     void end_with_return (location loc = location ());\n \n+    void end_with_switch (rvalue expr,\n+\t\t\t  block default_block,\n+\t\t\t  std::vector <case_> cases,\n+\t\t\t  location loc = location ());\n   };\n \n   class rvalue : public object\n@@ -471,6 +480,14 @@ namespace gccjit\n     gcc_jit_param *get_inner_param () const;\n   };\n \n+  class case_ : public object\n+  {\n+  public:\n+    case_ ();\n+    case_ (gcc_jit_case *inner);\n+\n+    gcc_jit_case *get_inner_case () const;\n+  };\n \n   /* Overloaded operators, for those who want the most terse API\n      (at the possible risk of being a little too magical).\n@@ -1124,6 +1141,17 @@ context::new_array_access (rvalue ptr,\n \t\t\t\t\t\t   index.get_inner_rvalue ()));\n }\n \n+inline case_\n+context::new_case (rvalue min_value,\n+\t\t   rvalue max_value,\n+\t\t   block dest_block)\n+{\n+  return case_ (gcc_jit_context_new_case (m_inner_ctxt,\n+\t\t\t\t\t  min_value.get_inner_rvalue (),\n+\t\t\t\t\t  max_value.get_inner_rvalue (),\n+\t\t\t\t\t  dest_block.get_inner_block ()));\n+}\n+\n // class object\n inline context\n object::get_context () const\n@@ -1371,6 +1399,27 @@ block::end_with_return (location loc)\n \t\t\t\t      loc.get_inner_location ());\n }\n \n+inline void\n+block::end_with_switch (rvalue expr,\n+\t\t\tblock default_block,\n+\t\t\tstd::vector <case_> cases,\n+\t\t\tlocation loc)\n+{\n+  /* Treat std::vector as an array, relying on it not being resized: */\n+  case_ *as_array_of_wrappers = &cases[0];\n+\n+  /* Treat the array as being of the underlying pointers, relying on\n+     the wrapper type being such a pointer internally.\t*/\n+  gcc_jit_case **as_array_of_ptrs =\n+    reinterpret_cast<gcc_jit_case **> (as_array_of_wrappers);\n+  gcc_jit_block_end_with_switch (get_inner_block (),\n+\t\t\t\t loc.get_inner_location (),\n+\t\t\t\t expr.get_inner_rvalue (),\n+\t\t\t\t default_block.get_inner_block (),\n+\t\t\t\t cases.size (),\n+\t\t\t\t as_array_of_ptrs);\n+}\n+\n inline rvalue\n block::add_call (function other,\n \t\t location loc)\n@@ -1561,6 +1610,20 @@ inline param::param (gcc_jit_param *inner)\n   : lvalue (gcc_jit_param_as_lvalue (inner))\n {}\n \n+// class case_ : public object\n+inline case_::case_ () : object () {}\n+inline case_::case_ (gcc_jit_case *inner)\n+  : object (gcc_jit_case_as_object (inner))\n+{\n+}\n+\n+inline gcc_jit_case *\n+case_::get_inner_case () const\n+{\n+  /* Manual downcast: */\n+  return reinterpret_cast<gcc_jit_case *> (get_inner_object ());\n+}\n+\n /* Overloaded operators.  */\n // Unary operators\n inline rvalue operator- (rvalue a)"}, {"sha": "4d7dd8cf40f66bc642f98a5a33a2ca5145367768", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"opts.h\"\n #include \"safe-ctype.h\"\n+#include \"typed-splay-tree.h\"\n \n #include \"libgccjit.h\"\n #include \"jit-common.h\"\n@@ -84,6 +85,10 @@ struct gcc_jit_param : public gcc::jit::recording::param\n {\n };\n \n+struct gcc_jit_case : public gcc::jit::recording::case_\n+{\n+};\n+\n /**********************************************************************\n  Error-handling.\n \n@@ -2123,6 +2128,382 @@ gcc_jit_block_end_with_void_return (gcc_jit_block *block,\n   block->end_with_return (loc, NULL);\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_case method in\n+   jit-recording.c.  */\n+\n+gcc_jit_case *\n+gcc_jit_context_new_case (gcc_jit_context *ctxt,\n+\t\t\t  gcc_jit_rvalue *min_value,\n+\t\t\t  gcc_jit_rvalue *max_value,\n+\t\t\t  gcc_jit_block *block)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_NULL_IF_FAIL (min_value, ctxt, NULL, \"NULL min_value\");\n+  RETURN_NULL_IF_FAIL (max_value, ctxt, NULL, \"NULL max_value\");\n+  RETURN_NULL_IF_FAIL (block, ctxt, NULL, \"NULL block\");\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1 (min_value->is_constant (), ctxt, NULL,\n+\t\t\t       \"min_value is not a constant: %s\",\n+\t\t\t       min_value->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF1 (max_value->is_constant (), ctxt, NULL,\n+\t\t\t       \"max_value is not a constant: %s\",\n+\t\t\t       max_value->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    min_value->get_type ()->is_int (),\n+    ctxt, NULL,\n+    \"min_value: %s (type: %s) is not of integer type\",\n+    min_value->get_debug_string (),\n+    min_value->get_type ()->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    max_value->get_type ()->is_int (),\n+    ctxt, NULL,\n+    \"max_value: %s (type: %s) is not of integer type\",\n+    max_value->get_debug_string (),\n+    max_value->get_type ()->get_debug_string ());\n+\n+  wide_int wi_min, wi_max;\n+  if (!min_value->get_wide_int (&wi_min))\n+    gcc_unreachable ();\n+  if (!max_value->get_wide_int (&wi_max))\n+    gcc_unreachable ();\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    wi::les_p (wi_min, wi_max),\n+    ctxt, NULL,\n+    \"min_value: %s > max_value: %s\",\n+    min_value->get_debug_string (),\n+    max_value->get_debug_string ());\n+  return (gcc_jit_case *)ctxt->new_case (min_value,\n+\t\t\t\t\t max_value,\n+\t\t\t\t\t block);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::memento::as_object method (a case is a\n+   memento), in jit-recording.h.  */\n+\n+gcc_jit_object *\n+gcc_jit_case_as_object (gcc_jit_case *case_)\n+{\n+  RETURN_NULL_IF_FAIL (case_, NULL, NULL, \"NULL case\");\n+\n+  return static_cast <gcc_jit_object *> (case_->as_object ());\n+}\n+\n+/* Helper function for gcc_jit_block_end_with_switch and\n+   valid_case_for_switch.  */\n+\n+static bool\n+valid_dest_for_switch (gcc::jit::recording::context *ctxt,\n+\t\t       gcc_jit_location *loc,\n+\t\t       const char *api_funcname,\n+\t\t       gcc::jit::recording::block *switch_block,\n+\t\t       gcc::jit::recording::block *dest_block,\n+\t\t       const char *dest_block_desc)\n+{\n+  if (!dest_block)\n+    {\n+      jit_error (ctxt, loc, \"%s: NULL %s\", api_funcname, dest_block_desc);\n+      return false;\n+    }\n+  gcc::jit::recording::function *switch_fn = switch_block->get_function ();\n+  gcc::jit::recording::function *dest_fn = dest_block->get_function ();\n+  if (switch_fn != dest_fn)\n+    {\n+      jit_error (ctxt, loc,\n+\t\t \"%s: %s is not in same function:\"\n+\t\t \" switch block %s is in function %s\"\n+\t\t \" whereas %s %s is in function %s\",\n+\t\t api_funcname,\n+\t\t dest_block_desc,\n+\t\t switch_block->get_debug_string (),\n+\t\t switch_fn->get_debug_string (),\n+\t\t dest_block_desc,\n+\t\t dest_block->get_debug_string (),\n+\t\t dest_fn->get_debug_string ());\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Helper function for gcc_jit_block_end_with_switch.  */\n+\n+static bool\n+valid_case_for_switch (gcc::jit::recording::context *ctxt,\n+\t\t       gcc_jit_location *loc,\n+\t\t       const char *api_funcname,\n+\t\t       gcc_jit_block *switch_block,\n+\t\t       gcc_jit_rvalue *expr,\n+\t\t       gcc_jit_case *case_,\n+\t\t       const char *case_desc,\n+\t\t       int case_idx)\n+{\n+  if (!case_)\n+    {\n+      jit_error (ctxt, loc,\n+\t\t \"%s:\"\n+\t\t \" NULL case %i\",\n+\t\t api_funcname,\n+\t\t case_idx);\n+      return false;\n+    }\n+  if (!valid_dest_for_switch (ctxt, loc,\n+\t\t\t      api_funcname,\n+\t\t\t      switch_block,\n+\t\t\t      case_->get_dest_block (),\n+\t\t\t      case_desc))\n+    return false;\n+  gcc::jit::recording::type *expr_type = expr->get_type ();\n+  if (expr_type != case_->get_min_value ()->get_type ())\n+    {\n+      jit_error (ctxt, loc,\n+\t\t \"%s:\"\n+\t\t \" mismatching types between case and expression:\"\n+\t\t \" cases[%i]->min_value: %s (type: %s)\"\n+\t\t \" expr: %s (type: %s)\",\n+\t\t api_funcname,\n+\t\t case_idx,\n+\t\t case_->get_min_value ()->get_debug_string (),\n+\t\t case_->get_min_value ()->get_type ()->get_debug_string (),\n+\t\t expr->get_debug_string (),\n+\t\t expr_type->get_debug_string ());\n+      return false;\n+    }\n+  if (expr_type != case_->get_max_value ()->get_type ())\n+    {\n+      jit_error (ctxt, loc,\n+\t\t \"%s:\"\n+\t\t \" mismatching types between case and expression:\"\n+\t\t \" cases[%i]->max_value: %s (type: %s)\"\n+\t\t \" expr: %s (type: %s)\",\n+\t\t api_funcname,\n+\t\t case_idx,\n+\t\t case_->get_max_value ()->get_debug_string (),\n+\t\t case_->get_max_value ()->get_type ()->get_debug_string (),\n+\t\t expr->get_debug_string (),\n+\t\t expr_type->get_debug_string ());\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* A class for holding the data we need to perform error-checking\n+   on a libgccjit API call.  */\n+\n+class api_call_validator\n+{\n+ public:\n+  api_call_validator (gcc::jit::recording::context *ctxt,\n+\t\t      gcc_jit_location *loc,\n+\t\t      const char *funcname)\n+  : m_ctxt (ctxt),\n+    m_loc (loc),\n+    m_funcname (funcname)\n+  {}\n+\n+ protected:\n+  gcc::jit::recording::context *m_ctxt;\n+  gcc_jit_location *m_loc;\n+  const char *m_funcname;\n+};\n+\n+/* A class for verifying that the ranges of cases within\n+   gcc_jit_block_end_with_switch don't overlap.  */\n+\n+class case_range_validator : public api_call_validator\n+{\n+ public:\n+  case_range_validator (gcc::jit::recording::context *ctxt,\n+\t\t\tgcc_jit_location *loc,\n+\t\t\tconst char *funcname);\n+\n+  bool\n+  validate (gcc_jit_case *case_, int idx);\n+\n+ private:\n+  static int\n+  case_compare (gcc::jit::recording::rvalue *k1,\n+\t\tgcc::jit::recording::rvalue *k2);\n+\n+  static wide_int\n+  get_wide_int (gcc::jit::recording::rvalue *k);\n+\n+ private:\n+  typed_splay_tree <gcc::jit::recording::rvalue *, gcc_jit_case *> m_cases;\n+};\n+\n+/* case_range_validator's ctor.  */\n+\n+case_range_validator::case_range_validator (gcc::jit::recording::context *ctxt,\n+\t\t\t\t\t    gcc_jit_location *loc,\n+\t\t\t\t\t    const char *funcname)\n+: api_call_validator (ctxt, loc, funcname),\n+  m_cases (case_compare, NULL, NULL)\n+{\n+}\n+\n+/* Ensure that the range of CASE_ does not overlap with any of the\n+   ranges of cases we've already seen.\n+   Return true if everything is OK.\n+   Return false and emit an error if there is an overlap.\n+   Compare with c-family/c-common.c:c_add_case_label.  */\n+\n+bool\n+case_range_validator::validate (gcc_jit_case *case_,\n+\t\t\t\tint case_idx)\n+{\n+  /* Look up the LOW_VALUE in the table of case labels we already\n+     have.  */\n+  gcc_jit_case *other = m_cases.lookup (case_->get_min_value ());\n+\n+  /* If there was not an exact match, check for overlapping ranges.  */\n+  if (!other)\n+    {\n+      gcc_jit_case *pred;\n+      gcc_jit_case *succ;\n+\n+      /* Even though there wasn't an exact match, there might be an\n+\t overlap between this case range and another case range.\n+\t Since we've (inductively) not allowed any overlapping case\n+\t ranges, we simply need to find the greatest low case label\n+\t that is smaller that CASE_MIN_VALUE, and the smallest low case\n+\t label that is greater than CASE_MAX_VALUE.  If there is an overlap\n+\t it will occur in one of these two ranges.  */\n+      pred = m_cases.predecessor (case_->get_min_value ());\n+      succ = m_cases.successor (case_->get_max_value ());\n+\n+      /* Check to see if the PRED overlaps.  It is smaller than\n+\t the LOW_VALUE, so we only need to check its max value.  */\n+      if (pred)\n+\t{\n+\t  wide_int wi_case_min = get_wide_int (case_->get_min_value ());\n+\t  wide_int wi_pred_max = get_wide_int (pred->get_max_value ());\n+\t  if (wi::ges_p (wi_pred_max, wi_case_min))\n+\t    other = pred;\n+\t}\n+\n+      if (!other && succ)\n+\t{\n+\t  /* Check to see if the SUCC overlaps.  The low end of that\n+\t     range is bigger than the low end of the current range.  */\n+\t  wide_int wi_case_max = get_wide_int (case_->get_max_value ());\n+\t  wide_int wi_succ_min = get_wide_int (succ->get_min_value ());\n+\t  if (wi::les_p (wi_succ_min, wi_case_max))\n+\t    other = succ;\n+\t}\n+    }\n+\n+  /* If there was an overlap, issue an error.  */\n+  if (other)\n+    {\n+      jit_error (m_ctxt, m_loc,\n+\t\t \"%s: duplicate (or overlapping) cases values:\"\n+\t\t \" case %i: %s overlaps %s\",\n+\t\t m_funcname,\n+\t\t case_idx,\n+\t\t case_->get_debug_string (),\n+\t\t other->get_debug_string ());\n+      return false;\n+    }\n+\n+  /* Register this case label in the splay tree.  */\n+  m_cases.insert (case_->get_min_value (),\n+\t\t  case_);\n+  return true;\n+}\n+\n+/* Compare with c-family/c-common.c:case_compare, which acts on tree\n+   nodes, rather than rvalue *.\n+\n+   Comparator for case label values.  K1 and K2 must be constant integer\n+   values (anything else should have been rejected by\n+   gcc_jit_context_new_case.\n+\n+   Returns -1 if K1 is ordered before K2, -1 if K1 is ordered after\n+   K2, and 0 if K1 and K2 are equal.  */\n+\n+int\n+case_range_validator::case_compare (gcc::jit::recording::rvalue * k1,\n+\t\t\t\t    gcc::jit::recording::rvalue * k2)\n+{\n+  wide_int wi1 = get_wide_int (k1);\n+  wide_int wi2 = get_wide_int (k2);\n+  return wi::cmps(wi1, wi2);\n+}\n+\n+/* Given a const int rvalue K, get the underlying value as a wide_int.  */\n+\n+wide_int\n+case_range_validator::get_wide_int (gcc::jit::recording::rvalue *k)\n+{\n+  wide_int wi;\n+  bool got_wi = k->get_wide_int (&wi);\n+  gcc_assert (got_wi);\n+  return wi;\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::block::end_with_switch method in\n+   jit-recording.c.  */\n+\n+void\n+gcc_jit_block_end_with_switch (gcc_jit_block *block,\n+\t\t\t       gcc_jit_location *loc,\n+\t\t\t       gcc_jit_rvalue *expr,\n+\t\t\t       gcc_jit_block *default_block,\n+\t\t\t       int num_cases,\n+\t\t\t       gcc_jit_case **cases)\n+{\n+  RETURN_IF_NOT_VALID_BLOCK (block, loc);\n+  gcc::jit::recording::context *ctxt = block->get_context ();\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n+  RETURN_IF_FAIL (expr, ctxt, loc,\n+\t\t  \"NULL expr\");\n+  gcc::jit::recording::type *expr_type = expr->get_type ();\n+  RETURN_IF_FAIL_PRINTF2 (\n+    expr_type->is_int (),\n+    ctxt, loc,\n+    \"expr: %s (type: %s) is not of integer type\",\n+    expr->get_debug_string (),\n+    expr_type->get_debug_string ());\n+  if (!valid_dest_for_switch (ctxt, loc,\n+\t\t\t      __func__,\n+\t\t\t      block,\n+\t\t\t      default_block,\n+\t\t\t      \"default_block\"))\n+    return;\n+  RETURN_IF_FAIL (num_cases >= 0, ctxt, loc, \"num_cases < 0\");\n+  case_range_validator crv (ctxt, loc, __func__);\n+  for (int i = 0; i < num_cases; i++)\n+    {\n+      char case_desc[32];\n+      snprintf (case_desc, sizeof (case_desc),\n+\t\t\"cases[%i]\", i);\n+      if (!valid_case_for_switch (ctxt, loc,\n+\t\t\t\t  __func__,\n+\t\t\t\t  block,\n+\t\t\t\t  expr,\n+\t\t\t\t  cases[i],\n+\t\t\t\t  case_desc,\n+\t\t\t\t  i))\n+\treturn;\n+      if (!crv.validate (cases[i], i))\n+\treturn;\n+    }\n+\n+  block->end_with_switch (loc, expr, default_block,\n+\t\t\t  num_cases,\n+\t\t\t  (gcc::jit::recording::case_ **)cases);\n+}\n+\n /**********************************************************************\n  Option-management\n  **********************************************************************/"}, {"sha": "32f2a5d38936c54b6287cd5b6406c21b6d06daf5", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -67,6 +67,7 @@ typedef struct gcc_jit_result gcc_jit_result;\n \t +- gcc_jit_rvalue\n \t     +- gcc_jit_lvalue\n \t\t +- gcc_jit_param\n+\t +- gcc_jit_case\n */\n typedef struct gcc_jit_object gcc_jit_object;\n \n@@ -131,6 +132,12 @@ typedef struct gcc_jit_lvalue gcc_jit_lvalue;\n    rvalue); use gcc_jit_param_as_lvalue to convert.  */\n typedef struct gcc_jit_param gcc_jit_param;\n \n+/* A gcc_jit_case is for use when building multiway branches via\n+   gcc_jit_block_end_with_switch and represents a range of integer\n+   values (or an individual integer value) together with an associated\n+   destination block.  */\n+typedef struct gcc_jit_case gcc_jit_case;\n+\n /* Acquire a JIT-compilation context.  */\n extern gcc_jit_context *\n gcc_jit_context_acquire (void);\n@@ -1097,6 +1104,81 @@ extern void\n gcc_jit_block_end_with_void_return (gcc_jit_block *block,\n \t\t\t\t    gcc_jit_location *loc);\n \n+/* Create a new gcc_jit_case instance for use in a switch statement.\n+   min_value and max_value must be constants of integer type.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n+*/\n+extern gcc_jit_case *\n+gcc_jit_context_new_case (gcc_jit_context *ctxt,\n+\t\t\t  gcc_jit_rvalue *min_value,\n+\t\t\t  gcc_jit_rvalue *max_value,\n+\t\t\t  gcc_jit_block *dest_block);\n+\n+/* Upcasting from case to object.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n+*/\n+\n+extern gcc_jit_object *\n+gcc_jit_case_as_object (gcc_jit_case *case_);\n+\n+/* Terminate a block by adding evalation of an rvalue, then performing\n+   a multiway branch.\n+\n+   This is roughly equivalent to this C code:\n+\n+     switch (expr)\n+       {\n+       default:\n+\t goto default_block;\n+\n+       case C0.min_value ... C0.max_value:\n+\t goto C0.dest_block;\n+\n+       case C1.min_value ... C1.max_value:\n+\t goto C1.dest_block;\n+\n+       ...etc...\n+\n+       case C[N - 1].min_value ... C[N - 1].max_value:\n+\t goto C[N - 1].dest_block;\n+     }\n+\n+   block, expr, default_block and cases must all be non-NULL.\n+\n+   expr must be of the same integer type as all of the min_value\n+   and max_value within the cases.\n+\n+   num_cases must be >= 0.\n+\n+   The ranges of the cases must not overlap (or have duplicate\n+   values).\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_3; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n+*/\n+\n+extern void\n+gcc_jit_block_end_with_switch (gcc_jit_block *block,\n+\t\t\t       gcc_jit_location *loc,\n+\t\t\t       gcc_jit_rvalue *expr,\n+\t\t\t       gcc_jit_block *default_block,\n+\t\t\t       int num_cases,\n+\t\t\t       gcc_jit_case **cases);\n+\n+/* Pre-canned feature macro to indicate the presence of\n+   gcc_jit_block_end_with_switch, gcc_jit_case_as_object, and\n+   gcc_jit_context_new_case.\n+\n+   This can be tested for with #ifdef.  */\n+#define LIBGCCJIT_HAVE_SWITCH_STATEMENTS\n+\n /**********************************************************************\n  Nested contexts.\n  **********************************************************************/"}, {"sha": "3c0a0c14a7a1ae44adbf2150f98cc03470987aec", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -120,3 +120,11 @@ LIBGCCJIT_ABI_2 {\n   global:\n     gcc_jit_context_set_bool_allow_unreachable_blocks;\n } LIBGCCJIT_ABI_1;\n+\n+# Add support for switch statements.\n+LIBGCCJIT_ABI_3 {\n+  global:\n+    gcc_jit_block_end_with_switch;\n+    gcc_jit_case_as_object;\n+    gcc_jit_context_new_case;\n+} LIBGCCJIT_ABI_2;"}, {"sha": "80be58e6e58dcd4577c93a83e26ba52bec4673dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -1,3 +1,21 @@\n+2015-06-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/all-non-failing-tests.h: Add test-switch.c.\n+\t* jit.dg/test-error-gcc_jit_block_end_with_switch-NULL-case.c: New\n+\ttestcase.\n+\t* jit.dg/test-error-gcc_jit_block_end_with_switch-mismatching-case-type.c:\n+\tNew testcase.\n+\t* jit.dg/test-error-gcc_jit_block_end_with_switch-overlapping-ranges.c:\n+\tNew testcase.\n+\t* jit.dg/test-error-gcc_jit_context_new_case-non-const-label.c:\n+\tNew testcase.\n+\t* jit.dg/test-error-gcc_jit_context_new_case-non-integer-type.c:\n+\tNew testcase.\n+\t* jit.dg/test-error-gcc_jit_context_new_case-reversed-endpoints.c:\n+\tNew testcase.\n+\t* jit.dg/test-switch.c: New testcase.\n+\t* jit.dg/test-switch.cc: New testcase.\n+\n 2015-06-30  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/66546"}, {"sha": "36a616018d50b82f34e92c7a326757a5e27a7061", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -175,6 +175,13 @@\n #undef create_code\n #undef verify_code\n \n+/* test-switch.c */\n+#define create_code create_code_switch\n+#define verify_code verify_code_switch\n+#include \"test-switch.c\"\n+#undef create_code\n+#undef verify_code\n+\n /* test-types.c */\n #define create_code create_code_types\n #define verify_code verify_code_types\n@@ -281,6 +288,9 @@ const struct testcase testcases[] = {\n   {\"sum_of_squares\",\n    create_code_sum_of_squares,\n    verify_code_sum_of_squares},\n+  {\"switch\",\n+   create_code_switch,\n+   verify_code_switch},\n   {\"types\",\n    create_code_types,\n    verify_code_types},"}, {"sha": "07a984806939166e3f0c627d648ec74b1f22a818", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_block_end_with_switch-NULL-case.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-NULL-case.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-NULL-case.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-NULL-case.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,66 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case x:\n+\t     return 3;\n+\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+      and verify that we get a sane error about the non-const\n+      case.\n+   */\n+  gcc_jit_type *t_int =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *return_type = t_int;\n+  gcc_jit_param *x =\n+    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n+  gcc_jit_param *params[1] = {x};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"test_switch\",\n+\t\t\t\t  1, params, 0);\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  gcc_jit_block *b_default =\n+    gcc_jit_function_new_block (func, \"default\");\n+\n+  gcc_jit_case *cases[1] = {\n+    NULL\n+  };\n+\n+  gcc_jit_block_end_with_switch (\n+    b_initial, NULL,\n+    gcc_jit_param_as_rvalue (x),\n+    b_default,\n+    1,\n+    cases);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_block_end_with_switch: NULL case 0\");\n+}"}, {"sha": "cc907cea1d8d61ee9254345fb5a0aa5d4d50bd53", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_block_end_with_switch-mismatching-case-type.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-mismatching-case-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-mismatching-case-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-mismatching-case-type.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,83 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case (long long)0 ... (long long)5:\n+\t     return 3;\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+      and verify that the floating-point case is an error.\n+   */\n+  gcc_jit_type *t_int =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *t_long_long =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_LONG_LONG);\n+  gcc_jit_type *return_type = t_int;\n+  gcc_jit_param *x =\n+    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n+  gcc_jit_param *params[1] = {x};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"test_switch\",\n+\t\t\t\t  1, params, 0);\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  gcc_jit_block *b_default =\n+    gcc_jit_function_new_block (func, \"default\");\n+  gcc_jit_block *b_case_0 =\n+    gcc_jit_function_new_block (func, \"case_0\");\n+\n+  /* Note the erroneous use of \"t_float\" here.  */\n+  gcc_jit_case *cases[1] = {\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_long_long, 0),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_long_long, 5),\n+      b_case_0)\n+  };\n+\n+  gcc_jit_block_end_with_switch (\n+    b_initial, NULL,\n+    gcc_jit_param_as_rvalue (x),\n+    b_default,\n+    1,\n+    cases);\n+\n+  gcc_jit_block_end_with_return (\n+    b_case_0, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 3));\n+  gcc_jit_block_end_with_return (\n+    b_default, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_block_end_with_switch:\"\n+\t\t      \" mismatching types between case and expression:\"\n+\t\t      \" cases[0]->min_value: (long long)0 (type: long long)\"\n+\t\t      \" expr: x (type: int)\");\n+}"}, {"sha": "40655c244a074f6b40e4f277f23e23391d794c51", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_block_end_with_switch-overlapping-ranges.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-overlapping-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-overlapping-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_block_end_with_switch-overlapping-ranges.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,95 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case 0 ... 5:\n+\t     return 3;\n+\n+\t  case 5 ... 10:\n+\t     return 4;\n+\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+     and verify that we get an error about the overlapping\n+     ranges.\n+   */\n+  gcc_jit_type *t_int =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *return_type = t_int;\n+  gcc_jit_param *x =\n+    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n+  gcc_jit_param *params[1] = {x};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"test_switch\",\n+\t\t\t\t  1, params, 0);\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  gcc_jit_block *b_default =\n+    gcc_jit_function_new_block (func, \"default\");\n+  gcc_jit_block *b_case_0_5 =\n+    gcc_jit_function_new_block (func, \"case_0_5\");\n+  gcc_jit_block *b_case_5_10 =\n+    gcc_jit_function_new_block (func, \"case_5_10\");\n+\n+  gcc_jit_case *cases[2] = {\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 0),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 5),\n+      b_case_0_5),\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 5),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10),\n+      b_case_5_10)\n+  };\n+\n+  gcc_jit_block_end_with_switch (\n+    b_initial, NULL,\n+    gcc_jit_param_as_rvalue (x),\n+    b_default,\n+    2,\n+    cases);\n+\n+  gcc_jit_block_end_with_return (\n+    b_case_0_5, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 3));\n+  gcc_jit_block_end_with_return (\n+    b_case_5_10, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 4));\n+  gcc_jit_block_end_with_return (\n+    b_default, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_block_end_with_switch:\"\n+\t\t      \" duplicate (or overlapping) cases values:\"\n+\t\t      \" case 1: case (int)5 ... (int)10: goto case_5_10;\"\n+\t\t      \" overlaps case (int)0 ... (int)5: goto case_0_5;\");\n+}"}, {"sha": "39538183f00354c8f4e4b11833ac6d9af61bab5a", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_context_new_case-non-const-label.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-non-const-label.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-non-const-label.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-non-const-label.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,80 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case x:\n+\t     return 3;\n+\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+      and verify that we get a sane error about the non-const\n+      case.\n+   */\n+  gcc_jit_type *t_int =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *return_type = t_int;\n+  gcc_jit_param *x =\n+    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n+  gcc_jit_param *params[1] = {x};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"test_switch\",\n+\t\t\t\t  1, params, 0);\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  gcc_jit_block *b_default =\n+    gcc_jit_function_new_block (func, \"default\");\n+  gcc_jit_block *b_case_x =\n+    gcc_jit_function_new_block (func, \"case_x\");\n+\n+  /* Erroneous use of non-const x for a case.  */\n+  gcc_jit_case *cases[1] = {\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_param_as_rvalue (x),\n+      gcc_jit_param_as_rvalue (x),\n+      b_case_x)\n+  };\n+\n+  gcc_jit_block_end_with_switch (\n+    b_initial, NULL,\n+    gcc_jit_param_as_rvalue (x),\n+    b_default,\n+    1,\n+    cases);\n+  gcc_jit_block_end_with_return (\n+    b_case_x, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 3));\n+  gcc_jit_block_end_with_return (\n+    b_default, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_case:\"\n+\t\t      \" min_value is not a constant: x\");\n+}"}, {"sha": "5d442862c08450f37334cc75b500be496d966047", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_context_new_case-non-integer-type.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-non-integer-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-non-integer-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-non-integer-type.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,81 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case 0.f ... 5.f:\n+\t     return 3;\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+      and verify that the floating-point case is an error.\n+   */\n+  gcc_jit_type *t_int =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *t_float =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_FLOAT);\n+  gcc_jit_type *return_type = t_int;\n+  gcc_jit_param *x =\n+    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n+  gcc_jit_param *params[1] = {x};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"test_switch\",\n+\t\t\t\t  1, params, 0);\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  gcc_jit_block *b_default =\n+    gcc_jit_function_new_block (func, \"default\");\n+  gcc_jit_block *b_case_0 =\n+    gcc_jit_function_new_block (func, \"case_0\");\n+\n+  /* Note the erroneous use of \"t_float\" here.  */\n+  gcc_jit_case *cases[1] = {\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_float, 0),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_float, 5),\n+      b_case_0)\n+  };\n+\n+  gcc_jit_block_end_with_switch (\n+    b_initial, NULL,\n+    gcc_jit_param_as_rvalue (x),\n+    b_default,\n+    1,\n+    cases);\n+\n+  gcc_jit_block_end_with_return (\n+    b_case_0, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 3));\n+  gcc_jit_block_end_with_return (\n+    b_default, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_case:\"\n+\t\t      \" min_value: (float)0 (type: float) is not of integer type\");\n+}"}, {"sha": "a84d9f33f3dcd30a9a784755e901cb3c6848626d", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_context_new_case-reversed-endpoints.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-reversed-endpoints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-reversed-endpoints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_case-reversed-endpoints.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,80 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case 5 ... 0:\n+\t     return 3;\n+\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+     and verify that we get an error about the reversed endpoints\n+     in the range.\n+   */\n+  gcc_jit_type *t_int =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *return_type = t_int;\n+  gcc_jit_param *x =\n+    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n+  gcc_jit_param *params[1] = {x};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"test_switch\",\n+\t\t\t\t  1, params, 0);\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  gcc_jit_block *b_default =\n+    gcc_jit_function_new_block (func, \"default\");\n+  gcc_jit_block *b_case_5_0 =\n+    gcc_jit_function_new_block (func, \"case_5_0\");\n+\n+  gcc_jit_case *cases[1] = {\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 5),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 0),\n+      b_case_5_0)\n+  };\n+\n+  gcc_jit_block_end_with_switch (\n+    b_initial, NULL,\n+    gcc_jit_param_as_rvalue (x),\n+    b_default,\n+    1,\n+    cases);\n+\n+  gcc_jit_block_end_with_return (\n+    b_case_5_0, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 3));\n+  gcc_jit_block_end_with_return (\n+    b_default, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_case:\"\n+\t\t      \" min_value: (int)5 > max_value: (int)0\");\n+}"}, {"sha": "74088c81f292413a0483a5c3e12ed5bafc750429", "filename": "gcc/testsuite/jit.dg/test-switch.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-switch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-switch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-switch.c?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,147 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+/* Quote from here in docs/topics/functions.rst.  */\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case 0 ... 5:\n+\t     return 3;\n+\n+\t  case 25 ... 27:\n+\t     return 4;\n+\n+\t  case -42 ... -17:\n+\t     return 83;\n+\n+\t  case 40:\n+\t     return 8;\n+\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+   */\n+  gcc_jit_type *t_int =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *return_type = t_int;\n+  gcc_jit_param *x =\n+    gcc_jit_context_new_param (ctxt, NULL, t_int, \"x\");\n+  gcc_jit_param *params[1] = {x};\n+  gcc_jit_function *func =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t  return_type,\n+\t\t\t\t  \"test_switch\",\n+\t\t\t\t  1, params, 0);\n+\n+  gcc_jit_block *b_initial =\n+    gcc_jit_function_new_block (func, \"initial\");\n+\n+  gcc_jit_block *b_default =\n+    gcc_jit_function_new_block (func, \"default\");\n+  gcc_jit_block *b_case_0_5 =\n+    gcc_jit_function_new_block (func, \"case_0_5\");\n+  gcc_jit_block *b_case_25_27 =\n+    gcc_jit_function_new_block (func, \"case_25_27\");\n+  gcc_jit_block *b_case_m42_m17 =\n+    gcc_jit_function_new_block (func, \"case_m42_m17\");\n+  gcc_jit_block *b_case_40 =\n+    gcc_jit_function_new_block (func, \"case_40\");\n+\n+  gcc_jit_case *cases[4] = {\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 0),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 5),\n+      b_case_0_5),\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 25),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 27),\n+      b_case_25_27),\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, -42),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, -17),\n+      b_case_m42_m17),\n+    gcc_jit_context_new_case (\n+      ctxt,\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 40),\n+      gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 40),\n+      b_case_40)\n+  };\n+  gcc_jit_block_end_with_switch (\n+    b_initial, NULL,\n+    gcc_jit_param_as_rvalue (x),\n+    b_default,\n+    4, cases);\n+\n+  gcc_jit_block_end_with_return (\n+    b_case_0_5, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 3));\n+  gcc_jit_block_end_with_return (\n+    b_case_25_27, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 4));\n+  gcc_jit_block_end_with_return (\n+    b_case_m42_m17, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 83));\n+  gcc_jit_block_end_with_return (\n+    b_case_40, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 8));\n+  gcc_jit_block_end_with_return (\n+    b_default, NULL,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, t_int, 10));\n+}\n+\n+/* Quote up to here in docs/topics/functions.rst.  */\n+\n+static int\n+c_test_switch (int x)\n+{\n+  switch (x)\n+    {\n+    case 0 ... 5:\n+      return 3;\n+    case 25 ... 27:\n+      return 4;\n+    case -42 ... -17:\n+      return 83;\n+    case 40:\n+      return 8;\n+    default:\n+      return 10;\n+    }\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef int (*test_switch_type) (int);\n+  CHECK_NON_NULL (result);\n+  test_switch_type test_switch =\n+    (test_switch_type)gcc_jit_result_get_code (result, \"test_switch\");\n+  CHECK_NON_NULL (test_switch);\n+\n+  int i;\n+\n+  for (i = -255; i < 255; i++)\n+    {\n+      int val = test_switch (i);\n+      int exp = c_test_switch (i);\n+      if (val != exp)\n+\tfail (\"test_switch (%i) returned: %i; expected; %i\", i, val, exp);\n+    }\n+}"}, {"sha": "862f7a8f72b51d64cbb9756d861c58e1377fd417", "filename": "gcc/testsuite/jit.dg/test-switch.cc", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-switch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftestsuite%2Fjit.dg%2Ftest-switch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-switch.cc?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,118 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit++.h\"\n+\n+#include \"harness.h\"\n+\n+/* Quote from here in docs/cp/topics/functions.rst.  */\n+\n+void\n+create_code (gcc_jit_context *c_ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+      int\n+      test_switch (int x)\n+      {\n+\tswitch (x)\n+\t  {\n+\t  case 0 ... 5:\n+\t     return 3;\n+\n+\t  case 25 ... 27:\n+\t     return 4;\n+\n+\t  case -42 ... -17:\n+\t     return 83;\n+\n+\t  case 40:\n+\t     return 8;\n+\n+\t  default:\n+\t     return 10;\n+\t  }\n+      }\n+   */\n+  gccjit::context ctxt (c_ctxt);\n+  gccjit::type t_int = ctxt.get_type (GCC_JIT_TYPE_INT);\n+  gccjit::type return_type = t_int;\n+  gccjit::param x = ctxt.new_param (t_int, \"x\");\n+  std::vector <gccjit::param> params;\n+  params.push_back (x);\n+  gccjit::function func = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                                             return_type,\n+                                             \"test_switch\",\n+                                             params, 0);\n+\n+  gccjit::block b_initial = func.new_block (\"initial\");\n+\n+  gccjit::block b_default = func.new_block (\"default\");\n+  gccjit::block b_case_0_5 = func.new_block (\"case_0_5\");\n+  gccjit::block b_case_25_27 = func.new_block (\"case_25_27\");\n+  gccjit::block b_case_m42_m17 = func.new_block (\"case_m42_m17\");\n+  gccjit::block b_case_40 = func.new_block (\"case_40\");\n+\n+  std::vector <gccjit::case_> cases;\n+  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, 0),\n+                                  ctxt.new_rvalue (t_int, 5),\n+                                  b_case_0_5));\n+  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, 25),\n+                                  ctxt.new_rvalue (t_int, 27),\n+                                  b_case_25_27));\n+  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, -42),\n+                                  ctxt.new_rvalue (t_int, -17),\n+                                  b_case_m42_m17));\n+  cases.push_back (ctxt.new_case (ctxt.new_rvalue (t_int, 40),\n+                                  ctxt.new_rvalue (t_int, 40),\n+                                  b_case_40));\n+  b_initial.end_with_switch (x,\n+                             b_default,\n+                             cases);\n+\n+  b_case_0_5.end_with_return (ctxt.new_rvalue (t_int, 3));\n+  b_case_25_27.end_with_return (ctxt.new_rvalue (t_int, 4));\n+  b_case_m42_m17.end_with_return (ctxt.new_rvalue (t_int, 83));\n+  b_case_40.end_with_return (ctxt.new_rvalue (t_int, 8));\n+  b_default.end_with_return (ctxt.new_rvalue (t_int, 10));\n+}\n+\n+/* Quote up to here in docs/cp/topics/functions.rst.  */\n+\n+static int\n+c_test_switch (int x)\n+{\n+  switch (x)\n+    {\n+    case 0 ... 5:\n+      return 3;\n+    case 25 ... 27:\n+      return 4;\n+    case -42 ... -17:\n+      return 83;\n+    case 40:\n+      return 8;\n+    default:\n+      return 10;\n+    }\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef int (*test_switch_type) (int);\n+  CHECK_NON_NULL (result);\n+  test_switch_type test_switch =\n+    (test_switch_type)gcc_jit_result_get_code (result, \"test_switch\");\n+  CHECK_NON_NULL (test_switch);\n+\n+  int i;\n+\n+  for (i = -255; i < 255; i++)\n+    {\n+      int val = test_switch (i);\n+      int exp = c_test_switch (i);\n+      if (val != exp)\n+\tfail (\"test_switch (%i) returned: %i; expected; %i\", i, val, exp);\n+    }\n+}"}, {"sha": "784986219e1f1a048fdbbfbddc9e0cbb3009e9da", "filename": "gcc/typed-splay-tree.h", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftyped-splay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5d0088148d1d6218f5f503d1c8e67a529dfacd/gcc%2Ftyped-splay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftyped-splay-tree.h?ref=ec5d0088148d1d6218f5f503d1c8e67a529dfacd", "patch": "@@ -0,0 +1,135 @@\n+/* A typesafe wrapper around libiberty's splay-tree.h.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TYPED_SPLAY_TREE_H\n+#define GCC_TYPED_SPLAY_TREE_H\n+\n+#include \"splay-tree.h\"\n+\n+/* Typesafe wrapper around libiberty's splay-tree.h.  */\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+class typed_splay_tree\n+{\n+ public:\n+  typedef KEY_TYPE key_type;\n+  typedef VALUE_TYPE value_type;\n+\n+  typedef int (*compare_fn) (key_type, key_type);\n+  typedef void (*delete_key_fn) (key_type);\n+  typedef void (*delete_value_fn) (value_type);\n+\n+  typed_splay_tree (compare_fn,\n+\t\t    delete_key_fn,\n+\t\t    delete_value_fn);\n+  ~typed_splay_tree ();\n+\n+  value_type lookup (key_type k);\n+  value_type predecessor (key_type k);\n+  value_type successor (key_type k);\n+  void insert (key_type k, value_type v);\n+\n+ private:\n+  static value_type node_to_value (splay_tree_node node);\n+\n+ private:\n+  ::splay_tree m_inner;\n+};\n+\n+/* Constructor for typed_splay_tree <K, V>.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline typed_splay_tree<KEY_TYPE, VALUE_TYPE>::\n+  typed_splay_tree (compare_fn compare_fn,\n+\t\t    delete_key_fn delete_key_fn,\n+\t\t    delete_value_fn delete_value_fn)\n+{\n+  m_inner = splay_tree_new ((splay_tree_compare_fn)compare_fn,\n+\t\t\t    (splay_tree_delete_key_fn)delete_key_fn,\n+\t\t\t    (splay_tree_delete_value_fn)delete_value_fn);\n+}\n+\n+/* Destructor for typed_splay_tree <K, V>.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline typed_splay_tree<KEY_TYPE, VALUE_TYPE>::\n+  ~typed_splay_tree ()\n+{\n+  splay_tree_delete (m_inner);\n+}\n+\n+/* Lookup KEY, returning a value if present, and NULL\n+   otherwise.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline VALUE_TYPE\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::lookup (key_type key)\n+{\n+  splay_tree_node node = splay_tree_lookup (m_inner, (splay_tree_key)key);\n+  return node_to_value (node);\n+}\n+\n+/* Return the immediate predecessor of KEY, or NULL if there is no\n+   predecessor.  KEY need not be present in the tree.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline VALUE_TYPE\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::predecessor (key_type key)\n+{\n+  splay_tree_node node = splay_tree_predecessor (m_inner, (splay_tree_key)key);\n+  return node_to_value (node);\n+}\n+\n+/* Return the immediate successor of KEY, or NULL if there is no\n+   successor.  KEY need not be present in the tree.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline VALUE_TYPE\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::successor (key_type k)\n+{\n+  splay_tree_node node = splay_tree_successor (m_inner, (splay_tree_key)k);\n+  return node_to_value (node);\n+}\n+\n+/* Insert a new node (associating KEY with VALUE).  If a\n+   previous node with the indicated KEY exists, its data is replaced\n+   with the new value.  */\n+\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline void\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::insert (key_type key,\n+\t\t\t\t\t\tvalue_type value)\n+{\n+  splay_tree_insert (m_inner,\n+\t\t     (splay_tree_key)key,\n+\t\t     (splay_tree_value)value);\n+}\n+\n+/* Internal function for converting from splay_tree_node to\n+   VALUE_TYPE.  */\n+template <typename KEY_TYPE, typename VALUE_TYPE>\n+inline VALUE_TYPE\n+typed_splay_tree<KEY_TYPE, VALUE_TYPE>::node_to_value (splay_tree_node node)\n+{\n+  if (node)\n+    return (value_type)node->value;\n+  else\n+    return 0;\n+}\n+\n+#endif  /* GCC_TYPED_SPLAY_TREE_H  */"}]}