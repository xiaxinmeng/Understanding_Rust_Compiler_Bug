{"sha": "f1bebab6974932668b19c4ec52cb15b638c163f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFiZWJhYjY5NzQ5MzI2NjhiMTljNGVjNTJjYjE1YjYzOGMxNjNmNQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-04-30T05:39:59Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-04-30T05:39:59Z"}, "message": "sh.c (register_sh_passes, [...]): Remove TARGET_SH1 checks.\n\ngcc/\n\t* config/sh/sh.c (register_sh_passes, sh_option_override,\n\tsh_print_operand, prepare_move_operands,\n\tsh_can_follow_jump): Remove TARGET_SH1 checks.\n\t* config/sh/sh.h (TARGET_VARARGS_PRETEND_ARGS, VALID_REGISTER_P,\n\tPROMOTE_MODE): Likewise.\n\t* config/sh/sh.md (adddi3, addsi3, subdi3, subsi3, andsi3,\n\tmovdi): Likewise.\n\nFrom-SVN: r235674", "tree": {"sha": "89443552d9508dbd545bd6b3461e14453f644bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89443552d9508dbd545bd6b3461e14453f644bfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1bebab6974932668b19c4ec52cb15b638c163f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1bebab6974932668b19c4ec52cb15b638c163f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1bebab6974932668b19c4ec52cb15b638c163f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1bebab6974932668b19c4ec52cb15b638c163f5/comments", "author": null, "committer": null, "parents": [{"sha": "85e051a3c45a6a02ecaf52447ad91b174d1bf33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85e051a3c45a6a02ecaf52447ad91b174d1bf33b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85e051a3c45a6a02ecaf52447ad91b174d1bf33b"}], "stats": {"total": 154, "additions": 70, "deletions": 84}, "files": [{"sha": "e49d649a4d90604f4e76a41e6d4b0fdb061e6b02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1bebab6974932668b19c4ec52cb15b638c163f5", "patch": "@@ -1,3 +1,13 @@\n+2016-04-30  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (register_sh_passes, sh_option_override,\n+\tsh_print_operand, prepare_move_operands,\n+\tsh_can_follow_jump): Remove TARGET_SH1 checks.\n+\t* config/sh/sh.h (TARGET_VARARGS_PRETEND_ARGS, VALID_REGISTER_P,\n+\tPROMOTE_MODE): Likewise.\n+\t* config/sh/sh.md (adddi3, addsi3, subdi3, subsi3, andsi3,\n+\tmovdi): Likewise.\n+\n 2016-04-30  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_savres_strategy): Force inline"}, {"sha": "b37d3abb252e519ac38d47753088cbd668caca0c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f1bebab6974932668b19c4ec52cb15b638c163f5", "patch": "@@ -772,9 +772,6 @@ extern opt_pass* make_pass_sh_optimize_sett_clrt (gcc::context* ctx,\n static void\n register_sh_passes (void)\n {\n-  if (!TARGET_SH1)\n-    return;\n-\n /* Running the sh_treg_combine pass after ce1 generates better code when\n    comparisons are combined and reg-reg moves are introduced, because\n    reg-reg moves will be eliminated afterwards.  However, there are quite\n@@ -848,36 +845,31 @@ sh_option_override (void)\n   if (!TARGET_SH3 && TARGET_USERMODE)\n     TARGET_USERMODE = false;\n \n-  if (TARGET_SH1)\n+  if (! strcmp (sh_div_str, \"call-div1\"))\n+    sh_div_strategy = SH_DIV_CALL_DIV1;\n+  else if (! strcmp (sh_div_str, \"call-fp\") && TARGET_FPU_ANY)\n+    sh_div_strategy = SH_DIV_CALL_FP;\n+  else if (! strcmp (sh_div_str, \"call-table\") && TARGET_DYNSHIFT)\n+    sh_div_strategy = SH_DIV_CALL_TABLE;\n+  else\n     {\n-      if (! strcmp (sh_div_str, \"call-div1\"))\n-\tsh_div_strategy = SH_DIV_CALL_DIV1;\n-      else if (! strcmp (sh_div_str, \"call-fp\")\n-\t       && (TARGET_FPU_DOUBLE || TARGET_FPU_SINGLE_ONLY\n-\t\t   || TARGET_FPU_ANY))\n-\tsh_div_strategy = SH_DIV_CALL_FP;\n-      else if (! strcmp (sh_div_str, \"call-table\") && TARGET_DYNSHIFT)\n+      /* Pick one that makes most sense for the target in general.\n+\t It is not much good to use different functions depending on -Os,\n+\t since then we'll end up with two different functions when some of\n+\t the code is compiled for size, and some for speed.  */\n+\n+      /* SH4 tends to emphasize speed.  */\n+      if (TARGET_HARD_SH4)\n \tsh_div_strategy = SH_DIV_CALL_TABLE;\n+      /* These have their own way of doing things.  */\n+      else if (TARGET_SH2A)\n+\tsh_div_strategy = SH_DIV_INTRINSIC;\n+      /* SH1 .. SH3 cores often go into small-footprint systems, so\n+\t default to the smallest implementation available.  */\n       else\n-\t/* Pick one that makes most sense for the target in general.\n-\t   It is not much good to use different functions depending\n-\t   on -Os, since then we'll end up with two different functions\n-\t   when some of the code is compiled for size, and some for\n-\t   speed.  */\n-\n-\t/* SH4 tends to emphasize speed.  */\n-\tif (TARGET_HARD_SH4)\n-\t  sh_div_strategy = SH_DIV_CALL_TABLE;\n-\t/* These have their own way of doing things.  */\n-\telse if (TARGET_SH2A)\n-\t  sh_div_strategy = SH_DIV_INTRINSIC;\n-\t/* SH1 .. SH3 cores often go into small-footprint systems, so\n-\t   default to the smallest implementation available.  */\n-\telse\n-\t  sh_div_strategy = SH_DIV_CALL_DIV1;\n+\tsh_div_strategy = SH_DIV_CALL_DIV1;\n     }\n-  if (!TARGET_SH1)\n-    TARGET_PRETEND_CMOVE = 0;\n+\n   if (sh_divsi3_libfunc[0])\n     ; /* User supplied - leave it alone.  */\n   else if (TARGET_DIVIDE_CALL_FP)\n@@ -1443,8 +1435,7 @@ sh_print_operand (FILE *stream, rtx x, int code)\n \t  break;\n \n \tdefault:\n-\t  if (TARGET_SH1)\n-\t    fputc ('#', stream);\n+\t  fputc ('#', stream);\n \t  output_addr_const (stream, x);\n \t  break;\n \t}\n@@ -1618,8 +1609,7 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t of a library call to the target.  Reject `st r0,@(rX,rY)' because\n \t reload will fail to find a spill register for rX, since r0 is already\n \t being used for the source.  */\n-      else if (TARGET_SH1\n-\t       && refers_to_regno_p (R0_REG, operands[1])\n+      else if (refers_to_regno_p (R0_REG, operands[1])\n \t       && MEM_P (operands[0])\n \t       && GET_CODE (XEXP (operands[0], 0)) == PLUS\n \t       && REG_P (XEXP (XEXP (operands[0], 0), 1)))\n@@ -1639,7 +1629,7 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t case.  We can pre-allocate R0 for that index term to avoid\n \t the issue.  See PR target/66591.  */\n       else if (sh_lra_p ()\n-\t       && TARGET_SH1 && ! TARGET_SH2A\n+\t       && ! TARGET_SH2A\n \t       && ((REG_P (operands[0]) && MEM_P (operands[1]))\n \t\t   || (REG_P (operands[1]) && MEM_P (operands[0]))))\n \t{\n@@ -9590,8 +9580,7 @@ sh_can_follow_jump (const rtx_insn *branch1, const rtx_insn *branch2)\n {\n   /* Don't follow if BRANCH2 is possible to be a jump crossing between\n      hot and cold partitions.  */\n-  if (TARGET_SH1\n-      && flag_reorder_blocks_and_partition\n+  if (flag_reorder_blocks_and_partition\n       && simplejump_p (branch2)\n       && CROSSING_JUMP_P (branch2))\n     return false;"}, {"sha": "31d75e89e92e58510bfc638338551e05c4cfbb1b", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=f1bebab6974932668b19c4ec52cb15b638c163f5", "patch": "@@ -77,7 +77,7 @@ extern int code_for_indirect_jump_scratch;\n \n /* This is not used by the SH2E calling convention  */\n #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \\\n-  (TARGET_SH1 && ! TARGET_SH2E \\\n+  (! TARGET_SH2E \\\n    && ! (TARGET_HITACHI || sh_attr_renesas_p (FUN_DECL)))\n \n #ifndef TARGET_CPU_DEFAULT\n@@ -636,7 +636,7 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n    || XD_REGISTER_P (REGNO) \\\n    || (REGNO) == AP_REG || (REGNO) == RAP_REG \\\n    || (REGNO) == FRAME_POINTER_REGNUM \\\n-   || (TARGET_SH1 && (SPECIAL_REGISTER_P (REGNO) || (REGNO) == PR_REG)) \\\n+   || ((SPECIAL_REGISTER_P (REGNO) || (REGNO) == PR_REG)) \\\n    || (TARGET_SH2E && (REGNO) == FPUL_REG))\n \n /* The mode that should be generally used to store a register by\n@@ -1879,8 +1879,7 @@ extern int current_function_interrupt;\n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \\\n   if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n       && GET_MODE_SIZE (MODE) < 4/* ! UNITS_PER_WORD */)\\\n-    (UNSIGNEDP) = ((MODE) == SImode ? 0 : (UNSIGNEDP)),\t\\\n-    (MODE) = (TARGET_SH1 ? SImode : DImode);\n+    (UNSIGNEDP) = ((MODE) == SImode ? 0 : (UNSIGNEDP)),\t(MODE) = SImode;\n \n #define MAX_FIXED_MODE_SIZE (64)\n "}, {"sha": "ad29426adfbc54c65fad46942ce166d5c964f4f6", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 32, "deletions": 44, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bebab6974932668b19c4ec52cb15b638c163f5/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=f1bebab6974932668b19c4ec52cb15b638c163f5", "patch": "@@ -1529,12 +1529,9 @@\n \t\t (match_operand:DI 2 \"arith_operand\")))]\n   \"\"\n {\n-  if (TARGET_SH1)\n-    {\n-      operands[2] = force_reg (DImode, operands[2]);\n-      emit_insn (gen_adddi3_compact (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n+  operands[2] = force_reg (DImode, operands[2]);\n+  emit_insn (gen_adddi3_compact (operands[0], operands[1], operands[2]));\n+  DONE;\n })\n \n (define_insn_and_split \"adddi3_compact\"\n@@ -1780,7 +1777,7 @@\n \t\t (match_operand:SI 2 \"arith_or_int_operand\")))]\n   \"\"\n {\n-  if (TARGET_SH1 && !arith_operand (operands[2], SImode))\n+  if (!arith_operand (operands[2], SImode))\n     {\n       if (!sh_lra_p () || reg_overlap_mentioned_p (operands[0], operands[1]))\n \t{\n@@ -1935,12 +1932,9 @@\n \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"\")))]\n   \"\"\n {\n-  if (TARGET_SH1)\n-    {\n-      operands[1] = force_reg (DImode, operands[1]);\n-      emit_insn (gen_subdi3_compact (operands[0], operands[1], operands[2]));\n-      DONE;\n-    }\n+  operands[1] = force_reg (DImode, operands[1]);\n+  emit_insn (gen_subdi3_compact (operands[0], operands[1], operands[2]));\n+  DONE;\n })\n \n (define_insn_and_split \"subdi3_compact\"\n@@ -2165,7 +2159,7 @@\n \t\t  (match_operand:SI 2 \"arith_reg_operand\" \"\")))]\n   \"\"\n {\n-  if (TARGET_SH1 && CONST_INT_P (operands[1]))\n+  if (CONST_INT_P (operands[1]))\n     {\n       emit_insn (gen_negsi2 (operands[0], operands[2]));\n       emit_insn (gen_addsi3 (operands[0], operands[0], operands[1]));\n@@ -2840,20 +2834,18 @@\n      Ideally the splitter of *andsi_compact would be enough, if redundant\n      zero extensions were detected after the combine pass, which does not\n      happen at the moment.  */\n-  if (TARGET_SH1)\n+\n+  if (satisfies_constraint_Jmb (operands[2]))\n     {\n-      if (satisfies_constraint_Jmb (operands[2]))\n-\t{\n-\t  emit_insn (gen_zero_extendqisi2 (operands[0],\n-\t\t\t\t\t   gen_lowpart (QImode, operands[1])));\n-\t  DONE;\n-\t}\n-      else if (satisfies_constraint_Jmw (operands[2]))\n-\t{\n-\t  emit_insn (gen_zero_extendhisi2 (operands[0],\n-\t\t\t\t\t   gen_lowpart (HImode, operands[1])));\n-\t  DONE;\n-\t}\n+      emit_insn (gen_zero_extendqisi2 (operands[0],\n+\t\t\t\t\tgen_lowpart (QImode, operands[1])));\n+      DONE;\n+    }\n+  else if (satisfies_constraint_Jmw (operands[2]))\n+    {\n+      emit_insn (gen_zero_extendhisi2 (operands[0],\n+\t\t\t\t       gen_lowpart (HImode, operands[1])));\n+      DONE;\n     }\n })\n \n@@ -5565,23 +5557,19 @@\n   \"\"\n {\n   prepare_move_operands (operands, DImode);\n-  if (TARGET_SH1)\n-    {\n-      /* When the dest operand is (R0, R1) register pair, split it to\n-\t two movsi of which dest is R1 and R0 so as to lower R0-register\n-\t pressure on the first movsi.  Apply only for simple source not\n-\t to make complex rtl here.  */\n-      if (REG_P (operands[0])\n-\t  && REGNO (operands[0]) == R0_REG\n-\t  && REG_P (operands[1])\n-\t  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  emit_insn (gen_movsi (gen_rtx_REG (SImode, R1_REG),\n-\t\t\t        gen_rtx_SUBREG (SImode, operands[1], 4)));\n-\t  emit_insn (gen_movsi (gen_rtx_REG (SImode, R0_REG),\n-\t\t\t        gen_rtx_SUBREG (SImode, operands[1], 0)));\n-\t  DONE;\n-\t}\n+\n+  /* When the dest operand is (R0, R1) register pair, split it to\n+     two movsi of which dest is R1 and R0 so as to lower R0-register\n+     pressure on the first movsi.  Apply only for simple source not\n+     to make complex rtl here.  */\n+  if (REG_P (operands[0]) && REGNO (operands[0]) == R0_REG\n+      && REG_P (operands[1]) && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      emit_insn (gen_movsi (gen_rtx_REG (SImode, R1_REG),\n+\t\t\t    gen_rtx_SUBREG (SImode, operands[1], 4)));\n+      emit_insn (gen_movsi (gen_rtx_REG (SImode, R0_REG),\n+\t\t\t    gen_rtx_SUBREG (SImode, operands[1], 0)));\n+      DONE;\n     }\n })\n "}]}