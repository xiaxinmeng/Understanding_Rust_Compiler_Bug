{"sha": "42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJmMTFlNGMyNmE4MjRjMmZhNGI4ZjliZmM5ZTRhZjY5ZmU4NmRjOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T10:18:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T10:18:12Z"}, "message": "[multiple changes]\n\n2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_prag.adb, comperr.adb: Minor reformatting.\n\n2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_pakd.adb (Rj_Unchecked_Convert_To): Do not perform an\n\tunchecked conversion if the source size is 0 (indicating that\n\tits RM size is unknown). This will happen with packed arrays of\n\tnon-discrete types, in which case the component type is known\n\tto match.\n\n2016-05-02  Arnaud Charlet  <charlet@adacore.com>\n\n\t* debug.adb: Reserve -gnatd.V.\n\n2016-05-02  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch3.adb (Process_Full_View): Remove from visibility\n\twrappers of synchronized types to avoid spurious errors with\n\ttheir wrapped entity.\n\t* exp_ch9.adb (Build_Wrapper_Spec): Do not generate the wrapper\n\tif no interface primitive is covered by the subprogram and this is\n\tnot a primitive declared between two views; see Process_Full_View.\n\t(Build_Protected_Sub_Specification): Link the dispatching\n\tsubprogram with its original non-dispatching protected subprogram\n\tsince their names differ.\n\t(Expand_N_Protected_Type_Declaration):\n\tIf a protected subprogram overrides an interface primitive then\n\tdo not build a wrapper if it was already built.\n\t* einfo.ads, einfo.adb (Original_Protected_Subprogram): New attribute.\n\t* sem_ch4.adb (Names_Match): New subprogram.\n\t* sem_ch6.adb (Check_Synchronized_Overriding): Moved\n\tto library level and defined in the public part of the\n\tpackage to invoke it from Exp_Ch9.Build_Wrapper_Spec\n\t(Has_Matching_Entry_Or_Subprogram): New subprogram.\n\t(Report_Conflict): New subprogram.\n\nFrom-SVN: r235739", "tree": {"sha": "dbb33c2ad4d55daac28792110fc46b320436430c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbb33c2ad4d55daac28792110fc46b320436430c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/comments", "author": null, "committer": null, "parents": [{"sha": "331e50151c7fbc9931899d0c10fa5fed7be4f8be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331e50151c7fbc9931899d0c10fa5fed7be4f8be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/331e50151c7fbc9931899d0c10fa5fed7be4f8be"}], "stats": {"total": 1162, "additions": 791, "deletions": 371}, "files": [{"sha": "8acbbb3ec325d4e6f72412a7bdde669cdd41c34e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -1,3 +1,41 @@\n+2016-05-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_prag.adb, comperr.adb: Minor reformatting.\n+\n+2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_pakd.adb (Rj_Unchecked_Convert_To): Do not perform an\n+\tunchecked conversion if the source size is 0 (indicating that\n+\tits RM size is unknown). This will happen with packed arrays of\n+\tnon-discrete types, in which case the component type is known\n+\tto match.\n+\n+2016-05-02  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* debug.adb: Reserve -gnatd.V.\n+\n+2016-05-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch3.adb (Process_Full_View): Remove from visibility\n+\twrappers of synchronized types to avoid spurious errors with\n+\ttheir wrapped entity.\n+\t* exp_ch9.adb (Build_Wrapper_Spec): Do not generate the wrapper\n+\tif no interface primitive is covered by the subprogram and this is\n+\tnot a primitive declared between two views; see Process_Full_View.\n+\t(Build_Protected_Sub_Specification): Link the dispatching\n+\tsubprogram with its original non-dispatching protected subprogram\n+\tsince their names differ.\n+\t(Expand_N_Protected_Type_Declaration):\n+\tIf a protected subprogram overrides an interface primitive then\n+\tdo not build a wrapper if it was already built.\n+\t* einfo.ads, einfo.adb (Original_Protected_Subprogram): New attribute.\n+\t* sem_ch4.adb (Names_Match): New subprogram.\n+\t* sem_ch6.adb (Check_Synchronized_Overriding): Moved\n+\tto library level and defined in the public part of the\n+\tpackage to invoke it from Exp_Ch9.Build_Wrapper_Spec\n+\t(Has_Matching_Entry_Or_Subprogram): New subprogram.\n+\t(Report_Conflict): New subprogram.\n+\n 2016-05-02  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* s-unstyp.ads: Code cleanups."}, {"sha": "f7061d51c2941d239096e0bbaea08f43c287772e", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -467,8 +467,9 @@ package body Comperr is\n       Main := Unit (Cunit (Main_Unit));\n \n       case Nkind (Main) is\n-         when N_Subprogram_Declaration | N_Subprogram_Body |\n-              N_Package_Declaration =>\n+         when N_Package_Declaration    |\n+              N_Subprogram_Body        |\n+              N_Subprogram_Declaration =>\n             Unit_Name := Defining_Unit_Name (Specification (Main));\n \n          when N_Package_Body =>"}, {"sha": "a4e83a9fad759156a6bea98fd48c803180790149", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -139,7 +139,7 @@ package body Debug is\n    --  d.S  Force Optimize_Alignment (Space)\n    --  d.T  Force Optimize_Alignment (Time)\n    --  d.U  Ignore indirect calls for static elaboration\n-   --  d.V\n+   --  d.V  Do not verify validity of SCIL files (CodePeer mode)\n    --  d.W  Print out debugging information for Walk_Library_Items\n    --  d.X  Old treatment of indexing aspects\n    --  d.Y\n@@ -686,6 +686,12 @@ package body Debug is\n    --       reverts to the behavior of earlier compilers, which ignored\n    --       indirect calls.\n \n+   --  d.V  Do not verify the validity of SCIL files (CodePeer mode). When\n+   --       generating SCIL files for CodePeer, by default we verify that the\n+   --       SCIL is well formed before saving it on disk. This switch can be\n+   --       used to disable this checking, either to improve speed or to shut\n+   --       down a false positive detected during the verification.\n+\n    --  d.W  Print out debugging information for Walk_Library_Items, including\n    --       the order in which units are walked. This is primarily for use in\n    --       debugging CodePeer mode."}, {"sha": "e66ca79aa7ce1a209631306d85ab10d0f245278b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -274,6 +274,7 @@ package body Einfo is\n \n    --    SPARK_Pragma                    Node40\n \n+   --    Original_Protected_Subprogram   Node41\n    --    SPARK_Aux_Pragma                Node41\n \n    ---------------------------------------------\n@@ -2837,6 +2838,11 @@ package body Einfo is\n       return Node21 (Id);\n    end Original_Array_Type;\n \n+   function Original_Protected_Subprogram (Id : E) return N is\n+   begin\n+      return Node41 (Id);\n+   end Original_Protected_Subprogram;\n+\n    function Original_Record_Component (Id : E) return E is\n    begin\n       pragma Assert (Ekind_In (Id, E_Void, E_Component, E_Discriminant));\n@@ -5900,6 +5906,12 @@ package body Einfo is\n       Set_Node21 (Id, V);\n    end Set_Original_Array_Type;\n \n+   procedure Set_Original_Protected_Subprogram (Id : E; V : N) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Procedure, E_Function));\n+      Set_Node41 (Id, V);\n+   end Set_Original_Protected_Subprogram;\n+\n    procedure Set_Original_Record_Component (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Void, E_Component, E_Discriminant));\n@@ -10483,6 +10495,10 @@ package body Einfo is\n               E_Task_Type                                  =>\n             Write_Str (\"SPARK_Aux_Pragma\");\n \n+         when E_Function                                   |\n+              E_Procedure                                  =>\n+            Write_Str (\"Original_Protected_Subprogram\");\n+\n          when others                                       =>\n             Write_Str (\"Field41??\");\n       end case;"}, {"sha": "901e2ef937ea2f39cdd5c5ce2115970100967610", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -3647,6 +3647,11 @@ package Einfo is\n --       points to the original array type for which this is the packed\n --       array implementation type.\n \n+--    Original_Protected_Subprogram (Node41)\n+--       Defined in functions and procedures. Set only on internally built\n+--       dispatching subprograms of protected types to reference their original\n+--       non-dispatching protected subprogram since their names differ.\n+\n --    Original_Record_Component (Node22)\n --       Defined in components, including discriminants. The usage depends\n --       on whether the record is a base type and whether it is tagged.\n@@ -5923,6 +5928,7 @@ package Einfo is\n    --    Class_Wide_Preconds                 (List38)\n    --    Class_Wide_Postconds                (List39)\n    --    SPARK_Pragma                        (Node40)\n+   --    Original_Protected_Subprogram       (Node41)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Default_Expressions_Processed       (Flag108)\n@@ -6234,6 +6240,7 @@ package Einfo is\n    --    Class_Wide_Preconds                 (List38)\n    --    Class_Wide_Postconds                (List39)\n    --    SPARK_Pragma                        (Node40)\n+   --    Original_Protected_Subprogram       (Node41)\n    --    Body_Needed_For_SAL                 (Flag40)\n    --    Contains_Ignored_Ghost_Code         (Flag279)\n    --    Delay_Cleanups                      (Flag114)\n@@ -7127,6 +7134,7 @@ package Einfo is\n    function Optimize_Alignment_Time             (Id : E) return B;\n    function Original_Access_Type                (Id : E) return E;\n    function Original_Array_Type                 (Id : E) return E;\n+   function Original_Protected_Subprogram       (Id : E) return N;\n    function Original_Record_Component           (Id : E) return E;\n    function Overlays_Constant                   (Id : E) return B;\n    function Overridden_Operation                (Id : E) return E;\n@@ -7801,6 +7809,7 @@ package Einfo is\n    procedure Set_Optimize_Alignment_Time         (Id : E; V : B := True);\n    procedure Set_Original_Access_Type            (Id : E; V : E);\n    procedure Set_Original_Array_Type             (Id : E; V : E);\n+   procedure Set_Original_Protected_Subprogram   (Id : E; V : N);\n    procedure Set_Original_Record_Component       (Id : E; V : E);\n    procedure Set_Overlays_Constant               (Id : E; V : B := True);\n    procedure Set_Overridden_Operation            (Id : E; V : E);\n@@ -8628,6 +8637,7 @@ package Einfo is\n    pragma Inline (Optimize_Alignment_Time);\n    pragma Inline (Original_Access_Type);\n    pragma Inline (Original_Array_Type);\n+   pragma Inline (Original_Protected_Subprogram);\n    pragma Inline (Original_Record_Component);\n    pragma Inline (Overlays_Constant);\n    pragma Inline (Overridden_Operation);\n@@ -9093,6 +9103,7 @@ package Einfo is\n    pragma Inline (Set_Optimize_Alignment_Time);\n    pragma Inline (Set_Original_Access_Type);\n    pragma Inline (Set_Original_Array_Type);\n+   pragma Inline (Set_Original_Protected_Subprogram);\n    pragma Inline (Set_Original_Record_Component);\n    pragma Inline (Set_Overlays_Constant);\n    pragma Inline (Set_Overridden_Operation);"}, {"sha": "e48b983906460331f832d37038f05cc8ed8a35f2", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 71, "deletions": 50, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2443,13 +2443,6 @@ package body Exp_Ch9 is\n       Obj_Typ : Entity_Id;\n       Formals : List_Id) return Node_Id\n    is\n-      Loc           : constant Source_Ptr := Sloc (Subp_Id);\n-      First_Param   : Node_Id;\n-      Iface         : Entity_Id;\n-      Iface_Elmt    : Elmt_Id;\n-      Iface_Op      : Entity_Id;\n-      Iface_Op_Elmt : Elmt_Id;\n-\n       function Overriding_Possible\n         (Iface_Op : Entity_Id;\n          Wrapper  : Entity_Id) return Boolean;\n@@ -2631,24 +2624,41 @@ package body Exp_Ch9 is\n          return New_Formals;\n       end Replicate_Formals;\n \n+      --  Local variables\n+\n+      Loc             : constant Source_Ptr := Sloc (Subp_Id);\n+      First_Param     : Node_Id := Empty;\n+      Iface           : Entity_Id;\n+      Iface_Elmt      : Elmt_Id;\n+      Iface_Op        : Entity_Id;\n+      Iface_Op_Elmt   : Elmt_Id;\n+      Overridden_Subp : Entity_Id;\n+\n    --  Start of processing for Build_Wrapper_Spec\n \n    begin\n       --  No point in building wrappers for untagged concurrent types\n \n       pragma Assert (Is_Tagged_Type (Obj_Typ));\n \n+      --  Check if this subprogram has a profile that matches some interface\n+      --  primitive\n+\n+      Check_Synchronized_Overriding (Subp_Id, Overridden_Subp);\n+\n+      if Present (Overridden_Subp) then\n+         First_Param :=\n+           First (Parameter_Specifications (Parent (Overridden_Subp)));\n+\n       --  An entry or a protected procedure can override a routine where the\n       --  controlling formal is either IN OUT, OUT or is of access-to-variable\n       --  type. Since the wrapper must have the exact same signature as that of\n       --  the overridden subprogram, we try to find the overriding candidate\n       --  and use its controlling formal.\n \n-      First_Param := Empty;\n-\n       --  Check every implemented interface\n \n-      if Present (Interfaces (Obj_Typ)) then\n+      elsif Present (Interfaces (Obj_Typ)) then\n          Iface_Elmt := First_Elmt (Interfaces (Obj_Typ));\n          Search : while Present (Iface_Elmt) loop\n             Iface := Node (Iface_Elmt);\n@@ -2684,40 +2694,14 @@ package body Exp_Ch9 is\n          end loop Search;\n       end if;\n \n-      --  Ada 2012 (AI05-0090-1): If no interface primitive is covered by\n-      --  this subprogram and this is not a primitive declared between two\n-      --  views then force the generation of a wrapper. As an optimization,\n-      --  previous versions of the frontend avoid generating the wrapper;\n-      --  however, the wrapper facilitates locating and reporting an error\n-      --  when a duplicate declaration is found later. See example in\n-      --  AI05-0090-1.\n+      --  Do not generate the wrapper if no interface primitive is covered by\n+      --  the subprogram and it is not a primitive declared declared between\n+      --  two views (see Process_Full_View).\n \n       if No (First_Param)\n         and then not Is_Private_Primitive_Subprogram (Subp_Id)\n       then\n-         if Is_Task_Type\n-              (Corresponding_Concurrent_Type (Obj_Typ))\n-         then\n-            First_Param :=\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Make_Defining_Identifier (Loc, Name_uO),\n-                In_Present          => True,\n-                Out_Present         => False,\n-                Parameter_Type      => New_Occurrence_Of (Obj_Typ, Loc));\n-\n-         --  For entries and procedures of protected types the mode of\n-         --  the controlling argument must be in-out.\n-\n-         else\n-            First_Param :=\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Loc,\n-                    Chars => Name_uO),\n-                In_Present     => True,\n-                Out_Present    => (Ekind (Subp_Id) /= E_Function),\n-                Parameter_Type => New_Occurrence_Of (Obj_Typ, Loc));\n-         end if;\n+         return Empty;\n       end if;\n \n       declare\n@@ -4229,6 +4213,15 @@ package body Exp_Ch9 is\n         Make_Defining_Identifier (Loc,\n           Chars => Build_Selected_Name (Prot_Typ, Def_Id, Append_Chr (Mode)));\n \n+      --  Reference the original non-dispatching subprogram since the analysis\n+      --  of the object.operation notation may need its original name (see\n+      --  Sem_Ch4.Names_Match).\n+\n+      if Mode = Dispatching_Mode then\n+         Set_Ekind (New_Id, Ekind (Def_Id));\n+         Set_Original_Protected_Subprogram (New_Id, Def_Id);\n+      end if;\n+\n       --  The unprotected operation carries the user code, and debugging\n       --  information must be generated for it, even though this spec does\n       --  not come from source. It is also convenient to allow gdb to step\n@@ -9653,22 +9646,50 @@ package body Exp_Ch9 is\n             Current_Node := Sub;\n \n             --  Generate an overriding primitive operation specification for\n-            --  this subprogram if the protected type implements an interface.\n+            --  this subprogram if the protected type implements an interface\n+            --  and Build_Wrapper_Spec did not not generate its wrapper.\n \n             if Ada_Version >= Ada_2005\n               and then\n                 Present (Interfaces (Corresponding_Record_Type (Prot_Typ)))\n             then\n-               Sub :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Specification =>\n-                     Build_Protected_Sub_Specification\n-                       (Comp, Prot_Typ, Dispatching_Mode));\n+               declare\n+                  Prim_Elmt : Elmt_Id;\n+                  Prim_Op   : Node_Id;\n+                  Found     : Boolean := False;\n \n-               Insert_After (Current_Node, Sub);\n-               Analyze (Sub);\n+               begin\n+                  Prim_Elmt :=\n+                    First_Elmt\n+                      (Primitive_Operations\n+                         (Corresponding_Record_Type (Prot_Typ)));\n \n-               Current_Node := Sub;\n+                  while Present (Prim_Elmt) loop\n+                     Prim_Op := Node (Prim_Elmt);\n+\n+                     if Is_Primitive_Wrapper (Prim_Op)\n+                       and then (Wrapped_Entity (Prim_Op))\n+                                   = Defining_Entity (Specification (Comp))\n+                     then\n+                        Found := True;\n+                        exit;\n+                     end if;\n+\n+                     Next_Elmt (Prim_Elmt);\n+                  end loop;\n+\n+                  if not Found then\n+                     Sub :=\n+                       Make_Subprogram_Declaration (Loc,\n+                         Specification =>\n+                           Build_Protected_Sub_Specification\n+                             (Comp, Prot_Typ, Dispatching_Mode));\n+                     Insert_After (Current_Node, Sub);\n+                     Analyze (Sub);\n+\n+                     Current_Node := Sub;\n+                  end if;\n+               end;\n             end if;\n \n             --  If a pragma Interrupt_Handler applies, build and add a call to"}, {"sha": "ea82596b820665d6df6d2d60a1d75afdc6178d06", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -2298,9 +2298,12 @@ package body Exp_Pakd is\n       --  convert to a modular type of the source length, since otherwise, on\n       --  a big-endian machine, we get left-justification. We do it for little-\n       --  endian machines as well, because there might be junk bits that are\n-      --  not cleared if the type is not numeric.\n+      --  not cleared if the type is not numeric. This can be done only if the\n+      --  source siz is different from 0 (i.e. known), otherwise we must trust\n+      --  the type declarations (case of non-discrete components).\n \n-      if Source_Siz /= Target_Siz\n+      if Source_Siz /= 0\n+        and then Source_Siz /= Target_Siz\n         and then not Is_Discrete_Type (Source_Typ)\n       then\n          Src := Unchecked_Convert_To (RTE (Bits_Id (Source_Siz)), Src);"}, {"sha": "62de26ba02620839ec6af5c896f895a084802db9", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -884,8 +884,8 @@ package body Exp_Prag is\n                   Set_Expression (Decl, Pref);\n                   Analyze (Decl);\n \n-                  --  Otherwise add an assignment  statement to temporary\n-                  --  using prefix as RHS.\n+               --  Otherwise add an assignment statement to temporary using\n+               --  prefix as RHS.\n \n                else\n                   Analyze (Decl);"}, {"sha": "df0293c8525b4ba2229b413fd5e9f57afc633ac3", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -19835,6 +19835,13 @@ package body Sem_Ch3 is\n                            Curr_Nod := Wrap_Spec;\n \n                            Analyze (Wrap_Spec);\n+\n+                           --  Remove the wrapper from visibility to avoid\n+                           --  spurious conflict with the wrapped entity.\n+\n+                           Set_Is_Immediately_Visible\n+                             (Defining_Entity (Specification (Wrap_Spec)),\n+                              False);\n                         end if;\n \n                         Next_Elmt (Prim_Elmt);"}, {"sha": "73fa52199caabcc2978553bbe8a37d77a13f84ea", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -8817,6 +8817,15 @@ package body Sem_Ch4 is\n          --  is visible a direct call to it will dispatch to the private one,\n          --  which is therefore a valid candidate.\n \n+         function Names_Match\n+           (Obj_Type : Entity_Id;\n+            Prim_Op  : Entity_Id;\n+            Subprog  : Entity_Id) return Boolean;\n+         --  Return True if the names of Prim_Op and Subprog match. If Obj_Type\n+         --  is a protected type then compare also the original name of Prim_Op\n+         --  with the name of Subprog (since the expander may have added a\n+         --  prefix to its original name --see Exp_Ch9.Build_Selected_Name).\n+\n          function Valid_First_Argument_Of (Op : Entity_Id) return Boolean;\n          --  Verify that the prefix, dereferenced if need be, is a valid\n          --  controlling argument in a call to Op. The remaining actuals\n@@ -8993,6 +9002,34 @@ package body Sem_Ch4 is\n               and then not Is_Hidden (Visible_Op);\n          end Is_Private_Overriding;\n \n+         -----------------\n+         -- Names_Match --\n+         -----------------\n+\n+         function Names_Match\n+           (Obj_Type : Entity_Id;\n+            Prim_Op  : Entity_Id;\n+            Subprog  : Entity_Id) return Boolean is\n+         begin\n+            --  Common case: exact match\n+\n+            if Chars (Prim_Op) = Chars (Subprog) then\n+               return True;\n+\n+            --  For protected type primitives the expander may have built the\n+            --  name of the dispatching primitive prepending the type name to\n+            --  avoid conflicts with the name of the protected subprogram (see\n+            --  Exp_Ch9.Build_Selected_Name).\n+\n+            elsif Is_Protected_Type (Obj_Type) then\n+               return Present (Original_Protected_Subprogram (Prim_Op))\n+                 and then Chars (Original_Protected_Subprogram (Prim_Op))\n+                            = Chars (Subprog);\n+            end if;\n+\n+            return False;\n+         end Names_Match;\n+\n          -----------------------------\n          -- Valid_First_Argument_Of --\n          -----------------------------\n@@ -9059,7 +9096,7 @@ package body Sem_Ch4 is\n          while Present (Elmt) loop\n             Prim_Op := Node (Elmt);\n \n-            if Chars (Prim_Op) = Chars (Subprog)\n+            if Names_Match (Obj_Type, Prim_Op, Subprog)\n               and then Present (First_Formal (Prim_Op))\n               and then Valid_First_Argument_Of (Prim_Op)\n               and then"}, {"sha": "d7647a3c1bfa3c50caf02a8cf15d32fbe0de89ed", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 583, "deletions": 312, "changes": 895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -6463,6 +6463,341 @@ package body Sem_Ch6 is\n          Get_Inst                 => Get_Inst);\n    end Check_Subtype_Conformant;\n \n+   -----------------------------------\n+   -- Check_Synchronized_Overriding --\n+   -----------------------------------\n+\n+   procedure Check_Synchronized_Overriding\n+     (Def_Id          : Entity_Id;\n+      Overridden_Subp : out Entity_Id)\n+   is\n+      Ifaces_List : Elist_Id;\n+      In_Scope    : Boolean;\n+      Typ         : Entity_Id;\n+\n+      function Matches_Prefixed_View_Profile\n+        (Prim_Params  : List_Id;\n+         Iface_Params : List_Id) return Boolean;\n+      --  Determine whether a subprogram's parameter profile Prim_Params\n+      --  matches that of a potentially overridden interface subprogram\n+      --  Iface_Params. Also determine if the type of first parameter of\n+      --  Iface_Params is an implemented interface.\n+\n+      -----------------------------------\n+      -- Matches_Prefixed_View_Profile --\n+      -----------------------------------\n+\n+      function Matches_Prefixed_View_Profile\n+        (Prim_Params  : List_Id;\n+         Iface_Params : List_Id) return Boolean\n+      is\n+         Iface_Id     : Entity_Id;\n+         Iface_Param  : Node_Id;\n+         Iface_Typ    : Entity_Id;\n+         Prim_Id      : Entity_Id;\n+         Prim_Param   : Node_Id;\n+         Prim_Typ     : Entity_Id;\n+\n+         function Is_Implemented\n+           (Ifaces_List : Elist_Id;\n+            Iface       : Entity_Id) return Boolean;\n+         --  Determine if Iface is implemented by the current task or\n+         --  protected type.\n+\n+         --------------------\n+         -- Is_Implemented --\n+         --------------------\n+\n+         function Is_Implemented\n+           (Ifaces_List : Elist_Id;\n+            Iface       : Entity_Id) return Boolean\n+         is\n+            Iface_Elmt : Elmt_Id;\n+\n+         begin\n+            Iface_Elmt := First_Elmt (Ifaces_List);\n+            while Present (Iface_Elmt) loop\n+               if Node (Iface_Elmt) = Iface then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+\n+            return False;\n+         end Is_Implemented;\n+\n+      --  Start of processing for Matches_Prefixed_View_Profile\n+\n+      begin\n+         Iface_Param := First (Iface_Params);\n+         Iface_Typ   := Etype (Defining_Identifier (Iface_Param));\n+\n+         if Is_Access_Type (Iface_Typ) then\n+            Iface_Typ := Designated_Type (Iface_Typ);\n+         end if;\n+\n+         Prim_Param := First (Prim_Params);\n+\n+         --  The first parameter of the potentially overridden subprogram\n+         --  must be an interface implemented by Prim.\n+\n+         if not Is_Interface (Iface_Typ)\n+           or else not Is_Implemented (Ifaces_List, Iface_Typ)\n+         then\n+            return False;\n+         end if;\n+\n+         --  The checks on the object parameters are done, move onto the\n+         --  rest of the parameters.\n+\n+         if not In_Scope then\n+            Prim_Param := Next (Prim_Param);\n+         end if;\n+\n+         Iface_Param := Next (Iface_Param);\n+         while Present (Iface_Param) and then Present (Prim_Param) loop\n+            Iface_Id  := Defining_Identifier (Iface_Param);\n+            Iface_Typ := Find_Parameter_Type (Iface_Param);\n+\n+            Prim_Id  := Defining_Identifier (Prim_Param);\n+            Prim_Typ := Find_Parameter_Type (Prim_Param);\n+\n+            if Ekind (Iface_Typ) = E_Anonymous_Access_Type\n+              and then Ekind (Prim_Typ) = E_Anonymous_Access_Type\n+              and then Is_Concurrent_Type (Designated_Type (Prim_Typ))\n+            then\n+               Iface_Typ := Designated_Type (Iface_Typ);\n+               Prim_Typ := Designated_Type (Prim_Typ);\n+            end if;\n+\n+            --  Case of multiple interface types inside a parameter profile\n+\n+            --     (Obj_Param : in out Iface; ...; Param : Iface)\n+\n+            --  If the interface type is implemented, then the matching type\n+            --  in the primitive should be the implementing record type.\n+\n+            if Ekind (Iface_Typ) = E_Record_Type\n+              and then Is_Interface (Iface_Typ)\n+              and then Is_Implemented (Ifaces_List, Iface_Typ)\n+            then\n+               if Prim_Typ /= Typ then\n+                  return False;\n+               end if;\n+\n+            --  The two parameters must be both mode and subtype conformant\n+\n+            elsif Ekind (Iface_Id) /= Ekind (Prim_Id)\n+              or else not\n+                Conforming_Types (Iface_Typ, Prim_Typ, Subtype_Conformant)\n+            then\n+               return False;\n+            end if;\n+\n+            Next (Iface_Param);\n+            Next (Prim_Param);\n+         end loop;\n+\n+         --  One of the two lists contains more parameters than the other\n+\n+         if Present (Iface_Param) or else Present (Prim_Param) then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Matches_Prefixed_View_Profile;\n+\n+   --  Start of processing for Check_Synchronized_Overriding\n+\n+   begin\n+      Overridden_Subp := Empty;\n+\n+      --  Def_Id must be an entry or a subprogram. We should skip predefined\n+      --  primitives internally generated by the frontend; however at this\n+      --  stage predefined primitives are still not fully decorated. As a\n+      --  minor optimization we skip here internally generated subprograms.\n+\n+      if (Ekind (Def_Id) /= E_Entry\n+           and then Ekind (Def_Id) /= E_Function\n+           and then Ekind (Def_Id) /= E_Procedure)\n+        or else not Comes_From_Source (Def_Id)\n+      then\n+         return;\n+      end if;\n+\n+      --  Search for the concurrent declaration since it contains the list\n+      --  of all implemented interfaces. In this case, the subprogram is\n+      --  declared within the scope of a protected or a task type.\n+\n+      if Present (Scope (Def_Id))\n+        and then Is_Concurrent_Type (Scope (Def_Id))\n+        and then not Is_Generic_Actual_Type (Scope (Def_Id))\n+      then\n+         Typ := Scope (Def_Id);\n+         In_Scope := True;\n+\n+      --  The enclosing scope is not a synchronized type and the subprogram\n+      --  has no formals.\n+\n+      elsif No (First_Formal (Def_Id)) then\n+         return;\n+\n+      --  The subprogram has formals and hence it may be a primitive of a\n+      --  concurrent type.\n+\n+      else\n+         Typ := Etype (First_Formal (Def_Id));\n+\n+         if Is_Access_Type (Typ) then\n+            Typ := Directly_Designated_Type (Typ);\n+         end if;\n+\n+         if Is_Concurrent_Type (Typ)\n+           and then not Is_Generic_Actual_Type (Typ)\n+         then\n+            In_Scope := False;\n+\n+         --  This case occurs when the concurrent type is declared within\n+         --  a generic unit. As a result the corresponding record has been\n+         --  built and used as the type of the first formal, we just have\n+         --  to retrieve the corresponding concurrent type.\n+\n+         elsif Is_Concurrent_Record_Type (Typ)\n+           and then not Is_Class_Wide_Type (Typ)\n+           and then Present (Corresponding_Concurrent_Type (Typ))\n+         then\n+            Typ := Corresponding_Concurrent_Type (Typ);\n+            In_Scope := False;\n+\n+         else\n+            return;\n+         end if;\n+      end if;\n+\n+      --  There is no overriding to check if is an inherited operation in a\n+      --  type derivation on for a generic actual.\n+\n+      Collect_Interfaces (Typ, Ifaces_List);\n+\n+      if Is_Empty_Elmt_List (Ifaces_List) then\n+         return;\n+      end if;\n+\n+      --  Determine whether entry or subprogram Def_Id overrides a primitive\n+      --  operation that belongs to one of the interfaces in Ifaces_List.\n+\n+      declare\n+         Candidate : Entity_Id := Empty;\n+         Hom       : Entity_Id := Empty;\n+         Subp      : Entity_Id := Empty;\n+\n+      begin\n+         --  Traverse the homonym chain, looking for a potentially\n+         --  overridden subprogram that belongs to an implemented\n+         --  interface.\n+\n+         Hom := Current_Entity_In_Scope (Def_Id);\n+         while Present (Hom) loop\n+            Subp := Hom;\n+\n+            if Subp = Def_Id\n+              or else not Is_Overloadable (Subp)\n+              or else not Is_Primitive (Subp)\n+              or else not Is_Dispatching_Operation (Subp)\n+              or else not Present (Find_Dispatching_Type (Subp))\n+              or else not Is_Interface (Find_Dispatching_Type (Subp))\n+            then\n+               null;\n+\n+            --  Entries and procedures can override abstract or null\n+            --  interface procedures.\n+\n+            elsif (Ekind (Def_Id) = E_Procedure\n+                    or else Ekind (Def_Id) = E_Entry)\n+              and then Ekind (Subp) = E_Procedure\n+              and then Matches_Prefixed_View_Profile\n+                         (Parameter_Specifications (Parent (Def_Id)),\n+                          Parameter_Specifications (Parent (Subp)))\n+            then\n+               Candidate := Subp;\n+\n+               --  For an overridden subprogram Subp, check whether the mode\n+               --  of its first parameter is correct depending on the kind\n+               --  of synchronized type.\n+\n+               declare\n+                  Formal : constant Node_Id := First_Formal (Candidate);\n+\n+               begin\n+                  --  In order for an entry or a protected procedure to\n+                  --  override, the first parameter of the overridden\n+                  --  routine must be of mode \"out\", \"in out\" or\n+                  --  access-to-variable.\n+\n+                  if Ekind_In (Candidate, E_Entry, E_Procedure)\n+                    and then Is_Protected_Type (Typ)\n+                    and then Ekind (Formal) /= E_In_Out_Parameter\n+                    and then Ekind (Formal) /= E_Out_Parameter\n+                    and then Nkind (Parameter_Type (Parent (Formal))) /=\n+                                                       N_Access_Definition\n+                  then\n+                     null;\n+\n+                  --  All other cases are OK since a task entry or routine\n+                  --  does not have a restriction on the mode of the first\n+                  --  parameter of the overridden interface routine.\n+\n+                  else\n+                     Overridden_Subp := Candidate;\n+                     return;\n+                  end if;\n+               end;\n+\n+            --  Functions can override abstract interface functions\n+\n+            elsif Ekind (Def_Id) = E_Function\n+              and then Ekind (Subp) = E_Function\n+              and then Matches_Prefixed_View_Profile\n+                         (Parameter_Specifications (Parent (Def_Id)),\n+                          Parameter_Specifications (Parent (Subp)))\n+              and then Etype (Result_Definition (Parent (Def_Id))) =\n+                       Etype (Result_Definition (Parent (Subp)))\n+            then\n+               Candidate := Subp;\n+\n+               --  If an inherited subprogram is implemented by a protected\n+               --  function, then the first parameter of the inherited\n+               --  subprogram shall be of mode in, but not an\n+               --  access-to-variable parameter (RM 9.4(11/9)\n+\n+               if Present (First_Formal (Subp))\n+                 and then Ekind (First_Formal (Subp)) = E_In_Parameter\n+                 and then\n+                   (not Is_Access_Type (Etype (First_Formal (Subp)))\n+                      or else\n+                    Is_Access_Constant (Etype (First_Formal (Subp))))\n+               then\n+                  Overridden_Subp := Subp;\n+                  return;\n+               end if;\n+            end if;\n+\n+            Hom := Homonym (Hom);\n+         end loop;\n+\n+         --  After examining all candidates for overriding, we are left with\n+         --  the best match which is a mode incompatible interface routine.\n+\n+         if In_Scope and then Present (Candidate) then\n+            Error_Msg_PT (Def_Id, Candidate);\n+         end if;\n+\n+         Overridden_Subp := Candidate;\n+         return;\n+      end;\n+   end Check_Synchronized_Overriding;\n+\n    ---------------------------\n    -- Check_Type_Conformant --\n    ---------------------------\n@@ -9000,14 +9335,14 @@ package body Sem_Ch6 is\n       --  type, and set Is_Primitive to True (otherwise set to False). Set the\n       --  corresponding flag on the entity itself for later use.\n \n-      procedure Check_Synchronized_Overriding\n-        (Def_Id          : Entity_Id;\n-         Overridden_Subp : out Entity_Id);\n-      --  First determine if Def_Id is an entry or a subprogram either defined\n-      --  in the scope of a task or protected type, or is a primitive of such\n-      --  a type. Check whether Def_Id overrides a subprogram of an interface\n-      --  implemented by the synchronized type, return the overridden entity\n-      --  or Empty.\n+      function Has_Matching_Entry_Or_Subprogram (E : Entity_Id) return Boolean;\n+      --  True if a) E is a subprogram whose first formal is a concurrent type\n+      --  defined in the scope of E that has some entry or subprogram whose\n+      --  profile matches E, or b) E is an internally built dispatching\n+      --  subprogram of a protected type and there is a matching subprogram\n+      --  defined in the enclosing scope of the protected type, or c) E is\n+      --  an entry of a synchronized type and a matching procedure has been\n+      --  previously defined in the enclosing scope of the synchronized type.\n \n       function Is_Private_Declaration (E : Entity_Id) return Boolean;\n       --  Check that E is declared in the private part of the current package,\n@@ -9025,6 +9360,9 @@ package body Sem_Ch6 is\n       --  function is conservative given that the converse is only true within\n       --  instances that contain accidental overloadings.\n \n+      procedure Report_Conflict (S : Entity_Id; E : Entity_Id);\n+      --  Report conflict between entities S and E.\n+\n       ------------------------------------\n       -- Check_For_Primitive_Subprogram --\n       ------------------------------------\n@@ -9350,340 +9688,256 @@ package body Sem_Ch6 is\n          end if;\n       end Check_For_Primitive_Subprogram;\n \n-      -----------------------------------\n-      -- Check_Synchronized_Overriding --\n-      -----------------------------------\n+      --------------------------------------\n+      -- Has_Matching_Entry_Or_Subprogram --\n+      --------------------------------------\n \n-      procedure Check_Synchronized_Overriding\n-        (Def_Id          : Entity_Id;\n-         Overridden_Subp : out Entity_Id)\n+      function Has_Matching_Entry_Or_Subprogram (E : Entity_Id) return Boolean\n       is\n-         Ifaces_List : Elist_Id;\n-         In_Scope    : Boolean;\n-         Typ         : Entity_Id;\n-\n-         function Matches_Prefixed_View_Profile\n-           (Prim_Params  : List_Id;\n-            Iface_Params : List_Id) return Boolean;\n-         --  Determine whether a subprogram's parameter profile Prim_Params\n-         --  matches that of a potentially overridden interface subprogram\n-         --  Iface_Params. Also determine if the type of first parameter of\n-         --  Iface_Params is an implemented interface.\n-\n-         -----------------------------------\n-         -- Matches_Prefixed_View_Profile --\n-         -----------------------------------\n-\n-         function Matches_Prefixed_View_Profile\n-           (Prim_Params  : List_Id;\n-            Iface_Params : List_Id) return Boolean\n+         function Check_Conforming_Parameters\n+           (E1_Param : Node_Id;\n+            E2_Param : Node_Id) return Boolean;\n+         --  Starting from the given parameters, check that all the parameters\n+         --  of two entries or subprograms are are subtype conformant. Used to\n+         --  skip the check on the controlling argument.\n+\n+         function Matching_Entry_Or_Subprogram\n+           (Conc_Typ : Entity_Id;\n+            Subp     : Entity_Id) return Entity_Id;\n+         --  Return the first entry or subprogram of the given concurrent type\n+         --  whose name matches the name of Subp and has a profile conformant\n+         --  with Subp; return Empty if not found.\n+\n+         function Matching_Dispatching_Subprogram\n+           (Conc_Typ : Entity_Id;\n+            Ent      : Entity_Id) return Entity_Id;\n+         --  Return the first dispatching primitive of Conc_Type defined in the\n+         --  enclosing scope of Conc_Type (ie. before the full definition of\n+         --  this concurrent type) whose name matches the entry Ent and has a\n+         --  profile conformant with the profile of the corresponding (not yet\n+         --  built) dispatching primitive of Ent; return Empty if not found.\n+\n+         function Matching_Original_Protected_Subprogram\n+           (Prot_Typ : Entity_Id;\n+            Subp     : Entity_Id) return Entity_Id;\n+         --  Return the first subprogram defined in the enclosing scope of\n+         --  Prot_Typ (before the full definition of this protected type)\n+         --  whose name matches the original name of Subp and has a profile\n+         --  conformant with the profile of Subp; return Empty if not found.\n+\n+         ---------------------------------\n+         -- Check_Confirming_Parameters --\n+         ---------------------------------\n+\n+         function Check_Conforming_Parameters\n+           (E1_Param : Node_Id;\n+            E2_Param : Node_Id) return Boolean\n          is\n-            Iface_Id     : Entity_Id;\n-            Iface_Param  : Node_Id;\n-            Iface_Typ    : Entity_Id;\n-            Prim_Id      : Entity_Id;\n-            Prim_Param   : Node_Id;\n-            Prim_Typ     : Entity_Id;\n-\n-            function Is_Implemented\n-              (Ifaces_List : Elist_Id;\n-               Iface       : Entity_Id) return Boolean;\n-            --  Determine if Iface is implemented by the current task or\n-            --  protected type.\n-\n-            --------------------\n-            -- Is_Implemented --\n-            --------------------\n-\n-            function Is_Implemented\n-              (Ifaces_List : Elist_Id;\n-               Iface       : Entity_Id) return Boolean\n-            is\n-               Iface_Elmt : Elmt_Id;\n-\n-            begin\n-               Iface_Elmt := First_Elmt (Ifaces_List);\n-               while Present (Iface_Elmt) loop\n-                  if Node (Iface_Elmt) = Iface then\n-                     return True;\n-                  end if;\n-\n-                  Next_Elmt (Iface_Elmt);\n-               end loop;\n-\n-               return False;\n-            end Is_Implemented;\n-\n-         --  Start of processing for Matches_Prefixed_View_Profile\n+            Param_E1 : Node_Id := E1_Param;\n+            Param_E2 : Node_Id := E2_Param;\n \n          begin\n-            Iface_Param := First (Iface_Params);\n-            Iface_Typ   := Etype (Defining_Identifier (Iface_Param));\n-\n-            if Is_Access_Type (Iface_Typ) then\n-               Iface_Typ := Designated_Type (Iface_Typ);\n-            end if;\n-\n-            Prim_Param := First (Prim_Params);\n-\n-            --  The first parameter of the potentially overridden subprogram\n-            --  must be an interface implemented by Prim.\n-\n-            if not Is_Interface (Iface_Typ)\n-              or else not Is_Implemented (Ifaces_List, Iface_Typ)\n-            then\n-               return False;\n-            end if;\n-\n-            --  The checks on the object parameters are done, move onto the\n-            --  rest of the parameters.\n-\n-            if not In_Scope then\n-               Prim_Param := Next (Prim_Param);\n-            end if;\n-\n-            Iface_Param := Next (Iface_Param);\n-            while Present (Iface_Param) and then Present (Prim_Param) loop\n-               Iface_Id  := Defining_Identifier (Iface_Param);\n-               Iface_Typ := Find_Parameter_Type (Iface_Param);\n-\n-               Prim_Id  := Defining_Identifier (Prim_Param);\n-               Prim_Typ := Find_Parameter_Type (Prim_Param);\n-\n-               if Ekind (Iface_Typ) = E_Anonymous_Access_Type\n-                 and then Ekind (Prim_Typ) = E_Anonymous_Access_Type\n-                 and then Is_Concurrent_Type (Designated_Type (Prim_Typ))\n-               then\n-                  Iface_Typ := Designated_Type (Iface_Typ);\n-                  Prim_Typ := Designated_Type (Prim_Typ);\n-               end if;\n-\n-               --  Case of multiple interface types inside a parameter profile\n-\n-               --     (Obj_Param : in out Iface; ...; Param : Iface)\n-\n-               --  If the interface type is implemented, then the matching type\n-               --  in the primitive should be the implementing record type.\n-\n-               if Ekind (Iface_Typ) = E_Record_Type\n-                 and then Is_Interface (Iface_Typ)\n-                 and then Is_Implemented (Ifaces_List, Iface_Typ)\n-               then\n-                  if Prim_Typ /= Typ then\n-                     return False;\n-                  end if;\n-\n-               --  The two parameters must be both mode and subtype conformant\n-\n-               elsif Ekind (Iface_Id) /= Ekind (Prim_Id)\n+            while Present (Param_E1) and then Present (Param_E2) loop\n+               if Ekind (Defining_Identifier (Param_E1))\n+                    /= Ekind (Defining_Identifier (Param_E2))\n                  or else not\n-                   Conforming_Types (Iface_Typ, Prim_Typ, Subtype_Conformant)\n+                   Conforming_Types (Find_Parameter_Type (Param_E1),\n+                                     Find_Parameter_Type (Param_E2),\n+                                     Subtype_Conformant)\n                then\n                   return False;\n                end if;\n \n-               Next (Iface_Param);\n-               Next (Prim_Param);\n+               Next (Param_E1);\n+               Next (Param_E2);\n             end loop;\n \n-            --  One of the two lists contains more parameters than the other\n+            --  The candidate is not valid if one of the two lists contains\n+            --  more parameters than the other\n \n-            if Present (Iface_Param) or else Present (Prim_Param) then\n-               return False;\n-            end if;\n+            return No (Param_E1) and then No (Param_E2);\n+         end Check_Conforming_Parameters;\n \n-            return True;\n-         end Matches_Prefixed_View_Profile;\n-\n-      --  Start of processing for Check_Synchronized_Overriding\n-\n-      begin\n-         Overridden_Subp := Empty;\n-\n-         --  Def_Id must be an entry or a subprogram. We should skip predefined\n-         --  primitives internally generated by the frontend; however at this\n-         --  stage predefined primitives are still not fully decorated. As a\n-         --  minor optimization we skip here internally generated subprograms.\n-\n-         if (Ekind (Def_Id) /= E_Entry\n-              and then Ekind (Def_Id) /= E_Function\n-              and then Ekind (Def_Id) /= E_Procedure)\n-           or else not Comes_From_Source (Def_Id)\n-         then\n-            return;\n-         end if;\n+         ----------------------------------\n+         -- Matching_Entry_Or_Subprogram --\n+         ----------------------------------\n \n-         --  Search for the concurrent declaration since it contains the list\n-         --  of all implemented interfaces. In this case, the subprogram is\n-         --  declared within the scope of a protected or a task type.\n-\n-         if Present (Scope (Def_Id))\n-           and then Is_Concurrent_Type (Scope (Def_Id))\n-           and then not Is_Generic_Actual_Type (Scope (Def_Id))\n-         then\n-            Typ := Scope (Def_Id);\n-            In_Scope := True;\n-\n-         --  The enclosing scope is not a synchronized type and the subprogram\n-         --  has no formals.\n-\n-         elsif No (First_Formal (Def_Id)) then\n-            return;\n+         function Matching_Entry_Or_Subprogram\n+           (Conc_Typ : Entity_Id;\n+            Subp     : Entity_Id) return Entity_Id\n+         is\n+            E : Entity_Id;\n \n-         --  The subprogram has formals and hence it may be a primitive of a\n-         --  concurrent type.\n+         begin\n+            E := First_Entity (Conc_Typ);\n+            while Present (E) loop\n+               if Chars (Subp) = Chars (E)\n+                 and then (Ekind (E) = E_Entry or else Is_Subprogram (E))\n+                 and then\n+                   Check_Conforming_Parameters\n+                     (First (Parameter_Specifications (Parent (E))),\n+                      Next (First (Parameter_Specifications (Parent (Subp)))))\n+               then\n+                  return E;\n+               end if;\n \n-         else\n-            Typ := Etype (First_Formal (Def_Id));\n+               Next_Entity (E);\n+            end loop;\n \n-            if Is_Access_Type (Typ) then\n-               Typ := Directly_Designated_Type (Typ);\n-            end if;\n+            return Empty;\n+         end Matching_Entry_Or_Subprogram;\n \n-            if Is_Concurrent_Type (Typ)\n-              and then not Is_Generic_Actual_Type (Typ)\n-            then\n-               In_Scope := False;\n+         -------------------------------------\n+         -- Matching_Dispatching_Subprogram --\n+         -------------------------------------\n \n-            --  This case occurs when the concurrent type is declared within\n-            --  a generic unit. As a result the corresponding record has been\n-            --  built and used as the type of the first formal, we just have\n-            --  to retrieve the corresponding concurrent type.\n+         function Matching_Dispatching_Subprogram\n+           (Conc_Typ : Entity_Id;\n+            Ent      : Entity_Id) return Entity_Id\n+         is\n+            E : Entity_Id;\n \n-            elsif Is_Concurrent_Record_Type (Typ)\n-              and then not Is_Class_Wide_Type (Typ)\n-              and then Present (Corresponding_Concurrent_Type (Typ))\n-            then\n-               Typ := Corresponding_Concurrent_Type (Typ);\n-               In_Scope := False;\n+         begin\n+            --  Search for entities in the enclosing scope of this synchonized\n+            --  type\n \n-            else\n-               return;\n-            end if;\n-         end if;\n+            pragma Assert (Is_Concurrent_Type (Conc_Typ));\n+            Push_Scope (Scope (Conc_Typ));\n+            E := Current_Entity_In_Scope (Ent);\n+            Pop_Scope;\n \n-         --  There is no overriding to check if is an inherited operation in a\n-         --  type derivation on for a generic actual.\n+            while Present (E) loop\n+               if Scope (E) = Scope (Conc_Typ)\n+                 and then Comes_From_Source (E)\n+                 and then Ekind (E) = E_Procedure\n+                 and then Present (First_Entity (E))\n+                 and then Is_Controlling_Formal (First_Entity (E))\n+                 and then Etype (First_Entity (E)) = Conc_Typ\n+                 and then\n+                   Check_Conforming_Parameters\n+                     (First (Parameter_Specifications (Parent (Ent))),\n+                      Next (First (Parameter_Specifications (Parent (E)))))\n+               then\n+                  return E;\n+               end if;\n \n-         Collect_Interfaces (Typ, Ifaces_List);\n+               E := Homonym (E);\n+            end loop;\n \n-         if Is_Empty_Elmt_List (Ifaces_List) then\n-            return;\n-         end if;\n+            return Empty;\n+         end Matching_Dispatching_Subprogram;\n \n-         --  Determine whether entry or subprogram Def_Id overrides a primitive\n-         --  operation that belongs to one of the interfaces in Ifaces_List.\n+         --------------------------------------------\n+         -- Matching_Original_Protected_Subprogram --\n+         --------------------------------------------\n \n-         declare\n-            Candidate : Entity_Id := Empty;\n-            Hom       : Entity_Id := Empty;\n-            Subp      : Entity_Id := Empty;\n+         function Matching_Original_Protected_Subprogram\n+           (Prot_Typ : Entity_Id;\n+            Subp     : Entity_Id) return Entity_Id\n+         is\n+            ICF : constant Boolean :=\n+                    Is_Controlling_Formal (First_Entity (Subp));\n+            E   : Entity_Id;\n \n          begin\n-            --  Traverse the homonym chain, looking for a potentially\n-            --  overridden subprogram that belongs to an implemented\n-            --  interface.\n-\n-            Hom := Current_Entity_In_Scope (Def_Id);\n-            while Present (Hom) loop\n-               Subp := Hom;\n-\n-               if Subp = Def_Id\n-                 or else not Is_Overloadable (Subp)\n-                 or else not Is_Primitive (Subp)\n-                 or else not Is_Dispatching_Operation (Subp)\n-                 or else not Present (Find_Dispatching_Type (Subp))\n-                 or else not Is_Interface (Find_Dispatching_Type (Subp))\n-               then\n-                  null;\n-\n-               --  Entries and procedures can override abstract or null\n-               --  interface procedures.\n+            --  Temporarily decorate the first parameter of Subp as controlling\n+            --  formal; required to invoke Subtype_Conformant()\n \n-               elsif (Ekind (Def_Id) = E_Procedure\n-                       or else Ekind (Def_Id) = E_Entry)\n-                 and then Ekind (Subp) = E_Procedure\n-                 and then Matches_Prefixed_View_Profile\n-                            (Parameter_Specifications (Parent (Def_Id)),\n-                             Parameter_Specifications (Parent (Subp)))\n-               then\n-                  Candidate := Subp;\n+            Set_Is_Controlling_Formal (First_Entity (Subp));\n \n-                  --  For an overridden subprogram Subp, check whether the mode\n-                  --  of its first parameter is correct depending on the kind\n-                  --  of synchronized type.\n-\n-                  declare\n-                     Formal : constant Node_Id := First_Formal (Candidate);\n-\n-                  begin\n-                     --  In order for an entry or a protected procedure to\n-                     --  override, the first parameter of the overridden\n-                     --  routine must be of mode \"out\", \"in out\" or\n-                     --  access-to-variable.\n-\n-                     if Ekind_In (Candidate, E_Entry, E_Procedure)\n-                       and then Is_Protected_Type (Typ)\n-                       and then Ekind (Formal) /= E_In_Out_Parameter\n-                       and then Ekind (Formal) /= E_Out_Parameter\n-                       and then Nkind (Parameter_Type (Parent (Formal))) /=\n-                                                          N_Access_Definition\n-                     then\n-                        null;\n+            E :=\n+              Current_Entity_In_Scope (Original_Protected_Subprogram (Subp));\n \n-                     --  All other cases are OK since a task entry or routine\n-                     --  does not have a restriction on the mode of the first\n-                     --  parameter of the overridden interface routine.\n+            while Present (E) loop\n+               if Scope (E) = Scope (Prot_Typ)\n+                 and then Comes_From_Source (E)\n+                 and then Ekind (Subp) = Ekind (E)\n+                 and then Present (First_Entity (E))\n+                 and then Is_Controlling_Formal (First_Entity (E))\n+                 and then Etype (First_Entity (E)) = Prot_Typ\n+                 and then Subtype_Conformant (Subp, E,\n+                            Skip_Controlling_Formals => True)\n+               then\n+                  Set_Is_Controlling_Formal (First_Entity (Subp), ICF);\n+                  return E;\n+               end if;\n \n-                     else\n-                        Overridden_Subp := Candidate;\n-                        return;\n-                     end if;\n-                  end;\n+               E := Homonym (E);\n+            end loop;\n \n-               --  Functions can override abstract interface functions\n+            Set_Is_Controlling_Formal (First_Entity (Subp), ICF);\n+            return Empty;\n+         end Matching_Original_Protected_Subprogram;\n \n-               elsif Ekind (Def_Id) = E_Function\n-                 and then Ekind (Subp) = E_Function\n-                 and then Matches_Prefixed_View_Profile\n-                            (Parameter_Specifications (Parent (Def_Id)),\n-                             Parameter_Specifications (Parent (Subp)))\n-                 and then Etype (Result_Definition (Parent (Def_Id))) =\n-                          Etype (Result_Definition (Parent (Subp)))\n-               then\n-                  Candidate := Subp;\n+      --  Start of processing for Has_Matching_Entry_Or_Subprogram\n \n-                  --  If an inherited subprogram is implemented by a protected\n-                  --  function, then the first parameter of the inherited\n-                  --  subprogram shall be of mode in, but not an\n-                  --  access-to-variable parameter (RM 9.4(11/9)\n+      begin\n+         --  Case 1: E is a subprogram whose first formal is a concurrent type\n+         --  defined in the scope of E that has an entry or subprogram whose\n+         --  profile matches E.\n+\n+         if Comes_From_Source (E)\n+           and then Is_Subprogram (E)\n+           and then Present (First_Entity (E))\n+           and then Is_Concurrent_Record_Type (Etype (First_Entity (E)))\n+         then\n+            if Scope (E) =\n+                 Scope (Corresponding_Concurrent_Type (\n+                          Etype (First_Entity (E))))\n+              and then\n+                Present\n+                  (Matching_Entry_Or_Subprogram\n+                     (Corresponding_Concurrent_Type (Etype (First_Entity (E))),\n+                      Subp => E))\n+            then\n+               Report_Conflict (E,\n+                 Matching_Entry_Or_Subprogram\n+                   (Corresponding_Concurrent_Type (Etype (First_Entity (E))),\n+                    Subp => E));\n+               return True;\n+            end if;\n \n-                  if Present (First_Formal (Subp))\n-                    and then Ekind (First_Formal (Subp)) = E_In_Parameter\n-                    and then\n-                      (not Is_Access_Type (Etype (First_Formal (Subp)))\n-                         or else\n-                       Is_Access_Constant (Etype (First_Formal (Subp))))\n-                  then\n-                     Overridden_Subp := Subp;\n-                     return;\n-                  end if;\n-               end if;\n+         --  Case 2: E is an internally built dispatching subprogram of a\n+         --  protected type and there is a subprogram defined in the enclosing\n+         --  scope of the protected type that has the original name of E and\n+         --  its profile is conformant with the profile of E. We check the\n+         --  name of the original protected subprogram associated with E since\n+         --  the expander builds dispatching primitives of protected functions\n+         --  and procedures with other name (see Exp_Ch9.Build_Selected_Name).\n \n-               Hom := Homonym (Hom);\n-            end loop;\n+         elsif not Comes_From_Source (E)\n+           and then Is_Subprogram (E)\n+           and then Present (First_Entity (E))\n+           and then Is_Concurrent_Record_Type (Etype (First_Entity (E)))\n+           and then Present (Original_Protected_Subprogram (E))\n+           and then\n+             Present\n+               (Matching_Original_Protected_Subprogram\n+                  (Corresponding_Concurrent_Type (Etype (First_Entity (E))),\n+                   Subp => E))\n+         then\n+            Report_Conflict (E,\n+              Matching_Original_Protected_Subprogram\n+                (Corresponding_Concurrent_Type (Etype (First_Entity (E))),\n+                 Subp => E));\n+            return True;\n \n-            --  After examining all candidates for overriding, we are left with\n-            --  the best match which is a mode incompatible interface routine.\n+         --  Case : E is an entry of a synchronized type and a matching\n+         --  procedure has been previously defined in the enclosing scope\n+         --  of the synchronzed type.\n \n-            if In_Scope and then Present (Candidate) then\n-               Error_Msg_PT (Def_Id, Candidate);\n-            end if;\n+         elsif Comes_From_Source (E)\n+           and then Ekind (E) = E_Entry\n+           and then\n+             Present (Matching_Dispatching_Subprogram (Current_Scope, E))\n+         then\n+            Report_Conflict (E,\n+              Matching_Dispatching_Subprogram (Current_Scope, E));\n+            return True;\n+         end if;\n \n-            Overridden_Subp := Candidate;\n-            return;\n-         end;\n-      end Check_Synchronized_Overriding;\n+         return False;\n+      end Has_Matching_Entry_Or_Subprogram;\n \n       ----------------------------\n       -- Is_Private_Declaration --\n@@ -9732,6 +9986,24 @@ package body Sem_Ch6 is\n            or else DT_Position (AO) = DT_Position (AN);\n       end Is_Overriding_Alias;\n \n+      ---------------------\n+      -- Report_Conflict --\n+      ---------------------\n+\n+      procedure Report_Conflict (S : Entity_Id; E : Entity_Id) is\n+      begin\n+         Error_Msg_Sloc := Sloc (E);\n+\n+         --  Generate message, with useful additional warning if in generic\n+\n+         if Is_Generic_Unit (E) then\n+            Error_Msg_N (\"previous generic unit cannot be overloaded\", S);\n+            Error_Msg_N (\"\\& conflicts with declaration#\", S);\n+         else\n+            Error_Msg_N (\"& conflicts with declaration#\", S);\n+         end if;\n+      end Report_Conflict;\n+\n    --  Start of processing for New_Overloaded_Entity\n \n    begin\n@@ -9788,6 +10060,15 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n+      --  For synchronized types check conflicts of this entity with\n+      --  previously defined entities.\n+\n+      if Ada_Version >= Ada_2005\n+        and then Has_Matching_Entry_Or_Subprogram (S)\n+      then\n+         return;\n+      end if;\n+\n       --  If there is no homonym then this is definitely not overriding\n \n       if No (E) then\n@@ -9864,17 +10145,7 @@ package body Sem_Ch6 is\n             return;\n \n          else\n-            Error_Msg_Sloc := Sloc (E);\n-\n-            --  Generate message, with useful additional warning if in generic\n-\n-            if Is_Generic_Unit (E) then\n-               Error_Msg_N (\"previous generic unit cannot be overloaded\", S);\n-               Error_Msg_N (\"\\& conflicts with declaration#\", S);\n-            else\n-               Error_Msg_N (\"& conflicts with declaration#\", S);\n-            end if;\n-\n+            Report_Conflict (S, E);\n             return;\n          end if;\n "}, {"sha": "d0c1e5c67e0792f41ffb16d8429494519b5b93fa", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=42f11e4c26a824c2fa4b8f9bfc9e4af69fe86dc8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -122,6 +122,15 @@ package Sem_Ch6 is\n    --  formal access-to-subprogram type, indicating that mapping of types\n    --  is needed.\n \n+   procedure Check_Synchronized_Overriding\n+     (Def_Id          : Entity_Id;\n+      Overridden_Subp : out Entity_Id);\n+   --  First determine if Def_Id is an entry or a subprogram either defined\n+   --  in the scope of a task or protected type, or is a primitive of such\n+   --  a type. Check whether Def_Id overrides a subprogram of an interface\n+   --  implemented by the synchronized type, return the overridden entity\n+   --  or Empty.\n+\n    procedure Check_Type_Conformant\n      (New_Id  : Entity_Id;\n       Old_Id  : Entity_Id;"}]}