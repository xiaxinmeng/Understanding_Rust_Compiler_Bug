{"sha": "6abd428605e3a279e533fde1cecbc9735ce03b66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFiZDQyODYwNWUzYTI3OWU1MzNmZGUxY2VjYmM5NzM1Y2UwM2I2Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-25T11:45:25Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-09-25T11:45:25Z"}, "message": "arm: Fix fp16 move patterns for base MVE\n\nThis patch fixes ICEs in gcc.dg/torture/float16-basic.c for\n-march=armv8.1-m.main+mve -mfloat-abi=hard.  The problem was\nthat an fp16 argument was (rightly) being passed in FPRs,\nbut the fp16 move patterns only handled GPRs.  LRA then cycled\ntrying to look for a way of handling the FPR.\n\nIt looks like there are three related problems here:\n\n(1) We're using the wrong fp16 move pattern for base MVE.\n    *mov<mode>_vfp_<mode>16 (the pattern we use for +mve.fp)\n    works for base MVE too.\n\n(2) The fp16 MVE load and store patterns are separate from the\n    main move patterns.  The loads and stores should instead be\n    alternatives of the main move patterns, so that LRA knows\n    what to do with pseudo registers that become stack slots.\n\n(3) The range restrictions for the loads and stores were wrong\n    for fp16: we were enforcing a multiple of 4 in [-255*4, 255*4]\n    instead of a multiple of 2 in [-255*2, 255*2].\n\n(2) came from a patch to prevent writeback being used for MVE.\nThat patch also added a Uj constraint to enforce the correct\nmemory types for MVE.  I think the simplest fix is therefore to merge\nthe loads and stores back into the main pattern and extend the Uj\nconstraint so that it acts like Um for non-MVE.\n\nThe testcase for that patch was mve-vldstr16-no-writeback.c, whose\nmain function is:\n\nvoid\nfn1 (__fp16 *pSrc)\n{\n  __fp16 high;\n  __fp16 *pDst = 0;\n  unsigned i;\n  for (i = 0;; i++)\n    if (pSrc[i])\n      pDst[i] = high;\n}\n\nFixing (2) causes the store part to fail, not because we're using\nwriteback, but because we decide to use GPRs to store high (which is\nuninitialised, and so gets replaced with zero).  This patch therefore\nadds some scan-assembler-nots instead.  (I wondered about changing the\ntestcase to initialise high, but that seemed like a bad idea for\na regression test.)\n\nFor (3): MVE seems to be the only thing to use arm_coproc_mem_operand_wb\n(and its various interfaces) for 16-bit scalars: the Neon patterns only\nuse it for 32-bit scalars.\n\nI've added new tests to try the various FPR alternatives of the\nmove patterns.  The range of offsets that GCC uses for FPR loads\nand stores is the intersection of the range allowed for GPRs and\nFPRs, so the tests include GPR<->memory tests as well.\n\nThe fp32 and fp64 tests already pass, they're just there for\ncompleteness.\n\ngcc/\n\t* config/arm/arm-protos.h (arm_mve_mode_and_operands_type_check):\n\tDelete.\n\t* config/arm/arm.c (arm_coproc_mem_operand_wb): Use a scale factor\n\tof 2 rather than 4 for 16-bit modes.\n\t(arm_mve_mode_and_operands_type_check): Delete.\n\t* config/arm/constraints.md (Uj): Allow writeback for Neon,\n\tbut continue to disallow it for MVE.\n\t* config/arm/arm.md (*arm32_mov<HFBF:mode>): Add !TARGET_HAVE_MVE.\n\t* config/arm/vfp.md (*mov_load_vfp_hf16, *mov_store_vfp_hf16): Fold\n\tback into...\n\t(*mov<mode>_vfp_<mode>16): ...here but use Uj for the FPR memory\n\tconstraints.  Use for base MVE too.\n\ngcc/testsuite/\n\t* gcc.target/arm/mve/intrinsics/mve-vldstr16-no-writeback.c: Allow\n\tthe store to use GPRs instead of FPRs.  Add scan-assembler-nots\n\tfor writeback.\n\t* gcc.target/arm/armv8_1m-fp16-move-1.c: New test.\n\t* gcc.target/arm/armv8_1m-fp32-move-1.c: Likewise.\n\t* gcc.target/arm/armv8_1m-fp64-move-1.c: Likewise.", "tree": {"sha": "d2f68871120d9c8a8d2ea05a6c60551450e352c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f68871120d9c8a8d2ea05a6c60551450e352c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6abd428605e3a279e533fde1cecbc9735ce03b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6abd428605e3a279e533fde1cecbc9735ce03b66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6abd428605e3a279e533fde1cecbc9735ce03b66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6abd428605e3a279e533fde1cecbc9735ce03b66/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dcc7f03b54087638e084ac69d40d7507fe83bd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dcc7f03b54087638e084ac69d40d7507fe83bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dcc7f03b54087638e084ac69d40d7507fe83bd8"}], "stats": {"total": 1340, "additions": 1295, "deletions": 45}, "files": [{"sha": "9bb9c61967b59d32c2f12417dd700708568ea482", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -120,7 +120,6 @@ extern int arm_coproc_mem_operand_no_writeback (rtx);\n extern int arm_coproc_mem_operand_wb (rtx, int);\n extern int neon_vector_mem_operand (rtx, int, bool);\n extern int mve_vector_mem_operand (machine_mode, rtx, bool);\n-bool arm_mve_mode_and_operands_type_check (machine_mode, rtx, rtx);\n extern int neon_struct_mem_operand (rtx);\n \n extern rtx *neon_vcmla_lane_prepare_operands (rtx *);"}, {"sha": "8105b39e7a41b47ccf8ff2173c914c670eb1153c", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -13277,14 +13277,18 @@ arm_coproc_mem_operand_wb (rtx op, int wb_level)\n \n   /* Match:\n      (plus (reg)\n-\t   (const)).  */\n+\t   (const))\n+\n+     The encoded immediate for 16-bit modes is multiplied by 2,\n+     while the encoded immediate for 32-bit and 64-bit modes is\n+     multiplied by 4.  */\n+  int factor = MIN (GET_MODE_SIZE (GET_MODE (op)), 4);\n   if (GET_CODE (ind) == PLUS\n       && REG_P (XEXP (ind, 0))\n       && REG_MODE_OK_FOR_BASE_P (XEXP (ind, 0), VOIDmode)\n       && CONST_INT_P (XEXP (ind, 1))\n-      && INTVAL (XEXP (ind, 1)) > -1024\n-      && INTVAL (XEXP (ind, 1)) <  1024\n-      && (INTVAL (XEXP (ind, 1)) & 3) == 0)\n+      && IN_RANGE (INTVAL (XEXP (ind, 1)), -255 * factor, 255 * factor)\n+      && (INTVAL (XEXP (ind, 1)) & (factor - 1)) == 0)\n     return TRUE;\n \n   return FALSE;\n@@ -33578,17 +33582,4 @@ arm_mode_base_reg_class (machine_mode mode)\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n-bool\n-arm_mve_mode_and_operands_type_check (machine_mode mode, rtx op0, rtx op1)\n-{\n-  if (!(TARGET_HAVE_MVE || TARGET_HAVE_MVE_FLOAT))\n-    return true;\n-  else if (mode == E_BFmode)\n-    return false;\n-  else if ((s_register_operand (op0, mode) && MEM_P (op1))\n-\t   || (s_register_operand (op1, mode) && MEM_P (op0)))\n-    return false;\n-  return true;\n-}\n-\n #include \"gt-arm.h\""}, {"sha": "147c4a50c72c02582f1d48ed7ebaa4f0d12d8134", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -7289,7 +7289,9 @@\n (define_insn \"*arm32_mov<mode>\"\n   [(set (match_operand:HFBF 0 \"nonimmediate_operand\" \"=r,m,r,r\")\n \t(match_operand:HFBF 1 \"general_operand\"\t   \" m,r,r,F\"))]\n-  \"TARGET_32BIT && !TARGET_HARD_FLOAT\n+  \"TARGET_32BIT\n+   && !TARGET_HARD_FLOAT\n+   && !TARGET_HAVE_MVE\n    && (\t  s_register_operand (operands[0], <MODE>mode)\n        || s_register_operand (operands[1], <MODE>mode))\"\n   \"*"}, {"sha": "789e3332abb7495b308509d03ed241d39498a8b6", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -454,10 +454,13 @@\n \n (define_memory_constraint \"Uj\"\n  \"@internal\n-  In ARM/Thumb-2 state an VFP load/store address which does not support\n-  writeback at all (eg vldr.16).\"\n+  In ARM/Thumb-2 state a VFP load/store address that supports writeback\n+  for Neon but not for MVE\"\n  (and (match_code \"mem\")\n-      (match_test \"TARGET_32BIT && arm_coproc_mem_operand_no_writeback (op)\")))\n+      (match_test \"TARGET_32BIT\")\n+      (match_test \"TARGET_HAVE_MVE\n+                   ? arm_coproc_mem_operand_no_writeback (op)\n+                   : neon_vector_mem_operand (op, 2, true)\")))\n \n (define_memory_constraint \"Uy\"\n  \"@internal"}, {"sha": "72707c179294312317bb9adf65217d244e06395e", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -387,31 +387,15 @@\n    (set_attr \"arch\"           \"t2,any,any,any,a,t2,any,any,any,any,any,any\")]\n )\n \n-(define_insn \"*mov_load_vfp_hf16\"\n-  [(set (match_operand:HF 0 \"s_register_operand\" \"=t\")\n-\t(match_operand:HF 1 \"memory_operand\" \"Uj\"))]\n-  \"TARGET_HAVE_MVE_FLOAT\"\n-  \"vldr.16\\\\t%0, %E1\"\n-)\n-\n-(define_insn \"*mov_store_vfp_hf16\"\n-  [(set (match_operand:HF 0 \"memory_operand\" \"=Uj\")\n-\t(match_operand:HF 1 \"s_register_operand\"   \"t\"))]\n-  \"TARGET_HAVE_MVE_FLOAT\"\n-  \"vstr.16\\\\t%1, %E0\"\n-)\n-\n ;; HFmode and BFmode moves\n \n (define_insn \"*mov<mode>_vfp_<mode>16\"\n   [(set (match_operand:HFBF 0 \"nonimmediate_operand\"\n-\t\t\t  \"= ?r,?m,t,r,t,r,t, t, Um,r\")\n+\t\t\t  \"= ?r,?m,t,r,t,r,t, t, Uj,r\")\n \t(match_operand:HFBF 1 \"general_operand\"\n-\t\t\t  \"  m,r,t,r,r,t,Dv,Um,t, F\"))]\n+\t\t\t  \"  m,r,t,r,r,t,Dv,Uj,t, F\"))]\n   \"TARGET_32BIT\n-   && TARGET_VFP_FP16INST\n-   && arm_mve_mode_and_operands_type_check (<MODE>mode, operands[0],\n-\t\t\t\t\t    operands[1])\n+   && (TARGET_VFP_FP16INST || TARGET_HAVE_MVE)\n    && (s_register_operand (operands[0], <MODE>mode)\n        || s_register_operand (operands[1], <MODE>mode))\"\n  {\n@@ -430,9 +414,15 @@\n     case 6: /* S register from immediate.  */\n       return \\\"vmov.f16\\\\t%0, %1\\t%@ __<fporbf>\\\";\n     case 7: /* S register from memory.  */\n-      return \\\"vld1.16\\\\t{%z0}, %A1\\\";\n+      if (TARGET_HAVE_MVE)\n+\treturn \\\"vldr.16\\\\t%0, %1\\\";\n+      else\n+\treturn \\\"vld1.16\\\\t{%z0}, %A1\\\";\n     case 8: /* Memory from S register.  */\n-      return \\\"vst1.16\\\\t{%z1}, %A0\\\";\n+      if (TARGET_HAVE_MVE)\n+\treturn \\\"vstr.16\\\\t%1, %0\\\";\n+      else\n+\treturn \\\"vst1.16\\\\t{%z1}, %A0\\\";\n     case 9: /* ARM register from constant.  */\n       {\n \tlong bits;"}, {"sha": "67a9f416adf68708c44363c3b2eedb1cdd4604ab", "filename": "gcc/testsuite/gcc.target/arm/armv8_1m-fp16-move-1.c", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp16-move-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp16-move-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp16-move-1.c?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -0,0 +1,418 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mfloat-abi=hard -mfp16-format=ieee\" } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** r_w:\n+**\tvmov.f16\tr0, s0\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_w (_Float16 s0)\n+{\n+  register _Float16 r0 asm (\"r0\");\n+  r0 = s0;\n+  asm volatile (\"\" :: \"r\" (r0));\n+}\n+\n+/*\n+** w_r:\n+**\tvmov.f16\ts0, r0\t@ __fp16\n+**\tbx\tlr\n+*/\n+_Float16\n+w_r ()\n+{\n+  register _Float16 r0 asm (\"r0\");\n+  asm volatile (\"\" : \"=r\" (r0));\n+  return r0;\n+}\n+\n+/*\n+** w_w:\n+**\tvmov\ts1, s0\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+w_w (_Float16 s0)\n+{\n+  register _Float16 s1 asm (\"s1\");\n+  s1 = s0;\n+  asm volatile (\"\" :: \"w\" (s1));\n+}\n+\n+/*\n+** r_m_m128:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tldrh\tr1, \\[\\1\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_m_m128 (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  r1 = r0[-128];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_m127:\n+**\tldrh\tr1, \\[r0, #-254\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_m_m127 (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  r1 = r0[-127];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_m1:\n+**\tldrh\tr1, \\[r0, #-2\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_m_m1 (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  r1 = r0[-1];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_0:\n+**\tldrh\tr1, \\[r0\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_m_0 (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  r1 = r0[0];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_1:\n+**\tldrh\tr1, \\[r0, #2\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_m_1 (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  r1 = r0[1];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_255:\n+**\tldrh\tr1, \\[r0, #510\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_m_255 (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  r1 = r0[255];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_256:\n+**\tldrh\tr1, \\[r0, #512\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+r_m_256 (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  r1 = r0[256];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/* ??? This could be done in one instruction, but without mve.fp,\n+   it makes more sense for memory_operand to enforce the GPR range.  */\n+/*\n+** w_m_m128:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tvldr.16\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m128 (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  s0 = r0[-128];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_m127:\n+**\tvldr.16\ts0, \\[r0, #-254\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m127 (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  s0 = r0[-127];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_m1:\n+**\tvldr.16\ts0, \\[r0, #-2\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m1 (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  s0 = r0[-1];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_0:\n+**\tvldr.16\ts0, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_0 (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  s0 = r0[0];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_1:\n+**\tvldr.16\ts0, \\[r0, #2\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_1 (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  s0 = r0[1];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_255:\n+**\tvldr.16\ts0, \\[r0, #510\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_255 (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  s0 = r0[255];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_256:\n+**\tadd\t(r[0-9]+), r0, #512\n+**\tvldr.16\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_256 (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  s0 = r0[256];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** m_m128_r:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tstrh\tr1, \\[\\1\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+m_m128_r (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[-128] = r1;\n+}\n+\n+/*\n+** m_m127_r:\n+**\tstrh\tr1, \\[r0, #-254\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+m_m127_r (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[-127] = r1;\n+}\n+\n+/*\n+** m_m1_r:\n+**\tstrh\tr1, \\[r0, #-2\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+m_m1_r (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[-1] = r1;\n+}\n+\n+/*\n+** m_0_r:\n+**\tstrh\tr1, \\[r0\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+m_0_r (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[0] = r1;\n+}\n+\n+/*\n+** m_1_r:\n+**\tstrh\tr1, \\[r0, #2\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+m_1_r (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[1] = r1;\n+}\n+\n+/*\n+** m_255_r:\n+**\tstrh\tr1, \\[r0, #510\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+m_255_r (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[255] = r1;\n+}\n+\n+/*\n+** m_256_r:\n+**\tstrh\tr1, \\[r0, #512\\]\t@ __fp16\n+**\tbx\tlr\n+*/\n+void\n+m_256_r (_Float16 *r0)\n+{\n+  register _Float16 r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[256] = r1;\n+}\n+\n+/* ??? This could be done in one instruction, but without mve.fp,\n+   it makes more sense for memory_operand to enforce the GPR range.  */\n+/*\n+** m_m128_w:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tvstr.16\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m128_w (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[-128] = s0;\n+}\n+\n+/*\n+** m_m127_w:\n+**\tvstr.16\ts0, \\[r0, #-254\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m127_w (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[-127] = s0;\n+}\n+\n+/*\n+** m_m1_w:\n+**\tvstr.16\ts0, \\[r0, #-2\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m1_w (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[-1] = s0;\n+}\n+\n+/*\n+** m_0_w:\n+**\tvstr.16\ts0, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+m_0_w (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[0] = s0;\n+}\n+\n+/*\n+** m_1_w:\n+**\tvstr.16\ts0, \\[r0, #2\\]\n+**\tbx\tlr\n+*/\n+void\n+m_1_w (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[1] = s0;\n+}\n+\n+/*\n+** m_255_w:\n+**\tvstr.16\ts0, \\[r0, #510\\]\n+**\tbx\tlr\n+*/\n+void\n+m_255_w (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[255] = s0;\n+}\n+\n+/*\n+** m_256_w:\n+**\tadd\t(r[0-9]+), r0, #512\n+**\tvstr.16\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+m_256_w (_Float16 *r0)\n+{\n+  register _Float16 s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[256] = s0;\n+}"}, {"sha": "1ecb839bfe739d91a7496325bd42c8bf5e998cdb", "filename": "gcc/testsuite/gcc.target/arm/armv8_1m-fp32-move-1.c", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp32-move-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp32-move-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp32-move-1.c?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -0,0 +1,420 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mfloat-abi=hard\" } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** r_w:\n+**\tvmov\tr0, s0\n+**\tbx\tlr\n+*/\n+void\n+r_w (float s0)\n+{\n+  register float r0 asm (\"r0\");\n+  r0 = s0;\n+  asm volatile (\"\" :: \"r\" (r0));\n+}\n+\n+/*\n+** w_r:\n+**\tvmov\ts0, r0\n+**\tbx\tlr\n+*/\n+float\n+w_r ()\n+{\n+  register float r0 asm (\"r0\");\n+  asm volatile (\"\" : \"=r\" (r0));\n+  return r0;\n+}\n+\n+/*\n+** w_w:\n+**\tvmov.f32\ts1, s0\n+**\tbx\tlr\n+*/\n+void\n+w_w (float s0)\n+{\n+  register float s1 asm (\"s1\");\n+  s1 = s0;\n+  asm volatile (\"\" :: \"w\" (s1));\n+}\n+\n+/*\n+** r_m_m64:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tldr\tr1, \\[\\1\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+r_m_m64 (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  r1 = r0[-64];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_m63:\n+**\tldr\tr1, \\[r0, #-252\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+r_m_m63 (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  r1 = r0[-63];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_m1:\n+**\tldr\tr1, \\[r0, #-4\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+r_m_m1 (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  r1 = r0[-1];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_0:\n+**\tldr\tr1, \\[r0\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+r_m_0 (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  r1 = r0[0];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_1:\n+**\tldr\tr1, \\[r0, #4\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+r_m_1 (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  r1 = r0[1];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_255:\n+**\tldr\tr1, \\[r0, #1020\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+r_m_255 (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  r1 = r0[255];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/*\n+** r_m_256:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tldr\tr1, \\[r0\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+r_m_256 (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  r1 = r0[256];\n+  asm volatile (\"\" :: \"r\" (r1));\n+}\n+\n+/* ??? This could be done in one instruction, but without mve.fp,\n+   it makes more sense for memory_operand to enforce the GPR range.  */\n+/*\n+** w_m_m64:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tvldr.32\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m64 (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  s0 = r0[-64];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_m63:\n+**\tvldr.32\ts0, \\[r0, #-252\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m63 (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  s0 = r0[-63];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_m1:\n+**\tvldr.32\ts0, \\[r0, #-4\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m1 (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  s0 = r0[-1];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_0:\n+**\tvldr.32\ts0, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_0 (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  s0 = r0[0];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_1:\n+**\tvldr.32\ts0, \\[r0, #4\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_1 (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  s0 = r0[1];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_255:\n+**\tvldr.32\ts0, \\[r0, #1020\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_255 (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  s0 = r0[255];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** w_m_256:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tvldr.32\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_256 (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  s0 = r0[256];\n+  asm volatile (\"\" :: \"w\" (s0));\n+}\n+\n+/*\n+** m_m64_r:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tstr\tr1, \\[\\1\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+m_m64_r (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[-64] = r1;\n+}\n+\n+/*\n+** m_m63_r:\n+**\tstr\tr1, \\[r0, #-252\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+m_m63_r (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[-63] = r1;\n+}\n+\n+/*\n+** m_m1_r:\n+**\tstr\tr1, \\[r0, #-4\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+m_m1_r (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[-1] = r1;\n+}\n+\n+/*\n+** m_0_r:\n+**\tstr\tr1, \\[r0\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+m_0_r (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[0] = r1;\n+}\n+\n+/*\n+** m_1_r:\n+**\tstr\tr1, \\[r0, #4\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+m_1_r (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[1] = r1;\n+}\n+\n+/*\n+** m_255_r:\n+**\tstr\tr1, \\[r0, #1020\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+m_255_r (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[255] = r1;\n+}\n+\n+/*\n+** m_256_r:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tstr\tr1, \\[r0\\]\t@ float\n+**\tbx\tlr\n+*/\n+void\n+m_256_r (float *r0)\n+{\n+  register float r1 asm (\"r1\");\n+  asm volatile (\"\" : \"=r\" (r1));\n+  r0[256] = r1;\n+}\n+\n+/* ??? This could be done in one instruction, but without mve.fp,\n+   it makes more sense for memory_operand to enforce the GPR range.  */\n+/*\n+** m_m64_w:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tvstr.32\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m64_w (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[-64] = s0;\n+}\n+\n+/*\n+** m_m63_w:\n+**\tvstr.32\ts0, \\[r0, #-252\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m63_w (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[-63] = s0;\n+}\n+\n+/*\n+** m_m1_w:\n+**\tvstr.32\ts0, \\[r0, #-4\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m1_w (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[-1] = s0;\n+}\n+\n+/*\n+** m_0_w:\n+**\tvstr.32\ts0, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+m_0_w (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[0] = s0;\n+}\n+\n+/*\n+** m_1_w:\n+**\tvstr.32\ts0, \\[r0, #4\\]\n+**\tbx\tlr\n+*/\n+void\n+m_1_w (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[1] = s0;\n+}\n+\n+/*\n+** m_255_w:\n+**\tvstr.32\ts0, \\[r0, #1020\\]\n+**\tbx\tlr\n+*/\n+void\n+m_255_w (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[255] = s0;\n+}\n+\n+/*\n+** m_256_w:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tvstr.32\ts0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+m_256_w (float *r0)\n+{\n+  register float s0 asm (\"s0\");\n+  asm volatile (\"\" : \"=w\" (s0));\n+  r0[256] = s0;\n+}"}, {"sha": "3f81350697aa4181f46b6e111186f95606d68ff6", "filename": "gcc/testsuite/gcc.target/arm/armv8_1m-fp64-move-1.c", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp64-move-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp64-move-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_1m-fp64-move-1.c?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -0,0 +1,426 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mfloat-abi=hard\" } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+/*\n+** r_w:\n+**\tvmov\tr0, r1, d0\n+**\tbx\tlr\n+*/\n+void\n+r_w (double d0)\n+{\n+  register double r0 asm (\"r0\");\n+  r0 = d0;\n+  asm volatile (\"\" :: \"r\" (r0));\n+}\n+\n+/*\n+** w_r:\n+**\tvmov\td0, r0, r1\n+**\tbx\tlr\n+*/\n+double\n+w_r ()\n+{\n+  register double r0 asm (\"r0\");\n+  asm volatile (\"\" : \"=r\" (r0));\n+  return r0;\n+}\n+\n+/*\n+** w_w:\n+** (\n+**\tvmov.f32\ts2, s0\n+**\tvmov.f32\ts3, s1\n+** |\n+**\tvmov.f32\ts3, s1\n+**\tvmov.f32\ts2, s0\n+** )\n+**\tbx\tlr\n+*/\n+void\n+w_w (double d0)\n+{\n+  register double d1 asm (\"d1\");\n+  d1 = d0;\n+  asm volatile (\"\" :: \"w\" (d1));\n+}\n+\n+/*\n+** r_m_m32:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tldrd\tr2, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+r_m_m32 (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  r2 = r0[-32];\n+  asm volatile (\"\" :: \"r\" (r2));\n+}\n+\n+/*\n+** r_m_m31:\n+**\tldrd\tr2, \\[r0, #-248\\]\n+**\tbx\tlr\n+*/\n+void\n+r_m_m31 (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  r2 = r0[-31];\n+  asm volatile (\"\" :: \"r\" (r2));\n+}\n+\n+/*\n+** r_m_m1:\n+**\tldrd\tr2, \\[r0, #-8\\]\n+**\tbx\tlr\n+*/\n+void\n+r_m_m1 (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  r2 = r0[-1];\n+  asm volatile (\"\" :: \"r\" (r2));\n+}\n+\n+/*\n+** r_m_0:\n+**\tldrd\tr2, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+r_m_0 (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  r2 = r0[0];\n+  asm volatile (\"\" :: \"r\" (r2));\n+}\n+\n+/*\n+** r_m_1:\n+**\tldrd\tr2, \\[r0, #8\\]\n+**\tbx\tlr\n+*/\n+void\n+r_m_1 (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  r2 = r0[1];\n+  asm volatile (\"\" :: \"r\" (r2));\n+}\n+\n+/*\n+** r_m_127:\n+**\tldrd\tr2, \\[r0, #1016\\]\n+**\tbx\tlr\n+*/\n+void\n+r_m_127 (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  r2 = r0[127];\n+  asm volatile (\"\" :: \"r\" (r2));\n+}\n+\n+/*\n+** r_m_128:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tldrd\tr2, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+r_m_128 (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  r2 = r0[128];\n+  asm volatile (\"\" :: \"r\" (r2));\n+}\n+\n+/* ??? This could be done in one instruction, but without mve.fp,\n+   it makes more sense for memory_operand to enforce the GPR range.  */\n+/*\n+** w_m_m32:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tvldr.64\td0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m32 (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  d0 = r0[-32];\n+  asm volatile (\"\" :: \"w\" (d0));\n+}\n+\n+/*\n+** w_m_m31:\n+**\tvldr.64\td0, \\[r0, #-248\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m31 (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  d0 = r0[-31];\n+  asm volatile (\"\" :: \"w\" (d0));\n+}\n+\n+/*\n+** w_m_m1:\n+**\tvldr.64\td0, \\[r0, #-8\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_m1 (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  d0 = r0[-1];\n+  asm volatile (\"\" :: \"w\" (d0));\n+}\n+\n+/*\n+** w_m_0:\n+**\tvldr.64\td0, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_0 (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  d0 = r0[0];\n+  asm volatile (\"\" :: \"w\" (d0));\n+}\n+\n+/*\n+** w_m_1:\n+**\tvldr.64\td0, \\[r0, #8\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_1 (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  d0 = r0[1];\n+  asm volatile (\"\" :: \"w\" (d0));\n+}\n+\n+/*\n+** w_m_127:\n+**\tvldr.64\td0, \\[r0, #1016\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_127 (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  d0 = r0[127];\n+  asm volatile (\"\" :: \"w\" (d0));\n+}\n+\n+/*\n+** w_m_128:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tvldr.64\td0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+w_m_128 (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  d0 = r0[128];\n+  asm volatile (\"\" :: \"w\" (d0));\n+}\n+\n+/*\n+** m_m32_r:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tstrd\tr2, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m32_r (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  asm volatile (\"\" : \"=r\" (r2));\n+  r0[-32] = r2;\n+}\n+\n+/*\n+** m_m31_r:\n+**\tstrd\tr2, \\[r0, #-248\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m31_r (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  asm volatile (\"\" : \"=r\" (r2));\n+  r0[-31] = r2;\n+}\n+\n+/*\n+** m_m1_r:\n+**\tstrd\tr2, \\[r0, #-8\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m1_r (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  asm volatile (\"\" : \"=r\" (r2));\n+  r0[-1] = r2;\n+}\n+\n+/*\n+** m_0_r:\n+**\tstrd\tr2, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+m_0_r (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  asm volatile (\"\" : \"=r\" (r2));\n+  r0[0] = r2;\n+}\n+\n+/*\n+** m_1_r:\n+**\tstrd\tr2, \\[r0, #8\\]\n+**\tbx\tlr\n+*/\n+void\n+m_1_r (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  asm volatile (\"\" : \"=r\" (r2));\n+  r0[1] = r2;\n+}\n+\n+/*\n+** m_127_r:\n+**\tstrd\tr2, \\[r0, #1016\\]\n+**\tbx\tlr\n+*/\n+void\n+m_127_r (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  asm volatile (\"\" : \"=r\" (r2));\n+  r0[127] = r2;\n+}\n+\n+/*\n+** m_128_r:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tstrd\tr2, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+m_128_r (double *r0)\n+{\n+  register double r2 asm (\"r2\");\n+  asm volatile (\"\" : \"=r\" (r2));\n+  r0[128] = r2;\n+}\n+\n+/* ??? This could be done in one instruction, but without mve.fp,\n+   it makes more sense for memory_operand to enforce the GPR range.  */\n+/*\n+** m_m32_w:\n+**\tsub\t(r[0-9]+), r0, #256\n+**\tvstr.64\td0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m32_w (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  asm volatile (\"\" : \"=w\" (d0));\n+  r0[-32] = d0;\n+}\n+\n+/*\n+** m_m31_w:\n+**\tvstr.64\td0, \\[r0, #-248\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m31_w (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  asm volatile (\"\" : \"=w\" (d0));\n+  r0[-31] = d0;\n+}\n+\n+/*\n+** m_m1_w:\n+**\tvstr.64\td0, \\[r0, #-8\\]\n+**\tbx\tlr\n+*/\n+void\n+m_m1_w (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  asm volatile (\"\" : \"=w\" (d0));\n+  r0[-1] = d0;\n+}\n+\n+/*\n+** m_0_w:\n+**\tvstr.64\td0, \\[r0\\]\n+**\tbx\tlr\n+*/\n+void\n+m_0_w (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  asm volatile (\"\" : \"=w\" (d0));\n+  r0[0] = d0;\n+}\n+\n+/*\n+** m_1_w:\n+**\tvstr.64\td0, \\[r0, #8\\]\n+**\tbx\tlr\n+*/\n+void\n+m_1_w (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  asm volatile (\"\" : \"=w\" (d0));\n+  r0[1] = d0;\n+}\n+\n+/*\n+** m_127_w:\n+**\tvstr.64\td0, \\[r0, #1016\\]\n+**\tbx\tlr\n+*/\n+void\n+m_127_w (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  asm volatile (\"\" : \"=w\" (d0));\n+  r0[127] = d0;\n+}\n+\n+/*\n+** m_128_w:\n+**\tadd\t(r[0-9]+), r0, #1024\n+**\tvstr.64\td0, \\[\\1\\]\n+**\tbx\tlr\n+*/\n+void\n+m_128_w (double *r0)\n+{\n+  register double d0 asm (\"d0\");\n+  asm volatile (\"\" : \"=w\" (d0));\n+  r0[128] = d0;\n+}"}, {"sha": "50b195300d89511c00dc4d555f57801dd13caf6e", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve-vldstr16-no-writeback.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve-vldstr16-no-writeback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6abd428605e3a279e533fde1cecbc9735ce03b66/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve-vldstr16-no-writeback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve-vldstr16-no-writeback.c?ref=6abd428605e3a279e533fde1cecbc9735ce03b66", "patch": "@@ -13,5 +13,6 @@ fn1 (__fp16 *pSrc)\n       pDst[i] = high;\n }\n \n-/* { dg-final { scan-assembler {vldr\\.16\\ts[0-9]+, \\[r[0-9]+\\]\\n} } } */\n-/* { dg-final { scan-assembler {vstr\\.16\\ts[0-9]+, \\[r[0-9]+\\]\\n} } } */\n+/* { dg-final { scan-assembler {vldr\\.16\\ts[0-9]+, \\[r[0-9]+(, #-?[0-9]+)?\\]\\n} } } */\n+/* { dg-final { scan-assembler-not {vldr\\.16\\t[^\\n]*\\]!} } } */\n+/* { dg-final { scan-assembler-not {vstr\\.16\\t[^\\n]*\\]!} } } */"}]}