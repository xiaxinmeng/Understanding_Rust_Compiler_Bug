{"sha": "9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwOGQyMzA4MmZiZWI5NTAxM2RjNzRkZDM2MTFiNmIyMzMxZTNjYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-08-02T22:18:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-08-02T22:18:35Z"}, "message": "re PR debug/49864 (ICE: in maybe_record_trace_start, at dwarf2cfi.c:2439)\n\nPR target/49864\n\t* reg-notes.def (REG_ARGS_SIZE): New.\n\t* calls.c (emit_call_1): Emit REG_ARGS_SIZE for call_pop.\n\t(expand_call): Add REG_ARGS_SIZE to emit_stack_restore.\n\t* cfgcleanup.c (old_insns_match_p): Don't allow cross-jumping to\n\tdifferent stack levels.\n\t* combine-stack-adj.c (adjust_frame_related_expr): Remove.\n\t(maybe_move_args_size_note): New.\n\t(combine_stack_adjustments_for_block): Use it.\n\t* combine.c (distribute_notes): Place REG_ARGS_SIZE.\n\t* dwarf2cfi.c (dw_cfi_row_struct): Remove args_size member.\n\t(dw_trace_info): Add beg_true_args_size, end_true_args_size,\n\tbeg_delay_args_size, end_delay_args_size, eh_head, args_size_undefined.\n\t(cur_cfa): New.\n\t(queued_args_size): Remove.\n\t(add_cfi_args_size): Assert size is non-negative.\n\t(stack_adjust_offset, dwarf2out_args_size): Remove.\n\t(dwarf2out_stack_adjust, dwarf2out_notice_stack_adjust): Remove.\n\t(notice_args_size, notice_eh_throw): New.\n\t(dwarf2out_frame_debug_def_cfa): Use cur_cfa.\n\t(dwarf2out_frame_debug_adjust_cfa): Likewise.\n\t(dwarf2out_frame_debug_cfa_offset): Likewise.\n\t(dwarf2out_frame_debug_expr): Likewise.  Don't stack_adjust_offset.\n\t(dwarf2out_frame_debug): Don't handle non-frame-related-p insns.\n\t(change_cfi_row): Don't emit args_size.\n\t(maybe_record_trace_start_abnormal): Split out from ...\n\t(maybe_record_trace_start): Here.  Set args_size_undefined.\n\t(create_trace_edges): Update to match.\n\t(scan_trace): Handle REG_ARGS_SIZE.\n\t(connect_traces): Connect args_size between EH insns.\n\t* emit-rtl.c (try_split): Handle REG_ARGS_SIZE.\n\t* explow.c (suppress_reg_args_size): New.\n\t(adjust_stack_1): Split out from ...\n\t(adjust_stack): ... here.\n\t(anti_adjust_stack): Use it.\n\t(allocate_dynamic_stack_space): Suppress REG_ARGS_SIZE.\n\t* expr.c (mem_autoinc_base): New.\n\t(fixup_args_size_notes): New.\n\t(emit_single_push_insn_1): Rename from emit_single_push_insn.\n\t(emit_single_push_insn): New.  Generate REG_ARGS_SIZE.\n\t* recog.c (peep2_attempt): Handle REG_ARGS_SIZE.\n\t* reload1.c (reload_as_needed): Likewise.\n\t* rtl.h (fixup_args_size_notes): Declare.\n\nFrom-SVN: r177218", "tree": {"sha": "3dd838d8e7cbbe356e3db0a0c2bcb80fcfbb4daf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd838d8e7cbbe356e3db0a0c2bcb80fcfbb4daf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/comments", "author": null, "committer": null, "parents": [{"sha": "cde7b553dbabe7d7341998f54979af2190539cd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde7b553dbabe7d7341998f54979af2190539cd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde7b553dbabe7d7341998f54979af2190539cd7"}], "stats": {"total": 1102, "additions": 640, "deletions": 462}, "files": [{"sha": "16af3149b65579e4334f4621f7ab343867117d1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -1,3 +1,49 @@\n+2011-08-02  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/49864\n+\t* reg-notes.def (REG_ARGS_SIZE): New.\n+\t* calls.c (emit_call_1): Emit REG_ARGS_SIZE for call_pop.\n+\t(expand_call): Add REG_ARGS_SIZE to emit_stack_restore.\n+\t* cfgcleanup.c (old_insns_match_p): Don't allow cross-jumping to\n+\tdifferent stack levels.\n+\t* combine-stack-adj.c (adjust_frame_related_expr): Remove.\n+\t(maybe_move_args_size_note): New.\n+\t(combine_stack_adjustments_for_block): Use it.\n+\t* combine.c (distribute_notes): Place REG_ARGS_SIZE.\n+\t* dwarf2cfi.c (dw_cfi_row_struct): Remove args_size member.\n+\t(dw_trace_info): Add beg_true_args_size, end_true_args_size,\n+\tbeg_delay_args_size, end_delay_args_size, eh_head, args_size_undefined.\n+\t(cur_cfa): New.\n+\t(queued_args_size): Remove.\n+\t(add_cfi_args_size): Assert size is non-negative.\n+\t(stack_adjust_offset, dwarf2out_args_size): Remove.\n+\t(dwarf2out_stack_adjust, dwarf2out_notice_stack_adjust): Remove.\n+\t(notice_args_size, notice_eh_throw): New.\n+\t(dwarf2out_frame_debug_def_cfa): Use cur_cfa.\n+\t(dwarf2out_frame_debug_adjust_cfa): Likewise.\n+\t(dwarf2out_frame_debug_cfa_offset): Likewise.\n+\t(dwarf2out_frame_debug_expr): Likewise.  Don't stack_adjust_offset.\n+\t(dwarf2out_frame_debug): Don't handle non-frame-related-p insns.\n+\t(change_cfi_row): Don't emit args_size.\n+\t(maybe_record_trace_start_abnormal): Split out from ...\n+\t(maybe_record_trace_start): Here.  Set args_size_undefined.\n+\t(create_trace_edges): Update to match.\n+\t(scan_trace): Handle REG_ARGS_SIZE.\n+\t(connect_traces): Connect args_size between EH insns.\n+\t* emit-rtl.c (try_split): Handle REG_ARGS_SIZE.\n+\t* explow.c (suppress_reg_args_size): New.\n+\t(adjust_stack_1): Split out from ...\n+\t(adjust_stack): ... here.\n+\t(anti_adjust_stack): Use it.\n+\t(allocate_dynamic_stack_space): Suppress REG_ARGS_SIZE.\n+\t* expr.c (mem_autoinc_base): New.\n+\t(fixup_args_size_notes): New.\n+\t(emit_single_push_insn_1): Rename from emit_single_push_insn.\n+\t(emit_single_push_insn): New.  Generate REG_ARGS_SIZE.\n+\t* recog.c (peep2_attempt): Handle REG_ARGS_SIZE.\n+\t* reload1.c (reload_as_needed): Likewise.\n+\t* rtl.h (fixup_args_size_notes): Declare.\n+\n 2011-08-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR bootstrap/49914"}, {"sha": "6eb1f2120874cfc9bbe6842e76b0fe43bad11aa4", "filename": "gcc/calls.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -434,6 +434,8 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n       rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n       stack_pointer_delta -= n_popped;\n \n+      add_reg_note (call_insn, REG_ARGS_SIZE, GEN_INT (stack_pointer_delta));\n+\n       /* If popup is needed, stack realign must use DRAP  */\n       if (SUPPORTS_STACK_ALIGNMENT)\n         crtl->need_drap = true;\n@@ -3126,8 +3128,19 @@ expand_call (tree exp, rtx target, int ignore)\n \n       if (old_stack_level)\n \t{\n+\t  rtx last, set;\n+\n \t  emit_stack_restore (SAVE_BLOCK, old_stack_level);\n \t  stack_pointer_delta = old_stack_pointer_delta;\n+\n+\t  /* ??? Is this assert warrented, given emit_stack_restore?\n+\t     or should we just mark the last insn no matter what?  */\n+\t  last = get_last_insn ();\n+\t  set = single_set (last);\n+\t  gcc_assert (set != NULL);\n+\t  gcc_assert (SET_DEST (set) == stack_pointer_rtx);\n+\t  add_reg_note (last, REG_ARGS_SIZE, GEN_INT (stack_pointer_delta));\n+\n \t  pending_stack_adjust = old_pending_adj;\n \t  old_stack_allocated = stack_pointer_delta - pending_stack_adjust;\n \t  stack_arg_under_construction = old_stack_arg_under_construction;"}, {"sha": "717301354e730d25d98a0764eeb4be16b16d9406", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -1078,6 +1078,16 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n   if (NOTE_INSN_BASIC_BLOCK_P (i1) && NOTE_INSN_BASIC_BLOCK_P (i2))\n     return dir_both;\n \n+  /* ??? Do not allow cross-jumping between different stack levels.  */\n+  p1 = find_reg_note (i1, REG_ARGS_SIZE, NULL);\n+  p2 = find_reg_note (i2, REG_ARGS_SIZE, NULL);\n+  if (p1)\n+    p1 = XEXP (p1, 0);\n+  if (p2)\n+    p2 = XEXP (p2, 0);\n+  if (!rtx_equal_p (p1, p2))\n+    return dir_none;\n+\n   p1 = PATTERN (i1);\n   p2 = PATTERN (i2);\n "}, {"sha": "bca078442f7c304c65b461ccc46600872959769d", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 11, "deletions": 58, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -296,68 +296,22 @@ record_stack_refs (rtx *xp, void *data)\n   return 0;\n }\n \n-/* Adjust or create REG_FRAME_RELATED_EXPR note when merging a stack\n-   adjustment into a frame related insn.  */\n+/* If INSN has a REG_ARGS_SIZE note, move it to LAST.  */\n \n static void\n-adjust_frame_related_expr (rtx last_sp_set, rtx insn,\n-\t\t\t   HOST_WIDE_INT this_adjust)\n+maybe_move_args_size_note (rtx last, rtx insn)\n {\n-  rtx note = find_reg_note (last_sp_set, REG_FRAME_RELATED_EXPR, NULL_RTX);\n-  rtx new_expr = NULL_RTX;\n+  rtx note, last_note;\n \n-  if (note == NULL_RTX && RTX_FRAME_RELATED_P (insn))\n+  note = find_reg_note (insn, REG_ARGS_SIZE, NULL_RTX);\n+  if (note == NULL)\n     return;\n \n-  if (note\n-      && GET_CODE (XEXP (note, 0)) == SEQUENCE\n-      && XVECLEN (XEXP (note, 0), 0) >= 2)\n-    {\n-      rtx expr = XEXP (note, 0);\n-      rtx last = XVECEXP (expr, 0, XVECLEN (expr, 0) - 1);\n-      int i;\n-\n-      if (GET_CODE (last) == SET\n-\t  && RTX_FRAME_RELATED_P (last) == RTX_FRAME_RELATED_P (insn)\n-\t  && SET_DEST (last) == stack_pointer_rtx\n-\t  && GET_CODE (SET_SRC (last)) == PLUS\n-\t  && XEXP (SET_SRC (last), 0) == stack_pointer_rtx\n-\t  && CONST_INT_P (XEXP (SET_SRC (last), 1)))\n-\t{\n-\t  XEXP (SET_SRC (last), 1)\n-\t    = GEN_INT (INTVAL (XEXP (SET_SRC (last), 1)) + this_adjust);\n-\t  return;\n-\t}\n-\n-      new_expr = gen_rtx_SEQUENCE (VOIDmode,\n-\t\t\t\t   rtvec_alloc (XVECLEN (expr, 0) + 1));\n-      for (i = 0; i < XVECLEN (expr, 0); i++)\n-\tXVECEXP (new_expr, 0, i) = XVECEXP (expr, 0, i);\n-    }\n-  else\n-    {\n-      new_expr = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (2));\n-      if (note)\n-\tXVECEXP (new_expr, 0, 0) = XEXP (note, 0);\n-      else\n-\t{\n-\t  rtx expr = copy_rtx (single_set_for_csa (last_sp_set));\n-\n-\t  XEXP (SET_SRC (expr), 1)\n-\t    = GEN_INT (INTVAL (XEXP (SET_SRC (expr), 1)) - this_adjust);\n-\t  RTX_FRAME_RELATED_P (expr) = 1;\n-\t  XVECEXP (new_expr, 0, 0) = expr;\n-\t}\n-    }\n-\n-  XVECEXP (new_expr, 0, XVECLEN (new_expr, 0) - 1)\n-    = copy_rtx (single_set_for_csa (insn));\n-  RTX_FRAME_RELATED_P (XVECEXP (new_expr, 0, XVECLEN (new_expr, 0) - 1))\n-    = RTX_FRAME_RELATED_P (insn);\n-  if (note)\n-    XEXP (note, 0) = new_expr;\n+  last_note = find_reg_note (last, REG_ARGS_SIZE, NULL_RTX);\n+  if (last_note)\n+    XEXP (last_note, 0) = XEXP (note, 0);\n   else\n-    add_reg_note (last_sp_set, REG_FRAME_RELATED_EXPR, new_expr);\n+    add_reg_note (last, REG_ARGS_SIZE, XEXP (note, 0));\n }\n \n /* Subroutine of combine_stack_adjustments, called for each basic block.  */\n@@ -431,9 +385,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t\t\t\t\t  last_sp_adjust + this_adjust,\n \t\t\t\t\t\t  this_adjust))\n \t\t    {\n-\t\t      if (RTX_FRAME_RELATED_P (last_sp_set))\n-\t\t\tadjust_frame_related_expr (last_sp_set, insn,\n-\t\t\t\t\t\t   this_adjust);\n+\t\t      maybe_move_args_size_note (last_sp_set, insn);\n+\n \t\t      /* It worked!  */\n \t\t      delete_insn (insn);\n \t\t      last_sp_adjust += this_adjust;"}, {"sha": "c24f08114cbfab985fbfe05ac0fa2b4200ffcbd9", "filename": "gcc/combine.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -13273,6 +13273,16 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t    }\n \t  break;\n \n+\tcase REG_ARGS_SIZE:\n+\t  {\n+\t    /* ??? How to distribute between i3-i1.  Assume i3 contains the\n+\t       entire adjustment.  Assert i3 contains at least some adjust.  */\n+\t    int old_size, args_size = INTVAL (XEXP (note, 0));\n+\t    old_size = fixup_args_size_notes (PREV_INSN (i3), i3, args_size);\n+\t    gcc_assert (old_size != args_size);\n+\t  }\n+\t  break;\n+\n \tcase REG_NORETURN:\n \tcase REG_SETJMP:\n \t  /* These notes must remain with the call.  It should not be"}, {"sha": "f6ab38d4b2cb048e3dd6593dd9d8456d29a2792f", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 274, "deletions": 368, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -70,9 +70,6 @@ typedef struct GTY(()) dw_cfi_row_struct\n \n   /* The expressions for any register column that is saved.  */\n   cfi_vec reg_save;\n-\n-  /* The value of any DW_CFA_GNU_args_size.  */\n-  HOST_WIDE_INT args_size;\n } dw_cfi_row;\n \n /* The caller's ORIG_REG is saved in SAVED_IN_REG.  */\n@@ -109,6 +106,16 @@ typedef struct\n   /* The row state at the beginning and end of the trace.  */\n   dw_cfi_row *beg_row, *end_row;\n \n+  /* Tracking for DW_CFA_GNU_args_size.  The \"true\" sizes are those we find\n+     while scanning insns.  However, the args_size value is irrelevant at\n+     any point except can_throw_internal_p insns.  Therefore the \"delay\"\n+     sizes the values that must actually be emitted for this trace.  */\n+  HOST_WIDE_INT beg_true_args_size, end_true_args_size;\n+  HOST_WIDE_INT beg_delay_args_size, end_delay_args_size;\n+\n+  /* The first EH insn in the trace, where beg_delay_args_size must be set.  */\n+  rtx eh_head;\n+\n   /* The following variables contain data used in interpreting frame related\n      expressions.  These are not part of the \"real\" row state as defined by\n      Dwarf, but it seems like they need to be propagated into a trace in case\n@@ -141,6 +148,9 @@ typedef struct\n \n   /* True if this trace immediately follows NOTE_INSN_SWITCH_TEXT_SECTIONS.  */\n   bool switch_sections;\n+\n+  /* True if we've seen different values incoming to beg_true_args_size.  */\n+  bool args_size_undefined;\n } dw_trace_info;\n \n DEF_VEC_O (dw_trace_info);\n@@ -179,6 +189,10 @@ static dw_trace_info *cur_trace;\n /* The current, i.e. most recently generated, row of the CFI table.  */\n static dw_cfi_row *cur_row;\n \n+/* A copy of the current CFA, for use during the processing of a\n+   single insn.  */\n+static dw_cfa_location *cur_cfa;\n+\n /* We delay emitting a register save until either (a) we reach the end\n    of the prologue or (b) the register is clobbered.  This clusters\n    register saves so that there are fewer pc advances.  */\n@@ -194,10 +208,6 @@ DEF_VEC_ALLOC_O (queued_reg_save, heap);\n \n static VEC(queued_reg_save, heap) *queued_reg_saves;\n \n-/* The (really) current value for DW_CFA_GNU_args_size.  We delay actually\n-   emitting this data, i.e. updating CUR_ROW, without async unwind.  */\n-static HOST_WIDE_INT queued_args_size;\n-\n /* True if any CFI directives were emitted at the current insn.  */\n static bool any_cfis_emitted;\n \n@@ -413,6 +423,10 @@ add_cfi_args_size (HOST_WIDE_INT size)\n {\n   dw_cfi_ref cfi = new_cfi ();\n \n+  /* While we can occasionally have args_size < 0 internally, this state\n+     should not persist at a point we actually need an opcode.  */\n+  gcc_assert (size >= 0);\n+\n   cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n   cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n \n@@ -663,16 +677,6 @@ cfi_row_equal_p (dw_cfi_row *a, dw_cfi_row *b)\n   else if (!cfa_equal_p (&a->cfa, &b->cfa))\n     return false;\n \n-  /* Logic suggests that we compare args_size here.  However, if\n-     EXIT_IGNORE_STACK we don't bother tracking the args_size after\n-     the last time it really matters within the function.  This does\n-     in fact lead to paths with differing arg_size, but in cases for\n-     which it doesn't matter.  */\n-  /* ??? If we really want to sanity check the output of the optimizers,\n-     find a way to backtrack from epilogues to the last EH site.  This\n-     would allow us to distinguish regions with garbage args_size and\n-     regions where paths ought to agree.  */\n-\n   n_a = VEC_length (dw_cfi_ref, a->reg_save);\n   n_b = VEC_length (dw_cfi_ref, b->reg_save);\n   n_max = MAX (n_a, n_b);\n@@ -836,214 +840,66 @@ reg_save (unsigned int reg, unsigned int sreg, HOST_WIDE_INT offset)\n   update_row_reg_save (cur_row, reg, cfi);\n }\n \n-/* Given a SET, calculate the amount of stack adjustment it\n-   contains.  */\n-\n-static HOST_WIDE_INT\n-stack_adjust_offset (const_rtx pattern, HOST_WIDE_INT cur_args_size,\n-\t\t     HOST_WIDE_INT cur_offset)\n-{\n-  const_rtx src = SET_SRC (pattern);\n-  const_rtx dest = SET_DEST (pattern);\n-  HOST_WIDE_INT offset = 0;\n-  enum rtx_code code;\n-\n-  if (dest == stack_pointer_rtx)\n-    {\n-      code = GET_CODE (src);\n-\n-      /* Assume (set (reg sp) (reg whatever)) sets args_size\n-\t level to 0.  */\n-      if (code == REG && src != stack_pointer_rtx)\n-\t{\n-\t  offset = -cur_args_size;\n-#ifndef STACK_GROWS_DOWNWARD\n-\t  offset = -offset;\n-#endif\n-\t  return offset - cur_offset;\n-\t}\n-\n-      if (! (code == PLUS || code == MINUS)\n-\t  || XEXP (src, 0) != stack_pointer_rtx\n-\t  || !CONST_INT_P (XEXP (src, 1)))\n-\treturn 0;\n-\n-      /* (set (reg sp) (plus (reg sp) (const_int))) */\n-      offset = INTVAL (XEXP (src, 1));\n-      if (code == PLUS)\n-\toffset = -offset;\n-      return offset;\n-    }\n-\n-  if (MEM_P (src) && !MEM_P (dest))\n-    dest = src;\n-  if (MEM_P (dest))\n-    {\n-      /* (set (mem (pre_dec (reg sp))) (foo)) */\n-      src = XEXP (dest, 0);\n-      code = GET_CODE (src);\n-\n-      switch (code)\n-\t{\n-\tcase PRE_MODIFY:\n-\tcase POST_MODIFY:\n-\t  if (XEXP (src, 0) == stack_pointer_rtx)\n-\t    {\n-\t      rtx val = XEXP (XEXP (src, 1), 1);\n-\t      /* We handle only adjustments by constant amount.  */\n-\t      gcc_assert (GET_CODE (XEXP (src, 1)) == PLUS\n-\t\t\t  && CONST_INT_P (val));\n-\t      offset = -INTVAL (val);\n-\t      break;\n-\t    }\n-\t  return 0;\n-\n-\tcase PRE_DEC:\n-\tcase POST_DEC:\n-\t  if (XEXP (src, 0) == stack_pointer_rtx)\n-\t    {\n-\t      offset = GET_MODE_SIZE (GET_MODE (dest));\n-\t      break;\n-\t    }\n-\t  return 0;\n-\n-\tcase PRE_INC:\n-\tcase POST_INC:\n-\t  if (XEXP (src, 0) == stack_pointer_rtx)\n-\t    {\n-\t      offset = -GET_MODE_SIZE (GET_MODE (dest));\n-\t      break;\n-\t    }\n-\t  return 0;\n-\n-\tdefault:\n-\t  return 0;\n-\t}\n-    }\n-  else\n-    return 0;\n-\n-  return offset;\n-}\n-\n-/* Add a CFI to update the running total of the size of arguments\n-   pushed onto the stack.  */\n+/* A subroutine of scan_trace.  Check INSN for a REG_ARGS_SIZE note\n+   and adjust data structures to match.  */\n \n static void\n-dwarf2out_args_size (HOST_WIDE_INT size)\n+notice_args_size (rtx insn)\n {\n-  if (size == cur_row->args_size)\n-    return;\n-\n-  cur_row->args_size = size;\n-  add_cfi_args_size (size);\n-}\n+  HOST_WIDE_INT args_size, delta;\n+  rtx note;\n \n-/* Record a stack adjustment of OFFSET bytes.  */\n-\n-static void\n-dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n-{\n-  dw_cfa_location loc = cur_row->cfa;\n+  note = find_reg_note (insn, REG_ARGS_SIZE, NULL);\n+  if (note == NULL)\n+    return;\n \n-  if (loc.reg == dw_stack_pointer_regnum)\n-    loc.offset += offset;\n+  args_size = INTVAL (XEXP (note, 0));\n+  delta = args_size - cur_trace->end_true_args_size;\n+  if (delta == 0)\n+    return;\n \n-  if (cur_trace->cfa_store.reg == dw_stack_pointer_regnum)\n-    cur_trace->cfa_store.offset += offset;\n+  cur_trace->end_true_args_size = args_size;\n \n-  /* ??? The assumption seems to be that if A_O_A, the only CFA adjustments\n-     involving the stack pointer are inside the prologue and marked as\n-     RTX_FRAME_RELATED_P.  That said, should we not verify this assumption\n-     by *asserting* A_O_A at this point?  Why else would we have a change\n-     to the stack pointer?  */\n-  if (ACCUMULATE_OUTGOING_ARGS)\n-    return;\n+  /* If the CFA is computed off the stack pointer, then we must adjust\n+     the computation of the CFA as well.  */\n+  if (cur_cfa->reg == dw_stack_pointer_regnum)\n+    {\n+      gcc_assert (!cur_cfa->indirect);\n \n+      /* Convert a change in args_size (always a positive in the\n+\t direction of stack growth) to a change in stack pointer.  */\n #ifndef STACK_GROWS_DOWNWARD\n-  offset = -offset;\n+      delta = -delta;\n #endif\n-\n-  queued_args_size += offset;\n-  if (queued_args_size < 0)\n-    queued_args_size = 0;\n-\n-  def_cfa_1 (&loc);\n-  if (flag_asynchronous_unwind_tables)\n-    dwarf2out_args_size (queued_args_size);\n+      cur_cfa->offset += delta;\n+    }\n }\n \n-/* Check INSN to see if it looks like a push or a stack adjustment, and\n-   make a note of it if it does.  EH uses this information to find out\n-   how much extra space it needs to pop off the stack.  */\n+/* A subroutine of scan_trace.  INSN is can_throw_internal.  Update the\n+   data within the trace related to EH insns and args_size.  */\n \n static void\n-dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n+notice_eh_throw (rtx insn)\n {\n-  HOST_WIDE_INT offset;\n-  int i;\n-\n-  /* Don't handle epilogues at all.  Certainly it would be wrong to do so\n-     with this function.  Proper support would require all frame-related\n-     insns to be marked, and to be able to handle saving state around\n-     epilogues textually in the middle of the function.  */\n-  if (prologue_epilogue_contains (insn))\n-    return;\n-\n-  /* If INSN is an instruction from target of an annulled branch, the\n-     effects are for the target only and so current argument size\n-     shouldn't change at all.  */\n-  if (final_sequence\n-      && INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))\n-      && INSN_FROM_TARGET_P (insn))\n-    return;\n+  HOST_WIDE_INT args_size;\n \n-  /* If only calls can throw, and we have a frame pointer,\n-     save up adjustments until we see the CALL_INSN.  */\n-  if (!flag_asynchronous_unwind_tables\n-      && cur_row->cfa.reg != dw_stack_pointer_regnum)\n+  args_size = cur_trace->end_true_args_size;\n+  if (cur_trace->eh_head == NULL)\n     {\n-      if (CALL_P (insn) && !after_p)\n-\t{\n-\t  /* Extract the size of the args from the CALL rtx itself.  */\n-\t  insn = PATTERN (insn);\n-\t  if (GET_CODE (insn) == PARALLEL)\n-\t    insn = XVECEXP (insn, 0, 0);\n-\t  if (GET_CODE (insn) == SET)\n-\t    insn = SET_SRC (insn);\n-\t  gcc_assert (GET_CODE (insn) == CALL);\n-\t  dwarf2out_args_size (INTVAL (XEXP (insn, 1)));\n-\t}\n-      return;\n+      cur_trace->eh_head = insn;\n+      cur_trace->beg_delay_args_size = args_size;\n+      cur_trace->end_delay_args_size = args_size;\n     }\n-\n-  if (CALL_P (insn) && !after_p)\n+  else if (cur_trace->end_delay_args_size != args_size)\n     {\n-      if (!flag_asynchronous_unwind_tables)\n-\tdwarf2out_args_size (queued_args_size);\n-      return;\n-    }\n-  else if (BARRIER_P (insn))\n-    return;\n-  else if (GET_CODE (PATTERN (insn)) == SET)\n-    offset = stack_adjust_offset (PATTERN (insn), queued_args_size, 0);\n-  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t   || GET_CODE (PATTERN (insn)) == SEQUENCE)\n-    {\n-      /* There may be stack adjustments inside compound insns.  Search\n-\t for them.  */\n-      for (offset = 0, i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n-\t  offset += stack_adjust_offset (XVECEXP (PATTERN (insn), 0, i),\n-\t\t\t\t\t queued_args_size, offset);\n-    }\n-  else\n-    return;\n-\n-  if (offset == 0)\n-    return;\n+      cur_trace->end_delay_args_size = args_size;\n \n-  dwarf2out_stack_adjust (offset);\n+      /* ??? If the CFA is the stack pointer, search backward for the last\n+\t CFI note and insert there.  Given that the stack changed for the\n+\t args_size change, there *must* be such a note in between here and\n+\t the last eh insn.  */\n+      add_cfi_args_size (args_size);\n+    }\n }\n \n /* Short-hand inline for the very common D_F_R (REGNO (x)) operation.  */\n@@ -1201,39 +1057,34 @@ reg_saved_in (rtx reg)\n static void\n dwarf2out_frame_debug_def_cfa (rtx pat)\n {\n-  dw_cfa_location loc;\n-\n-  memset (&loc, 0, sizeof (loc));\n+  memset (cur_cfa, 0, sizeof (*cur_cfa));\n \n   if (GET_CODE (pat) == PLUS)\n     {\n-      loc.offset = INTVAL (XEXP (pat, 1));\n+      cur_cfa->offset = INTVAL (XEXP (pat, 1));\n       pat = XEXP (pat, 0);\n     }\n   if (MEM_P (pat))\n     {\n-      loc.indirect = 1;\n+      cur_cfa->indirect = 1;\n       pat = XEXP (pat, 0);\n       if (GET_CODE (pat) == PLUS)\n \t{\n-\t  loc.base_offset = INTVAL (XEXP (pat, 1));\n+\t  cur_cfa->base_offset = INTVAL (XEXP (pat, 1));\n \t  pat = XEXP (pat, 0);\n \t}\n     }\n   /* ??? If this fails, we could be calling into the _loc functions to\n      define a full expression.  So far no port does that.  */\n   gcc_assert (REG_P (pat));\n-  loc.reg = dwf_regno (pat);\n-\n-  def_cfa_1 (&loc);\n+  cur_cfa->reg = dwf_regno (pat);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_ADJUST_CFA note.  */\n \n static void\n dwarf2out_frame_debug_adjust_cfa (rtx pat)\n {\n-  dw_cfa_location loc = cur_row->cfa;\n   rtx src, dest;\n \n   gcc_assert (GET_CODE (pat) == SET);\n@@ -1243,21 +1094,19 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n   switch (GET_CODE (src))\n     {\n     case PLUS:\n-      gcc_assert (dwf_regno (XEXP (src, 0)) == loc.reg);\n-      loc.offset -= INTVAL (XEXP (src, 1));\n+      gcc_assert (dwf_regno (XEXP (src, 0)) == cur_cfa->reg);\n+      cur_cfa->offset -= INTVAL (XEXP (src, 1));\n       break;\n \n     case REG:\n-\tbreak;\n+      break;\n \n     default:\n-\tgcc_unreachable ();\n+      gcc_unreachable ();\n     }\n \n-  loc.reg = dwf_regno (dest);\n-  gcc_assert (loc.indirect == 0);\n-\n-  def_cfa_1 (&loc);\n+  cur_cfa->reg = dwf_regno (dest);\n+  gcc_assert (cur_cfa->indirect == 0);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_OFFSET note.  */\n@@ -1278,12 +1127,12 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      gcc_assert (dwf_regno (addr) == cur_row->cfa.reg);\n-      offset = -cur_row->cfa.offset;\n+      gcc_assert (dwf_regno (addr) == cur_cfa->reg);\n+      offset = -cur_cfa->offset;\n       break;\n     case PLUS:\n-      gcc_assert (dwf_regno (XEXP (addr, 0)) == cur_row->cfa.reg);\n-      offset = INTVAL (XEXP (addr, 1)) - cur_row->cfa.offset;\n+      gcc_assert (dwf_regno (XEXP (addr, 0)) == cur_cfa->reg);\n+      offset = INTVAL (XEXP (addr, 1)) - cur_cfa->offset;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -1451,7 +1300,7 @@ dwarf2out_frame_debug_cfa_window_save (void)\n \n   cfa\t       current rule for calculating the CFA.  It usually\n \t       consists of a register and an offset.  This is\n-\t       actually stored in cur_row->cfa, but abbreviated\n+\t       actually stored in *cur_cfa, but abbreviated\n \t       for the purposes of this documentation.\n   cfa_store    register used by prologue code to save things to the stack\n \t       cfa_store.offset is the offset from the value of\n@@ -1606,7 +1455,6 @@ dwarf2out_frame_debug_cfa_window_save (void)\n static void\n dwarf2out_frame_debug_expr (rtx expr)\n {\n-  dw_cfa_location cfa = cur_row->cfa;\n   rtx src, dest, span;\n   HOST_WIDE_INT offset;\n   dw_fde_ref fde;\n@@ -1644,18 +1492,6 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      && (!MEM_P (SET_DEST (elem)) || GET_CODE (expr) == SEQUENCE)\n \t      && (RTX_FRAME_RELATED_P (elem) || par_index == 0))\n \t    dwarf2out_frame_debug_expr (elem);\n-\t  else if (GET_CODE (elem) == SET\n-\t\t   && par_index != 0\n-\t\t   && !RTX_FRAME_RELATED_P (elem))\n-\t    {\n-\t      /* Stack adjustment combining might combine some post-prologue\n-\t\t stack adjustment into a prologue stack adjustment.  */\n-\t      HOST_WIDE_INT offset\n-\t\t= stack_adjust_offset (elem, queued_args_size, 0);\n-\n-\t      if (offset != 0)\n-\t\tdwarf2out_stack_adjust (offset);\n-\t    }\n \t}\n       return;\n     }\n@@ -1681,7 +1517,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t{\n \t  /* Setting FP from SP.  */\n \tcase REG:\n-\t  if (cfa.reg == dwf_regno (src))\n+\t  if (cur_cfa->reg == dwf_regno (src))\n \t    {\n \t      /* Rule 1 */\n \t      /* Update the CFA rule wrt SP or FP.  Make sure src is\n@@ -1691,9 +1527,9 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t ARM copies SP to a temporary register, and from there to\n \t\t FP.  So we just rely on the backends to only set\n \t\t RTX_FRAME_RELATED_P on appropriate insns.  */\n-\t      cfa.reg = dwf_regno (dest);\n-\t      cur_trace->cfa_temp.reg = cfa.reg;\n-\t      cur_trace->cfa_temp.offset = cfa.offset;\n+\t      cur_cfa->reg = dwf_regno (dest);\n+\t      cur_trace->cfa_temp.reg = cur_cfa->reg;\n+\t      cur_trace->cfa_temp.offset = cur_cfa->offset;\n \t    }\n \t  else\n \t    {\n@@ -1711,7 +1547,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t  && REGNO (src) == STACK_POINTER_REGNUM)\n \t\tgcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n \t\t\t    && fde->drap_reg != INVALID_REGNUM\n-\t\t\t    && cfa.reg != dwf_regno (src));\n+\t\t\t    && cur_cfa->reg != dwf_regno (src));\n \t      else\n \t\tqueue_reg_save (src, dest, 0);\n \t    }\n@@ -1741,8 +1577,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n \t\t{\n \t\t  /* Restoring SP from FP in the epilogue.  */\n-\t\t  gcc_assert (cfa.reg == dw_frame_pointer_regnum);\n-\t\t  cfa.reg = dw_stack_pointer_regnum;\n+\t\t  gcc_assert (cur_cfa->reg == dw_frame_pointer_regnum);\n+\t\t  cur_cfa->reg = dw_stack_pointer_regnum;\n \t\t}\n \t      else if (GET_CODE (src) == LO_SUM)\n \t\t/* Assume we've set the source reg of the LO_SUM from sp.  */\n@@ -1752,8 +1588,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n-\t      if (cfa.reg == dw_stack_pointer_regnum)\n-\t\tcfa.offset += offset;\n+\t      if (cur_cfa->reg == dw_stack_pointer_regnum)\n+\t\tcur_cfa->offset += offset;\n \t      if (cur_trace->cfa_store.reg == dw_stack_pointer_regnum)\n \t\tcur_trace->cfa_store.offset += offset;\n \t    }\n@@ -1765,31 +1601,31 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      gcc_assert (frame_pointer_needed);\n \n \t      gcc_assert (REG_P (XEXP (src, 0))\n-\t\t\t  && dwf_regno (XEXP (src, 0)) == cfa.reg\n+\t\t\t  && dwf_regno (XEXP (src, 0)) == cur_cfa->reg\n \t\t\t  && CONST_INT_P (XEXP (src, 1)));\n \t      offset = INTVAL (XEXP (src, 1));\n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n-\t      cfa.offset += offset;\n-\t      cfa.reg = dw_frame_pointer_regnum;\n+\t      cur_cfa->offset += offset;\n+\t      cur_cfa->reg = dw_frame_pointer_regnum;\n \t    }\n \t  else\n \t    {\n \t      gcc_assert (GET_CODE (src) != MINUS);\n \n \t      /* Rule 4 */\n \t      if (REG_P (XEXP (src, 0))\n-\t\t  && dwf_regno (XEXP (src, 0)) == cfa.reg\n+\t\t  && dwf_regno (XEXP (src, 0)) == cur_cfa->reg\n \t\t  && CONST_INT_P (XEXP (src, 1)))\n \t\t{\n \t\t  /* Setting a temporary CFA register that will be copied\n \t\t     into the FP later on.  */\n \t\t  offset = - INTVAL (XEXP (src, 1));\n-\t\t  cfa.offset += offset;\n-\t\t  cfa.reg = dwf_regno (dest);\n+\t\t  cur_cfa->offset += offset;\n+\t\t  cur_cfa->reg = dwf_regno (dest);\n \t\t  /* Or used to save regs to the stack.  */\n-\t\t  cur_trace->cfa_temp.reg = cfa.reg;\n-\t\t  cur_trace->cfa_temp.offset = cfa.offset;\n+\t\t  cur_trace->cfa_temp.reg = cur_cfa->reg;\n+\t\t  cur_trace->cfa_temp.offset = cur_cfa->offset;\n \t\t}\n \n \t      /* Rule 5 */\n@@ -1799,10 +1635,10 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n \t\t     of SP for saving registers to the stack.  */\n-\t\t  gcc_assert (cfa.reg == dw_stack_pointer_regnum);\n+\t\t  gcc_assert (cur_cfa->reg == dw_stack_pointer_regnum);\n \t\t  cur_trace->cfa_store.reg = dwf_regno (dest);\n \t\t  cur_trace->cfa_store.offset\n-\t\t    = cfa.offset - cur_trace->cfa_temp.offset;\n+\t\t    = cur_cfa->offset - cur_trace->cfa_temp.offset;\n \t\t}\n \n \t      /* Rule 9 */\n@@ -1863,17 +1699,15 @@ dwarf2out_frame_debug_expr (rtx expr)\n               fde->stack_realignment = INTVAL (XEXP (src, 1));\n               cur_trace->cfa_store.offset = 0;\n \n-\t      if (cfa.reg != dw_stack_pointer_regnum\n-\t\t  && cfa.reg != dw_frame_pointer_regnum)\n-\t\tfde->drap_reg = cfa.reg;\n+\t      if (cur_cfa->reg != dw_stack_pointer_regnum\n+\t\t  && cur_cfa->reg != dw_frame_pointer_regnum)\n+\t\tfde->drap_reg = cur_cfa->reg;\n             }\n           return;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-\n-      def_cfa_1 (&cfa);\n       break;\n \n     case MEM:\n@@ -1895,8 +1729,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t      && cur_trace->cfa_store.reg == dw_stack_pointer_regnum);\n \n \t  cur_trace->cfa_store.offset += offset;\n-\t  if (cfa.reg == dw_stack_pointer_regnum)\n-\t    cfa.offset = cur_trace->cfa_store.offset;\n+\t  if (cur_cfa->reg == dw_stack_pointer_regnum)\n+\t    cur_cfa->offset = cur_trace->cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_MODIFY)\n \t    offset -= cur_trace->cfa_store.offset;\n@@ -1925,12 +1759,12 @@ dwarf2out_frame_debug_expr (rtx expr)\n               && fde->stack_realign\n               && src == hard_frame_pointer_rtx)\n \t    {\n-\t      gcc_assert (cfa.reg != dw_frame_pointer_regnum);\n+\t      gcc_assert (cur_cfa->reg != dw_frame_pointer_regnum);\n \t      cur_trace->cfa_store.offset = 0;\n \t    }\n \n-\t  if (cfa.reg == dw_stack_pointer_regnum)\n-\t    cfa.offset = cur_trace->cfa_store.offset;\n+\t  if (cur_cfa->reg == dw_stack_pointer_regnum)\n+\t    cur_cfa->offset = cur_trace->cfa_store.offset;\n \n \t  if (GET_CODE (XEXP (dest, 0)) == POST_DEC)\n \t    offset += -cur_trace->cfa_store.offset;\n@@ -1954,8 +1788,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t    regno = dwf_regno (XEXP (XEXP (dest, 0), 0));\n \n-\t    if (cfa.reg == regno)\n-\t      offset -= cfa.offset;\n+\t    if (cur_cfa->reg == regno)\n+\t      offset -= cur_cfa->offset;\n \t    else if (cur_trace->cfa_store.reg == regno)\n \t      offset -= cur_trace->cfa_store.offset;\n \t    else\n@@ -1972,8 +1806,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  {\n \t    unsigned int regno = dwf_regno (XEXP (dest, 0));\n \n-\t    if (cfa.reg == regno)\n-\t      offset = -cfa.offset;\n+\t    if (cur_cfa->reg == regno)\n+\t      offset = -cur_cfa->offset;\n \t    else if (cur_trace->cfa_store.reg == regno)\n \t      offset = -cur_trace->cfa_store.offset;\n \t    else\n@@ -2005,11 +1839,11 @@ dwarf2out_frame_debug_expr (rtx expr)\n       if (REG_P (src)\n \t  && REGNO (src) != STACK_POINTER_REGNUM\n \t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n-\t  && dwf_regno (src) == cfa.reg)\n+\t  && dwf_regno (src) == cur_cfa->reg)\n \t{\n \t  /* We're storing the current CFA reg into the stack.  */\n \n-\t  if (cfa.offset == 0)\n+\t  if (cur_cfa->offset == 0)\n \t    {\n               /* Rule 19 */\n               /* If stack is aligned, putting CFA reg into stack means\n@@ -2019,28 +1853,23 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t value.  */\n               if (fde\n                   && fde->stack_realign\n-                  && cfa.indirect == 0\n-                  && cfa.reg != dw_frame_pointer_regnum)\n+                  && cur_cfa->indirect == 0\n+                  && cur_cfa->reg != dw_frame_pointer_regnum)\n                 {\n-\t\t  dw_cfa_location cfa_exp;\n-\n-\t\t  gcc_assert (fde->drap_reg == cfa.reg);\n+\t\t  gcc_assert (fde->drap_reg == cur_cfa->reg);\n \n-\t\t  cfa_exp.indirect = 1;\n-\t\t  cfa_exp.reg = dw_frame_pointer_regnum;\n-\t\t  cfa_exp.base_offset = offset;\n-\t\t  cfa_exp.offset = 0;\n+\t\t  cur_cfa->indirect = 1;\n+\t\t  cur_cfa->reg = dw_frame_pointer_regnum;\n+\t\t  cur_cfa->base_offset = offset;\n+\t\t  cur_cfa->offset = 0;\n \n \t\t  fde->drap_reg_saved = 1;\n-\n-\t\t  def_cfa_1 (&cfa_exp);\n \t\t  break;\n                 }\n \n \t      /* If the source register is exactly the CFA, assume\n \t\t we're saving SP like any other register; this happens\n \t\t on the ARM.  */\n-\t      def_cfa_1 (&cfa);\n \t      queue_reg_save (stack_pointer_rtx, NULL_RTX, offset);\n \t      break;\n \t    }\n@@ -2054,16 +1883,13 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\tx = XEXP (x, 0);\n \t      gcc_assert (REG_P (x));\n \n-\t      cfa.reg = dwf_regno (x);\n-\t      cfa.base_offset = offset;\n-\t      cfa.indirect = 1;\n-\t      def_cfa_1 (&cfa);\n+\t      cur_cfa->reg = dwf_regno (x);\n+\t      cur_cfa->base_offset = offset;\n+\t      cur_cfa->indirect = 1;\n \t      break;\n \t    }\n \t}\n \n-      def_cfa_1 (&cfa);\n-\n       span = NULL;\n       if (REG_P (src))\n \tspan = targetm.dwarf_register_span (src);\n@@ -2094,33 +1920,17 @@ dwarf2out_frame_debug_expr (rtx expr)\n     }\n }\n \n-/* Record call frame debugging information for INSN, which either\n-   sets SP or FP (adjusting how we calculate the frame address) or saves a\n-   register to the stack.  If INSN is NULL_RTX, initialize our state.\n-\n-   If AFTER_P is false, we're being called before the insn is emitted,\n-   otherwise after.  Call instructions get invoked twice.  */\n+/* Record call frame debugging information for INSN, which either sets\n+   SP or FP (adjusting how we calculate the frame address) or saves a\n+   register to the stack.  */\n \n static void\n-dwarf2out_frame_debug (rtx insn, bool after_p)\n+dwarf2out_frame_debug (rtx insn)\n {\n   rtx note, n;\n   bool handled_one = false;\n   bool need_flush = false;\n \n-  if (!NONJUMP_INSN_P (insn) || clobbers_queued_reg_save (insn))\n-    dwarf2out_flush_queued_reg_saves ();\n-\n-  if (!RTX_FRAME_RELATED_P (insn))\n-    {\n-      /* ??? This should be done unconditionally since stack adjustments\n-\t matter if the stack pointer is not the CFA register anymore but\n-\t is still used to save registers.  */\n-      if (!ACCUMULATE_OUTGOING_ARGS)\n-\tdwarf2out_notice_stack_adjust (insn, after_p);\n-      return;\n-    }\n-\n   any_cfis_emitted = false;\n \n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n@@ -2258,9 +2068,6 @@ change_cfi_row (dw_cfi_row *old_row, dw_cfi_row *new_row)\n \tadd_cfi (cfi);\n     }\n \n-  if (old_row->args_size != new_row->args_size)\n-    add_cfi_args_size (new_row->args_size);\n-\n   n_old = VEC_length (dw_cfi_ref, old_row->reg_save);\n   n_new = VEC_length (dw_cfi_ref, new_row->reg_save);\n   n_max = MAX (n_old, n_new);\n@@ -2384,14 +2191,10 @@ add_cfis_to_fde (void)\n    trace from CUR_TRACE and CUR_ROW.  */\n \n static void\n-maybe_record_trace_start (rtx start, rtx origin, bool abnormal)\n+maybe_record_trace_start (rtx start, rtx origin)\n {\n   dw_trace_info *ti;\n-\n-  /* Sync queued data before propagating to a destination,\n-     lest we propagate out-of-date data.  */\n-  dwarf2out_flush_queued_reg_saves ();\n-  dwarf2out_args_size (queued_args_size);\n+  HOST_WIDE_INT args_size;\n \n   ti = get_trace_info (start);\n   gcc_assert (ti != NULL);\n@@ -2404,15 +2207,13 @@ maybe_record_trace_start (rtx start, rtx origin, bool abnormal)\n \t       (origin ? INSN_UID (origin) : 0));\n     }\n \n+  args_size = cur_trace->end_true_args_size;\n   if (ti->beg_row == NULL)\n     {\n       /* This is the first time we've encountered this trace.  Propagate\n \t state across the edge and push the trace onto the work list.  */\n       ti->beg_row = copy_cfi_row (cur_row);\n-      /* On all abnormal edges, especially EH and non-local-goto, we take\n-\t care to free the pushed arguments.  */\n-      if (abnormal)\n-\tti->beg_row->args_size = 0;\n+      ti->beg_true_args_size = args_size;\n \n       ti->cfa_store = cur_trace->cfa_store;\n       ti->cfa_temp = cur_trace->cfa_temp;\n@@ -2426,11 +2227,52 @@ maybe_record_trace_start (rtx start, rtx origin, bool abnormal)\n     }\n   else\n     {\n+\n       /* We ought to have the same state incoming to a given trace no\n \t matter how we arrive at the trace.  Anything else means we've\n \t got some kind of optimization error.  */\n       gcc_checking_assert (cfi_row_equal_p (cur_row, ti->beg_row));\n+\n+      /* The args_size is allowed to conflict if it isn't actually used.  */\n+      if (ti->beg_true_args_size != args_size)\n+\tti->args_size_undefined = true;\n+    }\n+}\n+\n+/* Similarly, but handle the args_size and CFA reset across EH\n+   and non-local goto edges.  */\n+\n+static void\n+maybe_record_trace_start_abnormal (rtx start, rtx origin)\n+{\n+  HOST_WIDE_INT save_args_size, delta;\n+  dw_cfa_location save_cfa;\n+\n+  save_args_size = cur_trace->end_true_args_size;\n+  if (save_args_size == 0)\n+    {\n+      maybe_record_trace_start (start, origin);\n+      return;\n+    }\n+\n+  delta = -save_args_size;\n+  cur_trace->end_true_args_size = 0;\n+\n+  save_cfa = cur_row->cfa;\n+  if (cur_row->cfa.reg == dw_stack_pointer_regnum)\n+    {\n+      /* Convert a change in args_size (always a positive in the\n+\t direction of stack growth) to a change in stack pointer.  */\n+#ifndef STACK_GROWS_DOWNWARD\n+      delta = -delta;\n+#endif\n+      cur_row->cfa.offset += delta;\n     }\n+  \n+  maybe_record_trace_start (start, origin);\n+\n+  cur_trace->end_true_args_size = save_args_size;\n+  cur_row->cfa = save_cfa;\n }\n \n /* Propagate CUR_TRACE state to the destinations implied by INSN.  */\n@@ -2445,8 +2287,9 @@ create_trace_edges (rtx insn)\n   if (JUMP_P (insn))\n     {\n       if (find_reg_note (insn, REG_NON_LOCAL_GOTO, NULL_RTX))\n-\t;\n-      else if (tablejump_p (insn, NULL, &tmp))\n+\treturn;\n+\n+      if (tablejump_p (insn, NULL, &tmp))\n \t{\n \t  rtvec vec;\n \n@@ -2457,13 +2300,13 @@ create_trace_edges (rtx insn)\n \t  for (i = 0; i < n; ++i)\n \t    {\n \t      lab = XEXP (RTVEC_ELT (vec, i), 0);\n-\t      maybe_record_trace_start (lab, insn, false);\n+\t      maybe_record_trace_start (lab, insn);\n \t    }\n \t}\n       else if (computed_jump_p (insn))\n \t{\n \t  for (lab = forced_labels; lab; lab = XEXP (lab, 1))\n-\t    maybe_record_trace_start (XEXP (lab, 0), insn, true);\n+\t    maybe_record_trace_start (XEXP (lab, 0), insn);\n \t}\n       else if (returnjump_p (insn))\n \t;\n@@ -2473,14 +2316,14 @@ create_trace_edges (rtx insn)\n \t  for (i = 0; i < n; ++i)\n \t    {\n \t      lab = XEXP (ASM_OPERANDS_LABEL (tmp, i), 0);\n-\t      maybe_record_trace_start (lab, insn, true);\n+\t      maybe_record_trace_start (lab, insn);\n \t    }\n \t}\n       else\n \t{\n \t  lab = JUMP_LABEL (insn);\n \t  gcc_assert (lab != NULL);\n-\t  maybe_record_trace_start (lab, insn, false);\n+\t  maybe_record_trace_start (lab, insn);\n \t}\n     }\n   else if (CALL_P (insn))\n@@ -2492,7 +2335,7 @@ create_trace_edges (rtx insn)\n       /* Process non-local goto edges.  */\n       if (can_nonlocal_goto (insn))\n \tfor (lab = nonlocal_goto_handler_labels; lab; lab = XEXP (lab, 1))\n-\t  maybe_record_trace_start (XEXP (lab, 0), insn, true);\n+\t  maybe_record_trace_start_abnormal (XEXP (lab, 0), insn);\n     }\n   else if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n     {\n@@ -2508,7 +2351,7 @@ create_trace_edges (rtx insn)\n     {\n       eh_landing_pad lp = get_eh_landing_pad_from_rtx (insn);\n       if (lp)\n-\tmaybe_record_trace_start (lp->landing_pad, insn, true);\n+\tmaybe_record_trace_start_abnormal (lp->landing_pad, insn);\n     }\n }\n \n@@ -2519,68 +2362,107 @@ static void\n scan_trace (dw_trace_info *trace)\n {\n   rtx insn = trace->head;\n+  dw_cfa_location this_cfa;\n \n   if (dump_file)\n     fprintf (dump_file, \"Processing trace %u : start at %s %d\\n\",\n \t     trace->id, rtx_name[(int) GET_CODE (insn)],\n \t     INSN_UID (insn));\n \n   trace->end_row = copy_cfi_row (trace->beg_row);\n+  trace->end_true_args_size = trace->beg_true_args_size;\n \n   cur_trace = trace;\n   cur_row = trace->end_row;\n-  queued_args_size = cur_row->args_size;\n+\n+  this_cfa = cur_row->cfa;\n+  cur_cfa = &this_cfa;\n \n   for (insn = NEXT_INSN (insn); insn ; insn = NEXT_INSN (insn))\n     {\n-      rtx pat;\n-\n+      /* Do everything that happens \"before\" the insn.  */\n       add_cfi_insn = PREV_INSN (insn);\n \n       /* Notice the end of a trace.  */\n-      if (BARRIER_P (insn) || save_point_p (insn))\n+      if (BARRIER_P (insn))\n+\t{\n+\t  /* Don't bother saving the unneeded queued registers at all.  */\n+\t  VEC_truncate (queued_reg_save, queued_reg_saves, 0);\n+\t  break;\n+\t}\n+      if (save_point_p (insn))\n \t{\n-\t  dwarf2out_flush_queued_reg_saves ();\n-\t  dwarf2out_args_size (queued_args_size);\n-\n \t  /* Propagate across fallthru edges.  */\n-\t  if (!BARRIER_P (insn))\n-\t    maybe_record_trace_start (insn, NULL, false);\n+\t  dwarf2out_flush_queued_reg_saves ();\n+\t  maybe_record_trace_start (insn, NULL);\n \t  break;\n \t}\n \n       if (DEBUG_INSN_P (insn) || !inside_basic_block_p (insn))\n \tcontinue;\n \n-      pat = PATTERN (insn);\n-      if (asm_noperands (pat) >= 0)\n+      /* Flush data before calls and jumps, and of course if necessary.  */\n+      if (can_throw_internal (insn))\n \t{\n-\t  dwarf2out_frame_debug (insn, false);\n-\t  add_cfi_insn = insn;\n+\t  dwarf2out_flush_queued_reg_saves ();\n+\t  notice_eh_throw (insn);\n \t}\n-      else\n+      else if (!NONJUMP_INSN_P (insn)\n+\t       || clobbers_queued_reg_save (insn)\n+\t       || find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL))\n+\tdwarf2out_flush_queued_reg_saves ();\n+\n+      /* Do everything that happens \"after\" the insn.  */\n+      add_cfi_insn = insn;\n+\n+      /* Handle changes to the row state.  */\n+      if (RTX_FRAME_RELATED_P (insn))\n+\tdwarf2out_frame_debug (insn);\n+\n+      /* Look for REG_ARGS_SIZE, and handle it.  */\n+      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t{\n-\t  if (GET_CODE (pat) == SEQUENCE)\n+\t  rtx elt, pat = PATTERN (insn);\n+\t  int i, n = XVECLEN (pat, 0);\n+\n+\t  if (INSN_ANNULLED_BRANCH_P (XVECEXP (pat, 0, 0)))\n \t    {\n-\t      int i, n = XVECLEN (pat, 0);\n-\t      for (i = 1; i < n; ++i)\n-\t\tdwarf2out_frame_debug (XVECEXP (pat, 0, i), false);\n-\t    }\n+\t      /* ??? Hopefully multiple delay slots are not annulled.  */\n+\t      gcc_assert (n == 2);\n+\t      elt = XVECEXP (pat, 0, 1);\n+\n+\t      /* If ELT is an instruction from target of an annulled branch,\n+\t\t the effects are for the target only and so the args_size\n+\t\t and CFA along the current path shouldn't change.  */\n+\t      if (INSN_FROM_TARGET_P (elt))\n+\t\t{\n+\t\t  HOST_WIDE_INT restore_args_size;\n \n-          if (CALL_P (insn))\n-\t    dwarf2out_frame_debug (insn, false);\n-          else if (find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL)\n-\t\t   || (cfun->can_throw_non_call_exceptions\n-\t\t       && can_throw_internal (insn)))\n-\t    dwarf2out_flush_queued_reg_saves ();\n+\t\t  restore_args_size = cur_trace->end_true_args_size;\n+\t\t  cur_cfa = &cur_row->cfa;\n \n-\t  /* Do not separate tablejump insns from their ADDR_DIFF_VEC.\n-\t     Putting the note after the VEC should be ok.  */\n-\t  if (!tablejump_p (insn, NULL, &add_cfi_insn))\n-\t    add_cfi_insn = insn;\n+\t\t  notice_args_size (elt);\n+\t\t  create_trace_edges (insn);\n \n-\t  dwarf2out_frame_debug (insn, true);\n+\t\t  cur_trace->end_true_args_size = restore_args_size;\n+\t\t  cur_row->cfa = this_cfa;\n+\t\t  cur_cfa = &this_cfa;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t  for (i = 1; i < n; ++i)\n+\t    {\n+\t      elt = XVECEXP (pat, 0, i);\n+\t      notice_args_size (elt);\n+\t    }\n \t}\n+      else\n+\tnotice_args_size (insn);\n+\n+      /* Between frame-related-p and args_size we might have otherwise\n+\t emitted two cfa adjustments.  Do it now.  */\n+      def_cfa_1 (&this_cfa);\n \n       /* Note that a test for control_flow_insn_p does exactly the\n \t same tests as are done to actually create the edges.  So\n@@ -2592,6 +2474,7 @@ scan_trace (dw_trace_info *trace)\n   add_cfi_insn = NULL;\n   cur_row = NULL;\n   cur_trace = NULL;\n+  cur_cfa = NULL;\n }\n \n /* Scan the function and create the initial set of CFI notes.  */\n@@ -2733,6 +2616,32 @@ connect_traces (void)\n \t  while (note != add_cfi_insn);\n \t}\n     }\n+\n+  /* Connect args_size between traces that have can_throw_internal insns.  */\n+  if (cfun->eh->lp_array != NULL)\n+    {\n+      HOST_WIDE_INT prev_args_size = 0;\n+\n+      for (i = 0; i < n; ++i)\n+\t{\n+\t  ti = VEC_index (dw_trace_info, trace_info, i);\n+\n+\t  if (ti->switch_sections)\n+\t    prev_args_size = 0;\n+\t  if (ti->eh_head == NULL)\n+\t    continue;\n+\t  gcc_assert (!ti->args_size_undefined);\n+\n+\t  if (ti->beg_delay_args_size != prev_args_size)\n+\t    {\n+\t      /* ??? Search back to previous CFI note.  */\n+\t      add_cfi_insn = PREV_INSN (ti->eh_head);\n+\t      add_cfi_args_size (ti->beg_delay_args_size);\n+\t    }\n+\n+\t  prev_args_size = ti->end_delay_args_size;\n+\t}\n+    }\n }\n \n /* Set up the pseudo-cfg of instruction traces, as described at the\n@@ -3380,9 +3289,6 @@ dump_cfi_row (FILE *f, dw_cfi_row *row)\n   FOR_EACH_VEC_ELT (dw_cfi_ref, row->reg_save, i, cfi)\n     if (cfi)\n       output_cfi_directive (f, cfi);\n-\n-  fprintf (f, \"\\t.cfi_GNU_args_size \"HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t   row->args_size);\n }\n \n void debug_cfi_row (dw_cfi_row *row);"}, {"sha": "aa743d723847eafad27b7e0840534e886a114a0d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -3614,6 +3614,10 @@ try_split (rtx pat, rtx trial, int last)\n \t  break;\n #endif\n \n+\tcase REG_ARGS_SIZE:\n+\t  fixup_args_size_notes (NULL_RTX, insn_last, INTVAL (XEXP (note, 0)));\n+\t  break;\n+\n \tdefault:\n \t  break;\n \t}"}, {"sha": "f8262dbb0a4be21927bd7036189cce3803715c67", "filename": "gcc/explow.c", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -873,14 +873,45 @@ promote_decl_mode (const_tree decl, int *punsignedp)\n }\n \n \f\n+/* Controls the behaviour of {anti_,}adjust_stack.  */\n+static bool suppress_reg_args_size;\n+\n+/* A helper for adjust_stack and anti_adjust_stack.  */\n+\n+static void\n+adjust_stack_1 (rtx adjust, bool anti_p)\n+{\n+  rtx temp, insn;\n+\n+#ifndef STACK_GROWS_DOWNWARD\n+  /* Hereafter anti_p means subtract_p.  */\n+  anti_p = !anti_p;\n+#endif\n+\n+  temp = expand_binop (Pmode,\n+\t\t       anti_p ? sub_optab : add_optab,\n+\t\t       stack_pointer_rtx, adjust, stack_pointer_rtx, 0,\n+\t\t       OPTAB_LIB_WIDEN);\n+\n+  if (temp != stack_pointer_rtx)\n+    insn = emit_move_insn (stack_pointer_rtx, temp);\n+  else\n+    {\n+      insn = get_last_insn ();\n+      temp = single_set (insn);\n+      gcc_assert (temp != NULL && SET_DEST (temp) == stack_pointer_rtx);\n+    }\n+\n+  if (!suppress_reg_args_size)\n+    add_reg_note (insn, REG_ARGS_SIZE, GEN_INT (stack_pointer_delta));\n+}\n+\n /* Adjust the stack pointer by ADJUST (an rtx for a number of bytes).\n    This pops when ADJUST is positive.  ADJUST need not be constant.  */\n \n void\n adjust_stack (rtx adjust)\n {\n-  rtx temp;\n-\n   if (adjust == const0_rtx)\n     return;\n \n@@ -889,17 +920,7 @@ adjust_stack (rtx adjust)\n   if (CONST_INT_P (adjust))\n     stack_pointer_delta -= INTVAL (adjust);\n \n-  temp = expand_binop (Pmode,\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t       add_optab,\n-#else\n-\t\t       sub_optab,\n-#endif\n-\t\t       stack_pointer_rtx, adjust, stack_pointer_rtx, 0,\n-\t\t       OPTAB_LIB_WIDEN);\n-\n-  if (temp != stack_pointer_rtx)\n-    emit_move_insn (stack_pointer_rtx, temp);\n+  adjust_stack_1 (adjust, false);\n }\n \n /* Adjust the stack pointer by minus ADJUST (an rtx for a number of bytes).\n@@ -908,8 +929,6 @@ adjust_stack (rtx adjust)\n void\n anti_adjust_stack (rtx adjust)\n {\n-  rtx temp;\n-\n   if (adjust == const0_rtx)\n     return;\n \n@@ -918,17 +937,7 @@ anti_adjust_stack (rtx adjust)\n   if (CONST_INT_P (adjust))\n     stack_pointer_delta += INTVAL (adjust);\n \n-  temp = expand_binop (Pmode,\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t       sub_optab,\n-#else\n-\t\t       add_optab,\n-#endif\n-\t\t       stack_pointer_rtx, adjust, stack_pointer_rtx, 0,\n-\t\t       OPTAB_LIB_WIDEN);\n-\n-  if (temp != stack_pointer_rtx)\n-    emit_move_insn (stack_pointer_rtx, temp);\n+  adjust_stack_1 (adjust, true);\n }\n \n /* Round the size of a block to be pushed up to the boundary required\n@@ -1416,14 +1425,18 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \t}\n \n       saved_stack_pointer_delta = stack_pointer_delta;\n+      suppress_reg_args_size = true;\n+\n       if (flag_stack_check && STACK_CHECK_MOVING_SP)\n \tanti_adjust_stack_and_probe (size, false);\n       else\n \tanti_adjust_stack (size);\n+\n       /* Even if size is constant, don't modify stack_pointer_delta.\n \t The constant size alloca should preserve\n \t crtl->preferred_stack_boundary alignment.  */\n       stack_pointer_delta = saved_stack_pointer_delta;\n+      suppress_reg_args_size = false;\n \n #ifdef STACK_GROWS_DOWNWARD\n       emit_move_insn (target, virtual_stack_dynamic_rtx);"}, {"sha": "0cfc845c4828968322d57f61fe63ce55b6755007", "filename": "gcc/expr.c", "status": "modified", "additions": 182, "deletions": 2, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -3514,12 +3514,168 @@ push_block (rtx size, int extra, int below)\n   return memory_address (GET_CLASS_NARROWEST_MODE (MODE_INT), temp);\n }\n \n-#ifdef PUSH_ROUNDING\n+/* A utility routine that returns the base of an auto-inc memory, or NULL.  */\n+\n+static rtx\n+mem_autoinc_base (rtx mem)\n+{\n+  if (MEM_P (mem))\n+    {\n+      rtx addr = XEXP (mem, 0);\n+      if (GET_RTX_CLASS (GET_CODE (addr)) == RTX_AUTOINC)\n+\treturn XEXP (addr, 0);\n+    }\n+  return NULL;\n+}\n+\n+/* A utility routine used here, in reload, and in try_split.  The insns\n+   after PREV up to and including LAST are known to adjust the stack,\n+   with a final value of END_ARGS_SIZE.  Iterate backward from LAST\n+   placing notes as appropriate.  PREV may be NULL, indicating the\n+   entire insn sequence prior to LAST should be scanned.\n+\n+   The set of allowed stack pointer modifications is small:\n+     (1) One or more auto-inc style memory references (aka pushes),\n+     (2) One or more addition/subtraction with the SP as destination,\n+     (3) A single move insn with the SP as destination,\n+     (4) A call_pop insn.\n+\n+   Insns in the sequence that do not modify the SP are ignored.\n+\n+   The return value is the amount of adjustment that can be trivially\n+   verified, via immediate operand or auto-inc.  If the adjustment\n+   cannot be trivially extracted, the return value is INT_MIN.  */\n+\n+int\n+fixup_args_size_notes (rtx prev, rtx last, int end_args_size)\n+{\n+  int args_size = end_args_size;\n+  bool saw_unknown = false;\n+  rtx insn;\n+\n+  for (insn = last; insn != prev; insn = PREV_INSN (insn))\n+    {\n+      rtx dest, set, pat;\n+      HOST_WIDE_INT this_delta = 0;\n+      int i;\n+\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+      pat = PATTERN (insn);\n+      set = NULL;\n+\n+      /* Look for a call_pop pattern.  */\n+      if (CALL_P (insn))\n+\t{\n+\t  /* We're not supposed to see non-pop call patterns here.  */\n+\t  gcc_assert (GET_CODE (pat) == PARALLEL);\n+\n+\t  /* All call_pop have a stack pointer adjust in the parallel.\n+\t     The call itself is always first, and the stack adjust is\n+\t     usually last, so search from the end.  */\n+\t  for (i = XVECLEN (pat, 0) - 1; i > 0; --i)\n+\t    {\n+\t      set = XVECEXP (pat, 0, i);\n+\t      if (GET_CODE (set) != SET)\n+\t\tcontinue;\n+\t      dest = SET_DEST (set);\n+\t      if (dest == stack_pointer_rtx)\n+\t\tbreak;\n+\t    }\n+\t  /* We'd better have found the stack pointer adjust.  */\n+\t  gcc_assert (i > 0);\n+\t  /* Fall through to process the extracted SET and DEST\n+\t     as if it was a standalone insn.  */\n+\t}\n+      else if (GET_CODE (pat) == SET)\n+\tset = pat;\n+      else if ((set = single_set (insn)) != NULL)\n+\t;\n+      else if (GET_CODE (pat) == PARALLEL)\n+\t{\n+\t  /* ??? Some older ports use a parallel with a stack adjust\n+\t     and a store for a PUSH_ROUNDING pattern, rather than a\n+\t     PRE/POST_MODIFY rtx.  Don't force them to update yet...  */\n+\t  /* ??? See h8300 and m68k, pushqi1.  */\n+\t  for (i = XVECLEN (pat, 0) - 1; i >= 0; --i)\n+\t    {\n+\t      set = XVECEXP (pat, 0, i);\n+\t      if (GET_CODE (set) != SET)\n+\t\tcontinue;\n+\t      dest = SET_DEST (set);\n+\t      if (dest == stack_pointer_rtx)\n+\t\tbreak;\n+\n+\t      /* We do not expect an auto-inc of the sp in the parallel.  */\n+\t      gcc_checking_assert (mem_autoinc_base (dest)\n+\t\t\t\t   != stack_pointer_rtx);\n+\t      gcc_checking_assert (mem_autoinc_base (SET_SRC (set))\n+\t\t\t\t   != stack_pointer_rtx);\n+\t    }\n+\t  if (i < 0)\n+\t    continue;\n+\t}\n+      else\n+\tcontinue;\n+      dest = SET_DEST (set);\n+\n+      /* Look for direct modifications of the stack pointer.  */\n+      if (dest == stack_pointer_rtx)\n+\t{\n+\t  gcc_assert (!saw_unknown);\n+\t  /* Look for a trivial adjustment, otherwise assume nothing.  */\n+\t  if (GET_CODE (SET_SRC (set)) == PLUS\n+\t      && XEXP (SET_SRC (set), 0) == stack_pointer_rtx\n+\t      && CONST_INT_P (XEXP (SET_SRC (set), 1)))\n+\t    this_delta = INTVAL (XEXP (SET_SRC (set), 1));\n+\t  else\n+\t    saw_unknown = true;\n+\t}\n+      /* Otherwise only think about autoinc patterns.  */\n+      else if (mem_autoinc_base (dest) == stack_pointer_rtx)\n+\t{\n+\t  rtx addr = XEXP (dest, 0);\n+\t  gcc_assert (!saw_unknown);\n+\t  switch (GET_CODE (addr))\n+\t    {\n+\t    case PRE_INC:\n+\t    case POST_INC:\n+\t      this_delta = GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    case PRE_DEC:\n+\t    case POST_DEC:\n+\t      this_delta = -GET_MODE_SIZE (GET_MODE (dest));\n+\t      break;\n+\t    case PRE_MODIFY:\n+\t    case POST_MODIFY:\n+\t      addr = XEXP (addr, 1);\n+\t      gcc_assert (GET_CODE (addr) == PLUS);\n+\t      gcc_assert (XEXP (addr, 0) == stack_pointer_rtx);\n+\t      gcc_assert (CONST_INT_P (XEXP (addr, 1)));\n+\t      this_delta = INTVAL (XEXP (addr, 1));\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      else\n+\tcontinue;\n+\n+      add_reg_note (insn, REG_ARGS_SIZE, GEN_INT (args_size));\n+#ifdef STACK_GROWS_DOWNWARD\n+      this_delta = -this_delta;\n+#endif\n+      args_size -= this_delta;\n+    }\n+\n+  return saw_unknown ? INT_MIN : args_size;\n+}\n \n+#ifdef PUSH_ROUNDING\n /* Emit single push insn.  */\n \n static void\n-emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n+emit_single_push_insn_1 (enum machine_mode mode, rtx x, tree type)\n {\n   rtx dest_addr;\n   unsigned rounded_size = PUSH_ROUNDING (GET_MODE_SIZE (mode));\n@@ -3603,6 +3759,30 @@ emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n     }\n   emit_move_insn (dest, x);\n }\n+\n+/* Emit and annotate a single push insn.  */\n+\n+static void\n+emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n+{\n+  int delta, old_delta = stack_pointer_delta;\n+  rtx prev = get_last_insn ();\n+  rtx last;\n+\n+  emit_single_push_insn_1 (mode, x, type);\n+\n+  last = get_last_insn ();\n+\n+  /* Notice the common case where we emitted exactly one insn.  */\n+  if (PREV_INSN (last) == prev)\n+    {\n+      add_reg_note (last, REG_ARGS_SIZE, GEN_INT (stack_pointer_delta));\n+      return;\n+    }\n+\n+  delta = fixup_args_size_notes (prev, last, stack_pointer_delta);\n+  gcc_assert (delta == INT_MIN || delta == old_delta);\n+}\n #endif\n \n /* Generate code to push X onto the stack, assuming it has mode MODE and"}, {"sha": "22a5402f00f28e37f2c423edcfb8613721c11af9", "filename": "gcc/recog.c", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -3146,16 +3146,17 @@ static rtx\n peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n {\n   int i;\n-  rtx last, note, before_try, x;\n+  rtx last, eh_note, as_note, before_try, x;\n   rtx old_insn, new_insn;\n   bool was_call = false;\n \n-  /* If we are splittind an RTX_FRAME_RELATED_P insn, do not allow it to\n+  /* If we are splitting an RTX_FRAME_RELATED_P insn, do not allow it to\n      match more than one insn, or to be split into more than one insn.  */\n   old_insn = peep2_insn_data[peep2_current].insn;\n   if (RTX_FRAME_RELATED_P (old_insn))\n     {\n       bool any_note = false;\n+      rtx note;\n \n       if (match_len != 0)\n \treturn NULL;\n@@ -3236,6 +3237,7 @@ peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n   for (i = 0; i <= match_len; ++i)\n     {\n       int j;\n+      rtx note;\n \n       j = peep2_buf_position (peep2_current + i);\n       old_insn = peep2_insn_data[j].insn;\n@@ -3281,9 +3283,21 @@ peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n       break;\n     }\n \n-  i = peep2_buf_position (peep2_current + match_len);\n+  /* If we matched any instruction that had a REG_ARGS_SIZE, then\n+     move those notes over to the new sequence.  */\n+  as_note = NULL;\n+  for (i = match_len; i >= 0; --i)\n+    {\n+      int j = peep2_buf_position (peep2_current + i);\n+      old_insn = peep2_insn_data[j].insn;\n+\n+      as_note = find_reg_note (old_insn, REG_ARGS_SIZE, NULL);\n+      if (as_note)\n+\tbreak;\n+    }\n \n-  note = find_reg_note (peep2_insn_data[i].insn, REG_EH_REGION, NULL_RTX);\n+  i = peep2_buf_position (peep2_current + match_len);\n+  eh_note = find_reg_note (peep2_insn_data[i].insn, REG_EH_REGION, NULL_RTX);\n \n   /* Replace the old sequence with the new.  */\n   last = emit_insn_after_setloc (attempt,\n@@ -3293,7 +3307,7 @@ peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n   delete_insn_chain (insn, peep2_insn_data[i].insn, false);\n \n   /* Re-insert the EH_REGION notes.  */\n-  if (note || (was_call && nonlocal_goto_handler_labels))\n+  if (eh_note || (was_call && nonlocal_goto_handler_labels))\n     {\n       edge eh_edge;\n       edge_iterator ei;\n@@ -3302,8 +3316,8 @@ peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n \tif (eh_edge->flags & (EDGE_EH | EDGE_ABNORMAL_CALL))\n \t  break;\n \n-      if (note)\n-\tcopy_reg_eh_region_note_backward (note, last, before_try);\n+      if (eh_note)\n+\tcopy_reg_eh_region_note_backward (eh_note, last, before_try);\n \n       if (eh_edge)\n \tfor (x = last; x != before_try; x = PREV_INSN (x))\n@@ -3336,6 +3350,10 @@ peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n       peep2_do_cleanup_cfg |= purge_dead_edges (bb);\n     }\n \n+  /* Re-insert the ARGS_SIZE notes.  */\n+  if (as_note)\n+    fixup_args_size_notes (before_try, last, INTVAL (XEXP (as_note, 0)));\n+\n   /* If we generated a jump instruction, it won't have\n      JUMP_LABEL set.  Recompute after we're done.  */\n   for (x = last; x != before_try; x = PREV_INSN (x))"}, {"sha": "8c8a99a225be298c9de62273a857b8582f0b59a7", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -201,3 +201,8 @@ REG_NOTE (CROSSING_JUMP)\n /* This kind of note is generated at each to `setjmp', and similar\n    functions that can return twice.  */\n REG_NOTE (SETJMP)\n+\n+/* Indicates the cumulative offset of the stack pointer accounting\n+   for pushed arguments.  This will only be generated when\n+   ACCUMULATE_OUTGOING_ARGS is false.  */\n+REG_NOTE (ARGS_SIZE)"}, {"sha": "ba6ce37da9dd82a22a9e6e78900b773bf6b94222", "filename": "gcc/reload1.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -4548,7 +4548,7 @@ reload_as_needed (int live_known)\n #if defined (AUTO_INC_DEC)\n   int i;\n #endif\n-  rtx x;\n+  rtx x, marker;\n \n   memset (spill_reg_rtx, 0, sizeof spill_reg_rtx);\n   memset (spill_reg_store, 0, sizeof spill_reg_store);\n@@ -4559,6 +4559,10 @@ reload_as_needed (int live_known)\n \n   set_initial_elim_offsets ();\n \n+  /* Generate a marker insn that we will move around.  */\n+  marker = emit_note (NOTE_INSN_DELETED);\n+  unlink_insn_chain (marker, marker);\n+\n   for (chain = reload_insn_chain; chain; chain = chain->next)\n     {\n       rtx prev = 0;\n@@ -4631,7 +4635,10 @@ reload_as_needed (int live_known)\n \t      rtx next = NEXT_INSN (insn);\n \t      rtx p;\n \n+\t      /* ??? PREV can get deleted by reload inheritance.\n+\t\t Work around this by emitting a marker note.  */\n \t      prev = PREV_INSN (insn);\n+\t      reorder_insns_nobb (marker, marker, prev);\n \n \t      /* Now compute which reload regs to reload them into.  Perhaps\n \t\t reusing reload regs from previous insns, or else output\n@@ -4649,10 +4656,22 @@ reload_as_needed (int live_known)\n \t\t and that we moved the structure into).  */\n \t      subst_reloads (insn);\n \n+\t      prev = PREV_INSN (marker);\n+\t      unlink_insn_chain (marker, marker);\n+\n \t      /* Adjust the exception region notes for loads and stores.  */\n \t      if (cfun->can_throw_non_call_exceptions && !CALL_P (insn))\n \t\tfixup_eh_region_note (insn, prev, next);\n \n+\t      /* Adjust the location of REG_ARGS_SIZE.  */\n+\t      p = find_reg_note (insn, REG_ARGS_SIZE, NULL_RTX);\n+\t      if (p)\n+\t\t{\n+\t\t  remove_note (insn, p);\n+\t\t  fixup_args_size_notes (prev, PREV_INSN (next),\n+\t\t\t\t\t INTVAL (XEXP (p, 0)));\n+\t\t}\n+\n \t      /* If this was an ASM, make sure that all the reload insns\n \t\t we have generated are valid.  If not, give an error\n \t\t and delete them.  */"}, {"sha": "d5d7b023ec570d413fef7064a239059cf87d9384", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a08d23082fbeb95013dc74dd3611b6b2331e3cb/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9a08d23082fbeb95013dc74dd3611b6b2331e3cb", "patch": "@@ -2471,6 +2471,7 @@ extern void emit_jump (rtx);\n /* In expr.c */\n extern rtx move_by_pieces (rtx, rtx, unsigned HOST_WIDE_INT,\n \t\t\t   unsigned int, int);\n+extern int fixup_args_size_notes (rtx, rtx, int);\n \n /* In cfgrtl.c */\n extern void print_rtl_with_bb (FILE *, const_rtx);"}]}