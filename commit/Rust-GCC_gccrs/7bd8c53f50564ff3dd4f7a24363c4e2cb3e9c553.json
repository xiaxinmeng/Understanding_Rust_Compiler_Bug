{"sha": "7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JkOGM1M2Y1MDU2NGZmM2RkNGY3YTI0MzYzYzRlMmNiM2U5YzU1Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-02-05T14:49:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-02-05T14:49:05Z"}, "message": "reload1.c (reload_regs_reach_end_p): Replace with...\n\ngcc/\n\t* reload1.c (reload_regs_reach_end_p): Replace with...\n\t(reload_reg_rtx_reaches_end_p): ...this function.\n\t(new_spill_reg_store): Update commentary.\n\t(emit_input_reload_insns): Don't clear new_spill_reg_store here.\n\t(emit_output_reload_insns): Check reload_reg_rtx_reaches_end_p\n\tbefore setting new_spill_reg_store.\n\t(emit_reload_insns): Use a separate loop to clear new_spill_reg_store.\n\tUse reload_reg_rtx_reaches_end_p instead of reload_regs_reach_end_p.\n\tAlso use reload_reg_rtx_reaches_end_p when reading new_spill_reg_store\n\tfor non-spill reload registers.\n\nFrom-SVN: r183908", "tree": {"sha": "76357d6cc57f79962fea776858753c8839a376cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76357d6cc57f79962fea776858753c8839a376cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f4f629390b100a5b79f3802aca3efa56a6967ba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f629390b100a5b79f3802aca3efa56a6967ba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f629390b100a5b79f3802aca3efa56a6967ba1"}], "stats": {"total": 90, "additions": 54, "deletions": 36}, "files": [{"sha": "c33ff0716eee05a44f66683f5f1f83891554f5f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553", "patch": "@@ -1,3 +1,16 @@\n+2012-02-05  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* reload1.c (reload_regs_reach_end_p): Replace with...\n+\t(reload_reg_rtx_reaches_end_p): ...this function.\n+\t(new_spill_reg_store): Update commentary.\n+\t(emit_input_reload_insns): Don't clear new_spill_reg_store here.\n+\t(emit_output_reload_insns): Check reload_reg_rtx_reaches_end_p\n+\tbefore setting new_spill_reg_store.\n+\t(emit_reload_insns): Use a separate loop to clear new_spill_reg_store.\n+\tUse reload_reg_rtx_reaches_end_p instead of reload_regs_reach_end_p.\n+\tAlso use reload_reg_rtx_reaches_end_p when reading new_spill_reg_store\n+\tfor non-spill reload registers.\n+\n 2012-02-05  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/52091"}, {"sha": "bbb75c85a1db0fc59474233c2af4fc90f896ed37", "filename": "gcc/reload1.c", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=7bd8c53f50564ff3dd4f7a24363c4e2cb3e9c553", "patch": "@@ -5505,15 +5505,15 @@ reload_reg_reaches_end_p (unsigned int regno, int reloadnum)\n }\n \n /* Like reload_reg_reaches_end_p, but check that the condition holds for\n-   every register in the range [REGNO, REGNO + NREGS).  */\n+   every register in REG.  */\n \n static bool\n-reload_regs_reach_end_p (unsigned int regno, int nregs, int reloadnum)\n+reload_reg_rtx_reaches_end_p (rtx reg, int reloadnum)\n {\n-  int i;\n+  unsigned int i;\n \n-  for (i = 0; i < nregs; i++)\n-    if (!reload_reg_reaches_end_p (regno + i, reloadnum))\n+  for (i = REGNO (reg); i < END_REGNO (reg); i++)\n+    if (!reload_reg_reaches_end_p (i, reloadnum))\n       return false;\n   return true;\n }\n@@ -7058,7 +7058,9 @@ static rtx operand_reload_insns = 0;\n static rtx other_operand_reload_insns = 0;\n static rtx other_output_reload_insns[MAX_RECOG_OPERANDS];\n \n-/* Values to be put in spill_reg_store are put here first.  */\n+/* Values to be put in spill_reg_store are put here first.  Instructions\n+   must only be placed here if the associated reload register reaches\n+   the end of the instruction's reload sequence.  */\n static rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n static HARD_REG_SET reg_reloaded_died;\n \n@@ -7219,9 +7221,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \n       /* Prevent normal processing of this reload.  */\n       special = 1;\n-      /* Output a special code sequence for this case, and forget about\n-\t spill reg information.  */\n-      new_spill_reg_store[REGNO (reloadreg)] = NULL;\n+      /* Output a special code sequence for this case.  */\n       inc_for_reload (reloadreg, oldequiv, rl->out, rl->inc);\n     }\n \n@@ -7742,14 +7742,14 @@ emit_output_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t    rld[s].out_reg = rl->out_reg;\n \t\t    set = single_set (next);\n \t\t    if (set && SET_SRC (set) == s_reg\n-\t\t\t&& ! new_spill_reg_store[REGNO (s_reg)])\n+\t\t\t&& reload_reg_rtx_reaches_end_p (s_reg, s))\n \t\t      {\n \t\t\tSET_HARD_REG_BIT (reg_is_output_reload,\n \t\t\t\t\t  REGNO (s_reg));\n \t\t\tnew_spill_reg_store[REGNO (s_reg)] = next;\n \t\t      }\n \t\t  }\n-\t\telse\n+\t\telse if (reload_reg_rtx_reaches_end_p (rl_reg_rtx, j))\n \t\t  new_spill_reg_store[REGNO (rl_reg_rtx)] = p;\n \t      }\n \t  }\n@@ -8009,21 +8009,22 @@ emit_reload_insns (struct insn_chain *chain)\n       debug_reload_to_stream (dump_file);\n     }\n \n+  for (j = 0; j < n_reloads; j++)\n+    if (rld[j].reg_rtx && HARD_REGISTER_P (rld[j].reg_rtx))\n+      {\n+\tunsigned int i;\n+\n+\tfor (i = REGNO (rld[j].reg_rtx); i < END_REGNO (rld[j].reg_rtx); i++)\n+\t  new_spill_reg_store[i] = 0;\n+      }\n+\n   /* Now output the instructions to copy the data into and out of the\n      reload registers.  Do these in the order that the reloads were reported,\n      since reloads of base and index registers precede reloads of operands\n      and the operands may need the base and index registers reloaded.  */\n \n   for (j = 0; j < n_reloads; j++)\n     {\n-      if (rld[j].reg_rtx && HARD_REGISTER_P (rld[j].reg_rtx))\n-\t{\n-\t  unsigned int i;\n-\n-\t  for (i = REGNO (rld[j].reg_rtx); i < END_REGNO (rld[j].reg_rtx); i++)\n-\t    new_spill_reg_store[i] = 0;\n-\t}\n-\n       do_input_reload (chain, rld + j, j);\n       do_output_reload (chain, rld + j, j);\n     }\n@@ -8149,15 +8150,13 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t && GET_CODE (rld[r].out) != PRE_MODIFY))))\n \t    {\n \t      rtx reg;\n-\t      enum machine_mode mode;\n-\t      int regno, nregs;\n \n \t      reg = reload_reg_rtx_for_output[r];\n-\t      mode = GET_MODE (reg);\n-\t      regno = REGNO (reg);\n-\t      nregs = hard_regno_nregs[regno][mode];\n-\t      if (reload_regs_reach_end_p (regno, nregs, r))\n+\t      if (reload_reg_rtx_reaches_end_p (reg, r))\n \t\t{\n+\t\t  enum machine_mode mode = GET_MODE (reg);\n+\t\t  int regno = REGNO (reg);\n+\t\t  int nregs = hard_regno_nregs[regno][mode];\n \t\t  rtx out = (REG_P (rld[r].out)\n \t\t\t     ? rld[r].out\n \t\t\t     : rld[r].out_reg\n@@ -8221,20 +8220,21 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t   && !reg_set_p (reload_reg_rtx_for_input[r], PATTERN (insn)))\n \t    {\n \t      rtx reg;\n-\t      enum machine_mode mode;\n-\t      int regno, nregs;\n \n \t      reg = reload_reg_rtx_for_input[r];\n-\t      mode = GET_MODE (reg);\n-\t      regno = REGNO (reg);\n-\t      nregs = hard_regno_nregs[regno][mode];\n-\t      if (reload_regs_reach_end_p (regno, nregs, r))\n+\t      if (reload_reg_rtx_reaches_end_p (reg, r))\n \t\t{\n+\t\t  enum machine_mode mode;\n+\t\t  int regno;\n+\t\t  int nregs;\n \t\t  int in_regno;\n \t\t  int in_nregs;\n \t\t  rtx in;\n \t\t  bool piecemeal;\n \n+\t\t  mode = GET_MODE (reg);\n+\t\t  regno = REGNO (reg);\n+\t\t  nregs = hard_regno_nregs[regno][mode];\n \t\t  if (REG_P (rld[r].in)\n \t\t      && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER)\n \t\t    in = rld[r].in;\n@@ -8336,10 +8336,17 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t delete_output_reload.  */\n \t      src_reg = reload_reg_rtx_for_output[r];\n \n-\t      /* If this is an optional reload, try to find the source reg\n-\t\t from an input reload.  */\n-\t      if (! src_reg)\n+\t      if (src_reg)\n \t\t{\n+\t\t  if (reload_reg_rtx_reaches_end_p (src_reg, r))\n+\t\t    store_insn = new_spill_reg_store[REGNO (src_reg)];\n+\t\t  else\n+\t\t    src_reg = NULL_RTX;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* If this is an optional reload, try to find the\n+\t\t     source reg from an input reload.  */\n \t\t  rtx set = single_set (insn);\n \t\t  if (set && SET_DEST (set) == rld[r].out)\n \t\t    {\n@@ -8357,8 +8364,6 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t}\n \t\t    }\n \t\t}\n-\t      else\n-\t\tstore_insn = new_spill_reg_store[REGNO (src_reg)];\n \t      if (src_reg && REG_P (src_reg)\n \t\t  && REGNO (src_reg) < FIRST_PSEUDO_REGISTER)\n \t\t{"}]}