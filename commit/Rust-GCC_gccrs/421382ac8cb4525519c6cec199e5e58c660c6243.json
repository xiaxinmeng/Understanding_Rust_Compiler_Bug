{"sha": "421382ac8cb4525519c6cec199e5e58c660c6243", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIxMzgyYWM4Y2I0NTI1NTE5YzZjZWMxOTllNWU1OGM2NjBjNjI0Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-29T23:18:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-29T23:18:51Z"}, "message": "flow.c (XNMALLOC): New macro.\n\n\t* flow.c (XNMALLOC): New macro.\n\t(flow_int_list_blocks, basic_block_succ, basic_block_pred): New\n\tstatic variables.\n\t(add_edge, add_edge_to_label): New static functions.\n\t(free_bb_memory): New function.\n\t(flow_delete_insn): Delete function.\n\t(basic_block_drops_in): Delete variable.\n\t(find_basic_blocks): Allocate and initialize basic_block_head,\n\tbasic_block_succ.  Don't allocate basic_block_drops_in.\n\tCall free_bb_memory at the beginning.\n\t(find_basic_blocks_1): Don't do multiple passes.\n\tDelete code to compute basic_block_drops_in.\n\tAfter calling make_edges, mark blocks reached by current block live.\n\tUpdate test for unreachable live blocks.\n\t(mark_label_ref): Delete args X, CHECKDUP.  Add PRED arg.  All callers\n\tchanged.\n\tSimplify to call add_edge_to_label when a LABEL_REF is found.\n\t(make_edges): Simplify to call add_edge_to_label instead of\n\tmark_label_ref most of the time.\n\tCompute here whether control drops into the next block.\n\t(delete_unreachable_blocks): Return void.  All callers changed.\n\tDelete unreachable blocks in reverse order.\n\tAfter deleting all unreachable blocks, renumber the remaining ones\n\tand update n_basic_blocks.\n\t(delete_block): Speed up deletion a bit.\n\tDon't set basic_block_drops_in for deleted blocks.\n\t(free_basic_block_vars): Don't free basic_block_drops_in.\n\t(life_analysis_1): Update to use new edge representation.\n\t(dump_flow_info): Delete code to print basic block info; call\n\tdump_bb_data instead.\n\t(compute_preds_succs): Delete code to recompute basic_block_drops_in\n\tand uid_block_number.\n\tSimply copy the previously computed cfg.\n\t(dump_bb_data): New arg LIVE_INFO.  All callers changed.\n\tPrint register lifetime information if LIVE_INFO is nonzero.\n\t* basic-block.h (dump_bb_data): Adjust prototype.\n\t* gcse.c (gcse_main): Update call to dump_bb_data.\n\t* rtl.h (free_bb_memory): Declare.\n\t* toplev.c (rest_of_compilation): Call free_bb_memory.\n\nFrom-SVN: r23443", "tree": {"sha": "cce896503a86e93798cdbe694b4414ccb75acd3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cce896503a86e93798cdbe694b4414ccb75acd3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/421382ac8cb4525519c6cec199e5e58c660c6243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421382ac8cb4525519c6cec199e5e58c660c6243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/421382ac8cb4525519c6cec199e5e58c660c6243", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421382ac8cb4525519c6cec199e5e58c660c6243/comments", "author": null, "committer": null, "parents": [{"sha": "1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3b1e1a0bb4549b57a060c36ceb49db0ddbfa41"}], "stats": {"total": 704, "additions": 315, "deletions": 389}, "files": [{"sha": "04b62dbbf941d7ae35daed62d649f0ee6b651ca4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=421382ac8cb4525519c6cec199e5e58c660c6243", "patch": "@@ -1,5 +1,45 @@\n Thu Oct 29 23:55:43 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n+\t* flow.c (XNMALLOC): New macro.\n+\t(flow_int_list_blocks, basic_block_succ, basic_block_pred): New\n+\tstatic variables.\n+\t(add_edge, add_edge_to_label): New static functions.\n+\t(free_bb_memory): New function.\n+\t(flow_delete_insn): Delete function.\n+\t(basic_block_drops_in): Delete variable.\n+\t(find_basic_blocks): Allocate and initialize basic_block_head,\n+\tbasic_block_succ.  Don't allocate basic_block_drops_in.\n+\tCall free_bb_memory at the beginning.\n+\t(find_basic_blocks_1): Don't do multiple passes.\n+\tDelete code to compute basic_block_drops_in.\n+\tAfter calling make_edges, mark blocks reached by current block live.\n+\tUpdate test for unreachable live blocks.\n+\t(mark_label_ref): Delete args X, CHECKDUP.  Add PRED arg.  All callers\n+\tchanged.\n+\tSimplify to call add_edge_to_label when a LABEL_REF is found.\n+\t(make_edges): Simplify to call add_edge_to_label instead of\n+\tmark_label_ref most of the time.\n+\tCompute here whether control drops into the next block.\n+\t(delete_unreachable_blocks): Return void.  All callers changed.\n+\tDelete unreachable blocks in reverse order.\n+\tAfter deleting all unreachable blocks, renumber the remaining ones\n+\tand update n_basic_blocks.\n+\t(delete_block): Speed up deletion a bit.\n+\tDon't set basic_block_drops_in for deleted blocks.\n+\t(free_basic_block_vars): Don't free basic_block_drops_in.\n+\t(life_analysis_1): Update to use new edge representation.\n+\t(dump_flow_info): Delete code to print basic block info; call\n+\tdump_bb_data instead.\n+\t(compute_preds_succs): Delete code to recompute basic_block_drops_in\n+\tand uid_block_number.\n+\tSimply copy the previously computed cfg.\n+\t(dump_bb_data): New arg LIVE_INFO.  All callers changed.\n+\tPrint register lifetime information if LIVE_INFO is nonzero.\n+\t* basic-block.h (dump_bb_data): Adjust prototype.\n+\t* gcse.c (gcse_main): Update call to dump_bb_data.\n+\t* rtl.h (free_bb_memory): Declare.\n+\t* toplev.c (rest_of_compilation): Call free_bb_memory.\n+\n \t* reload1.c (struct elim_table): Delete MAX_OFFSET member.\n \t(update_eliminable_offsets): Don't compute it.\n \t(set_initial_elim_offsets): Don't initialize it."}, {"sha": "a946405ee5e7df0086f9438ff522e66e50658b15", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=421382ac8cb4525519c6cec199e5e58c660c6243", "patch": "@@ -190,7 +190,8 @@ extern int *uid_block_number;\n \n extern void compute_preds_succs PROTO ((int_list_ptr *, int_list_ptr *,\n \t\t\t\t        int *, int *));\n-extern void dump_bb_data       PROTO ((FILE *, int_list_ptr *, int_list_ptr *));\n+extern void dump_bb_data       PROTO ((FILE *, int_list_ptr *, int_list_ptr *,\n+\t\t\t\t       int));\n extern void free_bb_mem        PROTO ((void));\n extern void free_basic_block_vars\tPROTO ((int));\n "}, {"sha": "22f7f1e4fa6221592cbb3beadda34858d5c7c6d9", "filename": "gcc/flow.c", "status": "modified", "additions": 269, "deletions": 385, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=421382ac8cb4525519c6cec199e5e58c660c6243", "patch": "@@ -128,6 +128,8 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n+#define XNMALLOC(TYPE, COUNT) ((TYPE *) xmalloc ((COUNT) * sizeof (TYPE)))\n+\n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.\n    For top-level functions, this is temporary_obstack.\n@@ -218,10 +220,14 @@ regset regs_live_at_setjmp;\n    are another pair, etc.  */\n rtx regs_may_share;\n \n-/* Element N is nonzero if control can drop into basic block N\n-   from the preceding basic block.  Freed after life_analysis.  */\n+/* Pointer to head of predecessor/successor block list.  */\n+static int_list_block *flow_int_list_blocks;\n+\n+/* Element N is the list of successors of basic block N.  */\n+static int_list_ptr *basic_block_succ;\n \n-static char *basic_block_drops_in;\n+/* Element N is the list of predecessors of basic block N.  */\n+static int_list_ptr *basic_block_pred;\n \n /* Element N is depth within loops of the last insn in basic block number N.\n    Freed after life_analysis.  */\n@@ -249,14 +255,15 @@ static HARD_REG_SET elim_reg_set;\n \n /* Forward declarations */\n static void find_basic_blocks_1\t\tPROTO((rtx, rtx));\n+static void add_edge\t\t\tPROTO((int, int));\n+static void add_edge_to_label\t\tPROTO((int, rtx));\n static void make_edges\t\t\tPROTO((int));\n-static void mark_label_ref\t\tPROTO((rtx, rtx, int));\n-static int delete_unreachable_blocks\tPROTO((void));\n+static void mark_label_ref\t\tPROTO((int, rtx));\n+static void delete_unreachable_blocks\tPROTO((void));\n static int delete_block\t\t\tPROTO((int));\n static void life_analysis_1\t\tPROTO((rtx, int));\n static void propagate_block\t\tPROTO((regset, rtx, rtx, int, \n \t\t\t\t\t       regset, int));\n-static rtx flow_delete_insn\t\tPROTO((rtx));\n static int set_noop_p\t\t\tPROTO((rtx));\n static int noop_move_p\t\t\tPROTO((rtx));\n static void record_volatile_insns\tPROTO((rtx));\n@@ -304,6 +311,10 @@ find_basic_blocks (f, nregs, file)\n   rtx nonlocal_label_list = nonlocal_label_rtx_list ();\n   int in_libcall_block = 0;\n \n+  /* Avoid leaking memory if this is called multiple times per compiled\n+     function.  */\n+  free_bb_memory ();\n+\n   /* Count the basic blocks.  Also find maximum insn uid value used.  */\n \n   {\n@@ -382,14 +393,17 @@ find_basic_blocks (f, nregs, file)\n   /* Allocate some tables that last till end of compiling this function\n      and some needed only in find_basic_blocks and life_analysis.  */\n \n-  basic_block_head = (rtx *) xmalloc (n_basic_blocks * sizeof (rtx));\n-  basic_block_end = (rtx *) xmalloc (n_basic_blocks * sizeof (rtx));\n-  basic_block_drops_in = (char *) xmalloc (n_basic_blocks);\n+  basic_block_head = XNMALLOC (rtx, n_basic_blocks);\n+  basic_block_end = XNMALLOC (rtx, n_basic_blocks);\n+  basic_block_succ = XNMALLOC (int_list_ptr, n_basic_blocks);\n+  basic_block_pred = XNMALLOC (int_list_ptr, n_basic_blocks);\n+  bzero ((char *)basic_block_succ, n_basic_blocks * sizeof (int_list_ptr));\n+  bzero ((char *)basic_block_pred, n_basic_blocks * sizeof (int_list_ptr));\n+\n   basic_block_computed_jump_target = (char *) oballoc (n_basic_blocks);\n-  basic_block_loop_depth = (short *) xmalloc (n_basic_blocks * sizeof (short));\n-  uid_block_number\n-    = (int *) xmalloc ((max_uid_for_flow + 1) * sizeof (int));\n-  uid_volatile = (char *) xmalloc (max_uid_for_flow + 1);\n+  basic_block_loop_depth = XNMALLOC (short, n_basic_blocks);\n+  uid_block_number = XNMALLOC (int, (max_uid_for_flow + 1));\n+  uid_volatile = XNMALLOC (char, (max_uid_for_flow + 1));\n   bzero (uid_volatile, max_uid_for_flow + 1);\n \n   find_basic_blocks_1 (f, nonlocal_label_list);\n@@ -435,15 +449,13 @@ find_basic_blocks_1 (f, nonlocal_labels)\n   register char *block_marked = (char *) alloca (n_basic_blocks);\n   rtx note, eh_note;\n   enum rtx_code prev_code, code;\n-  int depth, pass;\n+  int depth;\n   int in_libcall_block = 0;\n   int call_had_abnormal_edge = 0;\n \n-  pass = 1;\n   active_eh_region = (int *) alloca ((max_uid_for_flow + 1) * sizeof (int));\n   nested_eh_region = (int *) alloca ((max_label_num () + 1) * sizeof (int));\n   nonlocal_label_list = nonlocal_labels;\n- restart:\n \n   label_value_list = 0;\n   block_live_static = block_live;\n@@ -564,23 +576,8 @@ find_basic_blocks_1 (f, nonlocal_labels)\n \tin_libcall_block = 0;\n     }\n \n-  /* During the second pass, `n_basic_blocks' is only an upper bound.\n-     Only perform the sanity check for the first pass, and on the second\n-     pass ensure `n_basic_blocks' is set to the correct value.  */\n-  if (pass == 1 && i + 1 != n_basic_blocks)\n+  if (i + 1 != n_basic_blocks)\n     abort ();\n-  n_basic_blocks = i + 1;\n-\n-  /* Record which basic blocks control can drop in to.  */\n-\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      for (insn = PREV_INSN (basic_block_head[i]);\n-\t   insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n-\t;\n-\n-      basic_block_drops_in[i] = insn && GET_CODE (insn) != BARRIER;\n-    }\n \n   /* Now find which basic blocks can actually be reached\n      and put all jump insns' LABEL_REFS onto the ref-chains\n@@ -589,7 +586,6 @@ find_basic_blocks_1 (f, nonlocal_labels)\n   if (n_basic_blocks > 0)\n     {\n       int something_marked = 1;\n-      int deleted = 0;\n \n       /* Pass over all blocks, marking each block that is reachable\n \t and has not yet been marked.\n@@ -603,10 +599,15 @@ find_basic_blocks_1 (f, nonlocal_labels)\n \t  for (i = 0; i < n_basic_blocks; i++)\n \t    if (block_live[i] && !block_marked[i])\n \t      {\n+\t\tint_list_ptr p;\n+\n \t\tblock_marked[i] = 1;\n \t\tsomething_marked = 1;\n \n \t\tmake_edges (i);\n+\n+\t\tfor (p = basic_block_succ[i]; p; p = p->next)\n+\t\t  block_live[INT_LIST_VAL (p)] = 1;\n \t      }\n \t}\n \n@@ -618,40 +619,11 @@ find_basic_blocks_1 (f, nonlocal_labels)\n \t later during the compile or at runtime.  It's easier to debug the\n \t problem here than later!  */\n       for (i = 1; i < n_basic_blocks; i++)\n-\tif (block_live[i] && ! basic_block_drops_in[i]\n-\t    && GET_CODE (basic_block_head[i]) == CODE_LABEL\n-\t    && LABEL_REFS (basic_block_head[i]) == basic_block_head[i])\n+\tif (block_live[i] && basic_block_pred[i] == 0)\n \t  abort ();\n \n       if (! reload_completed)\n-\tdeleted = delete_unreachable_blocks ();\n-\n-      /* There are pathological cases where one function calling hundreds of\n-\t nested inline functions can generate lots and lots of unreachable\n-\t blocks that jump can't delete.  Since we don't use sparse matrices\n-\t a lot of memory will be needed to compile such functions.\n-\t Implementing sparse matrices is a fair bit of work and it is not\n-\t clear that they win more than they lose (we don't want to\n-\t unnecessarily slow down compilation of normal code).  By making\n-\t another pass for the pathological case, we can greatly speed up\n-\t their compilation without hurting normal code.  This works because\n-\t all the insns in the unreachable blocks have either been deleted or\n-\t turned into notes.\n-\t Note that we're talking about reducing memory usage by 10's of\n-\t megabytes and reducing compilation time by several minutes.  */\n-      /* ??? The choice of when to make another pass is a bit arbitrary,\n-\t and was derived from empirical data.  */\n-      if (pass == 1\n-\t  && deleted > 200)\n-\t{\n-\t  pass++;\n-\t  n_basic_blocks -= deleted;\n-\t  /* `n_basic_blocks' may not be correct at this point: two previously\n-\t     separate blocks may now be merged.  That's ok though as we\n-\t     recalculate it during the second pass.  It certainly can't be\n-\t     any larger than the current value.  */\n-\t  goto restart;\n-\t}\n+\tdelete_unreachable_blocks ();\n     }\n }\n \n@@ -671,10 +643,74 @@ set_block_num (insn, bb)\n     }\n   BLOCK_NUM (insn) = bb;\n }\n-\n \f\n /* Subroutines of find_basic_blocks.  */\n \n+void\n+free_bb_memory ()\n+{\n+  free_int_list (&flow_int_list_blocks);\n+}\n+\n+/* Make an edge in the cfg from block PRED to block SUCC.  */\n+static void\n+add_edge (pred, succ)\n+     int pred, succ;\n+{\n+  add_int_list_node (&flow_int_list_blocks, basic_block_pred + succ, pred);\n+  add_int_list_node (&flow_int_list_blocks, basic_block_succ + pred, succ);\n+}\n+\n+/* Make an edge in the cfg from block PRED to the block starting with\n+   label LABEL.  */\n+static void\n+add_edge_to_label (pred, label)\n+     int pred;\n+     rtx label;\n+{\n+  /* If the label was never emitted, this insn is junk,\n+     but avoid a crash trying to refer to BLOCK_NUM (label).\n+     This can happen as a result of a syntax error\n+     and a diagnostic has already been printed.  */\n+  if (INSN_UID (label) == 0)\n+    return;\n+\n+  add_edge (pred, BLOCK_NUM (label));\n+}\n+\n+/* Check expression X for label references.  If one is found, add an edge\n+   from basic block PRED to the block beginning with the label.  */\n+\n+static void\n+mark_label_ref (pred, x)\n+     int pred;\n+     rtx x;\n+{\n+  register RTX_CODE code;\n+  register int i;\n+  register char *fmt;\n+\n+  code = GET_CODE (x);\n+  if (code == LABEL_REF)\n+    {\n+      add_edge_to_label (pred, XEXP (x, 0));\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tmark_label_ref (pred, XEXP (x, i));\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    mark_label_ref (pred, XVECEXP (x, i, j));\n+\t}\n+    }\n+}\n+\n /* For basic block I, make edges and mark live all blocks which are reachable\n    from it.  */\n static void\n@@ -683,18 +719,26 @@ make_edges (i)\n {\n   rtx insn, x;\n \n-  if (i + 1 < n_basic_blocks && basic_block_drops_in[i + 1])\n-    block_live_static[i + 1] = 1;\n+  /* See if control drops into the next block.  */\n+  if (i + 1 < n_basic_blocks)\n+    {\n+      for (insn = PREV_INSN (basic_block_head[i + 1]);\n+\t   insn && GET_CODE (insn) == NOTE; insn = PREV_INSN (insn))\n+\t;\n+\n+      if (insn && GET_CODE (insn) != BARRIER)\n+\tadd_edge (i, i + 1);\n+    }\n+\n   insn = basic_block_end[i];\n   if (GET_CODE (insn) == JUMP_INSN)\n-    mark_label_ref (PATTERN (insn), insn, 0);\n+    mark_label_ref (i, PATTERN (insn));\n \n   /* If we have any forced labels, mark them as potentially reachable from\n      this block.  */\n   for (x = forced_labels; x; x = XEXP (x, 1))\n     if (! LABEL_REF_NONLOCAL_P (x))\n-      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n-\t\t      insn, 0);\n+      add_edge_to_label (i, XEXP (x, 0));\n \n   /* Now scan the insns for this block, we may need to make edges for some of\n      them to various non-obvious locations (exception handlers, nonlocal\n@@ -731,12 +775,7 @@ make_edges (i)\n \t    {\n \t      if (REG_NOTE_KIND (note) == REG_LABEL\n \t\t  && XEXP (note, 0) != eh_return_stub_label)\n-\t\t{\n-\t\t  x = XEXP (note, 0);\n-\t\t  block_live_static[BLOCK_NUM (x)] = 1;\n-\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, x),\n-\t\t\t\t  insn, 0);\n-\t\t}\n+\t\tadd_edge_to_label (i, XEXP (note, 0));\n \t    }\n \n \t  /* If this is a computed jump, then mark it as reaching everything\n@@ -748,16 +787,14 @@ make_edges (i)\n \t\t{\n \t\t  int b = BLOCK_NUM (XEXP (x, 0));\n \t\t  basic_block_computed_jump_target[b] = 1;\n-\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n-\t\t\t\t  insn, 0);\n+\t\t  add_edge (i, b);\n \t\t}\n \n \t      for (x = forced_labels; x; x = XEXP (x, 1))\n \t\t{\n \t\t  int b = BLOCK_NUM (XEXP (x, 0));\n \t\t  basic_block_computed_jump_target[b] = 1;\n-\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n-\t\t\t\t  insn, 0);\n+\t\t  add_edge (i, b);\n \t\t}\n \t    }\n \n@@ -775,21 +812,17 @@ make_edges (i)\n \t\t  int region;\n \t\t  handler_info *ptr;\n \t\t  region = active_eh_region[INSN_UID (insn)];\n-\t\t  for ( ; region; \n-\t\t\tregion = nested_eh_region[region]) \n+\t\t  for ( ; region; region = nested_eh_region[region])\n \t\t    {\n \t\t      ptr = get_first_handler (region);\n \t\t      for ( ; ptr ; ptr = ptr->next)\n-\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t   ptr->handler_label),\n-\t\t\t\t\tinsn, 0);\n+\t\t\tadd_edge_to_label (i, ptr->handler_label);\n \t\t    }\n \t\t}\n \t      if (! asynchronous_exceptions)\n \t\t{\n \t\t  for (x = nonlocal_label_list; x; x = XEXP (x, 1))\n-\t\t    mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n-\t\t\t\t    insn, 0);\n+\t\t    add_edge_to_label (i, XEXP (x, 0));\n \t\t}\n \t      /* ??? This could be made smarter: in some cases it's possible\n \t\t to tell that certain calls will not do a nonlocal goto.\n@@ -807,101 +840,79 @@ make_edges (i)\n      the eh_stub labels within it.  So we have to make additional edges in\n      the flow graph.  */\n   if (i + 1 == n_basic_blocks && eh_return_stub_label != 0)\n-    {\n-      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, eh_return_stub_label),\n-\t\t      basic_block_end[i], 0);\n-    }\n-}\n-\n-/* Check expression X for label references;\n-   if one is found, add INSN to the label's chain of references.\n-\n-   CHECKDUP means check for and avoid creating duplicate references\n-   from the same insn.  Such duplicates do no serious harm but\n-   can slow life analysis.  CHECKDUP is set only when duplicates\n-   are likely.  */\n-\n-static void\n-mark_label_ref (x, insn, checkdup)\n-     rtx x, insn;\n-     int checkdup;\n-{\n-  register RTX_CODE code;\n-  register int i;\n-  register char *fmt;\n-\n-  /* We can be called with NULL when scanning label_value_list.  */\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-  if (code == LABEL_REF)\n-    {\n-      register rtx label = XEXP (x, 0);\n-      register rtx y;\n-      if (GET_CODE (label) != CODE_LABEL)\n-\tabort ();\n-      /* If the label was never emitted, this insn is junk,\n-\t but avoid a crash trying to refer to BLOCK_NUM (label).\n-\t This can happen as a result of a syntax error\n-\t and a diagnostic has already been printed.  */\n-      if (INSN_UID (label) == 0)\n-\treturn;\n-      CONTAINING_INSN (x) = insn;\n-      /* if CHECKDUP is set, check for duplicate ref from same insn\n-\t and don't insert.  */\n-      if (checkdup)\n-\tfor (y = LABEL_REFS (label); y != label; y = LABEL_NEXTREF (y))\n-\t  if (CONTAINING_INSN (y) == insn)\n-\t    return;\n-      LABEL_NEXTREF (x) = LABEL_REFS (label);\n-      LABEL_REFS (label) = x;\n-      block_live_static[BLOCK_NUM (label)] = 1;\n-      return;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tmark_label_ref (XEXP (x, i), insn, 0);\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    mark_label_ref (XVECEXP (x, i, j), insn, 1);\n-\t}\n-    }\n+    add_edge_to_label (i, eh_return_stub_label);\n }\n \n /* Now delete the code for any basic blocks that can't be reached.\n    They can occur because jump_optimize does not recognize unreachable loops\n-   as unreachable.\n-   Return the number of deleted blocks.  */\n-static int\n+   as unreachable.  */\n+static void\n delete_unreachable_blocks ()\n {\n   int deleted_handler = 0;\n   int deleted = 0;\n-  int i;\n+  int i, j;\n   rtx insn;\n+  int *block_num_map = XNMALLOC (int, n_basic_blocks);\n \n-  for (i = 0; i < n_basic_blocks; i++)\n+  for (i = n_basic_blocks - 1; i >= 0; i--)\n     if (! block_live_static[i])\n+      deleted_handler |= delete_block (i);\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (block_live_static[i])\n+      block_num_map[i] = i - deleted;\n+    else\n       {\n \tdeleted++;\n-\n-\tdeleted_handler |= delete_block (i);\n+\tblock_num_map[i] = -1;\n       }\n \n+  /* Eliminate all traces of the deleted blocks by renumbering the remaining\n+     ones.  */\n+  for (i = j = 0; i < n_basic_blocks; i++)\n+    {\n+      int_list_ptr p;\n+\n+      if (block_num_map[i] == -1)\n+\tcontinue;\n+\n+      for (p = basic_block_pred[i]; p; p = p->next)\n+\tINT_LIST_VAL (p) = block_num_map[INT_LIST_VAL (p)];\n+      for (p = basic_block_succ[i]; p; p = p->next)\n+\tINT_LIST_VAL (p) = block_num_map[INT_LIST_VAL (p)];\n+\n+      if (i != j)\n+\t{\n+\t  rtx tmp = basic_block_head[i];\n+\t  for (;;)\n+\t    {\n+\t      BLOCK_NUM (tmp) = j;\n+\t      if (tmp == basic_block_end[i])\n+\t\tbreak;\n+\t      tmp = NEXT_INSN (tmp);\n+\t    }\n+\t  basic_block_head[j] = basic_block_head[i];\n+\t  basic_block_end[j] = basic_block_end[i];\n+\t  basic_block_pred[j] = basic_block_pred[i];\n+\t  basic_block_succ[j] = basic_block_succ[i];\n+\t  basic_block_loop_depth[j] = basic_block_loop_depth[i];\n+\t  basic_block_computed_jump_target[j]\n+\t    = basic_block_computed_jump_target[i];\n+\t}\n+      j++;\n+    }\n+  n_basic_blocks -= deleted;\n+  free (block_num_map);\n+\n   /* If we deleted an exception handler, we may have EH region\n      begin/end blocks to remove as well. */\n   if (deleted_handler)\n     for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n       if (GET_CODE (insn) == NOTE)\n \t{\n-\t  if ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG) ||\n-\t      (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)) \n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG ||\n+\t      NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n \t    {\n \t      int num = CODE_LABEL_NUMBER (insn);\n \t      /* A NULL handler indicates a region is no longer needed */\n@@ -912,7 +923,6 @@ delete_unreachable_blocks ()\n \t\t}\n \t    }\n \t}\n-  return deleted;\n }\n \n /* Delete the insns in a (non-live) block.  We physically delete every\n@@ -932,83 +942,89 @@ delete_block (i)\n {\n   int deleted_handler = 0;\n   rtx insn;\n+  rtx kept_head = 0;\n+  rtx kept_tail = 0;\n+\n+  /* If the head of this block is a CODE_LABEL, then it might\n+     be the label for an exception handler which can't be\n+     reached.\n \n-  if (basic_block_head[i] != basic_block_end[i])\n+     We need to remove the label from the exception_handler_label\n+     list and remove the associated NOTE_EH_REGION_BEG and\n+     NOTE_EH_REGION_END notes.  */\n+  insn = basic_block_head[i];\n+  if (GET_CODE (insn) == CODE_LABEL)\n     {\n-      /* It would be quicker to delete all of these with a single\n-\t unchaining, rather than one at a time, but we need to keep\n-\t the NOTE's.  */\n-      insn = NEXT_INSN (basic_block_head[i]);\n-      while (insn != basic_block_end[i])\n+      rtx x, *prev = &exception_handler_labels;\n+\n+      for (x = exception_handler_labels; x; x = XEXP (x, 1))\n \t{\n-\t  if (GET_CODE (insn) == BARRIER)\n-\t    abort ();\n-\t  else if (GET_CODE (insn) != NOTE)\n-\t    insn = flow_delete_insn (insn);\n-\t  else\n-\t    insn = NEXT_INSN (insn);\n+\t  if (XEXP (x, 0) == insn)\n+\t    {\n+\t      /* Found a match, splice this label out of the\n+\t\t EH label list.  */\n+\t      *prev = XEXP (x, 1);\n+\t      XEXP (x, 1) = NULL_RTX;\n+\t      XEXP (x, 0) = NULL_RTX;\n+\n+\t      /* Remove the handler from all regions */\n+\t      remove_handler (insn);\n+\t      deleted_handler = 1;\n+\t      break;\n+\t    }\n+\t  prev = &XEXP (x, 1);\n \t}\n     }\n \n+  /* Walk the insns of the block, building a chain of NOTEs that need to be\n+     kept.  */\n   insn = basic_block_head[i];\n-  if (GET_CODE (insn) != NOTE)\n+  for (;;)\n     {\n-      /* Turn the head into a deleted insn note.  */\n       if (GET_CODE (insn) == BARRIER)\n \tabort ();\n-\n-      /* If the head of this block is a CODE_LABEL, then it might\n-\t be the label for an exception handler which can't be\n-\t reached.\n-\n-\t We need to remove the label from the exception_handler_label\n-\t list and remove the associated NOTE_EH_REGION_BEG and\n-\t NOTE_EH_REGION_END notes.  */\n-      if (GET_CODE (insn) == CODE_LABEL)\n+      else if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED)\n \t{\n-\t  rtx x, *prev = &exception_handler_labels;\n-\n-\t  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n+\t  if (kept_head == 0)\n+\t    kept_head = kept_tail = insn;\n+\t  else\n \t    {\n-\t      if (XEXP (x, 0) == insn)\n-\t\t{\n-\t\t  /* Found a match, splice this label out of the\n-\t\t     EH label list.  */\n-\t\t  *prev = XEXP (x, 1);\n-\t\t  XEXP (x, 1) = NULL_RTX;\n-\t\t  XEXP (x, 0) = NULL_RTX;\n-\n-\t\t  /* Remove the handler from all regions */\n-\t\t  remove_handler (insn);\n-\t\t  deleted_handler = 1;\n-\t\t  break;\n-\t\t}\n-\t      prev = &XEXP (x, 1);\n+\t      NEXT_INSN (kept_tail) = insn;\n+\t      PREV_INSN (insn) = kept_tail;\n+\t      kept_tail = insn;\n \t    }\n \t}\n-\t\t \n-      PUT_CODE (insn, NOTE);\n-      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-      NOTE_SOURCE_FILE (insn) = 0;\n-    }\n-  insn = basic_block_end[i];\n-  if (GET_CODE (insn) != NOTE)\n-    {\n-      /* Turn the tail into a deleted insn note.  */\n-      if (GET_CODE (insn) == BARRIER)\n-\tabort ();\n-      PUT_CODE (insn, NOTE);\n-      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-      NOTE_SOURCE_FILE (insn) = 0;\n+      if (insn == basic_block_end[i])\n+\tbreak;\n+      insn = NEXT_INSN (insn);\n     }\n+  insn = NEXT_INSN (insn);\n+\n   /* BARRIERs are between basic blocks, not part of one.\n      Delete a BARRIER if the preceding jump is deleted.\n      We cannot alter a BARRIER into a NOTE\n      because it is too short; but we can really delete\n      it because it is not part of a basic block.  */\n-  if (NEXT_INSN (insn) != 0\n-      && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n-    delete_insn (NEXT_INSN (insn));\n+  if (insn != 0 && GET_CODE (insn) == BARRIER)\n+    insn = NEXT_INSN (insn);\n+\n+  /* Now unchain all of the block, and put the chain of kept notes in its\n+     place.  */\n+  if (kept_head == 0)\n+    {\n+      NEXT_INSN (PREV_INSN (basic_block_head[i])) = insn;\n+      if (insn != 0)\n+\tPREV_INSN (insn) = PREV_INSN (basic_block_head[i]);\n+    }\n+  else\n+    {\n+      NEXT_INSN (PREV_INSN (basic_block_head[i])) = kept_head;\n+      if (insn != 0)\n+\tPREV_INSN (insn) = kept_tail;\n+\n+      PREV_INSN (kept_head) = PREV_INSN (basic_block_head[i]);\n+      NEXT_INSN (kept_tail) = insn;\n+    }\n \n   /* Each time we delete some basic blocks,\n      see if there is a jump around them that is\n@@ -1031,14 +1047,6 @@ delete_block (i)\n \t\t&& INSN_UID (label) != 0\n \t\t&& BLOCK_NUM (label) == j)\n \t      {\n-\t\tint k;\n-\n-\t\t/* The deleted blocks still show up in the cfg,\n-\t\t   so we must set basic_block_drops_in for blocks\n-\t\t   I to J inclusive to keep the cfg accurate.  */\n-\t\tfor (k = i; k <= j; k++)\n-\t\t  basic_block_drops_in[k] = 1;\n-\n \t\tPUT_CODE (insn, NOTE);\n \t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t\tNOTE_SOURCE_FILE (insn) = 0;\n@@ -1052,20 +1060,6 @@ delete_block (i)\n \n   return deleted_handler;\n }\n-\n-/* Delete INSN by patching it out.\n-   Return the next insn.  */\n-\n-static rtx\n-flow_delete_insn (insn)\n-     rtx insn;\n-{\n-  /* ??? For the moment we assume we don't have to watch for NULLs here\n-     since the start/end of basic blocks aren't deleted like this.  */\n-  NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n-  PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n-  return NEXT_INSN (insn);\n-}\n \f\n /* Perform data flow analysis.\n    F is the first insn of the function and NREGS the number of register numbers\n@@ -1110,12 +1104,6 @@ void\n free_basic_block_vars (keep_head_end_p)\n      int keep_head_end_p;\n {\n-  if (basic_block_drops_in)\n-    {\n-      free (basic_block_drops_in);\n-      /* Tell dump_flow_info this isn't available anymore.  */\n-      basic_block_drops_in = 0;\n-    }\n   if (basic_block_loop_depth)\n     {\n       free (basic_block_loop_depth);\n@@ -1484,26 +1472,16 @@ life_analysis_1 (f, nregs)\n \t    }\n \n \t  {\n-\t    register rtx jump, head;\n-\n-\t    /* Update the basic_block_new_live_at_end's of the block\n-\t       that falls through into this one (if any).  */\n-\t    head = basic_block_head[i];\n-\t    if (basic_block_drops_in[i])\n-\t      IOR_REG_SET (basic_block_new_live_at_end[i-1],\n-\t\t\t   basic_block_live_at_start[i]);\n+\t    int_list_ptr p;\n \n \t    /* Update the basic_block_new_live_at_end's of\n-\t       all the blocks that jump to this one.  */\n-\t    if (GET_CODE (head) == CODE_LABEL)\n-\t      for (jump = LABEL_REFS (head);\n-\t\t   jump != head;\n-\t\t   jump = LABEL_NEXTREF (jump))\n-\t\t{\n-\t\t  register int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n-\t\t  IOR_REG_SET (basic_block_new_live_at_end[from_block],\n-\t\t\t       basic_block_live_at_start[i]);\n-\t\t}\n+\t       all the blocks that reach this one.  */\n+\t    for (p = basic_block_pred[i]; p; p = p->next)\n+\t      {\n+\t\tregister int from_block = INT_LIST_VAL (p);\n+\t\tIOR_REG_SET (basic_block_new_live_at_end[from_block],\n+\t\t\t     basic_block_live_at_start[i]);\n+\t      }\n \t  }\n #ifdef USE_C_ALLOCA\n \t  alloca (0);\n@@ -3191,39 +3169,7 @@ dump_flow_info (file)\n \tfprintf (file, \".\\n\");\n       }\n   fprintf (file, \"\\n%d basic blocks.\\n\", n_basic_blocks);\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      register rtx head, jump;\n-      register int regno;\n-      fprintf (file, \"\\nBasic block %d: first insn %d, last %d.\\n\",\n-\t       i,\n-\t       INSN_UID (basic_block_head[i]),\n-\t       INSN_UID (basic_block_end[i]));\n-      /* The control flow graph's storage is freed\n-\t now when flow_analysis returns.\n-\t Don't try to print it if it is gone.  */\n-      if (basic_block_drops_in)\n-\t{\n-\t  fprintf (file, \"Reached from blocks: \");\n-\t  head = basic_block_head[i];\n-\t  if (GET_CODE (head) == CODE_LABEL)\n-\t    for (jump = LABEL_REFS (head);\n-\t\t jump != head;\n-\t\t jump = LABEL_NEXTREF (jump))\n-\t      {\n-\t\tregister int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n-\t\tfprintf (file, \" %d\", from_block);\n-\t      }\n-\t  if (basic_block_drops_in[i])\n-\t    fprintf (file, \" previous\");\n-\t}\n-      fprintf (file, \"\\nRegisters live at start:\");\n-      for (regno = 0; regno < max_regno; regno++)\n-\tif (REGNO_REG_SET_P (basic_block_live_at_start[i], regno))\n-\t  fprintf (file, \" %d\", regno);\n-      fprintf (file, \"\\n\");\n-    }\n-  fprintf (file, \"\\n\");\n+  dump_bb_data (file, basic_block_pred, basic_block_succ, 1);\n }\n \n \f\n@@ -3406,117 +3352,46 @@ compute_preds_succs (s_preds, s_succs, num_preds, num_succs)\n      int *num_preds;\n      int *num_succs;\n {\n-  int bb, clear_local_bb_vars = 0;\n+  int bb;\n \n   bzero ((char *) s_preds, n_basic_blocks * sizeof (int_list_ptr));\n   bzero ((char *) s_succs, n_basic_blocks * sizeof (int_list_ptr));\n   bzero ((char *) num_preds, n_basic_blocks * sizeof (int));\n   bzero ((char *) num_succs, n_basic_blocks * sizeof (int));\n \n-  /* This routine can be called after life analysis; in that case\n-     basic_block_drops_in and uid_block_number will not be available\n-     and we must recompute their values.  */\n-  if (basic_block_drops_in == NULL || uid_block_number == NULL)\n-    {\n-      clear_local_bb_vars = 1;\n-      basic_block_drops_in = (char *) alloca (n_basic_blocks);\n-      uid_block_number = (int *) alloca ((get_max_uid () + 1) * sizeof (int));\n-\n-      bzero ((char *) basic_block_drops_in, n_basic_blocks * sizeof (char));\n-      bzero ((char *) uid_block_number, n_basic_blocks * sizeof (int));\n-\n-      /* Scan each basic block setting basic_block_drops_in and\n-\t uid_block_number as needed.  */\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t{\n-\t  rtx insn, stop_insn;\n-\n-\t  if (bb == 0)\n-\t    stop_insn = NULL_RTX;\n-\t  else\n-\t    stop_insn = basic_block_end[bb-1];\n-\n-\t  /* Look backwards from the start of this block.  Stop if we\n-\t     hit the start of the function or the end of a previous\n-\t     block.  Don't walk backwards through blocks that are just\n-\t     deleted insns!  */\n-\t  for (insn = PREV_INSN (basic_block_head[bb]);\n-\t       insn && insn != stop_insn && GET_CODE (insn) == NOTE;\n-\t       insn = PREV_INSN (insn))\n-\t    ;\n-\n-\t  /* Never set basic_block_drops_in for the first block.  It is\n-\t     implicit.\n-\n-\t     If we stopped on anything other than a BARRIER, then this\n-\t     block drops in.  */\n-\t  if (bb != 0)\n-\t    basic_block_drops_in[bb] = (insn ? GET_CODE (insn) != BARRIER : 1);\n-\n-\t  insn = basic_block_head[bb];\n-\t  while (insn)\n-\t    {\n-\t      BLOCK_NUM (insn) = bb;\n-\t      if (insn == basic_block_end[bb])\n-\t\tbreak;\n-\t      insn = NEXT_INSN (insn);\n-\t    }\n-\t}\n-    }\n-      \n+  /* It's somewhat stupid to simply copy the information.  The passes\n+     which use this function ought to be changed to refer directly to\n+     basic_block_succ and its relatives.  */\n   for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n-      rtx head;\n-      rtx jump;\n-\n-      head = BLOCK_HEAD (bb);\n+      rtx jump = BLOCK_END (bb);\n+      enum rtx_code code = GET_CODE (jump);\n+      int_list_ptr p;\n \n-      if (GET_CODE (head) == CODE_LABEL)\n-\tfor (jump = LABEL_REFS (head);\n-\t     jump != head;\n-\t     jump = LABEL_NEXTREF (jump))\n-\t  {\n-\t    if (! INSN_DELETED_P (CONTAINING_INSN (jump))\n-\t\t&& (GET_CODE (CONTAINING_INSN (jump)) != NOTE\n-\t\t    || (NOTE_LINE_NUMBER (CONTAINING_INSN (jump))\n-\t\t\t!= NOTE_INSN_DELETED)))\n-\t      add_pred_succ (BLOCK_NUM (CONTAINING_INSN (jump)), bb,\n-\t\t\t     s_preds, s_succs, num_preds, num_succs);\n-\t  }\n+      for (p = basic_block_succ[bb]; p; p = p->next)\n+\tadd_pred_succ (bb, INT_LIST_VAL (p), s_preds, s_succs, num_preds,\n+\t\t       num_succs);\n \n-      jump = BLOCK_END (bb);\n       /* If this is a RETURN insn or a conditional jump in the last\n \t basic block, or a non-jump insn in the last basic block, then\n \t this block reaches the exit block.  */\n-      if ((GET_CODE (jump) == JUMP_INSN && GET_CODE (PATTERN (jump)) == RETURN)\n-\t  || (((GET_CODE (jump) == JUMP_INSN\n+      if ((code == JUMP_INSN && GET_CODE (PATTERN (jump)) == RETURN)\n+\t  || (((code == JUMP_INSN\n \t        && condjump_p (jump) && !simplejump_p (jump))\n-\t       || GET_CODE (jump) != JUMP_INSN)\n- \t      && (bb == n_basic_blocks - 1)))\n+\t       || code != JUMP_INSN)\n+ \t      && bb == n_basic_blocks - 1))\n \tadd_pred_succ (bb, EXIT_BLOCK, s_preds, s_succs, num_preds, num_succs);\n-\n-      if (basic_block_drops_in[bb])\n-\tadd_pred_succ (bb - 1, bb, s_preds, s_succs, num_preds, num_succs);\n     }\n \n   add_pred_succ (ENTRY_BLOCK, 0, s_preds, s_succs, num_preds, num_succs);\n-\n-\n-  /* If we allocated any variables in temporary storage, clear out the\n-     pointer to the local storage to avoid dangling pointers.  */\n-  if (clear_local_bb_vars)\n-    {\n-      basic_block_drops_in = NULL;\n-      uid_block_number = NULL;\n-    \n-    }\n }\n \n void\n-dump_bb_data (file, preds, succs)\n+dump_bb_data (file, preds, succs, live_info)\n      FILE *file;\n      int_list_ptr *preds;\n      int_list_ptr *succs;\n+     int live_info;\n {\n   int bb;\n   int_list_ptr p;\n@@ -3545,6 +3420,15 @@ dump_bb_data (file, preds, succs)\n \t  else\n \t    fprintf (file, \" %d\", succ_bb);\n \t}\n+      if (live_info)\n+\t{\n+\t  int regno;\n+\t  fprintf (file, \"\\nRegisters live at start:\");\n+\t  for (regno = 0; regno < max_regno; regno++)\n+\t    if (REGNO_REG_SET_P (basic_block_live_at_start[bb], regno))\n+\t      fprintf (file, \" %d\", regno);\n+\t  fprintf (file, \"\\n\");\n+\t}\n       fprintf (file, \"\\n\");\n     }\n   fprintf (file, \"\\n\");"}, {"sha": "32e8b516fc25749ec198583a74655bccddeb2929", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=421382ac8cb4525519c6cec199e5e58c660c6243", "patch": "@@ -700,9 +700,7 @@ gcse_main (f, file)\n   compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n \n   if (file)\n-    {\n-      dump_bb_data (file, s_preds, s_succs);\n-    }\n+    dump_bb_data (file, s_preds, s_succs, 0);\n \n   /* Record where pseudo-registers are set.\n      This data is kept accurate during each pass."}, {"sha": "2a761c4e3bce99b434000a7686a9adc9d186def6", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=421382ac8cb4525519c6cec199e5e58c660c6243", "patch": "@@ -1374,6 +1374,7 @@ extern void recompute_reg_usage\t\tPROTO ((rtx));\n #ifdef BUFSIZ\n extern void dump_flow_info\t\tPROTO ((FILE *));\n #endif\n+extern void free_bb_memory\t\tPROTO ((void));\n \n /* In expmed.c */\n extern void init_expmed\t\t\tPROTO ((void));"}, {"sha": "43fd83e41c7c90b8e814967df0a0aa5f99b3f052", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421382ac8cb4525519c6cec199e5e58c660c6243/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=421382ac8cb4525519c6cec199e5e58c660c6243", "patch": "@@ -3951,6 +3951,8 @@ rest_of_compilation (decl)\n \n  exit_rest_of_compilation:\n \n+  free_bb_memory ();\n+\n   /* In case the function was not output,\n      don't leave any temporary anonymous types\n      queued up for sdb output.  */"}]}