{"sha": "794e31808f1554d51f0f0357c3a74a6365f0a274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0ZTMxODA4ZjE1NTRkNTFmMGYwMzU3YzNhNzRhNjM2NWYwYTI3NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-14T15:46:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-14T15:46:08Z"}, "message": "Use vec<> in build_vector\n\nThis patch makes build_vector take the elements as a vec<> rather\nthan a tree *.  This is useful for SVE because it bundles the number\nof elements with the elements themselves, and enforces the fact that\nthe number is constant.  Also, I think things like the folds can be used\nwith any generic GNU vector, not just those that match machine vectors,\nso the arguments to XALLOCAVEC had no clear limit.\n\n2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree.h (build_vector): Take a vec<tree> instead of a tree *.\n\t* tree.c (build_vector): Likewise.\n\t(build_vector_from_ctor): Update accordingly.\n\t(build_vector_from_val): Likewise.\n\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Likewise.\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n\t* tree-vect-generic.c (add_rshift): Likewise.\n\t(expand_vector_divmod): Likewise.\n\t(optimize_vector_constructor): Likewise.\n\t* tree-vect-slp.c (vect_get_constant_vectors): Likewise.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vect_schedule_slp_instance): Likewise.\n\t* tree-vect-stmts.c (vectorizable_bswap): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vect_gen_perm_mask_any): Likewise.  Add elements in order.\n\t* expmed.c (make_tree): Likewise.\n\t* fold-const.c (fold_negate_expr_1): Use auto_vec<tree> when building\n\ta vector passed to build_vector.\n\t(fold_convert_const): Likewise.\n\t(exact_inverse): Likewise.\n\t(fold_ternary_loc): Likewise.\n\t(fold_relational_const): Likewise.\n\t(const_binop): Likewise.  Use VECTOR_CST_ELT directly when operating\n\ton VECTOR_CSTs, rather than going through vec_cst_ctor_to_array.\n\t(const_unop): Likewise.  Store the reduction accumulator in a\n\tvariable rather than an array.\n\t(vec_cst_ctor_to_array): Take the number of elements as a parameter.\n\t(fold_vec_perm): Update calls accordingly.  Use auto_vec<tree> for\n\tthe new vector, rather than constructing it after the input arrays.\n\t(native_interpret_vector): Use auto_vec<tree> when building\n\ta vector passed to build_vector.  Add elements in order.\n\t* tree-vect-loop.c (get_initial_defs_for_reduction): Use\n\tauto_vec<tree> when building a vector passed to build_vector.\n\t(vect_create_epilog_for_reduction): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(get_initial_def_for_reduction): Likewise.  Fix indentation of\n\tcase statements.\n\t* config/sparc/sparc.c (sparc_handle_vis_mul8x16): Change n_elts\n\tto a vec<tree> *.\n\t(sparc_fold_builtin): Use auto_vec<tree> when building a vector\n\tpassed to build_vector.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252760", "tree": {"sha": "d491aa520d3a8de4b35dbdde63439716c15b6f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d491aa520d3a8de4b35dbdde63439716c15b6f8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/794e31808f1554d51f0f0357c3a74a6365f0a274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794e31808f1554d51f0f0357c3a74a6365f0a274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/794e31808f1554d51f0f0357c3a74a6365f0a274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794e31808f1554d51f0f0357c3a74a6365f0a274/comments", "author": null, "committer": null, "parents": [{"sha": "9e822269364f5268b2bdc82530fd6c871f47b1bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e822269364f5268b2bdc82530fd6c871f47b1bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e822269364f5268b2bdc82530fd6c871f47b1bc"}], "stats": {"total": 457, "additions": 253, "deletions": 204}, "files": [{"sha": "b52eced6e1a6be862599dc9b3a114dbc51097af9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -1,3 +1,49 @@\n+2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree.h (build_vector): Take a vec<tree> instead of a tree *.\n+\t* tree.c (build_vector): Likewise.\n+\t(build_vector_from_ctor): Update accordingly.\n+\t(build_vector_from_val): Likewise.\n+\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n+\t* tree-vect-generic.c (add_rshift): Likewise.\n+\t(expand_vector_divmod): Likewise.\n+\t(optimize_vector_constructor): Likewise.\n+\t* tree-vect-slp.c (vect_get_constant_vectors): Likewise.\n+\t(vect_transform_slp_perm_load): Likewise.\n+\t(vect_schedule_slp_instance): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_bswap): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vect_gen_perm_mask_any): Likewise.  Add elements in order.\n+\t* expmed.c (make_tree): Likewise.\n+\t* fold-const.c (fold_negate_expr_1): Use auto_vec<tree> when building\n+\ta vector passed to build_vector.\n+\t(fold_convert_const): Likewise.\n+\t(exact_inverse): Likewise.\n+\t(fold_ternary_loc): Likewise.\n+\t(fold_relational_const): Likewise.\n+\t(const_binop): Likewise.  Use VECTOR_CST_ELT directly when operating\n+\ton VECTOR_CSTs, rather than going through vec_cst_ctor_to_array.\n+\t(const_unop): Likewise.  Store the reduction accumulator in a\n+\tvariable rather than an array.\n+\t(vec_cst_ctor_to_array): Take the number of elements as a parameter.\n+\t(fold_vec_perm): Update calls accordingly.  Use auto_vec<tree> for\n+\tthe new vector, rather than constructing it after the input arrays.\n+\t(native_interpret_vector): Use auto_vec<tree> when building\n+\ta vector passed to build_vector.  Add elements in order.\n+\t* tree-vect-loop.c (get_initial_defs_for_reduction): Use\n+\tauto_vec<tree> when building a vector passed to build_vector.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t(vectorizable_induction): Likewise.\n+\t(get_initial_def_for_reduction): Likewise.  Fix indentation of\n+\tcase statements.\n+\t* config/sparc/sparc.c (sparc_handle_vis_mul8x16): Change n_elts\n+\tto a vec<tree> *.\n+\t(sparc_fold_builtin): Use auto_vec<tree> when building a vector\n+\tpassed to build_vector.\n+\n 2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "53689a1ccfa27fb39d4d80997b3640b8c3cd0673", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -11446,7 +11446,7 @@ sparc_vis_mul8x16 (int e8, int e16)\n    the result into the array N_ELTS, whose elements are of INNER_TYPE.  */\n \n static void\n-sparc_handle_vis_mul8x16 (tree *n_elts, enum sparc_builtins fncode,\n+sparc_handle_vis_mul8x16 (vec<tree> *n_elts, enum sparc_builtins fncode,\n \t\t\t  tree inner_type, tree cst0, tree cst1)\n {\n   unsigned i, num = VECTOR_CST_NELTS (cst0);\n@@ -11460,7 +11460,7 @@ sparc_handle_vis_mul8x16 (tree *n_elts, enum sparc_builtins fncode,\n \t  int val\n \t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (VECTOR_CST_ELT (cst0, i)),\n \t\t\t\t TREE_INT_CST_LOW (VECTOR_CST_ELT (cst1, i)));\n-\t  n_elts[i] = build_int_cst (inner_type, val);\n+\t  n_elts->quick_push (build_int_cst (inner_type, val));\n \t}\n       break;\n \n@@ -11472,7 +11472,7 @@ sparc_handle_vis_mul8x16 (tree *n_elts, enum sparc_builtins fncode,\n \t  int val\n \t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (VECTOR_CST_ELT (cst0, i)),\n \t\t\t\t scale);\n-\t  n_elts[i] = build_int_cst (inner_type, val);\n+\t  n_elts->quick_push (build_int_cst (inner_type, val));\n \t}\n       break;\n \n@@ -11484,7 +11484,7 @@ sparc_handle_vis_mul8x16 (tree *n_elts, enum sparc_builtins fncode,\n \t  int val\n \t    = sparc_vis_mul8x16 (TREE_INT_CST_LOW (VECTOR_CST_ELT (cst0, i)),\n \t\t\t\t scale);\n-\t  n_elts[i] = build_int_cst (inner_type, val);\n+\t  n_elts->quick_push (build_int_cst (inner_type, val));\n \t}\n       break;\n \n@@ -11533,14 +11533,15 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n       if (TREE_CODE (arg0) == VECTOR_CST)\n \t{\n \t  tree inner_type = TREE_TYPE (rtype);\n-\t  tree *n_elts;\n \t  unsigned i;\n \n-\t  n_elts = XALLOCAVEC (tree, VECTOR_CST_NELTS (arg0));\n+\t  auto_vec<tree, 32> n_elts (VECTOR_CST_NELTS (arg0));\n \t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n-\t    n_elts[i] = build_int_cst (inner_type,\n-\t\t\t\t       TREE_INT_CST_LOW\n-\t\t\t\t         (VECTOR_CST_ELT (arg0, i)) << 4);\n+\t    {\n+\t      unsigned HOST_WIDE_INT val\n+\t\t= TREE_INT_CST_LOW (VECTOR_CST_ELT (arg0, i));\n+\t      n_elts.quick_push (build_int_cst (inner_type, val << 4));\n+\t    }\n \t  return build_vector (rtype, n_elts);\n \t}\n       break;\n@@ -11556,8 +11557,8 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n       if (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST)\n \t{\n \t  tree inner_type = TREE_TYPE (rtype);\n-\t  tree *n_elts = XALLOCAVEC (tree, VECTOR_CST_NELTS (arg0));\n-\t  sparc_handle_vis_mul8x16 (n_elts, code, inner_type, arg0, arg1);\n+\t  auto_vec<tree, 32> n_elts (VECTOR_CST_NELTS (arg0));\n+\t  sparc_handle_vis_mul8x16 (&n_elts, code, inner_type, arg0, arg1);\n \t  return build_vector (rtype, n_elts);\n \t}\n       break;\n@@ -11570,12 +11571,12 @@ sparc_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED,\n \n       if (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST)\n \t{\n-\t  tree *n_elts = XALLOCAVEC (tree, 2 * VECTOR_CST_NELTS (arg0));\n+\t  auto_vec<tree, 32> n_elts (2 * VECTOR_CST_NELTS (arg0));\n \t  unsigned i;\n \t  for (i = 0; i < VECTOR_CST_NELTS (arg0); ++i)\n \t    {\n-\t      n_elts[2*i] = VECTOR_CST_ELT (arg0, i);\n-\t      n_elts[2*i+1] = VECTOR_CST_ELT (arg1, i);\n+\t      n_elts.quick_push (VECTOR_CST_ELT (arg0, i));\n+\t      n_elts.quick_push (VECTOR_CST_ELT (arg1, i));\n \t    }\n \n \t  return build_vector (rtype, n_elts);"}, {"sha": "b9d31921047d00eff57d9bc37f851ce00ebe4613", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -5180,15 +5180,14 @@ make_tree (tree type, rtx x)\n       {\n \tint units = CONST_VECTOR_NUNITS (x);\n \ttree itype = TREE_TYPE (type);\n-\ttree *elts;\n \tint i;\n \n \t/* Build a tree with vector elements.  */\n-\telts = XALLOCAVEC (tree, units);\n-\tfor (i = units - 1; i >= 0; --i)\n+\tauto_vec<tree, 32> elts (units);\n+\tfor (i = 0; i < units; ++i)\n \t  {\n \t    rtx elt = CONST_VECTOR_ELT (x, i);\n-\t    elts[i] = make_tree (itype, elt);\n+\t    elts.quick_push (make_tree (itype, elt));\n \t  }\n \n \treturn build_vector (type, elts);"}, {"sha": "013081da673999a94a1881d6885fc9194b064e87", "filename": "gcc/fold-const.c", "status": "modified", "additions": 86, "deletions": 91, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -136,7 +136,6 @@ static tree fold_not_const (const_tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n static tree fold_convert_const (enum tree_code, tree, tree);\n static tree fold_view_convert_expr (tree, tree);\n-static bool vec_cst_ctor_to_array (tree, tree *);\n static tree fold_negate_expr (location_t, tree);\n \n \n@@ -565,13 +564,14 @@ fold_negate_expr_1 (location_t loc, tree t)\n     case VECTOR_CST:\n       {\n \tint count = VECTOR_CST_NELTS (t), i;\n-\ttree *elts = XALLOCAVEC (tree, count);\n \n+\tauto_vec<tree, 32> elts (count);\n \tfor (i = 0; i < count; i++)\n \t  {\n-\t    elts[i] = fold_negate_expr (loc, VECTOR_CST_ELT (t, i));\n-\t    if (elts[i] == NULL_TREE)\n+\t    tree elt = fold_negate_expr (loc, VECTOR_CST_ELT (t, i));\n+\t    if (elt == NULL_TREE)\n \t      return NULL_TREE;\n+\t    elts.quick_push (elt);\n \t  }\n \n \treturn build_vector (type, elts);\n@@ -1414,19 +1414,20 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n     {\n       tree type = TREE_TYPE (arg1);\n       int count = VECTOR_CST_NELTS (arg1), i;\n-      tree *elts = XALLOCAVEC (tree, count);\n \n+      auto_vec<tree, 32> elts (count);\n       for (i = 0; i < count; i++)\n \t{\n \t  tree elem1 = VECTOR_CST_ELT (arg1, i);\n \t  tree elem2 = VECTOR_CST_ELT (arg2, i);\n \n-\t  elts[i] = const_binop (code, elem1, elem2);\n+\t  tree elt = const_binop (code, elem1, elem2);\n \n \t  /* It is possible that const_binop cannot handle the given\n \t     code and return NULL_TREE */\n-\t  if (elts[i] == NULL_TREE)\n+\t  if (elt == NULL_TREE)\n \t    return NULL_TREE;\n+\t  elts.quick_push (elt);\n \t}\n \n       return build_vector (type, elts);\n@@ -1438,18 +1439,19 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n     {\n       tree type = TREE_TYPE (arg1);\n       int count = VECTOR_CST_NELTS (arg1), i;\n-      tree *elts = XALLOCAVEC (tree, count);\n \n+      auto_vec<tree, 32> elts (count);\n       for (i = 0; i < count; i++)\n \t{\n \t  tree elem1 = VECTOR_CST_ELT (arg1, i);\n \n-\t  elts[i] = const_binop (code, elem1, arg2);\n+\t  tree elt = const_binop (code, elem1, arg2);\n \n \t  /* It is possible that const_binop cannot handle the given\n \t     code and return NULL_TREE.  */\n-\t  if (elts[i] == NULL_TREE)\n+\t  if (elt == NULL_TREE)\n \t    return NULL_TREE;\n+\t  elts.quick_push (elt);\n \t}\n \n       return build_vector (type, elts);\n@@ -1481,7 +1483,6 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n     case VEC_PACK_TRUNC_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n       {\n-\ttree *elts;\n \tunsigned int out_nelts, in_nelts, i;\n \n \tif (TREE_CODE (arg1) != VECTOR_CST\n@@ -1493,18 +1494,18 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n \tgcc_assert (in_nelts == VECTOR_CST_NELTS (arg2)\n \t\t    && out_nelts == TYPE_VECTOR_SUBPARTS (type));\n \n-\telts = XALLOCAVEC (tree, out_nelts);\n-\tif (!vec_cst_ctor_to_array (arg1, elts)\n-\t    || !vec_cst_ctor_to_array (arg2, elts + in_nelts))\n-\t  return NULL_TREE;\n-\n+\tauto_vec<tree, 32> elts (out_nelts);\n \tfor (i = 0; i < out_nelts; i++)\n \t  {\n-\t    elts[i] = fold_convert_const (code == VEC_PACK_TRUNC_EXPR\n-\t\t\t\t\t  ? NOP_EXPR : FIX_TRUNC_EXPR,\n-\t\t\t\t\t  TREE_TYPE (type), elts[i]);\n-\t    if (elts[i] == NULL_TREE || !CONSTANT_CLASS_P (elts[i]))\n+\t    tree elt = (i < in_nelts\n+\t\t\t? VECTOR_CST_ELT (arg1, i)\n+\t\t\t: VECTOR_CST_ELT (arg2, i - in_nelts));\n+\t    elt = fold_convert_const (code == VEC_PACK_TRUNC_EXPR\n+\t\t\t\t      ? NOP_EXPR : FIX_TRUNC_EXPR,\n+\t\t\t\t      TREE_TYPE (type), elt);\n+\t    if (elt == NULL_TREE || !CONSTANT_CLASS_P (elt))\n \t      return NULL_TREE;\n+\t    elts.quick_push (elt);\n \t  }\n \n \treturn build_vector (type, elts);\n@@ -1516,7 +1517,6 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n     case VEC_WIDEN_MULT_ODD_EXPR:\n       {\n \tunsigned int out_nelts, in_nelts, out, ofs, scale;\n-\ttree *elts;\n \n \tif (TREE_CODE (arg1) != VECTOR_CST || TREE_CODE (arg2) != VECTOR_CST)\n \t  return NULL_TREE;\n@@ -1526,11 +1526,6 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n \tgcc_assert (in_nelts == VECTOR_CST_NELTS (arg2)\n \t\t    && out_nelts == TYPE_VECTOR_SUBPARTS (type));\n \n-\telts = XALLOCAVEC (tree, in_nelts * 2);\n-\tif (!vec_cst_ctor_to_array (arg1, elts)\n-\t    || !vec_cst_ctor_to_array (arg2, elts + in_nelts))\n-\t  return NULL_TREE;\n-\n \tif (code == VEC_WIDEN_MULT_LO_EXPR)\n \t  scale = 0, ofs = BYTES_BIG_ENDIAN ? out_nelts : 0;\n \telse if (code == VEC_WIDEN_MULT_HI_EXPR)\n@@ -1540,20 +1535,21 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n \telse /* if (code == VEC_WIDEN_MULT_ODD_EXPR) */\n \t  scale = 1, ofs = 1;\n \n+\tauto_vec<tree, 32> elts (out_nelts);\n \tfor (out = 0; out < out_nelts; out++)\n \t  {\n-\t    unsigned int in1 = (out << scale) + ofs;\n-\t    unsigned int in2 = in1 + in_nelts;\n-\t    tree t1, t2;\n-\n-\t    t1 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), elts[in1]);\n-\t    t2 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), elts[in2]);\n+\t    unsigned int in = (out << scale) + ofs;\n+\t    tree t1 = fold_convert_const (NOP_EXPR, TREE_TYPE (type),\n+\t\t\t\t\t  VECTOR_CST_ELT (arg1, in));\n+\t    tree t2 = fold_convert_const (NOP_EXPR, TREE_TYPE (type),\n+\t\t\t\t\t  VECTOR_CST_ELT (arg2, in));\n \n \t    if (t1 == NULL_TREE || t2 == NULL_TREE)\n \t      return NULL_TREE;\n-\t    elts[out] = const_binop (MULT_EXPR, t1, t2);\n-\t    if (elts[out] == NULL_TREE || !CONSTANT_CLASS_P (elts[out]))\n+\t    tree elt = const_binop (MULT_EXPR, t1, t2);\n+\t    if (elt == NULL_TREE || !CONSTANT_CLASS_P (elt))\n \t      return NULL_TREE;\n+\t    elts.quick_push (elt);\n \t  }\n \n \treturn build_vector (type, elts);\n@@ -1638,18 +1634,17 @@ const_unop (enum tree_code code, tree type, tree arg0)\n       /* Perform BIT_NOT_EXPR on each element individually.  */\n       else if (TREE_CODE (arg0) == VECTOR_CST)\n \t{\n-\t  tree *elements;\n \t  tree elem;\n \t  unsigned count = VECTOR_CST_NELTS (arg0), i;\n \n-\t  elements = XALLOCAVEC (tree, count);\n+\t  auto_vec<tree, 32> elements (count);\n \t  for (i = 0; i < count; i++)\n \t    {\n \t      elem = VECTOR_CST_ELT (arg0, i);\n \t      elem = const_unop (BIT_NOT_EXPR, TREE_TYPE (type), elem);\n \t      if (elem == NULL_TREE)\n \t\tbreak;\n-\t      elements[i] = elem;\n+\t      elements.quick_push (elem);\n \t    }\n \t  if (i == count)\n \t    return build_vector (type, elements);\n@@ -1677,7 +1672,6 @@ const_unop (enum tree_code code, tree type, tree arg0)\n     case VEC_UNPACK_FLOAT_HI_EXPR:\n       {\n \tunsigned int out_nelts, in_nelts, i;\n-\ttree *elts;\n \tenum tree_code subcode;\n \n \tif (TREE_CODE (arg0) != VECTOR_CST)\n@@ -1687,24 +1681,24 @@ const_unop (enum tree_code code, tree type, tree arg0)\n \tout_nelts = in_nelts / 2;\n \tgcc_assert (out_nelts == TYPE_VECTOR_SUBPARTS (type));\n \n-\telts = XALLOCAVEC (tree, in_nelts);\n-\tif (!vec_cst_ctor_to_array (arg0, elts))\n-\t  return NULL_TREE;\n-\n+\tunsigned int offset = 0;\n \tif ((!BYTES_BIG_ENDIAN) ^ (code == VEC_UNPACK_LO_EXPR\n \t\t\t\t   || code == VEC_UNPACK_FLOAT_LO_EXPR))\n-\t  elts += out_nelts;\n+\t  offset = out_nelts;\n \n \tif (code == VEC_UNPACK_LO_EXPR || code == VEC_UNPACK_HI_EXPR)\n \t  subcode = NOP_EXPR;\n \telse\n \t  subcode = FLOAT_EXPR;\n \n+\tauto_vec<tree, 32> elts (out_nelts);\n \tfor (i = 0; i < out_nelts; i++)\n \t  {\n-\t    elts[i] = fold_convert_const (subcode, TREE_TYPE (type), elts[i]);\n-\t    if (elts[i] == NULL_TREE || !CONSTANT_CLASS_P (elts[i]))\n+\t    tree elt = fold_convert_const (subcode, TREE_TYPE (type),\n+\t\t\t\t\t   VECTOR_CST_ELT (arg0, i + offset));\n+\t    if (elt == NULL_TREE || !CONSTANT_CLASS_P (elt))\n \t      return NULL_TREE;\n+\t    elts.quick_push (elt);\n \t  }\n \n \treturn build_vector (type, elts);\n@@ -1715,17 +1709,12 @@ const_unop (enum tree_code code, tree type, tree arg0)\n     case REDUC_PLUS_EXPR:\n       {\n \tunsigned int nelts, i;\n-\ttree *elts;\n \tenum tree_code subcode;\n \n \tif (TREE_CODE (arg0) != VECTOR_CST)\n \t  return NULL_TREE;\n \tnelts = VECTOR_CST_NELTS (arg0);\n \n-\telts = XALLOCAVEC (tree, nelts);\n-\tif (!vec_cst_ctor_to_array (arg0, elts))\n-\t  return NULL_TREE;\n-\n \tswitch (code)\n \t  {\n \t  case REDUC_MIN_EXPR: subcode = MIN_EXPR; break;\n@@ -1734,14 +1723,15 @@ const_unop (enum tree_code code, tree type, tree arg0)\n \t  default: gcc_unreachable ();\n \t  }\n \n+\ttree res = VECTOR_CST_ELT (arg0, 0);\n \tfor (i = 1; i < nelts; i++)\n \t  {\n-\t    elts[0] = const_binop (subcode, elts[0], elts[i]);\n-\t    if (elts[0] == NULL_TREE || !CONSTANT_CLASS_P (elts[0]))\n+\t    res = const_binop (subcode, res, VECTOR_CST_ELT (arg0, i));\n+\t    if (res == NULL_TREE || !CONSTANT_CLASS_P (res))\n \t      return NULL_TREE;\n \t  }\n \n-\treturn elts[0];\n+\treturn res;\n       }\n \n     default:\n@@ -2163,14 +2153,14 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \t{\n \t  int len = VECTOR_CST_NELTS (arg1);\n \t  tree elttype = TREE_TYPE (type);\n-\t  tree *v = XALLOCAVEC (tree, len);\n+\t  auto_vec<tree, 32> v (len);\n \t  for (int i = 0; i < len; ++i)\n \t    {\n \t      tree elt = VECTOR_CST_ELT (arg1, i);\n \t      tree cvt = fold_convert_const (code, elttype, elt);\n \t      if (cvt == NULL_TREE)\n \t\treturn NULL_TREE;\n-\t      v[i] = cvt;\n+\t      v.quick_push (cvt);\n \t    }\n \t  return build_vector (type, v);\n \t}\n@@ -7392,21 +7382,20 @@ native_interpret_vector (tree type, const unsigned char *ptr, int len)\n {\n   tree etype, elem;\n   int i, size, count;\n-  tree *elements;\n \n   etype = TREE_TYPE (type);\n   size = GET_MODE_SIZE (SCALAR_TYPE_MODE (etype));\n   count = TYPE_VECTOR_SUBPARTS (type);\n   if (size * count > len)\n     return NULL_TREE;\n \n-  elements = XALLOCAVEC (tree, count);\n-  for (i = count - 1; i >= 0; i--)\n+  auto_vec<tree, 32> elements (count);\n+  for (i = 0; i < count; ++i)\n     {\n       elem = native_interpret_expr (etype, ptr+(i*size), size);\n       if (!elem)\n \treturn NULL_TREE;\n-      elements[i] = elem;\n+      elements.quick_push (elem);\n     }\n   return build_vector (type, elements);\n }\n@@ -8761,12 +8750,13 @@ fold_mult_zconjz (location_t loc, tree type, tree expr)\n \n \n /* Helper function for fold_vec_perm.  Store elements of VECTOR_CST or\n-   CONSTRUCTOR ARG into array ELTS and return true if successful.  */\n+   CONSTRUCTOR ARG into array ELTS, which has NELTS elements, and return\n+   true if successful.  */\n \n static bool\n-vec_cst_ctor_to_array (tree arg, tree *elts)\n+vec_cst_ctor_to_array (tree arg, unsigned int nelts, tree *elts)\n {\n-  unsigned int nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg)), i;\n+  unsigned int i;\n \n   if (TREE_CODE (arg) == VECTOR_CST)\n     {\n@@ -8799,7 +8789,6 @@ static tree\n fold_vec_perm (tree type, tree arg0, tree arg1, const unsigned char *sel)\n {\n   unsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n-  tree *elts;\n   bool need_ctor = false;\n \n   gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts\n@@ -8808,28 +8797,29 @@ fold_vec_perm (tree type, tree arg0, tree arg1, const unsigned char *sel)\n       || TREE_TYPE (TREE_TYPE (arg1)) != TREE_TYPE (type))\n     return NULL_TREE;\n \n-  elts = XALLOCAVEC (tree, nelts * 3);\n-  if (!vec_cst_ctor_to_array (arg0, elts)\n-      || !vec_cst_ctor_to_array (arg1, elts + nelts))\n+  tree *in_elts = XALLOCAVEC (tree, nelts * 2);\n+  if (!vec_cst_ctor_to_array (arg0, nelts, in_elts)\n+      || !vec_cst_ctor_to_array (arg1, nelts, in_elts + nelts))\n     return NULL_TREE;\n \n+  auto_vec<tree, 32> out_elts (nelts);\n   for (i = 0; i < nelts; i++)\n     {\n-      if (!CONSTANT_CLASS_P (elts[sel[i]]))\n+      if (!CONSTANT_CLASS_P (in_elts[sel[i]]))\n \tneed_ctor = true;\n-      elts[i + 2 * nelts] = unshare_expr (elts[sel[i]]);\n+      out_elts.quick_push (unshare_expr (in_elts[sel[i]]));\n     }\n \n   if (need_ctor)\n     {\n       vec<constructor_elt, va_gc> *v;\n       vec_alloc (v, nelts);\n       for (i = 0; i < nelts; i++)\n-\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[2 * nelts + i]);\n+\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, out_elts[i]);\n       return build_constructor (type, v);\n     }\n   else\n-    return build_vector (type, &elts[2 * nelts]);\n+    return build_vector (type, out_elts);\n }\n \n /* Try to fold a pointer difference of type TYPE two address expressions of\n@@ -8879,7 +8869,7 @@ tree\n exact_inverse (tree type, tree cst)\n {\n   REAL_VALUE_TYPE r;\n-  tree unit_type, *elts;\n+  tree unit_type;\n   machine_mode mode;\n   unsigned vec_nelts, i;\n \n@@ -8894,20 +8884,22 @@ exact_inverse (tree type, tree cst)\n       return NULL_TREE;\n \n     case VECTOR_CST:\n-      vec_nelts = VECTOR_CST_NELTS (cst);\n-      elts = XALLOCAVEC (tree, vec_nelts);\n-      unit_type = TREE_TYPE (type);\n-      mode = TYPE_MODE (unit_type);\n+      {\n+\tvec_nelts = VECTOR_CST_NELTS (cst);\n+\tunit_type = TREE_TYPE (type);\n+\tmode = TYPE_MODE (unit_type);\n \n-      for (i = 0; i < vec_nelts; i++)\n-\t{\n-\t  r = TREE_REAL_CST (VECTOR_CST_ELT (cst, i));\n-\t  if (!exact_real_inverse (mode, &r))\n-\t    return NULL_TREE;\n-\t  elts[i] = build_real (unit_type, r);\n-\t}\n+\tauto_vec<tree, 32> elts (vec_nelts);\n+\tfor (i = 0; i < vec_nelts; i++)\n+\t  {\n+\t    r = TREE_REAL_CST (VECTOR_CST_ELT (cst, i));\n+\t    if (!exact_real_inverse (mode, &r))\n+\t      return NULL_TREE;\n+\t    elts.quick_push (build_real (unit_type, r));\n+\t  }\n \n-      return build_vector (type, elts);\n+\treturn build_vector (type, elts);\n+      }\n \n     default:\n       return NULL_TREE;\n@@ -11596,9 +11588,9 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t  if (n == 1)\n \t\t    return VECTOR_CST_ELT (arg0, idx);\n \n-\t\t  tree *vals = XALLOCAVEC (tree, n);\n+\t\t  auto_vec<tree, 32> vals (n);\n \t\t  for (unsigned i = 0; i < n; ++i)\n-\t\t    vals[i] = VECTOR_CST_ELT (arg0, idx + i);\n+\t\t    vals.quick_push (VECTOR_CST_ELT (arg0, idx + i));\n \t\t  return build_vector (type, vals);\n \t\t}\n \t    }\n@@ -11731,10 +11723,10 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \n \t  if (need_mask_canon && arg2 == op2)\n \t    {\n-\t      tree *tsel = XALLOCAVEC (tree, nelts);\n \t      tree eltype = TREE_TYPE (TREE_TYPE (arg2));\n+\t      auto_vec<tree, 32> tsel (nelts);\n \t      for (i = 0; i < nelts; i++)\n-\t\ttsel[i] = build_int_cst (eltype, sel[i]);\n+\t\ttsel.quick_push (build_int_cst (eltype, sel[i]));\n \t      op2 = build_vector (TREE_TYPE (arg2), tsel);\n \t      changed = true;\n \t    }\n@@ -11775,8 +11767,10 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t      else\n \t\t{\n \t\t  unsigned int nelts = VECTOR_CST_NELTS (arg0);\n-\t\t  tree *elts = XALLOCAVEC (tree, nelts);\n-\t\t  memcpy (elts, VECTOR_CST_ELTS (arg0), sizeof (tree) * nelts);\n+\t\t  auto_vec<tree, 32> elts (nelts);\n+\t\t  elts.quick_grow (nelts);\n+\t\t  memcpy (&elts[0], VECTOR_CST_ELTS (arg0),\n+\t\t\t  sizeof (tree) * nelts);\n \t\t  elts[k] = arg1;\n \t\t  return build_vector (type, elts);\n \t\t}\n@@ -13894,10 +13888,10 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \t  return constant_boolean_node (true, type);\n \t}\n       unsigned count = VECTOR_CST_NELTS (op0);\n-      tree *elts =  XALLOCAVEC (tree, count);\n       gcc_assert (VECTOR_CST_NELTS (op1) == count\n \t\t  && TYPE_VECTOR_SUBPARTS (type) == count);\n \n+      auto_vec<tree, 32> elts (count);\n       for (unsigned i = 0; i < count; i++)\n \t{\n \t  tree elem_type = TREE_TYPE (type);\n@@ -13910,7 +13904,8 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \t  if (tem == NULL_TREE)\n \t    return NULL_TREE;\n \n-\t  elts[i] = build_int_cst (elem_type, integer_zerop (tem) ? 0 : -1);\n+\t  elts.quick_push (build_int_cst (elem_type,\n+\t\t\t\t\t  integer_zerop (tem) ? 0 : -1));\n \t}\n \n       return build_vector (type, elts);"}, {"sha": "bde20a34bfbb12e6bbf666096b2d939ba51deff1", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -5919,18 +5919,18 @@ gimple_fold_stmt_to_constant_1 (gimple *stmt, tree (*valueize) (tree),\n \t\t       && (CONSTRUCTOR_NELTS (rhs)\n \t\t\t   == TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs))))\n \t\t{\n-\t\t  unsigned i;\n-\t\t  tree val, *vec;\n+\t\t  unsigned i, nelts;\n+\t\t  tree val;\n \n-\t\t  vec = XALLOCAVEC (tree,\n-\t\t\t\t    TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs)));\n+\t\t  nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (rhs));\n+\t\t  auto_vec<tree, 32> vec (nelts);\n \t\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (rhs), i, val)\n \t\t    {\n \t\t      val = (*valueize) (val);\n \t\t      if (TREE_CODE (val) == INTEGER_CST\n \t\t\t  || TREE_CODE (val) == REAL_CST\n \t\t\t  || TREE_CODE (val) == FIXED_CST)\n-\t\t\tvec[i] = val;\n+\t\t\tvec.quick_push (val);\n \t\t      else\n \t\t\treturn NULL_TREE;\n \t\t    }"}, {"sha": "82d940bd36eb7fc6c20fad1293cca1da2193a984", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -2051,7 +2051,7 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n     }\n   else\n     {\n-      tree mask_type, *mask_elts;\n+      tree mask_type;\n \n       if (!can_vec_perm_p (TYPE_MODE (type), false, sel))\n \treturn false;\n@@ -2062,9 +2062,9 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t  || GET_MODE_SIZE (TYPE_MODE (mask_type))\n \t     != GET_MODE_SIZE (TYPE_MODE (type)))\n \treturn false;\n-      mask_elts = XALLOCAVEC (tree, nelts);\n+      auto_vec<tree, 32> mask_elts (nelts);\n       for (i = 0; i < nelts; i++)\n-\tmask_elts[i] = build_int_cst (TREE_TYPE (mask_type), sel[i]);\n+\tmask_elts.quick_push (build_int_cst (TREE_TYPE (mask_type), sel[i]));\n       op2 = build_vector (mask_type, mask_elts);\n       if (conv_code == ERROR_MARK)\n \tgimple_assign_set_rhs_with_ops (gsi, VEC_PERM_EXPR, orig, orig, op2);"}, {"sha": "1341d66deed72baa31b75fc32dbdaf14528eefb0", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -398,9 +398,9 @@ add_rshift (gimple_stmt_iterator *gsi, tree type, tree op0, int *shiftcnts)\n   if (op != unknown_optab\n       && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n     {\n-      tree *vec = XALLOCAVEC (tree, nunits);\n+      auto_vec<tree, 32> vec (nunits);\n       for (i = 0; i < nunits; i++)\n-\tvec[i] = build_int_cst (TREE_TYPE (type), shiftcnts[i]);\n+\tvec.quick_push (build_int_cst (TREE_TYPE (type), shiftcnts[i]));\n       return gimplify_build2 (gsi, RSHIFT_EXPR, type, op0,\n \t\t\t      build_vector (type, vec));\n     }\n@@ -429,7 +429,6 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n   unsigned int i;\n   signop sign_p = TYPE_SIGN (TREE_TYPE (type));\n   unsigned HOST_WIDE_INT mask = GET_MODE_MASK (TYPE_MODE (TREE_TYPE (type)));\n-  tree *vec;\n   tree cur_op, mulcst, tem;\n   optab op;\n \n@@ -593,8 +592,6 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \tmode = -2;\n     }\n \n-  vec = XALLOCAVEC (tree, nunits);\n-\n   if (use_pow2)\n     {\n       tree addend = NULL_TREE;\n@@ -638,10 +635,11 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t      mask_type = build_same_sized_truth_vector_type (type);\n \t      zero = build_zero_cst (type);\n \t      cond = build2 (LT_EXPR, mask_type, op0, zero);\n+\t      auto_vec<tree, 32> vec (nunits);\n \t      for (i = 0; i < nunits; i++)\n-\t\tvec[i] = build_int_cst (TREE_TYPE (type),\n-\t\t\t\t\t(HOST_WIDE_INT_1U\n-\t\t\t\t\t << shifts[i]) - 1);\n+\t\tvec.quick_push (build_int_cst (TREE_TYPE (type),\n+\t\t\t\t\t       (HOST_WIDE_INT_1U\n+\t\t\t\t\t\t<< shifts[i]) - 1));\n \t      cst = build_vector (type, vec);\n \t      addend = make_ssa_name (type);\n \t      stmt = gimple_build_assign (addend, VEC_COND_EXPR, cond,\n@@ -676,10 +674,11 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n       else\n \t{\n \t  tree mask;\n+\t  auto_vec<tree, 32> vec (nunits);\n \t  for (i = 0; i < nunits; i++)\n-\t    vec[i] = build_int_cst (TREE_TYPE (type),\n-\t\t\t\t    (HOST_WIDE_INT_1U\n-\t\t\t\t     << shifts[i]) - 1);\n+\t    vec.quick_push (build_int_cst (TREE_TYPE (type),\n+\t\t\t\t\t   (HOST_WIDE_INT_1U\n+\t\t\t\t\t    << shifts[i]) - 1));\n \t  mask = build_vector (type, vec);\n \t  op = optab_for_tree_code (BIT_AND_EXPR, type, optab_default);\n \t  if (op != unknown_optab\n@@ -754,8 +753,9 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n       return NULL_TREE;\n     }\n \n+  auto_vec<tree, 32> vec (nunits);\n   for (i = 0; i < nunits; i++)\n-    vec[i] = build_int_cst (TREE_TYPE (type), mulc[i]);\n+    vec.quick_push (build_int_cst (TREE_TYPE (type), mulc[i]));\n   mulcst = build_vector (type, vec);\n \n   cur_op = gimplify_build2 (gsi, MULT_HIGHPART_EXPR, type, cur_op, mulcst);\n@@ -1066,7 +1066,6 @@ optimize_vector_constructor (gimple_stmt_iterator *gsi)\n   unsigned int i, j, nelts = TYPE_VECTOR_SUBPARTS (type);\n   bool all_same = true;\n   constructor_elt *elt;\n-  tree *cst;\n   gimple *g;\n   tree base = NULL_TREE;\n   optab op;\n@@ -1105,22 +1104,23 @@ optimize_vector_constructor (gimple_stmt_iterator *gsi)\n       }\n   if (all_same)\n     return;\n-  cst = XALLOCAVEC (tree, nelts);\n+  auto_vec<tree, 32> cst (nelts);\n   for (i = 0; i < nelts; i++)\n     {\n-      tree this_base = CONSTRUCTOR_ELT (rhs, i)->value;;\n-      cst[i] = build_zero_cst (TREE_TYPE (base));\n+      tree this_base = CONSTRUCTOR_ELT (rhs, i)->value;\n+      tree elt = build_zero_cst (TREE_TYPE (base));\n       while (this_base != base)\n \t{\n \t  g = SSA_NAME_DEF_STMT (this_base);\n-\t  cst[i] = fold_binary (PLUS_EXPR, TREE_TYPE (base),\n-\t\t\t\tcst[i], gimple_assign_rhs2 (g));\n-\t  if (cst[i] == NULL_TREE\n-\t      || TREE_CODE (cst[i]) != INTEGER_CST\n-\t      || TREE_OVERFLOW (cst[i]))\n+\t  elt = fold_binary (PLUS_EXPR, TREE_TYPE (base),\n+\t\t\t     elt, gimple_assign_rhs2 (g));\n+\t  if (elt == NULL_TREE\n+\t      || TREE_CODE (elt) != INTEGER_CST\n+\t      || TREE_OVERFLOW (elt))\n \t    return;\n \t  this_base = gimple_assign_rhs1 (g);\n \t}\n+      cst.quick_push (elt);\n     }\n   for (i = 0; i < nelts; i++)\n     CONSTRUCTOR_ELT (rhs, i)->value = base;"}, {"sha": "3b4a71eba894caf408855ea67a74a3b99da4ec1f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -3969,7 +3969,6 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree def_for_init;\n   tree init_def;\n-  tree *elts;\n   int i;\n   bool nested_in_vect_loop = false;\n   REAL_VALUE_TYPE real_init_val = dconst0;\n@@ -4015,15 +4014,16 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n \n   switch (code)\n     {\n-      case WIDEN_SUM_EXPR:\n-      case DOT_PROD_EXPR:\n-      case SAD_EXPR:\n-      case PLUS_EXPR:\n-      case MINUS_EXPR:\n-      case BIT_IOR_EXPR:\n-      case BIT_XOR_EXPR:\n-      case MULT_EXPR:\n-      case BIT_AND_EXPR:\n+    case WIDEN_SUM_EXPR:\n+    case DOT_PROD_EXPR:\n+    case SAD_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case MULT_EXPR:\n+    case BIT_AND_EXPR:\n+      {\n         /* ADJUSMENT_DEF is NULL when called from\n            vect_create_epilog_for_reduction to vectorize double reduction.  */\n         if (adjustment_def)\n@@ -4044,17 +4044,19 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n           def_for_init = build_int_cst (scalar_type, int_init_val);\n \n         /* Create a vector of '0' or '1' except the first element.  */\n-\telts = XALLOCAVEC (tree, nunits);\n+\tauto_vec<tree, 32> elts (nunits);\n+\telts.quick_grow (nunits);\n         for (i = nunits - 2; i >= 0; --i)\n \t  elts[i + 1] = def_for_init;\n \n         /* Option1: the first element is '0' or '1' as well.  */\n-        if (adjustment_def)\n-          {\n+\tif (adjustment_def)\n+\t  {\n \t    elts[0] = def_for_init;\n-            init_def = build_vector (vectype, elts);\n-            break;\n-          }\n+\n+\t    init_def = build_vector (vectype, elts);\n+\t    break;\n+\t  }\n \n         /* Option2: the first element is INIT_VAL.  */\n \telts[0] = init_val;\n@@ -4069,12 +4071,13 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n \t      CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[i]);\n \t    init_def = build_constructor (vectype, v);\n \t  }\n+      }\n+      break;\n \n-        break;\n-\n-      case MIN_EXPR:\n-      case MAX_EXPR:\n-      case COND_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case COND_EXPR:\n+      {\n \tif (adjustment_def)\n           {\n \t    *adjustment_def = NULL_TREE;\n@@ -4088,10 +4091,11 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n \tif (! gimple_seq_empty_p (stmts))\n \t  gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n \tinit_def = build_vector_from_val (vectype, init_val);\n-\tbreak;\n+      }\n+      break;\n \n-      default:\n-        gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n     }\n \n   return init_def;\n@@ -4111,7 +4115,6 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   unsigned nunits;\n   tree vec_cst;\n-  tree *elts;\n   unsigned j, number_of_places_left_in_vector;\n   tree vector_type, scalar_type;\n   tree vop;\n@@ -4195,7 +4198,8 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \n   number_of_places_left_in_vector = nunits;\n   constant_p = true;\n-  elts = XALLOCAVEC (tree, nunits);\n+  auto_vec<tree, 32> elts (nunits);\n+  elts.quick_grow (nunits);\n   for (j = 0; j < number_of_copies; j++)\n     {\n       for (i = group_size - 1; stmts.iterate (i, &stmt); i--)\n@@ -4533,9 +4537,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t vector size (STEP).  */\n \n       /* Create a {1,2,3,...} vector.  */\n-      tree *vtemp = XALLOCAVEC (tree, nunits_out);\n+      auto_vec<tree, 32> vtemp (nunits_out);\n       for (k = 0; k < nunits_out; ++k)\n-\tvtemp[k] = build_int_cst (cr_index_scalar_type, k + 1);\n+\tvtemp.quick_push (build_int_cst (cr_index_scalar_type, k + 1));\n       tree series_vect = build_vector (cr_index_vector_type, vtemp);\n \n       /* Create a vector of the step value.  */\n@@ -6731,7 +6735,7 @@ vectorizable_induction (gimple *phi,\n       unsigned ivn;\n       for (ivn = 0; ivn < nivs; ++ivn)\n \t{\n-\t  tree *elts = XALLOCAVEC (tree, nunits);\n+\t  auto_vec<tree, 32> elts (nunits);\n \t  bool constant_p = true;\n \t  for (unsigned eltn = 0; eltn < nunits; ++eltn)\n \t    {\n@@ -6749,7 +6753,7 @@ vectorizable_induction (gimple *phi,\n \t\t}\n \t      if (! CONSTANT_CLASS_P (elt))\n \t\tconstant_p = false;\n-\t      elts[eltn] = elt;\n+\t      elts.quick_push (elt);\n \t    }\n \t  if (constant_p)\n \t    new_vec = build_vector (vectype, elts);"}, {"sha": "32ca6afa614524aa65f0e150e87e5a7162cb968d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -3105,7 +3105,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n   unsigned nunits;\n   tree vec_cst;\n-  tree *elts;\n   unsigned j, number_of_places_left_in_vector;\n   tree vector_type;\n   tree vop;\n@@ -3158,7 +3157,8 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \n   number_of_places_left_in_vector = nunits;\n   constant_p = true;\n-  elts = XALLOCAVEC (tree, nunits);\n+  auto_vec<tree, 32> elts (nunits);\n+  elts.quick_grow (nunits);\n   bool place_after_defs = false;\n   for (j = 0; j < number_of_copies; j++)\n     {\n@@ -3600,10 +3600,10 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t  \n \t\t  if (! noop_p)\n \t\t    {\n-\t\t      tree *mask_elts = XALLOCAVEC (tree, nunits);\n+\t\t      auto_vec<tree, 32> mask_elts (nunits);\n \t\t      for (int l = 0; l < nunits; ++l)\n-\t\t\tmask_elts[l] = build_int_cst (mask_element_type,\n-\t\t\t\t\t\t      mask[l]);\n+\t\t\tmask_elts.quick_push (build_int_cst (mask_element_type,\n+\t\t\t\t\t\t\t     mask[l]));\n \t\t      mask_vec = build_vector (mask_type, mask_elts);\n \t\t    }\n \n@@ -3759,13 +3759,14 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \t  unsigned k = 0, l;\n \t  for (j = 0; j < v0.length (); ++j)\n \t    {\n-\t      tree *melts = XALLOCAVEC (tree, TYPE_VECTOR_SUBPARTS (vectype));\n-\t      for (l = 0; l < TYPE_VECTOR_SUBPARTS (vectype); ++l)\n+\t      unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\t      auto_vec<tree, 32> melts (nunits);\n+\t      for (l = 0; l < nunits; ++l)\n \t\t{\n \t\t  if (k >= group_size)\n \t\t    k = 0;\n-\t\t  melts[l] = build_int_cst\n-\t\t      (meltype, mask[k++] * TYPE_VECTOR_SUBPARTS (vectype) + l);\n+\t\t  tree t = build_int_cst (meltype, mask[k++] * nunits + l);\n+\t\t  melts.quick_push (t);\n \t\t}\n \t      tmask = build_vector (mvectype, melts);\n "}, {"sha": "b5f706c1f31ee8e9b923da01a2c5f1f4fe135eb0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -2480,10 +2480,10 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (! char_vectype)\n     return false;\n \n-  unsigned char *elts\n-    = XALLOCAVEC (unsigned char, TYPE_VECTOR_SUBPARTS (char_vectype));\n+  unsigned int num_bytes = TYPE_VECTOR_SUBPARTS (char_vectype);\n+  unsigned char *elts = XALLOCAVEC (unsigned char, num_bytes);\n   unsigned char *elt = elts;\n-  unsigned word_bytes = TYPE_VECTOR_SUBPARTS (char_vectype) / nunits;\n+  unsigned word_bytes = num_bytes / nunits;\n   for (unsigned i = 0; i < nunits; ++i)\n     for (unsigned j = 0; j < word_bytes; ++j)\n       *elt++ = (i + 1) * word_bytes - j - 1;\n@@ -2507,9 +2507,9 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n       return true;\n     }\n \n-  tree *telts = XALLOCAVEC (tree, TYPE_VECTOR_SUBPARTS (char_vectype));\n-  for (unsigned i = 0; i < TYPE_VECTOR_SUBPARTS (char_vectype); ++i)\n-    telts[i] = build_int_cst (char_type_node, elts[i]);\n+  auto_vec<tree, 32> telts (num_bytes);\n+  for (unsigned i = 0; i < num_bytes; ++i)\n+    telts.quick_push (build_int_cst (char_type_node, elts[i]));\n   tree bswap_vconst = build_vector (char_vectype, telts);\n \n   /* Transform.  */\n@@ -2928,10 +2928,10 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  if (gimple_call_internal_p (stmt)\n \t      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n \t    {\n-\t      tree *v = XALLOCAVEC (tree, nunits_out);\n-\t      int k;\n-\t      for (k = 0; k < nunits_out; ++k)\n-\t\tv[k] = build_int_cst (unsigned_type_node, j * nunits_out + k);\n+\t      auto_vec<tree, 32> v (nunits_out);\n+\t      for (int k = 0; k < nunits_out; ++k)\n+\t\tv.quick_push (build_int_cst (unsigned_type_node,\n+\t\t\t\t\t     j * nunits_out + k));\n \t      tree cst = build_vector (vectype_out, v);\n \t      tree new_var\n \t\t= vect_get_new_ssa_name (vectype_out, vect_simple_var, \"cst_\");\n@@ -6505,7 +6505,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n tree\n vect_gen_perm_mask_any (tree vectype, const unsigned char *sel)\n {\n-  tree mask_elt_type, mask_type, mask_vec, *mask_elts;\n+  tree mask_elt_type, mask_type, mask_vec;\n   int i, nunits;\n \n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -6514,9 +6514,9 @@ vect_gen_perm_mask_any (tree vectype, const unsigned char *sel)\n     (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_elt_type);\n \n-  mask_elts = XALLOCAVEC (tree, nunits);\n-  for (i = nunits - 1; i >= 0; i--)\n-    mask_elts[i] = build_int_cst (mask_elt_type, sel[i]);\n+  auto_vec<tree, 32> mask_elts (nunits);\n+  for (i = 0; i < nunits; ++i)\n+    mask_elts.quick_push (build_int_cst (mask_elt_type, sel[i]));\n   mask_vec = build_vector (mask_type, mask_elts);\n \n   return mask_vec;"}, {"sha": "788a84b511eb30ba31b048483aef028fa46cf310", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -1702,18 +1702,20 @@ make_vector (unsigned len MEM_STAT_DECL)\n }\n \n /* Return a new VECTOR_CST node whose type is TYPE and whose values\n-   are in a list pointed to by VALS.  */\n+   are given by VALS.  */\n \n tree\n-build_vector (tree type, tree *vals MEM_STAT_DECL)\n+build_vector (tree type, vec<tree> vals MEM_STAT_DECL)\n {\n+  unsigned int nelts = vals.length ();\n+  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n   int over = 0;\n   unsigned cnt = 0;\n-  tree v = make_vector (TYPE_VECTOR_SUBPARTS (type));\n+  tree v = make_vector (nelts);\n   TREE_TYPE (v) = type;\n \n   /* Iterate through elements and check for overflow.  */\n-  for (cnt = 0; cnt < TYPE_VECTOR_SUBPARTS (type); ++cnt)\n+  for (cnt = 0; cnt < nelts; ++cnt)\n     {\n       tree value = vals[cnt];\n \n@@ -1736,20 +1738,21 @@ build_vector (tree type, tree *vals MEM_STAT_DECL)\n tree\n build_vector_from_ctor (tree type, vec<constructor_elt, va_gc> *v)\n {\n-  tree *vec = XALLOCAVEC (tree, TYPE_VECTOR_SUBPARTS (type));\n-  unsigned HOST_WIDE_INT idx, pos = 0;\n+  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n+  unsigned HOST_WIDE_INT idx;\n   tree value;\n \n+  auto_vec<tree, 32> vec (nelts);\n   FOR_EACH_CONSTRUCTOR_VALUE (v, idx, value)\n     {\n       if (TREE_CODE (value) == VECTOR_CST)\n \tfor (unsigned i = 0; i < VECTOR_CST_NELTS (value); ++i)\n-\t  vec[pos++] = VECTOR_CST_ELT (value, i);\n+\t  vec.quick_push (VECTOR_CST_ELT (value, i));\n       else\n-\tvec[pos++] = value;\n+\tvec.quick_push (value);\n     }\n-  while (pos < TYPE_VECTOR_SUBPARTS (type))\n-    vec[pos++] = build_zero_cst (TREE_TYPE (type));\n+  while (vec.length () < nelts)\n+    vec.quick_push (build_zero_cst (TREE_TYPE (type)));\n \n   return build_vector (type, vec);\n }\n@@ -1774,9 +1777,9 @@ build_vector_from_val (tree vectype, tree sc)\n \n   if (CONSTANT_CLASS_P (sc))\n     {\n-      tree *v = XALLOCAVEC (tree, nunits);\n+      auto_vec<tree, 32> v (nunits);\n       for (i = 0; i < nunits; ++i)\n-\tv[i] = sc;\n+\tv.quick_push (sc);\n       return build_vector (vectype, v);\n     }\n   else"}, {"sha": "caa4a69977d4c39f3710149246228a0d63c50a73", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794e31808f1554d51f0f0357c3a74a6365f0a274/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=794e31808f1554d51f0f0357c3a74a6365f0a274", "patch": "@@ -4026,7 +4026,7 @@ extern tree build_int_cst (tree, HOST_WIDE_INT);\n extern tree build_int_cstu (tree type, unsigned HOST_WIDE_INT cst);\n extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n extern tree make_vector (unsigned CXX_MEM_STAT_INFO);\n-extern tree build_vector (tree, tree * CXX_MEM_STAT_INFO);\n+extern tree build_vector (tree, vec<tree> CXX_MEM_STAT_INFO);\n extern tree build_vector_from_ctor (tree, vec<constructor_elt, va_gc> *);\n extern tree build_vector_from_val (tree, tree);\n extern void recompute_constructor_flags (tree);"}]}