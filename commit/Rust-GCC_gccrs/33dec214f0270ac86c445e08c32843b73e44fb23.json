{"sha": "33dec214f0270ac86c445e08c32843b73e44fb23", "node_id": "C_kwDOANBUbNoAKDMzZGVjMjE0ZjAyNzBhYzg2YzQ0NWUwOGMzMjg0M2I3M2U0NGZiMjM", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-04-21T03:17:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-30T08:29:02Z"}, "message": "[Ada] Tweaks to hardening docs\n\nMention when security hardening features are available in other\nlanguages.\n\nExpand the strub documentation a little, for clarity and completeness.\n\nAdd missing 'aliased' and attribute to variables in strub example.\n\ngcc/ada/\n\n\t* doc/gnat_rm/security_hardening_features.rst: Mention\n\tavailability in other languages when applicable.\n\t(Stack Scrubbing): Associate the attribute with types, expand\n\tsome comments, fix the example involving access to variables.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "26308e6beb7c431ff80282c663a129cb81d8aa4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26308e6beb7c431ff80282c663a129cb81d8aa4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33dec214f0270ac86c445e08c32843b73e44fb23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33dec214f0270ac86c445e08c32843b73e44fb23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33dec214f0270ac86c445e08c32843b73e44fb23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33dec214f0270ac86c445e08c32843b73e44fb23/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4609660b7739c85ee354da9c758c97f8ea2b998b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4609660b7739c85ee354da9c758c97f8ea2b998b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4609660b7739c85ee354da9c758c97f8ea2b998b"}], "stats": {"total": 104, "additions": 79, "deletions": 25}, "files": [{"sha": "0631a53df9b1a9ea33e5a20246fcae38cb37a35b", "filename": "gcc/ada/doc/gnat_rm/security_hardening_features.rst", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33dec214f0270ac86c445e08c32843b73e44fb23/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33dec214f0270ac86c445e08c32843b73e44fb23/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst?ref=33dec214f0270ac86c445e08c32843b73e44fb23", "patch": "@@ -31,9 +31,10 @@ option, to affect all subprograms in a compilation, and with a\n      --  Before returning, Bar scrubs all call-clobbered registers.\n \n \n-For usage and more details on the command-line option, and on the\n-``zero_call_used_regs`` attribute, see :title:`Using the GNU Compiler\n-Collection (GCC)`.\n+For usage and more details on the command-line option, on the\n+``zero_call_used_regs`` attribute, and on their use with other\n+programming languages, see :title:`Using the GNU Compiler Collection\n+(GCC)`.\n \n \n .. Stack Scrubbing:\n@@ -44,14 +45,17 @@ Stack Scrubbing\n GNAT can generate code to zero-out stack frames used by subprograms.\n \n It can be activated with the :samp:`Machine_Attribute` pragma, on\n-specific subprograms and variables.\n+specific subprograms and variables, or their types.  (This attribute\n+always applies to a type, even when it is associated with a subprogram\n+or a variable.)\n \n .. code-block:: ada\n \n      function Foo returns Integer;\n      pragma Machine_Attribute (Foo, \"strub\");\n      --  Foo and its callers are modified so as to scrub the stack\n-     --  space used by Foo after it returns.\n+     --  space used by Foo after it returns.  Shorthand for:\n+     --  pragma Machine_Attribute (Foo, \"strub\", \"at-calls\");\n \n      procedure Bar;\n      pragma Machine_Attribute (Bar, \"strub\", \"internal\");\n@@ -61,13 +65,16 @@ specific subprograms and variables.\n      Var : Integer;\n      pragma Machine_Attribute (Var, \"strub\");\n      --  Reading from Var in a subprogram enables stack scrubbing\n-     --  of the stack space used by the subprogram.\n+     --  of the stack space used by the subprogram.  Furthermore, if\n+     --  Var is declared within a subprogram, this also enables\n+     --  scrubbing of the stack space used by that subprogram.\n \n \n There are also :switch:`-fstrub` command-line options to control\n default settings.  For usage and more details on the command-line\n-option, and on the ``strub`` attribute, see :title:`Using the GNU\n-Compiler Collection (GCC)`.\n+option, on the ``strub`` attribute, and their use with other\n+programming languages, see :title:`Using the GNU Compiler Collection\n+(GCC)`.\n \n Note that Ada secondary stacks are not scrubbed.  The restriction\n ``No_Secondary_Stack`` avoids their use, and thus their accidental\n@@ -81,16 +88,19 @@ access type designates a non-strub type.\n \n .. code-block:: ada\n \n-     VI : Integer;\n+     VI : aliased Integer;\n+     pragma Machine_Attribute (VI, \"strub\");\n      XsVI : access Integer := VI'Access; -- Error.\n      UXsVI : access Integer := VI'Unchecked_Access; -- OK,\n-     -- UXsVI.all does not enable strub in the enclosing subprogram.\n+     --  UXsVI does *not* enable strub in subprograms that\n+     --  dereference it to obtain the UXsVI.all value.\n \n      type Strub_Int is new Integer;\n      pragma Machine_Attribute (Strub_Int, \"strub\");\n-     VSI : Strub_Int;\n-     XsVSI : access Strub_Int := VSI'Access; -- OK.\n-     -- XsVSI.all enables strub in the enclosing subprogram.\n+     VSI : aliased Strub_Int;\n+     XsVSI : access Strub_Int := VSI'Access; -- OK,\n+     --  VSI and XsVSI.all both enable strub in subprograms that\n+     --  read their values.\n \n \n Every access-to-subprogram type, renaming, and overriding and\n@@ -108,13 +118,17 @@ turned ``callable`` through such an explicit conversion:\n \n      type TBar_Callable is access procedure;\n      pragma Machine_Attribute (TBar_Callable, \"strub\", \"callable\");\n+     --  The attribute modifies the procedure type, rather than the\n+     --  access type, because of the extra argument after \"strub\",\n+     --  only applicable to subprogram types.\n \n      Bar_Callable_Ptr : constant TBar_Callable\n \t\t:= TBar_Callable (TBar'(Bar'Access));\n \n      procedure Bar_Callable renames Bar_Callable_Ptr.all;\n      pragma Machine_Attribute (Bar_Callable, \"strub\", \"callable\");\n \n+\n Note that the renaming declaration is expanded to a full subprogram\n body, it won't be just an alias.  Only if it is inlined will it be as\n efficient as a call by dereferencing the access-to-subprogram constant\n@@ -162,6 +176,10 @@ respectively.\n They are separate options, however, because of the significantly\n different performance impact of the hardening transformations.\n \n+For usage and more details on the command-line options, see\n+:title:`Using the GNU Compiler Collection (GCC)`.  These options can\n+be used with other programming languages supported by GCC.\n+\n \n .. Hardened Booleans:\n \n@@ -177,6 +195,7 @@ alternative representations, using representation clauses:\n    for HBool use (16#5a#, 16#a5#);\n    for HBool'Size use 8;\n \n+\n When validity checking is enabled, the compiler will check that\n variables of such types hold values corresponding to the selected\n representations.\n@@ -196,8 +215,14 @@ checked even when compiling with :switch:`-gnatVT`.\n \n    pragma Machine_Attribute (HBool, \"hardbool\");\n \n+\n Note that :switch:`-gnatVn` will disable even ``hardbool`` testing.\n \n+Analogous behavior is available as a GCC extension to the C and\n+Objective C programming languages, through the ``hardbool`` attribute.\n+For usage and more details on that attribute, see :title:`Using the\n+GNU Compiler Collection (GCC)`.\n+\n \n .. Control Flow Redundancy:\n \n@@ -243,3 +268,7 @@ disabled altogether.\n The instrumentation for hardening with control flow redundancy can be\n observed in dump files generated by the command-line option\n :switch:`-fdump-tree-hardcfr`.\n+\n+For more details on the control flow redundancy command-line options,\n+see :title:`Using the GNU Compiler Collection (GCC)`.  These options\n+can be used with other programming languages supported by GCC."}, {"sha": "434bd3c8e61a96ad7a805c1e30a968cc76f06092", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33dec214f0270ac86c445e08c32843b73e44fb23/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33dec214f0270ac86c445e08c32843b73e44fb23/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=33dec214f0270ac86c445e08c32843b73e44fb23", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Apr 22, 2022\n+GNAT Reference Manual , May 24, 2022\n \n AdaCore\n \n@@ -28920,8 +28920,9 @@ pragma Machine_Attribute (Bar, \"zero_call_used_regs\", \"all\");\n --  Before returning, Bar scrubs all call-clobbered registers.\n @end example\n \n-For usage and more details on the command-line option, and on the\n-@code{zero_call_used_regs} attribute, see @cite{Using the GNU Compiler Collection (GCC)}.\n+For usage and more details on the command-line option, on the\n+@code{zero_call_used_regs} attribute, and on their use with other\n+programming languages, see @cite{Using the GNU Compiler Collection (GCC)}.\n \n @c Stack Scrubbing:\n \n@@ -28933,13 +28934,16 @@ For usage and more details on the command-line option, and on the\n GNAT can generate code to zero-out stack frames used by subprograms.\n \n It can be activated with the @code{Machine_Attribute} pragma, on\n-specific subprograms and variables.\n+specific subprograms and variables, or their types.  (This attribute\n+always applies to a type, even when it is associated with a subprogram\n+or a variable.)\n \n @example\n function Foo returns Integer;\n pragma Machine_Attribute (Foo, \"strub\");\n --  Foo and its callers are modified so as to scrub the stack\n---  space used by Foo after it returns.\n+--  space used by Foo after it returns.  Shorthand for:\n+--  pragma Machine_Attribute (Foo, \"strub\", \"at-calls\");\n \n procedure Bar;\n pragma Machine_Attribute (Bar, \"strub\", \"internal\");\n@@ -28949,12 +28953,15 @@ pragma Machine_Attribute (Bar, \"strub\", \"internal\");\n Var : Integer;\n pragma Machine_Attribute (Var, \"strub\");\n --  Reading from Var in a subprogram enables stack scrubbing\n---  of the stack space used by the subprogram.\n+--  of the stack space used by the subprogram.  Furthermore, if\n+--  Var is declared within a subprogram, this also enables\n+--  scrubbing of the stack space used by that subprogram.\n @end example\n \n There are also @code{-fstrub} command-line options to control\n default settings.  For usage and more details on the command-line\n-option, and on the @code{strub} attribute, see @cite{Using the GNU Compiler Collection (GCC)}.\n+option, on the @code{strub} attribute, and their use with other\n+programming languages, see @cite{Using the GNU Compiler Collection (GCC)}.\n \n Note that Ada secondary stacks are not scrubbed.  The restriction\n @code{No_Secondary_Stack} avoids their use, and thus their accidental\n@@ -28967,16 +28974,19 @@ there is no way to express an access-to-strub type otherwise.\n access type designates a non-strub type.\n \n @example\n-VI : Integer;\n+VI : aliased Integer;\n+pragma Machine_Attribute (VI, \"strub\");\n XsVI : access Integer := VI'Access; -- Error.\n UXsVI : access Integer := VI'Unchecked_Access; -- OK,\n--- UXsVI.all does not enable strub in the enclosing subprogram.\n+--  UXsVI does *not* enable strub in subprograms that\n+--  dereference it to obtain the UXsVI.all value.\n \n type Strub_Int is new Integer;\n pragma Machine_Attribute (Strub_Int, \"strub\");\n-VSI : Strub_Int;\n-XsVSI : access Strub_Int := VSI'Access; -- OK.\n--- XsVSI.all enables strub in the enclosing subprogram.\n+VSI : aliased Strub_Int;\n+XsVSI : access Strub_Int := VSI'Access; -- OK,\n+--  VSI and XsVSI.all both enable strub in subprograms that\n+--  read their values.\n @end example\n \n Every access-to-subprogram type, renaming, and overriding and\n@@ -28993,6 +29003,9 @@ type TBar is access procedure;\n \n type TBar_Callable is access procedure;\n pragma Machine_Attribute (TBar_Callable, \"strub\", \"callable\");\n+--  The attribute modifies the procedure type, rather than the\n+--  access type, because of the extra argument after \"strub\",\n+--  only applicable to subprogram types.\n \n Bar_Callable_Ptr : constant TBar_Callable\n            := TBar_Callable (TBar'(Bar'Access));\n@@ -29049,6 +29062,10 @@ respectively.\n They are separate options, however, because of the significantly\n different performance impact of the hardening transformations.\n \n+For usage and more details on the command-line options, see\n+@cite{Using the GNU Compiler Collection (GCC)}.  These options can\n+be used with other programming languages supported by GCC.\n+\n @c Hardened Booleans:\n \n @node Hardened Booleans,Control Flow Redundancy,Hardened Conditionals,Security Hardening Features\n@@ -29086,6 +29103,10 @@ pragma Machine_Attribute (HBool, \"hardbool\");\n \n Note that @code{-gnatVn} will disable even @code{hardbool} testing.\n \n+Analogous behavior is available as a GCC extension to the C and\n+Objective C programming languages, through the @code{hardbool} attribute.\n+For usage and more details on that attribute, see @cite{Using the GNU Compiler Collection (GCC)}.\n+\n @c Control Flow Redundancy:\n \n @node Control Flow Redundancy,,Hardened Booleans,Security Hardening Features\n@@ -29133,6 +29154,10 @@ The instrumentation for hardening with control flow redundancy can be\n observed in dump files generated by the command-line option\n @code{-fdump-tree-hardcfr}.\n \n+For more details on the control flow redundancy command-line options,\n+see @cite{Using the GNU Compiler Collection (GCC)}.  These options\n+can be used with other programming languages supported by GCC.\n+\n @node Obsolescent Features,Compatibility and Porting Guide,Security Hardening Features,Top\n @anchor{gnat_rm/obsolescent_features doc}@anchor{447}@anchor{gnat_rm/obsolescent_features id1}@anchor{448}@anchor{gnat_rm/obsolescent_features obsolescent-features}@anchor{16}\n @chapter Obsolescent Features"}]}