{"sha": "aa1806136c169334a389a8ed9d69fff1521ad42b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWExODA2MTM2YzE2OTMzNGEzODlhOGVkOWQ2OWZmZjE1MjFhZDQyYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:44:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:44:22Z"}, "message": "sem_res.adb (Resolve_Unary_Op): Add warning for use of unary minus with multiplying operator.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n        * sem_res.adb (Resolve_Unary_Op): Add warning for use of unary minus\n\twith multiplying operator.\n\t(Expected_Type_Is_Any_Real): New function to determine from the Parent\n\tpointer whether the context expects \"any real type\".\n\t(Resolve_Arithmetic_Op): Do not give an error on calls to the\n\tuniversal_fixed \"*\" and \"/\" operators when they are used in a context\n\tthat expects any real type. Also set the type of the node to\n\tUniversal_Real in this case, because downstream processing requires it\n\t(mainly static expression evaluation).\n\tReword some continuation messages\n\tAdd some \\\\ sequences to continuation messages\n\t(Resolve_Call): Refine infinite recursion case. The test has been\n\tsharpened to eliminate some false positives.\n\tCheck for Current_Task usage now includes entry barrier, and is now a\n\twarning, not an error.\n\t(Resolve): If the call is ambiguous, indicate whether an interpretation\n\tis an inherited operation.\n\t(Check_Aggr): When resolving aggregates, skip associations with a box,\n\twhich are priori correct, and will be replaced by an actual default\n\texpression in the course of expansion.\n\t(Resolve_Type_Conversion): Add missing support for conversion from\n\ta class-wide interface to a tagged type. Minor code cleanup.\n\t(Valid_Tagged_Converion): Add support for abstact interface type\n\tconversions.\n\t(Resolve_Selected_Component): Call Generate_Reference here rather than\n\tduring analysis, and use May_Be_Lvalue to distinguish read/write.\n\t(Valid_Array_Conversion): New procedure, abstracted from\n\tValid_Conversion, to incorporate accessibility checks for arrays of\n\tanonymous access types.\n\t(Valid_Conversion): For a conversion to a numeric type occurring in an\n\tinstance or inlined body, no need to check that the operand type is\n\tnumeric, since this has been checked during analysis of the template.\n\tRemove legacy test for scope name Unchecked_Conversion.\n\n\t* sem_res.ads: Minor reformatting\n\n\t* a-except.adb, a-except-2005.adb: Turn off subprogram ordering\n\t(PE_Current_Task_In_Entry_Body): New exception code\n\t(SE_Restriction_Violation): Removed, not used\n\n\t* a-except.ads:  Update comments.\n\n\t* types.h, types.ads: Add definition for Validity_Check\n\t(PE_Current_Task_In_Entry_Body): New exception code\n\t(SE_Restriction_Violation): Removed, not used\n\nFrom-SVN: r118232", "tree": {"sha": "9bb90d4b54264e437fe69288bbb2c3b9070ecbaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb90d4b54264e437fe69288bbb2c3b9070ecbaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa1806136c169334a389a8ed9d69fff1521ad42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa1806136c169334a389a8ed9d69fff1521ad42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa1806136c169334a389a8ed9d69fff1521ad42b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa1806136c169334a389a8ed9d69fff1521ad42b/comments", "author": null, "committer": null, "parents": [{"sha": "524c02d73cada8610253a83558a02ebc5ba9ed25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/524c02d73cada8610253a83558a02ebc5ba9ed25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/524c02d73cada8610253a83558a02ebc5ba9ed25"}], "stats": {"total": 827, "additions": 563, "deletions": 264}, "files": [{"sha": "0c9bc6807f3923c0d9f8e0cfc425c5df1ad4f257", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=aa1806136c169334a389a8ed9d69fff1521ad42b", "patch": "@@ -41,6 +41,9 @@\n --  The base version of this unit Ada.Exceptions omits the Wide version of\n --  Exception_Name and is used to build the compiler and other basic tools.\n \n+pragma Style_Checks (All_Checks);\n+--  No subprogram ordering check, due to logical grouping\n+\n pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with System.Exception_Tables.\n@@ -555,23 +558,24 @@ package body Ada.Exceptions is\n    Rmsg_14 : constant String := \"access before elaboration\"        & NUL;\n    Rmsg_15 : constant String := \"accessibility check failed\"       & NUL;\n    Rmsg_16 : constant String := \"all guards closed\"                & NUL;\n-   Rmsg_17 : constant String := \"duplicated entry address\"         & NUL;\n-   Rmsg_18 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_19 : constant String := \"finalize/adjust raised exception\" & NUL;\n-   Rmsg_20 : constant String := \"implicit return with No_Return\"   & NUL;\n-   Rmsg_21 : constant String := \"misaligned address value\"         & NUL;\n-   Rmsg_22 : constant String := \"missing return\"                   & NUL;\n-   Rmsg_23 : constant String := \"overlaid controlled object\"       & NUL;\n-   Rmsg_24 : constant String := \"potentially blocking operation\"   & NUL;\n-   Rmsg_25 : constant String := \"stubbed subprogram called\"        & NUL;\n-   Rmsg_26 : constant String := \"unchecked union restriction\"      & NUL;\n-   Rmsg_27 : constant String := \"illegal use of remote access-to-\" &\n+   Rmsg_17 : constant String := \"Current_Task referenced in entry\" &\n+                                \" body\"                            & NUL;\n+   Rmsg_18 : constant String := \"duplicated entry address\"         & NUL;\n+   Rmsg_19 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_20 : constant String := \"finalize/adjust raised exception\" & NUL;\n+   Rmsg_21 : constant String := \"implicit return with No_Return\"   & NUL;\n+   Rmsg_22 : constant String := \"misaligned address value\"         & NUL;\n+   Rmsg_23 : constant String := \"missing return\"                   & NUL;\n+   Rmsg_24 : constant String := \"overlaid controlled object\"       & NUL;\n+   Rmsg_25 : constant String := \"potentially blocking operation\"   & NUL;\n+   Rmsg_26 : constant String := \"stubbed subprogram called\"        & NUL;\n+   Rmsg_27 : constant String := \"unchecked union restriction\"      & NUL;\n+   Rmsg_28 : constant String := \"illegal use of remote access-to-\" &\n                                 \"class-wide type, see RM E.4(18)\"  & NUL;\n-   Rmsg_28 : constant String := \"empty storage pool\"               & NUL;\n-   Rmsg_29 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_30 : constant String := \"infinite recursion\"               & NUL;\n-   Rmsg_31 : constant String := \"object too large\"                 & NUL;\n-   Rmsg_32 : constant String := \"restriction violation\"            & NUL;\n+   Rmsg_29 : constant String := \"empty storage pool\"               & NUL;\n+   Rmsg_30 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_31 : constant String := \"infinite recursion\"               & NUL;\n+   Rmsg_32 : constant String := \"object too large\"                 & NUL;\n \n    -----------------------\n    -- Polling Interface --\n@@ -1106,7 +1110,7 @@ package body Ada.Exceptions is\n \n    procedure Rcheck_28 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_28'Address);\n+      Raise_Program_Error_Msg (File, Line, Rmsg_28'Address);\n    end Rcheck_28;\n \n    procedure Rcheck_29 (File : System.Address; Line : Integer) is"}, {"sha": "44c7640a1ee87181a4398b470d9f5f8b1c66fc77", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=aa1806136c169334a389a8ed9d69fff1521ad42b", "patch": "@@ -31,15 +31,20 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This version of Ada.Exceptions is a full Ada 95 version, but lacks the\n---  additional definitions of Exception_Name returning Wide_[Wide_]String.\n+--  This version of Ada.Exceptions is a full Ada 95 version, and Ada 2005\n+--  features such as the additional definitions of Exception_Name returning\n+--  Wide_[Wide_]String.\n+\n --  It is used for building the compiler and the basic tools, since these\n --  builds may be done with bootstrap compilers that cannot handle these\n --  additions. The full version of Ada.Exceptions can be found in the files\n --  a-except-2005.ads/adb, and is used for all other builds where full Ada\n --  2005 functionality is required. in particular, it is used for building\n --  run times on all targets.\n \n+pragma Style_Checks (All_Checks);\n+--  No subprogram ordering check, due to logical grouping\n+\n pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with System.Exception_Tables.\n@@ -206,7 +211,7 @@ package body Ada.Exceptions is\n         (Excep    : EOA;\n          Current  : EOA;\n          Reraised : Boolean := False);\n-      --  Dummy routine used to share a-exexda.adb, do nothing.\n+      --  Dummy routine used to share a-exexda.adb, do nothing\n \n    end Exception_Propagation;\n \n@@ -504,23 +509,24 @@ package body Ada.Exceptions is\n    Rmsg_14 : constant String := \"access before elaboration\"        & NUL;\n    Rmsg_15 : constant String := \"accessibility check failed\"       & NUL;\n    Rmsg_16 : constant String := \"all guards closed\"                & NUL;\n-   Rmsg_17 : constant String := \"duplicated entry address\"         & NUL;\n-   Rmsg_18 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_19 : constant String := \"finalize/adjust raised exception\" & NUL;\n-   Rmsg_20 : constant String := \"implicit return with No_Return\"   & NUL;\n-   Rmsg_21 : constant String := \"misaligned address value\"         & NUL;\n-   Rmsg_22 : constant String := \"missing return\"                   & NUL;\n-   Rmsg_23 : constant String := \"overlaid controlled object\"       & NUL;\n-   Rmsg_24 : constant String := \"potentially blocking operation\"   & NUL;\n-   Rmsg_25 : constant String := \"stubbed subprogram called\"        & NUL;\n-   Rmsg_26 : constant String := \"unchecked union restriction\"      & NUL;\n-   Rmsg_27 : constant String := \"illegal use of remote access-to-\" &\n+   Rmsg_17 : constant String := \"Current_Task referenced in entry\" &\n+                                \" body\"                            & NUL;\n+   Rmsg_18 : constant String := \"duplicated entry address\"         & NUL;\n+   Rmsg_19 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_20 : constant String := \"finalize/adjust raised exception\" & NUL;\n+   Rmsg_21 : constant String := \"implicit return with No_Return\"   & NUL;\n+   Rmsg_22 : constant String := \"misaligned address value\"         & NUL;\n+   Rmsg_23 : constant String := \"missing return\"                   & NUL;\n+   Rmsg_24 : constant String := \"overlaid controlled object\"       & NUL;\n+   Rmsg_25 : constant String := \"potentially blocking operation\"   & NUL;\n+   Rmsg_26 : constant String := \"stubbed subprogram called\"        & NUL;\n+   Rmsg_27 : constant String := \"unchecked union restriction\"      & NUL;\n+   Rmsg_28 : constant String := \"illegal use of remote access-to-\" &\n                                 \"class-wide type, see RM E.4(18)\"  & NUL;\n-   Rmsg_28 : constant String := \"empty storage pool\"               & NUL;\n-   Rmsg_29 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_30 : constant String := \"infinite recursion\"               & NUL;\n-   Rmsg_31 : constant String := \"object too large\"                 & NUL;\n-   Rmsg_32 : constant String := \"restriction violation\"            & NUL;\n+   Rmsg_29 : constant String := \"empty storage pool\"               & NUL;\n+   Rmsg_30 : constant String := \"explicit raise\"                   & NUL;\n+   Rmsg_31 : constant String := \"infinite recursion\"               & NUL;\n+   Rmsg_32 : constant String := \"object too large\"                 & NUL;\n \n    -----------------------\n    -- Polling Interface --\n@@ -802,11 +808,7 @@ package body Ada.Exceptions is\n          Raise_Current_Excep (E);\n       end if;\n \n-      --  Note: if E is null, then we simply return, which is correct Ada 95\n-      --  semantics. If we are operating in Ada 2005 mode, then the expander\n-      --  generates a raise Constraint_Error immediately following the call\n-      --  to provide the required Ada 2005 semantics (see AI-329). We do it\n-      --  this way to avoid having run time dependencies on the Ada version.\n+      --  Note: if E is null then just return (Ada 95 semantics)\n \n       return;\n    end Raise_Exception;\n@@ -1072,7 +1074,7 @@ package body Ada.Exceptions is\n \n    procedure Rcheck_28 (File : System.Address; Line : Integer) is\n    begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_28'Address);\n+      Raise_Program_Error_Msg (File, Line, Rmsg_28'Address);\n    end Rcheck_28;\n \n    procedure Rcheck_29 (File : System.Address; Line : Integer) is"}, {"sha": "2dae518140ed56bd7772058ebeffff17b12d584e", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=aa1806136c169334a389a8ed9d69fff1521ad42b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -35,8 +35,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This version of Ada.Exceptions is a full Ada 95 version, but lacks the\n---  additional definitions of Exception_Name returning Wide_[Wide_]String.\n+--  This version of Ada.Exceptions is a full Ada 95 version.\n --  It is used for building the compiler and the basic tools, since these\n --  builds may be done with bootstrap compilers that cannot handle these\n --  additions. The full version of Ada.Exceptions can be found in the files\n@@ -57,14 +56,17 @@ package Ada.Exceptions is\n    pragma Warnings (Off);\n    pragma Preelaborate_05;\n    pragma Warnings (On);\n-   --  In accordance with Ada 2005 AI-362. The warnings pragmas are so that we\n-   --  can compile this using older compiler versions, which will ignore the\n-   --  pragma, which is fine for the bootstrap.\n+   --  We make this preelaborable in Ada 2005 mode. If we did not do this, then\n+   --  run time units used by the compiler (e.g. s-soflin.ads) would run\n+   --  into trouble. Conformance is not an issue, since this version is used\n+   --  only by the compiler.\n \n    type Exception_Id is private;\n+\n    Null_Id : constant Exception_Id;\n \n    type Exception_Occurrence is limited private;\n+\n    type Exception_Occurrence_Access is access all Exception_Occurrence;\n \n    Null_Occurrence : constant Exception_Occurrence;\n@@ -76,11 +78,11 @@ package Ada.Exceptions is\n \n    procedure Raise_Exception (E : Exception_Id; Message : String := \"\");\n    --  Note: it would be really nice to give a pragma No_Return for this\n-   --  procedure, but it would be wrong, since Raise_Exception does return\n-   --  if given the null exception. However we do special case the name in\n-   --  the test in the compiler for issuing a warning for a missing return\n-   --  after this call. Program_Error seems reasonable enough in such a case.\n-   --  See also the routine Raise_Exception_Always in the private part.\n+   --  procedure, but it would be wrong, since Raise_Exception does return if\n+   --  given the null exception in Ada 95 mode. However we do special case the\n+   --  name in the test in the compiler for issuing a warning for a missing\n+   --  return after this call. Program_Error seems reasonable enough in such a\n+   --  case. See also the routine Raise_Exception_Always in the private part.\n \n    function Exception_Message (X : Exception_Occurrence) return String;\n "}, {"sha": "ee263fe4ce6d5cc7d399e683149dc3ca2d321453", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 455, "deletions": 166, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=aa1806136c169334a389a8ed9d69fff1521ad42b", "patch": "@@ -241,11 +241,11 @@ package body Sem_Res is\n       if Nkind (C) = N_Character_Literal then\n          Error_Msg_N (\"ambiguous character literal\", C);\n          Error_Msg_N\n-           (\"\\possible interpretations: Character, Wide_Character!\", C);\n+           (\"\\\\possible interpretations: Character, Wide_Character!\", C);\n \n          E := Current_Entity (C);\n          while Present (E) loop\n-            Error_Msg_NE (\"\\possible interpretation:}!\", C, Etype (E));\n+            Error_Msg_NE (\"\\\\possible interpretation:}!\", C, Etype (E));\n             E := Homonym (E);\n          end loop;\n       end if;\n@@ -1823,12 +1823,20 @@ package body Sem_Res is\n                      --  message only at the start of an ambiguous set.\n \n                      if not Ambiguous then\n-                        Error_Msg_NE\n-                          (\"ambiguous expression (cannot resolve&)!\",\n-                           N, It.Nam);\n+                        if Nkind (N) = N_Function_Call\n+                          and then Nkind (Name (N)) = N_Explicit_Dereference\n+                        then\n+                           Error_Msg_N\n+                             (\"ambiguous expression \"\n+                               & \"(cannot resolve indirect call)!\", N);\n+                        else\n+                           Error_Msg_NE\n+                             (\"ambiguous expression (cannot resolve&)!\",\n+                              N, It.Nam);\n+                        end if;\n \n                         Error_Msg_N\n-                          (\"possible interpretation#!\", N);\n+                          (\"\\\\possible interpretation#!\", N);\n                         Ambiguous := True;\n                      end if;\n \n@@ -1857,7 +1865,7 @@ package body Sem_Res is\n                      elsif Nkind (N) in N_Binary_Op\n                        and then Scope (It.Nam) = Standard_Standard\n                        and then not Is_Overloaded (Left_Opnd (N))\n-                       and then  Scope (Base_Type (Etype (Left_Opnd (N))))\n+                       and then Scope (Base_Type (Etype (Left_Opnd (N))))\n                             /= Standard_Standard\n                      then\n                         Err_Type := First_Subtype (Etype (Left_Opnd (N)));\n@@ -1867,6 +1875,20 @@ package body Sem_Res is\n                         then\n                            Error_Msg_Sloc := Sloc (Parent (Err_Type));\n                         end if;\n+\n+                     --  If this is an indirect call, use the subprogram_type\n+                     --  in the message, to have a meaningful location.\n+                     --  Indicate as well if this is an inherited operation,\n+                     --  created by a type declaration.\n+\n+                     elsif Nkind (N) = N_Function_Call\n+                       and then Nkind (Name (N)) = N_Explicit_Dereference\n+                       and then Is_Type (It.Nam)\n+                     then\n+                        Err_Type := It.Nam;\n+                        Error_Msg_Sloc :=\n+                          Sloc (Associated_Node_For_Itype (Err_Type));\n+\n                      else\n                         Err_Type := Empty;\n                      end if;\n@@ -1876,9 +1898,15 @@ package body Sem_Res is\n                        and then Present (Err_Type)\n                      then\n                         Error_Msg_N\n-                          (\"possible interpretation (predefined)#!\", N);\n+                          (\"\\\\possible interpretation (predefined)#!\", N);\n+\n+                     elsif\n+                       Nkind (Parent (It.Nam)) = N_Full_Type_Declaration\n+                     then\n+                        Error_Msg_N\n+                          (\"\\\\possible interpretation (inherited)#!\", N);\n                      else\n-                        Error_Msg_N (\"possible interpretation#!\", N);\n+                        Error_Msg_N (\"\\\\possible interpretation#!\", N);\n                      end if;\n \n                   end if;\n@@ -2012,16 +2040,14 @@ package body Sem_Res is\n                Set_Etype (N, Typ);\n                return;\n \n-            --  Check for an aggregate. Sometimes we can get bogus\n-            --  aggregates from misuse of parentheses, and we are\n-            --  about to complain about the aggregate without even\n-            --  looking inside it.\n+            --  Check for an aggregate. Sometimes we can get bogus aggregates\n+            --  from misuse of parentheses, and we are about to complain about\n+            --  the aggregate without even looking inside it.\n \n-            --  Instead, if we have an aggregate of type Any_Composite,\n-            --  then analyze and resolve the component fields, and then\n-            --  only issue another message if we get no errors doing\n-            --  this (otherwise assume that the errors in the aggregate\n-            --  caused the problem).\n+            --  Instead, if we have an aggregate of type Any_Composite, then\n+            --  analyze and resolve the component fields, and then only issue\n+            --  another message if we get no errors doing this (otherwise\n+            --  assume that the errors in the aggregate caused the problem).\n \n             elsif Nkind (N) = N_Aggregate\n               and then Etype (N) = Any_Composite\n@@ -2034,12 +2060,16 @@ package body Sem_Res is\n \n                declare\n                   procedure Check_Aggr (Aggr : Node_Id);\n-                  --  Check one aggregate, and set Found to True if we\n-                  --  have a definite error in any of its elements\n+                  --  Check one aggregate, and set Found to True if we have a\n+                  --  definite error in any of its elements\n \n                   procedure Check_Elmt (Aelmt : Node_Id);\n-                  --  Check one element of aggregate and set Found to\n-                  --  True if we definitely have an error in the element.\n+                  --  Check one element of aggregate and set Found to True if\n+                  --  we definitely have an error in the element.\n+\n+                  ----------------\n+                  -- Check_Aggr --\n+                  ----------------\n \n                   procedure Check_Aggr (Aggr : Node_Id) is\n                      Elmt : Node_Id;\n@@ -2056,7 +2086,16 @@ package body Sem_Res is\n                      if Present (Component_Associations (Aggr)) then\n                         Elmt := First (Component_Associations (Aggr));\n                         while Present (Elmt) loop\n-                           Check_Elmt (Expression (Elmt));\n+\n+                           --  Nothing to check is this is a default-\n+                           --  initialized component. The box will be\n+                           --  be replaced by the appropriate call during\n+                           --  late expansion.\n+\n+                           if not Box_Present (Elmt) then\n+                              Check_Elmt (Expression (Elmt));\n+                           end if;\n+\n                            Next (Elmt);\n                         end loop;\n                      end if;\n@@ -2131,7 +2170,7 @@ package body Sem_Res is\n                         It    : Interp;\n \n                      begin\n-                        Error_Msg_N (\"\\possible interpretations:\", N);\n+                        Error_Msg_N (\"\\\\possible interpretations:\", N);\n \n                         Get_First_Interp (Name (N), Index, It);\n                         while Present (It.Nam) loop\n@@ -2254,7 +2293,7 @@ package body Sem_Res is\n             when N_Identifier\n                              => Resolve_Entity_Name              (N, Ctx_Type);\n \n-            when N_In | N_Not_In\n+            when N_Membership_Test\n                              => Resolve_Membership_Op            (N, Ctx_Type);\n \n             when N_Indexed_Component\n@@ -3167,7 +3206,12 @@ package body Sem_Res is\n                     Make_Raise_Program_Error (Sloc (N),\n                       Reason => PE_Accessibility_Check_Failed));\n                   Set_Etype (N, Typ);\n-               else\n+\n+               --  Do not apply Ada 2005 accessibility checks on a class-wide\n+               --  allocator if the type given in the allocator is a formal\n+               --  type. A run-time check will be performed in the instance.\n+\n+               elsif not Is_Generic_Type (Exp_Typ) then\n                   Error_Msg_N (\"type in allocator has deeper level than\" &\n                                \" designated class-wide type\", E);\n                end if;\n@@ -3219,6 +3263,9 @@ package body Sem_Res is\n       --  We do the resolution using the base type, because intermediate values\n       --  in expressions always are of the base type, not a subtype of it.\n \n+      function Expected_Type_Is_Any_Real (N : Node_Id) return Boolean;\n+      --  Returns True if N is in a context that expects \"any real type\"\n+\n       function Is_Integer_Or_Universal (N : Node_Id) return Boolean;\n       --  Return True iff given type is Integer or universal real/integer\n \n@@ -3230,6 +3277,29 @@ package body Sem_Res is\n       procedure Set_Operand_Type (N : Node_Id);\n       --  Set operand type to T if universal\n \n+      -------------------------------\n+      -- Expected_Type_Is_Any_Real --\n+      -------------------------------\n+\n+      function Expected_Type_Is_Any_Real (N : Node_Id) return Boolean is\n+      begin\n+         --  N is the expression after \"delta\" in a fixed_point_definition;\n+         --  see RM-3.5.9(6):\n+\n+         return    Nkind (Parent (N)) = N_Ordinary_Fixed_Point_Definition\n+           or else Nkind (Parent (N)) = N_Decimal_Fixed_Point_Definition\n+\n+         --  N is one of the bounds in a real_range_specification;\n+         --  see RM-3.5.7(5):\n+\n+           or else Nkind (Parent (N)) = N_Real_Range_Specification\n+\n+         --  N is the expression of a delta_constraint;\n+         --  see RM-J.3(3):\n+\n+           or else Nkind (Parent (N)) = N_Delta_Constraint;\n+      end Expected_Type_Is_Any_Real;\n+\n       -----------------------------\n       -- Is_Integer_Or_Universal --\n       -----------------------------\n@@ -3467,10 +3537,17 @@ package body Sem_Res is\n             Set_Mixed_Mode_Operand (R, TL);\n          end if;\n \n+         --  Check the rule in RM05-4.5.5(19.1/2) disallowing the\n+         --  universal_fixed multiplying operators from being used when the\n+         --  expected type is also universal_fixed. Note that B_Typ will be\n+         --  Universal_Fixed in some cases where the expected type is actually\n+         --  Any_Real; Expected_Type_Is_Any_Real takes care of that case.\n+\n          if Etype (N) = Universal_Fixed\n            or else Etype (N) = Any_Fixed\n          then\n             if B_Typ = Universal_Fixed\n+              and then not Expected_Type_Is_Any_Real (N)\n               and then Nkind (Parent (N)) /= N_Type_Conversion\n               and then Nkind (Parent (N)) /= N_Unchecked_Type_Conversion\n             then\n@@ -3494,7 +3571,16 @@ package body Sem_Res is\n                      N);\n                end if;\n \n-               Set_Etype (N, B_Typ);\n+               --  The expected type is \"any real type\" in contexts like\n+               --    type T is delta <universal_fixed-expression> ...\n+               --  in which case we need to set the type to Universal_Real\n+               --  so that static expression evaluation will work properly.\n+\n+               if Expected_Type_Is_Any_Real (N) then\n+                  Set_Etype (N, Universal_Real);\n+               else\n+                  Set_Etype (N, B_Typ);\n+               end if;\n             end if;\n \n          elsif Is_Fixed_Point_Type (B_Typ)\n@@ -3582,9 +3668,30 @@ package body Sem_Res is\n                         (Is_Real_Type (Etype (Rop))\n                                 and then Expr_Value_R (Rop) = Ureal_0))\n             then\n-               Apply_Compile_Time_Constraint_Error\n-                 (N, \"division by zero?\", CE_Divide_By_Zero,\n-                  Loc => Sloc (Right_Opnd (N)));\n+               --  Specialize the warning message according to the operation\n+\n+               case Nkind (N) is\n+                  when N_Op_Divide =>\n+                     Apply_Compile_Time_Constraint_Error\n+                       (N, \"division by zero?\", CE_Divide_By_Zero,\n+                        Loc => Sloc (Right_Opnd (N)));\n+\n+                  when N_Op_Rem =>\n+                     Apply_Compile_Time_Constraint_Error\n+                       (N, \"rem with zero divisor?\", CE_Divide_By_Zero,\n+                        Loc => Sloc (Right_Opnd (N)));\n+\n+                  when N_Op_Mod =>\n+                     Apply_Compile_Time_Constraint_Error\n+                       (N, \"mod with zero divisor?\", CE_Divide_By_Zero,\n+                        Loc => Sloc (Right_Opnd (N)));\n+\n+                  --  Division by zero can only happen with division, rem,\n+                  --  and mod operations.\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n \n             --  Otherwise just set the flag to check at run time\n \n@@ -3610,6 +3717,7 @@ package body Sem_Res is\n       It      : Interp;\n       Norm_OK : Boolean;\n       Scop    : Entity_Id;\n+      Rtype   : Entity_Id;\n \n    begin\n       --  The context imposes a unique interpretation with type Typ on a\n@@ -3656,7 +3764,7 @@ package body Sem_Res is\n          --  For an indirect call, we always invalidate checks, since we do not\n          --  know whether the subprogram is local or global. Yes we could do\n          --  better here, e.g. by knowing that there are no local subprograms,\n-         --  but it does not seem worth the effort. Similarly, we kill al\n+         --  but it does not seem worth the effort. Similarly, we kill all\n          --  knowledge of current constant values.\n \n          Kill_Current_Values;\n@@ -3718,10 +3826,20 @@ package body Sem_Res is\n                P := Parent (P);\n                exit when No (P);\n \n-               if Nkind (P) = N_Entry_Body then\n+               if Nkind (P) = N_Entry_Body\n+                 or else (Nkind (P) = N_Subprogram_Body\n+                            and then Is_Entry_Barrier_Function (P))\n+               then\n+                  Rtype := Etype (N);\n                   Error_Msg_NE\n-                    (\"& should not be used in entry body ('R'M C.7(17))\",\n+                    (\"& should not be used in entry body ('R'M C.7(17))?\",\n                      N, Nam);\n+                  Error_Msg_NE\n+                    (\"\\Program_Error will be raised at run time?\", N, Nam);\n+                  Rewrite (N,\n+                    Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Current_Task_In_Entry_Body));\n+                  Set_Etype (N, Rtype);\n                   exit;\n                end if;\n             end loop;\n@@ -3734,25 +3852,6 @@ package body Sem_Res is\n          Error_Msg_N (\"cannot call thread body directly\", N);\n       end if;\n \n-      --  If the subprogram is not global, then kill all checks. This is a bit\n-      --  conservative, since in many cases we could do better, but it is not\n-      --  worth the effort. Similarly, we kill constant values. However we do\n-      --  not need to do this for internal entities (unless they are inherited\n-      --  user-defined subprograms), since they are not in the business of\n-      --  molesting global values.\n-\n-      if not Is_Library_Level_Entity (Nam)\n-        and then (Comes_From_Source (Nam)\n-                   or else (Present (Alias (Nam))\n-                             and then Comes_From_Source (Alias (Nam))))\n-      then\n-         Kill_Current_Values;\n-      end if;\n-\n-      --  Check for call to subprogram marked Is_Obsolescent\n-\n-      Check_Obsolescent (Nam, N);\n-\n       --  Check that a procedure call does not occur in the context of the\n       --  entry call statement of a conditional or timed entry call. Note that\n       --  the case of a call to a subprogram renaming of an entry will also be\n@@ -3914,15 +4013,16 @@ package body Sem_Res is\n       --  the case of a possible run-time detectable infinite recursion.\n \n       else\n-         while Scop /= Standard_Standard loop\n+         Scope_Loop : while Scop /= Standard_Standard loop\n             if Nam = Scop then\n+\n                --  Although in general recursion is not statically checkable,\n                --  the case of calling an immediately containing subprogram\n                --  is easy to catch.\n \n                Check_Restriction (No_Recursion, N);\n \n-               --  If the recursive call is to a parameterless procedure, then\n+               --  If the recursive call is to a parameterless subprogram, then\n                --  even if we can't statically detect infinite recursion, this\n                --  is pretty suspicious, and we output a warning. Furthermore,\n                --  we will try later to detect some cases here at run time by\n@@ -3938,16 +4038,58 @@ package body Sem_Res is\n                  and then not Error_Posted (N)\n                  and then Nkind (Parent (N)) /= N_Exception_Handler\n                then\n+                  --  For the case of a procedure call. We give the message\n+                  --  only if the call is the first statement in a sequence of\n+                  --  statements, or if all previous statements are simple\n+                  --  assignments. This is simply a heuristic to decrease false\n+                  --  positives, without losing too many good warnings. The\n+                  --  idea is that these previous statements may affect global\n+                  --  variables the procedure depends on.\n+\n+                  if Nkind (N) = N_Procedure_Call_Statement\n+                    and then Is_List_Member (N)\n+                  then\n+                     declare\n+                        P : Node_Id;\n+                     begin\n+                        P := Prev (N);\n+                        while Present (P) loop\n+                           if Nkind (P) /= N_Assignment_Statement then\n+                              exit Scope_Loop;\n+                           end if;\n+\n+                           Prev (P);\n+                        end loop;\n+                     end;\n+                  end if;\n+\n+                  --  Do not give warning if we are in a conditional context\n+\n+                  declare\n+                     K : constant Node_Kind := Nkind (Parent (N));\n+                  begin\n+                     if (K = N_Loop_Statement\n+                          and then Present (Iteration_Scheme (Parent (N))))\n+                       or else K = N_If_Statement\n+                       or else K = N_Elsif_Part\n+                       or else K = N_Case_Statement_Alternative\n+                     then\n+                        exit Scope_Loop;\n+                     end if;\n+                  end;\n+\n+                  --  Here warning is to be issued\n+\n                   Set_Has_Recursive_Call (Nam);\n                   Error_Msg_N (\"possible infinite recursion?\", N);\n                   Error_Msg_N (\"\\Storage_Error may be raised at run time?\", N);\n                end if;\n \n-               exit;\n+               exit Scope_Loop;\n             end if;\n \n             Scop := Scope (Scop);\n-         end loop;\n+         end loop Scope_Loop;\n       end if;\n \n       --  If subprogram name is a predefined operator, it was given in\n@@ -4044,6 +4186,25 @@ package body Sem_Res is\n          return;\n       end if;\n \n+      --  If the subprogram is not global, then kill all checks. This is a bit\n+      --  conservative, since in many cases we could do better, but it is not\n+      --  worth the effort. Similarly, we kill constant values. However we do\n+      --  not need to do this for internal entities (unless they are inherited\n+      --  user-defined subprograms), since they are not in the business of\n+      --  molesting global values.\n+\n+      --  Note: we do not do this step till after resolving the actuals. That\n+      --  way we still take advantage of the current value information while\n+      --  scanning the actuals.\n+\n+      if not Is_Library_Level_Entity (Nam)\n+        and then (Comes_From_Source (Nam)\n+                   or else (Present (Alias (Nam))\n+                             and then Comes_From_Source (Alias (Nam))))\n+      then\n+         Kill_Current_Values;\n+      end if;\n+\n       --  If the subprogram is a primitive operation, check whether or not\n       --  it is a correct dispatching call.\n \n@@ -5180,6 +5341,7 @@ package body Sem_Res is\n          end loop;\n       end if;\n \n+      Warn_On_Suspicious_Index (Name, First (Expressions (N)));\n       Eval_Indexed_Component (N);\n    end Resolve_Indexed_Component;\n \n@@ -5557,14 +5719,14 @@ package body Sem_Res is\n                         Error_Msg_Sloc := Sloc (Func);\n                         Error_Msg_N (\"\\ambiguous call to function#\", Arg);\n                         Error_Msg_NE\n-                          (\"\\interpretation as call yields&\", Arg, Typ);\n+                          (\"\\\\interpretation as call yields&\", Arg, Typ);\n                         Error_Msg_NE\n-                          (\"\\interpretation as indexing of call yields&\",\n+                          (\"\\\\interpretation as indexing of call yields&\",\n                             Arg, Component_Type (Typ));\n \n                      else\n-                        Error_Msg_N (\"ambiguous operand for concatenation!\",\n-                          Arg);\n+                        Error_Msg_N\n+                          (\"ambiguous operand for concatenation!\", Arg);\n                         Get_First_Interp (Arg, I, It);\n                         while Present (It.Nam) loop\n                            Error_Msg_Sloc := Sloc (It.Nam);\n@@ -5573,7 +5735,7 @@ package body Sem_Res is\n                              or else Base_Type (It.Typ) =\n                                Base_Type (Component_Type (Typ))\n                            then\n-                              Error_Msg_N (\"\\possible interpretation#\", Arg);\n+                              Error_Msg_N (\"\\\\possible interpretation#\", Arg);\n                            end if;\n \n                            Get_Next_Interp (I, It);\n@@ -5723,6 +5885,10 @@ package body Sem_Res is\n       --  and the not in question is the left operand of this operation.\n       --  Note that if the not is in parens, then false is returned.\n \n+      -----------------------\n+      -- Parent_Is_Boolean --\n+      -----------------------\n+\n       function Parent_Is_Boolean return Boolean is\n       begin\n          if Paren_Count (N) /= 0 then\n@@ -5742,7 +5908,7 @@ package body Sem_Res is\n                     N_In       |\n                     N_Not_In   |\n                     N_And_Then |\n-                    N_Or_Else =>\n+                    N_Or_Else  =>\n \n                   return Left_Opnd (Parent (N)) = N;\n \n@@ -5765,11 +5931,15 @@ package body Sem_Res is\n          B_Typ := Base_Type (Typ);\n       end if;\n \n+      --  Straigtforward case of incorrect arguments\n+\n       if not Valid_Boolean_Arg (Typ) then\n          Error_Msg_N (\"invalid operand type for operator&\", N);\n          Set_Etype (N, Any_Type);\n          return;\n \n+      --  Special case of probable missing parens\n+\n       elsif Typ = Universal_Integer or else Typ = Any_Modular then\n          if Parent_Is_Boolean then\n             Error_Msg_N\n@@ -5783,8 +5953,15 @@ package body Sem_Res is\n          Set_Etype (N, Any_Type);\n          return;\n \n+      --  OK resolution of not\n+\n       else\n-         if not Is_Boolean_Type (Typ)\n+         --  Warn if non-boolean types involved. This is a case like not a < b\n+         --  where a and b are modular, where we will get (not a) < b and most\n+         --  likely not (a < b) was intended.\n+\n+         if Warn_On_Questionable_Missing_Parens\n+           and then not Is_Boolean_Type (Typ)\n            and then Parent_Is_Boolean\n          then\n             Error_Msg_N (\"?not expression should be parenthesized here\", N);\n@@ -6111,14 +6288,24 @@ package body Sem_Res is\n \n          Resolve (P, It1.Typ);\n          Set_Etype (N, Typ);\n-         Set_Entity (S, Comp1);\n+         Set_Entity_With_Style_Check (S, Comp1);\n \n       else\n          --  Resolve prefix with its type\n \n          Resolve (P, T);\n       end if;\n \n+      --  Generate cross-reference. We needed to wait until full overloading\n+      --  resolution was complete to do this, since otherwise we can't tell if\n+      --  we are an Lvalue of not.\n+\n+      if May_Be_Lvalue (N) then\n+         Generate_Reference (Entity (S), S, 'm');\n+      else\n+         Generate_Reference (Entity (S), S, 'r');\n+      end if;\n+\n       --  If prefix is an access type, the node will be transformed into an\n       --  explicit dereference during expansion. The type of the node is the\n       --  designated type of that of the prefix.\n@@ -6317,6 +6504,12 @@ package body Sem_Res is\n       end if;\n \n       Set_Slice_Subtype (N);\n+\n+      if Nkind (Drange) = N_Range then\n+         Warn_On_Suspicious_Index (Name, Low_Bound  (Drange));\n+         Warn_On_Suspicious_Index (Name, High_Bound (Drange));\n+      end if;\n+\n       Eval_Slice (N);\n    end Resolve_Slice;\n \n@@ -6654,9 +6847,12 @@ package body Sem_Res is\n               and then Realval (Rop) /= Ureal_0\n               and then abs (Realval (Rop)) < Delta_Value (Standard_Duration)\n             then\n-               Error_Msg_N (\"universal real operand can only be interpreted?\",\n-                 Rop);\n-               Error_Msg_N (\"\\as Duration, and will lose precision?\", Rop);\n+               Error_Msg_N\n+                 (\"universal real operand can only \" &\n+                  \"be interpreted as Duration?\",\n+                  Rop);\n+               Error_Msg_N\n+                 (\"\\precision will be lost in the conversion\", Rop);\n             end if;\n \n          elsif Is_Numeric_Type (Typ)\n@@ -6734,7 +6930,7 @@ package body Sem_Res is\n \n       --  Ada 2005 (AI-251): Handle conversions to abstract interface types\n \n-      if Ada_Version >= Ada_05 then\n+      if Ada_Version >= Ada_05 and then Expander_Active then\n          if Is_Access_Type (Target_Type) then\n             Target_Type := Directly_Designated_Type (Target_Type);\n          end if;\n@@ -6770,9 +6966,18 @@ package body Sem_Res is\n                --  conversion at run-time.\n \n                Expand_Interface_Conversion (N, Is_Static => False);\n+\n             else\n                Expand_Interface_Conversion (N);\n             end if;\n+\n+         --  Ada 2005 (AI-251): Conversion from a class-wide interface to a\n+         --  tagged type\n+\n+         elsif Is_Class_Wide_Type (Opnd_Type)\n+            and then Is_Interface (Opnd_Type)\n+         then\n+            Expand_Interface_Conversion (N, Is_Static => False);\n          end if;\n       end if;\n    end Resolve_Type_Conversion;\n@@ -6791,10 +6996,11 @@ package body Sem_Res is\n    begin\n       --  Generate warning for expressions like -5 mod 3\n \n-      if Paren_Count (N) = 0\n-        and then Nkind (N) = N_Op_Minus\n+      if Warn_On_Questionable_Missing_Parens\n+        and then Paren_Count (N) = 0\n+        and then (Nkind (N) = N_Op_Minus or else Nkind (N) = N_Op_Plus)\n         and then Paren_Count (Right_Opnd (N)) = 0\n-        and then Nkind (Right_Opnd (N)) = N_Op_Mod\n+        and then Nkind (Right_Opnd (N)) in N_Multiplying_Operator\n         and then Comes_From_Source (N)\n       then\n          Error_Msg_N\n@@ -7161,8 +7367,8 @@ package body Sem_Res is\n       procedure Fixed_Point_Error is\n       begin\n          Error_Msg_N (\"ambiguous universal_fixed_expression\", N);\n-         Error_Msg_NE (\"\\possible interpretation as}\", N, T1);\n-         Error_Msg_NE (\"\\possible interpretation as}\", N, T2);\n+         Error_Msg_NE (\"\\\\possible interpretation as}\", N, T1);\n+         Error_Msg_NE (\"\\\\possible interpretation as}\", N, T2);\n       end Fixed_Point_Error;\n \n    --  Start of processing for Unique_Fixed_Point_Type\n@@ -7257,6 +7463,10 @@ package body Sem_Res is\n          Opnd_Type   : Entity_Id) return Boolean;\n       --  Specifically test for validity of tagged conversions\n \n+      function Valid_Array_Conversion return Boolean;\n+      --  Check index and component conformance, and accessibility levels\n+      --  if the component types are anonymous access types (Ada 2005)\n+\n       ----------------------\n       -- Conversion_Check --\n       ----------------------\n@@ -7273,6 +7483,135 @@ package body Sem_Res is\n          return Valid;\n       end Conversion_Check;\n \n+      ----------------------------\n+      -- Valid_Array_Conversion --\n+      ----------------------------\n+\n+      function Valid_Array_Conversion return Boolean\n+      is\n+         Opnd_Comp_Type : constant Entity_Id := Component_Type (Opnd_Type);\n+         Opnd_Comp_Base : constant Entity_Id := Base_Type (Opnd_Comp_Type);\n+\n+         Opnd_Index      : Node_Id;\n+         Opnd_Index_Type : Entity_Id;\n+\n+         Target_Comp_Type : constant Entity_Id :=\n+                              Component_Type (Target_Type);\n+         Target_Comp_Base : constant Entity_Id :=\n+                              Base_Type (Target_Comp_Type);\n+\n+         Target_Index      : Node_Id;\n+         Target_Index_Type : Entity_Id;\n+\n+      begin\n+         --  Error if wrong number of dimensions\n+\n+         if\n+           Number_Dimensions (Target_Type) /= Number_Dimensions (Opnd_Type)\n+         then\n+            Error_Msg_N\n+              (\"incompatible number of dimensions for conversion\", Operand);\n+            return False;\n+\n+         --  Number of dimensions matches\n+\n+         else\n+            --  Loop through indexes of the two arrays\n+\n+            Target_Index := First_Index (Target_Type);\n+            Opnd_Index   := First_Index (Opnd_Type);\n+            while Present (Target_Index) and then Present (Opnd_Index) loop\n+               Target_Index_Type := Etype (Target_Index);\n+               Opnd_Index_Type   := Etype (Opnd_Index);\n+\n+               --  Error if index types are incompatible\n+\n+               if not (Is_Integer_Type (Target_Index_Type)\n+                       and then Is_Integer_Type (Opnd_Index_Type))\n+                 and then (Root_Type (Target_Index_Type)\n+                           /= Root_Type (Opnd_Index_Type))\n+               then\n+                  Error_Msg_N\n+                    (\"incompatible index types for array conversion\",\n+                     Operand);\n+                  return False;\n+               end if;\n+\n+               Next_Index (Target_Index);\n+               Next_Index (Opnd_Index);\n+            end loop;\n+\n+            --  If component types have same base type, all set\n+\n+            if Target_Comp_Base  = Opnd_Comp_Base then\n+               null;\n+\n+               --  Here if base types of components are not the same. The only\n+               --  time this is allowed is if we have anonymous access types.\n+\n+               --  The conversion of arrays of anonymous access types can lead\n+               --  to dangling pointers. AI-392 formalizes the accessibility\n+               --  checks that must be applied to such conversions to prevent\n+               --  out-of-scope references.\n+\n+            elsif\n+              (Ekind (Target_Comp_Base) = E_Anonymous_Access_Type\n+                 or else\n+               Ekind (Target_Comp_Base) = E_Anonymous_Access_Subprogram_Type)\n+              and then Ekind (Opnd_Comp_Base) = Ekind (Target_Comp_Base)\n+              and then\n+                Subtypes_Statically_Match (Target_Comp_Type, Opnd_Comp_Type)\n+            then\n+               if Type_Access_Level (Target_Type) <\n+                   Type_Access_Level (Opnd_Type)\n+               then\n+                  if In_Instance_Body then\n+                     Error_Msg_N (\"?source array type \" &\n+                       \"has deeper accessibility level than target\", Operand);\n+                     Error_Msg_N (\"\\?Program_Error will be raised at run time\",\n+                         Operand);\n+                     Rewrite (N,\n+                       Make_Raise_Program_Error (Sloc (N),\n+                         Reason => PE_Accessibility_Check_Failed));\n+                     Set_Etype (N, Target_Type);\n+                     return False;\n+\n+                  --  Conversion not allowed because of accessibility levels\n+\n+                  else\n+                     Error_Msg_N (\"source array type \" &\n+                       \"has deeper accessibility level than target\", Operand);\n+                     return False;\n+                  end if;\n+               else\n+                  null;\n+               end if;\n+\n+            --  All other cases where component base types do not match\n+\n+            else\n+               Error_Msg_N\n+                 (\"incompatible component types for array conversion\",\n+                  Operand);\n+               return False;\n+            end if;\n+\n+            --  Check that component subtypes statically match\n+\n+            if Is_Constrained (Target_Comp_Type) /=\n+                 Is_Constrained (Opnd_Comp_Type)\n+              or else not Subtypes_Statically_Match\n+                            (Target_Comp_Type, Opnd_Comp_Type)\n+            then\n+               Error_Msg_N\n+                 (\"component subtypes must statically match\", Operand);\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end Valid_Array_Conversion;\n+\n       -----------------------------\n       -- Valid_Tagged_Conversion --\n       -----------------------------\n@@ -7310,6 +7649,11 @@ package body Sem_Res is\n          elsif Is_Interface (Target_Type) then\n             return True;\n \n+         elsif Is_Access_Type (Opnd_Type)\n+           and then Is_Interface (Directly_Designated_Type (Opnd_Type))\n+         then\n+            return True;\n+\n          else\n             Error_Msg_NE\n               (\"invalid tagged conversion, not compatible with}\",\n@@ -7392,10 +7736,10 @@ package body Sem_Res is\n                   Error_Msg_N (\"ambiguous operand in conversion\", Operand);\n \n                   Error_Msg_Sloc := Sloc (It.Nam);\n-                  Error_Msg_N (\"possible interpretation#!\", Operand);\n+                  Error_Msg_N (\"\\\\possible interpretation#!\", Operand);\n \n                   Error_Msg_Sloc := Sloc (N1);\n-                  Error_Msg_N (\"possible interpretation#!\", Operand);\n+                  Error_Msg_N (\"\\\\possible interpretation#!\", Operand);\n \n                   return False;\n                end if;\n@@ -7406,27 +7750,40 @@ package body Sem_Res is\n          end;\n       end if;\n \n-      if Chars (Current_Scope) = Name_Unchecked_Conversion then\n+      --  Numeric types\n \n-         --  This check is dubious, what if there were a user defined\n-         --  scope whose name was Unchecked_Conversion ???\n+      if Is_Numeric_Type (Target_Type)  then\n \n-         return True;\n+         --  A universal fixed expression can be converted to any numeric type\n \n-      elsif Is_Numeric_Type (Target_Type)  then\n          if Opnd_Type = Universal_Fixed then\n             return True;\n \n-         elsif (In_Instance or else In_Inlined_Body)\n-           and then not Comes_From_Source (N)\n-         then\n-            return True;\n+         --  Also no need to check when in an instance or inlined body, because\n+         --  the legality has been established when the template was analyzed.\n+         --  Furthermore, numeric conversions may occur where only a private\n+         --  view of the operand type is visible at the instanciation point.\n+         --  This results in a spurious error if we check that the operand type\n+         --  is a numeric type.\n+\n+         --  Note: in a previous version of this unit, the following tests were\n+         --  applied only for generated code (Comes_From_Source set to False),\n+         --  but in fact the test is required for source code as well, since\n+         --  this situation can arise in source code.\n+\n+         elsif In_Instance or else In_Inlined_Body then\n+               return True;\n+\n+         --  Otherwise we need the conversion check\n \n          else\n-            return Conversion_Check (Is_Numeric_Type (Opnd_Type),\n-                             \"illegal operand for numeric conversion\");\n+            return Conversion_Check\n+                    (Is_Numeric_Type (Opnd_Type),\n+                     \"illegal operand for numeric conversion\");\n          end if;\n \n+      --  Array types\n+\n       elsif Is_Array_Type (Target_Type) then\n          if not Is_Array_Type (Opnd_Type)\n            or else Opnd_Type = Any_Composite\n@@ -7435,91 +7792,15 @@ package body Sem_Res is\n             Error_Msg_N\n               (\"illegal operand for array conversion\", Operand);\n             return False;\n-\n-         elsif Number_Dimensions (Target_Type) /=\n-           Number_Dimensions (Opnd_Type)\n-         then\n-            Error_Msg_N\n-              (\"incompatible number of dimensions for conversion\", Operand);\n-            return False;\n-\n          else\n-            declare\n-               Target_Index : Node_Id := First_Index (Target_Type);\n-               Opnd_Index   : Node_Id := First_Index (Opnd_Type);\n-\n-               Target_Index_Type : Entity_Id;\n-               Opnd_Index_Type   : Entity_Id;\n-\n-               Target_Comp_Type : constant Entity_Id :=\n-                                    Component_Type (Target_Type);\n-               Opnd_Comp_Type   : constant Entity_Id :=\n-                                     Component_Type (Opnd_Type);\n-\n-            begin\n-               while Present (Target_Index) and then Present (Opnd_Index) loop\n-                  Target_Index_Type := Etype (Target_Index);\n-                  Opnd_Index_Type   := Etype (Opnd_Index);\n-\n-                  if not (Is_Integer_Type (Target_Index_Type)\n-                          and then Is_Integer_Type (Opnd_Index_Type))\n-                    and then (Root_Type (Target_Index_Type)\n-                              /= Root_Type (Opnd_Index_Type))\n-                  then\n-                     Error_Msg_N\n-                       (\"incompatible index types for array conversion\",\n-                        Operand);\n-                     return False;\n-                  end if;\n-\n-                  Next_Index (Target_Index);\n-                  Next_Index (Opnd_Index);\n-               end loop;\n-\n-               declare\n-                  BT : constant Entity_Id := Base_Type (Target_Comp_Type);\n-                  BO : constant Entity_Id := Base_Type (Opnd_Comp_Type);\n-\n-               begin\n-                  if BT = BO then\n-                     null;\n-\n-                  elsif\n-                    (Ekind (BT) = E_Anonymous_Access_Type\n-                       or else Ekind (BT) = E_Anonymous_Access_Subprogram_Type)\n-                    and then Ekind (BO) = Ekind (BT)\n-                    and then Subtypes_Statically_Match\n-                               (Target_Comp_Type,  Opnd_Comp_Type)\n-                  then\n-                     null;\n-\n-                  else\n-                     Error_Msg_N\n-                       (\"incompatible component types for array conversion\",\n-                        Operand);\n-                     return False;\n-                  end if;\n-               end;\n-\n-               if Is_Constrained (Target_Comp_Type) /=\n-                    Is_Constrained (Opnd_Comp_Type)\n-                 or else not Subtypes_Statically_Match\n-                               (Target_Comp_Type, Opnd_Comp_Type)\n-               then\n-                  Error_Msg_N\n-                    (\"component subtypes must statically match\", Operand);\n-                  return False;\n-\n-               end if;\n-            end;\n+            return Valid_Array_Conversion;\n          end if;\n \n-         return True;\n-\n-      --  Ada 2005 (AI-251)\n+      --  Anonymous access types where target references an interface\n \n       elsif (Ekind (Target_Type) = E_General_Access_Type\n-               or else Ekind (Target_Type) = E_Anonymous_Access_Type)\n+              or else\n+             Ekind (Target_Type) = E_Anonymous_Access_Type)\n         and then Is_Interface (Directly_Designated_Type (Target_Type))\n       then\n          --  Check the static accessibility rule of 4.6(17). Note that the\n@@ -7602,6 +7883,8 @@ package body Sem_Res is\n \n          return True;\n \n+      --  General and anonymous access types\n+\n       elsif (Ekind (Target_Type) = E_General_Access_Type\n         or else Ekind (Target_Type) = E_Anonymous_Access_Type)\n           and then\n@@ -7742,6 +8025,8 @@ package body Sem_Res is\n             end if;\n          end;\n \n+      --  Subprogram access types\n+\n       elsif (Ekind (Target_Type) = E_Access_Subprogram_Type\n                or else\n              Ekind (Target_Type) = E_Anonymous_Access_Subprogram_Type)\n@@ -7792,6 +8077,8 @@ package body Sem_Res is\n \n          return True;\n \n+      --  Remote subprogram access types\n+\n       elsif Is_Remote_Access_To_Subprogram_Type (Target_Type)\n         and then Is_Remote_Access_To_Subprogram_Type (Opnd_Type)\n       then\n@@ -7807,6 +8094,8 @@ package body Sem_Res is\n               N);\n          return True;\n \n+      --  Tagged types\n+\n       elsif Is_Tagged_Type (Target_Type) then\n          return Valid_Tagged_Conversion (Target_Type, Opnd_Type);\n "}, {"sha": "b83be5d741674857368d0a888066b9c4716e134f", "filename": "gcc/ada/sem_res.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fsem_res.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Fsem_res.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.ads?ref=aa1806136c169334a389a8ed9d69fff1521ad42b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -114,8 +114,7 @@ package Sem_Res is\n    --  read the spec of Sem.\n \n    procedure Pre_Analyze_And_Resolve (N : Node_Id);\n-   --  Same, but use type of node because context does not impose a single\n-   --  type.\n+   --  Same, but use type of node because context does not impose a single type\n \n private\n    procedure Resolve_Implicit_Type (N : Node_Id) renames Resolve;"}, {"sha": "eccae6e8f739875fca0060717e10d90ad311ff47", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=aa1806136c169334a389a8ed9d69fff1521ad42b", "patch": "@@ -106,10 +106,11 @@ package Types is\n \n    subtype Line_Terminator is Character range ASCII.LF .. ASCII.CR;\n    --  Line terminator characters (LF, VT, FF, CR)\n+   --\n    --  This definition is dubious now that we have two more wide character\n    --  sequences that constitute a line terminator. Every reference to\n    --  this subtype needs checking to make sure the wide character case\n-   --  is handled appropriately.\n+   --  is handled appropriately. ???\n \n    subtype Upper_Half_Character is\n      Character range Character'Val (16#80#) .. Character'Val (16#FF#);\n@@ -206,7 +207,7 @@ package Types is\n \n    No_Location : constant Source_Ptr := -1;\n    --  Value used to indicate no source position set in a node. A test for\n-   --  a Source_Ptr value being >= No_Location is the apporoved way to test\n+   --  a Source_Ptr value being > No_Location is the approved way to test\n    --  for a standard value that does not include No_Location or any of the\n    --  following special definitions.\n \n@@ -683,9 +684,10 @@ package Types is\n    -- Types used for Pragma Suppress Management --\n    -----------------------------------------------\n \n-   type Check_Id is (\n-      Access_Check,\n+   type Check_Id is\n+     (Access_Check,\n       Accessibility_Check,\n+      Alignment_Check,\n       Discriminant_Check,\n       Division_Check,\n       Elaboration_Check,\n@@ -695,6 +697,7 @@ package Types is\n       Range_Check,\n       Storage_Check,\n       Tag_Check,\n+      Validity_Check,\n       All_Checks);\n \n    --  The following array contains an entry for each recognized check name\n@@ -804,23 +807,23 @@ package Types is\n       PE_Access_Before_Elaboration,      -- 14\n       PE_Accessibility_Check_Failed,     -- 15\n       PE_All_Guards_Closed,              -- 16\n-      PE_Duplicated_Entry_Address,       -- 17\n-      PE_Explicit_Raise,                 -- 18\n-      PE_Finalize_Raised_Exception,      -- 19\n-      PE_Implicit_Return,                -- 20\n-      PE_Misaligned_Address_Value,       -- 21\n-      PE_Missing_Return,                 -- 22\n-      PE_Overlaid_Controlled_Object,     -- 23\n-      PE_Potentially_Blocking_Operation, -- 24\n-      PE_Stubbed_Subprogram_Called,      -- 25\n-      PE_Unchecked_Union_Restriction,    -- 26\n-      PE_Illegal_RACW_E_4_18,            -- 27\n-\n-      SE_Empty_Storage_Pool,             -- 28\n-      SE_Explicit_Raise,                 -- 29\n-      SE_Infinite_Recursion,             -- 30\n-      SE_Object_Too_Large,               -- 31\n-      SE_Restriction_Violation);         -- 32\n+      PE_Current_Task_In_Entry_Body,     -- 17\n+      PE_Duplicated_Entry_Address,       -- 18\n+      PE_Explicit_Raise,                 -- 19\n+      PE_Finalize_Raised_Exception,      -- 20\n+      PE_Implicit_Return,                -- 21\n+      PE_Misaligned_Address_Value,       -- 22\n+      PE_Missing_Return,                 -- 23\n+      PE_Overlaid_Controlled_Object,     -- 24\n+      PE_Potentially_Blocking_Operation, -- 25\n+      PE_Stubbed_Subprogram_Called,      -- 26\n+      PE_Unchecked_Union_Restriction,    -- 27\n+      PE_Illegal_RACW_E_4_18,            -- 28\n+\n+      SE_Empty_Storage_Pool,             -- 29\n+      SE_Explicit_Raise,                 -- 30\n+      SE_Infinite_Recursion,             -- 31\n+      SE_Object_Too_Large);              -- 32\n \n    subtype RT_CE_Exceptions is RT_Exception_Code range\n      CE_Access_Check_Failed ..\n@@ -832,6 +835,6 @@ package Types is\n \n    subtype RT_SE_Exceptions is RT_Exception_Code range\n      SE_Empty_Storage_Pool ..\n-     SE_Restriction_Violation;\n+     SE_Object_Too_Large;\n \n end Types;"}, {"sha": "ca0148b047635ca4b4d88706ae36af6d0607114b", "filename": "gcc/ada/types.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa1806136c169334a389a8ed9d69fff1521ad42b/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=aa1806136c169334a389a8ed9d69fff1521ad42b", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -348,22 +348,22 @@ typedef Int Mechanism_Type;\n #define PE_Access_Before_Elaboration       14\n #define PE_Accessibility_Check_Failed      15\n #define PE_All_Guards_Closed               16\n-#define PE_Duplicated_Entry_Address        17\n-#define PE_Explicit_Raise                  18\n-#define PE_Finalize_Raised_Exception       19\n-#define PE_Implicit_Return                 20\n-#define PE_Misaligned_Address_Value        21\n-#define PE_Missing_Return                  22\n-#define PE_Overlaid_Controlled_Object      23\n-#define PE_Potentially_Blocking_Operation  24\n-#define PE_Stubbed_Subprogram_Called       25\n-#define PE_Unchecked_Union_Restriction     26\n-#define PE_Illegal_RACW_E_4_18             27\n-\n-#define SE_Empty_Storage_Pool              28\n-#define SE_Explicit_Raise                  29\n-#define SE_Infinite_Recursion              30\n-#define SE_Object_Too_Large                31\n-#define SE_Restriction_Violation           32\n-\n-#define LAST_REASON_CODE                   31\n+#define PE_Current_Task_In_Entry_Body      17\n+#define PE_Duplicated_Entry_Address        18\n+#define PE_Explicit_Raise                  19\n+#define PE_Finalize_Raised_Exception       20\n+#define PE_Implicit_Return                 21\n+#define PE_Misaligned_Address_Value        22\n+#define PE_Missing_Return                  23\n+#define PE_Overlaid_Controlled_Object      24\n+#define PE_Potentially_Blocking_Operation  25\n+#define PE_Stubbed_Subprogram_Called       26\n+#define PE_Unchecked_Union_Restriction     27\n+#define PE_Illegal_RACW_E_4_18             28\n+\n+#define SE_Empty_Storage_Pool              29\n+#define SE_Explicit_Raise                  30\n+#define SE_Infinite_Recursion              31\n+#define SE_Object_Too_Large                32\n+\n+#define LAST_REASON_CODE                   32"}]}