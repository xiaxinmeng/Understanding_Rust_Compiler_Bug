{"sha": "acef433b61b5e8001133d37e66250c2f0ab2a042", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNlZjQzM2I2MWI1ZTgwMDExMzNkMzdlNjYyNTBjMmYwYWIyYTA0Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-08-28T21:46:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-08-28T21:46:30Z"}, "message": "cp-tree.def (LABEL_STMT): New tree node.\n\n\t* cp-tree.def (LABEL_STMT): New tree node.\n\t(LABEL_STMT_LABEL): New macro.\n\t(shadow_label): Remove.\n\t(declare_local_label): New function.\n\t(finish_label_decl): Likewise.\n\t* decl.c (make_label_decl): New function, split out from\n\tlookup_label.\n\t(shadowed_labels): Remove.\n\t(binding_level): Add shadowed_labels.\n\t(clear_binding_level): Remove.\n\t(push_binding_level): Just bzero the new binding level.\n\t(pushlevel): Fix indentation.\n\t(pop_label): New function.\n\t(pop_labels): Likewise, split out from poplevel.\n\t(poplevel): Pop local labels.  Use pop_labels.\n\t(maybe_push_to_top_level): Don't clear shadowed_labels.\n\t(lookup_label): Use make_label_decl.\n\t(shadow_label): Remove.\n\t(declare_local_label): New function.\n\t(define_label): Simplify.\n\t(start_function): Don't clear shadowed_labels.\n\t(cp_function): Remove shadowed_labels.\n\t(push_cp_function_context): Don't save shadowed_labels.\n\t(pop_cp_function_context): Don't restore it.\n\t* dump.c (dequeue_and_dump): Handle LABEL_STMT.\n\t* parse.y (label_decl): Use finish_label_decl.\n\t* pt.c (tsubst_expr): Handle LABEL_STMTs, and local label\n\tdeclarations.\n\t* semantics.c (finish_label_stmt): Add a LABEL_STMT when\n\tbuilding_stmt_tree.\n\t(finish_label_decl): New function.\n\t(expand_stmt): Handle LABEL_STMTs and local label declarations.\n\nFrom-SVN: r28943", "tree": {"sha": "8ab9e1dd5159729ad69d044ceacb1739bfbc9532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ab9e1dd5159729ad69d044ceacb1739bfbc9532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acef433b61b5e8001133d37e66250c2f0ab2a042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acef433b61b5e8001133d37e66250c2f0ab2a042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acef433b61b5e8001133d37e66250c2f0ab2a042", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acef433b61b5e8001133d37e66250c2f0ab2a042/comments", "author": null, "committer": null, "parents": [{"sha": "79101920008a32754f6cfc9074fc13d5fc50c473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79101920008a32754f6cfc9074fc13d5fc50c473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79101920008a32754f6cfc9074fc13d5fc50c473"}], "stats": {"total": 818, "additions": 490, "deletions": 328}, "files": [{"sha": "06d6b06e910515b8479b226ef7e554777769f673", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -1,3 +1,38 @@\n+1999-08-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (LABEL_STMT): New tree node.\n+\t(LABEL_STMT_LABEL): New macro.\n+\t(shadow_label): Remove.\n+\t(declare_local_label): New function.\n+\t(finish_label_decl): Likewise.\n+\t* decl.c (make_label_decl): New function, split out from\n+\tlookup_label.\n+\t(shadowed_labels): Remove.\n+\t(binding_level): Add shadowed_labels.\n+\t(clear_binding_level): Remove.\n+\t(push_binding_level): Just bzero the new binding level.\n+\t(pushlevel): Fix indentation.\n+\t(pop_label): New function.\n+\t(pop_labels): Likewise, split out from poplevel.\n+\t(poplevel): Pop local labels.  Use pop_labels.\n+\t(maybe_push_to_top_level): Don't clear shadowed_labels.\n+\t(lookup_label): Use make_label_decl.\n+\t(shadow_label): Remove.\n+\t(declare_local_label): New function.\n+\t(define_label): Simplify.\n+\t(start_function): Don't clear shadowed_labels.\n+\t(cp_function): Remove shadowed_labels.\n+\t(push_cp_function_context): Don't save shadowed_labels.\n+\t(pop_cp_function_context): Don't restore it.\n+\t* dump.c (dequeue_and_dump): Handle LABEL_STMT.\n+\t* parse.y (label_decl): Use finish_label_decl.\n+\t* pt.c (tsubst_expr): Handle LABEL_STMTs, and local label\n+\tdeclarations.\n+\t* semantics.c (finish_label_stmt): Add a LABEL_STMT when\n+\tbuilding_stmt_tree.\n+\t(finish_label_decl): New function.\n+\t(expand_stmt): Handle LABEL_STMTs and local label declarations.\n+\t\n 1999-08-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (lookup_label): Build labels on the permanent obstack"}, {"sha": "e864c7863fcb6bd77d8aa6d8b8033ac025e1d434", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -228,6 +228,7 @@ DEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 2)\n DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n+DEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n /* A SUBOBJECT statement marks the point at which a sub-object is\n    fully constructed.  After this point, the SUBOBJECT_CLEANUP must be"}, {"sha": "350eb8e5a0e51a9709742bbbb090af1110042c21", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 144, "deletions": 125, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -190,6 +190,9 @@ static void warn_about_implicit_typename_lookup PROTO((tree, tree));\n static int walk_namespaces_r PROTO((tree, walk_namespaces_fn, void *));\n static int walk_globals_r PROTO((tree, void *));\n static void add_decl_to_level PROTO((tree, struct binding_level *));\n+static tree make_label_decl PROTO((tree, int));\n+static void pop_label PROTO((tree));\n+static void pop_labels PROTO((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -419,14 +422,11 @@ static tree current_function_parm_tags;\n \n /* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n    that have names.  Here so we can clear out their names' definitions\n-   at the end of the function.  */\n+   at the end of the function.  The TREE_VALUE is a LABEL_DECL; the\n+   TREE_PURPOSE is the previous binding of the label.  */\n \n static tree named_labels;\n \n-/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */\n-\n-static tree shadowed_labels;\n-\n /* The FUNCTION_DECL for the function currently being compiled,\n    or 0 if between functions.  */\n tree current_function_decl;\n@@ -587,6 +587,11 @@ struct binding_level\n        is used for all binding levels.  */\n     tree type_shadowed;\n \n+    /* A TREE_LIST.  Each TREE_VALUE is the LABEL_DECL for a local\n+       label in this scope.  The TREE_PURPOSE is the previous value of\n+       the IDENTIFIER_LABEL VALUE.  */\n+    tree shadowed_labels;\n+\n     /* For each level (except not the global one),\n        a chain of BLOCK nodes for all the levels\n        that were entered and exited one level down.  */\n@@ -669,10 +674,6 @@ static struct binding_level *free_binding_level;\n \n static struct binding_level *global_binding_level;\n \n-/* Binding level structures are initialized by copying this one.  */\n-\n-static struct binding_level clear_binding_level;\n-\n /* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n \n static int keep_next_level_flag;\n@@ -700,7 +701,7 @@ push_binding_level (newlevel, tag_transparent, keep)\n {\n   /* Add this level to the front of the chain (stack) of levels that\n      are active.  */\n-  *newlevel = clear_binding_level;\n+  bzero ((char*) newlevel, sizeof (struct binding_level));\n   newlevel->level_chain = current_binding_level;\n   current_binding_level = newlevel;\n   newlevel->tag_transparent = tag_transparent;\n@@ -967,9 +968,7 @@ pushlevel (tag_transparent)\n       free_binding_level = free_binding_level->level_chain;\n     }\n   else\n-    {\n-      newlevel = make_binding_level ();\n-    }\n+    newlevel = make_binding_level ();\n \n   push_binding_level (newlevel, tag_transparent, keep_next_level_flag);\n   GNU_xref_start_scope ((HOST_WIDE_INT) newlevel);\n@@ -1277,6 +1276,51 @@ pop_binding (id, decl)\n     }\n }\n \n+/* When a label goes out of scope, check to see if that label was used\n+   in a valid manner, and issue any appropriate warnings or errors.  */\n+\n+static void\n+pop_label (link)\n+     tree link;\n+{\n+  tree label = TREE_VALUE (link);\n+\n+  if (DECL_INITIAL (label) == NULL_TREE)\n+    {\n+      cp_error_at (\"label `%D' used but not defined\", label);\n+      /* Avoid crashing later.  */\n+      define_label (input_filename, 1, DECL_NAME (label));\n+    }\n+  else if (warn_unused && !TREE_USED (label))\n+    cp_warning_at (\"label `%D' defined but not used\", label);\n+\n+  SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (label), TREE_PURPOSE (link));\n+}\n+\n+/* At the end of a function, all labels declared within the fucntion\n+   go out of scope.  BLOCK is the top-level block for the \n+   function.  */\n+\n+static void\n+pop_labels (block)\n+     tree block;\n+{\n+  tree link;\n+\n+  /* Clear out the definitions of all label names, since their scopes\n+     end here.  */\n+  for (link = named_labels; link; link = TREE_CHAIN (link))\n+    {\n+      pop_label (link);\n+      /* Put the labels into the \"variables\" of the top-level block,\n+\t so debugger can see them.  */\n+      TREE_CHAIN (TREE_VALUE (link)) = BLOCK_VARS (block);\n+      BLOCK_VARS (block) = TREE_VALUE (link);\n+    }\n+\n+  named_labels = NULL_TREE;\n+}\n+\n /* Exit a binding level.\n    Pop the level off, and restore the state of the identifier-decl mappings\n    that were in effect when this level was entered.\n@@ -1512,7 +1556,13 @@ poplevel (keep, reverse, functionbody)\n   for (link = current_binding_level->type_shadowed;\n        link; link = TREE_CHAIN (link))\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n-  \n+\n+  /* Restore the IDENTIFIER_LABEL_VALUEs for local labels.  */\n+  for (link = current_binding_level->shadowed_labels;\n+       link; \n+       link = TREE_CHAIN (link))\n+    pop_label (link);\n+\n   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n      list if a `using' declaration put them there.  The debugging\n      back-ends won't understand OVERLOAD, so we remove them here.\n@@ -1534,40 +1584,13 @@ poplevel (keep, reverse, functionbody)\n \n   /* If the level being exited is the top level of a function,\n      check over all the labels.  */\n-\n   if (functionbody)\n     {\n-      /* If this is the top level block of a function,\n-         the vars are the function's parameters.\n-         Don't leave them in the BLOCK because they are\n-         found in the FUNCTION_DECL instead.  */\n-\n+      /* Since this is the top level block of a function, the vars are\n+\t the function's parameters.  Don't leave them in the BLOCK\n+\t because they are found in the FUNCTION_DECL instead.  */\n       BLOCK_VARS (block) = 0;\n-\n-      /* Clear out the definitions of all label names,\n-\t since their scopes end here.  */\n-\n-      for (link = named_labels; link; link = TREE_CHAIN (link))\n-\t{\n-\t  register tree label = TREE_VALUE (link);\n-\n-\t  if (DECL_INITIAL (label) == NULL_TREE)\n-\t    {\n-\t      cp_error_at (\"label `%D' used but not defined\", label);\n-\t      /* Avoid crashing later.  */\n-\t      define_label (input_filename, 1, DECL_NAME (label));\n-\t    }\n-\t  else if (warn_unused && !TREE_USED (label))\n-\t    cp_warning_at (\"label `%D' defined but not used\", label);\n-\t  SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (label), NULL_TREE);\n-\n-          /* Put the labels into the \"variables\" of the\n-             top-level block, so debugger can see them.  */\n-          TREE_CHAIN (label) = BLOCK_VARS (block);\n-          BLOCK_VARS (block) = label;\n-\t}\n-\n-      named_labels = NULL_TREE;\n+      pop_labels (block);\n     }\n \n   /* Any uses of undefined labels now operate under constraints\n@@ -2547,7 +2570,6 @@ maybe_push_to_top_level (pseudo)\n   current_lang_name = lang_name_cplusplus;\n   strict_prototype = strict_prototypes_lang_cplusplus;\n   named_labels = NULL_TREE;\n-  shadowed_labels = NULL_TREE;\n   previous_class_type = previous_class_values = NULL_TREE;\n   class_cache_firstobj = 0;\n   processing_specialization = 0;\n@@ -4784,25 +4806,40 @@ redeclaration_error_message (newdecl, olddecl)\n     }\n }\n \f\n-/* Get the LABEL_DECL corresponding to identifier ID as a label.\n-   Create one if none exists so far for the current function.\n-   This function is called for both label definitions and label references.  */\n+/* Create a new label, named ID.  */\n \n-tree\n-lookup_label (id)\n+static tree\n+make_label_decl (id, local_p)\n      tree id;\n+     int local_p;\n {\n-  register tree decl = IDENTIFIER_LABEL_VALUE (id);\n+  tree decl;\n \n-  if (current_function_decl == NULL_TREE)\n-    {\n-      error (\"label `%s' referenced outside of any function\",\n-\t     IDENTIFIER_POINTER (id));\n-      return NULL_TREE;\n-    }\n+  if (building_stmt_tree ())\n+    push_permanent_obstack ();\n+  decl = build_decl (LABEL_DECL, id, void_type_node);\n+  if (building_stmt_tree ())\n+    pop_obstacks ();\n+  else\n+    /* Make sure every label has an rtx.  */\n+    label_rtx (decl);\n+\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  DECL_MODE (decl) = VOIDmode;\n+  C_DECLARED_LABEL_FLAG (decl) = local_p;\n \n-  if ((decl == NULL_TREE\n-      || DECL_SOURCE_LINE (decl) == 0)\n+  /* Say where one reference is to the label, for the sake of the\n+     error if it is not defined.  */\n+  DECL_SOURCE_LINE (decl) = lineno;\n+  DECL_SOURCE_FILE (decl) = input_filename;\n+\n+  /* Record the fact that this identifier is bound to this label.  */\n+  SET_IDENTIFIER_LABEL_VALUE (id, decl);\n+\n+  /* Record this label on the list of used labels so that we can check\n+     at the end of the function to see whether or not the label was\n+     actually defined.  */\n+  if ((named_label_uses == NULL || named_label_uses->label_decl != decl)\n       && (named_label_uses == NULL\n \t  || named_label_uses->names_in_scope != current_binding_level->names\n \t  || named_label_uses->label_decl != decl))\n@@ -4819,64 +4856,65 @@ lookup_label (id)\n       named_label_uses = new_ent;\n     }\n \n-  /* Use a label already defined or ref'd with this name.  */\n-  if (decl != NULL_TREE)\n-    {\n-      /* But not if it is inherited and wasn't declared to be inheritable.  */\n-      if (DECL_CONTEXT (decl) != current_function_decl\n-\t  && ! C_DECLARED_LABEL_FLAG (decl))\n-\treturn shadow_label (id);\n-      return decl;\n-    }\n-\n-  if (building_stmt_tree ())\n-    push_permanent_obstack ();\n-  decl = build_decl (LABEL_DECL, id, void_type_node);\n-  if (building_stmt_tree ())\n-    pop_obstacks ();\n-  else\n-    /* Make sure every label has an rtx.  */\n-    label_rtx (decl);\n-\n-  /* A label not explicitly declared must be local to where it's ref'd.  */\n-  DECL_CONTEXT (decl) = current_function_decl;\n+  return decl;\n+}\n \n-  DECL_MODE (decl) = VOIDmode;\n+/* Look for a label named ID in the current function.  If one cannot\n+   be found, create one.  (We keep track of used, but undefined,\n+   labels, and complain about them at the end of a function.)  */\n \n-  /* Say where one reference is to the label,\n-     for the sake of the error if it is not defined.  */\n-  DECL_SOURCE_LINE (decl) = lineno;\n-  DECL_SOURCE_FILE (decl) = input_filename;\n+tree \n+lookup_label (id)\n+     tree id;\n+{\n+  tree decl;\n \n-  SET_IDENTIFIER_LABEL_VALUE (id, decl);\n+  /* You can't use labels at global scope.  */\n+  if (current_function_decl == NULL_TREE)\n+    {\n+      error (\"label `%s' referenced outside of any function\",\n+\t     IDENTIFIER_POINTER (id));\n+      return NULL_TREE;\n+    }\n+  \n+  /* See if we've already got this label.  */\n+  decl = IDENTIFIER_LABEL_VALUE (id);\n+  if (decl != NULL_TREE && DECL_CONTEXT (decl) == current_function_decl)\n+    return decl;\n \n-  named_labels = tree_cons (NULL_TREE, decl, named_labels);\n-  named_label_uses->label_decl = decl;\n+  /* Record this label on the list of labels used in this function.\n+     We do this before calling make_label_decl so that we get the\n+     IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n+  named_labels = tree_cons (IDENTIFIER_LABEL_VALUE (id), NULL_TREE,\n+\t\t\t    named_labels);\n+  /* We need a new label.  */\n+  decl = make_label_decl (id, /*local_p=*/0);\n+  /* Now fill in the information we didn't have before.  */\n+  TREE_VALUE (named_labels) = decl;\n \n   return decl;\n }\n \n-/* Make a label named NAME in the current function,\n-   shadowing silently any that may be inherited from containing functions\n-   or containing scopes.\n-\n-   Note that valid use, if the label being shadowed\n-   comes from another scope in the same function,\n-   requires calling declare_nonlocal_label right away.  */\n+/* Declare a local label named ID.  */\n \n tree\n-shadow_label (name)\n-     tree name;\n+declare_local_label (id)\n+     tree id;\n {\n-  register tree decl = IDENTIFIER_LABEL_VALUE (name);\n-\n-  if (decl != NULL_TREE)\n-    {\n-      shadowed_labels = tree_cons (NULL_TREE, decl, shadowed_labels);\n-      SET_IDENTIFIER_LABEL_VALUE (name, NULL_TREE);\n-    }\n+  tree decl;\n \n-  return lookup_label (name);\n+  /* Add a new entry to the SHADOWED_LABELS list so that when we leave\n+     this scope we can restore the old value of\n+     IDENTIFIER_TYPE_VALUE.  */\n+  current_binding_level->shadowed_labels \n+    = tree_cons (IDENTIFIER_LABEL_VALUE (id), NULL_TREE,\n+\t\t current_binding_level->shadowed_labels);\n+  /* Look for the label.  */\n+  decl = make_label_decl (id, /*local_p=*/1);\n+  /* Now fill in the information we didn't have before.  */\n+  TREE_VALUE (current_binding_level->shadowed_labels) = decl;\n+  \n+  return decl;\n }\n \n /* Define a label, specifying the location in the source file.\n@@ -4895,14 +4933,6 @@ define_label (filename, line, name)\n      own new (temporary) binding contour.  */\n   current_binding_level->more_cleanups_ok = 0;\n \n-  /* If label with this name is known from an outer context, shadow it.  */\n-  if (decl != NULL_TREE && DECL_CONTEXT (decl) != current_function_decl)\n-    {\n-      shadowed_labels = tree_cons (NULL_TREE, decl, shadowed_labels);\n-      SET_IDENTIFIER_LABEL_VALUE (name, NULL_TREE);\n-      decl = lookup_label (name);\n-    }\n-\n   if (name == get_identifier (\"wchar_t\"))\n     cp_pedwarn (\"label named wchar_t\");\n \n@@ -12815,7 +12845,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   current_function_returns_value = 0;\n   current_function_returns_null = 0;\n   named_labels = 0;\n-  shadowed_labels = 0;\n   current_function_assigns_this = 0;\n   current_function_just_assigned_this = 0;\n   current_function_parms_stored = 0;\n@@ -14385,7 +14414,6 @@ struct cp_function\n   int temp_name_counter;\n   tree named_labels;\n   struct named_label_list *named_label_uses;\n-  tree shadowed_labels;\n   tree ctor_label;\n   tree dtor_label;\n   rtx last_dtor_insn;\n@@ -14427,7 +14455,6 @@ push_cp_function_context (context)\n \n   p->named_labels = named_labels;\n   p->named_label_uses = named_label_uses;\n-  p->shadowed_labels = shadowed_labels;\n   p->returns_value = current_function_returns_value;\n   p->returns_null = current_function_returns_null;\n   p->binding_level = current_binding_level;\n@@ -14468,21 +14495,13 @@ pop_cp_function_context (context)\n      tree context;\n {\n   struct cp_function *p = cp_function_chain;\n-  tree link;\n-\n-  /* Bring back all the labels that were shadowed.  */\n-  for (link = shadowed_labels; link; link = TREE_CHAIN (link))\n-    if (DECL_NAME (TREE_VALUE (link)) != 0)\n-      SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link)),\n-\t\t\t\t  TREE_VALUE (link));\n \n   pop_function_context_from (context);\n \n   cp_function_chain = p->next;\n \n   named_labels = p->named_labels;\n   named_label_uses = p->named_label_uses;\n-  shadowed_labels = p->shadowed_labels;\n   current_function_returns_value = p->returns_value;\n   current_function_returns_null = p->returns_null;\n   current_binding_level = p->binding_level;"}, {"sha": "1241d410986d86e71ba471fce6be62368a3f0259", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -731,6 +731,13 @@ dequeue_and_dump (di)\n       dump_next_stmt (di, t);\n       break;\n \n+    case LABEL_STMT:\n+      dump_stmt (di, t);\n+      if (dump_children_p)\n+\tdump_child (\"labl\", LABEL_STMT_LABEL (t));\n+      dump_next_stmt (di, t);\n+      break;\n+\n     case RETURN_STMT:\n       dump_stmt (di, t);\n       if (dump_children_p)"}, {"sha": "7b413f3732bcd8c9e4015cc77e3ce39a9cb8e09b", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 167, "deletions": 168, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -714,23 +714,23 @@ static const short yyrline[] = { 0,\n   3090,  3092,  3094,  3096,  3098,  3100,  3102,  3104,  3108,  3112,\n   3116,  3120,  3122,  3124,  3126,  3128,  3130,  3132,  3134,  3136,\n   3144,  3146,  3147,  3148,  3151,  3157,  3159,  3164,  3166,  3169,\n-  3183,  3186,  3189,  3193,  3196,  3203,  3205,  3208,  3210,  3212,\n-  3215,  3218,  3221,  3224,  3226,  3229,  3233,  3235,  3241,  3243,\n-  3244,  3246,  3251,  3253,  3255,  3257,  3259,  3262,  3263,  3265,\n-  3268,  3269,  3272,  3272,  3275,  3275,  3278,  3278,  3280,  3282,\n-  3284,  3286,  3292,  3298,  3301,  3304,  3310,  3312,  3314,  3318,\n-  3320,  3321,  3322,  3324,  3327,  3330,  3333,  3339,  3343,  3345,\n-  3348,  3350,  3353,  3357,  3359,  3362,  3364,  3367,  3384,  3390,\n-  3393,  3395,  3397,  3401,  3404,  3405,  3413,  3417,  3421,  3424,\n-  3425,  3431,  3434,  3437,  3439,  3443,  3448,  3451,  3461,  3466,\n-  3467,  3474,  3477,  3480,  3482,  3485,  3487,  3497,  3511,  3515,\n-  3518,  3520,  3524,  3528,  3531,  3534,  3536,  3540,  3542,  3549,\n-  3556,  3559,  3563,  3567,  3571,  3577,  3581,  3586,  3588,  3591,\n-  3596,  3602,  3613,  3616,  3618,  3622,  3630,  3633,  3637,  3640,\n-  3642,  3644,  3650,  3655,  3658,  3660,  3662,  3664,  3666,  3668,\n-  3670,  3672,  3674,  3676,  3678,  3680,  3682,  3684,  3686,  3688,\n-  3690,  3692,  3694,  3696,  3698,  3700,  3702,  3704,  3706,  3708,\n-  3710,  3712,  3714,  3716,  3718,  3720,  3723,  3725\n+  3182,  3185,  3188,  3192,  3195,  3202,  3204,  3207,  3209,  3211,\n+  3214,  3217,  3220,  3223,  3225,  3228,  3232,  3234,  3240,  3242,\n+  3243,  3245,  3250,  3252,  3254,  3256,  3258,  3261,  3262,  3264,\n+  3267,  3268,  3271,  3271,  3274,  3274,  3277,  3277,  3279,  3281,\n+  3283,  3285,  3291,  3297,  3300,  3303,  3309,  3311,  3313,  3317,\n+  3319,  3320,  3321,  3323,  3326,  3329,  3332,  3338,  3342,  3344,\n+  3347,  3349,  3352,  3356,  3358,  3361,  3363,  3366,  3383,  3389,\n+  3392,  3394,  3396,  3400,  3403,  3404,  3412,  3416,  3420,  3423,\n+  3424,  3430,  3433,  3436,  3438,  3442,  3447,  3450,  3460,  3465,\n+  3466,  3473,  3476,  3479,  3481,  3484,  3486,  3496,  3510,  3514,\n+  3517,  3519,  3523,  3527,  3530,  3533,  3535,  3539,  3541,  3548,\n+  3555,  3558,  3562,  3566,  3570,  3576,  3580,  3585,  3587,  3590,\n+  3595,  3601,  3612,  3615,  3617,  3621,  3629,  3632,  3636,  3639,\n+  3641,  3643,  3649,  3654,  3657,  3659,  3661,  3663,  3665,  3667,\n+  3669,  3671,  3673,  3675,  3677,  3679,  3681,  3683,  3685,  3687,\n+  3689,  3691,  3693,  3695,  3697,  3699,  3701,  3703,  3705,  3707,\n+  3709,  3711,  3713,  3715,  3717,  3719,  3722,  3724\n };\n #endif\n \n@@ -7489,365 +7489,364 @@ case 707:\n     break;}\n case 710:\n #line 3171 \"parse.y\"\n-{ tree link;\n-\t\t  for (link = yyvsp[-1].ttype; link; link = TREE_CHAIN (link))\n+{ \n+\t\t  while (yyvsp[-1].ttype)\n \t\t    {\n-\t\t      tree label = shadow_label (TREE_VALUE (link));\n-\t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t\t      declare_nonlocal_label (label);\n+\t\t      finish_label_decl (TREE_VALUE (yyvsp[-1].ttype));\n+\t\t      yyvsp[-1].ttype = TREE_CHAIN (yyvsp[-1].ttype);\n \t\t    }\n \t\t;\n     break;}\n case 711:\n-#line 3185 \"parse.y\"\n+#line 3184 \"parse.y\"\n {;\n     break;}\n case 713:\n-#line 3191 \"parse.y\"\n+#line 3190 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 714:\n-#line 3193 \"parse.y\"\n+#line 3192 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 715:\n-#line 3198 \"parse.y\"\n+#line 3197 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_if_stmt ();\n \t\t  cond_stmt_keyword = \"if\";\n \t\t;\n     break;}\n case 716:\n-#line 3203 \"parse.y\"\n+#line 3202 \"parse.y\"\n { finish_if_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 717:\n-#line 3205 \"parse.y\"\n+#line 3204 \"parse.y\"\n { yyval.ttype = finish_then_clause (yyvsp[-3].ttype); ;\n     break;}\n case 719:\n-#line 3210 \"parse.y\"\n+#line 3209 \"parse.y\"\n { yyval.ttype = begin_compound_stmt (0); ;\n     break;}\n case 720:\n-#line 3212 \"parse.y\"\n+#line 3211 \"parse.y\"\n { yyval.ttype = finish_compound_stmt (0, yyvsp[-1].ttype); ;\n     break;}\n case 721:\n-#line 3217 \"parse.y\"\n+#line 3216 \"parse.y\"\n {;\n     break;}\n case 723:\n-#line 3223 \"parse.y\"\n+#line 3222 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 724:\n-#line 3225 \"parse.y\"\n+#line 3224 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 725:\n-#line 3227 \"parse.y\"\n+#line 3226 \"parse.y\"\n { begin_else_clause (); ;\n     break;}\n case 726:\n-#line 3229 \"parse.y\"\n+#line 3228 \"parse.y\"\n { \n \t\t  finish_else_clause (yyvsp[-3].ttype); \n \t\t  finish_if_stmt ();\n \t\t;\n     break;}\n case 727:\n-#line 3234 \"parse.y\"\n+#line 3233 \"parse.y\"\n { finish_if_stmt (); ;\n     break;}\n case 728:\n-#line 3236 \"parse.y\"\n+#line 3235 \"parse.y\"\n {\n \t\t  yyval.ttype = begin_while_stmt ();\n \t\t  cond_stmt_keyword = \"while\";\n \t\t;\n     break;}\n case 729:\n-#line 3241 \"parse.y\"\n+#line 3240 \"parse.y\"\n { finish_while_stmt_cond (yyvsp[0].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 730:\n-#line 3243 \"parse.y\"\n+#line 3242 \"parse.y\"\n { finish_while_stmt (yyvsp[-3].ttype); ;\n     break;}\n case 731:\n-#line 3245 \"parse.y\"\n+#line 3244 \"parse.y\"\n { yyval.ttype = begin_do_stmt (); ;\n     break;}\n case 732:\n-#line 3247 \"parse.y\"\n+#line 3246 \"parse.y\"\n {\n \t\t  finish_do_body (yyvsp[-2].ttype);\n \t\t  cond_stmt_keyword = \"do\";\n \t\t;\n     break;}\n case 733:\n-#line 3252 \"parse.y\"\n+#line 3251 \"parse.y\"\n { finish_do_stmt (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 734:\n-#line 3254 \"parse.y\"\n+#line 3253 \"parse.y\"\n { yyval.ttype = begin_for_stmt (); ;\n     break;}\n case 735:\n-#line 3256 \"parse.y\"\n+#line 3255 \"parse.y\"\n { finish_for_init_stmt (yyvsp[-2].ttype); ;\n     break;}\n case 736:\n-#line 3258 \"parse.y\"\n+#line 3257 \"parse.y\"\n { finish_for_cond (yyvsp[-1].ttype, yyvsp[-5].ttype); ;\n     break;}\n case 737:\n-#line 3260 \"parse.y\"\n+#line 3259 \"parse.y\"\n { finish_for_expr (yyvsp[-1].ttype, yyvsp[-8].ttype); ;\n     break;}\n case 738:\n-#line 3262 \"parse.y\"\n+#line 3261 \"parse.y\"\n { finish_for_stmt (yyvsp[-3].ttype, yyvsp[-10].ttype); ;\n     break;}\n case 739:\n-#line 3264 \"parse.y\"\n+#line 3263 \"parse.y\"\n { begin_switch_stmt (); ;\n     break;}\n case 740:\n-#line 3266 \"parse.y\"\n+#line 3265 \"parse.y\"\n { yyval.ttype = finish_switch_cond (yyvsp[-1].ttype); ;\n     break;}\n case 741:\n-#line 3268 \"parse.y\"\n+#line 3267 \"parse.y\"\n { finish_switch_stmt (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 742:\n-#line 3270 \"parse.y\"\n+#line 3269 \"parse.y\"\n { finish_case_label (yyvsp[-1].ttype, NULL_TREE); ;\n     break;}\n case 744:\n-#line 3273 \"parse.y\"\n+#line 3272 \"parse.y\"\n { finish_case_label (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 746:\n-#line 3276 \"parse.y\"\n+#line 3275 \"parse.y\"\n { finish_case_label (NULL_TREE, NULL_TREE); ;\n     break;}\n case 748:\n-#line 3279 \"parse.y\"\n+#line 3278 \"parse.y\"\n { finish_break_stmt (); ;\n     break;}\n case 749:\n-#line 3281 \"parse.y\"\n+#line 3280 \"parse.y\"\n { finish_continue_stmt (); ;\n     break;}\n case 750:\n-#line 3283 \"parse.y\"\n+#line 3282 \"parse.y\"\n { finish_return_stmt (NULL_TREE); ;\n     break;}\n case 751:\n-#line 3285 \"parse.y\"\n+#line 3284 \"parse.y\"\n { finish_return_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 752:\n-#line 3287 \"parse.y\"\n+#line 3286 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 753:\n-#line 3293 \"parse.y\"\n+#line 3292 \"parse.y\"\n { \n \t\t  finish_asm_stmt (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE,\n \t\t\t\t   NULL_TREE); \n \t\t;\n     break;}\n case 754:\n-#line 3299 \"parse.y\"\n+#line 3298 \"parse.y\"\n { finish_asm_stmt (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE); ;\n     break;}\n case 755:\n-#line 3303 \"parse.y\"\n+#line 3302 \"parse.y\"\n { finish_asm_stmt (yyvsp[-10].ttype, yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype); ;\n     break;}\n case 756:\n-#line 3305 \"parse.y\"\n+#line 3304 \"parse.y\"\n { \n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n \t\t  finish_goto_stmt (yyvsp[-1].ttype);\n \t\t;\n     break;}\n case 757:\n-#line 3311 \"parse.y\"\n+#line 3310 \"parse.y\"\n { finish_goto_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 758:\n-#line 3313 \"parse.y\"\n+#line 3312 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 759:\n-#line 3315 \"parse.y\"\n+#line 3314 \"parse.y\"\n { error (\"label must be followed by statement\");\n \t\t  yyungetc ('}', 0);\n \t\t  finish_stmt (); ;\n     break;}\n case 760:\n-#line 3319 \"parse.y\"\n+#line 3318 \"parse.y\"\n { finish_stmt (); ;\n     break;}\n case 763:\n-#line 3323 \"parse.y\"\n+#line 3322 \"parse.y\"\n { do_local_using_decl (yyvsp[0].ttype); ;\n     break;}\n case 765:\n-#line 3329 \"parse.y\"\n+#line 3328 \"parse.y\"\n { yyval.ttype = begin_function_try_block (); ;\n     break;}\n case 766:\n-#line 3331 \"parse.y\"\n+#line 3330 \"parse.y\"\n { finish_function_try_block (yyvsp[-2].ttype); ;\n     break;}\n case 767:\n-#line 3333 \"parse.y\"\n+#line 3332 \"parse.y\"\n {\n \t\t  finish_function_handler_sequence (yyvsp[-4].ttype);\n \t\t  yyval.itype = yyvsp[-3].itype;\n \t\t;\n     break;}\n case 768:\n-#line 3341 \"parse.y\"\n+#line 3340 \"parse.y\"\n { yyval.ttype = begin_try_block (); ;\n     break;}\n case 769:\n-#line 3343 \"parse.y\"\n+#line 3342 \"parse.y\"\n { finish_try_block (yyvsp[-1].ttype); ;\n     break;}\n case 770:\n-#line 3345 \"parse.y\"\n+#line 3344 \"parse.y\"\n { finish_handler_sequence (yyvsp[-3].ttype); ;\n     break;}\n case 773:\n-#line 3355 \"parse.y\"\n+#line 3354 \"parse.y\"\n { yyval.ttype = begin_handler(); ;\n     break;}\n case 774:\n-#line 3357 \"parse.y\"\n+#line 3356 \"parse.y\"\n { finish_handler_parms (yyvsp[-1].ttype); ;\n     break;}\n case 775:\n-#line 3359 \"parse.y\"\n+#line 3358 \"parse.y\"\n { finish_handler (yyvsp[-3].ttype); ;\n     break;}\n case 778:\n-#line 3369 \"parse.y\"\n+#line 3368 \"parse.y\"\n { expand_start_catch_block (NULL_TREE, NULL_TREE); ;\n     break;}\n case 779:\n-#line 3385 \"parse.y\"\n+#line 3384 \"parse.y\"\n { check_for_new_type (\"inside exception declarations\", yyvsp[-1].ftype);\n \t\t  expand_start_catch_block (TREE_PURPOSE (yyvsp[-1].ftype.t),\n \t\t\t\t\t    TREE_VALUE (yyvsp[-1].ftype.t)); ;\n     break;}\n case 780:\n-#line 3392 \"parse.y\"\n+#line 3391 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 781:\n-#line 3394 \"parse.y\"\n+#line 3393 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 782:\n-#line 3396 \"parse.y\"\n+#line 3395 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 783:\n-#line 3398 \"parse.y\"\n+#line 3397 \"parse.y\"\n { finish_label_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 784:\n-#line 3403 \"parse.y\"\n+#line 3402 \"parse.y\"\n { finish_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 786:\n-#line 3406 \"parse.y\"\n+#line 3405 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 787:\n-#line 3415 \"parse.y\"\n+#line 3414 \"parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 788:\n-#line 3418 \"parse.y\"\n+#line 3417 \"parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 789:\n-#line 3423 \"parse.y\"\n+#line 3422 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 791:\n-#line 3426 \"parse.y\"\n+#line 3425 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 792:\n-#line 3433 \"parse.y\"\n+#line 3432 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 795:\n-#line 3440 \"parse.y\"\n+#line 3439 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 796:\n-#line 3445 \"parse.y\"\n+#line 3444 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 797:\n-#line 3450 \"parse.y\"\n+#line 3449 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 798:\n-#line 3452 \"parse.y\"\n+#line 3451 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 799:\n-#line 3463 \"parse.y\"\n+#line 3462 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 801:\n-#line 3468 \"parse.y\"\n+#line 3467 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE, yyvsp[0].ftype.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 802:\n-#line 3476 \"parse.y\"\n+#line 3475 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyval.ttype, 0); ;\n     break;}\n case 803:\n-#line 3478 \"parse.y\"\n+#line 3477 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 804:\n-#line 3481 \"parse.y\"\n+#line 3480 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 805:\n-#line 3483 \"parse.y\"\n+#line 3482 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t yyvsp[-1].ftype.t), 1); ;\n     break;}\n case 806:\n-#line 3486 \"parse.y\"\n+#line 3485 \"parse.y\"\n { yyval.ttype = finish_parmlist (NULL_TREE, 1); ;\n     break;}\n case 807:\n-#line 3488 \"parse.y\"\n+#line 3487 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7859,7 +7858,7 @@ case 807:\n \t\t;\n     break;}\n case 808:\n-#line 3498 \"parse.y\"\n+#line 3497 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7872,99 +7871,99 @@ case 808:\n \t\t;\n     break;}\n case 809:\n-#line 3513 \"parse.y\"\n+#line 3512 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 810:\n-#line 3515 \"parse.y\"\n+#line 3514 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 813:\n-#line 3526 \"parse.y\"\n+#line 3525 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 814:\n-#line 3529 \"parse.y\"\n+#line 3528 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 815:\n-#line 3532 \"parse.y\"\n+#line 3531 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 816:\n-#line 3535 \"parse.y\"\n+#line 3534 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 817:\n-#line 3537 \"parse.y\"\n+#line 3536 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 819:\n-#line 3543 \"parse.y\"\n+#line 3542 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 820:\n-#line 3553 \"parse.y\"\n+#line 3552 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 821:\n-#line 3557 \"parse.y\"\n+#line 3556 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 822:\n-#line 3560 \"parse.y\"\n+#line 3559 \"parse.y\"\n { yyval.ftype.t = build_tree_list (build_decl_list (NULL_TREE, yyvsp[-1].ftype.t),\n \t\t\t\t\t  yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 823:\n-#line 3564 \"parse.y\"\n+#line 3563 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 824:\n-#line 3568 \"parse.y\"\n+#line 3567 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 825:\n-#line 3572 \"parse.y\"\n+#line 3571 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 826:\n-#line 3579 \"parse.y\"\n+#line 3578 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 827:\n-#line 3582 \"parse.y\"\n+#line 3581 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 830:\n-#line 3593 \"parse.y\"\n+#line 3592 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 831:\n-#line 3598 \"parse.y\"\n+#line 3597 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 832:\n-#line 3603 \"parse.y\"\n+#line 3602 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -7975,192 +7974,192 @@ case 832:\n \t\t;\n     break;}\n case 833:\n-#line 3615 \"parse.y\"\n+#line 3614 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 834:\n-#line 3617 \"parse.y\"\n+#line 3616 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 835:\n-#line 3619 \"parse.y\"\n+#line 3618 \"parse.y\"\n { yyval.ttype = empty_except_spec; ;\n     break;}\n case 836:\n-#line 3624 \"parse.y\"\n+#line 3623 \"parse.y\"\n {\n \t\t  check_for_new_type (\"exception specifier\", yyvsp[0].ftype);\n \t\t  yyval.ttype = groktypename (yyvsp[0].ftype.t);\n \t\t;\n     break;}\n case 837:\n-#line 3632 \"parse.y\"\n+#line 3631 \"parse.y\"\n { yyval.ttype = add_exception_specifier (NULL_TREE, yyvsp[0].ttype, 1); ;\n     break;}\n case 838:\n-#line 3634 \"parse.y\"\n+#line 3633 \"parse.y\"\n { yyval.ttype = add_exception_specifier (yyvsp[-2].ttype, yyvsp[0].ttype, 1); ;\n     break;}\n case 839:\n-#line 3639 \"parse.y\"\n+#line 3638 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 840:\n-#line 3641 \"parse.y\"\n+#line 3640 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 841:\n-#line 3643 \"parse.y\"\n+#line 3642 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 842:\n-#line 3645 \"parse.y\"\n+#line 3644 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 843:\n-#line 3652 \"parse.y\"\n+#line 3651 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 844:\n-#line 3657 \"parse.y\"\n+#line 3656 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 845:\n-#line 3659 \"parse.y\"\n+#line 3658 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 846:\n-#line 3661 \"parse.y\"\n+#line 3660 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 847:\n-#line 3663 \"parse.y\"\n+#line 3662 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 848:\n-#line 3665 \"parse.y\"\n+#line 3664 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 849:\n-#line 3667 \"parse.y\"\n+#line 3666 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 850:\n-#line 3669 \"parse.y\"\n+#line 3668 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 851:\n-#line 3671 \"parse.y\"\n+#line 3670 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 852:\n-#line 3673 \"parse.y\"\n+#line 3672 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 853:\n-#line 3675 \"parse.y\"\n+#line 3674 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 854:\n-#line 3677 \"parse.y\"\n+#line 3676 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 855:\n-#line 3679 \"parse.y\"\n+#line 3678 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 856:\n-#line 3681 \"parse.y\"\n+#line 3680 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 857:\n-#line 3683 \"parse.y\"\n+#line 3682 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 858:\n-#line 3685 \"parse.y\"\n+#line 3684 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 859:\n-#line 3687 \"parse.y\"\n+#line 3686 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 860:\n-#line 3689 \"parse.y\"\n+#line 3688 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 861:\n-#line 3691 \"parse.y\"\n+#line 3690 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 862:\n-#line 3693 \"parse.y\"\n+#line 3692 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 863:\n-#line 3695 \"parse.y\"\n+#line 3694 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 864:\n-#line 3697 \"parse.y\"\n+#line 3696 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 865:\n-#line 3699 \"parse.y\"\n+#line 3698 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 866:\n-#line 3701 \"parse.y\"\n+#line 3700 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 867:\n-#line 3703 \"parse.y\"\n+#line 3702 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 868:\n-#line 3705 \"parse.y\"\n+#line 3704 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 869:\n-#line 3707 \"parse.y\"\n+#line 3706 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 870:\n-#line 3709 \"parse.y\"\n+#line 3708 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 871:\n-#line 3711 \"parse.y\"\n+#line 3710 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 872:\n-#line 3713 \"parse.y\"\n+#line 3712 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 873:\n-#line 3715 \"parse.y\"\n+#line 3714 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 874:\n-#line 3717 \"parse.y\"\n+#line 3716 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 875:\n-#line 3719 \"parse.y\"\n+#line 3718 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 876:\n-#line 3721 \"parse.y\"\n+#line 3720 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 877:\n-#line 3724 \"parse.y\"\n+#line 3723 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 878:\n-#line 3726 \"parse.y\"\n+#line 3725 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n@@ -8385,7 +8384,7 @@ case 878:\n     }\n   return 1;\n }\n-#line 3729 \"parse.y\"\n+#line 3728 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "f93fa612ab9d75dd37b74371939d22a836ba6176", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -3168,12 +3168,11 @@ label_decls:\n \n label_decl:\n \t  LABEL identifiers_or_typenames ';'\n-\t\t{ tree link;\n-\t\t  for (link = $2; link; link = TREE_CHAIN (link))\n+                { \n+\t\t  while ($2)\n \t\t    {\n-\t\t      tree label = shadow_label (TREE_VALUE (link));\n-\t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t\t      declare_nonlocal_label (label);\n+\t\t      finish_label_decl (TREE_VALUE ($2));\n+\t\t      $2 = TREE_CHAIN ($2);\n \t\t    }\n \t\t}\n \t;"}, {"sha": "bb3429612076c15b50d4bc10a8cfaf231afc0b8c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -7264,18 +7264,23 @@ tsubst_expr (t, args, complain, in_decl)\n \n \tlineno = STMT_LINENO (t);\n \tdecl = DECL_STMT_DECL (t);\n-\tinit = DECL_INITIAL (decl);\n-\tdecl = tsubst (decl, args, complain, in_decl);\n-\tinit = tsubst_expr (init, args, complain, in_decl);\n-\tDECL_INITIAL (decl) = init;\n-\t/* By marking the declaration as instantiated, we avoid trying\n+\tif (TREE_CODE (decl) == LABEL_DECL)\n+\t  finish_label_decl (DECL_NAME (decl));\n+\telse\n+\t  {\n+\t    init = DECL_INITIAL (decl);\n+\t    decl = tsubst (decl, args, complain, in_decl);\n+\t    init = tsubst_expr (init, args, complain, in_decl);\n+\t    DECL_INITIAL (decl) = init;\n+\t    /* By marking the declaration as instantiated, we avoid trying\n \t   to instantiate it.  Since instantiate_decl can't handle\n \t   local variables, and since we've already done all that\n \t   needs to be done, that's the right thing to do.  */\n-\tif (TREE_CODE (decl) == VAR_DECL)\n-\t  DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n-\tmaybe_push_decl (decl);\n-\tadd_decl_stmt (decl);\n+\t    if (TREE_CODE (decl) == VAR_DECL)\n+\t      DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n+\t    maybe_push_decl (decl);\n+\t    add_decl_stmt (decl);\n+\t  }\n \tresume_momentary (i);\n \treturn decl;\n       }\n@@ -7392,10 +7397,9 @@ tsubst_expr (t, args, complain, in_decl)\n \t\t\t tsubst_expr (CASE_HIGH (t), args, complain, in_decl));\n       break;\n \n-    case LABEL_DECL:\n-      lineno = DECL_SOURCE_LINE (t);\n-      input_filename = DECL_SOURCE_FILE (t);\n-      finish_label_stmt (DECL_NAME (t));\n+    case LABEL_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_label_stmt (DECL_NAME (LABEL_STMT_LABEL (t)));\n       break;\n \n     case GOTO_STMT:"}, {"sha": "382258b3b89fd31d9bbeba70097f160b3de4fe1a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -919,11 +919,24 @@ finish_label_stmt (name)\n   tree decl = define_label (input_filename, lineno, name);\n \n   if (building_stmt_tree ())\n-    add_tree (decl);\n+    add_tree (build_min_nt (LABEL_STMT, decl));\n   else if (decl)\n     expand_label (decl);\n }\n \n+/* Finish a series of declarations for local labels.  G++ allows users\n+   to declare \"local\" labels, i.e., labels with scope.  This extension\n+   is useful when writing code involving statement-expressions.  */\n+\n+void\n+finish_label_decl (name)\n+     tree name;\n+{\n+  tree decl = declare_local_label (name);\n+  if (building_stmt_tree ())\n+    add_decl_stmt (decl);\n+}\n+\n /* Create a declaration statement for the declaration given by the\n    DECL.  */\n \n@@ -2019,17 +2032,22 @@ expand_stmt (t)\n \tlineno = STMT_LINENO (t);\n \temit_line_note (input_filename, lineno);\n \tdecl = DECL_STMT_DECL (t);\n-\t/* We need to clear DECL_CONTEXT so that maybe_push_decl\n-\t   will push it into the current scope.  */\n-\tif (DECL_CONTEXT (decl) == current_function_decl)\n-\t  DECL_CONTEXT (decl) = NULL_TREE;\n-\t/* If we marked this variable as dead when we processed it\n-\t   before, we must undo that now.  The variable has been\n-\t   resuscitated.  */\n-\tif (TREE_CODE (decl) == VAR_DECL)\n-\t  DECL_DEAD_FOR_LOCAL (decl) = 0;\n-\tmaybe_push_decl (decl);\n-\tcp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0, 0);\n+\tif (TREE_CODE (decl) == LABEL_DECL)\n+\t  finish_label_decl (DECL_NAME (decl));\n+\telse\n+\t  {\n+\t    /* We need to clear DECL_CONTEXT so that maybe_push_decl\n+\t       will push it into the current scope.  */\n+\t    if (DECL_CONTEXT (decl) == current_function_decl)\n+\t      DECL_CONTEXT (decl) = NULL_TREE;\n+\t    /* If we marked this variable as dead when we processed it\n+\t       before, we must undo that now.  The variable has been\n+\t       resuscitated.  */\n+\t    if (TREE_CODE (decl) == VAR_DECL)\n+\t      DECL_DEAD_FOR_LOCAL (decl) = 0;\n+\t    maybe_push_decl (decl);\n+\t    cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0, 0);\n+\t  }\n \tresume_momentary (i);\n       }\n       break;\n@@ -2119,15 +2137,17 @@ expand_stmt (t)\n       finish_case_label (CASE_LOW (t), CASE_HIGH (t));\n       break;\n \n-    case LABEL_DECL:\n-      input_filename = DECL_SOURCE_FILE (t);\n-      lineno = DECL_SOURCE_LINE (t);\n-      finish_label_stmt (DECL_NAME (t));\n+    case LABEL_STMT:\n+      lineno = STMT_LINENO (t);\n+      finish_label_stmt (DECL_NAME (LABEL_STMT_LABEL (t)));\n       break;\n \n     case GOTO_STMT:\n       lineno = STMT_LINENO (t);\n-      finish_goto_stmt (GOTO_DESTINATION (t));\n+      if (TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL)\n+\tfinish_goto_stmt (DECL_NAME (GOTO_DESTINATION (t)));\n+      else\n+\tfinish_goto_stmt (GOTO_DESTINATION (t));\n       break;\n \n     case ASM_STMT:"}, {"sha": "e7327b4b9d1f0142b35b9aa1a5dc7d991c31770e", "filename": "gcc/testsuite/g++.old-deja/g++.ext/label1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Flabel1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Flabel1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Flabel1.C?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -0,0 +1,27 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options:\n+\n+int main ()\n+{\n+  int i = 0;\n+  int j = 0;\n+  int k = 0;\n+\n+ l:\n+  if (j)\n+    return 0;\n+  ({\n+    __label__ l; \n+    k = 0;\n+  l: \n+    if (++k <= 2)\n+      goto l;\n+    ++i;});\n+  if (i > 1 || k != 3)\n+    return 1;\n+  else\n+    {\n+      j = 1;\n+      goto l;\n+    }\n+}"}, {"sha": "891b89b10db2089f45a3121ecbc330aa220de4c1", "filename": "gcc/testsuite/g++.old-deja/g++.ext/label2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Flabel2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Flabel2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Flabel2.C?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -0,0 +1,34 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options:\n+\n+template <class T>\n+int f ()\n+{\n+  int i = 0;\n+  int j = 0;\n+  int k = 0;\n+\n+ l:\n+  if (j)\n+    return 0;\n+  ({\n+    __label__ l; \n+    k = 0;\n+  l: \n+    if (++k <= 2)\n+      goto l;\n+    ++i;});\n+  if (i > 1 || k != 3)\n+    return 1;\n+  else\n+    {\n+      j = 1;\n+      goto l;\n+    }\n+}\n+\n+int main ()\n+{\n+  return f<double>();\n+}\n+"}, {"sha": "a51348654c276b22cb066d2d8dcb6c257ce6b149", "filename": "gcc/testsuite/g++.old-deja/g++.pt/goto2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fgoto2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef433b61b5e8001133d37e66250c2f0ab2a042/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fgoto2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fgoto2.C?ref=acef433b61b5e8001133d37e66250c2f0ab2a042", "patch": "@@ -0,0 +1,17 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+int i = 1;\n+\n+template <class T> void test()\n+{\n+  goto lab;\n+ lab: \n+  --i;\n+}\n+\n+int main ()\n+{\n+  test<int>();\n+  return i;\n+}"}]}