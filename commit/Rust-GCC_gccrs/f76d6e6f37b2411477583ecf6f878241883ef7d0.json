{"sha": "f76d6e6f37b2411477583ecf6f878241883ef7d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2ZDZlNmYzN2IyNDExNDc3NTgzZWNmNmY4NzgyNDE4ODNlZjdkMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-08-25T15:02:19Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-08-25T15:02:19Z"}, "message": "gimplify.c (prepare_gimple_addressable): New static function.\n\n\t* gimplify.c (prepare_gimple_addressable): New static function.\n\t(gimplify_modify_expr_to_memcpy): Invoke it on the RHS before marking\n\tit addressable.\n\t(gimplify_addr_expr): Invoke it similarly on the operand instead of\n\tmanually fiddling with it.\nada/\n\t* gcc-interface/trans.c (call_to_gnu): Tidy.\n\t(gnat_to_gnu) <N_Slice>: Set TYPE_ARRAY_MAX_SIZE if the slice has\n\tnon-constant size but the array itself has constant size.\n\t* gcc-interface/utils.c (convert_vms_descriptor64): Fix type\n\tconsistency error.\n\t(convert_vms_descriptor32): Likewise.\n\nFrom-SVN: r151082", "tree": {"sha": "f7857a6dd43c7cecbaa9c1e23de6832efeed3ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7857a6dd43c7cecbaa9c1e23de6832efeed3ba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f76d6e6f37b2411477583ecf6f878241883ef7d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76d6e6f37b2411477583ecf6f878241883ef7d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f76d6e6f37b2411477583ecf6f878241883ef7d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76d6e6f37b2411477583ecf6f878241883ef7d0/comments", "author": null, "committer": null, "parents": [{"sha": "23878536a6b359865599d300c214bbb8fef83a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23878536a6b359865599d300c214bbb8fef83a43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23878536a6b359865599d300c214bbb8fef83a43"}], "stats": {"total": 125, "additions": 106, "deletions": 19}, "files": [{"sha": "c981d54f03cb7495d95268b4713e73e6febc009a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -1,3 +1,11 @@\n+2009-08-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimplify.c (prepare_gimple_addressable): New static function.\n+\t(gimplify_modify_expr_to_memcpy): Invoke it on the RHS before marking\n+\tit addressable.\n+\t(gimplify_addr_expr): Invoke it similarly on the operand instead of\n+\tmanually fiddling with it.\n+\n 2009-08-25  Michael Matz  <matz@suse.de>\n \n \t* expr.h (jumpifnot_1, jumpif_1, do_jump_1): Declare."}, {"sha": "ede9b4da10138555ebd3940e6eadab35b18348e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -1,3 +1,12 @@\n+2009-08-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (call_to_gnu): Tidy.\n+\t(gnat_to_gnu) <N_Slice>: Set TYPE_ARRAY_MAX_SIZE if the slice has\n+\tnon-constant size but the array itself has constant size.\n+\t* gcc-interface/utils.c (convert_vms_descriptor64): Fix type\n+\tconsistency error.\n+\t(convert_vms_descriptor32): Likewise.\n+\n 2009-08-22  Aurelien Jarno  <aurelien@aurel32.net>\n \n \t* gcc-interface/Makefile.in: Add Ada support for "}, {"sha": "7333f8c7b4b61900936106eee00cc9428a6a349a", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -2506,7 +2506,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n \t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n-\t  tree gnu_copy = gnu_name, gnu_temp;\n+\t  tree gnu_copy = gnu_name;\n \n \t  /* If the type is by_reference, a copy is not allowed.  */\n \t  if (Is_By_Reference_Type (Etype (gnat_formal)))\n@@ -2569,10 +2569,10 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  /* Set up to move the copy back to the original.  */\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n-\t      gnu_temp = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_copy,\n-\t\t\t\t\t  gnu_name);\n-\t      set_expr_location_from_node (gnu_temp, gnat_node);\n-\t      append_to_statement_list (gnu_temp, &gnu_after_list);\n+\t      tree stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_copy,\n+\t\t\t\t\t   gnu_name);\n+\t      set_expr_location_from_node (stmt, gnat_node);\n+\t      append_to_statement_list (stmt, &gnu_after_list);\n \t    }\n \t}\n \n@@ -3889,8 +3889,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Slice:\n       {\n-\ttree gnu_type;\n \tNode_Id gnat_range_node = Discrete_Range (gnat_node);\n+\ttree gnu_type;\n \n \tgnu_result = gnat_to_gnu (Prefix (gnat_node));\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -3963,6 +3963,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  /* Simply return the naked low bound.  */\n \t  gnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n \n+\t/* If this is a slice with non-constant size of an array with constant\n+\t   size, set the maximum size for the allocation of temporaries.  */\n+\tif (!TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_result_type))\n+\t    && TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_type)))\n+\t  TYPE_ARRAY_MAX_SIZE (gnu_result_type) = TYPE_SIZE_UNIT (gnu_type);\n+\n \tgnu_result = build_binary_op (ARRAY_RANGE_REF, gnu_result_type,\n \t\t\t\t      gnu_result, gnu_expr);\n       }"}, {"sha": "9748caf546335fc5e91b75bf8cd9157262871cee", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -3244,7 +3244,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t\t\t tree_cons (TREE_CHAIN (TYPE_FIELDS (template_type)),\n                                     ufield, NULL_TREE));\n \t  template_tree = gnat_build_constructor (template_type, t);\n-\t  template_tree = build3 (COND_EXPR, p_bounds_type, u,\n+\t  template_tree = build3 (COND_EXPR, template_type, u,\n \t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n \t\t\t    template_tree);\n@@ -3365,7 +3365,7 @@ convert_vms_descriptor32 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (t))));\n \t  template_tree\n \t    = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n-\t  template_tree = build3 (COND_EXPR, p_bounds_type, u,\n+\t  template_tree = build3 (COND_EXPR, TREE_TYPE (t), u,\n \t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n \t\t\t    template_tree);"}, {"sha": "bdb64ea88c892543a7e639a41859b86810d20ba9", "filename": "gcc/gimplify.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -3095,6 +3095,25 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n   return ret;\n }\n \n+/* Prepare the node pointed to by EXPR_P, an is_gimple_addressable expression,\n+   to be marked addressable.\n+\n+   We cannot rely on such an expression being directly markable if a temporary\n+   has been created by the gimplification.  In this case, we create another\n+   temporary and initialize it with a copy, which will become a store after we\n+   mark it addressable.  This can happen if the front-end passed us something\n+   that it could not mark addressable yet, like a Fortran pass-by-reference\n+   parameter (int) floatvar.  */\n+\n+static void\n+prepare_gimple_addressable (tree *expr_p, gimple_seq *seq_p)\n+{\n+  while (handled_component_p (*expr_p))\n+    expr_p = &TREE_OPERAND (*expr_p, 0);\n+  if (is_gimple_reg (*expr_p))\n+    *expr_p = get_initialized_tmp_var (*expr_p, seq_p, NULL);\n+}\n+\n /* A subroutine of gimplify_modify_expr.  Replace a MODIFY_EXPR with\n    a call to __builtin_memcpy.  */\n \n@@ -3109,6 +3128,10 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n   to = TREE_OPERAND (*expr_p, 0);\n   from = TREE_OPERAND (*expr_p, 1);\n \n+  /* Mark the RHS addressable.  Beware that it may not be possible to do so\n+     directly if a temporary has been created by the gimplification.  */\n+  prepare_gimple_addressable (&from, seq_p);\n+\n   mark_addressable (from);\n   from_ptr = build_fold_addr_expr_loc (loc, from);\n   gimplify_arg (&from_ptr, seq_p, loc);\n@@ -4685,22 +4708,15 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t gcc.dg/c99-array-lval-1.c.  The gimplifier will correctly make\n \t the implied temporary explicit.  */\n \n-      /* Mark the RHS addressable.  */\n+      /* Make the operand addressable.  */\n       ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, post_p,\n \t\t\t   is_gimple_addressable, fb_either);\n       if (ret == GS_ERROR)\n \tbreak;\n \n-      /* We cannot rely on making the RHS addressable if it is\n-\t a temporary created by gimplification.  In this case create a\n-\t new temporary that is initialized by a copy (which will\n-\t become a store after we mark it addressable).\n-\t This mostly happens if the frontend passed us something that\n-\t it could not mark addressable yet, like a fortran\n-\t pass-by-reference parameter (int) floatvar.  */\n-      if (is_gimple_reg (TREE_OPERAND (expr, 0)))\n-\tTREE_OPERAND (expr, 0)\n-\t  = get_initialized_tmp_var (TREE_OPERAND (expr, 0), pre_p, post_p);\n+      /* Then mark it.  Beware that it may not be possible to do so directly\n+\t if a temporary has been created by the gimplification.  */\n+      prepare_gimple_addressable (&TREE_OPERAND (expr, 0), pre_p);\n \n       op0 = TREE_OPERAND (expr, 0);\n "}, {"sha": "7cfcccd1752df8053f292d8eeefb3ec36a8b0b33", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -1,3 +1,8 @@\n+2009-08-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/slice7.adb: New test.\n+\t* gnat.dg/slice7_pkg.ads: New helper.\n+\n 2009-08-25  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/41139"}, {"sha": "3f0d3f5b3fc94bb8feaa110b37c2dbfe96242aab", "filename": "gcc/testsuite/gnat.dg/slice7.adb", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Ftestsuite%2Fgnat.dg%2Fslice7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Ftestsuite%2Fgnat.dg%2Fslice7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fslice7.adb?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -0,0 +1,36 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+with System.Storage_Elements; use System.Storage_Elements;\n+with Unchecked_Conversion;\n+with Slice7_Pkg; use Slice7_Pkg;\n+\n+procedure Slice7 is\n+\n+  type Discrete_Type is range 1 .. 32;\n+\n+  Max_Byte_Count : constant := 4;\n+  subtype Byte_Count_Type is Storage_Offset range 1..Max_Byte_Count;\n+\n+  subtype Buffer_Type is Storage_Array (Byte_Count_Type);\n+  function Convert_Put is new Unchecked_Conversion (Integer, Buffer_Type);\n+\n+  function Set_Buffer_Size return Byte_Count_Type is\n+  begin\n+    return 4;\n+  end;\n+\n+  Buffer_Size  : constant Byte_Count_Type := Set_Buffer_Size;\n+  Buffer_End   : constant Byte_Count_Type := Max_Byte_Count;\n+  Buffer_Start : constant Byte_Count_Type := Buffer_End - Buffer_Size + 1;\n+\n+  Obj : Discrete_Type;\n+\n+begin\n+  Put (Convert_Put(Discrete_Type'Pos (Obj))\n+       (Buffer_Start..Buffer_End));\n+\n+  Put (Convert_Put(Discrete_Type'Pos (Obj) -\n+                   Discrete_Type'Pos (Discrete_Type'First))\n+       (Buffer_Start..Buffer_End));\n+end;"}, {"sha": "3c2f4a177c7d8328958d61a7cbc47e9d2fdb5c85", "filename": "gcc/testsuite/gnat.dg/slice7_pkg.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Ftestsuite%2Fgnat.dg%2Fslice7_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f76d6e6f37b2411477583ecf6f878241883ef7d0/gcc%2Ftestsuite%2Fgnat.dg%2Fslice7_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fslice7_pkg.ads?ref=f76d6e6f37b2411477583ecf6f878241883ef7d0", "patch": "@@ -0,0 +1,7 @@\n+with System.Storage_Elements; use System.Storage_Elements;\n+\n+package Slice7_Pkg is\n+\n+  procedure Put (The_Object : in Storage_Array);\n+\n+end Slice7_Pkg;"}]}