{"sha": "b7fb9feb713f47d880d251ff1323e40fc37c14c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdmYjlmZWI3MTNmNDdkODgwZDI1MWZmMTMyM2U0MGZjMzdjMTRjNw==", "commit": {"author": {"name": "Turly O'Connor", "email": "turly@gcc.gnu.org", "date": "2001-12-21T10:44:50Z"}, "committer": {"name": "Turly O'Connor", "email": "turly@gcc.gnu.org", "date": "2001-12-21T10:44:50Z"}, "message": "darwin.c (machopic_classify_ident): Handle \"stale\" section- encoded name problem to avoid generating illegal stubs.\n\n\t* darwin.c (machopic_classify_ident): Handle \"stale\" section-\n\tencoded name problem to avoid generating illegal stubs.\n\t(func_name_maybe_scoped): Remove, not needed for gcc3.\n\t(machopic_indirect_call_target): Don't use it.\n\t(darwin_encode_section_info): Call only one of update_stubs()\n\tor update_non_lazy_ptrs() as DECL cannot be both.\n\t(machopic_output_possible_stub_label): New.\n\t* darwin.h (ASM_DECLARE_FUNCTION_NAME): Use it.\n\t* darwin-protos.h (machopic_output_possible_stub_label): Declare.\n\nFrom-SVN: r48238", "tree": {"sha": "120a1e8484f0b9ff624971bd8e0d3f9c36263e6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/120a1e8484f0b9ff624971bd8e0d3f9c36263e6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7fb9feb713f47d880d251ff1323e40fc37c14c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fb9feb713f47d880d251ff1323e40fc37c14c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7fb9feb713f47d880d251ff1323e40fc37c14c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fb9feb713f47d880d251ff1323e40fc37c14c7/comments", "author": null, "committer": null, "parents": [{"sha": "a00b07c5e5c9423dd3ae9bb62284c235bffe8daa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a00b07c5e5c9423dd3ae9bb62284c235bffe8daa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a00b07c5e5c9423dd3ae9bb62284c235bffe8daa"}], "stats": {"total": 140, "additions": 65, "deletions": 75}, "files": [{"sha": "0bff1308d0130eae62756773f82a3225b8d4a695", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fb9feb713f47d880d251ff1323e40fc37c14c7/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fb9feb713f47d880d251ff1323e40fc37c14c7/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=b7fb9feb713f47d880d251ff1323e40fc37c14c7", "patch": "@@ -64,6 +64,8 @@ extern void darwin_encode_section_info PARAMS ((tree));\n \n extern void machopic_finish PARAMS ((FILE *));\n \n+extern void machopic_output_possible_stub_label PARAMS ((FILE *, const char*));\n+\n extern void darwin_exception_section PARAMS ((void));\n extern void darwin_eh_frame_section PARAMS ((void));\n "}, {"sha": "8e617e9aa82fc5dfb2b1cf9887aeaba797e0bcbb", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 60, "deletions": 75, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fb9feb713f47d880d251ff1323e40fc37c14c7/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fb9feb713f47d880d251ff1323e40fc37c14c7/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=b7fb9feb713f47d880d251ff1323e40fc37c14c7", "patch": "@@ -118,6 +118,22 @@ machopic_classify_ident (ident)\n   else if (name[1] == 'T')\n     return MACHOPIC_DEFINED_FUNCTION;\n \n+  /* It is possible that someone is holding a \"stale\" name, which has\n+     since been defined.  See if there is a \"defined\" name (i.e,\n+     different from NAME only in having a '!D_' or a '!T_' instead of\n+     a '!d_' or '!t_' prefix) in the identifier hash tables.  If so, say\n+     that this identifier is defined.  */\n+  else if (name[1] == 'd' || name[1] == 't')\n+    {\n+      char *new_name;\n+      new_name = (char *)alloca (strlen (name) + 1);\n+      strcpy (new_name, name);\n+      new_name[1] = (name[1] == 'd') ? 'D' : 'T';\n+      if (maybe_get_identifier (new_name) != NULL)\n+\treturn  (name[1] == 'd') ? MACHOPIC_DEFINED_DATA\n+\t\t\t\t : MACHOPIC_DEFINED_FUNCTION;\n+    }\n+\n   for (temp = machopic_defined_list; temp != NULL_TREE; temp = TREE_CHAIN (temp))\n     {\n       if (ident == TREE_VALUE (temp))\n@@ -527,78 +543,6 @@ machopic_indirect_data_reference (orig, reg)\n   return ptr_ref;\n }\n \n-/* For MACHOPIC_INDIRECT_CALL_TARGET below, we need to beware of:\n-\n-\textern \"C\" { int f(); }\n-\tstruct X { int f(); int g(); };\n-\tint X::f() { ::f(); }\n-\tint X::g() { ::f(); f();}\n-\n-  This is hairy.  Both calls to \"::f()\" need to be indirect (i.e., to\n-  appropriate symbol stubs), but since MACHOPIC_NAME_DEFINED_P calls\n-  GET_IDENTIFIER which treats \"f\" as \"X::f\", and \"X::f\" is indeed (being)\n-  defined somewhere in \"X\"'s inheritance hierarchy, MACHOPIC_NAME_DEFINED_P\n-  returns TRUE when called with \"f\", which means that\n-  MACHOPIC_INDIRECT_CALL_TARGET uses an \"internal\" call instead of an\n-  indirect one as it should.\n-\n-  Our quick-n-dirty solution to this is to call the following\n-  FUNC_NAME_MAYBE_SCOPED routine which (only for C++) checks whether\n-  FNAME -- the name of the function which we're calling -- is NOT a\n-  mangled C++ name, AND if the current function being compiled is a\n-  method, and if so, use an \"external\" or \"indirect\" call. \n-\n-  Note that this function will be called ONLY when MACHOPIC_INDIRECT_TARGET_P\n-  has already indicated that the target is NOT indirect.\n-\n-  This conservative solution will sometimes make indirect calls where\n-  it might have been possible to make direct ones.\n-\n-  FUNC_NAME_MAYBE_SCOPED returns 1 to indicate a \"C\" name (not scoped),\n-  which in turns means we should create a stub for an indirect call.\n-  */\n-\n-static int is_cplusplus = -1;\n-\n-static int\n-func_name_maybe_scoped (fname)\n-     const char *fname;\n-{\n-\n-  if (is_cplusplus < 0)\n-    is_cplusplus = (strcmp (lang_hooks.name, \"GNU C++\") == 0);\n-\n-  if (is_cplusplus)\n-    {\n-      /* If we have a method, then check whether the function we're trying to\n-         call is a \"C\" function.  If so, we should use an indirect call.\n-\n-         It turns out to be hard to tell whether \"we have a method\", since\n-         static member functions have a TREE_CODE of FUNCTION_TYPE, as do\n-         namespace-level non-member functions.  So here, we always look for\n-         an extern-\"C\"-like name, and make stubs for them no matter the\n-         calling context.  This is temporary, and leaves nagging suspicion\n-\t that improvements should be possible here.  (I.e., I suspect that\n-         it can still sometimes make stubs where it needn't.)  */\n-\n-      /* if (1 || TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE) */\n-\t{\n-\t  /* If fname is of the form \"f__1X\" or \"f__Fv\", it's C++.  */\n-\t  while (*fname == '_') ++fname;\t/* skip leading underscores  */\n-\t  while (*fname != 0)\n-\t    {\n-\t      if (fname[0] == '_' && fname[1] == '_'\n-\t\t  && (fname[2] == 'F' || ISDIGIT (fname[2])))\n-\t\treturn 0;\n-\t      ++fname;\n-\t    }\n-\t  /* Not a C++ mangled name: must be \"C\", in which case play safe.  */\n-\t  return 1;\n-\t}\n-    }\n-  return 0;\n-}\n-\n /* Transform TARGET (a MEM), which is a function call target, to the\n    corresponding symbol_stub if necessary.  Return a new MEM.  */\n \n@@ -614,7 +558,11 @@ machopic_indirect_call_target (target)\n       enum machine_mode mode = GET_MODE (XEXP (target, 0));\n       const char *name = XSTR (XEXP (target, 0), 0);\n \n-      if (!machopic_name_defined_p (name) || func_name_maybe_scoped (name)) \n+      /* If the name is already defined, we need do nothing.  */\n+      if (name[0] == '!' && name[1] == 'T')\n+\treturn target;\n+\n+      if (!machopic_name_defined_p (name))\n \t{\n \t  const char *stub_name = machopic_stub_name (name);\n \n@@ -894,6 +842,10 @@ machopic_finish (asm_out_file)\n       if (! TREE_USED (temp))\n \tcontinue;\n \n+      /* If the symbol is actually defined, we don't need a stub.  */\n+      if (sym_name[0] == '!' && sym_name[1] == 'T')\n+\tcontinue;\n+\n       STRIP_NAME_ENCODING (sym_name, sym_name);\n \n       sym = alloca (strlen (sym_name) + 2);\n@@ -1056,8 +1008,10 @@ darwin_encode_section_info (decl)\n     }\n   /* The non-lazy pointer list may have captured references to the\n      old encoded name, change them.  */\n-  update_non_lazy_ptrs (XSTR (sym_ref, 0));\n-  update_stubs (XSTR (sym_ref, 0));\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    update_non_lazy_ptrs (XSTR (sym_ref, 0));\n+  else\n+    update_stubs (XSTR (sym_ref, 0));\n }\n \n /* Scan the list of non-lazy pointers and update any recorded names whose\n@@ -1090,6 +1044,37 @@ update_non_lazy_ptrs (name)\n     }\n }\n \n+/* Function NAME is being defined, and its label has just been output.\n+   If there's already a reference to a stub for this function, we can\n+   just emit the stub label now and we don't bother emitting the stub later. */\n+\n+void\n+machopic_output_possible_stub_label (file, name)\n+     FILE *file;\n+     const char *name;\n+{\n+  tree temp;\n+\n+\n+  /* Ensure we're looking at a section-encoded name.  */\n+  if (name[0] != '!' || (name[1] != 't' && name[1] != 'T'))\n+    return;\n+\n+  for (temp = machopic_stubs;\n+       temp != NULL_TREE;\n+       temp = TREE_CHAIN (temp))\n+    {\n+      const char *sym_name;\n+\n+      sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n+      if (sym_name[0] == '!' && sym_name[1] == 'T'\n+\t  && ! strcmp (name+2, sym_name+2))\n+\t{\n+\t  ASM_OUTPUT_LABEL (file, IDENTIFIER_POINTER (TREE_PURPOSE (temp)));\n+\t  break;\n+\t}\n+    }\n+}\n \n /* Scan the list of stubs and update any recorded names whose\n    stripped name matches the argument.  */"}, {"sha": "3ee493daac79d122eaeb0b57ce4f2e3ac6b9dfd1", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fb9feb713f47d880d251ff1323e40fc37c14c7/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fb9feb713f47d880d251ff1323e40fc37c14c7/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=b7fb9feb713f47d880d251ff1323e40fc37c14c7", "patch": "@@ -232,6 +232,9 @@ do { text_section ();\t\t\t\t\t\t\t\\\n         || DECL_INITIAL (DECL))                                         \\\n       ENCODE_SECTION_INFO (DECL);\t\t\t\t\t\\\n     ASM_OUTPUT_LABEL (FILE, xname);                                     \\\n+    /* Avoid generating stubs for functions we've just defined by\t\\\n+       outputting any required stub name label now.  */\t\t\t\\\n+    machopic_output_possible_stub_label (FILE, xname);\t\t\t\\\n   } while (0)\n \n /* Wrap new method names in quotes so the assembler doesn't gag."}]}