{"sha": "b5e04de5e321eef54e6d85d155981fdbbdd09428", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlMDRkZTVlMzIxZWVmNTRlNmQ4NWQxNTU5ODFmZGJiZGQwOTQyOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-11T12:45:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-11T12:45:00Z"}, "message": "gimple.c (gimple_type_hash_1): Merge with ...\n\n2011-05-11  Richard Guenther  <rguenther@suse.de>\n\n\t* gimple.c (gimple_type_hash_1): Merge with ...\n\t(gimple_type_hash): ... this.\n\t(gtc_visit): Remove mode parameter and simplify accordingly.\n\t(gimple_types_compatible_p_1): Likewise.\n\t(gimple_types_compatible_p): Likewise.\n\t(iterative_hash_gimple_type): Likewise.\n\t(visit): Likewise.\n\t(gimple_type_eq): Adjust.\n\nFrom-SVN: r173655", "tree": {"sha": "3f8d691961579dff9e878f2f3c3db8453e0ea587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f8d691961579dff9e878f2f3c3db8453e0ea587"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5e04de5e321eef54e6d85d155981fdbbdd09428", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e04de5e321eef54e6d85d155981fdbbdd09428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5e04de5e321eef54e6d85d155981fdbbdd09428", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e04de5e321eef54e6d85d155981fdbbdd09428/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc6970e432491e8bd0451c69bdca14985ccbe8df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc6970e432491e8bd0451c69bdca14985ccbe8df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc6970e432491e8bd0451c69bdca14985ccbe8df"}], "stats": {"total": 194, "additions": 75, "deletions": 119}, "files": [{"sha": "5b7408b3fff38ca7c4d1309555c3204b4b23a30a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e04de5e321eef54e6d85d155981fdbbdd09428/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e04de5e321eef54e6d85d155981fdbbdd09428/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5e04de5e321eef54e6d85d155981fdbbdd09428", "patch": "@@ -1,3 +1,14 @@\n+2011-05-11  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gimple.c (gimple_type_hash_1): Merge with ...\n+\t(gimple_type_hash): ... this.\n+\t(gtc_visit): Remove mode parameter and simplify accordingly.\n+\t(gimple_types_compatible_p_1): Likewise.\n+\t(gimple_types_compatible_p): Likewise.\n+\t(iterative_hash_gimple_type): Likewise.\n+\t(visit): Likewise.\n+\t(gimple_type_eq): Adjust.\n+\n 2011-05-11  Revital Eres  <revital.eres@linaro.org>\n \n \t* ddg.c (create_ddg_dep_from_intra_loop_link): If a true dep edge"}, {"sha": "4f9a145074b76f81586a52c8791fa9314d5faa86", "filename": "gcc/gimple.c", "status": "modified", "additions": 64, "deletions": 119, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e04de5e321eef54e6d85d155981fdbbdd09428/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e04de5e321eef54e6d85d155981fdbbdd09428/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=b5e04de5e321eef54e6d85d155981fdbbdd09428", "patch": "@@ -3210,7 +3210,7 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n \n enum gtc_mode { GTC_MERGE = 0, GTC_DIAG = 1 };\n \n-static hashval_t gimple_type_hash_1 (const void *, enum gtc_mode);\n+static hashval_t gimple_type_hash (const void *);\n \n /* Structure used to maintain a cache of some type pairs compared by\n    gimple_types_compatible_p when comparing aggregate types.  There are\n@@ -3459,7 +3459,7 @@ gimple_compatible_complete_and_incomplete_subtype_p (tree t1, tree t2)\n }\n \n static bool\n-gimple_types_compatible_p_1 (tree, tree, enum gtc_mode, type_pair_t,\n+gimple_types_compatible_p_1 (tree, tree, type_pair_t,\n \t\t\t     VEC(type_pair_t, heap) **,\n \t\t\t     struct pointer_map_t *, struct obstack *);\n \n@@ -3470,7 +3470,7 @@ gimple_types_compatible_p_1 (tree, tree, enum gtc_mode, type_pair_t,\n    SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n \n static bool\n-gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n+gtc_visit (tree t1, tree t2,\n \t   struct sccs *state,\n \t   VEC(type_pair_t, heap) **sccstack,\n \t   struct pointer_map_t *sccstate,\n@@ -3479,6 +3479,7 @@ gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n   struct sccs *cstate = NULL;\n   type_pair_t p;\n   void **slot;\n+  tree leader1, leader2;\n \n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n@@ -3490,21 +3491,12 @@ gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n \n   /* If the types have been previously registered and found equal\n      they still are.  */\n-  if (mode == GTC_MERGE)\n-    {\n-      tree leader1 = gimple_lookup_type_leader (t1);\n-      tree leader2 = gimple_lookup_type_leader (t2);\n-      if (leader1 == t2\n-\t  || t1 == leader2\n-\t  || (leader1 && leader1 == leader2))\n-\treturn true;\n-    }\n-  else if (mode == GTC_DIAG)\n-    {\n-      if (TYPE_CANONICAL (t1)\n-\t  && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-\treturn true;\n-    }\n+  leader1 = gimple_lookup_type_leader (t1);\n+  leader2 = gimple_lookup_type_leader (t2);\n+  if (leader1 == t2\n+      || t1 == leader2\n+      || (leader1 && leader1 == leader2))\n+    return true;\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n@@ -3558,24 +3550,24 @@ gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n      small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash_1 (t1, mode) != gimple_type_hash_1 (t2, mode))\n+  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n     return false;\n \n   /* Allocate a new cache entry for this comparison.  */\n   p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n-  if (p->same_p[mode] == 0 || p->same_p[mode] == 1)\n+  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n \t same, return the cached result.  */\n-      return p->same_p[mode] == 1;\n+      return p->same_p[GTC_MERGE] == 1;\n     }\n \n   if ((slot = pointer_map_contains (sccstate, p)) != NULL)\n     cstate = (struct sccs *)*slot;\n   /* Not yet visited.  DFS recurse.  */\n   if (!cstate)\n     {\n-      gimple_types_compatible_p_1 (t1, t2, mode, p,\n+      gimple_types_compatible_p_1 (t1, t2, p,\n \t\t\t\t   sccstack, sccstate, sccstate_obstack);\n       cstate = (struct sccs *)* pointer_map_contains (sccstate, p);\n       state->low = MIN (state->low, cstate->low);\n@@ -3595,15 +3587,14 @@ gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n    SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n \n static bool\n-gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n-\t\t\t     type_pair_t p,\n+gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n \t\t\t     VEC(type_pair_t, heap) **sccstack,\n \t\t\t     struct pointer_map_t *sccstate,\n \t\t\t     struct obstack *sccstate_obstack)\n {\n   struct sccs *state;\n \n-  gcc_assert (p->same_p[mode] == -2);\n+  gcc_assert (p->same_p[GTC_MERGE] == -2);\n \n   state = XOBNEW (sccstate_obstack, struct sccs);\n   *pointer_map_insert (sccstate, p) = state;\n@@ -3625,15 +3616,15 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n     {\n     case VECTOR_TYPE:\n     case COMPLEX_TYPE:\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n \t\t      state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n       goto same_types;\n \n     case ARRAY_TYPE:\n       /* Array types are the same if the element types are the same and\n \t the number of elements are the same.  */\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n \t\t      state, sccstack, sccstate, sccstate_obstack)\n \t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n \t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n@@ -3683,19 +3674,16 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n     case METHOD_TYPE:\n       /* Method types should belong to the same class.  */\n       if (!gtc_visit (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2),\n-\t\t      mode, state, sccstack, sccstate, sccstate_obstack))\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n \n       /* Fallthru  */\n \n     case FUNCTION_TYPE:\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n-      if ((mode != GTC_DIAG\n-\t   || !gimple_compatible_complete_and_incomplete_subtype_p\n-\t         (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\t  && !gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n-\t\t\t state, sccstack, sccstate, sccstate_obstack))\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t      state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n \n       if (!comp_type_attributes (t1, t2))\n@@ -3711,11 +3699,8 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \t       parms1 && parms2;\n \t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n-\t      if ((mode == GTC_MERGE\n-\t\t   || !gimple_compatible_complete_and_incomplete_subtype_p\n-\t\t         (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n-\t\t  && !gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2), mode,\n-\t\t\t\t state, sccstack, sccstate, sccstate_obstack))\n+\t      if (!gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2),\n+\t\t\t      state, sccstack, sccstate, sccstate_obstack))\n \t\tgoto different_types;\n \t    }\n \n@@ -3727,10 +3712,10 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \n     case OFFSET_TYPE:\n       {\n-\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n+\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n \t\t\tstate, sccstack, sccstate, sccstate_obstack)\n \t    || !gtc_visit (TYPE_OFFSET_BASETYPE (t1),\n-\t\t\t   TYPE_OFFSET_BASETYPE (t2), mode,\n+\t\t\t   TYPE_OFFSET_BASETYPE (t2),\n \t\t\t   state, sccstack, sccstate, sccstate_obstack))\n \t  goto different_types;\n \n@@ -3745,16 +3730,9 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \tif (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n \t  goto different_types;\n \n-\t/* If one pointer points to an incomplete type variant of\n-\t   the other pointed-to type they are the same.  */\n-\tif (mode == GTC_DIAG\n-\t    && gimple_compatible_complete_and_incomplete_subtype_p\n-\t         (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\t  goto same_types;\n-\n \t/* Otherwise, pointer and reference types are the same if the\n \t   pointed-to types are the same.  */\n-\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n+\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n \t\t       state, sccstack, sccstate, sccstate_obstack))\n \t  goto same_types;\n \n@@ -3825,7 +3803,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \t    if (tree_int_cst_equal (c1, c2) != 1)\n \t      goto different_types;\n \n-\t    if (mode == GTC_MERGE && TREE_PURPOSE (v1) != TREE_PURPOSE (v2))\n+\t    if (TREE_PURPOSE (v1) != TREE_PURPOSE (v2))\n \t      goto different_types;\n \t  }\n \n@@ -3844,9 +3822,8 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \ttree f1, f2;\n \n \t/* The struct tags shall compare equal.  */\n-\tif (mode == GTC_MERGE\n-\t    && !compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n-\t\t\t\t      TYPE_MAIN_VARIANT (t2), false))\n+\tif (!compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n+\t\t\t\t   TYPE_MAIN_VARIANT (t2), false))\n \t  goto different_types;\n \n \t/* For aggregate types, all the fields must be the same.  */\n@@ -3855,11 +3832,10 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n \t  {\n \t    /* The fields must have the same name, offset and type.  */\n-\t    if ((mode == GTC_MERGE\n-\t\t && DECL_NAME (f1) != DECL_NAME (f2))\n+\t    if (DECL_NAME (f1) != DECL_NAME (f2)\n \t\t|| DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n \t\t|| !gimple_compare_field_offset (f1, f2)\n-\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2), mode,\n+\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2),\n \t\t\t       state, sccstack, sccstate, sccstate_obstack))\n \t      goto different_types;\n \t  }\n@@ -3898,7 +3874,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n \t  x = VEC_pop (type_pair_t, *sccstack);\n \t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n \t  cstate->on_sccstack = false;\n-\t  x->same_p[mode] = state->u.same_p;\n+\t  x->same_p[GTC_MERGE] = state->u.same_p;\n \t}\n       while (x != p);\n     }\n@@ -3911,13 +3887,14 @@ gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n    are considered different, otherwise they are considered compatible.  */\n \n static bool\n-gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n+gimple_types_compatible_p (tree t1, tree t2)\n {\n   VEC(type_pair_t, heap) *sccstack = NULL;\n   struct pointer_map_t *sccstate;\n   struct obstack sccstate_obstack;\n   type_pair_t p = NULL;\n   bool res;\n+  tree leader1, leader2;\n \n   /* Before starting to set up the SCC machinery handle simple cases.  */\n \n@@ -3931,21 +3908,12 @@ gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n \n   /* If the types have been previously registered and found equal\n      they still are.  */\n-  if (mode == GTC_MERGE)\n-    {\n-      tree leader1 = gimple_lookup_type_leader (t1);\n-      tree leader2 = gimple_lookup_type_leader (t2);\n-      if (leader1 == t2\n-\t  || t1 == leader2\n-\t  || (leader1 && leader1 == leader2))\n-\treturn true;\n-    }\n-  else if (mode == GTC_DIAG)\n-    {\n-      if (TYPE_CANONICAL (t1)\n-\t  && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-\treturn true;\n-    }\n+  leader1 = gimple_lookup_type_leader (t1);\n+  leader2 = gimple_lookup_type_leader (t2);\n+  if (leader1 == t2\n+      || t1 == leader2\n+      || (leader1 && leader1 == leader2))\n+    return true;\n \n   /* Can't be the same type if the types don't have the same code.  */\n   if (TREE_CODE (t1) != TREE_CODE (t2))\n@@ -3999,24 +3967,24 @@ gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n   /* If the hash values of t1 and t2 are different the types can't\n      possibly be the same.  This helps keeping the type-pair hashtable\n      small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash_1 (t1, mode) != gimple_type_hash_1 (t2, mode))\n+  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n     return false;\n \n   /* If we've visited this type pair before (in the case of aggregates\n      with self-referential types), and we made a decision, return it.  */\n   p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n-  if (p->same_p[mode] == 0 || p->same_p[mode] == 1)\n+  if (p->same_p[GTC_MERGE] == 0 || p->same_p[GTC_MERGE] == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n \t same, return the cached result.  */\n-      return p->same_p[mode] == 1;\n+      return p->same_p[GTC_MERGE] == 1;\n     }\n \n   /* Now set up the SCC machinery for the comparison.  */\n   gtc_next_dfs_num = 1;\n   sccstate = pointer_map_create ();\n   gcc_obstack_init (&sccstate_obstack);\n-  res = gimple_types_compatible_p_1 (t1, t2, mode, p,\n+  res = gimple_types_compatible_p_1 (t1, t2, p,\n \t\t\t\t     &sccstack, sccstate, &sccstate_obstack);\n   VEC_free (type_pair_t, heap, sccstack);\n   pointer_map_destroy (sccstate);\n@@ -4028,8 +3996,7 @@ gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n \n static hashval_t\n iterative_hash_gimple_type (tree, hashval_t, VEC(tree, heap) **,\n-\t\t\t    struct pointer_map_t *, struct obstack *,\n-\t\t\t    enum gtc_mode);\n+\t\t\t    struct pointer_map_t *, struct obstack *);\n \n /* DFS visit the edge from the callers type with state *STATE to T.\n    Update the callers type hash V with the hash for T if it is not part\n@@ -4040,7 +4007,7 @@ static hashval_t\n visit (tree t, struct sccs *state, hashval_t v,\n        VEC (tree, heap) **sccstack,\n        struct pointer_map_t *sccstate,\n-       struct obstack *sccstate_obstack, enum gtc_mode mode)\n+       struct obstack *sccstate_obstack)\n {\n   struct sccs *cstate = NULL;\n   struct tree_int_map m;\n@@ -4049,9 +4016,7 @@ visit (tree t, struct sccs *state, hashval_t v,\n   /* If there is a hash value recorded for this type then it can't\n      possibly be part of our parent SCC.  Simply mix in its hash.  */\n   m.base.from = t;\n-  if ((slot = htab_find_slot (mode == GTC_MERGE\n-\t\t\t      ? type_hash_cache : canonical_type_hash_cache,\n-\t\t\t      &m, NO_INSERT))\n+  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n       && *slot)\n     return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, v);\n \n@@ -4062,8 +4027,7 @@ visit (tree t, struct sccs *state, hashval_t v,\n       hashval_t tem;\n       /* Not yet visited.  DFS recurse.  */\n       tem = iterative_hash_gimple_type (t, v,\n-\t\t\t\t\tsccstack, sccstate, sccstate_obstack,\n-\t\t\t\t\tmode);\n+\t\t\t\t\tsccstack, sccstate, sccstate_obstack);\n       if (!cstate)\n \tcstate = (struct sccs *)* pointer_map_contains (sccstate, t);\n       state->low = MIN (state->low, cstate->low);\n@@ -4114,8 +4078,7 @@ static hashval_t\n iterative_hash_gimple_type (tree type, hashval_t val,\n \t\t\t    VEC(tree, heap) **sccstack,\n \t\t\t    struct pointer_map_t *sccstate,\n-\t\t\t    struct obstack *sccstate_obstack,\n-\t\t\t    enum gtc_mode mode)\n+\t\t\t    struct obstack *sccstate_obstack)\n {\n   hashval_t v;\n   void **slot;\n@@ -4165,7 +4128,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t}\n       else\n \tv = visit (TREE_TYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack, mode);\n+\t\t   sccstack, sccstate, sccstate_obstack);\n     }\n \n   /* For integer types hash the types min/max values and the string flag.  */\n@@ -4186,15 +4149,15 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n     {\n       v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n       v = visit (TYPE_DOMAIN (type), state, v,\n-\t\t sccstack, sccstate, sccstate_obstack, mode);\n+\t\t sccstack, sccstate, sccstate_obstack);\n     }\n \n   /* Recurse for aggregates with a single element type.  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n       || TREE_CODE (type) == COMPLEX_TYPE\n       || TREE_CODE (type) == VECTOR_TYPE)\n     v = visit (TREE_TYPE (type), state, v,\n-\t       sccstack, sccstate, sccstate_obstack, mode);\n+\t       sccstack, sccstate, sccstate_obstack);\n \n   /* Incorporate function return and argument types.  */\n   if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n@@ -4205,7 +4168,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n       /* For method types also incorporate their parent class.  */\n       if (TREE_CODE (type) == METHOD_TYPE)\n \tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack, mode);\n+\t\t   sccstack, sccstate, sccstate_obstack);\n \n       /* For result types allow mismatch in completeness.  */\n       if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n@@ -4216,7 +4179,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t}\n       else\n \tv = visit (TREE_TYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack, mode);\n+\t\t   sccstack, sccstate, sccstate_obstack);\n \n       for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n \t{\n@@ -4229,7 +4192,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t    }\n \t  else\n \t    v = visit (TREE_VALUE (p), state, v,\n-\t\t       sccstack, sccstate, sccstate_obstack, mode);\n+\t\t       sccstack, sccstate, sccstate_obstack);\n \t  na++;\n \t}\n \n@@ -4243,15 +4206,13 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n       unsigned nf;\n       tree f;\n \n-      if (mode == GTC_MERGE)\n-\tv = iterative_hash_name (TYPE_NAME (TYPE_MAIN_VARIANT (type)), v);\n+      v = iterative_hash_name (TYPE_NAME (TYPE_MAIN_VARIANT (type)), v);\n \n       for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n \t{\n-\t  if (mode == GTC_MERGE)\n-\t    v = iterative_hash_name (DECL_NAME (f), v);\n+\t  v = iterative_hash_name (DECL_NAME (f), v);\n \t  v = visit (TREE_TYPE (f), state, v,\n-\t\t     sccstack, sccstate, sccstate_obstack, mode);\n+\t\t     sccstack, sccstate, sccstate_obstack);\n \t  nf++;\n \t}\n \n@@ -4276,9 +4237,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \t  cstate->on_sccstack = false;\n \t  m->base.from = x;\n \t  m->to = cstate->u.hash;\n-\t  slot = htab_find_slot (mode == GTC_MERGE\n-\t\t\t\t ? type_hash_cache : canonical_type_hash_cache,\n-\t\t\t\t m, INSERT);\n+\t  slot = htab_find_slot (type_hash_cache, m, INSERT);\n \t  gcc_assert (!*slot);\n \t  *slot = (void *) m;\n \t}\n@@ -4298,7 +4257,7 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n    types according to gimple_types_compatible_p.  */\n \n static hashval_t\n-gimple_type_hash_1 (const void *p, enum gtc_mode mode)\n+gimple_type_hash (const void *p)\n {\n   const_tree t = (const_tree) p;\n   VEC(tree, heap) *sccstack = NULL;\n@@ -4308,19 +4267,12 @@ gimple_type_hash_1 (const void *p, enum gtc_mode mode)\n   void **slot;\n   struct tree_int_map m;\n \n-  if (mode == GTC_MERGE\n-      && type_hash_cache == NULL)\n+  if (type_hash_cache == NULL)\n     type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n \t\t\t\t       tree_int_map_eq, NULL);\n-  else if (mode == GTC_DIAG\n-\t   && canonical_type_hash_cache == NULL)\n-    canonical_type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n-\t\t\t\t\t\t tree_int_map_eq, NULL);\n \n   m.base.from = CONST_CAST_TREE (t);\n-  if ((slot = htab_find_slot (mode == GTC_MERGE\n-\t\t\t      ? type_hash_cache : canonical_type_hash_cache,\n-\t\t\t      &m, NO_INSERT))\n+  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n       && *slot)\n     return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, 0);\n \n@@ -4329,21 +4281,14 @@ gimple_type_hash_1 (const void *p, enum gtc_mode mode)\n   sccstate = pointer_map_create ();\n   gcc_obstack_init (&sccstate_obstack);\n   val = iterative_hash_gimple_type (CONST_CAST_TREE (t), 0,\n-\t\t\t\t    &sccstack, sccstate, &sccstate_obstack,\n-\t\t\t\t    mode);\n+\t\t\t\t    &sccstack, sccstate, &sccstate_obstack);\n   VEC_free (tree, heap, sccstack);\n   pointer_map_destroy (sccstate);\n   obstack_free (&sccstate_obstack, NULL);\n \n   return val;\n }\n \n-static hashval_t\n-gimple_type_hash (const void *p)\n-{\n-  return gimple_type_hash_1 (p, GTC_MERGE);\n-}\n-\n /* Returning a hash value for gimple type TYPE combined with VAL.\n \n    The hash value returned is equal for types considered compatible\n@@ -4497,7 +4442,7 @@ gimple_type_eq (const void *p1, const void *p2)\n   const_tree t1 = (const_tree) p1;\n   const_tree t2 = (const_tree) p2;\n   return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n-\t\t\t\t    CONST_CAST_TREE (t2), GTC_MERGE);\n+\t\t\t\t    CONST_CAST_TREE (t2));\n }\n \n "}]}