{"sha": "1fb000641146f78eb756228c6f5a64dc4c91b0ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZiMDAwNjQxMTQ2Zjc4ZWI3NTYyMjhjNmY1YTY0ZGM0YzkxYjBjYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-18T09:37:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-18T09:37:14Z"}, "message": "[multiple changes]\n\n2010-10-18  Robert Dewar  <dewar@adacore.com>\n\n\t* g-trasym-vms-ia64.adb: Minor reformatting.\n\n2010-10-18  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_type.adb (Covers): If either argument is Standard_Void_Type and\n\tthe other isn't, return False early.\n\n2010-10-18  Ed Falis  <falis@adacore.com>\n\n\t* s-vxwext-rtp.ads, s-vxext-rtp.adb: Adapt for missing APIs for RTPs in\n\tVxWorks Cert.\n\n2010-10-18  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_disp.ads: Minor comment update.\n\n2010-10-18  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads, einfo.adb (Spec_PPC_List): Is now present in Entries\n\t* sem_ch3.adb (Analyze_Declarations): Add processing for delaying\n\tvisibility analysis of precondition and postcondition pragmas (and\n\tPre/Post aspects).\n\t* sem_ch6.adb (Process_PPCs): Add handling of inherited Pre'Class\n\taspects.\n\t* sem_ch7.adb (Analyze_Package_Specification): Remove special handling\n\tof pre/post conditions (no longer needed).\n\t* sem_disp.adb (Inherit_Subprograms): Deal with interface case.\n\t* sem_prag.adb (Analyze_PPC_In_Decl_Part): Remove analysis of message\n\targument, since this is now done in the main processing for\n\tpre/postcondition pragmas when they are first seen.\n\t(Chain_PPC): Pre'Class and Post'Class now handled properly\n\t(Chain_PPC): Handle Pre/Post aspects for entries\n\t(Check_Precondition_Postcondition): Handle entry declaration case\n\t(Check_Precondition_Postcondition): Handle delay of visibility analysis\n\t(Check_Precondition_Postcondition): Preanalyze message argument if\n\tpresent.\n\nFrom-SVN: r165612", "tree": {"sha": "34f268f90e4345a88e0278633d604c1a38a29f31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34f268f90e4345a88e0278633d604c1a38a29f31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fb000641146f78eb756228c6f5a64dc4c91b0ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb000641146f78eb756228c6f5a64dc4c91b0ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fb000641146f78eb756228c6f5a64dc4c91b0ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb000641146f78eb756228c6f5a64dc4c91b0ca/comments", "author": null, "committer": null, "parents": [{"sha": "a4485ef6398a741b55fa244546074f01cfdd83a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4485ef6398a741b55fa244546074f01cfdd83a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4485ef6398a741b55fa244546074f01cfdd83a4"}], "stats": {"total": 300, "additions": 211, "deletions": 89}, "files": [{"sha": "256483c3e7715375a99c599191f814b54f0d785b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -1,3 +1,42 @@\n+2010-10-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-trasym-vms-ia64.adb: Minor reformatting.\n+\n+2010-10-18  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_type.adb (Covers): If either argument is Standard_Void_Type and\n+\tthe other isn't, return False early.\n+\n+2010-10-18  Ed Falis  <falis@adacore.com>\n+\n+\t* s-vxwext-rtp.ads, s-vxext-rtp.adb: Adapt for missing APIs for RTPs in\n+\tVxWorks Cert.\n+\n+2010-10-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_disp.ads: Minor comment update.\n+\n+2010-10-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (Spec_PPC_List): Is now present in Entries\n+\t* sem_ch3.adb (Analyze_Declarations): Add processing for delaying\n+\tvisibility analysis of precondition and postcondition pragmas (and\n+\tPre/Post aspects).\n+\t* sem_ch6.adb (Process_PPCs): Add handling of inherited Pre'Class\n+\taspects.\n+\t* sem_ch7.adb (Analyze_Package_Specification): Remove special handling\n+\tof pre/post conditions (no longer needed).\n+\t* sem_disp.adb (Inherit_Subprograms): Deal with interface case.\n+\t* sem_prag.adb (Analyze_PPC_In_Decl_Part): Remove analysis of message\n+\targument, since this is now done in the main processing for\n+\tpre/postcondition pragmas when they are first seen.\n+\t(Chain_PPC): Pre'Class and Post'Class now handled properly\n+\t(Chain_PPC): Handle Pre/Post aspects for entries\n+\t(Check_Precondition_Postcondition): Handle entry declaration case\n+\t(Check_Precondition_Postcondition): Handle delay of visibility analysis\n+\t(Check_Precondition_Postcondition): Preanalyze message argument if\n+\tpresent.\n+\n 2010-10-18  Robert Dewar  <dewar@adacore.com>\n \n \t* g-trasym-vms-ia64.adb, prj-nmsc.adb, prj.ads: Minor reformatting."}, {"sha": "3c0314b3db5527e5993debba9e8a8698c1ab710b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -2581,7 +2581,10 @@ package body Einfo is\n \n    function Spec_PPC_List (Id : E) return N is\n    begin\n-      pragma Assert (Is_Subprogram (Id) or else Is_Generic_Subprogram (Id));\n+      pragma Assert\n+        (Ekind (Id) = E_Entry\n+          or else Is_Subprogram (Id)\n+          or else Is_Generic_Subprogram (Id));\n       return Node24 (Id);\n    end Spec_PPC_List;\n \n@@ -5046,7 +5049,10 @@ package body Einfo is\n \n    procedure Set_Spec_PPC_List (Id : E; V : N) is\n    begin\n-      pragma Assert (Is_Subprogram (Id) or else Is_Generic_Subprogram (Id));\n+      pragma Assert\n+        (Ekind_In (Id, E_Entry, E_Void)\n+          or else Is_Subprogram (Id)\n+          or else Is_Generic_Subprogram (Id));\n       Set_Node24 (Id, V);\n    end Set_Spec_PPC_List;\n "}, {"sha": "c459f64cea17047a56cbafb49f7f3d6976da7cf6", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -3532,11 +3532,12 @@ package Einfo is\n --       the corresponding parameter entities in the spec.\n \n --    Spec_PPC_List (Node24)\n---       Present in subprogram and generic subprogram entities. Points to a\n---       list of Precondition and Postcondition pragma nodes for preconditions\n---       and postconditions declared in the spec. The last pragma encountered\n---       is at the head of this list, so it is in reverse order of textual\n---       appearance.\n+--       Present in entries, and in subprogram and generic subprogram entities.\n+--       Points to a list of Precondition and Postcondition pragma nodes for\n+--       preconditions and postconditions declared in the spec. The last pragma\n+--       encountered is at the head of this list, so it is in reverse order of\n+--       textual appearance. Note that this includes precondition/postcondition\n+--       pragmas generated to correspond to Pre/Post aspects.\n \n --    Storage_Size_Variable (Node15) [implementation base type only]\n --       Present in access types and task type entities. This flag is set\n@@ -4951,6 +4952,7 @@ package Einfo is\n    --    Accept_Address                      (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Protection_Object                   (Node23)   (protected kind)\n+   --    Spec_PPC_List                       (Node24)   (for entry only)\n    --    Default_Expressions_Processed       (Flag108)\n    --    Entry_Accepted                      (Flag152)\n    --    Is_AST_Entry                        (Flag132)  (for entry only)"}, {"sha": "897e2ebb24ae9170913907e585120b78e8b5a8c5", "filename": "gcc/ada/g-trasym-vms-ia64.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fg-trasym-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fg-trasym-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-trasym-vms-ia64.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -325,7 +325,7 @@ package body GNAT.Traceback.Symbolic is\n                Len := Last;\n             end;\n \n-         --  Even status values\n+         --  Failure (bit 0 clear)\n \n          else\n             Res (Len + 1 .. Len + 6) := \"ERROR\" & ASCII.LF;"}, {"sha": "431f41e7499572525a31234c3ae6881e41a0af7c", "filename": "gcc/ada/s-vxwext-rtp.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fs-vxwext-rtp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fs-vxwext-rtp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-rtp.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -26,7 +26,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides vxworks specific support functions needed\n+--  This package provides VxWorks specific support functions needed\n --  by System.OS_Interface.\n \n --  This is the VxWorks 6 RTP version of this package\n@@ -90,6 +90,17 @@ package body System.VxWorks.Ext is\n       return 0;\n    end Interrupt_Number_To_Vector;\n \n+   ---------------\n+   -- semDelete --\n+   ---------------\n+\n+   function semDelete (Sem : SEM_ID) return int is\n+      function OS_semDelete (Sem : SEM_ID) return int;\n+      pragma Import (C, OS_semDelete, \"semDelete\");\n+   begin\n+      return OS_semDelete (Sem);\n+   end semDelete;\n+\n    --------------------\n    -- Set_Time_Slice --\n    --------------------"}, {"sha": "f1783c9c22ab0e9821afcc98ffac6ca456e916be", "filename": "gcc/ada/s-vxwext-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fs-vxwext-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fs-vxwext-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-rtp.ads?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -69,7 +69,7 @@ package System.VxWorks.Ext is\n    pragma Convention (C, Interrupt_Number_To_Vector);\n \n    function semDelete (Sem : SEM_ID) return int;\n-   pragma Import (C, semDelete, \"semDelete\");\n+   pragma Convention (C, semDelete);\n \n    function Task_Cont (tid : t_id) return int;\n    pragma Import (C, Task_Cont, \"taskResume\");"}, {"sha": "f78495aa52b9d2aba4a68c589a7461231cd5acc7", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -62,6 +62,7 @@ with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Smem; use Sem_Smem;\n with Sem_Type; use Sem_Type;\n@@ -2069,6 +2070,35 @@ package body Sem_Ch3 is\n \n          D := Next_Node;\n       end loop;\n+\n+      --  One more thing to do, we need to scan the declarations to check\n+      --  for any precondition/postcondition pragmas (Pre/Post aspects have\n+      --  by this stage been converted into corresponding pragmas). It is\n+      --  at this point that we analyze the expressions in such pragmas,\n+      --  to implement the delayed visibility requirement.\n+\n+      declare\n+         Decl : Node_Id;\n+         Spec : Node_Id;\n+         Sent : Entity_Id;\n+         Prag : Node_Id;\n+\n+      begin\n+         Decl := First (L);\n+         while Present (Decl) loop\n+            if Nkind (Original_Node (Decl)) = N_Subprogram_Declaration then\n+               Spec := Specification (Original_Node (Decl));\n+               Sent := Defining_Unit_Name (Spec);\n+               Prag := Spec_PPC_List (Sent);\n+               while Present (Prag) loop\n+                  Analyze_PPC_In_Decl_Part (Prag, Sent);\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end;\n    end Analyze_Declarations;\n \n    -----------------------------------"}, {"sha": "bc228e4efb25a0a2e5105651785fdfb61b7edd48", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -8699,18 +8699,22 @@ package body Sem_Ch6 is\n          --  do this fiddling, for the spec cases, the already preanalyzed\n          --  parameters are not affected.\n \n+         Set_Analyzed (CP, False);\n+\n+         --  We also make sure Comes_From_Source is False for the copy\n+\n+         Set_Comes_From_Source (CP, False);\n+\n          --  For a postcondition pragma within a generic, preserve the pragma\n          --  for later expansion.\n \n-         Set_Analyzed (CP, False);\n-\n          if Nam = Name_Postcondition\n            and then not Expander_Active\n          then\n             return CP;\n          end if;\n \n-         --  Change pragma into corresponding pragma Check\n+         --  Change copy of pragma into corresponding pragma Check\n \n          Prepend_To (Pragma_Argument_Associations (CP),\n            Make_Pragma_Argument_Association (Sloc (Prag),\n@@ -8761,9 +8765,8 @@ package body Sem_Ch6 is\n \n          Prag := Spec_PPC_List (Spec_Id);\n          while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Precondition\n-              and then Pragma_Enabled (Prag)\n-            then\n+            if Pragma_Name (Prag) = Name_Precondition then\n+\n                --  For Pre (or Precondition pragma), we simply prepend the\n                --  pragma to the list of declarations right away so that it\n                --  will be executed at the start of the procedure. Note that\n@@ -8969,7 +8972,6 @@ package body Sem_Ch6 is\n                Prag := Spec_PPC_List (Spec);\n                loop\n                   if Pragma_Name (Prag) = Name_Postcondition\n-                    and then Pragma_Enabled (Prag)\n                     and then (not Class or else Class_Present (Prag))\n                   then\n                      if Plist = No_List then"}, {"sha": "e53fb55e3809acc3c987add5d8e1919609a9fabd", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -55,7 +55,6 @@ with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n-with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Snames;   use Snames;\n@@ -872,12 +871,6 @@ package body Sem_Ch7 is\n       --  private_with_clauses, and remove them at the end of the nested\n       --  package.\n \n-      procedure Analyze_PPCs (Decls : List_Id);\n-      --  Given a list of declarations, go through looking for subprogram\n-      --  specs, and for each one found, analyze any pre/postconditions that\n-      --  are chained to the spec. This is the implementation of the late\n-      --  visibility analysis for preconditions and postconditions in specs.\n-\n       procedure Clear_Constants (Id : Entity_Id; FE : Entity_Id);\n       --  Clears constant indications (Never_Set_In_Source, Constant_Value, and\n       --  Is_True_Constant) on all variables that are entities of Id, and on\n@@ -906,33 +899,6 @@ package body Sem_Ch7 is\n       --  private part rather than being done in Sem_Ch12.Install_Parent\n       --  (which is where the parents' visible declarations are installed).\n \n-      ------------------\n-      -- Analyze_PPCs --\n-      ------------------\n-\n-      procedure Analyze_PPCs (Decls : List_Id) is\n-         Decl : Node_Id;\n-         Spec : Node_Id;\n-         Sent : Entity_Id;\n-         Prag : Node_Id;\n-\n-      begin\n-         Decl := First (Decls);\n-         while Present (Decl) loop\n-            if Nkind (Original_Node (Decl)) = N_Subprogram_Declaration then\n-               Spec := Specification (Original_Node (Decl));\n-               Sent := Defining_Unit_Name (Spec);\n-               Prag := Spec_PPC_List (Sent);\n-               while Present (Prag) loop\n-                  Analyze_PPC_In_Decl_Part (Prag, Sent);\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-      end Analyze_PPCs;\n-\n       ---------------------\n       -- Clear_Constants --\n       ---------------------\n@@ -1161,7 +1127,6 @@ package body Sem_Ch7 is\n    begin\n       if Present (Vis_Decls) then\n          Analyze_Declarations (Vis_Decls);\n-         Analyze_PPCs (Vis_Decls);\n       end if;\n \n       --  Verify that incomplete types have received full declarations\n@@ -1296,7 +1261,6 @@ package body Sem_Ch7 is\n          end if;\n \n          Analyze_Declarations (Priv_Decls);\n-         Analyze_PPCs (Priv_Decls);\n \n          --  Check the private declarations for incomplete deferred constants\n "}, {"sha": "322e5352f4d1eb26941dc1cc316fef4061f04042", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -1742,8 +1742,29 @@ package body Sem_Disp is\n       Parent_Op : Entity_Id;\n       --  Traverses the Overridden_Operation chain\n \n+      procedure Store_IS (E : Entity_Id);\n+      --  Stores E in Result if not already stored\n+\n+      --------------\n+      -- Store_IS --\n+      --------------\n+\n+      procedure Store_IS (E : Entity_Id) is\n+      begin\n+         for J in 1 .. N loop\n+            if E = Result (J) then\n+               return;\n+            end if;\n+         end loop;\n+\n+         N := N + 1;\n+         Result (N) := E;\n+      end Store_IS;\n+\n+   --  Start of processing for Inherited_Subprograms\n+\n    begin\n-      if Present (S) then\n+      if Present (S) and then Is_Dispatching_Operation (S) then\n \n          --  Deal with direct inheritance\n \n@@ -1755,13 +1776,56 @@ package body Sem_Disp is\n             if Is_Subprogram (Parent_Op)\n               or else Is_Generic_Subprogram (Parent_Op)\n             then\n-               N := N + 1;\n-               Result (N) := Parent_Op;\n+               Store_IS (Parent_Op);\n             end if;\n          end loop;\n \n-         --  For now don't bother with interfaces, TBD ???\n+         --  Now deal with interfaces\n+\n+         declare\n+            Tag_Typ : Entity_Id;\n+            Prim    : Entity_Id;\n+            Elmt    : Elmt_Id;\n+\n+         begin\n+            Tag_Typ := Find_Dispatching_Type (S);\n+\n+            if Is_Concurrent_Type (Tag_Typ) then\n+               Tag_Typ := Corresponding_Record_Type (Tag_Typ);\n+            end if;\n \n+            --  Search primitive operations of dispatching type\n+\n+            if Present (Tag_Typ)\n+              and then Present (Primitive_Operations (Tag_Typ))\n+            then\n+               Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+               while Present (Elmt) loop\n+                  Prim := Node (Elmt);\n+\n+                  --  The following test eliminates some odd cases in which\n+                  --  Ekind (Prim) is Void, to be investigated further ???\n+\n+                  if not (Is_Subprogram (Prim)\n+                            or else\n+                          Is_Generic_Subprogram (Prim))\n+                  then\n+                     null;\n+\n+                     --  For [generic] subprogram, look at interface alias\n+\n+                  elsif Present (Interface_Alias (Prim))\n+                    and then Alias (Prim) = S\n+                  then\n+                     --  We have found a primitive covered by S\n+\n+                     Store_IS (Interface_Alias (Prim));\n+                  end if;\n+\n+                  Next_Elmt (Elmt);\n+               end loop;\n+            end if;\n+         end;\n       end if;\n \n       return Result (1 .. N);"}, {"sha": "66a02513455c42cfd46d301f13b022a7a15f72ca", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -76,8 +76,9 @@ package Sem_Disp is\n    --  and Empty if it is not dynamically tagged.\n \n    function Find_Dispatching_Type (Subp : Entity_Id) return Entity_Id;\n-   --  Check whether a subprogram is dispatching, and find the tagged\n-   --  type of the controlling argument or arguments.\n+   --  Check whether a subprogram is dispatching, and find the tagged type of\n+   --  the controlling argument or arguments. Returns Empty if Subp is not a\n+   --  dispatching operation.\n \n    function Find_Primitive_Covering_Interface\n      (Tagged_Type : Entity_Id;"}, {"sha": "516ebc9416f73d51ab82fc9b7ec1b349dba46f5b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -240,9 +240,7 @@ package body Sem_Prag is\n    ------------------------------\n \n    procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n-      Arg1 : constant Node_Id :=\n-               First (Pragma_Argument_Associations (N));\n-      Arg2 : constant Node_Id := Next (Arg1);\n+      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n \n    begin\n       --  Install formals and push subprogram spec onto scope stack so that we\n@@ -257,13 +255,6 @@ package body Sem_Prag is\n       Preanalyze_Spec_Expression\n         (Get_Pragma_Arg (Arg1), Standard_Boolean);\n \n-      --  If there is a message argument, analyze it the same way\n-\n-      if Present (Arg2) then\n-         Preanalyze_Spec_Expression\n-           (Get_Pragma_Arg (Arg2), Standard_String);\n-      end if;\n-\n       --  Remove the subprogram from the scope stack now that the pre-analysis\n       --  of the precondition/postcondition is done.\n \n@@ -1511,23 +1502,27 @@ package body Sem_Prag is\n                     (\"pragma% cannot be applied to abstract subprogram\");\n \n                elsif Class_Present (N) then\n-                  Error_Pragma\n-                    (\"aspect `%''Class` not implemented yet\");\n+                  null;\n \n                else\n                   Error_Pragma\n                     (\"aspect % requires ''Class for abstract subprogram\");\n                end if;\n \n             elsif not Nkind_In (PO, N_Subprogram_Declaration,\n-                                    N_Generic_Subprogram_Declaration)\n+                                    N_Generic_Subprogram_Declaration,\n+                                    N_Entry_Declaration)\n             then\n                Pragma_Misplaced;\n             end if;\n \n-            --  Here if we have subprogram or generic subprogram declaration\n+            --  Here if we have [generic] subprogram or entry declaration\n \n-            S := Defining_Unit_Name (Specification (PO));\n+            if Nkind (PO) = N_Entry_Declaration then\n+               S := Defining_Entity (PO);\n+            else\n+               S := Defining_Unit_Name (Specification (PO));\n+            end if;\n \n             --  Make sure we do not have the case of a precondition pragma when\n             --  the Pre'Class aspect is present.\n@@ -1583,14 +1578,11 @@ package body Sem_Prag is\n                end;\n             end if;\n \n-            --  Analyze the pragma unless it appears within a package spec,\n-            --  which is the case where we delay the analysis of the PPC until\n-            --  the end of the package declarations (for details, see\n-            --  Analyze_Package_Specification.Analyze_PPCs).\n-\n-            if not Is_Package_Or_Generic_Package (Scope (S)) then\n-               Analyze_PPC_In_Decl_Part (N, S);\n-            end if;\n+            --  Note: we do not analye the pragma at this point. Instead we\n+            --  delay this analysis until the end of the declarative part in\n+            --  which the pragma appears. This implements the required delay\n+            --  in this analysis, allowing forward references. The analysis\n+            --  happens at the end of Analyze_Declarations.\n \n             --  Chain spec PPC pragma to list for subprogram\n \n@@ -1610,6 +1602,15 @@ package body Sem_Prag is\n             Pragma_Misplaced;\n          end if;\n \n+         --  Preanalyze message argument if present. Visibility in this\n+         --  argument is established at the point of pragma occurrence.\n+\n+         if Arg_Count = 2 then\n+            Check_Optional_Identifier (Arg2, Name_Message);\n+            Preanalyze_Spec_Expression\n+              (Get_Pragma_Arg (Arg2), Standard_String);\n+         end if;\n+\n          --  Record if pragma is enabled\n \n          if Check_Enabled (Pname) then\n@@ -10823,7 +10824,6 @@ package body Sem_Prag is\n             Check_At_Least_N_Arguments (1);\n             Check_At_Most_N_Arguments (2);\n             Check_Optional_Identifier (Arg1, Name_Check);\n-\n             Check_Precondition_Postcondition (In_Body);\n \n             --  If in spec, nothing more to do. If in body, then we convert the\n@@ -10833,11 +10833,6 @@ package body Sem_Prag is\n             --  analyze the condition itself in the proper context.\n \n             if In_Body then\n-               if Arg_Count = 2 then\n-                  Check_Optional_Identifier (Arg3, Name_Message);\n-                  Analyze_And_Resolve (Get_Pragma_Arg (Arg2), Standard_String);\n-               end if;\n-\n                Rewrite (N,\n                  Make_Pragma (Loc,\n                    Chars => Name_Check,"}, {"sha": "08d273e37fe602f03d3370378b1cd53a5ec9b547", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb000641146f78eb756228c6f5a64dc4c91b0ca/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=1fb000641146f78eb756228c6f5a64dc4c91b0ca", "patch": "@@ -755,6 +755,14 @@ package body Sem_Type is\n          end if;\n       end if;\n \n+      --  First check for Standard_Void_Type, which is special. Subsequent\n+      --  processing in this routine assumes T1 and T2 are bona fide types;\n+      --  Standard_Void_Type is a special entity that has some, but not all,\n+      --  properties of types.\n+\n+      if (T1 = Standard_Void_Type) /= (T2 = Standard_Void_Type) then\n+         return False;\n+\n       --  Simplest case: same types are compatible, and types that have the\n       --  same base type and are not generic actuals are compatible. Generic\n       --  actuals  belong to their class but are not compatible with other\n@@ -770,7 +778,7 @@ package body Sem_Type is\n       --  the same actual, so that different subprograms end up with the same\n       --  signature in the instance.\n \n-      if T1 = T2 then\n+      elsif T1 = T2 then\n          return True;\n \n       elsif BT1 = BT2"}]}