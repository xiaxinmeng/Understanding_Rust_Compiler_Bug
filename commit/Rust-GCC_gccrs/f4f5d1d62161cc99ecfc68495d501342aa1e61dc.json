{"sha": "f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRmNWQxZDYyMTYxY2M5OWVjZmM2ODQ5NWQ1MDEzNDJhYTFlNjFkYw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-18T06:00:25Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-18T06:00:25Z"}, "message": "BufferedReader.java, [...]: Merged from classpath.\n\n2003-03-18  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/BufferedReader.java,\n\tjava/io/BufferedWriter.java,\n\tjava/io/ByteArrayOutputStream.java,\n\tjava/io/FileFilter.java,\n\tjava/io/FilePermission.java,\n\tjava/io/FileReader.java,\n\tjava/io/FileWriter.java,\n\tjava/io/FilenameFilter.java,\n\tjava/io/FilterInputStream.java,\n\tjava/io/FilterOutputStream.java,\n\tjava/io/FilterReader.java,\n\tjava/io/FilterWriter.java,\n\tjava/io/ObjectInput.java,\n\tjava/io/ObjectInputValidation.java,\n\tjava/io/ObjectOutput.java,\n\tjava/io/ObjectStreamField.java,\n\tjava/io/PipedInputStream.java,\n\tjava/io/PipedReader.java,\n\tjava/io/PrintWriter.java,\n\tjava/io/PushbackReader.java,\n\tjava/io/Reader.java,\n\tjava/io/SerializablePermission.java,\n\tjava/io/StringReader.java,\n\tjava/io/Writer.java:\n\tMerged from classpath.\n\nFrom-SVN: r64525", "tree": {"sha": "9f83602fa5fd87c7741475487fab1b0b3a3e47ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f83602fa5fd87c7741475487fab1b0b3a3e47ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/comments", "author": null, "committer": null, "parents": [{"sha": "61f1ed592c606d1d2ae272292ad4dbe37d71d78b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f1ed592c606d1d2ae272292ad4dbe37d71d78b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f1ed592c606d1d2ae272292ad4dbe37d71d78b"}], "stats": {"total": 2512, "additions": 1273, "deletions": 1239}, "files": [{"sha": "16697a7c35f9f880eef8891ae79c2319415f869e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,3 +1,31 @@\n+2003-03-18  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/BufferedReader.java,\n+\tjava/io/BufferedWriter.java,\n+\tjava/io/ByteArrayOutputStream.java,\n+\tjava/io/FileFilter.java,\n+\tjava/io/FilePermission.java,\n+\tjava/io/FileReader.java,\n+\tjava/io/FileWriter.java,\n+\tjava/io/FilenameFilter.java,\n+\tjava/io/FilterInputStream.java,\n+\tjava/io/FilterOutputStream.java,\n+\tjava/io/FilterReader.java,\n+\tjava/io/FilterWriter.java,\n+\tjava/io/ObjectInput.java,\n+\tjava/io/ObjectInputValidation.java,\n+\tjava/io/ObjectOutput.java,\n+\tjava/io/ObjectStreamField.java,\n+\tjava/io/PipedInputStream.java,\n+\tjava/io/PipedReader.java,\n+\tjava/io/PrintWriter.java,\n+\tjava/io/PushbackReader.java,\n+\tjava/io/Reader.java,\n+\tjava/io/SerializablePermission.java,\n+\tjava/io/StringReader.java,\n+\tjava/io/Writer.java:\n+\tMerged from classpath.\n+\n 2003-03-17  Michael Koch  <konqueror@gmx.de>\n \n \t* java/awt/ScrollPaneAdjustable.java:"}, {"sha": "a40015b32d68f1c3144010dc1aa75266a1b499a1", "filename": "libjava/java/io/BufferedReader.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FBufferedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FBufferedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedReader.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -243,7 +243,8 @@ public void reset() throws IOException\n     * This method returns <code>false</code> then this stream could (but is\n     * not guaranteed to) block on the next read attempt.\n     *\n-    * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n+    * @return <code>true</code> if this stream is ready to be read, \n+    * <code>false</code> otherwise\n     *\n     * @exception IOException If an error occurs\n     */\n@@ -258,7 +259,8 @@ public boolean ready() throws IOException\n \n   /**\n     * This method read chars from a stream and stores them into a caller\n-    * supplied buffer.  It starts storing the data at index <code>offset</code> into\n+    * supplied buffer.  It starts storing the data at index \n+    * <code>offset</code> into\n     * the buffer and attempts to read <code>len</code> chars.  This method can\n     * return before reading the number of chars requested.  The actual number\n     * of chars read is returned as an int.  A -1 is returned to indicate the\n@@ -473,7 +475,8 @@ public String readLine() throws IOException\n     * requested amount.\n     * <p>\n     * This method first discards chars in the buffer, then calls the\n-    * <code>skip</code> method on the underlying stream to skip the remaining chars.\n+    * <code>skip</code> method on the underlying stream to skip the \n+    * remaining chars.\n     *\n     * @param num_chars The requested number of chars to skip\n     *"}, {"sha": "b7837843cd3fc2d4c41db9ed077823169dca5fe0", "filename": "libjava/java/io/BufferedWriter.java", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FBufferedWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FBufferedWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedWriter.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -51,8 +51,6 @@\n   * efficient mechanism for writing versus doing numerous small unbuffered\n   * writes.\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   * @author Tom Tromey <tromey@cygnus.com>\n   * @date September 25, 1998 "}, {"sha": "bb5b869a3914d4f38eb08c087d355ad6e14a71f9", "filename": "libjava/java/io/ByteArrayOutputStream.java", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FByteArrayOutputStream.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -65,8 +65,6 @@\n   * application specified character encoding.  Thus it can handle \n   * multibyte character encodings.\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   * @author Tom Tromey <tromey@cygnus.com>\n   * @date September 24, 1998 "}, {"sha": "4cfdb01d6f40eec8a8d3ad33f9038fcf1b39b6ea", "filename": "libjava/java/io/FileFilter.java", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFileFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFileFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileFilter.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -46,23 +46,21 @@\n   * The method in this interface determines if a particular pathname should\n   * or should not be included in the pathname listing.\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public interface FileFilter\n {\n \n-/**\n-  * This method determines whether or not a given pathname should be included\n-  * in a pathname listing.\n-  *\n-  * @param pathname The pathname to test\n-  *\n-  * @return <code>true</code> if the path should be included in the list, <code>false</code> otherwise.\n-  */\n-public abstract boolean\n-accept(File pathname);\n+  /**\n+    * This method determines whether or not a given pathname should be included\n+    * in a pathname listing.\n+    *\n+    * @param pathname The pathname to test\n+    *\n+    * @return <code>true</code> if the path should be included in the list, \n+    * <code>false</code> otherwise.\n+    */\n+  public abstract boolean accept(File pathname);\n \n } // interface FileFilter\n "}, {"sha": "95aa42077850f012e1e8d79da96da6e2ed20b711", "filename": "libjava/java/io/FilePermission.java", "status": "modified", "additions": 136, "deletions": 94, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilePermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilePermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilePermission.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* java.lang.FilePermission\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -45,34 +45,37 @@ public final class FilePermission extends Permission implements Serializable\n {\n   static final long serialVersionUID = 7930732926638008763L;\n \n-  private static final String CURRENT_DIRECTORY = System.getProperty(\"user.dir\");\n+  private static final String CURRENT_DIRECTORY = \n+    System.getProperty(\"user.dir\");\n   private boolean usingPerms = false;\n   private boolean readPerm = false;\n   private boolean writePerm = false;\n   private boolean executePerm = false;\n   private boolean deletePerm = false;\n   private String actionsString;\n   \n-  private void cachePerms() {\n+  private void cachePerms() \n+  {\n     // While race conditions could occur, they don't matter at all.\n     \n     String action;\n     int i = actionsString.indexOf(',');\n     int startI = 0;\n-    while(i != -1) {\n-      action = actionsString.substring(startI,i);\n-      if(action.equals(\"read\"))\n-\treadPerm = true;\n-      else if(action.equals(\"write\"))\n-\twritePerm = true;\n-      else if(action.equals(\"execute\"))\n-\texecutePerm = true;\n-      else if(action.equals(\"delete\"))\n-\tdeletePerm = true;\n+    while(i != -1) \n+      {\n+        action = actionsString.substring(startI,i);\n+        if(action.equals(\"read\"))\n+          readPerm = true;\n+        else if(action.equals(\"write\"))\n+          writePerm = true;\n+        else if(action.equals(\"execute\"))\n+          executePerm = true;\n+        else if(action.equals(\"delete\"))\n+          deletePerm = true;\n       \n-      startI = i+1;\n-      i = actionsString.indexOf(',',startI);\n-    }\n+        startI = i+1;\n+        i = actionsString.indexOf(',',startI);\n+      }\n     \n     action = actionsString.substring(startI);\n     if(action.equals(\"read\"))\n@@ -93,25 +96,29 @@ else if(action.equals(\"delete\"))\n    ** @XXX what to do when the file string is malformed?\n    **/\n   public FilePermission(String pathExpression, String actionsString) \n-    {\n-      super(pathExpression);\n-      this.actionsString = actionsString;\n-    }\n+  {\n+    super(pathExpression);\n+    this.actionsString = actionsString;\n+  }\n   \n   /** Get the actions this FilePermission supports.\n    ** @return the String representing the actions this FilePermission supports.\n    **/\n-  public String getActions() {\n+  public String getActions() \n+  {\n     return actionsString;\n   }\n   \n   /** Get the hash code for this Object.<P>\n-   ** FilePermission's hash code is calculated as the exclusive or of the target\n+   ** FilePermission's hash code is calculated as the exclusive or of the \n+   ** target\n    ** String's hash code and the action String's hash code.\n-   ** @specnote Sun did not specify how to calculate the hash code; I made this up.\n+   ** @specnote Sun did not specify how to calculate the hash code; \n+   ** I made this up.\n    ** @return the hash code for this Object.\n    **/\n-  public int hashCode() {\n+  public int hashCode() \n+  {\n     return getName().hashCode() ^ actionsString.hashCode();\n   }\n   \n@@ -121,7 +128,8 @@ public int hashCode() {\n    ** @param o the Object to compare to.\n    ** @return whether the Objects are semantically equivalent.\n    **/\n-  public boolean equals(Object o) {\n+  public boolean equals(Object o) \n+  {\n     if(!(o instanceof FilePermission))\n       return false;\n     FilePermission p = (FilePermission)o;\n@@ -136,86 +144,116 @@ public boolean equals(Object o) {\n     /* Compare names, taking into account if they refer to a\n      * directory and one has a separator and the other does not.\n      */\n-    if(f1.charAt(f1.length()) == File.separatorChar) {\n-      if(f2.charAt(f2.length()) == File.separatorChar) {\n-\tif(!f2.equals(f1))\n-\t  return false;\n-      } else {\n-\tif(!f2.equals(f1.substring(0,f1.length()-1)))\n-\t  return false;\n-      }\n-    } else {\n-      if(f2.charAt(f2.length()) == File.separatorChar) {\n-\tif(!f1.equals(f2.substring(0,f2.length()-1)))\n-\t  return false;\n-      } else {\n-\tif(!f1.equals(f2))\n-\t  return false;\n-      }\n-    }\n+    if(f1.charAt(f1.length()) == File.separatorChar) \n+      {\n+        if(f2.charAt(f2.length()) == File.separatorChar) \n+          {\n+\t    if(!f2.equals(f1))\n+\t      return false;\n+          } \n+        else \n+          {\n+\t    if(!f2.equals(f1.substring(0,f1.length()-1)))\n+\t      return false;\n+          }\n+      } \n+    else \n+      {\n+        if(f2.charAt(f2.length()) == File.separatorChar) \n+          {\n+\t    if(!f1.equals(f2.substring(0,f2.length()-1)))\n+\t      return false;\n+          } \n+        else \n+          {\n+\t    if(!f1.equals(f2))\n+\t      return false;\n+          }\n+       }\n     return readPerm == p.readPerm && writePerm == p.writePerm && executePerm == p.executePerm && deletePerm == p.deletePerm;\n   }\n   \n   /** Check to see if this permission implies another.\n    ** Permission A implies permission B if these things are all true:\n    ** <OL>\n    ** <LI>A and B are both FilePermissions.</LI>\n-   ** <LI>All possible files in B are included in A (possibly more are in A).</LI>\n+   ** <LI>All possible files in B are included in A \n+   ** (possibly more are in A).</LI>\n    ** <LI>All actions B supports, A also supports.</LI>\n    ** </OL>\n    ** @param p the Permission to compare against.\n    ** @return whether this Permission implies p\n    **/\n-  public boolean implies(Permission p) {\n+  public boolean implies(Permission p) \n+  {\n     FilePermission fp;\n     if(!(p instanceof FilePermission))\n       return false;\n     fp = (FilePermission)p;\n     \n     String f1 = getName();\n     String f2 = fp.getName();\n-    if(f1.charAt(0) != File.separatorChar) {\n-      f1 = CURRENT_DIRECTORY + f1;\n-    }\n-    if(f2.charAt(0) != File.separatorChar) {\n-      f2 = CURRENT_DIRECTORY + f2;\n-    }\n+    if(f1.charAt(0) != File.separatorChar) \n+      {\n+        f1 = CURRENT_DIRECTORY + f1;\n+      }\n+    if(f2.charAt(0) != File.separatorChar) \n+      {\n+        f2 = CURRENT_DIRECTORY + f2;\n+      }\n     \n     String sub1, sub2a, sub2b;\n-    switch(f1.charAt(f1.length() - 1)) {\n-    case '*':\n-      sub1 = f1.substring(0,f1.length() - 1); // chop off \"*\"\n-      if(f2.length() <= sub1.length()) {\n-\t/* If it's smaller, there is no way it could be part of this directory.\n-\t * If it's the same (or length - 1), it could be the same directory but\n-\t * specifies access to the directory rather than the files in it.\n-\t */\n-\treturn false;\n-      } else if(f2.charAt(sub1.length() - 1) == File.separatorChar) {\n-\t/* Make sure the part before the \"/\" is the same */\n-\tif(!f2.substring(0,sub1.length()).equals(sub1))\n-\t  return false;\n-\t/* Make sure there are no subdirectories specified underneath this one */\n-\tString sub2 = f2.substring(sub1.length()+1);\n-\tif(f2.substring(sub1.length()+1).indexOf(File.separatorChar) != -1)\n-\t  return false;\n-      } else {\n-\t/* Obviously not equal: f2 is either not a directory or is not\n-\t * the same directory (its name continues further than we want)\n-\t */\n-\treturn false;\n-      }\n-      break;\n-    case '-':\n-      sub1 = f1.substring(0,f1.length() - 2); // chop off \"/-\"\n-      if(f2.length() < sub1.length()) {\n-\t/* If it's smaller, there is no way it could be part of this directory. */\n-\treturn false;\n-      } else if(f2.length() > sub1.length() && f2.charAt(sub1.length()) != File.separatorChar) {\n-\treturn false;\n-      } else if(!f2.substring(0,sub1.length()).equals(sub1))\n-\treturn false;\n-      break;\n+    switch(f1.charAt(f1.length() - 1)) \n+      {\n+        case '*':\n+          sub1 = f1.substring(0,f1.length() - 1); // chop off \"*\"\n+          if(f2.length() <= sub1.length()) \n+            {\n+\t  /* If it's smaller, there is no way it could be part of this \n+           * directory.\n+\t   * If it's the same (or length - 1), it could be the same \n+           * directory but\n+\t   * specifies access to the directory rather than the files in it.\n+\t   */\n+\t      return false;\n+            } \n+          else if(f2.charAt(sub1.length() - 1) == File.separatorChar) \n+            {\n+\t      /* Make sure the part before the \"/\" is the same */\n+\t      if(!f2.substring(0,sub1.length()).equals(sub1))\n+\t        return false;\n+\t      /* Make sure there are no subdirectories specified \n+                 underneath this one */\n+\t      String sub2 = f2.substring(sub1.length()+1);\n+\t      if(f2.substring(sub1.length()+1).indexOf(File.separatorChar) \n+                 != -1)\n+\t        return false;\n+            } \n+          else \n+            {\n+\t  /* Obviously not equal: f2 is either not a directory or is not\n+\t   * the same directory (its name continues further than we want)\n+\t   */\n+\t      return false;\n+            }\n+          break;\n+        case '-':\n+          sub1 = f1.substring(0,f1.length() - 2); // chop off \"/-\"\n+          if(f2.length() < sub1.length()) \n+            {\n+\t     /* If it's smaller, there is no way it could be part of \n+              * this directory. */\n+\t      return false;\n+            } \n+          else if(f2.length() > sub1.length() && f2.charAt(sub1.length()) \n+             != File.separatorChar) \n+            {\n+\t      return false;\n+            \n+            } \n+          else if(!f2.substring(0,sub1.length()).equals(sub1))\n+\t    return false;\n+          break;\n /* Looks redundant with default case and won't compile anyway - arenn\n     case File.separatorChar:\n       if(f2.charAt(f2.length()) == File.separatorChar) {\n@@ -227,16 +265,19 @@ public boolean implies(Permission p) {\n       }\n       break;\n */\n-    default:\n-      if(f2.charAt(f2.length()) == File.separatorChar) {\n-\tif(!f1.equals(f2.substring(0,f2.length()-1)))\n-\t  return false;\n-      } else {\n-\tif(!f1.equals(f2))\n-\t  return false;\n+        default:\n+          if(f2.charAt(f2.length()) == File.separatorChar) \n+            {\n+              if(!f1.equals(f2.substring(0,f2.length()-1)))\n+\t        return false;\n+            } \n+          else \n+            {\n+\t      if(!f1.equals(f2))\n+\t        return false;\n+            }\n+         break;\n       }\n-      break;\n-    }\n     \n     if(!usingPerms)\n       cachePerms();\n@@ -254,4 +295,5 @@ public boolean implies(Permission p) {\n     \n     return true;\n   }\n-}\n+} // class FilePermission\n+"}, {"sha": "c18613852ab5f4fcdc6f048c472a5a54e050bbed", "filename": "libjava/java/io/FileReader.java", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFileReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFileReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileReader.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* FileReader.java -- Convenience class for reading characters from a file\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -46,8 +46,6 @@\n  * to read from files using the default character encoding.  Use\n  * <code>InputStreamReader</code> directly to use a non-default encoding.\n  *\n- * @version 0.0\n- *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  */\n public class FileReader extends InputStreamReader\n@@ -90,4 +88,5 @@ public FileReader(String name) throws FileNotFoundException\n   {\n     super(new FileInputStream(name));\n   }\n-}\n+} // class FileReader\n+"}, {"sha": "5217f9ecc33432a812a505a7dd1c271705059910", "filename": "libjava/java/io/FileWriter.java", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFileWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFileWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileWriter.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -54,84 +54,82 @@\n public class FileWriter extends OutputStreamWriter\n {\n \n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n- \n-/**\n-  * This method initializes a new <code>FileWriter</code> object to write\n-  * to the specified <code>File</code> object.\n-  *\n-  * @param file The <code>File</code> object to write to.\n-  *\n-  * @param SecurityException If writing to this file is forbidden by the\n-  *                          <code>SecurityManager</code>.\n-  * @param IOException If any other error occurs\n-  */\n-public \n-FileWriter(File file) throws SecurityException, IOException\n-{\n-  super(new FileOutputStream(file));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a new <code>FileWriter</code> object to write\n-  * to the specified <code>FileDescriptor</code> object.\n-  *\n-  * @param fd The <code>FileDescriptor</code> object to write to\n-  *\n-  * @param SecurityException If writing to this file is forbidden by the\n-  *                          <code>SecurityManager</code>.\n-  */\n-public\n-FileWriter(FileDescriptor fd) throws SecurityException\n-{\n-  super(new FileOutputStream(fd));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method intializes a new <code>FileWriter</code> object to write to the\n-  * specified named file.\n-  *\n-  * @param name The name of the file to write to\n-  *\n-  * @param SecurityException If writing to this file is forbidden by the\n-  *                          <code>SecurityManager</code>.\n-  * @param IOException If any other error occurs\n-  */\n-public\n-FileWriter(String name) throws IOException\n-{\n-  super(new FileOutputStream(name));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method intializes a new <code>FileWriter</code> object to write to the\n-  * specified named file.  This form of the constructor allows the caller\n-  * to determin whether data should be written starting at the beginning or\n-  * the end of the file.\n-  *\n-  * @param name The name of the file to write to\n-  * @param append <code>true</code> to start adding data at the end of the\n-  *               file, <code>false</code> otherwise.\n-  *\n-  * @param SecurityException If writing to this file is forbidden by the\n-  *                          <code>SecurityManager</code>.\n-  * @param IOException If any other error occurs\n-  */\n-public\n-FileWriter(String name, boolean append) throws IOException\n-{\n-  super(new FileOutputStream(name, append));\n-}\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+   \n+  /**\n+    * This method initializes a new <code>FileWriter</code> object to write\n+    * to the specified <code>File</code> object.\n+    *\n+    * @param file The <code>File</code> object to write to.\n+    *\n+    * @param SecurityException If writing to this file is forbidden by the\n+    *                          <code>SecurityManager</code>.\n+    * @param IOException If any other error occurs\n+    */\n+  public FileWriter(File file) throws SecurityException, IOException\n+  {\n+    super(new FileOutputStream(file));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method initializes a new <code>FileWriter</code> object to write\n+    * to the specified <code>FileDescriptor</code> object.\n+    *\n+    * @param fd The <code>FileDescriptor</code> object to write to\n+    *\n+    * @param SecurityException If writing to this file is forbidden by the\n+    *                          <code>SecurityManager</code>.\n+    */\n+  public FileWriter(FileDescriptor fd) throws SecurityException\n+  {\n+    super(new FileOutputStream(fd));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method intializes a new <code>FileWriter</code> object to \n+    * write to the\n+    * specified named file.\n+    *\n+    * @param name The name of the file to write to\n+    *\n+    * @param SecurityException If writing to this file is forbidden by the\n+    *                          <code>SecurityManager</code>.\n+    * @param IOException If any other error occurs\n+    */\n+  public FileWriter(String name) throws IOException\n+  {\n+    super(new FileOutputStream(name));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method intializes a new <code>FileWriter</code> object to \n+    * write to the\n+    * specified named file.  This form of the constructor allows the caller\n+    * to determin whether data should be written starting at the beginning or\n+    * the end of the file.\n+    *\n+    * @param name The name of the file to write to\n+    * @param append <code>true</code> to start adding data at the end of the\n+    *               file, <code>false</code> otherwise.\n+    *\n+    * @param SecurityException If writing to this file is forbidden by the\n+    *                          <code>SecurityManager</code>.\n+    * @param IOException If any other error occurs\n+    */\n+  public FileWriter(String name, boolean append) throws IOException\n+  {\n+    super(new FileOutputStream(name, append));\n+  }\n \n } // class FileWriter\n "}, {"sha": "df0509adaddeb51d14cae193fb96e7caac76b662", "filename": "libjava/java/io/FilenameFilter.java", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilenameFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilenameFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilenameFilter.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -57,17 +57,17 @@\n public interface FilenameFilter\n {\n \n-/**\n-  * This method determines whether or not a given file should be included\n-  * in a directory listing.\n-  *\n-  * @param dir The <code>File</code> instance for the directory being read\n-  * @param name The name of the file to test\n-  *\n-  * @return <code>true</code> if the file should be included in the list,\n-  * <code>false</code> otherwise.\n-  */\n-boolean\n-accept(File dir, String name);\n+  /**\n+    * This method determines whether or not a given file should be included\n+    * in a directory listing.\n+    *\n+    * @param dir The <code>File</code> instance for the directory being read\n+    * @param name The name of the file to test\n+    *\n+    * @return <code>true</code> if the file should be included in the list,\n+    * <code>false</code> otherwise.\n+    */\n+  boolean accept(File dir, String name);\n \n } // interface FilenameFilter\n+"}, {"sha": "80cbd9273758d2dca10f82d4077402c6278b98fd", "filename": "libjava/java/io/FilterInputStream.java", "status": "modified", "additions": 166, "deletions": 174, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterInputStream.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -70,179 +70,171 @@\n public class FilterInputStream extends InputStream\n {\n \n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the subordinate <code>InputStream</code> to which method calls\n-  * are redirected\n-  */\n-protected InputStream in;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * Create a <code>FilterInputStream</code> with the specified subordinate\n-  * <code>InputStream</code>.\n-  *\n-  * @param in The subordinate <code>InputStream</code>\n-  */\n-protected \n-FilterInputStream(InputStream in)\n-{\n-  this.in = in;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * Calls the <code>in.mark(int)</code> method.\n-  *\n-  * @param readlimit The parameter passed to <code>in.mark(int)</code>\n-  */\n-public void\n-mark(int readlimit)\n-{\n-  in.mark(readlimit);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.markSupported()</code> method.\n-  *\n-  * @return <code>true</code> if mark/reset is supported, <code>false</code>\n-  *         otherwise\n-  */\n-public boolean\n-markSupported()\n-{\n-  return(in.markSupported());\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.reset()</code> method.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-reset() throws IOException\n-{\n-  in.reset();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.available()</code> method.\n-  *\n-  * @return The value returned from <code>in.available()</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public int\n-available() throws IOException\n-{\n-  return(in.available());\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.skip(long)</code> method\n-  *\n-  * @param The requested number of bytes to skip. \n-  *\n-  * @return The value returned from <code>in.skip(long)</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public long\n-skip(long num_bytes) throws IOException\n-{\n-  return(in.skip(num_bytes));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.read()</code> method\n-  *\n-  * @return The value returned from <code>in.read()</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public int\n-read() throws IOException\n-{\n-  return(in.read());\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>read(byte[], int, int)</code> overloaded method.  Note that \n-  * this method does not redirect its call directly to a corresponding\n-  * method in <code>in</code>.  This allows subclasses to override only the\n-  * three argument version of <code>read</code>.\n-  *\n-  * @param buf The buffer to read bytes into\n-  *\n-  * @return The value retured from <code>in.read(byte[], int, int)</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public int\n-read(byte[] buf) throws IOException\n-{\n-  return(read(buf, 0, buf.length));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.read(byte[], int, int)</code> method.\n-  *\n-  * @param buf The buffer to read bytes into\n-  * @param offset The index into the buffer to start storing bytes\n-  * @param len The maximum number of bytes to read.\n-  *\n-  * @return The value retured from <code>in.read(byte[], int, int)</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public int\n-read(byte[] buf, int offset, int len) throws IOException\n-{\n-  return(in.read(buf, offset, len));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method closes the input stream by closing the input stream that\n-  * this object is filtering.  Future attempts to access this stream may\n-  * throw an exception.\n-  * \n-  * @exception IOException If an error occurs\n-  */\n-public void\n-close() throws IOException\n-{\n-  in.close();\n-}\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Variables\n+   */\n+\n+  /**\n+    * This is the subordinate <code>InputStream</code> to which method calls\n+    * are redirected\n+    */\n+  protected InputStream in;\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+    * Create a <code>FilterInputStream</code> with the specified subordinate\n+    * <code>InputStream</code>.\n+    *\n+    * @param in The subordinate <code>InputStream</code>\n+    */\n+  protected FilterInputStream(InputStream in)\n+  {\n+    this.in = in;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Methods\n+   */\n+\n+  /**\n+    * Calls the <code>in.mark(int)</code> method.\n+    *\n+    * @param readlimit The parameter passed to <code>in.mark(int)</code>\n+    */\n+  public void mark(int readlimit)\n+  {\n+    in.mark(readlimit);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.markSupported()</code> method.\n+    *\n+    * @return <code>true</code> if mark/reset is supported, <code>false</code>\n+    *         otherwise\n+    */\n+  public boolean markSupported()\n+  {\n+    return(in.markSupported());\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.reset()</code> method.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void reset() throws IOException\n+  {\n+    in.reset();\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.available()</code> method.\n+    *\n+    * @return The value returned from <code>in.available()</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public int available() throws IOException\n+  {\n+    return(in.available());\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.skip(long)</code> method\n+    *\n+    * @param numBytes The requested number of bytes to skip. \n+    *\n+    * @return The value returned from <code>in.skip(long)</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public long skip(long num_bytes) throws IOException\n+  {\n+    return(in.skip(num_bytes));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.read()</code> method\n+    *\n+    * @return The value returned from <code>in.read()</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public int read() throws IOException\n+  {\n+    return(in.read());\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>read(byte[], int, int)</code> overloaded method.  \n+    * Note that \n+    * this method does not redirect its call directly to a corresponding\n+    * method in <code>in</code>.  This allows subclasses to override only the\n+    * three argument version of <code>read</code>.\n+    *\n+    * @param buf The buffer to read bytes into\n+    *\n+    * @return The value retured from <code>in.read(byte[], int, int)</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public int read(byte[] buf) throws IOException\n+  {\n+    return(read(buf, 0, buf.length));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.read(byte[], int, int)</code> method.\n+    *\n+    * @param buf The buffer to read bytes into\n+    * @param offset The index into the buffer to start storing bytes\n+    * @param len The maximum number of bytes to read.\n+    *\n+    * @return The value retured from <code>in.read(byte[], int, int)</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public int read(byte[] buf, int offset, int len) throws IOException\n+  {\n+    return(in.read(buf, offset, len));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method closes the input stream by closing the input stream that\n+    * this object is filtering.  Future attempts to access this stream may\n+    * throw an exception.\n+    * \n+    * @exception IOException If an error occurs\n+    */\n+  public void close() throws IOException\n+  {\n+    in.close();\n+  }\n \n } // class FilterInputStream\n+"}, {"sha": "01204b461096d0a5a7bdef72a16c4bcfc88af78d", "filename": "libjava/java/io/FilterOutputStream.java", "status": "modified", "additions": 117, "deletions": 122, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterOutputStream.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* FilterOutputStream.java -- Parent class for output streams that filter\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -57,126 +57,121 @@\n public class FilterOutputStream extends OutputStream\n {\n \n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the subordinate <code>OutputStream</code> that this class\n-  * redirects its method calls to.\n-  */\n-protected OutputStream out;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This method initializes an instance of <code>FilterOutputStream</code>\n-  * to write to the specified subordinate <code>OutputStream</code>.\n-  *\n-  * @param out The <code>OutputStream</code> to write to\n-  */\n-public\n-FilterOutputStream(OutputStream out)\n-{\n-  this.out = out;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * This method closes the underlying <code>OutputStream</code>.  Any\n-  * further attempts to write to this stream may throw an exception.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-close() throws IOException\n-{\n-  flush();\n-  out.close();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method attempt to flush all buffered output to be written to the\n-  * underlying output sink.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-flush() throws IOException\n-{\n-  out.flush();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a single byte of output to the underlying\n-  * <code>OutputStream</code>.\n-  *\n-  * @param b The byte to write, passed as an int.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(int b) throws IOException\n-{\n-  out.write(b);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes all the bytes in the specified array to the underlying\n-  * <code>OutputStream</code>.  It does this by calling the three parameter\n-  * version of this method - <code>write(byte[], int, int)</code> in this\n-  * class instead of writing to the underlying <code>OutputStream</code>\n-  * directly.  This allows most subclasses to avoid overriding this method.\n-  *\n-  * @param buf The byte array to write bytes from\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(byte[] buf) throws IOException\n-{\n-  // Don't do checking here, per Java Lang Spec.\n-  write(buf, 0, buf.length);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method calls the <code>write(int)</code> method <code>len</code>\n-  * times for all bytes from the array <code>buf</code> starting at index\n-  * <code>offset</code>. Subclasses should overwrite this method to get a\n-  * more efficient implementation.\n-  *\n-  * @param buf The byte array to write bytes from\n-  * @param offset The index into the array to start writing bytes from\n-  * @param len The number of bytes to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(byte[] buf, int offset, int len) throws IOException\n-{\n-  // Don't do checking here, per Java Lang Spec.\n-  for (int i=0; i < len; i++) \n-    write(buf[offset + i]);\n-\n-}\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Variables\n+   */\n+\n+  /**\n+    * This is the subordinate <code>OutputStream</code> that this class\n+    * redirects its method calls to.\n+    */\n+  protected OutputStream out;\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+    * This method initializes an instance of <code>FilterOutputStream</code>\n+    * to write to the specified subordinate <code>OutputStream</code>.\n+    *\n+    * @param out The <code>OutputStream</code> to write to\n+    */\n+  public FilterOutputStream(OutputStream out)\n+  {\n+    this.out = out;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Methods\n+   */\n+\n+  /**\n+    * This method closes the underlying <code>OutputStream</code>.  Any\n+    * further attempts to write to this stream may throw an exception.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void close() throws IOException\n+  {\n+    flush();\n+    out.close();\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method attempt to flush all buffered output to be written to the\n+    * underlying output sink.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void flush() throws IOException\n+  {\n+    out.flush();\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a single byte of output to the underlying\n+    * <code>OutputStream</code>.\n+    *\n+    * @param b The byte to write, passed as an int.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(int b) throws IOException\n+  {\n+    out.write(b);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes all the bytes in the specified array to the underlying\n+    * <code>OutputStream</code>.  It does this by calling the three parameter\n+    * version of this method - <code>write(byte[], int, int)</code> in this\n+    * class instead of writing to the underlying <code>OutputStream</code>\n+    * directly.  This allows most subclasses to avoid overriding this method.\n+    *\n+    * @param buf The byte array to write bytes from\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(byte[] buf) throws IOException\n+  {\n+    // Don't do checking here, per Java Lang Spec.\n+    write(buf, 0, buf.length);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method calls the <code>write(int)</code> method <code>len</code>\n+    * times for all bytes from the array <code>buf</code> starting at index\n+    * <code>offset</code>. Subclasses should overwrite this method to get a\n+    * more efficient implementation.\n+    *\n+    * @param buf The byte array to write bytes from\n+    * @param offset The index into the array to start writing bytes from\n+    * @param len The number of bytes to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(byte[] buf, int offset, int len) throws IOException\n+  {\n+    // Don't do checking here, per Java Lang Spec.\n+    for (int i=0; i < len; i++) \n+      write(buf[offset + i]);\n+\n+  }\n \n } // class FilterOutputStream\n+"}, {"sha": "22bf6e618974ce5e29930380cd10af81073b01d0", "filename": "libjava/java/io/FilterReader.java", "status": "modified", "additions": 149, "deletions": 159, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterReader.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* FilterReader.java -- Base class for char stream classes that filter input\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -63,163 +63,153 @@\n   */\n public abstract class FilterReader extends Reader\n {\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the subordinate <code>Reader</code> to which method calls\n-  * are redirected\n-  */\n-protected Reader in;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * Create a <code>FilterReader</code> with the specified subordinate\n-  * <code>Reader</code>.\n-  * The <code>lock</code> of the new <code>FilterReader</code> will be set\n-  * to <code>in.lock</code>.\n-  *\n-  * @param in The subordinate <code>Reader</code>\n-  */\n-protected \n-FilterReader(Reader in)\n-{\n-  super(in.lock);\n-  this.in = in;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * Calls the <code>in.mark(int)</code> method.\n-  *\n-  * @param readlimit The parameter passed to <code>in.mark(int)</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-mark(int readlimit) throws IOException\n-{\n-  in.mark(readlimit);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.markSupported()</code> method.\n-  *\n-  * @return <code>true</code> if mark/reset is supported, <code>false</code> otherwise\n-  */\n-public boolean\n-markSupported()\n-{\n-  return(in.markSupported());\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.reset()</code> method.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-reset() throws IOException\n-{\n-  in.reset();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.read()</code> method.\n-  *\n-  * @return The value returned from <code>in.available()</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public boolean\n-ready() throws IOException\n-{\n-  return(in.ready());\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.skip(long)</code> method\n-  *\n-  * @param The requested number of chars to skip. \n-  *\n-  * @return The value returned from <code>in.skip(long)</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public long\n-skip(long num_chars) throws IOException\n-{\n-  return(in.skip(num_chars));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.read()</code> method\n-  *\n-  * @return The value returned from <code>in.read()</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public int\n-read() throws IOException\n-{\n-  return(in.read());\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * Calls the <code>in.read(char[], int, int)</code> method.\n-  *\n-  * @param buf The buffer to read chars into\n-  * @param offset The index into the buffer to start storing chars\n-  * @param len The maximum number of chars to read.\n-  *\n-  * @return The value retured from <code>in.read(char[], int, int)</code>\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public int\n-read(char[] buf, int offset, int len) throws IOException\n-{\n-  return(in.read(buf, offset, len));\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method closes the stream by calling the <code>close()</code> method\n-  * of the underlying stream.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-close() throws IOException\n-{\n-  in.close();\n-}\n+  /*\n+   * Instance Variables\n+   */\n+\n+  /**\n+    * This is the subordinate <code>Reader</code> to which method calls\n+    * are redirected\n+    */\n+  protected Reader in;\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+    * Create a <code>FilterReader</code> with the specified subordinate\n+    * <code>Reader</code>.\n+    * The <code>lock</code> of the new <code>FilterReader</code> will be set\n+    * to <code>in.lock</code>.\n+    *\n+    * @param in The subordinate <code>Reader</code>\n+    */\n+  protected FilterReader(Reader in)\n+  {\n+    super(in.lock);\n+    this.in = in;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Methods\n+   */\n+\n+  /**\n+    * Calls the <code>in.mark(int)</code> method.\n+    *\n+    * @param readlimit The parameter passed to <code>in.mark(int)</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void mark(int readlimit) throws IOException\n+  {\n+    in.mark(readlimit);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.markSupported()</code> method.\n+    *\n+    * @return <code>true</code> if mark/reset is supported, \n+    * <code>false</code> otherwise\n+    */\n+  public boolean markSupported()\n+  {\n+    return(in.markSupported());\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.reset()</code> method.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void reset() throws IOException\n+  {\n+    in.reset();\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.read()</code> method.\n+    *\n+    * @return The value returned from <code>in.available()</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public boolean ready() throws IOException\n+  {\n+    return(in.ready());\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.skip(long)</code> method\n+    *\n+    * @param numBytes The requested number of chars to skip. \n+    *\n+    * @return The value returned from <code>in.skip(long)</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public long skip(long num_chars) throws IOException\n+  {\n+    return(in.skip(num_chars));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.read()</code> method\n+    *\n+    * @return The value returned from <code>in.read()</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public int read() throws IOException\n+  {\n+    return(in.read());\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Calls the <code>in.read(char[], int, int)</code> method.\n+    *\n+    * @param buf The buffer to read chars into\n+    * @param offset The index into the buffer to start storing chars\n+    * @param len The maximum number of chars to read.\n+    *\n+    * @return The value retured from <code>in.read(char[], int, int)</code>\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public int read(char[] buf, int offset, int len) throws IOException\n+  {\n+    return(in.read(buf, offset, len));\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method closes the stream by calling the <code>close()</code> method\n+    * of the underlying stream.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void close() throws IOException\n+  {\n+    in.close();\n+  }\n \n } // class FilterReader\n+"}, {"sha": "f476dfee3f58df83052737580de62659d6b4cd10", "filename": "libjava/java/io/FilterWriter.java", "status": "modified", "additions": 112, "deletions": 120, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FFilterWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFilterWriter.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* FilterWriter.java -- Parent class for output streams that filter\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -52,128 +52,120 @@\n   * underlying stream.  Subclasses provide actual filtering.\n   *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n-  * @author Tom Tromey <tromey@cygnus.com>\n+  * @author Tom Tromey <tromey@cygnus.com> \n   */\n public abstract class FilterWriter extends Writer\n {\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the subordinate <code>Writer</code> that this class\n-  * redirects its method calls to.\n-  */\n-protected Writer out;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This method initializes an instance of <code>FilterWriter</code>\n-  * to write to the specified subordinate <code>Writer</code>.\n-  * The given <code>Writer</code> will be used as <code>lock</code> for\n-  * the newly created <code>FilterWriter</code>.\n-  *\n-  * @param out The <code>Writer</code> to write to\n-  */\n-protected\n-FilterWriter(Writer out)\n-{\n-  super(out);\n-  this.out = out;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * This method closes the underlying <code>Writer</code>.  Any\n-  * further attempts to write to this stream may throw an exception.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-close() throws IOException\n-{\n-  out.close();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method attempt to flush all buffered output to be written to the\n-  * underlying output sink.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-flush() throws IOException\n-{\n-  out.flush();\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a single char of output to the underlying\n-  * <code>Writer</code>.\n-  *\n-  * @param b The char to write, passed as an int.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(int b) throws IOException\n-{\n-  out.write(b);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes <code>len</code> chars from the array <code>buf</code>\n-  * starting at index <code>offset</code> to the underlying\n-  * <code>Writer</code>.\n-  *\n-  * @param buf The char array to write chars from\n-  * @param offset The index into the array to start writing chars from\n-  * @param len The number of chars to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(char[] buf, int offset, int len) throws IOException\n-{\n-  out.write(buf, offset, len);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes <code>len</code> chars from the <code>String</code>\n-  * starting at position <code>offset</code>.\n-  *\n-  * @param str The <code>String</code> that is to be written\n-  * @param offset The character offset into the <code>String</code> to start writing from\n-  * @param len The number of chars to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(String str, int offset, int len) throws IOException\n-{\n-  out.write(str, offset, len);\n-}\n+  /*\n+   * Instance Variables\n+   */\n+\n+  /**\n+    * This is the subordinate <code>Writer</code> that this class\n+    * redirects its method calls to.\n+    */\n+  protected Writer out;\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+    * This method initializes an instance of <code>FilterWriter</code>\n+    * to write to the specified subordinate <code>Writer</code>.\n+    * The given <code>Writer</code> will be used as <code>lock</code> for\n+    * the newly created <code>FilterWriter</code>.\n+    *\n+    * @param out The <code>Writer</code> to write to\n+    */\n+  protected FilterWriter(Writer out)\n+  {\n+    super(out);\n+    this.out = out;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Methods\n+   */\n+\n+  /**\n+    * This method closes the underlying <code>Writer</code>.  Any\n+    * further attempts to write to this stream may throw an exception.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void close() throws IOException\n+  {\n+    out.close();\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method attempt to flush all buffered output to be written to the\n+    * underlying output sink.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void flush() throws IOException\n+  {\n+    out.flush();\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a single char of output to the underlying\n+    * <code>Writer</code>.\n+    *\n+    * @param b The char to write, passed as an int.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(int b) throws IOException\n+  {\n+    out.write(b);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes <code>len</code> chars from the array <code>buf</code>\n+    * starting at index <code>offset</code> to the underlying\n+    * <code>Writer</code>.\n+    *\n+    * @param buf The char array to write chars from\n+    * @param offset The index into the array to start writing chars from\n+    * @param len The number of chars to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(char[] buf, int offset, int len) throws IOException\n+  {\n+    out.write(buf, offset, len);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes <code>len</code> chars from the <code>String</code>\n+    * starting at position <code>offset</code>.\n+    *\n+    * @param str The <code>String</code> that is to be written\n+    * @param offset The character offset into the <code>String</code> \n+    * to start writing from\n+    * @param len The number of chars to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(String str, int offset, int len) throws IOException\n+  {\n+    out.write(str, offset, len);\n+  }\n \n } // class FilterWriter\n "}, {"sha": "678a31edc482329ec0ea809b75dd9104208ad026", "filename": "libjava/java/io/ObjectInput.java", "status": "modified", "additions": 99, "deletions": 106, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectInput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectInput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInput.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* ObjectInput.java -- Read object data from a stream\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998,2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -44,115 +44,108 @@\n   * also has methods that allow input to be done in a manner similar to\n   * <code>InputStream</code>\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public interface ObjectInput extends DataInput\n {\n-\n-/**\n-  * This method returns the number of bytes that can be read without\n-  * blocking.\n-  *\n-  * @return The number of bytes available before blocking\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract int\n-available() throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reading a byte of data from a stream.  It returns that byte\n-  * as an int.  This method blocks if no data is available to be read.\n-  * \n-  * @return The byte of data read\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract int\n-read() throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads raw bytes and stores them them a byte array buffer.\n-  * Note that this method will block if no data is available.  However, \n-  * it will not necessarily block until it fills the entire buffer.  That is,\n-  * a \"short count\" is possible.\n-  *\n-  * @param buf The byte array to receive the data read\n-  *\n-  * @return The actual number fo bytes read or -1 if end of stream\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract int\n-read(byte[] buf) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads raw bytes and stores them in a byte array buffer\n-  * <code>buf</code> starting at position <code>offset</code> into the buffer.  A \n-  * maximum of <code>len</code> bytes will be read.  Note that this method\n-  * blocks if no data is available, but will not necessarily block until\n-  * it can read <code>len</code> bytes of data.  That is, a \"short count\" is\n-  * possible.\n-  *\n-  * @param buf The byte array to receive the data read\n-  * @param offset The offset into @code{buf} to start storing data\n-  * @param len The maximum number of bytes to read\n-  *\n-  * @return The actual number fo bytes read or -1 if end of stream\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract int\n-read(byte[] buf, int offset, int len) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * Reads an object instance and returns it.  If the class for the object\n-  * being read cannot be found, then a ClassNotFoundException will\n-  * be thrown.\n-  *\n-  * @return The object instance that was read\n-  *\n-  * @exception ClassNotFoundException If a class for the object cannot be found\n-  * @exception IOException If an error occurs\n-  */\n-public abstract Object\n-readObject() throws ClassNotFoundException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method causes the specified number of bytes to be read and\n-  * discarded.  It is possible that fewer than the requested number of bytes\n-  * will actually be skipped.\n-  *\n-  * @param num_bytes The number of bytes to skip\n-  *\n-  * @return The actual number of bytes skipped\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract long\n-skip(long num_bytes) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method closes the input source\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-close() throws IOException;\n+  /**\n+    * This method returns the number of bytes that can be read without\n+    * blocking.\n+    *\n+    * @return The number of bytes available before blocking\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract int available() throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reading a byte of data from a stream.  It returns that byte\n+    * as an int.  This method blocks if no data is available to be read.\n+    * \n+    * @return The byte of data read\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract int read() throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads raw bytes and stores them them a byte array buffer.\n+    * Note that this method will block if no data is available.  However, \n+    * it will not necessarily block until it fills the entire buffer.  That is,\n+    * a \"short count\" is possible.\n+    *\n+    * @param buf The byte array to receive the data read\n+    *\n+    * @return The actual number fo bytes read or -1 if end of stream\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract int read(byte[] buf) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads raw bytes and stores them in a byte array buffer\n+    * <code>buf</code> starting at position <code>offset</code> into the \n+    * buffer.  A \n+    * maximum of <code>len</code> bytes will be read.  Note that this method\n+    * blocks if no data is available, but will not necessarily block until\n+    * it can read <code>len</code> bytes of data.  That is, a \"short count\" is\n+    * possible.\n+    *\n+    * @param buf The byte array to receive the data read\n+    * @param offset The offset into @code{buf} to start storing data\n+    * @param len The maximum number of bytes to read\n+    *\n+    * @return The actual number fo bytes read or -1 if end of stream\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract int read(byte[] buf, int offset, int len) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * Reads an object instance and returns it.  If the class for the object\n+    * being read cannot be found, then a ClassNotFoundException will\n+    * be thrown.\n+    *\n+    * @return The object instance that was read\n+    *\n+    * @exception ClassNotFoundException If a class for the object cannot be \n+    * found\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract Object readObject() \n+    throws ClassNotFoundException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method causes the specified number of bytes to be read and\n+    * discarded.  It is possible that fewer than the requested number of bytes\n+    * will actually be skipped.\n+    *\n+    * @param numBytes The number of bytes to skip\n+    *\n+    * @return The actual number of bytes skipped\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract long skip(long num_bytes) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method closes the input source\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void close() throws IOException;\n \n } // interface ObjectInput\n "}, {"sha": "2259eb832852dcf442d83dce2f183f4bdbd975da", "filename": "libjava/java/io/ObjectInputValidation.java", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectInputValidation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectInputValidation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputValidation.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* ObjectInputValidation.java -- Validate an object \n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,21 +41,18 @@\n /**\n   * What does this interface really do?\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public interface ObjectInputValidation\n {\n \n-/**\n-  * This method is called to validate an object.  If the object is invalid\n-  * an exception is thrown.\n-  *\n-  * @exception InvalidObjectException If the object is invalid\n-  */\n-public abstract void\n-validateObject() throws InvalidObjectException;\n+  /**\n+    * This method is called to validate an object.  If the object is invalid\n+    * an exception is thrown.\n+    *\n+    * @exception InvalidObjectException If the object is invalid\n+    */\n+  public abstract void validateObject() throws InvalidObjectException;\n \n } // interface ObjectInputValidation\n "}, {"sha": "1397027d402c8f6db4e066e6734cd4ed7f092470", "filename": "libjava/java/io/ObjectOutput.java", "status": "modified", "additions": 69, "deletions": 76, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectOutput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectOutput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutput.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* ObjectOutput.java -- Interface for writing objects to a stream\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,87 +41,80 @@\n /**\n   * This interface extends <code>DataOutput</code> to provide the additional\n   * facility of writing object instances to a stream.  It also adds some\n-  * additional methods to make the interface more <code>OutputStream</code> like.\n-  *\n-  * @version 0.0\n+  * additional methods to make the interface more \n+  * <code>OutputStream</code> like.\n   *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public interface ObjectOutput extends DataOutput\n {\n \n-\n-/**\n-  * This method writes the specified byte to the output stream.\n-  *\n-  * @param b The byte to write.\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public abstract void\n-write(int b) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes all the bytes in the specified byte array to the\n-  * output stream.\n-  *\n-  * @param buf The array of bytes to write.\n-  * \n-  * @exception IOException If an error occurs.\n-  */\n-public abstract void\n-write(byte[] buf) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes <code>len</code> bytes from the specified array\n-  * starting at index <code>offset</code> into that array.\n-  *\n-  * @param buf The byte array to write from.\n-  * @param offset The index into the byte array to start writing from.\n-  * @param len The number of bytes to write.\n-  *\n-  * @exception IOException If an error occurs.\n-  */\n-public abstract void\n-write(byte[] buf, int offset, int len) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a object instance to a stream.  The format of the\n-  * data written is determined by the actual implementation of this method\n-  *\n-  * @param obj The object to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-writeObject(Object obj) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method causes any buffered data to be flushed out to the underlying\n-  * stream\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-flush() throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method closes the underlying stream.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-close() throws IOException;\n+  /**\n+    * This method writes the specified byte to the output stream.\n+    *\n+    * @param b The byte to write.\n+    *\n+    * @exception IOException If an error occurs.\n+    */\n+  public abstract void write(int b) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes all the bytes in the specified byte array to the\n+    * output stream.\n+    *\n+    * @param buf The array of bytes to write.\n+    * \n+    * @exception IOException If an error occurs.\n+    */\n+  public abstract void write(byte[] buf) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes <code>len</code> bytes from the specified array\n+    * starting at index <code>offset</code> into that array.\n+    *\n+    * @param buf The byte array to write from.\n+    * @param offset The index into the byte array to start writing from.\n+    * @param len The number of bytes to write.\n+    *\n+    * @exception IOException If an error occurs.\n+    */\n+  public abstract void write(byte[] buf, int offset, int len) \n+    throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a object instance to a stream.  The format of the\n+    * data written is determined by the actual implementation of this method\n+    *\n+    * @param obj The object to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void writeObject(Object obj) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method causes any buffered data to be flushed out to the underlying\n+    * stream\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void flush() throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method closes the underlying stream.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void close() throws IOException;\n \n } // interface ObjectOutput\n "}, {"sha": "56f0d1aa87266e3f86e2d71fe93a8a4a80abf47b", "filename": "libjava/java/io/ObjectStreamField.java", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectStreamField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FObjectStreamField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamField.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* ObjectStreamField.java -- Class used to store name and class of fields\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -51,17 +51,21 @@ public ObjectStreamField (String name, Class type)\n   }\n  \n   /**\n-   * There're many cases you can't get java.lang.Class from typename if your context\n+   * There're many cases you can't get java.lang.Class from typename \n+   * if your context\n    * class loader can't load it, then use typename to construct the field\n    */\n   ObjectStreamField (String name, String typename){\n     this.name = name;\n     this.typename = typename;\n-    try{\n-      type = TypeSignature.getClassForEncoding(typename);\n-    }catch(ClassNotFoundException e){\n-      type = Object.class; //??\n-    }\n+    try\n+      {\n+        type = TypeSignature.getClassForEncoding(typename);\n+      }\n+    catch(ClassNotFoundException e)\n+      {\n+        type = Object.class; //FIXME: ???\n+      }\n   }\n   \n   public String getName ()\n@@ -125,3 +129,4 @@ public String toString ()\n   private String typename;\n   private int offset = -1; // XXX make sure this is correct\n }\n+"}, {"sha": "bf7730a85c4b011cae61e2e934ba29fdf7c6bc2b", "filename": "libjava/java/io/PipedInputStream.java", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPipedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPipedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedInputStream.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* PipedInputStream.java -- Read portion of piped streams.\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -46,7 +46,8 @@\n   * to which it is connected. \n   * <p>\n   * Data is read and written to an internal buffer.  It is highly recommended\n-  * that the <code>PipedInputStream</code> and connected <code>PipedOutputStream</code>\n+  * that the <code>PipedInputStream</code> and connected \n+  * <code>PipedOutputStream</code>\n   * be part of different threads.  If they are not, the read and write \n   * operations could deadlock their thread.\n   *\n@@ -113,7 +114,8 @@ public PipedInputStream()\n     * it to the passed in <code>PipedOutputStream</code>. The stream is then \n     * ready for reading.\n     *\n-    * @param source The <code>PipedOutputStream</code> to connect this stream to\n+    * @param source The <code>PipedOutputStream</code> to connect this \n+    * stream to\n     *\n     * @exception IOException If <code>source</code> is already connected.\n     */\n@@ -123,7 +125,8 @@ public PipedInputStream(PipedOutputStream source) throws IOException\n   }\n \n   /**\n-    * This method connects this stream to the passed in <code>PipedOutputStream</code>.\n+    * This method connects this stream to the passed in \n+    * <code>PipedOutputStream</code>.\n     * This stream is then ready for reading.  If this stream is already\n     * connected or has been previously closed, then an exception is thrown\n     *\n@@ -224,9 +227,12 @@ synchronized void receive(byte[] buf, int offset, int len)\n   \n   /**\n     * This method reads bytes from the stream into a caller supplied buffer.\n-    * It starts storing bytes at position <code>offset</code> into the buffer and\n-    * reads a maximum of <code>len</code> bytes.  Note that this method can actually\n-    * read fewer than <code>len</code> bytes.  The actual number of bytes read is\n+    * It starts storing bytes at position <code>offset</code> into the \n+    * buffer and\n+    * reads a maximum of <code>len</code> bytes.  Note that this method \n+    * can actually\n+    * read fewer than <code>len</code> bytes.  The actual number of bytes \n+    * read is\n     * returned.  A -1 is returned to indicated that no bytes can be read\n     * because the end of the stream was reached.  If the stream is already\n     * closed, a -1 will again be returned to indicate the end of the stream.\n@@ -255,9 +261,12 @@ public int read() throws IOException\n   \n   /**\n     * This method reads bytes from the stream into a caller supplied buffer.\n-    * It starts storing bytes at position <code>offset</code> into the buffer and\n-    * reads a maximum of <code>len</code> bytes.  Note that this method can actually\n-    * read fewer than <code>len</code> bytes.  The actual number of bytes read is\n+    * It starts storing bytes at position <code>offset</code> into the \n+    * buffer and\n+    * reads a maximum of <code>len</code> bytes.  Note that this method \n+    * can actually\n+    * read fewer than <code>len</code> bytes.  The actual number of bytes \n+    * read is\n     * returned.  A -1 is returned to indicated that no bytes can be read\n     * because the end of the stream was reached - ie close() was called on the\n     * connected PipedOutputStream.\n@@ -371,3 +380,4 @@ public synchronized void close() throws IOException\n     notifyAll();\n   }\n }\n+"}, {"sha": "ec135427d0954177cf86e89c75006c093c55665b", "filename": "libjava/java/io/PipedReader.java", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPipedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPipedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedReader.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -118,7 +118,8 @@ public PipedReader(PipedWriter source) throws IOException\n   }\n \n   /**\n-    * This method connects this stream to the passed in <code>PipedWriter</code>.\n+    * This method connects this stream to the passed in \n+    * <code>PipedWriter</code>.\n     * This stream is then ready for reading.  If this stream is already\n     * connected or has been previously closed, then an exception is thrown\n     *\n@@ -207,9 +208,12 @@ void receive(char[] buf, int offset, int len)\n   \n   /**\n     * This method reads chars from the stream into a caller supplied buffer.\n-    * It starts storing chars at position <code>offset</code> into the buffer and\n-    * reads a maximum of <code>len</code> chars.  Note that this method can actually\n-    * read fewer than <code>len</code> chars.  The actual number of chars read is\n+    * It starts storing chars at position <code>offset</code> into the \n+    * buffer and\n+    * reads a maximum of <code>len</code> chars.  Note that this method \n+    * can actually\n+    * read fewer than <code>len</code> chars.  The actual number of chars \n+    * read is\n     * returned.  A -1 is returned to indicated that no chars can be read\n     * because the end of the stream was reached.  If the stream is already\n     * closed, a -1 will again be returned to indicate the end of the stream.\n@@ -237,10 +241,11 @@ public int read() throws IOException\n   }\n   \n   /**\n-    * This method reads characters from the stream into a caller supplied buffer.\n-    * It starts storing chars at position <code>offset</code> into the buffer and\n-    * reads a maximum of <code>len</code> chars.  Note that this method can actually\n-    * read fewer than <code>len</code> chars.  The actual number of chars read is\n+    * This method reads characters from the stream into a caller supplied \n+    * buffer. It starts storing chars at position <code>offset</code> into \n+    * the buffer and reads a maximum of <code>len</code> chars.  Note that \n+    * this method can actually read fewer than <code>len</code> chars.  \n+    * The actual number of chars read is\n     * returned.  A -1 is returned to indicated that no chars can be read\n     * because the end of the stream was reached - ie close() was called on the\n     * connected PipedWriter.\n@@ -361,3 +366,4 @@ public void close() throws IOException\n     }\n   }\n }\n+"}, {"sha": "acc6ae46e3dad8e6184c7dcd646e08aac855257c", "filename": "libjava/java/io/PrintWriter.java", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPrintWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPrintWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPrintWriter.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -48,8 +48,6 @@\n   * class which also auto-flushes when it encounters a newline character\n   * in the chars written).\n   *\n-  * @version 0.0\n-  *\n   * @author Per Bothner <bothner@cygnus.com>\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   * @date April 17, 1998.  \n@@ -99,7 +97,8 @@ public PrintWriter(Writer wr)\n    * every line is terminated or newline character is written.\n    *\n    * @param wr The <code>Writer</code> to write to.\n-   * @param autoflush <code>true</code> to flush the stream after every line, <code>false</code> otherwise\n+   * @param autoflush <code>true</code> to flush the stream after every \n+   * line, <code>false</code> otherwise\n    */\n   public PrintWriter(Writer wr, boolean autoflush)\n   {\n@@ -130,7 +129,8 @@ public PrintWriter(OutputStream out)\n    * constructor allows auto-flush functionality to be enabled if desired\n    *\n    * @param out The <code>OutputStream</code> to write to\n-   * @param autoflush <code>true</code> to flush the stream after every <code>println</code> call, <code>false</code> otherwise.\n+   * @param autoflush <code>true</code> to flush the stream after every \n+   * <code>println</code> call, <code>false</code> otherwise.\n    */\n   public PrintWriter(OutputStream out, boolean autoflush)\n   {\n@@ -153,7 +153,8 @@ protected void setError()\n    * <code>true</code> forever for this stream.  Before checking for an\n    * error condition, this method flushes the stream.\n    *\n-   * @return <code>true</code> if an error has occurred, <code>false</code> otherwise\n+   * @return <code>true</code> if an error has occurred, \n+   * <code>false</code> otherwise\n    */\n   public boolean checkError()\n   {\n@@ -309,7 +310,7 @@ public void print(Object obj)\n    * This is the system dependent line separator\n    */\n   private static final char[] line_separator\n-  = System.getProperty(\"line.separator\").toCharArray();\n+    = System.getProperty(\"line.separator\").toCharArray();\n \n   /**\n    * This method prints a line separator sequence to the stream.  The value\n@@ -567,3 +568,4 @@ public void write(String str)\n     write(str, 0, str.length());\n   }  \n }\n+"}, {"sha": "4a353190d814fe1a9ff28ba0edbd398079222a4a", "filename": "libjava/java/io/PushbackReader.java", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPushbackReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FPushbackReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPushbackReader.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* PushbackReader.java -- An character stream that can unread chars\n-   Copyright (C) 1998, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -48,8 +48,6 @@\n  * The default pushback buffer size one char, but this can be overridden\n  * by the creator of the stream.\n  *\n- * @version 0.0\n- *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Warren Levy <warrenl@cygnus.com>\n  */\n@@ -136,7 +134,8 @@ public void mark(int read_limit) throws IOException\n    * This method returns <code>false</code> to indicate that it does not support\n    * mark/reset functionality.\n    *\n-   * @return This method returns <code>false</code> to indicate that this class does not support mark/reset functionality\n+   * @return This method returns <code>false</code> to indicate that this \n+   * class does not support mark/reset functionality\n    *\n    */\n   public boolean markSupported()\n@@ -165,7 +164,8 @@ public void reset() throws IOException\n    * read in the pushback buffer or if the underlying stream is ready to\n    * be read.\n    *\n-   * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n+   * @return <code>true</code> if this stream is ready to be read, \n+   * <code>false</code> otherwise\n    *\n    * @exception IOException If an error occurs\n    */\n@@ -252,7 +252,8 @@ public int read() throws IOException\n \n   /**\n    * This method read chars from a stream and stores them into a caller\n-   * supplied buffer.  It starts storing the data at index <code>offset</code> into\n+   * supplied buffer.  It starts storing the data at index <code>offset</code>\n+   * into\n    * the buffer and attempts to read <code>len</code> chars.  This method can\n    * return before reading the number of chars requested.  The actual number\n    * of chars read is returned as an int.  A -1 is returned to indicate the\n@@ -302,8 +303,8 @@ public synchronized int read(char[] b, int offset, int len) throws IOException\n    * <p>\n    * If the pushback buffer is full, this method throws an exception.\n    * <p>\n-   * The argument to this method is an <code>int</code>.  Only the low eight bits\n-   * of this value are pushed back.\n+   * The argument to this method is an <code>int</code>.  Only the low eight \n+   * bits of this value are pushed back.\n    *\n    * @param b The char to be pushed back, passed as an int\n    *\n@@ -343,7 +344,8 @@ public synchronized void unread(char[] buf) throws IOException\n \n   /**\n    * This method pushed back chars from the passed in array into the pushback\n-   * buffer.  The chars from <code>buf[offset]</code> to <code>buf[offset + len]</code>\n+   * buffer.  The chars from <code>buf[offset]</code> to \n+   * <code>buf[offset + len]</code>\n    * are pushed in reverse order so that the next char read from the stream\n    * after this operation will be <code>buf[offset]</code> followed by\n    * <code>buf[offset + 1]</code>, etc.\n@@ -378,3 +380,4 @@ public synchronized void unread(char[] b, int offset, int len)\n       }\n   }\n }\n+"}, {"sha": "be8794928fd52f99d91d03fe0959785b712bdcf6", "filename": "libjava/java/io/Reader.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FReader.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* Reader.java -- base class of classes that read input as a stream of chars\n-   Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+   Copyright (C) 1998, 1999, 2000, 2003  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -222,7 +222,8 @@ public void reset() throws IOException\n     * <p>\n     * This method always returns <code>false</code> in this class\n     *\n-    * @return <code>true</code> if the stream is ready to be read, <code>false</code> otherwise.\n+    * @return <code>true</code> if the stream is ready to be read, \n+    * <code>false</code> otherwise.\n     *\n     * @exception IOException If an error occurs\n     */"}, {"sha": "85b9cdf24454bdb5891e42098cf1ca34d2bfb9b7", "filename": "libjava/java/io/SerializablePermission.java", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FSerializablePermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FSerializablePermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FSerializablePermission.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* SerializablePermission.java -- Basic permissions related to serialization.\n-   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -55,64 +55,63 @@\n   *\n   * @see java.security.BasicPermission\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public final class SerializablePermission extends BasicPermission\n {\n   static final long serialVersionUID = 8537212141160296410L;\n \t\n-/*\n- * Class Variables\n- */\n-\n-private static final String[] legal_names = { \"enableSubclassImplementation\",\n-\t\t\t\t\t      \"enableSubstitution\" };\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This method initializes a new instance of <code>SerializablePermission</code>\n-  * that has the specified name.\n-  *\n-  * @param name The name of the permission.\n-  *\n-  * @exception IllegalArgumentException If the name is not valid for this class.\n-  */\n-public\n-SerializablePermission(String name)\n-{\n-  this(name, null);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a new instance of <code>SerializablePermission</code>\n-  * that has the specified name and action list.  Note that the action list\n-  * is unused in this class.\n-  *\n-  * @param name The name of the permission.\n-  * @param actions The action list (unused).\n-  *\n-  * @exception IllegalArgumentException If the name is not valid for this class.\n-  */\n-public\n-SerializablePermission(String name, String actions)\n-{\n-  super(name, actions);\n-\n-  for (int i = 0; i < legal_names.length; i++)\n-    if (legal_names[i].equals(name))\n-      return;\n-\n-  throw new IllegalArgumentException(\"Bad permission name:  \" + name);\n-}\n-\n+  /*\n+   * Class Variables\n+   */\n+\n+  private static final String[] legal_names = { \"enableSubclassImplementation\",\n+  \t\t\t\t\t      \"enableSubstitution\" };\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+    * This method initializes a new instance of \n+    * <code>SerializablePermission</code>\n+    * that has the specified name.\n+    *\n+    * @param name The name of the permission.\n+    *\n+    * @exception IllegalArgumentException If the name is not valid for\n+    * this class.\n+    */\n+  public SerializablePermission(String name)\n+  {\n+    this(name, null);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method initializes a new instance of \n+    * <code>SerializablePermission</code>\n+    * that has the specified name and action list.  Note that the action list\n+    * is unused in this class.\n+    *\n+    * @param name The name of the permission.\n+    * @param actions The action list (unused).\n+    *\n+    * @exception IllegalArgumentException If the name is not valid for \n+    * this class.\n+    */\n+  public SerializablePermission(String name, String actions)\n+  {\n+    super(name, actions);\n+\n+    for (int i = 0; i < legal_names.length; i++)\n+      if (legal_names[i].equals(name))\n+        return;\n+\n+    throw new IllegalArgumentException(\"Bad permission name:  \" + name);\n+  }\n \n } // class SerializablePermission\n "}, {"sha": "8153d80d91b7dd70889f5731827771fd613236d7", "filename": "libjava/java/io/StringReader.java", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FStringReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FStringReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStringReader.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* StringReader.java -- permits a String to be read as a character input stream\n-   Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+   Copyright (C) 1998, 1999, 2000, 2003  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -51,8 +51,6 @@\n  * normal.  If no mark has been set, then calling the <code>reset()</code>\n  * method rewinds the read pointer to the beginning of the <code>String</code>.\n  *\n- * @version 0.0\n- *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Warren Levy <warrenl@cygnus.com>\n  * @date October 19, 1998.  \n@@ -73,8 +71,8 @@ public class StringReader extends Reader\n \n   /**\n    * Create a new <code>StringReader</code> that will read chars from the \n-   * passed in <code>String</code>.  This stream will read from the beginning to the \n-   * end of the <code>String</code>.\n+   * passed in <code>String</code>.  This stream will read from the beginning \n+   * to the end of the <code>String</code>.\n    *\n    * @param s The <code>String</code> this stream will read from.\n    */\n@@ -208,3 +206,4 @@ public long skip(long n) throws IOException\n     }\n   }\n }\n+"}, {"sha": "3b2cf79ffdc1ebed6128e74dc63852391114e363", "filename": "libjava/java/io/Writer.java", "status": "modified", "additions": 157, "deletions": 164, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f5d1d62161cc99ecfc68495d501342aa1e61dc/libjava%2Fjava%2Fio%2FWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FWriter.java?ref=f4f5d1d62161cc99ecfc68495d501342aa1e61dc", "patch": "@@ -1,5 +1,5 @@\n /* Writer.java -- Base class for character output streams\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -55,168 +55,161 @@\n   */\n public abstract class Writer\n {\n-\n-/*************************************************************************/\n-\n-/**\n-  * This is the object used to synchronize criticial code sections for\n-  * thread safety.  Subclasses should use this field instead of using\n-  * synchronized methods or explicity synchronizations on <code>this</code>\n-  */\n-protected Object lock;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This is the default no-argument constructor for this class.  This method\n-  * will set up the class to synchronize criticial sections on itself.\n-  */\n-protected\n-Writer()\n-{\n-  lock = this;\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a <code>Writer</code> that will synchronize\n-  * on the specified <code>Object</code>.\n-  *\n-  * @param obj The <code>Object</code> to use for synchronizing critical\n-  *            sections\n-  */\n-protected\n-Writer(Object lock)\n-{\n-  this.lock = lock;\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * This method forces any data that may have been buffered to be written\n-  * to the underlying output device.  Please note that the host environment\n-  * might perform its own buffering unbeknowst to Java.  In that case, a\n-  * write made (for example, to a disk drive) might be cached in OS\n-  * buffers instead of actually being written to disk.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-flush() throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method closes the stream.  Any internal or native resources associated\n-  * with this stream are freed.  Any subsequent attempt to access the stream\n-  * might throw an exception.\n-  * <p>\n-  * This method in this class does nothing.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-close() throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a single char to the output stream. \n-  *\n-  * @param b The char to be written to the output stream, passed as an int\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(int b) throws IOException\n-{\n-  char[] buf = new char[1];\n-\n-  buf[0] = (char)b;\n-  write(buf, 0, buf.length);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method all the writes char from the passed array to the output stream.\n-  * This method is equivalent to <code>write(buf, 0, buf.length)</code> which\n-  * is exactly how it is implemented in this class.\n-  *\n-  * @param buf The array of char to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(char[] buf) throws IOException\n-{\n-  write(buf, 0, buf.length);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes <code>len</code> char from the specified array\n-  * <code>buf</code> starting at index <code>offset</code> into the array.\n-  * <p>\n-  * Subclasses must provide an implementation of this abstract method.\n-  *\n-  * @param buf The array of char to write from\n-  * @param offset The index into the array to start writing from\n-  * @param len The number of char to write\n-  * \n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-write(char[] buf, int offset, int len) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes all the characters in a <code>String</code> to the\n-  * output.\n-  *\n-  * @param str The <code>String</code> whose chars are to be written.\n-  *\n-  * @param IOException If an error occurs\n-  */\n-public void\n-write(String str) throws IOException\n-{\n-  write(str, 0, str.length());\n-} \n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes <code>len</code> chars from the <code>String</code>\n-  * starting at position <code>offset</code>.\n-  *\n-  * @param str The <code>String</code> that is to be written\n-  * @param offset The character offset into the <code>String</code> to start\n-  *               writing from\n-  * @param len The number of chars to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public void\n-write(String str, int offset, int len) throws IOException\n-{\n-  // FIXME - for libgcj re-write using native code to not require copied buffer.\n-  char[] buf = new char[len];\n-\n-  str.getChars(offset, offset + len, buf, 0);\n-  write(buf, 0, len);\n-}\n+  /**\n+    * This is the object used to synchronize criticial code sections for\n+    * thread safety.  Subclasses should use this field instead of using\n+    * synchronized methods or explicity synchronizations on <code>this</code>\n+    */\n+  protected Object lock;\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+    * This is the default no-argument constructor for this class.  This method\n+    * will set up the class to synchronize criticial sections on itself.\n+    */\n+  protected Writer()\n+  {\n+    lock = this;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method initializes a <code>Writer</code> that will synchronize\n+    * on the specified <code>Object</code>.\n+    *\n+    * @param obj The <code>Object</code> to use for synchronizing critical\n+    *            sections\n+    */\n+  protected Writer(Object lock)\n+  {\n+    this.lock = lock;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Methods\n+   */\n+\n+  /**\n+    * This method forces any data that may have been buffered to be written\n+    * to the underlying output device.  Please note that the host environment\n+    * might perform its own buffering unbeknowst to Java.  In that case, a\n+    * write made (for example, to a disk drive) might be cached in OS\n+    * buffers instead of actually being written to disk.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void flush() throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method closes the stream.  Any internal or native resources \n+    * associated\n+    * with this stream are freed.  Any subsequent attempt to access the stream\n+    * might throw an exception.\n+    * <p>\n+    * This method in this class does nothing.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void close() throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a single char to the output stream. \n+    *\n+    * @param b The char to be written to the output stream, passed as an int\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(int b) throws IOException\n+  {\n+    char[] buf = new char[1];\n+\n+    buf[0] = (char)b;\n+    write(buf, 0, buf.length);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method all the writes char from the passed array to the output \n+    * stream. This method is equivalent to \n+    * <code>write(buf, 0, buf.length)</code> which\n+    * is exactly how it is implemented in this class.\n+    *\n+    * @param buf The array of char to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(char[] buf) throws IOException\n+  {\n+    write(buf, 0, buf.length);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes <code>len</code> char from the specified array\n+    * <code>buf</code> starting at index <code>offset</code> into the array.\n+    * <p>\n+    * Subclasses must provide an implementation of this abstract method.\n+    *\n+    * @param buf The array of char to write from\n+    * @param offset The index into the array to start writing from\n+    * @param len The number of char to write\n+    * \n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void write(char[] buf, int offset, int len) \n+    throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes all the characters in a <code>String</code> to the\n+    * output.\n+    *\n+    * @param str The <code>String</code> whose chars are to be written.\n+    *\n+    * @param IOException If an error occurs\n+    */\n+  public void write(String str) throws IOException\n+  {\n+    write(str, 0, str.length());\n+  } \n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes <code>len</code> chars from the <code>String</code>\n+    * starting at position <code>offset</code>.\n+    *\n+    * @param str The <code>String</code> that is to be written\n+    * @param offset The character offset into the <code>String</code> to start\n+    *               writing from\n+    * @param len The number of chars to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public void write(String str, int offset, int len) throws IOException\n+  {\n+    // FIXME - for libgcj re-write using native code to not require \n+    // copied buffer.\n+    char[] buf = new char[len];\n+\n+    str.getChars(offset, offset + len, buf, 0);\n+    write(buf, 0, len);\n+  }\n \n } // class Writer\n+"}]}