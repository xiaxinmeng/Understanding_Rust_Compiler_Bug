{"sha": "005dda25ff98c6762242f1eaa20eb8795f30a766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1ZGRhMjVmZjk4YzY3NjIyNDJmMWVhYTIwZWI4Nzk1ZjMwYTc2Ng==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "1998-09-17T08:04:30Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "1998-09-17T08:04:30Z"}, "message": "Move documentation files from egcs/gcc/objc.\n\nFrom-SVN: r22461", "tree": {"sha": "b8630279e559f3c950e92a27c2b4aa0daacb432a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8630279e559f3c950e92a27c2b4aa0daacb432a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/005dda25ff98c6762242f1eaa20eb8795f30a766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005dda25ff98c6762242f1eaa20eb8795f30a766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005dda25ff98c6762242f1eaa20eb8795f30a766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005dda25ff98c6762242f1eaa20eb8795f30a766/comments", "author": null, "committer": null, "parents": [{"sha": "9d2106a4a4f9d5acab8bdac8e3eb619c9ef554b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2106a4a4f9d5acab8bdac8e3eb619c9ef554b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d2106a4a4f9d5acab8bdac8e3eb619c9ef554b6"}], "stats": {"total": 936, "additions": 936, "deletions": 0}, "files": [{"sha": "f478d67dec8fa6c2403330214468a09025e28e47", "filename": "libobjc/README", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FREADME?ref=005dda25ff98c6762242f1eaa20eb8795f30a766", "patch": "@@ -0,0 +1,97 @@\n+\n+GNU Objective C notes\n+*********************\n+\n+This document is to explain what has been done, and a little about how\n+specific features differ from other implementations.  The runtime has\n+been completely rewritten in gcc 2.4.  The earlier runtime had several\n+severe bugs and was rather incomplete.  The compiler has had several\n+new features added as well.\n+\n+This is not documentation for Objective C, it is usable to someone\n+who knows Objective C from somewhere else.\n+\n+\n+Runtime API functions\n+=====================\n+\n+The runtime is modeled after the NeXT Objective C runtime.  That is,\n+most functions have semantics as it is known from the NeXT.  The\n+names, however, have changed.  All runtime API functions have names\n+of lowercase letters and underscores as opposed to the\n+`traditional' mixed case names.  \n+\tThe runtime api functions are not documented as of now.\n+Someone offered to write it, and did it, but we were not allowed to\n+use it by his university (Very sad story).  We have started writing\n+the documentation over again.  This will be announced in appropriate\n+places when it becomes available.\n+\n+\n+Protocols\n+=========\n+\n+Protocols are now fully supported.  The semantics is exactly as on the\n+NeXT.  There is a flag to specify how protocols should be typechecked\n+when adopted to classes.  The normal typechecker requires that all\n+methods in a given protocol must be implemented in the class that\n+adopts it -- it is not enough to inherit them.  The flag\n+`-Wno-protocol' causes it to allow inherited methods, while\n+`-Wprotocols' is the default which requires them defined.\n+\n+\n++initialize \n+===========\n+\n+This method, if defined, is called before any other instance or class\n+methods of that particular class.  This method is not inherited, and\n+is thus not called as initializer for a subclass that doesn't define\n+it itself.  Thus, each +initialize method is called exactly once (or\n+never if no methods of that particular class is never called).\n+Besides this, it is allowed to have several +initialize methods, one\n+for each category.  The order in which these (multiple methods) are\n+called is not well defined.  I am not completely certain what the\n+semantics of this method is for other implementations, but this is\n+how it works for GNU Objective C.\n+\n+\n+Passivation/Activation/Typedstreams\n+===================================\n+\n+This is supported in the style of NeXT TypedStream's.  Consult the\n+headerfile Typedstreams.h for api functions.  I (Kresten) have\n+rewritten it in Objective C, but this implementation is not part of\n+2.4, it is available from the GNU Objective C prerelease archive. \n+   There is one difference worth noting concerning objects stored with\n+objc_write_object_reference (aka NXWriteObjectReference).  When these\n+are read back in, their object is not guaranteed to be available until\n+the `-awake' method is called in the object that requests that object.\n+To objc_read_object you must pass a pointer to an id, which is valid\n+after exit from the function calling it (like e.g. an instance\n+variable).  In general, you should not use objects read in until the\n+-awake method is called.\n+\n+\n+Acknowledgements\n+================\n+\n+The GNU Objective C team: Geoffrey Knauth <gsk@marble.com> (manager),\n+Tom Wood <wood@next.com> (compiler) and Kresten Krab Thorup\n+<krab@iesd.auc.dk> (runtime) would like to thank a some people for\n+participating in the development of the present GNU Objective C.\n+\n+Paul Burchard <burchard@geom.umn.edu> and Andrew McCallum\n+<mccallum@cs.rochester.edu> has been very helpful debugging the\n+runtime.   Eric Herring <herring@iesd.auc.dk> has been very helpful\n+cleaning up after the documentation-copyright disaster and is now\n+helping with the new documentation.\n+\n+Steve Naroff <snaroff@next.com> and Richard Stallman\n+<rms@gnu.ai.mit.edu> has been very helpful with implementation details\n+in the compiler.\n+\n+\n+Bug Reports\n+===========\n+\n+Please read the section `Submitting Bugreports' of the gcc manual\n+before you submit any bugs."}, {"sha": "5f15bd9cb45c99ae5395fe1dad99e9816545951c", "filename": "libobjc/README.threads", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FREADME.threads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FREADME.threads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FREADME.threads?ref=005dda25ff98c6762242f1eaa20eb8795f30a766", "patch": "@@ -0,0 +1,50 @@\n+==============================================================================\n+README.threads - Wed Nov 29 15:16:24 EST 1995\n+------------------------------------------------------------------------------\n+\n+Limited documentation is available in the THREADS file.\n+\n+This version has been tested on Sun Solaris, SGI Irix, and Windows NT.\n+It should also work on any single threaded system.\n+\n+Thanks go to the following people for help test and debug the library:\n+\n+\tScott Christley, scottc@ocbi.com\n+\tAndrew McCallum, mccallum@cs.rochester.edu\n+\n+galen\n+gchunt@cs.rochester.edu\n+\n+Any questions, bug reports, etc should be directed to:\n+\n+Scott Christley, scottc@ocbi.com\n+\n+Please do not bug Galen with email as he no longer supports the code.\n+\n+==============================================================================\n+Changes from prior releases (in revered chronological order):\n+------------------------------------------------------------------------------\n+\n+* Fixed bug in copy part of sarray_realloc.  I had an < which should\n+  have been <=. (Bug report from Scott).\n+\n+------------------------------------------------------------------------------\n+\n+* Support for DEC OSF/1 is definitely broken.  My programs always\n+  seg-fault when I link with libpthreads.a.\n+\n+* Thread id's are no longer int's, but are instead of type\n+  _objc_thread_t which is typedef'ed from a void *.  An invalid thread\n+  id is denoted by NULL and not -1 as before.\n+\n+------------------------------------------------------------------------------\n+\n+* Renamed thread-winnt.c to thread-win32.c to better reflect support\n+  for the API on both Windows NT and Windows 95 platforms.  \n+  (Who knows, maybe even Win32s :-).\n+\n+* Fixed bugs in Win32 support as per report from Scott Christley.\n+\n+* Fixed bug in sarray_get as per report from Scott Christley.\n+\n+\t"}, {"sha": "9dfbbed97af2a422c61ec129eef8ca08527e0f46", "filename": "libobjc/THREADS", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FTHREADS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FTHREADS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FTHREADS?ref=005dda25ff98c6762242f1eaa20eb8795f30a766", "patch": "@@ -0,0 +1,374 @@\n+This file describes in little detail the modifications to the\n+Objective-C runtime needed to make it thread safe. \n+\n+First off, kudos to Galen Hunt who is the author of this great work.\n+\n+If you have an comments or just want to know where to\n+send me money to express your undying gratitude for threading the\n+Objective-C runtime you can reach Galen at:\n+\n+\tgchunt@cs.rochester.edu\n+\n+Any questions, comments, bug reports, etc. should send email either to the\n+GCC bug account or to:\n+\n+\tScott Christley <scottc@net-community.com>\n+\n+* Sarray Threading:\n+\n+The most critical component of the Objective-C runtime is the sparse array\n+structure (sarray).  Sarrays store object selectors and implementations.  \n+Following in the tradition of the Objective-C runtime, my threading\n+support assumes that fast message dispatching is far more important\n+than *ANY* and *ALL* other operations.  The message dispatching thus\n+uses *NO* locks on any kind.  In fact, if you look in sarray.h, you\n+will notice that the message dispatching has not been modified.\n+Instead, I have modified the sarray management functions so that all\n+updates to the sarray data structure can be made in parallel will\n+message dispatching.  \n+\n+To support concurrent message dispatching, no dynamically allocated\n+sarray data structures are freed while more than one thread is\n+operational.  Sarray data structures that are no longer in use are\n+kept in a linked list of garbage and are released whenever the program\n+is operating with a single thread.  The programmer can also flush the \n+garbage list by calling sarray_remove_garbage when the programmer can\n+ensure that no message dispatching is taking place concurrently.  The\n+amount of un-reclaimed sarray garbage should normally be extremely\n+small in a real program as sarray structures are freed only when using\n+the \"poseAs\" functionality and early in program initialization, which\n+normally occurs while the program is single threaded.\n+\n+******************************************************************************\n+* Static Variables:\n+\n+The following variables are either statically or globally defined. This list \n+does not include variables which are internal to implementation dependent \n+versions of thread-*.c.\n+\n+The following threading designations are used:\n+\tSAFE   : Implicitly thread safe.\n+\tSINGLE : Must only be used in single thread mode.\n+\tMUTEX  : Protected by single global mutex objc_runtime_mutex.\n+\tUNUSED : Not used in the runtime.\n+\n+Variable Name:\t\t\tUsage:  Defined:\tAlso used in:\n+===========================\t======\t============\t=====================\n+__objc_class_hash\t\tMUTEX\tclass.c\n+__objc_class_links_resolved\tUNUSED\tclass.c\t\truntime.h\n+__objc_class_number\t\tMUTEX\tclass.c\n+__objc_dangling_categories\tUNUSED\tinit.c\n+__objc_module_list\t\tMUTEX\tinit.c\n+__objc_selector_array\t\tMUTEX\tselector.c\n+__objc_selector_hash\t\tMUTEX\tselector.c\n+__objc_selector_max_index\tMUTEX\tselector.c\tsendmsg.c runtime.h\n+__objc_selector_names\t\tMUTEX\tselector.c\n+__objc_thread_exit_status\tSAFE\tthread.c\n+__objc_uninstalled_dtable\tMUTEX\tsendmsg.c\tselector.c\n+_objc_load_callback\t\tSAFE\tinit.c\t\tobjc-api.h\n+_objc_lookup_class\t\tSAFE\tclass.c\t\tobjc-api.h\n+_objc_object_alloc\t\tSINGLE\tobjects.c\tobjc-api.h\n+_objc_object_copy\t\tSINGLE\tobjects.c\tobjc-api.h\n+_objc_object_dispose\t\tSINGLE\tobjects.c\tobjc-api.h\n+frwd_sel\t\t\tSAFE2\tsendmsg.c\n+idxsize\t\t\t\tMUTEX\tsarray.c\tsendmsg.c sarray.h\n+initialize_sel\t\t\tSAFE2\tsendmsg.c\n+narrays\t\t\t\tMUTEX\tsarray.c\tsendmsg.c sarray.h\n+nbuckets\t\t\tMUTEX\tsarray.c\tsendmsg.c sarray.h\n+nindices\t\t\tMUTEX\tsarray.c\tsarray.h\n+previous_constructors\t\tSAFE1\tinit.c\n+proto_class\t\t\tSAFE1\tinit.c\n+unclaimed_categories\t\tMUTEX\tinit.c\n+unclaimed_proto_list\t\tMUTEX\tinit.c\n+uninitialized_statics\t\tMUTEX\tinit.c\n+\n+Notes:\n+1) Initialized once in unithread mode.\n+2) Initialized value will always be same, guaranteed by lock on selector \n+   hash table.\n+\n+\n+******************************************************************************\n+* Frontend/Backend design:\n+\n+The design of the Objective-C runtime thread and mutex functions utilizes a\n+frontend/backend implementation.\n+\n+The frontend, as characterized by the files thr.h and thr.c, is a set\n+of platform independent structures and functions which represent the\n+user interface.  Objective-C programs should use these structures and\n+functions for their thread and mutex work if they wish to maintain a\n+high degree of portability across platforms.\n+\n+The backend is composed of a file with the necessary code to map the ObjC\n+thread and mutex to a platform specific implementation.  For example, the\n+file thr-solaris.c contains the implementation for Solaris.  When you \n+configure GCC, it attempts to pick an appropriate backend file for the\n+target platform; however, you can override this choice by assign the\n+OBJC_THREAD_FILE make variable to the basename of the backend file.  This\n+is especially useful on platforms which have multiple thread libraries.\n+For example:\n+\n+\tmake OBJC_THREAD_FILE=thr-posix\n+\n+would indicate that the generic posix backend file, thr-posix.c, should be\n+compiled with the ObjC runtime library.  If your platform does not support\n+threads then you should specify the OBJC_THREAD_FILE=thr-single backend file\n+to compile the ObjC runtime library without thread or mutex support; note\n+that programs which rely upon the ObjC thread and mutex functions will\n+compile and link correctly but attempting to create a thread or mutex will\n+result in an error.\n+\n+It is questionable whether it is really necessary to have both a\n+frontend and backend function for all available functionality.  On the\n+one hand, it provides a clear, consistent differentiation between what\n+is public and what is private with the downside of having the overhead\n+of multiple functions calls.  For example, the function to have a thread\n+yield the processor is objc_thread_yield; in the current implementation\n+this produces a function call set:\n+\n+objc_thread_yield()  ->  __objc_thread_yield()  ->  system yield function\n+\n+This has two extra function calls over calling the platform specific function\n+explicitly, but the issue is whether only the overhead of a single function\n+is necessary.\n+\n+objc_thread_yield()  ->  system yield function\n+\n+This breaks the public/private dichotomy between the frontend/backend\n+for the sake of efficiency.  It is possible to just use a preprocessor\n+define so as to eliminate the extra function call:\n+\n+#define objc_thread_yield() __objc_thread_yield()\n+\n+This has the undesirable effect that if objc_thread_yield is actually\n+turned into a function based upon future need; then ObjC programs which\n+access the thread functions would need to be recompiled versus just\n+being relinked.\n+ \n+******************************************************************************\n+* Threads:\n+\n+The thread system attempts to create multiple threads using whatever\n+operating system or library thread support is available.  It does\n+assume that all system functions are thread safe.  Notably this means\n+that the system implementation of malloc and free must be thread safe.\n+If a system has multiple processors, the threads are configured for\n+full parallel processing.\n+\n+* Backend initialization functions\n+\n+__objc_init_thread_system(void), int\n+\tInitialize the thread subsystem.  Called once by __objc_exec_class.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_close_thread_system(void), int\n+\tCloses the thread subsystem, not currently guaranteed to be called.\n+\tReturn -1 if error otherwise return 0.\n+\n+*****\n+* Frontend thread functions\n+* User programs should use these functions.\n+\n+objc_thread_detach(SEL selector, id object, id argument), objc_thread_t\n+\tCreates and detaches a new thread.  The new thread starts by\n+\tsending the given selector with a single argument to the\n+\tgiven object.\n+\n+objc_thread_set_priority(int priority), int\n+\tSets a thread's relative priority within the program.  Valid\n+\toptions are:\n+\t\n+\tOBJC_THREAD_INTERACTIVE_PRIORITY\n+\tOBJC_THREAD_BACKGROUND_PRIORITY\n+\tOBJC_THREAD_LOW_PRIORITY\n+\n+objc_thread_get_priority(void), int\n+\tQuery a thread's priority.\n+\n+objc_thread_yield(void), void\n+\tYields processor to another thread with equal or higher\n+\tpriority.  It is up to the system scheduler to determine if\n+\tthe processor is taken or not.\n+\n+objc_thread_exit(void), int\n+\tTerminates a thread.  If this is the last thread executing\n+\tthen the program will terminate.\n+\n+objc_thread_id(void), int\n+\tReturns the current thread's id.\n+\n+objc_thread_set_data(void *value), int\n+\tSet a pointer to the thread's local storage.  Local storage is\n+\tthread specific.\n+\n+objc_thread_get_data(void), void *\n+\tReturns the pointer to the thread's local storage.\n+\n+*****\n+* Backend thread functions\n+* User programs should *NOT* directly call these functions.\n+\n+__objc_thread_detach(void (*func)(void *arg), void *arg), objc_thread_t\n+\tSpawns a new thread executing func, called by objc_thread_detach.\n+\tReturn NULL if error otherwise return thread id.\n+\n+__objc_thread_set_priority(int priority), int\n+\tSet the thread's priority, called by objc_thread_set_priority.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_thread_get_priority(void), int\n+\tQuery a thread's priority, called by objc_thread_get_priority.\n+\tReturn -1 if error otherwise return the priority.\n+\n+__objc_thread_yield(void), void\n+\tYields the processor, called by objc_thread_yield.\n+\n+__objc_thread_exit(void), int\n+\tTerminates the thread, called by objc_thread_exit.\n+\tReturn -1 if error otherwise function does not return.\n+\n+__objc_thread_id(void), objc_thread_t\n+\tReturns the current thread's id, called by objc_thread_id.\n+\tReturn -1 if error otherwise return thread id.\n+\n+__objc_thread_set_data(void *value), int\n+\tSet pointer for thread local storage, called by objc_thread_set_data.\n+\tReturns -1 if error otherwise return 0.\n+\n+__objc_thread_get_data(void), void *\n+\tReturns the pointer to the thread's local storage.\n+\tReturns NULL if error, called by objc_thread_get_data.\n+\n+\n+******************************************************************************\n+* Mutexes:\n+\n+Mutexes can be locked recursively.  Each locked mutex remembers\n+its owner (by thread id) and how many times it has been locked.  The\n+last unlock on a mutex removes the system lock and allows other\n+threads to access the mutex.\n+\n+*****\n+* Frontend mutex functions\n+* User programs should use these functions.\n+\n+objc_mutex_allocate(void), objc_mutex_t\n+\tAllocates a new mutex.  Mutex is initially unlocked.\n+\tReturn NULL if error otherwise return mutex pointer.\n+\n+objc_mutex_deallocate(objc_mutex_t mutex), int\n+\tFree a mutex.  Before freeing the mutex, makes sure that no\n+\tone else is using it.\n+\tReturn -1 if error otherwise return 0.\n+\n+objc_mutex_lock(objc_mutex_t mutex), int\n+\tLocks a mutex.  As mentioned earlier, the same thread may call\n+\tthis routine repeatedly.\n+\tReturn -1 if error otherwise return 0.\n+\t\n+objc_mutex_trylock(objc_mutex_t mutex), int\n+\tAttempts to lock a mutex.  If lock on mutex can be acquired \n+\tthen function operates exactly as objc_mutex_lock.\n+\tReturn -1 if failed to acquire lock otherwise return 0.\n+\n+objc_mutex_unlock(objc_mutex_t mutex), int\n+\tUnlocks the mutex by one level.  Other threads may not acquire\n+\tthe mutex until this thread has released all locks on it.\n+\tReturn -1 if error otherwise return 0.\n+\n+*****\n+* Backend mutex functions\n+* User programs should *NOT* directly call these functions.\n+\n+__objc_mutex_allocate(objc_mutex_t mutex), int\n+\tAllocates a new mutex, called by objc_mutex_allocate.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_mutex_deallocate(objc_mutex_t mutex), int\n+\tFree a mutex, called by objc_mutex_deallocate.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_mutex_lock(objc_mutex_t mutex), int\n+\tLocks a mutex, called by objc_mutex_lock.\n+\tReturn -1 if error otherwise return 0.\n+\t\n+__objc_mutex_trylock(objc_mutex_t mutex), int\n+\tAttempts to lock a mutex, called by objc_mutex_trylock.\n+\tReturn -1 if failed to acquire lock or error otherwise return 0.\n+\n+__objc_mutex_unlock(objc_mutex_t mutex), int\n+\tUnlocks the mutex, called by objc_mutex_unlock.\n+\tReturn -1 if error otherwise return 0.\n+\n+******************************************************************************\n+* Condition Mutexes:\n+\n+Mutexes can be locked recursively.  Each locked mutex remembers\n+its owner (by thread id) and how many times it has been locked.  The\n+last unlock on a mutex removes the system lock and allows other\n+threads to access the mutex.\n+\n+*\n+* Frontend condition mutex functions\n+* User programs should use these functions.\n+*\n+\n+objc_condition_allocate(void), objc_condition_t \n+\tAllocate a condition mutex.\n+\tReturn NULL if error otherwise return condition pointer.\n+\n+objc_condition_deallocate(objc_condition_t condition), int\n+\tDeallocate a condition. Note that this includes an implicit\n+\tcondition_broadcast to insure that waiting threads have the \n+\topportunity to wake.  It is legal to dealloc a condition only\n+\tif no other thread is/will be using it. Does NOT check for\n+\tother threads waiting but just wakes them up.\n+\tReturn -1 if error otherwise return 0.\n+\n+objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n+\tWait on the condition unlocking the mutex until objc_condition_signal()\n+\tor objc_condition_broadcast() are called for the same condition. The\n+\tgiven mutex *must* have the depth 1 so that it can be unlocked\n+\there, for someone else can lock it and signal/broadcast the condition.\n+\tThe mutex is used to lock access to the shared data that make up the\n+\t\"condition\" predicate.\n+\tReturn -1 if error otherwise return 0.\n+\t\n+objc_condition_broadcast(objc_condition_t condition), int\n+\tWake up all threads waiting on this condition. It is recommended that \n+\tthe called would lock the same mutex as the threads in\n+\tobjc_condition_wait before changing the \"condition predicate\"\n+\tand make this call and unlock it right away after this call.\n+\tReturn -1 if error otherwise return 0.\n+\n+objc_condition_signal(objc_condition_t condition), int\n+\tWake up one thread waiting on this condition.\n+\tReturn -1 if error otherwise return 0.\n+\n+*\n+* Backend condition mutex functions\n+* User programs should *NOT* directly call these functions.\n+*\n+\n+__objc_condition_allocate(objc_condition_t condition), int\n+\tAllocate a condition mutex, called by objc_condition_allocate.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_condition_deallocate(objc_condition_t condition), int\n+\tDeallocate a condition, called by objc_condition_deallocate.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n+\tWait on the condition, called by objc_condition_wait.\n+\tReturn -1 if error otherwise return 0 when condition is met.\n+\t\n+__objc_condition_broadcast(objc_condition_t condition), int\n+\tWake up all threads waiting on this condition.\n+\tCalled by objc_condition_broadcast.\n+\tReturn -1 if error otherwise return 0.\n+\n+__objc_condition_signal(objc_condition_t condition), int\n+\tWake up one thread waiting on this condition.\n+\tCalled by objc_condition_signal.\n+\tReturn -1 if error otherwise return 0."}, {"sha": "55de663786698a06b1e2ebbcde06fe62a3d3518b", "filename": "libobjc/THREADS.MACH", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FTHREADS.MACH", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2FTHREADS.MACH", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FTHREADS.MACH?ref=005dda25ff98c6762242f1eaa20eb8795f30a766", "patch": "@@ -0,0 +1,23 @@\n+This readme refers to the file thr-mach.c.\n+\n+Under mach, thread priorities are kinda strange-- any given thread has\n+a MAXIMUM priority and a BASE priority.  The BASE priority is the\n+current priority of the thread and the MAXIMUM is the maximum possible\n+priority the thread can assume.  The developer can lower, but never\n+raise the maximum priority.\n+\n+The gcc concept of thread priorities is that they run at one of three\n+levels;  interactive, background, and low.\n+\n+Under mach, this is translated to:\n+\n+interactive -- set priority to maximum\n+background  -- set priority to 2/3 of maximum\n+low         -- set priority to 1/3 of maximum\n+\n+This means that it is possible for a thread with the priority of\n+interactive to actually run at a lower priority than another thread\n+with a background, or even low, priority if the developer has modified\n+the maximum priority.\n+\n+"}, {"sha": "ec3b5a6284de66fdca9181fdc78721e017b6ffc5", "filename": "libobjc/objc-features.texi", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2Fobjc-features.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/005dda25ff98c6762242f1eaa20eb8795f30a766/libobjc%2Fobjc-features.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-features.texi?ref=005dda25ff98c6762242f1eaa20eb8795f30a766", "patch": "@@ -0,0 +1,392 @@\n+\\input texinfo  @c -*-texinfo-*-\n+@c %**start of header \n+@setfilename objc-features.info\n+@settitle GNU Objective-C runtime features\n+@setchapternewpage odd\n+@c %**end of header\n+     \n+@node Top, Executing code before main, , (dir), (dir)\n+@comment  node-name,  next,  previous,  up\n+\n+@chapter GNU Objective-C runtime features\n+\n+This document is meant to describe some of the GNU Objective-C runtime\n+features. It is not intended to teach you Objective-C, there are several\n+resources on the Internet that present the language.  Questions and\n+comments about this document to Ovidiu Predescu\n+@code{<ovidiu@@aracnet.com>}.\n+\n+@menu\n+* Executing code before main::\n+* Type encoding::\n+* Garbage Collection::\n+@end menu\n+\n+\n+@node Executing code before main, What you can and what you cannot do in +load, Top, Top\n+@section @code{+load}: Executing code before main\n+\n+\n+The GNU Objective-C runtime provides a way that allows you to execute\n+code before the execution of the program enters the @code{main}\n+function. The code is executed on a per-class and a per-category basis,\n+through a special class method @code{+load}.\n+\n+This facility is very useful if you want to initialize global variables\n+which can be accessed by the program directly, without sending a message\n+to the class first. The usual way to initialize global variables, in the\n+@code{+initialize} method, might not be useful because\n+@code{+initialize} is only called when the first message is sent to a\n+class object, which in some cases could be too late.\n+\n+Suppose for example you have a @code{FileStream} class that declares\n+@code{Stdin}, @code{Stdout} and @code{Stderr} as global variables, like\n+below:\n+\n+@example\n+            \n+FileStream *Stdin = nil;                                              \n+FileStream *Stdout = nil;                                          \n+FileStream *Stderr = nil;                                                \n+            \n+@@implementation FileStream                                               \n+          \n++ (void)initialize                                                 \n+@{\n+    Stdin = [[FileStream new] initWithFd:0];                           \n+    Stdout = [[FileStream new] initWithFd:1];                           \n+    Stderr = [[FileStream new] initWithFd:2];\n+@}\n+ \n+/* Other methods here */\n+@@end\n+\n+@end example\n+\n+In this example, the initialization of @code{Stdin}, @code{Stdout} and\n+@code{Stderr} in @code{+initialize} occurs too late. The programmer can\n+send a message to one of these objects before the variables are actually\n+initialized, thus sending messages to the @code{nil} object. The\n+@code{+initialize} method which actually initializes the global\n+variables is not invoked until the first message is sent to the class\n+object. The solution would require these variables to be initialized\n+just before entering @code{main}.\n+\n+The correct solution of the above problem is to use the @code{+load}\n+method instead of @code{+initialize}:\n+\n+@example\n+\n+@@implementation FileStream                                             \n+ \n++ (void)load                                 \n+@{\n+    Stdin = [[FileStream new] initWithFd:0];\n+    Stdout = [[FileStream new] initWithFd:1];\n+    Stderr = [[FileStream new] initWithFd:2];\n+@}\n+ \n+/* Other methods here */                                               \n+@@end\n+\n+@end example\n+ \n+The @code{+load} is a method that is not overridden by categories. If a\n+class and a category of it both implement @code{+load}, both methods are\n+invoked.  This allows some additional initializations to be performed in\n+a category.\n+   \n+This mechanism is not intended to be a replacement for @code{+initialize}.\n+You should be aware of its limitations when you decide to use it\n+instead of @code{+initialize}.\n+\n+@menu\n+* What you can and what you cannot do in +load::\n+@end menu\n+\n+\n+@node What you can and what you cannot do in +load, Type encoding, Executing code before main, Executing code before main\n+@subsection What you can and what you cannot do in @code{+load}\n+\n+The +load implementation in the GNU runtime guarantees you the following\n+things:\n+\n+@itemize @bullet\n+\n+@item\n+you can write whatever C code you like;\n+\n+@item\n+you can send messages to Objective-C constant strings (@@\"this is a\n+constant string\");\n+\n+@item\n+you can allocate and send messages to objects whose class is implemented\n+in the same file;\n+\n+@item\n+the @code{+load} implementation of all super classes of a class are executed before the @code{+load} of that class is executed;\n+\n+@item\n+the @code{+load} implementation of a class is executed before the\n+@code{+load} implementation of any category.\n+\n+@end itemize\n+\n+In particular, the following things, even if they can work in a\n+particular case, are not guaranteed:\n+\n+@itemize @bullet\n+\n+@item\n+allocation of or sending messages to arbitrary objects;\n+\n+@item\n+allocation of or sending messages to objects whose classes have a\n+category implemented in the same file;\n+\n+@end itemize\n+\n+You should make no assumptions about receiving @code{+load} in sibling\n+classes when you write @code{+load} of a class. The order in which\n+sibling classes receive @code{+load} is not guaranteed.\n+    \n+The order in which @code{+load} and @code{+initialize} are called could\n+be problematic if this matters. If you don't allocate objects inside\n+@code{+load}, it is guaranteed that @code{+load} is called before\n+@code{+initialize}. If you create an object inside @code{+load} the\n+@code{+initialize} method of object's class is invoked even if\n+@code{+load} was not invoked. Note if you explicitly call @code{+load}\n+on a class, @code{+initialize} will be called first. To avoid possible\n+problems try to implement only one of these methods.\n+\n+The @code{+load} method is also invoked when a bundle is dynamically\n+loaded into your running program. This happens automatically without any\n+intervening operation from you. When you write bundles and you need to\n+write @code{+load} you can safely create and send messages to objects whose\n+classes already exist in the running program. The same restrictions as\n+above apply to classes defined in bundle.\n+\n+\n+\n+@node Type encoding, Garbage Collection, What you can and what you cannot do in +load, Top\n+@section Type encoding\n+\n+The Objective-C compiler generates type encodings for all the\n+types. These type encodings are used at runtime to find out information\n+about selectors and methods and about objects and classes.\n+\n+The types are encoded in the following way:\n+\n+@c @sp 1\n+\n+@multitable @columnfractions .25 .75\n+@item @code{char}                      \n+@tab @code{c}\n+@item @code{unsigned char}             \n+@tab @code{C}\n+@item @code{short}                     \n+@tab @code{s}\n+@item @code{unsigned short}            \n+@tab @code{S}\n+@item @code{int}                       \n+@tab @code{i}\n+@item @code{unsigned int}              \n+@tab @code{I}\n+@item @code{long}                      \n+@tab @code{l}\n+@item @code{unsigned long}             \n+@tab @code{L}\n+@item @code{long long}                 \n+@tab @code{q}\n+@item @code{unsigned long long}        \n+@tab @code{Q}\n+@item @code{float}                     \n+@tab @code{f}\n+@item @code{double}                    \n+@tab @code{d}\n+@item @code{void}                      \n+@tab @code{v}\n+@item @code{id}                        \n+@tab @code{@@}\n+@item @code{Class}                     \n+@tab @code{#}\n+@item @code{SEL}                       \n+@tab @code{:}\n+@item @code{char*}                     \n+@tab @code{*}\n+@item unknown type                     \n+@tab @code{?}\n+@item bitfields                 \n+@tab @code{b} followed by the starting position of the bitfield, the type of the bitfield and the size of the bitfield (the bitfields encoding was changed from the NeXT's compiler encoding, see below)\n+@end multitable\n+\n+@c @sp 1\n+\n+The encoding of bitfields has changed to allow bitfields to be properly\n+handled by the runtime functions that compute sizes and alignments of\n+types that contain bitfields. The previous encoding contained only the\n+size of the bitfield. Using only this information it is not possible to\n+reliably compute the size occupied by the bitfield. This is very\n+important in the presence of the Boehm's garbage collector because the\n+objects are allocated using the typed memory facility available in this\n+collector. The typed memory allocation requires information about where\n+the pointers are located inside the object.\n+\n+The position in the bitfield is the position, counting in bits, of the\n+bit closest to the beginning of the structure.\n+\n+The non-atomic types are encoded as follows:\n+\n+@c @sp 1\n+\n+@multitable @columnfractions .2 .8\n+@item pointers          \n+@tab @code{'^'} followed by the pointed type.\n+@item arrays\n+@tab @code{'['} followed by the number of elements in the array followed by the type of the elements followed by @code{']'}\n+@item structures\n+@tab @code{'@{'} followed by the name of the structure (or '?' if the structure is unnamed), the '=' sign, the type of the members and by @code{'@}'}\n+@item unions\n+@tab @code{'('} followed by the name of the structure (or '?' if the union is unnamed), the '=' sign, the type of the members followed by @code{')'}\n+@end multitable\n+\n+Here are some types and their encodings, as they are generated by the\n+compiler on a i386 machine:\n+\n+@sp 1\n+\n+@multitable @columnfractions .25 .75\n+@item Objective-C type\n+@tab Compiler encoding\n+@item\n+@example\n+int a[10];\n+@end example\n+@tab @code{[10i]}\n+@item\n+@example\n+struct @{\n+  int i;\n+  float f[3];\n+  int a:3;\n+  int b:2;\n+  char c;\n+@}\n+@end example\n+@tab @code{@{?=i[3f]b128i3b131i2c@}}\n+@end multitable\n+\n+@sp 1\n+\n+In addition to the types the compiler also encodes the type\n+specifiers. The table below describes the encoding of the current\n+Objective-C type specifiers:\n+\n+@sp 1\n+\n+@multitable @columnfractions .25 .75\n+@item Specifier\n+@tab Encoding\n+@item @code{const}              \n+@tab @code{r}\n+@item @code{in}                 \n+@tab @code{n}\n+@item @code{inout}              \n+@tab @code{N}\n+@item @code{out}                \n+@tab @code{o}\n+@item @code{bycopy}             \n+@tab @code{O}\n+@item @code{oneway}             \n+@tab @code{V}\n+@end multitable\n+\n+@sp 1\n+\n+The type specifiers are encoded just before the type. Unlike types\n+however, the type specifiers are only encoded when they appear in method\n+argument types.\n+\n+\n+@node Garbage Collection, , Type encoding, Top\n+\n+@page\n+@section Garbage Collection\n+\n+Support for a new memory management policy has been added by using a\n+powerful conservative garbage collector, known as the\n+Boehm-Demers-Weiser conservative garbage collector. It is available from\n+@w{@url{http://reality.sgi.com/employees/boehm_mti/gc.html}}.\n+\n+To enable the support for it you have to configure the compiler using an\n+additional argument, @w{@kbd{--enable-objc-gc}}. You need to have\n+garbage collector installed before building the compiler. This will\n+build an additional runtime library which has several enhancements to\n+support the garbage collector. The new library has a new name,\n+@kbd{libobjc_gc.a} to not conflict with the non-garbage-collected\n+library.\n+\n+When the garbage collector is used, the objects are allocated using the\n+so-called typed memory allocation mechanism available in the\n+Boehm-Demers-Weiser collector. This mode requires precise information on\n+where pointers are located inside objects. This information is computed\n+once per class, immediately after the class has been initialized.\n+\n+There is a new runtime function @code{class_ivar_set_gcinvisible()}\n+which can be used to declare a so-called @strong{weak pointer}\n+reference. Such a pointer is basically hidden for the garbage collector;\n+this can be useful in certain situations, especially when you want to\n+keep track of the allocated objects, yet allow them to be\n+collected. This kind of pointers can only be members of objects, you\n+cannot declare a global pointer as a weak reference. Every type which is\n+a pointer type can be declared a weak pointer, including @code{id},\n+@code{Class} and @code{SEL}.\n+\n+Here is an example of how to use this feature. Suppose you want to\n+implement a class whose instances hold a weak pointer reference; the\n+following class does this:\n+\n+@example\n+\n+@@interface WeakPointer : Object\n+@{\n+    const void* weakPointer;\n+@}\n+\n+- initWithPointer:(const void*)p;\n+- (const void*)weakPointer;\n+@@end\n+\n+\n+@@implementation WeakPointer\n+\n++ (void)initialize\n+@{\n+  class_ivar_set_gcinvisible (self, \"weakPointer\", YES);\n+@}\n+\n+- initWithPointer:(const void*)p\n+@{\n+  weakPointer = p;\n+  return self;\n+@}\n+\n+- (const void*)weakPointer\n+@{\n+  return weakPointer;\n+@}\n+\n+@@end\n+\n+@end example\n+\n+Weak pointers are supported through a new type character specifier\n+represented by the @code{'!'} character. The\n+@code{class_ivar_set_gcinvisible()} function adds or removes this\n+specifier to the string type description of the instance variable named\n+as argument.\n+\n+\n+@bye\n+"}]}