{"sha": "4e4791ffbae66bc5c4b96c014efb21dd7e7f2775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU0NzkxZmZiYWU2NmJjNWM0Yjk2YzAxNGVmYjIxZGQ3ZTdmMjc3NQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2019-10-04T16:15:00Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2019-10-04T16:15:00Z"}, "message": "genmatch.c (commutate): Rename local var.\n\n2019-10-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * genmatch.c (commutate): Rename local var.\n        (lower_cond): Reuse local var.\n        (dt_node::gen, dt_node::gen_kids, dt_node::gen_kids_1,\n        dt_operand::gen, dt_operand::gen_gimple_expr,\n        dt_simplify::gen): Add a param.  Rename generated vars.\n        (decision_tree::insert_operand,\n        (capture_info::walk_match, capture_info::walk_result,\n        capture_info::walk_c_expr): Rename local vars.\n        (expr::gen_transform): Rename generated vars.\n        Use snprintf.  Rename local vars.\n        (capture::gen_transform, dt_operand::get_name,\n        dt_operand::gen_opname): Rename generated vars.\n        (write_predicate): Adjust call to gen_kids.\n        (parser::get_internal_capture_id): Rename generated vars.\n        (parser::parse_expr): Rename local vars.\n        (parser::parse_if): Remove local var.\n        (parser::parse_pattern, add_operator): Rename local vars.\n\nFrom-SVN: r276589", "tree": {"sha": "16c3296e184b80da802f835c5aa7af4dd54e109b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16c3296e184b80da802f835c5aa7af4dd54e109b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0fa00483026f58848767c1577e3d76ef2fb2568b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fa00483026f58848767c1577e3d76ef2fb2568b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fa00483026f58848767c1577e3d76ef2fb2568b"}], "stats": {"total": 319, "additions": 174, "deletions": 145}, "files": [{"sha": "ba33fe7886f2a78adaef4f678c4e43bc58243080", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e4791ffbae66bc5c4b96c014efb21dd7e7f2775", "patch": "@@ -1,3 +1,23 @@\n+2019-10-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* genmatch.c (commutate): Rename local var.\n+\t(lower_cond): Reuse local var.\n+\t(dt_node::gen, dt_node::gen_kids, dt_node::gen_kids_1,\n+\tdt_operand::gen, dt_operand::gen_gimple_expr,\n+\tdt_simplify::gen): Add a param.  Rename generated vars.\n+\t(decision_tree::insert_operand,\n+\t(capture_info::walk_match, capture_info::walk_result,\n+\tcapture_info::walk_c_expr): Rename local vars.\n+\t(expr::gen_transform): Rename generated vars.\n+\tUse snprintf.  Rename local vars.\n+\t(capture::gen_transform, dt_operand::get_name,\n+\tdt_operand::gen_opname): Rename generated vars.\n+\t(write_predicate): Adjust call to gen_kids.\n+\t(parser::get_internal_capture_id): Rename generated vars.\n+\t(parser::parse_expr): Rename local vars.\n+\t(parser::parse_if): Remove local var.\n+\t(parser::parse_pattern, add_operator): Rename local vars.\n+\n 2019-10-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* builtins.def (DEF_C2X_BUILTIN): New macro."}, {"sha": "7db1f135840e09e794e2921859fa8e9b76666fa8", "filename": "gcc/genmatch.c", "status": "modified", "additions": 154, "deletions": 145, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e4791ffbae66bc5c4b96c014efb21dd7e7f2775/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=4e4791ffbae66bc5c4b96c014efb21dd7e7f2775", "patch": "@@ -1022,10 +1022,10 @@ commutate (operand *op, vec<vec<user_id *> > &for_vec)\n   for (unsigned i = 0; i < result.length (); ++i)\n     {\n       expr *ne = new expr (e);\n-      if (operator_id *p = dyn_cast <operator_id *> (ne->operation))\n+      if (operator_id *r = dyn_cast <operator_id *> (ne->operation))\n \t{\n-\t  if (comparison_code_p (p->code))\n-\t    ne->operation = swap_tree_comparison (p);\n+\t  if (comparison_code_p (r->code))\n+\t    ne->operation = swap_tree_comparison (r);\n \t}\n       else if (user_id *p = dyn_cast <user_id *> (ne->operation))\n \t{\n@@ -1279,7 +1279,7 @@ lower_cond (operand *o)\n \t      || (is_a <expr *> (e->ops[0])\n \t\t  && as_a <expr *> (e->ops[0])->ops.length () == 2)))\n \t{\n-\t  expr *ne = new expr (e);\n+\t  ne = new expr (e);\n \t  for (unsigned j = 0; j < result[i].length (); ++j)\n \t    ne->append_op (result[i][j]);\n \t  if (capture *c = dyn_cast <capture *> (ne->ops[0]))\n@@ -1637,10 +1637,10 @@ class dt_node\n \t\t\t    unsigned pos);\n   dt_node *append_simplify (simplify *, unsigned, dt_operand **);\n \n-  virtual void gen (FILE *, int, bool) {}\n+  virtual void gen (FILE *, int, bool, int) {}\n \n-  void gen_kids (FILE *, int, bool);\n-  void gen_kids_1 (FILE *, int, bool,\n+  void gen_kids (FILE *, int, bool, int);\n+  void gen_kids_1 (FILE *, int, bool, int,\n \t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_operand *>,\n \t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_node *>);\n \n@@ -1663,11 +1663,11 @@ class dt_operand : public dt_node\n       : dt_node (type, parent_), op (op_), match_dop (match_dop_),\n       pos (pos_), value_match (false), for_id (current_id) {}\n \n-  void gen (FILE *, int, bool);\n+  void gen (FILE *, int, bool, int);\n   unsigned gen_predicate (FILE *, int, const char *, bool);\n   unsigned gen_match_op (FILE *, int, const char *, bool);\n \n-  unsigned gen_gimple_expr (FILE *, int);\n+  unsigned gen_gimple_expr (FILE *, int, int);\n   unsigned gen_generic_expr (FILE *, int, const char *);\n \n   char *get_name (char *);\n@@ -1689,7 +1689,7 @@ class dt_simplify : public dt_node\n \t  indexes (indexes_), info (NULL)  {}\n \n   void gen_1 (FILE *, int, bool, operand *);\n-  void gen (FILE *f, int, bool);\n+  void gen (FILE *f, int, bool, int);\n };\n \n template<>\n@@ -1987,9 +1987,9 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n \n \t      if (elm == 0)\n \t\t{\n-\t\t  dt_operand temp (dt_node::DT_MATCH, 0, match_op, 0, 0);\n-\t\t  temp.value_match = c->value_match;\n-\t\t  elm = decision_tree::find_node (p->kids, &temp);\n+\t\t  dt_operand match (dt_node::DT_MATCH, 0, match_op, 0, 0);\n+\t\t  match.value_match = c->value_match;\n+\t\t  elm = decision_tree::find_node (p->kids, &match);\n \t\t}\n \t    }\n \t  else\n@@ -2202,7 +2202,7 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,\n       for (unsigned i = 0; i < e->ops.length (); ++i)\n \t{\n \t  bool cond_p = conditional_p;\n-\t  bool cond_expr_cond_p = false;\n+\t  bool expr_cond_p = false;\n \t  if (i != 0 && *e->operation == COND_EXPR)\n \t    cond_p = true;\n \t  else if (*e->operation == TRUTH_ANDIF_EXPR\n@@ -2211,8 +2211,8 @@ capture_info::walk_match (operand *o, unsigned toplevel_arg,\n \t  if (i == 0\n \t      && (*e->operation == COND_EXPR\n \t\t  || *e->operation == VEC_COND_EXPR))\n-\t    cond_expr_cond_p = true;\n-\t  walk_match (e->ops[i], toplevel_arg, cond_p, cond_expr_cond_p);\n+\t    expr_cond_p = true;\n+\t  walk_match (e->ops[i], toplevel_arg, cond_p, expr_cond_p);\n \t}\n     }\n   else if (is_a <predicate *> (o))\n@@ -2270,42 +2270,42 @@ capture_info::walk_result (operand *o, bool conditional_p, operand *result)\n \t  walk_result (e->ops[i], cond_p, result);\n \t}\n     }\n-  else if (if_expr *e = dyn_cast <if_expr *> (o))\n+  else if (if_expr *ie = dyn_cast <if_expr *> (o))\n     {\n       /* 'if' conditions should be all fine.  */\n-      if (e->trueexpr == result)\n+      if (ie->trueexpr == result)\n \t{\n-\t  walk_result (e->trueexpr, false, result);\n+\t  walk_result (ie->trueexpr, false, result);\n \t  return true;\n \t}\n-      if (e->falseexpr == result)\n+      if (ie->falseexpr == result)\n \t{\n-\t  walk_result (e->falseexpr, false, result);\n+\t  walk_result (ie->falseexpr, false, result);\n \t  return true;\n \t}\n       bool res = false;\n-      if (is_a <if_expr *> (e->trueexpr)\n-\t  || is_a <with_expr *> (e->trueexpr))\n-\tres |= walk_result (e->trueexpr, false, result);\n-      if (e->falseexpr\n-\t  && (is_a <if_expr *> (e->falseexpr)\n-\t      || is_a <with_expr *> (e->falseexpr)))\n-\tres |= walk_result (e->falseexpr, false, result);\n+      if (is_a <if_expr *> (ie->trueexpr)\n+\t  || is_a <with_expr *> (ie->trueexpr))\n+\tres |= walk_result (ie->trueexpr, false, result);\n+      if (ie->falseexpr\n+\t  && (is_a <if_expr *> (ie->falseexpr)\n+\t      || is_a <with_expr *> (ie->falseexpr)))\n+\tres |= walk_result (ie->falseexpr, false, result);\n       return res;\n     }\n-  else if (with_expr *e = dyn_cast <with_expr *> (o))\n+  else if (with_expr *we = dyn_cast <with_expr *> (o))\n     {\n-      bool res = (e->subexpr == result);\n+      bool res = (we->subexpr == result);\n       if (res\n-\t  || is_a <if_expr *> (e->subexpr)\n-\t  || is_a <with_expr *> (e->subexpr))\n-\tres |= walk_result (e->subexpr, false, result);\n+\t  || is_a <if_expr *> (we->subexpr)\n+\t  || is_a <with_expr *> (we->subexpr))\n+\tres |= walk_result (we->subexpr, false, result);\n       if (res)\n-\twalk_c_expr (e->with);\n+\twalk_c_expr (we->with);\n       return res;\n     }\n-  else if (c_expr *e = dyn_cast <c_expr *> (o))\n-    walk_c_expr (e);\n+  else if (c_expr *ce = dyn_cast <c_expr *> (o))\n+    walk_c_expr (ce);\n   else\n     gcc_unreachable ();\n \n@@ -2347,14 +2347,14 @@ capture_info::walk_c_expr (c_expr *e)\n \t\t   || n->type == CPP_NAME)\n \t       && !(n->flags & PREV_WHITE))\n \t{\n-\t  const char *id;\n+\t  const char *id1;\n \t  if (n->type == CPP_NUMBER)\n-\t    id = (const char *)n->val.str.text;\n+\t    id1 = (const char *)n->val.str.text;\n \t  else\n-\t    id = (const char *)CPP_HASHNODE (n->val.node.node)->ident.str;\n-\t  unsigned *where = e->capture_ids->get(id);\n+\t    id1 = (const char *)CPP_HASHNODE (n->val.node.node)->ident.str;\n+\t  unsigned *where = e->capture_ids->get(id1);\n \t  if (! where)\n-\t    fatal_at (n, \"unknown capture id '%s'\", id);\n+\t    fatal_at (n, \"unknown capture id '%s'\", id1);\n \t  info[info[*where].same_as].force_no_side_effects_p = true;\n \t  if (verbose >= 1\n \t      && !gimple)\n@@ -2452,7 +2452,8 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n \t   || *opr == IMAGPART_EXPR)\n     {\n       /* __real and __imag use the component type of its operand.  */\n-      sprintf (optype, \"TREE_TYPE (TREE_TYPE (ops%d[0]))\", depth);\n+      snprintf (optype, sizeof (optype), \"TREE_TYPE (TREE_TYPE (_o%d[0]))\",\n+\t\tdepth);\n       type = optype;\n     }\n   else if (is_a <operator_id *> (opr)\n@@ -2464,7 +2465,7 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n \ttype = in_type;\n       else\n \t{\n-\t  sprintf (optype, \"boolean_type_node\");\n+\t  snprintf (optype, sizeof (optype), \"boolean_type_node\");\n \t  type = optype;\n \t}\n       in_type = NULL;\n@@ -2474,31 +2475,32 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n \t   || strncmp (opr->id, \"CFN_COND_\", 9) == 0)\n     {\n       /* Conditions are of the same type as their first alternative.  */\n-      sprintf (optype, \"TREE_TYPE (ops%d[1])\", depth);\n+      snprintf (optype, sizeof (optype), \"TREE_TYPE (_o%d[1])\", depth);\n       type = optype;\n     }\n   else\n     {\n       /* Other operations are of the same type as their first operand.  */\n-      sprintf (optype, \"TREE_TYPE (ops%d[0])\", depth);\n+      snprintf (optype, sizeof (optype), \"TREE_TYPE (_o%d[0])\", depth);\n       type = optype;\n     }\n   if (!type)\n     fatal_at (location, \"cannot determine type of operand\");\n \n   fprintf_indent (f, indent, \"{\\n\");\n   indent += 2;\n-  fprintf_indent (f, indent, \"tree ops%d[%u], res;\\n\", depth, ops.length ());\n+  fprintf_indent (f, indent,\n+\t\t  \"tree _o%d[%u], _r%d;\\n\", depth, ops.length (), depth);\n   char op0type[64];\n-  snprintf (op0type, 64, \"TREE_TYPE (ops%d[0])\", depth);\n+  snprintf (op0type, sizeof (op0type), \"TREE_TYPE (_o%d[0])\", depth);\n   for (unsigned i = 0; i < ops.length (); ++i)\n     {\n-      char dest[32];\n-      snprintf (dest, 32, \"ops%d[%u]\", depth, i);\n-      const char *optype\n+      char dest1[32];\n+      snprintf (dest1, sizeof (dest1), \"_o%d[%u]\", depth, i);\n+      const char *optype1\n \t= get_operand_type (opr, i, in_type, expr_type,\n \t\t\t    i == 0 ? NULL : op0type);\n-      ops[i]->gen_transform (f, indent, dest, gimple, depth + 1, optype,\n+      ops[i]->gen_transform (f, indent, dest1, gimple, depth + 1, optype1,\n \t\t\t     cinfo, indexes,\n \t\t\t     (*opr == COND_EXPR\n \t\t\t      || *opr == VEC_COND_EXPR) && i == 0 ? 1 : 2);\n@@ -2515,10 +2517,11 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       if (*opr == CONVERT_EXPR)\n \t{\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"if (%s != TREE_TYPE (ops%d[0])\\n\",\n+\t\t\t  \"if (%s != TREE_TYPE (_o%d[0])\\n\",\n \t\t\t  type, depth);\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"    && !useless_type_conversion_p (%s, TREE_TYPE (ops%d[0])))\\n\",\n+\t\t\t  \"    && !useless_type_conversion_p (%s, TREE_TYPE \"\n+\t\t\t  \"(_o%d[0])))\\n\",\n \t\t\t  type, depth);\n \t  fprintf_indent (f, indent + 2, \"{\\n\");\n \t  indent += 4;\n@@ -2529,57 +2532,59 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       fprintf_indent (f, indent, \"gimple_match_op tem_op \"\n \t\t      \"(res_op->cond.any_else (), %s, %s\", opr_name, type);\n       for (unsigned i = 0; i < ops.length (); ++i)\n-\tfprintf (f, \", ops%d[%u]\", depth, i);\n+\tfprintf (f, \", _o%d[%u]\", depth, i);\n       fprintf (f, \");\\n\");\n       fprintf_indent (f, indent,\n \t\t      \"gimple_resimplify%d (lseq, &tem_op, valueize);\\n\",\n \t\t      ops.length ());\n       fprintf_indent (f, indent,\n-\t\t      \"res = maybe_push_res_to_seq (&tem_op, lseq);\\n\");\n+\t\t      \"_r%d = maybe_push_res_to_seq (&tem_op, lseq);\\n\",\n+\t\t      depth);\n       fprintf_indent (f, indent,\n-\t\t      \"if (!res) return false;\\n\");\n+\t\t      \"if (!_r%d) return false;\\n\",\n+\t\t      depth);\n       if (*opr == CONVERT_EXPR)\n \t{\n \t  indent -= 4;\n \t  fprintf_indent (f, indent, \"  }\\n\");\n \t  fprintf_indent (f, indent, \"else\\n\");\n-\t  fprintf_indent (f, indent, \"  res = ops%d[0];\\n\", depth);\n+\t  fprintf_indent (f, indent, \"  _r%d = _o%d[0];\\n\", depth, depth);\n \t}\n     }\n   else\n     {\n       if (*opr == CONVERT_EXPR)\n \t{\n-\t  fprintf_indent (f, indent, \"if (TREE_TYPE (ops%d[0]) != %s)\\n\",\n+\t  fprintf_indent (f, indent, \"if (TREE_TYPE (_o%d[0]) != %s)\\n\",\n \t\t\t  depth, type);\n \t  indent += 2;\n \t}\n       if (opr->kind == id_base::CODE)\n-\tfprintf_indent (f, indent, \"res = fold_build%d_loc (loc, %s, %s\",\n-\t\t\tops.length(), opr_name, type);\n+\tfprintf_indent (f, indent, \"_r%d = fold_build%d_loc (loc, %s, %s\",\n+\t\t\tdepth, ops.length(), opr_name, type);\n       else\n \t{\n \t  fprintf_indent (f, indent, \"{\\n\");\n-\t  fprintf_indent (f, indent, \"  res = maybe_build_call_expr_loc (loc, \"\n-\t\t\t  \"%s, %s, %d\", opr_name, type, ops.length());\n+\t  fprintf_indent (f, indent, \"  _r%d = maybe_build_call_expr_loc (loc, \"\n+\t\t\t  \"%s, %s, %d\", depth, opr_name, type, ops.length());\n \t}\n       for (unsigned i = 0; i < ops.length (); ++i)\n-\tfprintf (f, \", ops%d[%u]\", depth, i);\n+\tfprintf (f, \", _o%d[%u]\", depth, i);\n       fprintf (f, \");\\n\");\n       if (opr->kind != id_base::CODE)\n \t{\n-\t  fprintf_indent (f, indent, \"  if (!res)\\n\");\n+\t  fprintf_indent (f, indent, \"  if (!_r%d)\\n\", depth);\n \t  fprintf_indent (f, indent, \"    return NULL_TREE;\\n\");\n \t  fprintf_indent (f, indent, \"}\\n\");\n \t}\n       if (*opr == CONVERT_EXPR)\n \t{\n \t  indent -= 2;\n \t  fprintf_indent (f, indent, \"else\\n\");\n-\t  fprintf_indent (f, indent, \"  res = ops%d[0];\\n\", depth);\n+\t  fprintf_indent (f, indent, \"  _r%d = _o%d[0];\\n\", depth, depth);\n \t}\n     }\n-  fprintf_indent (f, indent, \"%s = res;\\n\", dest);\n+  fprintf_indent (f, indent, \"%s = _r%d;\\n\", dest, depth);\n   indent -= 2;\n   fprintf_indent (f, indent, \"}\\n\");\n }\n@@ -2670,7 +2675,7 @@ capture::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       if (indexes[where] == 0)\n \t{\n \t  char buf[20];\n-\t  sprintf (buf, \"captures[%u]\", where);\n+\t  snprintf (buf, sizeof (buf), \"captures[%u]\", where);\n \t  what->gen_transform (f, indent, buf, gimple, depth, in_type,\n \t\t\t       cinfo, NULL);\n \t}\n@@ -2725,11 +2730,11 @@ dt_operand::get_name (char *name)\n   if (! parent)\n     sprintf (name, \"t\");\n   else if (parent->level == 1)\n-    sprintf (name, \"op%u\", pos);\n+    sprintf (name, \"_p%u\", pos);\n   else if (parent->type == dt_node::DT_MATCH)\n     return as_a <dt_operand *> (parent)->get_name (name);\n   else\n-    sprintf (name, \"o%u%u\", parent->level, pos);\n+    sprintf (name, \"_q%u%u\", parent->level, pos);\n   return name;\n }\n \n@@ -2739,9 +2744,9 @@ void\n dt_operand::gen_opname (char *name, unsigned pos)\n {\n   if (! parent)\n-    sprintf (name, \"op%u\", pos);\n+    sprintf (name, \"_p%u\", pos);\n   else\n-    sprintf (name, \"o%u%u\", level, pos);\n+    sprintf (name, \"_q%u%u\", level, pos);\n }\n \n /* Generate matching code for the decision tree operand which is\n@@ -2793,7 +2798,7 @@ dt_operand::gen_match_op (FILE *f, int indent, const char *opname, bool)\n /* Generate GIMPLE matching code for the decision tree operand.  */\n \n unsigned\n-dt_operand::gen_gimple_expr (FILE *f, int indent)\n+dt_operand::gen_gimple_expr (FILE *f, int indent, int depth)\n {\n   expr *e = static_cast<expr *> (op);\n   id_base *id = e->operation;\n@@ -2825,8 +2830,8 @@ dt_operand::gen_gimple_expr (FILE *f, int indent)\n \t      else\n \t\tfprintf_indent (f, indent,\n \t\t\t\t\"tree %s = TREE_OPERAND \"\n-\t\t\t\t\"(gimple_assign_rhs1 (def), %i);\\n\",\n-\t\t\t\tchild_opname, i);\n+\t\t\t\t\"(gimple_assign_rhs1 (_a%d), %i);\\n\",\n+\t\t\t\tchild_opname, depth, i);\n \t      fprintf_indent (f, indent,\n \t\t\t      \"if ((TREE_CODE (%s) == SSA_NAME\\n\",\n \t\t\t      child_opname);\n@@ -2844,13 +2849,13 @@ dt_operand::gen_gimple_expr (FILE *f, int indent)\n \t    }\n \t  else\n \t    fprintf_indent (f, indent,\n-\t\t\t    \"tree %s = gimple_assign_rhs%u (def);\\n\",\n-\t\t\t    child_opname, i + 1);\n+\t\t\t    \"tree %s = gimple_assign_rhs%u (_a%d);\\n\",\n+\t\t\t    child_opname, i + 1, depth);\n \t}\n       else\n \tfprintf_indent (f, indent,\n-\t\t\t\"tree %s = gimple_call_arg (def, %u);\\n\",\n-\t\t\tchild_opname, i);\n+\t\t\t\"tree %s = gimple_call_arg (_c%d, %u);\\n\",\n+\t\t\tchild_opname, depth, i);\n       fprintf_indent (f, indent,\n \t\t      \"%s = do_valueize (valueize, %s);\\n\",\n \t\t      child_opname, child_opname);\n@@ -2902,7 +2907,7 @@ dt_operand::gen_generic_expr (FILE *f, int indent, const char *opname)\n /* Generate matching code for the children of the decision tree node.  */\n \n void\n-dt_node::gen_kids (FILE *f, int indent, bool gimple)\n+dt_node::gen_kids (FILE *f, int indent, bool gimple, int depth)\n {\n   auto_vec<dt_operand *> gimple_exprs;\n   auto_vec<dt_operand *> generic_exprs;\n@@ -2953,10 +2958,10 @@ dt_node::gen_kids (FILE *f, int indent, bool gimple)\n \t     Like DT_TRUE, DT_MATCH serves as a barrier as it can cause\n \t     dependent matches to get out-of-order.  Generate code now\n \t     for what we have collected sofar.  */\n-\t  gen_kids_1 (f, indent, gimple, gimple_exprs, generic_exprs,\n+\t  gen_kids_1 (f, indent, gimple, depth, gimple_exprs, generic_exprs,\n \t\t      fns, generic_fns, preds, others);\n \t  /* And output the true operand itself.  */\n-\t  kids[i]->gen (f, indent, gimple);\n+\t  kids[i]->gen (f, indent, gimple, depth);\n \t  gimple_exprs.truncate (0);\n \t  generic_exprs.truncate (0);\n \t  fns.truncate (0);\n@@ -2969,14 +2974,14 @@ dt_node::gen_kids (FILE *f, int indent, bool gimple)\n     }\n \n   /* Generate code for the remains.  */\n-  gen_kids_1 (f, indent, gimple, gimple_exprs, generic_exprs,\n+  gen_kids_1 (f, indent, gimple, depth, gimple_exprs, generic_exprs,\n \t      fns, generic_fns, preds, others);\n }\n \n /* Generate matching code for the children of the decision tree node.  */\n \n void\n-dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n+dt_node::gen_kids_1 (FILE *f, int indent, bool gimple, int depth,\n \t\t     vec<dt_operand *> gimple_exprs,\n \t\t     vec<dt_operand *> generic_exprs,\n \t\t     vec<dt_operand *> fns,\n@@ -3010,20 +3015,23 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \n   if (exprs_len || fns_len)\n     {\n+      depth++;\n       fprintf_indent (f, indent,\n \t\t      \"case SSA_NAME:\\n\");\n       fprintf_indent (f, indent,\n-\t\t      \"  if (gimple *def_stmt = get_def (valueize, %s))\\n\",\n-\t\t      kid_opname);\n+\t\t      \"  if (gimple *_d%d = get_def (valueize, %s))\\n\",\n+\t\t      depth, kid_opname);\n       fprintf_indent (f, indent,\n \t\t      \"    {\\n\");\n       indent += 6;\n       if (exprs_len)\n \t{\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"if (gassign *def = dyn_cast <gassign *> (def_stmt))\\n\");\n+\t\t\t  \"if (gassign *_a%d = dyn_cast <gassign *> (_d%d))\\n\",\n+\t\t\t  depth, depth);\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"  switch (gimple_assign_rhs_code (def))\\n\");\n+\t\t\t  \"  switch (gimple_assign_rhs_code (_a%d))\\n\",\n+\t\t\t  depth);\n \t  indent += 4;\n \t  fprintf_indent (f, indent, \"{\\n\");\n \t  for (unsigned i = 0; i < exprs_len; ++i)\n@@ -3035,7 +3043,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \t      else\n \t\tfprintf_indent (f, indent, \"case %s:\\n\", op->id);\n \t      fprintf_indent (f, indent, \"  {\\n\");\n-\t      gimple_exprs[i]->gen (f, indent + 4, true);\n+\t      gimple_exprs[i]->gen (f, indent + 4, true, depth);\n \t      fprintf_indent (f, indent, \"    break;\\n\");\n \t      fprintf_indent (f, indent, \"  }\\n\");\n \t    }\n@@ -3047,11 +3055,11 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n       if (fns_len)\n \t{\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"%sif (gcall *def = dyn_cast <gcall *>\"\n-\t\t\t  \" (def_stmt))\\n\",\n-\t\t\t  exprs_len ? \"else \" : \"\");\n+\t\t\t  \"%sif (gcall *_c%d = dyn_cast <gcall *> (_d%d))\\n\",\n+\t\t\t  exprs_len ? \"else \" : \"\", depth, depth);\n \t  fprintf_indent (f, indent,\n-\t\t\t  \"  switch (gimple_call_combined_fn (def))\\n\");\n+\t\t\t  \"  switch (gimple_call_combined_fn (_c%d))\\n\",\n+\t\t\t  depth);\n \n \t  indent += 4;\n \t  fprintf_indent (f, indent, \"{\\n\");\n@@ -3060,7 +3068,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \t      expr *e = as_a <expr *>(fns[i]->op);\n \t      fprintf_indent (f, indent, \"case %s:\\n\", e->operation->id);\n \t      fprintf_indent (f, indent, \"  {\\n\");\n-\t      fns[i]->gen (f, indent + 4, true);\n+\t      fns[i]->gen (f, indent + 4, true, depth);\n \t      fprintf_indent (f, indent, \"    break;\\n\");\n \t      fprintf_indent (f, indent, \"  }\\n\");\n \t    }\n@@ -3071,6 +3079,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \t}\n \n       indent -= 6;\n+      depth--;\n       fprintf_indent (f, indent, \"    }\\n\");\n       /* See if there is SSA_NAME among generic_exprs and if yes, emit it\n \t here rather than in the next loop.  */\n@@ -3081,7 +3090,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \t  if (*op == SSA_NAME && (exprs_len || fns_len))\n \t    {\n \t      fprintf_indent (f, indent + 4, \"{\\n\");\n-\t      generic_exprs[i]->gen (f, indent + 6, gimple);\n+\t      generic_exprs[i]->gen (f, indent + 6, gimple, depth);\n \t      fprintf_indent (f, indent + 4, \"}\\n\");\n \t    }\n \t}\n@@ -3101,7 +3110,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n       else\n \tfprintf_indent (f, indent, \"case %s:\\n\", op->id);\n       fprintf_indent (f, indent, \"  {\\n\");\n-      generic_exprs[i]->gen (f, indent + 4, gimple);\n+      generic_exprs[i]->gen (f, indent + 4, gimple, depth);\n       fprintf_indent (f, indent, \"    break;\\n\");\n       fprintf_indent (f, indent, \"  }\\n\");\n     }\n@@ -3124,7 +3133,7 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \n \t  fprintf_indent (f, indent, \"case %s:\\n\", e->operation->id);\n \t  fprintf_indent (f, indent, \"  {\\n\");\n-\t  generic_fns[j]->gen (f, indent + 4, false);\n+\t  generic_fns[j]->gen (f, indent + 4, false, depth);\n \t  fprintf_indent (f, indent, \"    break;\\n\");\n \t  fprintf_indent (f, indent, \"  }\\n\");\n \t}\n@@ -3163,20 +3172,20 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple,\n \t  fprintf_indent (f, indent + 4, \"tree %s = %s_pops[%d];\\n\",\n \t\t\t  child_opname, kid_opname, j);\n \t}\n-      preds[i]->gen_kids (f, indent + 4, gimple);\n+      preds[i]->gen_kids (f, indent + 4, gimple, depth);\n       fprintf (f, \"}\\n\");\n       indent -= 2;\n       fprintf_indent (f, indent, \"}\\n\");\n     }\n \n   for (unsigned i = 0; i < others.length (); ++i)\n-    others[i]->gen (f, indent, gimple);\n+    others[i]->gen (f, indent, gimple, depth);\n }\n \n /* Generate matching code for the decision tree operand.  */\n \n void\n-dt_operand::gen (FILE *f, int indent, bool gimple)\n+dt_operand::gen (FILE *f, int indent, bool gimple, int depth)\n {\n   char opname[20];\n   get_name (opname);\n@@ -3192,7 +3201,7 @@ dt_operand::gen (FILE *f, int indent, bool gimple)\n \n \tcase operand::OP_EXPR:\n \t  if (gimple)\n-\t    n_braces = gen_gimple_expr (f, indent);\n+\t    n_braces = gen_gimple_expr (f, indent, depth);\n \t  else\n \t    n_braces = gen_generic_expr (f, indent, opname);\n \t  break;\n@@ -3208,7 +3217,7 @@ dt_operand::gen (FILE *f, int indent, bool gimple)\n     gcc_unreachable ();\n \n   indent += 4 * n_braces;\n-  gen_kids (f, indent, gimple);\n+  gen_kids (f, indent, gimple, depth);\n \n   for (unsigned i = 0; i < n_braces; ++i)\n     {\n@@ -3276,7 +3285,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t    if (cinfo.force_no_side_effects & (1 << i))\n \t      {\n \t\tfprintf_indent (f, indent,\n-\t\t\t\t\"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\",\n+\t\t\t\t\"if (TREE_SIDE_EFFECTS (_p%d)) return NULL_TREE;\\n\",\n \t\t\t\ti);\n \t\tif (verbose >= 1)\n \t\t  warning_at (as_a <expr *> (s->match)->ops[i]->location,\n@@ -3381,9 +3390,9 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t    {\n \t      char dest[32];\n \t      if (is_predicate)\n-\t\tsnprintf (dest, 32, \"res_ops[%d]\", j);\n+\t\tsnprintf (dest, sizeof (dest), \"res_ops[%d]\", j);\n \t      else\n-\t\tsnprintf (dest, 32, \"res_op->ops[%d]\", j);\n+\t\tsnprintf (dest, sizeof (dest), \"res_op->ops[%d]\", j);\n \t      const char *optype\n \t\t= get_operand_type (opr, j,\n \t\t\t\t    \"type\", e->expr_type,\n@@ -3468,11 +3477,11 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t    {\n \t      char dest[32];\n \t      if (is_predicate)\n-\t\tsnprintf (dest, 32, \"res_ops[%d]\", j);\n+\t\tsnprintf (dest, sizeof (dest), \"res_ops[%d]\", j);\n \t      else\n \t\t{\n \t\t  fprintf_indent (f, indent, \"tree res_op%d;\\n\", j);\n-\t\t  snprintf (dest, 32, \"res_op%d\", j);\n+\t\t  snprintf (dest, sizeof (dest), \"res_op%d\", j);\n \t\t}\n \t      const char *optype\n \t        = get_operand_type (opr, j,\n@@ -3486,32 +3495,32 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t    fprintf_indent (f, indent, \"return true;\\n\");\n \t  else\n \t    {\n-\t      fprintf_indent (f, indent, \"tree res;\\n\");\n+\t      fprintf_indent (f, indent, \"tree _r;\\n\");\n \t      /* Re-fold the toplevel result.  Use non_lvalue to\n-\t         build NON_LVALUE_EXPRs so they get properly\n+\t\t build NON_LVALUE_EXPRs so they get properly\n \t\t ignored when in GIMPLE form.  */\n \t      if (*opr == NON_LVALUE_EXPR)\n \t\tfprintf_indent (f, indent,\n-\t\t\t\t\"res = non_lvalue_loc (loc, res_op0);\\n\");\n+\t\t\t\t\"_r = non_lvalue_loc (loc, res_op0);\\n\");\n \t      else\n \t\t{\n \t\t  if (is_a <operator_id *> (opr))\n \t\t    fprintf_indent (f, indent,\n-\t\t\t\t    \"res = fold_build%d_loc (loc, %s, type\",\n+\t\t\t\t    \"_r = fold_build%d_loc (loc, %s, type\",\n \t\t\t\t    e->ops.length (),\n \t\t\t\t    *e->operation == CONVERT_EXPR\n \t\t\t\t    ? \"NOP_EXPR\" : e->operation->id);\n \t\t  else\n \t\t    fprintf_indent (f, indent,\n-\t\t\t\t    \"res = maybe_build_call_expr_loc (loc, \"\n+\t\t\t\t    \"_r = maybe_build_call_expr_loc (loc, \"\n \t\t\t\t    \"%s, type, %d\", e->operation->id,\n \t\t\t\t    e->ops.length());\n \t\t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t\t    fprintf (f, \", res_op%d\", j);\n \t\t  fprintf (f, \");\\n\");\n \t\t  if (!is_a <operator_id *> (opr))\n \t\t    {\n-\t\t      fprintf_indent (f, indent, \"if (!res)\\n\");\n+\t\t      fprintf_indent (f, indent, \"if (!_r)\\n\");\n \t\t      fprintf_indent (f, indent, \"  return NULL_TREE;\\n\");\n \t\t    }\n \t\t}\n@@ -3521,8 +3530,8 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t       || result->type == operand::OP_C_EXPR)\n \n \t{\n-\t  fprintf_indent (f, indent, \"tree res;\\n\");\n-\t  result->gen_transform (f, indent, \"res\", false, 1, \"type\",\n+\t  fprintf_indent (f, indent, \"tree _r;\\n\");\n+\t  result->gen_transform (f, indent, \"_r\", false, 1, \"type\",\n \t\t\t\t    &cinfo, indexes);\n \t}\n       else\n@@ -3543,12 +3552,12 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t\t\t\t  \"if (TREE_SIDE_EFFECTS (captures[%d]))\\n\",\n \t\t\t\t  i);\n \t\t  fprintf_indent (f, indent + 2,\n-\t\t\t\t  \"res = build2_loc (loc, COMPOUND_EXPR, type, \"\n-\t\t\t\t  \"fold_ignored_result (captures[%d]), res);\\n\",\n+\t\t\t\t  \"_r = build2_loc (loc, COMPOUND_EXPR, type, \"\n+\t\t\t\t  \"fold_ignored_result (captures[%d]), _r);\\n\",\n \t\t\t\t  i);\n \t\t}\n \t    }\n-\t  fprintf_indent (f, indent, \"return res;\\n\");\n+\t  fprintf_indent (f, indent, \"return _r;\\n\");\n \t}\n     }\n }\n@@ -3558,7 +3567,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n    that is not part of the decision tree (simplify->match).  */\n \n void\n-dt_simplify::gen (FILE *f, int indent, bool gimple)\n+dt_simplify::gen (FILE *f, int indent, bool gimple, int depth ATTRIBUTE_UNUSED)\n {\n   fprintf_indent (f, indent, \"{\\n\");\n   indent += 2;\n@@ -3597,7 +3606,7 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t  fprintf_indent (f, indent, \"tree res = %s (loc, type\",\n \t\t\t  info->fname);\n \t  for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n-\t    fprintf (f, \", op%d\", i);\n+\t    fprintf (f, \", _p%d\", i);\n \t  fprintf (f, \", captures\");\n \t  for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n \t    {\n@@ -3764,7 +3773,7 @@ decision_tree::gen (FILE *f, bool gimple)\n \t\t   (*iter).second->fname);\n \t  for (unsigned i = 0;\n \t       i < as_a <expr *>(s->s->s->match)->ops.length (); ++i)\n-\t    fprintf (f, \" tree ARG_UNUSED (op%d),\", i);\n+\t    fprintf (f, \" tree ARG_UNUSED (_p%d),\", i);\n \t  fprintf (f, \" tree *captures\\n\");\n \t}\n       for (unsigned i = 0; i < s->s->s->for_subst_vec.length (); ++i)\n@@ -3792,9 +3801,9 @@ decision_tree::gen (FILE *f, bool gimple)\n   for (unsigned n = 1; n <= 5; ++n)\n     {\n       /* First generate split-out functions.  */\n-      for (unsigned i = 0; i < root->kids.length (); i++)\n+      for (unsigned j = 0; j < root->kids.length (); j++)\n \t{\n-\t  dt_operand *dop = static_cast<dt_operand *>(root->kids[i]);\n+\t  dt_operand *dop = static_cast<dt_operand *>(root->kids[j]);\n \t  expr *e = static_cast<expr *>(dop->op);\n \t  if (e->ops.length () != n\n \t      /* Builtin simplifications are somewhat premature on\n@@ -3820,10 +3829,10 @@ decision_tree::gen (FILE *f, bool gimple)\n \t\t     \"tree_code ARG_UNUSED (code), const tree ARG_UNUSED (type)\",\n \t\t     e->operation->id);\n \t  for (unsigned i = 0; i < n; ++i)\n-\t    fprintf (f, \", tree op%d\", i);\n+\t    fprintf (f, \", tree _p%d\", i);\n \t  fprintf (f, \")\\n\");\n \t  fprintf (f, \"{\\n\");\n-\t  dop->gen_kids (f, 2, gimple);\n+\t  dop->gen_kids (f, 2, gimple, 0);\n \t  if (gimple)\n \t    fprintf (f, \"  return false;\\n\");\n \t  else\n@@ -3843,7 +3852,7 @@ decision_tree::gen (FILE *f, bool gimple)\n \t\t \"generic_simplify (location_t loc, enum tree_code code, \"\n \t\t \"const tree type ATTRIBUTE_UNUSED\");\n       for (unsigned i = 0; i < n; ++i)\n-\tfprintf (f, \", tree op%d\", i);\n+\tfprintf (f, \", tree _p%d\", i);\n       fprintf (f, \")\\n\");\n       fprintf (f, \"{\\n\");\n \n@@ -3879,8 +3888,8 @@ decision_tree::gen (FILE *f, bool gimple)\n \t  else\n \t    fprintf (f, \"      return generic_simplify_%s (loc, code, type\",\n \t\t     e->operation->id);\n-\t  for (unsigned i = 0; i < n; ++i)\n-\t    fprintf (f, \", op%d\", i);\n+\t  for (unsigned j = 0; j < n; ++j)\n+\t    fprintf (f, \", _p%d\", j);\n \t  fprintf (f, \");\\n\");\n \t}\n       fprintf (f,       \"    default:;\\n\"\n@@ -3909,7 +3918,7 @@ write_predicate (FILE *f, predicate_id *p, decision_tree &dt, bool gimple)\n \n   if (!gimple)\n     fprintf_indent (f, 2, \"if (TREE_SIDE_EFFECTS (t)) return false;\\n\");\n-  dt.root->gen_kids (f, 2, gimple);\n+  dt.root->gen_kids (f, 2, gimple, 0);\n \n   fprintf_indent (f, 2, \"return false;\\n\"\n \t   \"}\\n\");\n@@ -4114,7 +4123,7 @@ parser::get_internal_capture_id ()\n   /* Big enough for a 32-bit UINT_MAX plus prefix.  */\n   char id[13];\n   bool existed;\n-  sprintf (id, \"__%u\", newid);\n+  snprintf (id, sizeof (id), \"__%u\", newid);\n   capture_ids->get_or_insert (xstrdup (id), &existed);\n   if (existed)\n     fatal (\"reserved capture id '%s' already used\", id);\n@@ -4261,11 +4270,11 @@ parser::parse_expr ()\n \t\t{\n \t\t  if (*sp == 'c')\n \t\t    {\n-\t\t      if (operator_id *p\n+\t\t      if (operator_id *o\n \t\t\t    = dyn_cast<operator_id *> (e->operation))\n \t\t\t{\n-\t\t\t  if (!commutative_tree_code (p->code)\n-\t\t\t      && !comparison_code_p (p->code))\n+\t\t\t  if (!commutative_tree_code (o->code)\n+\t\t\t      && !comparison_code_p (o->code))\n \t\t\t    fatal_at (token, \"operation is not commutative\");\n \t\t\t}\n \t\t      else if (user_id *p = dyn_cast<user_id *> (e->operation))\n@@ -4313,7 +4322,7 @@ parser::parse_expr ()\n     op = e;\n   do\n     {\n-      const cpp_token *token = peek ();\n+      token = peek ();\n       if (token->type == CPP_CLOSE_PAREN)\n \t{\n \t  if (e->operation->nargs != -1\n@@ -4424,17 +4433,17 @@ parser::parse_op ()\n \t  id_base *opr = get_operator (id);\n \t  if (!opr)\n \t    fatal_at (token, \"expected predicate name\");\n-\t  if (operator_id *code = dyn_cast <operator_id *> (opr))\n+\t  if (operator_id *code1 = dyn_cast <operator_id *> (opr))\n \t    {\n-\t      if (code->nargs != 0)\n+\t      if (code1->nargs != 0)\n \t\tfatal_at (token, \"using an operator with operands as predicate\");\n \t      /* Parse the zero-operand operator \"predicates\" as\n \t\t expression.  */\n \t      op = new expr (opr, token->src_loc);\n \t    }\n-\t  else if (user_id *code = dyn_cast <user_id *> (opr))\n+\t  else if (user_id *code2 = dyn_cast <user_id *> (opr))\n \t    {\n-\t      if (code->nargs != 0)\n+\t      if (code2->nargs != 0)\n \t\tfatal_at (token, \"using an operator with operands as predicate\");\n \t      /* Parse the zero-operand operator \"predicates\" as\n \t\t expression.  */\n@@ -4859,7 +4868,7 @@ parser::parse_if (location_t)\n   active_ifs.safe_push (ifexpr);\n   while (1)\n     {\n-      const cpp_token *token = peek ();\n+      token = peek ();\n       if (token->type == CPP_CLOSE_PAREN)\n \tbreak;\n \n@@ -4910,14 +4919,14 @@ parser::parse_pattern ()\n \t  with_args = true;\n \t}\n       const char *name = get_ident ();\n-      id_base *id = get_operator (name);\n+      id_base *id1 = get_operator (name);\n       predicate_id *p;\n-      if (!id)\n+      if (!id1)\n \t{\n \t  p = add_predicate (name);\n \t  user_predicates.safe_push (p);\n \t}\n-      else if ((p = dyn_cast <predicate_id *> (id)))\n+      else if ((p = dyn_cast <predicate_id *> (id1)))\n \t;\n       else\n \tfatal_at (token, \"cannot add a match to a non-predicate ID\");\n@@ -5160,12 +5169,12 @@ add_operator (VIEW_CONVERT2, \"view_convert2\", \"tcc_unary\", 1);\n       lower (pred->matchers, gimple);\n \n       if (verbose == 2)\n-\tfor (unsigned i = 0; i < pred->matchers.length (); ++i)\n-\t  print_matches (pred->matchers[i]);\n+\tfor (unsigned j = 0; j < pred->matchers.length (); ++j)\n+\t  print_matches (pred->matchers[j]);\n \n       decision_tree dt;\n-      for (unsigned i = 0; i < pred->matchers.length (); ++i)\n-\tdt.insert (pred->matchers[i], i);\n+      for (unsigned j = 0; j < pred->matchers.length (); ++j)\n+\tdt.insert (pred->matchers[j], j);\n \n       if (verbose == 2)\n \tdt.print (stderr);"}]}