{"sha": "602a7ec025a239f80d9857fc4c80dfd8b961910e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAyYTdlYzAyNWEyMzlmODBkOTg1N2ZjNGM4MGRmZDhiOTYxOTEwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T15:24:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T15:24:03Z"}, "message": "[multiple changes]\n\n2010-06-21  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Conditional_Expression): Fold if condition\n\tknown at compile time.\n\n2010-06-21  Gary Dismukes  <dismukes@adacore.com>\n\n\t* atree.adb: Fix comment typo.\n\n2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_eval.adb (Test_Ambiguous_Operator): New procedure to check\n\twhether a universal arithmetic expression in a conversion, which is\n\trewritten from a function call with an expanded name, is ambiguous.\n\n2010-06-21  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Name_Location): New Boolean component Listed, to record\n\tsource files in specified list of sources.\n\t(Check_Package_Naming): Remove out parameters Bodies and Specs, as they\n\tare never used.\n\t(Add_Source): Set the Location of the new source\n\t(Process_Exceptions_File_Based): Call Add_Source with the Location\n\t(Get_Sources_From_File): If an exception is found, set its Listed to\n\tTrue\n\t(Find_Sources): When Source_Files is specified, if an exception is\n\tfound, set its Listed to True. Remove any exception that is not in a\n\tspecified list of sources.\n\t* prj.ads (Source_Data): New component Location\n\n2010-06-21  Vincent Celier  <celier@adacore.com>\n\n\t* gnatbind.adb (Closure_Sources): Global table, moved from block.\n\nFrom-SVN: r161088", "tree": {"sha": "2f26229f8bb14959089bd4e16133eda60ff5d845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f26229f8bb14959089bd4e16133eda60ff5d845"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/602a7ec025a239f80d9857fc4c80dfd8b961910e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602a7ec025a239f80d9857fc4c80dfd8b961910e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602a7ec025a239f80d9857fc4c80dfd8b961910e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602a7ec025a239f80d9857fc4c80dfd8b961910e/comments", "author": null, "committer": null, "parents": [{"sha": "06f2efd7ed334399dcbab0ebe6980c42cd21acaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f2efd7ed334399dcbab0ebe6980c42cd21acaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06f2efd7ed334399dcbab0ebe6980c42cd21acaf"}], "stats": {"total": 303, "additions": 261, "deletions": 42}, "files": [{"sha": "317195a3bfb8ee3f6c809b579481a146bf0e55b6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=602a7ec025a239f80d9857fc4c80dfd8b961910e", "patch": "@@ -1,3 +1,37 @@\n+2010-06-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Conditional_Expression): Fold if condition\n+\tknown at compile time.\n+\n+2010-06-21  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* atree.adb: Fix comment typo.\n+\n+2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_eval.adb (Test_Ambiguous_Operator): New procedure to check\n+\twhether a universal arithmetic expression in a conversion, which is\n+\trewritten from a function call with an expanded name, is ambiguous.\n+\n+2010-06-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Name_Location): New Boolean component Listed, to record\n+\tsource files in specified list of sources.\n+\t(Check_Package_Naming): Remove out parameters Bodies and Specs, as they\n+\tare never used.\n+\t(Add_Source): Set the Location of the new source\n+\t(Process_Exceptions_File_Based): Call Add_Source with the Location\n+\t(Get_Sources_From_File): If an exception is found, set its Listed to\n+\tTrue\n+\t(Find_Sources): When Source_Files is specified, if an exception is\n+\tfound, set its Listed to True. Remove any exception that is not in a\n+\tspecified list of sources.\n+\t* prj.ads (Source_Data): New component Location\n+\n+2010-06-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatbind.adb (Closure_Sources): Global table, moved from block.\n+\n 2010-06-21  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_res.adb: Minor reformatting."}, {"sha": "6f1fc55111fc5d28823b5675d79d198a752283e0", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=602a7ec025a239f80d9857fc4c80dfd8b961910e", "patch": "@@ -108,7 +108,7 @@ package body Atree is\n    --  calls Rewrite_Breakpoint. Otherwise, does nothing.\n \n    procedure Node_Debug_Output (Op : String; N : Node_Id);\n-   --  Common code for nnr and rrd. Write Op followed by information about N\n+   --  Common code for nnd and rrd. Write Op followed by information about N.\n \n    -----------------------------\n    -- Local Objects and Types --"}, {"sha": "10d9dbc4af9f5ac418860d0cbcfd1cf952114058", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=602a7ec025a239f80d9857fc4c80dfd8b961910e", "patch": "@@ -2826,9 +2826,9 @@ package body Exp_Ch4 is\n \n       Insert_Actions (Cnode, Actions, Suppress => All_Checks);\n \n-      --  Now we construct an array object with appropriate bounds\n-      --  The target is marked as internal, to prevent useless initialization\n-      --  when Initialize_Scalars is enabled.\n+      --  Now we construct an array object with appropriate bounds. We mark\n+      --  the target as internal to prevent useless initialization when\n+      --  Initialize_Scalars is enabled.\n \n       Ent := Make_Temporary (Loc, 'S');\n       Set_Is_Internal (Ent);\n@@ -4025,13 +4025,44 @@ package body Exp_Ch4 is\n       Elsex  : constant Node_Id    := Next (Thenx);\n       Typ    : constant Entity_Id  := Etype (N);\n \n-      Cnn    : Entity_Id;\n-      Decl   : Node_Id;\n-      New_If : Node_Id;\n-      New_N  : Node_Id;\n-      P_Decl : Node_Id;\n+      Cnn     : Entity_Id;\n+      Decl    : Node_Id;\n+      New_If  : Node_Id;\n+      New_N   : Node_Id;\n+      P_Decl  : Node_Id;\n+      Expr    : Node_Id;\n+      Actions : List_Id;\n \n    begin\n+      --  Fold at compile time if condition known. We have already folded\n+      --  static conditional expressions, but it is possible to fold any\n+      --  case in which the condition is known at compile time, even though\n+      --  the result is non-static.\n+\n+      --  Note that we don't do the fold of such cases in Sem_Elab because\n+      --  it can cause infinite loops with the expander adding a conditional\n+      --  expression, and Sem_Elab circuitry removing it repeatedly.\n+\n+      if Compile_Time_Known_Value (Cond) then\n+         if Is_True (Expr_Value (Cond)) then\n+            Expr := Thenx;\n+            Actions := Then_Actions (N);\n+         else\n+            Expr := Elsex;\n+            Actions := Else_Actions (N);\n+         end if;\n+\n+         Remove (Expr);\n+         Insert_Actions (N, Actions);\n+         Rewrite (N, Relocate_Node (Expr));\n+\n+         --  Note that the result is never static (legitimate cases of static\n+         --  conditional expressions were folded in Sem_Eval).\n+\n+         Set_Is_Static_Expression (N, False);\n+         return;\n+      end if;\n+\n       --  If the type is limited or unconstrained, we expand as follows to\n       --  avoid any possibility of improper copies.\n "}, {"sha": "cc06ce397062db50670692f53c56c1bec45edde2", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=602a7ec025a239f80d9857fc4c80dfd8b961910e", "patch": "@@ -82,6 +82,16 @@ procedure Gnatbind is\n \n    Mapping_File : String_Ptr := null;\n \n+   package Closure_Sources is new Table.Table\n+     (Table_Component_Type => File_Name_Type,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 10,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Gnatbind.Closure_Sources\");\n+   --  Table to record the sources in the closure, to avoid duplications. Used\n+   --  only with switch -R.\n+\n    function Gnatbind_Supports_Auto_Init return Boolean;\n    --  Indicates if automatic initialization of elaboration procedure\n    --  through the constructor mechanism is possible on the platform.\n@@ -817,16 +827,6 @@ begin\n \n             if List_Closure then\n                declare\n-                  package Sources is new Table.Table\n-                    (Table_Component_Type => File_Name_Type,\n-                     Table_Index_Type     => Natural,\n-                     Table_Low_Bound      => 1,\n-                     Table_Initial        => 10,\n-                     Table_Increment      => 100,\n-                     Table_Name           => \"Gnatbind.Sources\");\n-                  --  Table to record the sources in the closure, to avoid\n-                  --  dupications.\n-\n                   Source : File_Name_Type;\n \n                   function Put_In_Sources (S : File_Name_Type) return Boolean;\n@@ -842,17 +842,19 @@ begin\n                                            return Boolean\n                   is\n                   begin\n-                     for J in 1 .. Sources.Last loop\n-                        if Sources.Table (J) = S then\n+                     for J in 1 .. Closure_Sources.Last loop\n+                        if Closure_Sources.Table (J) = S then\n                            return False;\n                         end if;\n                      end loop;\n \n-                     Sources.Append (S);\n+                     Closure_Sources.Append (S);\n                      return True;\n                   end Put_In_Sources;\n \n                begin\n+                  Closure_Sources.Init;\n+\n                   if not Zero_Formatting then\n                      Write_Eol;\n                      Write_Str (\"REFERENCED SOURCES\");"}, {"sha": "7932486ed7a3459814426efa97821f223717729e", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 73, "deletions": 20, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=602a7ec025a239f80d9857fc4c80dfd8b961910e", "patch": "@@ -54,10 +54,11 @@ package body Prj.Nmsc is\n       Name     : File_Name_Type;  --  ??? duplicates the key\n       Location : Source_Ptr;\n       Source   : Source_Id := No_Source;\n+      Listed   : Boolean := False;\n       Found    : Boolean := False;\n    end record;\n    No_Name_Location : constant Name_Location :=\n-     (No_File, No_Location, No_Source, False);\n+     (No_File, No_Location, No_Source, False, False);\n    package Source_Names_Htable is new GNAT.Dynamic_HTables.Simple_HTable\n      (Header_Num => Header_Num,\n       Element    => Name_Location,\n@@ -234,13 +235,9 @@ package body Prj.Nmsc is\n \n    procedure Check_Package_Naming\n      (Project : Project_Id;\n-      Data    : in out Tree_Processing_Data;\n-      Bodies  : out Array_Element_Id;\n-      Specs   : out Array_Element_Id);\n+      Data    : in out Tree_Processing_Data);\n    --  Check the naming scheme part of Data, and initialize the naming scheme\n-   --  data in the config of the various languages. This also returns the\n-   --  naming scheme exceptions for unit-based languages (Bodies and Specs are\n-   --  associative arrays mapping individual unit names to source file names).\n+   --  data in the config of the various languages.\n \n    procedure Check_Configuration\n      (Project : Project_Id;\n@@ -727,6 +724,7 @@ package body Prj.Nmsc is\n       end if;\n \n       Id.Project             := Project;\n+      Id.Location            := Location;\n       Id.Source_Dir_Rank     := Source_Dir_Rank;\n       Id.Language            := Lang_Id;\n       Id.Kind                := Kind;\n@@ -816,8 +814,6 @@ package body Prj.Nmsc is\n      (Project : Project_Id;\n       Data    : in out Tree_Processing_Data)\n    is\n-      Specs     : Array_Element_Id;\n-      Bodies    : Array_Element_Id;\n       Extending : Boolean := False;\n       Prj_Data  : Project_Processing_Data;\n \n@@ -889,7 +885,7 @@ package body Prj.Nmsc is\n \n       Extending := Project.Extends /= No_Project;\n \n-      Check_Package_Naming (Project, Data, Bodies => Bodies, Specs => Specs);\n+      Check_Package_Naming (Project, Data);\n \n       --  Find the sources\n \n@@ -2722,9 +2718,7 @@ package body Prj.Nmsc is\n \n    procedure Check_Package_Naming\n      (Project : Project_Id;\n-      Data    : in out Tree_Processing_Data;\n-      Bodies  : out Array_Element_Id;\n-      Specs   : out Array_Element_Id)\n+      Data    : in out Tree_Processing_Data)\n    is\n       Naming_Id : constant Package_Id :=\n                     Util.Value_Of\n@@ -2957,7 +2951,8 @@ package body Prj.Nmsc is\n                      Kind             => Kind,\n                      File_Name        => File_Name,\n                      Display_File     => File_Name_Type (Element.Value),\n-                     Naming_Exception => True);\n+                     Naming_Exception => True,\n+                     Location         => Element.Location);\n \n                else\n                   --  Check if the file name is already recorded for another\n@@ -3380,9 +3375,6 @@ package body Prj.Nmsc is\n    --  Start of processing for Check_Naming_Schemes\n \n    begin\n-      Specs  := No_Array_Element;\n-      Bodies := No_Array_Element;\n-\n       --  No Naming package or parsing a configuration file? nothing to do\n \n       if Naming_Id /= No_Package\n@@ -5557,7 +5549,11 @@ package body Prj.Nmsc is\n                     (Name     => Source_Name,\n                      Location => Location,\n                      Source   => No_Source,\n+                     Listed   => True,\n                      Found    => False);\n+\n+               else\n+                  Name_Loc.Listed := True;\n                end if;\n \n                Source_Names_Htable.Set\n@@ -6292,11 +6288,16 @@ package body Prj.Nmsc is\n                     (Name     => Name,\n                      Location => Location,\n                      Source   => No_Source,\n+                     Listed   => True,\n                      Found    => False);\n-                  Source_Names_Htable.Set\n-                    (Project.Source_Names, Name, Name_Loc);\n+\n+               else\n+                  Name_Loc.Listed := True;\n                end if;\n \n+               Source_Names_Htable.Set\n+                 (Project.Source_Names, Name, Name_Loc);\n+\n                Current := Element.Next;\n             end loop;\n \n@@ -6343,6 +6344,57 @@ package body Prj.Nmsc is\n          Has_Explicit_Sources := False;\n       end if;\n \n+      --  Remove any exception that is not in the specified list of sources\n+\n+      if Has_Explicit_Sources then\n+         declare\n+            Source : Source_Id;\n+            Iter   : Source_Iterator;\n+            NL     : Name_Location;\n+            Again  : Boolean;\n+         begin\n+            Iter_Loop :\n+            loop\n+               Again := False;\n+               Iter := For_Each_Source (Data.Tree, Project.Project);\n+\n+               Source_Loop :\n+               loop\n+                  Source := Prj.Element (Iter);\n+                  exit Source_Loop when Source = No_Source;\n+\n+                  if Source.Naming_Exception then\n+                     NL := Source_Names_Htable.Get\n+                       (Project.Source_Names, Source.File);\n+\n+                     if NL /= No_Name_Location and then not NL.Listed then\n+                        --  Remove the exception\n+                        Source_Names_Htable.Set\n+                          (Project.Source_Names,\n+                           Source.File,\n+                           No_Name_Location);\n+                        Remove_Source (Source, No_Source);\n+\n+                        Error_Msg_Name_1 := Name_Id (Source.File);\n+                        Error_Msg\n+                          (Data.Flags,\n+                           \"? unknown source file %%\",\n+                           NL.Location,\n+                           Project.Project);\n+\n+                        Again := True;\n+                        exit Source_Loop;\n+                     end if;\n+                  end if;\n+\n+                  Next (Iter);\n+               end loop Source_Loop;\n+\n+               exit Iter_Loop when not Again;\n+            end loop Iter_Loop;\n+         end;\n+      end if;\n+\n       Search_Directories\n         (Project,\n          Data            => Data,\n@@ -7031,8 +7083,9 @@ package body Prj.Nmsc is\n             K => Source.File,\n             E => Name_Location'\n                   (Name     => Source.File,\n-                   Location => No_Location,\n+                   Location => Source.Location,\n                    Source   => Source,\n+                   Listed   => False,\n                    Found    => False));\n \n          --  If this is an Ada exception, record in table Unit_Exceptions"}, {"sha": "cba9c6f1b36ab2ed7f9dfa0e23bc90b2410d2ede", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=602a7ec025a239f80d9857fc4c80dfd8b961910e", "patch": "@@ -667,6 +667,10 @@ package Prj is\n       Project : Project_Id := No_Project;\n       --  Project of the source\n \n+      Location : Source_Ptr := No_Location;\n+      --  Location in the project file of the declaration of the source in\n+      --  package Naming.\n+\n       Source_Dir_Rank : Natural := 0;\n       --  The rank of the source directory in list declared with attribute\n       --  Source_Dirs. Two source files with the same name cannot appears in\n@@ -768,6 +772,7 @@ package Prj is\n \n    No_Source_Data : constant Source_Data :=\n                       (Project                => No_Project,\n+                       Location               => No_Location,\n                        Source_Dir_Rank        => 0,\n                        Language               => No_Language_Index,\n                        In_Interfaces          => True,"}, {"sha": "b2a29a577dbcca2ea81233ef3b3115cb530ef7d4", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602a7ec025a239f80d9857fc4c80dfd8b961910e/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=602a7ec025a239f80d9857fc4c80dfd8b961910e", "patch": "@@ -180,6 +180,13 @@ package body Sem_Eval is\n    --  used for producing the result of the static evaluation of the\n    --  logical operators\n \n+   procedure Test_Ambiguous_Operator (N : Node_Id);\n+   --  Check whether an arithmetic operation with universal operands which\n+   --  is a rewritten function call with an explicit scope indication is\n+   --  ambiguous:  P.\"+\" (1, 2) will be ambiguous if there is more than one\n+   --  visible numeric type declared in P and the context does not impose a\n+   --  type on the result (e.g. in the expression of a type conversion).\n+\n    procedure Test_Expression_Is_Foldable\n      (N    : Node_Id;\n       Op1  : Node_Id;\n@@ -1458,6 +1465,15 @@ package body Sem_Eval is\n          return;\n       end if;\n \n+      if (Etype (Right) = Universal_Integer\n+           or else Etype (Right) = Universal_Real)\n+        and then\n+          (Etype (Left) = Universal_Integer\n+            or else Etype (Left) = Universal_Real)\n+      then\n+         Test_Ambiguous_Operator (N);\n+      end if;\n+\n       --  Fold for cases where both operands are of integer type\n \n       if Is_Integer_Type (Ltype) and then Is_Integer_Type (Rtype) then\n@@ -3395,6 +3411,12 @@ package body Sem_Eval is\n          return;\n       end if;\n \n+      if Etype (Right) = Universal_Integer\n+           or else Etype (Right) = Universal_Real\n+      then\n+         Test_Ambiguous_Operator (N);\n+      end if;\n+\n       --  Fold for integer case\n \n       if Is_Integer_Type (Etype (N)) then\n@@ -4699,6 +4721,78 @@ package body Sem_Eval is\n       end if;\n    end Test;\n \n+   -----------------------------\n+   -- Test_Ambiguous_Operator --\n+   -----------------------------\n+\n+   procedure Test_Ambiguous_Operator (N : Node_Id) is\n+      Call   : constant Node_Id := Original_Node (N);\n+      Is_Int : constant Boolean := Is_Integer_Type (Etype (N));\n+\n+      Is_Fix : constant Boolean :=\n+        Nkind (N) in N_Binary_Op\n+        and then Nkind (Right_Opnd (N)) /= Nkind (Left_Opnd (N));\n+      --  a mixed-mode operation in this context indicates the\n+      --  presence of fixed-point type in the designated package.\n+\n+      E      : Entity_Id;\n+      Pack   : Entity_Id;\n+      Typ1   : Entity_Id;\n+      Priv_E : Entity_Id;\n+\n+   begin\n+      if Nkind (Call) /= N_Function_Call\n+        or else Nkind (Name (Call)) /= N_Expanded_Name\n+      then\n+         return;\n+\n+      elsif Nkind (Parent (N)) = N_Type_Conversion then\n+         Pack := Entity (Prefix (Name (Call)));\n+\n+         --  If the prefix is a package declared elsewhere, iterate over\n+         --  its visible entities, otherwise iterate over all declarations\n+         --  in the designated scope.\n+\n+         if Ekind (Pack) = E_Package\n+           and then not In_Open_Scopes (Pack)\n+         then\n+            Priv_E := First_Private_Entity (Pack);\n+         else\n+            Priv_E := Empty;\n+         end if;\n+\n+         Typ1 := Empty;\n+         E := First_Entity (Pack);\n+         while Present (E)\n+           and then E /= Priv_E\n+         loop\n+            if Is_Numeric_Type (E)\n+              and then Nkind (Parent (E)) /= N_Subtype_Declaration\n+              and then Comes_From_Source (E)\n+              and then Is_Integer_Type (E) = Is_Int\n+              and then\n+                (Nkind (N) in N_Unary_Op\n+                  or else Is_Fixed_Point_Type (E) = Is_Fix)\n+            then\n+               if No (Typ1) then\n+                  Typ1 := E;\n+\n+               else\n+                  --  More than one type of the proper class declared in P\n+\n+                  Error_Msg_N (\"ambiguous operation\", N);\n+                  Error_Msg_Sloc := Sloc (Typ1);\n+                  Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n+                  Error_Msg_Sloc := Sloc (E);\n+                  Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n+               end if;\n+            end if;\n+\n+            Next_Entity (E);\n+         end loop;\n+      end if;\n+   end Test_Ambiguous_Operator;\n+\n    ---------------------------------\n    -- Test_Expression_Is_Foldable --\n    ---------------------------------"}]}