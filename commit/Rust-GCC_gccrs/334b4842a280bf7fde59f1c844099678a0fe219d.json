{"sha": "334b4842a280bf7fde59f1c844099678a0fe219d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM0YjQ4NDJhMjgwYmY3ZmRlNTlmMWM4NDQwOTk2NzhhMGZlMjE5ZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-10-29T20:37:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-29T20:37:01Z"}, "message": "[PATCH] Remove unnecessary invalidation support in threading\n2015-10-29  Jeff Law  <law@redhat.com>\n\n\t* tree-ssa-scopedtables.h (const_and_copies): Remove invalidate\n\tmethod.\n\t* tree-ssa-scopedtables.h (const_and_copies::invalidate): Remove.\n\t* tree-ssa-threadedge.c\n\t(record_temporary_equivalences_from_stmts_at_dest): Remove\n\tbackedge_seen argument and associated code which invalidated\n\tequivalences based on the value of that argument.\n\t(thread_through_normal_block): Corresponding changes.\n\nFrom-SVN: r229559", "tree": {"sha": "e3383887c06bf39776d85ce45967e12daa3339bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3383887c06bf39776d85ce45967e12daa3339bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/334b4842a280bf7fde59f1c844099678a0fe219d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/334b4842a280bf7fde59f1c844099678a0fe219d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/334b4842a280bf7fde59f1c844099678a0fe219d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/334b4842a280bf7fde59f1c844099678a0fe219d/comments", "author": null, "committer": null, "parents": [{"sha": "5a978b9f8899d6fc42364c0db8ed13b674a5ffb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a978b9f8899d6fc42364c0db8ed13b674a5ffb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a978b9f8899d6fc42364c0db8ed13b674a5ffb0"}], "stats": {"total": 97, "additions": 16, "deletions": 81}, "files": [{"sha": "2ff1db6a048374d68889ae1c0c114b20b84dedd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=334b4842a280bf7fde59f1c844099678a0fe219d", "patch": "@@ -1,3 +1,14 @@\n+2015-10-29  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-scopedtables.h (const_and_copies): Remove invalidate\n+\tmethod.\n+\t* tree-ssa-scopedtables.h (const_and_copies::invalidate): Remove.\n+\t* tree-ssa-threadedge.c\n+\t(record_temporary_equivalences_from_stmts_at_dest): Remove\n+\tbackedge_seen argument and associated code which invalidated\n+\tequivalences based on the value of that argument.\n+\t(thread_through_normal_block): Corresponding changes.\n+\n 2015-10-29  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.c (rs6000_reg_live_or_pic_offset_p): Move this"}, {"sha": "ae5acc21a7a5d61abc91503a8ebbdc38c7224106", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=334b4842a280bf7fde59f1c844099678a0fe219d", "patch": "@@ -669,45 +669,6 @@ const_and_copies::record_const_or_copy (tree x, tree y, tree prev_x)\n   m_stack.quick_push (x);\n }\n \n-/* A new value has been assigned to LHS.  If necessary, invalidate any\n-   equivalences that are no longer valid.   This includes invaliding\n-   LHS and any objects that are currently equivalent to LHS.\n-\n-   Finding the objects that are currently marked as equivalent to LHS\n-   is a bit tricky.  We could walk the ssa names and see if any have\n-   SSA_NAME_VALUE that is the same as LHS.  That's expensive.\n-\n-   However, it's far more efficient to look at the unwinding stack as\n-   that will have all context sensitive equivalences which are the only\n-   ones that we really have to worry about here.   */\n-void\n-const_and_copies::invalidate (tree lhs)\n-{\n-\n-  /* The stack is an unwinding stack.  If the current element is NULL\n-     then it's a \"stop unwinding\" marker.  Else the current marker is\n-     the SSA_NAME with an equivalence and the prior entry in the stack\n-     is what the current element is equivalent to.  */\n-  for (int i = m_stack.length() - 1; i >= 0; i--)\n-    {\n-      /* Ignore the stop unwinding markers.  */\n-      if ((m_stack)[i] == NULL)\n-\tcontinue;\n-\n-      /* We want to check the current value of stack[i] to see if\n-\t it matches LHS.  If so, then invalidate.  */\n-      if (SSA_NAME_VALUE ((m_stack)[i]) == lhs)\n-\trecord_const_or_copy ((m_stack)[i], NULL_TREE);\n-\n-      /* Remember, we're dealing with two elements in this case.  */\n-      i--;\n-    }\n-\n-  /* And invalidate any known value for LHS itself.  */\n-  if (SSA_NAME_VALUE (lhs))\n-    record_const_or_copy (lhs, NULL_TREE);\n-}\n-\n bool\n expr_elt_hasher::equal (const value_type &p1, const compare_type &p2)\n {"}, {"sha": "1e6b46cd5bb39e6b0e46736130dcaa3080d1dd9f", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=334b4842a280bf7fde59f1c844099678a0fe219d", "patch": "@@ -168,12 +168,6 @@ class const_and_copies\n      value for the first argument.  Try to get rid of this in the future.  */\n   void record_const_or_copy (tree, tree, tree);\n \n-  /* When threading we need to invalidate certain equivalences after\n-     following a loop backedge.  The entries we need to invalidate will\n-     always be in this unwindable stack.  This entry point handles\n-     finding and invalidating those entries.  */\n-  void invalidate (tree);\n-\n  private:\n   vec<tree> m_stack;\n   const_and_copies& operator= (const const_and_copies&);"}, {"sha": "9379198901fa43fab5e979b902a987405cb52d78", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/334b4842a280bf7fde59f1c844099678a0fe219d/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=334b4842a280bf7fde59f1c844099678a0fe219d", "patch": "@@ -215,8 +215,7 @@ static gimple *\n record_temporary_equivalences_from_stmts_at_dest (edge e,\n     const_and_copies *const_and_copies,\n     avail_exprs_stack *avail_exprs_stack,\n-    pfn_simplify simplify,\n-    bool backedge_seen)\n+    pfn_simplify simplify)\n {\n   gimple *stmt = NULL;\n   gimple_stmt_iterator gsi;\n@@ -268,22 +267,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n           && (gimple_code (stmt) != GIMPLE_CALL\n               || gimple_call_lhs (stmt) == NULL_TREE\n               || TREE_CODE (gimple_call_lhs (stmt)) != SSA_NAME))\n-\t{\n-\t  /* STMT might still have DEFS and we need to invalidate any known\n-\t     equivalences for them.\n-\n-\t     Consider if STMT is a GIMPLE_ASM with one or more outputs that\n-\t     feeds a conditional inside a loop.  We might derive an equivalence\n-\t     due to the conditional.  */\n-\t  tree op;\n-\t  ssa_op_iter iter;\n-\n-\t  if (backedge_seen)\n-\t    FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n-\t      const_and_copies->invalidate (op);\n-\n-\t  continue;\n-\t}\n+\tcontinue;\n \n       /* The result of __builtin_object_size depends on all the arguments\n \t of a phi node. Temporarily using only one edge produces invalid\n@@ -316,14 +300,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t  if (fndecl\n \t      && (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_OBJECT_SIZE\n \t\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CONSTANT_P))\n-\t    {\n-\t      if (backedge_seen)\n-\t\t{\n-\t\t  tree lhs = gimple_get_lhs (stmt);\n-\t\t  const_and_copies->invalidate (lhs);\n-\t\t}\n-\t      continue;\n-\t    }\n+\t    continue;\n \t}\n \n       /* At this point we have a statement which assigns an RHS to an\n@@ -389,19 +366,12 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t}\n \n       /* Record the context sensitive equivalence if we were able\n-\t to simplify this statement.\n-\n-\t If we have traversed a backedge at some point during threading,\n-\t then always enter something here.  Either a real equivalence,\n-\t or a NULL_TREE equivalence which is effectively invalidation of\n-\t prior equivalences.  */\n+\t to simplify this statement.  */\n       if (cached_lhs\n \t  && (TREE_CODE (cached_lhs) == SSA_NAME\n \t      || is_gimple_min_invariant (cached_lhs)))\n \tconst_and_copies->record_const_or_copy (gimple_get_lhs (stmt),\n \t\t\t\t\t\tcached_lhs);\n-      else if (backedge_seen)\n-\tconst_and_copies->invalidate (gimple_get_lhs (stmt));\n     }\n   return stmt;\n }\n@@ -925,8 +895,7 @@ thread_through_normal_block (edge e,\n   gimple *stmt\n     = record_temporary_equivalences_from_stmts_at_dest (e, const_and_copies,\n \t\t\t\t\t\t\tavail_exprs_stack,\n-\t\t\t\t\t\t\tsimplify,\n-\t\t\t\t\t\t\t*backedge_seen_p);\n+\t\t\t\t\t\t\tsimplify);\n \n   /* There's two reasons STMT might be null, and distinguishing\n      between them is important."}]}