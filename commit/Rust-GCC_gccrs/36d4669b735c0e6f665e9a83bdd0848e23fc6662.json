{"sha": "36d4669b735c0e6f665e9a83bdd0848e23fc6662", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZkNDY2OWI3MzVjMGU2ZjY2NWU5YTgzYmRkMDg0OGUyM2ZjNjY2Mg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-05-12T20:45:20Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-05-12T20:45:20Z"}, "message": "ByteBufferImpl.java: Reformatted.\n\n2003-05-12  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/nio/ByteBufferImpl.java: Reformatted.\n\t(nio_get_*): Removed.\n\t(nio_put_*): Removed.\n\t(as*Buffer): Implemented.\n\t(compact): Implemented.\n\t(get): Documentation added.\n\t(put): Documentation added.\n\t(get*): Newly implemented.\n\t(put*): Newly implemented.\n\t* gnu/java/nio/CharBufferImpl.java: Reformatted.\n\t(CharBufferImpl): Revised.\n\t(slice): New implementation.\n\t(duplicate): New implementation.\n\t(compact): New implementation.\n\t(asReadOnlyBuffer): New implementation.\n\t(get): Documentation revised.\n\t(order): Return native byte order.\n\t* gnu/java/nio/DirectByteBufferImpl.java\n\t(allocateDirect): objects can be null not 0.\n\t* gnu/java/nio/DoubleBufferImpl.java: Reformatted.\n\t(DoubleBufferImpl): Revised.\n\t(slice): New implementation.\n\t(duplicate): New implementation.\n\t(compact): New implementation.\n\t(asReadOnlyBuffer): New implementation.\n\t(get): Documentation revised.\n\t(order): Return native byte order.\n\t* gnu/java/nio/FloatBufferImpl.java: Reformatted.\n\t(FloatBufferImpl): Revised.\n\t(slice): New implementation.\n\t(duplicate): New implementation.\n\t(compact): New implementation.\n\t(asReadOnlyBuffer): New implementation.\n\t(get): Documentation revised.\n\t(order): Return native byte order.\n\t* gnu/java/nio/IntBufferImpl.java: Reformatted.\n\t(IntBufferImpl): Revised.\n\t(slice): New implementation.\n\t(duplicate): New implementation.\n\t(compact): New implementation.\n\t(asReadOnlyBuffer): New implementation.\n\t(get): Documentation revised.\n\t(order): Return native byte order.\n\t* gnu/java/nio/LongBufferImpl.java: Reformatted.\n\t(LongBufferImpl): Revised.\n\t(slice): New implementation.\n\t(duplicate): New implementation.\n\t(compact): New implementation.\n\t(asReadOnlyBuffer): New implementation.\n\t(get): Documentation revised.\n\t(order): Return native byte order.\n\t* gnu/java/nio/ShortBufferImpl.java: Reformatted.\n\t(ShortBufferImpl): Revised.\n\t(slice): New implementation.\n\t(duplicate): New implementation.\n\t(compact): New implementation.\n\t(asReadOnlyBuffer): New implementation.\n\t(get): Documentation revised.\n\t(order): Return native byte order.\n\t* java/nio/CharBuffer.java: Reformatted, much documentation rewritten.\n\t(CharBuffer): Revised.\n\t(order): Removed.\n\t* java/nio/DoubleBuffer.java: Reformatted, much documentation rewritten.\n\t(DoubleBuffer): Revised.\n\t(allocateDirect): Removed.\n\t(order): Removed.\n\t* java/nio/FloatBuffer.java: Reformatted, much documentation rewritten.\n\t(FloatBuffer): Revised.\n\t(allocateDirect): Removed.\n\t(order): Removed.\n\t* java/nio/IntBuffer.java: Reformatted, much documentation rewritten.\n\t(IntBuffer): Revised.\n\t(allocateDirect): Removed.\n\t(order): Removed.\n\t* java/nio/LongBuffer.java: Reformatted, much documentation rewritten.\n\t(LongBuffer): Revised.\n\t(allocateDirect): Removed.\n\t(order): Removed.\n\t* java/nio/ShortBuffer.java: Reformatted, much documentation rewritten.\n\t(ShortBuffer): Revised.\n\t(allocateDirect): Removed.\n\t(order): Removed.\n\t* gnu/java/nio/natByteBufferImpl.cc: Removed.\n\t* gnu/java/nio/natCharBufferImpl.cc: Removed.\n\t* Makefile.am\n\t(ordinary_java_source_files): Added the following files:\n\tgnu/java/nio/CharViewBufferImpl.java,\n\tgnu/java/nio/DoubleViewBufferImpl.java,\n\tgnu/java/nio/FloatViewBufferImpl.java,\n\tgnu/java/nio/IntViewBufferImpl.java,\n\tgnu/java/nio/LongViewBufferImpl.java,\n\tgnu/java/nio/ShortViewBufferImpl.java\n\t(nat_source_files): Removed the following files:\n\tgnu/java/nio/natByteBufferImpl.cc,\n\tgnu/java/nio/natCharBufferImpl.cc\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r66733", "tree": {"sha": "eba2e2a8271971b25fa39af84cbebe056dd27e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eba2e2a8271971b25fa39af84cbebe056dd27e91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36d4669b735c0e6f665e9a83bdd0848e23fc6662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d4669b735c0e6f665e9a83bdd0848e23fc6662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d4669b735c0e6f665e9a83bdd0848e23fc6662", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d4669b735c0e6f665e9a83bdd0848e23fc6662/comments", "author": null, "committer": null, "parents": [{"sha": "d3e0dffb76fd85d777f5c5de71f47816121bc5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e0dffb76fd85d777f5c5de71f47816121bc5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e0dffb76fd85d777f5c5de71f47816121bc5e3"}], "stats": {"total": 2928, "additions": 2004, "deletions": 924}, "files": [{"sha": "0aed87438e7a1ddaa42801df69e4307fc97927f1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,3 +1,102 @@\n+2003-05-12  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/nio/ByteBufferImpl.java: Reformatted.\n+\t(nio_get_*): Removed.\n+\t(nio_put_*): Removed.\n+\t(as*Buffer): Implemented.\n+\t(compact): Implemented.\n+\t(get): Documentation added.\n+\t(put): Documentation added.\n+\t(get*): Newly implemented.\n+\t(put*): Newly implemented.\n+\t* gnu/java/nio/CharBufferImpl.java: Reformatted.\n+\t(CharBufferImpl): Revised.\n+\t(slice): New implementation.\n+\t(duplicate): New implementation.\n+\t(compact): New implementation.\n+\t(asReadOnlyBuffer): New implementation.\n+\t(get): Documentation revised.\n+\t(order): Return native byte order.\n+\t* gnu/java/nio/DirectByteBufferImpl.java\n+\t(allocateDirect): objects can be null not 0.\n+\t* gnu/java/nio/DoubleBufferImpl.java: Reformatted.\n+\t(DoubleBufferImpl): Revised.\n+\t(slice): New implementation.\n+\t(duplicate): New implementation.\n+\t(compact): New implementation.\n+\t(asReadOnlyBuffer): New implementation.\n+\t(get): Documentation revised.\n+\t(order): Return native byte order.\n+\t* gnu/java/nio/FloatBufferImpl.java: Reformatted.\n+\t(FloatBufferImpl): Revised.\n+\t(slice): New implementation.\n+\t(duplicate): New implementation.\n+\t(compact): New implementation.\n+\t(asReadOnlyBuffer): New implementation.\n+\t(get): Documentation revised.\n+\t(order): Return native byte order.\n+\t* gnu/java/nio/IntBufferImpl.java: Reformatted.\n+\t(IntBufferImpl): Revised.\n+\t(slice): New implementation.\n+\t(duplicate): New implementation.\n+\t(compact): New implementation.\n+\t(asReadOnlyBuffer): New implementation.\n+\t(get): Documentation revised.\n+\t(order): Return native byte order.\n+\t* gnu/java/nio/LongBufferImpl.java: Reformatted.\n+\t(LongBufferImpl): Revised.\n+\t(slice): New implementation.\n+\t(duplicate): New implementation.\n+\t(compact): New implementation.\n+\t(asReadOnlyBuffer): New implementation.\n+\t(get): Documentation revised.\n+\t(order): Return native byte order.\n+\t* gnu/java/nio/ShortBufferImpl.java: Reformatted.\n+\t(ShortBufferImpl): Revised.\n+\t(slice): New implementation.\n+\t(duplicate): New implementation.\n+\t(compact): New implementation.\n+\t(asReadOnlyBuffer): New implementation.\n+\t(get): Documentation revised.\n+\t(order): Return native byte order.\n+\t* java/nio/CharBuffer.java: Reformatted, much documentation rewritten.\n+\t(CharBuffer): Revised.\n+\t(order): Removed.\n+\t* java/nio/DoubleBuffer.java: Reformatted, much documentation rewritten.\n+\t(DoubleBuffer): Revised.\n+\t(allocateDirect): Removed.\n+\t(order): Removed.\n+\t* java/nio/FloatBuffer.java: Reformatted, much documentation rewritten.\n+\t(FloatBuffer): Revised.\n+\t(allocateDirect): Removed.\n+\t(order): Removed.\n+\t* java/nio/IntBuffer.java: Reformatted, much documentation rewritten.\n+\t(IntBuffer): Revised.\n+\t(allocateDirect): Removed.\n+\t(order): Removed.\n+\t* java/nio/LongBuffer.java: Reformatted, much documentation rewritten.\n+\t(LongBuffer): Revised.\n+\t(allocateDirect): Removed.\n+\t(order): Removed.\n+\t* java/nio/ShortBuffer.java: Reformatted, much documentation rewritten.\n+\t(ShortBuffer): Revised.\n+\t(allocateDirect): Removed.\n+\t(order): Removed.\n+\t* gnu/java/nio/natByteBufferImpl.cc: Removed.\n+\t* gnu/java/nio/natCharBufferImpl.cc: Removed.\n+\t* Makefile.am\n+\t(ordinary_java_source_files): Added the following files:\n+\tgnu/java/nio/CharViewBufferImpl.java,\n+\tgnu/java/nio/DoubleViewBufferImpl.java,\n+\tgnu/java/nio/FloatViewBufferImpl.java,\n+\tgnu/java/nio/IntViewBufferImpl.java,\n+\tgnu/java/nio/LongViewBufferImpl.java,\n+\tgnu/java/nio/ShortViewBufferImpl.java\n+\t(nat_source_files): Removed the following files:\n+\tgnu/java/nio/natByteBufferImpl.cc,\n+\tgnu/java/nio/natCharBufferImpl.cc\n+\t* Makefile.in: Regenerated.\n+\n 2003-05-12  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/nio/CharViewBufferImpl.java,"}, {"sha": "e745528242a966edd72fbfc74779c630ba42410f", "filename": "libjava/Makefile.am", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -2098,19 +2098,25 @@ gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n gnu/java/nio/ByteBufferImpl.java \\\n gnu/java/nio/CharBufferImpl.java \\\n+gnu/java/nio/CharViewBufferImpl.java \\\n gnu/java/nio/DatagramChannelImpl.java \\\n gnu/java/nio/DoubleBufferImpl.java \\\n+gnu/java/nio/DoubleViewBufferImpl.java \\\n gnu/java/nio/FileChannelImpl.java \\\n gnu/java/nio/FloatBufferImpl.java \\\n+gnu/java/nio/FloatViewBufferImpl.java \\\n gnu/java/nio/IntBufferImpl.java \\\n+gnu/java/nio/IntViewBufferImpl.java \\\n gnu/java/nio/LongBufferImpl.java \\\n+gnu/java/nio/LongViewBufferImpl.java \\\n gnu/java/nio/MappedByteFileBuffer.java \\\n gnu/java/nio/PipeImpl.java \\\n gnu/java/nio/SelectionKeyImpl.java \\\n gnu/java/nio/SelectorImpl.java \\\n gnu/java/nio/SelectorProviderImpl.java \\\n gnu/java/nio/ServerSocketChannelImpl.java \\\n gnu/java/nio/ShortBufferImpl.java \\\n+gnu/java/nio/ShortViewBufferImpl.java \\\n gnu/java/nio/SocketChannelImpl.java \\\n gnu/java/nio/charset/ISO_8859_1.java \\\n gnu/java/nio/charset/Provider.java \\\n@@ -2555,8 +2561,6 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n-gnu/java/nio/natByteBufferImpl.cc \\\n-gnu/java/nio/natCharBufferImpl.cc \\\n gnu/java/nio/natFileChannelImpl.cc \\\n gnu/java/nio/natMappedByteFileBuffer.cc \\\n gnu/java/nio/natSelectorImpl.cc \\"}, {"sha": "6aa88cc8cd4f432846015bf15c39032c3c3ed1a3", "filename": "libjava/Makefile.in", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1860,19 +1860,25 @@ gnu/java/locale/LocaleInformation_zh_TW.java \\\n gnu/java/math/MPN.java \\\n gnu/java/nio/ByteBufferImpl.java \\\n gnu/java/nio/CharBufferImpl.java \\\n+gnu/java/nio/CharViewBufferImpl.java \\\n gnu/java/nio/DatagramChannelImpl.java \\\n gnu/java/nio/DoubleBufferImpl.java \\\n+gnu/java/nio/DoubleViewBufferImpl.java \\\n gnu/java/nio/FileChannelImpl.java \\\n gnu/java/nio/FloatBufferImpl.java \\\n+gnu/java/nio/FloatViewBufferImpl.java \\\n gnu/java/nio/IntBufferImpl.java \\\n+gnu/java/nio/IntViewBufferImpl.java \\\n gnu/java/nio/LongBufferImpl.java \\\n+gnu/java/nio/LongViewBufferImpl.java \\\n gnu/java/nio/MappedByteFileBuffer.java \\\n gnu/java/nio/PipeImpl.java \\\n gnu/java/nio/SelectionKeyImpl.java \\\n gnu/java/nio/SelectorImpl.java \\\n gnu/java/nio/SelectorProviderImpl.java \\\n gnu/java/nio/ServerSocketChannelImpl.java \\\n gnu/java/nio/ShortBufferImpl.java \\\n+gnu/java/nio/ShortViewBufferImpl.java \\\n gnu/java/nio/SocketChannelImpl.java \\\n gnu/java/nio/charset/ISO_8859_1.java \\\n gnu/java/nio/charset/Provider.java \\\n@@ -2316,8 +2322,6 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n-gnu/java/nio/natByteBufferImpl.cc \\\n-gnu/java/nio/natCharBufferImpl.cc \\\n gnu/java/nio/natFileChannelImpl.cc \\\n gnu/java/nio/natMappedByteFileBuffer.cc \\\n gnu/java/nio/natSelectorImpl.cc \\\n@@ -2492,8 +2496,7 @@ gnu/gcj/io/shs.lo gnu/gcj/protocol/core/natCoreInputStream.lo \\\n gnu/gcj/runtime/natFinalizerThread.lo gnu/gcj/runtime/natFirstThread.lo \\\n gnu/gcj/runtime/natNameFinder.lo gnu/gcj/runtime/natSharedLibLoader.lo \\\n gnu/gcj/runtime/natStackTrace.lo gnu/gcj/runtime/natStringBuffer.lo \\\n-gnu/gcj/runtime/natVMClassLoader.lo gnu/java/nio/natByteBufferImpl.lo \\\n-gnu/java/nio/natCharBufferImpl.lo gnu/java/nio/natFileChannelImpl.lo \\\n+gnu/gcj/runtime/natVMClassLoader.lo gnu/java/nio/natFileChannelImpl.lo \\\n gnu/java/nio/natMappedByteFileBuffer.lo gnu/java/nio/natSelectorImpl.lo \\\n gnu/java/nio/natSocketChannelImpl.lo java/io/natFile.lo \\\n java/io/natFileDescriptor.lo java/io/natObjectInputStream.lo \\\n@@ -2958,16 +2961,23 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_TW.P \\\n .deps/gnu/java/math/MPN.P .deps/gnu/java/nio/ByteBufferImpl.P \\\n .deps/gnu/java/nio/CharBufferImpl.P \\\n+.deps/gnu/java/nio/CharViewBufferImpl.P \\\n .deps/gnu/java/nio/DatagramChannelImpl.P \\\n .deps/gnu/java/nio/DoubleBufferImpl.P \\\n+.deps/gnu/java/nio/DoubleViewBufferImpl.P \\\n .deps/gnu/java/nio/FileChannelImpl.P \\\n-.deps/gnu/java/nio/FloatBufferImpl.P .deps/gnu/java/nio/IntBufferImpl.P \\\n+.deps/gnu/java/nio/FloatBufferImpl.P \\\n+.deps/gnu/java/nio/FloatViewBufferImpl.P \\\n+.deps/gnu/java/nio/IntBufferImpl.P \\\n+.deps/gnu/java/nio/IntViewBufferImpl.P \\\n .deps/gnu/java/nio/LongBufferImpl.P \\\n+.deps/gnu/java/nio/LongViewBufferImpl.P \\\n .deps/gnu/java/nio/MappedByteFileBuffer.P .deps/gnu/java/nio/PipeImpl.P \\\n .deps/gnu/java/nio/SelectionKeyImpl.P .deps/gnu/java/nio/SelectorImpl.P \\\n .deps/gnu/java/nio/SelectorProviderImpl.P \\\n .deps/gnu/java/nio/ServerSocketChannelImpl.P \\\n .deps/gnu/java/nio/ShortBufferImpl.P \\\n+.deps/gnu/java/nio/ShortViewBufferImpl.P \\\n .deps/gnu/java/nio/SocketChannelImpl.P \\\n .deps/gnu/java/nio/charset/ISO_8859_1.P \\\n .deps/gnu/java/nio/charset/Provider.P \\\n@@ -2978,8 +2988,6 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/nio/charset/UTF_16Encoder.P \\\n .deps/gnu/java/nio/charset/UTF_16LE.P \\\n .deps/gnu/java/nio/charset/UTF_8.P \\\n-.deps/gnu/java/nio/natByteBufferImpl.P \\\n-.deps/gnu/java/nio/natCharBufferImpl.P \\\n .deps/gnu/java/nio/natFileChannelImpl.P \\\n .deps/gnu/java/nio/natMappedByteFileBuffer.P \\\n .deps/gnu/java/nio/natSelectorImpl.P \\"}, {"sha": "7b7f72e5fb077ecbde6f833a2c5f83ede6428e54", "filename": "libjava/gnu/java/nio/ByteBufferImpl.java", "status": "modified", "additions": 201, "deletions": 142, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* ByteBufferImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n@@ -66,7 +67,7 @@ public ByteBufferImpl (byte[] array, int offset, int length)\n     this.backing_buffer = array;\n     readOnly = false;\n   }\n-\n+  \n   public ByteBufferImpl (ByteBufferImpl copy)\n   {\n     super (copy.capacity (), copy.limit (), copy.position (), 0);\n@@ -79,311 +80,369 @@ void inc_pos (int toAdd)\n     position (position () + toAdd);\n   }\n \n-  private static native char nio_get_Char (ByteBufferImpl b, int index, int limit);\n-\n-  private static native void nio_put_Char (ByteBufferImpl b, int index, int limit, char value);\n-\n   public CharBuffer asCharBuffer ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return new CharViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n   }\n \n-  private static native short nio_get_Short (ByteBufferImpl b, int index, int limit);\n-  \n-  private static native void nio_put_Short (ByteBufferImpl b, int index, int limit, short value);\n-  \n   public ShortBuffer asShortBuffer ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return new ShortViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n   }\n \n-  private static native int nio_get_Int (ByteBufferImpl b, int index, int limit);\n-  \n-  private static native void nio_put_Int (ByteBufferImpl b, int index, int limit, int value);\n-  \n   public IntBuffer asIntBuffer ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return new IntViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n   }\n \n-  private static native long nio_get_Long (ByteBufferImpl b, int index, int limit);\n-  \n-  private static native void nio_put_Long (ByteBufferImpl b, int index, int limit, long value);\n-  \n   public LongBuffer asLongBuffer ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return new LongViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n   }\n \n-  private static native float nio_get_Float (ByteBufferImpl b, int index, int limit);\n-  \n-  private static native void nio_put_Float (ByteBufferImpl b, int index, int limit, float value);\n-  \n   public FloatBuffer asFloatBuffer ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return new FloatViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n   }\n \n-  private static native double nio_get_Double (ByteBufferImpl b, int index, int limit);\n-  \n-  private static native void nio_put_Double (ByteBufferImpl b, int index, int limit, double value);\n-  \n   public DoubleBuffer asDoubleBuffer ()\n   {\n-    throw new Error (\"Not implemented\");\n+    return new DoubleViewBufferImpl (this, position (), remaining(), remaining (), 0, -1, isReadOnly ());\n   }\n \n-  public boolean isReadOnly()\n+  public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n   \n-  public ByteBuffer slice()\n+  public ByteBuffer slice ()\n   {\n-    return new ByteBufferImpl(this);\n+    return new ByteBufferImpl (this);\n   }\n-\n-  public ByteBuffer duplicate()\n+  \n+  public ByteBuffer duplicate ()\n   {\n-    return new ByteBufferImpl(this);\n+    return new ByteBufferImpl (this);\n   }\n-\n-  public ByteBuffer asReadOnlyBuffer()\n+  \n+  public ByteBuffer asReadOnlyBuffer ()\n   {\n-    ByteBufferImpl a = new ByteBufferImpl(this);\n+    ByteBufferImpl a = new ByteBufferImpl (this);\n     a.readOnly = true;\n     return a;\n   }\n-\n-  public ByteBuffer compact()\n+  \n+  public ByteBuffer compact ()\n   {\n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n     return this;\n   }\n-\n-  public boolean isDirect()\n+  \n+  public boolean isDirect ()\n   {\n     return false;\n   }\n-  \n-  final public byte get()\n+\n+  /**\n+   * Relative get method. Reads the next <code>byte</code> from the buffer.\n+   */\n+  final public byte get ()\n   {\n-    byte e = backing_buffer[position()];\n-    position(position()+1);\n-    return e;\n+    byte result = backing_buffer [position ()];\n+    position (position () + 1);\n+    return result;\n   }\n   \n-  final public ByteBuffer put(byte b)\n+  /**\n+   * Relative put method. Writes <code>value</code> to the next position\n+   * in the buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public ByteBuffer put (byte value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[position()] = b;\n-    position(position()+1);\n+\t  \t    \n+    backing_buffer [position ()] = value;\n+    position (position () + 1);\n     return this;\n   }\n   \n-  final public byte get(int index)\n+  /**\n+   * Absolute get method. Reads the <code>byte</code> at position\n+   * <code>index</code>.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  final public byte get (int index)\n   {\n-    return backing_buffer[index];\n+    return backing_buffer [index];\n   }\n   \n-  final public ByteBuffer put(int index, byte b)\n+  /**\n+   * Absolute put method. Writes <code>value</value> to position\n+   * <code>index</code> in the buffer.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public ByteBuffer put (int index, byte value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[index] = b;\n+    \t    \n+    backing_buffer [index] = value;\n     return this;\n   }\n   \n   final public char getChar ()\n   {\n-    char a = nio_get_Char (this, position (), limit ());\n-    inc_pos (2);\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (char) (((get () & 0xff) << 8) + (get () & 0xff));\n   }\n   \n   final public ByteBuffer putChar (char value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Char (this, position (), limit (), value);\n-    inc_pos (2);\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00) >> 8));\n+    put ((byte) (((int) value) & 0x00ff));\n     return this;\n   }\n   \n   final public char getChar (int index)\n   {\n-    char a = nio_get_Char (this, index, limit ());\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (char) (((get (index) & 0xff) << 8) + (get (index + 1) & 0xff));\n   }\n   \n   final public ByteBuffer putChar (int index, char value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Char (this, index, limit (), value);\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n+    put (index + 1, (byte) (((int) value) & 0x00ff));\n     return this;\n   }\n \n   final public short getShort ()\n   {\n-    short a = nio_get_Short (this, position (), limit ());\n-    inc_pos (2);\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (short) (((get () & 0xff) << 8) + (get () & 0xff));\n   }\n   \n   final public ByteBuffer putShort (short value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Short (this, position (), limit (), value);\n-    inc_pos (2);\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00) >> 8));\n+    put ((byte) (((int) value) & 0x00ff));\n     return this;\n   }\n   \n   final public short getShort (int index)\n   {\n-    short a = nio_get_Short (this, index, limit ());\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (short) (((get (index) & 0xff) << 8) + (get (index + 1) & 0xff));\n   }\n   \n   final public ByteBuffer putShort (int index, short value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Short (this, index, limit (), value);\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n+    put (index + 1, (byte) (((int) value) & 0x00ff));\n     return this;\n   }\n \n   final public int getInt ()\n   {\n-    int a = nio_get_Int (this, position (), limit ());\n-    inc_pos (4);\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (int) (((get () & 0xff) << 24)\n+                  + (get () & 0xff) << 16\n+                  + (get () & 0xff) << 8\n+                  + (get () & 0xff));\n   }\n   \n   final public ByteBuffer putInt (int value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Int (this, position (), limit (), value);\n-    inc_pos (4);\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x000000ff));\n     return this;\n   }\n   \n   final public int getInt (int index)\n   {\n-    int a = nio_get_Int (this, index, limit ());\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (int) (((get (index) & 0xff) << 24)\n+                  + (get (index + 1) & 0xff) << 16\n+                  + (get (index + 2) & 0xff) << 8\n+                  + (get (index + 3) & 0xff));\n   }\n   \n   final public ByteBuffer putInt (int index, int value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Int(this, index, limit (), value);\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put (index + 3, (byte) (((int) value) & 0x000000ff));\n     return this;\n   }\n \n   final public long getLong ()\n   {\n-    long a = nio_get_Long (this, position (), limit ());\n-    inc_pos (8);\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (long) (((get () & 0xff) << 56)\n+                   + (get () & 0xff) << 48\n+                   + (get () & 0xff) << 40\n+                   + (get () & 0xff) << 32\n+                   + (get () & 0xff) << 24\n+                   + (get () & 0xff) << 16\n+                   + (get () & 0xff) << 8\n+                   + (get () & 0xff));\n   }\n   \n   final public ByteBuffer putLong (long value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Long (this, position (), limit (), value);\n-    inc_pos (8);\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put ((byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put ((byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put ((byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put ((byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x00000000000000ff));\n     return this;\n   }\n   \n   final public long getLong (int index)\n   {\n-    long a = nio_get_Long (this, index, limit ());\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (long) (((get (index) & 0xff) << 56)\n+                   + (get (index + 1) & 0xff) << 48\n+                   + (get (index + 2) & 0xff) << 40\n+                   + (get (index + 3) & 0xff) << 32\n+                   + (get (index + 4) & 0xff) << 24\n+                   + (get (index + 5) & 0xff) << 16\n+                   + (get (index + 6) & 0xff) << 8\n+                   + (get (index + 7) & 0xff));\n   }\n   \n   final public ByteBuffer putLong (int index, long value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Long (this, index, limit (), value);\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put (index + 3, (byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put (index + 4, (byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put (index + 5, (byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put (index + 6, (byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put (index + 7, (byte) (((int) value) & 0x00000000000000ff));\n     return this;\n   }\n \n   final public float getFloat ()\n   {\n-    float a = nio_get_Float (this, position (), limit ());\n-    inc_pos (4);\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (float) (((get () & 0xff) << 24)\n+                    + (get () & 0xff) << 16\n+                    + (get () & 0xff) << 8\n+                    + (get () & 0xff));\n   }\n   \n   final public ByteBuffer putFloat (float value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Float (this, position (), limit (), value);\n-    inc_pos (4);\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x000000ff));\n     return this;\n   }\n   \n   final public float getFloat (int index)\n   {\n-    float a = nio_get_Float (this, index, limit ());\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (float) (((get (index) & 0xff) << 24)\n+                    + (get (index + 1) & 0xff) << 16\n+                    + (get (index + 2) & 0xff) << 8\n+                    + (get (index + 3) & 0xff));\n   }\n \n   final public ByteBuffer putFloat (int index, float value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Float (this, index, limit(), value);\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put (index + 3, (byte) (((int) value) & 0x000000ff));\n     return this;\n   }\n \n   final public double getDouble ()\n   {\n-    double a = nio_get_Double (this, position (), limit ());\n-    inc_pos (8);\n-    return a;\n+    // FIXME: this handles big endian only\n+    return (double) (((get () & 0xff) << 56)\n+                     + (get () & 0xff) << 48\n+                     + (get () & 0xff) << 40\n+                     + (get () & 0xff) << 32\n+                     + (get () & 0xff) << 24\n+                     + (get () & 0xff) << 16\n+                     + (get () & 0xff) << 8\n+                     + (get () & 0xff));\n   }\n \n   final public ByteBuffer putDouble (double value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Double (this, position(), limit (), value);\n-    inc_pos (8);\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put ((byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put ((byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put ((byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put ((byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x00000000000000ff));\n     return this;\n   }\n   \n   final public double getDouble (int index)\n   {\n-    return nio_get_Double (this, index, limit ());\n+    // FIXME: this handles big endian only\n+    return (double) (((get (index) & 0xff) << 56)\n+                     + (get (index + 1) & 0xff) << 48\n+                     + (get (index + 2) & 0xff) << 40\n+                     + (get (index + 3) & 0xff) << 32\n+                     + (get (index + 4) & 0xff) << 24\n+                     + (get (index + 5) & 0xff) << 16\n+                     + (get (index + 6) & 0xff) << 8\n+                     + (get (index + 7) & 0xff));\n   }\n   \n   final public ByteBuffer putDouble (int index, double value)\n   {\n-    if (readOnly)\n-      throw new ReadOnlyBufferException ();\n-    \n-    nio_put_Double (this, index, limit (), value);\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put (index + 3, (byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put (index + 4, (byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put (index + 5, (byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put (index + 6, (byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put (index + 7, (byte) (((int) value) & 0x00000000000000ff));\n     return this;\n   }\n }"}, {"sha": "fcf0e15e4745a05a28c01a980f7c5de42dade48f", "filename": "libjava/gnu/java/nio/CharBufferImpl.java", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* CharBufferImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n@@ -49,18 +50,15 @@ public final class CharBufferImpl extends CharBuffer\n {\n   private boolean readOnly;\n \n-  public CharBufferImpl(int cap, int off, int lim)\n+  CharBufferImpl (int capacity)\n   {\n-    super (cap, lim, off, 0);\n-    this.backing_buffer = new char [cap];\n-    readOnly = false;\n+    this (new char [capacity], 0, capacity, capacity, 0, -1, false);\n   }\n   \n-  public CharBufferImpl(char[] array, int offset, int length)\n+  CharBufferImpl (char[] buffer, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n   {\n-    super (array.length, length, offset, 0);\n-    this.backing_buffer = array;\n-    readOnly = false;\n+    super (buffer, offset, capacity, limit, position, mark);\n+    this.readOnly = readOnly;\n   }\n   \n   public CharBufferImpl (CharBufferImpl copy)\n@@ -70,37 +68,41 @@ public CharBufferImpl (CharBufferImpl copy)\n     readOnly = copy.isReadOnly ();\n   }\n   \n-  private static native char[] nio_cast (byte[] copy);\n-\n-  public boolean isReadOnly()\n+  public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n   \n-  public CharBuffer slice()\n+  public CharBuffer slice ()\n   {\n-    return new CharBufferImpl (backing_buffer, arrayOffset () + position (),\n-                               remaining ());\n+    return new CharBufferImpl (backing_buffer, array_offset + position (), remaining (), remaining (), 0, -1, isReadOnly ());\n   }\n   \n-  public CharBuffer duplicate()\n+  public CharBuffer duplicate ()\n   {\n-    return new CharBufferImpl(this);\n+    return new CharBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, isReadOnly ());\n   }\n   \n-  public CharBuffer asReadOnlyBuffer()\n+  public CharBuffer asReadOnlyBuffer ()\n   {\n-    CharBufferImpl result = new CharBufferImpl (this);\n-    result.readOnly = true;\n-    return result;\n+    return new CharBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, true);\n   }\n   \n-  public CharBuffer compact()\n+  public CharBuffer compact ()\n   {\n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n     return this;\n   }\n   \n-  public boolean isDirect()\n+  public boolean isDirect ()\n   {\n     return false;\n   }\n@@ -113,20 +115,17 @@ final public CharSequence subSequence (int start, int end)\n         || end > length ())\n       throw new IndexOutOfBoundsException ();\n \n-    // No support for direct buffers yet.\n-    // assert array () != null;\n-    return new CharBufferImpl (array (), position () + start,\n-                               position () + end);\n+    return new CharBufferImpl (backing_buffer, array_offset, capacity (), position () + end, position () + start, -1, isReadOnly ());\n   }\n   \n   /**\n-   * Relative get method. Reads the next character from the buffer.\n+   * Relative get method. Reads the next <code>char</code> from the buffer.\n    */\n-  final public char get()\n+  final public char get ()\n   {\n-    char e = backing_buffer[position()];\n-    position(position()+1);\n-    return e;\n+    char result = backing_buffer [position ()];\n+    position (position () + 1);\n+    return result;\n   }\n   \n   /**\n@@ -135,29 +134,30 @@ final public char get()\n    * \n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n-  final public CharBuffer put(char b)\n+  final public CharBuffer put (char value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[position()] = b;\n-    position(position()+1);\n+\t  \t    \n+    backing_buffer [position ()] = value;\n+    position (position () + 1);\n     return this;\n   }\n-\n+  \n   /**\n-   * Absolute get method. Reads the character at position <code>index</code>.\n+   * Absolute get method. Reads the <code>char</code> at position\n+   * <code>index</code>.\n    *\n    * @exception IndexOutOfBoundsException If index is negative or not smaller\n    * than the buffer's limit.\n    */\n-  final public char get(int index)\n+  final public char get (int index)\n   {\n     if (index < 0\n         || index >= limit ())\n       throw new IndexOutOfBoundsException ();\n     \n-    return backing_buffer[index];\n+    return backing_buffer [index];\n   }\n   \n   /**\n@@ -168,22 +168,21 @@ final public char get(int index)\n    * than the buffer's limit.\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n-  final public CharBuffer put(int index, char b)\n+  final public CharBuffer put (int index, char value)\n   {\n     if (index < 0\n         || index >= limit ())\n       throw new IndexOutOfBoundsException ();\n     \n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[index] = b;\n+    \t    \n+    backing_buffer [index] = value;\n     return this;\n   }\n-\n-\n-  public final ByteOrder order()\n+  \n+  final public ByteOrder order ()\n   {\n-    return ByteOrder.BIG_ENDIAN;\n+    return ByteOrder.nativeOrder ();\n   }\n }"}, {"sha": "47b76bb8142b3f70afd9453fa5b7bf19534a0975", "filename": "libjava/gnu/java/nio/DirectByteBufferImpl.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDirectByteBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -75,7 +75,7 @@ public static ByteBuffer allocateDirect (int capacity)\n   {\n     RawData address = allocateImpl (capacity);\n \n-    if (address == 0)\n+    if (address == null)\n       throw new InternalError (\"Not enough memory to create direct buffer\");\n     \n     return new DirectByteBufferImpl (address, 0, capacity, capacity, 0, -1, false);"}, {"sha": "dc809598238a1b7fb356aef0d63645f880f6992c", "filename": "libjava/gnu/java/nio/DoubleBufferImpl.java", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* DoubleBufferImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n@@ -48,93 +49,114 @@\n public final class DoubleBufferImpl extends DoubleBuffer\n {\n   private boolean readOnly;\n-  \n-  public DoubleBufferImpl(int cap, int off, int lim)\n+\n+  DoubleBufferImpl (int capacity)\n   {\n-    super (cap, lim, off, 0);\n-    this.backing_buffer = new double[cap];\n-    readOnly = false;\n+    this (new double [capacity], 0, capacity, capacity, 0, -1, false);\n   }\n   \n-  public DoubleBufferImpl(double[] array, int offset, int length)\n+  DoubleBufferImpl (double[] buffer, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n   {\n-    super (array.length, length, offset, 0);\n-    this.backing_buffer = array;\n-    readOnly = false;\n-  }\n-\n-  public DoubleBufferImpl(DoubleBufferImpl copy)\n-  {\n-    super (copy.capacity (), copy.limit (), copy.position (), 0);\n-    backing_buffer = copy.backing_buffer;\n-    readOnly = copy.isReadOnly ();\n+    super (buffer, offset, capacity, limit, position, mark);\n+    this.readOnly = readOnly;\n   }\n   \n   public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n-\n+  \n   public DoubleBuffer slice ()\n   {\n-    return new DoubleBufferImpl (this);\n+    return new DoubleBufferImpl (backing_buffer, array_offset + position (), remaining (), remaining (), 0, -1, isReadOnly ());\n   }\n-\n-  public DoubleBuffer duplicate()\n+  \n+  public DoubleBuffer duplicate ()\n   {\n-    return new DoubleBufferImpl(this);\n+    return new DoubleBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, isReadOnly ());\n   }\n-\n-  public DoubleBuffer asReadOnlyBuffer()\n+  \n+  public DoubleBuffer asReadOnlyBuffer ()\n   {\n-    DoubleBufferImpl result = new DoubleBufferImpl (this);\n-    result.readOnly = true;\n-    return result;\n+    return new DoubleBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, true);\n   }\n-\n-  public DoubleBuffer compact()\n+  \n+  public DoubleBuffer compact ()\n   {\n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n     return this;\n   }\n-\n-  public boolean isDirect()\n+  \n+  public boolean isDirect ()\n   {\n     return false;\n   }\n \n-  final public double get()\n+  /**\n+   * Relative get method. Reads the next <code>double</code> from the buffer.\n+   */\n+  final public double get ()\n   {\n-    double e = backing_buffer[position()];\n-    position(position()+1);\n-    return e;\n+    double result = backing_buffer [position ()];\n+    position (position () + 1);\n+    return result;\n   }\n-\n-  final public DoubleBuffer put(double b)\n+  \n+  /**\n+   * Relative put method. Writes <code>value</code> to the next position\n+   * in the buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public DoubleBuffer put (double value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[position()] = b;\n-    position(position()+1);\n+\t  \t    \n+    backing_buffer [position ()] = value;\n+    position (position () + 1);\n     return this;\n   }\n-\n-  final public double get(int index)\n+  \n+  /**\n+   * Absolute get method. Reads the <code>double</code> at position\n+   * <code>index</code>.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  final public double get (int index)\n   {\n-    return backing_buffer[index];\n+    return backing_buffer [index];\n   }\n-\n-  final public DoubleBuffer put(int index, double b)\n+  \n+  /**\n+   * Absolute put method. Writes <code>value</value> to position\n+   * <code>index</code> in the buffer.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public DoubleBuffer put (int index, double value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[index] = b;\n+    \t    \n+    backing_buffer [index] = value;\n     return this;\n   }\n   \n   final public ByteOrder order ()\n   {\n-    return ByteOrder.BIG_ENDIAN;\n+    return ByteOrder.nativeOrder ();\n   }\n }"}, {"sha": "69acecf52fed1b041fcdd6b134a5a3f8da9d54fc", "filename": "libjava/gnu/java/nio/FloatBufferImpl.java", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* FloatBufferImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n@@ -48,93 +49,114 @@\n public final class FloatBufferImpl extends FloatBuffer\n {\n   private boolean readOnly;\n-  \n-  public FloatBufferImpl(int cap, int off, int lim)\n-  {\n-    super (cap, lim, off, 0);\n-    this.backing_buffer = new float [cap];\n-    readOnly = false;\n-  }\n-  \n-  public FloatBufferImpl(float[] array, int offset, int length)\n+\n+  FloatBufferImpl (int capacity)\n   {\n-    super (array.length, length, offset, 0);\n-    this.backing_buffer = array;\n-    readOnly = false;\n+    this (new float [capacity], 0, capacity, capacity, 0, -1, false);\n   }\n   \n-  public FloatBufferImpl(FloatBufferImpl copy)\n+  FloatBufferImpl (float[] buffer, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n   {\n-    super (copy.capacity (), copy.limit (), copy.position (), 0);\n-    backing_buffer = copy.backing_buffer;\n-    readOnly = copy.isReadOnly ();\n+    super (buffer, offset, capacity, limit, position, mark);\n+    this.readOnly = readOnly;\n   }\n   \n   public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n   \n-  public FloatBuffer slice()\n+  public FloatBuffer slice ()\n   {\n-    return new FloatBufferImpl (this);\n+    return new FloatBufferImpl (backing_buffer, array_offset + position (), remaining (), remaining (), 0, -1, isReadOnly ());\n   }\n   \n-  public FloatBuffer duplicate()\n+  public FloatBuffer duplicate ()\n   {\n-    return new FloatBufferImpl(this);\n+    return new FloatBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, isReadOnly ());\n   }\n   \n-  public FloatBuffer asReadOnlyBuffer()\n+  public FloatBuffer asReadOnlyBuffer ()\n   {\n-    FloatBufferImpl result = new FloatBufferImpl (this);\n-    result.readOnly = true;\n-    return result;\n+    return new FloatBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, true);\n   }\n   \n-  public FloatBuffer compact()\n+  public FloatBuffer compact ()\n   {\n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n     return this;\n   }\n   \n-  public boolean isDirect()\n+  public boolean isDirect ()\n   {\n     return false;\n   }\n-  \n-  final public float get()\n+\n+  /**\n+   * Relative get method. Reads the next <code>float</code> from the buffer.\n+   */\n+  final public float get ()\n   {\n-    float e = backing_buffer[position()];\n-    position(position()+1);\n-    return e;\n+    float result = backing_buffer [position ()];\n+    position (position () + 1);\n+    return result;\n   }\n   \n-  final public FloatBuffer put(float b)\n+  /**\n+   * Relative put method. Writes <code>value</code> to the next position\n+   * in the buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public FloatBuffer put (float value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[position()] = b;\n-    position(position()+1);\n+\t  \t    \n+    backing_buffer [position ()] = value;\n+    position (position () + 1);\n     return this;\n   }\n   \n-  final public float get(int index)\n+  /**\n+   * Absolute get method. Reads the <code>float</code> at position\n+   * <code>index</code>.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  final public float get (int index)\n   {\n-    return backing_buffer[index];\n+    return backing_buffer [index];\n   }\n   \n-  final public FloatBuffer put(int index, float b)\n+  /**\n+   * Absolute put method. Writes <code>value</value> to position\n+   * <code>index</code> in the buffer.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public FloatBuffer put (int index, float value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[index] = b;\n+    \t    \n+    backing_buffer [index] = value;\n     return this;\n   }\n   \n   final public ByteOrder order ()\n   {\n-    return ByteOrder.BIG_ENDIAN;\n+    return ByteOrder.nativeOrder ();\n   }\n }"}, {"sha": "573e5e0372b44ed3637c0b2368cecee2ac13fe33", "filename": "libjava/gnu/java/nio/IntBufferImpl.java", "status": "modified", "additions": 73, "deletions": 51, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* IntBufferImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n@@ -48,93 +49,114 @@\n public final class IntBufferImpl extends IntBuffer\n {\n   private boolean readOnly;\n-  \n-  public IntBufferImpl(int cap, int off, int lim)\n-  {\n-    super (cap, lim, off, 0);\n-    this.backing_buffer = new int[cap];\n-    readOnly = false;\n-  }\n \n-  public IntBufferImpl(int[] array, int offset, int length)\n+  IntBufferImpl (int capacity)\n   {\n-    super (array.length, length, offset, 0);\n-    this.backing_buffer = array;\n-    readOnly = false;\n+    this (new int [capacity], 0, capacity, capacity, 0, -1, false);\n   }\n-\n-  public IntBufferImpl(IntBufferImpl copy)\n+  \n+  IntBufferImpl (int[] buffer, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n   {\n-    super (copy.capacity (), copy.limit (), copy.position (), 0);\n-    backing_buffer = copy.backing_buffer;\n-    readOnly = copy.isReadOnly ();\n+    super (buffer, offset, capacity, limit, position, mark);\n+    this.readOnly = readOnly;\n   }\n-\n-  public boolean isReadOnly()\n+  \n+  public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n-\n-  public IntBuffer slice()\n+  \n+  public IntBuffer slice ()\n   {\n-    return new IntBufferImpl (this);\n+    return new IntBufferImpl (backing_buffer, array_offset + position (), remaining (), remaining (), 0, -1, isReadOnly ());\n   }\n-\n-  public IntBuffer duplicate()\n+  \n+  public IntBuffer duplicate ()\n   {\n-    return new IntBufferImpl(this);\n+    return new IntBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, isReadOnly ());\n   }\n-\n-  public IntBuffer asReadOnlyBuffer()\n+  \n+  public IntBuffer asReadOnlyBuffer ()\n   {\n-    IntBufferImpl result = new IntBufferImpl (this);\n-    result.readOnly = true;\n-    return result;\n+    return new IntBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, true);\n   }\n-\n-  public IntBuffer compact()\n+  \n+  public IntBuffer compact ()\n   {\n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n     return this;\n   }\n-\n-  public boolean isDirect()\n+  \n+  public boolean isDirect ()\n   {\n     return false;\n   }\n \n-  final public int get()\n+  /**\n+   * Relative get method. Reads the next <code>int</code> from the buffer.\n+   */\n+  final public int get ()\n   {\n-    int e = backing_buffer[position()];\n-    position(position()+1);\n-    return e;\n+    int result = backing_buffer [position ()];\n+    position (position () + 1);\n+    return result;\n   }\n-\n-  final public IntBuffer put(int b)\n+  \n+  /**\n+   * Relative put method. Writes <code>value</code> to the next position\n+   * in the buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public IntBuffer put (int value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[position()] = b;\n-    position(position()+1);\n+\t  \t    \n+    backing_buffer [position ()] = value;\n+    position (position () + 1);\n     return this;\n   }\n-\n-  final public int get(int index)\n+  \n+  /**\n+   * Absolute get method. Reads the <code>int</code> at position\n+   * <code>index</code>.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  final public int get (int index)\n   {\n-    return backing_buffer[index];\n+    return backing_buffer [index];\n   }\n-\n-  final public IntBuffer put(int index, int b)\n+  \n+  /**\n+   * Absolute put method. Writes <code>value</value> to position\n+   * <code>index</code> in the buffer.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public IntBuffer put (int index, int value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[index] = b;\n+    \t    \n+    backing_buffer [index] = value;\n     return this;\n   }\n   \n   final public ByteOrder order ()\n   {\n-    return ByteOrder.BIG_ENDIAN;\n+    return ByteOrder.nativeOrder ();\n   }\n }"}, {"sha": "e37ac8e4b2cb7defdfe294be851d730dd2d25d46", "filename": "libjava/gnu/java/nio/LongBufferImpl.java", "status": "modified", "additions": 74, "deletions": 52, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* LongBufferImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n@@ -49,92 +50,113 @@ public final class LongBufferImpl extends LongBuffer\n {\n   private boolean readOnly;\n \n-  public LongBufferImpl(int cap, int off, int lim)\n-  {\n-    super (cap, lim, off, 0);\n-    this.backing_buffer = new long[cap];\n-    readOnly = false;\n-  }\n-\n-  public LongBufferImpl(long[] array, int offset, int length)\n+  LongBufferImpl (int capacity)\n   {\n-    super (array.length, length, offset, 0);\n-    this.backing_buffer = array;\n-    readOnly = false;\n+    this (new long [capacity], 0, capacity, capacity, 0, -1, false);\n   }\n-\n-  public LongBufferImpl(LongBufferImpl copy)\n+  \n+  LongBufferImpl (long[] buffer, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n   {\n-    super (copy.capacity (), copy.limit (), copy.position (), 0);\n-    backing_buffer = copy.backing_buffer;\n-    readOnly = copy.isReadOnly ();\n+    super (buffer, offset, capacity, limit, position, mark);\n+    this.readOnly = readOnly;\n   }\n-\n-  public boolean isReadOnly()\n+  \n+  public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n-\n-  public LongBuffer slice()\n+  \n+  public LongBuffer slice ()\n   {\n-    return new LongBufferImpl (this);\n+    return new LongBufferImpl (backing_buffer, array_offset + position (), remaining (), remaining (), 0, -1, isReadOnly ());\n   }\n-\n-  public LongBuffer duplicate()\n+  \n+  public LongBuffer duplicate ()\n   {\n-    return new LongBufferImpl(this);\n+    return new LongBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, isReadOnly ());\n   }\n-\n-  public LongBuffer asReadOnlyBuffer()\n+  \n+  public LongBuffer asReadOnlyBuffer ()\n   {\n-    LongBufferImpl result = new LongBufferImpl (this);\n-    result.readOnly = true;\n-    return result;\n+    return new LongBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, true);\n   }\n-\n-  public LongBuffer compact()\n+  \n+  public LongBuffer compact ()\n   {\n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n     return this;\n   }\n-\n-  public boolean isDirect()\n+  \n+  public boolean isDirect ()\n   {\n     return false;\n   }\n \n-  final public long get()\n+  /**\n+   * Relative get method. Reads the next <code>long</code> from the buffer.\n+   */\n+  final public long get ()\n   {\n-    long e = backing_buffer[position()];\n-    position(position()+1);\n-    return e;\n+    long result = backing_buffer [position ()];\n+    position (position () + 1);\n+    return result;\n   }\n-\n-  final public LongBuffer put(long b)\n+  \n+  /**\n+   * Relative put method. Writes <code>value</code> to the next position\n+   * in the buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public LongBuffer put (long value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[position()] = b;\n-    position(position()+1);\n+\t  \t    \n+    backing_buffer [position ()] = value;\n+    position (position () + 1);\n     return this;\n   }\n-\n-  final public long get(int index)\n+  \n+  /**\n+   * Absolute get method. Reads the <code>long</code> at position\n+   * <code>index</code>.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  final public long get (int index)\n   {\n-    return backing_buffer[index];\n+    return backing_buffer [index];\n   }\n-\n-  final public LongBuffer put(int index, long b)\n+  \n+  /**\n+   * Absolute put method. Writes <code>value</value> to position\n+   * <code>index</code> in the buffer.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public LongBuffer put (int index, long value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[index] = b;\n+    \t    \n+    backing_buffer [index] = value;\n     return this;\n   }\n-\n+  \n   final public ByteOrder order ()\n   {\n-    return ByteOrder.BIG_ENDIAN;\n+    return ByteOrder.nativeOrder ();\n   }\n }"}, {"sha": "3dc625e11587a513933938b13644d7ea3dc7a528", "filename": "libjava/gnu/java/nio/ShortBufferImpl.java", "status": "modified", "additions": 73, "deletions": 51, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* ShortBufferImpl.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,6 +35,7 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package gnu.java.nio;\n \n import java.nio.ByteBuffer;\n@@ -49,92 +50,113 @@ public final class ShortBufferImpl extends ShortBuffer\n {\n   private boolean readOnly;\n \n-  public ShortBufferImpl(int cap, int off, int lim)\n-  {\n-    super (cap, lim, off, 0);\n-    this.backing_buffer = new short [cap];\n-    readOnly = false;\n-  }\n-\n-  public ShortBufferImpl(short[] array, int offset, int length)\n+  ShortBufferImpl (int capacity)\n   {\n-    super (array.length, length, offset, 0);\n-    this.backing_buffer = array;\n-    readOnly = false;\n+    this (new short [capacity], 0, capacity, capacity, 0, -1, false);\n   }\n-\n-  public ShortBufferImpl(ShortBufferImpl copy)\n+  \n+  ShortBufferImpl (short[] buffer, int offset, int capacity, int limit, int position, int mark, boolean readOnly)\n   {\n-    super (copy.capacity (), copy.limit (), copy.position (), 0);\n-    backing_buffer = copy.backing_buffer;\n-    readOnly = copy.isReadOnly ();\n+    super (buffer, offset, capacity, limit, position, mark);\n+    this.readOnly = readOnly;\n   }\n-\n-  public boolean isReadOnly()\n+  \n+  public boolean isReadOnly ()\n   {\n     return readOnly;\n   }\n-\n-  public ShortBuffer slice()\n+  \n+  public ShortBuffer slice ()\n   {\n-    return new ShortBufferImpl (this);\n+    return new ShortBufferImpl (backing_buffer, array_offset + position (), remaining (), remaining (), 0, -1, isReadOnly ());\n   }\n-\n-  public ShortBuffer duplicate()\n+  \n+  public ShortBuffer duplicate ()\n   {\n-    return new ShortBufferImpl(this);\n+    return new ShortBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, isReadOnly ());\n   }\n-\n-  public ShortBuffer asReadOnlyBuffer()\n+  \n+  public ShortBuffer asReadOnlyBuffer ()\n   {\n-    ShortBufferImpl result = new ShortBufferImpl (this);\n-    result.readOnly = true;\n-    return result;\n+    return new ShortBufferImpl (backing_buffer, array_offset, capacity (), limit (), position (), mark, true);\n   }\n-\n-  public ShortBuffer compact()\n+  \n+  public ShortBuffer compact ()\n   {\n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n     return this;\n   }\n-\n-  public boolean isDirect()\n+  \n+  public boolean isDirect ()\n   {\n     return false;\n   }\n \n-  final public short get()\n+  /**\n+   * Relative get method. Reads the next <code>short</code> from the buffer.\n+   */\n+  final public short get ()\n   {\n-    short e = backing_buffer[position()];\n-    position(position()+1);\n-    return e;\n+    short result = backing_buffer [position ()];\n+    position (position () + 1);\n+    return result;\n   }\n-\n-  final public ShortBuffer put(short b)\n+  \n+  /**\n+   * Relative put method. Writes <code>value</code> to the next position\n+   * in the buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public ShortBuffer put (short value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[position()] = b;\n-    position(position()+1);\n+\t  \t    \n+    backing_buffer [position ()] = value;\n+    position (position () + 1);\n     return this;\n   }\n-\n-  final public short get(int index)\n+  \n+  /**\n+   * Absolute get method. Reads the <code>short</code> at position\n+   * <code>index</code>.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  final public short get (int index)\n   {\n-    return backing_buffer[index];\n+    return backing_buffer [index];\n   }\n-\n-  final public ShortBuffer put(int index, short b)\n+  \n+  /**\n+   * Absolute put method. Writes <code>value</value> to position\n+   * <code>index</code> in the buffer.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  final public ShortBuffer put (int index, short value)\n   {\n     if (readOnly)\n       throw new ReadOnlyBufferException ();\n-    \n-    backing_buffer[index] = b;\n+    \t    \n+    backing_buffer [index] = value;\n     return this;\n   }\n   \n   final public ByteOrder order ()\n   {\n-    return ByteOrder.BIG_ENDIAN;\n+    return ByteOrder.nativeOrder ();\n   }\n }"}, {"sha": "c6ba45669ffefec66bc9305b97f51450fdf2591b", "filename": "libjava/gnu/java/nio/natByteBufferImpl.cc", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3e0dffb76fd85d777f5c5de71f47816121bc5e3/libjava%2Fgnu%2Fjava%2Fnio%2FnatByteBufferImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3e0dffb76fd85d777f5c5de71f47816121bc5e3/libjava%2Fgnu%2Fjava%2Fnio%2FnatByteBufferImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FnatByteBufferImpl.cc?ref=d3e0dffb76fd85d777f5c5de71f47816121bc5e3", "patch": "@@ -1,82 +0,0 @@\n-// natByteBufferImpl.cc\n-\n-/* Copyright (C) 2002, 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-\n-#include <gnu/java/nio/ByteBufferImpl.h>\n-\n-void\n-gnu::java::nio::ByteBufferImpl::nio_put_Char(gnu::java::nio::ByteBufferImpl*, jint, jint, jchar)\n-{\n-}\n-\n-void\n-gnu::java::nio::ByteBufferImpl::nio_put_Short(gnu::java::nio::ByteBufferImpl*, jint, jint, jshort)\n-{\n-}\n-\n-void\n-gnu::java::nio::ByteBufferImpl::nio_put_Int(gnu::java::nio::ByteBufferImpl*, jint, jint, jint)\n-{\n-}\n-\n-void\n-gnu::java::nio::ByteBufferImpl::nio_put_Long(gnu::java::nio::ByteBufferImpl*, jint, jint, jlong)\n-{\n-}\n-\n-void\n-gnu::java::nio::ByteBufferImpl::nio_put_Float(gnu::java::nio::ByteBufferImpl*, jint, jint, jfloat)\n-{\n-}\n-\n-void\n-gnu::java::nio::ByteBufferImpl::nio_put_Double(gnu::java::nio::ByteBufferImpl*, jint, jint, jdouble)\n-{\n-}\n-\n-jchar\n-gnu::java::nio::ByteBufferImpl::nio_get_Char(gnu::java::nio::ByteBufferImpl*, jint, jint)\n-{\n-  return ' ';\n-}\n-\n-jshort\n-gnu::java::nio::ByteBufferImpl::nio_get_Short(gnu::java::nio::ByteBufferImpl*, jint, jint)\n-{\n-  return 0;\n-}\n-\n-jint\n-gnu::java::nio::ByteBufferImpl::nio_get_Int(gnu::java::nio::ByteBufferImpl*, jint, jint)\n-{\n-  return 0;\n-}\n-\n-jlong\n-gnu::java::nio::ByteBufferImpl::nio_get_Long(gnu::java::nio::ByteBufferImpl*, jint, jint)\n-{\n-  return 0;\n-}\n-\n-jfloat\n-gnu::java::nio::ByteBufferImpl::nio_get_Float(gnu::java::nio::ByteBufferImpl*, jint, jint)\n-{\n-  return 0.0;\n-}\n-\n-jdouble\n-gnu::java::nio::ByteBufferImpl::nio_get_Double(gnu::java::nio::ByteBufferImpl*, jint, jint)\n-{\n-  return 0.0;\n-}"}, {"sha": "eb729277d3ac24063801c776439af958e6dbf857", "filename": "libjava/gnu/java/nio/natCharBufferImpl.cc", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3e0dffb76fd85d777f5c5de71f47816121bc5e3/libjava%2Fgnu%2Fjava%2Fnio%2FnatCharBufferImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3e0dffb76fd85d777f5c5de71f47816121bc5e3/libjava%2Fgnu%2Fjava%2Fnio%2FnatCharBufferImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FnatCharBufferImpl.cc?ref=d3e0dffb76fd85d777f5c5de71f47816121bc5e3", "patch": "@@ -1,22 +0,0 @@\n-// natCharBufferImpl.cc\n-\n-/* Copyright (C) 2002, 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-\n-#include <gnu/java/nio/CharBufferImpl.h>\n-\n-JArray<jchar>*\n-gnu::java::nio::CharBufferImpl::nio_cast(JArray<jbyte>*)\n-{\n-  return NULL;\n-}"}, {"sha": "fbee6dfb9dd93285b20a3c95a49f1137883c938a", "filename": "libjava/java/nio/CharBuffer.java", "status": "modified", "additions": 148, "deletions": 92, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FCharBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FCharBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FCharBuffer.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* CharBuffer.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -45,26 +45,40 @@\n public abstract class CharBuffer extends Buffer\n   implements Comparable, CharSequence\n {\n-  int array_offset = 0;\n+  int array_offset;\n   char[] backing_buffer;\n-  \n+\n+  CharBuffer (int capacity, int limit, int position, int mark)\n+  {\n+    super (capacity, limit, position, mark);\n+    array_offset = 0;\n+  }\n+\n+  CharBuffer (char[] buffer, int offset, int capacity, int limit, int position, int mark)\n+  {\n+    super (capacity, limit, position, mark);\n+    this.backing_buffer = buffer;\n+    this.array_offset = offset;\n+  }\n+\n   /**\n    * Allocates a new <code>CharBuffer</code> object with a given capacity.\n    */\n   public static CharBuffer allocate (int capacity)\n   {\n-    return new CharBufferImpl (capacity, 0, capacity);\n+    return new CharBufferImpl (capacity);\n   }\n-  \n+\n   /**\n-   * Wraps a character array into a <code>CharBuffer</code> object.\n-   * \n+   * Wraps a <code>char</code> array into a <code>CharBuffer</code>\n+   * object.\n+   *\n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n    * and length parameters do not hold\n    */\n   final public static CharBuffer wrap (char[] array, int offset, int length)\n   {\n-    return new CharBufferImpl (array, offset, length);\n+    return new CharBufferImpl (array, 0, array.length, offset + length, offset, -1, false);\n   }\n   \n   /**\n@@ -101,52 +115,63 @@ final public static CharBuffer wrap (CharSequence a, int offset, int length)\n     \n     return wrap (buffer, offset, length);\n   }\n-  \n+\n   /**\n-   * Wraps a character array into a <code>CharBuffer</code> object.\n+   * Wraps a <code>char</code> array into a <code>CharBuffer</code>\n+   * object.\n    */\n   final public static CharBuffer wrap (char[] array)\n   {\n     return wrap (array, 0, array.length);\n   }\n- \n-  CharBuffer (int cap, int lim, int pos, int mark)\n-  {\n-    super (cap, lim, pos, mark);\n-  }\n   \n   /**\n-   * Relative get method.\n-   * \n-   * @exception BufferUnderflowException If the buffer's current position is\n-   * not smaller than its limit.\n+   * This method transfers <code>chars<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The destination array\n+   * @param offset The offset within the array of the first <code>char</code>\n+   * to be written; must be non-negative and no larger than dst.length.\n+   * @param length The maximum number of bytes to be written to the given array;\n+   * must be non-negative and no larger than dst.length - offset.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than length\n+   * <code>chars</code> remaining in this buffer.\n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n-   * and length parameters do not hold\n+   * and length parameters do not hold.\n    */\n   public CharBuffer get (char[] dst, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n       {\n         dst [i] = get ();\n       }\n-    \n+\n     return this;\n   }\n-  \n+\n   /**\n-   * Relative get method.\n-   * \n-   * @exception BufferUnderflowException If there are fewer than length\n-   * characters remaining in this buffer.\n+   * This method transfers <code>chars<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The byte array to write into.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than dst.length\n+   * <code>chars</code> remaining in this buffer.\n    */\n   public CharBuffer get (char[] dst)\n   {\n     return get (dst, 0, dst.length);\n   }\n-  \n+\n   /**\n-   * @exception BufferOverflowException If there are fewer than length of\n-   * source buffer characters remaining in this buffer.\n+   * Writes the content of the the <code>CharBUFFER</code> src\n+   * into the buffer.\n+   *\n+   * @param src The source data.\n+   *\n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>chars<code> in the source buffer.\n    * @exception IllegalArgumentException If the source buffer is this buffer.\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n@@ -155,19 +180,31 @@ public CharBuffer put (CharBuffer src)\n     if (src == this)\n       throw new IllegalArgumentException ();\n \n-    if (src.length () > 0)\n+    if (src.remaining () > remaining ())\n+      throw new BufferOverflowException ();\n+\n+    if (src.remaining () > 0)\n       {\n-        char [] toPut = new char [src.length ()];\n+        char[] toPut = new char [src.remaining ()];\n         src.get (toPut);\n         src.put (toPut);\n       }\n \n     return this;\n   }\n- \n+\n   /**\n-   * @exception BufferOverflowException If there are fewer then length\n-   * characters remaining in this buffer.\n+   * Writes the content of the the <code>char array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * @param offset The offset within the array of the first byte to be read;\n+   * must be non-negative and no larger than src.length.\n+   * @param length The number of bytes to be read from the given array;\n+   * must be non-negative and no larger than src.length - offset.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>chars<code> in the source array.\n    * @exception IndexOutOfBoundsException If the preconditions on the offset\n    * and length parameters do not hold\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n@@ -185,18 +222,19 @@ public CharBuffer put (char[] src, int offset, int length)\n       throw new BufferOverflowException ();\n \t\t    \n     for (int i = offset; i < offset + length; i++)\n-      {\n-        put (src [i]);\n-      }\n+      put (src [i]);\n \n     return this;\n   }\n \n   /**\n-   * Relative put method.\n+   * Writes the content of the the <code>char array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n    * \n-   * @exception BufferOverflowException If there are fewer then length of the\n-   * array characters remaining in this buffer.\n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>chars<code> in the source array.\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public final CharBuffer put (char[] src)\n@@ -205,17 +243,18 @@ public final CharBuffer put (char[] src)\n   }\n \n   /**\n-   * Tells wether this is buffer is backed by an accessible array or not.\n+   * Tells whether ot not this buffer is backed by an accessible\n+   * <code>char</code> array.\n    */\n   public final boolean hasArray ()\n   {\n     return (backing_buffer != null\n-            && ! isReadOnly ());\n+            && !isReadOnly ());\n   }\n \n   /**\n-   * Returns the array that backs this buffer.\n-   * \n+   * Returns the <code>char</code> array that backs this buffer.\n+   *\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    * @exception UnsupportedOperationException If this buffer is not backed\n    * by an accessible array.\n@@ -230,10 +269,10 @@ public final char[] array ()\n     \n     return backing_buffer;\n   }\n-  \n+\n   /**\n-   * Returns the offset to the position of a character in this buffer.\n-   * \n+   * Returns the offset within this buffer's backing array of the first element.\n+   *\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    * @exception UnsupportedOperationException If this buffer is not backed\n    * by an accessible array.\n@@ -248,111 +287,133 @@ public final int arrayOffset ()\n     \n     return array_offset;\n   }\n-  \n+\n   /**\n-   * Calculates a hash code for this buffer-\n+   * Calculates a hash code for this buffer.\n    */\n   public int hashCode ()\n   {\n     // FIXME: Check what SUN calculates here.\n     return super.hashCode ();\n   }\n-  \n+\n   /**\n    * Checks if this buffer is equal to obj.\n    */\n   public boolean equals (Object obj)\n   {\n     if (obj instanceof CharBuffer)\n-      return compareTo (obj) == 0;\n-    \n+      {\n+        return compareTo (obj) == 0;\n+      }\n+\n     return false;\n   }\n- \n+\n   /**\n-   * Compares two character buffer objects.\n-   * \n+   * Compares two <code>CharBuffer</code> objects.\n+   *\n    * @exception ClassCastException If obj is not an object derived from\n    * <code>CharBuffer</code>.\n    */\n-  public int compareTo(Object obj)\n+  public int compareTo (Object obj)\n   {\n     CharBuffer a = (CharBuffer) obj;\n-    \n+\n     if (a.remaining () != remaining ())\n       return 1;\n-    \n-    if (! hasArray () || ! a.hasArray ())\n-      return 1;\n-    \n+\n+    if (! hasArray () ||\n+        ! a.hasArray ())\n+      {\n+        return 1;\n+      }\n+\n     int r = remaining ();\n     int i1 = position ();\n     int i2 = a.position ();\n-    \n+\n     for (int i = 0; i < r; i++)\n       {\n-        int t = (int) (get (i1)- a.get (i2));\n-\t\n+        int t = (int) (get (i1) - a.get (i2));\n+\n         if (t != 0)\n-          return (int) t;\n+          {\n+            return (int) t;\n+          }\n       }\n-    \n+\n     return 0;\n   }\n- \n+\n   /**\n-   * Relative get method.\n-   * \n-   * @exception BufferUnderflowException If there are no remaining characters\n-   * in this buffer.\n+   * Returns the byte order of this buffer.\n+   */\n+  public abstract ByteOrder order ();\n+\n+  /**\n+   * Reads the <code>char</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferUnderflowException If there are no remaining\n+   * <code>chars</code> in this buffer.\n    */\n   public abstract char get ();\n-  \n+\n   /**\n-   * Relative put method.\n-   * \n-   * @exception BufferOverflowException If there no remaining characters in\n-   * this buffer.\n+   * Writes the <code>char</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferOverflowException If there no remaining \n+   * <code>chars</code> in this buffer.\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public abstract CharBuffer put (char b);\n-  \n+\n   /**\n    * Absolute get method.\n-   * \n+   *\n    * @exception IndexOutOfBoundsException If index is negative or not smaller\n    * than the buffer's limit.\n    */\n   public abstract char get (int index);\n   \n   /**\n    * Absolute put method.\n-   * \n+   *\n    * @exception IndexOutOfBoundsException If index is negative or not smaller\n    * than the buffer's limit.\n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public abstract CharBuffer put (int index, char b);\n- \n+\n   /**\n+   * Compacts this buffer.\n+   * \n    * @exception ReadOnlyBufferException If this buffer is read-only.\n    */\n   public abstract CharBuffer compact ();\n-  \n+\n   /**\n-   * Tells wether this buffer is direct or not.\n+   * Tells wether or not this buffer is direct.\n    */\n   public abstract boolean isDirect ();\n-  \n+\n+  /**\n+   * Creates a new <code>CharBuffer</code> whose content is a shared\n+   * subsequence of this buffer's content.\n+   */\n   public abstract CharBuffer slice ();\n-  \n+\n   /**\n-   * Duplicates this buffer.\n+   * Creates a new <code>CharBuffer</code> that shares this buffer's\n+   * content.\n    */\n   public abstract CharBuffer duplicate ();\n-  \n+\n   /**\n-   * Returns this buffer made read-only.\n+   * Creates a new read-only <code>CharBuffer</code> that shares this\n+   * buffer's content.\n    */\n   public abstract CharBuffer asReadOnlyBuffer ();\n   \n@@ -377,11 +438,6 @@ public final int length ()\n     return remaining ();\n   }\n \n-  /**\n-   * Returns the byte order of this buffer.\n-   */\n-  public abstract ByteOrder order ();\n-\n   /**\n    * Creates a new character buffer that represents the specified subsequence\n    * of this buffer, relative to the current position."}, {"sha": "f212566111c720160f185dcd8746aae6fa0a7e5b", "filename": "libjava/java/nio/DoubleBuffer.java", "status": "modified", "additions": 225, "deletions": 54, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FDoubleBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FDoubleBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FDoubleBuffer.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* DoubleBuffer.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,72 +39,141 @@\n \n import gnu.java.nio.DoubleBufferImpl;\n \n-public abstract class DoubleBuffer extends Buffer implements Comparable\n+/**\n+ * @since 1.4\n+ */\n+public abstract class DoubleBuffer extends Buffer\n+  implements Comparable\n {\n   int array_offset;\n   double[] backing_buffer;\n \n-  public static DoubleBuffer allocateDirect(int capacity)\n-  {\n-    throw new Error (\"direct buffers are not implemented\");\n-  }\n-\n-  public static DoubleBuffer allocate(int capacity)\n+  DoubleBuffer (int capacity, int limit, int position, int mark)\n   {\n-    return new DoubleBufferImpl(capacity, 0, capacity);\n+    super (capacity, limit, position, mark);\n+    array_offset = 0;\n   }\n \n-  final public static DoubleBuffer wrap (double[] array, int offset, int length)\n+  DoubleBuffer (double[] buffer, int offset, int capacity, int limit, int position, int mark)\n   {\n-    return new DoubleBufferImpl(array, offset, length);\n+    super (capacity, limit, position, mark);\n+    this.backing_buffer = buffer;\n+    this.array_offset = offset;\n   }\n \n-  final public static DoubleBuffer wrap(String a)\n+  /**\n+   * Allocates a new <code>DoubleBuffer</code> object with a given capacity.\n+   */\n+  public static DoubleBuffer allocate (int capacity)\n   {\n-    int len = a.length();\n-    double[] buffer = new double[len];\n-\n-    for (int i=0;i<len;i++)\n-      {\n-        buffer[i] = (double) a.charAt(i);\n-      }\n-\n-    return wrap(buffer, 0, len);\n+    return new DoubleBufferImpl (capacity);\n   }\n \n-  final public static DoubleBuffer wrap(double[] array)\n+  /**\n+   * Wraps a <code>double</code> array into a <code>DoubleBuffer</code>\n+   * object.\n+   *\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public static DoubleBuffer wrap (double[] array, int offset, int length)\n   {\n-    return wrap(array, 0, array.length);\n+    return new DoubleBufferImpl (array, 0, array.length, offset + length, offset, -1, false);\n   }\n \n-  DoubleBuffer (int capacity, int limit, int position, int mark)\n+  /**\n+   * Wraps a <code>double</code> array into a <code>DoubleBuffer</code>\n+   * object.\n+   */\n+  final public static DoubleBuffer wrap (double[] array)\n   {\n-    super (capacity, limit, position, mark);\n+    return wrap (array, 0, array.length);\n   }\n   \n+  /**\n+   * This method transfers <code>doubles<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The destination array\n+   * @param offset The offset within the array of the first <code>double</code>\n+   * to be written; must be non-negative and no larger than dst.length.\n+   * @param length The maximum number of bytes to be written to the given array;\n+   * must be non-negative and no larger than dst.length - offset.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than length\n+   * <code>doubles</code> remaining in this buffer.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold.\n+   */\n   public DoubleBuffer get (double[] dst, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n       {\n-        dst[i] = get();\n+        dst [i] = get ();\n       }\n \n     return this;\n   }\n \n+  /**\n+   * This method transfers <code>doubles<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The byte array to write into.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than dst.length\n+   * <code>doubles</code> remaining in this buffer.\n+   */\n   public DoubleBuffer get (double[] dst)\n   {\n-    return get(dst, 0, dst.length);\n+    return get (dst, 0, dst.length);\n   }\n \n+  /**\n+   * Writes the content of the the <code>DoubleBUFFER</code> src\n+   * into the buffer.\n+   *\n+   * @param src The source data.\n+   *\n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>doubles<code> in the source buffer.\n+   * @exception IllegalArgumentException If the source buffer is this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public DoubleBuffer put (DoubleBuffer src)\n   {\n-    while (src.hasRemaining())\n-      put(src.get());\n+    if (src == this)\n+      throw new IllegalArgumentException ();\n+\n+    if (src.remaining () > remaining ())\n+      throw new BufferOverflowException ();\n+\n+    if (src.remaining () > 0)\n+      {\n+        double[] toPut = new double [src.remaining ()];\n+        src.get (toPut);\n+        src.put (toPut);\n+      }\n \n     return this;\n   }\n \n+  /**\n+   * Writes the content of the the <code>double array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * @param offset The offset within the array of the first byte to be read;\n+   * must be non-negative and no larger than src.length.\n+   * @param length The number of bytes to be read from the given array;\n+   * must be non-negative and no larger than src.length - offset.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>doubles<code> in the source array.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public DoubleBuffer put (double[] src, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n@@ -113,18 +182,39 @@ public DoubleBuffer put (double[] src, int offset, int length)\n     return this;\n   }\n \n-  public final DoubleBuffer put(double[] src)\n+  /**\n+   * Writes the content of the the <code>double array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>doubles<code> in the source array.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public final DoubleBuffer put (double[] src)\n   {\n-    return put(src, 0, src.length);\n+    return put (src, 0, src.length);\n   }\n \n-  public final boolean hasArray()\n+  /**\n+   * Tells whether ot not this buffer is backed by an accessible\n+   * <code>double</code> array.\n+   */\n+  public final boolean hasArray ()\n   {\n     return (backing_buffer != null\n             && !isReadOnly ());\n   }\n \n-  public final double[] array()\n+  /**\n+   * Returns the <code>double</code> array that backs this buffer.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final double[] array ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -135,7 +225,14 @@ public final double[] array()\n     return backing_buffer;\n   }\n \n-  public final int arrayOffset()\n+  /**\n+   * Returns the offset within this buffer's backing array of the first element.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final int arrayOffset ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -146,41 +243,55 @@ public final int arrayOffset()\n     return array_offset;\n   }\n \n-  public int hashCode()\n+  /**\n+   * Calculates a hash code for this buffer.\n+   */\n+  public int hashCode ()\n   {\n-    return super.hashCode();\n+    // FIXME: Check what SUN calculates here.\n+    return super.hashCode ();\n   }\n \n-  public boolean equals(Object obj)\n+  /**\n+   * Checks if this buffer is equal to obj.\n+   */\n+  public boolean equals (Object obj)\n   {\n     if (obj instanceof DoubleBuffer)\n       {\n-        return compareTo(obj) == 0;\n+        return compareTo (obj) == 0;\n       }\n \n     return false;\n   }\n \n-  public int compareTo(Object ob)\n+  /**\n+   * Compares two <code>DoubleBuffer</code> objects.\n+   *\n+   * @exception ClassCastException If obj is not an object derived from\n+   * <code>DoubleBuffer</code>.\n+   */\n+  public int compareTo (Object obj)\n   {\n-    DoubleBuffer a = (DoubleBuffer) ob;\n+    DoubleBuffer a = (DoubleBuffer) obj;\n \n-    if (a.remaining() != remaining())\n+    if (a.remaining () != remaining ())\n       return 1;\n \n-    if (! hasArray() ||\n-        ! a.hasArray())\n+    if (! hasArray () ||\n+        ! a.hasArray ())\n       {\n         return 1;\n       }\n \n-    int r = remaining();\n+    int r = remaining ();\n     int i1 = position ();\n     int i2 = a.position ();\n \n-    for (int i=0;i<r;i++)\n+    for (int i = 0; i < r; i++)\n       {\n-        int t = (int) (get(i1)- a.get(i2));\n+        int t = (int) (get (i1) - a.get (i2));\n+\n         if (t != 0)\n           {\n             return (int) t;\n@@ -190,14 +301,74 @@ public int compareTo(Object ob)\n     return 0;\n   }\n \n+  /**\n+   * Returns the byte order of this buffer.\n+   */\n   public abstract ByteOrder order ();\n-  public abstract double get();\n+\n+  /**\n+   * Reads the <code>double</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferUnderflowException If there are no remaining\n+   * <code>doubles</code> in this buffer.\n+   */\n+  public abstract double get ();\n+\n+  /**\n+   * Writes the <code>double</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferOverflowException If there no remaining \n+   * <code>doubles</code> in this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public abstract DoubleBuffer put (double b);\n-  public abstract double get(int index);\n-  public abstract DoubleBuffer put(int index, double b);\n-  public abstract DoubleBuffer compact();\n-  public abstract boolean isDirect();\n-  public abstract DoubleBuffer slice();\n-  public abstract DoubleBuffer duplicate();\n-  public abstract DoubleBuffer asReadOnlyBuffer();\n+\n+  /**\n+   * Absolute get method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  public abstract double get (int index);\n+  \n+  /**\n+   * Absolute put method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract DoubleBuffer put (int index, double b);\n+\n+  /**\n+   * Compacts this buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract DoubleBuffer compact ();\n+\n+  /**\n+   * Tells wether or not this buffer is direct.\n+   */\n+  public abstract boolean isDirect ();\n+\n+  /**\n+   * Creates a new <code>DoubleBuffer</code> whose content is a shared\n+   * subsequence of this buffer's content.\n+   */\n+  public abstract DoubleBuffer slice ();\n+\n+  /**\n+   * Creates a new <code>DoubleBuffer</code> that shares this buffer's\n+   * content.\n+   */\n+  public abstract DoubleBuffer duplicate ();\n+\n+  /**\n+   * Creates a new read-only <code>DoubleBuffer</code> that shares this\n+   * buffer's content.\n+   */\n+  public abstract DoubleBuffer asReadOnlyBuffer ();\n }"}, {"sha": "65d680bb108db49386057d5992a31820c8386d44", "filename": "libjava/java/nio/FloatBuffer.java", "status": "modified", "additions": 227, "deletions": 57, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FFloatBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FFloatBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FFloatBuffer.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* FloatBuffer.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,93 +39,182 @@\n \n import gnu.java.nio.FloatBufferImpl;\n \n-public abstract class FloatBuffer extends Buffer implements Comparable\n+/**\n+ * @since 1.4\n+ */\n+public abstract class FloatBuffer extends Buffer\n+  implements Comparable\n {\n   int array_offset;\n   float[] backing_buffer;\n \n-  public static FloatBuffer allocateDirect(int capacity)\n+  FloatBuffer (int capacity, int limit, int position, int mark)\n   {\n-    throw new Error (\"direct buffers not implemented\");\n+    super (capacity, limit, position, mark);\n+    array_offset = 0;\n   }\n \n-  public static FloatBuffer allocate(int capacity)\n+  FloatBuffer (float[] buffer, int offset, int capacity, int limit, int position, int mark)\n   {\n-    return new FloatBufferImpl (capacity, 0, capacity);\n+    super (capacity, limit, position, mark);\n+    this.backing_buffer = buffer;\n+    this.array_offset = offset;\n   }\n \n-  final public static FloatBuffer wrap(float[] array, int offset, int length)\n+  /**\n+   * Allocates a new <code>FloatBuffer</code> object with a given capacity.\n+   */\n+  public static FloatBuffer allocate (int capacity)\n   {\n-    return new FloatBufferImpl(array, offset, length);\n+    return new FloatBufferImpl (capacity);\n   }\n \n-  final public static FloatBuffer wrap(String a)\n+  /**\n+   * Wraps a <code>float</code> array into a <code>FloatBuffer</code>\n+   * object.\n+   *\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public static FloatBuffer wrap (float[] array, int offset, int length)\n   {\n-    int len = a.length();\n-    float[] buffer = new float[len];\n-\n-    for (int i=0;i<len;i++)\n-      {\n-        buffer[i] = (float) a.charAt(i);\n-      }\n-\n-    return wrap(buffer, 0, len);\n+    return new FloatBufferImpl (array, 0, array.length, offset + length, offset, -1, false);\n   }\n \n-  final public static FloatBuffer wrap(float[] array)\n+  /**\n+   * Wraps a <code>float</code> array into a <code>FloatBuffer</code>\n+   * object.\n+   */\n+  final public static FloatBuffer wrap (float[] array)\n   {\n-    return wrap(array, 0, array.length);\n-  }\n-\n-  FloatBuffer (int capacity, int limit, int position, int mark)\n-  {\n-    super (capacity, limit, position, mark);\n-    array_offset = 0;                    \n+    return wrap (array, 0, array.length);\n   }\n   \n+  /**\n+   * This method transfers <code>floats<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The destination array\n+   * @param offset The offset within the array of the first <code>float</code>\n+   * to be written; must be non-negative and no larger than dst.length.\n+   * @param length The maximum number of bytes to be written to the given array;\n+   * must be non-negative and no larger than dst.length - offset.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than length\n+   * <code>floats</code> remaining in this buffer.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold.\n+   */\n   public FloatBuffer get (float[] dst, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n       {\n-        dst[i] = get();\n+        dst [i] = get ();\n       }\n \n     return this;\n   }\n \n+  /**\n+   * This method transfers <code>floats<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The byte array to write into.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than dst.length\n+   * <code>floats</code> remaining in this buffer.\n+   */\n   public FloatBuffer get (float[] dst)\n   {\n-    return get(dst, 0, dst.length);\n+    return get (dst, 0, dst.length);\n   }\n \n+  /**\n+   * Writes the content of the the <code>FloatBUFFER</code> src\n+   * into the buffer.\n+   *\n+   * @param src The source data.\n+   *\n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>floats<code> in the source buffer.\n+   * @exception IllegalArgumentException If the source buffer is this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public FloatBuffer put (FloatBuffer src)\n   {\n-    while (src.hasRemaining())\n-      put(src.get());\n+    if (src == this)\n+      throw new IllegalArgumentException ();\n+\n+    if (src.remaining () > remaining ())\n+      throw new BufferOverflowException ();\n+\n+    if (src.remaining () > 0)\n+      {\n+        float[] toPut = new float [src.remaining ()];\n+        src.get (toPut);\n+        src.put (toPut);\n+      }\n \n     return this;\n   }\n \n+  /**\n+   * Writes the content of the the <code>float array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * @param offset The offset within the array of the first byte to be read;\n+   * must be non-negative and no larger than src.length.\n+   * @param length The number of bytes to be read from the given array;\n+   * must be non-negative and no larger than src.length - offset.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>floats<code> in the source array.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public FloatBuffer put (float[] src, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n-      put(src[i]);\n+      put (src [i]);\n \n     return this;\n   }\n \n-  public final FloatBuffer put(float[] src)\n+  /**\n+   * Writes the content of the the <code>float array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>floats<code> in the source array.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public final FloatBuffer put (float[] src)\n   {\n-    return put(src, 0, src.length);\n+    return put (src, 0, src.length);\n   }\n \n-  public final boolean hasArray()\n+  /**\n+   * Tells whether ot not this buffer is backed by an accessible\n+   * <code>float</code> array.\n+   */\n+  public final boolean hasArray ()\n   {\n     return (backing_buffer != null\n             && !isReadOnly ());\n   }\n \n-  public final float[] array()\n+  /**\n+   * Returns the <code>float</code> array that backs this buffer.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final float[] array ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -136,7 +225,14 @@ public final float[] array()\n     return backing_buffer;\n   }\n \n-  public final int arrayOffset()\n+  /**\n+   * Returns the offset within this buffer's backing array of the first element.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final int arrayOffset ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -147,41 +243,55 @@ public final int arrayOffset()\n     return array_offset;\n   }\n \n-  public int hashCode()\n+  /**\n+   * Calculates a hash code for this buffer.\n+   */\n+  public int hashCode ()\n   {\n-    return super.hashCode();\n+    // FIXME: Check what SUN calculates here.\n+    return super.hashCode ();\n   }\n \n-  public boolean equals(Object obj)\n+  /**\n+   * Checks if this buffer is equal to obj.\n+   */\n+  public boolean equals (Object obj)\n   {\n     if (obj instanceof FloatBuffer)\n       {\n-        return compareTo(obj) == 0;\n+        return compareTo (obj) == 0;\n       }\n \n     return false;\n   }\n \n-  public int compareTo(Object ob)\n+  /**\n+   * Compares two <code>FloatBuffer</code> objects.\n+   *\n+   * @exception ClassCastException If obj is not an object derived from\n+   * <code>FloatBuffer</code>.\n+   */\n+  public int compareTo (Object obj)\n   {\n-    FloatBuffer a = (FloatBuffer) ob;\n+    FloatBuffer a = (FloatBuffer) obj;\n \n-    if (a.remaining() != remaining())\n+    if (a.remaining () != remaining ())\n       return 1;\n \n-    if (! hasArray() ||\n-        ! a.hasArray())\n+    if (! hasArray () ||\n+        ! a.hasArray ())\n       {\n         return 1;\n       }\n \n-    int r = remaining();\n+    int r = remaining ();\n     int i1 = position ();\n     int i2 = a.position ();\n \n-    for (int i=0;i<r;i++)\n+    for (int i = 0; i < r; i++)\n       {\n-        int t = (int) (get(i1)- a.get(i2));\n+        int t = (int) (get (i1) - a.get (i2));\n+\n         if (t != 0)\n           {\n             return (int) t;\n@@ -191,14 +301,74 @@ public int compareTo(Object ob)\n     return 0;\n   }\n \n+  /**\n+   * Returns the byte order of this buffer.\n+   */\n   public abstract ByteOrder order ();\n-  public abstract float get();\n-  public abstract java.nio. FloatBuffer put(float b);\n-  public abstract float get(int index);\n-  public abstract java.nio. FloatBuffer put(int index, float b);\n-  public abstract FloatBuffer compact();\n-  public abstract boolean isDirect();\n-  public abstract FloatBuffer slice();\n-  public abstract FloatBuffer duplicate();\n-  public abstract FloatBuffer asReadOnlyBuffer();\n+\n+  /**\n+   * Reads the <code>float</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferUnderflowException If there are no remaining\n+   * <code>floats</code> in this buffer.\n+   */\n+  public abstract float get ();\n+\n+  /**\n+   * Writes the <code>float</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferOverflowException If there no remaining \n+   * <code>floats</code> in this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract FloatBuffer put (float b);\n+\n+  /**\n+   * Absolute get method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  public abstract float get (int index);\n+  \n+  /**\n+   * Absolute put method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract FloatBuffer put (int index, float b);\n+\n+  /**\n+   * Compacts this buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract FloatBuffer compact ();\n+\n+  /**\n+   * Tells wether or not this buffer is direct.\n+   */\n+  public abstract boolean isDirect ();\n+\n+  /**\n+   * Creates a new <code>FloatBuffer</code> whose content is a shared\n+   * subsequence of this buffer's content.\n+   */\n+  public abstract FloatBuffer slice ();\n+\n+  /**\n+   * Creates a new <code>FloatBuffer</code> that shares this buffer's\n+   * content.\n+   */\n+  public abstract FloatBuffer duplicate ();\n+\n+  /**\n+   * Creates a new read-only <code>FloatBuffer</code> that shares this\n+   * buffer's content.\n+   */\n+  public abstract FloatBuffer asReadOnlyBuffer ();\n }"}, {"sha": "c8e0d0f4b9c5da28484cf4d300b7d940c1ef59a7", "filename": "libjava/java/nio/IntBuffer.java", "status": "modified", "additions": 229, "deletions": 59, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FIntBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FIntBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FIntBuffer.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* IntBuffer.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,93 +39,182 @@\n \n import gnu.java.nio.IntBufferImpl;\n \n-public abstract class IntBuffer extends Buffer implements Comparable\n+/**\n+ * @since 1.4\n+ */\n+public abstract class IntBuffer extends Buffer\n+  implements Comparable\n {\n   int array_offset;\n   int[] backing_buffer;\n \n-  public static IntBuffer allocateDirect(int capacity)\n-  {\n-    throw new Error (\"direct buffers not implemented\");\n-  }\n-\n-  public static IntBuffer allocate(int capacity)\n+  IntBuffer (int capacity, int limit, int position, int mark)\n   {\n-    return new IntBufferImpl (capacity, 0, capacity);\n+    super (capacity, limit, position, mark);\n+    array_offset = 0;\n   }\n \n-  final public static IntBuffer wrap(int[] array, int offset, int length)\n+  IntBuffer (int[] buffer, int offset, int capacity, int limit, int position, int mark)\n   {\n-    return new IntBufferImpl(array, offset, length);\n+    super (capacity, limit, position, mark);\n+    this.backing_buffer = buffer;\n+    this.array_offset = offset;\n   }\n \n-  final public static IntBuffer wrap(String a)\n+  /**\n+   * Allocates a new <code>IntBuffer</code> object with a given capacity.\n+   */\n+  public static IntBuffer allocate (int capacity)\n   {\n-    int len = a.length();\n-    int[] buffer = new int[len];\n-\n-    for (int i=0;i<len;i++)\n-      {\n-        buffer[i] = (int) a.charAt(i);\n-      }\n-\n-    return wrap(buffer, 0, len);\n+    return new IntBufferImpl (capacity);\n   }\n \n-  final public static IntBuffer wrap(int[] array)\n+  /**\n+   * Wraps a <code>int</code> array into a <code>IntBuffer</code>\n+   * object.\n+   *\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public static IntBuffer wrap (int[] array, int offset, int length)\n   {\n-    return wrap(array, 0, array.length);\n+    return new IntBufferImpl (array, 0, array.length, offset + length, offset, -1, false);\n   }\n \n-  IntBuffer (int capacity, int limit, int position, int mark)\n+  /**\n+   * Wraps a <code>int</code> array into a <code>IntBuffer</code>\n+   * object.\n+   */\n+  final public static IntBuffer wrap (int[] array)\n   {\n-    super (capacity, limit, position, mark);\n-    array_offset = 0;\n+    return wrap (array, 0, array.length);\n   }\n   \n-  public IntBuffer get(int[] dst, int offset, int length)\n+  /**\n+   * This method transfers <code>ints<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The destination array\n+   * @param offset The offset within the array of the first <code>int</code>\n+   * to be written; must be non-negative and no larger than dst.length.\n+   * @param length The maximum number of bytes to be written to the given array;\n+   * must be non-negative and no larger than dst.length - offset.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than length\n+   * <code>ints</code> remaining in this buffer.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold.\n+   */\n+  public IntBuffer get (int[] dst, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n       {\n-        dst[i] = get();\n+        dst [i] = get ();\n       }\n \n     return this;\n   }\n \n+  /**\n+   * This method transfers <code>ints<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The byte array to write into.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than dst.length\n+   * <code>ints</code> remaining in this buffer.\n+   */\n   public IntBuffer get (int[] dst)\n   {\n-    return get(dst, 0, dst.length);\n+    return get (dst, 0, dst.length);\n   }\n \n+  /**\n+   * Writes the content of the the <code>IntBUFFER</code> src\n+   * into the buffer.\n+   *\n+   * @param src The source data.\n+   *\n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>ints<code> in the source buffer.\n+   * @exception IllegalArgumentException If the source buffer is this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public IntBuffer put (IntBuffer src)\n   {\n-    while (src.hasRemaining())\n-      put(src.get());\n+    if (src == this)\n+      throw new IllegalArgumentException ();\n+\n+    if (src.remaining () > remaining ())\n+      throw new BufferOverflowException ();\n+\n+    if (src.remaining () > 0)\n+      {\n+        int[] toPut = new int [src.remaining ()];\n+        src.get (toPut);\n+        src.put (toPut);\n+      }\n \n     return this;\n   }\n \n+  /**\n+   * Writes the content of the the <code>int array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * @param offset The offset within the array of the first byte to be read;\n+   * must be non-negative and no larger than src.length.\n+   * @param length The number of bytes to be read from the given array;\n+   * must be non-negative and no larger than src.length - offset.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>ints<code> in the source array.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public IntBuffer put (int[] src, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n-      put(src[i]);\n+      put (src [i]);\n \n     return this;\n   }\n \n-  public final IntBuffer put(int[] src)\n+  /**\n+   * Writes the content of the the <code>int array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>ints<code> in the source array.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public final IntBuffer put (int[] src)\n   {\n-    return put(src, 0, src.length);\n+    return put (src, 0, src.length);\n   }\n \n-  public final boolean hasArray()\n+  /**\n+   * Tells whether ot not this buffer is backed by an accessible\n+   * <code>int</code> array.\n+   */\n+  public final boolean hasArray ()\n   {\n     return (backing_buffer != null\n             && !isReadOnly ());\n   }\n \n-  public final int[] array()\n+  /**\n+   * Returns the <code>int</code> array that backs this buffer.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final int[] array ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -136,7 +225,14 @@ public final int[] array()\n     return backing_buffer;\n   }\n \n-  public final int arrayOffset()\n+  /**\n+   * Returns the offset within this buffer's backing array of the first element.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final int arrayOffset ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -147,41 +243,55 @@ public final int arrayOffset()\n     return array_offset;\n   }\n \n-  public int hashCode()\n+  /**\n+   * Calculates a hash code for this buffer.\n+   */\n+  public int hashCode ()\n   {\n-    return super.hashCode();\n+    // FIXME: Check what SUN calculates here.\n+    return super.hashCode ();\n   }\n \n-  public boolean equals(Object obj)\n+  /**\n+   * Checks if this buffer is equal to obj.\n+   */\n+  public boolean equals (Object obj)\n   {\n     if (obj instanceof IntBuffer)\n       {\n-        return compareTo(obj) == 0;\n+        return compareTo (obj) == 0;\n       }\n \n     return false;\n   }\n \n-  public int compareTo(Object ob)\n+  /**\n+   * Compares two <code>IntBuffer</code> objects.\n+   *\n+   * @exception ClassCastException If obj is not an object derived from\n+   * <code>IntBuffer</code>.\n+   */\n+  public int compareTo (Object obj)\n   {\n-    IntBuffer a = (IntBuffer) ob;\n+    IntBuffer a = (IntBuffer) obj;\n \n-    if (a.remaining() != remaining())\n+    if (a.remaining () != remaining ())\n       return 1;\n \n-    if (! hasArray() ||\n-        ! a.hasArray())\n+    if (! hasArray () ||\n+        ! a.hasArray ())\n       {\n         return 1;\n       }\n \n-    int r = remaining();\n+    int r = remaining ();\n     int i1 = position ();\n     int i2 = a.position ();\n \n-    for (int i=0;i<r;i++)\n+    for (int i = 0; i < r; i++)\n       {\n-        int t = (int) (get(i1)- a.get(i2));\n+        int t = (int) (get (i1) - a.get (i2));\n+\n         if (t != 0)\n           {\n             return (int) t;\n@@ -191,14 +301,74 @@ public int compareTo(Object ob)\n     return 0;\n   }\n \n-  public abstract ByteOrder order();\n-  public abstract int get();\n-  public abstract IntBuffer put(int b);\n-  public abstract int get(int index);\n-  public abstract IntBuffer put(int index, int b);\n-  public abstract IntBuffer compact();\n-  public abstract boolean isDirect();\n-  public abstract IntBuffer slice();\n-  public abstract IntBuffer duplicate();\n-  public abstract IntBuffer asReadOnlyBuffer();\n+  /**\n+   * Returns the byte order of this buffer.\n+   */\n+  public abstract ByteOrder order ();\n+\n+  /**\n+   * Reads the <code>int</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferUnderflowException If there are no remaining\n+   * <code>ints</code> in this buffer.\n+   */\n+  public abstract int get ();\n+\n+  /**\n+   * Writes the <code>int</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferOverflowException If there no remaining \n+   * <code>ints</code> in this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract IntBuffer put (int b);\n+\n+  /**\n+   * Absolute get method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  public abstract int get (int index);\n+  \n+  /**\n+   * Absolute put method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract IntBuffer put (int index, int b);\n+\n+  /**\n+   * Compacts this buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract IntBuffer compact ();\n+\n+  /**\n+   * Tells wether or not this buffer is direct.\n+   */\n+  public abstract boolean isDirect ();\n+\n+  /**\n+   * Creates a new <code>IntBuffer</code> whose content is a shared\n+   * subsequence of this buffer's content.\n+   */\n+  public abstract IntBuffer slice ();\n+\n+  /**\n+   * Creates a new <code>IntBuffer</code> that shares this buffer's\n+   * content.\n+   */\n+  public abstract IntBuffer duplicate ();\n+\n+  /**\n+   * Creates a new read-only <code>IntBuffer</code> that shares this\n+   * buffer's content.\n+   */\n+  public abstract IntBuffer asReadOnlyBuffer ();\n }"}, {"sha": "8808fd5f507ea4026887a08653074d931f5aabc3", "filename": "libjava/java/nio/LongBuffer.java", "status": "modified", "additions": 227, "deletions": 58, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FLongBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FLongBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FLongBuffer.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* LongBuffer.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,93 +39,182 @@\n \n import gnu.java.nio.LongBufferImpl;\n \n-public abstract class LongBuffer extends Buffer implements Comparable\n+/**\n+ * @since 1.4\n+ */\n+public abstract class LongBuffer extends Buffer\n+  implements Comparable\n {\n   int array_offset;\n   long[] backing_buffer;\n \n-  public static LongBuffer allocateDirect(int capacity)\n+  LongBuffer (int capacity, int limit, int position, int mark)\n   {\n-    throw new Error (\"direct buffers not implemented\");\n+    super (capacity, limit, position, mark);\n+    array_offset = 0;\n   }\n \n-  public static LongBuffer allocate(int capacity)\n+  LongBuffer (long[] buffer, int offset, int capacity, int limit, int position, int mark)\n   {\n-    return new LongBufferImpl(capacity, 0, capacity);\n+    super (capacity, limit, position, mark);\n+    this.backing_buffer = buffer;\n+    this.array_offset = offset;\n   }\n \n-  final public static LongBuffer wrap(long[] array, int offset, int length)\n+  /**\n+   * Allocates a new <code>LongBuffer</code> object with a given capacity.\n+   */\n+  public static LongBuffer allocate (int capacity)\n   {\n-    return new LongBufferImpl (array, offset, length);\n+    return new LongBufferImpl (capacity);\n   }\n \n-  final public static LongBuffer wrap(String a)\n+  /**\n+   * Wraps a <code>long</code> array into a <code>LongBuffer</code>\n+   * object.\n+   *\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public static LongBuffer wrap (long[] array, int offset, int length)\n   {\n-    int len = a.length();\n-    long[] buffer = new long[len];\n-\n-    for (int i=0;i<len;i++)\n-      {\n-        buffer[i] = (long) a.charAt(i);\n-      }\n-\n-    return wrap(buffer, 0, len);\n+    return new LongBufferImpl (array, 0, array.length, offset + length, offset, -1, false);\n   }\n \n-  final public static LongBuffer wrap(long[] array)\n+  /**\n+   * Wraps a <code>long</code> array into a <code>LongBuffer</code>\n+   * object.\n+   */\n+  final public static LongBuffer wrap (long[] array)\n   {\n-    return wrap(array, 0, array.length);\n-  }\n-\n-  LongBuffer (int capacity, int limit, int position, int mark)\n-  {\n-    super (capacity, limit, position, mark);\n-    array_offset = 0;\n+    return wrap (array, 0, array.length);\n   }\n   \n+  /**\n+   * This method transfers <code>longs<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The destination array\n+   * @param offset The offset within the array of the first <code>long</code>\n+   * to be written; must be non-negative and no larger than dst.length.\n+   * @param length The maximum number of bytes to be written to the given array;\n+   * must be non-negative and no larger than dst.length - offset.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than length\n+   * <code>longs</code> remaining in this buffer.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold.\n+   */\n   public LongBuffer get (long[] dst, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n       {\n-        dst[i] = get();\n+        dst [i] = get ();\n       }\n \n     return this;\n   }\n \n+  /**\n+   * This method transfers <code>longs<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The byte array to write into.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than dst.length\n+   * <code>longs</code> remaining in this buffer.\n+   */\n   public LongBuffer get (long[] dst)\n   {\n-    return get(dst, 0, dst.length);\n+    return get (dst, 0, dst.length);\n   }\n \n+  /**\n+   * Writes the content of the the <code>LongBUFFER</code> src\n+   * into the buffer.\n+   *\n+   * @param src The source data.\n+   *\n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>longs<code> in the source buffer.\n+   * @exception IllegalArgumentException If the source buffer is this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public LongBuffer put (LongBuffer src)\n   {\n-    while (src.hasRemaining())\n-      put(src.get());\n+    if (src == this)\n+      throw new IllegalArgumentException ();\n+\n+    if (src.remaining () > remaining ())\n+      throw new BufferOverflowException ();\n+\n+    if (src.remaining () > 0)\n+      {\n+        long[] toPut = new long [src.remaining ()];\n+        src.get (toPut);\n+        src.put (toPut);\n+      }\n \n     return this;\n   }\n \n+  /**\n+   * Writes the content of the the <code>long array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * @param offset The offset within the array of the first byte to be read;\n+   * must be non-negative and no larger than src.length.\n+   * @param length The number of bytes to be read from the given array;\n+   * must be non-negative and no larger than src.length - offset.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>longs<code> in the source array.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public LongBuffer put (long[] src, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n-      put(src[i]);\n+      put (src [i]);\n \n     return this;\n   }\n \n-  public final LongBuffer put(long[] src)\n+  /**\n+   * Writes the content of the the <code>long array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>longs<code> in the source array.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public final LongBuffer put (long[] src)\n   {\n-    return put(src, 0, src.length);\n+    return put (src, 0, src.length);\n   }\n \n-  public final boolean hasArray()\n+  /**\n+   * Tells whether ot not this buffer is backed by an accessible\n+   * <code>long</code> array.\n+   */\n+  public final boolean hasArray ()\n   {\n     return (backing_buffer != null\n             && !isReadOnly ());\n   }\n \n-  public final long[] array()\n+  /**\n+   * Returns the <code>long</code> array that backs this buffer.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final long[] array ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -136,7 +225,14 @@ public final long[] array()\n     return backing_buffer;\n   }\n \n-  public final int arrayOffset()\n+  /**\n+   * Returns the offset within this buffer's backing array of the first element.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final int arrayOffset ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -147,41 +243,54 @@ public final int arrayOffset()\n     return array_offset;\n   }\n \n-  public int hashCode()\n+  /**\n+   * Calculates a hash code for this buffer.\n+   */\n+  public int hashCode ()\n   {\n-    return super.hashCode();\n+    // FIXME: Check what SUN calculates here.\n+    return super.hashCode ();\n   }\n \n-  public boolean equals(Object obj)\n+  /**\n+   * Checks if this buffer is equal to obj.\n+   */\n+  public boolean equals (Object obj)\n   {\n     if (obj instanceof LongBuffer)\n       {\n-        return compareTo(obj) == 0;\n+        return compareTo (obj) == 0;\n       }\n \n     return false;\n   }\n \n-  public int compareTo(Object ob)\n+  /**\n+   * Compares two <code>LongBuffer</code> objects.\n+   *\n+   * @exception ClassCastException If obj is not an object derived from\n+   * <code>LongBuffer</code>.\n+   */\n+  public int compareTo (Object obj)\n   {\n-    LongBuffer a = (LongBuffer) ob;\n+    LongBuffer a = (LongBuffer) obj;\n \n-    if (a.remaining() != remaining())\n+    if (a.remaining () != remaining ())\n       return 1;\n \n-    if (! hasArray() ||\n-        ! a.hasArray())\n+    if (! hasArray () ||\n+        ! a.hasArray ())\n       {\n         return 1;\n       }\n \n-    int r = remaining();\n+    int r = remaining ();\n     int i1 = position ();\n     int i2 = a.position ();\n \n-    for (int i=0;i<r;i++)\n+    for (int i = 0; i < r; i++)\n       {\n-        int t = (int) (get(i1)- a.get(i2));\n+        int t = (int) (get (i1) - a.get (i2));\n \n         if (t != 0)\n           {\n@@ -192,14 +301,74 @@ public int compareTo(Object ob)\n     return 0;\n   }\n \n-  public abstract ByteOrder order();\n-  public abstract long get();\n-  public abstract java.nio. LongBuffer put(long b);\n-  public abstract long get(int index);\n-  public abstract java.nio. LongBuffer put(int index, long b);\n-  public abstract LongBuffer compact();\n-  public abstract boolean isDirect();\n-  public abstract LongBuffer slice();\n-  public abstract LongBuffer duplicate();\n-  public abstract LongBuffer asReadOnlyBuffer();\n+  /**\n+   * Returns the byte order of this buffer.\n+   */\n+  public abstract ByteOrder order ();\n+\n+  /**\n+   * Reads the <code>long</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferUnderflowException If there are no remaining\n+   * <code>longs</code> in this buffer.\n+   */\n+  public abstract long get ();\n+\n+  /**\n+   * Writes the <code>long</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferOverflowException If there no remaining \n+   * <code>longs</code> in this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract LongBuffer put (long b);\n+\n+  /**\n+   * Absolute get method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  public abstract long get (int index);\n+  \n+  /**\n+   * Absolute put method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract LongBuffer put (int index, long b);\n+\n+  /**\n+   * Compacts this buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract LongBuffer compact ();\n+\n+  /**\n+   * Tells wether or not this buffer is direct.\n+   */\n+  public abstract boolean isDirect ();\n+\n+  /**\n+   * Creates a new <code>LongBuffer</code> whose content is a shared\n+   * subsequence of this buffer's content.\n+   */\n+  public abstract LongBuffer slice ();\n+\n+  /**\n+   * Creates a new <code>LongBuffer</code> that shares this buffer's\n+   * content.\n+   */\n+  public abstract LongBuffer duplicate ();\n+\n+  /**\n+   * Creates a new read-only <code>LongBuffer</code> that shares this\n+   * buffer's content.\n+   */\n+  public abstract LongBuffer asReadOnlyBuffer ();\n }"}, {"sha": "db14b483b66bb210da8318aca01d8a7ae0d9e53e", "filename": "libjava/java/nio/ShortBuffer.java", "status": "modified", "additions": 226, "deletions": 57, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FShortBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d4669b735c0e6f665e9a83bdd0848e23fc6662/libjava%2Fjava%2Fnio%2FShortBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FShortBuffer.java?ref=36d4669b735c0e6f665e9a83bdd0848e23fc6662", "patch": "@@ -1,5 +1,5 @@\n /* ShortBuffer.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,93 +39,182 @@\n \n import gnu.java.nio.ShortBufferImpl;\n \n-public abstract class ShortBuffer extends Buffer implements Comparable\n+/**\n+ * @since 1.4\n+ */\n+public abstract class ShortBuffer extends Buffer\n+  implements Comparable\n {\n   int array_offset;\n   short[] backing_buffer;\n \n-  public static ShortBuffer allocateDirect(int capacity)\n-  {\n-    throw new Error (\"direct buffers not implemented\");\n-  }\n-\n-  public static ShortBuffer allocate(int capacity)\n+  ShortBuffer (int capacity, int limit, int position, int mark)\n   {\n-    return new ShortBufferImpl(capacity, 0, capacity);\n+    super (capacity, limit, position, mark);\n+    array_offset = 0;\n   }\n \n-  final public static ShortBuffer wrap(short[] array, int offset, int length)\n+  ShortBuffer (short[] buffer, int offset, int capacity, int limit, int position, int mark)\n   {\n-    return new ShortBufferImpl(array, offset, length);\n+    super (capacity, limit, position, mark);\n+    this.backing_buffer = buffer;\n+    this.array_offset = offset;\n   }\n \n-  final public static ShortBuffer wrap(String a)\n+  /**\n+   * Allocates a new <code>ShortBuffer</code> object with a given capacity.\n+   */\n+  public static ShortBuffer allocate (int capacity)\n   {\n-    int len = a.length();\n-    short[] buffer = new short[len];\n-\n-    for (int i=0;i<len;i++)\n-      {\n-        buffer[i] = (short) a.charAt(i);\n-      }\n-\n-    return wrap(buffer, 0, len);\n+    return new ShortBufferImpl (capacity);\n   }\n \n-  final public static ShortBuffer wrap(short[] array)\n+  /**\n+   * Wraps a <code>short</code> array into a <code>ShortBuffer</code>\n+   * object.\n+   *\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   */\n+  final public static ShortBuffer wrap (short[] array, int offset, int length)\n   {\n-    return wrap(array, 0, array.length);\n+    return new ShortBufferImpl (array, 0, array.length, offset + length, offset, -1, false);\n   }\n \n-  ShortBuffer (int capacity, int limit, int position, int mark)\n+  /**\n+   * Wraps a <code>short</code> array into a <code>ShortBuffer</code>\n+   * object.\n+   */\n+  final public static ShortBuffer wrap (short[] array)\n   {\n-    super (capacity, limit, position, mark);\n-    array_offset = 0;\n+    return wrap (array, 0, array.length);\n   }\n   \n+  /**\n+   * This method transfers <code>shorts<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The destination array\n+   * @param offset The offset within the array of the first <code>short</code>\n+   * to be written; must be non-negative and no larger than dst.length.\n+   * @param length The maximum number of bytes to be written to the given array;\n+   * must be non-negative and no larger than dst.length - offset.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than length\n+   * <code>shorts</code> remaining in this buffer.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold.\n+   */\n   public ShortBuffer get (short[] dst, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n       {\n-        dst[i] = get();\n+        dst [i] = get ();\n       }\n \n     return this;\n   }\n \n+  /**\n+   * This method transfers <code>shorts<code> from this buffer into the given\n+   * destination array.\n+   *\n+   * @param dst The byte array to write into.\n+   *\n+   * @exception BufferUnderflowException If there are fewer than dst.length\n+   * <code>shorts</code> remaining in this buffer.\n+   */\n   public ShortBuffer get (short[] dst)\n   {\n-    return get(dst, 0, dst.length);\n+    return get (dst, 0, dst.length);\n   }\n \n+  /**\n+   * Writes the content of the the <code>ShortBUFFER</code> src\n+   * into the buffer.\n+   *\n+   * @param src The source data.\n+   *\n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>shorts<code> in the source buffer.\n+   * @exception IllegalArgumentException If the source buffer is this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public ShortBuffer put (ShortBuffer src)\n   {\n-    while (src.hasRemaining())\n-      put(src.get());\n+    if (src == this)\n+      throw new IllegalArgumentException ();\n+\n+    if (src.remaining () > remaining ())\n+      throw new BufferOverflowException ();\n+\n+    if (src.remaining () > 0)\n+      {\n+        short[] toPut = new short [src.remaining ()];\n+        src.get (toPut);\n+        src.put (toPut);\n+      }\n \n     return this;\n   }\n \n+  /**\n+   * Writes the content of the the <code>short array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * @param offset The offset within the array of the first byte to be read;\n+   * must be non-negative and no larger than src.length.\n+   * @param length The number of bytes to be read from the given array;\n+   * must be non-negative and no larger than src.length - offset.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>shorts<code> in the source array.\n+   * @exception IndexOutOfBoundsException If the preconditions on the offset\n+   * and length parameters do not hold\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n   public ShortBuffer put (short[] src, int offset, int length)\n   {\n     for (int i = offset; i < offset + length; i++)\n-      put(src[i]);\n+      put (src [i]);\n \n     return this;\n   }\n \n-  public final ShortBuffer put(short[] src)\n+  /**\n+   * Writes the content of the the <code>short array</code> src\n+   * into the buffer.\n+   *\n+   * @param src The array to copy into the buffer.\n+   * \n+   * @exception BufferOverflowException If there is insufficient space in this\n+   * buffer for the remaining <code>shorts<code> in the source array.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public final ShortBuffer put (short[] src)\n   {\n-    return put(src, 0, src.length);\n+    return put (src, 0, src.length);\n   }\n \n-  public final boolean hasArray()\n+  /**\n+   * Tells whether ot not this buffer is backed by an accessible\n+   * <code>short</code> array.\n+   */\n+  public final boolean hasArray ()\n   {\n     return (backing_buffer != null\n             && !isReadOnly ());\n   }\n \n-  public final short[] array()\n+  /**\n+   * Returns the <code>short</code> array that backs this buffer.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final short[] array ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -136,7 +225,14 @@ public final short[] array()\n     return backing_buffer;\n   }\n \n-  public final int arrayOffset()\n+  /**\n+   * Returns the offset within this buffer's backing array of the first element.\n+   *\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   * @exception UnsupportedOperationException If this buffer is not backed\n+   * by an accessible array.\n+   */\n+  public final int arrayOffset ()\n   {\n     if (backing_buffer == null)\n       throw new UnsupportedOperationException ();\n@@ -147,41 +243,54 @@ public final int arrayOffset()\n     return array_offset;\n   }\n \n-  public int hashCode()\n+  /**\n+   * Calculates a hash code for this buffer.\n+   */\n+  public int hashCode ()\n   {\n-    return super.hashCode();\n+    // FIXME: Check what SUN calculates here.\n+    return super.hashCode ();\n   }\n \n-  public boolean equals(Object obj)\n+  /**\n+   * Checks if this buffer is equal to obj.\n+   */\n+  public boolean equals (Object obj)\n   {\n     if (obj instanceof ShortBuffer)\n       {\n-        return compareTo(obj) == 0;\n+        return compareTo (obj) == 0;\n       }\n \n     return false;\n   }\n \n-  public int compareTo(Object ob)\n+  /**\n+   * Compares two <code>ShortBuffer</code> objects.\n+   *\n+   * @exception ClassCastException If obj is not an object derived from\n+   * <code>ShortBuffer</code>.\n+   */\n+  public int compareTo (Object obj)\n   {\n-    ShortBuffer a = (ShortBuffer) ob;\n+    ShortBuffer a = (ShortBuffer) obj;\n \n-    if (a.remaining() != remaining())\n+    if (a.remaining () != remaining ())\n       return 1;\n \n-    if (! hasArray() ||\n-        ! a.hasArray())\n+    if (! hasArray () ||\n+        ! a.hasArray ())\n       {\n         return 1;\n       }\n \n-    int r = remaining();\n+    int r = remaining ();\n     int i1 = position ();\n     int i2 = a.position ();\n \n-    for (int i=0;i<r;i++)\n+    for (int i = 0; i < r; i++)\n       {\n-        int t = (int) (get(i1)- a.get(i2));\n+        int t = (int) (get (i1) - a.get (i2));\n \n         if (t != 0)\n           {\n@@ -192,14 +301,74 @@ public int compareTo(Object ob)\n     return 0;\n   }\n \n+  /**\n+   * Returns the byte order of this buffer.\n+   */\n   public abstract ByteOrder order ();\n-  public abstract short get();\n-  public abstract java.nio. ShortBuffer put(short b);\n-  public abstract short get(int index);\n-  public abstract java.nio. ShortBuffer put(int index, short b);\n-  public abstract ShortBuffer compact();\n-  public abstract boolean isDirect();\n-  public abstract ShortBuffer slice();\n-  public abstract ShortBuffer duplicate();\n-  public abstract ShortBuffer asReadOnlyBuffer();\n+\n+  /**\n+   * Reads the <code>short</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferUnderflowException If there are no remaining\n+   * <code>shorts</code> in this buffer.\n+   */\n+  public abstract short get ();\n+\n+  /**\n+   * Writes the <code>short</code> at this buffer's current position,\n+   * and then increments the position.\n+   *\n+   * @exception BufferOverflowException If there no remaining \n+   * <code>shorts</code> in this buffer.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract ShortBuffer put (short b);\n+\n+  /**\n+   * Absolute get method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   */\n+  public abstract short get (int index);\n+  \n+  /**\n+   * Absolute put method.\n+   *\n+   * @exception IndexOutOfBoundsException If index is negative or not smaller\n+   * than the buffer's limit.\n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract ShortBuffer put (int index, short b);\n+\n+  /**\n+   * Compacts this buffer.\n+   * \n+   * @exception ReadOnlyBufferException If this buffer is read-only.\n+   */\n+  public abstract ShortBuffer compact ();\n+\n+  /**\n+   * Tells wether or not this buffer is direct.\n+   */\n+  public abstract boolean isDirect ();\n+\n+  /**\n+   * Creates a new <code>ShortBuffer</code> whose content is a shared\n+   * subsequence of this buffer's content.\n+   */\n+  public abstract ShortBuffer slice ();\n+\n+  /**\n+   * Creates a new <code>ShortBuffer</code> that shares this buffer's\n+   * content.\n+   */\n+  public abstract ShortBuffer duplicate ();\n+\n+  /**\n+   * Creates a new read-only <code>ShortBuffer</code> that shares this\n+   * buffer's content.\n+   */\n+  public abstract ShortBuffer asReadOnlyBuffer ();\n }"}]}