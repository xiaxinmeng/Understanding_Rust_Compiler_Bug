{"sha": "c63f5a428cc7b15651e076b291e1a72c36d74618", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYzZjVhNDI4Y2M3YjE1NjUxZTA3NmIyOTFlMWE3MmMzNmQ3NDYxOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-25T18:19:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-25T18:19:09Z"}, "message": "re PR middle-end/19609 (real and imaginary part interchanged when flags_complex_divide_method=1)\n\n        PR middle-end/19609\n        * tree-complex.c (expand_complex_div_wide): Use the correct formulae.\n\nFrom-SVN: r94222", "tree": {"sha": "0adf1f694dd9d4b5548652af20e1700291398272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0adf1f694dd9d4b5548652af20e1700291398272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c63f5a428cc7b15651e076b291e1a72c36d74618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63f5a428cc7b15651e076b291e1a72c36d74618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c63f5a428cc7b15651e076b291e1a72c36d74618", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63f5a428cc7b15651e076b291e1a72c36d74618/comments", "author": null, "committer": null, "parents": [{"sha": "52e6723c6ced471d8dd44b9072e8a3ff65c28013", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e6723c6ced471d8dd44b9072e8a3ff65c28013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e6723c6ced471d8dd44b9072e8a3ff65c28013"}], "stats": {"total": 160, "additions": 101, "deletions": 59}, "files": [{"sha": "2648c68785d024d221993659a852792a80b08ad1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63f5a428cc7b15651e076b291e1a72c36d74618/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63f5a428cc7b15651e076b291e1a72c36d74618/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c63f5a428cc7b15651e076b291e1a72c36d74618", "patch": "@@ -1,3 +1,8 @@\n+2005-01-25  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/19609\n+\t* tree-complex.c (expand_complex_div_wide): Use the correct formulae.\n+\n 2005-01-25  Roger Sayle  <roger@eyesopen.com>\n \n \t* expmed.c (choose_multiplier): Change interface to return the"}, {"sha": "3373326aad9190355b1a0fc84738cd8b9751a056", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 96, "deletions": 59, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c63f5a428cc7b15651e076b291e1a72c36d74618/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c63f5a428cc7b15651e076b291e1a72c36d74618/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=c63f5a428cc7b15651e076b291e1a72c36d74618", "patch": "@@ -169,45 +169,36 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n \t\t\t tree ar, tree ai, tree br, tree bi,\n \t\t\t enum tree_code code)\n {\n-  tree rr, ri, ratio, div, t1, t2, min, max, cond;\n+  tree rr, ri, ratio, div, t1, t2, tr, ti, cond;\n+  basic_block bb_cond, bb_true, bb_false, bb_join;\n \n   /* Examine |br| < |bi|, and branch.  */\n   t1 = gimplify_build1 (bsi, ABS_EXPR, inner_type, br);\n   t2 = gimplify_build1 (bsi, ABS_EXPR, inner_type, bi);\n   cond = fold (build (LT_EXPR, boolean_type_node, t1, t2));\n   STRIP_NOPS (cond);\n \n-  if (TREE_CONSTANT (cond))\n+  bb_cond = bb_true = bb_false = bb_join = NULL;\n+  rr = ri = tr = ti = NULL;\n+  if (!TREE_CONSTANT (cond))\n     {\n-      if (integer_zerop (cond))\n-\tmin = bi, max = br;\n-      else\n-\tmin = br, max = bi;\n-    }\n-  else\n-    {\n-      basic_block bb_cond, bb_true, bb_false, bb_join;\n-      tree l1, l2, l3;\n       edge e;\n \n-      l1 = create_artificial_label ();\n-      t1 = build (GOTO_EXPR, void_type_node, l1);\n-      l2 = create_artificial_label ();\n-      t2 = build (GOTO_EXPR, void_type_node, l2);\n-      cond = build (COND_EXPR, void_type_node, cond, t1, t2);\n+      cond = build (COND_EXPR, void_type_node, cond, NULL, NULL);\n       bsi_insert_before (bsi, cond, BSI_SAME_STMT);\n \n-      min = make_rename_temp (inner_type, NULL);\n-      max = make_rename_temp (inner_type, NULL);\n-      l3 = create_artificial_label ();\n-\n       /* Split the original block, and create the TRUE and FALSE blocks.  */\n       e = split_block (bsi->bb, cond);\n       bb_cond = e->src;\n       bb_join = e->dest;\n       bb_true = create_empty_bb (bb_cond);\n       bb_false = create_empty_bb (bb_true);\n \n+      t1 = build (GOTO_EXPR, void_type_node, tree_block_label (bb_true));\n+      t2 = build (GOTO_EXPR, void_type_node, tree_block_label (bb_false));\n+      COND_EXPR_THEN (cond) = t1;\n+      COND_EXPR_ELSE (cond) = t2;\n+\n       /* Wire the blocks together.  */\n       e->flags = EDGE_TRUE_VALUE;\n       redirect_edge_succ (e, bb_true);\n@@ -223,46 +214,92 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n           set_immediate_dominator (CDI_DOMINATORS, bb_false, bb_cond);\n         }\n \n-      /* Compute min and max for TRUE block.  */\n-      *bsi = bsi_start (bb_true);\n-      t1 = build (LABEL_EXPR, void_type_node, l1);\n-      bsi_insert_after (bsi, t1, BSI_NEW_STMT);\n-      t1 = build (MODIFY_EXPR, inner_type, min, br);\n-      bsi_insert_after (bsi, t1, BSI_NEW_STMT);\n-      t1 = build (MODIFY_EXPR, inner_type, max, bi);\n-      bsi_insert_after (bsi, t1, BSI_NEW_STMT);\n-\n-      /* Compute min and max for FALSE block.  */\n-      *bsi = bsi_start (bb_false);\n-      t1 = build (LABEL_EXPR, void_type_node, l2);\n-      bsi_insert_after (bsi, t1, BSI_NEW_STMT);\n-      t1 = build (MODIFY_EXPR, inner_type, min, bi);\n-      bsi_insert_after (bsi, t1, BSI_NEW_STMT);\n-      t1 = build (MODIFY_EXPR, inner_type, max, br);\n-      bsi_insert_after (bsi, t1, BSI_NEW_STMT);\n-\n-      /* Insert the join label into the tail of the original block.  */\n-      *bsi = bsi_start (bb_join);\n-      t1 = build (LABEL_EXPR, void_type_node, l3);\n-      bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n+      rr = make_rename_temp (inner_type, NULL);\n+      ri = make_rename_temp (inner_type, NULL);\n     }\n-  \n-  /* Now we have MIN(|br|, |bi|) and MAX(|br|, |bi|).  We now use the\n-     ratio min/max to scale both the dividend and divisor.  */\n-  ratio = gimplify_build2 (bsi, code, inner_type, min, max);\n-\n-  /* Calculate the divisor: min*ratio + max.  */\n-  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, min, ratio);\n-  div = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, max);\n-\n-  /* Result is now ((ar + ai*ratio)/div) + i((ai - ar*ratio)/div).  */\n-  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, ratio);\n-  t2 = gimplify_build2 (bsi, PLUS_EXPR, inner_type, ar, t1);\n-  rr = gimplify_build2 (bsi, code, inner_type, t2, div);\n-\n-  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, ratio);\n-  t2 = gimplify_build2 (bsi, MINUS_EXPR, inner_type, ai, t1);\n-  ri = gimplify_build2 (bsi, code, inner_type, t2, div);\n+\n+  /* In the TRUE branch, we compute\n+      ratio = br/bi;\n+      div = (br * ratio) + bi;\n+      tr = (ar * ratio) + ai;\n+      ti = (ai * ratio) - ar;\n+      tr = tr / div;\n+      ti = ti / div;  */\n+  if (bb_true || integer_nonzerop (cond))\n+    {\n+      if (bb_true)\n+\t{\n+\t  *bsi = bsi_last (bb_true);\n+\t  bsi_insert_after (bsi, build_empty_stmt (), BSI_NEW_STMT);\n+\t}\n+\n+      ratio = gimplify_build2 (bsi, code, inner_type, br, bi);\n+\n+      t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, br, ratio);\n+      div = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, bi);\n+\n+      t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, ratio);\n+      tr = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, ai);\n+\n+      t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, ratio);\n+      ti = gimplify_build2 (bsi, MINUS_EXPR, inner_type, t1, ar);\n+\n+      tr = gimplify_build2 (bsi, code, inner_type, tr, div);\n+      ti = gimplify_build2 (bsi, code, inner_type, ti, div);\n+\n+     if (bb_true)\n+       {\n+\t t1 = build (MODIFY_EXPR, inner_type, rr, tr);\n+\t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n+\t t1 = build (MODIFY_EXPR, inner_type, ri, ti);\n+\t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n+\t bsi_remove (bsi);\n+       }\n+    }\n+\n+  /* In the FALSE branch, we compute\n+      ratio = d/c;\n+      divisor = (d * ratio) + c;\n+      tr = (b * ratio) + a;\n+      ti = b - (a * ratio);\n+      tr = tr / div;\n+      ti = ti / div;  */\n+  if (bb_false || integer_zerop (cond))\n+    {\n+      if (bb_false)\n+\t{\n+\t  *bsi = bsi_last (bb_false);\n+\t  bsi_insert_after (bsi, build_empty_stmt (), BSI_NEW_STMT);\n+\t}\n+\n+      ratio = gimplify_build2 (bsi, code, inner_type, bi, br);\n+\n+      t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, bi, ratio);\n+      div = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, br);\n+\n+      t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, ratio);\n+      tr = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, ar);\n+\n+      t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, ratio);\n+      ti = gimplify_build2 (bsi, MINUS_EXPR, inner_type, ai, t1);\n+\n+      tr = gimplify_build2 (bsi, code, inner_type, tr, div);\n+      ti = gimplify_build2 (bsi, code, inner_type, ti, div);\n+\n+     if (bb_false)\n+       {\n+\t t1 = build (MODIFY_EXPR, inner_type, rr, tr);\n+\t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n+\t t1 = build (MODIFY_EXPR, inner_type, ri, ti);\n+\t bsi_insert_before (bsi, t1, BSI_SAME_STMT);\n+\t bsi_remove (bsi);\n+       }\n+    }\n+\n+  if (bb_join)\n+    *bsi = bsi_start (bb_join);\n+  else\n+    rr = tr, ri = ti;\n \n   update_complex_assignment (bsi, rr, ri);\n }"}]}