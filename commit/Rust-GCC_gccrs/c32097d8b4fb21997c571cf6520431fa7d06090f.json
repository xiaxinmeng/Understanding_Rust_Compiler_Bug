{"sha": "c32097d8b4fb21997c571cf6520431fa7d06090f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMyMDk3ZDhiNGZiMjE5OTdjNTcxY2Y2NTIwNDMxZmE3ZDA2MDkwZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-07-16T20:36:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-07-16T20:36:10Z"}, "message": "re PR libstdc++/37907 ([c++0x] support for std::is_standard_layout)\n\n\tPR libstdc++/37907\n\tSupport std::is_standard_layout and std::is_trivial traits,\n\tchange POD to C++0x version (except for layout).\n\t* gcc/c-common.c (c_common_reswords): Add __is_standard_layout\n\tand __is_trivial.\n\t* gcc/c-common.h (enum rid): Add RID_IS_STD_LAYOUT and RID_IS_TRIVIAL.\n\t* gcc/cp/cp-tree.h (enum cp_trait_kind): Add CPTK_IS_STD_LAYOUT,\n\tCPTK_IS_TRIVIAL.\n\t(struct lang_type_class): Add non_std_layout.\n\t(CLASSTYPE_NON_STD_LAYOUT): New.\n\t* gcc/cp/class.c (check_bases): Set it.\n\t(check_field_decls): Likewise.\n\t(check_bases_and_members): Likewise.\n\t* gcc/cp/parser.c (cp_parser_primary_expression): Handle RID_IS_STD_LAYOUT,\n\tRID_IS_TRIVIAL.\n\t(cp_parser_trait_expr): Likewise.\n\t* gcc/cp/semantics.c (trait_expr_value): Handle CPTK_IS_STD_LAYOUT,\n\tCPTK_IS_TRIVIAL.\n\t(finish_trait_expr): Likewise.\n\t* gcc/cp/tree.c (scalarish_type_p, trivial_type_p, std_layout_type_p): New.\n\t(pod_type_p): Use them.\n\t* gcc/cp/typeck.c (build_class_member_access_expr): Check\n\tCLASSTYPE_NON_STD_LAYOUT rather than CLASSTYPE_NON_POD_P.\n\t* libstdc++-v3/include/std/type_traits: Add is_standard_layout, is_trivial.\n\nFrom-SVN: r149721", "tree": {"sha": "100c59a1743caa8ea59faa87406fd5f529be94f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/100c59a1743caa8ea59faa87406fd5f529be94f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c32097d8b4fb21997c571cf6520431fa7d06090f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c32097d8b4fb21997c571cf6520431fa7d06090f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c32097d8b4fb21997c571cf6520431fa7d06090f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c32097d8b4fb21997c571cf6520431fa7d06090f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3c5a40978985447d8ccf7d583929a4e8a78a91d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c5a40978985447d8ccf7d583929a4e8a78a91d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3c5a40978985447d8ccf7d583929a4e8a78a91d"}], "stats": {"total": 712, "additions": 597, "deletions": 115}, "files": [{"sha": "28ff1631d65056f2c06765a03f7ce9088bdb7083", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -1,3 +1,12 @@\n+2009-07-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR libstdc++/37907\n+\t* c-common.c (c_common_reswords): Add __is_standard_layout\n+\tand __is_trivial.\n+\t* c-common.h (enum rid): Add RID_IS_STD_LAYOUT and RID_IS_TRIVIAL.\n+\t* doc/implement-cxx.texi: New.\n+\t* doc/gcc.texi: Include it.\n+\n 2009-07-16  DJ Delorie  <dj@redhat.com>\n \n \t* config/m32c/m32c.c (m32c_compare_redundant): Avoid removing"}, {"sha": "18f25d5529a0e222385b5e8bd53ac2241c1f00e6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -3777,7 +3777,7 @@ TEXI_GCC_FILES = gcc.texi gcc-common.texi gcc-vers.texi frontends.texi\t\\\n \t gcov.texi trouble.texi bugreport.texi service.texi\t\t\\\n \t contribute.texi compat.texi funding.texi gnu.texi gpl_v3.texi\t\\\n \t fdl.texi contrib.texi cppenv.texi cppopts.texi\t\t\t\\\n-\t implement-c.texi arm-neon-intrinsics.texi\n+\t implement-c.texi implement-cxx.texi arm-neon-intrinsics.texi\n \n TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi\t\t\\\n \t contribute.texi makefile.texi configterms.texi options.texi\t\\"}, {"sha": "069452cd1984f7fecb46e01501ada4b00ef9d3ec", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -598,6 +598,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__is_enum\",\tRID_IS_ENUM,\tD_CXXONLY },\n   { \"__is_pod\",\t\tRID_IS_POD,\tD_CXXONLY },\n   { \"__is_polymorphic\",\tRID_IS_POLYMORPHIC, D_CXXONLY },\n+  { \"__is_standard_layout\", RID_IS_STD_LAYOUT, D_CXXONLY },\n+  { \"__is_trivial\",     RID_IS_TRIVIAL, D_CXXONLY },\n   { \"__is_union\",\tRID_IS_UNION,\tD_CXXONLY },\n   { \"__imag\",\t\tRID_IMAGPART,\t0 },\n   { \"__imag__\",\t\tRID_IMAGPART,\t0 },"}, {"sha": "ec5705e6ed8f3e135c42f50b60412f9d3be25a05", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -110,6 +110,7 @@ enum rid\n   RID_IS_CONVERTIBLE_TO,       RID_IS_CLASS,\n   RID_IS_EMPTY,                RID_IS_ENUM,\n   RID_IS_POD,                  RID_IS_POLYMORPHIC,\n+  RID_IS_STD_LAYOUT,           RID_IS_TRIVIAL,\n   RID_IS_UNION,\n \n   /* C++0x */"}, {"sha": "81cc8e0f64623dbfee25bf5ec1ea18dd394aba5c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -1,3 +1,37 @@\n+2009-07-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR libstdc++/37907\n+\tSplit POD into \"standard-layout\" and \"trivial\" as per N2230,\n+\tSupport std::is_standard_layout and std::is_trivial traits.\n+\t* cp-tree.h (enum cp_trait_kind): Add CPTK_IS_STD_LAYOUT,\n+\tCPTK_IS_TRIVIAL.\n+\t(struct lang_type_class): Add non_std_layout.\n+\t(CLASSTYPE_NON_STD_LAYOUT): New.\n+\t* class.c (check_bases): Set it.\n+\t(check_field_decls): Likewise.\n+\t(check_bases_and_members): Likewise.\n+\t* parser.c (cp_parser_primary_expression): Handle RID_IS_STD_LAYOUT,\n+\tRID_IS_TRIVIAL.\n+\t(cp_parser_trait_expr): Likewise.\n+\t* semantics.c (trait_expr_value): Handle CPTK_IS_STD_LAYOUT,\n+\tCPTK_IS_TRIVIAL.\n+\t(finish_trait_expr): Likewise.\n+\t* tree.c (scalarish_type_p, trivial_type_p, std_layout_type_p): New.\n+\t(pod_type_p): Use them.\n+\t(type_has_nontrivial_copy_init, type_has_nontrivial_default_init): New.\n+\n+\tAdjust bits of the language that no longer refer to POD types.\n+\t* call.c (convert_arg_to_ellipsis): Use type_has_nontrivial_copy_init\n+\tand TYPE_HAS_NONTRIVIAL_DESTRUCTOR rather than pod_type_p.\n+\t(build_x_va_arg): Likewise.\n+\t(call_builtin_trap): Remove.\n+\t* decl.c (declare_local_label): Use type_has_nontrivial_default_init\n+\tand TYPE_HAS_NONTRIVIAL_DESTRUCTOR rather than pod_type_p.\n+\t(cp_finish_decl): Likewise.\n+\t(check_previous_goto_1, check_goto): Adjust error.\n+\t* typeck.c (build_class_member_access_expr): Check\n+\tCLASSTYPE_NON_STD_LAYOUT rather than CLASSTYPE_NON_POD_P.\n+\n 2009-07-14  Taras Glek  <tglek@mozilla.com>\n \t    Rafael Espindola  <espindola@google.com>\n "}, {"sha": "6a7a1b861a03ea8bb64153fc6b98066adc1e35ce", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -197,7 +197,6 @@ static conversion *direct_reference_binding (tree, conversion *);\n static bool promoted_arithmetic_type_p (tree);\n static conversion *conditional_conversion (tree, tree);\n static char *name_as_c_string (tree, tree, bool *);\n-static tree call_builtin_trap (void);\n static tree prep_operand (tree);\n static void add_candidates (tree, const VEC(tree,gc) *, tree, bool, tree, tree,\n \t\t\t    int, struct z_candidate **);\n@@ -5042,18 +5041,6 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n   return expr;\n }\n \n-/* Build a call to __builtin_trap.  */\n-\n-static tree\n-call_builtin_trap (void)\n-{\n-  tree fn = implicit_built_in_decls[BUILT_IN_TRAP];\n-\n-  gcc_assert (fn != NULL);\n-  fn = build_call_n (fn, 0);\n-  return fn;\n-}\n-\n /* ARG is being passed to a varargs function.  Perform any conversions\n    required.  Return the converted value.  */\n \n@@ -5082,20 +5069,23 @@ convert_arg_to_ellipsis (tree arg)\n   arg = require_complete_type (arg);\n \n   if (arg != error_mark_node\n-      && !pod_type_p (TREE_TYPE (arg)))\n+      && (type_has_nontrivial_copy_init (TREE_TYPE (arg))\n+\t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (arg))))\n     {\n-      /* Undefined behavior [expr.call] 5.2.2/7.  We used to just warn\n-\t here and do a bitwise copy, but now cp_expr_size will abort if we\n-\t try to do that.\n+      /* [expr.call] 5.2.2/7:\n+\t Passing a potentially-evaluated argument of class type (Clause 9)\n+\t with a non-trivial copy constructor or a non-trivial destructor\n+\t with no corresponding parameter is conditionally-supported, with\n+\t implementation-defined semantics.\n+\n+\t We used to just warn here and do a bitwise copy, but now\n+\t cp_expr_size will abort if we try to do that.\n+\n \t If the call appears in the context of a sizeof expression,\n-\t there is no need to emit a warning, since the expression won't be\n-\t evaluated. We keep the builtin_trap just as a safety check.  */\n+\t it is not potentially-evaluated.  */\n       if (cp_unevaluated_operand == 0)\n-\twarning (0, \"cannot pass objects of non-POD type %q#T through %<...%>; \"\n-\t\t \"call will abort at runtime\", TREE_TYPE (arg));\n-      arg = call_builtin_trap ();\n-      arg = build2 (COMPOUND_EXPR, integer_type_node, arg,\n-\t\t    integer_zero_node);\n+\terror (\"cannot pass objects of non-trivially-copyable \"\n+\t       \"type %q#T through %<...%>\", TREE_TYPE (arg));\n     }\n \n   return arg;\n@@ -5114,16 +5104,16 @@ build_x_va_arg (tree expr, tree type)\n   if (expr == error_mark_node || !type)\n     return error_mark_node;\n \n-  if (! pod_type_p (type))\n+  if (type_has_nontrivial_copy_init (type)\n+      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+      || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       /* Remove reference types so we don't ICE later on.  */\n       tree type1 = non_reference (type);\n-      /* Undefined behavior [expr.call] 5.2.2/7.  */\n-      warning (0, \"cannot receive objects of non-POD type %q#T through %<...%>; \"\n-\t       \"call will abort at runtime\", type);\n+      /* conditionally-supported behavior [expr.call] 5.2.2/7.  */\n+      error (\"cannot receive objects of non-trivially-copyable type %q#T \"\n+\t     \"through %<...%>; \", type);\n       expr = convert (build_pointer_type (type1), null_node);\n-      expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr),\n-\t\t     call_builtin_trap (), expr);\n       expr = cp_build_indirect_ref (expr, NULL, tf_warning_or_error);\n       return expr;\n     }"}, {"sha": "373f45781905ce4e40e981523bb1daba94c21d9c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -1248,9 +1248,15 @@ check_bases (tree t,\n   int seen_non_virtual_nearly_empty_base_p;\n   tree base_binfo;\n   tree binfo;\n+  tree field = NULL_TREE;\n \n   seen_non_virtual_nearly_empty_base_p = 0;\n \n+  if (!CLASSTYPE_NON_STD_LAYOUT (t))\n+    for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+      if (TREE_CODE (field) == FIELD_DECL)\n+\tbreak;\n+\n   for (binfo = TYPE_BINFO (t), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n@@ -1305,6 +1311,36 @@ check_bases (tree t,\n       CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t)\n \t|= CLASSTYPE_CONTAINS_EMPTY_CLASS_P (basetype);\n       TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_HAS_COMPLEX_DFLT (basetype);      \n+\n+      /*  A standard-layout class is a class that:\n+\t  ...\n+\t  * has no non-standard-layout base classes,  */\n+      CLASSTYPE_NON_STD_LAYOUT (t) |= CLASSTYPE_NON_STD_LAYOUT (basetype);\n+      if (!CLASSTYPE_NON_STD_LAYOUT (t))\n+\t{\n+\t  tree basefield;\n+\t  /* ...has no base classes of the same type as the first non-static\n+\t     data member...  */\n+\t  if (field && DECL_CONTEXT (field) == t\n+\t      && (same_type_ignoring_top_level_qualifiers_p\n+\t\t  (TREE_TYPE (field), basetype)))\n+\t    CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n+\t  else\n+\t    /* ...either has no non-static data members in the most-derived\n+\t       class and at most one base class with non-static data\n+\t       members, or has no base classes with non-static data\n+\t       members */\n+\t    for (basefield = TYPE_FIELDS (basetype); basefield;\n+\t\t basefield = TREE_CHAIN (basefield))\n+\t      if (TREE_CODE (basefield) == FIELD_DECL)\n+\t\t{\n+\t\t  if (field)\n+\t\t    CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n+\t\t  else\n+\t\t    field = basefield;\n+\t\t  break;\n+\t\t}\n+\t}\n     }\n }\n \n@@ -2870,6 +2906,7 @@ check_field_decls (tree t, tree *access_decls,\n   bool has_pointers;\n   int any_default_members;\n   int cant_pack = 0;\n+  int field_access = -1;\n \n   /* Assume there are no access declarations.  */\n   *access_decls = NULL_TREE;\n@@ -2883,6 +2920,7 @@ check_field_decls (tree t, tree *access_decls,\n     {\n       tree x = *field;\n       tree type = TREE_TYPE (x);\n+      int this_field_access;\n \n       next = &TREE_CHAIN (x);\n \n@@ -2957,10 +2995,21 @@ check_field_decls (tree t, tree *access_decls,\n       if (TREE_PRIVATE (x) || TREE_PROTECTED (x))\n \tCLASSTYPE_NON_AGGREGATE (t) = 1;\n \n+      /* A standard-layout class is a class that:\n+\t ...\n+\t has the same access control (Clause 11) for all non-static data members,\n+         ...  */\n+      this_field_access = TREE_PROTECTED (x) ? 1 : TREE_PRIVATE (x) ? 2 : 0;\n+      if (field_access == -1)\n+\tfield_access = this_field_access;\n+      else if (this_field_access != field_access)\n+\tCLASSTYPE_NON_STD_LAYOUT (t) = 1;\n+\n       /* If this is of reference type, check if it needs an init.  */\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \t{\n-\t  CLASSTYPE_NON_POD_P (t) = 1;\n+\t  CLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n+\t  CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n \t  if (DECL_INITIAL (x) == NULL_TREE)\n \t    SET_CLASSTYPE_REF_FIELDS_NEED_INIT (t, 1);\n \n@@ -2975,7 +3024,7 @@ check_field_decls (tree t, tree *access_decls,\n \n       if (TYPE_PACKED (t))\n \t{\n-\t  if (!pod_type_p (type) && !TYPE_PACKED (type))\n+\t  if (!layout_pod_type_p (type) && !TYPE_PACKED (type))\n \t    {\n \t      warning\n \t\t(0,\n@@ -3024,10 +3073,13 @@ check_field_decls (tree t, tree *access_decls,\n       if (DECL_MUTABLE_P (x) || TYPE_HAS_MUTABLE_P (type))\n \tCLASSTYPE_HAS_MUTABLE (t) = 1;\n \n-      if (! pod_type_p (type))\n+      if (! layout_pod_type_p (type))\n \t/* DR 148 now allows pointers to members (which are POD themselves),\n \t   to be allowed in POD structs.  */\n-\tCLASSTYPE_NON_POD_P (t) = 1;\n+\tCLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n+\n+      if (!std_layout_type_p (type))\n+\tCLASSTYPE_NON_STD_LAYOUT (t) = 1;\n \n       if (! zero_init_p (type))\n \tCLASSTYPE_NON_ZERO_INIT_P (t) = 1;\n@@ -4280,7 +4332,7 @@ type_requires_array_cookie (tree type)\n /* Check the validity of the bases and members declared in T.  Add any\n    implicitly-generated functions (like copy-constructors and\n    assignment operators).  Compute various flag bits (like\n-   CLASSTYPE_NON_POD_T) for T.  This routine works purely at the C++\n+   CLASSTYPE_NON_LAYOUT_POD_T) for T.  This routine works purely at the C++\n    level: i.e., independently of the ABI in use.  */\n \n static void\n@@ -4346,9 +4398,12 @@ check_bases_and_members (tree t)\n      elsewhere.  */\n   CLASSTYPE_NON_AGGREGATE (t)\n     |= (type_has_user_provided_constructor (t) || TYPE_POLYMORPHIC_P (t));\n-  CLASSTYPE_NON_POD_P (t)\n+  /* This is the C++98/03 definition of POD; it changed in C++0x, but we\n+     retain the old definition internally for ABI reasons.  */\n+  CLASSTYPE_NON_LAYOUT_POD_P (t)\n     |= (CLASSTYPE_NON_AGGREGATE (t)\n \t|| saved_nontrivial_dtor || saved_complex_asn_ref);\n+  CLASSTYPE_NON_STD_LAYOUT (t) |= TYPE_CONTAINS_VPTR_P (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_CONTAINS_VPTR_P (t);\n   TYPE_HAS_COMPLEX_DFLT (t) |= TYPE_CONTAINS_VPTR_P (t);\n \n@@ -5031,7 +5086,7 @@ layout_class_type (tree t, tree *virtuals_p)\n   /* Create the version of T used for virtual bases.  We do not use\n      make_class_type for this version; this is an artificial type.  For\n      a POD type, we just reuse T.  */\n-  if (CLASSTYPE_NON_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n+  if (CLASSTYPE_NON_LAYOUT_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n     {\n       base_t = make_node (TREE_CODE (t));\n "}, {"sha": "6ad039ae3cf083c24bfb33a9b29d3e4748232798", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -494,6 +494,8 @@ typedef enum cp_trait_kind\n   CPTK_IS_ENUM,\n   CPTK_IS_POD,\n   CPTK_IS_POLYMORPHIC,\n+  CPTK_IS_STD_LAYOUT,\n+  CPTK_IS_TRIVIAL,\n   CPTK_IS_UNION\n } cp_trait_kind;\n \n@@ -1124,6 +1126,7 @@ struct GTY(()) lang_type_class {\n   unsigned non_aggregate : 1;\n   unsigned has_complex_dflt : 1;\n   unsigned has_list_ctor : 1;\n+  unsigned non_std_layout : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1132,7 +1135,7 @@ struct GTY(()) lang_type_class {\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 10;\n+  unsigned dummy : 9;\n \n   tree primary_base;\n   VEC(tree_pair_s,gc) *vcall_indices;\n@@ -1385,8 +1388,14 @@ struct GTY(()) lang_type {\n #define CLASSTYPE_HAS_MUTABLE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_mutable)\n #define TYPE_HAS_MUTABLE_P(NODE) (cp_has_mutable_p (NODE))\n \n-/* Nonzero means that this class type is a non-POD class.  */\n-#define CLASSTYPE_NON_POD_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->non_pod_class)\n+/* Nonzero means that this class type is not POD for the purpose of layout\n+   (as defined in the ABI).  This is different from the language's POD.  */\n+#define CLASSTYPE_NON_LAYOUT_POD_P(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->non_pod_class)\n+\n+/* Nonzero means that this class type is a non-standard-layout class.  */\n+#define CLASSTYPE_NON_STD_LAYOUT(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->non_std_layout)\n \n /* Nonzero means that this class contains pod types whose default\n    initialization is not a zero initialization (namely, pointers to\n@@ -4877,7 +4886,12 @@ extern void stabilize_aggr_init\t\t\t(tree, tree *);\n extern bool stabilize_init\t\t\t(tree, tree *);\n extern tree add_stmt_to_compound\t\t(tree, tree);\n extern void init_tree\t\t\t\t(void);\n-extern int pod_type_p\t\t\t\t(const_tree);\n+extern bool pod_type_p\t\t\t\t(const_tree);\n+extern bool layout_pod_type_p\t\t\t(const_tree);\n+extern bool std_layout_type_p\t\t\t(const_tree);\n+extern bool trivial_type_p\t\t\t(const_tree);\n+extern bool type_has_nontrivial_default_init\t(const_tree);\n+extern bool type_has_nontrivial_copy_init\t(const_tree);\n extern bool class_tmpl_impl_spec_p\t\t(const_tree);\n extern int zero_init_p\t\t\t\t(const_tree);\n extern tree strip_typedefs\t\t\t(tree);"}, {"sha": "0b13bc1eb8d5fef8b59630fd693331da1254eae1", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -2296,6 +2296,12 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_POLYMORPHIC:\n       pp_cxx_ws_string (pp, \"__is_polymorphic\");\n       break;\n+    case CPTK_IS_STD_LAYOUT:\n+      pp_cxx_ws_string (pp, \"__is_std_layout\");\n+      break;\n+    case CPTK_IS_TRIVIAL:\n+      pp_cxx_ws_string (pp, \"__is_trivial\");\n+      break;\n     case CPTK_IS_UNION:\n       pp_cxx_ws_string (pp, \"__is_union\");\n       break;"}, {"sha": "e65e6360cb6a409373a6cb34e2d408873f61e187", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -2473,20 +2473,28 @@ declare_local_label (tree id)\n static int\n decl_jump_unsafe (tree decl)\n {\n+  /* [stmt.dcl]/3: A program that jumps from a point where a local variable\n+     with automatic storage duration is not in scope to a point where it is\n+     in scope is ill-formed unless the variable has scalar type, class type\n+     with a trivial default constructor and a trivial destructor, a\n+     cv-qualified version of one of these types, or an array of one of the\n+     preceding types and is declared without an initializer (8.5).  */\n+  tree type = TREE_TYPE (decl);\n+\n   if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl)\n-      || TREE_TYPE (decl) == error_mark_node)\n+      || type == error_mark_node)\n     return 0;\n \n-  if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))\n+  type = strip_array_types (type);\n+\n+  if (type_has_nontrivial_default_init (TREE_TYPE (decl))\n       || DECL_NONTRIVIALLY_INITIALIZED_P (decl))\n     return 2;\n \n-  if (pod_type_p (TREE_TYPE (decl)))\n-    return 0;\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+    return 1;\n \n-  /* The POD stuff is just pedantry; why should it matter if the class\n-     contains a field of pointer to member type?  */\n-  return 1;\n+  return 0;\n }\n \n /* A subroutine of check_previous_goto_1 to identify a branch to the user.  */\n@@ -2541,7 +2549,8 @@ check_previous_goto_1 (tree decl, struct cp_binding_level* level, tree names,\n \t  if (problem > 1)\n \t    error (\"  crosses initialization of %q+#D\", new_decls);\n \t  else\n-\t    permerror (input_location, \"  enters scope of non-POD %q+#D\", new_decls);\n+\t    permerror (input_location, \"  enters scope of %q+#D which has \"\n+\t\t       \"non-trivial destructor\", new_decls);\n \t}\n \n       if (b == level)\n@@ -2656,7 +2665,8 @@ check_goto (tree decl)\n       else if (u > 1)\n \terror (\"  skips initialization of %q+#D\", b);\n       else\n-\tpermerror (input_location, \"  enters scope of non-POD %q+#D\", b);\n+\tpermerror (input_location, \"  enters scope of %q+#D which has \"\n+\t\t   \"non-trivial destructor\", b);\n     }\n \n   if (ent->in_try_scope)\n@@ -5687,11 +5697,13 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      /* Only PODs can have thread-local storage.  Other types may require\n-\t various kinds of non-trivial initialization.  */\n-      if (DECL_THREAD_LOCAL_P (decl) && !pod_type_p (TREE_TYPE (decl)))\n-\terror (\"%qD cannot be thread-local because it has non-POD type %qT\",\n-\t       decl, TREE_TYPE (decl));\n+      /* Only variables with trivial initialization and destruction can\n+\t have thread-local storage.  */\n+      if (DECL_THREAD_LOCAL_P (decl)\n+\t  && (type_has_nontrivial_default_init (TREE_TYPE (decl))\n+\t      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl))))\n+\terror (\"%qD cannot be thread-local because it has non-trivial \"\n+\t       \"type %qT\", decl, TREE_TYPE (decl));\n       /* If this is a local variable that will need a mangled name,\n \t register it now.  We must do this before processing the\n \t initializer for the variable, since the initialization might"}, {"sha": "9118c61928b4c388b8d2a059e0e63446871dc3a7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -2703,7 +2703,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t       || ! TYPE_HAS_NONTRIVIAL_DESTRUCTOR (inner_elt_type)))\n \t  || from_array))\n     {\n-      /* Do non-default initialization of POD arrays resulting from\n+      /* Do non-default initialization of trivial arrays resulting from\n \t brace-enclosed initializers.  In this case, digest_init and\n \t store_constructor will handle the semantics for us.  */\n \n@@ -2769,7 +2769,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n   if (init != NULL_TREE && TREE_CODE (init) == CONSTRUCTOR)\n     {\n-      /* Do non-default initialization of non-POD arrays resulting from\n+      /* Do non-default initialization of non-trivial arrays resulting from\n \t brace-enclosed initializers.  */\n       unsigned HOST_WIDE_INT idx;\n       tree elt;"}, {"sha": "e64d0bf7cbdcce7a8dd7831d12036b30ea2166a4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -3399,6 +3399,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_ENUM:\n \tcase RID_IS_POD:\n \tcase RID_IS_POLYMORPHIC:\n+\tcase RID_IS_STD_LAYOUT:\n+\tcase RID_IS_TRIVIAL:\n \tcase RID_IS_UNION:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n \n@@ -6865,6 +6867,12 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n     case RID_IS_POLYMORPHIC:\n       kind = CPTK_IS_POLYMORPHIC;\n       break;\n+    case RID_IS_STD_LAYOUT:\n+      kind = CPTK_IS_STD_LAYOUT;\n+      break;\n+    case RID_IS_TRIVIAL:\n+      kind = CPTK_IS_TRIVIAL;\n+      break;\n     case RID_IS_UNION:\n       kind = CPTK_IS_UNION;\n       break;"}, {"sha": "4473c4927b40a465baee81a89ac8e7f602a537af", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -4878,15 +4878,19 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n   switch (kind)\n     {\n     case CPTK_HAS_NOTHROW_ASSIGN:\n+      type1 = strip_array_types (type1);\n       return (!CP_TYPE_CONST_P (type1) && type_code1 != REFERENCE_TYPE\n \t      && (trait_expr_value (CPTK_HAS_TRIVIAL_ASSIGN, type1, type2)\n \t\t  || (CLASS_TYPE_P (type1)\n \t\t      && classtype_has_nothrow_assign_or_copy_p (type1,\n \t\t\t\t\t\t\t\t true))));\n \n     case CPTK_HAS_TRIVIAL_ASSIGN:\n+      /* ??? The standard seems to be missing the \"or array of such a class\n+\t type\" wording for this trait.  */\n+      type1 = strip_array_types (type1);\n       return (!CP_TYPE_CONST_P (type1) && type_code1 != REFERENCE_TYPE\n-\t      && (pod_type_p (type1)\n+\t      && (trivial_type_p (type1)\n \t\t    || (CLASS_TYPE_P (type1)\n \t\t\t&& TYPE_HAS_TRIVIAL_ASSIGN_REF (type1))));\n \n@@ -4899,21 +4903,25 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n \n     case CPTK_HAS_TRIVIAL_CONSTRUCTOR:\n       type1 = strip_array_types (type1);\n-      return (pod_type_p (type1)\n+      return (trivial_type_p (type1)\n \t      || (CLASS_TYPE_P (type1) && TYPE_HAS_TRIVIAL_DFLT (type1)));\n \n     case CPTK_HAS_NOTHROW_COPY:\n+      type1 = strip_array_types (type1);\n       return (trait_expr_value (CPTK_HAS_TRIVIAL_COPY, type1, type2)\n \t      || (CLASS_TYPE_P (type1)\n \t\t  && classtype_has_nothrow_assign_or_copy_p (type1, false)));\n \n     case CPTK_HAS_TRIVIAL_COPY:\n-      return (pod_type_p (type1) || type_code1 == REFERENCE_TYPE\n+      /* ??? The standard seems to be missing the \"or array of such a class\n+\t type\" wording for this trait.  */\n+      type1 = strip_array_types (type1);\n+      return (trivial_type_p (type1) || type_code1 == REFERENCE_TYPE\n \t      || (CLASS_TYPE_P (type1) && TYPE_HAS_TRIVIAL_INIT_REF (type1)));\n \n     case CPTK_HAS_TRIVIAL_DESTRUCTOR:\n       type1 = strip_array_types (type1);\n-      return (pod_type_p (type1) || type_code1 == REFERENCE_TYPE\n+      return (trivial_type_p (type1) || type_code1 == REFERENCE_TYPE\n \t      || (CLASS_TYPE_P (type1)\n \t\t  && TYPE_HAS_TRIVIAL_DESTRUCTOR (type1)));\n \n@@ -4947,6 +4955,12 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_POLYMORPHIC:\n       return (CLASS_TYPE_P (type1) && TYPE_POLYMORPHIC_P (type1));\n \n+    case CPTK_IS_STD_LAYOUT:\n+      return (std_layout_type_p (type1));\n+\n+    case CPTK_IS_TRIVIAL:\n+      return (trivial_type_p (type1));\n+\n     case CPTK_IS_UNION:\n       return (type_code1 == UNION_TYPE);\n \n@@ -4995,6 +5009,8 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n \t      || kind == CPTK_IS_ENUM\n \t      || kind == CPTK_IS_POD\n \t      || kind == CPTK_IS_POLYMORPHIC\n+\t      || kind == CPTK_IS_STD_LAYOUT\n+\t      || kind == CPTK_IS_TRIVIAL\n \t      || kind == CPTK_IS_UNION);\n \n   if (kind == CPTK_IS_CONVERTIBLE_TO)\n@@ -5036,6 +5052,8 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_EMPTY:\n     case CPTK_IS_POD:\n     case CPTK_IS_POLYMORPHIC:\n+    case CPTK_IS_STD_LAYOUT:\n+    case CPTK_IS_TRIVIAL:\n       if (!check_trait_type (type1))\n \t{\n \t  error (\"incomplete type %qT not allowed\", type1);"}, {"sha": "255a297de6fed37b5ea9c663c7f6ea8f3d78e161", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 94, "deletions": 22, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -2238,36 +2238,108 @@ is_dummy_object (const_tree ob)\n \t  && TREE_OPERAND (ob, 0) == void_zero_node);\n }\n \n+/* Returns 1 iff type T is something we want to treat as a scalar type for\n+   the purpose of deciding whether it is trivial/POD/standard-layout.  */\n+\n+static bool\n+scalarish_type_p (const_tree t)\n+{\n+  if (t == error_mark_node)\n+    return 1;\n+\n+  return (SCALAR_TYPE_P (t)\n+\t  || TREE_CODE (t) == VECTOR_TYPE);\n+}\n+\n+/* Returns true iff T requires non-trivial default initialization.  */\n+\n+bool\n+type_has_nontrivial_default_init (const_tree t)\n+{\n+  t = strip_array_types (CONST_CAST_TREE (t));\n+\n+  if (CLASS_TYPE_P (t))\n+    return TYPE_HAS_COMPLEX_DFLT (t);\n+  else\n+    return 0;\n+}\n+\n+/* Returns true iff copying an object of type T is non-trivial.  */\n+\n+bool\n+type_has_nontrivial_copy_init (const_tree t)\n+{\n+  t = strip_array_types (CONST_CAST_TREE (t));\n+\n+  if (CLASS_TYPE_P (t))\n+    return TYPE_HAS_COMPLEX_INIT_REF (t);\n+  else\n+    return 0;\n+}\n+\n+/* Returns 1 iff type T is a trivial type, as defined in [basic.types].  */\n+\n+bool\n+trivial_type_p (const_tree t)\n+{\n+  t = strip_array_types (CONST_CAST_TREE (t));\n+\n+  if (CLASS_TYPE_P (t))\n+    return !(TYPE_HAS_COMPLEX_DFLT (t)\n+\t     || TYPE_HAS_COMPLEX_INIT_REF (t)\n+\t     || TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n+\t     || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t));\n+  else\n+    return scalarish_type_p (t);\n+}\n+\n /* Returns 1 iff type T is a POD type, as defined in [basic.types].  */\n \n-int\n+bool\n pod_type_p (const_tree t)\n {\n   /* This CONST_CAST is okay because strip_array_types returns its\n      argument unmodified and we assign it to a const_tree.  */\n   t = strip_array_types (CONST_CAST_TREE(t));\n \n-  if (t == error_mark_node)\n-    return 1;\n-  if (INTEGRAL_OR_ENUMERATION_TYPE_P (t))\n-    return 1;  /* integral, character or enumeral type */\n-  if (FLOAT_TYPE_P (t))\n-    return 1;\n-  if (TYPE_PTR_P (t))\n-    return 1; /* pointer to non-member */\n-  if (TYPE_PTR_TO_MEMBER_P (t))\n-    return 1; /* pointer to member */\n-\n-  if (TREE_CODE (t) == VECTOR_TYPE)\n-    return 1; /* vectors are (small) arrays of scalars */\n-\n-  if (! RECORD_OR_UNION_CODE_P (TREE_CODE (t)))\n-    return 0; /* other non-class type (reference or function) */\n-  if (! CLASS_TYPE_P (t))\n-    return 1; /* struct created by the back end */\n-  if (CLASSTYPE_NON_POD_P (t))\n-    return 0;\n-  return 1;\n+  if (CLASS_TYPE_P (t))\n+    /* [class]/10: A POD struct is a class that is both a trivial class and a\n+       standard-layout class, and has no non-static data members of type\n+       non-POD struct, non-POD union (or array of such types).\n+\n+       We don't need to check individual members because if a member is\n+       non-std-layout or non-trivial, the class will be too.  */\n+    return (std_layout_type_p (t) && trivial_type_p (t));\n+  else\n+    return scalarish_type_p (t);\n+}\n+\n+/* Returns true iff T is POD for the purpose of layout, as defined in the\n+   C++ ABI.  */\n+\n+bool\n+layout_pod_type_p (const_tree t)\n+{\n+  t = strip_array_types (CONST_CAST_TREE (t));\n+\n+  if (CLASS_TYPE_P (t))\n+    return !CLASSTYPE_NON_LAYOUT_POD_P (t);\n+  else\n+    return scalarish_type_p (t);\n+}\n+\n+/* Returns true iff T is a standard-layout type, as defined in\n+   [basic.types].  */\n+\n+bool\n+std_layout_type_p (const_tree t)\n+{\n+  t = strip_array_types (CONST_CAST_TREE (t));\n+\n+  if (CLASS_TYPE_P (t))\n+    return !CLASSTYPE_NON_STD_LAYOUT (t);\n+  else\n+    return scalarish_type_p (t);\n }\n \n /* Nonzero iff type T is a class template implicit specialization.  */"}, {"sha": "9e49ce58b4bc1525b816266706a9e77610ce48cc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -2017,7 +2017,7 @@ build_class_member_access_expr (tree object, tree member,\n \t in various testsuite cases where a null object is passed where a\n \t vtable access is required.  */\n       if (null_object_p && warn_invalid_offsetof\n-\t  && CLASSTYPE_NON_POD_P (object_type)\n+\t  && CLASSTYPE_NON_STD_LAYOUT (object_type)\n \t  && !DECL_FIELD_IS_BASE (member)\n \t  && cp_unevaluated_operand == 0\n \t  && (complain & tf_warning))\n@@ -3134,7 +3134,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t  if (fndecl && DECL_BUILT_IN (fndecl)\n \t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CONSTANT_P)\n \t    /* Don't do ellipsis conversion for __built_in_constant_p\n-\t       as this will result in spurious warnings for non-POD\n+\t       as this will result in spurious errors for non-trivial\n \t       types.  */\n \t    val = require_complete_type (val);\n \t  else"}, {"sha": "34b896340337b213446e867a03e4074d5cbc0d8b", "filename": "gcc/doc/gcc.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fdoc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fdoc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc.texi?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -134,6 +134,7 @@ Introduction, gccint, GNU Compiler Collection (GCC) Internals}.\n * Invoking GCC::    Command options supported by @samp{gcc}.\n * C Implementation:: How GCC implements the ISO C specification.\n * C Extensions::    GNU extensions to the C language family.\n+* C++ Implementation:: How GCC implements the ISO C++ specification.\n * C++ Extensions::  GNU extensions to the C++ language.\n * Objective-C::     GNU Objective-C runtime features.\n * Compatibility::   Binary Compatibility\n@@ -159,6 +160,7 @@ Introduction, gccint, GNU Compiler Collection (GCC) Internals}.\n @include standards.texi\n @include invoke.texi\n @include implement-c.texi\n+@include implement-cxx.texi\n @include extend.texi\n @include objc.texi\n @include compat.texi"}, {"sha": "9968f592473e96a5841a3a1602ee9833e512331a", "filename": "gcc/doc/implement-cxx.texi", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fdoc%2Fimplement-cxx.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Fdoc%2Fimplement-cxx.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fimplement-cxx.texi?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -0,0 +1,47 @@\n+@c Copyright (C) 2009\n+@c Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@node C++ Implementation\n+@chapter C++ Implementation-defined behavior\n+@cindex implementation-defined behavior, C++ language\n+\n+A conforming implementation of ISO C++ is required to document its\n+choice of behavior in each of the areas that are designated\n+``implementation defined''.  The following lists all such areas,\n+along with the section numbers from the ISO/IEC 14822:1998 and ISO/IEC\n+14822:2003 standards.  Some areas are only implementation-defined in\n+one version of the standard.\n+\n+Some choices depend on the externally determined ABI for the platform\n+(including standard character encodings) which GCC follows; these are\n+listed as ``determined by ABI'' below.  @xref{Compatibility, , Binary\n+Compatibility}, and @uref{http://gcc.gnu.org/readings.html}.  Some\n+choices are documented in the preprocessor manual.\n+@xref{Implementation-defined behavior, , Implementation-defined\n+behavior, cpp, The C Preprocessor}.  Some choices are documented in\n+the corresponding document for the C language.  @xref{C\n+Implementation}.  Some choices are made by the library and operating\n+system (or other environment when compiling for a freestanding\n+environment); refer to their documentation for details.\n+\n+@menu\n+* Conditionally-supported behavior::\n+@end menu\n+\n+@node Conditionally-supported behavior\n+@section Conditionally-supported behavior\n+\n+@cite{Each implementation shall include documentation that identifies\n+all conditionally-supported constructs that it does not support (C++0x\n+1.4).}\n+\n+@itemize @bullet\n+@item\n+@cite{Whether an argument of class type with a non-trivial copy\n+constructor or destructor can be passed to ... (C++0x 5.2.2).}\n+\n+Such argument passing is not supported.\n+\n+@end itemize"}, {"sha": "7ab159ad5cec36400771a776204d0e8c73971362", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -1,3 +1,21 @@\n+2009-07-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR libstdc++/37907\n+\t* g++.dg/cpp0x/std-layout1.C: New.\n+\t* g++.dg/ext/has_nothrow_assign.C: Fix.\n+\t* g++.dg/ext/has_nothrow_copy.C: Fix.\n+\t* g++.dg/ext/has_trivial_assign.C: Fix.\n+\t* g++.dg/ext/has_trivial_copy.C: Fix.\n+\t* g++.dg/ext/is_pod.C: Fix.\n+\t* g++.dg/other/offsetof3.C: Adjust.\n+\t* g++.dg/overload/ellipsis1.C: Adjust.\n+\t* g++.dg/warn/var-args1.C: Adjust.\n+\t* g++.old-deja/g++.brendan/crash63.C: Adjust.\n+\t* g++.old-deja/g++.brendan/crash64.C: Adjust.\n+\t* g++.old-deja/g++.brendan/overload8.C: Adjust.\n+\t* g++.old-deja/g++.other/vaarg3.C: Adjust.\n+\t* g++.old-deja/g++.pt/vaarg3.C: Adjust.\n+\n 2009-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-math-5.c: Add more cases."}, {"sha": "bdad8211145ef121960fa8ce00ec30c2eb53b480", "filename": "gcc/testsuite/g++.dg/cpp0x/std-layout1.C", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fstd-layout1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fstd-layout1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fstd-layout1.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -0,0 +1,91 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// [basic.types]/10:\n+// Scalar types, standard-layout class types (Clause 9), arrays of such\n+// types and cv-qualified versions of these types (3.9.3) are collectively\n+// called standard-layout types.\n+\n+// [class]/7:\n+// A standard-layout class is a class that:\n+// * has no non-static data members of type non-standard-layout class (or\n+// array of such types) or reference,\n+// * has no virtual functions (10.3) and no virtual base classes (10.1),\n+// * has the same access control (Clause 11) for all non-static data members,\n+// * has no non-standard-layout base classes,\n+// * either has no non-static data members in the most-derived class and at\n+// most one base class with non-static data members, or has no base classes\n+// with non-static data members, and\n+// * has no base classes of the same type as the first non-static data member.\n+\n+#include <type_traits>\n+\n+#define TRY(expr) static_assert (expr, #expr)\n+#define YES(type) TRY(std::is_standard_layout<type>::value); \\\n+  TRY(std::is_standard_layout<type[]>::value); \\\n+  TRY(std::is_standard_layout<const volatile type>::value);\n+#define NO(type) TRY(!std::is_standard_layout<type>::value); \\\n+  TRY(!std::is_standard_layout<type[]>::value); \\\n+  TRY(!std::is_standard_layout<const volatile type>::value);\n+#define NONPOD(type) TRY(!std::is_pod<type>::value); \\\n+  TRY(!std::is_pod<type[]>::value); \\\n+  TRY(!std::is_pod<const volatile type>::value);\n+\n+struct A;\n+\n+YES(int);\n+YES(__complex int);\n+YES(void *);\n+YES(int A::*);\n+typedef int (A::*pmf)();\n+YES(pmf);\n+\n+struct A { ~A(); };\n+YES(A);\n+NONPOD(A);\n+struct F: public A { int i; };\n+YES(F);\n+NONPOD(F);\n+struct G: public A { A a; };\n+NO(G);\n+struct M { A a; };\n+YES(M);\n+\n+class B\n+{\n+  int i;\n+  __complex int c;\n+  void *p;\n+  double ar[4];\n+  int A::* pm;\n+  int (A::*pmf)();\n+};\n+YES(B);\n+struct D: public B { };\n+YES(D);\n+struct E: public B { int q; };\n+NO(E);\n+struct D2: public B { };\n+YES(D2);\n+struct I: public D, public D2 { };\n+NO(I);\n+\n+struct C\n+{\n+  int i;\n+private:\n+  int j;\n+};\n+NO(C);\n+struct H: public C { };\n+NO(H);\n+struct N { C c; };\n+NO(N);\n+\n+struct J { virtual void f(); };\n+struct J2: J { };\n+NO(J);\n+NO(J2);\n+struct K { };\n+struct L: virtual K {};\n+YES(K);\n+NO(L);"}, {"sha": "62173ac0caf128f60058a1ff2b3dc752c5411abd", "filename": "gcc/testsuite/g++.dg/cpp0x/trivial1.C", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrivial1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrivial1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftrivial1.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -0,0 +1,82 @@\n+// { dg-options \"-std=c++0x\" }\n+\n+// [basic.types]/10:\n+// Scalar types, trivial class types (Clause 9), arrays of such types and\n+// cv-qualified versions of these types (3.9.3) are collectively called\n+// trivial types.\n+\n+// [class]/6:\n+// A trivially copyable class is a class that:\n+// * has no non-trivial copy constructors (12.8),\n+// * has no non-trivial copy assignment operators (13.5.3, 12.8), and\n+// * has a trivial destructor (12.4).\n+// A trivial class is a class that has a trivial default constructor (12.1)\n+// and is trivially copyable.\n+\n+#include <type_traits>\n+\n+#define TRY(expr) static_assert (expr, #expr)\n+#define YES(type) TRY(std::is_trivial<type>::value); \\\n+  TRY(std::is_trivial<type[]>::value); \\\n+  TRY(std::is_trivial<const volatile type>::value);\n+#define NO(type) TRY(!std::is_trivial<type>::value); \\\n+  TRY(!std::is_trivial<type[]>::value); \\\n+  TRY(!std::is_trivial<const volatile type>::value);\n+\n+struct A;\n+\n+YES(int);\n+YES(__complex int);\n+YES(void *);\n+YES(int A::*);\n+typedef int (A::*pmf)();\n+YES(pmf);\n+\n+struct A { ~A(); };\n+NO(A);\n+struct F: public A { int i; };\n+NO(F);\n+struct G: public A { A a; };\n+NO(G);\n+struct M { A a; };\n+NO(M);\n+\n+class B\n+{\n+  int i;\n+  __complex int c;\n+  void *p;\n+  double ar[4];\n+  int A::* pm;\n+  int (A::*pmf)();\n+};\n+YES(B);\n+struct D: public B { };\n+YES(D);\n+struct E: public B { int q; };\n+YES(E);\n+struct D2: public B { };\n+YES(D2);\n+struct I: public D, public D2 { };\n+YES(I);\n+\n+struct C\n+{\n+  int i;\n+private:\n+  int j;\n+};\n+YES(C);\n+struct H: public C { };\n+YES(H);\n+struct N { C c; };\n+YES(N);\n+\n+struct J { virtual void f(); };\n+struct J2: J { };\n+NO(J);\n+NO(J2);\n+struct K { };\n+struct L: virtual K {};\n+YES(K);\n+NO(L);"}, {"sha": "f3b4a8b2556dec36620d3035cfe9a7f4f4b2fd0c", "filename": "gcc/testsuite/g++.dg/ext/has_nothrow_assign.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_assign.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_assign.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_assign.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -134,7 +134,7 @@ int main()\n   assert (PTEST (A));\n   assert (PTEST (B));\n   assert (PTEST (C));\n-  assert (NTEST (C[]));\n+  assert (PTEST (C[]));\n   assert (PTEST (D));\n   assert (NTEST (E));\n   assert (NTEST (E1));"}, {"sha": "056c9be61f666139c486f6243983379a398b9f7c", "filename": "gcc/testsuite/g++.dg/ext/has_nothrow_copy-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_copy-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_copy-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_nothrow_copy-1.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -124,7 +124,7 @@ int main()\n   assert (PTEST (A));\n   assert (PTEST (B));\n   assert (PTEST (C));\n-  assert (NTEST (C[]));\n+  assert (PTEST (C[]));\n   assert (PTEST (D));\n   assert (NTEST (E));\n   assert (NTEST (E1));"}, {"sha": "46d8c34bb3f76220eb25025d890e6cc1ac6c2bad", "filename": "gcc/testsuite/g++.dg/ext/has_trivial_assign.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_assign.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_assign.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_assign.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -96,7 +96,7 @@ int main()\n   assert (NTEST (C));\n   assert (NTEST (D));\n   assert (PTEST (E));\n-  assert (NTEST (E[]));\n+  assert (PTEST (E[]));\n   assert (PTEST (F));\n   assert (NTEST (G));\n   assert (NTEST (const A));"}, {"sha": "4b8cc1541477c7966c5c4e4cea5bb8ec96ee5cb4", "filename": "gcc/testsuite/g++.dg/ext/has_trivial_copy.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_copy.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_copy.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fhas_trivial_copy.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -96,7 +96,7 @@ int main()\n   assert (NTEST (C));\n   assert (NTEST (D));\n   assert (PTEST (E));\n-  assert (NTEST (E[]));\n+  assert (PTEST (E[]));\n   assert (PTEST (F));\n   assert (NTEST (G));\n   assert (PTEST (B&));"}, {"sha": "c984283a0e93c0b95d2169fd0fb1b081dd215c53", "filename": "gcc/testsuite/g++.dg/ext/is_pod.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_pod.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_pod.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_pod.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -68,8 +68,8 @@ int main()\n   assert (PTEST (A));\n   assert (PTEST (A[]));\n   assert (NTEST (B));\n-  assert (NTEST (C));\n-  assert (NTEST (C[]));\n+  assert (PTEST (C));\n+  assert (PTEST (C[]));\n \n   return 0;\n }"}, {"sha": "5946c812ced7a983857c64c9a678fe7be8e7605d", "filename": "gcc/testsuite/g++.dg/other/offsetof3.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Foffsetof3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Foffsetof3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Foffsetof3.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -1,16 +1,17 @@\n-/* Verify that offsetof warns if given a non-POD */\n+/* Verify that offsetof warns if given a non-standard-layout class */\n /* Copyright (C) 2003 Free Software Foundation, Inc. */\n /* Contributed by Matt Austern <austern@apple.com> 15 May 2003 */\n /* { dg-do compile } */\n \n struct X\n {\n-  X() : x(3), y(4) { }\n   int x, y;\n+protected:\n+  int z;\n };\n \n typedef X* pX;\n typedef __SIZE_TYPE__ size_t;\n \n size_t yoff = size_t(&(pX(0)->y)); /* { dg-warning \"invalid access\" \"\" } */\n-/* { dg-warning \"macro was used incorrectly\" \"macro\" { target *-*-* } 15 } */\n+/* { dg-warning \"macro was used incorrectly\" \"macro\" { target *-*-* } 16 } */"}, {"sha": "3dedaa6be4a83c376349e6f5fe008e8388198957", "filename": "gcc/testsuite/g++.dg/overload/ellipsis1.C", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fellipsis1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fellipsis1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fellipsis1.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -1,9 +1,6 @@\n // PR c++/15142\n // Bug: We were aborting after giving a warning about passing a non-POD.\n \n-// Suppress the warning about undefined behavior.\n-// { dg-options \"-w\" }\n-\n struct B { \n     B() throw() { } \n     B(const B&) throw() { } \n@@ -17,5 +14,5 @@ struct X {\n struct S { S(...); }; \n  \n void SillyFunc() { \n-  throw S(X()); \n+  throw S(X()); \t\t// { dg-error \"copy\" }\n } "}, {"sha": "9bd84a7dd55ae934e03288cd3f7c9da45699df28", "filename": "gcc/testsuite/g++.dg/warn/var-args1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fvar-args1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fvar-args1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fvar-args1.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -6,6 +6,6 @@ void foo(int, ...)\n {\n     va_list va;\n     int i;\n-    i = va_arg(va, int&); /* { dg-warning \"cannot receive objects\" } */\n+    i = va_arg(va, int&); /* { dg-error \"cannot receive objects\" } */\n }\n "}, {"sha": "89685fcaeb5496e2fb0659dd15209a90377e64d2", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash63.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash63.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash63.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash63.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -4,6 +4,7 @@ class String\n    {\n  public:\n    String (const char *str);\n+   String (const String&);\n    };\n \n class UnitList \n@@ -12,4 +13,4 @@ class UnitList\n    UnitList (...);\n    };\n \n-UnitList unit_list (String(\"keV\")); // { dg-warning \"\" } cannot pass non-pod\n+UnitList unit_list (String(\"keV\")); // { dg-error \"\" } cannot pass non-pod"}, {"sha": "3c98692833176240e9e7ba39455465474a3df845", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash64.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash64.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash64.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash64.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -16,4 +16,4 @@ struct metatype { int base_list; };\n \n static _type_desc _type_metatype(\"metatype\", sizeof(metatype),\n   (RF_Ptr)0, 0, 1, 1,\n-  _im_pers_mem_spec( ((size_t)&((( metatype *)0)-> base_list )) , 1)); // { dg-warning \"\" } cannot pass non-pod\n+  _im_pers_mem_spec( ((size_t)&((( metatype *)0)-> base_list )) , 1));"}, {"sha": "bf129b02c2b03309d22f0de42d4d70722b732f0c", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/overload8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Foverload8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Foverload8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Foverload8.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -6,4 +6,4 @@ class Complex{public:double re,im;\n void zxcvbnm(int n,...){n=1;}\n int main(){complex c; Complex C;\n zxcvbnm(1,c);\n-zxcvbnm(1,C);} // { dg-warning \"\" } cannot pass non pod\n+zxcvbnm(1,C);}"}, {"sha": "3408a1811885da9172432d7040f1b692e87a4904", "filename": "gcc/testsuite/g++.old-deja/g++.other/vaarg3.C", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvaarg3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvaarg3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvaarg3.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -9,14 +9,14 @@\n #include <stdarg.h>\n \n struct X {int m;};\n-struct Y : X {int m;};\n+struct Y { Y(const Y&); };\n struct Z;   // { dg-error \"forward decl\" } \n void fn1(va_list args)\n {\n   int i = va_arg (args, int);\n-  Y x = va_arg (args, Y);         // { dg-warning \"cannot receive\" } \n-  Y y = va_arg (args, struct Y);  // { dg-warning \"cannot receive\" } \n-  int &r = va_arg (args, int &);  // { dg-warning \"cannot receive\" } \n+  Y x = va_arg (args, Y);         // { dg-error \"cannot receive\" }\n+  Y y = va_arg (args, struct Y);  // { dg-error \"cannot receive\" }\n+  int &r = va_arg (args, int &);  // { dg-error \"cannot receive\" }\n   \n   Z z1 = va_arg (args, Z);        // { dg-error \"incomplete\" } \n   const Z &z2 = va_arg (args, Z);       // { dg-error \"incomplete\" } \n@@ -25,7 +25,8 @@ void fn1(va_list args)\n   // { dg-message \"should pass\" \"pass\" { target *-*-* } 24 }\n   // { dg-message \"abort\" \"abort\" { target *-*-* } 24 }\n   va_arg (args, int []);  // { dg-error \"array with unspecified bounds\" } promote\n-  va_arg (args, int ());  // { dg-warning \"non-POD\" } promote\n+  va_arg (args, int ());  // { dg-warning \"promoted\" } promote\n+  // { dg-message \"abort\" \"abort\" { target *-*-* } 28 }\n   va_arg (args, bool);    // { dg-warning \"promote\" \"promote\" } \n-  // { dg-message \"abort\" \"abort\" { target *-*-* } 29 }\n+  // { dg-message \"abort\" \"abort\" { target *-*-* } 30 }\n }"}, {"sha": "07fb18d77d898d37566b275c141a923970719d26", "filename": "gcc/testsuite/g++.old-deja/g++.pt/vaarg3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvaarg3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvaarg3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fvaarg3.C?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -14,14 +14,14 @@ void PrintArgs (Type somearg, ...)\n va_list argp;\n va_start (argp, somearg);\n Type value;\n-value = va_arg (argp, Type); // { dg-warning \"non-POD\" } cannot pass non-POD\n+value = va_arg (argp, Type); // { dg-error \"cannot receive\" } cannot pass non-POD\n va_end (argp);\n }\n \n int main (void)\n {\n A dummy;\n-PrintArgs (dummy, dummy); // { dg-warning \"non-POD\" } cannot pass non-POD\n+PrintArgs (dummy, dummy); // { dg-error \"cannot pass\" } cannot pass non-POD\n // { dg-message \"instantiated\" \"inst\" { target *-*-* } 24 }\n return 0;\n }"}, {"sha": "60c1c3fe3ad00bef0f23e026748a8acd065eb620", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -1,3 +1,11 @@\n+2009-07-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR libstdc++/37907\n+\t* include/std/type_traits: Add is_standard_layout, is_trivial.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc,\n+\ttestsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tUpdate line numbers.\n+\n 2009-07-16  Phil Muldoon <pmuldoon@redhat.com>\n \t    Tom Tromey <tromey@redhat.com>\n "}, {"sha": "dd26bb84dbfff7f057c7916f47cda49f23d50361", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -173,11 +173,18 @@ namespace std\n   // Member introspection.\n \n   /// is_pod\n+  // Could use is_standard_layout && is_trivial instead of the builtin.\n   template<typename _Tp>\n     struct is_pod\n     : public integral_constant<bool, __is_pod(_Tp)>\n     { };\n \n+  /// is_standard_layout\n+  template<typename _Tp>\n+    struct is_standard_layout\n+    : public integral_constant<bool, __is_standard_layout(_Tp)>\n+    { };\n+\n   /// has_trivial_default_constructor\n   template<typename _Tp>\n     struct has_trivial_default_constructor\n@@ -202,6 +209,12 @@ namespace std\n     : public integral_constant<bool, __has_trivial_destructor(_Tp)>\n     { };\n \n+  /// is_trivial\n+  template<typename _Tp>\n+    struct is_trivial\n+    : public integral_constant<bool, __is_trivial(_Tp)>\n+    { };\n+\n   /// has_nothrow_default_constructor\n   template<typename _Tp>\n     struct has_nothrow_default_constructor"}, {"sha": "3455462869b0273474b3e79833b7b66dc2aa0e9f", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -48,8 +48,8 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 557 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 519 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 570 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 532 }\n \n // { dg-excess-errors \"At global scope\" }\n // { dg-excess-errors \"In instantiation of\" }"}, {"sha": "3d3a10a9ba8ee245d8baba5e039fb9f983f8c04e", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c32097d8b4fb21997c571cf6520431fa7d06090f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=c32097d8b4fb21997c571cf6520431fa7d06090f", "patch": "@@ -48,8 +48,8 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 478 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 440 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 491 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 453 }\n \n // { dg-excess-errors \"At global scope\" }\n // { dg-excess-errors \"In instantiation of\" }"}]}