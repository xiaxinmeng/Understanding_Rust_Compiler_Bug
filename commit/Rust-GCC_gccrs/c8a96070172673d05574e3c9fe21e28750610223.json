{"sha": "c8a96070172673d05574e3c9fe21e28750610223", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhhOTYwNzAxNzI2NzNkMDU1NzRlM2M5ZmUyMWUyODc1MDYxMDIyMw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-05-11T23:48:21Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-05-11T23:48:21Z"}, "message": "c-lex.c (lex_charconst): Convert into a simple wrapper around cpp_interpret_charconst...\n\n\t* c-lex.c (lex_charconst): Convert into a simple wrapper\n\taround cpp_interpret_charconst, to which most of the code\n\tbody is moved.\n\t* cppexp.c (MAX_CHAR_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE,\n\tMAX_LONG_TYPE_SIZE, MAX_INT_TYPE_SIZE, MAX_CHAR_TYPE_MASK,\n\tMAX_WCHAR_TYPE_MASK, parse_escape, parse_charconst): Remove.\n\t(lex): Use cpp_interpret_charconst.\n\t* cpplex.c (parse_escape, read_ucs, cpp_interpret_charconst,\n\thex_digit_value): New functions.\n\t(MAX_CHAR_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE): New macros.\n\t* cpplib.h (cpp_interpret_charconst): New prototype.\n\t* Makefile.in: Update.\n\nFrom-SVN: r41978", "tree": {"sha": "eefc97fe7077fa7f6cfc9bb868638feb3419f0dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eefc97fe7077fa7f6cfc9bb868638feb3419f0dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8a96070172673d05574e3c9fe21e28750610223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a96070172673d05574e3c9fe21e28750610223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a96070172673d05574e3c9fe21e28750610223", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a96070172673d05574e3c9fe21e28750610223/comments", "author": null, "committer": null, "parents": [{"sha": "f42974dc81a20a5ea306fab56faef8c322bf26d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f42974dc81a20a5ea306fab56faef8c322bf26d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f42974dc81a20a5ea306fab56faef8c322bf26d2"}], "stats": {"total": 709, "additions": 404, "deletions": 305}, "files": [{"sha": "c04386c2acc1c88a9e2463c99bee023a75693ecd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a96070172673d05574e3c9fe21e28750610223/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a96070172673d05574e3c9fe21e28750610223/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8a96070172673d05574e3c9fe21e28750610223", "patch": "@@ -1,3 +1,18 @@\n+2001-05-12  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-lex.c (lex_charconst): Convert into a simple wrapper\n+\taround cpp_interpret_charconst, to which most of the code\n+\tbody is moved.\n+\t* cppexp.c (MAX_CHAR_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE,\n+\tMAX_LONG_TYPE_SIZE, MAX_INT_TYPE_SIZE, MAX_CHAR_TYPE_MASK,\n+\tMAX_WCHAR_TYPE_MASK, parse_escape, parse_charconst): Remove.\n+\t(lex): Use cpp_interpret_charconst.\n+\t* cpplex.c (parse_escape, read_ucs, cpp_interpret_charconst,\n+\thex_digit_value): New functions.\n+\t(MAX_CHAR_TYPE_SIZE, MAX_WCHAR_TYPE_SIZE): New macros.\n+\t* cpplib.h (cpp_interpret_charconst): New prototype.\n+\t* Makefile.in: Update.\n+\n 2001-05-12  Dean Wakerley  <dean@wakerley.com>\n \n \t* doc/install.texi: New file. Converted to texinfo from the HTML"}, {"sha": "304f6f88ea8620d72296d565bb0eb657cce33daa", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a96070172673d05574e3c9fe21e28750610223/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a96070172673d05574e3c9fe21e28750610223/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c8a96070172673d05574e3c9fe21e28750610223", "patch": "@@ -1955,7 +1955,7 @@ cppmain.o:  cppmain.c  $(CONFIG_H) cpplib.h intl.h $(SYSTEM_H)\n \n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n-cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n+cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS) mbchar.h\n cppmacro.o: cppmacro.c $(CONFIG_H) $(LIBCPP_DEPS)\n cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)"}, {"sha": "3a321ac11996af0c9dbfbcd20dcfa0b91ddc0325", "filename": "gcc/c-lex.c", "status": "modified", "additions": 24, "deletions": 102, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=c8a96070172673d05574e3c9fe21e28750610223", "patch": "@@ -86,7 +86,7 @@ static const char *read_ucs \tPARAMS ((const char *, const char *,\n static void parse_float\t\tPARAMS ((PTR));\n static tree lex_number\t\tPARAMS ((const char *, unsigned int));\n static tree lex_string\t\tPARAMS ((const char *, unsigned int, int));\n-static tree lex_charconst\tPARAMS ((const char *, unsigned int, int));\n+static tree lex_charconst\tPARAMS ((const cpp_token *));\n static void update_header_times\tPARAMS ((const char *));\n static int dump_one_header\tPARAMS ((splay_tree_node, void *));\n static void cb_ident\t\tPARAMS ((cpp_reader *, const cpp_string *));\n@@ -1008,8 +1008,7 @@ c_lex (value)\n \n     case CPP_CHAR:\n     case CPP_WCHAR:\n-      *value = lex_charconst ((const char *)tok.val.str.text,\n-\t\t\t      tok.val.str.len, tok.type == CPP_WCHAR);\n+      *value = lex_charconst (&tok);\n       break;\n \n     case CPP_STRING:\n@@ -1607,113 +1606,36 @@ lex_string (str, len, wide)\n   return value;\n }\n \n+/* Converts a (possibly wide) character constant token into a tree.  */\n static tree\n-lex_charconst (str, len, wide)\n-     const char *str;\n-     unsigned int len;\n-     int wide;\n+lex_charconst (token)\n+     const cpp_token *token;\n {\n-  const char *limit = str + len;\n-  int result = 0;\n-  int num_chars = 0;\n-  int chars_seen = 0;\n-  unsigned width = TYPE_PRECISION (char_type_node);\n-  int max_chars;\n-  unsigned int c;\n+  HOST_WIDE_INT result;\n   tree value;\n-\n-#ifdef MULTIBYTE_CHARS\n-  int longest_char = local_mb_cur_max ();\n-  (void) local_mbtowc (NULL, NULL, 0);\n-#endif\n-\n-  max_chars = TYPE_PRECISION (integer_type_node) / width;\n-  if (wide)\n-    width = WCHAR_TYPE_SIZE;\n-\n-  while (str < limit)\n-    {\n-#ifdef MULTIBYTE_CHARS\n-      wchar_t wc;\n-      int char_len;\n-\n-      char_len = local_mbtowc (&wc, str, limit - str);\n-      if (char_len == -1)\n-\t{\n-\t  warning (\"Ignoring invalid multibyte character\");\n-\t  char_len = 1;\n-\t  c = *str++;\n-\t}\n-      else\n-\t{\n-\t  str += char_len;\n-\t  c = wc;\n-\t}\n-#else\n-      c = *str++;\n-#endif\n-\n-      ++chars_seen;\n-      if (c == '\\\\')\n-\t{\n-\t  str = readescape (str, limit, &c);\n-\t  if (width < HOST_BITS_PER_INT\n-\t      && (unsigned) c >= ((unsigned)1 << width))\n-\t    pedwarn (\"escape sequence out of range for character\");\n-\t}\n-#ifdef MAP_CHARACTER\n-      if (ISPRINT (c))\n-\tc = MAP_CHARACTER (c);\n-#endif\n-      \n-      /* Merge character into result; ignore excess chars.  */\n-      num_chars += (width / TYPE_PRECISION (char_type_node));\n-      if (num_chars < max_chars + 1)\n-\t{\n-\t  if (width < HOST_BITS_PER_INT)\n-\t    result = (result << width) | (c & ((1 << width) - 1));\n-\t  else\n-\t    result = c;\n-\t}\n-    }\n-\n-  if (chars_seen == 0)\n-    error (\"empty character constant\");\n-  else if (num_chars > max_chars)\n+  unsigned int chars_seen;\n+ \n+  result = cpp_interpret_charconst (parse_in, token, warn_multichar,\n+ \t\t\t\t    flag_traditional, &chars_seen);\n+  if (token->type == CPP_WCHAR)\n     {\n-      num_chars = max_chars;\n-      error (\"character constant too long\");\n+      value = build_int_2 (result, 0);\n+      TREE_TYPE (value) = wchar_type_node;\n     }\n-  else if (chars_seen != 1 && ! flag_traditional && warn_multichar)\n-    warning (\"multi-character character constant\");\n-\n-  /* If char type is signed, sign-extend the constant.  */\n-  if (! wide)\n+  else\n     {\n-      int num_bits = num_chars * width;\n-      if (num_bits == 0)\n-\t/* We already got an error; avoid invalid shift.  */\n-\tvalue = build_int_2 (0, 0);\n-      else if (TREE_UNSIGNED (char_type_node)\n-\t       || ((result >> (num_bits - 1)) & 1) == 0)\n-\tvalue = build_int_2 (result & (~(unsigned HOST_WIDE_INT) 0\n-\t\t\t\t       >> (HOST_BITS_PER_WIDE_INT - num_bits)),\n-\t\t\t     0);\n+      if (result < 0)\n+ \tvalue = build_int_2 (result, -1);\n       else\n-\tvalue = build_int_2 (result | ~(~(unsigned HOST_WIDE_INT) 0\n-\t\t\t\t\t>> (HOST_BITS_PER_WIDE_INT - num_bits)),\n-\t\t\t     -1);\n-      /* In C, a character constant has type 'int'; in C++, 'char'.  */\n-      if (chars_seen <= 1 && c_language == clk_cplusplus)\n-\tTREE_TYPE (value) = char_type_node;\n+ \tvalue = build_int_2 (result, 0);\n+ \n+      /* In C, a character constant has type 'int'.\n+ \t In C++ 'char', but multi-char charconsts have type 'int'.  */\n+      if (c_language == clk_cplusplus && chars_seen <= 1)\n+ \tTREE_TYPE (value) = char_type_node;\n       else\n-\tTREE_TYPE (value) = integer_type_node;\n+ \tTREE_TYPE (value) = integer_type_node;\n     }\n-  else\n-    {\n-      value = build_int_2 (result, 0);\n-      TREE_TYPE (value) = wchar_type_node;\n-    }\n-\n+ \n   return value;\n }"}, {"sha": "acfa30ee5a407e2d5af5f2657fb4500e1887bf81", "filename": "gcc/cppexp.c", "status": "modified", "additions": 9, "deletions": 201, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=c8a96070172673d05574e3c9fe21e28750610223", "patch": "@@ -18,37 +18,11 @@ along with this program; if not, write to the Free Software\n Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Parse a C expression from text in a string  */\n-   \n #include \"config.h\"\n #include \"system.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-#ifndef MAX_CHAR_TYPE_SIZE\n-#define MAX_CHAR_TYPE_SIZE CHAR_TYPE_SIZE\n-#endif\n-\n-#ifndef MAX_INT_TYPE_SIZE\n-#define MAX_INT_TYPE_SIZE INT_TYPE_SIZE\n-#endif\n-\n-#ifndef MAX_LONG_TYPE_SIZE\n-#define MAX_LONG_TYPE_SIZE LONG_TYPE_SIZE\n-#endif\n-\n-#ifndef MAX_WCHAR_TYPE_SIZE\n-#define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n-#endif\n-\n-#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n-\t\t    ? (~(~(HOST_WIDEST_INT) 0 << MAX_CHAR_TYPE_SIZE)) \\\n-\t\t    : ~ (HOST_WIDEST_INT) 0)\n-\n-#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDEST_INT \\\n-\t\t\t     ? ~(~(HOST_WIDEST_INT) 0 << MAX_WCHAR_TYPE_SIZE) \\\n-\t\t\t     : ~ (HOST_WIDEST_INT) 0)\n-\n /* Yield nonzero if adding two numbers with A's and B's signs can yield a\n    number with SUM's sign, where A, B, and SUM are all C integers.  */\n #define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)\n@@ -61,10 +35,7 @@ static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT,\n \t\t\t\t\t    unsigned int,\n \t\t\t\t\t    unsigned HOST_WIDEST_INT));\n static struct op parse_number PARAMS ((cpp_reader *, const cpp_token *));\n-static struct op parse_charconst PARAMS ((cpp_reader *, const cpp_token *));\n static struct op parse_defined PARAMS ((cpp_reader *));\n-static HOST_WIDEST_INT parse_escape PARAMS ((cpp_reader *, const U_CHAR **,\n-\t\t\t\t\t     const U_CHAR *, HOST_WIDEST_INT));\n static struct op lex PARAMS ((cpp_reader *, int, cpp_token *));\n static const unsigned char *op_as_text PARAMS ((cpp_reader *, enum cpp_ttype));\n \n@@ -238,81 +209,6 @@ parse_number (pfile, tok)\n   return op;\n }\n \n-/* Parse and convert a character constant for #if.  Understands backslash\n-   escapes (\\n, \\031) and multibyte characters (if so configured).  */\n-static struct op\n-parse_charconst (pfile, tok)\n-     cpp_reader *pfile;\n-     const cpp_token *tok;\n-{\n-  struct op op;\n-  HOST_WIDEST_INT result = 0;\n-  int num_chars = 0;\n-  int num_bits;\n-  unsigned int width = MAX_CHAR_TYPE_SIZE;\n-  HOST_WIDEST_INT mask = MAX_CHAR_TYPE_MASK;\n-  int max_chars;\n-  const U_CHAR *ptr = tok->val.str.text;\n-  const U_CHAR *end = ptr + tok->val.str.len;\n-\n-  int c = -1;\n-\n-  if (tok->type == CPP_WCHAR)\n-    width = MAX_WCHAR_TYPE_SIZE, mask = MAX_WCHAR_TYPE_MASK;\n-  max_chars = MAX_LONG_TYPE_SIZE / width;\n-\n-  while (ptr < end)\n-    {\n-      c = *ptr++;\n-      if (c == '\\'')\n-\tCPP_ICE (\"unescaped ' in character constant\");\n-      else if (c == '\\\\')\n-\t{\n-\t  c = parse_escape (pfile, &ptr, end, mask);\n-\t  if (width < HOST_BITS_PER_INT\n-\t      && (unsigned int) c >= (unsigned int)(1 << width))\n-\t    cpp_pedwarn (pfile,\n-\t\t\t \"escape sequence out of range for character\");\n-\t}\n-\t  \n-      /* Merge character into result; ignore excess chars.  */\n-      if (++num_chars <= max_chars)\n-\t{\n-\t  if (width < HOST_BITS_PER_INT)\n-\t    result = (result << width) | (c & ((1 << width) - 1));\n-\t  else\n-\t    result = c;\n-\t}\n-    }\n-\n-  if (num_chars == 0)\n-    SYNTAX_ERROR (\"empty character constant\");\n-  else if (num_chars > max_chars)\n-    SYNTAX_ERROR (\"character constant too long\");\n-  else if (num_chars != 1)\n-    cpp_warning (pfile, \"multi-character character constant\");\n-\n-  /* If char type is signed, sign-extend the constant.  */\n-  num_bits = num_chars * width;\n-      \n-  if (pfile->spec_nodes.n__CHAR_UNSIGNED__->type == NT_MACRO\n-      || ((result >> (num_bits - 1)) & 1) == 0)\n-    op.value = result & ((unsigned HOST_WIDEST_INT) ~0\n-\t\t\t >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n-  else\n-    op.value = result | ~((unsigned HOST_WIDEST_INT) ~0\n-\t\t\t  >> (HOST_BITS_PER_WIDEST_INT - num_bits));\n-\n-  /* This is always a signed type.  */\n-  op.unsignedp = 0;\n-  op.op = CPP_INT;\n-  return op;\n-\n- syntax_error:\n-  op.op = CPP_ERROR;\n-  return op;\n-}\n-\n static struct op\n parse_defined (pfile)\n      cpp_reader *pfile;\n@@ -405,7 +301,15 @@ lex (pfile, skip_evaluation, token)\n \n     case CPP_CHAR:\n     case CPP_WCHAR:\n-      return parse_charconst (pfile, token);\n+      {\n+\tunsigned int chars_seen;\n+\n+\t/* This is always a signed type.  */\n+\top.unsignedp = 0;\n+\top.op = CPP_INT;\n+\top.value = cpp_interpret_charconst (pfile, token, 1, 0, &chars_seen);\n+\treturn op;\n+      }\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n@@ -494,102 +398,6 @@ lex (pfile, skip_evaluation, token)\n   return op;\n }\n \n-/* Parse a C escape sequence.  STRING_PTR points to a variable\n-   containing a pointer to the string to parse.  That pointer\n-   is updated past the characters we use.  The value of the\n-   escape sequence is returned.\n-\n-   If \\ is followed by 000, we return 0 and leave the string pointer\n-   after the zeros.  A value of 0 does not mean end of string.  */\n-\n-static HOST_WIDEST_INT\n-parse_escape (pfile, string_ptr, limit, result_mask)\n-     cpp_reader *pfile;\n-     const U_CHAR **string_ptr;\n-     const U_CHAR *limit;\n-     HOST_WIDEST_INT result_mask;\n-{\n-  const U_CHAR *ptr = *string_ptr;\n-  /* We know we have at least one following character.  */\n-  int c = *ptr++;\n-  switch (c)\n-    {\n-    case 'a': c = TARGET_BELL;\t  break;\n-    case 'b': c = TARGET_BS;\t  break;\n-    case 'f': c = TARGET_FF;\t  break;\n-    case 'n': c = TARGET_NEWLINE; break;\n-    case 'r': c = TARGET_CR;\t  break;\n-    case 't': c = TARGET_TAB;\t  break;\n-    case 'v': c = TARGET_VT;\t  break;\n-\n-    case 'e': case 'E':\n-      if (CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"non-ISO-standard escape sequence, '\\\\%c'\", c);\n-      c = TARGET_ESC;\n-      break;\n-      \n-    case '0': case '1': case '2': case '3':\n-    case '4': case '5': case '6': case '7':\n-      {\n-\tunsigned int i = c - '0';\n-\tint count = 0;\n-\twhile (++count < 3)\n-\t  {\n-\t    if (ptr >= limit)\n-\t      break;\n-\t    \n-\t    c = *ptr;\n-\t    if (c < '0' || c > '7')\n-\t      break;\n-\t    ptr++;\n-\t    i = (i << 3) + c - '0';\n-\t  }\n-\tif (i != (i & result_mask))\n-\t  {\n-\t    i &= result_mask;\n-\t    cpp_pedwarn (pfile, \"octal escape sequence out of range\");\n-\t  }\n-\tc = i;\n-\tbreak;\n-      }\n-\n-    case 'x':\n-      {\n-\tunsigned int i = 0, overflow = 0;\n-\tint digits_found = 0, digit;\n-\tfor (;;)\n-\t  {\n-\t    if (ptr >= limit)\n-\t      break;\n-\t    c = *ptr;\n-\t    if (c >= '0' && c <= '9')\n-\t      digit = c - '0';\n-\t    else if (c >= 'a' && c <= 'f')\n-\t      digit = c - 'a' + 10;\n-\t    else if (c >= 'A' && c <= 'F')\n-\t      digit = c - 'A' + 10;\n-\t    else\n-\t      break;\n-\t    ptr++;\n-\t    overflow |= i ^ (i << 4 >> 4);\n-\t    i = (i << 4) + digit;\n-\t    digits_found = 1;\n-\t  }\n-\tif (!digits_found)\n-\t  cpp_error (pfile, \"\\\\x used with no following hex digits\");\n-\tif (overflow | (i != (i & result_mask)))\n-\t  {\n-\t    i &= result_mask;\n-\t    cpp_pedwarn (pfile, \"hex escape sequence out of range\");\n-\t  }\n-\tc = i;\n-\tbreak;\n-      }\n-    }\n-  *string_ptr = ptr;\n-  return c;\n-}\n-\n static void\n integer_overflow (pfile)\n      cpp_reader *pfile;"}, {"sha": "2a038cb259e4995297094be9bda0bcd664cb98af", "filename": "gcc/cppinternals.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinternals.texi?ref=c8a96070172673d05574e3c9fe21e28750610223", "patch": "@@ -391,7 +391,7 @@ macro is defined when we leave the header file for the first time.  If\n the host supports it, we try to map suitably large files into memory,\n rather than reading them in directly.\n \n-The include paths are intenally stored on a null-terminated\n+The include paths are internally stored on a null-terminated\n singly-linked list, starting with the @code{\"header.h\"} directory search\n chain, which then links into the @code{<header.h>} directory chain.\n "}, {"sha": "9bbab0fb68676b3df3cb0e6a03360d91347825b6", "filename": "gcc/cpplex.c", "status": "modified", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=c8a96070172673d05574e3c9fe21e28750610223", "patch": "@@ -39,6 +39,18 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n+/* MULTIBYTE_CHARS support only works for native compilers.\n+   ??? Ideally what we want is to model widechar support after\n+   the current floating point support.  */\n+#ifdef CROSS_COMPILE\n+#undef MULTIBYTE_CHARS\n+#endif\n+\n+#ifdef MULTIBYTE_CHARS\n+#include \"mbchar.h\"\n+#include <locale.h>\n+#endif\n+\n /* Tokens with SPELL_STRING store their spelling in the token list,\n    and it's length in the token->val.name.len.  */\n enum spell_type\n@@ -86,9 +98,15 @@ static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n static void lex_percent PARAMS ((cpp_buffer *, cpp_token *));\n static void lex_dot PARAMS ((cpp_reader *, cpp_token *));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n+static unsigned int parse_escape PARAMS ((cpp_reader *, const unsigned char **,\n+\t\t\t\t\t  const unsigned char *, HOST_WIDE_INT,\n+\t\t\t\t\t  int));\n+static unsigned int read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n+\t\t\t\t      const unsigned char *, unsigned int));\n \n static cpp_chunk *new_chunk PARAMS ((unsigned int));\n static int chunk_suitable PARAMS ((cpp_pool *, cpp_chunk *, unsigned int));\n+static unsigned int hex_digit_value PARAMS ((unsigned int));\n \n /* Utility routine:\n \n@@ -1640,6 +1658,337 @@ cpp_output_line (pfile, fp)\n   putc ('\\n', fp);\n }\n \n+/* Returns the value of a hexadecimal digit.  */\n+static unsigned int\n+hex_digit_value (c)\n+     unsigned int c;\n+{\n+  if (c >= 'a' && c <= 'f')\n+    return c - 'a' + 10;\n+  if (c >= 'A' && c <= 'F')\n+    return c - 'A' + 10;\n+  if (c >= '0' && c <= '9')\n+    return c - '0';\n+  abort ();\n+}\n+\n+/* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence (C++ and C99).\n+\n+   [lex.charset]: The character designated by the universal character\n+   name \\UNNNNNNNN is that character whose character short name in\n+   ISO/IEC 10646 is NNNNNNNN; the character designated by the\n+   universal character name \\uNNNN is that character whose character\n+   short name in ISO/IEC 10646 is 0000NNNN.  If the hexadecimal value\n+   for a universal character name is less than 0x20 or in the range\n+   0x7F-0x9F (inclusive), or if the universal character name\n+   designates a character in the basic source character set, then the\n+   program is ill-formed.\n+\n+   We assume that wchar_t is Unicode, so we don't need to do any\n+   mapping.  Is this ever wrong?  */\n+\n+static unsigned int\n+read_ucs (pfile, pstr, limit, length)\n+     cpp_reader *pfile;\n+     const unsigned char **pstr;\n+     const unsigned char *limit;\n+     unsigned int length;\n+{\n+  const unsigned char *p = *pstr;\n+  unsigned int c, code = 0;\n+\n+  for (; length; --length)\n+    {\n+      if (p >= limit)\n+\t{\n+\t  cpp_error (pfile, \"incomplete universal-character-name\");\n+\t  break;\n+\t}\n+\n+      c = *p;\n+      if (ISXDIGIT (c))\n+\t{\n+\t  code = (code << 4) + hex_digit_value (c);\n+\t  p++;\n+\t}\n+      else\n+\t{\n+\t  cpp_error (pfile,\n+\t\t     \"non-hex digit '%c' in universal-character-name\", c);\n+\t  break;\n+\t}\n+\n+    }\n+\n+#ifdef TARGET_EBCDIC\n+  cpp_error (pfile, \"universal-character-name on EBCDIC target\");\n+  code = 0x3f;  /* EBCDIC invalid character */\n+#else\n+  if (code > 0x9f && !(code & 0x80000000))\n+    ; /* True extended character, OK.  */\n+  else if (code >= 0x20 && code < 0x7f)\n+    {\n+      /* ASCII printable character.  The C character set consists of all of\n+\t these except $, @ and `.  We use hex escapes so that this also\n+\t works with EBCDIC hosts.  */\n+      if (code != 0x24 && code != 0x40 && code != 0x60)\n+\tcpp_error (pfile, \"universal-character-name used for '%c'\", code);\n+    }\n+  else\n+    cpp_error (pfile, \"invalid universal-character-name\");\n+#endif\n+\n+  *pstr = p;\n+  return code;\n+}\n+\n+/* Interpret an escape sequence, and return its value.  PSTR points to\n+   the input pointer, which is just after the backslash.  LIMIT is how\n+   much text we have.  MASK is the precision for the target type (char\n+   or wchar_t).  TRADITIONAL, if true, does not interpret escapes that\n+   did not exist in traditional C.  */\n+\n+static unsigned int\n+parse_escape (pfile, pstr, limit, mask, traditional)\n+     cpp_reader *pfile;\n+     const unsigned char **pstr;\n+     const unsigned char *limit;\n+     HOST_WIDE_INT mask;\n+     int traditional;\n+{\n+  int unknown = 0;\n+  const unsigned char *str = *pstr;\n+  unsigned int c = *str++;\n+\n+  switch (c)\n+    {\n+    case '\\\\': case '\\'': case '\"': case '?': break;\n+    case 'b': c = TARGET_BS;\t  break;\n+    case 'f': c = TARGET_FF;\t  break;\n+    case 'n': c = TARGET_NEWLINE; break;\n+    case 'r': c = TARGET_CR;\t  break;\n+    case 't': c = TARGET_TAB;\t  break;\n+    case 'v': c = TARGET_VT;\t  break;\n+\n+    case '(': case '{': case '[': case '%':\n+      /* '\\(', etc, are used at beginning of line to avoid confusing Emacs.\n+\t '\\%' is used to prevent SCCS from getting confused.  */\n+      unknown = CPP_PEDANTIC (pfile);\n+      break;\n+\n+    case 'a':\n+      if (CPP_WTRADITIONAL (pfile))\n+\tcpp_warning (pfile, \"the meaning of '\\\\a' varies with -traditional\");\n+      if (!traditional)\n+\tc = TARGET_BELL;\n+      break;\n+\n+    case 'e': case 'E':\n+      if (CPP_PEDANTIC (pfile))\n+\tcpp_pedwarn (pfile, \"non-ISO-standard escape sequence, '\\\\%c'\", c);\n+      c = TARGET_ESC;\n+      break;\n+      \n+      /* Warnings and support checks handled by read_ucs().  */\n+    case 'u': case 'U':\n+      if (CPP_OPTION (pfile, cplusplus) || CPP_OPTION (pfile, c99))\n+\t{\n+\t  if (CPP_WTRADITIONAL (pfile))\n+\t    cpp_warning (pfile,\n+\t\t\t \"the meaning of '\\\\%c' varies with -traditional\", c);\n+\t  c = read_ucs (pfile, &str, limit, c == 'u' ? 4 : 8);\n+\t}\n+      else\n+\tunknown = 1;\n+      break;\n+\n+    case 'x':\n+      if (CPP_WTRADITIONAL (pfile))\n+\tcpp_warning (pfile, \"the meaning of '\\\\x' varies with -traditional\");\n+\n+      if (!traditional)\n+\t{\n+\t  unsigned int i = 0, overflow = 0;\n+\t  int digits_found = 0;\n+\n+\t  while (str < limit)\n+\t    {\n+\t      c = *str;\n+\t      if (! ISXDIGIT (c))\n+\t\tbreak;\n+\t      str++;\n+\t      overflow |= i ^ (i << 4 >> 4);\n+\t      i = (i << 4) + hex_digit_value (c);\n+\t      digits_found = 1;\n+\t    }\n+\n+\t  if (!digits_found)\n+\t    cpp_error (pfile, \"\\\\x used with no following hex digits\");\n+\n+\t  if (overflow | (i != (i & mask)))\n+\t    {\n+\t      cpp_pedwarn (pfile, \"hex escape sequence out of range\");\n+\t      i &= mask;\n+\t    }\n+\t  c = i;\n+\t}\n+      break;\n+\n+    case '0':  case '1':  case '2':  case '3':\n+    case '4':  case '5':  case '6':  case '7':\n+      {\n+\tunsigned int i = c - '0';\n+\tint count = 0;\n+\n+\twhile (str < limit && ++count < 3)\n+\t  {\n+\t    c = *str;\n+\t    if (c < '0' || c > '7')\n+\t      break;\n+\t    str++;\n+\t    i = (i << 3) + c - '0';\n+\t  }\n+\n+\tif (i != (i & mask))\n+\t  {\n+\t    cpp_pedwarn (pfile, \"octal escape sequence out of range\");\n+\t    i &= mask;\n+\t  }\n+\tc = i;\n+      }\n+      break;\n+\n+    default:\n+      unknown = 1;\n+      break;\n+    }\n+\n+  if (unknown)\n+    {\n+      if (ISGRAPH (c))\n+\tcpp_pedwarn (pfile, \"unknown escape sequence '\\\\%c'\", c);\n+      else\n+\tcpp_pedwarn (pfile, \"unknown escape sequence: '\\\\%03o'\", c);\n+    }\n+\n+  *pstr = str;\n+  return c;\n+}\n+\n+#ifndef MAX_CHAR_TYPE_SIZE\n+#define MAX_CHAR_TYPE_SIZE CHAR_TYPE_SIZE\n+#endif\n+\n+#ifndef MAX_WCHAR_TYPE_SIZE\n+#define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE\n+#endif\n+\n+/* Interpret a (possibly wide) character constant in TOKEN.\n+   WARN_MULTI warns about multi-character charconsts, if not\n+   TRADITIONAL.  TRADITIONAL also indicates not to interpret escapes\n+   that did not exist in traditional C.  PCHARS_SEEN points to a\n+   variable that is filled in with the number of characters seen.  */\n+HOST_WIDE_INT\n+cpp_interpret_charconst (pfile, token, warn_multi, traditional, pchars_seen)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+     int warn_multi;\n+     int traditional;\n+     unsigned int *pchars_seen;\n+{\n+  const unsigned char *str = token->val.str.text;\n+  const unsigned char *limit = str + token->val.str.len;\n+  unsigned int chars_seen = 0;\n+  unsigned int width, max_chars, c;\n+  HOST_WIDE_INT result = 0, mask;\n+\n+#ifdef MULTIBYTE_CHARS\n+  (void) local_mbtowc (NULL, NULL, 0);\n+#endif\n+\n+  /* Width in bits.  */\n+  if (token->type == CPP_CHAR)\n+    width = MAX_CHAR_TYPE_SIZE;\n+  else\n+    width = MAX_WCHAR_TYPE_SIZE;\n+\n+  if (width < HOST_BITS_PER_WIDE_INT)\n+    mask = ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+  else\n+    mask = ~0;\n+  max_chars = HOST_BITS_PER_WIDE_INT / width;\n+\n+  while (str < limit)\n+    {\n+#ifdef MULTIBYTE_CHARS\n+      wchar_t wc;\n+      int char_len;\n+\n+      char_len = local_mbtowc (&wc, str, limit - str);\n+      if (char_len == -1)\n+\t{\n+\t  cpp_warning (pfile, \"ignoring invalid multibyte character\");\n+\t  c = *str++;\n+\t}\n+      else\n+\t{\n+\t  str += char_len;\n+\t  c = wc;\n+\t}\n+#else\n+      c = *str++;\n+#endif\n+\n+      if (c == '\\\\')\n+\t{\n+\t  c = parse_escape (pfile, &str, limit, mask, traditional);\n+\t  if (width < HOST_BITS_PER_WIDE_INT && c > mask)\n+\t    cpp_pedwarn (pfile, \"escape sequence out of range for character\");\n+\t}\n+\n+#ifdef MAP_CHARACTER\n+      if (ISPRINT (c))\n+\tc = MAP_CHARACTER (c);\n+#endif\n+      \n+      /* Merge character into result; ignore excess chars.  */\n+      if (++chars_seen <= max_chars)\n+\t{\n+\t  if (width < HOST_BITS_PER_WIDE_INT)\n+\t    result = (result << width) | (c & mask);\n+\t  else\n+\t    result = c;\n+\t}\n+    }\n+\n+  if (chars_seen == 0)\n+    cpp_error (pfile, \"empty character constant\");\n+  else if (chars_seen > max_chars)\n+    {\n+      chars_seen = max_chars;\n+      cpp_error (pfile, \"character constant too long\");\n+    }\n+  else if (chars_seen > 1 && !traditional && warn_multi)\n+    cpp_warning (pfile, \"multi-character character constant\");\n+\n+  /* If char type is signed, sign-extend the constant.  The\n+     __CHAR_UNSIGNED__ macro is set by the driver if appropriate.  */\n+  if (token->type == CPP_CHAR && chars_seen)\n+    {\n+      unsigned int nbits = chars_seen * width;\n+      unsigned int mask = (unsigned int) ~0 >> (HOST_BITS_PER_INT - nbits);\n+\n+      if (pfile->spec_nodes.n__CHAR_UNSIGNED__->type == NT_MACRO\n+\t  || ((result >> (nbits - 1)) & 1) == 0)\n+\tresult &= mask;\n+      else\n+\tresult |= ~mask;\n+    }\n+\n+  *pchars_seen = chars_seen;\n+  return result;\n+}\n+\n /* Memory pools.  */\n \n struct dummy"}, {"sha": "dc4c763ed19b1f714dce2dca33f5232bb503f8f0", "filename": "gcc/cpplib.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a96070172673d05574e3c9fe21e28750610223/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c8a96070172673d05574e3c9fe21e28750610223", "patch": "@@ -542,6 +542,11 @@ extern const cpp_lexer_pos *cpp_get_line PARAMS ((cpp_reader *));\n extern const unsigned char *cpp_macro_definition PARAMS ((cpp_reader *,\n \t\t\t\t\t\t  const cpp_hashnode *));\n \n+/* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\n+extern HOST_WIDE_INT\n+cpp_interpret_charconst PARAMS ((cpp_reader *, const cpp_token *,\n+\t\t\t\t int, int, unsigned int *));\n+\n extern void cpp_define PARAMS ((cpp_reader *, const char *));\n extern void cpp_assert PARAMS ((cpp_reader *, const char *));\n extern void cpp_undef  PARAMS ((cpp_reader *, const char *));"}]}