{"sha": "10f4f6354022760060f5256e175500dc12392c09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmNGY2MzU0MDIyNzYwMDYwZjUyNTZlMTc1NTAwZGMxMjM5MmMwOQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2003-03-03T19:50:38Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2003-03-03T19:50:38Z"}, "message": "sh.h (OVERRIDE_OPTIONS): Set default values for align_loops and align_jumps if not set.\n\n\t* sh.h (OVERRIDE_OPTIONS): Set default values for align_loops\n\tand align_jumps if not set.\n\tForce align_jumps to be at least 2.\n\tWhen relaxing, force align_functions to be at least the maximum of\n\talign_loops, align_jumps and 4.\n\t* sh.c (find_barrier, barrier_align): Honour align_jumps_log.\n\t(sh_loop_align): Honour align_loops_log.\n\n\t* sh.md (length attribute): Use prev_nonnote_insn instead of PREV_INSN\n\tto check for indirect_jump_scratch.\n\t(indirect_jump_scratch): Add second set.\n\t* sh.c (output_far_jump): Use prev_nonnote_insn instead of PREV_INSN\n\twhen looking for indirect_jump_scratch.\n\tExtract scratch register taking new structure of indirect_jump_scratch\n\tinto account.\n\t(gen_block_redirect): Set INSN_SCOPE for indirect_jump_scratch.\n\nFrom-SVN: r63728", "tree": {"sha": "d711723f7b4c2a1fad5e37cd586b4b8490d3dba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d711723f7b4c2a1fad5e37cd586b4b8490d3dba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10f4f6354022760060f5256e175500dc12392c09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f4f6354022760060f5256e175500dc12392c09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f4f6354022760060f5256e175500dc12392c09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f4f6354022760060f5256e175500dc12392c09/comments", "author": null, "committer": null, "parents": [{"sha": "ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebcc6a7ec08a1e7cc2cf1d2a06daebbb904bde25"}], "stats": {"total": 94, "additions": 77, "deletions": 17}, "files": [{"sha": "436ee289aa4ea1ca7904811156b559f0da010ccf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f4f6354022760060f5256e175500dc12392c09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f4f6354022760060f5256e175500dc12392c09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10f4f6354022760060f5256e175500dc12392c09", "patch": "@@ -1,3 +1,22 @@\n+Mon Mar  3 19:47:26 2003  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.h (OVERRIDE_OPTIONS): Set default values for align_loops\n+\tand align_jumps if not set.\n+\tForce align_jumps to be at least 2.\n+\tWhen relaxing, force align_functions to be at least the maximum of\n+\talign_loops, align_jumps and 4.\n+\t* sh.c (find_barrier, barrier_align): Honour align_jumps_log.\n+\t(sh_loop_align): Honour align_loops_log.\n+\n+\t* sh.md (length attribute): Use prev_nonnote_insn instead of PREV_INSN\n+\tto check for indirect_jump_scratch.\n+\t(indirect_jump_scratch): Add second set.\n+\t* sh.c (output_far_jump): Use prev_nonnote_insn instead of PREV_INSN\n+\twhen looking for indirect_jump_scratch.\n+\tExtract scratch register taking new structure of indirect_jump_scratch\n+\tinto account.\n+\t(gen_block_redirect): Set INSN_SCOPE for indirect_jump_scratch.\n+\n Mon Mar  3 19:07:21 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* calls.c (rtx_for_function_call): Take the address as an argument"}, {"sha": "e3f9a26398b983fbfb668b48242d1bab4d705ec4", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f4f6354022760060f5256e175500dc12392c09/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f4f6354022760060f5256e175500dc12392c09/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=10f4f6354022760060f5256e175500dc12392c09", "patch": "@@ -1048,6 +1048,7 @@ output_far_jump (insn, op)\n   const char *jump;\n   int far;\n   int offset = branch_dest (insn) - INSN_ADDRESSES (INSN_UID (insn));\n+  rtx prev;\n \n   this.lab = gen_label_rtx ();\n \n@@ -1072,10 +1073,10 @@ output_far_jump (insn, op)\n \tjump = \"mov.l\t%O0,%1; jmp\t@%1\";\n     }\n   /* If we have a scratch register available, use it.  */\n-  if (GET_CODE (PREV_INSN (insn)) == INSN\n-      && INSN_CODE (PREV_INSN (insn)) == CODE_FOR_indirect_jump_scratch)\n+  if (GET_CODE ((prev = prev_nonnote_insn (insn))) == INSN\n+      && INSN_CODE (prev) == CODE_FOR_indirect_jump_scratch)\n     {\n-      this.reg = SET_DEST (PATTERN (PREV_INSN (insn)));\n+      this.reg = SET_DEST (XVECEXP (PATTERN (prev), 0, 0));\n       if (REGNO (this.reg) == R0_REG && flag_pic && ! TARGET_SH2)\n \tjump = \"mov.l\tr1,@-r15; mova\t%O0,r0; mov.l\t@r0,r1; add\tr1,r0; mov.l\t@r15+,r1; jmp\t@%1\";\n       output_asm_insn (jump, &this.lab);\n@@ -3016,7 +3017,7 @@ find_barrier (num_mova, mova, from)\n \t{\n \t  if (num_mova)\n \t    num_mova--;\n-\t  if (barrier_align (next_real_insn (from)) == CACHE_LOG)\n+\t  if (barrier_align (next_real_insn (from)) == align_jumps_log)\n \t    {\n \t      /* We have just passed the barrier in front of the\n \t\t ADDR_DIFF_VEC, which is stored in found_barrier.  Since\n@@ -3454,6 +3455,13 @@ gen_block_redirect (jump, addr, need_block)\n       rtx insn = emit_insn_before (gen_indirect_jump_scratch\n \t\t\t\t   (reg, GEN_INT (INSN_UID (JUMP_LABEL (jump))))\n \t\t\t\t   , jump);\n+      /* ??? We would like this to have the scope of the jump, but that\n+\t scope will change when a delay slot insn of an inner scope is added.\n+\t Hence, after delay slot scheduling, we'll have to expect\n+\t NOTE_INSN_BLOCK_END notes between the indirect_jump_scratch and\n+\t the jump.  */\n+\t \n+      INSN_SCOPE (insn) = INSN_SCOPE (jump);\n       INSN_CODE (insn) = CODE_FOR_indirect_jump_scratch;\n       return insn;\n     }\n@@ -3596,14 +3604,14 @@ barrier_align (barrier_or_label)\n       return ((TARGET_SMALLCODE\n \t       || ((unsigned) XVECLEN (pat, 1) * GET_MODE_SIZE (GET_MODE (pat))\n \t\t   <= (unsigned)1 << (CACHE_LOG - 2)))\n-\t      ? 1 << TARGET_SHMEDIA : CACHE_LOG);\n+\t      ? 1 << TARGET_SHMEDIA : align_jumps_log);\n     }\n \n   if (TARGET_SMALLCODE)\n     return 0;\n \n   if (! TARGET_SH2 || ! optimize)\n-    return CACHE_LOG;\n+    return align_jumps_log;\n \n   /* When fixing up pcloads, a constant table might be inserted just before\n      the basic block that ends with the barrier.  Thus, we can't trust the\n@@ -3679,7 +3687,7 @@ barrier_align (barrier_or_label)\n \t}\n     }\n   \n-  return CACHE_LOG;\n+  return align_jumps_log;\n }\n \n /* If we are inside a phony loop, almost any kind of label can turn up as the\n@@ -3704,10 +3712,7 @@ sh_loop_align (label)\n       || recog_memoized (next) == CODE_FOR_consttable_2)\n     return 0;\n \n-  if (TARGET_SH5)\n-    return 3;\n-\n-  return 2;\n+  return align_loops_log;\n }\n \n /* Exported to toplev.c.\n@@ -4418,9 +4423,6 @@ split_branches (first)\n    If relaxing, output the label and pseudo-ops used to link together\n    calls and the instruction which set the registers.  */\n \n-/* ??? This is unnecessary, and probably should be deleted.  This makes\n-   the insn_addresses declaration above unnecessary.  */\n-\n /* ??? The addresses printed by this routine for insns are nonsense for\n    insns which are inside of a sequence where none of the inner insns have\n    variable length.  This is because the second pass of shorten_branches"}, {"sha": "5e1712a18dccb48513d7ace01025d6f86aea9075", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f4f6354022760060f5256e175500dc12392c09/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f4f6354022760060f5256e175500dc12392c09/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=10f4f6354022760060f5256e175500dc12392c09", "patch": "@@ -489,13 +489,34 @@ do {\t\t\t\t\t\t\t\t\t\\\n       flag_schedule_insns = 0;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  if (align_loops == 0)\t\t\t\t\t\t\t\\\n+    align_loops =  1 << (TARGET_SH5 ? 3 : 2);\t\t\t\t\\\n+  if (align_jumps == 0)\t\t\t\t\t\t\t\\\n+    align_jumps = 1 << CACHE_LOG;\t\t\t\t\t\\\n+  else if (align_jumps <= 1)\t\t\t\t\t\t\\\n+    align_jumps = 2;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   /* Allocation boundary (in *bytes*) for the code of a function.\t\\\n      SH1: 32 bit alignment is faster, because instructions are always\t\\\n      fetched as a pair from a longword boundary.\t\t\t\\\n      SH2 .. SH5 : align to cache line start.  */\t\t\t\\\n   if (align_functions == 0)\t\t\t\t\t\t\\\n     align_functions\t\t\t\t\t\t\t\\\n       = TARGET_SMALLCODE ? FUNCTION_BOUNDARY/8 : (1 << CACHE_LOG);\t\\\n+  /* The linker relaxation code breaks when a function contains\t\t\\\n+     alignments that are larger than that at the start of a\t\t\\\n+     compilation unit.  */\t\t\t\t\t\t\\\n+  if (TARGET_RELAX)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int min_align\t\t\t\t\t\t\t\\\n+\t= align_loops > align_jumps ? align_loops : align_jumps;\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* Also take possible .long constants / mova tables int account.\t*/\\\n+      if (min_align < 4)\t\t\t\t\t\t\\\n+\tmin_align = 4;\t\t\t\t\t\t\t\\\n+      if (align_functions < min_align)\t\t\t\t\t\\\n+\talign_functions = min_align;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \f\n /* Target machine storage layout.  */"}, {"sha": "65dd6967e8693d1b040b556c4a8503194b4a0a60", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f4f6354022760060f5256e175500dc12392c09/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f4f6354022760060f5256e175500dc12392c09/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=10f4f6354022760060f5256e175500dc12392c09", "patch": "@@ -391,9 +391,9 @@\n \t (eq_attr \"type\" \"jump\")\n \t (cond [(eq_attr \"med_branch_p\" \"yes\")\n \t\t(const_int 2)\n-\t\t(and (eq (symbol_ref \"GET_CODE (PREV_INSN (insn))\")\n+\t\t(and (eq (symbol_ref \"GET_CODE (prev_nonnote_insn (insn))\")\n \t\t\t (symbol_ref \"INSN\"))\n-\t\t     (eq (symbol_ref \"INSN_CODE (PREV_INSN (insn))\")\n+\t\t     (eq (symbol_ref \"INSN_CODE (prev_nonnote_insn (insn))\")\n \t\t\t (symbol_ref \"code_for_indirect_jump_scratch\")))\n \t\t(if_then_else (eq_attr \"braf_branch_p\" \"yes\")\n \t\t\t      (const_int 6)\n@@ -5035,9 +5035,14 @@\n \n ;; This one has the additional purpose to record a possible scratch register\n ;; for the following branch.\n+;; ??? Unfortunately, just setting the scratch register is not good enough,\n+;; because the insn then might be deemed dead and deleted.  And we can't\n+;; make the use in the jump insn explicit because that would disable\n+;; delay slot scheduling from the target.\n (define_insn \"indirect_jump_scratch\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand 1 \"const_int_operand\" \"\")] UNSPEC_BBR))]\n+\t(unspec:SI [(match_operand 1 \"const_int_operand\" \"\")] UNSPEC_BBR)) \n+   (set (pc) (unspec [(const_int 0)] UNSPEC_BBR))]\n   \"TARGET_SH1\"\n   \"\"\n   [(set_attr \"length\" \"0\")])\n@@ -5475,6 +5480,19 @@\n   [(set_attr \"type\" \"jump\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n+;; ??? It would be much saner to explicitly use the scratch register\n+;; in the jump insn, and have indirect_jump_scratch only set it,\n+;; but fill_simple_delay_slots would refuse to do delay slot filling\n+;; from the target then, as it uses simplejump_p.\n+;;(define_insn \"jump_compact_far\"\n+;;  [(set (pc)\n+;;\t(label_ref (match_operand 0 \"\" \"\")))\n+;;   (use (match_operand 1 \"register_operand\" \"r\")]\n+;;  \"TARGET_SH1\"\n+;;  \"* return output_far_jump(insn, operands[0], operands[1]);\"\n+;;  [(set_attr \"type\" \"jump\")\n+;;   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n (define_insn \"jump_media\"\n   [(set (pc)\n \t(match_operand:DI 0 \"target_operand\" \"b\"))]"}]}