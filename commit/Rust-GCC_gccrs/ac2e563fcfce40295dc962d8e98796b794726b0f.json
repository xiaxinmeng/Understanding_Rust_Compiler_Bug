{"sha": "ac2e563fcfce40295dc962d8e98796b794726b0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMyZTU2M2ZjZmNlNDAyOTVkYzk2MmQ4ZTk4Nzk2Yjc5NDcyNmIwZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-07-08T16:41:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-07-08T16:41:23Z"}, "message": "re PR target/38900 (ICE: unable to find a register to spill)\n\n\tPR target/38900\n\t* config/i386/i386.h (CONDITIONAL_REGISTER_USAGE): Move to i386.c.\n\t(enum reg_class): Add CLOBBERED_REGS.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Likewise.\n\t* config/i386/i386.c (ix86_conditional_register_usage): Moved\n\tfrom CONDITIONAL_REGISTER_USAGE; build CLOBBERED_REGS for 64-bit.\n\t(ix86_function_ok_for_sibcall): Tidy.  Disallow MS->SYSV sibcalls.\n\t(ix86_expand_call): Use sibcall_insn_operand when needed.  Don't\n\tforce 64-bit sibcalls into R11.\n\t* config/i386/constraints.md (U): New constraint.\n\t* config/i386/i386.md (sibcall_1, sibcall_value_1): Use it.\n\t(sibcall_1_rex64, sibcall_value_1_rex64): Likewise.\n\t(sibcall_1_rex64_v, sibcall_value_1_rex64_v): Remove.\n\nFrom-SVN: r149373", "tree": {"sha": "f71db91f4b324227a6722f9b26010f65116c833b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f71db91f4b324227a6722f9b26010f65116c833b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac2e563fcfce40295dc962d8e98796b794726b0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac2e563fcfce40295dc962d8e98796b794726b0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac2e563fcfce40295dc962d8e98796b794726b0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac2e563fcfce40295dc962d8e98796b794726b0f/comments", "author": null, "committer": null, "parents": [{"sha": "acb78844c730bdb9b411442caa4df7ee78309596", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb78844c730bdb9b411442caa4df7ee78309596", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb78844c730bdb9b411442caa4df7ee78309596"}], "stats": {"total": 294, "additions": 165, "deletions": 129}, "files": [{"sha": "47f8920dfe7b867bb23c306d1569563e5d8d5c84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac2e563fcfce40295dc962d8e98796b794726b0f", "patch": "@@ -1,3 +1,19 @@\n+2009-07-08  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/38900\n+\t* config/i386/i386.h (CONDITIONAL_REGISTER_USAGE): Move to i386.c.\n+\t(enum reg_class): Add CLOBBERED_REGS.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Likewise.\n+\t* config/i386/i386.c (ix86_conditional_register_usage): Moved\n+\tfrom CONDITIONAL_REGISTER_USAGE; build CLOBBERED_REGS for 64-bit.\n+\t(ix86_function_ok_for_sibcall): Tidy.  Disallow MS->SYSV sibcalls.\n+\t(ix86_expand_call): Use sibcall_insn_operand when needed.  Don't\n+\tforce 64-bit sibcalls into R11.\n+\t* config/i386/constraints.md (U): New constraint.\n+\t* config/i386/i386.md (sibcall_1, sibcall_value_1): Use it.\n+\t(sibcall_1_rex64, sibcall_value_1_rex64): Likewise.\n+\t(sibcall_1_rex64_v, sibcall_value_1_rex64_v): Remove.\n+\n 2009-07-08  Shujing Zhao  <pearly.zhao@oracle.com>\n \n \t* basic-block.h (dump_regset, debug_regset): Remove duplicate"}, {"sha": "89722bb92daacb860dad18f87a81d9ef1df80abb", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=ac2e563fcfce40295dc962d8e98796b794726b0f", "patch": "@@ -18,7 +18,7 @@\n ;; <http://www.gnu.org/licenses/>.\n \n ;;; Unused letters:\n-;;;     B     H           TU W\n+;;;     B     H           T  W\n ;;;           h jk          vw  z\n \n ;; Integer register constraints.\n@@ -62,6 +62,9 @@\n  \"The @code{a} and @code{d} registers, as a pair (for instructions\n   that return half the result in one and half in the other).\")\n \n+(define_register_constraint \"U\" \"CLOBBERED_REGS\"\n+ \"The call-clobbered integer registers.\")\n+\n ;; Floating-point register constraints.\n (define_register_constraint \"f\"\n  \"TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387 ? FLOAT_REGS : NO_REGS\""}, {"sha": "d1d601a6a67c1ce867e931bcf82980db95cbdca7", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ac2e563fcfce40295dc962d8e98796b794726b0f", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Functions in i386.c */\n extern void override_options (bool);\n extern void optimization_options (int, int);\n+extern void ix86_conditional_register_usage (void);\n \n extern int ix86_can_use_return_insn_p (void);\n extern void ix86_setup_frame_addresses (void);"}, {"sha": "15a73d8655168220549399647efb4294ca7366be", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 119, "deletions": 46, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ac2e563fcfce40295dc962d8e98796b794726b0f", "patch": "@@ -3418,6 +3418,79 @@ override_options (bool main_args_p)\n     target_option_default_node = target_option_current_node\n       = build_target_option_node ();\n }\n+\n+/* Update register usage after having seen the compiler flags.  */\n+\n+void\n+ix86_conditional_register_usage (void)\n+{\n+  int i;\n+  unsigned int j;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (fixed_regs[i] > 1)\n+\tfixed_regs[i] = (fixed_regs[i] == (TARGET_64BIT ? 3 : 2));\n+      if (call_used_regs[i] > 1)\n+\tcall_used_regs[i] = (call_used_regs[i] == (TARGET_64BIT ? 3 : 2));\n+    }\n+\n+  /* The PIC register, if it exists, is fixed.  */\n+  j = PIC_OFFSET_TABLE_REGNUM;\n+  if (j != INVALID_REGNUM)\n+    fixed_regs[j] = call_used_regs[j] = 1;\n+\n+  /* The MS_ABI changes the set of call-used registers.  */\n+  if (TARGET_64BIT && ix86_cfun_abi () == MS_ABI)\n+    {\n+      call_used_regs[SI_REG] = 0;\n+      call_used_regs[DI_REG] = 0;\n+      call_used_regs[XMM6_REG] = 0;\n+      call_used_regs[XMM7_REG] = 0;\n+      for (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\n+\tcall_used_regs[i] = 0;\n+    }\n+\n+  /* The default setting of CLOBBERED_REGS is for 32-bit; add in the\n+     other call-clobbered regs for 64-bit.  */\n+  if (TARGET_64BIT)\n+    {\n+      CLEAR_HARD_REG_SET (reg_class_contents[(int)CLOBBERED_REGS]);\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (reg_class_contents[(int)GENERAL_REGS], i)\n+\t    && call_used_regs[i])\n+\t  SET_HARD_REG_BIT (reg_class_contents[(int)CLOBBERED_REGS], i);\n+    }\n+\n+  /* If MMX is disabled, squash the registers.  */\n+  if (! TARGET_MMX)\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (TEST_HARD_REG_BIT (reg_class_contents[(int)MMX_REGS], i))\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+\n+  /* If SSE is disabled, squash the registers.  */\n+  if (! TARGET_SSE)\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (TEST_HARD_REG_BIT (reg_class_contents[(int)SSE_REGS], i))\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+\n+  /* If the FPU is disabled, squash the registers.  */\n+  if (! (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387))\n+    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (TEST_HARD_REG_BIT (reg_class_contents[(int)FLOAT_REGS], i))\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+\n+  /* If 32-bit, squash the 64-bit registers.  */\n+  if (! TARGET_64BIT)\n+    {\n+      for (i = FIRST_REX_INT_REG; i <= LAST_REX_INT_REG; i++)\n+\treg_names[i] = \"\";\n+      for (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\n+\treg_names[i] = \"\";\n+    }\n+}\n+\n \f\n /* Save the current options */\n \n@@ -4193,7 +4266,7 @@ optimization_options (int level, int size ATTRIBUTE_UNUSED)\n static bool\n ix86_function_ok_for_sibcall (tree decl, tree exp)\n {\n-  tree func;\n+  tree type, decl_or_type;\n   rtx a, b;\n \n   /* If we are generating position-independent code, we cannot sibcall\n@@ -4202,13 +4275,23 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n   if (!TARGET_64BIT && flag_pic && (!decl || !targetm.binds_local_p (decl)))\n     return false;\n \n+  /* If we need to align the outgoing stack, then sibcalling would\n+     unalign the stack, which may break the called function.  */\n+  if (ix86_incoming_stack_boundary < PREFERRED_STACK_BOUNDARY)\n+    return false;\n+\n   if (decl)\n-    func = decl;\n+    {\n+      decl_or_type = decl;\n+      type = TREE_TYPE (decl);\n+    }\n   else\n     {\n-      func = TREE_TYPE (CALL_EXPR_FN (exp));\n-      if (POINTER_TYPE_P (func))\n-        func = TREE_TYPE (func);\n+      /* We're looking at the CALL_EXPR, we need the type of the function.  */\n+      type = CALL_EXPR_FN (exp);\t\t/* pointer expression */\n+      type = TREE_TYPE (type);\t\t\t/* pointer type */\n+      type = TREE_TYPE (type);\t\t\t/* function type */\n+      decl_or_type = type;\n     }\n \n   /* Check that the return value locations are the same.  Like\n@@ -4220,7 +4303,7 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n      differences in the return value ABI.  Note that it is ok for one\n      of the functions to have void return type as long as the return\n      value of the other is passed in a register.  */\n-  a = ix86_function_value (TREE_TYPE (exp), func, false);\n+  a = ix86_function_value (TREE_TYPE (exp), decl_or_type, false);\n   b = ix86_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),\n \t\t\t   cfun->decl, false);\n   if (STACK_REG_P (a) || STACK_REG_P (b))\n@@ -4233,38 +4316,32 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n   else if (!rtx_equal_p (a, b))\n     return false;\n \n-  /* If this call is indirect, we'll need to be able to use a call-clobbered\n-     register for the address of the target function.  Make sure that all\n-     such registers are not used for passing parameters.  */\n-  if (!decl && !TARGET_64BIT)\n+  if (TARGET_64BIT)\n     {\n-      tree type;\n-\n-      /* We're looking at the CALL_EXPR, we need the type of the function.  */\n-      type = CALL_EXPR_FN (exp);\t\t/* pointer expression */\n-      type = TREE_TYPE (type);\t\t\t/* pointer type */\n-      type = TREE_TYPE (type);\t\t\t/* function type */\n-\n-      if (ix86_function_regparm (type, NULL) >= 3)\n+      /* The SYSV ABI has more call-clobbered registers;\n+\t disallow sibcalls from MS to SYSV.  */\n+      if (cfun->machine->call_abi == MS_ABI\n+\t  && ix86_function_type_abi (type) == SYSV_ABI)\n+\treturn false;\n+    }\n+  else\n+    {\n+      /* If this call is indirect, we'll need to be able to use a\n+\t call-clobbered register for the address of the target function.\n+\t Make sure that all such registers are not used for passing\n+\t parameters.  Note that DLLIMPORT functions are indirect.  */\n+      if (!decl\n+\t  || (TARGET_DLLIMPORT_DECL_ATTRIBUTES && DECL_DLLIMPORT_P (decl)))\n \t{\n-\t  /* ??? Need to count the actual number of registers to be used,\n-\t     not the possible number of registers.  Fix later.  */\n-\t  return false;\n+\t  if (ix86_function_regparm (type, NULL) >= 3)\n+\t    {\n+\t      /* ??? Need to count the actual number of registers to be used,\n+\t\t not the possible number of registers.  Fix later.  */\n+\t      return false;\n+\t    }\n \t}\n     }\n \n-  /* Dllimport'd functions are also called indirectly.  */\n-  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-      && !TARGET_64BIT\n-      && decl && DECL_DLLIMPORT_P (decl)\n-      && ix86_function_regparm (TREE_TYPE (decl), NULL) >= 3)\n-    return false;\n-\n-  /* If we need to align the outgoing stack, then sibcalling would\n-     unalign the stack, which may break the called function.  */\n-  if (ix86_incoming_stack_boundary < PREFERRED_STACK_BOUNDARY)\n-    return false;\n-\n   /* Otherwise okay.  That also includes certain types of indirect calls.  */\n   return true;\n }\n@@ -4321,7 +4398,8 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n   if (TARGET_64BIT)\n     {\n       /* Do not warn when emulating the MS ABI.  */\n-      if (TREE_CODE (*node) != FUNCTION_TYPE || ix86_function_type_abi (*node)!=MS_ABI)\n+      if (TREE_CODE (*node) != FUNCTION_TYPE\n+\t  || ix86_function_type_abi (*node) != MS_ABI)\n \twarning (OPT_Wattributes, \"%qE attribute ignored\",\n \t         name);\n       *no_add_attrs = true;\n@@ -4790,7 +4868,8 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n   /* Set up the number of registers to use for passing arguments.  */\n \n   if (cum->call_abi == MS_ABI && !ACCUMULATE_OUTGOING_ARGS)\n-    sorry (\"ms_abi attribute require -maccumulate-outgoing-args or subtarget optimization implying it\");\n+    sorry (\"ms_abi attribute requires -maccumulate-outgoing-args \"\n+\t   \"or subtarget optimization implying it\");\n   cum->nregs = ix86_regparm;\n   if (TARGET_64BIT)\n     {\n@@ -7933,7 +8012,8 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n       || (TARGET_64BIT && frame->to_allocate >= (HOST_WIDE_INT) 0x80000000))\n     frame->save_regs_using_mov = false;\n \n-  if (!TARGET_64BIT_MS_ABI && TARGET_RED_ZONE && current_function_sp_is_unchanging\n+  if (!TARGET_64BIT_MS_ABI && TARGET_RED_ZONE\n+      && current_function_sp_is_unchanging\n       && current_function_is_leaf\n       && !ix86_current_function_calls_tls_descriptor)\n     {\n@@ -19151,20 +19231,13 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n       && !local_symbolic_operand (XEXP (fnaddr, 0), VOIDmode))\n     fnaddr = gen_rtx_MEM (QImode, construct_plt_address (XEXP (fnaddr, 0)));\n-  else if (! call_insn_operand (XEXP (fnaddr, 0), Pmode))\n+  else if (sibcall\n+\t   ? !sibcall_insn_operand (XEXP (fnaddr, 0), Pmode)\n+\t   : !call_insn_operand (XEXP (fnaddr, 0), Pmode))\n     {\n       fnaddr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));\n       fnaddr = gen_rtx_MEM (QImode, fnaddr);\n     }\n-  if (sibcall && TARGET_64BIT\n-      && !constant_call_address_operand (XEXP (fnaddr, 0), Pmode))\n-    {\n-      rtx addr;\n-      addr = copy_to_mode_reg (Pmode, XEXP (fnaddr, 0));\n-      fnaddr = gen_rtx_REG (Pmode, R11_REG);\n-      emit_move_insn (fnaddr, addr);\n-      fnaddr = gen_rtx_MEM (QImode, fnaddr);\n-    }\n \n   call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);\n   if (retval)"}, {"sha": "97483b7cf367e5d960ddad565ee10c5685d5c8b9", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 9, "deletions": 49, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ac2e563fcfce40295dc962d8e98796b794726b0f", "patch": "@@ -960,52 +960,7 @@ enum target_cpu_default\n #define OVERRIDE_ABI_FORMAT(FNDECL) ix86_call_abi_override (FNDECL)\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-    int i;\t\t\t\t\t\t\t\t\\\n-    unsigned int j;\t\t\t\t\t\t\t\\\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (fixed_regs[i] > 1)\t\t\t\t\t\t\\\n-\t  fixed_regs[i] = (fixed_regs[i] == (TARGET_64BIT ? 3 : 2));\t\\\n-\tif (call_used_regs[i] > 1)\t\t\t\t\t\\\n-\t  call_used_regs[i] = (call_used_regs[i]\t\t\t\\\n-\t\t\t       == (TARGET_64BIT ? 3 : 2));\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    j = PIC_OFFSET_TABLE_REGNUM;\t\t\t\t\t\\\n-    if (j != INVALID_REGNUM)\t\t\t\t\t\t\\\n-      fixed_regs[j] = call_used_regs[j] = 1;\t\t\t\t\\\n-    if (TARGET_64BIT\t\t\t\t\t\t\t\\\n-\t&& ((cfun && cfun->machine->call_abi == MS_ABI)\t\t\t\\\n-\t    || (!cfun && ix86_abi == MS_ABI)))\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tcall_used_regs[SI_REG] = 0;\t\t\t\t\t\\\n-\tcall_used_regs[DI_REG] = 0;\t\t\t\t\t\\\n-\tcall_used_regs[XMM6_REG] = 0;\t\t\t\t\t\\\n-\tcall_used_regs[XMM7_REG] = 0;\t\t\t\t\t\\\n-\tfor (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\t\t\\\n-\t  call_used_regs[i] = 0;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (! TARGET_MMX)\t\t\t\t\t\t\t\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\\\n-\tif (TEST_HARD_REG_BIT (reg_class_contents[(int)MMX_REGS], i))\t\\\n-\t  fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\t\\\n-    if (! TARGET_SSE)\t\t\t\t\t\t\t\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\\\n-\tif (TEST_HARD_REG_BIT (reg_class_contents[(int)SSE_REGS], i))\t\\\n-\t  fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\t\\\n-    if (! (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387))\t\t\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t\\\n-\tif (TEST_HARD_REG_BIT (reg_class_contents[(int)FLOAT_REGS], i))\t\\\n-\t  fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\t\\\n-    if (! TARGET_64BIT)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfor (i = FIRST_REX_INT_REG; i <= LAST_REX_INT_REG; i++)\t\t\\\n-\t  reg_names[i] = \"\";\t\t\t\t\t\t\\\n-\tfor (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\t\t\\\n-\t  reg_names[i] = \"\";\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+#define CONDITIONAL_REGISTER_USAGE  ix86_conditional_register_usage ()\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -1225,6 +1180,7 @@ enum reg_class\n   NO_REGS,\n   AREG, DREG, CREG, BREG, SIREG, DIREG,\n   AD_REGS,\t\t\t/* %eax/%edx for DImode */\n+  CLOBBERED_REGS,\t\t/* call-clobbered integers */\n   Q_REGS,\t\t\t/* %eax %ebx %ecx %edx */\n   NON_Q_REGS,\t\t\t/* %esi %edi %ebp %esp */\n   INDEX_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp */\n@@ -1273,6 +1229,7 @@ enum reg_class\n    \"AREG\", \"DREG\", \"CREG\", \"BREG\",\t\\\n    \"SIREG\", \"DIREG\",\t\t\t\\\n    \"AD_REGS\",\t\t\t\t\\\n+   \"CLOBBERED_REGS\",\t\t\t\\\n    \"Q_REGS\", \"NON_Q_REGS\",\t\t\\\n    \"INDEX_REGS\",\t\t\t\\\n    \"LEGACY_REGS\",\t\t\t\\\n@@ -1290,16 +1247,19 @@ enum reg_class\n    \"FLOAT_INT_SSE_REGS\",\t\t\\\n    \"ALL_REGS\" }\n \n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n+/* Define which registers fit in which classes.  This is an initializer\n+   for a vector of HARD_REG_SET of length N_REG_CLASSES.\n+\n+   Note that the default setting of CLOBBERED_REGS is for 32-bit; this\n+   is adjusted by CONDITIONAL_REGISTER_USAGE for the 64-bit ABI in effect.  */\n \n #define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n {     { 0x00,     0x0 },\t\t\t\t\t\t\\\n       { 0x01,     0x0 }, { 0x02, 0x0 },\t/* AREG, DREG */\t\t\\\n       { 0x04,     0x0 }, { 0x08, 0x0 },\t/* CREG, BREG */\t\t\\\n       { 0x10,     0x0 }, { 0x20, 0x0 },\t/* SIREG, DIREG */\t\t\\\n       { 0x03,     0x0 },\t\t/* AD_REGS */\t\t\t\\\n+      { 0x07,     0x0 },\t\t/* CLOBBERED_REGS */\t\t\\\n       { 0x0f,     0x0 },\t\t/* Q_REGS */\t\t\t\\\n   { 0x1100f0,  0x1fe0 },\t\t/* NON_Q_REGS */\t\t\\\n       { 0x7f,  0x1fe0 },\t\t/* INDEX_REGS */\t\t\\"}, {"sha": "47f2ce65cc2396ece970376ac73c27b031a7b307", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2e563fcfce40295dc962d8e98796b794726b0f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ac2e563fcfce40295dc962d8e98796b794726b0f", "patch": "@@ -15536,14 +15536,12 @@\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*sibcall_1\"\n-  [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,c,d,a\"))\n+  [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n-{\n-  if (constant_call_address_operand (operands[0], Pmode))\n-    return \"jmp\\t%P0\";\n-  return \"jmp\\t%A0\";\n-}\n+  \"@\n+   jmp\\t%P0\n+   jmp\\t%A0\"\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*call_1_rex64\"\n@@ -15590,22 +15588,15 @@\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*sibcall_1_rex64\"\n-  [(call (mem:QI (match_operand:DI 0 \"constant_call_address_operand\" \"\"))\n+  [(call (mem:QI (match_operand:DI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n-  \"jmp\\t%P0\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_insn \"*sibcall_1_rex64_v\"\n-  [(call (mem:QI (reg:DI R11_REG))\n-\t (match_operand 0 \"\" \"\"))]\n-  \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n-  \"jmp\\t{*%%}r11\"\n+  \"@\n+   jmp\\t%P0\n+   jmp\\t%A0\"\n   [(set_attr \"type\" \"call\")])\n \n-\n ;; Call subroutine, returning value in operand 0\n-\n (define_expand \"call_value_pop\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (match_operand:QI 1 \"\" \"\")\n@@ -22183,14 +22174,12 @@\n \n (define_insn \"*sibcall_value_1\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,c,d,a\"))\n+\t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n   \"SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n-{\n-  if (constant_call_address_operand (operands[1], Pmode))\n-    return \"jmp\\t%P1\";\n-  return \"jmp\\t%A1\";\n-}\n+  \"@\n+   jmp\\t%P1\n+   jmp\\t%A1\"\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*call_value_1_rex64\"\n@@ -22241,18 +22230,12 @@\n \n (define_insn \"*sibcall_value_1_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:QI (match_operand:DI 1 \"constant_call_address_operand\" \"\"))\n+\t(call (mem:QI (match_operand:DI 1 \"sibcall_insn_operand\" \"s,U\"))\n \t      (match_operand:DI 2 \"\" \"\")))]\n   \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n-  \"jmp\\t%P1\"\n-  [(set_attr \"type\" \"callv\")])\n-\n-(define_insn \"*sibcall_value_1_rex64_v\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:QI (reg:DI R11_REG))\n-\t      (match_operand:DI 1 \"\" \"\")))]\n-  \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n-  \"jmp\\t{*%%}r11\"\n+  \"@\n+   jmp\\t%P1\n+   jmp\\t%A1\"\n   [(set_attr \"type\" \"callv\")])\n \f\n ;; We used to use \"int $5\", in honor of #BR which maps to interrupt vector 5."}]}