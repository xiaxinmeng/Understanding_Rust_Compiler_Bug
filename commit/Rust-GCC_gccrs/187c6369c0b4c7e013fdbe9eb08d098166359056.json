{"sha": "187c6369c0b4c7e013fdbe9eb08d098166359056", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg3YzYzNjljMGI0YzdlMDEzZmRiZTllYjA4ZDA5ODE2NjM1OTA1Ng==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-04-04T23:10:23Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-04-04T23:10:23Z"}, "message": "PR c++/89974 - ICE on a definition of a non-type specialization on a struct object with pointer to member function\n\nPR c++/89974 - ICE on a definition of a non-type specialization on a struct object with pointer to member function\nPR c++/89878 - same specializations on a zero-initialized struct object as a non-type parameter treated as distinct\nPR c++/89833 - sorry, unimplemented: string literal in function template signature\nPR c++/47488 - sorry, unimplemented: string literal in function template signature\n\ngcc/cp/ChangeLog:\n\n\tPR c++/89974\n\tPR c++/89878\n\tPR c++/89833\n\tPR c++/47488\n\t* decl.c (reshape_init_array_1): Strip trailing zero-initializers\n\tfrom arrays of trivial type and known size.\n\t* mangle.c (write_expression): Convert braced initializer lists\n\tto STRING_CSTs.\n\t(write_expression): Trim trailing zero-initializers from arrays\n\tof trivial type.\n\t(write_template_arg_literal): Mangle strings the same as braced\n\tinitializer lists.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/89974\n\tPR c++/89878\n\tPR c++/89833\n\tPR c++/47488\n\t* gcc/testsuite/g++.dg/abi/mangle69.C: New test.\n\t* gcc/testsuite/g++.dg/abi/mangle70.C: New test.\n\t* gcc/testsuite/g++.dg/abi/mangle71.C: New test.\n\t* gcc/testsuite/g++.dg/abi/mangle72.C: New test.\n\t* gcc/testsuite/g++.dg/cpp0x/constexpr-array19.C: New test.\n\t* gcc/testsuite/g++.dg/cpp2a/nontype-class15.C: New test.\n\t* gcc/testsuite/g++.dg/cpp2a/nontype-class16.C: New test.\n\t* gcc/testsuite/g++.dg/init/array51.C: New test.\n\nFrom-SVN: r270155", "tree": {"sha": "7594a3b21feb39a649170bfa6daa218b1fdd8396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7594a3b21feb39a649170bfa6daa218b1fdd8396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/187c6369c0b4c7e013fdbe9eb08d098166359056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187c6369c0b4c7e013fdbe9eb08d098166359056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187c6369c0b4c7e013fdbe9eb08d098166359056", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187c6369c0b4c7e013fdbe9eb08d098166359056/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a9b15a7d76ee3ee2cd960698a84e34ec10c2bf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a9b15a7d76ee3ee2cd960698a84e34ec10c2bf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a9b15a7d76ee3ee2cd960698a84e34ec10c2bf0"}], "stats": {"total": 1042, "additions": 1032, "deletions": 10}, "files": [{"sha": "729b7732565629be07fbec81c2be3d1c6ab249ef", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -1,3 +1,18 @@\n+2019-04-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/89974\n+\tPR c++/89878\n+\tPR c++/89833\n+\tPR c++/47488\n+\t* decl.c (reshape_init_array_1): Strip trailing zero-initializers\n+\tfrom arrays of trivial type and known size.\n+        * mangle.c (write_expression): Convert braced initializer lists\n+        to STRING_CSTs.\n+\t(write_expression): Trim trailing zero-initializers from arrays\n+\tof trivial type.\n+        (write_template_arg_literal): Mangle strings the same as braced\n+        initializer lists.\n+\n 2019-04-03  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/81866 - ICE with member template and default targ."}, {"sha": "400e1a274aa36804626d63eff8503de72b01a5b0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -5799,6 +5799,9 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n \tmax_index_cst = tree_to_uhwi (fold_convert (size_type_node, max_index));\n     }\n \n+  /* Set to the index of the last element with a non-zero initializer.\n+     Initializers for elements past this one can be dropped.  */\n+  unsigned HOST_WIDE_INT last_nonzero = -1;\n   /* Loop until there are no more initializers.  */\n   for (index = 0;\n        d->cur != d->end && (!sized_array_p || index <= max_index_cst);\n@@ -5817,11 +5820,30 @@ reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,\n       if (!TREE_CONSTANT (elt_init))\n \tTREE_CONSTANT (new_init) = false;\n \n+      if (!initializer_zerop (elt_init))\n+\tlast_nonzero = index;\n+\n       /* This can happen with an invalid initializer (c++/54501).  */\n       if (d->cur == old_cur && !sized_array_p)\n \tbreak;\n     }\n \n+  if (sized_array_p\n+      && (!CLASS_TYPE_P (elt_type)\n+\t  || TYPE_HAS_TRIVIAL_DFLT (elt_type)))\n+    {\n+      /* Strip trailing zero-initializers from an array of a trivial\n+\t type of known size.  They are redundant and get in the way\n+\t of telling them apart from those with implicit zero value.  */\n+      unsigned HOST_WIDE_INT nelts = CONSTRUCTOR_NELTS (new_init);\n+      if (last_nonzero > nelts)\n+\tnelts = 0;\n+      else if (last_nonzero < nelts - 1)\n+\tnelts = last_nonzero + 1;\n+\n+      vec_safe_truncate (CONSTRUCTOR_ELTS (new_init), nelts);\n+    }\n+\n   return new_init;\n }\n "}, {"sha": "a5fd66fe0de3ba9832d91290353e9ce2bc9b1717", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -3136,18 +3136,48 @@ write_expression (tree expr)\n     }\n   else if (code == CONSTRUCTOR)\n     {\n-      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (expr);\n-      unsigned i; tree val;\n+      bool braced_init = BRACE_ENCLOSED_INITIALIZER_P (expr);\n+      tree etype = TREE_TYPE (expr);\n \n-      if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n+      if (braced_init)\n \twrite_string (\"il\");\n       else\n \t{\n \t  write_string (\"tl\");\n-\t  write_type (TREE_TYPE (expr));\n+\t  write_type (etype);\n+\t}\n+\n+      if (!initializer_zerop (expr) || !trivial_type_p (etype))\n+\t{\n+\t  /* Convert braced initializer lists to STRING_CSTs so that\n+\t     A<\"Foo\"> mangles the same as A<{'F', 'o', 'o', 0}> while\n+\t     still using the latter mangling for strings that\n+\t     originated as braced initializer lists.  */\n+\t  expr = braced_lists_to_strings (etype, expr);\n+\n+\t  if (TREE_CODE (expr) == CONSTRUCTOR)\n+\t    {\n+\t      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (expr);\n+\t      unsigned last_nonzero = -1, i;\n+\t      tree val;\n+\n+\t      FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n+\t\tif (!initializer_zerop (val))\n+\t\t  last_nonzero = i;\n+\n+\t      FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n+\t\t{\n+\t\t  if (i > last_nonzero)\n+\t\t    break;\n+\t\t  write_expression (val);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (TREE_CODE (expr) == STRING_CST);\n+\t      write_expression (expr);\n+\t    }\n \t}\n-      FOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n-\twrite_expression (val);\n       write_char ('E');\n     }\n   else if (code == LAMBDA_EXPR)\n@@ -3353,8 +3383,14 @@ write_expression (tree expr)\n static void\n write_template_arg_literal (const tree value)\n {\n-  write_char ('L');\n-  write_type (TREE_TYPE (value));\n+  if (TREE_CODE (value) == STRING_CST)\n+    /* Temporarily mangle strings as braced initializer lists.  */\n+    write_string (\"tl\");\n+  else\n+    write_char ('L');\n+\n+  tree valtype = TREE_TYPE (value);\n+  write_type (valtype);\n \n   /* Write a null member pointer value as (type)0, regardless of its\n      real representation.  */\n@@ -3397,8 +3433,31 @@ write_template_arg_literal (const tree value)\n \tbreak;\n \n       case STRING_CST:\n-\tsorry (\"string literal in function template signature\");\n-\tbreak;\n+\t{\n+\t  /* Mangle strings the same as braced initializer lists.  */\n+\t  unsigned n = TREE_STRING_LENGTH (value);\n+\t  const char *str = TREE_STRING_POINTER (value);\n+\n+\t  /* Count the number of trailing nuls and subtract them from\n+\t     STRSIZE because they don't need to be mangled.  */\n+\t  for (const char *p = str + n - 1; ; --p)\n+\t    {\n+\t      if (*p || p == str)\n+\t\t{\n+\t\t  n -= str + n - !!*p - p;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  tree eltype = TREE_TYPE (valtype);\n+\t  for (const char *p = str; n--; ++p)\n+\t    {\n+\t      write_char ('L');\n+\t      write_type (eltype);\n+\t      write_unsigned_number (*(const unsigned char*)p);\n+\t      write_string (\"E\");\n+\t    }\n+\t  break;\n+\t}\n \n       default:\n \tgcc_unreachable ();"}, {"sha": "26c5637619fae1b87097f7a8b286dbbccc180cc9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -1,3 +1,19 @@\n+2019-04-04  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/89974\n+\tPR c++/89878\n+\tPR c++/89833\n+\tPR c++/47488\n+\t* gcc/testsuite/g++.dg/abi/mangle69.C: New test.\n+\t* gcc/testsuite/g++.dg/abi/mangle70.C: New test.\n+\t* gcc/testsuite/g++.dg/abi/mangle71.C: New test.\n+\t* gcc/testsuite/g++.dg/abi/mangle72.C: New test.\n+\t* gcc/testsuite/g++.dg/cpp0x/constexpr-array19.C: New test.\n+\t* gcc/testsuite/g++.dg/cpp2a/nontype-class15.C: New test.\n+\t* gcc/testsuite/g++.dg/cpp2a/nontype-class16.C: New test.\n+\t* gcc/testsuite/g++.dg/init/array51.C: New test.\n+\t* gcc/testsuite/g++.dg/template/nontype29.C: New test.\n+\n 2019-04-04  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/89957"}, {"sha": "dea3eeca022ad309a3d26824bf2516432912b357", "filename": "gcc/testsuite/g++.dg/abi/mangle69.C", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle69.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle69.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle69.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,164 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A1 { char c[5]; };\n+\n+template <A1> struct B { };\n+\n+// All of the following name the same type.\n+typedef B<A1{ }>                   A______;\n+typedef B<A1{ { 0 } }>             A_Z____;\n+typedef B<A1{ { 0, 0 } }>          A_ZZ___;\n+typedef B<A1{ { 0, 0, 0 } }>       A_ZZZ__;\n+typedef B<A1{ { 0, 0, 0, 0 } }>    A_ZZZZ_;\n+typedef B<A1{ { 0, 0, 0, 0, 0 } }> A_ZZZZZ;\n+\n+// Verify that the types mangle the same.\n+void a______ (A______) { }\n+// { dg-final { scan-assembler \"_Z7a______1BIXtl2A1EEE\" } }\n+\n+void a_z____ (A_Z____) { }\n+// { dg-final { scan-assembler \"_Z7a_z____1BIXtl2A1EEE\" } }\n+\n+void a_zz___ (A_ZZ___) { }\n+// { dg-final { scan-assembler \"_Z7a_zz___1BIXtl2A1EEE\" } }\n+\n+void a_zzz__ (A_ZZZ__) { }\n+// { dg-final { scan-assembler \"_Z7a_zzz__1BIXtl2A1EEE\" } }\n+\n+void a_zzzz_ (A_ZZZZ_) { }\n+// { dg-final { scan-assembler \"_Z7a_zzzz_1BIXtl2A1EEE\" } }\n+\n+void a_zzzzz (A_ZZZZZ) { }\n+// { dg-final { scan-assembler \"_Z7a_zzzzz1BIXtl2A1EEE\" } }\n+\n+\n+// All of the following use a string to initialize the array but\n+// also name the same type as the above.\n+typedef B<A1{ \"\" }>                S_z____;\n+typedef B<A1{ \"\\0\" }>              S_Zz___;\n+typedef B<A1{ \"\\0\\0\" }>            S_ZZz__;\n+typedef B<A1{ \"\\0\\0\\0\" }>          S_ZZZz_;\n+typedef B<A1{ \"\\0\\0\\0\\0\" }>        S_ZZZZz;\n+\n+// Verify that the types mangle the same.\n+void s_z____ (S_z____) { }\n+// { dg-final { scan-assembler \"_Z7s_z____1BIXtl2A1EEE\" } }\n+\n+void s_Zz___ (S_Zz___) { }\n+// { dg-final { scan-assembler \"_Z7s_Zz___1BIXtl2A1EEE\" } }\n+\n+void s_ZZz__ (S_ZZz__) { }\n+// { dg-final { scan-assembler \"_Z7s_ZZz__1BIXtl2A1EEE\" } }\n+\n+void s_ZZZz_ (S_ZZZz_) { }\n+// { dg-final { scan-assembler \"_Z7s_ZZZz_1BIXtl2A1EEE\" } }\n+\n+void s_ZZZZz (S_ZZZZz) { }\n+// { dg-final { scan-assembler \"_Z7s_ZZZZz1BIXtl2A1EEE\" } }\n+\n+\n+// All of the following also name the same type (distinct from\n+// the above).\n+typedef B<A1{ { 'A' } }>              A_A____;\n+typedef B<A1{ { 'A', 0 } }>           A_AZ___;\n+typedef B<A1{ { 'A', 0, 0 } }>        A_AZZ__;\n+typedef B<A1{ { 'A', 0, 0, 0 } }>     A_AZZZ_;\n+typedef B<A1{ { 'A', 0, 0, 0, 0 } }>  A_AZZZZ;\n+\n+void a_A____ (A_A____) { }\n+// { dg-final { scan-assembler \"_Z7a_A____1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+void a_AZ___ (A_AZ___) { }\n+// { dg-final { scan-assembler \"_Z7a_AZ___1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+void a_AZZ__ (A_AZZ__) { }\n+// { dg-final { scan-assembler \"_Z7a_AZZ__1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+void a_AZZZ_ (A_AZZZ_) { }\n+// { dg-final { scan-assembler \"_Z7a_AZZZ_1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+void a_AZZZZ (A_AZZZZ) { }\n+// { dg-final { scan-assembler \"_Z7a_AZZZZ1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+\n+typedef B<A1{ \"A\" }>            S_Az___;\n+typedef B<A1{ \"A\\0\" }>          S_AZz__;\n+typedef B<A1{ \"A\\0\\0\" }>        S_AZZz_;\n+typedef B<A1{ \"A\\0\\0\\0\" }>      S_AZZZz;\n+\n+void s_Az___ (S_Az___) { }\n+// { dg-final { scan-assembler \"_Z7s_Az___1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+void s_AZz__ (S_AZz__) { }\n+// { dg-final { scan-assembler \"_Z7s_AZz__1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+void s_AZZz_ (S_AZZz_) { }\n+// { dg-final { scan-assembler \"_Z7s_AZZz_1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+void s_AZZZz (S_AZZZz) { }\n+// { dg-final { scan-assembler \"_Z7s_AZZZz1BIXtl2A1tlA5_cLc65EEEEE\" } }\n+\n+\n+typedef B<A1{ 'A', 0, 0, 'D', 0 }> A_AZZDZ;\n+typedef B<A1{ 'A', 0, 0, 'D' }>    A_AZZD_;\n+\n+void a_AZZDZ (A_AZZDZ) { }\n+// { dg-final { scan-assembler \"_Z7a_AZZD_1BIXtl2A1tlA5_cLc65ELc0ELc0ELc68EEEEE\" } }\n+\n+void a_AZZD_ (A_AZZD_) { }\n+// { dg-final { scan-assembler \"_Z7a_AZZDZ1BIXtl2A1tlA5_cLc65ELc0ELc0ELc68EEEEE\" } }\n+\n+\n+typedef B<A1{ { \"AB\\0D\" } }>  S_ABZD_;\n+typedef B<A1{ { \"AB\\0\\0\" } }> S_ABZZ_;\n+typedef B<A1{ { \"AB\\0\" } }>   S_ABZ__;\n+typedef B<A1{ { \"AB\" } }>     S_AB___;\n+\n+void s_abzd_ (S_ABZD_) { }\n+// { dg-final { scan-assembler \"_Z7s_abzd_1BIXtl2A1tlA5_cLc65ELc66ELc0ELc68EEEEE\" } }\n+\n+void s_abzz_ (S_ABZZ_) { }\n+// { dg-final { scan-assembler \"_Z7s_abzz_1BIXtl2A1tlA5_cLc65ELc66EEEEE\" } }\n+\n+void s_abz__ (S_ABZ__) { }\n+// { dg-final { scan-assembler \"_Z7s_abz__1BIXtl2A1tlA5_cLc65ELc66EEEEE\" } }\n+\n+void s_ab___ (S_AB___) { }\n+// { dg-final { scan-assembler \"_Z7s_ab___1BIXtl2A1tlA5_cLc65ELc66EEEEE\" } }\n+\n+\n+struct A3 { char a[5], b[5], c[5]; };\n+template <A3> struct B3 { };\n+\n+/* These all name the same type.  */\n+typedef B3<A3{ \"\\1\\2\",     { },             \"\\3\\4\\5\\6\" }> T_123z_______3456z;\n+typedef B3<A3{ \"\\1\\2\",     { 0 },           \"\\3\\4\\5\\6\" }> T_123z__Z____3456z;\n+typedef B3<A3{ \"\\1\\2\",     { 0, 0 },        \"\\3\\4\\5\\6\" }> T_123z__ZZ___3456z;\n+typedef B3<A3{ \"\\1\\2\",     { 0, 0, 0 },     \"\\3\\4\\5\\6\" }> T_123z__ZZZ__3456z;\n+typedef B3<A3{ \"\\1\\2\",     { 0, 0, 0, 0 },  \"\\3\\4\\5\\6\" }> T_123z__ZZZZ_3456z;\n+typedef B3<A3{ \"\\1\\2\",     \"\",              \"\\3\\4\\5\\6\" }> T_123z__Z____3456z;\n+typedef B3<A3{ \"\\1\\2\",     \"\\0\",            \"\\3\\4\\5\\6\" }> T_123z__ZZ___3456z;\n+typedef B3<A3{ \"\\1\\2\",     \"\\0\\0\",          \"\\3\\4\\5\\6\" }> T_123z__ZZZ__3456z;\n+typedef B3<A3{ \"\\1\\2\",     \"\\0\\0\\0\",        \"\\3\\4\\5\\6\" }> T_123z__ZZZZ_3456z;\n+typedef B3<A3{ \"\\1\\2\",     \"\\0\\0\\0\\0\",      \"\\3\\4\\5\\6\" }> T_123z__ZZZZZ3456z;\n+typedef B3<A3{ \"\\1\\2\\0\",   \"\\0\\0\\0\\0\",      \"\\3\\4\\5\\6\" }> T_123Zz_ZZZZZ3456z;\n+typedef B3<A3{ \"\\1\\2\\0\\0\", \"\\0\\0\\0\\0\",      \"\\3\\4\\5\\6\" }> T_123ZZzZZZZZ3456z;\n+\n+\n+void ft0 (T_123z_______3456z) { }\n+// { dg-final { scan-assembler \"_Z3ft02B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }\n+\n+void ft1 (T_123z__Z____3456z) { }\n+// { dg-final { scan-assembler \"_Z3ft12B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }\n+void ft2 (T_123z__ZZ___3456z) { }\n+// { dg-final { scan-assembler \"_Z3ft22B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }\n+void ft3 (T_123z__ZZZ__3456z) { }\n+// { dg-final { scan-assembler \"_Z3ft32B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }\n+void ft4 (T_123z__ZZZZ_3456z) { }\n+// { dg-final { scan-assembler \"_Z3ft42B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }\n+void ft9 (T_123z__ZZZZZ3456z) { }\n+// { dg-final { scan-assembler \"_Z3ft92B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }\n+void fta (T_123Zz_ZZZZZ3456z) { }\n+// { dg-final { scan-assembler \"_Z3fta2B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }\n+void ftb (T_123ZZzZZZZZ3456z) { }\n+// { dg-final { scan-assembler \"_Z3ftb2B3IXtl2A3tlA5_cLc1ELc2EEtlS1_EtlS1_Lc3ELc4ELc5ELc6EEEEE\" } }"}, {"sha": "39c987d73c237e0a08f4d2bf36c4227d420ca40e", "filename": "gcc/testsuite/g++.dg/abi/mangle70.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle70.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle70.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle70.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,29 @@\n+// Verify that class literals are mangled the same way regardless\n+// of the underlying type.\n+// { dg-do compile { target c++2a } }\n+\n+struct I { int a[5], b[5], c[5]; };\n+template <I> struct X { };\n+\n+typedef X<I{ {1,2}, {}, {11,12,13,14} }> Ti;\n+void f (Ti) { }\n+// { dg-final { scan-assembler \"_Z1f1XIXtl1ItlA5_iLi1ELi2EEtlS1_EtlS1_Li11ELi12ELi13ELi14EEEEE\" } }\n+\n+struct C { char a[5], b[5], c[5]; };\n+template <C> struct Y { };\n+\n+typedef Y<C{ {1,2}, {}, {11,12,13,14} }> Tca;\n+void g (Tca) { }\n+// { dg-final { scan-assembler \"_Z1g1YIXtl1CtlA5_cLc1ELc2EEtlS1_EtlS1_Lc11ELc12ELc13ELc14EEEEE\" } }\n+\n+typedef Y<C{ \"\\1\\2\", \"\", {11,12,13,14} }> Tcs;\n+void h (Tcs) { }\n+// { dg-final { scan-assembler \"_Z1h1YIXtl1CtlA5_cLc1ELc2EEtlS1_EtlS1_Lc11ELc12ELc13ELc14EEEEE\" } }\n+\n+struct S { signed char a[5], b[5], c[5]; };\n+template <S> struct Z { };\n+\n+typedef Z<S{ {1,2}, {}, {11,12,13,14} }> Tsc;\n+\n+void i (Tsc) { }\n+// { dg-final { scan-assembler \"_Z1i1ZIXtl1StlA5_aLa1ELa2EEtlS1_EtlS1_La11ELa12ELa13ELa14EEEEE\" } }"}, {"sha": "cb9d7d3a1d8f38d13ab0c3a93bb990397237f83a", "filename": "gcc/testsuite/g++.dg/abi/mangle71.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle71.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle71.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle71.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,28 @@\n+// Verify manglinng of class literals of types with ctors.\n+// { dg-do compile { target c++2a } }\n+\n+struct A\n+{\n+  char i;\n+  constexpr A (): i (1) { }\n+  constexpr A (int i): i (i) { }\n+};\n+\n+struct B { A a[3]; };\n+\n+template <B> struct X { };\n+\n+void f___ (X<B{{ }}>) { }\n+// { dg-final { scan-assembler \"_Z4f___1XIXtl1BtlA3_1AtlS1_Lc1EEEEEE\" } }\n+\n+void f0__ (X<B{{ 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z4f0__1XIXtl1BtlA3_1AtlS1_Lc0EEtlS1_Lc1EEEEEE\" } }\n+\n+void f00_ (X<B{{ 0, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z4f00_1XIXtl1BtlA3_1AtlS1_Lc0EEtlS1_Lc0EEtlS1_Lc1EEEEEE\" } }\n+\n+void f000 (X<B{{ 0, 0, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z4f0001XIXtl1BtlA3_1AtlS1_Lc0EEtlS1_Lc0EEtlS1_Lc0EEEEEE\" } }\n+\n+void f1__ (X<B{{ 1 }}>) { }\n+// { dg-final { scan-assembler \"_Z4f1__1XIXtl1BtlA3_1AtlS1_Lc1EEtlS1_Lc1EEEEEE\" } }"}, {"sha": "656a0cae403f72ec9034217c1c28340527034559", "filename": "gcc/testsuite/g++.dg/abi/mangle72.C", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle72.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle72.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle72.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,106 @@\n+// Verify manglinng of class literals with pointers to members.\n+// Some of the mangling here is wrong.  Note the FIXME comments below.\n+// { dg-do compile { target c++2a } }\n+\n+struct A { int a[2]; };\n+\n+template <A> struct X { };\n+\n+// Let's mangle some non-member pointer literals for comparison.\n+void f__ (X<A{{ }}>) { }\n+// { dg-final { scan-assembler \"_Z3f001XIXtl1AEEE\" } }\n+\n+void f0_ (X<A{{ 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z3f0_1XIXtl1AEEE\" } }\n+\n+void f00 (X<A{{ 0, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z3f__1XIXtl1AEEE\" } }\n+\n+\n+// Exercise arrays of pointers to data members.\n+typedef int (A::*padm_t)[2];\n+\n+struct B { padm_t a[2]; };\n+template <B> struct Y { };\n+\n+void g__ (Y<B{{ }}>) { }\n+// { dg-final { scan-assembler \"_Z3g__1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE\" } }\n+\n+void g0_ (Y<B{{ 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z3g0_1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE\" } }\n+\n+void g00 (Y<B{{ 0, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z3g001YIXtl1BtlA2_M1AA2_iLS3_0EEEEE\" } }\n+\n+void g0x (Y<B{{ 0, &A::a }}>) { }\n+// FIXME: This needs to mangle differently from g00.  The space at\n+// the end is intentional to make the directive fail so that the xfail\n+// can be reminder to change this once the mangling is fixed.\n+// { dg-final { scan-assembler \"_Z3g0x1YIXtl1BtlA2_M1AA2_iLS3_0EEEEE \" { xfail *-*-* } } }\n+\n+void gx_ (Y<B{{ &A::a }}>) { }\n+// { dg-final { scan-assembler \"_Z3gx_1YIXtl1BtlA2_M1AA2_iLS3_0ELS3_0EEEEE\" } }\n+\n+\n+struct C { padm_t a[3]; };\n+template <C> struct Z { };\n+\n+void h___ (Z<C{{ }}>) { }\n+// { dg-final { scan-assembler \"_Z4h___1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+\n+void h0__ (Z<C{{ 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z4h0__1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+\n+void h00_ (Z<C{{ 0, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z4h00_1ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+\n+void h000 (Z<C{{ 0, 0, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z4h0001ZIXtl1CtlA3_M1AA2_iLS3_0EEEEE\" } }\n+\n+void h00x (Z<C{{ 0, 0, &A::a }}>) { }\n+// FIXME: This needs to mangle differently from hx0_ and hx__.\n+// { dg-final { scan-assembler \"_Z4h00x1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE \" { xfail *-*-*} } }\n+\n+void h0x0 (Z<C{{ 0, &A::a, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z4h0x01ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0ELS3_0EEEEE\" } }\n+\n+void h0x_ (Z<C{{ 0, &A::a }}>) { }\n+// { dg-final { scan-assembler \"_Z4h0x_1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0ELS3_0EEEEE\" } }\n+\n+void hx0_ (Z<C{{ &A::a, 0 }}>) { }\n+// FIXME: This needs to mangle differently from h00x and hx__.\n+// { dg-final { scan-assembler \"_Z4hx0_1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE \" { xfail *-*-*} } }\n+\n+void hx__ (Z<C{{ &A::a }}>) { }\n+// FIXME: This needs to mangle differently from h00x and hx0_.\n+// { dg-final { scan-assembler \"_Z4hx__1ZIXtl1CtlA3_M1AA2_iLS3_0ELS3_0EEEEE \" { xfail *-*-* } } }\n+\n+\n+// Exercise arrays of pointers to function members.\n+\n+struct AF { void f (); };\n+typedef void (AF::*pafm_t)();\n+\n+struct D { pafm_t a[2]; };\n+template <D> struct F { };\n+\n+void k__ (F<D{{ }}>) { }\n+// { dg-final { scan-assembler \"_Z3k__1FIXtl1DEEE\" } }\n+\n+void k0_ (F<D{{ 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z3k0_1FIXtl1DEEE\" } }\n+\n+void k00 (F<D{{ 0, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z3k001FIXtl1DEEE\" } }\n+\n+void k0x (F<D{{ 0, &AF::f }}>) { }\n+// { dg-final { scan-assembler \"_Z3k0x1FIXtl1DtlA2_M2AFFvvEtlS3_EtlS3_adL_ZNS1_1fEvEEEEEE\" } }\n+\n+void kx_ (F<D{{ &AF::f }}>) { }\n+// { dg-final { scan-assembler \"_Z3kx_1FIXtl1DtlA2_M2AFFvvEtlS3_adL_ZNS1_1fEvEEEEEE\" } }\n+\n+void kx0 (F<D{{ &AF::f, 0 }}>) { }\n+// { dg-final { scan-assembler \"_Z3kx01FIXtl1DtlA2_M2AFFvvEtlS3_adL_ZNS1_1fEvEEEEEE\" } }\n+\n+void kxx (F<D{{ &AF::f, &AF::f }}>) { }\n+// { dg-final { scan-assembler \"_Z3kxx1FIXtl1DtlA2_M2AFFvvEtlS3_adL_ZNS1_1fEvEEtlS3_adL_ZNS1_1fEvEEEEEE\" } }"}, {"sha": "f7e5d352d88ae2745bcded0598bda97a16b81134", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array19.C", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array19.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,137 @@\n+// PR c++/89833\n+// Test to verify that constant array elements initialized to zero\n+// evaluate to zero regardless of the form of their initilizer,\n+// and irrespective whether it's explicit or implicit.\n+\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wall\" }\n+\n+static const char all_zero[1024] = { };\n+\n+namespace test_int\n+{\n+constexpr int a[][3] = { { 0, 0 }, { 0 }, { } };\n+\n+static_assert (sizeof a == sizeof (int) * 3 * 3);\n+\n+static_assert (   a[0][0] == 0 && a[0][1] == 0 && a[0][2] == 0\n+               && a[1][0] == 0 && a[1][1] == 0 && a[1][2] == 0\n+               && a[2][0] == 0 && a[2][1] == 0 && a[2][2] == 0);\n+\n+constexpr int b[3][3] = { { 0, 0 }, { 0 } };\n+\n+static_assert (sizeof b == sizeof (int) * 3 * 3);\n+\n+static_assert (   b[0][0] == 0 && b[0][1] == 0 && b[0][2] == 0\n+               && b[1][0] == 0 && b[1][1] == 0 && b[1][2] == 0\n+               && b[2][0] == 0 && b[2][1] == 0 && b[2][2] == 0);\n+\n+constexpr int c[3][3] = { { } };\n+\n+static_assert (sizeof c == sizeof (int) * 3 * 3);\n+\n+static_assert (   c[0][0] == 0 && c[0][1] == 0 && c[0][2] == 0\n+               && c[1][0] == 0 && c[1][1] == 0 && c[1][2] == 0\n+               && c[2][0] == 0 && c[2][1] == 0 && c[2][2] == 0);\n+\n+}\n+\n+namespace test_char\n+{\n+constexpr char a[][3] = { { 0, 0 }, { 0 }, { } };\n+\n+static_assert (sizeof a == sizeof (char) * 3 * 3);\n+\n+static_assert (   a[0][0] == 0 && a[0][1] == 0 && a[0][2] == 0\n+               && a[1][0] == 0 && a[1][1] == 0 && a[1][2] == 0\n+               && a[2][0] == 0 && a[2][1] == 0 && a[2][2] == 0);\n+\n+constexpr char b[3][3] = { { 0, 0 }, { 0 } };\n+\n+static_assert (sizeof b == sizeof (char) * 3 * 3);\n+\n+static_assert (   b[0][0] == 0 && b[0][1] == 0 && b[0][2] == 0\n+               && b[1][0] == 0 && b[1][1] == 0 && b[1][2] == 0\n+               && b[2][0] == 0 && b[2][1] == 0 && b[2][2] == 0);\n+\n+constexpr char c[3][3] = { { } };\n+\n+static_assert (sizeof c == sizeof (char) * 3 * 3);\n+\n+static_assert (   c[0][0] == 0 && c[0][1] == 0 && c[0][2] == 0\n+               && c[1][0] == 0 && c[1][1] == 0 && c[1][2] == 0\n+               && c[2][0] == 0 && c[2][1] == 0 && c[2][2] == 0);\n+}\n+\n+namespace test_string\n+{\n+constexpr char a[][3] = { \"\\0\", \"\", { } };\n+\n+static_assert (sizeof a == sizeof (char) * 3 * 3);\n+\n+static_assert (   a[0][0] == 0 && a[0][1] == 0 && a[0][2] == 0\n+               && a[1][0] == 0 && a[1][1] == 0 && a[1][2] == 0\n+               && a[2][0] == 0 && a[2][1] == 0 && a[2][2] == 0);\n+\n+constexpr char b[3][3] = { \"\\0\", \"\" };\n+\n+static_assert (sizeof b == sizeof (char) * 3 * 3);\n+\n+static_assert (   b[0][0] == 0 && b[0][1] == 0 && b[0][2] == 0\n+               && b[1][0] == 0 && b[1][1] == 0 && b[1][2] == 0\n+               && b[2][0] == 0 && b[2][1] == 0 && b[2][2] == 0);\n+\n+constexpr char c[3][3] = { };\n+\n+static_assert (sizeof c == sizeof (char) * 3 * 3);\n+\n+static_assert (   c[0][0] == 0 && c[0][1] == 0 && c[0][2] == 0\n+               && c[1][0] == 0 && c[1][1] == 0 && c[1][2] == 0\n+               && c[2][0] == 0 && c[2][1] == 0 && c[2][2] == 0);\n+}\n+\n+namespace test_string_member\n+{\n+struct B { struct A { char a[5]; } a[2]; };\n+\n+constexpr B b[3] =\n+  {\n+   /* [0] */\n+   {\n+    /* a = */\n+    {\n+     /* a[0] */ { { 0, 0, 0, 0, 0 } },\n+     /* a[1] */ { { 0, 0  } }\n+    }\n+   },\n+   /* [1] */\n+   {\n+    /* a */\n+    {\n+     /* a[0] */ { \"\\0\\0\\0\\0\" },\n+     /* a[0] */ { \"\" }\n+    }\n+   },\n+  };\n+\n+static_assert (   b[0].a[0].a[0] == 0\n+\t       && b[0].a[0].a[1] == 0\n+\t       && b[0].a[0].a[2] == 0\n+\t       && b[0].a[0].a[3] == 0\n+\t       && b[0].a[0].a[4] == 0\n+\t       && b[0].a[1].a[0] == 0\n+\t       && b[0].a[1].a[1] == 0\n+\t       && b[0].a[1].a[2] == 0\n+\t       && b[0].a[1].a[3] == 0\n+\t       && b[0].a[1].a[4] == 0\n+\t       && b[1].a[0].a[0] == 0\n+\t       && b[1].a[0].a[1] == 0\n+\t       && b[1].a[0].a[2] == 0\n+\t       && b[1].a[0].a[3] == 0\n+\t       && b[1].a[0].a[4] == 0\n+\t       && b[2].a[0].a[0] == 0\n+\t       && b[2].a[0].a[1] == 0\n+\t       && b[2].a[0].a[2] == 0\n+\t       && b[2].a[0].a[3] == 0\n+\t       && b[2].a[0].a[4] == 0);\n+}"}, {"sha": "d684785a77f63175bb0949bc2724f9b7121986be", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class15.C", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class15.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,222 @@\n+// PR c++/89833\n+// Test to verify that the same specializations on non-type template\n+// parameters of class types are in fact treated as the same.\n+// { dg-do compile { target c++2a } }\n+\n+struct A1 { char c[5]; };\n+\n+template <A1> struct B { };\n+\n+// All of the following name the same type.\n+typedef B<A1{ }>                   A______;\n+typedef B<A1{ { 0 } }>             A_Z____;\n+typedef B<A1{ { 0, 0 } }>          A_ZZ___;\n+typedef B<A1{ { 0, 0, 0 } }>       A_ZZZ__;\n+typedef B<A1{ { 0, 0, 0, 0 } }>    A_ZZZZ_;\n+typedef B<A1{ { 0, 0, 0, 0, 0 } }> A_ZZZZZ;\n+\n+// Verify the types are indeed the same by redeclaring the same identifier\n+// of each of them.\n+extern A______ same_type_B_A1;\n+extern A_Z____ same_type_B_A1;\n+extern A_ZZ___ same_type_B_A1;\n+extern A_ZZZ__ same_type_B_A1;\n+extern A_ZZZZ_ same_type_B_A1;\n+extern A_ZZZZZ same_type_B_A1;\n+\n+\n+// All of the following use a string to initialize the array but\n+// also name the same type as the above.\n+typedef B<A1{ \"\" }>                S_z____;\n+typedef B<A1{ \"\\0\" }>              S_Zz___;\n+typedef B<A1{ \"\\0\\0\" }>            S_ZZz__;\n+typedef B<A1{ \"\\0\\0\\0\" }>          S_ZZZz_;\n+typedef B<A1{ \"\\0\\0\\0\\0\" }>        S_ZZZZz;\n+\n+// Verify the types are indeed the same by redeclaring the same identifier\n+// of each of them.\n+extern S_z____ same_type_B_A1;\n+extern S_Zz___ same_type_B_A1;\n+extern S_Zz___ same_type_B_A1;\n+extern S_ZZz__ same_type_B_A1;\n+extern S_ZZZz_ same_type_B_A1;\n+extern S_ZZZZz same_type_B_A1;\n+\n+\n+// All of the following also name the same type (distinct from\n+// the above).\n+typedef B<A1{ { 'A' } }>              A_A____;\n+typedef B<A1{ { 'A', 0 } }>           A_AZ___;\n+typedef B<A1{ { 'A', 0, 0 } }>        A_AZZ__;\n+typedef B<A1{ { 'A', 0, 0, 0 } }>     A_AZZZ_;\n+typedef B<A1{ { 'A', 0, 0, 0, 0 } }>  A_AZZZZ;\n+\n+extern A_A____ same_type_B_A1_A;\n+extern A_AZ___ same_type_B_A1_A;\n+extern A_AZZ__ same_type_B_A1_A;\n+extern A_AZZZ_ same_type_B_A1_A;\n+extern A_AZZZZ same_type_B_A1_A;\n+\n+\n+struct A3 { char a[5], b[5], c[5]; };\n+template <A3> struct B3 { };\n+\n+// These all name the same type.\n+typedef B3<A3{ }>                                   B3_A3________________;\n+typedef B3<A3{ { } }>                               B3_A3________________;\n+typedef B3<A3{ { }, { } }>                          B3_A3________________;\n+typedef B3<A3{ { }, { }, { } }>                     B3_A3________________;\n+typedef B3<A3{ { 0 }, { }, { } }>                   B3_A3________________;\n+typedef B3<A3{ { 0 }, { 0 }, { } }>                 B3_A3________________;\n+typedef B3<A3{ { 0 }, { 0 }, { 0 } }>               B3_A3________________;\n+typedef B3<A3{ { 0, 0 }, { 0 }, { 0 } }>            B3_A3________________;\n+typedef B3<A3{ { 0, 0 }, { 0, 0 }, { 0 } }>         B3_A3________________;\n+typedef B3<A3{ { 0, 0 }, { 0, 0 }, { 0, 0 } }>      B3_A3________________;\n+\n+// These all name the same type.\n+typedef B3<A3{ \"AB\",     { },             \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     { 0 },           \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     { 0, 0 },        \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     { 0, 0, 0 },     \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     { 0, 0, 0, 0 },  \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     \"\",              \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     \"\\0\",            \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     \"\\0\\0\",          \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     \"\\0\\0\\0\",        \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\",     \"\\0\\0\\0\\0\",      \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\\0\",   \"\\0\\0\\0\\0\",      \"IJKL\" }> B3_A3_AB________IJKL_;\n+typedef B3<A3{ \"AB\\0\\0\", \"\\0\\0\\0\\0\",      \"IJKL\" }> B3_A3_AB________IJKL_;\n+\n+// Types with the same name must be the same (and so redefinitions\n+// must be accepted).  Likewise, overloads on distinct types must\n+// be accepted.\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0} }> B3_A3________________;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,0}, {0} }>         B3_A3________________;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,0}, {} }>          B3_A3________________;\n+typedef B3<A3{ {0,0,0,0,0}, {0}, {} }>                  B3_A3________________;\n+typedef B3<A3{ {0,0,0,0,0}, {}, {} }>                   B3_A3________________;\n+typedef B3<A3{ {0}, {0}, {0} }>                         B3_A3________________;\n+typedef B3<A3{ {0}, {0}, {} }>                          B3_A3________________;\n+typedef B3<A3{ {0}, {}, {0} }>                          B3_A3________________;\n+typedef B3<A3{ {}, {}, {} }>                            B3_A3________________;\n+typedef B3<A3{ {}, {} }>                                B3_A3________________;\n+typedef B3<A3{ {} }>                                    B3_A3________________;\n+typedef B3<A3{ }>                                       B3_A3________________;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0},   {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0},     {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0},       {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0,0,0}, {0},         {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0,0,0}, {},          {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0,0},   {0,0,0,0,0}, {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0},     {0,0,0,0},   {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0},       {0,0,0},     {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0},         {0,0,},      {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {},          {0},         {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {},          {},          {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ {0,0,0},     {0,0},       {0,0,0,1,0} }> B3_A3______________1_;\n+typedef B3<A3{ {0,0,0},     {0,0},       {0,0,0,1} }>   B3_A3______________1_;\n+typedef B3<A3{ {0},         {},          {0,0,1,0} }>   B3_A3_____________1__;\n+typedef B3<A3{ {0},         {},          {0,0,1} }>     B3_A3_____________1__;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,0}, {0,1,0} }>     B3_A3____________1___;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,0}, {0,1} }>       B3_A3____________1___;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,0}, {1} }>         B3_A3___________1____;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,1}, {0,0,0,0,0} }> B3_A3__________1_____;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,1}, {} }>          B3_A3__________1_____;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,0,1} }>              B3_A3__________1_____;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,0,1,0}, {0,0,0,0,0} }> B3_A3_________1______;\n+typedef B3<A3{ {0,0,0,0,0}, {0,0,1,0,0}, {0,0,0,0,0} }> B3_A3________1_______;\n+typedef B3<A3{ {0,0,0,0,0}, {0,1,0,0,0}, {0,0,0,0,0} }> B3_A3_______1________;\n+typedef B3<A3{ {0,0,0,0,0}, {1,0,0,0,0}, {0,0,0,0,0} }> B3_A3______1_________;\n+typedef B3<A3{ {0,0,0,0,1}, {0,0,0,0,0}, {0,0,0,0,0} }> B3_A3_____1__________;\n+typedef B3<A3{ {0,0,0,0,1}, {0,0,0,0,0} }>              B3_A3_____1__________;\n+typedef B3<A3{ {0,0,0,0,1} }>                           B3_A3_____1__________;\n+typedef B3<A3{ {0,0,0,1,0}, {0,0,0,0,0}, {0,0,0,0,0} }> B3_A3____1___________;\n+typedef B3<A3{ {0,0,1,0,0}, {0,0,0,0,0}, {0,0,0,0,0} }> B3_A3___1____________;\n+typedef B3<A3{ {0,1,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0} }> B3_A3__1_____________;\n+typedef B3<A3{ {1,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0} }> B3_A3_1______________;\n+typedef B3<A3{ {1,0,0,0,0}, {0,0,0,0,0} }>              B3_A3_1______________;\n+typedef B3<A3{ {1,0,0,0,0} }>                           B3_A3_1______________;\n+typedef B3<A3{ {1,0,0,0} }>                             B3_A3_1______________;\n+typedef B3<A3{ {1,0,0} }>                               B3_A3_1______________;\n+typedef B3<A3{ {1,0} }>                                 B3_A3_1______________;\n+typedef B3<A3{ {1} }>                                   B3_A3_1______________;\n+\n+typedef B3<A3{ {1,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,1} }> B3_A3_1_____________1;\n+typedef B3<A3{ {1},         {0},         {0,0,0,0,1} }> B3_A3_1_____________1;\n+typedef B3<A3{ {1},         {},          {0,0,0,0,1} }> B3_A3_1_____________1;\n+typedef B3<A3{ {0,1,0,0,0}, {0,0,0,0,0}, {0,0,0,1} }>   B3_A3__1___________1_;\n+typedef B3<A3{ {0,1},       {0},         {0,0,0,1} }>   B3_A3__1___________1_;\n+typedef B3<A3{ {0,1},       {},          {0,0,0,1} }>   B3_A3__1___________1_;\n+\n+// Same as above.\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\\0\",   \"\\0\\0\\0\\0\" }> B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\\0\",   \"\\0\\0\\0\" }>   B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\\0\",   \"\\0\\0\" }>     B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\\0\",   \"\\0\" }>       B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\\0\",   \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\",     \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\",       \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\",         \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\",           \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\",    \"\",           \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\",      \"\",           \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\\0\",        \"\",           \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\",          \"\",           \"\" }>         B3_A3________________;\n+typedef B3<A3{ \"\",          \"\" }>                       B3_A3________________;\n+typedef B3<A3{ \"\" }>                                    B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\",     { 0 } }>      B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\",      { 0 },        \"\\0\" }>       B3_A3________________;\n+typedef B3<A3{ { 0 },       \"\",           \"\\0\\0\\0\\0\" }> B3_A3________________;\n+typedef B3<A3{ \"\\0\\0\\0\",    \"\\0\\0\",       { } }>        B3_A3________________;\n+typedef B3<A3{ \"\\0\",        { },          \"\" }>         B3_A3________________;\n+typedef B3<A3{ { },         \"\\0\\0\\0\\0\",   \"\\0\\0\\0\" }>   B3_A3________________;\n+\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\",    {0,0,0,0,1} }> B3_A3_______________1;\n+typedef B3<A3{ \"\\0\\0\",      \"\\0\",        \"\\0\\0\\0\\1\" }>  B3_A3______________1_;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\",    \"\\0\\0\\1\" }>    B3_A3_____________1__;\n+typedef B3<A3{ \"\\0\\0\",      \"\\0\",        \"\\0\\1\" }>      B3_A3____________1___;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\",    \"\\1\" }>        B3_A3___________1____;\n+typedef B3<A3{ \"\\0\\0\",      {0,0,0,0,1}, \"\\0\" }>        B3_A3__________1_____;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\0\\0\\1\",  \"\\0\\0\\0\" }>    B3_A3_________1______;\n+typedef B3<A3{ \"\\0\\0\",      \"\\0\\0\\1\",    \"\\0\" }>        B3_A3________1_______;\n+typedef B3<A3{ \"\\0\\0\\0\\0\",  \"\\0\\1\",      \"\\0\\0\\0\" }>    B3_A3_______1________;\n+typedef B3<A3{ \"\\0\\0\",      \"\\1\",        \"\\0\" }>        B3_A3______1_________;\n+typedef B3<A3{ {0,0,0,0,1}, \"\\0\\0\\0\\0\",  \"\\0\\0\\0\" }>    B3_A3_____1__________;\n+typedef B3<A3{ \"\\0\\0\\0\\1\",  \"\\0\\0\",      \"\\0\" }>        B3_A3____1___________;\n+typedef B3<A3{ \"\\0\\0\\1\",    \"\\0\\0\\0\\0\",  \"\\0\\0\\0\" }>    B3_A3___1____________;\n+typedef B3<A3{ \"\\0\\1\",      \"\\0\\0\",      \"\\0\" }>        B3_A3__1_____________;\n+typedef B3<A3{ \"\\1\",        \"\",          \"\\0\\0\\0\\0\" }>  B3_A3_1______________;\n+\n+typedef B3<A3{ \"\\1\",        {},          {0,0,0,0,1} }> B3_A3_1_____________1;\n+typedef B3<A3{ \"\\1\",        \"\",          {0,0,0,0,1} }> B3_A3_1_____________1;\n+typedef B3<A3{ \"\\0\\1\",      {},          {0,0,0,1} }>   B3_A3__1___________1_;\n+typedef B3<A3{ \"\\0\\1\",      \"\",          \"\\0\\0\\0\\1\" }>  B3_A3__1___________1_;\n+typedef B3<A3{ \"\\0\\1\\0\",    \"\\0\",        \"\\0\\0\\0\\1\" }>  B3_A3__1___________1_;\n+\n+void f_b3_a3 (B3_A3________________) { }\n+void f_b3_a3 (B3_A3_______________1) { }\n+void f_b3_a3 (B3_A3______________1_) { }\n+void f_b3_a3 (B3_A3_____________1__) { }\n+void f_b3_a3 (B3_A3____________1___) { }\n+void f_b3_a3 (B3_A3___________1____) { }\n+void f_b3_a3 (B3_A3__________1_____) { }\n+void f_b3_a3 (B3_A3_________1______) { }\n+void f_b3_a3 (B3_A3________1_______) { }\n+void f_b3_a3 (B3_A3_______1________) { }\n+void f_b3_a3 (B3_A3______1_________) { }\n+void f_b3_a3 (B3_A3_____1__________) { }\n+void f_b3_a3 (B3_A3____1___________) { }\n+void f_b3_a3 (B3_A3___1____________) { }\n+void f_b3_a3 (B3_A3__1_____________) { }\n+void f_b3_a3 (B3_A3_1______________) { }\n+void f_b3_a3 (B3_A3_1_____________1) { }\n+void f_b3_a3 (B3_A3__1___________1_) { }\n+\n+typedef B3<A3{ \"AB\\0D\",  { },             \"IJKL\" }> B3_A3_ABZDZZZZZZIJKLZ;\n+typedef B3<A3{ \"AB\\0D\",  { 0, 0, 1 },     \"IJKL\" }> B3_A3_ABZDZZZ1ZZIJKLZ;\n+typedef B3<A3{ \"AB\\0D\",  { 0, 1 },        \"IJKL\" }> B3_A3_ABZDZZ1ZZZIJKLZ;\n+\n+void f (B3_A3_ABZDZZZZZZIJKLZ) { }\n+void f (B3_A3_ABZDZZZ1ZZIJKLZ) { }\n+void f (B3_A3_ABZDZZ1ZZZIJKLZ) { }"}, {"sha": "3afb5d24261b650d885f774153b051fcbd07c881", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class16.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class16.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,57 @@\n+// PR c++/89833\n+// Test to verify that arrays of null pointer to members used as\n+// non-type template arguments are interprested as null regardless\n+// of the form of their initialization.\n+// { dg-do compile { target c++2a } }\n+// { dg-options \"-O2 -Wall -fdump-tree-optimized\" }\n+\n+struct A { int i; };\n+\n+typedef int A::*pam_t;\n+\n+struct B { pam_t a[2]; };\n+template <B x> struct C { static constexpr B b = x; };\n+\n+B f__   () { return B{ }; }\n+B f0_   () { return B{ 0 }; }\n+B f00   () { return B{ 0, 0 }; }\n+\n+typedef C<B{ }>      X__;\n+typedef C<B{ 0 }>    X0_;\n+typedef C<B{ 0, 0 }> X00;\n+\n+B g__ () { return X__::b; }\n+B g0_ () { return X0_::b; }\n+B g00 () { return X00::b; }\n+\n+const B b__{ };\n+const B b0_{ 0 };\n+const B b00{ 0, 0 };\n+\n+const pam_t apam__[2] = { };\n+const pam_t apam0_[2] = { 0 };\n+const pam_t apam00[2] = { 0, 0 };\n+\n+#define assert(expr) \\\n+  (expr) ? (void)0 : __builtin_abort ()\n+\n+void test ()\n+{\n+  assert (f__ ().a[0] == nullptr && f__ ().a[1] == nullptr);\n+  assert (f0_ ().a[0] == nullptr && f0_ ().a[1] == nullptr);\n+  assert (f00 ().a[0] == nullptr && f00 ().a[1] == nullptr);\n+\n+  assert (g__ ().a[0] == nullptr && g__ ().a[1] == nullptr);\n+  assert (g0_ ().a[0] == nullptr && g0_ ().a[1] == nullptr);\n+  assert (g00 ().a[0] == nullptr && g00 ().a[1] == nullptr);\n+\n+  assert (b__.a[0] == nullptr && b__.a[1] == nullptr);\n+  assert (b0_.a[0] == nullptr && b0_.a[1] == nullptr);\n+  assert (b00.a[0] == nullptr && b00.a[1] == nullptr);\n+\n+  assert (apam__[0] == nullptr && apam__[1] == nullptr);\n+  assert (apam0_[0] == nullptr && apam0_[1] == nullptr);\n+  assert (apam00[0] == nullptr && apam00[1] == nullptr);\n+}\n+\n+// { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } }"}, {"sha": "2a90088953c0e4158752e8f03c6d6d70533fb5a0", "filename": "gcc/testsuite/g++.dg/init/array51.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray51.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray51.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Farray51.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,86 @@\n+// PR c++/89833\n+// Anal test to verify that arrays of null pointer to members are\n+// treated as null regardless of the form of their initialization,\n+// and have all bits set in their representation.\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O2 -Wall\" }\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+struct A { int i; };\n+\n+typedef int A::*pam_t;\n+\n+pam_t apam__[2] = { };\n+pam_t apam0_[2] = { 0 };\n+pam_t apam00[2] = { 0, 0 };\n+\n+struct B { pam_t a[2]; };\n+\n+NOIPA B f__   () { return B{ }; }\n+NOIPA B f0_   () { return B{ 0 }; }\n+NOIPA B f00   () { return B{ 0, 0 }; }\n+\n+const B c__{ };\n+const B c0_{ 0 };\n+const B c00{ 0, 0 };\n+\n+B b__{ };\n+B b0_{ 0 };\n+B b00{ 0, 0 };\n+\n+#define assert(expr)\t\t\t\t\\\n+  (expr) ? (void)0 : __builtin_abort ()\n+\n+signed char allones[2 * sizeof (pam_t)];\n+\n+#define assert_rep(mp, n)\t\t\t\\\n+  assert (!test_allones (mp, n))\n+\n+NOIPA void init_allones ()\n+{\n+  __builtin_memset (allones, -1, sizeof allones);\n+}\n+\n+NOIPA int test_allones (const pam_t *p, unsigned n)\n+{\n+  return __builtin_memcmp (allones, p, sizeof *p * n);\n+}\n+\n+int main ()\n+{\n+  init_allones ();\n+\n+  assert (apam__[0] == nullptr && apam__[1] == nullptr);\n+  assert (apam0_[0] == nullptr && apam0_[1] == nullptr);\n+  assert (apam00[0] == nullptr && apam00[1] == nullptr);\n+\n+  assert (f__ ().a[0] == nullptr && f__ ().a[1] == nullptr);\n+  assert (f0_ ().a[0] == nullptr && f0_ ().a[1] == nullptr);\n+  assert (f00 ().a[0] == nullptr && f00 ().a[1] == nullptr);\n+\n+  assert (b__.a[0] == nullptr && b__.a[1] == nullptr);\n+  assert (b0_.a[0] == nullptr && b0_.a[1] == nullptr);\n+  assert (b00.a[0] == nullptr && b00.a[1] == nullptr);\n+\n+  assert (c__.a[0] == nullptr && c__.a[1] == nullptr);\n+  assert (c0_.a[0] == nullptr && c0_.a[1] == nullptr);\n+  assert (c00.a[0] == nullptr && c00.a[1] == nullptr);\n+\n+  assert_rep (apam__, 2);\n+  assert_rep (apam0_, 2);\n+  assert_rep (apam00, 2);\n+\n+  assert_rep (f__ ().a, 2);\n+  assert_rep (f0_ ().a, 2);\n+  assert_rep (f0_ ().a, 2);\n+  assert_rep (f00 ().a, 2);\n+\n+  assert_rep (b__.a, 2);\n+  assert_rep (b0_.a, 2);\n+  assert_rep (b00.a, 2);\n+\n+  assert_rep (c__.a, 2);\n+  assert_rep (c0_.a, 2);\n+  assert_rep (c00.a, 2);\n+}"}, {"sha": "18a3058e7e314146c83b5eaa8bb0c0eb9813223f", "filename": "gcc/testsuite/g++.dg/template/nontype29.C", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187c6369c0b4c7e013fdbe9eb08d098166359056/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype29.C?ref=187c6369c0b4c7e013fdbe9eb08d098166359056", "patch": "@@ -0,0 +1,81 @@\n+// PR c++/47488 - sorry, unimplemented: string literal in function\n+// template signature\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+\n+#if __cpluspls >= 201103L\n+\n+// C++ 11 test case from comment #0.\n+namespace comment_0 {\n+\n+template <typename T>\n+int f (const T&, const char *);\n+\n+template <typename T>\n+decltype (f (T (), \"\")) g (const T &);\n+\n+void h ()\n+{\n+  g (0);\n+}\n+\n+}   // comment_0\n+\n+#endif\n+\n+// C++ 98 test case from comment #1.\n+namespace comment_1 {\n+\n+template <typename T>\n+int  f(const T&, const char *);\n+\n+template<int> struct N { };\n+\n+template <typename T>\n+N<sizeof (f (T (), \"\"))> g (const T&);\n+\n+void h ()\n+{\n+  g (0);\n+}\n+\n+}   // comment_1\n+\n+// C++ 98 test case from comment #2.\n+namespace comment_2 {\n+\n+template <typename T>\n+int f (const char *);\n+\n+template<int> struct N { };\n+\n+template <typename T>\n+N<sizeof (f<T>(\"\"))> g (const T &);\n+\n+void h ()\n+{\n+  g (0);\n+}\n+\n+}   // comment_2\n+\n+\n+#if __cpluspls >= 201103L\n+\n+// C++ 11 test case from comment #5.\n+namespace comment_5 {\n+\n+template <typename T> constexpr T f(const T* p) { return p[0]; }\n+template <int> struct N { };\n+template <typename T> void g (T, N<f((const T*)\"1\")>) { }\n+template <typename T> void g (T, N<f((const T*)\"2\")>) { }\n+\n+void h ()\n+{\n+  g ('1', N<'1'>());\n+  g ('2', N<'2'>());\n+}\n+\n+}\n+\n+#endif"}]}