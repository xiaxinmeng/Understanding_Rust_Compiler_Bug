{"sha": "bccaf73a0589a218b90f430c3471cd12ebcdf97e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjYWY3M2EwNTg5YTIxOGI5MGY0MzBjMzQ3MWNkMTJlYmNkZjk3ZQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-02T12:06:59Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-02T12:06:59Z"}, "message": "parse.y (patch_method_invocation): Handle calling static methods...\n\nd\n\t* parse.y (patch_method_invocation):  Handle calling static methods,\n\teven in the form EXPR.METHOD(ARGS), not just TYPE.METHOD(ARGS).\n\t* parse.y (java_complete_lhs):  Don't complain about unreachable\n\texit condition in a do-while statement.\n\nFrom-SVN: r24968", "tree": {"sha": "8802dd0bd8fd7128360334e64a734ab0574aae58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8802dd0bd8fd7128360334e64a734ab0574aae58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bccaf73a0589a218b90f430c3471cd12ebcdf97e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bccaf73a0589a218b90f430c3471cd12ebcdf97e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bccaf73a0589a218b90f430c3471cd12ebcdf97e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bccaf73a0589a218b90f430c3471cd12ebcdf97e/comments", "author": null, "committer": null, "parents": [{"sha": "7221f080227636b16826313a5148999c777d8b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7221f080227636b16826313a5148999c777d8b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7221f080227636b16826313a5148999c777d8b67"}], "stats": {"total": 52, "additions": 38, "deletions": 14}, "files": [{"sha": "5f9ad6ef56e8906ad7336b04593a385e954d1bf0", "filename": "gcc/java/parse.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccaf73a0589a218b90f430c3471cd12ebcdf97e/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccaf73a0589a218b90f430c3471cd12ebcdf97e/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=bccaf73a0589a218b90f430c3471cd12ebcdf97e", "patch": "@@ -9270,6 +9270,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n   tree list;\n   int is_static_flag = 0;\n   int is_super_init = 0;\n+  tree this_arg = NULL_TREE;\n   \n   /* Should be overriden if everything goes well. Otherwise, if\n      something fails, it should keep this value. It stop the\n@@ -9367,7 +9368,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t\t\t\t       identifier, args);\n \n \t  /* 4- Add the field as an argument */\n-\t  args = tree_cons (NULL_TREE, field, nreverse (args));\n+\t  args = nreverse (args);\n+\t  this_arg = field;\n \t}\n \n       /* IDENTIFIER_WFL will be used to report any problem further */\n@@ -9462,8 +9464,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t returned by the object allocator. If method is resolved as a\n \t primary, use the primary otherwise use the current THIS. */\n       args = nreverse (args);\n-      if (!METHOD_STATIC (list) && TREE_CODE (patch) != NEW_CLASS_EXPR)\n-\targs = tree_cons (NULL_TREE, primary ? primary : current_this, args);\n+      if (TREE_CODE (patch) != NEW_CLASS_EXPR)\n+\tthis_arg = primary ? primary : current_this;\n     }\n \n   /* Merge point of all resolution schemes. If we have nothing, this\n@@ -9488,6 +9490,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n   check_deprecation (wfl, list);\n \n   is_static_flag = METHOD_STATIC (list);\n+  if (! METHOD_STATIC (list) && this_arg != NULL_TREE)\n+    args = tree_cons (NULL_TREE, this_arg, args);\n \n   /* In the context of an explicit constructor invocation, we can't\n      invoke any method relying on `this'. Exceptions are: we're\n@@ -10365,10 +10369,18 @@ java_complete_lhs (node)\n       TREE_OPERAND (node, 0) = nn = \n \tjava_complete_tree (TREE_OPERAND (node, 0));\n       if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK\n-\t  && TREE_OPERAND (node, 1) != empty_stmt_node)\n-\t{\n-\t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n-\t  parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t  && wfl_op2 != empty_stmt_node)\n+\t{\n+\t  /* An unreachable condition in a do-while statement\n+\t     is *not* (technically) an unreachable statement. */\n+\t  nn = wfl_op2;\n+\t  if (TREE_CODE (nn) == EXPR_WITH_FILE_LOCATION)\n+\t    nn = EXPR_WFL_NODE (nn);\n+\t  if (TREE_CODE (nn) != EXIT_EXPR)\n+\t    {\n+\t      SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n+\t      parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t    }\n \t}\n       TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n       if (TREE_OPERAND (node, 1) == error_mark_node)"}, {"sha": "ac8f03e245eec56a07e7700a1abbc1af44780dcd", "filename": "gcc/java/parse.y", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bccaf73a0589a218b90f430c3471cd12ebcdf97e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bccaf73a0589a218b90f430c3471cd12ebcdf97e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=bccaf73a0589a218b90f430c3471cd12ebcdf97e", "patch": "@@ -6632,6 +6632,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n   tree list;\n   int is_static_flag = 0;\n   int is_super_init = 0;\n+  tree this_arg = NULL_TREE;\n   \n   /* Should be overriden if everything goes well. Otherwise, if\n      something fails, it should keep this value. It stop the\n@@ -6729,7 +6730,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t\t\t\t       identifier, args);\n \n \t  /* 4- Add the field as an argument */\n-\t  args = tree_cons (NULL_TREE, field, nreverse (args));\n+\t  args = nreverse (args);\n+\t  this_arg = field;\n \t}\n \n       /* IDENTIFIER_WFL will be used to report any problem further */\n@@ -6824,8 +6826,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t returned by the object allocator. If method is resolved as a\n \t primary, use the primary otherwise use the current THIS. */\n       args = nreverse (args);\n-      if (!METHOD_STATIC (list) && TREE_CODE (patch) != NEW_CLASS_EXPR)\n-\targs = tree_cons (NULL_TREE, primary ? primary : current_this, args);\n+      if (TREE_CODE (patch) != NEW_CLASS_EXPR)\n+\tthis_arg = primary ? primary : current_this;\n     }\n \n   /* Merge point of all resolution schemes. If we have nothing, this\n@@ -6850,6 +6852,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n   check_deprecation (wfl, list);\n \n   is_static_flag = METHOD_STATIC (list);\n+  if (! METHOD_STATIC (list) && this_arg != NULL_TREE)\n+    args = tree_cons (NULL_TREE, this_arg, args);\n \n   /* In the context of an explicit constructor invocation, we can't\n      invoke any method relying on `this'. Exceptions are: we're\n@@ -7727,10 +7731,18 @@ java_complete_lhs (node)\n       TREE_OPERAND (node, 0) = nn = \n \tjava_complete_tree (TREE_OPERAND (node, 0));\n       if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK\n-\t  && TREE_OPERAND (node, 1) != empty_stmt_node)\n-\t{\n-\t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n-\t  parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t  && wfl_op2 != empty_stmt_node)\n+\t{\n+\t  /* An unreachable condition in a do-while statement\n+\t     is *not* (technically) an unreachable statement. */\n+\t  nn = wfl_op2;\n+\t  if (TREE_CODE (nn) == EXPR_WITH_FILE_LOCATION)\n+\t    nn = EXPR_WFL_NODE (nn);\n+\t  if (TREE_CODE (nn) != EXIT_EXPR)\n+\t    {\n+\t      SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n+\t      parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t    }\n \t}\n       TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n       if (TREE_OPERAND (node, 1) == error_mark_node)"}]}