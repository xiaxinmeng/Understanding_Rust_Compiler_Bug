{"sha": "2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQyZTkyM2ZjMTA1MmY0YWYwOGUzYTJiMWQzZGFkZDg0N2I4MzA3ZQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2010-02-24T13:09:37Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2010-02-24T13:09:37Z"}, "message": "re PR c/43128 (c-c++-common/pr41779.c doesn't work)\n\n2010-02-24  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR c/43128\n\t* c-typeck.c (ep_convert_and_check): New.\n\t(build_conditional_expr): Use it.\n\t(build_binary_op): Likewise.\ntestsuite/\t\n\t* c-c++-common/pr41779.c: Update.\n\nFrom-SVN: r157040", "tree": {"sha": "39e3521ef4e168d776325f7e4429f4c17398ac1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39e3521ef4e168d776325f7e4429f4c17398ac1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/comments", "author": null, "committer": null, "parents": [{"sha": "015e9be7de8739b1cb4e1f5fc5eb722d09671f9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015e9be7de8739b1cb4e1f5fc5eb722d09671f9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015e9be7de8739b1cb4e1f5fc5eb722d09671f9c"}], "stats": {"total": 113, "additions": 87, "deletions": 26}, "files": [{"sha": "c99cce8f0d58af73610cf4a6541cd075f33dea61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "patch": "@@ -1,3 +1,10 @@\n+2010-02-24  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR c/43128\n+\t* c-typeck.c (ep_convert_and_check): New.\n+\t(build_conditional_expr): Use it.\n+\t(build_binary_op): Likewise.\n+\n 2010-02-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* regcprop.c (copyprop_hardreg_forward_1): Don't call df_insn_rescan."}, {"sha": "81c18ac7bf9ccc1a777688f68b01ba1155704145", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "patch": "@@ -3897,6 +3897,34 @@ c_mark_addressable (tree exp)\n     }\n }\n \f\n+/* Convert EXPR to TYPE, warning about conversion problems with\n+   constants.  SEMANTIC_TYPE is the type this conversion would use\n+   without excess precision. If SEMANTIC_TYPE is NULL, this function\n+   is equivalent to convert_and_check. This function is a wrapper that\n+   handles conversions that may be different than\n+   the usual ones because of excess precision.  */\n+\n+static tree\n+ep_convert_and_check (tree type, tree expr, tree semantic_type)\n+{\n+  if (TREE_TYPE (expr) == type)\n+    return expr;\n+\n+  if (!semantic_type)\n+    return convert_and_check (type, expr);\n+\n+  if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+      && TREE_TYPE (expr) != semantic_type)\n+    {\n+      /* For integers, we need to check the real conversion, not\n+\t the conversion to the excess precision type.  */\n+      expr = convert_and_check (semantic_type, expr);\n+    }\n+  /* Result type is the excess precision type, which should be\n+     large enough, so do not check.  */\n+  return convert (type, expr);\n+}\n+\n /* Build and return a conditional expression IFEXP ? OP1 : OP2.  If\n    IFEXP_BCP then the condition is a call to __builtin_constant_p, and\n    if folded to an integer constant then the unselected half may\n@@ -3913,7 +3941,7 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n   enum tree_code code1;\n   enum tree_code code2;\n   tree result_type = NULL;\n-  tree ep_result_type = NULL;\n+  tree semantic_result_type = NULL;\n   tree orig_op1 = op1, orig_op2 = op2;\n   bool int_const, op1_int_operands, op2_int_operands, int_operands;\n   bool ifexp_int_operands;\n@@ -3964,7 +3992,7 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n       && (code2 == INTEGER_TYPE || code2 == REAL_TYPE\n \t  || code2 == COMPLEX_TYPE))\n     {\n-      ep_result_type = c_common_type (type1, type2);\n+      semantic_result_type = c_common_type (type1, type2);\n       if (TREE_CODE (op1) == EXCESS_PRECISION_EXPR)\n \t{\n \t  op1 = TREE_OPERAND (op1, 0);\n@@ -4169,10 +4197,8 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t\t\t  TYPE_READONLY (type1) || TYPE_READONLY (type2),\n \t\t\t  TYPE_VOLATILE (type1) || TYPE_VOLATILE (type2));\n \n-  if (result_type != type1)\n-    op1 = convert_and_check (result_type, op1);\n-  if (result_type != type2)\n-    op2 = convert_and_check (result_type, op2);\n+  op1 = ep_convert_and_check (result_type, op1, semantic_result_type);\n+  op2 = ep_convert_and_check (result_type, op2, semantic_result_type);\n \n   if (ifexp_bcp && ifexp == truthvalue_true_node)\n     {\n@@ -4204,8 +4230,8 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n       if (int_operands)\n \tret = note_integer_operands (ret);\n     }\n-  if (ep_result_type)\n-    ret = build1 (EXCESS_PRECISION_EXPR, ep_result_type, ret);\n+  if (semantic_result_type)\n+    ret = build1 (EXCESS_PRECISION_EXPR, semantic_result_type, ret);\n \n   protected_set_expr_location (ret, colon_loc);\n   return ret;\n@@ -9023,7 +9049,7 @@ build_binary_op (location_t location, enum tree_code code,\n \n   /* When the computation is in excess precision, the type of the\n      final EXCESS_PRECISION_EXPR.  */\n-  tree real_result_type = NULL;\n+  tree semantic_result_type = NULL;\n \n   /* Nonzero means operands have already been type-converted\n      in whatever way is necessary.\n@@ -9602,7 +9628,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t  if (type0 != orig_type0 || type1 != orig_type1)\n \t    {\n \t      gcc_assert (may_need_excess_precision && common);\n-\t      real_result_type = c_common_type (orig_type0, orig_type1);\n+\t      semantic_result_type = c_common_type (orig_type0, orig_type1);\n \t    }\n \t  if (first_complex)\n \t    {\n@@ -9799,29 +9825,27 @@ build_binary_op (location_t location, enum tree_code code,\n       return error_mark_node;\n     }\n \n-  if (!converted)\n-    {\n-      if (TREE_TYPE (op0) != result_type)\n-\top0 = convert_and_check (result_type, op0);\n-      if (TREE_TYPE (op1) != result_type)\n-\top1 = convert_and_check (result_type, op1);\n-\n-      /* This can happen if one operand has a vector type, and the other\n-\t has a different type.  */\n-      if (TREE_CODE (op0) == ERROR_MARK || TREE_CODE (op1) == ERROR_MARK)\n-\treturn error_mark_node;\n-    }\n-\n   if (build_type == NULL_TREE)\n     {\n       build_type = result_type;\n       if (type0 != orig_type0 || type1 != orig_type1)\n \t{\n \t  gcc_assert (may_need_excess_precision && common);\n-\t  real_result_type = c_common_type (orig_type0, orig_type1);\n+\t  semantic_result_type = c_common_type (orig_type0, orig_type1);\n \t}\n     }\n \n+  if (!converted)\n+    {\n+      op0 = ep_convert_and_check (result_type, op0, semantic_result_type);\n+      op1 = ep_convert_and_check (result_type, op1, semantic_result_type);\n+\n+      /* This can happen if one operand has a vector type, and the other\n+\t has a different type.  */\n+      if (TREE_CODE (op0) == ERROR_MARK || TREE_CODE (op1) == ERROR_MARK)\n+\treturn error_mark_node;\n+    }\n+\n   /* Treat expressions in initializers specially as they can't trap.  */\n   if (int_const_or_overflow)\n     ret = (require_constant_value\n@@ -9842,8 +9866,8 @@ build_binary_op (location_t location, enum tree_code code,\n   else if (TREE_CODE (ret) != INTEGER_CST && int_operands\n \t   && !in_late_binary_op)\n     ret = note_integer_operands (ret);\n-  if (real_result_type)\n-    ret = build1 (EXCESS_PRECISION_EXPR, real_result_type, ret);\n+  if (semantic_result_type)\n+    ret = build1 (EXCESS_PRECISION_EXPR, semantic_result_type, ret);\n   protected_set_expr_location (ret, location);\n   return ret;\n }"}, {"sha": "196c6bf02f0804a11dc7242b01854dd2ce5b08f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "patch": "@@ -1,3 +1,8 @@\n+2010-02-24  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR c/43128\n+\t* c-c++-common/pr41779.c: Update.\n+\n 2010-02-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR ada/32547"}, {"sha": "80c8e6b1ddd2f91995594ed69086115acb076815", "filename": "gcc/testsuite/c-c++-common/pr41779.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr41779.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2e923fc1052f4af08e3a2b1d3dadd847b8307e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr41779.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr41779.c?ref=2d2e923fc1052f4af08e3a2b1d3dadd847b8307e", "patch": "@@ -29,3 +29,28 @@ float f5(float x, int y)\n {\n   return x * y; /* { dg-warning \"conversion\" } */\n }\n+\n+double c1(float x, unsigned short y, int z)\n+{\n+  return z ? x + x : y;\n+}\n+\n+double c2(float x, short y, int z)\n+{\n+  return z ? x + x : y;\n+}\n+\n+double c3(float x, char y, int z)\n+{\n+  return z ? x + x : y;\n+}\n+\n+double c4(float x, unsigned char y, int z)\n+{\n+  return z ? x + x : y;\n+}\n+\n+double c5(float x, int y, int z)\n+{\n+  return z ? x + x : y; /* { dg-warning \"conversion\" } */\n+}"}]}