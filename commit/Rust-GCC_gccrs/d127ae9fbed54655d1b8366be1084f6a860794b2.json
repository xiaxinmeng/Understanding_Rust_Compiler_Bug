{"sha": "d127ae9fbed54655d1b8366be1084f6a860794b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEyN2FlOWZiZWQ1NDY1NWQxYjgzNjZiZTEwODRmNmE4NjA3OTRiMg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-04-28T22:29:40Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-04-28T22:29:40Z"}, "message": "PR tree-optimization/80523 -  -Wformat-overflow doesn't consider -fexec-charset\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/80523\n\t* gimple-ssa-sprintf.c (target_to_host_charmap): New global variable.\n\t(init_target_to_host_charmap, target_to_host, target_strtol10): New\n\tfunctions.\n\t(maybe_warn, format_directive, parse_directive): Use new functions.\n\t(pass_sprintf_length::execute): Call init_target_to_host_charmap.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/80523\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-18.c: New test.\n\nFrom-SVN: r247401", "tree": {"sha": "b9636a01fc267c0c7e214301db75f442397a5df2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9636a01fc267c0c7e214301db75f442397a5df2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d127ae9fbed54655d1b8366be1084f6a860794b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d127ae9fbed54655d1b8366be1084f6a860794b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d127ae9fbed54655d1b8366be1084f6a860794b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d127ae9fbed54655d1b8366be1084f6a860794b2/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c961093393e427bce36172d6b3d0348af403cd96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c961093393e427bce36172d6b3d0348af403cd96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c961093393e427bce36172d6b3d0348af403cd96"}], "stats": {"total": 517, "additions": 443, "deletions": 74}, "files": [{"sha": "f8486784f4c0f05e2480d5e0ef104a7eb62e5334", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d127ae9fbed54655d1b8366be1084f6a860794b2", "patch": "@@ -1,3 +1,12 @@\n+2017-04-28  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/80523\n+\t* gimple-ssa-sprintf.c (target_to_host_charmap): New global variable.\n+\t(init_target_to_host_charmap, target_to_host, target_strtol10): New\n+\tfunctions.\n+\t(maybe_warn, format_directive, parse_directive): Use new functions.\n+\t(pass_sprintf_length::execute): Call init_target_to_host_charmap.\t\n+\n 2017-04-28  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* match.pd (X+Z OP Y+Z, X-Z OP Y-Z, Z-X OP Z-Y): New transformations."}, {"sha": "9ad2f6e1fcc54b48cead4c9f2609ac04a233d1cc", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=d127ae9fbed54655d1b8366be1084f6a860794b2", "patch": "@@ -304,7 +304,7 @@ C ObjC C++ ObjC++ Var(warn_alloca) Warning\n Warn on any use of alloca.\n \n Walloc-size-larger-than=\n-C ObjC C++ ObjC++ Var(warn_alloc_size_limit) Warning Joined\n+C ObjC C++ ObjC++ Var(warn_alloc_size_limit) Warning Joined LangEnabledBy(C ObjC C++ ObjC++,Wall)\n -Walloc-size-larger-than=<bytes> Warn for calls to allocation functions that\n attempt to allocate objects larger than the specified number of bytes.\n \n@@ -716,7 +716,7 @@ Warn about buffer overflow in string manipulation functions like memcpy\n and strcpy.\n \n Wstringop-overflow=\n-C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_stringop_overflow) Init(2) Warning\n+C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_stringop_overflow) Init(2) Warning LangEnabledBy(C ObjC C++ ObjC++, Wall)\n Under the control of Object Size type, warn about buffer overflow in string\n manipulation functions like memcpy and strcpy.\n "}, {"sha": "c3c717d9060273594d9626611000cc35e4b89257", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 286, "deletions": 72, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=d127ae9fbed54655d1b8366be1084f6a860794b2", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"calls.h\"\n #include \"cfgloop.h\"\n #include \"intl.h\"\n+#include \"langhooks.h\"\n \n #include \"builtins.h\"\n #include \"stor-layout.h\"\n@@ -273,6 +274,158 @@ target_size_max ()\n   return tree_to_uhwi (TYPE_MAX_VALUE (size_type_node));\n }\n \n+/* A straightforward mapping from the execution character set to the host\n+   character set indexed by execution character.  */\n+\n+static char target_to_host_charmap[256];\n+\n+/* Initialize a mapping from the execution character set to the host\n+   character set.  */\n+\n+static bool\n+init_target_to_host_charmap ()\n+{\n+  /* If the percent sign is non-zero the mapping has already been\n+     initialized.  */\n+  if (target_to_host_charmap['%'])\n+    return true;\n+\n+  /* Initialize the target_percent character (done elsewhere).  */\n+  if (!init_target_chars ())\n+    return false;\n+\n+  /* The subset of the source character set used by printf conversion\n+     specifications (strictly speaking, not all letters are used but\n+     they are included here for the sake of simplicity).  The dollar\n+     sign must be included even though it's not in the basic source\n+     character set.  */\n+  const char srcset[] = \" 0123456789!\\\"#%&'()*+,-./:;<=>?[\\\\]^_{|}~$\"\n+    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n+\n+  /* Set the mapping for all characters to some ordinary value (i,e.,\n+     not none used in printf conversion specifications) and overwrite\n+     those that are used by conversion specifications with their\n+     corresponding values.  */\n+  memset (target_to_host_charmap + 1, '?', sizeof target_to_host_charmap - 1);\n+\n+  /* Are the two sets of characters the same?  */\n+  bool all_same_p = true;\n+\n+  for (const char *pc = srcset; *pc; ++pc)\n+    {\n+      /* Slice off the high end bits in case target characters are\n+\t signed.  All values are expected to be non-nul, otherwise\n+\t there's a problem.  */\n+      if (unsigned char tc = lang_hooks.to_target_charset (*pc))\n+\t{\n+\t  target_to_host_charmap[tc] = *pc;\n+\t  if (tc != *pc)\n+\t    all_same_p = false;\n+\t}\n+      else\n+\treturn false;\n+\n+    }\n+\n+  /* Set the first element to a non-zero value if the mapping\n+     is 1-to-1, otherwise leave it clear (NUL is assumed to be\n+     the same in both character sets).  */\n+  target_to_host_charmap[0] = all_same_p;\n+\n+  return true;\n+}\n+\n+/* Return the host source character corresponding to the character\n+   CH in the execution character set if one exists, or some innocuous\n+   (non-special, non-nul) source character otherwise.  */\n+\n+static inline unsigned char\n+target_to_host (unsigned char ch)\n+{\n+  return target_to_host_charmap[ch];\n+}\n+\n+/* Convert an initial substring of the string TARGSTR consisting of\n+   characters in the execution character set into a string in the\n+   source character set on the host and store up to HOSTSZ characters\n+   in the buffer pointed to by HOSTR.  Return HOSTR.  */\n+\n+static const char*\n+target_to_host (char *hostr, size_t hostsz, const char *targstr)\n+{\n+  /* Make sure the buffer is reasonably big.  */\n+  gcc_assert (hostsz > 4);\n+\n+  /* The interesting subset of source and execution characters are\n+     the same so no conversion is necessary.  However, truncate\n+     overlong strings just like the translated strings are.  */\n+  if (target_to_host_charmap['\\0'] == 1)\n+    {\n+      strncpy (hostr, targstr, hostsz - 4);\n+      if (strlen (targstr) >= hostsz)\n+\tstrcpy (hostr + hostsz - 4, \"...\");\n+      return hostr;\n+    }\n+\n+  /* Convert the initial substring of TARGSTR to the corresponding\n+     characters in the host set, appending \"...\" if TARGSTR is too\n+     long to fit.  Using the static buffer assumes the function is\n+     not called in between sequence points (which it isn't).  */\n+  for (char *ph = hostr; ; ++targstr)\n+    {\n+      *ph++ = target_to_host (*targstr);\n+      if (!*targstr)\n+\tbreak;\n+\n+      if (size_t (ph - hostr) == hostsz - 4)\n+\t{\n+\t  *ph = '\\0';\n+\t  strcat (ph, \"...\");\n+\t  break;\n+\t}\n+    }\n+\n+  return hostr;\n+}\n+\n+/* Convert the sequence of decimal digits in the execution character\n+   starting at S to a long, just like strtol does.  Return the result\n+   and set *END to one past the last converted character.  On range\n+   error set ERANGE to the digit that caused it.  */\n+\n+static inline long\n+target_strtol10 (const char **ps, const char **erange)\n+{\n+  unsigned HOST_WIDE_INT val = 0;\n+  for ( ; ; ++*ps)\n+    {\n+      unsigned char c = target_to_host (**ps);\n+      if (ISDIGIT (c))\n+\t{\n+\t  c -= '0';\n+\n+\t  /* Check for overflow.  */\n+\t  if (val > (LONG_MAX - c) / 10LU)\n+\t    {\n+\t      val = LONG_MAX;\n+\t      *erange = *ps;\n+\n+\t      /* Skip the remaining digits.  */\n+\t      do\n+\t\tc = target_to_host (*++*ps);\n+\t      while (ISDIGIT (c));\n+\t      break;\n+\t    }\n+\t  else\n+\t    val = val * 10 + c;\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  return val;\n+}\n+\n /* Return the constant initial value of DECL if available or DECL\n    otherwise.  Same as the synonymous function in c/c-typeck.c.  */\n \n@@ -2284,12 +2437,16 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t    || (res.max < HOST_WIDE_INT_MAX\n \t\t\t&& avail_range.min < res.max)));\n \n+  /* Buffer for the directive in the host character set (used when\n+     the source character set is different).  */\n+  char hostdir[32];\n+\n   if (avail_range.min == avail_range.max)\n     {\n       /* The size of the destination region is exact.  */\n       unsigned HOST_WIDE_INT navail = avail_range.max;\n \n-      if (*dir.beg != '%')\n+      if (target_to_host (*dir.beg) != '%')\n \t{\n \t  /* For plain character directives (i.e., the format string itself)\n \t     but not others, point the caret at the first character that's\n@@ -2339,9 +2496,9 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t  : G_(\"%<%.*s%> directive writing %wu bytes \"\n \t\t       \"into a region of size %wu\")));\n \t  return fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t  info.warnopt (), fmtstr,\n-\t\t\t  dir.len, dir.beg, res.min,\n-\t\t\t  navail);\n+\t\t\t  info.warnopt (), fmtstr, dir.len,\n+\t\t\t  target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t\t  res.min, navail);\n \t}\n \n       if (res.min == 0 && res.max < maxbytes)\n@@ -2356,8 +2513,8 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t       : G_(\"%<%.*s%> directive writing up to %wu bytes \"\n \t\t    \"into a region of size %wu\"));\n \t  return fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t  info.warnopt (), fmtstr,\n-\t\t\t  dir.len, dir.beg,\n+\t\t\t  info.warnopt (), fmtstr, dir.len,\n+\t\t\t  target_to_host (hostdir, sizeof hostdir, dir.beg),\n \t\t\t  res.max, navail);\n \t}\n \n@@ -2376,8 +2533,8 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t       : G_(\"%<%.*s%> directive writing likely %wu or more bytes \"\n \t\t    \"into a region of size %wu\"));\n \t  return fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t  info.warnopt (), fmtstr,\n-\t\t\t  dir.len, dir.beg,\n+\t\t\t  info.warnopt (), fmtstr, dir.len,\n+\t\t\t  target_to_host (hostdir, sizeof hostdir, dir.beg),\n \t\t\t  res.likely, navail);\n \t}\n \n@@ -2393,10 +2550,9 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t       : G_(\"%<%.*s%> directive writing between %wu and \"\n \t\t    \"%wu bytes into a region of size %wu\"));\n \t  return fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t  info.warnopt (), fmtstr,\n-\t\t\t  dir.len, dir.beg,\n-\t\t\t  res.min, res.max,\n-\t\t\t  navail);\n+\t\t\t  info.warnopt (), fmtstr, dir.len,\n+\t\t\t  target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t\t  res.min, res.max, navail);\n \t}\n \n       const char* fmtstr\n@@ -2409,14 +2565,14 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t   : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n \t\t\"into a region of size %wu\"));\n       return fmtwarn (dirloc, pargrange, NULL,\n-\t\t      info.warnopt (), fmtstr,\n-\t\t      dir.len, dir.beg,\n+\t\t      info.warnopt (), fmtstr, dir.len,\n+\t\t      target_to_host (hostdir, sizeof hostdir, dir.beg),\n \t\t      res.min, navail);\n     }\n \n   /* The size of the destination region is a range.  */\n \n-  if (*dir.beg != '%')\n+  if (target_to_host (*dir.beg) != '%')\n     {\n       unsigned HOST_WIDE_INT navail = avail_range.max;\n \n@@ -2468,9 +2624,9 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t\t   \"into a region of size between %wu and %wu\")));\n \n       return fmtwarn (dirloc, pargrange, NULL,\n-\t\t      info.warnopt (), fmtstr,\n-\t\t      dir.len, dir.beg, res.min,\n-\t\t      avail_range.min, avail_range.max);\n+\t\t      info.warnopt (), fmtstr, dir.len,\n+\t\t      target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t      res.min, avail_range.min, avail_range.max);\n     }\n \n   if (res.min == 0 && res.max < maxbytes)\n@@ -2487,9 +2643,9 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t   : G_(\"%<%.*s%> directive writing up to %wu bytes \"\n \t\t\"into a region of size between %wu and %wu\"));\n       return fmtwarn (dirloc, pargrange, NULL,\n-\t\t      info.warnopt (), fmtstr,\n-\t\t      dir.len, dir.beg, res.max,\n-\t\t      avail_range.min, avail_range.max);\n+\t\t      info.warnopt (), fmtstr, dir.len,\n+\t\t      target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t      res.max, avail_range.min, avail_range.max);\n     }\n \n   if (res.min == 0 && maxbytes <= res.max)\n@@ -2509,9 +2665,9 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t   : G_(\"%<%.*s%> directive writing likely %wu or more bytes \"\n \t\t\"into a region of size between %wu and %wu\"));\n       return fmtwarn (dirloc, pargrange, NULL,\n-\t\t      info.warnopt (), fmtstr,\n-\t\t      dir.len, dir.beg, res.likely,\n-\t\t      avail_range.min, avail_range.max);\n+\t\t      info.warnopt (), fmtstr, dir.len,\n+\t\t      target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t      res.likely, avail_range.min, avail_range.max);\n     }\n \n   if (res.max < maxbytes)\n@@ -2528,10 +2684,9 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t   : G_(\"%<%.*s%> directive writing between %wu and \"\n \t\t\"%wu bytes into a region of size between %wu and %wu\"));\n       return fmtwarn (dirloc, pargrange, NULL,\n-\t\t      info.warnopt (), fmtstr,\n-\t\t      dir.len, dir.beg,\n-\t\t      res.min, res.max,\n-\t\t      avail_range.min, avail_range.max);\n+\t\t      info.warnopt (), fmtstr, dir.len,\n+\t\t      target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t      res.min, res.max, avail_range.min, avail_range.max);\n     }\n \n   const char* fmtstr\n@@ -2546,10 +2701,9 @@ maybe_warn (substring_loc &dirloc, source_range *pargrange,\n        : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n \t    \"into a region of size between %wu and %wu\"));\n   return fmtwarn (dirloc, pargrange, NULL,\n-\t\t  info.warnopt (), fmtstr,\n-\t\t  dir.len, dir.beg,\n-\t\t  res.min,\n-\t\t  avail_range.min, avail_range.max);\n+\t\t  info.warnopt (), fmtstr, dir.len,\n+\t\t  target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t  res.min, avail_range.min, avail_range.max);\n }\n \n /* Compute the length of the output resulting from the directive DIR\n@@ -2630,13 +2784,17 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t}\n     }\n \n+  /* Buffer for the directive in the host character set (used when\n+     the source character set is different).  */\n+  char hostdir[32];\n+\n   int dirlen = dir.len;\n \n   if (fmtres.nullp)\n     {\n       fmtwarn (dirloc, pargrange, NULL, info.warnopt (),\n \t       \"%<%.*s%> directive argument is null\",\n-\t       dirlen, dir.beg);\n+\t       dirlen, target_to_host (hostdir, sizeof hostdir, dir.beg));\n \n       /* Don't bother processing the rest of the format string.  */\n       res->warned = true;\n@@ -2703,7 +2861,9 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t\t  info.warnopt (),\n \t\t\t  \"%<%.*s%> directive output of %wu bytes exceeds \"\n \t\t\t  \"minimum required size of 4095\",\n-\t\t\t  dirlen, dir.beg, fmtres.range.min);\n+\t\t\t  dirlen,\n+\t\t\t  target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t\t  fmtres.range.min);\n       else\n \t{\n \t  const char *fmtstr\n@@ -2714,8 +2874,8 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t    \"bytes exceeds minimum required size of 4095\"));\n \n \t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t    dirlen, dir.beg,\n+\t\t\t    info.warnopt (), fmtstr, dirlen,\n+\t\t\t    target_to_host (hostdir, sizeof hostdir, dir.beg),\n \t\t\t    fmtres.range.min, fmtres.range.max);\n \t}\n     }\n@@ -2744,7 +2904,9 @@ format_directive (const pass_sprintf_length::call_info &info,\n \twarned = fmtwarn (dirloc, pargrange, NULL, info.warnopt (),\n \t\t\t  \"%<%.*s%> directive output of %wu bytes causes \"\n \t\t\t  \"result to exceed %<INT_MAX%>\",\n-\t\t\t  dirlen, dir.beg, fmtres.range.min);\n+\t\t\t  dirlen,\n+\t\t\t  target_to_host (hostdir, sizeof hostdir, dir.beg),\n+\t\t\t  fmtres.range.min);\n       else\n \t{\n \t  const char *fmtstr\n@@ -2754,8 +2916,8 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t       : G_ (\"%<%.*s%> directive output between %wu and %wu \"\n \t\t     \"bytes may cause result to exceed %<INT_MAX%>\"));\n \t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t    dirlen, dir.beg,\n+\t\t\t    info.warnopt (), fmtstr, dirlen,\n+\t\t\t    target_to_host (hostdir, sizeof hostdir, dir.beg),\n \t\t\t    fmtres.range.min, fmtres.range.max);\n \t}\n     }\n@@ -2847,7 +3009,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t\t directive &dir, format_result *res,\n \t\t const char *str, unsigned *argno)\n {\n-  const char *pcnt = strchr (str, '%');\n+  const char *pcnt = strchr (str, target_percent);\n   dir.beg = str;\n \n   if (size_t len = pcnt ? pcnt - str : *str ? strlen (str) : 1)\n@@ -2873,14 +3035,25 @@ parse_directive (pass_sprintf_length::call_info &info,\n   const char *pf = pcnt + 1;\n \n     /* POSIX numbered argument index or zero when none.  */\n-  unsigned dollar = 0;\n+  HOST_WIDE_INT dollar = 0;\n \n   /* With and precision.  -1 when not specified, HOST_WIDE_INT_MIN\n      when given by a va_list argument, and a non-negative value\n      when specified in the format string itself.  */\n   HOST_WIDE_INT width = -1;\n   HOST_WIDE_INT precision = -1;\n \n+  /* Pointers to the beginning of the width and precision decimal\n+     string (if any) within the directive.  */\n+  const char *pwidth = 0;\n+  const char *pprec = 0;\n+\n+  /* When the value of the decimal string that specifies width or\n+     precision is out of range, points to the digit that causes\n+     the value to exceed the limit.  */\n+  const char *werange = NULL;\n+  const char *perange = NULL;\n+\n   /* Width specified via the asterisk.  Need not be INTEGER_CST.\n      For vararg functions set to void_node.  */\n   tree star_width = NULL_TREE;\n@@ -2889,17 +3062,16 @@ parse_directive (pass_sprintf_length::call_info &info,\n      For vararg functions set to void_node.  */\n   tree star_precision = NULL_TREE;\n \n-  if (ISDIGIT (*pf))\n+  if (ISDIGIT (target_to_host (*pf)))\n     {\n       /* This could be either a POSIX positional argument, the '0'\n \t flag, or a width, depending on what follows.  Store it as\n \t width and sort it out later after the next character has\n \t been seen.  */\n-      char *end;\n-      width = strtol (pf, &end, 10);\n-      pf = end;\n+      pwidth = pf;\n+      width = target_strtol10 (&pf, &werange);\n     }\n-  else if ('*' == *pf)\n+  else if (target_to_host (*pf) == '*')\n     {\n       /* Similarly to the block above, this could be either a POSIX\n \t positional argument or a width, depending on what follows.  */\n@@ -2910,7 +3082,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n       ++pf;\n     }\n \n-  if (*pf == '$')\n+  if (target_to_host (*pf) == '$')\n     {\n       /* Handle the POSIX dollar sign which references the 1-based\n \t positional argument number.  */\n@@ -2925,7 +3097,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n       /* Bail when the numbered argument is out of range (it will\n \t have already been diagnosed by -Wformat).  */\n       if (dollar == 0\n-\t  || dollar == info.argidx\n+\t  || dollar == (int)info.argidx\n \t  || dollar > gimple_call_num_args (info.callstmt))\n \treturn false;\n \n@@ -2959,14 +3131,14 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t the next field is the optional flags followed by an optional\n \t width.  */\n       for ( ; ; ) {\n-\tswitch (*pf)\n+\tswitch (target_to_host (*pf))\n \t  {\n \t  case ' ':\n \t  case '0':\n \t  case '+':\n \t  case '-':\n \t  case '#':\n-\t    dir.set_flag (*pf++);\n+\t    dir.set_flag (target_to_host (*pf++));\n \t    break;\n \n \t  default:\n@@ -2975,13 +3147,13 @@ parse_directive (pass_sprintf_length::call_info &info,\n       }\n \n     start_width:\n-      if (ISDIGIT (*pf))\n+      if (ISDIGIT (target_to_host (*pf)))\n \t{\n-\t  char *end;\n-\t  width = strtol (pf, &end, 10);\n-\t  pf = end;\n+\t  werange = 0;\n+\t  pwidth = pf;\n+\t  width = target_strtol10 (&pf, &werange);\n \t}\n-      else if ('*' == *pf)\n+      else if (target_to_host (*pf) == '*')\n \t{\n \t  if (*argno < gimple_call_num_args (info.callstmt))\n \t    star_width = gimple_call_arg (info.callstmt, (*argno)++);\n@@ -2993,7 +3165,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t    }\n \t  ++pf;\n \t}\n-      else if ('\\'' == *pf)\n+      else if (target_to_host (*pf) == '\\'')\n \t{\n \t  /* The POSIX apostrophe indicating a numeric grouping\n \t     in the current locale.  Even though it's possible to\n@@ -3005,17 +3177,16 @@ parse_directive (pass_sprintf_length::call_info &info,\n     }\n \n  start_precision:\n-  if ('.' == *pf)\n+  if (target_to_host (*pf) == '.')\n     {\n       ++pf;\n \n-      if (ISDIGIT (*pf))\n+      if (ISDIGIT (target_to_host (*pf)))\n \t{\n-\t  char *end;\n-\t  precision = strtol (pf, &end, 10);\n-\t  pf = end;\n+\t  pprec = pf;\n+\t  precision = target_strtol10 (&pf, &perange);\n \t}\n-      else if ('*' == *pf)\n+      else if (target_to_host (*pf) == '*')\n \t{\n \t  if (*argno < gimple_call_num_args (info.callstmt))\n \t    star_precision = gimple_call_arg (info.callstmt, (*argno)++);\n@@ -3035,10 +3206,10 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t}\n     }\n \n-  switch (*pf)\n+  switch (target_to_host (*pf))\n     {\n     case 'h':\n-      if (pf[1] == 'h')\n+      if (target_to_host (pf[1]) == 'h')\n \t{\n \t  ++pf;\n \t  dir.modifier = FMT_LEN_hh;\n@@ -3059,7 +3230,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n       break;\n \n     case 'l':\n-      if (pf[1] == 'l')\n+      if (target_to_host (pf[1]) == 'l')\n \t{\n \t  ++pf;\n \t  dir.modifier = FMT_LEN_ll;\n@@ -3080,7 +3251,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n       break;\n     }\n \n-  switch (*pf)\n+  switch (target_to_host (*pf))\n     {\n       /* Handle a sole '%' character the same as \"%%\" but since it's\n \t undefined prevent the result from being folded.  */\n@@ -3141,7 +3312,14 @@ parse_directive (pass_sprintf_length::call_info &info,\n       return 0;\n     }\n \n-  dir.specifier = *pf++;\n+  dir.specifier = target_to_host (*pf++);\n+\n+  /* Store the length of the format directive.  */\n+  dir.len = pf - pcnt;\n+\n+  /* Buffer for the directive in the host character set (used when\n+     the source character set is different).  */\n+  char hostdir[32];\n \n   if (star_width)\n     {\n@@ -3156,7 +3334,25 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t}\n     }\n   else\n-    dir.set_width (width);\n+    {\n+      if (width == LONG_MAX && werange)\n+\t{\n+\t  size_t begin = dir.beg - info.fmtstr + (pwidth - pcnt);\n+\t  size_t caret = begin + (werange - pcnt);\n+\t  size_t end = pf - info.fmtstr - 1;\n+\n+\t  /* Create a location for the width part of the directive,\n+\t     pointing the caret at the first out-of-range digit.  */\n+\t  substring_loc dirloc (info.fmtloc, TREE_TYPE (info.format),\n+\t\t\t\tcaret, begin, end);\n+\n+\t  fmtwarn (dirloc, NULL, NULL,\n+\t\t   info.warnopt (), \"%<%.*s%> directive width out of range\",\n+\t\t   dir.len, target_to_host (hostdir, sizeof hostdir, dir.beg));\n+\t}\n+\n+      dir.set_width (width);\n+    }\n \n   if (star_precision)\n     {\n@@ -3171,7 +3367,26 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t}\n     }\n   else\n-    dir.set_precision (precision);\n+    {\n+      if (precision == LONG_MAX && perange)\n+\t{\n+\t  size_t begin = dir.beg - info.fmtstr + (pprec - pcnt) - 1;\n+\t  size_t caret = dir.beg - info.fmtstr + (perange - pcnt) - 1;\n+\t  size_t end = pf - info.fmtstr - 2;\n+\n+\t  /* Create a location for the precision part of the directive,\n+\t     including the leading period, pointing the caret at the first\n+\t     out-of-range digit .  */\n+\t  substring_loc dirloc (info.fmtloc, TREE_TYPE (info.format),\n+\t\t\t\tcaret, begin, end);\n+\n+\t  fmtwarn (dirloc, NULL, NULL,\n+\t\t   info.warnopt (), \"%<%.*s%> directive precision out of range\",\n+\t\t   dir.len, target_to_host (hostdir, sizeof hostdir, dir.beg));\n+\t}\n+\n+      dir.set_precision (precision);\n+    }\n \n   /* Extract the argument if the directive takes one and if it's\n      available (e.g., the function doesn't take a va_list).  Treat\n@@ -3181,9 +3396,6 @@ parse_directive (pass_sprintf_length::call_info &info,\n       && *argno < gimple_call_num_args (info.callstmt))\n     dir.arg = gimple_call_arg (info.callstmt, dollar ? dollar : (*argno)++);\n \n-  /* Return the length of the format directive.  */\n-  dir.len = pf - pcnt;\n-\n   if (dump_file)\n     {\n       fprintf (dump_file, \"  Directive %u at offset %llu: \\\"%.*s\\\"\",\n@@ -3708,6 +3920,8 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n unsigned int\n pass_sprintf_length::execute (function *fun)\n {\n+  init_target_to_host_charmap ();\n+\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {"}, {"sha": "3334d6d788889a15d99a8e13bac068f43de119a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d127ae9fbed54655d1b8366be1084f6a860794b2", "patch": "@@ -1,3 +1,8 @@\n+2017-04-28  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/80523\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-18.c: New test.\n+\n 2017-04-28  Tom de Vries  <tom@codesourcery.com>\n \n \tPR testsuite/80557"}, {"sha": "55c397457ff7403308719dce5b06c0b775bec35f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-18.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d127ae9fbed54655d1b8366be1084f6a860794b2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-18.c?ref=d127ae9fbed54655d1b8366be1084f6a860794b2", "patch": "@@ -0,0 +1,141 @@\n+/* PR tree-optimization/80523 - -Wformat-overflow doesn't consider\n+   -fexec-charset\n+   { dg-do compile }\n+   { dg-require-iconv \"IBM1047\" }\n+   { dg-options \"-O2 -Wall -Wno-format -Wformat-overflow -fexec-charset=IBM1047 -ftrack-macro-expansion=0\" } */\n+\n+char buf[1];\n+void sink (void*);\n+\n+#define T(...) (__builtin_sprintf (buf + 1, __VA_ARGS__), sink (buf))\n+\n+/* Exercise all special C and POSIX characters.  */\n+\n+void test_characters ()\n+{\n+  T (\"%%\");           /* { dg-warning \".%%. directive writing 1 byte\" } */\n+\n+  T (\"%A\",    0.0);   /* { dg-warning \".%A. directive writing between 6 and 20 \" } */\n+  T (\"%a\",    0.0);   /* { dg-warning \".%a. directive writing between 6 and 20 \" } */\n+\n+  T (\"%C\",    'a');   /* { dg-warning \".%C. directive writing 1 byte\" \"bug 80537\" { xfail *-*-* } } */\n+  T (\"%c\",    'a');   /* { dg-warning \".%c. directive writing 1 byte\" } */\n+\n+  T (\"%d\",     12);   /* { dg-warning \".%d. directive writing 2 bytes\" } */\n+  T (\"% d\",    12);   /* { dg-warning \".% d. directive writing 3 bytes\" } */\n+  T (\"%-d\",   123);   /* { dg-warning \".%-d. directive writing 3 bytes\" } */\n+  T (\"%+d\",  1234);   /* { dg-warning \".%\\\\+d. directive writing 5 bytes\" } */\n+  T (\"%'d\",  1234);   /* { dg-warning \".%'d. directive writing 5 bytes\" \"bug 80535\" { xfail *-*-* } } */\n+  T (\"%1$d\", 2345);   /* { dg-warning \".%1\\\\\\$d. directive writing 4 bytes\" } */\n+\n+  /* Verify that digits are correctly interpreted as width and precision.  */\n+  T (\"%0d\", 12345);   /* { dg-warning \".%0d. directive writing 5 bytes\" } */\n+  T (\"%1d\", 12345);   /* { dg-warning \".%1d. directive writing 5 bytes\" } */\n+  T (\"%2d\", 12345);   /* { dg-warning \".%2d. directive writing 5 bytes\" } */\n+  T (\"%3d\", 12345);   /* { dg-warning \".%3d. directive writing 5 bytes\" } */\n+  T (\"%4d\", 12345);   /* { dg-warning \".%4d. directive writing 5 bytes\" } */\n+  T (\"%5d\", 12345);   /* { dg-warning \".%5d. directive writing 5 bytes\" } */\n+  T (\"%6d\", 12345);   /* { dg-warning \".%6d. directive writing 6 bytes\" } */\n+  T (\"%7d\", 12345);   /* { dg-warning \".%7d. directive writing 7 bytes\" } */\n+  T (\"%8d\", 12345);   /* { dg-warning \".%8d. directive writing 8 bytes\" } */\n+  T (\"%9d\", 12345);   /* { dg-warning \".%9d. directive writing 9 bytes\" } */\n+\n+  T (\"%.0d\", 12345);  /* { dg-warning \".%.0d. directive writing 5 bytes\" } */\n+  T (\"%.1d\", 12345);  /* { dg-warning \".%.1d. directive writing 5 bytes\" } */\n+  T (\"%.2d\", 12345);  /* { dg-warning \".%.2d. directive writing 5 bytes\" } */\n+  T (\"%.3d\", 12345);  /* { dg-warning \".%.3d. directive writing 5 bytes\" } */\n+  T (\"%.4d\", 12345);  /* { dg-warning \".%.4d. directive writing 5 bytes\" } */\n+  T (\"%.5d\", 12345);  /* { dg-warning \".%.5d. directive writing 5 bytes\" } */\n+  T (\"%.6d\", 12345);  /* { dg-warning \".%.6d. directive writing 6 bytes\" } */\n+  T (\"%.7d\", 12345);  /* { dg-warning \".%.7d. directive writing 7 bytes\" } */\n+  T (\"%.8d\", 12345);  /* { dg-warning \".%.8d. directive writing 8 bytes\" } */\n+  T (\"%.9d\", 12345);  /* { dg-warning \".%.9d. directive writing 9 bytes\" } */\n+\n+  T (\"%hhd\",    12);   /* { dg-warning \".%hhd. directive writing 2 bytes\" } */\n+  T (\"%hd\",    234);   /* { dg-warning \".%hd. directive writing 3 bytes\" } */\n+\n+  {\n+    const __PTRDIFF_TYPE__ i = 3456;\n+    T (\"%jd\",   i);  /* { dg-warning \".%jd. directive writing 4 bytes\" } */\n+  }\n+\n+  T (\"%ld\",  45678L);  /* { dg-warning \".%ld. directive writing 5 bytes\" } */\n+\n+  {\n+    const __PTRDIFF_TYPE__ i = 56789;\n+    T (\"%td\",   i);  /* { dg-warning \".%td. directive writing 5 bytes\" } */\n+  }\n+\n+  {\n+    const __SIZE_TYPE__ i = 67890;\n+    T (\"%zd\",   i);  /* { dg-warning \".%zd. directive writing 5 bytes\" } */\n+  }\n+\n+  T (\"%E\",    0.0);   /* { dg-warning \".%E. directive writing 12 bytes\" } */\n+  T (\"%e\",    0.0);   /* { dg-warning \".%e. directive writing 12 bytes\" } */\n+  T (\"%F\",    0.0);   /* { dg-warning \".%F. directive writing 8 bytes\" } */\n+  T (\"%f\",    0.0);   /* { dg-warning \".%f. directive writing 8 bytes\" } */\n+  T (\"%G\",    0.0);   /* { dg-warning \".%G. directive writing 1 byte\" } */\n+  T (\"%g\",    0.0);   /* { dg-warning \".%g. directive writing 1 byte\" } */\n+\n+  T (\"%i\",     123);  /* { dg-warning \".%i. directive writing 3 bytes\" } */\n+\n+  {\n+    int n;\n+\n+    T (\"%n\",    &n);  /* { dg-warning \"writing a terminating nul\" } */\n+    T (\"%nH\",   &n);  /* { dg-warning \".H. directive writing 1 byte\" } */\n+  }\n+\n+  T (\"%o\",     999);  /* { dg-warning \".%o. directive writing 4 bytes\" } */\n+  T (\"%#o\",    999);  /* { dg-warning \".%#o. directive writing 5 bytes\" } */\n+\n+  T (\"%x\",    1234);  /* { dg-warning \".%x. directive writing 3 bytes\" } */\n+  T (\"%#X\",   1235);  /* { dg-warning \".%#X. directive writing 5 bytes\" } */\n+\n+  T (\"%S\",    L\"1\");  /* { dg-warning \".%S. directive writing 1 byte\" } */\n+  T (\"%-s\",    \"1\");  /* { dg-warning \".%-s. directive writing 1 byte\" } */\n+\n+  /* Verify that characters in the source character set appear in\n+     the text of the warning unchanged (i.e., not as their equivalents\n+     in the execution character set on the target).  The trailing %%\n+     disables sprintf->strcpy optimization.  */\n+  T (\"ABCDEFGHIJ%%\");   /* { dg-warning \".ABCDEFGHIJ. directive writing 10 bytes\" } */\n+  T (\"KLMNOPQRST%%\");   /* { dg-warning \".KLMNOPQRST. directive writing 10 bytes\" } */\n+  T (\"UVWXYZ%%\");       /* { dg-warning \".UVWXYZ. directive writing 6 bytes\" } */\n+\n+  T (\"abcdefghij%%\");   /* { dg-warning \".abcdefghij. directive writing 10 bytes\" } */\n+  T (\"klmnopqrst%%\");   /* { dg-warning \".klmnopqrst. directive writing 10 bytes\" } */\n+  T (\"uvwxyz%%\");       /* { dg-warning \".uvwxyz. directive writing 6 bytes\" } */\n+}\n+\n+#undef T\n+#define T(...) (__builtin_sprintf (d, __VA_ARGS__), sink (d))\n+\n+void test_width_and_precision_out_of_range (char *d)\n+{\n+#if __LONG_MAX__ == 2147483647\n+#  define   MAX_P1_STR \"2147483648\"\n+#elif __LONG_MAX__ == 9223372036854775807\n+#  define MAX_P1_STR \"9223372036854775808\"\n+#endif\n+\n+  T (\"%\" MAX_P1_STR \"i\", 0);    /* { dg-warning \"width out of range\" } */\n+  /* { dg-warning \"result to exceed .INT_MAX. \" \"\" { target *-*-* } .-1 } */\n+  T (\"%.\" MAX_P1_STR \"i\", 0);   /* { dg-warning \"precision out of range\" } */\n+\n+  /* The following is diagnosed by -Wformat (disabled here).  */\n+  /* T (\"%\" MAX_P1_STR \"$i\", 0); */\n+}\n+\n+/* Verify that an excessively long directive is truncated and the truncation\n+   is indicated by three trailing dots in the text of the warning.  */\n+\n+void test_overlong_plain_string ()\n+{\n+  static const char longfmtstr[] =\n+    \"0123456789012345678901234567890123456789012345678901234567890123456789%%\";\n+\n+  char d[1];\n+  T (longfmtstr);   /* { dg-warning \".0123\\[0-9\\]\\*\\.\\.\\.. directive writing 70 bytes\" } */\n+}"}]}