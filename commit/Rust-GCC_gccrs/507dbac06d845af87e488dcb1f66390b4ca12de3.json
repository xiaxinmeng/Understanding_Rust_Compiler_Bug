{"sha": "507dbac06d845af87e488dcb1f66390b4ca12de3", "node_id": "C_kwDOANBUbNoAKDUwN2RiYWMwNmQ4NDVhZjg3ZTQ4OGRjYjFmNjYzOTBiNGNhMTJkZTM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-05T18:31:03Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-01-06T10:48:10Z"}, "message": "Add overflow checking on LiteralExpression\n\nThis checks that the literal value is within the bounds of their respective\ntypes. I have ommited code fixing the other issue in the bug report that\noverflow/max_val integers should be saturated to infinity when cast to\nREAL_TYPE's this seems like something we really should have documentation\nto reference in the code as to why this is the correct Rust behaviour.\n\nAddresses #635", "tree": {"sha": "98ee1dbd06ff29564271a18929ed092f9e158875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98ee1dbd06ff29564271a18929ed092f9e158875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/507dbac06d845af87e488dcb1f66390b4ca12de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507dbac06d845af87e488dcb1f66390b4ca12de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/507dbac06d845af87e488dcb1f66390b4ca12de3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/507dbac06d845af87e488dcb1f66390b4ca12de3/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69f6be3ee483c9895b4b5187a44b3e1c8be2ba63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f6be3ee483c9895b4b5187a44b3e1c8be2ba63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f6be3ee483c9895b4b5187a44b3e1c8be2ba63"}], "stats": {"total": 406, "additions": 278, "deletions": 128}, "files": [{"sha": "0307b2145ae61a2b6f8fc5abc8f3cb07b9d78027", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -27,6 +27,8 @@\n #include \"rust-compile-pattern.h\"\n \n #include \"fold-const.h\"\n+#include \"realmpfr.h\"\n+#include \"convert.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -893,5 +895,210 @@ CompileExpr::resolve_operator_overload (\n \t\t\t\t\t       nullptr, expr.get_locus ());\n }\n \n+tree\n+CompileExpr::compile_bool_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t   const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::BOOL);\n+\n+  const auto literal_value = expr.get_literal ();\n+  bool bval = literal_value.as_string ().compare (\"true\") == 0;\n+  return ctx->get_backend ()->boolean_constant_expression (bval);\n+}\n+\n+tree\n+CompileExpr::compile_integer_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t      const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::INT);\n+  const auto literal_value = expr.get_literal ();\n+\n+  tree type = TyTyResolveCompile::compile (ctx, tyty);\n+  rust_assert (TREE_CODE (type) == INTEGER_TYPE);\n+\n+  mpz_t ival;\n+  if (mpz_init_set_str (ival, literal_value.as_string ().c_str (), 10) != 0)\n+    {\n+      rust_error_at (expr.get_locus (), \"bad number in literal\");\n+      return error_mark_node;\n+    }\n+\n+  mpz_t type_min;\n+  mpz_t type_max;\n+  mpz_init (type_min);\n+  mpz_init (type_max);\n+  get_type_static_bounds (type, type_min, type_max);\n+\n+  if (mpz_cmp (ival, type_min) < 0 || mpz_cmp (ival, type_max) > 0)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"integer overflows the respective type %<%s%>\",\n+\t\t     tyty->get_name ().c_str ());\n+      return error_mark_node;\n+    }\n+  return double_int_to_tree (type, mpz_get_double_int (type, ival, true));\n+}\n+\n+tree\n+CompileExpr::compile_float_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t    const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::FLOAT);\n+  const auto literal_value = expr.get_literal ();\n+\n+  mpfr_t fval;\n+  if (mpfr_init_set_str (fval, literal_value.as_string ().c_str (), 10,\n+\t\t\t MPFR_RNDN)\n+      != 0)\n+    {\n+      rust_error_at (expr.get_locus (), \"bad number in literal\");\n+      return error_mark_node;\n+    }\n+\n+  tree type = TyTyResolveCompile::compile (ctx, tyty);\n+\n+  // taken from:\n+  // see go/gofrontend/expressions.cc:check_float_type\n+  mpfr_exp_t exp = mpfr_get_exp (fval);\n+  bool real_value_overflow = exp > TYPE_PRECISION (type);\n+\n+  REAL_VALUE_TYPE r1;\n+  real_from_mpfr (&r1, fval, type, GMP_RNDN);\n+  REAL_VALUE_TYPE r2;\n+  real_convert (&r2, TYPE_MODE (type), &r1);\n+\n+  tree real_value = build_real (type, r2);\n+  if (TREE_OVERFLOW (real_value) || real_value_overflow)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"decimal overflows the respective type %<%s%>\",\n+\t\t     tyty->get_name ().c_str ());\n+      return error_mark_node;\n+    }\n+\n+  return real_value;\n+}\n+\n+tree\n+CompileExpr::compile_char_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t   const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::CHAR);\n+  const auto literal_value = expr.get_literal ();\n+\n+  // FIXME needs wchar_t\n+  char c = literal_value.as_string ().c_str ()[0];\n+  return ctx->get_backend ()->wchar_constant_expression (c);\n+}\n+\n+tree\n+CompileExpr::compile_byte_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t   const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::BYTE);\n+  const auto literal_value = expr.get_literal ();\n+\n+  tree type = TyTyResolveCompile::compile (ctx, tyty);\n+  char c = literal_value.as_string ().c_str ()[0];\n+  return build_int_cst (type, c);\n+}\n+\n+tree\n+CompileExpr::compile_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t     const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::STRING);\n+  const auto literal_value = expr.get_literal ();\n+\n+  auto base = ctx->get_backend ()->string_constant_expression (\n+    literal_value.as_string ());\n+  return ctx->get_backend ()->address_expression (base, expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::compile_byte_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t\t  const TyTy::BaseType *tyty)\n+{\n+  rust_assert (expr.get_lit_type () == HIR::Literal::BYTE_STRING);\n+\n+  // the type here is &[ty; capacity]\n+  rust_assert (tyty->get_kind () == TyTy::TypeKind::REF);\n+  const auto ref_tyty = static_cast<const TyTy::ReferenceType *> (tyty);\n+  auto base_tyty = ref_tyty->get_base ();\n+  rust_assert (base_tyty->get_kind () == TyTy::TypeKind::ARRAY);\n+  auto array_tyty = static_cast<TyTy::ArrayType *> (base_tyty);\n+\n+  std::string value_str = expr.get_literal ().as_string ();\n+  std::vector<tree> vals;\n+  std::vector<unsigned long> indexes;\n+  for (size_t i = 0; i < value_str.size (); i++)\n+    {\n+      char b = value_str.at (i);\n+      tree bb = ctx->get_backend ()->char_constant_expression (b);\n+      vals.push_back (bb);\n+      indexes.push_back (i);\n+    }\n+\n+  tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+  tree constructed\n+    = ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n+\t\t\t\t\t\t\t vals,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+\n+  return ctx->get_backend ()->address_expression (constructed,\n+\t\t\t\t\t\t  expr.get_locus ());\n+}\n+\n+tree\n+CompileExpr::type_cast_expression (tree type_to_cast_to, tree expr_tree,\n+\t\t\t\t   Location location)\n+{\n+  if (type_to_cast_to == error_mark_node || expr_tree == error_mark_node\n+      || TREE_TYPE (expr_tree) == error_mark_node)\n+    return error_mark_node;\n+\n+  if (ctx->get_backend ()->type_size (type_to_cast_to) == 0\n+      || TREE_TYPE (expr_tree) == void_type_node)\n+    {\n+      // Do not convert zero-sized types.\n+      return expr_tree;\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == INTEGER_TYPE)\n+    {\n+      tree cast = fold (convert_to_integer (type_to_cast_to, expr_tree));\n+      // FIXME check for TREE_OVERFLOW?\n+      return cast;\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == REAL_TYPE)\n+    {\n+      tree cast = fold (convert_to_real (type_to_cast_to, expr_tree));\n+      // FIXME\n+      // We might need to check that the tree is MAX val and thusly saturate it\n+      // to inf. we can get the bounds and check the value if its >= or <= to\n+      // the min and max bounds\n+      //\n+      // https://github.com/Rust-GCC/gccrs/issues/635\n+      return cast;\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == COMPLEX_TYPE)\n+    {\n+      return fold (convert_to_complex (type_to_cast_to, expr_tree));\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (expr_tree)) == INTEGER_TYPE)\n+    {\n+      return fold (convert_to_pointer (type_to_cast_to, expr_tree));\n+    }\n+  else if (TREE_CODE (type_to_cast_to) == RECORD_TYPE\n+\t   || TREE_CODE (type_to_cast_to) == ARRAY_TYPE)\n+    {\n+      return fold_build1_loc (location.gcc_location (), VIEW_CONVERT_EXPR,\n+\t\t\t      type_to_cast_to, expr_tree);\n+    }\n+\n+  return fold_convert_loc (location.gcc_location (), type_to_cast_to,\n+\t\t\t   expr_tree);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "2f4462176839c1d804c06df1355a0e8f025b4fa5", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 49, "deletions": 117, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -234,132 +234,41 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::LiteralExpr &expr) override\n   {\n-    auto literal_value = expr.get_literal ();\n+    TyTy::BaseType *tyty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &tyty))\n+      return;\n+\n     switch (expr.get_lit_type ())\n       {\n-\tcase HIR::Literal::BOOL: {\n-\t  bool bval = literal_value->as_string ().compare (\"true\") == 0;\n-\t  translated = ctx->get_backend ()->boolean_constant_expression (bval);\n-\t}\n+      case HIR::Literal::BOOL:\n+\ttranslated = compile_bool_literal (expr, tyty);\n \treturn;\n \n-\tcase HIR::Literal::INT: {\n-\t  mpz_t ival;\n-\t  if (mpz_init_set_str (ival, literal_value->as_string ().c_str (), 10)\n-\t      != 0)\n-\t    {\n-\t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n-\t      return;\n-\t    }\n-\n-\t  TyTy::BaseType *tyty = nullptr;\n-\t  if (!ctx->get_tyctx ()->lookup_type (\n-\t\texpr.get_mappings ().get_hirid (), &tyty))\n-\t    {\n-\t      rust_fatal_error (\n-\t\texpr.get_locus (),\n-\t\t\"did not resolve type for this literal expr (HirId %d)\",\n-\t\texpr.get_mappings ().get_hirid ());\n-\t      return;\n-\t    }\n-\n-\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n-\t  translated\n-\t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n-\t}\n+      case HIR::Literal::INT:\n+\ttranslated = compile_integer_literal (expr, tyty);\n \treturn;\n \n-\tcase HIR::Literal::FLOAT: {\n-\t  mpfr_t fval;\n-\t  if (mpfr_init_set_str (fval, literal_value->as_string ().c_str (), 10,\n-\t\t\t\t MPFR_RNDN)\n-\t      != 0)\n-\t    {\n-\t      rust_fatal_error (expr.get_locus (),\n-\t\t\t\t\"bad floating-point number in literal\");\n-\t      return;\n-\t    }\n-\n-\t  TyTy::BaseType *tyty = nullptr;\n-\t  if (!ctx->get_tyctx ()->lookup_type (\n-\t\texpr.get_mappings ().get_hirid (), &tyty))\n-\t    {\n-\t      rust_fatal_error (expr.get_locus (),\n-\t\t\t\t\"did not resolve type for this literal expr\");\n-\t      return;\n-\t    }\n-\n-\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n-\t  translated\n-\t    = ctx->get_backend ()->float_constant_expression (type, fval);\n-\t}\n+      case HIR::Literal::FLOAT:\n+\ttranslated = compile_float_literal (expr, tyty);\n \treturn;\n \n-\tcase HIR::Literal::CHAR: {\n-\t  // FIXME needs wchar_t\n-\t  char c = literal_value->as_string ().c_str ()[0];\n-\t  translated = ctx->get_backend ()->wchar_constant_expression (c);\n-\t}\n+      case HIR::Literal::CHAR:\n+\ttranslated = compile_char_literal (expr, tyty);\n \treturn;\n \n-\tcase HIR::Literal::BYTE: {\n-\t  char c = literal_value->as_string ().c_str ()[0];\n-\t  translated = ctx->get_backend ()->char_constant_expression (c);\n-\t}\n+      case HIR::Literal::BYTE:\n+\ttranslated = compile_byte_literal (expr, tyty);\n \treturn;\n \n-\tcase HIR::Literal::STRING: {\n-\t  auto base = ctx->get_backend ()->string_constant_expression (\n-\t    literal_value->as_string ());\n-\t  translated\n-\t    = ctx->get_backend ()->address_expression (base, expr.get_locus ());\n-\t}\n+      case HIR::Literal::STRING:\n+\ttranslated = compile_string_literal (expr, tyty);\n \treturn;\n \n-\tcase HIR::Literal::BYTE_STRING: {\n-\t  TyTy::BaseType *tyty = nullptr;\n-\t  if (!ctx->get_tyctx ()->lookup_type (\n-\t\texpr.get_mappings ().get_hirid (), &tyty))\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"did not resolve type for this byte string\");\n-\t      return;\n-\t    }\n-\n-\t  // the type here is &[ty; capacity]\n-\t  rust_assert (tyty->get_kind () == TyTy::TypeKind::REF);\n-\t  auto ref_tyty = static_cast<TyTy::ReferenceType *> (tyty);\n-\t  auto base_tyty = ref_tyty->get_base ();\n-\t  rust_assert (base_tyty->get_kind () == TyTy::TypeKind::ARRAY);\n-\t  auto array_tyty = static_cast<TyTy::ArrayType *> (base_tyty);\n-\n-\t  std::string value_str = expr.get_literal ()->as_string ();\n-\t  std::vector<tree> vals;\n-\t  std::vector<unsigned long> indexes;\n-\t  for (size_t i = 0; i < value_str.size (); i++)\n-\t    {\n-\t      char b = value_str.at (i);\n-\t      tree bb = ctx->get_backend ()->char_constant_expression (b);\n-\t      vals.push_back (bb);\n-\t      indexes.push_back (i);\n-\t    }\n-\n-\t  tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n-\t  tree constructed = ctx->get_backend ()->array_constructor_expression (\n-\t    array_type, indexes, vals, expr.get_locus ());\n-\n-\t  translated\n-\t    = ctx->get_backend ()->address_expression (constructed,\n-\t\t\t\t\t\t       expr.get_locus ());\n-\t}\n-\treturn;\n-\n-      default:\n-\trust_fatal_error (expr.get_locus (), \"unknown literal\");\n+      case HIR::Literal::BYTE_STRING:\n+\ttranslated = compile_byte_string_literal (expr, tyty);\n \treturn;\n       }\n-\n-    gcc_unreachable ();\n   }\n \n   void visit (HIR::AssignmentExpr &expr) override\n@@ -502,20 +411,19 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::TypeCastExpr &expr) override\n   {\n-    TyTy::BaseType *tyty_to_cast_to = nullptr;\n+    TyTy::BaseType *tyty = nullptr;\n     if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t &tyty_to_cast_to))\n+\t\t\t\t\t &tyty))\n       {\n-\ttranslated = ctx->get_backend ()->error_expression ();\n+\ttranslated = error_mark_node;\n \treturn;\n       }\n \n-    auto type_to_cast_to = TyTyResolveCompile::compile (ctx, tyty_to_cast_to);\n+    auto type_to_cast_to = TyTyResolveCompile::compile (ctx, tyty);\n     auto casted_expr\n       = CompileExpr::Compile (expr.get_casted_expr ().get (), ctx);\n     translated\n-      = ctx->get_backend ()->convert_expression (type_to_cast_to, casted_expr,\n-\t\t\t\t\t\t expr.get_locus ());\n+      = type_cast_expression (type_to_cast_to, casted_expr, expr.get_locus ());\n   }\n \n   void visit (HIR::IfExpr &expr) override\n@@ -1067,9 +975,33 @@ class CompileExpr : public HIRCompileBase\n \t\t\t     HIR::OperatorExpr &expr, tree lhs, tree rhs,\n \t\t\t     HIR::Expr *lhs_expr, HIR::Expr *rhs_expr);\n \n+  tree compile_bool_literal (const HIR::LiteralExpr &expr,\n+\t\t\t     const TyTy::BaseType *tyty);\n+\n+  tree compile_integer_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\tconst TyTy::BaseType *tyty);\n+\n+  tree compile_float_literal (const HIR::LiteralExpr &expr,\n+\t\t\t      const TyTy::BaseType *tyty);\n+\n+  tree compile_char_literal (const HIR::LiteralExpr &expr,\n+\t\t\t     const TyTy::BaseType *tyty);\n+\n+  tree compile_byte_literal (const HIR::LiteralExpr &expr,\n+\t\t\t     const TyTy::BaseType *tyty);\n+\n+  tree compile_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t       const TyTy::BaseType *tyty);\n+\n+  tree compile_byte_string_literal (const HIR::LiteralExpr &expr,\n+\t\t\t\t    const TyTy::BaseType *tyty);\n+\n+  tree type_cast_expression (tree type_to_cast_to, tree expr, Location locus);\n+\n private:\n   CompileExpr (Context *ctx)\n-    : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)\n+    : HIRCompileBase (ctx), translated (error_mark_node),\n+      capacity_expr (nullptr)\n   {}\n \n   tree translated;"}, {"sha": "c1495d4a501219994e77fc4f230f862172fda9e8", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -95,7 +95,8 @@ class LiteralExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRFullVisitor &vis) override;\n \n-  Literal *get_literal () { return &literal; }\n+  Literal &get_literal () { return literal; }\n+  const Literal &get_literal () const { return literal; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather"}, {"sha": "190781658624edb40832315861764e36b7b3571b", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -354,7 +354,7 @@ class ConstFoldExpr : public ConstFoldBase\n       {\n \tcase HIR::Literal::INT: {\n \t  mpz_t ival;\n-\t  if (mpz_init_set_str (ival, literal_value->as_string ().c_str (), 10)\n+\t  if (mpz_init_set_str (ival, literal_value.as_string ().c_str (), 10)\n \t      != 0)\n \t    {\n \t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n@@ -376,14 +376,14 @@ class ConstFoldExpr : public ConstFoldBase\n \treturn;\n \n \tcase HIR::Literal::BOOL: {\n-\t  bool bval = literal_value->as_string ().compare (\"true\") == 0;\n+\t  bool bval = literal_value.as_string ().compare (\"true\") == 0;\n \t  folded = ctx->get_backend ()->boolean_constant_expression (bval);\n \t}\n \treturn;\n \n \tcase HIR::Literal::FLOAT: {\n \t  mpfr_t fval;\n-\t  if (mpfr_init_set_str (fval, literal_value->as_string ().c_str (), 10,\n+\t  if (mpfr_init_set_str (fval, literal_value.as_string ().c_str (), 10,\n \t\t\t\t MPFR_RNDN)\n \t      != 0)\n \t    {"}, {"sha": "cb3aa6a5237b1dcf50ec9f28880ef94beb054454", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -604,7 +604,7 @@ class TypeCheckExpr : public TypeCheckBase\n \tcase HIR::Literal::LitType::INT: {\n \t  bool ok = false;\n \n-\t  switch (expr.get_literal ()->get_type_hint ())\n+\t  switch (expr.get_literal ().get_type_hint ())\n \t    {\n \t    case CORETYPE_I8:\n \t      ok = context->lookup_builtin (\"i8\", &infered);\n@@ -639,11 +639,11 @@ class TypeCheckExpr : public TypeCheckBase\n \t      break;\n \n \t    case CORETYPE_F32:\n-\t      expr.get_literal ()->set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t      expr.get_literal ().set_lit_type (HIR::Literal::LitType::FLOAT);\n \t      ok = context->lookup_builtin (\"f32\", &infered);\n \t      break;\n \t    case CORETYPE_F64:\n-\t      expr.get_literal ()->set_lit_type (HIR::Literal::LitType::FLOAT);\n+\t      expr.get_literal ().set_lit_type (HIR::Literal::LitType::FLOAT);\n \t      ok = context->lookup_builtin (\"f64\", &infered);\n \t      break;\n \n@@ -661,7 +661,7 @@ class TypeCheckExpr : public TypeCheckBase\n \tcase HIR::Literal::LitType::FLOAT: {\n \t  bool ok = false;\n \n-\t  switch (expr.get_literal ()->get_type_hint ())\n+\t  switch (expr.get_literal ().get_type_hint ())\n \t    {\n \t    case CORETYPE_F32:\n \t      ok = context->lookup_builtin (\"f32\", &infered);\n@@ -727,7 +727,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t  /* Capacity is the size of the string (number of chars).\n \t     It is a constant, but for fold it to get a tree.  */\n \t  std::string capacity_str\n-\t    = std::to_string (expr.get_literal ()->as_string ().size ());\n+\t    = std::to_string (expr.get_literal ().as_string ().size ());\n \t  HIR::LiteralExpr literal_capacity (capacity_mapping, capacity_str,\n \t\t\t\t\t     HIR::Literal::LitType::INT,\n \t\t\t\t\t     PrimitiveCoreType::CORETYPE_USIZE,"}, {"sha": "33a4b11539f4edce0b874813f36ca69aef6772e3", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -141,7 +141,7 @@ class TypeResolverDump : public TypeCheckBase\n \n   void visit (HIR::LiteralExpr &expr) override\n   {\n-    dump += expr.get_literal ()->as_string () + \":\"\n+    dump += expr.get_literal ().as_string () + \":\"\n \t    + type_string (expr.get_mappings ());\n   }\n "}, {"sha": "07fedd0f878e2beb02049f1a828c276622ec9ee8", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -444,7 +444,7 @@ class InferCastRules : public BaseCastRules\n   void visit (FloatType &type) override\n   {\n     bool is_valid\n-      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::INTEGRAL)\n \t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n     if (is_valid)\n       {"}, {"sha": "dc6a4c2eece748ad48d7a94175dad3f6a2a1ead0", "filename": "gcc/testsuite/rust/compile/issue-635-1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-635-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-635-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-635-1.rs?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -0,0 +1,5 @@\n+// { dg-additional-options \"-w\" }\n+fn test() -> i32 {\n+    return 10000000000000000000000000000000000000000000;\n+    // { dg-error \"integer overflows the respective type .i32.\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "335218aa52c3b205e80e6eac7b7c0ac92e8ace06", "filename": "gcc/testsuite/rust/compile/issue-635-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-635-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/507dbac06d845af87e488dcb1f66390b4ca12de3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-635-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-635-2.rs?ref=507dbac06d845af87e488dcb1f66390b4ca12de3", "patch": "@@ -0,0 +1,5 @@\n+// { dg-additional-options \"-w\" }\n+fn test() -> f32 {\n+    return 10000000000000000000000000000000000000000000.0f32;\n+    // { dg-error \"decimal overflows the respective type .f32.\" \"\" { target *-*-* } .-1 }\n+}"}]}