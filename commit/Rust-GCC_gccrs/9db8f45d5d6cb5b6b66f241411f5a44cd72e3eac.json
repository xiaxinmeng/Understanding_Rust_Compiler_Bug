{"sha": "9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiOGY0NWQ1ZDZjYjViNmI2NmYyNDE0MTFmNWE0NGNkNzJlM2VhYw==", "commit": {"author": {"name": "Dmitry Plotnikov", "email": "dplotnikov@ispras.ru", "date": "2011-10-30T17:12:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-30T17:12:02Z"}, "message": "tree-cfg.c (verify_gimple_assign_unary): Allow vector conversions.\n\n2011-10-30  Dmitry Plotnikov  <dplotnikov@ispras.ru>\n\n        * tree-cfg.c (verify_gimple_assign_unary): Allow vector conversions.\n        * optabs.c (supportable_convert_operation): New function.\n        * optabs.h (supportable_convert_operation): New prototype.\n        * tree-vect-stmts.c (vectorizable_conversion): Change condition and\n        behavior for NONE modifier case.\n        * tree.h (VECTOR_INTEGER_TYPE_P): New macro.\n\nFrom-SVN: r180684", "tree": {"sha": "e44c3a45aa245b7294a083e14b64e2518eec620f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e44c3a45aa245b7294a083e14b64e2518eec620f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/comments", "author": null, "committer": null, "parents": [{"sha": "9814fdd6183efaa572a8cbd2a52e2abf30542413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9814fdd6183efaa572a8cbd2a52e2abf30542413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9814fdd6183efaa572a8cbd2a52e2abf30542413"}], "stats": {"total": 121, "additions": 104, "deletions": 17}, "files": [{"sha": "155625c9da2671e5c2d6791e0a3d17bf4da91495", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "patch": "@@ -1,3 +1,12 @@\n+2011-10-30  Dmitry Plotnikov  <dplotnikov@ispras.ru>\n+\n+\t* tree-cfg.c (verify_gimple_assign_unary): Allow vector conversions.\n+\t* optabs.c (supportable_convert_operation): New function.\n+\t* optabs.h (supportable_convert_operation): New prototype.\n+\t* tree-vect-stmts.c (vectorizable_conversion): Change condition and\n+\tbehavior for NONE modifier case.\n+\t* tree.h (VECTOR_INTEGER_TYPE_P): New macro.\n+\n 2011-10-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-vectorizer.h (NUM_PATTERNS): Bump to 9."}, {"sha": "f07381cf836d97e9a0c33e3b96b73d3a780eea46", "filename": "gcc/optabs.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "patch": "@@ -4824,6 +4824,60 @@ can_float_p (enum machine_mode fltmode, enum machine_mode fixmode,\n   tab = unsignedp ? ufloat_optab : sfloat_optab;\n   return convert_optab_handler (tab, fltmode, fixmode);\n }\n+\n+/* Function supportable_convert_operation\n+\n+   Check whether an operation represented by the code CODE is a\n+   convert operation that is supported by the target platform in\n+   vector form (i.e., when operating on arguments of type VECTYPE_IN\n+   producing a result of type VECTYPE_OUT).\n+   \n+   Convert operations we currently support directly are FIX_TRUNC and FLOAT.\n+   This function checks if these operations are supported\n+   by the target platform either directly (via vector tree-codes), or via\n+   target builtins.\n+   \n+   Output:\n+   - CODE1 is code of vector operation to be used when\n+   vectorizing the operation, if available.\n+   - DECL is decl of target builtin functions to be used\n+   when vectorizing the operation, if available.  In this case,\n+   CODE1 is CALL_EXPR.  */\n+\n+bool\n+supportable_convert_operation (enum tree_code code,\n+                                    tree vectype_out, tree vectype_in,\n+                                    tree *decl, enum tree_code *code1)\n+{\n+  enum machine_mode m1,m2;\n+  int truncp;\n+\n+  m1 = TYPE_MODE (vectype_out);\n+  m2 = TYPE_MODE (vectype_in);\n+\n+  /* First check if we can done conversion directly.  */\n+  if ((code == FIX_TRUNC_EXPR \n+       && can_fix_p (m1,m2,TYPE_UNSIGNED (vectype_out), &truncp) \n+          != CODE_FOR_nothing)\n+      || (code == FLOAT_EXPR\n+          && can_float_p (m1,m2,TYPE_UNSIGNED (vectype_in))\n+\t     != CODE_FOR_nothing))\n+    {\n+      *code1 = code;\n+      return true;\n+    }\n+\n+  /* Now check for builtin.  */\n+  if (targetm.vectorize.builtin_conversion\n+      && targetm.vectorize.builtin_conversion (code, vectype_out, vectype_in))\n+    {\n+      *code1 = CALL_EXPR;\n+      *decl = targetm.vectorize.builtin_conversion (code, vectype_out, vectype_in);\n+      return true;\n+    }\n+  return false;\n+}\n+\n \f\n /* Generate code to convert FROM to floating point\n    and store in TO.  FROM must be fixed point and not VOIDmode."}, {"sha": "8357a2986185b07f3ed3e6e1ed07bc7388d55003", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "patch": "@@ -883,6 +883,12 @@ extern void expand_float (rtx, rtx, int);\n /* Return the insn_code for a FLOAT_EXPR.  */\n enum insn_code can_float_p (enum machine_mode, enum machine_mode, int);\n \n+/* Check whether an operation represented by the code CODE is a\n+   convert operation that is supported by the target platform in\n+   vector form */\n+bool supportable_convert_operation (enum tree_code, tree, tree, tree *, \n+                                    enum tree_code *);\n+\n /* Generate code for a FIX_EXPR.  */\n extern void expand_fix (rtx, rtx, int);\n "}, {"sha": "2819e7b2fc6ecbb45040d2a8d079cf43ec63dd81", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "patch": "@@ -3342,7 +3342,9 @@ verify_gimple_assign_unary (gimple stmt)\n \n     case FLOAT_EXPR:\n       {\n-\tif (!INTEGRAL_TYPE_P (rhs1_type) || !SCALAR_FLOAT_TYPE_P (lhs_type))\n+\tif ((!INTEGRAL_TYPE_P (rhs1_type) || !SCALAR_FLOAT_TYPE_P (lhs_type))\n+\t    && (!VECTOR_INTEGER_TYPE_P (rhs1_type)\n+\t        || !VECTOR_FLOAT_TYPE_P(lhs_type)))\n \t  {\n \t    error (\"invalid types in conversion to floating point\");\n \t    debug_generic_expr (lhs_type);\n@@ -3355,7 +3357,9 @@ verify_gimple_assign_unary (gimple stmt)\n \n     case FIX_TRUNC_EXPR:\n       {\n-\tif (!INTEGRAL_TYPE_P (lhs_type) || !SCALAR_FLOAT_TYPE_P (rhs1_type))\n+        if ((!INTEGRAL_TYPE_P (lhs_type) || !SCALAR_FLOAT_TYPE_P (rhs1_type))\n+            && (!VECTOR_INTEGER_TYPE_P (lhs_type)\n+                || !VECTOR_FLOAT_TYPE_P(rhs1_type)))\n \t  {\n \t    error (\"invalid types in conversion to integer\");\n \t    debug_generic_expr (lhs_type);"}, {"sha": "08abd23c0a113f7541eecb8c4ebc915a42503761", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "patch": "@@ -1824,7 +1824,6 @@ vect_gen_widened_results_half (enum tree_code code,\n   return new_stmt;\n }\n \n-\n /* Check if STMT performs a conversion operation, that can be vectorized.\n    If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n    stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n@@ -1853,7 +1852,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vectype_out, vectype_in;\n   int ncopies, j;\n   tree rhs_type;\n-  tree builtin_decl;\n   enum { NARROW, NONE, WIDEN } modifier;\n   int i;\n   VEC(tree,heap) *vec_oprnds0 = NULL;\n@@ -1942,7 +1940,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /* Supportable by target?  */\n   if ((modifier == NONE\n-       && !targetm.vectorize.builtin_conversion (code, vectype_out, vectype_in))\n+       && !supportable_convert_operation (code, vectype_out, vectype_in, &decl1, &code1))\n       || (modifier == WIDEN\n \t  && !supportable_widening_operation (code, stmt,\n \t\t\t\t\t      vectype_out, vectype_in,\n@@ -1992,19 +1990,28 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  else\n \t    vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, NULL);\n \n-\t  builtin_decl =\n-\t    targetm.vectorize.builtin_conversion (code,\n-\t\t\t\t\t\t  vectype_out, vectype_in);\n \t  FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vop0)\n-\t    {\n-\t      /* Arguments are ready. create the new vector stmt.  */\n-\t      new_stmt = gimple_build_call (builtin_decl, 1, vop0);\n-\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t      gimple_call_set_lhs (new_stmt, new_temp);\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t      if (slp_node)\n-\t\tVEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n-\t    }\n+          {\n+            /* Arguments are ready, create the new vector stmt.  */\n+            if (code1 == CALL_EXPR)\n+              {\n+                new_stmt = gimple_build_call (decl1, 1, vop0);\n+                new_temp = make_ssa_name (vec_dest, new_stmt);\n+                gimple_call_set_lhs (new_stmt, new_temp);\n+              }\n+            else\n+              {\n+                gcc_assert (TREE_CODE_LENGTH (code) == unary_op);\n+                new_stmt = gimple_build_assign_with_ops (code, vec_dest, vop0,\n+                                                        NULL);\n+                new_temp = make_ssa_name (vec_dest, new_stmt);\n+                gimple_assign_set_lhs (new_stmt, new_temp);\n+              }\n+\n+            vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+            if (slp_node)\n+              VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n+          }\n \n \t  if (j == 0)\n \t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;"}, {"sha": "4f9970b3c8c36e8a9b7b48ec364dac9e1204d131", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9db8f45d5d6cb5b6b66f241411f5a44cd72e3eac", "patch": "@@ -1120,6 +1120,13 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n   (TREE_CODE (TYPE) == COMPLEX_TYPE\t\\\n    && TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE)\n \n+/* Nonzero if TYPE represents a vector integer type.  */\n+                \n+#define VECTOR_INTEGER_TYPE_P(TYPE)                   \\\n+             (TREE_CODE (TYPE) == VECTOR_TYPE      \\\n+                 && TREE_CODE (TREE_TYPE (TYPE)) == INTEGER_TYPE)\n+\n+\n /* Nonzero if TYPE represents a vector floating-point type.  */\n \n #define VECTOR_FLOAT_TYPE_P(TYPE)\t\\"}]}