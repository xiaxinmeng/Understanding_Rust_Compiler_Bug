{"sha": "0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIyMTJkOGM4NmVlZTRkZDJiOWIwYzRjMDRlYTRkZDk5NGU3MjY4Mg==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2016-08-04T13:35:19Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2016-08-04T13:35:19Z"}, "message": "C/C++: Simplify handling of location information for OpenACC routine directives\n\n\tgcc/c/\n\t* c-parser.c (struct oacc_routine_data): New.\n\t(c_parser_declaration_or_fndef, c_parser_oacc_routine): Use it.\n\tSimplify code.\n\t(c_finish_oacc_routine): Likewise.  Don't attach clauses to \"omp\n\tdeclare target\" attribute.\n\tgcc/cp/\n\t* parser.h (struct cp_omp_declare_simd_data): New.\n\t(struct cp_parser): Use it for oacc_routine member.\n\t* parser.c (cp_ensure_no_oacc_routine, cp_parser_oacc_routine)\n\t(cp_parser_late_parsing_oacc_routine, cp_finalize_oacc_routine):\n\tUse it.  Simplify code.\n\t(cp_parser_new): Initialize all members pointing to special\n\tparsing data structures.\n\t(cp_parser_cilk_simd_fn_vector_attrs): Initialize\n\tparser->cilk_simd_fn_info->clauses.\n\t(cp_parser_omp_declare_simd): Initialize\n\tparser->omp_declare_simd->clauses.\n\t(cp_parser_late_parsing_omp_declare_simd): Simplify code.\n\nFrom-SVN: r239127", "tree": {"sha": "3c902630f7e7db375d5643b09b8b06cf4c1a409d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c902630f7e7db375d5643b09b8b06cf4c1a409d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bbc79c0e9ee0f8a3e6a2e0a4ec104d2b86e093b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc79c0e9ee0f8a3e6a2e0a4ec104d2b86e093b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbc79c0e9ee0f8a3e6a2e0a4ec104d2b86e093b9"}], "stats": {"total": 238, "additions": 126, "deletions": 112}, "files": [{"sha": "7ef094a9cf5ebd62d33b7a7dfb79f2b6aab60019", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "patch": "@@ -1,3 +1,11 @@\n+2016-08-04  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* c-parser.c (struct oacc_routine_data): New.\n+\t(c_parser_declaration_or_fndef, c_parser_oacc_routine): Use it.\n+\tSimplify code.\n+\t(c_finish_oacc_routine): Likewise.  Don't attach clauses to \"omp\n+\tdeclare target\" attribute.\n+\n 2016-08-01  Jan Beulich  <jbeulich@suse.com>\n \n \t* c-fold.c (c_fully_fold_internal): Also emit shift count"}, {"sha": "c4a9797d49ca0a48036352b411318ad49f74c273", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "patch": "@@ -1274,11 +1274,17 @@ enum c_parser_prec {\n   NUM_PRECS\n };\n \n+/* Helper data structure for parsing #pragma acc routine.  */\n+struct oacc_routine_data {\n+  tree clauses;\n+  location_t loc;\n+};\n+\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n \t\t\t\t\t   bool, bool, tree *, vec<c_token>,\n-\t\t\t\t\t   tree = NULL_TREE);\n+\t\t\t\t\t   struct oacc_routine_data * = NULL);\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n static void c_parser_static_assert_declaration (c_parser *);\n static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n@@ -1370,7 +1376,7 @@ static bool c_parser_omp_target (c_parser *, enum pragma_context, bool *);\n static void c_parser_omp_end_declare_target (c_parser *);\n static void c_parser_omp_declare (c_parser *, enum pragma_context);\n static bool c_parser_omp_ordered (c_parser *, enum pragma_context, bool *);\n-static void c_parser_oacc_routine (c_parser *parser, enum pragma_context);\n+static void c_parser_oacc_routine (c_parser *, enum pragma_context);\n \n /* These Objective-C parser functions are only ever called when\n    compiling Objective-C.  */\n@@ -1562,7 +1568,8 @@ c_parser_external_declaration (c_parser *parser)\n }\n \n static void c_finish_omp_declare_simd (c_parser *, tree, tree, vec<c_token>);\n-static void c_finish_oacc_routine (c_parser *, tree, tree, bool, bool, bool);\n+static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool,\n+\t\t\t\t   bool, bool);\n \n /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99\n    6.7, 6.9.1).  If FNDEF_OK is true, a function definition is\n@@ -1641,7 +1648,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t       bool nested, bool start_attr_ok,\n \t\t\t       tree *objc_foreach_object_declaration,\n \t\t\t       vec<c_token> omp_declare_simd_clauses,\n-\t\t\t       tree oacc_routine_clauses)\n+\t\t\t       struct oacc_routine_data *oacc_routine_data)\n {\n   struct c_declspecs *specs;\n   tree prefix_attrs;\n@@ -1746,9 +1753,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  pedwarn (here, 0, \"empty declaration\");\n \t}\n       c_parser_consume_token (parser);\n-      if (oacc_routine_clauses)\n-\tc_finish_oacc_routine (parser, NULL_TREE,\n-\t\t\t       oacc_routine_clauses, false, true, false);\n+      if (oacc_routine_data)\n+\tc_finish_oacc_routine (oacc_routine_data, NULL_TREE, false, true,\n+\t\t\t       false);\n       return;\n     }\n \n@@ -1865,9 +1872,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n \t    c_finish_omp_declare_simd (parser, NULL_TREE, NULL_TREE,\n \t\t\t\t       omp_declare_simd_clauses);\n-\t  if (oacc_routine_clauses)\n-\t    c_finish_oacc_routine (parser, NULL_TREE,\n-\t\t\t\t   oacc_routine_clauses,\n+\t  if (oacc_routine_data)\n+\t    c_finish_oacc_routine (oacc_routine_data, NULL_TREE,\n \t\t\t\t   false, first, false);\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n@@ -1983,8 +1989,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  init = c_parser_initializer (parser);\n \t\t  finish_init ();\n \t\t}\n-\t      if (oacc_routine_clauses)\n-\t\tc_finish_oacc_routine (parser, d, oacc_routine_clauses,\n+\t      if (oacc_routine_data)\n+\t\tc_finish_oacc_routine (oacc_routine_data, d,\n \t\t\t\t       false, first, false);\n \t      if (d != error_mark_node)\n \t\t{\n@@ -2029,8 +2035,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  if (parms)\n \t\t    temp_pop_parm_decls ();\n \t\t}\n-\t      if (oacc_routine_clauses)\n-\t\tc_finish_oacc_routine (parser, d, oacc_routine_clauses,\n+\t      if (oacc_routine_data)\n+\t\tc_finish_oacc_routine (oacc_routine_data, d,\n \t\t\t\t       false, first, false);\n \t      if (d)\n \t\tfinish_decl (d, UNKNOWN_LOCATION, NULL_TREE,\n@@ -2142,9 +2148,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n \tc_finish_omp_declare_simd (parser, current_function_decl, NULL_TREE,\n \t\t\t\t   omp_declare_simd_clauses);\n-      if (oacc_routine_clauses)\n-\tc_finish_oacc_routine (parser, current_function_decl,\n-\t\t\t       oacc_routine_clauses, false, first, true);\n+      if (oacc_routine_data)\n+\tc_finish_oacc_routine (oacc_routine_data, current_function_decl,\n+\t\t\t       false, first, true);\n       DECL_STRUCT_FUNCTION (current_function_decl)->function_start_locus\n \t= c_parser_peek_token (parser)->location;\n       fnbody = c_parser_compound_statement (parser);\n@@ -14025,9 +14031,9 @@ static void\n c_parser_oacc_routine (c_parser *parser, enum pragma_context context)\n {\n   tree decl = NULL_TREE;\n-  /* Create a dummy claue, to record location.  */\n-  tree c_head = build_omp_clause (c_parser_peek_token (parser)->location,\n-\t\t\t\t  OMP_CLAUSE_SEQ);\n+  oacc_routine_data data;\n+  data.clauses = NULL_TREE;\n+  data.loc = c_parser_peek_token (parser)->location;\n   \n   if (context != pragma_external)\n     c_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n@@ -14062,56 +14068,52 @@ c_parser_oacc_routine (c_parser *parser, enum pragma_context context)\n \n   /* Build a chain of clauses.  */\n   parser->in_pragma = true;\n-  tree clauses = c_parser_oacc_all_clauses\n-    (parser, OACC_ROUTINE_CLAUSE_MASK, \"#pragma acc routine\");\n+  data.clauses\n+    = c_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+\t\t\t\t \"#pragma acc routine\");\n \n-  /* Force clauses to be non-null, by attaching context to it.  */\n-  clauses = tree_cons (c_head, clauses, NULL_TREE);\n-  \n   if (decl)\n-    c_finish_oacc_routine (parser, decl, clauses, true, true, false);\n+    c_finish_oacc_routine (&data, decl, true, true, false);\n   else if (c_parser_peek_token (parser)->type == CPP_PRAGMA)\n     /* This will emit an error.  */\n-    c_finish_oacc_routine (parser, NULL_TREE, clauses, false, true, false);\n+    c_finish_oacc_routine (&data, NULL_TREE, false, true, false);\n   else\n     c_parser_declaration_or_fndef (parser, true, false, false, false,\n-\t\t\t\t   true, NULL, vNULL, clauses);\n+\t\t\t\t   true, NULL, vNULL, &data);\n }\n \n-/* Finalize an OpenACC routine pragma, applying it to FNDECL.  CLAUSES\n-   are the parsed clauses.  IS_DEFN is true if we're applying it to\n-   the definition (so expect FNDEF to look somewhat defined.  */\n+/* Finalize an OpenACC routine pragma, applying it to FNDECL.\n+   IS_DEFN is true if we're applying it to the definition.  */\n \n static void\n-c_finish_oacc_routine (c_parser *ARG_UNUSED (parser), tree fndecl,\n-\t\t       tree clauses, bool named, bool first, bool is_defn)\n+c_finish_oacc_routine (struct oacc_routine_data *data, tree fndecl,\n+\t\t       bool named, bool first, bool is_defn)\n {\n-  location_t loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses));\n-\n   if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL || !first)\n     {\n       if (fndecl != error_mark_node)\n-\terror_at (loc, \"%<#pragma acc routine%> %s\",\n+\terror_at (data->loc, \"%<#pragma acc routine%> %s\",\n \t\t  named ? \"does not refer to a function\"\n \t\t  : \"not followed by single function\");\n       return;\n     }\n \n   if (get_oacc_fn_attrib (fndecl))\n-    error_at (loc, \"%<#pragma acc routine%> already applied to %D\", fndecl);\n+    error_at (data->loc,\n+\t      \"%<#pragma acc routine%> already applied to %D\", fndecl);\n \n   if (TREE_USED (fndecl) || (!is_defn && DECL_SAVED_TREE (fndecl)))\n-    error_at (loc, \"%<#pragma acc routine%> must be applied before %s\",\n+    error_at (data->loc, \"%<#pragma acc routine%> must be applied before %s\",\n \t      TREE_USED (fndecl) ? \"use\" : \"definition\");\n \n-  /* Process for function attrib  */\n-  tree dims = build_oacc_routine_dims (TREE_VALUE (clauses));\n+  /* Process the routine's dimension clauses.  */\n+  tree dims = build_oacc_routine_dims (data->clauses);\n   replace_oacc_fn_attrib (fndecl, dims);\n \n-  /* Also attach as a declare.  */\n+  /* Add an \"omp declare target\" attribute.  */\n   DECL_ATTRIBUTES (fndecl)\n     = tree_cons (get_identifier (\"omp declare target\"),\n-\t\t clauses, DECL_ATTRIBUTES (fndecl));\n+\t\t NULL_TREE, DECL_ATTRIBUTES (fndecl));\n }\n \n /* OpenACC 2.0:"}, {"sha": "45e647dd1f7d7ef2e5d40a55beefa4b5b60fbf5d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "patch": "@@ -1,3 +1,18 @@\n+2016-08-04  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* parser.h (struct cp_omp_declare_simd_data): New.\n+\t(struct cp_parser): Use it for oacc_routine member.\n+\t* parser.c (cp_ensure_no_oacc_routine, cp_parser_oacc_routine)\n+\t(cp_parser_late_parsing_oacc_routine, cp_finalize_oacc_routine):\n+\tUse it.  Simplify code.\n+\t(cp_parser_new): Initialize all members pointing to special\n+\tparsing data structures.\n+\t(cp_parser_cilk_simd_fn_vector_attrs): Initialize\n+\tparser->cilk_simd_fn_info->clauses.\n+\t(cp_parser_omp_declare_simd): Initialize\n+\tparser->omp_declare_simd->clauses.\n+\t(cp_parser_late_parsing_omp_declare_simd): Simplify code.\n+\n 2016-08-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/70229"}, {"sha": "e696d465192aeb30ff2b67738edaec8b57a50e73", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 47, "deletions": 61, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "patch": "@@ -1391,10 +1391,8 @@ cp_ensure_no_oacc_routine (cp_parser *parser)\n {\n   if (parser->oacc_routine && !parser->oacc_routine->error_seen)\n     {\n-      tree clauses = parser->oacc_routine->clauses;\n-      location_t loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses));\n-\n-      error_at (loc, \"%<#pragma acc routine%> not followed by a function \"\n+      error_at (parser->oacc_routine->loc,\n+\t\t\"%<#pragma acc routine%> not followed by a function \"\n \t\t\"declaration or definition\");\n       parser->oacc_routine = NULL;\n     }\n@@ -3775,15 +3773,17 @@ cp_parser_new (void)\n   /* No template parameters apply.  */\n   parser->num_template_parameter_lists = 0;\n \n+  /* Special parsing data structures.  */\n+  parser->omp_declare_simd = NULL;\n+  parser->cilk_simd_fn_info = NULL;\n+  parser->oacc_routine = NULL;\n+\n   /* Not declaring an implicit function template.  */\n   parser->auto_is_implicit_function_template_parm_p = false;\n   parser->fully_implicit_function_template_p = false;\n   parser->implicit_template_parms = 0;\n   parser->implicit_template_scope = 0;\n \n-  /* Active OpenACC routine clauses.  */\n-  parser->oacc_routine = NULL;\n-\n   /* Allow constrained-type-specifiers. */\n   parser->prevent_constrained_type_specifiers = 0;\n \n@@ -19820,8 +19820,9 @@ parsing_nsdmi (void)\n \n    Returns the type indicated by the type-id.\n \n-   In addition to this, parse any queued up omp declare simd\n-   clauses and Cilk Plus SIMD-enabled function's vector attributes.\n+   In addition to this, parse any queued up #pragma omp declare simd\n+   clauses, Cilk Plus SIMD-enabled functions' vector attributes, and\n+   #pragma acc routine clauses.\n \n    QUALS is either a bitmask of cv_qualifiers or -1 for a non-member\n    function.  */\n@@ -23727,6 +23728,7 @@ cp_parser_cilk_simd_fn_vector_attrs (cp_parser *parser, cp_token *v_token)\n       parser->cilk_simd_fn_info->error_seen = false;\n       parser->cilk_simd_fn_info->fndecl_seen = false;\n       parser->cilk_simd_fn_info->tokens = vNULL;\n+      parser->cilk_simd_fn_info->clauses = NULL_TREE;\n     }\n   int paren_scope = 0;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n@@ -35729,6 +35731,9 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n       data.error_seen = false;\n       data.fndecl_seen = false;\n       data.tokens = vNULL;\n+      data.clauses = NULL_TREE;\n+      /* It is safe to take the address of a local variable; it will only be\n+\t used while this scope is live.  */\n       parser->omp_declare_simd = &data;\n     }\n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n@@ -35846,7 +35851,6 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n       error (\"%<#pragma omp declare simd%> not immediately followed by \"\n \t     \"a single function declaration or definition\");\n       data->error_seen = true;\n-      return attrs;\n     }\n   if (data->error_seen)\n     return attrs;\n@@ -36560,21 +36564,19 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t\t\tenum pragma_context context)\n {\n   bool first_p = parser->oacc_routine == NULL;\n-  location_t loc = pragma_tok->location;\n-  cp_omp_declare_simd_data data;\n+  cp_oacc_routine_data data;\n   if (first_p)\n     {\n       data.error_seen = false;\n       data.fndecl_seen = false;\n       data.tokens = vNULL;\n       data.clauses = NULL_TREE;\n+      data.loc = pragma_tok->location;\n+      /* It is safe to take the address of a local variable; it will only be\n+\t used while this scope is live.  */\n       parser->oacc_routine = &data;\n     }\n \n-  tree decl = NULL_TREE;\n-  /* Create a dummy claue, to record location.  */\n-  tree c_head = build_omp_clause (pragma_tok->location, OMP_CLAUSE_SEQ);\n-\n   if (context != pragma_external)\n     {\n       cp_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n@@ -36595,7 +36597,7 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t    parser->oacc_routine->error_seen = true;\n \t  cp_parser_require_pragma_eol (parser, pragma_tok);\n \n-\t  error_at (OMP_CLAUSE_LOCATION (parser->oacc_routine->clauses),\n+\t  error_at (parser->oacc_routine->loc,\n \t\t    \"%<#pragma acc routine%> not followed by a \"\n \t\t    \"function declaration or definition\");\n \n@@ -36615,7 +36617,7 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t\t\t /*template_p=*/NULL,\n \t\t\t\t\t /*declarator_p=*/false,\n \t\t\t\t\t /*optional_p=*/false);\n-      decl = cp_parser_lookup_name_simple (parser, id, token->location);\n+      tree decl = cp_parser_lookup_name_simple (parser, id, token->location);\n       if (id != error_mark_node && decl == error_mark_node)\n \tcp_parser_name_lookup_error (parser, id, decl, NLE_NULL,\n \t\t\t\t     token->location);\n@@ -36630,20 +36632,17 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \n       /* Build a chain of clauses.  */\n       parser->lexer->in_pragma = true;\n-      tree clauses = NULL_TREE;\n-      clauses = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n-\t\t\t\t\t    \"#pragma acc routine\",\n-\t\t\t\t\t    cp_lexer_peek_token\n-\t\t\t\t\t    (parser->lexer));\n-\n-      /* Force clauses to be non-null, by attaching context to it.  */\n-      clauses = tree_cons (c_head, clauses, NULL_TREE);\n+      data.clauses\n+\t= cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+\t\t\t\t      \"#pragma acc routine\",\n+\t\t\t\t      cp_lexer_peek_token (parser->lexer));\n \n       if (decl && is_overloaded_fn (decl)\n \t  && (TREE_CODE (decl) != FUNCTION_DECL\n \t      || DECL_FUNCTION_TEMPLATE_P  (decl)))\n \t{\n-\t  error_at (loc, \"%<#pragma acc routine%> names a set of overloads\");\n+\t  error_at (data.loc,\n+\t\t    \"%<#pragma acc routine%> names a set of overloads\");\n \t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n@@ -36652,22 +36651,21 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t namespaces?  */\n       if (!DECL_NAMESPACE_SCOPE_P (decl))\n \t{\n-\t  error_at (loc, \"%<#pragma acc routine%> does not refer to a \"\n+\t  error_at (data.loc,\n+\t\t    \"%<#pragma acc routine%> does not refer to a \"\n \t\t    \"namespace scope function\");\n \t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n \n       if (!decl || TREE_CODE (decl) != FUNCTION_DECL)\n \t{\n-\t  error_at (loc,\n+\t  error_at (data.loc,\n \t\t    \"%<#pragma acc routine%> does not refer to a function\");\n \t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n \n-      data.clauses = clauses;\n-\n       cp_finalize_oacc_routine (parser, decl, false);\n       data.tokens.release ();\n       parser->oacc_routine = NULL;\n@@ -36685,23 +36683,18 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t= cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser->lexer));\n       parser->oacc_routine->tokens.safe_push (cp);\n \n-      if (first_p)\n-\tparser->oacc_routine->clauses = c_head;\n-\n       while (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n \tcp_parser_pragma (parser, context, NULL);\n \n       if (first_p)\n \t{\n-\t  /* Create an empty list of clauses.  */\n-\t  parser->oacc_routine->clauses = tree_cons (c_head, NULL_TREE,\n-\t\t\t\t\t\t     NULL_TREE);\n \t  cp_parser_declaration (parser);\n \n \t  if (parser->oacc_routine\n \t      && !parser->oacc_routine->error_seen\n \t      && !parser->oacc_routine->fndecl_seen)\n-\t    error_at (loc, \"%<#pragma acc routine%> not followed by a \"\n+\t    error_at (data.loc,\n+\t\t      \"%<#pragma acc routine%> not followed by a \"\n \t\t      \"function declaration or definition\");\n \n \t  data.tokens.release ();\n@@ -36717,19 +36710,15 @@ static tree\n cp_parser_late_parsing_oacc_routine (cp_parser *parser, tree attrs)\n {\n   struct cp_token_cache *ce;\n-  cp_omp_declare_simd_data *data = parser->oacc_routine;\n-  tree cl, clauses = parser->oacc_routine->clauses;\n-  location_t loc;\n+  cp_oacc_routine_data *data = parser->oacc_routine;\n \n-  loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE(clauses));\n-  \n   if ((!data->error_seen && data->fndecl_seen)\n       || data->tokens.length () != 1)\n     {\n-      error_at (loc, \"%<#pragma acc routine%> not followed by a \"\n+      error_at (data->loc,\n+\t\t\"%<#pragma acc routine%> not followed by a \"\n \t\t\"function declaration or definition\");\n       data->error_seen = true;\n-      return attrs;\n     }\n   if (data->error_seen)\n     return attrs;\n@@ -36741,15 +36730,11 @@ cp_parser_late_parsing_oacc_routine (cp_parser *parser, tree attrs)\n   gcc_assert (cp_lexer_peek_token (parser->lexer)->type == CPP_PRAGMA);\n \n   cp_token *pragma_tok = cp_lexer_consume_token (parser->lexer);\n-  cl = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+  parser->oacc_routine->clauses\n+    = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n \t\t\t\t  \"#pragma acc routine\", pragma_tok);\n   cp_parser_pop_lexer (parser);\n \n-  tree c_head = build_omp_clause (loc, OMP_CLAUSE_SEQ);\n-\n-  /* Force clauses to be non-null, by attaching context to it.  */\n-  parser->oacc_routine->clauses = tree_cons (c_head, cl, NULL_TREE);\n-\n   data->fndecl_seen = true;\n   return attrs;\n }\n@@ -36762,9 +36747,6 @@ cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n {\n   if (__builtin_expect (parser->oacc_routine != NULL, 0))\n     {\n-      tree clauses = parser->oacc_routine->clauses;\n-      location_t loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE(clauses));\n-\n       if (parser->oacc_routine->error_seen)\n \treturn;\n       \n@@ -36782,31 +36764,35 @@ cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n \n       if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL)\n \t{\n-\t  error_at (loc,\n+\t  error_at (parser->oacc_routine->loc,\n \t\t    \"%<#pragma acc routine%> not followed by a function \"\n \t\t    \"declaration or definition\");\n \t  parser->oacc_routine = NULL;\n+\t  return;\n \t}\n \t  \n       if (get_oacc_fn_attrib (fndecl))\n \t{\n-\t  error_at (loc, \"%<#pragma acc routine%> already applied to %D\",\n-\t\t    fndecl);\n+\t  error_at (parser->oacc_routine->loc,\n+\t\t    \"%<#pragma acc routine%> already applied to %D\", fndecl);\n \t  parser->oacc_routine = NULL;\n+\t  return;\n \t}\n \n       if (TREE_USED (fndecl) || (!is_defn && DECL_SAVED_TREE (fndecl)))\n \t{\n-\t  error_at (loc, \"%<#pragma acc routine%> must be applied before %s\",\n+\t  error_at (parser->oacc_routine->loc,\n+\t\t    \"%<#pragma acc routine%> must be applied before %s\",\n \t\t    TREE_USED (fndecl) ? \"use\" : \"definition\");\n \t  parser->oacc_routine = NULL;\n+\t  return;\n \t}\n \n-      /* Process for function attrib  */\n-      tree dims = build_oacc_routine_dims (TREE_VALUE (clauses));\n+      /* Process the routine's dimension clauses.  */\n+      tree dims = build_oacc_routine_dims (parser->oacc_routine->clauses);\n       replace_oacc_fn_attrib (fndecl, dims);\n       \n-      /* Add an \"omp target\" attribute.  */\n+      /* Add an \"omp declare target\" attribute.  */\n       DECL_ATTRIBUTES (fndecl)\n \t= tree_cons (get_identifier (\"omp declare target\"),\n \t\t     NULL_TREE, DECL_ATTRIBUTES (fndecl));"}, {"sha": "2d3feb6915772c5db3e301745f52e2f1e0951342", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=0b212d8c86eee4dd2b9b0c4c04ea4dd994e72682", "patch": "@@ -199,14 +199,19 @@ struct GTY (()) cp_parser_context {\n };\n \n \n-/* Control structure for #pragma omp declare simd parsing.  */\n+/* Helper data structure for parsing #pragma omp declare simd, and Cilk Plus\n+   SIMD-enabled functions' vector attribute.  */\n struct cp_omp_declare_simd_data {\n   bool error_seen; /* Set if error has been reported.  */\n   bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */\n   vec<cp_token_cache_ptr> tokens;\n   tree clauses;\n };\n \n+/* Helper data structure for parsing #pragma acc routine.  */\n+struct cp_oacc_routine_data : cp_omp_declare_simd_data {\n+  location_t loc;\n+};\n \n /* The cp_parser structure represents the C++ parser.  */\n \n@@ -363,18 +368,16 @@ struct GTY(()) cp_parser {\n   unsigned num_template_parameter_lists;\n \n   /* When parsing #pragma omp declare simd, this is a pointer to a\n-     data structure with everything needed for parsing the clauses.  */\n+     helper data structure.  */\n   cp_omp_declare_simd_data * GTY((skip)) omp_declare_simd;\n \n-  /* When parsing the vector attribute in Cilk Plus SIMD-enabled function,\n-     this is a pointer to data structure with everything needed for parsing\n-     the clauses.  The cp_omp_declare_simd_data struct will hold all the\n-     necessary information, so creating another struct for this is not\n-     necessary.  */\n+  /* When parsing Cilk Plus SIMD-enabled functions' vector attributes,\n+     this is a pointer to a helper data structure.  */\n   cp_omp_declare_simd_data * GTY((skip)) cilk_simd_fn_info;\n \n-  /* Parsing information for #pragma acc routine.  */\n-  cp_omp_declare_simd_data * GTY((skip)) oacc_routine;\n+  /* When parsing #pragma acc routine, this is a pointer to a helper data\n+     structure.  */\n+  cp_oacc_routine_data * GTY((skip)) oacc_routine;\n   \n   /* Nonzero if parsing a parameter list where 'auto' should trigger an implicit\n      template parameter.  */"}]}