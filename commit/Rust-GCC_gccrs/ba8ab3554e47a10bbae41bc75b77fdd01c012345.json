{"sha": "ba8ab3554e47a10bbae41bc75b77fdd01c012345", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE4YWIzNTU0ZTQ3YTEwYmJhZTQxYmM3NWI3N2ZkZDAxYzAxMjM0NQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-05T17:53:05Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-05T17:53:05Z"}, "message": "Initial revision\n\nFrom-SVN: r907", "tree": {"sha": "173f8dc4a90700b67c5ea7c0872f499994a8be8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/173f8dc4a90700b67c5ea7c0872f499994a8be8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba8ab3554e47a10bbae41bc75b77fdd01c012345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba8ab3554e47a10bbae41bc75b77fdd01c012345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba8ab3554e47a10bbae41bc75b77fdd01c012345", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba8ab3554e47a10bbae41bc75b77fdd01c012345/comments", "author": null, "committer": null, "parents": [{"sha": "f543676f57d8e673581b79409b706c377064ff59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f543676f57d8e673581b79409b706c377064ff59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f543676f57d8e673581b79409b706c377064ff59"}], "stats": {"total": 6336, "additions": 6336, "deletions": 0}, "files": [{"sha": "dc7282fb85844b51296df2ca3c566cb998b81a3e", "filename": "gcc/config/i960/i960.c", "status": "added", "additions": 2314, "deletions": 0, "changes": 2314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=ba8ab3554e47a10bbae41bc75b77fdd01c012345", "patch": "@@ -0,0 +1,2314 @@\n+/* Subroutines used for code generation on intel 80960.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Steven McGeady, Intel Corp.\n+   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n+   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"insn-codes.h\"\n+#include \"assert.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"recog.h\"\n+#include <math.h>\n+\n+/* Save the operands last given to a compare for use when we\n+   generate a scc or bcc insn.  */\n+\n+rtx i960_compare_op0, i960_compare_op1;\n+\n+/* Used to implement #pragma align/noalign.  Initialized by OVERRIDE_OPTIONS\n+   macro in i960.h.  */\n+\n+static int i960_maxbitalignment;\n+static int i960_last_maxbitalignment;\n+\n+/* Used to implement switching between MEM and ALU insn types, for better\n+   C series performance.  */\n+\n+enum insn_types i960_last_insn_type;\n+\n+/* Where to save/restore register 14 to/from before/after a procedure call\n+   when it holds an argument block pointer.  */\n+\n+static rtx g14_save_reg;\n+\n+/* The leaf-procedure return register.  Set only if this is a leaf routine.  */\n+\n+static int i960_leaf_ret_reg;\n+\n+/* True if replacing tail calls with jumps is OK.  */\n+\n+static int tail_call_ok;\n+\n+/* A string containing a list of insns to emit in the epilogue so as to\n+   restore all registers saved by the prologue.  Created by the prologue\n+   code as it saves registers away.  */\n+\n+char epilogue_string[1000];\n+\n+/* A unique number (per function) for return labels.  */\n+\n+static int ret_label = 0;\n+\n+#if 0\n+/* Handle pragmas for compatibility with Intel's compilers.  */\n+\n+/* ??? This is incomplete, since it does not handle all pragmas that the\n+   intel compilers understand.  Also, it needs to be rewritten to accept\n+   a stream instead of a string for GCC 2.  */\n+\n+void\n+process_pragma(str)\n+     char  *str;\n+{\n+  int align;\n+  int i;\n+\n+  if ((i = sscanf (str, \" align %d\", &align)) == 1)\n+    switch (align)\n+      {\n+      case 0:\t\t\t/* Return to last alignment.  */\n+        align = i960_last_maxbitalignment / 8;\n+\n+      case 16:\t\t\t/* Byte alignments. */\n+      case 8:\n+      case 4:\n+      case 2:\n+      case 1:\n+        i960_last_maxbitalignment = i960_maxbitalignment;\n+        i960_maxbitalignment = align * 8;\n+        break;\n+\n+      default:\t\t\t/* Unknown, silently ignore.  */\n+        break;\n+      }\n+\n+  /* NOTE: ic960 R3.0 pragma align definition:\n+\n+     #pragma align [(size)] | (identifier=size[,...])\n+     #pragma noalign [(identifier)[,...]]\n+\n+     (all parens are optional)\n+\n+     - size is [1,2,4,8,16]\n+     - noalign means size==1\n+     - applies only to component elements of a struct (and union?)\n+     - identifier applies to structure tag (only)\n+     - missing identifier means next struct\n+\n+     - alignment rules for bitfields need more investigation  */\n+\n+  /* Should be pragma 'far' or equivalent for callx/balx here.  */\n+}\n+#endif\n+\n+/* Initialize variables before compiling any files.  */\n+\n+void\n+i960_initialize ()\n+{\n+  if (TARGET_IC_COMPAT2_0)\n+    {\n+      i960_maxbitalignment = 8;\n+      i960_last_maxbitalignment = 128;\n+    }\n+  else\n+    {\n+      i960_maxbitalignment = 128;\n+      i960_last_maxbitalignment = 8;\n+    }\n+}\n+\f\n+/* Return true if OP can be used as the source of an fp move insn.  */\n+\n+int\n+fpmove_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_DOUBLE || general_operand (op, mode));\n+}\n+\n+#if 0\n+/* Return true if OP is a register or zero.  */\n+\n+int\n+reg_or_zero_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return register_operand (op, mode) || op == const0_rtx;\n+}\n+#endif\n+\n+/* Return truth value of whether OP can be used as an operands in a three\n+   address arithmetic insn (such as add %o1,7,%l2) of mode MODE.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) || literal (op, mode));\n+}\n+\n+/* Return true if OP is a register or a valid floating point literal.  */\n+\n+int\n+fp_arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) || fp_literal (op, mode));\n+}\n+\n+/* Return true is OP is a register or a valid signed integer literal.  */\n+\n+int\n+signed_arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) || signed_literal (op, mode));\n+}\n+\n+/* Return truth value of whether OP is a integer which fits the\n+   range constraining immediate operands in three-address insns.  */\n+\n+int\n+literal (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == CONST_INT) && INTVAL(op) >= 0 && INTVAL(op) < 32);\n+}\n+\n+/* Return true if OP is a float constant of 1.  */\n+\n+int\n+fp_literal_one (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (TARGET_NUMERICS && (mode == VOIDmode || mode == GET_MODE (op))\n+\t  && (op == CONST1_RTX (mode)));\n+}\n+\n+/* Return true if OP is a float constant of 0.  */\n+\n+int\n+fp_literal_zero (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (TARGET_NUMERICS && (mode == VOIDmode || mode == GET_MODE (op))\n+\t  && (op == CONST0_RTX (mode)));\n+}\n+\n+/* Return true if OP is a valid floating point literal.  */\n+\n+int\n+fp_literal(op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return fp_literal_zero (op, mode) || fp_literal_one (op, mode);\n+}\n+\n+/* Return true if OP is a valid signed immediate constant.  */\n+\n+int\n+signed_literal(op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == CONST_INT) && INTVAL(op) > -32 && INTVAL(op) < 32);\n+}\n+\n+/* Return truth value of statement that OP is a symbolic memory\n+   operand of mode MODE.  */\n+\n+int\n+symbolic_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n+\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n+}\n+\n+/* Return truth value of whether OP is EQ or NE.  */\n+\n+int\n+eq_or_neq (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+}\n+\n+/* OP is an integer register or a constant.  */\n+\n+int\n+arith32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+  return (CONSTANT_P (op));\n+}\n+\n+/* Return true if OP is an integer constant which is a power of 2.  */\n+\n+int\n+power2_operand (op,mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE(op) != CONST_INT)\n+    return 0;\n+\n+  return exact_log2 (INTVAL (op)) >= 0;\n+}\n+\n+/* If VAL has only one bit set, return the index of that bit.  Otherwise\n+   return -1.  */\n+\n+int\n+bitpos (val)\n+     unsigned int val;\n+{\n+  register int i;\n+\n+  for (i = 0; val != 0; i++, val >>= 1)\n+    {\n+      if (val & 1)\n+\t{\n+\t  if (val != 1)\n+\t    return -1;\n+\t  return i;\n+\t}\n+    }\n+  return -1;\n+}\n+\n+/* Return non-zero if OP is a mask, i.e. all one bits are consecutive.\n+   The return value indicates how many consecutive non-zero bits exist\n+   if this is a mask.  This is the same as the next function, except that\n+   it does not indicate what the start and stop bit positions are.  */\n+\n+int\n+is_mask (val)\n+     unsigned int val;\n+{\n+  register int start, end, i;\n+\n+  start = -1;\n+  for (i = 0; val != 0; val >>= 1, i++)\n+    {\n+      if (val & 1)\n+\t{\n+\t  if (start < 0)\n+\t    start = i;\n+\n+\t  end = i;\n+\t  continue;\n+\t}\n+      /* Still looking for the first bit.  */\n+      if (start < 0)\n+\tcontinue;\n+\n+      /* We've seen the start of a bit sequence, and now a zero.  There\n+\t must be more one bits, otherwise we would have exited the loop.\n+\t Therefore, it is not a mask.  */\n+      if (val)\n+\treturn 0;\n+    }\n+\n+  /* The bit string has ones from START to END bit positions only.  */\n+  return end - start + 1;\n+}\n+\n+/* If VAL is a mask, then return nonzero, with S set to the starting bit\n+   position and E set to the ending bit position of the mask.  The return\n+   value indicates how many consecutive bits exist in the mask.  This is\n+   the same as the previous function, except that it also indicates the\n+   start and end bit positions of the mask.  */\n+\n+int\n+bitstr (val, s, e)\n+     unsigned int val;\n+     int *s, *e;\n+{\n+  register int start, end, i;\n+\n+  start = -1;\n+  end = -1;\n+  for (i = 0; val != 0; val >>= 1, i++)\n+    {\n+      if (val & 1)\n+\t{\n+\t  if (start < 0)\n+\t    start = i;\n+\n+\t  end = i;\n+\t  continue;\n+\t}\n+\n+      /* Still looking for the first bit.  */\n+      if (start < 0)\n+\tcontinue;\n+\n+      /* We've seen the start of a bit sequence, and now a zero.  There\n+\t must be more one bits, otherwise we would have exited the loop.\n+\t Therefor, it is not a mask.  */\n+      if (val)\n+\t{\n+\t  start = -1;\n+\t  end = -1;\n+\t  break;\n+\t}\n+    }\n+\n+  /* The bit string has ones from START to END bit positions only.  */\n+  *s = start;\n+  *e = end;\n+  return ((start < 0) ? 0 : end - start + 1);\n+}\n+\f\n+/* Return the machine mode to use for a comparison.  */\n+\n+enum machine_mode\n+select_cc_mode (op, x)\n+     RTX_CODE op;\n+     rtx x;\n+{\n+  if (op == GTU || op == LTU || op == GEU || op == LEU)\n+    return CC_UNSmode;\n+  return CCmode;\n+}\n+\n+/* X and Y are two things to compare using CODE.  Emit the compare insn and\n+   return the rtx for register 36 in the proper mode.  */\n+\n+rtx\n+gen_compare_reg (code, x, y)\n+     enum rtx_code code;\n+     rtx x, y;\n+{\n+  rtx cc_reg;\n+  enum machine_mode ccmode = SELECT_CC_MODE (code, x);\n+  enum machine_mode mode\n+    = GET_MODE (x) == VOIDmode ? GET_MODE (y) : GET_MODE (x);\n+\n+  if (mode == SImode)\n+    {\n+      if (! arith_operand (x, mode))\n+\tx = force_reg (SImode, x);\n+      if (! arith_operand (y, mode))\n+\ty = force_reg (SImode, y);\n+    }\n+\n+  cc_reg = gen_rtx (REG, ccmode, 36);\n+  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n+\t\t      gen_rtx (COMPARE, ccmode, x, y)));\n+\n+  return cc_reg;\n+}\n+\n+/* For the i960, REG is cost 1, REG+immed CONST is cost 2, REG+REG is cost 2,\n+   REG+nonimmed CONST is cost 4.  REG+SYMBOL_REF, SYMBOL_REF, and similar\n+   are 4.  Indexed addresses are cost 6.  */\n+\n+/* ??? Try using just RTX_COST, i.e. not defining ADDRESS_COST.  */\n+\n+int\n+i960_address_cost (x)\n+     rtx x;\n+{\n+#if 0\n+  /* Handled before calling here.  */\n+  if (GET_CODE (x) == REG)\n+    return 1;\n+#endif\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      rtx base = XEXP (x, 0);\n+      rtx offset = XEXP (x, 1);\n+\n+      if (GET_CODE (base) == SUBREG)\n+\tbase = SUBREG_REG (base);\n+      if (GET_CODE (offset) == SUBREG)\n+\toffset = SUBREG_REG (offset);\n+\n+      if (GET_CODE (base) == REG)\n+\t{\n+\t  if (GET_CODE (offset) == REG)\n+\t    return 2;\n+\t  if (GET_CODE (offset) == CONST_INT)\n+\t    {\n+\t      if ((unsigned)INTVAL (offset) < 2047)\n+\t\treturn 2;\n+\t      return 4;\n+\t    }\n+\t  if (CONSTANT_P (offset))\n+\t    return 4;\n+\t}\n+      if (GET_CODE (base) == PLUS || GET_CODE (base) == MULT)\n+\treturn 6;\n+\n+      abort ();\n+    }\n+  if (GET_CODE (x) == MULT)\n+    return 6;\n+\n+  /* Symbol_refs and other unrecognized addresses are cost 4.  */\n+  return 4;\n+}\n+\f\n+/* Emit insns to move operands[1] into operands[0].\n+\n+   Return 1 if we have written out everything that needs to be done to\n+   do the move.  Otherwise, return 0 and the caller will emit the move\n+   normally.  */\n+\n+int\n+emit_move_sequence (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  register rtx operand0 = operands[0];\n+  register rtx operand1 = operands[1];\n+\n+  /* We can only store registers to memory.  */\n+\n+  if (GET_CODE (operand0) == MEM && GET_CODE (operand1) != REG)\n+    operands[1] = force_reg (mode, operand1);\n+\n+  return 0;\n+}\n+\f\n+/* Emit insns to load a constant.  Uses several strategies to try to use\n+   as few insns as possible.  */\n+\n+char *\n+i960_output_ldconst (dst, src)\n+     register rtx dst, src;\n+{\n+  register int rsrc1;\n+  register unsigned rsrc2;\n+  enum machine_mode mode = GET_MODE (dst);\n+  rtx operands[4];\n+  union { long l[2]; double d; } x;\n+\n+  operands[0] = operands[2] = dst;\n+  operands[1] = operands[3] = src;\n+\n+  /* Anything that isn't a compile time constant, such as a SYMBOL_REF,\n+     must be a ldconst insn.  */\n+\n+  if (GET_CODE (src) != CONST_INT && GET_CODE (src) != CONST_DOUBLE)\n+    {\n+      output_asm_insn (\"ldconst\t%1,%0\", operands);\n+      return \"\";\n+    }\n+  else if (mode == DFmode)\n+    {\n+      rtx first, second;\n+\n+      if (fp_literal_zero (src, VOIDmode))\n+\t{\n+\t  if (FP_REG_P (dst))\n+\t    return \"movrl\t%1,%0\";\n+\t  else\n+\t    return \"movl\t0,%0\";\n+\t}\n+\n+#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+      split_double (src, &first, &second);\n+\n+      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n+\n+      operands[0] = gen_rtx (REG, SImode, REGNO (dst));\n+      operands[1] = first;\n+      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n+\t\t      operands);\n+      operands[0] = gen_rtx (REG, SImode, REGNO (dst) + 1);\n+      operands[1] = second;\n+      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n+\t\t      operands);\n+      return \"\";\n+#else\n+      if (fp_literal_one (src, VOIDmode))\n+\treturn \"movrl\t0f1.0,%0\";\n+      fatal (\"inline double constants not supported on this host\");\n+#endif\n+    }\n+  else if (mode == TImode)\n+    {\n+      /* ??? This is currently not handled at all.  */\n+      abort ();\n+\n+      /* Note: lowest order word goes in lowest numbered reg.  */\n+      rsrc1 = INTVAL (src);\n+      if (rsrc1 >= 0 && rsrc1 < 32)\n+\treturn \"movq\t%1,%0\";\n+      else\n+\toutput_asm_insn (\"movq\\t0,%0\\t# ldconstq %1,%0\",operands);\n+      /* Go pick up the low-order word.  */\n+    }\n+  else if (mode == DImode)\n+    {\n+      rtx upperhalf, lowerhalf;\n+      char *string;\n+\n+      if (GET_CODE (src) == CONST_DOUBLE)\n+\t{\n+\t  upperhalf = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (src));\n+\t  lowerhalf = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (src));\n+\t}\n+      else if (GET_CODE (src) == CONST_INT)\n+\t{\n+\t  lowerhalf = src;\n+\t  upperhalf = INTVAL (src) < 0 ? constm1_rtx : const0_rtx;\n+\t}\n+      else\n+\tabort ();\n+\n+      /* Note: lowest order word goes in lowest numbered reg.  */\n+      /* Numbers from 0 to 31 can be handled with a single insn.  */\n+      rsrc1 = INTVAL (lowerhalf);\n+      if (upperhalf == const0_rtx && rsrc1 >= 0 && rsrc1 < 32)\n+\treturn \"movl\t%1,%0\";\n+\n+      /* Output the upper half with a recursive call.  */\n+      string = i960_output_ldconst (gen_rtx (REG, SImode, REGNO (dst) + 1),\n+\t\t\t\t    upperhalf);\n+      output_asm_insn (string);\n+      /* The lower word is emitted as normally.  */\n+    }\n+  else if (mode == SFmode)\n+    {\n+#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+      union { long l; float f; } flt;\n+\n+      flt.f = (float) *((double *) &CONST_DOUBLE_LOW (src));\n+\n+      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n+      operands[0] = gen_rtx (REG, SImode, REGNO (dst));\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, flt.l);\n+      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n+\t\t      operands);\n+#else\n+      if (fp_literal_zero (src, VOIDmode))\n+\treturn \"movr\t0f0.0,%0\";\n+      if (fp_literal_one (src, VOIDmode))\n+\treturn \"movr\t0f1.0,%0\";\n+      fatal (\"inline float constants not supported on this host\");\n+#endif\n+      return \"\";\n+    }\n+  else\n+    {\n+      rsrc1 = INTVAL (src);\n+      if (mode == QImode)\n+\t{\n+\t  if (rsrc1 > 0xff)\n+\t    rsrc1 &= 0xff;\n+\t}\n+      else if (mode == HImode)\n+\t{\n+\t  if (rsrc1 > 0xffff)\n+\t    rsrc1 &= 0xffff;\n+\t}\n+    }\n+\n+  if (rsrc1 >= 0)\n+    {\n+      /* ldconst\t0..31,X\t\t-> \tmov\t0..31,X  */\n+      if (rsrc1 < 32)\n+\t{\n+\t  if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t    return \"lda\t%1,%0\";\n+\t  return \"mov\t%1,%0\";\n+\t}\n+\n+      /* ldconst\t32..63,X\t->\tadd\t31,nn,X  */\n+      if (rsrc1 < 63)\n+\t{\n+\t  if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t    return \"lda\t%1,%0\";\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, rsrc1 - 31);\n+\t  output_asm_insn (\"addo\\t31,%1,%0\\t# ldconst %3,%0\", operands);\n+\t  return \"\";\n+\t}\n+    }\n+  else if (rsrc1 < 0)\n+    {\n+      /* ldconst\t-1..-31\t\t->\tsub\t0,0..31,X  */\n+      if (rsrc1 >= -31)\n+\t{\n+\t  /* return 'sub -(%1),0,%0' */\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, - rsrc1);\n+\t  output_asm_insn (\"subo\\t%1,0,%0\\t# ldconst %3,%0\", operands);\n+\t  return \"\";\n+\t}\n+      \n+      /* ldconst\t-32\t\t->\tnot\t31,X  */\n+      if (rsrc1 == -32)\n+\t{\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, ~rsrc1);\n+\t  output_asm_insn (\"not\\t%1,%0\t# ldconst %3,%0\", operands);\n+\t  return \"\";\n+\t}\n+    }\n+\n+  /* If const is a single bit.  */\n+  if (bitpos (rsrc1) >= 0)\n+    {\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, bitpos (rsrc1));\n+      output_asm_insn (\"setbit\\t%1,0,%0\\t# ldconst %3,%0\", operands);\n+      return \"\";\n+    }\n+\n+  /* If const is a bit string of less than 6 bits (1..31 shifted).  */\n+  if (is_mask (rsrc1))\n+    {\n+      int s, e;\n+\n+      if (bitstr (rsrc1, &s, &e) < 6)\n+\t{\n+\t  rsrc2 = ((unsigned int) rsrc1) >> s;\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, rsrc2);\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, s);\n+\t  output_asm_insn (\"shlo\\t%2,%1,%0\\t# ldconst %3,%0\", operands);\n+\t  return \"\";\n+\t}\n+    }\n+\n+  /* Unimplemented cases:\n+     const is in range 0..31 but rotated around end of word:\n+     ror\t31,3,g0\t-> ldconst 0xe0000003,g0\n+   \n+     and any 2 instruction cases that might be worthwhile  */\n+  \n+  output_asm_insn (\"ldconst\t%1,%0\", operands);\n+  return \"\";\n+}\n+\n+/* Determine if there is an opportunity for a bypass optimization.\n+   Bypass suceeds on the 960K* if the destination of the previous\n+   instruction is the second operand of the current instruction.\n+   Bypass always succeeds on the C*.\n+ \n+   Return 1 if the pattern should interchange the operands.\n+\n+   CMPBR_FLAG is true if this is for a compare-and-branch insn.\n+   OP1 and OP2 are the two source operands of a 3 operand insn.  */\n+\n+int\n+i960_bypass (insn, op1, op2, cmpbr_flag)\n+     register rtx insn, op1, op2;\n+     int cmpbr_flag;\n+{\n+  register rtx prev_insn, prev_dest;\n+\n+  if (TARGET_C_SERIES)\n+    return 0;\n+\n+  /* Can't do this if op1 isn't a register.  */\n+  if (! REG_P (op1))\n+    return 0;\n+\n+  /* Can't do this for a compare-and-branch if both ops aren't regs.  */\n+  if (cmpbr_flag && ! REG_P (op2))\n+    return 0;\n+\n+  prev_insn = prev_real_insn (insn);\n+\n+  if (prev_insn && GET_CODE (prev_insn) == INSN\n+      && GET_CODE (PATTERN (prev_insn)) == SET)\n+    {\n+      prev_dest = SET_DEST (PATTERN (prev_insn));\n+      if ((GET_CODE (prev_dest) == REG && REGNO (prev_dest) == REGNO (op1))\n+\t  || (GET_CODE (prev_dest) == SUBREG\n+\t      && GET_CODE (SUBREG_REG (prev_dest)) == REG\n+\t      && REGNO (SUBREG_REG (prev_dest)) == REGNO (op1)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\f\n+/* Output the code which declares the function name.  This also handles\n+   leaf routines, which have special requirements, and initializes some\n+   global variables.  */\n+\n+void\n+i960_function_name_declare (file, name, fndecl)\n+     FILE *file;\n+     char *name;\n+     tree fndecl;\n+{\n+  register int i, j;\n+  int leaf_proc_ok;\n+  rtx insn;\n+\n+  /* Increment global return label.  */\n+\n+  ret_label++;\n+\n+  /* Compute whether tail calls and leaf routine optimizations can be performed\n+     for this function.  */\n+\n+  if (TARGET_TAILCALL)\n+    tail_call_ok = 1;\n+  else\n+    tail_call_ok = 0;\n+\n+  if (TARGET_LEAFPROC)\n+    leaf_proc_ok = 1;\n+  else\n+    leaf_proc_ok = 0;\n+\n+  /* Even if nobody uses extra parms, can't have leafroc or tail calls if\n+     argblock, because argblock uses g14 implicitly.  */\n+\n+  if (current_function_args_size > 48)\n+    {\n+      tail_call_ok = 0;\n+      leaf_proc_ok = 0;\n+    }\n+      \n+  /* See if caller passes in an address to return value. */\n+\n+  if (aggregate_value_p (DECL_RESULT (fndecl)))\n+    {\n+      tail_call_ok = 0;\n+      leaf_proc_ok = 0;\n+    }\n+\n+  /* Can not use tail calls or make this a leaf routine if there is a non\n+     zero frame size.  */\n+\n+  if (get_frame_size () != 0)\n+    leaf_proc_ok = 0;\n+\n+  /* I don't understand this condition, and do not think that it is correct.\n+     Apparently this is just checking whether the frame pointer is used, and\n+     we can't trust regs_ever_live[fp] since it is (almost?) always set.  */\n+\n+  if (tail_call_ok)\n+    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      if (GET_CODE (insn) == INSN\n+\t  && reg_mentioned_p (frame_pointer_rtx, insn))\n+\t{\n+\t  tail_call_ok = 0;\n+\t  break;\n+\t}\n+\n+  /* Check for CALL insns.  Can not be a leaf routine if there are any.  */\n+\n+  if (leaf_proc_ok)\n+    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  leaf_proc_ok = 0;\n+\t  break;\n+\t}\n+\n+  /* Can not be a leaf routine if any non-call clobbered registers are\n+     used in this function.  */\n+\n+  if (leaf_proc_ok)\n+    for (i = 0, j = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+      if (regs_ever_live[i]\n+\t  && ((! call_used_regs[i]) || (i > 7 && i < 12)))\n+\t{\n+\t  /* Global registers.  */\n+\t  if (i < 16 && i > 7 && i != 13)\n+\t    leaf_proc_ok = 0;\n+\t  /* Local registers.  */\n+\t  else if (i < 32)\n+\t    leaf_proc_ok = 0;\n+\t}\n+\n+  /* Now choose a leaf return register, if we can find one, and if it is\n+     OK for this to be a leaf routine.  */\n+\n+  i960_leaf_ret_reg = -1;\n+\n+  if (optimize && leaf_proc_ok)\n+    {\n+      for (i960_leaf_ret_reg = -1, i = 0; i < 8; i++)\n+\tif (regs_ever_live[i] == 0)\n+\t  {\n+\t    i960_leaf_ret_reg = i;\n+\t    regs_ever_live[i] = 1;\n+\t    break;\n+\t  }\n+    }\n+\n+  /* Do this after choosing the leaf return register, so it will be listed\n+     if one was chosen.  */\n+\n+  fprintf (file, \"\\t#  Function '%s'\\n\", name);\n+  fprintf (file, \"\\t#  Registers used: \");\n+\n+  for (i = 0, j = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i])\n+\t{\n+\t  fprintf (file, \"%s%s \", reg_names[i], call_used_regs[i] ? \"\" : \"*\");\n+\n+\t  if (i > 15 && j == 0)\n+\t    {\n+\t      fprintf (file,\"\\n\\t#\\t\\t   \");\n+\t      j++;\n+            }\n+        }\n+    }\n+\n+  fprintf (file, \"\\n\");\n+\n+  if (i960_leaf_ret_reg >= 0)\n+    {\n+      /* Make it a leaf procedure.  */\n+\n+      if (TREE_PUBLIC (fndecl))\n+\tfprintf (file,\"\\t.globl    %s.lf\\n\", name);\n+\n+      fprintf (file, \"\\t.leafproc\\t_%s,%s.lf\\n\", name, name);\n+      fprintf (file, \"_%s:\\n\", name);\n+      fprintf (file, \"\\tlda    LR%d,g14\\n\", ret_label);\n+      fprintf (file, \"%s.lf:\\n\", name);\n+      fprintf (file, \"\\tmov    g14,g%d\\n\", i960_leaf_ret_reg);\n+\n+      if (TARGET_C_SERIES)\n+\t{\n+\t  fprintf (file, \"\\tlda    0,g14\\n\");\n+\t  i960_last_insn_type = I_TYPE_MEM;\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tmov    0,g14\\n\");\n+\t  i960_last_insn_type = I_TYPE_REG;\n+\t}\n+    }\n+  else\n+    {\n+      ASM_OUTPUT_LABEL (file, name);\n+      i960_last_insn_type = I_TYPE_CTRL; \n+    }\n+}\n+\f\n+/* Compute and return the frame size.  */\n+\n+int\n+compute_frame_size (size)\n+     int size;\n+{\n+  int actual_fsize;\n+  int outgoing_args_size\n+    = current_function_outgoing_args_size + current_function_pretend_args_size;\n+\n+  /* The STARTING_FRAME_OFFSET is totally hidden to us as far\n+     as size is concerned.  */\n+  actual_fsize = (size + 15) & -16;\n+  actual_fsize += (outgoing_args_size + 15) & -16;\n+\n+  return actual_fsize;\n+}\n+\n+/* Output code for the function prologue.  */\n+\n+void\n+i960_function_prologue (file, size)\n+     FILE *file;\n+     unsigned int size;\n+{\n+  register int i, j, nr;\n+  int n_iregs = 0;\n+  int rsize = 0;\n+  int actual_fsize;\n+  char tmpstr[1000];\n+  /* -1 if reg must be saved on proc entry, 0 if available, 1 if saved\n+     somewhere.  */\n+  int regs[FIRST_PSEUDO_REGISTER];\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regs_ever_live[i]\n+\t&& ((! call_used_regs[i]) || (i > 7 && i < 12)))\n+      {\n+\tregs[i] = -1;\n+        /* Count global registers that need saving.  */\n+\tif (i < 16)\n+\t  n_iregs++;\n+      }\n+    else\n+      regs[i] = 0;\n+\n+  epilogue_string[0] = '\\0';\n+\n+  /* First look for local registers to save globals in.  */\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (regs[i] == 0)\n+\tcontinue;\n+\n+      /* Start at r4, not r3.  */\n+      for (j = 20; j < 32; j++)\n+\t{\n+\t  if (regs[j] != 0)\n+\t    continue;\n+\n+\t  regs[i] = 1;\n+\t  regs[j] = -1;\n+\t  regs_ever_live[j] = 1;\n+\t  nr = 1;\n+\t  if (i <= 14 && i % 2 == 0 && j <= 30 && j % 2 == 0\n+\t      && regs[i+1] != 0 && regs[j+1] == 0)\n+\t    {\n+\t      nr = 2;\n+\t      regs[i+1] = 1;\n+\t      regs[j+1] = -1;\n+\t      regs_ever_live[j+1] = 1;\n+\t    }\n+\t  if (nr == 2 && i <= 12 && i % 4 == 0 && j <= 28 && j % 4 == 0\n+\t      && regs[i+2] != 0 && regs[j+2] == 0)\n+\t    {\n+\t      nr = 3;\n+\t      regs[i+2] = 1;\n+\t      regs[j+2] = -1;\n+\t      regs_ever_live[j+2] = 1;\n+\t    }\n+\t  if (nr == 3 && regs[i+3] != 0 && regs[j+3] == 0)\n+\t    {\n+\t      nr = 4;\n+\t      regs[i+3] = 1;\n+\t      regs[j+3] = -1;\n+\t      regs_ever_live[j+3] = 1;\n+\t    }\n+\n+\t  fprintf (file, \"\\tmov%s\t%s,%s\\n\",\n+\t\t   ((nr == 4) ? \"q\" :\n+\t\t    (nr == 3) ? \"t\" :\n+\t\t    (nr == 2) ? \"l\" : \"\"),\n+\t\t   reg_names[i], reg_names[j]);\n+\t  sprintf (tmpstr, \"\\tmov%s\t%s,%s\\n\",\n+\t\t   ((nr == 4) ? \"q\" :\n+\t\t    (nr == 3) ? \"t\" :\n+\t\t    (nr == 2) ? \"l\" : \"\"),\n+\t\t   reg_names[j], reg_names[i]);\n+\t  strcat (epilogue_string, tmpstr);\n+\n+\t  n_iregs -= nr;\n+\t  i += nr-1;\n+\t  break;\n+\t}\n+    }\n+\n+  /* N_iregs is now the number of global registers that haven't been saved\n+     yet.  */\n+\n+  rsize = (n_iregs * 4);\n+  actual_fsize = compute_frame_size (size) + rsize;\n+#if 0\n+  /* ??? The 1.2.1 compiler does this also.  This is meant to round the frame\n+     size up to the nearest multiple of 16.  I don't know whether this is\n+     necessary, or even desirable.  */\n+  actual_fsize = (actual_fsize + 15) & ~0xF;\n+#endif\n+\n+  /* Allocate space for register save and locals.  */\n+  if (actual_fsize > 0)\n+    {\n+      if (actual_fsize < 32)\n+\tfprintf (file, \"\\taddo\t%d,sp,sp\\n\", actual_fsize);\n+      else\n+\tfprintf (file, \"\\tlda\\t%d(sp),sp\\n\", actual_fsize);\n+    }\n+  \n+  /* Save registers on stack if needed.  */\n+  for (i = 0, j = n_iregs; j > 0 && i < 16; i++)\n+    {\n+      if (regs[i] != -1)\n+\tcontinue;\n+\n+      nr = 1;\n+\n+      if (i <= 14 && i % 2 == 0 && regs[i+1] == -1)\n+\tnr = 2;\n+\n+      if (nr == 2 && i <= 12 && i % 4 == 0 && regs[i+2] == -1)\n+\tnr = 3;\n+\n+      if (nr == 3 && regs[i+3] == -1)\n+\tnr = 4;\n+\n+      fprintf (file,\"\\tst%s\t%s,%d(fp)\\n\",\n+\t       ((nr == 4) ? \"q\" :\n+\t\t(nr == 3) ? \"t\" :\n+\t\t(nr == 2) ? \"l\" : \"\"),\n+\t       reg_names[i], size+(nr*4));\n+      sprintf (tmpstr,\"\\tld%s\t%d(fp),%s\\n\",\n+\t       ((nr == 4) ? \"q\" :\n+\t\t(nr == 3) ? \"t\" :\n+\t\t(nr == 2) ? \"l\" : \"\"),\n+\t       size+(nr*4), reg_names[i]);\n+      strcat (epilogue_string, tmpstr);\n+      i += nr-1;\n+      j -= nr;\n+    }\n+\n+  if (actual_fsize == 0 && size == 0 && rsize == 0)\n+    return;\n+\n+  fprintf (file, \"\\t#Prologue stats:\\n\");\n+  fprintf (file, \"\\t#  Total Frame Size: %d bytes\\n\", actual_fsize);\n+\n+  if (size)\n+    fprintf (file, \"\\t#  Local Variable Size: %d bytes\\n\", size);\n+  if (rsize)\n+    fprintf (file, \"\\t#  Register Save Size: %d regs, %d bytes\\n\",\n+\t     n_iregs, rsize);\n+  fprintf (file, \"\\t#End Prologue#\\n\");\n+}\n+\n+/* Output code for the function epilogue.  */\n+\n+void\n+i960_function_epilogue (file, size)\n+     FILE *file;\n+     unsigned int size;\n+{\n+  if (i960_leaf_ret_reg >= 0)\n+    {\n+      fprintf (file, \"LR%d:\tret\\n\", ret_label);\n+      return;\n+    }\n+\n+  if (*epilogue_string == 0)\n+    {\n+      register rtx tmp;\n+\t\n+      /* Emit a return insn, but only if control can fall through to here.  */\n+\n+      tmp = get_last_insn ();\n+      while (tmp)\n+\t{\n+\t  if (GET_CODE (tmp) == BARRIER)\n+\t    return;\n+\t  if (GET_CODE (tmp) == CODE_LABEL)\n+\t    break;\n+\t  if (GET_CODE (tmp) == JUMP_INSN)\n+\t    {\n+\t      if (GET_CODE (PATTERN (tmp)) == RETURN)\n+\t\treturn;\n+\t      break;\n+\t    }\n+\t  if (GET_CODE (tmp) == NOTE)\n+\t    {\n+\t      tmp = PREV_INSN (tmp);\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+      fprintf (file, \"LR%d:\tret\\n\", ret_label);\n+      return;\n+    }\n+\n+  fprintf (file, \"LR%d:\\n\", ret_label);\n+\n+  fprintf (file, \"\\t#EPILOGUE#\\n\");\n+\n+  /* Output the string created by the prologue which will restore all\n+     registers saved by the prologue.  */\n+\n+  if (epilogue_string[0] != '\\0')\n+    fprintf (file, \"%s\", epilogue_string);\n+\n+  /* Must clear g14 on return.  */\n+\n+  if (current_function_args_size > 48)\n+    fprintf (file, \"\\tmov\t0,g14\\n\");\n+\n+  fprintf (file, \"\\tret\\n\");\n+  fprintf (file, \"\\t#End Epilogue#\\n\");\n+}\n+\n+/* Output code for a call insn.  */\n+\n+char *\n+i960_output_call_insn (target, argsize_rtx, insn)\n+     register rtx target, argsize_rtx, insn;\n+{\n+  int non_indirect;\n+  int argsize = INTVAL (argsize_rtx);\n+  rtx nexti = next_real_insn (insn);\n+  rtx operands[1];\n+\n+  operands[0] = target;\n+\n+  non_indirect = ((GET_CODE (target) == MEM)\n+\t\t  && (GET_CODE (XEXP (target, 0)) == SYMBOL_REF));\n+\n+  /* Nexti could be zero if the called routine is volatile.  */\n+  if (optimize && (*epilogue_string == 0) && argsize == 0 && tail_call_ok \n+      && (nexti == 0 || GET_CODE (PATTERN (nexti)) == RETURN))\n+    {\n+      /* Delete following return insn.  */\n+      if (nexti && no_labels_between_p (insn, nexti))\n+\tdelete_insn (nexti);\n+      output_asm_insn (non_indirect ? \"b\t %0\" : \"bx\t %0\",\n+\t\t       operands);\n+      return \"# notreached\";\n+    }\n+\n+  output_asm_insn (non_indirect ? \"callj\t%0\" : \"callx\t%0\", operands);\n+  return \"\";\n+}\n+\n+/* Output code for a return insn.  */\n+\n+char *\n+i960_output_ret_insn (insn)\n+     register rtx insn;\n+{\n+  static char lbuf[20];\n+  \n+  if (*epilogue_string != 0)\n+    {\n+      if (! TARGET_CODE_ALIGN && next_real_insn (insn) == 0)\n+\treturn \"\";\n+\n+      sprintf (lbuf, \"b\tLR%d\", ret_label);\n+      return lbuf;\n+    }\n+\n+  if (current_function_args_size > 48)\n+    output_asm_insn (\"mov\t0,g14\", 0);\n+\n+  if (i960_leaf_ret_reg >= 0)\n+    {\n+      sprintf (lbuf, \"bx\t(%s)\", reg_names[i960_leaf_ret_reg]);\n+      return lbuf;\n+    }\n+  return \"ret\";\n+}\n+\f\n+#if 0\n+/* Return a character string representing the branch prediction\n+   opcode to be tacked on an instruction.  This must at least\n+   return a null string.  */\n+\n+char *\n+i960_br_predict_opcode (lab_ref, insn)\n+     rtx lab_ref, insn;\n+{\n+  if (TARGET_BRANCH_PREDICT)\n+    {\n+      unsigned long label_uid;\n+      \n+      if (GET_CODE (lab_ref) == CODE_LABEL)\n+\tlabel_uid = INSN_UID (lab_ref);\n+      else if (GET_CODE (lab_ref) == LABEL_REF)\n+\tlabel_uid = INSN_UID (XEXP (lab_ref, 0));\n+      else\n+\treturn \".f\";\n+\n+      /* If not optimizing, then the insn_addresses array will not be\n+\t valid.  In this case, always return \".t\" since most branches\n+\t are taken.  If optimizing, return .t for backward branches\n+\t and .f for forward branches.  */\n+      if (! optimize\n+\t  || insn_addresses[label_uid] < insn_addresses[INSN_UID (insn)])\n+\treturn \".t\";\n+      return \".f\";\n+    }\n+    \n+  return \"\";\n+}\n+#endif\n+\n+/* Print the operand represented by rtx X formatted by code CODE.  */\n+\n+void\n+i960_print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     char code;\n+{\n+  enum rtx_code rtxcode = GET_CODE (x);\n+\n+  if (rtxcode == REG)\n+    {\n+      switch (code)\n+\t{\n+\tcase 'D':\n+\t  /* Second reg of a double.  */\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)+1]);\n+\t  break;\n+\n+\tcase 0:\n+\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      return;\n+    }\n+  else if (rtxcode == MEM)\n+    {\n+      output_address (XEXP (x, 0));\n+      return;\n+    }\n+  else if (rtxcode == CONST_INT)\n+    {\n+      if (INTVAL (x) > 9999 || INTVAL (x) < -999)\n+\tfprintf (file, \"0x%x\", INTVAL (x));\n+      else\n+\tfprintf (file, \"%d\", INTVAL (x));\n+      return;\n+    }\n+  else if (rtxcode == CONST_DOUBLE)\n+    {\n+      double d;\n+\n+      if (x == CONST0_RTX (DFmode) || x == CONST0_RTX (SFmode))\n+\t{\n+\t  fprintf (file, \"0f0.0\");\n+\t  return;\n+\t}\n+      else if (x == CONST1_RTX (DFmode) || x == CONST1_RTX (SFmode))\n+\t{\n+\t  fprintf (file, \"0f1.0\");\n+\t  return;\n+\t}\n+\n+      /* This better be a comment.  */\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+      fprintf (file, \"%#g\", d);\n+      return;\n+    }\n+\n+  switch(code)\n+    {\n+    case 'B':\n+      /* Branch or jump, depending on assembler.  */\n+      if (TARGET_ASM_COMPAT)\n+\tfputs (\"j\", file);\n+      else\n+\tfputs (\"b\", file);\n+      break;\n+\n+    case 'S':\n+      /* Sign of condition.  */\n+      if ((rtxcode == EQ) || (rtxcode == NE) || (rtxcode == GTU)\n+\t  || (rtxcode == LTU) || (rtxcode == GEU) || (rtxcode == LEU))\n+\tfputs (\"o\", file);\n+      else if ((rtxcode == GT) || (rtxcode == LT)\n+\t  || (rtxcode == GE) || (rtxcode == LE))\n+\tfputs (\"i\", file);\n+      else\n+\tabort();\n+      break;\n+\n+    case 'I':\n+      /* Inverted condition.  */\n+      rtxcode = reverse_condition (rtxcode);\n+      goto normal;\n+\n+    case 'X':\n+      /* Inverted condition w/ reversed operands.  */\n+      rtxcode = reverse_condition (rtxcode);\n+      /* Fallthrough.  */\n+\n+    case 'R':\n+      /* Reversed operand condition.  */\n+      rtxcode = swap_condition (rtxcode);\n+      /* Fallthrough.  */\n+\n+    case 'C':\n+      /* Normal condition.  */\n+    normal:\n+      if (rtxcode == EQ)  { fputs (\"e\", file); return; }\n+      else if (rtxcode == NE)  { fputs (\"ne\", file); return; }\n+      else if (rtxcode == GT)  { fputs (\"g\", file); return; }\n+      else if (rtxcode == GTU) { fputs (\"g\", file); return; }\n+      else if (rtxcode == LT)  { fputs (\"l\", file); return; }\n+      else if (rtxcode == LTU) { fputs (\"l\", file); return; }\n+      else if (rtxcode == GE)  { fputs (\"ge\", file); return; }\n+      else if (rtxcode == GEU) { fputs (\"ge\", file); return; }\n+      else if (rtxcode == LE)  { fputs (\"le\", file); return; }\n+      else if (rtxcode == LEU) { fputs (\"le\", file); return; }\n+      else abort ();\n+      break;\n+\n+    case 0:\n+      output_addr_const (file, x);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return;\n+}\n+\f\n+/* Print a memory address as an operand to reference that memory location.\n+\n+   This is exactly the same as legitimate_address_p, except that it the prints\n+   addresses instead of recognizing them.  */\n+\n+void\n+i960_print_operand_addr (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  rtx breg, ireg;\n+  rtx scale, offset;\n+\n+  ireg = 0;\n+  breg = 0;\n+  offset = 0;\n+  scale = const1_rtx;\n+\n+  if (GET_CODE (addr) == REG)\n+    breg = addr;\n+  else if (CONSTANT_P (addr))\n+    offset = addr;\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx op0, op1;\n+\n+      op0 = XEXP (addr, 0);\n+      op1 = XEXP (addr, 1);\n+\n+      if (GET_CODE (op0) == REG)\n+\t{\n+\t  breg = op0;\n+\t  if (GET_CODE (op1) == REG)\n+\t    ireg = op1;\n+\t  else if (CONSTANT_P (op1))\n+\t    offset = op1;\n+\t  else\n+\t    abort ();\n+\t}\n+      else if (GET_CODE (op0) == PLUS)\n+\t{\n+\t  if (GET_CODE (XEXP (op0, 0)) == MULT)\n+\t    {\n+\t      ireg = XEXP (XEXP (op0, 0), 0);\n+\t      scale = XEXP (XEXP (op0, 0), 1);\n+\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n+\t\t{\n+\t\t  breg = XEXP (op0, 1);\n+\t\t  offset = op1;\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t  else if (GET_CODE (XEXP (op0, 0)) == REG)\n+\t    {\n+\t      breg = XEXP (op0, 0);\n+\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n+\t\t{\n+\t\t  ireg = XEXP (op0, 1);\n+\t\t  offset = op1;\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      else if (GET_CODE (op0) == MULT)\n+\t{\n+\t  ireg = XEXP (op0, 0);\n+\t  scale = XEXP (op0, 1);\n+\t  if (GET_CODE (op1) == REG)\n+\t    breg = op1;\n+\t  else if (CONSTANT_P (op1))\n+\t    offset = op1;\n+\t  else\n+\t    abort ();\n+\t}\n+      else\n+\tabort ();\n+    }\n+  else if (GET_CODE (addr) == MULT)\n+    {\n+      breg = XEXP (addr, 0);\n+      scale = XEXP (addr, 1);\n+    }\n+  else\n+    abort ();\n+\n+  if (offset)\n+    output_addr_const (file, offset);\n+  if (breg)\n+    fprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n+  if (ireg)\n+    fprintf (file, \"[%s*%d]\", reg_names[REGNO (ireg)], INTVAL (scale));\n+}\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+\tOn 80960, legitimate addresses are:\n+\t\tbase\t\t\t\tld\t(g0),r0\n+\t\tdisp\t(12 or 32 bit)\t\tld\tfoo,r0\n+\t\tbase + index\t\t\tld\t(g0)[g1*1],r0\n+\t\tbase + displ\t\t\tld\t0xf00(g0),r0\n+\t\tbase + index*scale + displ\tld\t0xf00(g0)[g1*4],r0\n+\t\tindex*scale + base\t\tld\t(g0)[g1*4],r0\n+\t\tindex*scale + displ\t\tld\t0xf00[g1*4],r0\n+\t\tindex*scale\t\t\tld\t[g1*4],r0\n+\t\tindex + base + displ\t\tld\t0xf00(g0)[g1*1],r0\n+\n+\tIn each case, scale can be 1, 2, 4, 8, or 16.  */\n+\n+/* This is exactly the same as i960_print_operand_addr, except that\n+   it recognizes addresses instead of printing them.\n+\n+   It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should\n+   convert common non-canonical forms to canonical form so that they will\n+   be recognized.  */\n+\n+int\n+legitimate_address_p (mode, addr, strict)\n+     enum machine_mode mode;\n+     register rtx addr;\n+     int strict;\n+{\n+  if (GET_CODE (addr) == REG)\n+    return (strict ? REG_OK_FOR_BASE_P_STRICT (addr)\n+\t    : REG_OK_FOR_BASE_P (addr));\n+  else if (CONSTANT_P (addr))\n+    return 1;\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      rtx op0, op1;\n+\n+      if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n+\treturn 0;\n+\n+      op0 = XEXP (addr, 0);\n+      op1 = XEXP (addr, 1);\n+\n+      if (GET_CODE (op0) == REG)\n+\t{\n+\t  if (! (strict ? REG_OK_FOR_BASE_P_STRICT (op0)\n+\t\t : REG_OK_FOR_BASE_P (op0)))\n+\t    return 0;\n+\n+\t  if (GET_CODE (op1) == REG)\n+\t    return (strict ? REG_OK_FOR_INDEX_P_STRICT (op1)\n+\t\t    : REG_OK_FOR_INDEX_P (op1));\n+\t  else if (CONSTANT_P (op1))\n+\t    return 1;\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (GET_CODE (op0) == PLUS)\n+\t{\n+\t  if (GET_CODE (XEXP (op0, 0)) == MULT)\n+\t    {\n+\t      if (! (GET_CODE (XEXP (XEXP (op0, 0), 0)) == REG\n+\t\t     && (strict ? REG_OK_FOR_INDEX_P_STRICT (XEXP (XEXP (op0, 0), 0))\n+\t\t\t : REG_OK_FOR_INDEX_P (XEXP (XEXP (op0, 0), 0)))\n+\t\t     && SCALE_TERM_P (XEXP (XEXP (op0, 0), 1))))\n+\t\treturn 0;\n+\n+\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n+\t\treturn ((strict ? REG_OK_FOR_BASE_P_STRICT (XEXP (op0, 1))\n+\t\t\t : REG_OK_FOR_BASE_P (XEXP (op0, 1)))\n+\t\t\t&& CONSTANT_P (op1));\n+\t      else\n+\t\treturn 0;\n+\t    }\n+\t  else if (GET_CODE (XEXP (op0, 0)) == REG)\n+\t    {\n+\t      if (! (strict ? REG_OK_FOR_BASE_P_STRICT (XEXP (op0, 0))\n+\t\t     : REG_OK_FOR_BASE_P (XEXP (op0, 0))))\n+\t\treturn 0;\n+\n+\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n+\t\treturn ((strict ? REG_OK_FOR_INDEX_P_STRICT (XEXP (op0, 1))\n+\t\t\t : REG_OK_FOR_INDEX_P (XEXP (op0, 1)))\n+\t\t\t&& CONSTANT_P (op1));\n+\t      else\n+\t\treturn 0;\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (GET_CODE (op0) == MULT)\n+\t{\n+\t  if (! (GET_CODE (XEXP (op0, 0)) == REG\n+\t\t && (strict ? REG_OK_FOR_INDEX_P_STRICT (XEXP (op0, 0))\n+\t\t     : REG_OK_FOR_INDEX_P (XEXP (op0, 0)))\n+\t\t && SCALE_TERM_P (XEXP (op0, 1))))\n+\t    return 0;\n+\n+\t  if (GET_CODE (op1) == REG)\n+\t    return (strict ? REG_OK_FOR_BASE_P_STRICT (op1)\n+\t\t    : REG_OK_FOR_BASE_P (op1));\n+\t  else if (CONSTANT_P (op1))\n+\t    return 1;\n+\t  else\n+\t    return 0;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+  else if (GET_CODE (addr) == MULT)\n+    {\n+      if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n+\treturn 0;\n+\n+      return (GET_CODE (XEXP (addr, 0)) == REG\n+\t      && (strict ? REG_OK_FOR_INDEX_P_STRICT (XEXP (addr, 0))\n+\t\t  : REG_OK_FOR_INDEX_P (XEXP (addr, 0)))\n+\t      && SCALE_TERM_P (XEXP (addr, 1)));\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   This converts some non-canonical addresses to canonical form so they\n+   can be recognized.  */\n+\n+rtx\n+legitimize_address (x, oldx, mode)\n+     register rtx x;\n+     register rtx oldx;\n+     enum machine_mode mode;\n+{ \n+  if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      abort ();\n+      x = copy_to_reg (x);\n+    }\n+\n+  if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n+    return x;\n+\n+  /* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const)))\n+     into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be\n+     created by virtual register instantiation, register elimination, and\n+     similar optimizations.  */\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n+      && GET_CODE (XEXP (x, 1)) == PLUS)\n+    x = gen_rtx (PLUS, Pmode,\n+\t\t gen_rtx (PLUS, Pmode, XEXP (x, 0), XEXP (XEXP (x, 1), 0)),\n+\t\t XEXP (XEXP (x, 1), 1));\n+\n+  /* Canonicalize (plus (plus (mult (reg) (const)) (plus (reg) (const))) const)\n+     into (plus (plus (mult (reg) (const)) (reg)) (const)).  */\n+  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == PLUS\n+\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n+\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == PLUS\n+\t   && CONSTANT_P (XEXP (x, 1)))\n+    {\n+      rtx constant, other;\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  constant = XEXP (x, 1);\n+\t  other = XEXP (XEXP (XEXP (x, 0), 1), 1);\n+\t}\n+      else if (GET_CODE (XEXP (XEXP (XEXP (x, 0), 1), 1)) == CONST_INT)\n+\t{\n+\t  constant = XEXP (XEXP (XEXP (x, 0), 1), 1);\n+\t  other = XEXP (x, 1);\n+\t}\n+      else\n+\tconstant = 0;\n+\n+      if (constant)\n+\tx = gen_rtx (PLUS, Pmode,\n+\t\t     gen_rtx (PLUS, Pmode, XEXP (XEXP (x, 0), 0),\n+\t\t\t      XEXP (XEXP (XEXP (x, 0), 1), 0)),\n+\t\t     plus_constant (other, INTVAL (constant)));\n+    }\n+\n+  return x;\n+}\n+\f\n+#if 0\n+/* Return the most stringent alignment that we are willing to consider\n+   objects of size SIZE and known alignment ALIGN as having. */\n+   \n+int\n+i960_alignment (size, align)\n+     int size;\n+     int align;\n+{\n+  int i;\n+\n+  if (! TARGET_STRICT_ALIGN)\n+    if (TARGET_IC_COMPAT2_0 || align >= 4)\n+      {\n+\ti = i960_object_bytes_bitalign (size) / BITS_PER_UNIT;\n+\tif (i > align)\n+\t  align = i;\n+      }\n+\n+  return align;\n+}\n+#endif\n+\f\n+/* Modes for condition codes.  */\n+#define C_MODES\t\t\\\n+  ((1 << (int) CCmode) | (1 << (int) CC_UNSmode) | (1<< (int) CC_CHKmode))\n+\n+/* Modes for single-word (and smaller) quantities.  */\n+#define S_MODES\t\t\t\t\t\t\\\n+ (~C_MODES\t\t\t\t\t\t\\\n+  & ~ ((1 << (int) DImode) | (1 << (int) TImode)\t\\\n+       | (1 << (int) DFmode) | (1 << (int) TFmode)))\n+\n+/* Modes for double-word (and smaller) quantities.  */\n+#define D_MODES\t\t\t\t\t\\\n+  (~C_MODES\t\t\t\t\t\\\n+   & ~ ((1 << (int) TImode) | (1 << (int) TFmode)))\n+\n+/* Modes for quad-word quantities.  */\n+#define T_MODES (~C_MODES)\n+\n+/* Modes for single-float quantities.  */\n+#define SF_MODES ((1 << (int) SFmode))\n+\n+/* Modes for double-float quantities.  */\n+#define DF_MODES (SF_MODES | (1 << (int) DFmode) | (1 << (int) SCmode))\n+\n+/* Modes for quad-float quantities.  */\n+#define TF_MODES (DF_MODES | (1 << (int) TFmode) | (1 << (int) DCmode))\n+\n+short hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] = {\n+  T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n+  T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n+  T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n+  T_MODES, S_MODES, D_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n+\n+  TF_MODES, TF_MODES, TF_MODES, TF_MODES, C_MODES};\n+\n+\f\n+/* Return the minimum alignment of an expression rtx X in bytes.  This takes\n+   advantage of machine specific facts, such as knowing that the frame pointer\n+   is always 16 byte aligned.  */\n+\n+int\n+i960_expr_alignment (x, size)\n+     rtx x;\n+     int size;\n+{\n+  int align = 1;\n+\n+  if (x == 0)\n+    return 1;\n+\n+  switch (GET_CODE(x))\n+    {\n+    case CONST_INT:\n+      align = INTVAL(x);\n+\n+      if ((align & 0xf) == 0)\n+\talign = 16;\n+      else if ((align & 0x7) == 0)\n+\talign = 8;\n+      else if ((align & 0x3) == 0)\n+\talign = 4;\n+      else if ((align & 0x1) == 0)\n+\talign = 2;\n+      else\n+\talign = 1;\n+      break;\n+\n+    case PLUS:\n+      align = MIN (i960_expr_alignment (XEXP (x, 0), size),\n+\t\t   i960_expr_alignment (XEXP (x, 1), size));\n+      break;\n+\n+    case SYMBOL_REF:\n+      /* If this is a valid program, objects are guaranteed to be\n+\t correctly aligned for whatever size the reference actually is. */\n+      align = i960_object_bytes_bitalign (size) / BITS_PER_UNIT;\n+      break;\n+\n+    case REG:\n+      if (REGNO (x) == FRAME_POINTER_REGNUM)\n+\talign = 16;\n+      break;\n+\n+    case ASHIFT:\n+    case LSHIFT:\n+      align = i960_expr_alignment (XEXP (x, 0));\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  align = align << INTVAL (XEXP (x, 1));\n+\t  align = MIN (align, 16);\n+\t}\n+      break;\n+\n+    case MULT:\n+      align = (i960_expr_alignment (XEXP (x, 0), size) *\n+\t       i960_expr_alignment (XEXP (x, 1), size));\n+\n+      align = MIN (align, 16);\n+      break;\n+    }\n+\n+  return align;\n+}\n+\n+/* Return true if it is possible to reference both BASE and OFFSET, which\n+   have alignment at least as great as 4 byte, as if they had alignment valid\n+   for an object of size SIZE.  */\n+\n+int\n+i960_improve_align (base, offset, size)\n+     rtx base;\n+     rtx offset;\n+     int size;\n+{\n+  int i, j;\n+\n+  /* We have at least a word reference to the object, so we know it has to\n+     be aligned at least to 4 bytes.  */\n+\n+  i = MIN (i960_expr_alignment (base, 4),\n+\t   i960_expr_alignment (offset, 4));\n+\n+  i = MAX (i, 4);\n+\n+  /* We know the size of the request.  If strict align is not enabled, we\n+     can guess that the alignment is OK for the requested size.  */\n+\n+  if (! TARGET_STRICT_ALIGN)\n+    if ((j = (i960_object_bytes_bitalign (size) / BITS_PER_UNIT)) > i)\n+      i = j;\n+\n+  return (i >= size);\n+}\n+\n+/* Return true if it is possible to access BASE and OFFSET, which have 4 byte\n+   (SImode) alignment as if they had 16 byte (TImode) alignment.  */\n+\n+int\n+i960_si_ti (base, offset)\n+     rtx base;\n+     rtx offset;\n+{\n+  return i960_improve_align (base, offset, 16);\n+}\n+\n+/* Return true if it is possible to access BASE and OFFSET, which have 4 byte\n+   (SImode) alignment as if they had 8 byte (DImode) alignment.  */\n+\n+int\n+i960_si_di (base, offset)\n+     rtx base;\n+     rtx offset;\n+{\n+  return i960_improve_align (base, offset, 8);\n+}\n+\f\n+/* Return raw values of size and alignment (in words) for the data\n+   type being accessed.  These values will be rounded by the caller.  */\n+\n+static void \n+i960_arg_size_and_align (mode, type, size_out, align_out)\n+     enum machine_mode mode;\n+     tree type;\n+     int *size_out;\n+     int *align_out;\n+{\n+  int size, align;\n+\n+  /* Use formal alignment requirements of type being passed, except make\n+     it at least a word.  If we don't have a type, this is a library call,\n+     and the parm has to be of scalar type.  In this case, consider its\n+     formal alignment requirement to be its size in words.  */\n+\n+  if (mode == BLKmode)\n+    size = (int_size_in_bytes (type) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  else if (mode == VOIDmode)\n+    {\n+      /* End of parm list.  */\n+      assert (type != 0 && TYPE_MODE (type) == VOIDmode);\n+      size = 1;\n+    }\n+  else\n+    size = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (type == 0)\n+    align = size;\n+  else if (TYPE_ALIGN (type) >= BITS_PER_WORD)\n+    align = TYPE_ALIGN (type) / BITS_PER_WORD;\n+  else\n+    align = 1;\n+\n+  *size_out  = size;\n+  *align_out = align;\n+}\n+\n+/* On the 80960 the first 12 args are in registers and the rest are pushed.\n+   Any arg that is bigger than 4 words is placed on the stack and all\n+   subsequent arguments are placed on the stack.\n+\n+   Additionally, parameters with an alignment requirement stronger than\n+   a word must be be aligned appropriately.  */\n+\n+/* Update CUM to advance past an argument described by MODE and TYPE.  */\n+\n+void\n+i960_function_arg_advance (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int size, align;\n+\n+  i960_arg_size_and_align (mode, type, &size, &align);\n+\n+  if (named == 0 || size > 4 || cum->ca_nstackparms != 0\n+      || (size + ROUND (cum->ca_nregparms, align)) > NPARM_REGS)\n+    cum->ca_nstackparms = ROUND (cum->ca_nstackparms, align) + size;\n+  else\n+    cum->ca_nregparms = ROUND (cum->ca_nregparms, align) + size;\n+}\n+\n+/* Return the register that the argument described by MODE and TYPE is\n+   passed in, or else return 0 if it is passed on the stack.  */\n+\n+rtx\n+i960_function_arg (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  rtx ret;\n+  int size, align;\n+\n+  i960_arg_size_and_align (mode, type, &size, &align);\n+\n+  if (named == 0 || size > 4 || cum->ca_nstackparms != 0\n+      || (size + ROUND (cum->ca_nregparms, align)) > NPARM_REGS)\n+    {\n+      cum->ca_nstackparms = ROUND (cum->ca_nstackparms, align);\n+      ret = 0;\n+    }\n+  else\n+    {\n+      cum->ca_nregparms = ROUND (cum->ca_nregparms, align);\n+      ret = gen_rtx (REG, mode, cum->ca_nregparms);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Return the rtx for the register representing the return value, or 0\n+   if the return value must be passed through the stack.  */\n+\n+rtx\n+i960_function_value (type)\n+     tree type;\n+{\n+  int mode = TYPE_MODE (type);\n+\n+  if (mode == BLKmode)\n+    {\n+      unsigned int size = int_size_in_bytes (type);\n+\n+      if (size <= 16)\n+\tmode = mode_for_size (i960_object_bytes_bitalign (size), MODE_INT, 0);\n+    }\n+\n+  if (mode == BLKmode || mode == VOIDmode)\n+    /* Tell stmt.c and expr.c to pass in address */\n+    return 0;\n+  else\n+    return gen_rtx (REG, mode, 0);\n+}\n+\f\n+/* Floating-point support.  */\n+\n+void\n+i960_output_double (file, value)\n+     FILE *file;\n+     double value;\n+{\n+  if (REAL_VALUE_ISINF (value))\n+    {\n+      fprintf (file, \"\\t.word\t0\\n\");\n+      fprintf (file, \"\\t.word\t0x7ff00000\t# Infinity\\n\");\n+    }\n+  else\n+    fprintf (file, \"\\t.double 0d%.17e\\n\", (value));\n+}\n+\n+void\n+i960_output_float (file, value)\n+     FILE *file;\n+     double value;\n+{\n+  if (REAL_VALUE_ISINF (value))\n+    fprintf (file, \"\\t.word\t0x7f800000\t# Infinity\\n\");\n+  else\n+    fprintf (file, \"\\t.float 0f%.12e\\n\", (value));\n+}\n+\f\n+/* Return the number of bits that an object of size N bytes is aligned to.  */\n+\n+int\n+i960_object_bytes_bitalign (n)\n+     int n;\n+{\n+  if (n > 8)      n = 128;\n+  else if (n > 4) n = 64;\n+  else if (n > 2) n = 32;\n+  else if (n > 1) n = 16;\n+  else            n = 8;\n+\n+  return n;\n+}\n+\n+/* Compute the size of an aggregate type TSIZE.  */\n+\n+tree\n+i960_round_size (tsize)\n+     tree tsize;\n+{\n+  int size, align;\n+\n+  if (TREE_CODE (tsize) != INTEGER_CST)\n+    return tsize;\n+\n+  size = TREE_INT_CST_LOW (tsize);\n+  align = i960_object_bytes_bitalign (size / BITS_PER_UNIT);\n+\n+  /* Handle #pragma align.  */\n+  if (align > i960_maxbitalignment)\n+    align = i960_maxbitalignment;\n+\n+  if (size % align)\n+    size = ((size / align) + 1) * align;\n+\n+  return size_int (size);\n+}\n+\n+/* Compute the alignment for an aggregate type TSIZE.  */\n+\n+int\n+i960_round_align (align, tsize)\n+     int align;\n+     tree tsize;\n+{\n+  if (TREE_CODE (tsize) != INTEGER_CST)\n+    return align;\n+\n+  align = i960_object_bytes_bitalign (TREE_INT_CST_LOW (tsize)\n+\t\t\t\t      / BITS_PER_UNIT);\n+  return align;\n+}\n+\f\n+/* Do any needed setup for a varargs function.  For the i960, we must\n+   create a register paramter block if one doesn't exist, and then copy\n+   all register parameters to memory.  */\n+\n+void\n+i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int *pretend_size;\n+     int no_rtl;\n+{\n+  if (cum->ca_nregparms < NPARM_REGS)\n+    {\n+      int first_reg_offset = cum->ca_nregparms;\n+\n+      if (first_reg_offset > NPARM_REGS)\n+\tfirst_reg_offset = NPARM_REGS;\n+\n+      if (! (no_rtl) && first_reg_offset != NPARM_REGS)\n+\t{\n+\t  rtx label = gen_label_rtx ();\n+\t  emit_insn (gen_cmpsi (arg_pointer_rtx, const0_rtx));\n+\t  emit_jump_insn (gen_bne (label));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx,\n+\t\t\t      stack_pointer_rtx));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, stack_pointer_rtx,\n+\t\t\t      memory_address (SImode,\n+\t\t\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t     48))));\n+\t  emit_label (label);\n+\t  move_block_from_reg\n+\t    (first_reg_offset,\n+\t     gen_rtx (MEM, BLKmode, virtual_incoming_args_rtx),\n+\t     NPARM_REGS - first_reg_offset);\n+\t}\n+      *pretend_size = (NPARM_REGS - first_reg_offset) * UNITS_PER_WORD;\n+    }\n+}\n+\n+/* Calculate the final size of the reg parm stack space for the current\n+   function, based on how many bytes would be allocated on the stack.  */\n+\n+int\n+i960_final_reg_parm_stack_space (const_size, var_size)\n+     int const_size;\n+     tree var_size;\n+{\n+  if (var_size || const_size > 48)\n+    return 48;\n+  else\n+    return 0;\n+}\n+\n+/* Calculate the size of the reg parm stack space.  This is a bit complicated\n+   on the i960.  */\n+\n+int\n+i960_reg_parm_stack_space (fndecl)\n+     tree fndecl;\n+{\n+  /* In this case, we are called from emit_library_call, and we don't need\n+     to pretend we have more space for parameters than what's apparent.  */\n+  if (fndecl == 0)\n+    return 0;\n+\n+  /* In this case, we are called from locate_and_pad_parms when we're\n+     not IN_REGS, so we have an arg block.  */\n+  if (fndecl != current_function_decl)\n+    return 48;\n+\n+  /* Otherwise, we have an arg block if the current function has more than\n+     48 bytes of parameters.  */\n+  if (current_function_args_size > 48)\n+    return 48;\n+  else\n+    return 0;\n+}\n+\f\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+enum reg_class\n+secondary_reload_class (class, mode, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  int regno = -1;\n+\n+  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n+    regno = true_regnum (in);\n+\n+  /* We can place anything into LOCAL_OR_GLOBAL_REGS and can put\n+     LOCAL_OR_GLOBAL_REGS into anything.  */\n+  if (class == LOCAL_OR_GLOBAL_REGS || class == LOCAL_REGS\n+      || class == GLOBAL_REGS || (regno >= 0 && regno < 32))\n+    return NO_REGS;\n+\n+  /* We can place any hard register, 0.0, and 1.0 into FP_REGS.  */\n+  if (class == FP_REGS\n+      && ((regno >= 0 && regno <= FIRST_PSEUDO_REGISTER)\n+\t  || in == CONST0_RTX (mode) || in == CONST1_RTX (mode)))\n+    return NO_REGS;\n+\n+  return LOCAL_OR_GLOBAL_REGS;\n+}\n+\f\n+/* Emit the code necessary for a procedure call.  Return value is needed\n+   after the call if target is non-zero.  */\n+\n+void\n+i960_expand_call (first_operand, second_operand, target)\n+     rtx first_operand, second_operand, target;\n+{\n+  /* Used to ensure that g14_save_reg is initialized once and only once\n+     for each function if it is needed.  */\n+  static char *this_function_name = 0;\n+  int frob_g14 = 0;\n+\n+  if (this_function_name != current_function_name)\n+    {\n+      rtx seq, first;\n+      struct sequence_stack *seq_stack;\n+\n+      this_function_name = current_function_name;\n+\n+      /* If the current function has an argument block, then save g14 into\n+\t a pseudo at the top of the function and restore it after this\n+\t function call.  If the current function has no argument block,\n+\t then g14 is zero before and after the call.  */\n+\n+      if (current_function_args_size > 48)\n+\t{\n+\t  start_sequence ();\n+\t  seq_stack = sequence_stack;\n+\t  while (seq_stack->next)\n+\t    seq_stack = seq_stack->next;\n+\t  first = seq_stack->first;\n+\t  g14_save_reg = copy_to_reg (arg_pointer_rtx);\n+\t  seq = gen_sequence ();\n+\t  end_sequence ();\n+\t  emit_insn_after (seq, first);\n+\t}\n+    }\n+\n+  if (current_function_args_size > 48)\n+    frob_g14 = 1;\n+\n+  if (GET_CODE (second_operand) != CONST_INT || INTVAL (second_operand) > 48)\n+    {\n+      /* Calling a function needing an argument block.  */\n+      emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx,\n+\t\t\t  virtual_outgoing_args_rtx));\n+    }\n+  else\n+    {\n+      /* Calling a normal function -- only set to zero if we know our g14\n+\t is nonzero.  */\n+      if (frob_g14)\n+\temit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx, const0_rtx));\n+    }\n+\n+  if (target)\n+    emit_call_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t     gen_rtx (CALL, VOIDmode, first_operand,\n+\t\t\t\t      second_operand)));\n+  else\n+    emit_call_insn (gen_rtx (CALL, VOIDmode, first_operand, second_operand));\n+\n+  if (frob_g14)\n+    emit_insn (gen_rtx (SET, VOIDmode, arg_pointer_rtx, g14_save_reg));\n+  else if (GET_CODE (second_operand) != CONST_INT\n+\t   || INTVAL (second_operand) > 48)\n+    {\n+      /* Calling a function needing an argument block.  It will have set\n+\t reg14 back to zero before returning, so we must emit a clobber here\n+\t to tell cse that g14 has changed.  */\n+      emit_insn (gen_rtx (CLOBBER, VOIDmode, arg_pointer_rtx));\n+    }\n+}\n+\f\n+/* Look at the opcode P, and set i96_last_insn_type to indicate which\n+   function unit it executed on.  */\n+\n+/* ??? This would make more sense as an attribute.  */\n+\n+void\n+i960_scan_opcode (p)\n+     char *p;\n+{\n+  switch (*p)\n+    {\n+    case 'a':\n+    case 'd':\n+    case 'e':\n+    case 'm':\n+    case 'n':\n+    case 'o':\n+    case 'r':\n+      /* Ret is not actually of type REG, but it won't matter, because no\n+\t insn will ever follow it.  */\n+    case 'u':\n+    case 'x':\n+      i960_last_insn_type = I_TYPE_REG;\n+      break;\n+\n+    case 'b':\n+      if (p[1] == 'x' || p[3] == 'x')\n+        i960_last_insn_type = I_TYPE_MEM;\n+      i960_last_insn_type = I_TYPE_CTRL;\n+      break;\n+\n+    case 'f':\n+    case 't':\n+      i960_last_insn_type = I_TYPE_CTRL;\n+      break;\n+\n+    case 'c':\n+      if (p[1] == 'a')\n+\t{\n+\t  if (p[4] == 'x')\n+\t    i960_last_insn_type = I_TYPE_MEM;\n+\t  else\n+\t    i960_last_insn_type = I_TYPE_CTRL;\n+\t}\n+      else if (p[1] == 'm')\n+\t{\n+\t  if (p[3] == 'd')\n+\t    i960_last_insn_type = I_TYPE_REG;\n+\t  else if (p[4] == 'b' || p[4] == 'j')\n+\t    i960_last_insn_type = I_TYPE_CTRL;\n+\t  else\n+\t    i960_last_insn_type = I_TYPE_REG;\n+\t}\n+      else\n+        i960_last_insn_type = I_TYPE_REG;\n+      break;\n+\n+    case 'l':\n+      i960_last_insn_type = I_TYPE_MEM;\n+      break;\n+\n+    case 's':\n+      if (p[1] == 't')\n+        i960_last_insn_type = I_TYPE_MEM;\n+      else\n+        i960_last_insn_type = I_TYPE_REG;\n+      break;\n+    }\n+}"}, {"sha": "aea4bbb2e2e460544cd9140f5a5dc98d61ef75e9", "filename": "gcc/config/i960/i960.h", "status": "added", "additions": 1470, "deletions": 0, "changes": 1470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=ba8ab3554e47a10bbae41bc75b77fdd01c012345", "patch": "@@ -0,0 +1,1470 @@\n+/* Definitions of target machine for GNU compiler, for Intel 80960\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Steven McGeady, Intel Corp.\n+   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n+   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Note that some other tm.h files may include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#define CPP_PREDEFINES \"-Di960 -Di80960 -DI960 -DI80960\"\n+\n+/* Name to predefine in the preprocessor for processor variations.  */\n+#define\tCPP_SPEC \"%{mic*:-D__i960\\\n+\t\t\t%{mka:-D__i960KA}%{mkb:-D__i960KB}%{mkc:-D__i960KC}\\\n+\t\t\t%{msa:-D__i960SA}%{msb:-D__i960SB}%{msc:-D__i960SC}\\\n+\t\t\t%{mmc:-D__i960MC}\\\n+\t\t\t%{mca:-D__i960CA}%{mcb:-D__i960CB}%{mcc:-D__i960CC}\\\n+\t\t\t%{mcf:-D__i960CF}}\\\n+\t%{mka:-D__i960KA__ -D__i960_KA__}\\\n+\t%{mkb:-D__i960KB__ -D__i960_KB__}\\\n+\t%{mkc:-D__i960KC__ -D__i960_KC__}\\\n+\t%{msa:-D__i960SA__ -D__i960_SA__}\\\n+\t%{msb:-D__i960SB__ -D__i960_SB__}\\\n+\t%{msc:-D__i960SC__ -D__i960_SC__}\\\n+\t%{mmc:-D__i960MC__ -D__i960_MC__}\\\n+\t%{mca:-D__i960CA__ -D__i960_CA__}\\\n+\t%{mcb:-D__i960CB__ -D__i960_CB__}\\\n+\t%{mcc:-D__i960CC__ -D__i960_CC__}\\\n+\t%{mcf:-D__i960CF__ -D__i960_CF__}\\\n+\t%{!mka:%{!mkb:%{!mkc:%{!msa:%{!msb:%{!msc:%{!mmc:%{!mca:%{!mcb:\\\n+\t\t%{!mcc:%{!mcf:-D__i960_KB -D__i960KB__ %{mic*:-D__i960KB}}}}}}}}}}}}\"\n+\n+/* -mic* options make characters signed by default.  */\n+#define SIGNED_CHAR_SPEC  \\\n+  (DEFAULT_SIGNED_CHAR ? \"%{funsigned-char:-D__CHAR_UNSIGNED__}\"\t\\\n+   : \"%{!fsigned-char:%{!mic*:-D__CHAR_UNSIGNED__}}\")\n+\n+/* Specs for the compiler, to handle processor variations.  */\n+#define CC1_SPEC \\\n+\t\"%{!mka:%{!mkb:%{!mkc:%{!msa:%{!msb:%{!msc:%{!mmc:%{!mca:%{!mcb:\\\n+\t\t%{!mcc:%{!mcf:-mkb}}}}}}}}}}}\\\n+\t%{mbout:%{g*:-gstabs}}\\\n+\t%{mcoff:%{g*:-gcoff}}\\\n+\t%{!mbout:%{!mcoff:%{g*:-gstabs}}}\"\n+\n+/* Specs for the assembler, to handle processor variations.\n+   For compatibility with Intel's gnu960 tool chain, pass -A options to\n+   the assembler.  */\n+#define ASM_SPEC \\\n+\t\"%{mka:-AKA}%{mkb:-AKB}%{mkc:-AKC}%{msa:-ASA}%{msb:-ASB}\\\n+\t%{msc:-ASC}%{mmc:-AMC}%{mca:-ACA}%{mcb:-ACB}%{mcc:-ACC}%{mcf:-ACF}\\\n+\t%{!mka:%{!mkb:%{!mkc:%{!msa:%{!msb:%{!msc:%{!mmc:%{!mca:%{!mcb:\\\n+\t\t%{!mcc:%{!mcf:-AKB}}}}}}}}}}}\"\n+\n+/* Specs for the linker, to handle processor variations.\n+   For compatibility with Intel's gnu960 tool chain, pass -F and -A options\n+   to the linker.  */\n+#define LINK_SPEC \\\n+\t\"%{mka:-AKA}%{mkb:-AKB}%{mkc:-AKC}%{msa:-ASA}%{msb:-ASB}\\\n+\t%{msc:-ASC}%{mmc:-AMC}%{mca:-ACA}%{mcb:-ACB}%{mcc:-ACC}%{mcf:-ACF}\\\n+\t%{!mka:%{!mkb:%{!mkc:%{!msa:%{!msb:%{!msc:%{!mmc:%{!mca:%{!mcb:\\\n+\t\t%{!mcc:%{!mcf:-AKB}}}}}}}}}}}\\\n+\t%{mbout:-Fbout}%{mcoff:-Fcoff}\"\n+\n+/* Specs for the libraries to link with, to handle processor variations.\n+   Compatible with Intel's gnu960 tool chain.  */\n+#define LIB_SPEC \"%{!nostdlib:-lcg %{p:-lprof}%{pg:-lgprof}\\\n+\t  %{mka:-lfpg}%{msa:-lfpg}%{mca:-lfpg}%{mcf:-lfpg} -lgnu}\"\n+\n+/* These compiler options take an argument.  */\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\\\n+ (!strcmp (STR, \"Tdata\") || !strcmp (STR, \"include\")\t\\\n+  || !strcmp (STR, \"imacros\") || !strcmp (STR, \"Ttext\"))\n+\n+/* Omit frame pointer at -O2.  Inline functions at -O3.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL)\t\t\\\n+{\t\t\t\t\t\t\\\n+  if ((LEVEL) >= 2)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      flag_omit_frame_pointer = 1;\t\t\\\n+      target_flags |= TARGET_FLAG_LEAFPROC;\t\\\n+      target_flags |= TARGET_FLAG_TAILCALL;\t\\\n+    }\t\t\t\t\t\t\\\n+  if ((LEVEL) >= 3)\t\t\t\t\\\n+    flag_inline_functions = 1;\t\t\t\\\n+}\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr,\" (intel 80960)\");\n+\n+/* Generate DBX debugging information.  */\n+#define DBX_DEBUGGING_INFO\n+\n+/* Generate SDB style debugging information.  */\n+#define SDB_DEBUGGING_INFO\n+\n+/* Generate DBX_DEBUGGING_INFO by default.  */\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+/* Redefine this to print in hex like iC960.  */\n+#define PUT_SDB_TYPE(A) fprintf (asm_out_file, \"\\t.type\\t0x%x;\", A)\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+/* 960 architecture with floating-point.  */\n+#define TARGET_FLAG_NUMERICS\t0x01\n+#define TARGET_NUMERICS\t\t(target_flags & TARGET_FLAG_NUMERICS)\n+\n+/* 960 architecture with memory management.  */\n+/* ??? Not used currently.  */\n+#define\tTARGET_FLAG_PROTECTED\t0x02\n+#define\tTARGET_PROTECTED\t(target_flags & TARGET_FLAG_PROTECTED)\n+\n+/* The following three are mainly used to provide a little sanity checking\n+   against the -mARCH flags given.  */\n+\n+/* Nonzero if we should generate code for the KA and similar processors.\n+   No FPU, no microcode instructions.  */\n+#define TARGET_FLAG_K_SERIES\t0x04\n+#define TARGET_K_SERIES\t\t(target_flags & TARGET_FLAG_K_SERIES)\n+\n+/* Nonzero if we should generate code for the MC processor.\n+   Not really different from KB for our purposes.  */\n+#define\tTARGET_FLAG_MC\t\t0x08\n+#define TARGET_MC \t\t(target_flags & TARGET_FLAG_MC)\n+\n+/* Nonzero if we should generate code for the CA processor.\n+   Enables different optimization strategies.  */\n+#define\tTARGET_FLAG_C_SERIES\t0x10\n+#define\tTARGET_C_SERIES \t(target_flags & TARGET_FLAG_C_SERIES)\n+\n+/* Nonzero if we should generate leaf-procedures when we find them.\n+   You may not want to do this because leaf-proc entries are\n+   slower when not entered via BAL - this would be true when\n+   a linker not supporting the optimization is used.  */\n+#define\tTARGET_FLAG_LEAFPROC\t0x20\n+#define\tTARGET_LEAFPROC\t\t(target_flags & TARGET_FLAG_LEAFPROC)\n+\n+/* Nonzero if we should perform tail-call optimizations when we find them.\n+   You may not want to do this because the detection of cases where\n+   this is not valid is not totally complete.  */\n+#define\tTARGET_FLAG_TAILCALL\t0x40\n+#define\tTARGET_TAILCALL\t\t(target_flags & TARGET_FLAG_TAILCALL)\n+\n+/* Nonzero if use of a complex addressing mode is a win on this implementation.\n+   Complex addressing modes are probably not worthwhile on the K-series,\n+   but they definitely are on the C-series.  */\n+#define\tTARGET_FLAG_COMPLEX_ADDR 0x80\n+#define\tTARGET_COMPLEX_ADDR\t(target_flags & TARGET_FLAG_COMPLEX_ADDR)\n+\n+/* Align code to 8 byte boundaries for faster fetching.  */\n+#define\tTARGET_FLAG_CODE_ALIGN\t0x100\n+#define\tTARGET_CODE_ALIGN\t(target_flags  & TARGET_FLAG_CODE_ALIGN)\n+\n+/* Append branch prediction suffixes to branch opcodes.  */\n+/* ??? Not used currently.  */\n+#define\tTARGET_FLAG_BRANCH_PREDICT 0x200\n+#define\tTARGET_BRANCH_PREDICT\t(target_flags  & TARGET_FLAG_BRANCH_PREDICT)\n+\n+/* Forces prototype and return promotions.  */\n+/* ??? This does not work.  */\n+#define\tTARGET_FLAG_CLEAN_LINKAGE 0x400\n+#define\tTARGET_CLEAN_LINKAGE\t(target_flags & TARGET_FLAG_CLEAN_LINKAGE)\n+\n+/* For compatibility with iC960 v3.0.  */\n+#define\tTARGET_FLAG_IC_COMPAT3_0 0x800 \n+#define\tTARGET_IC_COMPAT3_0\t(target_flags & TARGET_FLAG_IC_COMPAT3_0)\n+\n+/* For compatibility with iC960 v2.0.  */\n+#define\tTARGET_FLAG_IC_COMPAT2_0 0x1000\n+#define\tTARGET_IC_COMPAT2_0\t(target_flags & TARGET_FLAG_IC_COMPAT2_0)\n+\n+/* If no unaligned accesses are to be permitted.  */\n+#define\tTARGET_FLAG_STRICT_ALIGN 0x2000\n+#define\tTARGET_STRICT_ALIGN\t(target_flags & TARGET_FLAG_STRICT_ALIGN)\n+\n+/* For compatibility with iC960 assembler.  */\n+#define\tTARGET_FLAG_ASM_COMPAT\t0x4000\n+#define\tTARGET_ASM_COMPAT\t(target_flags & TARGET_FLAG_ASM_COMPAT)\n+\n+/* For compatibility with the gcc960 v1.2 compiler.  Use the old structure\n+   alignement rules.  Also, turns on STRICT_ALIGNMENT.  */\n+#define TARGET_FLAG_OLD_ALIGN\t0x8000\n+#define TARGET_OLD_ALIGN\t(target_flags & TARGET_FLAG_OLD_ALIGN)\n+\n+extern int target_flags;\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+/* ??? Not all ten of these architecture variations actually exist, but I\n+   am not sure which are real and which aren't.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"sa\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"sb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES| \\\n+\t\t\tTARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"sc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\\\n+\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"ka\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"kb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES| \\\n+\t\t\tTARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"kc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\\\n+\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"mc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\\\n+\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"ca\", (TARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\\\n+\t\t\tTARGET_FLAG_CODE_ALIGN|TARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"cb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_C_SERIES|\\\n+\t\t\tTARGET_FLAG_BRANCH_PREDICT|TARGET_FLAG_CODE_ALIGN)},\\\n+    {\"cc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\\\n+\t\t\tTARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\\\n+\t\t\tTARGET_FLAG_CODE_ALIGN)},\t\\\n+    {\"cf\", (TARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\\\n+\t\t\tTARGET_FLAG_CODE_ALIGN|TARGET_FLAG_COMPLEX_ADDR)},\\\n+    {\"numerics\", (TARGET_FLAG_NUMERICS)},\t\t\\\n+    {\"soft-float\", -(TARGET_FLAG_NUMERICS)},\t\t\\\n+    {\"leaf-procedures\", TARGET_FLAG_LEAFPROC},\t\t\\\n+    {\"no-leaf-procedures\",-(TARGET_FLAG_LEAFPROC)},\t\\\n+    {\"tail-call\",TARGET_FLAG_TAILCALL},\t\t\t\\\n+    {\"no-tail-call\",-(TARGET_FLAG_TAILCALL)},\t\t\\\n+    {\"complex-addr\",TARGET_FLAG_COMPLEX_ADDR},\t\t\\\n+    {\"no-complex-addr\",-(TARGET_FLAG_COMPLEX_ADDR)},\t\\\n+    {\"code-align\",TARGET_FLAG_CODE_ALIGN},\t\t\\\n+    {\"no-code-align\",-(TARGET_FLAG_CODE_ALIGN)},\t\\\n+    {\"clean-linkage\", (TARGET_FLAG_CLEAN_LINKAGE)},\t\\\n+    {\"no-clean-linkage\", -(TARGET_FLAG_CLEAN_LINKAGE)},\t\\\n+    {\"ic-compat\", TARGET_FLAG_IC_COMPAT2_0},\t\t\\\n+    {\"ic2.0-compat\", TARGET_FLAG_IC_COMPAT2_0},\t\t\\\n+    {\"ic3.0-compat\", TARGET_FLAG_IC_COMPAT3_0},\t\t\\\n+    {\"asm-compat\",TARGET_FLAG_ASM_COMPAT},\t\t\\\n+    {\"intel-asm\",TARGET_FLAG_ASM_COMPAT},\t\t\\\n+    {\"strict-align\", TARGET_FLAG_STRICT_ALIGN},\t\t\\\n+    {\"no-strict-align\", -(TARGET_FLAG_STRICT_ALIGN)},\t\\\n+    {\"old-align\", TARGET_FLAG_OLD_ALIGN},\t\t\\\n+    {\"no-old-align\", -(TARGET_FLAG_OLD_ALIGN)},\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+\n+/* Override conflicting target switch options.\n+   Doesn't actually detect if more than one -mARCH option is given, but\n+   does handle the case of two blatantly conflicting -mARCH options.  */\n+#define OVERRIDE_OPTIONS\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (TARGET_K_SERIES && TARGET_C_SERIES)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      warning (\"conflicting architectures defined - using C series\", 0); \\\n+      target_flags &= ~TARGET_FLAG_K_SERIES;\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (TARGET_K_SERIES && TARGET_MC)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      warning (\"conflicting architectures defined - using K series\", 0); \\\n+      target_flags &= ~TARGET_FLAG_MC;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (TARGET_C_SERIES && TARGET_MC)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      warning (\"conflicting architectures defined - using C series\", 0);\\\n+      target_flags &= ~TARGET_FLAG_MC;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (TARGET_IC_COMPAT3_0)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      flag_short_enums = 1;\t\t\t\t\t\\\n+      flag_signed_char = 1;\t\t\t\t\t\\\n+      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\t\t\\\n+      if (TARGET_IC_COMPAT2_0)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  warning (\"iC2.0 and iC3.0 are incompatible - using iC3.0\", 0); \\\n+\t  target_flags &= ~TARGET_FLAG_IC_COMPAT2_0;\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (TARGET_IC_COMPAT2_0)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      flag_signed_char = 1;\t\t\t\t\t\\\n+      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  i960_initialize ();\t\t\t\t\t\t\\\n+}\n+\n+/* Don't enable anything by default.  The user is expected to supply a -mARCH\n+   option.  If none is given, then -mkb is added by CC1_SPEC.  */\n+#define TARGET_DEFAULT 0\n+\f\n+/* Target machine storage layout.  */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.\n+   The i960 case be either big endian or little endian.  We only support\n+   little endian, which is the most common.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Number of bits in an addressible storage unit.  */\n+#define BITS_PER_UNIT 8\n+\n+/* Bitfields cannot cross word boundaries.  */\n+#define BITFIELD_NBYTES_LIMITED 1\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.  See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Width in bits of a long double.  Identical to double for now.  */\n+#define\tLONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 128\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 128\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* This makes zero-length anonymous fields lay the next field\n+   at a word boundary.  It also makes the whole struct have\n+   at least word alignment if there are any bitfields at all.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* No data type wants to be aligned rounder than this.\n+   Extended precision floats gets 4-word alignment.  */\n+#define BIGGEST_ALIGNMENT 128\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.\n+   80960 will work even with unaligned data, but it is slow.  */\n+#define STRICT_ALIGNMENT TARGET_OLD_ALIGN\n+\n+/* Specify alignment for string literals (which might be higher than the\n+   base type's minimnal alignment requirement.  This allows strings to be\n+   aligned on word boundaries, and optimizes calls to the str* and mem*\n+   library functions.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN) \\\n+  (i960_object_bytes_bitalign (int_size_in_bytes (TREE_TYPE (EXP))) > (ALIGN) \\\n+   ? i960_object_bytes_bitalign (int_size_in_bytes (TREE_TYPE (EXP)))\t    \\\n+   : (ALIGN))\n+\n+/* Macros to determine size of aggregates (structures and unions\n+   in C).  Normally, these may be defined to simply return the maximum\n+   alignment and simple rounded-up size, but on some machines (like\n+   the i960), the total size of a structure is based on a non-trivial\n+   rounding method.  */\n+\n+#define ROUND_TYPE_ALIGN(TYPE, COMPUTED, SPECIFIED)\t\t\\\n+  ((!TARGET_OLD_ALIGN && TREE_CODE (TYPE) == RECORD_TYPE)\t\\\n+   ? i960_round_align ((SPECIFIED), TYPE_SIZE (TYPE))\t\t\\\n+   : MAX ((COMPUTED), (SPECIFIED)))\n+\n+#define ROUND_TYPE_SIZE(TYPE, SIZE, ALIGN)\t\t\t\\\n+  ((!TARGET_OLD_ALIGN && TREE_CODE (TYPE) == RECORD_TYPE)\t\\\n+   ? (tree) i960_round_size (SIZE)\t\t\t\t\\\n+   : round_up ((SIZE), (ALIGN)))\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   Registers 0-15 are the global registers (g0-g15).\n+   Registers 16-31 are the local registers (r0-r15).\n+   Register 32-35 are the fp registers (fp0-fp3).\n+   Register 36 is the condition code register.\n+   Register 37 is unused.  */\n+\n+#define FIRST_PSEUDO_REGISTER 38\n+\n+/* 1 for registers that have pervasive standard uses and are not available\n+   for the register allocator.  On 80960, this includes the frame pointer\n+   (g15), the previous FP (r0), the stack pointer (r1), the return\n+   instruction pointer (r2), and the argument pointer (g14).  */\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+  1, 1, 1, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 1, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+/* On the 80960, note that:\n+\tg0..g3 are used for return values,\n+\tg0..g7 may always be used for parameters,\n+\tg8..g11 may be used for parameters, but are preserved if they aren't,\n+\tg12 is always preserved, but otherwise unused,\n+\tg13 is the struct return ptr if used, or temp, but may be trashed,\n+\tg14 is the leaf return ptr or the arg block ptr otherwise zero,\n+\t\tmust be reset to zero before returning if it was used,\n+\tg15 is the frame pointer,\n+\tr0 is the previous FP,\n+\tr1 is the stack pointer,\n+\tr2 is the return instruction pointer,\n+\tr3-r15 are always available,\n+\tfp0..fp3 are never available.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 1, 1, 1,\t\\\n+  1, 1, 1, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1}\n+\n+/* If no fp unit, make all of the fp registers fixed so that they can't\n+   be used.  */\n+#define\tCONDITIONAL_REGISTER_USAGE\t\\\n+  if (! TARGET_NUMERICS) {\t\t\t\t\t\t\\\n+     fixed_regs[32] = fixed_regs[33] = fixed_regs[34] = fixed_regs[35] = 1;\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On 80960, ordinary registers hold 32 bits worth, but can be ganged\n+   together to hold double or extended precision floating point numbers,\n+   and the floating point registers hold any size floating point number */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((REGNO) < 32\t\t\t\t\t\t\t\\\n+   ? (((MODE) == VOIDmode)\t\t\t\t\t\\\n+      ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)) \\\n+   : ((REGNO) < FIRST_PSEUDO_REGISTER) ? 1 : 0)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On 80960, the cpu registers can hold any mode but the float registers\n+   can only hold SFmode, DFmode, or TFmode.  */\n+extern short hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((hard_regno_mode_ok[REGNO] & (1 << (int) (MODE))) != 0)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* 80960 pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 17\n+\n+/* Actual top-of-stack address is same as\n+   the contents of the stack pointer register.  */\n+#define STACK_POINTER_OFFSET (-current_function_outgoing_args_size)\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 15\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED (! leaf_function_p ())\n+\n+/* C statement to store the difference between the frame pointer\n+   and the stack pointer values immediately after the function prologue.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n+  do { (VAR) = compute_frame_size (get_frame_size ()); } while (0)\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 14\n+\n+/* Register in which static-chain is passed to a function.\n+   On i960, we use r3.  */\n+#define STATIC_CHAIN_REGNUM 19\n+ \n+/* Functions which return large structures get the address\n+   to place the wanted value at in g13.  */\n+\n+#define STRUCT_VALUE_REGNUM 13 \n+\n+/* The order in which to allocate registers.  */\n+\n+#define\tREG_ALLOC_ORDER\t\\\n+{  4, 5, 6, 7, 0, 1, 2, 3, 13,\t /* g4, g5, g6, g7, g0, g1, g2, g3, g13  */ \\\n+  20, 21, 22, 23, 24, 25, 26, 27,/* r4, r5, r6, r7, r8, r9, r10, r11  */    \\\n+  28, 29, 30, 31, 19, 8, 9, 10,\t /* r12, r13, r14, r15, r3, g8, g9, g10  */ \\\n+  11, 12,\t\t\t /* g11, g12  */\t\t\t    \\\n+  32, 33, 34, 35,\t\t /* fp0, fp1, fp2, fp3  */\t\t    \\\n+  /* We can't actually allocate these.  */\t\t\t\t    \\\n+  16, 17, 18, 14, 15, 36, 37}\t /* r0, r1, r2, g14, g15, cc  */\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The 80960 has four kinds of registers, global, local, floating point,\n+   and condition code.  The cc register is never allocated, so no class\n+   needs to be defined for it.  */\n+\n+enum reg_class { NO_REGS, GLOBAL_REGS, LOCAL_REGS, LOCAL_OR_GLOBAL_REGS,\n+  FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+/* 'r' includes floating point registers if TARGET_NUMERICS.  'd' never\n+   does.  */\n+#define\tGENERAL_REGS\t((TARGET_NUMERICS) ? ALL_REGS : LOCAL_OR_GLOBAL_REGS)\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.  */\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{ \"NO_REGS\", \"GLOBAL_REGS\", \"LOCAL_REGS\", \"LOCAL_OR_GLOBAL_REGS\",\t\\\n+  \"FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+{ {0, 0}, {0x0ffff, 0}, {0xffff0000, 0}, {-1,0}, {0, -1}, {-1,-1}}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO)\t\\\n+  ((REGNO) < 16 ? GLOBAL_REGS\t\\\n+   : (REGNO) < 32 ? LOCAL_REGS\t\\\n+   : (REGNO) < 36 ? FP_REGS\t\\\n+   : NO_REGS)\n+\n+/* The class value for index registers, and the one for base regs.\n+   There is currently no difference between base and index registers on the\n+   i960, but this distinction may one day be useful.  */\n+#define INDEX_REG_CLASS LOCAL_OR_GLOBAL_REGS\n+#define BASE_REG_CLASS LOCAL_OR_GLOBAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.\n+   'f' is a floating point register (fp0..fp3)\n+   'l' is a local register (r0-r15)\n+   'b' is a global register (g0-g15)\n+   'd' is any local or global register\n+   'r' or 'g' are pre-defined to the class GENERAL_REGS.  */\n+/* 'l' and 'b' are probably never used.  Note that 'd' and 'r' are *not*\n+   the same thing, since 'r' may include the fp registers.  */\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  (((C) == 'f') && (TARGET_NUMERICS) ? FP_REGS : ((C) == 'l' ? LOCAL_REGS : \\\n+    (C) == 'b' ? GLOBAL_REGS : ((C) == 'd' ? LOCAL_OR_GLOBAL_REGS : NO_REGS)))\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For 80960:\n+\t'I' is used for literal values 0..31\n+   \t'J' means literal 0\n+\t'K' means 0..-31.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t\t\t\\\n+  ((C) == 'I' ? (((unsigned) (VALUE)) <= 31)\t\t\t\t\\\n+   : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n+      : (C) == 'K' ? ((VALUE) > -32 && (VALUE) <= 0)\t\t\t\\\n+\t: 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.\n+   For the 80960, G is 0.0 and H is 1.0.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n+  ((TARGET_NUMERICS) &&\t\t\t\t\t\\\n+   (((C) == 'G' && ((VALUE) == CONST0_RTX (DFmode)\t\\\n+\t\t    || (VALUE) == CONST0_RTX (SFmode))) \\\n+    || ((C) == 'H' && ((VALUE) == CONST1_RTX (DFmode)\t\\\n+\t\t       || (VALUE) == CONST1_RTX (SFmode)))))\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+/* On 960, can't load constant into floating-point reg except\n+   0.0 or 1.0.\n+\n+   Any hard reg is ok as a src operand of a reload insn.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n+  (GET_CODE (X) == REG && REGNO (X) < FIRST_PSEUDO_REGISTER\t\\\n+   ? (CLASS)\t\t\t\t\t\t\t\\\n+   : ((CLASS) == FP_REGS && CONSTANT_P (X)\t\t\t\\\n+      && (X) != CONST0_RTX (DFmode) && (X) != CONST1_RTX (DFmode)\\\n+      && (X) != CONST0_RTX (SFmode) && (X) != CONST1_RTX (SFmode)\\\n+      ? NO_REGS\t\t\t\t\t\t\t\\\n+      : (CLASS) == ALL_REGS ? LOCAL_OR_GLOBAL_REGS : (CLASS)))\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class (CLASS, MODE, IN)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On 80960, this is the size of MODE in words,\n+   except in the FP regs, where a single reg is always enough.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  ((CLASS) == FP_REGS ? 1 : HARD_REGNO_NREGS (0, (MODE)))\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+/* #define STACK_GROWS_DOWNWARD */\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.\n+\n+   The i960 has a 64 byte register save area, plus possibly some extra\n+   bytes allocated for varargs functions.  */\n+#define STARTING_FRAME_OFFSET 64\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On 80960, don't define this because there are no push insns.  */\n+/* #define PUSH_ROUNDING(BYTES) BYTES */\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* When a parameter is passed in a register, no stack space is\n+   allocated for it.  However, when args are passed in the\n+   stack, space is allocated for every register parameter.  */\n+#define MAYBE_REG_PARM_STACK_SPACE 48\n+#define FINAL_REG_PARM_STACK_SPACE(CONST_SIZE, VAR_SIZE)\t\\\n+  i960_final_reg_parm_stack_space (CONST_SIZE, VAR_SIZE);\n+#define REG_PARM_STACK_SPACE(DECL) i960_reg_parm_stack_space (DECL)\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+/* Keep the stack pointer constant throughout the function.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Value is 1 if returning from a function call automatically\n+   pops the arguments described by the number-of-args field in the call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE, SIZE) 0\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE) gen_rtx ((REG), (MODE), 0)\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.\n+   On 80960, returns are in g0..g3 */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) < 4)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On 80960, parameters are passed in g0..g11 */\n+\n+#define FUNCTION_ARG_REGNO_P(N) ((N) < 12)\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n+  i960_setup_incoming_varargs(&CUM,MODE,TYPE,&PRETEND_SIZE,NO_RTL)\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On 80960, this is two integers, which count the number of register\n+   parameters and the number of stack parameters seen so far.  */\n+\n+struct cum_args { int ca_nregparms; int ca_nstackparms; };\n+\n+#define CUMULATIVE_ARGS struct cum_args\n+\n+/* Define the number of registers that can hold parameters.\n+   This macro is used only in macro definitions below and/or i960.c.  */\n+#define NPARM_REGS 12\n+\n+/* Define how to round to the next parameter boundary.\n+   This macro is used only in macro definitions below and/or i960.c.  */\n+#define ROUND(X, MULTIPLE_OF)\t\\\n+  ((((X) + (MULTIPLE_OF) - 1) / (MULTIPLE_OF)) * MULTIPLE_OF)\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On 80960, the offset always starts at 0; the first parm reg is g0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+  ((CUM).ca_nregparms = 0, (CUM).ca_nstackparms = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   CUM should be advanced to align with the data type accessed and\n+   also the size of that data type in # of regs.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+  i960_function_arg_advance(&CUM, MODE, TYPE, NAMED)\n+\n+/* Indicate the alignment boundary for an argument of the specified mode and\n+   type.  */\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n+  ((TYPE) && TYPE_ALIGN (TYPE) > PARM_BOUNDARY ? TYPE_ALIGN (TYPE)\t\\\n+   : PARM_BOUNDARY)\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+extern struct rtx_def *i960_function_arg ();\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+  i960_function_arg(&CUM, MODE, TYPE, NAMED)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+extern struct rtx_def *i960_function_value ();\n+#define FUNCTION_VALUE(TYPE, FUNC) i960_function_value (TYPE)\n+\n+/* Force objects larger than 16 bytes to be returned in memory, since we\n+   only have 4 registers available for return values.  */\n+\n+#define RETURN_IN_MEMORY(TYPE) (int_size_in_bytes (TYPE) > 16)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   This never happens on 80960.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\f\n+/* Output the label for a function definition.\n+  This handles leaf functions and a few other things for the i960.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n+  i960_function_name_declare (FILE, NAME, DECL)\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) i960_function_prologue ((FILE), (SIZE))\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tlda\tLP%d,g0\\n\\tbal\tmcount\\n\", (LABELNO))\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define\tEXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) i960_function_epilogue (FILE, SIZE)\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+  ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+  ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+#define REGNO_OK_FOR_FP_P(REGNO) \\\n+  ((REGNO) < 36 || (unsigned) reg_renumber[REGNO] < 36)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+   These macros are specific to the 960, and may be used only\n+   in code for printing assembler insns and in conditions for\n+   define_optimization.  */\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REGNO (X) >= 32 && REGNO (X) < 36)\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define\tMAX_REGS_PER_ADDRESS 2\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* LEGITIMATE_CONSTANT_P is nonzero if the constant value X\n+   is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P.\n+\n+   Anything but a CONST_DOUBLE can be made to work, excepting 0.0 and 1.0.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  ((GET_CODE (X) != CONST_DOUBLE) || fp_literal ((X), VOIDmode))\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) \\\n+  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+#define REG_OK_FOR_INDEX_P_STRICT(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_BASE_P_STRICT(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+\tOn 80960, legitimate addresses are:\n+\t\tbase\t\t\t\tld\t(g0),r0\n+\t\tdisp\t(12 or 32 bit)\t\tld\tfoo,r0\n+\t\tbase + index\t\t\tld\t(g0)[g1*1],r0\n+\t\tbase + displ\t\t\tld\t0xf00(g0),r0\n+\t\tbase + index*scale + displ\tld\t0xf00(g0)[g1*4],r0\n+\t\tindex*scale + base\t\tld\t(g0)[g1*4],r0\n+\t\tindex*scale + displ\t\tld\t0xf00[g1*4],r0\n+\t\tindex*scale\t\t\tld\t[g1*4],r0\n+\t\tindex + base + displ\t\tld\t0xf00(g0)[g1*1],r0\n+\n+\tIn each case, scale can be 1, 2, 4, 8, or 16.  */\n+\n+/* Returns 1 if the scale factor of an index term is valid. */\n+#define SCALE_TERM_P(X)\t\t\t\t\t\t\t\\\n+  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+   && (INTVAL (X) == 1 || INTVAL (X) == 2 || INTVAL (X) == 4 \t\t\\\n+       || INTVAL(X) == 8 || INTVAL (X) == 16))\n+\n+\n+#ifdef REG_OK_STRICT\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+  { if (legitimate_address_p (MODE, X, 1)) goto ADDR; }\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+  { if (legitimate_address_p (MODE, X, 0)) goto ADDR; }\n+#endif\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+/* On 80960, convert non-cannonical addresses to canonical form.  */\n+\n+extern struct rtx_def *legitimize_address ();\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n+{ rtx orig_x = (X);\t\t\t\t\\\n+  (X) = legitimize_address (X, OLDX, MODE);\t\\\n+  if ((X) != orig_x && memory_address_p (MODE, X)) \\\n+    goto WIN; }\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the 960 this is never true.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* Allow and ignore #sccs directives.  */\n+#define\tSCCS_DIRECTIVE\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 16\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.  */\n+#define BYTE_LOADS_ZERO_EXTEND\n+\n+/* Nonzero if access to memory by bytes is no faster than for words.\n+   Defining this results in worse code on the i960.  */\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* Specify the widest mode that BLKmode objects can be promoted to */\n+#define\tMAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (TImode)\n+\f\n+/* These global variables are used to pass information between\n+   cc setter and cc user at insn emit time.  */\n+\n+extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n+\n+/* Define the function that build the compare insn for scc and bcc.  */\n+\n+extern struct rtx_def *gen_compare_reg ();\n+\n+/* Add any extra modes needed to represent the condition code.\n+\n+   Also, signed and unsigned comparisons are distinguished, as\n+   are operations which are compatible with chkbit insns.  */\n+#define EXTRA_CC_MODES CC_UNSmode, CC_CHKmode\n+\n+/* Define the names for the modes specified above.  */\n+#define EXTRA_CC_NAMES \"CC_UNS\", \"CC_CHK\"\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  For floating-point, CCFPmode\n+   should be used.  CC_NOOVmode should be used when the first operand is a\n+   PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n+   needed.  */\n+#define SELECT_CC_MODE(OP,X) select_cc_mode (OP, X)\n+\n+/* A function address in a call instruction is a byte address\n+   (for indexing purposes) so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Use memcpy, etc. instead of bcopy.  */\n+\n+#ifndef WIND_RIVER\n+#define\tTARGET_MEM_FUNCTIONS\t1\n+#endif\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+/* Constants that can be (non-ldconst) insn operands are cost 0.  Constants\n+   that can be non-ldconst operands in rare cases are cost 1.  Other constants\n+   have higher costs.  */\n+\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\t\t\\\n+    if ((INTVAL (RTX) >= 0 && INTVAL (RTX) < 32)\t\t\t\\\n+\t|| power2_operand (RTX, VOIDmode))\t\t\t\t\\\n+      return 0; \t\t\t\t\t\t\t\\\n+    else if (INTVAL (RTX) >= -31 && INTVAL (RTX) < 0)\t\t\t\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+    return (TARGET_FLAG_C_SERIES ? 6 : 8);\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+    if ((RTX) == CONST0_RTX (DFmode) || (RTX) == CONST0_RTX (SFmode)\t\\\n+\t|| (RTX) == CONST1_RTX (DFmode) || (RTX) == CONST1_RTX (SFmode))\\\n+      return 1;\t\t\t\t\t\t\t\t\\\n+    return 12;\n+\n+/* The i960 offers addressing modes which are \"as cheap as a register\".\n+   See i960.c (or gcc.texinfo) for details.  */\n+\n+#define ADDRESS_COST(RTX) \\\n+  (GET_CODE (RTX) == REG ? 1 : i960_address_cost (RTX))\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(file)\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES {\t\t\t\t\t\t\\\n+\t\"g0\", \"g1\", \"g2\",  \"g3\",  \"g4\",  \"g5\",  \"g6\",  \"g7\",\t\t\\\n+\t\"g8\", \"g9\", \"g10\", \"g11\", \"g12\", \"g13\", \"g14\", \"fp\",\t\t\\\n+\t\"pfp\",\"sp\", \"rip\", \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n+\t\"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n+\t\"fp0\",\"fp1\",\"fp2\", \"fp3\", \"cc\", \"fake\" }\n+\n+/* How to renumber registers for dbx and gdb.\n+   In the 960 encoding, g0..g15 are registers 16..31.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n+  (((REGNO) < 16) ? (REGNO) + 16\t\t\t\t\t\\\n+   : (((REGNO) > 31) ? (REGNO) : (REGNO) - 16))\n+\n+/* Don't emit dbx records longer than this.  This is an arbitrary value.  */\n+#define DBX_CONTIN_LENGTH 1500\n+\n+/* This is how to output a note to DBX telling it the line number\n+   to which the following sequence of instructions corresponds. */\n+\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE)\t\t\t\\\n+{ if (write_symbols == SDB_DEBUG) {\t\t\t\t\\\n+    fprintf ((FILE), \"\\t.ln\t%d\\n\",\t\t\t\t\\\n+\t     (sdb_begin_function_line\t\t\t\t\\\n+\t      ? (LINE) - sdb_begin_function_line : 1));\t\t\\\n+  } else if (write_symbols == DBX_DEBUG) {\t\t\t\\\n+\tfprintf((FILE),\"\\t.stabd\t68,0,%d\\n\",(LINE));\t\\\n+  } }\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\t\\\n+{ fputs (\"\\t.globl \", FILE);\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\\\n+  fputs (\"\\n\", FILE); }\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\tfprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  i960_output_double(FILE, VALUE)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  i960_output_float(FILE, VALUE)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)\t\\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tst\\t%s,(sp)\\n\\taddo\\t4,sp,sp\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tsubo\\t4,sp,sp\\n\\tld\\t(sp),%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+/* For common objects, output unpadded size... gld960 & lnk960 both\n+   have code to align each common object at link time.  Also, if size\n+   is 0, treat this as a declaration, not a definition - i.e.,\n+   do nothing at all.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+{ if ((SIZE) != 0)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fputs (\".globl \", (FILE)),\t\t\t\\\n+      assemble_name ((FILE), (NAME)),\t\t\t\\\n+      fputs (\"\\n.comm \", (FILE)),\t\t\t\\\n+      assemble_name ((FILE), (NAME)),\t\t\t\\\n+      fprintf ((FILE), \",%d\\n\", (ROUNDED));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* This says how to output an assembler line to define a local common symbol.\n+   Output unpadded size, with request to linker to align as requested.\n+   0 size should not be possible here.  */\n+\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)  \\\n+( fputs (\".bss\\t\", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d,%d\\n\", (SIZE),\t\t\\\n+\t   ((ALIGN) <= 8 ? 0\t\t\t\\\n+\t    : ((ALIGN) <= 16 ? 1\t\t\\\n+\t       : ((ALIGN) <= 32 ? 2\t\t\\\n+\t\t  : ((ALIGN <= 64 ? 3 : 4)))))))\n+\n+/* Output text for an #ident directive.  */\n+#define\tASM_OUTPUT_IDENT(FILE, STR)  fprintf(FILE, \"\\t# %s\\n\", STR);\n+\n+/* Align code to 8 byte boundary if TARGET_CODE_ALIGN is true.  */\n+\n+#define\tASM_OUTPUT_ALIGN_CODE(FILE)\t\t\\\n+{ if (TARGET_CODE_ALIGN) fputs(\"\\t.align 3\\n\",FILE); }\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+\t( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+\t  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+\f\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO) \\\n+{ fprintf (FILE, \"\\tld\tLPBX0,g12\\n\");\t\t\t\\\n+  fprintf (FILE, \"\\tcmpobne\t0,g12,LPY%d\\n\",LABELNO);\\\n+  fprintf (FILE, \"\\tlda\tLPBX0,g12\\n\");\t\t\t\\\n+  fprintf (FILE, \"\\tcall\t___bb_init_func\\n\");\t\\\n+  fprintf (FILE, \"LPY%d:\\n\",LABELNO); }\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n+{ int blockn = (BLOCKNO);\t\t\t\t\\\n+  fprintf (FILE, \"\\tld\tLPBX2+%d,g12\\n\", 4 * blockn);\t\\\n+  fprintf (FILE, \"\\taddo\tg12,1,g12\\n\");\t\t\\\n+  fprintf (FILE, \"\\tst\tg12,LPBX2+%d\\n\", 4 * blockn); }\n+\f\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+  i960_print_operand (FILE, X, CODE);\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\\\n+  i960_print_operand_addr (FILE, ADDR)\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the i960, the trampoline contains three instructions:\n+     ldconst _function, r4\n+     ldconst static addr, r3\n+     jump (r4)  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x8C203000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x00000000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x8C183000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x00000000));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x84212000));\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)),\t\\\n+\t\t  FNADDR);\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)),\t\\\n+\t\t  CXT);\t\t\t\t\t\t\t\\\n+}\n+\n+#if 0\n+/* Promote char and short arguments to ints, when want compitibility with\n+   the iC960 compilers.  */\n+\n+/* ??? In order for this to work, all users would need to be changed\n+   to test the value of the macro at run time.  */\n+#define PROMOTE_PROTOTYPES\tTARGET_CLEAN_LINKAGE\n+/* ??? This does not exist.  */\n+#define PROMOTE_RETURN\t\tTARGET_CLEAN_LINKAGE\n+#endif\n+\n+/* Instruction type definitions.  Used to alternate instructions types for\n+   better performance on the C series chips.  */\n+\n+enum insn_types { I_TYPE_REG, I_TYPE_MEM, I_TYPE_CTRL };\n+\n+/* Holds the insn type of the last insn output to the assembly file.  */\n+\n+extern enum insn_types i960_last_insn_type;\n+\n+/* Parse opcodes, and set the insn last insn type based on them.  */\n+\n+#define ASM_OUTPUT_OPCODE(FILE, INSN)\ti960_scan_opcode (INSN)\n+\n+/* Table listing what rtl codes each predicate in i960.c will accept.  */\n+\n+#define PREDICATE_CODES \\\n+  {\"fpmove_src_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n+\t\t\t  LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n+  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"fp_arith_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n+  {\"signed_arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"literal\", {CONST_INT}},\t\t\t\t\t\t\\\n+  {\"fp_literal_one\", {CONST_DOUBLE}},\t\t\t\t\t\\\n+  {\"fp_literal_double\", {CONST_DOUBLE}},\t\t\t\t\\\n+  {\"fp_literal\", {CONST_DOUBLE}},\t\t\t\t\t\\\n+  {\"signed_literal\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n+  {\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\\\n+  {\"arith32_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n+\t\t       CONST_DOUBLE, CONST}},\t\t\t\t\\\n+  {\"power2_operand\", {CONST_INT}},\n+\n+/* Define functions in i960.c and used in insn-output.c.  */\n+\n+extern char *i960_output_ldconst ();\n+extern char *i960_output_call_insn ();\n+extern char *i960_output_ret_insn ();"}, {"sha": "7130a90a9a5b55746af4e3287ef0ff20f84f1e0c", "filename": "gcc/config/i960/i960.md", "status": "added", "additions": 2507, "deletions": 0, "changes": 2507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=ba8ab3554e47a10bbae41bc75b77fdd01c012345", "patch": "@@ -0,0 +1,2507 @@\n+;;- Machine description for Intel 80960 chip for GNU C compiler\n+;;   Copyright (C) 1992 Free Software Foundation, Inc.\n+;;   Contributed by Steven McGeady, Intel Corp.\n+;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n+;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\f\n+;; Insn attributes which describe the i960.\n+\n+;; Modscan is not used, since the compiler never emits any of these insns.\n+(define_attr \"type\"\n+  \"move,arith,alu2,mult,div,modscan,load,store,branch,call,address,compare,fpload,fpstore,fpmove,fpcvt,fpcc,fpadd,fpmul,fpdiv,multi,misc\"\n+  (const_string \"arith\"))\n+\n+;; Length (in # of insns).\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"load,fpload\")\n+\t      (if_then_else (match_operand 1 \"symbolic_memory_operand\" \"\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 1))\n+\t (eq_attr \"type\" \"store,fpstore\")\n+\t      (if_then_else (match_operand 0 \"symbolic_memory_operand\" \"\")\n+\t\t\t    (const_int 2)\n+\t\t\t    (const_int 1))\n+\t (eq_attr \"type\" \"address\")\n+\t      (const_int 2)]\n+\t(const_int 1)))\n+\n+(define_asm_attributes\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"type\" \"multi\")])\n+\n+;; (define_function_unit {name} {num-units} {n-users} {test}\n+;;                       {ready-delay} {busy-delay} [{conflict-list}])\n+\n+;; The integer ALU\n+(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"arith,compare,move,address\") 1 0)\n+(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"alu2\") 2 0)\n+(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"mult\") 5 0)\n+(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"div\") 35 0)\n+(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"modscan\") 3 0)\n+\n+;; Memory with load-delay of 1 (i.e., 2 cycle load).\n+(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,fpload\") 2 0)\n+\n+;; Floating point operations.\n+(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpmove\") 5 0)\n+(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpcvt\") 35 0)\n+(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpcc\") 10 0)\n+(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpadd\") 10 0)\n+(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpmul\") 20 0)\n+(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpdiv\") 35 0)\n+\f\n+;; Compare instructions.\n+;; This controls RTL generation and register allocation.\n+\n+;; We generate RTL for comparisons and branches by having the cmpxx \n+;; patterns store away the operands.  Then, the scc and bcc patterns\n+;; emit RTL for both the compare and the branch.\n+;;\n+;; We start with the DEFINE_EXPANDs, then then DEFINE_INSNs to match\n+;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc\n+;; insns that actually require more than one machine instruction.\n+\n+;; Put cmpsi first because it is expected to be the most common.\n+\n+(define_expand \"cmpsi\"\n+  [(set (reg:CC 36)\n+\t(compare:CC (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  i960_compare_op0 = operands[0];\n+  i960_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (reg:CC 36)\n+\t(compare:CC (match_operand:DF 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:DF 1 \"nonmemory_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"\n+{\n+  i960_compare_op0 = operands[0];\n+  i960_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (reg:CC 36)\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:SF 1 \"nonmemory_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"\n+{\n+  i960_compare_op0 = operands[0];\n+  i960_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+;; Now the DEFINE_INSNs for the compare and scc cases.  First the compares.\n+\n+(define_insn \"\"\n+  [(set (reg:CC 36)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t    (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"cmpi\t%0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC_UNS 36)\n+\t(compare:CC_UNS (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t(match_operand:SI 1 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"cmpo\t%0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 36)\n+\t(compare:CC (match_operand:DF 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:DF 1 \"nonmemory_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"cmprl %0,%1\"\n+  [(set_attr \"type\" \"fpcc\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 36)\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t    (match_operand:SF 1 \"nonmemory_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"cmpr %0,%1\"\n+  [(set_attr \"type\" \"fpcc\")])\n+\n+;; Instruction definitions for branch-on-bit-set and clear insns.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (sign_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 2 \"arith_operand\" \"dI\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbs\t%2,%1,%l3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (sign_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 2 \"arith_operand\" \"dI\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbc\t%2,%1,%l3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 2 \"arith_operand\" \"dI\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbs\t%2,%1,%l3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (eq (zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t      (const_int 1)\n+\t\t\t      (match_operand:SI 2 \"arith_operand\" \"dI\"))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"bbc\t%2,%1,%l3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;; ??? These will never match.  The LOG_LINKs necessary to make these match\n+;; are not created by flow.  These remain as a reminder to make this work\n+;; some day.\n+\n+(define_insn \"\"\n+  [(set (reg:CC 36)\n+\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n+\t\t (match_operand:SI 1 \"arith_operand\" \"d\")))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n+  \"0\"\n+  \"cmpinci\t%0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC_UNS 36)\n+\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n+\t\t (match_operand:SI 1 \"arith_operand\" \"d\")))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n+  \"0\"\n+  \"cmpinco\t%0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC 36)\n+\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n+\t\t (match_operand:SI 1 \"arith_operand\" \"d\")))\n+   (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]\n+  \"0\"\n+  \"cmpdeci\t%0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (reg:CC_UNS 36)\n+\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n+\t\t (match_operand:SI 1 \"arith_operand\" \"d\")))\n+   (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]\n+  \"0\"\n+  \"cmpdeco\t%0,%1\"\n+  [(set_attr \"type\" \"compare\")])\n+\f\n+;; Templates to store result of condition.\n+;; '1' is stored if condition is true.\n+;; '0' is stored if condition is false.\n+;; These should use predicate \"general_operand\", since\n+;; gcc seems to be creating mem references which use these\n+;; templates.\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(eq (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(ne (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(gt (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(gtu (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(lt (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(ltu (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(ge (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(geu (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(le (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(leu (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(match_operator 1 \"comparison_operator\" [(reg:CC 36) (const_int 0)]))]\n+  \"\"\n+  \"test%C1 %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(match_operator 1 \"comparison_operator\" [(reg:CC_UNS 36) (const_int 0)]))]\n+  \"\"\n+  \"test%C1 %0\"\n+  [(set_attr \"type\" \"compare\")])\n+\f\n+;; These control RTL generation for conditional jump insns\n+;; and match them for register allocation.\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_dup 1)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_dup 1)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_dup 1)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (match_dup 1)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_dup 1)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (match_dup 1)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_dup 1)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (match_dup 1)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (match_dup 1)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1); }\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_dup 1)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1); }\")\n+\f\n+;; Now the normal branch insns (forward and reverse).\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(reg:CC 36) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"b%C0 %l1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(reg:CC 36) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"b%I0 %l1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(reg:CC_UNS 36) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"b%C0 %l1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(reg:CC_UNS 36) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"\"\n+  \"b%I0 %l1\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 1 \"arith_operand\" \"d\")\n+\t\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"cmp%S0%B0%R0\t%2,%1,%l3\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"comparison_operator\"\n+\t\t\t [(match_operand:SI 1 \"arith_operand\" \"d\")\n+\t\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")])\n+\t (pc)\n+\t (label_ref (match_operand 3 \"\" \"\"))))]\n+  \"\"\n+  \"cmp%S0%B0%X0\t%2,%1,%l3\"\n+  [(set_attr \"type\" \"branch\")])\n+\f\n+;; Normal move instructions.\n+;; This code is based on the sparc machine desciption.\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SImode))\n+    DONE;\n+}\")\n+\n+;; The store case can not be separate, because reload may convert a register\n+;; to register move insn to a store (or load) insn without rerecognizing\n+;; the insn.\n+\n+;; Special pattern for zero stores to memory for functions which don't use\n+;; the arg pointer.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:SI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode)\n+       || operands[1] == const0_rtx)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t{\n+\t  if (GET_CODE (operands[1]) == REG)\n+\t    return \\\"lda\t(%1),%0\\\";\n+\t  else\n+\t    return \\\"lda\t%1,%0\\\";\n+\t}\n+      return \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ld\t%1,%0\\\";\n+    case 3:\n+      if (operands[1] == const0_rtx)\n+\treturn \\\"st\tg14,%0\\\";\n+      return \\\"st\t%1,%0\\\";      \n+    }\n+}\"\n+  [(set_attr \"type\" \"move,address,load,store\")\n+   (set_attr \"length\" \"*,3,*,*\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:SI 1 \"general_operand\" \"dI,i,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t{\n+\t  if (GET_CODE (operands[1]) == REG)\n+\t    return \\\"lda\t(%1),%0\\\";\n+\t  else\n+\t    return \\\"lda\t%1,%0\\\";\n+\t}\n+      return \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ld\t%1,%0\\\";\n+    case 3:\n+      return \\\"st\t%1,%0\\\";      \n+    }\n+}\"\n+  [(set_attr \"type\" \"move,address,load,store\")\n+   (set_attr \"length\" \"*,3,*,*\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, HImode))\n+    DONE;\n+}\")\n+\n+;; Special pattern for zero stores to memory for functions which don't use\n+;; the arg pointer.\n+\n+;; The store case can not be separate.  See above.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode)\n+       || operands[1] == const0_rtx)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t{\n+\t  if (GET_CODE (operands[1]) == REG)\n+\t    return \\\"lda\t(%1),%0\\\";\n+\t  else\n+\t    return \\\"lda\t%1,%0\\\";\n+\t}\n+      return \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldos\t%1,%0\\\";\n+    case 3:\n+      if (operands[1] == const0_rtx)\n+\treturn \\\"stos\tg14,%0\\\";\n+      return \\\"stos\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,misc,load,store\")\n+   (set_attr \"length\" \"*,3,*,*\")])\n+\n+;; The store case can not be separate.  See above.\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"dI,i,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t{\n+\t  if (GET_CODE (operands[1]) == REG)\n+\t    return \\\"lda\t(%1),%0\\\";\n+\t  else\n+\t    return \\\"lda\t%1,%0\\\";\n+\t}\n+      return \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldos\t%1,%0\\\";\n+    case 3:\n+      return \\\"stos\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,misc,load,store\")\n+   (set_attr \"length\" \"*,3,*,*\")])\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, QImode))\n+    DONE;\n+}\")\n+\n+;; The store case can not be separate.  See comment above.\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], QImode)\n+       || register_operand (operands[1], QImode)\n+       || operands[1] == const0_rtx)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t{\n+\t  if (GET_CODE (operands[1]) == REG)\n+\t    return \\\"lda\t(%1),%0\\\";\n+\t  else\n+\t    return \\\"lda\t%1,%0\\\";\n+\t}\n+      return \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldob\t%1,%0\\\";\n+    case 3:\n+      if (operands[1] == const0_rtx)\n+\treturn \\\"stob\tg14,%0\\\";\n+      return \\\"stob\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,misc,load,store\")\n+   (set_attr \"length\" \"*,3,*,*\")])\n+\n+;; The store case can not be separate.  See comment above.\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"dI,i,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], QImode)\n+       || register_operand (operands[1], QImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n+\t{\n+\t  if (GET_CODE (operands[1]) == REG)\n+\t    return \\\"lda\t(%1),%0\\\";\n+\t  else\n+\t    return \\\"lda\t%1,%0\\\";\n+\t}\n+      return \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldob\t%1,%0\\\";\n+    case 3:\n+      return \\\"stob\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,misc,load,store\")\n+   (set_attr \"length\" \"*,3,*,*\")])\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DImode))\n+    DONE;\n+}\")\n+\n+;; The store case can not be separate.  See comment above.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:DI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], DImode)\n+       || register_operand (operands[1], DImode)\n+       || operands[1] == const0_rtx)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"movl\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldl\t%1,%0\\\";\n+    case 3:\n+      if (operands[1] == const0_rtx)\n+\treturn \\\"st\tg14,%0\\;st\tg14,4(%0)\\\";\n+      return \\\"stl\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,load,load,store\")])\n+\n+;; The store case can not be separate.  See comment above.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:DI 1 \"general_operand\" \"dI,i,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], DImode)\n+       || register_operand (operands[1], DImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"movl\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldl\t%1,%0\\\";\n+    case 3:\n+      return \\\"stl\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,load,load,store\")])\n+\n+(define_expand \"movti\"\n+  [(set (match_operand:TI 0 \"general_operand\" \"\")\n+\t(match_operand:TI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, TImode))\n+    DONE;\n+}\")\n+\n+;; The store case can not be separate.  See comment above.\n+(define_insn \"\"\n+  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:TI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], TImode)\n+       || register_operand (operands[1], TImode)\n+       || operands[1] == const0_rtx)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"movq\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldq\t%1,%0\\\";\n+    case 3:\n+      if (operands[1] == const0_rtx)\n+\treturn \\\"st\tg14,%0\\;st\tg14,4(%0)\\;st\tg14,8(%0)\\;st\tg14,12(%0)\\\";\n+      return \\\"stq\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,load,load,store\")])\n+\n+;; The store case can not be separate.  See comment above.\n+(define_insn \"\"\n+  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,m\")\n+\t(match_operand:TI 1 \"general_operand\" \"dI,i,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], TImode)\n+       || register_operand (operands[1], TImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"movq\t%1,%0\\\";\n+    case 1:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 2:\n+      return \\\"ldq\t%1,%0\\\";\n+    case 3:\n+      return \\\"stq\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,load,load,store\")])\n+\n+(define_expand \"store_multiple\"\n+  [(set (match_operand:SI 0 \"\" \"\")\t;;- dest\n+\t(match_operand:SI 1 \"\" \"\"))\t;;- src\n+   (use (match_operand:SI 2 \"\" \"\"))]\t;;- nregs\n+  \"\"\n+  \"\n+{\n+  int regno;\n+  int count;\n+  rtx from;\n+  int i;\n+\n+  if (GET_CODE (operands[0]) != MEM\n+      || GET_CODE (operands[1]) != REG\n+      || GET_CODE (operands[2]) != CONST_INT)\n+    FAIL;\n+\n+  count = INTVAL (operands[2]);\n+  if (count > 12)\n+    FAIL;\n+\n+  regno = REGNO (operands[1]);\n+  from = memory_address (SImode, XEXP (operands[0], 0));\n+  while (count >= 4 && ((regno & 3) == 0))\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  gen_rtx (MEM, TImode, from),\n+\t\t\t  gen_rtx (REG, TImode, regno)));\n+      count -= 4;\n+      regno += 4;\n+      from = memory_address (TImode, plus_constant (from, 16));\n+    }\n+  while (count >= 2 && ((regno & 1) == 0))\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  gen_rtx (MEM, DImode, from),\n+\t\t\t  gen_rtx (REG, DImode, regno)));\n+      count -= 2;\n+      regno += 2;\n+      from = memory_address (DImode, plus_constant (from, 8));\n+    }\n+  while (count > 0)\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  gen_rtx (MEM, SImode, from),\n+\t\t\t  gen_rtx (REG, SImode, regno)));\n+      count -= 1;\n+      regno += 1;\n+      from = memory_address (SImode, plus_constant (from, 4));\n+    }\n+  DONE;\n+}\")\n+\f\n+;; Floating point move insns\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"fpmove_src_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,f,d,d,m\")\n+\t(match_operand:DF 1 \"fpmove_src_operand\" \"r,GH,F,m,dG\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode)\n+       || operands[1] == CONST0_RTX (DFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+\treturn \\\"movrl\t%1,%0\\\";\n+      else\n+\treturn \\\"movl\t%1,%0\\\";\n+    case 1:\n+      return \\\"movrl\t%1,%0\\\";\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 3:\n+      return \\\"ldl\t%1,%0\\\";\n+    case 4:\n+      if (operands[1] == CONST0_RTX (DFmode))\n+\treturn \\\"st\tg14,%0\\;st\tg14,4(%0)\\\";\n+      return \\\"stl\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,f,d,d,m\")\n+\t(match_operand:DF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+\treturn \\\"movrl\t%1,%0\\\";\n+      else\n+\treturn \\\"movl\t%1,%0\\\";\n+    case 1:\n+      return \\\"movrl\t%1,%0\\\";\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 3:\n+      return \\\"ldl\t%1,%0\\\";\n+    case 4:\n+      return \\\"stl\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"fpmove_src_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=r,f,d,d,m\")\n+\t(match_operand:SF 1 \"fpmove_src_operand\" \"r,GH,F,m,dG\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode)\n+       || operands[1] == CONST0_RTX (SFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+\treturn \\\"movr\t%1,%0\\\";\n+      else\n+\treturn \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return \\\"movr\t%1,%0\\\";\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 3:\n+      return \\\"ld\t%1,%0\\\";\n+    case 4:\n+      if (operands[1] == CONST0_RTX (SFmode))\n+\treturn \\\"st\tg14,%0\\\";\n+      return \\\"st\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=r,f,d,d,m\")\n+\t(match_operand:SF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+\treturn \\\"movr\t%1,%0\\\";\n+      else\n+\treturn \\\"mov\t%1,%0\\\";\n+    case 1:\n+      return \\\"movr\t%1,%0\\\";\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 3:\n+      return \\\"ld\t%1,%0\\\";\n+    case 4:\n+      return \\\"st\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n+\f\n+;; Mixed-mode moves with sign and zero-extension.\n+\n+;; Note that the one starting from HImode comes before those for QImode\n+;; so that a constant operand will match HImode, not QImode.\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+ \"\"\n+ \"\n+{\n+  if (GET_CODE (operand1) == REG\n+      || (GET_CODE (operand1) == SUBREG\n+\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      rtx shift_16 = gen_rtx (CONST_INT, VOIDmode, 16);\n+      int op1_subreg_word = 0;\n+\n+      if (GET_CODE (operand1) == SUBREG)\n+\t{\n+\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  operand1 = SUBREG_REG (operand1);\n+\t}\n+      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\n+      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n+      emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldis\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operand1) == REG\n+      || (GET_CODE (operand1) == SUBREG\n+\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+      int op1_subreg_word = 0;\n+\n+      if (GET_CODE (operand1) == SUBREG)\n+\t{\n+\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  operand1 = SUBREG_REG (operand1);\n+\t}\n+      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word),\n+\n+      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n+      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldib\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operand1) == REG\n+      || (GET_CODE (operand1) == SUBREG\n+\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+      int op0_subreg_word = 0;\n+      int op1_subreg_word = 0;\n+\n+      if (GET_CODE (operand1) == SUBREG)\n+\t{\n+\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  operand1 = SUBREG_REG (operand1);\n+\t}\n+      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\n+      if (GET_CODE (operand0) == SUBREG)\n+\t{\n+\t  op0_subreg_word = SUBREG_WORD (operand0);\n+\t  operand0 = SUBREG_REG (operand0);\n+\t}\n+      if (GET_MODE (operand0) != SImode)\n+\toperand0 = gen_rtx (SUBREG, SImode, operand0, op0_subreg_word);\n+\n+      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n+      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldib\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n+ \"\"\n+ \"\n+{\n+  if (GET_CODE (operand1) == REG\n+      || (GET_CODE (operand1) == SUBREG\n+\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      rtx shift_16 = gen_rtx (CONST_INT, VOIDmode, 16);\n+      int op1_subreg_word = 0;\n+\n+      if (GET_CODE (operand1) == SUBREG)\n+\t{\n+\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  operand1 = SUBREG_REG (operand1);\n+\t}\n+      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\n+      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n+      emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldos\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operand1) == REG\n+      || (GET_CODE (operand1) == SUBREG\n+\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+      int op1_subreg_word = 0;\n+\n+      if (GET_CODE (operand1) == SUBREG)\n+\t{\n+\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  operand1 = SUBREG_REG (operand1);\n+\t}\n+      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\n+      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n+      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldob\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operand1) == REG\n+      || (GET_CODE (operand1) == SUBREG\n+\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n+    {\n+      rtx temp = gen_reg_rtx (SImode);\n+      rtx shift_24 = gen_rtx (CONST_INT, VOIDmode, 24);\n+      int op0_subreg_word = 0;\n+      int op1_subreg_word = 0;\n+\n+      if (GET_CODE (operand1) == SUBREG)\n+\t{\n+\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  operand1 = SUBREG_REG (operand1);\n+\t}\n+      operand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\n+      if (GET_CODE (operand0) == SUBREG)\n+\t{\n+\t  op0_subreg_word = SUBREG_WORD (operand0);\n+\t  operand0 = SUBREG_REG (operand0);\n+\t}\n+      if (GET_MODE (operand0) != SImode)\n+\toperand0 = gen_rtx (SUBREG, SImode, operand0, op0_subreg_word);\n+\n+      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n+      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"ldob\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n+;; Conversions between float and double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,d\")\n+\t(float_extend:DF (match_operand:SF 1 \"fp_arith_operand\" \"dGH,fGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"@\n+  movr\t%1,%0\n+  movrl\t%1,%0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(float_truncate:SF\n+\t (match_operand:DF 1 \"fp_arith_operand\" \"fGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"movr\t%1,%0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\n+;; Conversion between fixed point and floating point.\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtir\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=df\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtir\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+;; Convert a float to an actual integer.\n+;; Truncation is performed as part of the conversion.\n+;; The i960 requires conversion from DFmode to DImode to make\n+;; unsigned conversions work properly.\n+\n+(define_insn \"fixuns_truncdfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(unsigned_fix:DI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"fGH\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtzril\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_insn \"fixuns_truncsfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(unsigned_fix:DI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"fGH\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtzril\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"fGH\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtzri\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_expand \"fixuns_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (DImode);\n+  emit_insn (gen_rtx (SET, VOIDmode, temp,\n+\t\t      gen_rtx (UNSIGNED_FIX, DImode,\n+\t\t\t       gen_rtx (FIX, DFmode, operands[1]))));\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t      gen_rtx (SUBREG, SImode, temp, 0)));\n+  DONE;\n+}\")\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"dfGH\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtzri\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_expand \"fixuns_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (DImode);\n+  emit_insn (gen_rtx (SET, VOIDmode, temp,\n+\t\t      gen_rtx (UNSIGNED_FIX, DImode,\n+\t\t\t       gen_rtx (FIX, SFmode, operands[1]))));\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t      gen_rtx (SUBREG, SImode, temp, 0)));\n+  DONE;\n+}\")\n+\f\n+;; Arithmetic instructions.\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(minus:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"subo\t%2,%1,%0\")\n+\n+;; Try to generate an lda instruction when it would be faster than an\n+;; add instruction.\n+;; Some assemblers apparently won't accept two addresses added together.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n+\t(plus:SI (match_operand:SI 1 \"arith32_operand\" \"%dn,i,dn\")\n+\t\t (match_operand:SI 2 \"arith32_operand\" \"dn,dn,i\")))]\n+  \"(TARGET_C_SERIES) && (CONSTANT_P (operands[1]) || CONSTANT_P (operands[2]))\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      rtx tmp = operands[1];\n+      operands[1] = operands[2];\n+      operands[2] = tmp;\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && GET_CODE (operands[1]) == REG\n+      && i960_last_insn_type != I_TYPE_REG)\n+    {\n+      if (INTVAL (operands[2]) < 0 && INTVAL (operands[2]) > -32)\n+\treturn \\\"subo\t%n2,%1,%0\\\";\n+      else if (INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 32)\n+\treturn \\\"addo\t%1,%2,%0\\\";\n+    }\n+  if (CONSTANT_P (operands[1]))\n+    return \\\"lda\t%1+%2,%0\\\";\n+  return \\\"lda\t%2(%1),%0\\\";\n+}\")\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(plus:SI (match_operand:SI 1 \"signed_arith_operand\" \"%dI\")\n+\t\t (match_operand:SI 2 \"signed_arith_operand\" \"dIK\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) < 0 && INTVAL (operands[2]) > -32)\n+    return \\\"subo\t%n2,%1,%0\\\";\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"addo\t%2,%1,%0\\\";\n+  return \\\"addo\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"mulo\t%2,%1,%0\\\";\n+  return \\\"mulo\t%1,%2,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"mult\")])\n+\n+;; This goes after the move/add/sub/mul instructions  \n+;; because those instructions are better when they apply.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"lda\t%a1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+;; This will never be selected because of an \"optimization\" that GCC does.\n+;; It always converts divides by a power of 2 into a sequence of instructions\n+;; that does a right shift, and then corrects the result if it was negative.\n+\n+;; (define_insn \"\"\n+;;   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+;;         (div:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+;;                 (match_operand:SI 2 \"power2_operand\" \"nI\")))]\n+;;   \"\"\n+;;   \"*{\n+;; \toperands[2] = gen_rtx(CONST_INT, VOIDmode,bitpos (INTVAL (operands[2])));\n+;; \treturn \\\"shrdi\t%2,%1,%0\\\";\n+;;   }\"\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (div:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+                (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"divi\t%2,%1,%0\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (udiv:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"divo\t%2,%1,%0\"\n+  [(set_attr \"type\" \"div\")])\n+\n+;; We must use `remi' not `modi' here, to ensure that `%' has the effects\n+;; specified by the ANSI C standard.\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (mod:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+                (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"remi\t%2,%1,%0\"\n+  [(set_attr \"type\" \"div\")])\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (umod:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"remo\t%2,%1,%0\"\n+  [(set_attr \"type\" \"div\")])\n+\n+;; And instructions (with complement also).\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(and:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"and\t%2,%1,%0\\\";\n+  return \\\"and\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"arith_operand\" \"dI\"))\n+\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"notand\t%2,%1,%0\\\";\n+  return \\\"andnot\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"arith_operand\" \"%dI\"))\n+\t\t(not:SI (match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"nand\t%2,%1,%0\\\";\n+  return \\\"nand\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (and:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"nand\t%2,%1,%0\\\";\n+  return \\\"nand\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+\t\t(match_operand:SI 2 \"power2_operand\" \"n\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t bitpos (INTVAL (operands[2])));\n+  return \\\"setbit\t%2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (match_operand:SI 1 \"power2_operand\" \"n\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t bitpos (INTVAL (operands[1])));\n+  return \\\"setbit\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"or\t%2,%1,%0\\\";\n+  return \\\"or\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"arith_operand\" \"dI\"))\n+\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"notor\t%2,%1,%0\\\";\n+  return \\\"ornot\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"arith_operand\" \"%dI\"))\n+\t\t(not:SI (match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"nor\t%2,%1,%0\\\";\n+  return \\\"nor\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (ior:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"nor\t%2,%1,%0\\\";\n+  return \\\"nor\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"xor\t%2,%1,%0\\\";\n+  return \\\"xor\t%1,%2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (i960_bypass (insn, operands[1], operands[2], 0))\n+    return \\\"xnor\t%2,%1,%0\\\";\n+  return \\\"xnor\t%2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"subo\t%1,0,%0\"\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"not\t%1,%0\"\n+  [(set_attr \"length\" \"1\")])\n+\f\n+;; Floating point arithmetic instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(plus:DF (match_operand:DF 1 \"fp_arith_operand\" \"%rGH\")\n+\t\t (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"addrl\t%1,%2,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(plus:SF (match_operand:SF 1 \"fp_arith_operand\" \"%rGH\")\n+\t\t (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"addr\t%1,%2,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(minus:DF (match_operand:DF 1 \"fp_arith_operand\" \"rGH\")\n+\t\t  (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"subrl\t%2,%1,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(minus:SF (match_operand:SF 1 \"fp_arith_operand\" \"rGH\")\n+\t\t  (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"subr\t%2,%1,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(mult:DF (match_operand:DF 1 \"fp_arith_operand\" \"rGH\")\n+\t\t (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"mulrl\t%1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(mult:SF (match_operand:SF 1 \"fp_arith_operand\" \"rGH\")\n+\t\t (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"mulr\t%1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(div:DF (match_operand:DF 1 \"fp_arith_operand\" \"rGH\")\n+\t\t(match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"divrl\t%2,%1,%0\"\n+  [(set_attr \"type\" \"fpdiv\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(div:SF (match_operand:SF 1 \"fp_arith_operand\" \"rGH\")\n+\t\t(match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n+  \"TARGET_NUMERICS\"\n+  \"divr\t%2,%1,%0\"\n+  [(set_attr \"type\" \"fpdiv\")])\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d,f\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"d,r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (REGNO (operands[0]) == REGNO (operands[1]))\n+\treturn \\\"notbit\t31,%D1,%D0\\\";\n+      return \\\"mov\t%1,%0\\;notbit\t31,%D1,%D0\\\";\n+    }\n+  return \\\"subrl\t%1,0f0.0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d,f\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"d,r\")))]\n+  \"\"\n+  \"@\n+  notbit\t31,%1,%0\n+  subr\t%1,0f0.0,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+;;; The abs patterns also work even if the target machine doesn't have\n+;;; floating point, because in that case dstreg and srcreg will always be\n+;;; less than 32.\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=df\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"df\")))]\n+  \"\"\n+  \"*\n+{\n+  int dstreg = REGNO (operands[0]);\n+  int srcreg = REGNO (operands[1]);\n+\n+  if (dstreg < 32)\n+    {\n+      if (srcreg < 32)\n+\t{\n+\t  if (dstreg != srcreg)\n+\t    output_asm_insn (\\\"mov\t%1,%0\\\", operands);\n+\t  return \\\"clrbit\t31,%D1,%D0\\\";\n+\t}\n+      /* Src is an fp reg.  */\n+      return \\\"movrl\t%1,%0\\;clrbit\t31,%D1,%D0\\\";\n+    }\n+  if (srcreg >= 32)\n+    return \\\"cpysre\t%1,0f0.0,%0\\\";\n+  return \\\"movrl\t%1,%0\\;cpysre\t%0,0f0.0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=df\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"df\")))]\n+  \"\"\n+  \"*\n+{\n+  int dstreg = REGNO (operands[0]);\n+  int srcreg = REGNO (operands[1]);\n+\n+  if (dstreg < 32 && srcreg < 32)\n+    return \\\"clrbit\t31,%1,%0\\\";\n+\n+  if (dstreg >= 32 && srcreg >= 32)\n+    return \\\"cpysre\t%1,0f0.0,%0\\\";\n+\n+  if (dstreg < 32)\n+    return \\\"movr\t%1,%0\\;clrbit\t31,%0,%0\\\";\n+\n+  return \\\"movr\t%1,%0\\;cpysre\t%0,0f0.0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\f\n+;; Tetra (16 byte) float support.\n+\n+(define_insn \"cmptf\"\n+  [(set (reg:CC 36)\n+\t(compare:CC (match_operand:TF 0 \"register_operand\" \"f\")\n+\t\t    (match_operand:TF 1 \"nonmemory_operand\" \"fG\")))]\n+  \"TARGET_NUMERICS\"\n+  \"cmpr\t%0,%1\"\n+  [(set_attr \"type\" \"fpcc\")])\n+\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"\")\n+\t(match_operand:TF 1 \"fpmove_src_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, TFmode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"=r,f,d,d,m\")\n+\t(match_operand:TF 1 \"fpmove_src_operand\" \"r,GH,F,m,dG\"))]\n+  \"current_function_args_size <= 48\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode)\n+       || operands[1] == CONST0_RTX (TFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+\treturn \\\"movre\t%1,%0\\\";\n+      else\n+\treturn \\\"movq\t%1,%0\\\";\n+    case 1:\n+      return \\\"movre\t%1,%0\\\";\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 3:\n+      return \\\"ldq\t%1,%0\\\";\n+    case 4:\n+      if (operands[1] == CONST0_RTX (TFmode))\n+\treturn \\\"st\tg14,%0\\;st\tg14,4(%0)\\;st\tg14,8(%0)\\;st\tg14,12(%0)\\\";\n+      return \\\"stq\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"=r,f,d,d,m\")\n+\t(match_operand:TF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n+  \"current_function_args_size > 48\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+\treturn \\\"movre\t%1,%0\\\";\n+      else\n+\treturn \\\"movq\t%1,%0\\\";\n+    case 1:\n+      return \\\"movre\t%1,%0\\\";\n+    case 2:\n+      return i960_output_ldconst (operands[0], operands[1]);\n+    case 3:\n+      return \\\"ldq\t%1,%0\\\";\n+    case 4:\n+      return \\\"stq\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n+\n+(define_insn \"extendsftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,d\")\n+\t(float_extend:TF\n+\t (match_operand:SF 1 \"register_operand\" \"d,f\")))]\n+  \"TARGET_NUMERICS\"\n+  \"@\n+  movr\t%1,%0\n+  movre\t%1,%0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\n+(define_insn \"extenddftf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f,d\")\n+\t(float_extend:TF\n+\t (match_operand:DF 1 \"register_operand\" \"d,f\")))]\n+  \"TARGET_NUMERICS\"\n+  \"@\n+  movrl\t%1,%0\n+  movre\t%1,%0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\n+(define_insn \"trunctfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(float_truncate:DF\n+\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_NUMERICS\"\n+  \"movrl\t%1,%0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\n+(define_insn \"trunctfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n+\t(float_truncate:SF\n+\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_NUMERICS\"\n+  \"movr\t%1,%0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\n+(define_insn \"floatsitf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(float:TF (match_operand:SI 1 \"register_operand\" \"d\")))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtir\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_insn \"fix_trunctfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtzri\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_insn \"fixuns_trunctfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unsigned_fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_NUMERICS\"\n+  \"cvtzri\t%1,%0\"\n+  [(set_attr \"type\" \"fpcvt\")])\n+\n+(define_insn \"addtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(plus:TF (match_operand:TF 1 \"nonmemory_operand\" \"%fG\")\n+\t\t (match_operand:TF 2 \"nonmemory_operand\" \"fG\")))]\n+  \"TARGET_NUMERICS\"\n+  \"addr\t%1,%2,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+(define_insn \"subtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(minus:TF (match_operand:TF 1 \"nonmemory_operand\" \"fG\")\n+\t\t  (match_operand:TF 2 \"nonmemory_operand\" \"fG\")))]\n+  \"TARGET_NUMERICS\"\n+  \"subr\t%2,%1,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+(define_insn \"multf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(mult:TF (match_operand:TF 1 \"nonmemory_operand\" \"fG\")\n+\t\t (match_operand:TF 2 \"nonmemory_operand\" \"fG\")))]\n+  \"TARGET_NUMERICS\"\n+  \"mulr\t%1,%2,%0\"\n+  [(set_attr \"type\" \"fpmul\")])\n+\n+(define_insn \"divtf3\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(div:TF (match_operand:TF 1 \"nonmemory_operand\" \"fG\")\n+\t\t(match_operand:TF 2 \"nonmemory_operand\" \"fG\")))]\n+  \"TARGET_NUMERICS\"\n+  \"divr\t%2,%1,%0\"\n+  [(set_attr \"type\" \"fpdiv\")])\n+\n+(define_insn \"negtf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(neg:TF (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_NUMERICS\"\n+  \"subr\t%1,0f0.0,%0\"\n+  [(set_attr \"type\" \"fpadd\")])\n+\n+(define_insn \"abstf2\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n+\t(abs:TF (match_operand:TF 1 \"register_operand\" \"f\")))]\n+  \"(TARGET_NUMERICS)\"\n+  \"cpysre\t%1,0f0.0,%0\"\n+  [(set_attr \"type\" \"fpmove\")])\n+\f\n+;; Arithmetic shift instructions.\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"shli\t%2,%1,%0\"\n+  [(set_attr \"type\" \"alu2\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"shri\t%2,%1,%0\"\n+  [(set_attr \"type\" \"alu2\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"\"\n+  \"shro\t%2,%1,%0\"\n+  [(set_attr \"type\" \"alu2\")])\n+\f\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"b\t%l0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"b*\t%0\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"bx\t(%0)\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+;;- jump to subroutine\n+\n+(define_expand \"call\"\n+  [(call (match_operand:SI 0 \"general_operand\" \"\")\n+\t (match_operand:SI 1 \"immediate_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  i960_expand_call (operand0, operand1, 0);\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(call (match_operand:SI 0 \"general_operand\" \"g\")\n+\t (match_operand:SI 1 \"immediate_operand\" \"i\"))]\n+  \"\"\n+  \"* return i960_output_call_insn (operands[0], operands[1], insn);\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+\t(call (match_operand:SI 1 \"general_operand\" \"g\")\n+\t      (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"\n+{\n+  i960_expand_call (operand1, operand2, operand0);\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+\t(call (match_operand:SI 1 \"general_operand\" \"g\")\n+\t      (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"* return i960_output_call_insn (operands[1], operands[2], insn);\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"\"\n+  \"* return i960_output_ret_insn (insn);\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"\")\n+\f\n+;; Various peephole optimizations for multiple-word moves, loads, and stores.\n+;; Multiple register moves.\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n+\t(match_operand:SI 5 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 6 \"register_operand\" \"=r\")\n+\t(match_operand:SI 7 \"register_operand\" \"r\"))]\n+  \"((REGNO (operands[0]) & 3) == 0)\n+   && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n+   && (REGNO (operands[0]) + 3 == REGNO (operands[6]))\n+   && (REGNO (operands[1]) + 3 == REGNO (operands[7]))\"\n+  \"movq\t%1,%0\")\n+\n+;; Matched 4/17/92\n+(define_peephole\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n+\t(match_operand:DI 3 \"register_operand\" \"r\"))]\n+  \"((REGNO (operands[0]) & 3) == 0)\n+   && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\"\n+  \"movq\t%1,%0\")\n+\n+;; Matched 4/17/92\n+(define_peephole\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n+\t(match_operand:SI 5 \"register_operand\" \"r\"))]\n+  \"((REGNO (operands[0]) & 3) == 0)\n+   && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\n+   && (REGNO (operands[0]) + 3 == REGNO (operands[4]))\n+   && (REGNO (operands[1]) + 3 == REGNO (operands[5]))\"\n+  \"movq\t%1,%0\")\n+\n+;; Matched 4/17/92\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))\n+   (set (match_operand:DI 4 \"register_operand\" \"=r\")\n+\t(match_operand:DI 5 \"register_operand\" \"r\"))]\n+  \"((REGNO (operands[0]) & 3) == 0)\n+   && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\"\n+  \"movq\t%1,%0\")\n+\n+;; Matched 4/17/92\n+(define_peephole\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"((REGNO (operands[0]) & 3) == 0)\n+   && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\"\n+  \"movt\t%1,%0\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n+\t(match_operand:SI 5 \"register_operand\" \"r\"))]\n+  \"((REGNO (operands[0]) & 3) == 0)\n+   && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\"\n+  \"movt\t%1,%0\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"((REGNO (operands[0]) & 1) == 0)\n+   && ((REGNO (operands[1]) & 1) == 0)\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\"\n+  \"movl\t%1,%0\")\n+\f\n+; Multiple register loads.\n+\n+;; Matched 6/15/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 5 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 7 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 8 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n+   && (REGNO (operands[1]) != REGNO (operands[3]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[5]))\n+   && (REGNO (operands[1]) != REGNO (operands[5]))\n+   && (REGNO (operands[0]) + 3 == REGNO (operands[7]))\n+   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4]))\n+   && (INTVAL (operands[2]) + 8 == INTVAL (operands[6]))\n+   && (INTVAL (operands[2]) + 12 == INTVAL (operands[8])))\"\n+  \"ldq\t%2(%1),%0\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n+\t(mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:DF 3 \"register_operand\" \"=d\")\n+\t(mem:DF (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[3]))\n+   && (REGNO (operands[1]) != REGNO (operands[3]))\n+   && (INTVAL (operands[2]) + 8 == INTVAL (operands[4])))\"\n+  \"ldq\t%2(%1),%0\")\n+\n+;; Matched 1/24/92\n+(define_peephole\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(mem:DI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:DI 3 \"register_operand\" \"=d\")\n+\t(mem:DI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[3]))\n+   && (REGNO (operands[1]) != REGNO (operands[3]))\n+   && (INTVAL (operands[2]) + 8 == INTVAL (operands[4])))\"\n+  \"ldq\t%2(%1),%0\")\n+\n+;; Matched 4/17/92\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n+   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 4 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 6 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 7 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_ti (operands[1], 0) && ((REGNO (operands[0]) & 3) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) != REGNO (operands[2]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n+   && (REGNO (operands[1]) != REGNO (operands[4]))\n+   && (REGNO (operands[0]) + 3 == REGNO (operands[6]))\n+   && (INTVAL (operands[3]) == 4)\n+   && (INTVAL (operands[5]) == 8)\n+   && (INTVAL (operands[7]) == 12))\"\n+  \"ldq\t(%1),%0\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 5 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n+   && (REGNO (operands[1]) != REGNO (operands[3]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[5]))\n+   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4]))\n+   && (INTVAL (operands[2]) + 8 == INTVAL (operands[6])))\"\n+  \"ldt\t%2(%1),%0\")\n+\n+;; Matched 6/15/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n+   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 4 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_ti (operands[1], 0) && ((REGNO (operands[0]) & 3) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n+   && (REGNO (operands[1]) != REGNO (operands[2]))\n+   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n+   && (INTVAL (operands[3]) == 4)\n+   && (INTVAL (operands[5]) == 8))\"\n+  \"ldt\t(%1),%0\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_di (operands[1], operands[2]) && ((REGNO (operands[0]) & 1) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n+   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4])))\"\n+  \"ldl\t%2(%1),%0\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n+   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_dup 1)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))]\n+  \"(i960_si_di (operands[1], 0) && ((REGNO (operands[0]) & 1) == 0)\n+   && (REGNO (operands[1]) != REGNO (operands[0]))\n+   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n+   && (INTVAL (operands[3]) == 4))\"\n+  \"ldl\t(%1),%0\")\n+\f\n+; Multiple register stores.\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 2 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 4 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 6 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 7 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 8 \"register_operand\" \"d\"))]\n+  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n+   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n+   && (REGNO (operands[2]) + 2 == REGNO (operands[6]))\n+   && (REGNO (operands[2]) + 3 == REGNO (operands[8]))\n+   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3]))\n+   && (INTVAL (operands[1]) + 8 == INTVAL (operands[5]))\n+   && (INTVAL (operands[1]) + 12 == INTVAL (operands[7])))\"\n+  \"stq\t%2,%1(%0)\")\n+\n+;; Matched 6/16/91\n+(define_peephole\n+  [(set (mem:DF (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n+\t(match_operand:DF 2 \"register_operand\" \"d\"))\n+   (set (mem:DF (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n+\t(match_operand:DF 4 \"register_operand\" \"d\"))]\n+  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n+   && (REGNO (operands[2]) + 2 == REGNO (operands[4]))\n+   && (INTVAL (operands[1]) + 8 == INTVAL (operands[3])))\"\n+  \"stq\t%2,%1(%0)\")\n+\n+;; Matched 4/17/92\n+(define_peephole\n+  [(set (mem:DI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n+\t(match_operand:DI 2 \"register_operand\" \"d\"))\n+   (set (mem:DI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n+\t(match_operand:DI 4 \"register_operand\" \"d\"))]\n+  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n+   && (REGNO (operands[2]) + 2 == REGNO (operands[4]))\n+   && (INTVAL (operands[1]) + 8 == INTVAL (operands[3])))\"\n+  \"stq\t%2,%1(%0)\")\n+\n+;; Matched 1/23/92\n+(define_peephole\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n+\t(match_operand:SI 1 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 3 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 5 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 7 \"register_operand\" \"d\"))]\n+  \"(i960_si_ti (operands[0], 0) && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n+   && (REGNO (operands[1]) + 3 == REGNO (operands[7]))\n+   && (INTVAL (operands[2]) == 4)\n+   && (INTVAL (operands[4]) == 8)\n+   && (INTVAL (operands[6]) == 12))\"\n+  \"stq\t%1,(%0)\")\n+\n+;; Matched 5/29/91\n+(define_peephole\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 2 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 4 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 6 \"register_operand\" \"d\"))]\n+  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n+   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n+   && (REGNO (operands[2]) + 2 == REGNO (operands[6]))\n+   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3]))\n+   && (INTVAL (operands[1]) + 8 == INTVAL (operands[5])))\"\n+  \"stt\t%2,%1(%0)\")\n+\n+;; Matched 5/29/91\n+(define_peephole\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n+\t(match_operand:SI 1 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 3 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 5 \"register_operand\" \"d\"))]\n+  \"(i960_si_ti (operands[0], 0) && ((REGNO (operands[1]) & 3) == 0)\n+   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n+   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n+   && (INTVAL (operands[2]) == 4)\n+   && (INTVAL (operands[4]) == 8))\"\n+  \"stt\t%1,(%0)\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 2 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 4 \"register_operand\" \"d\"))]\n+  \"(i960_si_di (operands[0], operands[1]) && ((REGNO (operands[2]) & 1) == 0)\n+   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n+   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3])))\"\n+  \"stl\t%2,%1(%0)\")\n+\n+;; Matched 5/28/91\n+(define_peephole\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n+\t(match_operand:SI 1 \"register_operand\" \"d\"))\n+   (set (mem:SI (plus:SI (match_dup 0)\n+\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+\t(match_operand:SI 3 \"register_operand\" \"d\"))]\n+  \"(i960_si_di (operands[0], 0) && ((REGNO (operands[1]) & 1) == 0)\n+   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n+   && (INTVAL (operands[2]) == 4))\"\n+  \"stl\t%1,(%0)\")\n+\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}, {"sha": "8424cf03655b82550447cf6b4c1b64870e024516", "filename": "gcc/ginclude/va-i960.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fginclude%2Fva-i960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba8ab3554e47a10bbae41bc75b77fdd01c012345/gcc%2Fginclude%2Fva-i960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-i960.h?ref=ba8ab3554e47a10bbae41bc75b77fdd01c012345", "patch": "@@ -0,0 +1,45 @@\n+/* GNU C varargs support for the Intel 80960.  */\n+\n+/* In GCC version 2, we want an ellipsis at the end of the declaration\n+   of the argument list.  GCC version 1 can't parse it.  */\n+\n+#if __GNUC__ > 1\n+#define __va_ellipsis ...\n+#else\n+#define __va_ellipsis\n+#endif\n+\n+#define\tva_alist __builtin_va_alist\n+#define\tva_dcl\t char *__builtin_va_alist; __va_ellipsis\n+\n+/* The first element is the address of the first argument.\n+   The second element is the number of bytes skipped past so far.  */\n+typedef unsigned va_list[2];\t\n+\n+/* The stack size of the type t.  */\n+#define __vsiz(T)   (((sizeof (T) + 3) / 4) * 4)\n+/* The stack alignment of the type t.  */\n+#define __vali(T)   (__alignof__ (T) >= 4 ? __alignof__ (T) : 4)\n+/* The offset of the next stack argument after one of type t at offset i.  */\n+#define __vpad(I, T) ((((I) + __vali (T) - 1) / __vali (T)) \\\n+\t\t       * __vali (T) + __vsiz (T))\n+\n+#ifdef _STDARG_H\n+#define va_start(AP, LASTARG) ((AP)[1] = 0, \\\n+\t\t\t\t*(AP) = (unsigned) __builtin_next_arg ())\n+#else\n+#define\tva_start(AP) ((AP)[1] = 0, *(AP) = (unsigned) &va_alist)\n+#endif\n+\n+#define\tva_arg(AP, T)\t\t\t\t\t\t\t\\\n+(\t\t\t\t\t\t\t\t\t\\\n+  (\t\t\t\t\t\t\t\t\t\\\n+    ((AP)[1] <= 48 && (__vpad ((AP)[1], T) > 48 || __vsiz (T) > 16))\t\\\n+      ? ((AP)[1] = 48 + __vsiz (T))\t\t\t\t\t\\\n+      : ((AP)[1] = __vpad ((AP)[1], T))\t\t\t\t\t\\\n+  ),\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  *((T *) ((char *) *(AP) + (AP)[1] - __vsiz (T)))\t\t\t\\\n+)\n+\n+#define\tva_end(AP)"}]}