{"sha": "ac9e9918462165841002d13123546e6e179e7be5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM5ZTk5MTg0NjIxNjU4NDEwMDJkMTMxMjM1NDZlNmUxNzllN2JlNQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:57:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:57:10Z"}, "message": "exp_prag.adb (Expand_Pragma_Common_Object): Use a single Machine_Attribute pragma internally to implement the user pragma.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_prag.adb (Expand_Pragma_Common_Object): Use a single\n\tMachine_Attribute pragma internally to implement the user pragma.\n\tAdd processing for pragma Interface so that it is now completely\n\tequivalent to pragma Import.\n\n\t* sem_prag.adb (Analyze_Pragma, case Obsolescent): Extend this pragma\n\tso that it can be applied to all entities, including record components\n\tand enumeration literals.\n\t(Analyze_Pragma, case Priority_Specific_Dispatching): Check whether\n\tpriority ranges are correct, verify compatibility against task\n\tdispatching and locking policies, and if everything is correct an entry\n\tis added to the table containing priority specific dispatching entries\n\tfor this compilation unit.\n\t(Delay_Config_Pragma_Analyze): Delay processing\n\tPriority_Specific_Dispatching pragmas because when processing the\n\tpragma we need to access run-time data, such as the range of\n\tSystem.Any_Priority.\n\t(Sig_Flags): Add Pragma_Priority_Specific_Dispatching.\n\tAllow pragma Unreferenced as a context item\n\tAdd pragma Preelaborable_Initialization\n\t(Analyze_Pragma, case Interface): Interface is extended so that it is\n\tnow syntactically and semantically equivalent to Import.\n\t(Analyze_Pragma, case Compile_Time_Warning): Fix error of blowups on\n\tinsertion characters.\n\tAdd handling for Pragma_Wide_Character_Encoding\n\t(Process_Restrictions_Restriction_Warnings): Ensure that a warning\n\tnever supercedes a real restriction, and that a real restriction\n\talways supercedes a warning.\n\t(Analyze_Pragma, case Assert): Set Low_Bound_Known if assert is of\n\tappropriate form.\n\nFrom-SVN: r118268", "tree": {"sha": "a63281235b9996249e1ebf9d52ce1f2e5fb26752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a63281235b9996249e1ebf9d52ce1f2e5fb26752"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac9e9918462165841002d13123546e6e179e7be5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9e9918462165841002d13123546e6e179e7be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac9e9918462165841002d13123546e6e179e7be5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac9e9918462165841002d13123546e6e179e7be5/comments", "author": null, "committer": null, "parents": [{"sha": "53cc4a7aa19330388a8262003f49753252c3561a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53cc4a7aa19330388a8262003f49753252c3561a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53cc4a7aa19330388a8262003f49753252c3561a"}], "stats": {"total": 1372, "additions": 890, "deletions": 482}, "files": [{"sha": "ada99fc1052d0c9f7f77c38e6737f3e2559fd114", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9e9918462165841002d13123546e6e179e7be5/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9e9918462165841002d13123546e6e179e7be5/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=ac9e9918462165841002d13123546e6e179e7be5", "patch": "@@ -63,7 +63,7 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Abort_Defer             (N : Node_Id);\n    procedure Expand_Pragma_Assert                  (N : Node_Id);\n    procedure Expand_Pragma_Common_Object           (N : Node_Id);\n-   procedure Expand_Pragma_Import                  (N : Node_Id);\n+   procedure Expand_Pragma_Import_Or_Interface     (N : Node_Id);\n    procedure Expand_Pragma_Import_Export_Exception (N : Node_Id);\n    procedure Expand_Pragma_Inspection_Point        (N : Node_Id);\n    procedure Expand_Pragma_Interrupt_Priority      (N : Node_Id);\n@@ -136,14 +136,17 @@ package body Exp_Prag is\n                Expand_Pragma_Import_Export_Exception (N);\n \n             when Pragma_Import =>\n-               Expand_Pragma_Import (N);\n+               Expand_Pragma_Import_Or_Interface (N);\n \n             when Pragma_Import_Exception =>\n                Expand_Pragma_Import_Export_Exception (N);\n \n             when Pragma_Inspection_Point =>\n                Expand_Pragma_Inspection_Point (N);\n \n+            when Pragma_Interface =>\n+               Expand_Pragma_Import_Or_Interface (N);\n+\n             when Pragma_Interrupt_Priority =>\n                Expand_Pragma_Interrupt_Priority (N);\n \n@@ -299,19 +302,12 @@ package body Exp_Prag is\n    -- Expand_Pragma_Common_Object --\n    ---------------------------------\n \n-   --  Add series of pragmas to replicate semantic effect in DEC Ada\n+   --  Use a machine attribute to replicate semantic effect in DEC Ada\n \n-   --    pragma Linker_Section (internal_name, external_name);\n-   --    pragma Machine_Attribute (internal_name, \"overlaid\");\n-   --    pragma Machine_Attribute (internal_name, \"global\");\n-   --    pragma Machine_Attribute (internal_name, \"initialize\");\n+   --    pragma Machine_Attribute (intern_name, \"common_object\", extern_name);\n \n    --  For now we do nothing with the size attribute ???\n \n-   --  Really this expansion would be much better in the back end. The\n-   --  front end should not need to know about target dependent, back end\n-   --  dependent semantics ???\n-\n    procedure Expand_Pragma_Common_Object (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n \n@@ -351,34 +347,9 @@ package body Exp_Prag is\n \n       Ploc := Sloc (Psect);\n \n-      --  Insert pragmas\n-\n-      Insert_List_After_And_Analyze (N, New_List (\n-\n-         --  The Linker_Section pragma ensures the correct section\n-\n-         Make_Pragma (Loc,\n-           Chars => Name_Linker_Section,\n-           Pragma_Argument_Associations => New_List (\n-             Make_Pragma_Argument_Association (Iloc,\n-               Expression => New_Copy_Tree (Internal)),\n-             Make_Pragma_Argument_Association (Ploc,\n-               Expression => New_Copy_Tree (Psect)))),\n-\n-         --  Machine_Attribute \"overlaid\" ensures that this section\n-         --  overlays any other sections of the same name.\n-\n-         Make_Pragma (Loc,\n-           Chars => Name_Machine_Attribute,\n-           Pragma_Argument_Associations => New_List (\n-             Make_Pragma_Argument_Association (Iloc,\n-               Expression => New_Copy_Tree (Internal)),\n-             Make_Pragma_Argument_Association (Eloc,\n-               Expression =>\n-                 Make_String_Literal (Sloc => Ploc,\n-                   Strval => \"overlaid\")))),\n+      --  Insert the pragma\n \n-         --  Machine_Attribute \"global\" ensures that section is visible\n+      Insert_After_And_Analyze (N,\n \n          Make_Pragma (Loc,\n            Chars => Name_Machine_Attribute,\n@@ -388,24 +359,15 @@ package body Exp_Prag is\n              Make_Pragma_Argument_Association (Eloc,\n                Expression =>\n                  Make_String_Literal (Sloc => Ploc,\n-                   Strval => \"global\")))),\n-\n-         --  Machine_Attribute \"initialize\" ensures section is demand zeroed\n+                   Strval => \"common_object\")),\n+             Make_Pragma_Argument_Association (Ploc,\n+               Expression => New_Copy_Tree (Psect)))));\n \n-         Make_Pragma (Loc,\n-           Chars => Name_Machine_Attribute,\n-           Pragma_Argument_Associations => New_List (\n-             Make_Pragma_Argument_Association (Iloc,\n-               Expression => New_Copy_Tree (Internal)),\n-             Make_Pragma_Argument_Association (Eloc,\n-               Expression =>\n-                 Make_String_Literal (Sloc => Ploc,\n-                   Strval => \"initialize\"))))));\n    end Expand_Pragma_Common_Object;\n \n-   --------------------------\n-   -- Expand_Pragma_Import --\n-   --------------------------\n+   ---------------------------------------\n+   -- Expand_Pragma_Import_Or_Interface --\n+   ---------------------------------------\n \n    --  When applied to a variable, the default initialization must not be\n    --  done. As it is already done when the pragma is found, we just get rid\n@@ -418,7 +380,7 @@ package body Exp_Prag is\n    --  have to elaborate the initialization expression when it is first\n    --  seen (i.e. this elaboration cannot be deferred to the freeze point).\n \n-   procedure Expand_Pragma_Import (N : Node_Id) is\n+   procedure Expand_Pragma_Import_Or_Interface (N : Node_Id) is\n       Def_Id    : constant Entity_Id := Entity (Arg2 (N));\n       Typ       : Entity_Id;\n       Init_Call : Node_Id;\n@@ -455,7 +417,7 @@ package body Exp_Prag is\n             Set_Expression (Parent (Def_Id), Empty);\n          end if;\n       end if;\n-   end Expand_Pragma_Import;\n+   end Expand_Pragma_Import_Or_Interface;\n \n    -------------------------------------------\n    -- Expand_Pragma_Import_Export_Exception --"}, {"sha": "aa994a4ae03c5ea86a69368bded515f4c3eb34cc", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 873, "deletions": 427, "changes": 1300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac9e9918462165841002d13123546e6e179e7be5/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac9e9918462165841002d13123546e6e179e7be5/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ac9e9918462165841002d13123546e6e179e7be5", "patch": "@@ -495,7 +495,15 @@ package body Sem_Prag is\n \n       function Is_Configuration_Pragma return Boolean;\n       --  Deterermines if the placement of the current pragma is appropriate\n-      --  for a configuration pragma (precedes the current compilation unit)\n+      --  for a configuration pragma (precedes the current compilation unit).\n+\n+      function Is_In_Context_Clause return Boolean;\n+      --  Returns True if pragma appears within the context clause of a unit,\n+      --  and False for any other placement (does not generate any messages).\n+\n+      function Is_Static_String_Expression (Arg : Node_Id) return Boolean;\n+      --  Analyzes the argument, and determines if it is a static string\n+      --  expression, returns True if so, False if non-static or not String.\n \n       procedure Pragma_Misplaced;\n       --  Issue fatal error message for misplaced pragma\n@@ -581,8 +589,9 @@ package body Sem_Prag is\n       procedure Process_Interrupt_Or_Attach_Handler;\n       --  Common processing for Interrupt and Attach_Handler pragmas\n \n-      procedure Process_Restrictions_Or_Restriction_Warnings;\n-      --  Common processing for Restrictions and Restriction_Warnings pragmas\n+      procedure Process_Restrictions_Or_Restriction_Warnings (Warn : Boolean);\n+      --  Common processing for Restrictions and Restriction_Warnings pragmas.\n+      --  Warn is False for Restrictions, True for Restriction_Warnings.\n \n       procedure Process_Suppress_Unsuppress (Suppress_Case : Boolean);\n       --  Common processing for Suppress and Unsuppress. The boolean parameter\n@@ -1803,6 +1812,46 @@ package body Sem_Prag is\n          end if;\n       end Is_Configuration_Pragma;\n \n+      --------------------------\n+      -- Is_In_Context_Clause --\n+      --------------------------\n+\n+      function Is_In_Context_Clause return Boolean is\n+         Plist       : List_Id;\n+         Parent_Node : Node_Id;\n+\n+      begin\n+         if not Is_List_Member (N) then\n+            return False;\n+\n+         else\n+            Plist := List_Containing (N);\n+            Parent_Node := Parent (Plist);\n+\n+            if Parent_Node = Empty\n+              or else Nkind (Parent_Node) /= N_Compilation_Unit\n+              or else Context_Items (Parent_Node) /= Plist\n+            then\n+               return False;\n+            end if;\n+         end if;\n+\n+         return True;\n+      end Is_In_Context_Clause;\n+\n+      ---------------------------------\n+      -- Is_Static_String_Expression --\n+      ---------------------------------\n+\n+      function Is_Static_String_Expression (Arg : Node_Id) return Boolean is\n+         Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n+\n+      begin\n+         Analyze_And_Resolve (Argx);\n+         return Is_OK_Static_Expression (Argx)\n+           and then Nkind (Argx) = N_String_Literal;\n+      end Is_Static_String_Expression;\n+\n       ----------------------\n       -- Pragma_Misplaced --\n       ----------------------\n@@ -1961,9 +2010,9 @@ package body Sem_Prag is\n \n          procedure Set_Convention_From_Pragma (E : Entity_Id) is\n          begin\n-            --  Check invalid attempt to change convention for an overridden\n-            --  dispatching operation. This is Ada 2005 AI 430. Technically\n-            --  this is an amendment and should only be done in Ada 2005 mode.\n+            --  Ada 2005 (AI-430): Check invalid attempt to change convention\n+            --  for an overridden dispatching operation. Technically this is\n+            --  an amendment and should only be done in Ada 2005 mode.\n             --  However, this is clearly a mistake, since the problem that is\n             --  addressed by this AI is that there is a clear gap in the RM!\n \n@@ -3585,7 +3634,9 @@ package body Sem_Prag is\n       --  but it is harmless (and more straightforward) to simply handle all\n       --  cases here, even if it means we repeat a bit of work in some cases.\n \n-      procedure Process_Restrictions_Or_Restriction_Warnings is\n+      procedure Process_Restrictions_Or_Restriction_Warnings\n+        (Warn : Boolean)\n+      is\n          Arg   : Node_Id;\n          R_Id  : Restriction_Id;\n          Id    : Name_Id;\n@@ -3596,10 +3647,6 @@ package body Sem_Prag is\n          --  Checks unit name parameter for No_Dependence. Returns if it has\n          --  an appropriate form, otherwise raises pragma argument error.\n \n-         procedure Set_Warning (R : All_Restrictions);\n-         --  If this is a Restriction_Warnings pragma, set warning flag,\n-         --  otherwise reset the flag.\n-\n          ---------------------\n          -- Check_Unit_Name --\n          ---------------------\n@@ -3619,19 +3666,6 @@ package body Sem_Prag is\n             end if;\n          end Check_Unit_Name;\n \n-         -----------------\n-         -- Set_Warning --\n-         -----------------\n-\n-         procedure Set_Warning (R : All_Restrictions) is\n-         begin\n-            if Prag_Id = Pragma_Restriction_Warnings then\n-               Restriction_Warnings (R) := True;\n-            else\n-               Restriction_Warnings (R) := False;\n-            end if;\n-         end Set_Warning;\n-\n       --  Start of processing for Process_Restrictions_Or_Restriction_Warnings\n \n       begin\n@@ -3666,16 +3700,33 @@ package body Sem_Prag is\n                     (No_Implementation_Restrictions, Arg);\n                end if;\n \n-               Set_Restriction (R_Id, N);\n-               Set_Warning (R_Id);\n+               --  If this is a warning, then set the warning unless we already\n+               --  have a real restriction active (we never want a warning to\n+               --  override a real restriction).\n \n-               --  A very special case that must be processed here:\n-               --  pragma Restrictions (No_Exceptions) turns off\n-               --  all run-time checking. This is a bit dubious in\n-               --  terms of the formal language definition, but it\n-               --  is what is intended by RM H.4(12).\n+               if Warn then\n+                  if not Restriction_Active (R_Id) then\n+                     Set_Restriction (R_Id, N);\n+                     Restriction_Warnings (R_Id) := True;\n+                  end if;\n+\n+               --  If real restriction case, then set it and make sure that the\n+               --  restriction warning flag is off, since a real restriction\n+               --  always overrides a warning.\n \n-               if R_Id = No_Exceptions then\n+               else\n+                  Set_Restriction (R_Id, N);\n+                  Restriction_Warnings (R_Id) := False;\n+               end if;\n+\n+               --  A very special case that must be processed here: pragma\n+               --  Restrictions (No_Exceptions) turns off all run-time\n+               --  checking. This is a bit dubious in terms of the formal\n+               --  language definition, but it is what is intended by RM\n+               --  H.4(12). Restriction_Warnings never affects generated code\n+               --  so this is done only in the real restriction case.\n+\n+               if R_Id = No_Exceptions and then not Warn then\n                   Scope_Suppress := (others => True);\n                end if;\n \n@@ -3705,19 +3756,36 @@ package body Sem_Prag is\n                then\n                   Error_Pragma_Arg\n                     (\"value must be non-negative integer\", Arg);\n+               end if;\n \n-                  --  Restriction pragma is active\n+               --  Restriction pragma is active\n \n-               else\n-                  Val := Expr_Value (Expr);\n+               Val := Expr_Value (Expr);\n \n-                  if not UI_Is_In_Int_Range (Val) then\n-                     Error_Pragma_Arg\n-                       (\"pragma ignored, value too large?\", Arg);\n-                  else\n-                     Set_Restriction (R_Id, N, Integer (UI_To_Int (Val)));\n-                     Set_Warning (R_Id);\n+               if not UI_Is_In_Int_Range (Val) then\n+                  Error_Pragma_Arg\n+                    (\"pragma ignored, value too large?\", Arg);\n+               end if;\n+\n+               --  Warning case. If the real restriction is active, then we\n+               --  ignore the request, since warning never overrides a real\n+               --  restriction. Otherwise we set the proper warning. Note that\n+               --  this circuit sets the warning again if it is already set,\n+               --  which is what we want, since the constant may have changed.\n+\n+               if Warn then\n+                  if not Restriction_Active (R_Id) then\n+                     Set_Restriction\n+                       (R_Id, N, Integer (UI_To_Int (Val)));\n+                     Restriction_Warnings (R_Id) := True;\n                   end if;\n+\n+               --  Real restriction case, set restriction and make sure warning\n+               --  flag is off since real restriction always overrides warning.\n+\n+               else\n+                  Set_Restriction (R_Id, N, Integer (UI_To_Int (Val)));\n+                  Restriction_Warnings (R_Id) := False;\n                end if;\n             end if;\n \n@@ -4416,7 +4484,7 @@ package body Sem_Prag is\n                   return;\n                end if;\n \n-               Set_Is_Ada_2005 (Entity (E_Id));\n+               Set_Is_Ada_2005_Only (Entity (E_Id));\n \n             else\n                Check_Arg_Count (0);\n@@ -4507,7 +4575,10 @@ package body Sem_Prag is\n          --  pragma Assert ([Check =>] Boolean_EXPRESSION\n          --                 [, [Message =>] Static_String_EXPRESSION]);\n \n-         when Pragma_Assert =>\n+         when Pragma_Assert => Assert : declare\n+            Expr : Node_Id;\n+\n+         begin\n             Check_At_Least_N_Arguments (1);\n             Check_At_Most_N_Arguments (2);\n             Check_Arg_Order ((Name_Check, Name_Message));\n@@ -4531,13 +4602,15 @@ package body Sem_Prag is\n             --  directly, or it may cause insertion of actions that would\n             --  escape the attempt to suppress the assertion code.\n \n+            Expr := Expression (Arg1);\n+\n             if Expander_Active and not Assertions_Enabled then\n                Rewrite (N,\n                  Make_If_Statement (Loc,\n                    Condition =>\n                      Make_And_Then (Loc,\n                        Left_Opnd  => New_Occurrence_Of (Standard_False, Loc),\n-                       Right_Opnd => Get_Pragma_Arg (Arg1)),\n+                       Right_Opnd => Expr),\n                    Then_Statements => New_List (\n                      Make_Null_Statement (Loc))));\n \n@@ -4548,9 +4621,29 @@ package body Sem_Prag is\n             --  and resolve the expression.\n \n             else\n-               Analyze_And_Resolve (Expression (Arg1), Any_Boolean);\n+               Analyze_And_Resolve (Expr, Any_Boolean);\n             end if;\n \n+            --  If assertion is of the form (X'First = literal), where X is\n+            --  formal parameter, then set Low_Bound_Known flag on this formal.\n+\n+            if Nkind (Expr) = N_Op_Eq then\n+               declare\n+                  Right : constant Node_Id := Right_Opnd (Expr);\n+                  Left  : constant Node_Id := Left_Opnd  (Expr);\n+               begin\n+                  if Nkind (Left) = N_Attribute_Reference\n+                    and then Attribute_Name (Left) = Name_First\n+                    and then Is_Entity_Name (Prefix (Left))\n+                    and then Is_Formal (Entity (Prefix (Left)))\n+                    and then Nkind (Right) = N_Integer_Literal\n+                  then\n+                     Set_Low_Bound_Known (Entity (Prefix (Left)));\n+                  end if;\n+               end;\n+            end if;\n+         end Assert;\n+\n          ----------------------\n          -- Assertion_Policy --\n          ----------------------\n@@ -4961,31 +5054,55 @@ package body Sem_Prag is\n \n             if Compile_Time_Known_Value (Arg1x) then\n                if Is_True (Expr_Value (Get_Pragma_Arg (Arg1))) then\n-                  String_To_Name_Buffer (Strval (Get_Pragma_Arg (Arg2)));\n-                  Add_Char_To_Name_Buffer ('?');\n-\n                   declare\n-                     Msg : String (1 .. Name_Len) :=\n-                             Name_Buffer (1 .. Name_Len);\n-\n-                     B : Natural;\n+                     Str   : constant String_Id :=\n+                               Strval (Get_Pragma_Arg (Arg2));\n+                     Len   : constant Int := String_Length (Str);\n+                     Cont  : Boolean;\n+                     Ptr   : Nat;\n+                     CC    : Char_Code;\n+                     C     : Character;\n \n                   begin\n-                     --  This loop looks for multiple lines separated by\n-                     --  ASCII.LF and breaks them into continuation error\n-                     --  messages marked with the usual back slash.\n-\n-                     B := 1;\n-                     for S in 2 .. Msg'Length - 1 loop\n-                        if Msg (S) = ASCII.LF then\n-                           Msg (S) := '?';\n-                           Error_Msg_N (Msg (B .. S), Arg1);\n-                           B := S;\n-                           Msg (B) := '\\';\n+                     Cont := False;\n+                     Ptr := 1;\n+\n+                     --  Loop through segments of message separated by line\n+                     --  feeds. We output these segments as separate messages\n+                     --  with continuation marks for all but the first.\n+\n+                     loop\n+                        Error_Msg_Strlen := 0;\n+\n+                        --  Loop to copy characters from argument to error\n+                        --  message string buffer.\n+\n+                        loop\n+                           exit when Ptr > Len;\n+                           CC := Get_String_Char (Str, Ptr);\n+                           Ptr := Ptr + 1;\n+\n+                           --  Ignore wide chars ??? else store character\n+\n+                           if In_Character_Range (CC) then\n+                              C := Get_Character (CC);\n+                              exit when C = ASCII.LF;\n+                              Error_Msg_Strlen := Error_Msg_Strlen + 1;\n+                              Error_Msg_String (Error_Msg_Strlen) := C;\n+                           end if;\n+                        end loop;\n+\n+                        --  Here with one line ready to go\n+\n+                        if Cont = False then\n+                           Error_Msg_N (\"?~\", Arg1);\n+                           Cont := True;\n+                        else\n+                           Error_Msg_N (\"\\?~\", Arg1);\n                         end if;\n-                     end loop;\n \n-                     Error_Msg_N (Msg (B .. Msg'Length), Arg1);\n+                        exit when Ptr > Len;\n+                     end loop;\n                   end;\n                end if;\n             end if;\n@@ -5739,29 +5856,14 @@ package body Sem_Prag is\n          --  pragma Elaborate (library_unit_NAME {, library_unit_NAME});\n \n          when Pragma_Elaborate => Elaborate : declare\n-            Plist       : List_Id;\n-            Parent_Node : Node_Id;\n-            Arg         : Node_Id;\n-            Citem       : Node_Id;\n+            Arg   : Node_Id;\n+            Citem : Node_Id;\n \n          begin\n             --  Pragma must be in context items list of a compilation unit\n \n-            if not Is_List_Member (N) then\n+            if not Is_In_Context_Clause then\n                Pragma_Misplaced;\n-               return;\n-\n-            else\n-               Plist := List_Containing (N);\n-               Parent_Node := Parent (Plist);\n-\n-               if Parent_Node = Empty\n-                 or else Nkind (Parent_Node) /= N_Compilation_Unit\n-                 or else Context_Items (Parent_Node) /= Plist\n-               then\n-                  Pragma_Misplaced;\n-                  return;\n-               end if;\n             end if;\n \n             --  Must be at least one argument\n@@ -5777,7 +5879,6 @@ package body Sem_Prag is\n \n             if Ada_Version = Ada_83 and then Comes_From_Source (N) then\n                Citem := Next (N);\n-\n                while Present (Citem) loop\n                   if Nkind (Citem) = N_Pragma\n                     or else (Nkind (Citem) = N_With_Clause\n@@ -5794,13 +5895,13 @@ package body Sem_Prag is\n             end if;\n \n             --  Finally, the arguments must all be units mentioned in a with\n-            --  clause in the same context clause. Note we already checked\n-            --  (in Par.Prag) that the arguments are either identifiers or\n+            --  clause in the same context clause. Note we already checked (in\n+            --  Par.Prag) that the arguments are all identifiers or selected\n+            --  components.\n \n             Arg := Arg1;\n             Outer : while Present (Arg) loop\n-               Citem := First (Plist);\n-\n+               Citem := First (List_Containing (N));\n                Inner : while Citem /= N loop\n                   if Nkind (Citem) = N_With_Clause\n                     and then Same_Name (Name (Citem), Expression (Arg))\n@@ -5820,6 +5921,7 @@ package body Sem_Prag is\n                         Set_Suppress_Elaboration_Warnings\n                           (Entity (Name (Citem)));\n                      end if;\n+\n                      exit Inner;\n                   end if;\n \n@@ -5852,31 +5954,16 @@ package body Sem_Prag is\n          --  pragma Elaborate_All (library_unit_NAME {, library_unit_NAME});\n \n          when Pragma_Elaborate_All => Elaborate_All : declare\n-            Plist       : List_Id;\n-            Parent_Node : Node_Id;\n-            Arg         : Node_Id;\n-            Citem       : Node_Id;\n+            Arg   : Node_Id;\n+            Citem : Node_Id;\n \n          begin\n             Check_Ada_83_Warning;\n \n             --  Pragma must be in context items list of a compilation unit\n \n-            if not Is_List_Member (N) then\n+            if not Is_In_Context_Clause then\n                Pragma_Misplaced;\n-               return;\n-\n-            else\n-               Plist := List_Containing (N);\n-               Parent_Node := Parent (Plist);\n-\n-               if Parent_Node = Empty\n-                 or else Nkind (Parent_Node) /= N_Compilation_Unit\n-                 or else Context_Items (Parent_Node) /= Plist\n-               then\n-                  Pragma_Misplaced;\n-                  return;\n-               end if;\n             end if;\n \n             --  Must be at least one argument\n@@ -5896,7 +5983,7 @@ package body Sem_Prag is\n \n             Arg := Arg1;\n             Outr : while Present (Arg) loop\n-               Citem := First (Plist);\n+               Citem := First (List_Containing (N));\n \n                Innr : while Citem /= N loop\n                   if Nkind (Citem) = N_With_Clause\n@@ -7182,13 +7269,20 @@ package body Sem_Prag is\n          ---------------\n \n          --  pragma Interface (\n-         --    convention_IDENTIFIER,\n-         --    local_NAME );\n+         --    [   Convention    =>] convention_IDENTIFIER,\n+         --    [   Entity        =>] local_NAME\n+         --    [, [External_Name =>] static_string_EXPRESSION ]\n+         --    [, [Link_Name     =>] static_string_EXPRESSION ]);\n \n          when Pragma_Interface =>\n             GNAT_Pragma;\n-            Check_Arg_Count (2);\n-            Check_No_Identifiers;\n+            Check_Arg_Order\n+              ((Name_Convention,\n+                Name_Entity,\n+                Name_External_Name,\n+                Name_Link_Name));\n+            Check_At_Least_N_Arguments (2);\n+            Check_At_Most_N_Arguments  (4);\n             Process_Import_Or_Interface;\n \n          --------------------\n@@ -8215,119 +8309,204 @@ package body Sem_Prag is\n          -- Obsolescent --\n          -----------------\n \n-         --  pragma Obsolescent [(static_string_EXPRESSION [, Ada_05])];\n+         --  pragma Obsolescent [(\n+         --    [Entity => NAME,]\n+         --    [(static_string_EXPRESSION [, Ada_05])];\n \n          when Pragma_Obsolescent => Obsolescent : declare\n-            Subp   : Node_Or_Entity_Id;\n-            S      : String_Id;\n-            Active : Boolean := True;\n+            Ename : Node_Id;\n+            Decl  : Node_Id;\n+\n+            procedure Set_Obsolescent (E : Entity_Id);\n+            --  Given an entity Ent, mark it as obsolescent if appropriate\n \n-            procedure Check_Obsolete_Subprogram;\n-            --  Checks if Subp is a subprogram declaration node, and if so\n-            --  replaces Subp by the defining entity of the subprogram. If not,\n-            --  issues an error message\n+            ---------------------\n+            -- Set_Obsolescent --\n+            ---------------------\n \n-            ------------------------------\n-            -- Check_Obsolete_Subprogram--\n-            ------------------------------\n+            procedure Set_Obsolescent (E : Entity_Id) is\n+               Active : Boolean;\n+               Ent    : Entity_Id;\n+               S      : String_Id;\n \n-            procedure Check_Obsolete_Subprogram is\n             begin\n-               if Nkind (Subp) /= N_Subprogram_Declaration then\n-                  Error_Pragma\n-                    (\"pragma% misplaced, must immediately \" &\n-                     \"follow subprogram/package declaration\");\n-               else\n-                  Subp := Defining_Entity (Subp);\n+               Active := True;\n+               Ent    := E;\n+\n+               --  Entity name was given\n+\n+               if Present (Ename) then\n+\n+                  --  If entity name matches, we are fine\n+\n+                  if Chars (Ename) = Chars (Ent) then\n+                     null;\n+\n+                  --  If entity name does not match, only possibility is an\n+                  --  enumeration literal from an enumeration type declaration.\n+\n+                  elsif Ekind (Ent) /= E_Enumeration_Type then\n+                     Error_Pragma\n+                       (\"pragma % entity name does not match declaration\");\n+\n+                  else\n+                     Ent := First_Literal (E);\n+                     loop\n+                        if No (Ent) then\n+                           Error_Pragma\n+                             (\"pragma % entity name does not match any \" &\n+                              \"enumeration literal\");\n+\n+                        elsif Chars (Ent) = Chars (Ename) then\n+                           exit;\n+\n+                        else\n+                           Ent := Next_Literal (Ent);\n+                        end if;\n+                     end loop;\n+                  end if;\n                end if;\n-            end Check_Obsolete_Subprogram;\n+\n+               --  Ent points to entity to be marked\n+\n+               if Arg_Count >= 1 then\n+\n+                  --  Deal with static string argument\n+\n+                  Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+                  S := Strval (Expression (Arg1));\n+\n+                  for J in 1 .. String_Length (S) loop\n+                     if not In_Character_Range (Get_String_Char (S, J)) then\n+                        Error_Pragma_Arg\n+                          (\"pragma% argument does not allow wide characters\",\n+                           Arg1);\n+                     end if;\n+                  end loop;\n+\n+                  Set_Obsolescent_Warning (Ent, Expression (Arg1));\n+\n+                  --  Check for Ada_05 parameter\n+\n+                  if Arg_Count /= 1 then\n+                     Check_Arg_Count (2);\n+\n+                     declare\n+                        Argx : constant Node_Id := Get_Pragma_Arg (Arg2);\n+\n+                     begin\n+                        Check_Arg_Is_Identifier (Argx);\n+\n+                        if Chars (Argx) /= Name_Ada_05 then\n+                           Error_Msg_Name_2 := Name_Ada_05;\n+                           Error_Pragma_Arg\n+                             (\"only allowed argument for pragma% is %\", Argx);\n+                        end if;\n+\n+                        if Ada_Version_Explicit < Ada_05\n+                          or else not Warn_On_Ada_2005_Compatibility\n+                        then\n+                           Active := False;\n+                        end if;\n+                     end;\n+                  end if;\n+               end if;\n+\n+               --  Set flag if pragma active\n+\n+               if Active then\n+                  Set_Is_Obsolescent (Ent);\n+               end if;\n+\n+               return;\n+            end Set_Obsolescent;\n \n          --  Start of processing for pragma Obsolescent\n \n          begin\n             GNAT_Pragma;\n-            Check_At_Most_N_Arguments (2);\n-            Check_No_Identifiers;\n \n-            --  Check OK placement\n+            Check_At_Most_N_Arguments (3);\n \n-            --  First possibility is within a declarative region, where the\n-            --  pragma immediately follows a subprogram declaration.\n+            --  See if first argument specifies an entity name\n \n-            if Present (Prev (N)) then\n-               Subp := Prev (N);\n-               Check_Obsolete_Subprogram;\n+            if Arg_Count >= 1\n+              and then Chars (Arg1) = Name_Entity\n+            then\n+               Ename := Get_Pragma_Arg (Arg1);\n \n-            --  Second possibility, stand alone subprogram declaration with the\n-            --  pragma immediately following the declaration.\n+               if Nkind (Ename) /= N_Character_Literal\n+                    and then\n+                  Nkind (Ename) /= N_Identifier\n+                    and then\n+                  Nkind (Ename) /= N_Operator_Symbol\n+               then\n+                  Error_Pragma_Arg (\"entity name expected for pragma%\", Arg1);\n+               end if;\n \n-            elsif No (Prev (N))\n-              and then Nkind (Parent (N)) = N_Compilation_Unit_Aux\n-            then\n-               Subp := Unit (Parent (Parent (N)));\n-               Check_Obsolete_Subprogram;\n+               --  Eliminate first argument, so we can share processing\n \n-            --  Only other possibility is library unit placement for package\n+               Arg1 := Arg2;\n+               Arg2 := Arg3;\n+               Arg_Count := Arg_Count - 1;\n \n-            else\n-               Subp := Find_Lib_Unit_Name;\n+            --  No Entity name argument given\n \n-               if Ekind (Subp) /= E_Package\n-                 and then Ekind (Subp) /= E_Generic_Package\n-               then\n-                  Check_Obsolete_Subprogram;\n-               end if;\n+            else\n+               Ename := Empty;\n             end if;\n \n-            --  If OK placement, acquire arguments\n+            Check_No_Identifiers;\n \n-            if Arg_Count >= 1 then\n+            --  Get immediately preceding declaration\n \n-               --  Deal with static string argument\n+            Decl := Prev (N);\n+            while Present (Decl) and then Nkind (Decl) = N_Pragma loop\n+               Prev (Decl);\n+            end loop;\n \n-               Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n-               S := Strval (Expression (Arg1));\n+            --  Cases where we do not follow anything other than another pragma\n \n-               for J in 1 .. String_Length (S) loop\n-                  if not In_Character_Range (Get_String_Char (S, J)) then\n-                     Error_Pragma_Arg\n-                       (\"pragma% argument does not allow wide characters\",\n-                        Arg1);\n-                  end if;\n-               end loop;\n+            if No (Decl) then\n \n-               Set_Obsolescent_Warning (Subp, Expression (Arg1));\n+               --  First case: library level compilation unit declaration with\n+               --  the pragma immediately following the declaration.\n \n-               --  Check for Ada_05 parameter\n+               if Nkind (Parent (N)) = N_Compilation_Unit_Aux then\n+                  Set_Obsolescent\n+                    (Defining_Entity (Unit (Parent (Parent (N)))));\n+                  return;\n \n-               if Arg_Count /= 1 then\n-                  Check_Arg_Count (2);\n+               --  Case 2: library unit placement for package\n \n+               else\n                   declare\n-                     Argx : constant Node_Id := Get_Pragma_Arg (Arg2);\n-\n+                     Ent : constant Entity_Id := Find_Lib_Unit_Name;\n                   begin\n-                     Check_Arg_Is_Identifier (Argx);\n-\n-                     if Chars (Argx) /= Name_Ada_05 then\n-                        Error_Msg_Name_2 := Name_Ada_05;\n-                        Error_Pragma_Arg\n-                          (\"only allowed argument for pragma% is %\", Argx);\n-                     end if;\n-\n-                     if Ada_Version_Explicit < Ada_05\n-                       or else not Warn_On_Ada_2005_Compatibility\n+                     if Ekind (Ent) = E_Package\n+                       or else Ekind (Ent) = E_Generic_Package\n                      then\n-                        Active := False;\n+                        Set_Obsolescent (Ent);\n+                        return;\n                      end if;\n                   end;\n                end if;\n-            end if;\n \n-            --  Set flag if pragma active\n+            --  Cases where we must follow a declaration\n \n-            if Active then\n-               Set_Is_Obsolescent (Subp);\n+            else\n+               if Nkind (Decl) not in N_Declaration\n+                 and then Nkind (Decl) not in N_Later_Decl_Item\n+                 and then Nkind (Decl) not in N_Generic_Declaration\n+               then\n+                  Error_Pragma\n+                    (\"pragma% misplaced, \" &\n+                     \"must immediately follow a declaration\");\n+\n+               else\n+                  Set_Obsolescent (Defining_Entity (Decl));\n+                  return;\n+               end if;\n             end if;\n          end Obsolescent;\n \n@@ -8525,6 +8704,31 @@ package body Sem_Prag is\n                Check_Arg_Is_One_Of (Arg1, Name_Semaphore, Name_No);\n             end if;\n \n+         ----------------------------------\n+         -- Preelaborable_Initialization --\n+         ----------------------------------\n+\n+         --  pragma Preelaborable_Initialization (DIRECT_NAME);\n+\n+         when Pragma_Preelaborable_Initialization => Preelab_Init : declare\n+            Ent : Entity_Id;\n+\n+         begin\n+            Check_Arg_Count (1);\n+            Check_No_Identifiers;\n+            Check_Arg_Is_Identifier (Arg1);\n+            Check_Arg_Is_Local_Name (Arg1);\n+            Check_First_Subtype (Arg1);\n+            Ent := Entity (Expression (Arg1));\n+\n+            if not Is_Private_Type (Ent) then\n+               Error_Pragma_Arg\n+                 (\"pragma % can only be applied to private type\", Arg1);\n+            end if;\n+\n+            Set_Known_To_Have_Preelab_Init (Ent);\n+         end Preelab_Init;\n+\n          -------------\n          -- Polling --\n          -------------\n@@ -8764,6 +8968,136 @@ package body Sem_Prag is\n             end if;\n          end Priority;\n \n+         -----------------------------------\n+         -- Priority_Specific_Dispatching --\n+         -----------------------------------\n+\n+         --  pragma Priority_Specific_Dispatching (\n+         --    policy_IDENTIFIER,\n+         --    first_priority_EXPRESSION,\n+         --    last_priority_EXPRESSION);\n+\n+         when Pragma_Priority_Specific_Dispatching =>\n+         Priority_Specific_Dispatching : declare\n+            Prio_Id : constant Entity_Id := RTE (RE_Any_Priority);\n+            --  This is the entity System.Any_Priority;\n+\n+            DP          : Character;\n+            Lower_Bound : Node_Id;\n+            Upper_Bound : Node_Id;\n+            Lower_Val   : Uint;\n+            Upper_Val   : Uint;\n+\n+         begin\n+            Check_Arg_Count (3);\n+            Check_No_Identifiers;\n+            Check_Arg_Is_Task_Dispatching_Policy (Arg1);\n+            Check_Valid_Configuration_Pragma;\n+            Get_Name_String (Chars (Expression (Arg1)));\n+            DP := Fold_Upper (Name_Buffer (1));\n+\n+            Lower_Bound := Expression (Arg2);\n+            Check_Arg_Is_Static_Expression (Lower_Bound, Standard_Integer);\n+            Lower_Val := Expr_Value (Lower_Bound);\n+\n+            Upper_Bound := Expression (Arg3);\n+            Check_Arg_Is_Static_Expression (Upper_Bound, Standard_Integer);\n+            Upper_Val := Expr_Value (Upper_Bound);\n+\n+            --  It is not allowed to use Task_Dispatching_Policy and\n+            --  Priority_Specific_Dispatching in the same partition.\n+\n+            if Task_Dispatching_Policy /= ' ' then\n+               Error_Msg_Sloc := Task_Dispatching_Policy_Sloc;\n+               Error_Pragma\n+                 (\"pragma% incompatible with Task_Dispatching_Policy#\");\n+\n+            --  Check lower bound in range\n+\n+            elsif Lower_Val < Expr_Value (Type_Low_Bound (Prio_Id))\n+                    or else\n+                  Lower_Val > Expr_Value (Type_High_Bound (Prio_Id))\n+            then\n+               Error_Pragma_Arg\n+                 (\"first_priority is out of range\", Arg2);\n+\n+            --  Check upper bound in range\n+\n+            elsif Upper_Val < Expr_Value (Type_Low_Bound (Prio_Id))\n+                    or else\n+                  Upper_Val > Expr_Value (Type_High_Bound (Prio_Id))\n+            then\n+               Error_Pragma_Arg\n+                 (\"last_priority is out of range\", Arg3);\n+\n+            --  Check that the priority range is valid\n+\n+            elsif Lower_Val > Upper_Val then\n+               Error_Pragma\n+                 (\"last_priority_expression must be greater than\" &\n+                  \" or equal to first_priority_expression\");\n+\n+            --  Store the new policy, but always preserve System_Location since\n+            --  we like the error message with the run-time name.\n+\n+            else\n+               --  Check overlapping in the priority ranges specified in other\n+               --  Priority_Specific_Dispatching pragmas within the same\n+               --  partition. We can only check those we know about!\n+\n+               for J in\n+                  Specific_Dispatching.First .. Specific_Dispatching.Last\n+               loop\n+                  if Specific_Dispatching.Table (J).First_Priority in\n+                    UI_To_Int (Lower_Val) .. UI_To_Int (Upper_Val)\n+                  or else Specific_Dispatching.Table (J).Last_Priority in\n+                    UI_To_Int (Lower_Val) .. UI_To_Int (Upper_Val)\n+                  then\n+                     Error_Msg_Sloc :=\n+                       Specific_Dispatching.Table (J).Pragma_Loc;\n+                     Error_Pragma (\"priority range overlaps with\" &\n+                                   \" Priority_Specific_Dispatching#\");\n+                  end if;\n+               end loop;\n+\n+               --  The use of Priority_Specific_Dispatching is incompatible\n+               --  with Task_Dispatching_Policy.\n+\n+               if Task_Dispatching_Policy /= ' ' then\n+                  Error_Msg_Sloc := Task_Dispatching_Policy_Sloc;\n+                  Error_Pragma (\"Priority_Specific_Dispatching incompatible\" &\n+                                \" with Task_Dispatching_Policy#\");\n+               end if;\n+\n+               --  The use of Priority_Specific_Dispatching forces ceiling\n+               --  locking policy.\n+\n+               if Locking_Policy /= ' ' and then Locking_Policy /= 'C' then\n+                  Error_Msg_Sloc := Locking_Policy_Sloc;\n+                  Error_Pragma (\"Priority_Specific_Dispatching incompatible\" &\n+                                \" with Locking_Policy#\");\n+\n+               --  Set the Ceiling_Locking policy, but preserve System_Location\n+               --  since we like the error message with the run time name.\n+\n+               else\n+                  Locking_Policy := 'C';\n+\n+                  if Locking_Policy_Sloc /= System_Location then\n+                     Locking_Policy_Sloc := Loc;\n+                  end if;\n+               end if;\n+\n+               --  Add entry in the table\n+\n+               Specific_Dispatching.Append\n+                    ((Dispatching_Policy => DP,\n+                      First_Priority     => UI_To_Int (Lower_Val),\n+                      Last_Priority      => UI_To_Int (Upper_Val),\n+                      Pragma_Loc         => Loc));\n+            end if;\n+         end Priority_Specific_Dispatching;\n+\n          -------------\n          -- Profile --\n          -------------\n@@ -8782,7 +9116,6 @@ package body Sem_Prag is\n             begin\n                if Chars (Argx) = Name_Ravenscar then\n                   Set_Ravenscar_Profile (N);\n-\n                elsif Chars (Argx) = Name_Restricted then\n                   Set_Profile_Restrictions (Restricted, N, Warn => False);\n                else\n@@ -8809,7 +9142,6 @@ package body Sem_Prag is\n             begin\n                if Chars (Argx) = Name_Ravenscar then\n                   Set_Profile_Restrictions (Ravenscar, N, Warn => True);\n-\n                elsif Chars (Argx) = Name_Restricted then\n                   Set_Profile_Restrictions (Restricted, N, Warn => True);\n                else\n@@ -9251,7 +9583,7 @@ package body Sem_Prag is\n          --  | restriction_parameter_IDENTIFIER => EXPRESSION\n \n          when Pragma_Restrictions =>\n-            Process_Restrictions_Or_Restriction_Warnings;\n+            Process_Restrictions_Or_Restriction_Warnings (Warn => False);\n \n          --------------------------\n          -- Restriction_Warnings --\n@@ -9264,7 +9596,7 @@ package body Sem_Prag is\n          --  | restriction_parameter_IDENTIFIER => EXPRESSION\n \n          when Pragma_Restriction_Warnings =>\n-            Process_Restrictions_Or_Restriction_Warnings;\n+            Process_Restrictions_Or_Restriction_Warnings (Warn => True);\n \n          ----------------\n          -- Reviewable --\n@@ -10291,47 +10623,90 @@ package body Sem_Prag is\n \n          --  pragma Unreferenced (local_Name {, local_Name});\n \n+         --    or when used in a context clause:\n+\n+         --  pragma Unreferenced (library_unit_NAME {, library_unit_NAME}\n+\n          when Pragma_Unreferenced => Unreferenced : declare\n             Arg_Node : Node_Id;\n             Arg_Expr : Node_Id;\n             Arg_Ent  : Entity_Id;\n+            Citem    : Node_Id;\n \n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n \n-            Arg_Node := Arg1;\n-            while Present (Arg_Node) loop\n-               Check_No_Identifier (Arg_Node);\n+            --  Check case of appearing within context clause\n \n-               --  Note that the analyze call done by Check_Arg_Is_Local_Name\n-               --  will in fact generate a reference, so that the entity will\n-               --  have a reference, which will inhibit any warnings about it\n-               --  not being referenced, and also properly show up in the ali\n-               --  file as a reference. But this reference is recorded before\n-               --  the Has_Pragma_Unreferenced flag is set, so that no warning\n-               --  is generated for this reference.\n+            if Is_In_Context_Clause then\n \n-               Check_Arg_Is_Local_Name (Arg_Node);\n-               Arg_Expr := Get_Pragma_Arg (Arg_Node);\n+               --  The arguments must all be units mentioned in a with\n+               --  clause in the same context clause. Note we already checked\n+               --  (in Par.Prag) that the arguments are either identifiers or\n \n-               if Is_Entity_Name (Arg_Expr) then\n-                  Arg_Ent := Entity (Arg_Expr);\n+               Arg_Node := Arg1;\n+               while Present (Arg_Node) loop\n+                  Citem := First (List_Containing (N));\n+                  while Citem /= N loop\n+                     if Nkind (Citem) = N_With_Clause\n+                       and then Same_Name (Name (Citem), Expression (Arg_Node))\n+                     then\n+                        Set_Has_Pragma_Unreferenced\n+                          (Cunit_Entity\n+                             (Get_Source_Unit\n+                                (Library_Unit (Citem))));\n+                        Set_Unit_Name (Expression (Arg_Node), Name (Citem));\n+                        exit;\n+                     end if;\n \n-                  --  If the entity is overloaded, the pragma applies to the\n-                  --  most recent overloading, as documented. In this case,\n-                  --  name resolution does not generate a reference, so it\n-                  --  must be done here explicitly.\n+                     Next (Citem);\n+                  end loop;\n \n-                  if Is_Overloaded (Arg_Expr) then\n-                     Generate_Reference (Arg_Ent, N);\n+                  if Citem = N then\n+                     Error_Pragma_Arg\n+                       (\"argument of pragma% is not with'ed unit\", Arg_Node);\n                   end if;\n \n-                  Set_Has_Pragma_Unreferenced (Arg_Ent);\n-               end if;\n+                  Next (Arg_Node);\n+               end loop;\n \n-               Next (Arg_Node);\n-            end loop;\n+            --  Case of not in list of context items\n+\n+            else\n+               Arg_Node := Arg1;\n+               while Present (Arg_Node) loop\n+                  Check_No_Identifier (Arg_Node);\n+\n+                  --  Note: the analyze call done by Check_Arg_Is_Local_Name\n+                  --  will in fact generate reference, so that the entity will\n+                  --  have a reference, which will inhibit any warnings about\n+                  --  it not being referenced, and also properly show up in the\n+                  --  ali file as a reference. But this reference is recorded\n+                  --  before the Has_Pragma_Unreferenced flag is set, so that\n+                  --  no warning is generated for this reference.\n+\n+                  Check_Arg_Is_Local_Name (Arg_Node);\n+                  Arg_Expr := Get_Pragma_Arg (Arg_Node);\n+\n+                  if Is_Entity_Name (Arg_Expr) then\n+                     Arg_Ent := Entity (Arg_Expr);\n+\n+                     --  If the entity is overloaded, the pragma applies to the\n+                     --  most recent overloading, as documented. In this case,\n+                     --  name resolution does not generate a reference, so it\n+                     --  must be done here explicitly.\n+\n+                     if Is_Overloaded (Arg_Expr) then\n+                        Generate_Reference (Arg_Ent, N);\n+                     end if;\n+\n+                     Set_Has_Pragma_Unreferenced (Arg_Ent);\n+                  end if;\n+\n+                  Next (Arg_Node);\n+               end loop;\n+            end if;\n          end Unreferenced;\n \n          ------------------------------\n@@ -10446,21 +10821,24 @@ package body Sem_Prag is\n          -- Warnings --\n          --------------\n \n-         --  pragma Warnings (On | Off, [LOCAL_NAME])\n+         --  pragma Warnings (On | Off);\n+         --  pragma Warnings (On | Off, LOCAL_NAME);\n          --  pragma Warnings (static_string_EXPRESSION);\n+         --  pragma Warnings (On | Off, STRING_LITERAL);\n \n          when Pragma_Warnings => Warnings : begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n             Check_No_Identifiers;\n \n-            --  One argument case\n+            declare\n+               Argx : constant Node_Id := Get_Pragma_Arg (Arg1);\n \n-            if Arg_Count = 1 then\n-               declare\n-                  Argx : constant Node_Id := Get_Pragma_Arg (Arg1);\n+            begin\n+               --  One argument case\n+\n+               if Arg_Count = 1 then\n \n-               begin\n                   --  On/Off one argument case was processed by parser\n \n                   if Nkind (Argx) = N_Identifier\n@@ -10471,9 +10849,16 @@ package body Sem_Prag is\n                   then\n                      null;\n \n-                  else\n-                     Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+                  --  One argument case must be ON/OFF or static string expr\n+\n+                  elsif not Is_Static_String_Expression (Arg1) then\n+                     Error_Pragma_Arg\n+                       (\"argument of pragma% must be On/Off or \" &\n+                        \"static string expression\", Arg2);\n \n+                  --  One argument string expression case\n+\n+                  else\n                      declare\n                         Lit : constant Node_Id   := Expr_Value_S (Argx);\n                         Str : constant String_Id := Strval (Lit);\n@@ -10494,70 +10879,111 @@ package body Sem_Prag is\n                         end loop;\n                      end;\n                   end if;\n-               end;\n \n-            --  Two argument case\n+                  --  Two or more arguments (must be two)\n \n-            elsif Arg_Count /= 1 then\n-               Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n-               Check_Arg_Count (2);\n+               else\n+                  Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n+                  Check_At_Most_N_Arguments (2);\n \n-               declare\n-                  E_Id : Node_Id;\n-                  E    : Entity_Id;\n+                  declare\n+                     E_Id : Node_Id;\n+                     E    : Entity_Id;\n+                     Err  : Boolean;\n \n-               begin\n-                  E_Id := Expression (Arg2);\n-                  Analyze (E_Id);\n+                  begin\n+                     E_Id := Expression (Arg2);\n+                     Analyze (E_Id);\n \n-                  --  In the expansion of an inlined body, a reference to\n-                  --  the formal may be wrapped in a conversion if the actual\n-                  --  is a conversion. Retrieve the real entity name.\n+                     --  In the expansion of an inlined body, a reference to\n+                     --  the formal may be wrapped in a conversion if the\n+                     --  actual is a conversion. Retrieve the real entity name.\n \n-                  if (In_Instance_Body\n-                      or else In_Inlined_Body)\n-                    and then Nkind (E_Id) = N_Unchecked_Type_Conversion\n-                  then\n-                     E_Id := Expression (E_Id);\n-                  end if;\n+                     if (In_Instance_Body\n+                         or else In_Inlined_Body)\n+                       and then Nkind (E_Id) = N_Unchecked_Type_Conversion\n+                     then\n+                        E_Id := Expression (E_Id);\n+                     end if;\n \n-                  if not Is_Entity_Name (E_Id) then\n-                     Error_Pragma_Arg\n-                       (\"second argument of pragma% must be entity name\",\n-                        Arg2);\n-                  end if;\n+                     --  Entity name case\n \n-                  E := Entity (E_Id);\n+                     if Is_Entity_Name (E_Id) then\n+                        E := Entity (E_Id);\n \n-                  if E = Any_Id then\n-                     return;\n-                  else\n-                     loop\n-                        Set_Warnings_Off\n-                          (E, (Chars (Expression (Arg1)) = Name_Off));\n-\n-                        if Is_Enumeration_Type (E) then\n-                           declare\n-                              Lit : Entity_Id;\n-                           begin\n-                              Lit := First_Literal (E);\n-                              while Present (Lit) loop\n-                                 Set_Warnings_Off (Lit);\n-                                 Next_Literal (Lit);\n-                              end loop;\n-                           end;\n+                        if E = Any_Id then\n+                           return;\n+                        else\n+                           loop\n+                              Set_Warnings_Off\n+                                (E, (Chars (Expression (Arg1)) = Name_Off));\n+\n+                              if Is_Enumeration_Type (E) then\n+                                 declare\n+                                    Lit : Entity_Id;\n+                                 begin\n+                                    Lit := First_Literal (E);\n+                                    while Present (Lit) loop\n+                                       Set_Warnings_Off (Lit);\n+                                       Next_Literal (Lit);\n+                                    end loop;\n+                                 end;\n+                              end if;\n+\n+                              exit when No (Homonym (E));\n+                              E := Homonym (E);\n+                           end loop;\n                         end if;\n \n-                        exit when No (Homonym (E));\n-                        E := Homonym (E);\n-                     end loop;\n-                  end if;\n-               end;\n+                     --  Error if not entity or static string literal case\n \n-               --  More than two arguments\n-            else\n-               Check_At_Most_N_Arguments (2);\n-            end if;\n+                     elsif not Is_Static_String_Expression (Arg2) then\n+                        Error_Pragma_Arg\n+                          (\"second argument of pragma% must be entity \" &\n+                           \"name or static string expression\", Arg2);\n+\n+                     --  String literal case\n+\n+                     else\n+                        String_To_Name_Buffer\n+                          (Strval (Expr_Value_S (Expression (Arg2))));\n+\n+                        --  Configuration pragma case\n+\n+                        if Is_Configuration_Pragma then\n+                           if Chars (Argx) = Name_On then\n+                              Error_Pragma\n+                                (\"pragma Warnings (Off, string) cannot be \" &\n+                                 \"used as configuration pragma\");\n+\n+                           else\n+                              Set_Specific_Warning_Off\n+                                (No_Location, Name_Buffer (1 .. Name_Len));\n+                           end if;\n+\n+                        --  Normal (non-configuration pragma) case\n+\n+                        else\n+                           if Chars (Argx) = Name_Off then\n+                              Set_Specific_Warning_Off\n+                                (Loc, Name_Buffer (1 .. Name_Len));\n+\n+                           elsif Chars (Argx) = Name_On then\n+                              Set_Specific_Warning_On\n+                                (Loc, Name_Buffer (1 .. Name_Len), Err);\n+\n+                              if Err then\n+                                 Error_Msg\n+                                   (\"?pragma Warnings On with no \" &\n+                                    \"matching Warnings Off\",\n+                                    Loc);\n+                              end if;\n+                           end if;\n+                        end if;\n+                     end if;\n+                  end;\n+               end if;\n+            end;\n          end Warnings;\n \n          -------------------\n@@ -10594,6 +11020,21 @@ package body Sem_Prag is\n             end if;\n          end Weak_External;\n \n+         -----------------------------\n+         -- Wide_Character_Encoding --\n+         -----------------------------\n+\n+         --  pragma Wide_Character_Encoding (IDENTIFIER);\n+\n+         when Pragma_Wide_Character_Encoding =>\n+\n+            --  Nothing to do, handled in parser. Note that we do not enforce\n+            --  configuration pragma placement, this pragma can appear at any\n+            --  place in the source, allowing mixed encodings within a single\n+            --  source program.\n+\n+            null;\n+\n          --------------------\n          -- Unknown_Pragma --\n          --------------------\n@@ -10615,7 +11056,9 @@ package body Sem_Prag is\n \n    function Delay_Config_Pragma_Analyze (N : Node_Id) return Boolean is\n    begin\n-      return Chars (N) = Name_Interrupt_State;\n+      return Chars (N) = Name_Interrupt_State\n+               or else\n+             Chars (N) = Name_Priority_Specific_Dispatching;\n    end Delay_Config_Pragma_Analyze;\n \n    -------------------------\n@@ -10714,158 +11157,161 @@ package body Sem_Prag is\n \n    Sig_Flags : constant array (Pragma_Id) of Int :=\n \n-     (Pragma_AST_Entry                    => -1,\n-      Pragma_Abort_Defer                  => -1,\n-      Pragma_Ada_83                       => -1,\n-      Pragma_Ada_95                       => -1,\n-      Pragma_Ada_05                       => -1,\n-      Pragma_Ada_2005                     => -1,\n-      Pragma_All_Calls_Remote             => -1,\n-      Pragma_Annotate                     => -1,\n-      Pragma_Assert                       => -1,\n-      Pragma_Assertion_Policy             =>  0,\n-      Pragma_Asynchronous                 => -1,\n-      Pragma_Atomic                       =>  0,\n-      Pragma_Atomic_Components            =>  0,\n-      Pragma_Attach_Handler               => -1,\n-      Pragma_CPP_Class                    =>  0,\n-      Pragma_CPP_Constructor              =>  0,\n-      Pragma_CPP_Virtual                  =>  0,\n-      Pragma_CPP_Vtable                   =>  0,\n-      Pragma_C_Pass_By_Copy               =>  0,\n-      Pragma_Comment                      =>  0,\n-      Pragma_Common_Object                => -1,\n-      Pragma_Compile_Time_Warning         => -1,\n-      Pragma_Complete_Representation      =>  0,\n-      Pragma_Complex_Representation       =>  0,\n-      Pragma_Component_Alignment          => -1,\n-      Pragma_Controlled                   =>  0,\n-      Pragma_Convention                   =>  0,\n-      Pragma_Convention_Identifier        =>  0,\n-      Pragma_Debug                        => -1,\n-      Pragma_Debug_Policy                 =>  0,\n-      Pragma_Detect_Blocking              => -1,\n-      Pragma_Discard_Names                =>  0,\n-      Pragma_Elaborate                    => -1,\n-      Pragma_Elaborate_All                => -1,\n-      Pragma_Elaborate_Body               => -1,\n-      Pragma_Elaboration_Checks           => -1,\n-      Pragma_Eliminate                    => -1,\n-      Pragma_Explicit_Overriding          => -1,\n-      Pragma_Export                       => -1,\n-      Pragma_Export_Exception             => -1,\n-      Pragma_Export_Function              => -1,\n-      Pragma_Export_Object                => -1,\n-      Pragma_Export_Procedure             => -1,\n-      Pragma_Export_Value                 => -1,\n-      Pragma_Export_Valued_Procedure      => -1,\n-      Pragma_Extend_System                => -1,\n-      Pragma_Extensions_Allowed           => -1,\n-      Pragma_External                     => -1,\n-      Pragma_External_Name_Casing         => -1,\n-      Pragma_Finalize_Storage_Only        =>  0,\n-      Pragma_Float_Representation         =>  0,\n-      Pragma_Ident                        => -1,\n-      Pragma_Import                       => +2,\n-      Pragma_Import_Exception             =>  0,\n-      Pragma_Import_Function              =>  0,\n-      Pragma_Import_Object                =>  0,\n-      Pragma_Import_Procedure             =>  0,\n-      Pragma_Import_Valued_Procedure      =>  0,\n-      Pragma_Initialize_Scalars           => -1,\n-      Pragma_Inline                       =>  0,\n-      Pragma_Inline_Always                =>  0,\n-      Pragma_Inline_Generic               =>  0,\n-      Pragma_Inspection_Point             => -1,\n-      Pragma_Interface                    => +2,\n-      Pragma_Interface_Name               => +2,\n-      Pragma_Interrupt_Handler            => -1,\n-      Pragma_Interrupt_Priority           => -1,\n-      Pragma_Interrupt_State              => -1,\n-      Pragma_Java_Constructor             => -1,\n-      Pragma_Java_Interface               => -1,\n-      Pragma_Keep_Names                   =>  0,\n-      Pragma_License                      => -1,\n-      Pragma_Link_With                    => -1,\n-      Pragma_Linker_Alias                 => -1,\n-      Pragma_Linker_Constructor           => -1,\n-      Pragma_Linker_Destructor            => -1,\n-      Pragma_Linker_Options               => -1,\n-      Pragma_Linker_Section               => -1,\n-      Pragma_List                         => -1,\n-      Pragma_Locking_Policy               => -1,\n-      Pragma_Long_Float                   => -1,\n-      Pragma_Machine_Attribute            => -1,\n-      Pragma_Main                         => -1,\n-      Pragma_Main_Storage                 => -1,\n-      Pragma_Memory_Size                  => -1,\n-      Pragma_No_Return                    =>  0,\n-      Pragma_No_Run_Time                  => -1,\n-      Pragma_No_Strict_Aliasing           => -1,\n-      Pragma_Normalize_Scalars            => -1,\n-      Pragma_Obsolescent                  =>  0,\n-      Pragma_Optimize                     => -1,\n-      Pragma_Optional_Overriding          => -1,\n-      Pragma_Pack                         =>  0,\n-      Pragma_Page                         => -1,\n-      Pragma_Passive                      => -1,\n-      Pragma_Polling                      => -1,\n-      Pragma_Persistent_BSS               =>  0,\n-      Pragma_Preelaborate                 => -1,\n-      Pragma_Preelaborate_05              => -1,\n-      Pragma_Priority                     => -1,\n-      Pragma_Profile                      =>  0,\n-      Pragma_Profile_Warnings             =>  0,\n-      Pragma_Propagate_Exceptions         => -1,\n-      Pragma_Psect_Object                 => -1,\n-      Pragma_Pure                         => -1,\n-      Pragma_Pure_05                      => -1,\n-      Pragma_Pure_Function                => -1,\n-      Pragma_Queuing_Policy               => -1,\n-      Pragma_Ravenscar                    => -1,\n-      Pragma_Remote_Call_Interface        => -1,\n-      Pragma_Remote_Types                 => -1,\n-      Pragma_Restricted_Run_Time          => -1,\n-      Pragma_Restriction_Warnings         => -1,\n-      Pragma_Restrictions                 => -1,\n-      Pragma_Reviewable                   => -1,\n-      Pragma_Share_Generic                => -1,\n-      Pragma_Shared                       => -1,\n-      Pragma_Shared_Passive               => -1,\n-      Pragma_Source_File_Name             => -1,\n-      Pragma_Source_File_Name_Project     => -1,\n-      Pragma_Source_Reference             => -1,\n-      Pragma_Storage_Size                 => -1,\n-      Pragma_Storage_Unit                 => -1,\n-      Pragma_Stream_Convert               => -1,\n-      Pragma_Style_Checks                 => -1,\n-      Pragma_Subtitle                     => -1,\n-      Pragma_Suppress                     =>  0,\n-      Pragma_Suppress_Exception_Locations =>  0,\n-      Pragma_Suppress_All                 => -1,\n-      Pragma_Suppress_Debug_Info          =>  0,\n-      Pragma_Suppress_Initialization      =>  0,\n-      Pragma_System_Name                  => -1,\n-      Pragma_Task_Dispatching_Policy      => -1,\n-      Pragma_Task_Info                    => -1,\n-      Pragma_Task_Name                    => -1,\n-      Pragma_Task_Storage                 =>  0,\n-      Pragma_Thread_Body                  => +2,\n-      Pragma_Time_Slice                   => -1,\n-      Pragma_Title                        => -1,\n-      Pragma_Unchecked_Union              =>  0,\n-      Pragma_Unimplemented_Unit           => -1,\n-      Pragma_Universal_Data               => -1,\n-      Pragma_Unreferenced                 => -1,\n-      Pragma_Unreserve_All_Interrupts     => -1,\n-      Pragma_Unsuppress                   =>  0,\n-      Pragma_Use_VADS_Size                => -1,\n-      Pragma_Validity_Checks              => -1,\n-      Pragma_Volatile                     =>  0,\n-      Pragma_Volatile_Components          =>  0,\n-      Pragma_Warnings                     => -1,\n-      Pragma_Weak_External                =>  0,\n-      Unknown_Pragma                      =>  0);\n+     (Pragma_AST_Entry                     => -1,\n+      Pragma_Abort_Defer                   => -1,\n+      Pragma_Ada_83                        => -1,\n+      Pragma_Ada_95                        => -1,\n+      Pragma_Ada_05                        => -1,\n+      Pragma_Ada_2005                      => -1,\n+      Pragma_All_Calls_Remote              => -1,\n+      Pragma_Annotate                      => -1,\n+      Pragma_Assert                        => -1,\n+      Pragma_Assertion_Policy              =>  0,\n+      Pragma_Asynchronous                  => -1,\n+      Pragma_Atomic                        =>  0,\n+      Pragma_Atomic_Components             =>  0,\n+      Pragma_Attach_Handler                => -1,\n+      Pragma_CPP_Class                     =>  0,\n+      Pragma_CPP_Constructor               =>  0,\n+      Pragma_CPP_Virtual                   =>  0,\n+      Pragma_CPP_Vtable                    =>  0,\n+      Pragma_C_Pass_By_Copy                =>  0,\n+      Pragma_Comment                       =>  0,\n+      Pragma_Common_Object                 => -1,\n+      Pragma_Compile_Time_Warning          => -1,\n+      Pragma_Complete_Representation       =>  0,\n+      Pragma_Complex_Representation        =>  0,\n+      Pragma_Component_Alignment           => -1,\n+      Pragma_Controlled                    =>  0,\n+      Pragma_Convention                    =>  0,\n+      Pragma_Convention_Identifier         =>  0,\n+      Pragma_Debug                         => -1,\n+      Pragma_Debug_Policy                  =>  0,\n+      Pragma_Detect_Blocking               => -1,\n+      Pragma_Discard_Names                 =>  0,\n+      Pragma_Elaborate                     => -1,\n+      Pragma_Elaborate_All                 => -1,\n+      Pragma_Elaborate_Body                => -1,\n+      Pragma_Elaboration_Checks            => -1,\n+      Pragma_Eliminate                     => -1,\n+      Pragma_Explicit_Overriding           => -1,\n+      Pragma_Export                        => -1,\n+      Pragma_Export_Exception              => -1,\n+      Pragma_Export_Function               => -1,\n+      Pragma_Export_Object                 => -1,\n+      Pragma_Export_Procedure              => -1,\n+      Pragma_Export_Value                  => -1,\n+      Pragma_Export_Valued_Procedure       => -1,\n+      Pragma_Extend_System                 => -1,\n+      Pragma_Extensions_Allowed            => -1,\n+      Pragma_External                      => -1,\n+      Pragma_External_Name_Casing          => -1,\n+      Pragma_Finalize_Storage_Only         =>  0,\n+      Pragma_Float_Representation          =>  0,\n+      Pragma_Ident                         => -1,\n+      Pragma_Import                        => +2,\n+      Pragma_Import_Exception              =>  0,\n+      Pragma_Import_Function               =>  0,\n+      Pragma_Import_Object                 =>  0,\n+      Pragma_Import_Procedure              =>  0,\n+      Pragma_Import_Valued_Procedure       =>  0,\n+      Pragma_Initialize_Scalars            => -1,\n+      Pragma_Inline                        =>  0,\n+      Pragma_Inline_Always                 =>  0,\n+      Pragma_Inline_Generic                =>  0,\n+      Pragma_Inspection_Point              => -1,\n+      Pragma_Interface                     => +2,\n+      Pragma_Interface_Name                => +2,\n+      Pragma_Interrupt_Handler             => -1,\n+      Pragma_Interrupt_Priority            => -1,\n+      Pragma_Interrupt_State               => -1,\n+      Pragma_Java_Constructor              => -1,\n+      Pragma_Java_Interface                => -1,\n+      Pragma_Keep_Names                    =>  0,\n+      Pragma_License                       => -1,\n+      Pragma_Link_With                     => -1,\n+      Pragma_Linker_Alias                  => -1,\n+      Pragma_Linker_Constructor            => -1,\n+      Pragma_Linker_Destructor             => -1,\n+      Pragma_Linker_Options                => -1,\n+      Pragma_Linker_Section                => -1,\n+      Pragma_List                          => -1,\n+      Pragma_Locking_Policy                => -1,\n+      Pragma_Long_Float                    => -1,\n+      Pragma_Machine_Attribute             => -1,\n+      Pragma_Main                          => -1,\n+      Pragma_Main_Storage                  => -1,\n+      Pragma_Memory_Size                   => -1,\n+      Pragma_No_Return                     =>  0,\n+      Pragma_No_Run_Time                   => -1,\n+      Pragma_No_Strict_Aliasing            => -1,\n+      Pragma_Normalize_Scalars             => -1,\n+      Pragma_Obsolescent                   =>  0,\n+      Pragma_Optimize                      => -1,\n+      Pragma_Optional_Overriding           => -1,\n+      Pragma_Pack                          =>  0,\n+      Pragma_Page                          => -1,\n+      Pragma_Passive                       => -1,\n+      Pragma_Preelaborable_Initialization  => -1,\n+      Pragma_Polling                       => -1,\n+      Pragma_Persistent_BSS                =>  0,\n+      Pragma_Preelaborate                  => -1,\n+      Pragma_Preelaborate_05               => -1,\n+      Pragma_Priority                      => -1,\n+      Pragma_Priority_Specific_Dispatching => -1,\n+      Pragma_Profile                       =>  0,\n+      Pragma_Profile_Warnings              =>  0,\n+      Pragma_Propagate_Exceptions          => -1,\n+      Pragma_Psect_Object                  => -1,\n+      Pragma_Pure                          => -1,\n+      Pragma_Pure_05                       => -1,\n+      Pragma_Pure_Function                 => -1,\n+      Pragma_Queuing_Policy                => -1,\n+      Pragma_Ravenscar                     => -1,\n+      Pragma_Remote_Call_Interface         => -1,\n+      Pragma_Remote_Types                  => -1,\n+      Pragma_Restricted_Run_Time           => -1,\n+      Pragma_Restriction_Warnings          => -1,\n+      Pragma_Restrictions                  => -1,\n+      Pragma_Reviewable                    => -1,\n+      Pragma_Share_Generic                 => -1,\n+      Pragma_Shared                        => -1,\n+      Pragma_Shared_Passive                => -1,\n+      Pragma_Source_File_Name              => -1,\n+      Pragma_Source_File_Name_Project      => -1,\n+      Pragma_Source_Reference              => -1,\n+      Pragma_Storage_Size                  => -1,\n+      Pragma_Storage_Unit                  => -1,\n+      Pragma_Stream_Convert                => -1,\n+      Pragma_Style_Checks                  => -1,\n+      Pragma_Subtitle                      => -1,\n+      Pragma_Suppress                      =>  0,\n+      Pragma_Suppress_Exception_Locations  =>  0,\n+      Pragma_Suppress_All                  => -1,\n+      Pragma_Suppress_Debug_Info           =>  0,\n+      Pragma_Suppress_Initialization       =>  0,\n+      Pragma_System_Name                   => -1,\n+      Pragma_Task_Dispatching_Policy       => -1,\n+      Pragma_Task_Info                     => -1,\n+      Pragma_Task_Name                     => -1,\n+      Pragma_Task_Storage                  =>  0,\n+      Pragma_Thread_Body                   => +2,\n+      Pragma_Time_Slice                    => -1,\n+      Pragma_Title                         => -1,\n+      Pragma_Unchecked_Union               =>  0,\n+      Pragma_Unimplemented_Unit            => -1,\n+      Pragma_Universal_Data                => -1,\n+      Pragma_Unreferenced                  => -1,\n+      Pragma_Unreserve_All_Interrupts      => -1,\n+      Pragma_Unsuppress                    =>  0,\n+      Pragma_Use_VADS_Size                 => -1,\n+      Pragma_Validity_Checks               => -1,\n+      Pragma_Volatile                      =>  0,\n+      Pragma_Volatile_Components           =>  0,\n+      Pragma_Warnings                      => -1,\n+      Pragma_Weak_External                 => -1,\n+      Pragma_Wide_Character_Encoding       =>  0,\n+      Unknown_Pragma                       =>  0);\n \n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean is\n       P : Node_Id;"}]}