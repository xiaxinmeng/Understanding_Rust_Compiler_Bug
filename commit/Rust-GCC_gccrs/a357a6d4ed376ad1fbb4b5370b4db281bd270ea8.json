{"sha": "a357a6d4ed376ad1fbb4b5370b4db281bd270ea8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM1N2E2ZDRlZDM3NmFkMWZiYjRiNTM3MGI0ZGIyODFiZDI3MGVhOA==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-10-14T15:01:44Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-10-14T15:01:44Z"}, "message": "expr.c (block_move_libcall_safe_for_call_parm): Clean up...\n\n\t* expr.c (block_move_libcall_safe_for_call_parm): Clean up,\n\tand add case for machines where outgoing register parameters\n\tget stack space.\n\nFrom-SVN: r72474", "tree": {"sha": "1ed8dbebc0fa59182ac860b5b54dad5c224de313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ed8dbebc0fa59182ac860b5b54dad5c224de313"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9b46dfb99308239e5fff12faf47ff0516f59f1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b46dfb99308239e5fff12faf47ff0516f59f1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b46dfb99308239e5fff12faf47ff0516f59f1a"}], "stats": {"total": 82, "additions": 38, "deletions": 44}, "files": [{"sha": "6ee700c449dcf9cf242f6cc0a9a57e89c4ddff98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a357a6d4ed376ad1fbb4b5370b4db281bd270ea8", "patch": "@@ -1,5 +1,9 @@\n 2003-10-14  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* expr.c (block_move_libcall_safe_for_call_parm): Clean up,\n+\tand add case for machines where outgoing register parameters\n+\tget stack space.\n+\n \t* config/darwin.c (machopic_indirect_data_reference): Use a scratch\n \tregister when generating indirect address.\n "}, {"sha": "927c158893968895aa415c51e7503b252550ac27", "filename": "gcc/expr.c", "status": "modified", "additions": 34, "deletions": 44, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a357a6d4ed376ad1fbb4b5370b4db281bd270ea8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a357a6d4ed376ad1fbb4b5370b4db281bd270ea8", "patch": "@@ -1394,56 +1394,46 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n static bool\n block_move_libcall_safe_for_call_parm (void)\n {\n+  /* If arguments are pushed on the stack, then they're safe.  */\n   if (PUSH_ARGS)\n     return true;\n-  else\n-    {\n-      /* Check to see whether memcpy takes all register arguments.  */\n-      static enum {\n-\ttakes_regs_uninit, takes_regs_no, takes_regs_yes\n-      } takes_regs = takes_regs_uninit;\n-\n-      switch (takes_regs)\n-\t{\n-\tcase takes_regs_uninit:\n-\t  {\n-\t    CUMULATIVE_ARGS args_so_far;\n-\t    tree fn, arg;\n-\n-\t    fn = emit_block_move_libcall_fn (false);\n-\t    INIT_CUMULATIVE_ARGS (args_so_far, TREE_TYPE (fn), NULL_RTX, 0);\n \n-\t    arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\t    for ( ; arg != void_list_node ; arg = TREE_CHAIN (arg))\n-\t      {\n-\t\tenum machine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n-\t\trtx tmp = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n-\t\tif (!tmp || !REG_P (tmp))\n-\t\t  goto fail_takes_regs;\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n-\t\tif (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode,\n-\t\t\t\t\t\tNULL_TREE, 1))\n-\t\t  goto fail_takes_regs;\n+  /* If registers go on the stack anyway, any argument is sure to clobber \n+     an outgoing argument.  */\n+#if defined (REG_PARM_STACK_SPACE) && defined (OUTGOING_REG_PARM_STACK_SPACE)\n+  {\n+    tree fn = emit_block_move_libcall_fn (false);\n+    (void) fn;\n+    if (REG_PARM_STACK_SPACE (fn) != 0)\n+      return false;\n+  }\n #endif\n-\t\tFUNCTION_ARG_ADVANCE (args_so_far, mode, NULL_TREE, 1);\n-\t      }\n-\t  }\n-\t  takes_regs = takes_regs_yes;\n-\t  /* FALLTHRU */\n-\n-\tcase takes_regs_yes:\n-\t  return true;\n \n-\tfail_takes_regs:\n-\t  takes_regs = takes_regs_no;\n-\t  /* FALLTHRU */\n-\tcase takes_regs_no:\n+  /* If any argument goes in memory, then it might clobber an outgoing\n+     argument.  */\n+  {\n+    CUMULATIVE_ARGS args_so_far;\n+    tree fn, arg;\n+    \n+    fn = emit_block_move_libcall_fn (false);\n+    INIT_CUMULATIVE_ARGS (args_so_far, TREE_TYPE (fn), NULL_RTX, 0);\n+    \n+    arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+    for ( ; arg != void_list_node ; arg = TREE_CHAIN (arg))\n+      {\n+\tenum machine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n+\trtx tmp = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n+\tif (!tmp || !REG_P (tmp))\n \t  return false;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+\tif (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode,\n+\t\t\t\t\tNULL_TREE, 1))\n+\t  return false;\n+#endif\n+\tFUNCTION_ARG_ADVANCE (args_so_far, mode, NULL_TREE, 1);\n+      }\n+  }\n+  return true;\n }\n \n /* A subroutine of emit_block_move.  Expand a movstr pattern;"}]}