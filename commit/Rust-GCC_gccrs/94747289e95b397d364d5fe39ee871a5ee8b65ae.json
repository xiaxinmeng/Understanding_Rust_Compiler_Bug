{"sha": "94747289e95b397d364d5fe39ee871a5ee8b65ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ3NDcyODllOTViMzk3ZDM2NGQ1ZmUzOWVlODcxYTVlZThiNjVhZQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-08-10T10:51:46Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-08-10T10:51:46Z"}, "message": "re PR fortran/37425 (Fortran 2003: GENERIC bindings as operators)\n\n2009-08-10  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37425\n\t* gfortran.dg/typebound_operator_1.f03: New test.\n\t* gfortran.dg/typebound_operator_2.f03: New test.\n\n2009-08-10  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37425\n\t* gfortran.h (struct gfc_namespace): New fields tb_uop_root and tb_op.\n\t(gfc_find_typebound_user_op): New routine.\n\t(gfc_find_typebound_intrinsic_op): Ditto.\n\t(gfc_check_operator_interface): Now public routine.\n\t* decl.c (gfc_match_generic): Match OPERATOR(X) or ASSIGNMENT(=).\n\t* interface.c (check_operator_interface): Made public, renamed to\n\t`gfc_check_operator_interface' accordingly and hand in the interface\n\tas gfc_symbol rather than gfc_interface so it is useful for type-bound\n\toperators, too.  Return boolean result.\n\t(gfc_check_interfaces): Adapt call to `check_operator_interface'.\n\t* symbol.c (gfc_get_namespace): Initialize new field `tb_op'.\n\t(gfc_free_namespace): Free `tb_uop_root'-based tree.\n\t(find_typebound_proc_uop): New helper function.\n\t(gfc_find_typebound_proc): Use it.\n\t(gfc_find_typebound_user_op): New method.\n\t(gfc_find_typebound_intrinsic_op): Ditto.\n\t* resolve.c (resolve_tb_generic_targets): New helper function.\n\t(resolve_typebound_generic): Use it.\n\t(resolve_typebound_intrinsic_op), (resolve_typebound_user_op): New.\n\t(resolve_typebound_procedures): Resolve operators, too.\n\t(check_uop_procedure): New, code from gfc_resolve_uops.\n\t(gfc_resolve_uops): Moved main code to new `check_uop_procedure'.\n\nFrom-SVN: r150622", "tree": {"sha": "c9cb831896e1271168a8d8990ba440b96eccd577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9cb831896e1271168a8d8990ba440b96eccd577"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94747289e95b397d364d5fe39ee871a5ee8b65ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94747289e95b397d364d5fe39ee871a5ee8b65ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94747289e95b397d364d5fe39ee871a5ee8b65ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94747289e95b397d364d5fe39ee871a5ee8b65ae/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f4e722eb62eaddb1313c09dfc0fa5d094d78148", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4e722eb62eaddb1313c09dfc0fa5d094d78148", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4e722eb62eaddb1313c09dfc0fa5d094d78148"}], "stats": {"total": 822, "additions": 664, "deletions": 158}, "files": [{"sha": "1e8d739085add0042dbd5f5e34eb4634ca895d3c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -1,3 +1,29 @@\n+2009-08-10  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37425\n+\t* gfortran.h (struct gfc_namespace): New fields tb_uop_root and tb_op.\n+\t(gfc_find_typebound_user_op): New routine.\n+\t(gfc_find_typebound_intrinsic_op): Ditto.\n+\t(gfc_check_operator_interface): Now public routine.\n+\t* decl.c (gfc_match_generic): Match OPERATOR(X) or ASSIGNMENT(=).\n+\t* interface.c (check_operator_interface): Made public, renamed to\n+\t`gfc_check_operator_interface' accordingly and hand in the interface\n+\tas gfc_symbol rather than gfc_interface so it is useful for type-bound\n+\toperators, too.  Return boolean result.\n+\t(gfc_check_interfaces): Adapt call to `check_operator_interface'.\n+\t* symbol.c (gfc_get_namespace): Initialize new field `tb_op'.\n+\t(gfc_free_namespace): Free `tb_uop_root'-based tree.\n+\t(find_typebound_proc_uop): New helper function.\n+\t(gfc_find_typebound_proc): Use it.\n+\t(gfc_find_typebound_user_op): New method.\n+\t(gfc_find_typebound_intrinsic_op): Ditto.\n+\t* resolve.c (resolve_tb_generic_targets): New helper function.\n+\t(resolve_typebound_generic): Use it.\n+\t(resolve_typebound_intrinsic_op), (resolve_typebound_user_op): New.\n+\t(resolve_typebound_procedures): Resolve operators, too.\n+\t(check_uop_procedure): New, code from gfc_resolve_uops.\n+\t(gfc_resolve_uops): Moved main code to new `check_uop_procedure'.\n+\n 2009-08-10  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40940"}, {"sha": "abe2147b7a2cbe238d77211416ae95cdc2a365a4", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 96, "deletions": 17, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -7406,11 +7406,13 @@ match\n gfc_match_generic (void)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n+  char bind_name[GFC_MAX_SYMBOL_LEN + 16]; /* Allow space for OPERATOR(...).  */\n   gfc_symbol* block;\n   gfc_typebound_proc tbattr; /* Used for match_binding_attributes.  */\n   gfc_typebound_proc* tb;\n-  gfc_symtree* st;\n   gfc_namespace* ns;\n+  interface_type op_type;\n+  gfc_intrinsic_op op;\n   match m;\n \n   /* Check current state.  */\n@@ -7437,49 +7439,126 @@ gfc_match_generic (void)\n       goto error;\n     }\n \n-  /* The binding name and =>.  */\n-  m = gfc_match (\" %n =>\", name);\n+  /* Match the binding name; depending on type (operator / generic) format\n+     it for future error messages into bind_name.  */\n+ \n+  m = gfc_match_generic_spec (&op_type, name, &op);\n   if (m == MATCH_ERROR)\n     return MATCH_ERROR;\n   if (m == MATCH_NO)\n     {\n-      gfc_error (\"Expected generic name at %C\");\n+      gfc_error (\"Expected generic name or operator descriptor at %C\");\n       goto error;\n     }\n \n-  /* If there's already something with this name, check that it is another\n-     GENERIC and then extend that rather than build a new node.  */\n-  st = gfc_find_symtree (ns->tb_sym_root, name);\n-  if (st)\n+  switch (op_type)\n     {\n-      gcc_assert (st->n.tb);\n-      tb = st->n.tb;\n+    case INTERFACE_GENERIC:\n+      snprintf (bind_name, sizeof (bind_name), \"%s\", name);\n+      break;\n+ \n+    case INTERFACE_USER_OP:\n+      snprintf (bind_name, sizeof (bind_name), \"OPERATOR(.%s.)\", name);\n+      break;\n+ \n+    case INTERFACE_INTRINSIC_OP:\n+      snprintf (bind_name, sizeof (bind_name), \"OPERATOR(%s)\",\n+\t\tgfc_op2string (op));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n+  /* Match the required =>.  */\n+  if (gfc_match (\" =>\") != MATCH_YES)\n+    {\n+      gfc_error (\"Expected '=>' at %C\");\n+      goto error;\n+    }\n+  \n+  /* Try to find existing GENERIC binding with this name / for this operator;\n+     if there is something, check that it is another GENERIC and then extend\n+     it rather than building a new node.  Otherwise, create it and put it\n+     at the right position.  */\n+\n+  switch (op_type)\n+    {\n+    case INTERFACE_USER_OP:\n+    case INTERFACE_GENERIC:\n+      {\n+\tconst bool is_op = (op_type == INTERFACE_USER_OP);\n+\tgfc_symtree* st;\n+\n+\tst = gfc_find_symtree (is_op ? ns->tb_uop_root : ns->tb_sym_root, name);\n+\tif (st)\n+\t  {\n+\t    tb = st->n.tb;\n+\t    gcc_assert (tb);\n+\t  }\n+\telse\n+\t  tb = NULL;\n+\n+\tbreak;\n+      }\n+\n+    case INTERFACE_INTRINSIC_OP:\n+      tb = ns->tb_op[op];\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (tb)\n+    {\n       if (!tb->is_generic)\n \t{\n+\t  gcc_assert (op_type == INTERFACE_GENERIC);\n \t  gfc_error (\"There's already a non-generic procedure with binding name\"\n \t\t     \" '%s' for the derived type '%s' at %C\",\n-\t\t     name, block->name);\n+\t\t     bind_name, block->name);\n \t  goto error;\n \t}\n \n       if (tb->access != tbattr.access)\n \t{\n \t  gfc_error (\"Binding at %C must have the same access as already\"\n-\t\t     \" defined binding '%s'\", name);\n+\t\t     \" defined binding '%s'\", bind_name);\n \t  goto error;\n \t}\n     }\n   else\n     {\n-      st = gfc_new_symtree (&ns->tb_sym_root, name);\n-      gcc_assert (st);\n-\n-      st->n.tb = tb = gfc_get_typebound_proc ();\n+      tb = gfc_get_typebound_proc ();\n       tb->where = gfc_current_locus;\n       tb->access = tbattr.access;\n       tb->is_generic = 1;\n       tb->u.generic = NULL;\n+\n+      switch (op_type)\n+\t{\n+\tcase INTERFACE_GENERIC:\n+\tcase INTERFACE_USER_OP:\n+\t  {\n+\t    const bool is_op = (op_type == INTERFACE_USER_OP);\n+\t    gfc_symtree* st;\n+\n+\t    st = gfc_new_symtree (is_op ? &ns->tb_uop_root : &ns->tb_sym_root,\n+\t\t\t\t  name);\n+\t    gcc_assert (st);\n+\t    st->n.tb = tb;\n+\n+\t    break;\n+\t  }\n+\t  \n+\tcase INTERFACE_INTRINSIC_OP:\n+\t  ns->tb_op[op] = tb;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n \n   /* Now, match all following names as specific targets.  */\n@@ -7504,7 +7583,7 @@ gfc_match_generic (void)\n \tif (target_st == target->specific_st)\n \t  {\n \t    gfc_error (\"'%s' already defined as specific binding for the\"\n-\t\t       \" generic '%s' at %C\", name, st->name);\n+\t\t       \" generic '%s' at %C\", name, bind_name);\n \t    goto error;\n \t  }\n "}, {"sha": "cb456bc5976f84b960c0e69a449096b637e9834e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -1287,6 +1287,10 @@ typedef struct gfc_namespace\n \n   /* Tree containing type-bound procedures.  */\n   gfc_symtree *tb_sym_root;\n+  /* Type-bound user operators.  */\n+  gfc_symtree *tb_uop_root;\n+  /* For derived-types, store type-bound intrinsic operators here.  */\n+  gfc_typebound_proc *tb_op[GFC_INTRINSIC_OPS];\n   /* Linked list of finalizer procedures.  */\n   struct gfc_finalizer *finalizers;\n \n@@ -2448,6 +2452,10 @@ gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n gfc_typebound_proc* gfc_get_typebound_proc (void);\n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n gfc_symtree* gfc_find_typebound_proc (gfc_symbol*, gfc_try*, const char*, bool);\n+gfc_symtree* gfc_find_typebound_user_op (gfc_symbol*, gfc_try*,\n+\t\t\t\t\t const char*, bool);\n+gfc_typebound_proc* gfc_find_typebound_intrinsic_op (gfc_symbol*, gfc_try*,\n+\t\t\t\t\t\t     gfc_intrinsic_op, bool);\n gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n \n void gfc_copy_formal_args (gfc_symbol *, gfc_symbol *);\n@@ -2636,6 +2644,7 @@ gfc_interface *gfc_current_interface_head (void);\n void gfc_set_current_interface_head (gfc_interface *);\n gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);\n+bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "daa46d88619ac0d91eb817a3e025de60408d8735", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -544,52 +544,49 @@ find_keyword_arg (const char *name, gfc_formal_arglist *f)\n /* Given an operator interface and the operator, make sure that all\n    interfaces for that operator are legal.  */\n \n-static void\n-check_operator_interface (gfc_interface *intr, gfc_intrinsic_op op)\n+bool\n+gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n+\t\t\t      locus opwhere)\n {\n   gfc_formal_arglist *formal;\n   sym_intent i1, i2;\n-  gfc_symbol *sym;\n   bt t1, t2;\n   int args, r1, r2, k1, k2;\n \n-  if (intr == NULL)\n-    return;\n+  gcc_assert (sym);\n \n   args = 0;\n   t1 = t2 = BT_UNKNOWN;\n   i1 = i2 = INTENT_UNKNOWN;\n   r1 = r2 = -1;\n   k1 = k2 = -1;\n \n-  for (formal = intr->sym->formal; formal; formal = formal->next)\n+  for (formal = sym->formal; formal; formal = formal->next)\n     {\n-      sym = formal->sym;\n-      if (sym == NULL)\n+      gfc_symbol *fsym = formal->sym;\n+      if (fsym == NULL)\n \t{\n \t  gfc_error (\"Alternate return cannot appear in operator \"\n-\t\t     \"interface at %L\", &intr->sym->declared_at);\n-\t  return;\n+\t\t     \"interface at %L\", &sym->declared_at);\n+\t  return false;\n \t}\n       if (args == 0)\n \t{\n-\t  t1 = sym->ts.type;\n-\t  i1 = sym->attr.intent;\n-\t  r1 = (sym->as != NULL) ? sym->as->rank : 0;\n-\t  k1 = sym->ts.kind;\n+\t  t1 = fsym->ts.type;\n+\t  i1 = fsym->attr.intent;\n+\t  r1 = (fsym->as != NULL) ? fsym->as->rank : 0;\n+\t  k1 = fsym->ts.kind;\n \t}\n       if (args == 1)\n \t{\n-\t  t2 = sym->ts.type;\n-\t  i2 = sym->attr.intent;\n-\t  r2 = (sym->as != NULL) ? sym->as->rank : 0;\n-\t  k2 = sym->ts.kind;\n+\t  t2 = fsym->ts.type;\n+\t  i2 = fsym->attr.intent;\n+\t  r2 = (fsym->as != NULL) ? fsym->as->rank : 0;\n+\t  k2 = fsym->ts.kind;\n \t}\n       args++;\n     }\n \n-  sym = intr->sym;\n-\n   /* Only +, - and .not. can be unary operators.\n      .not. cannot be a binary operator.  */\n   if (args == 0 || args > 2 || (args == 1 && op != INTRINSIC_PLUS\n@@ -598,8 +595,8 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op op)\n       || (args == 2 && op == INTRINSIC_NOT))\n     {\n       gfc_error (\"Operator interface at %L has the wrong number of arguments\",\n-\t\t &intr->sym->declared_at);\n-      return;\n+\t\t &sym->declared_at);\n+      return false;\n     }\n \n   /* Check that intrinsics are mapped to functions, except\n@@ -609,61 +606,73 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op op)\n       if (!sym->attr.subroutine)\n \t{\n \t  gfc_error (\"Assignment operator interface at %L must be \"\n-\t\t     \"a SUBROUTINE\", &intr->sym->declared_at);\n-\t  return;\n+\t\t     \"a SUBROUTINE\", &sym->declared_at);\n+\t  return false;\n \t}\n       if (args != 2)\n \t{\n \t  gfc_error (\"Assignment operator interface at %L must have \"\n-\t\t     \"two arguments\", &intr->sym->declared_at);\n-\t  return;\n+\t\t     \"two arguments\", &sym->declared_at);\n+\t  return false;\n \t}\n \n       /* Allowed are (per F2003, 12.3.2.1.2 Defined assignments):\n-         - First argument an array with different rank than second,\n-         - Types and kinds do not conform, and\n-         - First argument is of derived type.  */\n+\t - First argument an array with different rank than second,\n+\t - Types and kinds do not conform, and\n+\t - First argument is of derived type.  */\n       if (sym->formal->sym->ts.type != BT_DERIVED\n \t  && (r1 == 0 || r1 == r2)\n \t  && (sym->formal->sym->ts.type == sym->formal->next->sym->ts.type\n \t      || (gfc_numeric_ts (&sym->formal->sym->ts)\n \t\t  && gfc_numeric_ts (&sym->formal->next->sym->ts))))\n \t{\n \t  gfc_error (\"Assignment operator interface at %L must not redefine \"\n-\t\t     \"an INTRINSIC type assignment\", &intr->sym->declared_at);\n-\t  return;\n+\t\t     \"an INTRINSIC type assignment\", &sym->declared_at);\n+\t  return false;\n \t}\n     }\n   else\n     {\n       if (!sym->attr.function)\n \t{\n \t  gfc_error (\"Intrinsic operator interface at %L must be a FUNCTION\",\n-\t\t     &intr->sym->declared_at);\n-\t  return;\n+\t\t     &sym->declared_at);\n+\t  return false;\n \t}\n     }\n \n   /* Check intents on operator interfaces.  */\n   if (op == INTRINSIC_ASSIGN)\n     {\n       if (i1 != INTENT_OUT && i1 != INTENT_INOUT)\n-\tgfc_error (\"First argument of defined assignment at %L must be \"\n-\t\t   \"INTENT(OUT) or INTENT(INOUT)\", &intr->sym->declared_at);\n+\t{\n+\t  gfc_error (\"First argument of defined assignment at %L must be \"\n+\t\t     \"INTENT(OUT) or INTENT(INOUT)\", &sym->declared_at);\n+\t  return false;\n+\t}\n \n       if (i2 != INTENT_IN)\n-\tgfc_error (\"Second argument of defined assignment at %L must be \"\n-\t\t   \"INTENT(IN)\", &intr->sym->declared_at);\n+\t{\n+\t  gfc_error (\"Second argument of defined assignment at %L must be \"\n+\t\t     \"INTENT(IN)\", &sym->declared_at);\n+\t  return false;\n+\t}\n     }\n   else\n     {\n       if (i1 != INTENT_IN)\n-\tgfc_error (\"First argument of operator interface at %L must be \"\n-\t\t   \"INTENT(IN)\", &intr->sym->declared_at);\n+\t{\n+\t  gfc_error (\"First argument of operator interface at %L must be \"\n+\t\t     \"INTENT(IN)\", &sym->declared_at);\n+\t  return false;\n+\t}\n \n       if (args == 2 && i2 != INTENT_IN)\n-\tgfc_error (\"Second argument of operator interface at %L must be \"\n-\t\t   \"INTENT(IN)\", &intr->sym->declared_at);\n+\t{\n+\t  gfc_error (\"Second argument of operator interface at %L must be \"\n+\t\t     \"INTENT(IN)\", &sym->declared_at);\n+\t  return false;\n+\t}\n     }\n \n   /* From now on, all we have to do is check that the operator definition\n@@ -686,28 +695,28 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op op)\n       if (t1 == BT_LOGICAL)\n \tgoto bad_repl;\n       else\n-\treturn;\n+\treturn true;\n     }\n \n   if (args == 1 && (op == INTRINSIC_PLUS || op == INTRINSIC_MINUS))\n     {\n       if (IS_NUMERIC_TYPE (t1))\n \tgoto bad_repl;\n       else\n-\treturn;\n+\treturn true;\n     }\n \n   /* Character intrinsic operators have same character kind, thus\n      operator definitions with operands of different character kinds\n      are always safe.  */\n   if (t1 == BT_CHARACTER && t2 == BT_CHARACTER && k1 != k2)\n-    return;\n+    return true;\n \n   /* Intrinsic operators always perform on arguments of same rank,\n      so different ranks is also always safe.  (rank == 0) is an exception\n      to that, because all intrinsic operators are elemental.  */\n   if (r1 != r2 && r1 != 0 && r2 != 0)\n-    return;\n+    return true;\n \n   switch (op)\n   {\n@@ -760,14 +769,14 @@ check_operator_interface (gfc_interface *intr, gfc_intrinsic_op op)\n       break;\n   }\n \n-  return;\n+  return true;\n \n #undef IS_NUMERIC_TYPE\n \n bad_repl:\n   gfc_error (\"Operator interface at %L conflicts with intrinsic interface\",\n-\t     &intr->where);\n-  return;\n+\t     &opwhere);\n+  return false;\n }\n \n \n@@ -1229,7 +1238,9 @@ gfc_check_interfaces (gfc_namespace *ns)\n       if (check_interface0 (ns->op[i], interface_name))\n \tcontinue;\n \n-      check_operator_interface (ns->op[i], (gfc_intrinsic_op) i);\n+      if (ns->op[i])\n+\tgfc_check_operator_interface (ns->op[i]->sym, (gfc_intrinsic_op) i,\n+\t\t\t\t      ns->op[i]->where);\n \n       for (ns2 = ns; ns2; ns2 = ns2->parent)\n \t{"}, {"sha": "5c4370427d841553a756d2db46e5e62dd78d3984", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 258, "deletions": 81, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -8793,37 +8793,27 @@ check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n }\n \n \n-/* Resolve a GENERIC procedure binding for a derived type.  */\n+/* Worker function for resolving a generic procedure binding; this is used to\n+   resolve GENERIC as well as user and intrinsic OPERATOR typebound procedures.\n+\n+   The difference between those cases is finding possible inherited bindings\n+   that are overridden, as one has to look for them in tb_sym_root,\n+   tb_uop_root or tb_op, respectively.  Thus the caller must already find\n+   the super-type and set p->overridden correctly.  */\n \n static gfc_try\n-resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n+resolve_tb_generic_targets (gfc_symbol* super_type,\n+\t\t\t    gfc_typebound_proc* p, const char* name)\n {\n   gfc_tbp_generic* target;\n   gfc_symtree* first_target;\n-  gfc_symbol* super_type;\n   gfc_symtree* inherited;\n-  locus where;\n-\n-  gcc_assert (st->n.tb);\n-  gcc_assert (st->n.tb->is_generic);\n-\n-  where = st->n.tb->where;\n-  super_type = gfc_get_derived_super_type (derived);\n-\n-  /* Find the overridden binding if any.  */\n-  st->n.tb->overridden = NULL;\n-  if (super_type)\n-    {\n-      gfc_symtree* overridden;\n-      overridden = gfc_find_typebound_proc (super_type, NULL, st->name, true);\n \n-      if (overridden && overridden->n.tb)\n-\tst->n.tb->overridden = overridden->n.tb;\n-    }\n+  gcc_assert (p && p->is_generic);\n \n   /* Try to find the specific bindings for the symtrees in our target-list.  */\n-  gcc_assert (st->n.tb->u.generic);\n-  for (target = st->n.tb->u.generic; target; target = target->next)\n+  gcc_assert (p->u.generic);\n+  for (target = p->u.generic; target; target = target->next)\n     if (!target->specific)\n       {\n \tgfc_typebound_proc* overridden_tbp;\n@@ -8854,7 +8844,7 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n \t  }\n \n \tgfc_error (\"Undefined specific binding '%s' as target of GENERIC '%s'\"\n-\t\t   \" at %L\", target_name, st->name, &where);\n+\t\t   \" at %L\", target_name, name, &p->where);\n \treturn FAILURE;\n \n \t/* Once we've found the specific binding, check it is not ambiguous with\n@@ -8866,56 +8856,187 @@ resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n \tif (target->specific->is_generic)\n \t  {\n \t    gfc_error (\"GENERIC '%s' at %L must target a specific binding,\"\n-\t\t       \" '%s' is GENERIC, too\", st->name, &where, target_name);\n+\t\t       \" '%s' is GENERIC, too\", name, &p->where, target_name);\n \t    return FAILURE;\n \t  }\n \n \t/* Check those already resolved on this type directly.  */\n-\tfor (g = st->n.tb->u.generic; g; g = g->next)\n+\tfor (g = p->u.generic; g; g = g->next)\n \t  if (g != target && g->specific\n-\t      && check_generic_tbp_ambiguity (target, g, st->name, where)\n+\t      && check_generic_tbp_ambiguity (target, g, name, p->where)\n \t\t  == FAILURE)\n \t    return FAILURE;\n \n \t/* Check for ambiguity with inherited specific targets.  */\n-\tfor (overridden_tbp = st->n.tb->overridden; overridden_tbp;\n+\tfor (overridden_tbp = p->overridden; overridden_tbp;\n \t     overridden_tbp = overridden_tbp->overridden)\n \t  if (overridden_tbp->is_generic)\n \t    {\n \t      for (g = overridden_tbp->u.generic; g; g = g->next)\n \t\t{\n \t\t  gcc_assert (g->specific);\n \t\t  if (check_generic_tbp_ambiguity (target, g,\n-\t\t\t\t\t\t   st->name, where) == FAILURE)\n+\t\t\t\t\t\t   name, p->where) == FAILURE)\n \t\t    return FAILURE;\n \t\t}\n \t    }\n       }\n \n   /* If we attempt to \"overwrite\" a specific binding, this is an error.  */\n-  if (st->n.tb->overridden && !st->n.tb->overridden->is_generic)\n+  if (p->overridden && !p->overridden->is_generic)\n     {\n       gfc_error (\"GENERIC '%s' at %L can't overwrite specific binding with\"\n-\t\t \" the same name\", st->name, &where);\n+\t\t \" the same name\", name, &p->where);\n       return FAILURE;\n     }\n \n   /* Take the SUBROUTINE/FUNCTION attributes of the first specific target, as\n      all must have the same attributes here.  */\n-  first_target = st->n.tb->u.generic->specific->u.specific;\n+  first_target = p->u.generic->specific->u.specific;\n   gcc_assert (first_target);\n-  st->n.tb->subroutine = first_target->n.sym->attr.subroutine;\n-  st->n.tb->function = first_target->n.sym->attr.function;\n+  p->subroutine = first_target->n.sym->attr.subroutine;\n+  p->function = first_target->n.sym->attr.function;\n \n   return SUCCESS;\n }\n \n \n-/* Resolve the type-bound procedures for a derived type.  */\n+/* Resolve a GENERIC procedure binding for a derived type.  */\n+\n+static gfc_try\n+resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n+{\n+  gfc_symbol* super_type;\n+\n+  /* Find the overridden binding if any.  */\n+  st->n.tb->overridden = NULL;\n+  super_type = gfc_get_derived_super_type (derived);\n+  if (super_type)\n+    {\n+      gfc_symtree* overridden;\n+      overridden = gfc_find_typebound_proc (super_type, NULL, st->name, true);\n+\n+      if (overridden && overridden->n.tb)\n+\tst->n.tb->overridden = overridden->n.tb;\n+    }\n+\n+  /* Resolve using worker function.  */\n+  return resolve_tb_generic_targets (super_type, st->n.tb, st->name);\n+}\n+\n+\n+/* Resolve a type-bound intrinsic operator.  */\n+\n+static gfc_try\n+resolve_typebound_intrinsic_op (gfc_symbol* derived, gfc_intrinsic_op op,\n+\t\t\t\tgfc_typebound_proc* p)\n+{\n+  gfc_symbol* super_type;\n+  gfc_tbp_generic* target;\n+  \n+  /* If there's already an error here, do nothing (but don't fail again).  */\n+  if (p->error)\n+    return SUCCESS;\n+\n+  /* Operators should always be GENERIC bindings.  */\n+  gcc_assert (p->is_generic);\n+\n+  /* Look for an overridden binding.  */\n+  super_type = gfc_get_derived_super_type (derived);\n+  if (super_type && super_type->f2k_derived)\n+    p->overridden = gfc_find_typebound_intrinsic_op (super_type, NULL,\n+\t\t\t\t\t\t     op, true);\n+  else\n+    p->overridden = NULL;\n+\n+  /* Resolve general GENERIC properties using worker function.  */\n+  if (resolve_tb_generic_targets (super_type, p, gfc_op2string (op)) == FAILURE)\n+    goto error;\n+\n+  /* Check the targets to be procedures of correct interface.  */\n+  for (target = p->u.generic; target; target = target->next)\n+    {\n+      gfc_symbol* target_proc;\n+\n+      gcc_assert (target->specific && !target->specific->is_generic);\n+      target_proc = target->specific->u.specific->n.sym;\n+      gcc_assert (target_proc);\n+\n+      if (!gfc_check_operator_interface (target_proc, op, p->where))\n+\treturn FAILURE;\n+    }\n+\n+  return SUCCESS;\n+\n+error:\n+  p->error = 1;\n+  return FAILURE;\n+}\n+\n+\n+/* Resolve a type-bound user operator (tree-walker callback).  */\n \n static gfc_symbol* resolve_bindings_derived;\n static gfc_try resolve_bindings_result;\n \n+static gfc_try check_uop_procedure (gfc_symbol* sym, locus where);\n+\n+static void\n+resolve_typebound_user_op (gfc_symtree* stree)\n+{\n+  gfc_symbol* super_type;\n+  gfc_tbp_generic* target;\n+\n+  gcc_assert (stree && stree->n.tb);\n+\n+  if (stree->n.tb->error)\n+    return;\n+\n+  /* Operators should always be GENERIC bindings.  */\n+  gcc_assert (stree->n.tb->is_generic);\n+\n+  /* Find overridden procedure, if any.  */\n+  super_type = gfc_get_derived_super_type (resolve_bindings_derived);\n+  if (super_type && super_type->f2k_derived)\n+    {\n+      gfc_symtree* overridden;\n+      overridden = gfc_find_typebound_user_op (super_type, NULL,\n+\t\t\t\t\t       stree->name, true);\n+\n+      if (overridden && overridden->n.tb)\n+\tstree->n.tb->overridden = overridden->n.tb;\n+    }\n+  else\n+    stree->n.tb->overridden = NULL;\n+\n+  /* Resolve basically using worker function.  */\n+  if (resolve_tb_generic_targets (super_type, stree->n.tb, stree->name)\n+\t== FAILURE)\n+    goto error;\n+\n+  /* Check the targets to be functions of correct interface.  */\n+  for (target = stree->n.tb->u.generic; target; target = target->next)\n+    {\n+      gfc_symbol* target_proc;\n+\n+      gcc_assert (target->specific && !target->specific->is_generic);\n+      target_proc = target->specific->u.specific->n.sym;\n+      gcc_assert (target_proc);\n+\n+      if (check_uop_procedure (target_proc, stree->n.tb->where) == FAILURE)\n+\tgoto error;\n+    }\n+\n+  return;\n+\n+error:\n+  resolve_bindings_result = FAILURE;\n+  stree->n.tb->error = 1;\n+}\n+\n+\n+/* Resolve the type-bound procedures for a derived type.  */\n+\n static void\n resolve_typebound_procedure (gfc_symtree* stree)\n {\n@@ -9082,13 +9203,42 @@ resolve_typebound_procedure (gfc_symtree* stree)\n static gfc_try\n resolve_typebound_procedures (gfc_symbol* derived)\n {\n+  int op;\n+  bool found_op;\n+\n   if (!derived->f2k_derived || !derived->f2k_derived->tb_sym_root)\n     return SUCCESS;\n \n   resolve_bindings_derived = derived;\n   resolve_bindings_result = SUCCESS;\n-  gfc_traverse_symtree (derived->f2k_derived->tb_sym_root,\n-\t\t\t&resolve_typebound_procedure);\n+\n+  if (derived->f2k_derived->tb_sym_root)\n+    gfc_traverse_symtree (derived->f2k_derived->tb_sym_root,\n+\t\t\t  &resolve_typebound_procedure);\n+\n+  found_op = (derived->f2k_derived->tb_uop_root != NULL);\n+  if (derived->f2k_derived->tb_uop_root)\n+    gfc_traverse_symtree (derived->f2k_derived->tb_uop_root,\n+\t\t\t  &resolve_typebound_user_op);\n+\n+  for (op = 0; op != GFC_INTRINSIC_OPS; ++op)\n+    {\n+      gfc_typebound_proc* p = derived->f2k_derived->tb_op[op];\n+      if (p && resolve_typebound_intrinsic_op (derived, (gfc_intrinsic_op) op,\n+\t\t\t\t\t       p) == FAILURE)\n+\tresolve_bindings_result = FAILURE;\n+      if (p)\n+\tfound_op = true;\n+    }\n+\n+  /* FIXME: Remove this (and found_op) once calls are fully implemented.  */\n+  if (found_op)\n+    {\n+      gfc_error (\"Derived type '%s' at %L contains type-bound OPERATOR's,\"\n+\t\t \" they are not yet implemented.\",\n+\t\t derived->name, &derived->declared_at);\n+      resolve_bindings_result = FAILURE;\n+    }\n \n   return resolve_bindings_result;\n }\n@@ -11063,67 +11213,94 @@ resolve_fntype (gfc_namespace *ns)\n       }\n }\n \n+\n /* 12.3.2.1.1 Defined operators.  */\n \n-static void\n-gfc_resolve_uops (gfc_symtree *symtree)\n+static gfc_try\n+check_uop_procedure (gfc_symbol *sym, locus where)\n {\n-  gfc_interface *itr;\n-  gfc_symbol *sym;\n   gfc_formal_arglist *formal;\n \n-  if (symtree == NULL)\n-    return;\n+  if (!sym->attr.function)\n+    {\n+      gfc_error (\"User operator procedure '%s' at %L must be a FUNCTION\",\n+\t\t sym->name, &where);\n+      return FAILURE;\n+    }\n \n-  gfc_resolve_uops (symtree->left);\n-  gfc_resolve_uops (symtree->right);\n+  if (sym->ts.type == BT_CHARACTER\n+      && !(sym->ts.cl && sym->ts.cl->length)\n+      && !(sym->result && sym->result->ts.cl\n+\t   && sym->result->ts.cl->length))\n+    {\n+      gfc_error (\"User operator procedure '%s' at %L cannot be assumed \"\n+\t\t \"character length\", sym->name, &where);\n+      return FAILURE;\n+    }\n \n-  for (itr = symtree->n.uop->op; itr; itr = itr->next)\n+  formal = sym->formal;\n+  if (!formal || !formal->sym)\n     {\n-      sym = itr->sym;\n-      if (!sym->attr.function)\n-\tgfc_error (\"User operator procedure '%s' at %L must be a FUNCTION\",\n-\t\t   sym->name, &sym->declared_at);\n+      gfc_error (\"User operator procedure '%s' at %L must have at least \"\n+\t\t \"one argument\", sym->name, &where);\n+      return FAILURE;\n+    }\n \n-      if (sym->ts.type == BT_CHARACTER\n-\t  && !(sym->ts.cl && sym->ts.cl->length)\n-\t  && !(sym->result && sym->result->ts.cl\n-\t       && sym->result->ts.cl->length))\n-\tgfc_error (\"User operator procedure '%s' at %L cannot be assumed \"\n-\t\t   \"character length\", sym->name, &sym->declared_at);\n+  if (formal->sym->attr.intent != INTENT_IN)\n+    {\n+      gfc_error (\"First argument of operator interface at %L must be \"\n+\t\t \"INTENT(IN)\", &where);\n+      return FAILURE;\n+    }\n \n-      formal = sym->formal;\n-      if (!formal || !formal->sym)\n-\t{\n-\t  gfc_error (\"User operator procedure '%s' at %L must have at least \"\n-\t\t     \"one argument\", sym->name, &sym->declared_at);\n-\t  continue;\n-\t}\n+  if (formal->sym->attr.optional)\n+    {\n+      gfc_error (\"First argument of operator interface at %L cannot be \"\n+\t\t \"optional\", &where);\n+      return FAILURE;\n+    }\n \n-      if (formal->sym->attr.intent != INTENT_IN)\n-\tgfc_error (\"First argument of operator interface at %L must be \"\n-\t\t   \"INTENT(IN)\", &sym->declared_at);\n+  formal = formal->next;\n+  if (!formal || !formal->sym)\n+    return SUCCESS;\n \n-      if (formal->sym->attr.optional)\n-\tgfc_error (\"First argument of operator interface at %L cannot be \"\n-\t\t   \"optional\", &sym->declared_at);\n+  if (formal->sym->attr.intent != INTENT_IN)\n+    {\n+      gfc_error (\"Second argument of operator interface at %L must be \"\n+\t\t \"INTENT(IN)\", &where);\n+      return FAILURE;\n+    }\n \n-      formal = formal->next;\n-      if (!formal || !formal->sym)\n-\tcontinue;\n+  if (formal->sym->attr.optional)\n+    {\n+      gfc_error (\"Second argument of operator interface at %L cannot be \"\n+\t\t \"optional\", &where);\n+      return FAILURE;\n+    }\n \n-      if (formal->sym->attr.intent != INTENT_IN)\n-\tgfc_error (\"Second argument of operator interface at %L must be \"\n-\t\t   \"INTENT(IN)\", &sym->declared_at);\n+  if (formal->next)\n+    {\n+      gfc_error (\"Operator interface at %L must have, at most, two \"\n+\t\t \"arguments\", &where);\n+      return FAILURE;\n+    }\n \n-      if (formal->sym->attr.optional)\n-\tgfc_error (\"Second argument of operator interface at %L cannot be \"\n-\t\t   \"optional\", &sym->declared_at);\n+  return SUCCESS;\n+}\n \n-      if (formal->next)\n-\tgfc_error (\"Operator interface at %L must have, at most, two \"\n-\t\t   \"arguments\", &sym->declared_at);\n-    }\n+static void\n+gfc_resolve_uops (gfc_symtree *symtree)\n+{\n+  gfc_interface *itr;\n+\n+  if (symtree == NULL)\n+    return;\n+\n+  gfc_resolve_uops (symtree->left);\n+  gfc_resolve_uops (symtree->right);\n+\n+  for (itr = symtree->n.uop->op; itr; itr = itr->next)\n+    check_uop_procedure (itr->sym, itr->sym->declared_at);\n }\n \n "}, {"sha": "c2666ae7e497f16eac97d05a81ef3245b802203d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 90, "deletions": 11, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -2220,7 +2220,10 @@ gfc_get_namespace (gfc_namespace *parent, int parent_types)\n   ns->parent = parent;\n \n   for (in = GFC_INTRINSIC_BEGIN; in != GFC_INTRINSIC_END; in++)\n-    ns->operator_access[in] = ACCESS_UNKNOWN;\n+    {\n+      ns->operator_access[in] = ACCESS_UNKNOWN;\n+      ns->tb_op[in] = NULL;\n+    }\n \n   /* Initialize default implicit types.  */\n   for (i = 'a'; i <= 'z'; i++)\n@@ -2948,15 +2951,13 @@ free_common_tree (gfc_symtree * common_tree)\n static void\n free_uop_tree (gfc_symtree *uop_tree)\n {\n-\n   if (uop_tree == NULL)\n     return;\n \n   free_uop_tree (uop_tree->left);\n   free_uop_tree (uop_tree->right);\n \n   gfc_free_interface (uop_tree->n.uop->op);\n-\n   gfc_free (uop_tree->n.uop);\n   gfc_free (uop_tree);\n }\n@@ -3128,6 +3129,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   free_uop_tree (ns->uop_root);\n   free_common_tree (ns->common_root);\n   free_tb_tree (ns->tb_sym_root);\n+  free_tb_tree (ns->tb_uop_root);\n   gfc_free_finalizer_list (ns->finalizers);\n   gfc_free_charlen (ns->cl_list, NULL);\n   free_st_labels (ns->st_labels);\n@@ -4519,22 +4521,27 @@ gfc_get_derived_super_type (gfc_symbol* derived)\n }\n \n \n-/* Find a type-bound procedure by name for a derived-type (looking recursively\n-   through the super-types).  */\n+/* General worker function to find either a type-bound procedure or a\n+   type-bound user operator.  */\n \n-gfc_symtree*\n-gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n-\t\t\t const char* name, bool noaccess)\n+static gfc_symtree*\n+find_typebound_proc_uop (gfc_symbol* derived, gfc_try* t,\n+\t\t\t const char* name, bool noaccess, bool uop)\n {\n   gfc_symtree* res;\n+  gfc_symtree* root;\n+\n+  /* Set correct symbol-root.  */\n+  gcc_assert (derived->f2k_derived);\n+  root = (uop ? derived->f2k_derived->tb_uop_root\n+\t      : derived->f2k_derived->tb_sym_root);\n \n   /* Set default to failure.  */\n   if (t)\n     *t = FAILURE;\n \n   /* Try to find it in the current type's namespace.  */\n-  gcc_assert (derived->f2k_derived);\n-  res = gfc_find_symtree (derived->f2k_derived->tb_sym_root, name);\n+  res = gfc_find_symtree (root, name);\n   if (res && res->n.tb)\n     {\n       /* We found one.  */\n@@ -4558,7 +4565,79 @@ gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n       gfc_symbol* super_type;\n       super_type = gfc_get_derived_super_type (derived);\n       gcc_assert (super_type);\n-      return gfc_find_typebound_proc (super_type, t, name, noaccess);\n+\n+      return find_typebound_proc_uop (super_type, t, name, noaccess, uop);\n+    }\n+\n+  /* Nothing found.  */\n+  return NULL;\n+}\n+\n+\n+/* Find a type-bound procedure or user operator by name for a derived-type\n+   (looking recursively through the super-types).  */\n+\n+gfc_symtree*\n+gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n+\t\t\t const char* name, bool noaccess)\n+{\n+  return find_typebound_proc_uop (derived, t, name, noaccess, false);\n+}\n+\n+gfc_symtree*\n+gfc_find_typebound_user_op (gfc_symbol* derived, gfc_try* t,\n+\t\t\t    const char* name, bool noaccess)\n+{\n+  return find_typebound_proc_uop (derived, t, name, noaccess, true);\n+}\n+\n+\n+/* Find a type-bound intrinsic operator looking recursively through the\n+   super-type hierarchy.  */\n+\n+gfc_typebound_proc*\n+gfc_find_typebound_intrinsic_op (gfc_symbol* derived, gfc_try* t,\n+\t\t\t\t gfc_intrinsic_op op, bool noaccess)\n+{\n+  gfc_typebound_proc* res;\n+\n+  /* Set default to failure.  */\n+  if (t)\n+    *t = FAILURE;\n+\n+  /* Try to find it in the current type's namespace.  */\n+  if (derived->f2k_derived)\n+    res = derived->f2k_derived->tb_op[op];\n+  else  \n+    res = NULL;\n+\n+  /* Check access.  */\n+  if (res)\n+    {\n+      /* We found one.  */\n+      if (t)\n+\t*t = SUCCESS;\n+\n+      if (!noaccess && derived->attr.use_assoc\n+\t  && res->access == ACCESS_PRIVATE)\n+\t{\n+\t  gfc_error (\"'%s' of '%s' is PRIVATE at %C\",\n+\t\t     gfc_op2string (op), derived->name);\n+\t  if (t)\n+\t    *t = FAILURE;\n+\t}\n+\n+      return res;\n+    }\n+\n+  /* Otherwise, recurse on parent type if derived is an extension.  */\n+  if (derived->attr.extension)\n+    {\n+      gfc_symbol* super_type;\n+      super_type = gfc_get_derived_super_type (derived);\n+      gcc_assert (super_type);\n+\n+      return gfc_find_typebound_intrinsic_op (super_type, t, op, noaccess);\n     }\n \n   /* Nothing found.  */"}, {"sha": "211381f9a1e234110c12aeed31ab208761994041", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -1,3 +1,9 @@\n+2009-08-10  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37425\n+\t* gfortran.dg/typebound_operator_1.f03: New test.\n+\t* gfortran.dg/typebound_operator_2.f03: New test.\n+\n 2009-08-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41006"}, {"sha": "fd74d9b06d51831b77d7b02e567eabc49deaeef0", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_1.f03", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_1.f03?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do compile }\n+! { dg-options \"-w\" }\n+! FIXME: Remove -w once CLASS is fully supported.\n+\n+! Type-bound procedures\n+! Check correct type-bound operator definitions.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE t ! { dg-error \"not yet implemented\" }\n+  CONTAINS\n+    PROCEDURE, PASS :: onearg\n+    PROCEDURE, PASS :: twoarg1\n+    PROCEDURE, PASS :: twoarg2\n+    PROCEDURE, PASS(me) :: assign_proc\n+\n+    GENERIC :: OPERATOR(.BINARY.) => twoarg1, twoarg2\n+    GENERIC :: OPERATOR(.UNARY.) => onearg\n+    GENERIC :: ASSIGNMENT(=) => assign_proc\n+  END TYPE t\n+\n+CONTAINS\n+\n+  INTEGER FUNCTION onearg (me)\n+    CLASS(t), INTENT(IN) :: me\n+    onearg = 5\n+  END FUNCTION onearg\n+\n+  INTEGER FUNCTION twoarg1 (me, a)\n+    CLASS(t), INTENT(IN) :: me\n+    INTEGER, INTENT(IN) :: a\n+    twoarg1 = 42\n+  END FUNCTION twoarg1\n+\n+  INTEGER FUNCTION twoarg2 (me, a)\n+    CLASS(t), INTENT(IN) :: me\n+    REAL, INTENT(IN) :: a\n+    twoarg2 = 123\n+  END FUNCTION twoarg2\n+\n+  SUBROUTINE assign_proc (me, b)\n+    CLASS(t), INTENT(OUT) :: me\n+    CLASS(t), INTENT(IN) :: b\n+    me = t ()\n+  END SUBROUTINE assign_proc\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "ccce3b525c28978c664e99ce19b852477700cb36", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_2.f03", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94747289e95b397d364d5fe39ee871a5ee8b65ae/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_2.f03?ref=94747289e95b397d364d5fe39ee871a5ee8b65ae", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do compile }\n+! { dg-options \"-w\" }\n+! FIXME: Remove -w once CLASS is fully supported.\n+\n+! Type-bound procedures\n+! Checks for correct errors with invalid OPERATOR/ASSIGNMENT usage.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE t ! { dg-error \"not yet implemented\" }\n+  CONTAINS\n+    PROCEDURE, PASS :: onearg\n+    PROCEDURE, PASS :: onearg_alt => onearg\n+    PROCEDURE, PASS :: onearg_alt2 => onearg\n+    PROCEDURE, PASS :: threearg\n+    PROCEDURE, NOPASS :: noarg\n+    PROCEDURE, PASS :: sub\n+    PROCEDURE, PASS :: sub2 ! { dg-error \"must be a FUNCTION\" }\n+    PROCEDURE, PASS :: func\n+\n+    ! These give errors at the targets' definitions.\n+    GENERIC :: OPERATOR(.AND.) => sub2\n+    GENERIC :: OPERATOR(*) => onearg\n+    GENERIC :: ASSIGNMENT(=) => func\n+\n+    GENERIC :: OPERATOR(.UOPA.) => sub ! { dg-error \"must be a FUNCTION\" }\n+    GENERIC :: OPERATOR(.UOPB.) => threearg ! { dg-error \"at most, two arguments\" }\n+    GENERIC :: OPERATOR(.UOPC.) => noarg ! { dg-error \"at least one argument\" }\n+\n+    GENERIC :: OPERATOR(.UNARY.) => onearg_alt\n+    GENERIC, PRIVATE :: OPERATOR(.UNARY.) => onearg_alt2 ! { dg-error \"must have the same access\" }\n+  END TYPE t\n+\n+CONTAINS\n+\n+  INTEGER FUNCTION onearg (me) ! { dg-error \"wrong number of arguments\" }\n+    CLASS(t), INTENT(IN) :: me\n+    onearg = 5\n+  END FUNCTION onearg\n+\n+  INTEGER FUNCTION threearg (a, b, c)\n+    CLASS(t), INTENT(IN) :: a, b, c\n+    threearg = 42\n+  END FUNCTION threearg\n+\n+  INTEGER FUNCTION noarg ()\n+    noarg = 42\n+  END FUNCTION noarg\n+\n+  LOGICAL FUNCTION func (me, b) ! { dg-error \"must be a SUBROUTINE\" }\n+    CLASS(t), INTENT(OUT) :: me\n+    CLASS(t), INTENT(IN) :: b\n+    me = t ()\n+    func = .TRUE.\n+  END FUNCTION func\n+\n+  SUBROUTINE sub (a)\n+    CLASS(t), INTENT(IN) :: a\n+  END SUBROUTINE sub\n+\n+  SUBROUTINE sub2 (a, x)\n+    CLASS(t), INTENT(IN) :: a\n+    INTEGER, INTENT(IN) :: x\n+  END SUBROUTINE sub2\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}