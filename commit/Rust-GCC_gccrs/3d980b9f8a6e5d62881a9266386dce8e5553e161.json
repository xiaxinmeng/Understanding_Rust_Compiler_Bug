{"sha": "3d980b9f8a6e5d62881a9266386dce8e5553e161", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q5ODBiOWY4YTZlNWQ2Mjg4MWE5MjY2Mzg2ZGNlOGU1NTUzZTE2MQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2002-04-18T11:23:25Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2002-04-18T11:23:25Z"}, "message": "Plug memory leak in handle_vector_size_attribute\n\nFrom-SVN: r52466", "tree": {"sha": "e912eac76e99416533db1b9a2424b1851bedb64e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e912eac76e99416533db1b9a2424b1851bedb64e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d980b9f8a6e5d62881a9266386dce8e5553e161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d980b9f8a6e5d62881a9266386dce8e5553e161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d980b9f8a6e5d62881a9266386dce8e5553e161", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d980b9f8a6e5d62881a9266386dce8e5553e161/comments", "author": null, "committer": null, "parents": [{"sha": "58c2956cc78b5eac943d4c800f28faa9e7529b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c2956cc78b5eac943d4c800f28faa9e7529b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c2956cc78b5eac943d4c800f28faa9e7529b4e"}], "stats": {"total": 57, "additions": 49, "deletions": 8}, "files": [{"sha": "9d19693c27f9b5374fd0e5cffab88e1b8a6d6589", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d980b9f8a6e5d62881a9266386dce8e5553e161/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d980b9f8a6e5d62881a9266386dce8e5553e161/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d980b9f8a6e5d62881a9266386dce8e5553e161", "patch": "@@ -1,3 +1,9 @@\n+2002-04-18  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* attribs.c (vector_type_node_list): New static variable.\n+\t(handle_vector_size_attribute): Use it to avoid generating a\n+\tnew type node each time we are called.\n+\n 2002-04-18  Roger Sayle  <roger@eyesopen.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "bdd6bd0b0a347ed680b1f19bca319d0926a2c621", "filename": "gcc/attribs.c", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d980b9f8a6e5d62881a9266386dce8e5553e161/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d980b9f8a6e5d62881a9266386dce8e5553e161/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=3d980b9f8a6e5d62881a9266386dce8e5553e161", "patch": "@@ -1268,6 +1268,13 @@ handle_deprecated_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \n+/* Keep a list of vector type nodes we created in handle_vector_size_attribute,\n+   to prevent us from duplicating type nodes unnecessarily.\n+   The normal mechanism to prevent duplicates is to use type_hash_canon, but\n+   since we want to distinguish types that are essentially identical (except\n+   for their debug representation), we use a local list here.  */\n+static tree vector_type_node_list = 0;\n+\n /* Handle a \"vector_size\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n@@ -1281,7 +1288,8 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n {\n   unsigned HOST_WIDE_INT vecsize, nunits;\n   enum machine_mode mode, orig_mode, new_mode;\n-  tree type = *node, new_type;\n+  tree type = *node, new_type = NULL_TREE;\n+  tree type_list_node;\n \n   *no_add_attrs = true;\n \n@@ -1337,11 +1345,34 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n \tbreak;\n       }\n \n-  if (new_mode == VOIDmode)\n-    error (\"no vector mode with the size and type specified could be found\");\n-  else\n+    if (new_mode == VOIDmode)\n     {\n-      tree index, array, rt;\n+      error (\"no vector mode with the size and type specified could be found\");\n+      return NULL_TREE;\n+    }\n+\n+  for (type_list_node = vector_type_node_list; type_list_node;\n+       type_list_node = TREE_CHAIN (type_list_node))\n+    {\n+      tree other_type = TREE_VALUE (type_list_node);\n+      tree record = TYPE_DEBUG_REPRESENTATION_TYPE (other_type);\n+      tree fields = TYPE_FIELDS (record);\n+      tree field_type = TREE_TYPE (fields);\n+      tree array_type = TREE_TYPE (field_type);\n+      if (TREE_CODE (fields) != FIELD_DECL\n+\t  || TREE_CODE (field_type) != ARRAY_TYPE)\n+\tabort ();\n+\n+      if (TYPE_MODE (other_type) == mode && type == array_type)\n+\t{\n+\t  new_type = other_type;\n+\t  break;\n+\t}\n+    }\n+\n+  if (new_type == NULL_TREE)\n+    {\n+      tree index, array, rt, list_node;\n \n       new_type = (*lang_hooks.types.type_for_mode) (new_mode,\n \t\t\t\t\t\t    TREE_UNSIGNED (type));\n@@ -1367,10 +1398,14 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n       layout_type (rt);\n       TYPE_DEBUG_REPRESENTATION_TYPE (new_type) = rt;\n \n-      /* Build back pointers if needed.  */\n-      *node = vector_size_helper (*node, new_type);\n+      list_node = build_tree_list (NULL, new_type);\n+      TREE_CHAIN (list_node) = vector_type_node_list;\n+      vector_type_node_list = list_node;\n     }\n-    \n+\n+  /* Build back pointers if needed.  */\n+  *node = vector_size_helper (*node, new_type);\n+\n   return NULL_TREE;\n }\n "}]}