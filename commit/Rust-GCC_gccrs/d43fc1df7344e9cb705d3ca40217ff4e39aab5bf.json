{"sha": "d43fc1df7344e9cb705d3ca40217ff4e39aab5bf", "node_id": "C_kwDOANBUbNoAKGQ0M2ZjMWRmNzM0NGU5Y2I3MDVkM2NhNDAyMTdmZjRlMzlhYWI1YmY", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-04T12:31:17Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-04T12:31:17Z"}, "message": "aarch64: Move more code into aarch64_vector_costs\n\nThis patch moves more code into aarch64_vector_costs and reuses\nsome of the information that is now available in the base class.\n\nI'm planing to significantly rework this code, with more hooks\ninto the vectoriser, but this seemed worth doing as a first step.\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_vector_costs): Make member\n\tvariables private and add \"m_\" to their names.  Remove is_loop.\n\t(aarch64_record_potential_advsimd_unrolling): Replace with...\n\t(aarch64_vector_costs::record_potential_advsimd_unrolling): ...this.\n\t(aarch64_analyze_loop_vinfo): Replace with...\n\t(aarch64_vector_costs::analyze_loop_vinfo): ...this.\n\tMove initialization of (m_)vec_flags to add_stmt_cost.\n\t(aarch64_analyze_bb_vinfo): Delete.\n\t(aarch64_count_ops): Replace with...\n\t(aarch64_vector_costs::count_ops): ...this.\n\t(aarch64_vector_costs::add_stmt_cost): Set m_vec_flags,\n\tusing m_costing_for_scalar to test whether we're costing\n\tscalar or vector code.\n\t(aarch64_adjust_body_cost_sve): Replace with...\n\t(aarch64_vector_costs::adjust_body_cost_sve): ...this.\n\t(aarch64_adjust_body_cost): Replace with...\n\t(aarch64_vector_costs::adjust_body_cost): ...this.\n\t(aarch64_vector_costs::finish_cost): Use m_vinfo instead of is_loop.", "tree": {"sha": "65ab124859cb2ad7f43bf778518ed87865155af6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ab124859cb2ad7f43bf778518ed87865155af6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d43fc1df7344e9cb705d3ca40217ff4e39aab5bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43fc1df7344e9cb705d3ca40217ff4e39aab5bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43fc1df7344e9cb705d3ca40217ff4e39aab5bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43fc1df7344e9cb705d3ca40217ff4e39aab5bf/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6239dd05127f1dc05f13f504805d36e8ebe1c2c5"}], "stats": {"total": 339, "additions": 155, "deletions": 184}, "files": [{"sha": "cc65b58a48f4698337b746510123abdb552de0d7", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 155, "deletions": 184, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43fc1df7344e9cb705d3ca40217ff4e39aab5bf/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43fc1df7344e9cb705d3ca40217ff4e39aab5bf/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=d43fc1df7344e9cb705d3ca40217ff4e39aab5bf", "patch": "@@ -14589,8 +14589,9 @@ struct aarch64_sve_op_count : aarch64_vec_op_count\n };\n \n /* Information about vector code that we're in the process of costing.  */\n-struct aarch64_vector_costs : public vector_costs\n+class aarch64_vector_costs : public vector_costs\n {\n+public:\n   using vector_costs::vector_costs;\n \n   unsigned int add_stmt_cost (int count, vect_cost_for_stmt kind,\n@@ -14599,26 +14600,31 @@ struct aarch64_vector_costs : public vector_costs\n \t\t\t      vect_cost_model_location where) override;\n   void finish_cost () override;\n \n-  /* True if we have performed one-time initialization based on the vec_info.\n-\n-     This variable exists because the vec_info is not passed to the\n-     init_cost hook.  We therefore have to defer initialization based on\n-     it till later.  */\n-  bool analyzed_vinfo = false;\n-\n-  /* True if we're costing a vector loop, false if we're costing block-level\n-     vectorization.  */\n-  bool is_loop = false;\n+private:\n+  void record_potential_advsimd_unrolling (loop_vec_info);\n+  void analyze_loop_vinfo (loop_vec_info);\n+  void count_ops (unsigned int, vect_cost_for_stmt, stmt_vec_info, tree,\n+\t\t  unsigned int, aarch64_vec_op_count *,\n+\t\t  const aarch64_base_vec_issue_info *, unsigned int);\n+  fractional_cost adjust_body_cost_sve (const aarch64_vec_issue_info *,\n+\t\t\t\t\tfractional_cost, fractional_cost,\n+\t\t\t\t\tbool, unsigned int, unsigned int *,\n+\t\t\t\t\tbool *);\n+  unsigned int adjust_body_cost (unsigned int);\n+\n+  /* True if we have performed one-time initialization based on the\n+     vec_info.  */\n+  bool m_analyzed_vinfo = false;\n \n   /* True if we've seen an SVE operation that we cannot currently vectorize\n      using Advanced SIMD.  */\n-  bool saw_sve_only_op = false;\n+  bool m_saw_sve_only_op = false;\n \n-  /* - If VEC_FLAGS is zero then we're costing the original scalar code.\n-     - If VEC_FLAGS & VEC_ADVSIMD is nonzero then we're costing Advanced\n+  /* - If M_VEC_FLAGS is zero then we're costing the original scalar code.\n+     - If M_VEC_FLAGS & VEC_ADVSIMD is nonzero then we're costing Advanced\n        SIMD code.\n-     - If VEC_FLAGS & VEC_ANY_SVE is nonzero then we're costing SVE code.  */\n-  unsigned int vec_flags = 0;\n+     - If M_VEC_FLAGS & VEC_ANY_SVE is nonzero then we're costing SVE code.  */\n+  unsigned int m_vec_flags = 0;\n \n   /* On some CPUs, SVE and Advanced SIMD provide the same theoretical vector\n      throughput, such as 4x128 Advanced SIMD vs. 2x256 SVE.  In those\n@@ -14628,39 +14634,39 @@ struct aarch64_vector_costs : public vector_costs\n      than length-agnostic SVE, since the SVE loop would execute an unknown\n      number of times and so could not be completely unrolled in the same way.\n \n-     If we're applying this heuristic, UNROLLED_ADVSIMD_NITERS is the\n+     If we're applying this heuristic, M_UNROLLED_ADVSIMD_NITERS is the\n      number of Advanced SIMD loop iterations that would be unrolled and\n-     UNROLLED_ADVSIMD_STMTS estimates the total number of statements\n+     M_UNROLLED_ADVSIMD_STMTS estimates the total number of statements\n      in the unrolled loop.  Both values are zero if we're not applying\n      the heuristic.  */\n-  unsigned HOST_WIDE_INT unrolled_advsimd_niters = 0;\n-  unsigned HOST_WIDE_INT unrolled_advsimd_stmts = 0;\n+  unsigned HOST_WIDE_INT m_unrolled_advsimd_niters = 0;\n+  unsigned HOST_WIDE_INT m_unrolled_advsimd_stmts = 0;\n \n   /* If we're vectorizing a loop that executes a constant number of times,\n      this variable gives the number of times that the vector loop would\n      iterate, otherwise it is zero.  */\n-  uint64_t num_vector_iterations = 0;\n+  uint64_t m_num_vector_iterations = 0;\n \n   /* Used only when vectorizing loops.  Estimates the number and kind of scalar\n      operations that would be needed to perform the same work as one iteration\n      of the vector loop.  */\n-  aarch64_vec_op_count scalar_ops;\n+  aarch64_vec_op_count m_scalar_ops;\n \n-  /* Used only when vectorizing loops.  If VEC_FLAGS & VEC_ADVSIMD,\n+  /* Used only when vectorizing loops.  If M_VEC_FLAGS & VEC_ADVSIMD,\n      this structure estimates the number and kind of operations that the\n-     vector loop would contain.  If VEC_FLAGS & VEC_SVE, the structure\n+     vector loop would contain.  If M_VEC_FLAGS & VEC_SVE, the structure\n      estimates what the equivalent Advanced SIMD-only code would need in\n      order to perform the same work as one iteration of the SVE loop.  */\n-  aarch64_vec_op_count advsimd_ops;\n+  aarch64_vec_op_count m_advsimd_ops;\n \n   /* Used only when vectorizing loops with SVE.  It estimates the number and\n      kind of operations that the SVE loop would contain.  */\n-  aarch64_sve_op_count sve_ops;\n+  aarch64_sve_op_count m_sve_ops;\n \n   /* Used to detect cases in which we end up costing the same load twice,\n      once to account for results that are actually used and once to account\n      for unused results.  */\n-  hash_map<nofree_ptr_hash<_stmt_vec_info>, unsigned int> seen_loads;\n+  hash_map<nofree_ptr_hash<_stmt_vec_info>, unsigned int> m_seen_loads;\n };\n \n /* Implement TARGET_VECTORIZE_CREATE_COSTS.  */\n@@ -14703,12 +14709,11 @@ aarch64_simd_vec_costs_for_flags (unsigned int flags)\n }\n \n /* Decide whether to use the unrolling heuristic described above\n-   aarch64_vector_costs::unrolled_advsimd_niters, updating that\n-   field if so.  LOOP_VINFO describes the loop that we're vectorizing\n-   and COSTS are the costs that we're calculating for it.  */\n-static void\n-aarch64_record_potential_advsimd_unrolling (loop_vec_info loop_vinfo,\n-\t\t\t\t\t    aarch64_vector_costs *costs)\n+   m_unrolled_advsimd_niters, updating that field if so.  LOOP_VINFO\n+   describes the loop that we're vectorizing.  */\n+void\n+aarch64_vector_costs::\n+record_potential_advsimd_unrolling (loop_vec_info loop_vinfo)\n {\n   /* The heuristic only makes sense on targets that have the same\n      vector throughput for SVE and Advanced SIMD.  */\n@@ -14718,7 +14723,7 @@ aarch64_record_potential_advsimd_unrolling (loop_vec_info loop_vinfo,\n \n   /* We only want to apply the heuristic if LOOP_VINFO is being\n      vectorized for SVE.  */\n-  if (!(costs->vec_flags & VEC_ANY_SVE))\n+  if (!(m_vec_flags & VEC_ANY_SVE))\n     return;\n \n   /* Check whether it is possible in principle to use Advanced SIMD\n@@ -14751,17 +14756,14 @@ aarch64_record_potential_advsimd_unrolling (loop_vec_info loop_vinfo,\n \n   /* Record that we're applying the heuristic and should try to estimate\n      the number of statements in the Advanced SIMD loop.  */\n-  costs->unrolled_advsimd_niters = unrolled_advsimd_niters;\n+  m_unrolled_advsimd_niters = unrolled_advsimd_niters;\n }\n \n-/* Do one-time initialization of COSTS given that we're costing the loop\n-   vectorization described by LOOP_VINFO.  */\n-static void\n-aarch64_analyze_loop_vinfo (loop_vec_info loop_vinfo,\n-\t\t\t    aarch64_vector_costs *costs)\n+/* Do one-time initialization of the aarch64_vector_costs given that we're\n+   costing the loop vectorization described by LOOP_VINFO.  */\n+void\n+aarch64_vector_costs::analyze_loop_vinfo (loop_vec_info loop_vinfo)\n {\n-  costs->is_loop = true;\n-\n   /* Record the number of times that the vector loop would execute,\n      if known.  */\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -14770,26 +14772,14 @@ aarch64_analyze_loop_vinfo (loop_vec_info loop_vinfo,\n     {\n       unsigned int vf = vect_vf_for_cost (loop_vinfo);\n       if (LOOP_VINFO_MASKS (loop_vinfo).is_empty ())\n-\tcosts->num_vector_iterations = scalar_niters / vf;\n+\tm_num_vector_iterations = scalar_niters / vf;\n       else\n-\tcosts->num_vector_iterations = CEIL (scalar_niters, vf);\n+\tm_num_vector_iterations = CEIL (scalar_niters, vf);\n     }\n \n-  /* Detect whether we're costing the scalar code or the vector code.\n-     This is a bit hacky: it would be better if the vectorizer told\n-     us directly.\n-\n-     If we're costing the vector code, record whether we're vectorizing\n-     for Advanced SIMD or SVE.  */\n-  if (costs == LOOP_VINFO_TARGET_COST_DATA (loop_vinfo))\n-    costs->vec_flags = aarch64_classify_vector_mode (loop_vinfo->vector_mode);\n-  else\n-    costs->vec_flags = 0;\n-\n-  /* Detect whether we're vectorizing for SVE and should\n-     apply the unrolling heuristic described above\n-     aarch64_vector_costs::unrolled_advsimd_niters.  */\n-  aarch64_record_potential_advsimd_unrolling (loop_vinfo, costs);\n+  /* Detect whether we're vectorizing for SVE and should apply the unrolling\n+     heuristic described above m_unrolled_advsimd_niters.  */\n+  record_potential_advsimd_unrolling (loop_vinfo);\n \n   /* Record the issue information for any SVE WHILE instructions that the\n      loop needs.  */\n@@ -14804,21 +14794,10 @@ aarch64_analyze_loop_vinfo (loop_vec_info loop_vinfo,\n       FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), num_vectors_m1, rgm)\n \tif (rgm->type)\n \t  num_masks += num_vectors_m1 + 1;\n-      costs->sve_ops.pred_ops += num_masks * issue_info->sve->while_pred_ops;\n+      m_sve_ops.pred_ops += num_masks * issue_info->sve->while_pred_ops;\n     }\n }\n \n-/* Do one-time initialization of COSTS given that we're costing the block\n-   vectorization described by BB_VINFO.  */\n-static void\n-aarch64_analyze_bb_vinfo (bb_vec_info bb_vinfo, aarch64_vector_costs *costs)\n-{\n-  /* Unfortunately, there's no easy way of telling whether we're costing\n-     the vector code or the scalar code, so just assume that we're costing\n-     the vector code.  */\n-  costs->vec_flags = aarch64_classify_vector_mode (bb_vinfo->vector_mode);\n-}\n-\n /* Implement targetm.vectorize.builtin_vectorization_cost.  */\n static int\n aarch64_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n@@ -15352,30 +15331,30 @@ aarch64_adjust_stmt_cost (vect_cost_for_stmt kind, stmt_vec_info stmt_info,\n   return stmt_cost;\n }\n \n-/* VINFO, COSTS, COUNT, KIND, STMT_INFO and VECTYPE are the same as for\n+/* COUNT, KIND, STMT_INFO and VECTYPE are the same as for\n    vector_costs::add_stmt_cost and they describe an operation in the\n    body of a vector loop.  Record issue information relating to the vector\n-   operation in OPS, where OPS is one of COSTS->scalar_ops, COSTS->advsimd_ops\n-   or COSTS->sve_ops; see the comments above those variables for details.\n+   operation in OPS, where OPS is one of m_scalar_ops, m_advsimd_ops\n+   or m_sve_ops; see the comments above those variables for details.\n    In addition:\n \n-   - VEC_FLAGS is zero if OPS is COSTS->scalar_ops.\n+   - VEC_FLAGS is zero if OPS is m_scalar_ops.\n \n-   - VEC_FLAGS & VEC_ADVSIMD is nonzero if OPS is COSTS->advsimd_ops.\n+   - VEC_FLAGS & VEC_ADVSIMD is nonzero if OPS is m_advsimd_ops.\n \n-   - VEC_FLAGS & VEC_ANY_SVE is nonzero if OPS is COSTS->sve_ops.\n+   - VEC_FLAGS & VEC_ANY_SVE is nonzero if OPS is m_sve_ops.\n \n    ISSUE_INFO provides the scalar, Advanced SIMD or SVE issue information\n    associated with OPS and VEC_FLAGS.  FACTOR says how many iterations of\n    the loop described by VEC_FLAGS would be needed to match one iteration\n    of the vector loop in VINFO.  */\n-static void\n-aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n-\t\t   unsigned int count, enum vect_cost_for_stmt kind,\n-\t\t   _stmt_vec_info *stmt_info, tree vectype,\n-\t\t   unsigned int vec_flags, aarch64_vec_op_count *ops,\n-\t\t   const aarch64_base_vec_issue_info *issue_info,\n-\t\t   unsigned int factor)\n+void\n+aarch64_vector_costs::count_ops (unsigned int count, vect_cost_for_stmt kind,\n+\t\t\t\t stmt_vec_info stmt_info, tree vectype,\n+\t\t\t\t unsigned int vec_flags,\n+\t\t\t\t aarch64_vec_op_count *ops,\n+\t\t\t\t const aarch64_base_vec_issue_info *issue_info,\n+\t\t\t\t unsigned int factor)\n {\n   if (!issue_info)\n     return;\n@@ -15394,9 +15373,9 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n       && vect_is_reduction (stmt_info))\n     {\n       unsigned int base\n-\t= aarch64_in_loop_reduction_latency (vinfo, stmt_info, vectype,\n+\t= aarch64_in_loop_reduction_latency (m_vinfo, stmt_info, vectype,\n \t\t\t\t\t     vec_flags);\n-      if (vect_reduc_type (vinfo, stmt_info) == FOLD_LEFT_REDUCTION)\n+      if (vect_reduc_type (m_vinfo, stmt_info) == FOLD_LEFT_REDUCTION)\n \t{\n \t  if (aarch64_sve_mode_p (TYPE_MODE (vectype)))\n \t    {\n@@ -15423,7 +15402,7 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n     }\n \n   /* Assume that multiply-adds will become a single operation.  */\n-  if (stmt_info && aarch64_multiply_add_p (vinfo, stmt_info, vec_flags))\n+  if (stmt_info && aarch64_multiply_add_p (m_vinfo, stmt_info, vec_flags))\n     return;\n \n   /* When costing scalar statements in vector code, the count already\n@@ -15473,7 +15452,7 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n \t{\n \t  bool existed = false;\n \t  unsigned int &prev_count\n-\t    = costs->seen_loads.get_or_insert (stmt_info, &existed);\n+\t    = m_seen_loads.get_or_insert (stmt_info, &existed);\n \t  if (existed)\n \t    num_copies -= prev_count;\n \t  else\n@@ -15504,7 +15483,7 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n      have only accounted for one.  */\n   if (vec_flags && (kind == vector_stmt || kind == vec_to_scalar))\n     {\n-      int reduc_type = vect_reduc_type (vinfo, stmt_info);\n+      int reduc_type = vect_reduc_type (m_vinfo, stmt_info);\n       if ((reduc_type == EXTRACT_LAST_REDUCTION && (vec_flags & VEC_ADVSIMD))\n \t  || reduc_type == COND_REDUCTION)\n \tops->general_ops += num_copies;\n@@ -15517,7 +15496,7 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n \tunsigned int base = (FLOAT_TYPE_P (type)\n \t\t\t     ? sve_issue->fp_cmp_pred_ops\n \t\t\t     : sve_issue->int_cmp_pred_ops);\n-\tcosts->sve_ops.pred_ops += base * num_copies;\n+\tm_sve_ops.pred_ops += base * num_copies;\n       }\n \n   /* Add any extra overhead associated with LD[234] and ST[234] operations.  */\n@@ -15543,8 +15522,7 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n       && STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) == VMAT_GATHER_SCATTER)\n     {\n       unsigned int pairs = CEIL (count, 2);\n-      costs->sve_ops.pred_ops\n-\t+= sve_issue->gather_scatter_pair_pred_ops * pairs;\n+      m_sve_ops.pred_ops += sve_issue->gather_scatter_pair_pred_ops * pairs;\n       ops->general_ops += sve_issue->gather_scatter_pair_general_ops * pairs;\n     }\n }\n@@ -15564,33 +15542,36 @@ aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n \n   /* Do one-time initialization based on the vinfo.  */\n   loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (m_vinfo);\n-  bb_vec_info bb_vinfo = dyn_cast<bb_vec_info> (m_vinfo);\n-  if (!analyzed_vinfo && aarch64_use_new_vector_costs_p ())\n+  if (!m_analyzed_vinfo && aarch64_use_new_vector_costs_p ())\n     {\n+      /* If we're costing the vector code, record whether we're vectorizing\n+\t for Advanced SIMD or SVE.  */\n+      if (!m_costing_for_scalar)\n+\tm_vec_flags = aarch64_classify_vector_mode (m_vinfo->vector_mode);\n+\n       if (loop_vinfo)\n-\taarch64_analyze_loop_vinfo (loop_vinfo, this);\n-      else\n-\taarch64_analyze_bb_vinfo (bb_vinfo, this);\n-      this->analyzed_vinfo = true;\n+\tanalyze_loop_vinfo (loop_vinfo);\n+\n+      m_analyzed_vinfo = true;\n     }\n \n   /* Try to get a more accurate cost by looking at STMT_INFO instead\n      of just looking at KIND.  */\n   if (stmt_info && aarch64_use_new_vector_costs_p ())\n     {\n       if (vectype && aarch64_sve_only_stmt_p (stmt_info, vectype))\n-\tthis->saw_sve_only_op = true;\n+\tm_saw_sve_only_op = true;\n \n       /* If we scalarize a strided store, the vectorizer costs one\n \t vec_to_scalar for each element.  However, we can store the first\n \t element using an FP store without a separate extract step.  */\n       if (vect_is_store_elt_extraction (kind, stmt_info))\n \tcount -= 1;\n \n-      stmt_cost = aarch64_detect_scalar_stmt_subtype\n-\t(m_vinfo, kind, stmt_info, stmt_cost);\n+      stmt_cost = aarch64_detect_scalar_stmt_subtype (m_vinfo, kind,\n+\t\t\t\t\t\t      stmt_info, stmt_cost);\n \n-      if (vectype && this->vec_flags)\n+      if (vectype && m_vec_flags)\n \tstmt_cost = aarch64_detect_vector_stmt_subtype (m_vinfo, kind,\n \t\t\t\t\t\t\tstmt_info, vectype,\n \t\t\t\t\t\t\twhere, stmt_cost);\n@@ -15614,47 +15595,42 @@ aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n       auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n       if (loop_vinfo\n \t  && issue_info\n-\t  && this->vec_flags\n+\t  && m_vec_flags\n \t  && where == vect_body\n \t  && (!LOOP_VINFO_LOOP (loop_vinfo)->inner || in_inner_loop_p)\n \t  && vectype\n \t  && stmt_cost != 0)\n \t{\n \t  /* Record estimates for the scalar code.  */\n-\t  aarch64_count_ops (m_vinfo, this, count, kind, stmt_info, vectype,\n-\t\t\t     0, &this->scalar_ops, issue_info->scalar,\n-\t\t\t     vect_nunits_for_cost (vectype));\n+\t  count_ops (count, kind, stmt_info, vectype, 0, &m_scalar_ops,\n+\t\t     issue_info->scalar, vect_nunits_for_cost (vectype));\n \n \t  if (aarch64_sve_mode_p (m_vinfo->vector_mode) && issue_info->sve)\n \t    {\n \t      /* Record estimates for a possible Advanced SIMD version\n \t\t of the SVE code.  */\n-\t      aarch64_count_ops (m_vinfo, this, count, kind, stmt_info,\n-\t\t\t\t vectype, VEC_ADVSIMD, &this->advsimd_ops,\n-\t\t\t\t issue_info->advsimd,\n-\t\t\t\t aarch64_estimated_sve_vq ());\n+\t      count_ops (count, kind, stmt_info, vectype, VEC_ADVSIMD,\n+\t\t\t &m_advsimd_ops, issue_info->advsimd,\n+\t\t\t aarch64_estimated_sve_vq ());\n \n \t      /* Record estimates for the SVE code itself.  */\n-\t      aarch64_count_ops (m_vinfo, this, count, kind, stmt_info,\n-\t\t\t\t vectype, VEC_ANY_SVE, &this->sve_ops,\n-\t\t\t\t issue_info->sve, 1);\n+\t      count_ops (count, kind, stmt_info, vectype, VEC_ANY_SVE,\n+\t\t\t &m_sve_ops, issue_info->sve, 1);\n \t    }\n \t  else\n \t    /* Record estimates for the Advanced SIMD code.  Treat SVE like\n \t       Advanced SIMD if the CPU has no specific SVE costs.  */\n-\t    aarch64_count_ops (m_vinfo, this, count, kind, stmt_info,\n-\t\t\t       vectype, VEC_ADVSIMD, &this->advsimd_ops,\n-\t\t\t       issue_info->advsimd, 1);\n+\t    count_ops (count, kind, stmt_info, vectype, VEC_ADVSIMD,\n+\t\t       &m_advsimd_ops, issue_info->advsimd, 1);\n \t}\n \n       /* If we're applying the SVE vs. Advanced SIMD unrolling heuristic,\n \t estimate the number of statements in the unrolled Advanced SIMD\n \t loop.  For simplicitly, we assume that one iteration of the\n \t Advanced SIMD loop would need the same number of statements\n \t as one iteration of the SVE loop.  */\n-      if (where == vect_body && this->unrolled_advsimd_niters)\n-\tthis->unrolled_advsimd_stmts\n-\t  += count * this->unrolled_advsimd_niters;\n+      if (where == vect_body && m_unrolled_advsimd_niters)\n+\tm_unrolled_advsimd_stmts += count * m_unrolled_advsimd_niters;\n     }\n   return record_stmt_cost (stmt_info, where, (count * stmt_cost).ceil ());\n }\n@@ -15698,32 +15674,28 @@ aarch64_estimate_min_cycles_per_iter\n   return cycles;\n }\n \n-/* Subroutine of aarch64_adjust_body_cost for handling SVE.\n-   Use ISSUE_INFO to work out how fast the SVE code can be issued and compare\n-   it to the equivalent value for scalar code (SCALAR_CYCLES_PER_ITER).\n-   If COULD_USE_ADVSIMD is true, also compare it to the issue rate of\n-   Advanced SIMD code (ADVSIMD_CYCLES_PER_ITER).\n+/* Subroutine of adjust_body_cost for handling SVE.  Use ISSUE_INFO to work out\n+   how fast the SVE code can be issued and compare it to the equivalent value\n+   for scalar code (SCALAR_CYCLES_PER_ITER).  If COULD_USE_ADVSIMD is true,\n+   also compare it to the issue rate of Advanced SIMD code\n+   (ADVSIMD_CYCLES_PER_ITER).\n \n-   COSTS is as for aarch64_adjust_body_cost.  ORIG_BODY_COST is the cost\n-   originally passed to aarch64_adjust_body_cost and *BODY_COST is the current\n-   value of the adjusted cost.  *SHOULD_DISPARAGE is true if we think the loop\n-   body is too expensive.  */\n+   ORIG_BODY_COST is the cost originally passed to adjust_body_cost and\n+   *BODY_COST is the current value of the adjusted cost.  *SHOULD_DISPARAGE\n+   is true if we think the loop body is too expensive.  */\n \n-static fractional_cost\n-aarch64_adjust_body_cost_sve (const aarch64_vector_costs *costs,\n-\t\t\t      const aarch64_vec_issue_info *issue_info,\n-\t\t\t      fractional_cost scalar_cycles_per_iter,\n-\t\t\t      fractional_cost advsimd_cycles_per_iter,\n-\t\t\t      bool could_use_advsimd,\n-\t\t\t      unsigned int orig_body_cost,\n-\t\t\t      unsigned int *body_cost,\n-\t\t\t      bool *should_disparage)\n+fractional_cost\n+aarch64_vector_costs::\n+adjust_body_cost_sve (const aarch64_vec_issue_info *issue_info,\n+\t\t      fractional_cost scalar_cycles_per_iter,\n+\t\t      fractional_cost advsimd_cycles_per_iter,\n+\t\t      bool could_use_advsimd, unsigned int orig_body_cost,\n+\t\t      unsigned int *body_cost, bool *should_disparage)\n {\n   /* Estimate the minimum number of cycles per iteration needed to issue\n      non-predicate operations.  */\n   fractional_cost sve_nonpred_issue_cycles_per_iter\n-    = aarch64_estimate_min_cycles_per_iter (&costs->sve_ops,\n-\t\t\t\t\t    issue_info->sve);\n+    = aarch64_estimate_min_cycles_per_iter (&m_sve_ops, issue_info->sve);\n \n   /* Estimate the minimum number of cycles per iteration needed to rename\n      SVE instructions.\n@@ -15739,9 +15711,9 @@ aarch64_adjust_body_cost_sve (const aarch64_vector_costs *costs,\n        ??? This value is very much on the pessimistic side, but seems to work\n        pretty well in practice.  */\n     sve_rename_cycles_per_iter\n-      = { costs->sve_ops.general_ops\n-\t  + costs->sve_ops.loads\n-\t  + costs->sve_ops.pred_ops + 1, 5 };\n+      = { m_sve_ops.general_ops\n+\t  + m_sve_ops.loads\n+\t  + m_sve_ops.pred_ops + 1, 5 };\n \n   /* Combine the rename and non-predicate issue limits into a single value.  */\n   fractional_cost sve_nonpred_cycles_per_iter\n@@ -15750,23 +15722,23 @@ aarch64_adjust_body_cost_sve (const aarch64_vector_costs *costs,\n   /* Separately estimate the minimum number of cycles per iteration needed\n      to issue the predicate operations.  */\n   fractional_cost sve_pred_issue_cycles_per_iter\n-    = { costs->sve_ops.pred_ops, issue_info->sve->pred_ops_per_cycle };\n+    = { m_sve_ops.pred_ops, issue_info->sve->pred_ops_per_cycle };\n \n   /* Calculate the overall limit on the number of cycles per iteration.  */\n   fractional_cost sve_cycles_per_iter\n     = std::max (sve_nonpred_cycles_per_iter, sve_pred_issue_cycles_per_iter);\n \n   if (dump_enabled_p ())\n     {\n-      costs->sve_ops.dump ();\n+      m_sve_ops.dump ();\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"  estimated cycles per iteration = %f\\n\",\n \t\t       sve_cycles_per_iter.as_double ());\n-      if (costs->sve_ops.pred_ops)\n+      if (m_sve_ops.pred_ops)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"    predicate issue = %f\\n\",\n \t\t\t sve_pred_issue_cycles_per_iter.as_double ());\n-      if (costs->sve_ops.pred_ops || sve_rename_cycles_per_iter)\n+      if (m_sve_ops.pred_ops || sve_rename_cycles_per_iter)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"    non-predicate issue = %f\\n\",\n \t\t\t sve_nonpred_issue_cycles_per_iter.as_double ());\n@@ -15843,10 +15815,10 @@ aarch64_adjust_body_cost_sve (const aarch64_vector_costs *costs,\n   return sve_cycles_per_iter;\n }\n \n-/* BODY_COST is the cost of a vector loop body recorded in COSTS.\n-   Adjust the cost as necessary and return the new cost.  */\n-static unsigned int\n-aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n+/* BODY_COST is the cost of a vector loop body.  Adjust the cost as necessary\n+   and return the new cost.  */\n+unsigned int\n+aarch64_vector_costs::adjust_body_cost (unsigned int body_cost)\n {\n   unsigned int orig_body_cost = body_cost;\n   bool should_disparage = false;\n@@ -15855,24 +15827,24 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"Original vector body cost = %d\\n\", body_cost);\n \n-  if (costs->unrolled_advsimd_stmts)\n+  if (m_unrolled_advsimd_stmts)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"Number of insns in\"\n \t\t\t \" unrolled Advanced SIMD loop = %d\\n\",\n-\t\t\t costs->unrolled_advsimd_stmts);\n+\t\t\t m_unrolled_advsimd_stmts);\n \n       /* Apply the Advanced SIMD vs. SVE unrolling heuristic described above\n-\t aarch64_vector_costs::unrolled_advsimd_niters.\n+\t m_unrolled_advsimd_niters.\n \n \t The balance here is tricky.  On the one hand, we can't be sure whether\n \t the code is vectorizable with Advanced SIMD or not.  However, even if\n \t it isn't vectorizable with Advanced SIMD, there's a possibility that\n \t the scalar code could also be unrolled.  Some of the code might then\n \t benefit from SLP, or from using LDP and STP.  We therefore apply\n \t the heuristic regardless of can_use_advsimd_p.  */\n-      if (costs->unrolled_advsimd_stmts\n-\t  && (costs->unrolled_advsimd_stmts\n+      if (m_unrolled_advsimd_stmts\n+\t  && (m_unrolled_advsimd_stmts\n \t      <= (unsigned int) param_max_completely_peeled_insns))\n \t{\n \t  unsigned int estimated_vq = aarch64_estimated_sve_vq ();\n@@ -15894,36 +15866,36 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n     return body_cost;\n \n   fractional_cost scalar_cycles_per_iter\n-    = aarch64_estimate_min_cycles_per_iter (&costs->scalar_ops,\n+    = aarch64_estimate_min_cycles_per_iter (&m_scalar_ops,\n \t\t\t\t\t    issue_info->scalar);\n \n   fractional_cost advsimd_cycles_per_iter\n-    = aarch64_estimate_min_cycles_per_iter (&costs->advsimd_ops,\n+    = aarch64_estimate_min_cycles_per_iter (&m_advsimd_ops,\n \t\t\t\t\t    issue_info->advsimd);\n \n   bool could_use_advsimd\n-    = ((costs->vec_flags & VEC_ADVSIMD)\n+    = ((m_vec_flags & VEC_ADVSIMD)\n        || (aarch64_autovec_preference != 2\n \t   && (aarch64_tune_params.extra_tuning_flags\n \t       & AARCH64_EXTRA_TUNE_MATCHED_VECTOR_THROUGHPUT)\n-\t   && !costs->saw_sve_only_op));\n+\t   && !m_saw_sve_only_op));\n \n   if (dump_enabled_p ())\n     {\n-      if (IN_RANGE (costs->num_vector_iterations, 0, 65536))\n+      if (IN_RANGE (m_num_vector_iterations, 0, 65536))\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Vector loop iterates at most %wd times\\n\",\n-\t\t\t costs->num_vector_iterations);\n+\t\t\t m_num_vector_iterations);\n       dump_printf_loc (MSG_NOTE, vect_location, \"Scalar issue estimate:\\n\");\n-      costs->scalar_ops.dump ();\n+      m_scalar_ops.dump ();\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"  estimated cycles per iteration = %f\\n\",\n \t\t       scalar_cycles_per_iter.as_double ());\n       if (could_use_advsimd)\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Advanced SIMD issue estimate:\\n\");\n-\t  costs->advsimd_ops.dump ();\n+\t  m_advsimd_ops.dump ();\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"  estimated cycles per iteration = %f\\n\",\n \t\t\t   advsimd_cycles_per_iter.as_double ());\n@@ -15934,19 +15906,17 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n     }\n \n   fractional_cost vector_cycles_per_iter = advsimd_cycles_per_iter;\n-  unsigned int vector_reduction_latency = costs->advsimd_ops.reduction_latency;\n+  unsigned int vector_reduction_latency = m_advsimd_ops.reduction_latency;\n \n-  if ((costs->vec_flags & VEC_ANY_SVE) && issue_info->sve)\n+  if ((m_vec_flags & VEC_ANY_SVE) && issue_info->sve)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"SVE issue estimate:\\n\");\n-      vector_reduction_latency = costs->sve_ops.reduction_latency;\n+      vector_reduction_latency = m_sve_ops.reduction_latency;\n       vector_cycles_per_iter\n-\t= aarch64_adjust_body_cost_sve (costs, issue_info,\n-\t\t\t\t\tscalar_cycles_per_iter,\n-\t\t\t\t\tadvsimd_cycles_per_iter,\n-\t\t\t\t\tcould_use_advsimd, orig_body_cost,\n-\t\t\t\t\t&body_cost, &should_disparage);\n+\t= adjust_body_cost_sve (issue_info, scalar_cycles_per_iter,\n+\t\t\t\tadvsimd_cycles_per_iter, could_use_advsimd,\n+\t\t\t\torig_body_cost, &body_cost, &should_disparage);\n \n       if (aarch64_tune_params.vec_costs == &neoverse512tvb_vector_cost)\n \t{\n@@ -15956,22 +15926,22 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Neoverse V1 estimate:\\n\");\n-\t  aarch64_adjust_body_cost_sve (costs, &neoversev1_vec_issue_info,\n-\t\t\t\t\tscalar_cycles_per_iter * 2,\n-\t\t\t\t\tadvsimd_cycles_per_iter * 2,\n-\t\t\t\t\tcould_use_advsimd, orig_body_cost,\n-\t\t\t\t\t&body_cost, &should_disparage);\n+\t  adjust_body_cost_sve (&neoversev1_vec_issue_info,\n+\t\t\t\tscalar_cycles_per_iter * 2,\n+\t\t\t\tadvsimd_cycles_per_iter * 2,\n+\t\t\t\tcould_use_advsimd, orig_body_cost,\n+\t\t\t\t&body_cost, &should_disparage);\n \t}\n     }\n \n   /* Decide whether to stick to latency-based costs or whether to try to\n      take issue rates into account.  */\n   unsigned int threshold = aarch64_loop_vect_issue_rate_niters;\n-  if (costs->vec_flags & VEC_ANY_SVE)\n+  if (m_vec_flags & VEC_ANY_SVE)\n     threshold = CEIL (threshold, aarch64_estimated_sve_vq ());\n \n-  if (costs->num_vector_iterations >= 1\n-      && costs->num_vector_iterations < threshold)\n+  if (m_num_vector_iterations >= 1\n+      && m_num_vector_iterations < threshold)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n@@ -16004,8 +15974,8 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n      vector code is an improvement, even if adding the other (non-loop-carried)\n      latencies tends to hide this saving.  We therefore reduce the cost of the\n      vector loop body in proportion to the saving.  */\n-  else if (costs->scalar_ops.reduction_latency > vector_reduction_latency\n-\t   && costs->scalar_ops.reduction_latency == scalar_cycles_per_iter\n+  else if (m_scalar_ops.reduction_latency > vector_reduction_latency\n+\t   && m_scalar_ops.reduction_latency == scalar_cycles_per_iter\n \t   && scalar_cycles_per_iter > vector_cycles_per_iter\n \t   && !should_disparage)\n     {\n@@ -16023,10 +15993,11 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n void\n aarch64_vector_costs::finish_cost ()\n {\n-  if (this->is_loop\n-      && this->vec_flags\n+  loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (m_vinfo);\n+  if (loop_vinfo\n+      && m_vec_flags\n       && aarch64_use_new_vector_costs_p ())\n-    m_costs[vect_body] = aarch64_adjust_body_cost (this, m_costs[vect_body]);\n+    m_costs[vect_body] = adjust_body_cost (m_costs[vect_body]);\n \n   vector_costs::finish_cost ();\n }"}]}