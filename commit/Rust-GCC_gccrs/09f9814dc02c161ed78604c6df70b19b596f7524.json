{"sha": "09f9814dc02c161ed78604c6df70b19b596f7524", "node_id": "C_kwDOANBUbNoAKDA5Zjk4MTRkYzAyYzE2MWVkNzg2MDRjNmRmNzBiMTliNTk2Zjc1MjQ", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-21T07:45:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-21T09:16:33Z"}, "message": "tree-optimization/107323 - loop distribution partition ordering issue\n\nThe following reverts part of the PR94125 fix which causes us to\nuse a bogus partition ordering after applying versioning for\nalias to the testcase in PR107323.  Instead PR94125 is fixed by\nappropriately considering to be merged SCCs when skipping edges\nwe want to ignore because of the alias versioning.\n\n\tPR tree-optimization/107323\n\t* tree-loop-distribution.cc (pg_unmark_merged_alias_ddrs):\n\tNew function.\n\t(loop_distribution::break_alias_scc_partitions): Revert\n\tpostorder save/restore from the PR94125 fix.  Instead\n\tmake sure to not ignore edges from SCCs we are going to\n\tmerge.\n\n\t* gcc.dg/tree-ssa/pr107323.c: New testcase.", "tree": {"sha": "55b12e33a3aa2b4d4646cb45244ed2cfc392efee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55b12e33a3aa2b4d4646cb45244ed2cfc392efee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09f9814dc02c161ed78604c6df70b19b596f7524", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09f9814dc02c161ed78604c6df70b19b596f7524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09f9814dc02c161ed78604c6df70b19b596f7524", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09f9814dc02c161ed78604c6df70b19b596f7524/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdac4b47cbdac52c7082c02f54ed07197161cb4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdac4b47cbdac52c7082c02f54ed07197161cb4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdac4b47cbdac52c7082c02f54ed07197161cb4d"}], "stats": {"total": 78, "additions": 64, "deletions": 14}, "files": [{"sha": "1204b6e36d5526be590c84c52514a740ed2480e4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr107323.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09f9814dc02c161ed78604c6df70b19b596f7524/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107323.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09f9814dc02c161ed78604c6df70b19b596f7524/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107323.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107323.c?ref=09f9814dc02c161ed78604c6df70b19b596f7524", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-tree-vectorize\" } */\n+\n+int A[4];\n+int B[4];\n+\n+static const char *__attribute__((noipa)) foo()\n+{\n+  return \"1\";\n+}\n+\n+int main()\n+{\n+  const char *s = foo();\n+\n+  A[0] = 1000;\n+  for(int i = 1; i < 4; ++i) {\n+      B[i] = 0;\n+      A[i] = 0;\n+      if(s[0])\n+\tB[i] = 1;\n+      A[i] = A[i - 1];\n+  }\n+\n+  if (A[3] != 1000)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "ed3dd73e1a9645c2a88293366fdea4275957a739", "filename": "gcc/tree-loop-distribution.cc", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09f9814dc02c161ed78604c6df70b19b596f7524/gcc%2Ftree-loop-distribution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09f9814dc02c161ed78604c6df70b19b596f7524/gcc%2Ftree-loop-distribution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.cc?ref=09f9814dc02c161ed78604c6df70b19b596f7524", "patch": "@@ -2201,8 +2201,6 @@ struct pg_edge_callback_data\n   bitmap sccs_to_merge;\n   /* Array constains component information for all vertices.  */\n   int *vertices_component;\n-  /* Array constains postorder information for all vertices.  */\n-  int *vertices_post;\n   /* Vector to record all data dependence relations which are needed\n      to break strong connected components by runtime alias checks.  */\n   vec<ddr_p> *alias_ddrs;\n@@ -2452,6 +2450,33 @@ pg_collect_alias_ddrs (struct graph *g, struct graph_edge *e, void *data)\n     cbdata->alias_ddrs->safe_splice (edata->alias_ddrs);\n }\n \n+/* Callback function for traversing edge E.  DATA is private\n+   callback data.  */\n+\n+static void\n+pg_unmark_merged_alias_ddrs (struct graph *, struct graph_edge *e, void *data)\n+{\n+  int i, j, component;\n+  struct pg_edge_callback_data *cbdata;\n+  struct pg_edata *edata = (struct pg_edata *) e->data;\n+\n+  if (edata == NULL || edata->alias_ddrs.length () == 0)\n+    return;\n+\n+  cbdata = (struct pg_edge_callback_data *) data;\n+  i = e->src;\n+  j = e->dest;\n+  component = cbdata->vertices_component[i];\n+  /* Make sure to not skip vertices inside SCCs we are going to merge.  */\n+  if (component == cbdata->vertices_component[j]\n+      && bitmap_bit_p (cbdata->sccs_to_merge, component))\n+    {\n+      edata->alias_ddrs.release ();\n+      delete edata;\n+      e->data = NULL;\n+    }\n+}\n+\n /* This is the main function breaking strong conected components in\n    PARTITIONS giving reduced depdendence graph RDG.  Store data dependence\n    relations for runtime alias check in ALIAS_DDRS.  */\n@@ -2511,7 +2536,6 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n       cbdata.sccs_to_merge = sccs_to_merge;\n       cbdata.alias_ddrs = alias_ddrs;\n       cbdata.vertices_component = XNEWVEC (int, pg->n_vertices);\n-      cbdata.vertices_post = XNEWVEC (int, pg->n_vertices);\n       /* Record the component information which will be corrupted by next\n \t graph scc finding call.  */\n       for (i = 0; i < pg->n_vertices; ++i)\n@@ -2520,17 +2544,18 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n       /* Collect data dependences for runtime alias checks to break SCCs.  */\n       if (bitmap_count_bits (sccs_to_merge) != (unsigned) num_sccs)\n \t{\n-\t  /* Record the postorder information which will be corrupted by next\n-\t     graph SCC finding call.  */\n-\t  for (i = 0; i < pg->n_vertices; ++i)\n-\t    cbdata.vertices_post[i] = pg->vertices[i].post;\n+\t  /* For SCCs we want to merge clear all alias_ddrs for edges\n+\t     inside the component.  */\n+\t  for_each_edge (pg, pg_unmark_merged_alias_ddrs, &cbdata);\n \n \t  /* Run SCC finding algorithm again, with alias dependence edges\n \t     skipped.  This is to topologically sort partitions according to\n \t     compilation time known dependence.  Note the topological order\n \t     is stored in the form of pg's post order number.  */\n \t  num_sccs_no_alias = graphds_scc (pg, NULL, pg_skip_alias_edge);\n-\t  gcc_assert (partitions->length () == (unsigned) num_sccs_no_alias);\n+\t  /* We cannot assert partitions->length () == num_sccs_no_alias\n+\t     since we are not ignoring alias edges in cycles we are\n+\t     going to merge.  That's required to compute correct postorder.  */\n \t  /* With topological order, we can construct two subgraphs L and R.\n \t     L contains edge <x, y> where x < y in terms of post order, while\n \t     R contains edge <x, y> where x > y.  Edges for compilation time\n@@ -2565,16 +2590,14 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n \t      first->type = PTYPE_SEQUENTIAL;\n \t    }\n \t}\n-      /* Restore the postorder information if it's corrupted in finding SCC\n-\t with alias dependence edges skipped.  If reduction partition's SCC is\n-\t broken by runtime alias checks, we force a negative post order to it\n-\t making sure it will be scheduled in the last.  */\n+      /* If reduction partition's SCC is broken by runtime alias checks,\n+\t we force a negative post order to it making sure it will be scheduled\n+\t in the last.  */\n       if (num_sccs_no_alias > 0)\n \t{\n \t  j = -1;\n \t  for (i = 0; i < pg->n_vertices; ++i)\n \t    {\n-\t      pg->vertices[i].post = cbdata.vertices_post[i];\n \t      struct pg_vdata *data = (struct pg_vdata *)pg->vertices[i].data;\n \t      if (data->partition && partition_reduction_p (data->partition))\n \t\t{\n@@ -2587,7 +2610,6 @@ loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n \t}\n \n       free (cbdata.vertices_component);\n-      free (cbdata.vertices_post);\n     }\n \n   sort_partitions_by_post_order (pg, partitions);"}]}