{"sha": "4ea60a393eee13a0a7715b7c8134e2115195c7f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVhNjBhMzkzZWVlMTNhMGE3NzE1YjdjODEzNGUyMTE1MTk1YzdmNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-03-09T19:21:24Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-03-09T19:21:24Z"}, "message": "re PR fortran/71544 (gfortran compiler optimization bug when dealing with c-style pointers)\n\n2019-03-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/71544\n\t* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of\n\tC_PTR and C_FUNPTR.\n\t(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.\n\n2019-03-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/71544\n\t* gfortran.dg/c_ptr_tests_19.f90: New test.\n\nFrom-SVN: r269532", "tree": {"sha": "39dbc71728cc53f1784eefc084ab8babbe7b8f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39dbc71728cc53f1784eefc084ab8babbe7b8f94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ea60a393eee13a0a7715b7c8134e2115195c7f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea60a393eee13a0a7715b7c8134e2115195c7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ea60a393eee13a0a7715b7c8134e2115195c7f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ea60a393eee13a0a7715b7c8134e2115195c7f7/comments", "author": null, "committer": null, "parents": [{"sha": "e6780631b13612b88b1ada69ca2e736f8a16da87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6780631b13612b88b1ada69ca2e736f8a16da87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6780631b13612b88b1ada69ca2e736f8a16da87"}], "stats": {"total": 54, "additions": 52, "deletions": 2}, "files": [{"sha": "785c7313eda3cb3f08e52b0493ff46bf0f227ba0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4ea60a393eee13a0a7715b7c8134e2115195c7f7", "patch": "@@ -1,3 +1,10 @@\n+2019-03-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/71544\n+\t* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of\n+\tC_PTR and C_FUNPTR.\n+\t(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.\n+\n 2019-03-09  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/84504"}, {"sha": "9ae516bb666417cab0a2c4537d679955c37e82ab", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=4ea60a393eee13a0a7715b7c8134e2115195c7f7", "patch": "@@ -1176,7 +1176,8 @@ gfc_typenode_for_spec (gfc_typespec * spec, int codim)\n         {\n           spec->type = BT_INTEGER;\n           spec->kind = gfc_index_integer_kind;\n-          spec->f90_type = BT_VOID;\n+\t  spec->f90_type = BT_VOID;\n+\t  spec->is_c_interop = 1;  /* Mark as escaping later.  */\n         }\n       break;\n     case BT_VOID:\n@@ -2957,7 +2958,8 @@ create_fn_spec (gfc_symbol *sym, tree fntype)\n \t\t    || f->sym->ts.u.derived->attr.pointer_comp))\n \t    || (f->sym->ts.type == BT_CLASS\n \t\t&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp\n-\t\t    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp)))\n+\t\t    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))\n+\t    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))\n \t  spec[spec_len++] = '.';\n \telse if (f->sym->attr.intent == INTENT_IN)\n \t  spec[spec_len++] = 'r';"}, {"sha": "b1714e4410959b349aaea94ea36be85811fe5611", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ea60a393eee13a0a7715b7c8134e2115195c7f7", "patch": "@@ -1,3 +1,8 @@\n+2019-03-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/71544\n+\t* gfortran.dg/c_ptr_tests_19.f90: New test.\n+\n 2019-03-09  John David Anglin  <dave.anglin@bell.net>\n \n \t* gnat.dg/debug11.adb: Skip on 32-bit hppa*-*-hpux*."}, {"sha": "2cb0b183c88ae460ebf0df22e261040549a50377", "filename": "gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ea60a393eee13a0a7715b7c8134e2115195c7f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_ptr_tests_19.f90?ref=4ea60a393eee13a0a7715b7c8134e2115195c7f7", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+\n+! PR 71544 - this failed with some optimization options due to a\n+! pointer not being marked as escaping.\n+\n+module store_cptr\n+    use, intrinsic :: iso_c_binding\n+    implicit none\n+    public\n+    type(c_ptr), save :: cptr\n+end module store_cptr\n+\n+subroutine init()\n+    use, intrinsic :: iso_c_binding\n+    implicit none\n+    integer(c_int), pointer :: a\n+    allocate(a)\n+    call save_cptr(c_loc(a))\n+    a = 100\n+end subroutine init\n+\n+subroutine save_cptr(cptr_in)\n+    use store_cptr\n+    implicit none\n+    type(c_ptr), intent(in) :: cptr_in\n+    cptr = cptr_in\n+end subroutine save_cptr\n+\n+program init_fails\n+    use store_cptr\n+    implicit none\n+    integer(c_int), pointer :: val\n+    call init()\n+    call c_f_pointer(cptr,val)\n+    if (val /= 100) stop 1\n+end program init_fails"}]}