{"sha": "4bdf739f835520ccbc433dc9eac461895741f317", "node_id": "C_kwDOANBUbNoAKDRiZGY3MzlmODM1NTIwY2NiYzQzM2RjOWVhYzQ2MTg5NTc0MWYzMTc", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-22T07:40:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-22T10:51:52Z"}, "message": "tree-optimization/99407 - DSE with data-ref analysis\n\nThe following resolves the issue that DSE cannot handle references\nwith variable offsets well when identifying possible uses of a store.\nInstead of just relying on ref_maybe_used_by_stmt_p we use data-ref\nanalysis, making sure to perform that at most once per stmt.  The\nnew mode is only exercised by the DSE pass before loop optimization\nas specified by a new pass parameter and when expensive optimizations\nare enabled, so it's disabled below -O2.\n\n\tPR tree-optimization/99407\n\t* tree-ssa-dse.cc (dse_stmt_to_dr_map): New global.\n\t(dse_classify_store): Use data-ref analysis to disambiguate more uses.\n\t(pass_dse::use_dr_analysis_p): New pass parameter.\n\t(pass_dse::set_pass_param): Implement.\n\t(pass_dse::execute): Allocate and deallocate dse_stmt_to_dr_map.\n\t* passes.def: Allow DR analysis for the DSE pass before loop.\n\n\t* gcc.dg/vect/tsvc/vect-tsvc-s243.c: Remove XFAIL.", "tree": {"sha": "9b9c4d63e6b02c118ab1e9d17ef97f767cf3b922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b9c4d63e6b02c118ab1e9d17ef97f767cf3b922"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bdf739f835520ccbc433dc9eac461895741f317", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdf739f835520ccbc433dc9eac461895741f317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdf739f835520ccbc433dc9eac461895741f317", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdf739f835520ccbc433dc9eac461895741f317/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41c7d2930a75eda3350956b6d9df9e571f9b494d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c7d2930a75eda3350956b6d9df9e571f9b494d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c7d2930a75eda3350956b6d9df9e571f9b494d"}], "stats": {"total": 55, "additions": 52, "deletions": 3}, "files": [{"sha": "939ec3e29c86dfab7cfbb710420940e3d97a2fd0", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdf739f835520ccbc433dc9eac461895741f317/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdf739f835520ccbc433dc9eac461895741f317/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=4bdf739f835520ccbc433dc9eac461895741f317", "patch": "@@ -263,7 +263,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_sancov);\n       NEXT_PASS (pass_asan);\n       NEXT_PASS (pass_tsan);\n-      NEXT_PASS (pass_dse);\n+      NEXT_PASS (pass_dse, true /* use DR analysis */);\n       NEXT_PASS (pass_dce);\n       /* Pass group that runs when 1) enabled, 2) there are loops\n \t in the function.  Make sure to run pass_fix_loops before"}, {"sha": "6eb0240da406b89179b3e2a5618c655ff73a2025", "filename": "gcc/testsuite/gcc.dg/vect/tsvc/vect-tsvc-s243.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdf739f835520ccbc433dc9eac461895741f317/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s243.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdf739f835520ccbc433dc9eac461895741f317/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s243.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Ftsvc%2Fvect-tsvc-s243.c?ref=4bdf739f835520ccbc433dc9eac461895741f317", "patch": "@@ -38,4 +38,4 @@ int main (int argc, char **argv)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "2411ac711ded5983c5a090cdf000d1263f325eee", "filename": "gcc/tree-ssa-dse.cc", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdf739f835520ccbc433dc9eac461895741f317/gcc%2Ftree-ssa-dse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdf739f835520ccbc433dc9eac461895741f317/gcc%2Ftree-ssa-dse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.cc?ref=4bdf739f835520ccbc433dc9eac461895741f317", "patch": "@@ -18,6 +18,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n@@ -45,6 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-modref.h\"\n #include \"target.h\"\n #include \"tree-ssa-loop-niter.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-data-ref.h\"\n \n /* This file implements dead store elimination.\n \n@@ -937,6 +940,10 @@ contains_phi_arg (gphi *phi, tree arg)\n   return false;\n }\n \n+/* Hash map of the memory use in a GIMPLE assignment to its\n+   data reference.  If NULL data-ref analysis isn't used.  */\n+static hash_map<gimple *, data_reference_p> *dse_stmt_to_dr_map;\n+\n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_ASSIGN in STMT that writes to REF, classify it\n    according to downstream uses and defs.  Sets *BY_CLOBBER_P to true\n@@ -951,6 +958,8 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n   gimple *temp;\n   int cnt = 0;\n   auto_bitmap visited;\n+  std::unique_ptr<data_reference, void(*)(data_reference_p)>\n+    dra (nullptr, free_data_ref);\n \n   if (by_clobber_p)\n     *by_clobber_p = true;\n@@ -1019,6 +1028,28 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n \t  /* If the statement is a use the store is not dead.  */\n \t  else if (ref_maybe_used_by_stmt_p (use_stmt, ref))\n \t    {\n+\t      if (dse_stmt_to_dr_map\n+\t\t  && ref->ref\n+\t\t  && is_gimple_assign (use_stmt))\n+\t\t{\n+\t\t  if (!dra)\n+\t\t    dra.reset (create_data_ref (NULL, NULL, ref->ref, stmt,\n+\t\t\t\t\t\tfalse, false));\n+\t\t  bool existed_p;\n+\t\t  data_reference_p &drb\n+\t\t    = dse_stmt_to_dr_map->get_or_insert (use_stmt, &existed_p);\n+\t\t  if (!existed_p)\n+\t\t    drb = create_data_ref (NULL, NULL,\n+\t\t\t\t\t   gimple_assign_rhs1 (use_stmt),\n+\t\t\t\t\t   use_stmt, false, false);\n+\t\t  if (!dr_may_alias_p (dra.get (), drb, NULL))\n+\t\t    {\n+\t\t      if (gimple_vdef (use_stmt))\n+\t\t\tdefs.safe_push (use_stmt);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n \t      /* Handle common cases where we can easily build an ao_ref\n \t\t structure for USE_STMT and in doing so we find that the\n \t\t references hit non-live bytes and thus can be ignored.\n@@ -1535,14 +1566,21 @@ class pass_dse : public gimple_opt_pass\n {\n public:\n   pass_dse (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_dse, ctxt)\n+    : gimple_opt_pass (pass_data_dse, ctxt), use_dr_analysis_p (false)\n   {}\n \n   /* opt_pass methods: */\n   opt_pass * clone () final override { return new pass_dse (m_ctxt); }\n+  void set_pass_param (unsigned n, bool param) final override\n+    {\n+      gcc_assert (n == 0);\n+      use_dr_analysis_p = param;\n+    }\n   bool gate (function *) final override { return flag_tree_dse != 0; }\n   unsigned int execute (function *) final override;\n \n+private:\n+  bool use_dr_analysis_p;\n }; // class pass_dse\n \n unsigned int\n@@ -1554,6 +1592,8 @@ pass_dse::execute (function *fun)\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n   need_ab_cleanup = BITMAP_ALLOC (NULL);\n   auto_sbitmap live_bytes (param_dse_max_object_size);\n+  if (flag_expensive_optimizations && use_dr_analysis_p)\n+    dse_stmt_to_dr_map = new hash_map<gimple *, data_reference_p>;\n \n   renumber_gimple_stmt_uids (fun);\n \n@@ -1644,6 +1684,15 @@ pass_dse::execute (function *fun)\n   if (released_def)\n     free_numbers_of_iterations_estimates (fun);\n \n+  if (flag_expensive_optimizations && use_dr_analysis_p)\n+    {\n+      for (auto i = dse_stmt_to_dr_map->begin ();\n+\t   i != dse_stmt_to_dr_map->end (); ++i)\n+\tfree_data_ref ((*i).second);\n+      delete dse_stmt_to_dr_map;\n+      dse_stmt_to_dr_map = NULL;\n+    }\n+\n   return todo;\n }\n "}]}