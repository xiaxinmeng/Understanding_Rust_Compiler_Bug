{"sha": "1a83142efc31b14e550359fb637d4ed390222351", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4MzE0MmVmYzMxYjE0ZTU1MDM1OWZiNjM3ZDRlZDM5MDIyMjM1MQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-04-22T10:48:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-22T10:48:43Z"}, "message": "sem_prag.adb, [...]: Minor reformatting.\n\n2013-04-22  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb, sem_util.adb, sem_util.ads, sem_res.adb, exp_ch6.adb,\n\tsem_ch6.adb, opt.ads: Minor reformatting.\n\nFrom-SVN: r198132", "tree": {"sha": "ba69859d868381db02bf86838cd807771259e604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba69859d868381db02bf86838cd807771259e604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a83142efc31b14e550359fb637d4ed390222351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a83142efc31b14e550359fb637d4ed390222351", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a83142efc31b14e550359fb637d4ed390222351", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a83142efc31b14e550359fb637d4ed390222351/comments", "author": null, "committer": null, "parents": [{"sha": "1de0ffecde75db3dc66ec8bcd7504fe0481d194e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de0ffecde75db3dc66ec8bcd7504fe0481d194e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de0ffecde75db3dc66ec8bcd7504fe0481d194e"}], "stats": {"total": 433, "additions": 214, "deletions": 219}, "files": [{"sha": "076f65c76b668ca57fdf469c1cebbfb692e51c16", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -1,3 +1,8 @@\n+2013-04-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb, sem_util.adb, sem_util.ads, sem_res.adb, exp_ch6.adb,\n+\tsem_ch6.adb, opt.ads: Minor reformatting.\n+\n 2013-04-22  Pascal Obry  <obry@adacore.com>\n \n \t* gnat_ugn.texi, prj-nmsc.adb, projects.texi: Add check for"}, {"sha": "fffeb9c62eaceb139cdffa0c6ab4024385aca8a9", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -1715,11 +1715,11 @@ package body Exp_Ch6 is\n                  and then Is_Inherited_Operation_For_Type (Subp, E_Actual)\n                then\n                   Append_To\n-                   (Post_Call, Make_Predicate_Check (E_Actual, Actual));\n+                    (Post_Call, Make_Predicate_Check (E_Actual, Actual));\n \n                elsif Is_Entity_Name (Actual) then\n                   Append_To\n-                   (Post_Call, Make_Predicate_Check (E_Actual, Actual));\n+                    (Post_Call, Make_Predicate_Check (E_Actual, Actual));\n                end if;\n             end if;\n "}, {"sha": "c99244e9b47ad88394c1f04c16c88083fc19412b", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -206,7 +206,10 @@ package Opt is\n \n    Assertions_Enabled : Boolean := False;\n    --  GNAT\n-   --  Enable assertions made using pragma Assert\n+   --  Indicates default policy (True = Check, False = Ignore) to be applied\n+   --  to all assertion aspects and pragmas, and to pragma Debug, if there is\n+   --  no overriding Assertion_Policy, Check_Policy, or Debug_Policy pragma.\n+   --  Set True by use of -gnata.\n \n    Assume_No_Invalid_Values : Boolean := False;\n    --  GNAT Normally, in accordance with (RM 13.9.1 (9-11)) the front end\n@@ -282,13 +285,13 @@ package Opt is\n \n    Check_Object_Consistency : Boolean := False;\n    --  GNATBIND, GNATMAKE\n-   --  Set to True to check whether every object file is consistent with\n-   --  its corresponding ada library information (ALI) file. An object\n-   --  file is inconsistent with the corresponding ALI file if the object\n-   --  file does not exist or if it has an older time stamp than the ALI file.\n-   --  Default above is for GNATBIND. GNATMAKE overrides this default to\n-   --  True (see Make.Initialize) since we normally do need to check source\n-   --  consistencies in gnatmake.\n+   --  Set to True to check whether every object file is consistent with its\n+   --  corresponding ada library information (ALI) file. An object file is\n+   --  inconsistent with the corresponding ALI file if the object file does\n+   --  not exist or if it has an older time stamp than the ALI file. Default\n+   --  above is for GNATBIND. GNATMAKE overrides this default to True (see\n+   --  Make.Initialize) since we normally do need to check source consistencies\n+   --  in gnatmake.\n \n    Check_Only : Boolean := False;\n    --  GNATBIND"}, {"sha": "d64cdc872698ff3453c9ff5f35f9112fd45934b4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -7063,17 +7063,15 @@ package body Sem_Ch6 is\n       --  Last non-trivial contract-cases on the subprogram, or else Empty\n \n       Attribute_Result_Mentioned : Boolean := False;\n-      --  Whether attribute 'Result is mentioned in a non-trivial postcondition\n-      --  or contract-cases.\n+      --  True if 'Result used in a non-trivial postcondition or contract-cases\n \n       No_Warning_On_Some_Postcondition : Boolean := False;\n-      --  Whether there exists a non-trivial postcondition or contract-cases\n+      --  True if there is a non-trivial postcondition or contract-cases\n       --  without a corresponding warning.\n \n       Post_State_Mentioned : Boolean := False;\n-      --  Whether some expression mentioned in a postcondition or\n-      --  contract-cases can have a different value in the post-state than\n-      --  in the pre-state.\n+      --  True if expression mentioned in a postcondition or contract-cases\n+      --  can have a different value in the post-state than in the pre-state.\n \n       function Check_Attr_Result (N : Node_Id) return Traverse_Result;\n       --  Check if N is a reference to the attribute 'Result, and if so set\n@@ -7223,7 +7221,6 @@ package body Sem_Ch6 is\n                   --  or \"False\".\n \n                   if not Is_Trivial_Post_Or_Ensures (Conseq) then\n-\n                      Last_Contract_Cases := Prag;\n \n                      --  For functions, look for presence of 'Result in\n@@ -12272,8 +12269,7 @@ package body Sem_Ch6 is\n                      end if;\n \n                      if not Expander_Active then\n-                        Prepend\n-                          (Grab_PPC (Pspec), Declarations (N));\n+                        Prepend (Grab_PPC (Pspec), Declarations (N));\n                      else\n                         Append (Grab_PPC (Pspec), Plist);\n                      end if;"}, {"sha": "d58b0a740cd44001190560604220200a3731614f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 186, "deletions": 196, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -1525,188 +1525,6 @@ package body Sem_Prag is\n          end if;\n       end Check_Component;\n \n-      ---------------------\n-      -- Check_Test_Case --\n-      ---------------------\n-\n-      procedure Check_Test_Case is\n-         P  : Node_Id;\n-         PO : Node_Id;\n-\n-         procedure Chain_CTC (PO : Node_Id);\n-         --  If PO is a [generic] subprogram declaration node, then the\n-         --  test-case applies to this subprogram and the processing for\n-         --  the pragma is completed. Otherwise the pragma is misplaced.\n-\n-         ---------------\n-         -- Chain_CTC --\n-         ---------------\n-\n-         procedure Chain_CTC (PO : Node_Id) is\n-            S   : Entity_Id;\n-\n-         begin\n-            if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n-               Error_Pragma\n-                 (\"pragma% cannot be applied to abstract subprogram\");\n-\n-            elsif Nkind (PO) = N_Entry_Declaration then\n-               Error_Pragma (\"pragma% cannot be applied to entry\");\n-\n-            elsif not Nkind_In (PO, N_Subprogram_Declaration,\n-                                    N_Generic_Subprogram_Declaration)\n-            then\n-               Pragma_Misplaced;\n-            end if;\n-\n-            --  Here if we have [generic] subprogram declaration\n-\n-            S := Defining_Unit_Name (Specification (PO));\n-\n-            --  Note: we do not analyze the pragma at this point. Instead we\n-            --  delay this analysis until the end of the declarative part in\n-            --  which the pragma appears. This implements the required delay\n-            --  in this analysis, allowing forward references. The analysis\n-            --  happens at the end of Analyze_Declarations.\n-\n-            --  There should not be another test-case with the same name\n-            --  associated to this subprogram.\n-\n-            declare\n-               Name : constant String_Id := Get_Name_From_CTC_Pragma (N);\n-               CTC  : Node_Id;\n-\n-            begin\n-               CTC := Spec_CTC_List (Contract (S));\n-               while Present (CTC) loop\n-\n-                  --  Omit pragma Contract_Cases because it does not introduce\n-                  --  a unique case name and it does not follow the syntax of\n-                  --  Test_Case.\n-\n-                  if Pragma_Name (CTC) = Name_Contract_Cases then\n-                     null;\n-\n-                  elsif String_Equal\n-                          (Name, Get_Name_From_CTC_Pragma (CTC))\n-                  then\n-                     Error_Msg_Sloc := Sloc (CTC);\n-                     Error_Pragma (\"name for pragma% is already used#\");\n-                  end if;\n-\n-                  CTC := Next_Pragma (CTC);\n-               end loop;\n-            end;\n-\n-            --  Chain spec CTC pragma to list for subprogram\n-\n-            Set_Next_Pragma (N, Spec_CTC_List (Contract (S)));\n-            Set_Spec_CTC_List (Contract (S), N);\n-         end Chain_CTC;\n-\n-      --  Start of processing for Check_Test_Case\n-\n-      begin\n-         --  First check pragma arguments\n-\n-         GNAT_Pragma;\n-         Check_At_Least_N_Arguments (2);\n-         Check_At_Most_N_Arguments (4);\n-         Check_Arg_Order\n-           ((Name_Name, Name_Mode, Name_Requires, Name_Ensures));\n-\n-         Check_Optional_Identifier (Arg1, Name_Name);\n-         Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n-\n-         --  In ASIS mode, for a pragma generated from a source aspect, also\n-         --  analyze the original aspect expression.\n-\n-         if ASIS_Mode\n-           and then Present (Corresponding_Aspect (N))\n-         then\n-            Check_Expr_Is_Static_Expression\n-              (Original_Node (Get_Pragma_Arg (Arg1)), Standard_String);\n-         end if;\n-\n-         Check_Optional_Identifier (Arg2, Name_Mode);\n-         Check_Arg_Is_One_Of (Arg2, Name_Nominal, Name_Robustness);\n-\n-         if Arg_Count = 4 then\n-            Check_Identifier (Arg3, Name_Requires);\n-            Check_Identifier (Arg4, Name_Ensures);\n-\n-         elsif Arg_Count = 3 then\n-            Check_Identifier_Is_One_Of (Arg3, Name_Requires, Name_Ensures);\n-         end if;\n-\n-         --  Check pragma placement\n-\n-         if not Is_List_Member (N) then\n-            Pragma_Misplaced;\n-         end if;\n-\n-         --  Test-case should only appear in package spec unit\n-\n-         if Get_Source_Unit (N) = No_Unit\n-           or else not Nkind_In (Sinfo.Unit (Cunit (Get_Source_Unit (N))),\n-                                 N_Package_Declaration,\n-                                 N_Generic_Package_Declaration)\n-         then\n-            Pragma_Misplaced;\n-         end if;\n-\n-         --  Search prior declarations\n-\n-         P := N;\n-         while Present (Prev (P)) loop\n-            P := Prev (P);\n-\n-            --  If the previous node is a generic subprogram, do not go to to\n-            --  the original node, which is the unanalyzed tree: we need to\n-            --  attach the test-case to the analyzed version at this point.\n-            --  They get propagated to the original tree when analyzing the\n-            --  corresponding body.\n-\n-            if Nkind (P) not in N_Generic_Declaration then\n-               PO := Original_Node (P);\n-            else\n-               PO := P;\n-            end if;\n-\n-            --  Skip past prior pragma\n-\n-            if Nkind (PO) = N_Pragma then\n-               null;\n-\n-            --  Skip stuff not coming from source\n-\n-            elsif not Comes_From_Source (PO) then\n-               null;\n-\n-            --  Only remaining possibility is subprogram declaration. First\n-            --  check that it is declared directly in a package declaration.\n-            --  This may be either the package declaration for the current unit\n-            --  being defined or a local package declaration.\n-\n-            elsif not Present (Parent (Parent (PO)))\n-              or else not Present (Parent (Parent (Parent (PO))))\n-              or else not Nkind_In (Parent (Parent (PO)),\n-                                    N_Package_Declaration,\n-                                    N_Generic_Package_Declaration)\n-            then\n-               Pragma_Misplaced;\n-\n-            else\n-               Chain_CTC (PO);\n-               return;\n-            end if;\n-         end loop;\n-\n-         --  If we fall through, pragma was misplaced\n-\n-         Pragma_Misplaced;\n-      end Check_Test_Case;\n-\n       ----------------------------\n       -- Check_Duplicate_Pragma --\n       ----------------------------\n@@ -2500,6 +2318,188 @@ package body Sem_Prag is\n          end case;\n       end Check_Static_Constraint;\n \n+      ---------------------\n+      -- Check_Test_Case --\n+      ---------------------\n+\n+      procedure Check_Test_Case is\n+         P  : Node_Id;\n+         PO : Node_Id;\n+\n+         procedure Chain_CTC (PO : Node_Id);\n+         --  If PO is a [generic] subprogram declaration node, then the\n+         --  test-case applies to this subprogram and the processing for\n+         --  the pragma is completed. Otherwise the pragma is misplaced.\n+\n+         ---------------\n+         -- Chain_CTC --\n+         ---------------\n+\n+         procedure Chain_CTC (PO : Node_Id) is\n+            S   : Entity_Id;\n+\n+         begin\n+            if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n+               Error_Pragma\n+                 (\"pragma% cannot be applied to abstract subprogram\");\n+\n+            elsif Nkind (PO) = N_Entry_Declaration then\n+               Error_Pragma (\"pragma% cannot be applied to entry\");\n+\n+            elsif not Nkind_In (PO, N_Subprogram_Declaration,\n+                                    N_Generic_Subprogram_Declaration)\n+            then\n+               Pragma_Misplaced;\n+            end if;\n+\n+            --  Here if we have [generic] subprogram declaration\n+\n+            S := Defining_Unit_Name (Specification (PO));\n+\n+            --  Note: we do not analyze the pragma at this point. Instead we\n+            --  delay this analysis until the end of the declarative part in\n+            --  which the pragma appears. This implements the required delay\n+            --  in this analysis, allowing forward references. The analysis\n+            --  happens at the end of Analyze_Declarations.\n+\n+            --  There should not be another test-case with the same name\n+            --  associated to this subprogram.\n+\n+            declare\n+               Name : constant String_Id := Get_Name_From_CTC_Pragma (N);\n+               CTC  : Node_Id;\n+\n+            begin\n+               CTC := Spec_CTC_List (Contract (S));\n+               while Present (CTC) loop\n+\n+                  --  Omit pragma Contract_Cases because it does not introduce\n+                  --  a unique case name and it does not follow the syntax of\n+                  --  Test_Case.\n+\n+                  if Pragma_Name (CTC) = Name_Contract_Cases then\n+                     null;\n+\n+                  elsif String_Equal\n+                          (Name, Get_Name_From_CTC_Pragma (CTC))\n+                  then\n+                     Error_Msg_Sloc := Sloc (CTC);\n+                     Error_Pragma (\"name for pragma% is already used#\");\n+                  end if;\n+\n+                  CTC := Next_Pragma (CTC);\n+               end loop;\n+            end;\n+\n+            --  Chain spec CTC pragma to list for subprogram\n+\n+            Set_Next_Pragma (N, Spec_CTC_List (Contract (S)));\n+            Set_Spec_CTC_List (Contract (S), N);\n+         end Chain_CTC;\n+\n+      --  Start of processing for Check_Test_Case\n+\n+      begin\n+         --  First check pragma arguments\n+\n+         GNAT_Pragma;\n+         Check_At_Least_N_Arguments (2);\n+         Check_At_Most_N_Arguments (4);\n+         Check_Arg_Order\n+           ((Name_Name, Name_Mode, Name_Requires, Name_Ensures));\n+\n+         Check_Optional_Identifier (Arg1, Name_Name);\n+         Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+\n+         --  In ASIS mode, for a pragma generated from a source aspect, also\n+         --  analyze the original aspect expression.\n+\n+         if ASIS_Mode\n+           and then Present (Corresponding_Aspect (N))\n+         then\n+            Check_Expr_Is_Static_Expression\n+              (Original_Node (Get_Pragma_Arg (Arg1)), Standard_String);\n+         end if;\n+\n+         Check_Optional_Identifier (Arg2, Name_Mode);\n+         Check_Arg_Is_One_Of (Arg2, Name_Nominal, Name_Robustness);\n+\n+         if Arg_Count = 4 then\n+            Check_Identifier (Arg3, Name_Requires);\n+            Check_Identifier (Arg4, Name_Ensures);\n+\n+         elsif Arg_Count = 3 then\n+            Check_Identifier_Is_One_Of (Arg3, Name_Requires, Name_Ensures);\n+         end if;\n+\n+         --  Check pragma placement\n+\n+         if not Is_List_Member (N) then\n+            Pragma_Misplaced;\n+         end if;\n+\n+         --  Test-case should only appear in package spec unit\n+\n+         if Get_Source_Unit (N) = No_Unit\n+           or else not Nkind_In (Sinfo.Unit (Cunit (Get_Source_Unit (N))),\n+                                 N_Package_Declaration,\n+                                 N_Generic_Package_Declaration)\n+         then\n+            Pragma_Misplaced;\n+         end if;\n+\n+         --  Search prior declarations\n+\n+         P := N;\n+         while Present (Prev (P)) loop\n+            P := Prev (P);\n+\n+            --  If the previous node is a generic subprogram, do not go to to\n+            --  the original node, which is the unanalyzed tree: we need to\n+            --  attach the test-case to the analyzed version at this point.\n+            --  They get propagated to the original tree when analyzing the\n+            --  corresponding body.\n+\n+            if Nkind (P) not in N_Generic_Declaration then\n+               PO := Original_Node (P);\n+            else\n+               PO := P;\n+            end if;\n+\n+            --  Skip past prior pragma\n+\n+            if Nkind (PO) = N_Pragma then\n+               null;\n+\n+            --  Skip stuff not coming from source\n+\n+            elsif not Comes_From_Source (PO) then\n+               null;\n+\n+            --  Only remaining possibility is subprogram declaration. First\n+            --  check that it is declared directly in a package declaration.\n+            --  This may be either the package declaration for the current unit\n+            --  being defined or a local package declaration.\n+\n+            elsif not Present (Parent (Parent (PO)))\n+              or else not Present (Parent (Parent (Parent (PO))))\n+              or else not Nkind_In (Parent (Parent (PO)),\n+                                    N_Package_Declaration,\n+                                    N_Generic_Package_Declaration)\n+            then\n+               Pragma_Misplaced;\n+\n+            else\n+               Chain_CTC (PO);\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  If we fall through, pragma was misplaced\n+\n+         Pragma_Misplaced;\n+      end Check_Test_Case;\n+\n       --------------------------------------\n       -- Check_Valid_Configuration_Pragma --\n       --------------------------------------\n@@ -7503,7 +7503,6 @@ package body Sem_Prag is\n             Policy : Node_Id;\n             Arg    : Node_Id;\n             Kind   : Name_Id;\n-            Prag   : Node_Id;\n \n          begin\n             Ada_2005_Pragma;\n@@ -7550,10 +7549,7 @@ package body Sem_Prag is\n                      Make_Pragma_Argument_Association (Loc,\n                        Expression =>\n                          Make_Identifier (Sloc (Policy), Chars (Policy))))));\n-\n-               Set_Analyzed (N);\n-               Set_Next_Pragma (N, Opt.Check_Policy_List);\n-               Opt.Check_Policy_List := N;\n+               Analyze (N);\n \n             --  Here if we have two or more arguments\n \n@@ -7593,19 +7589,14 @@ package body Sem_Prag is\n \n                   --    Check_Policy (Kind, Policy);\n \n-                  Prag :=\n+                  Insert_Action (N,\n                     Make_Pragma (LocP,\n                       Chars                        => Name_Check_Policy,\n                       Pragma_Argument_Associations => New_List (\n                          Make_Pragma_Argument_Association (LocP,\n                            Expression => Make_Identifier (LocP, Kind)),\n                          Make_Pragma_Argument_Association (LocP,\n-                           Expression => Get_Pragma_Arg (Arg))));\n-\n-                  Set_Analyzed (Prag);\n-                  Set_Next_Pragma (Prag, Opt.Check_Policy_List);\n-                  Opt.Check_Policy_List := Prag;\n-                  Insert_Action (N, Prag);\n+                           Expression => Get_Pragma_Arg (Arg)))));\n \n                   Arg := Next (Arg);\n                end loop;\n@@ -8339,7 +8330,7 @@ package body Sem_Prag is\n             --  For the new syntax, what we do is to convert each argument to\n             --  an old syntax equivalent. We do that because we want to chain\n             --  old style Check_Policy pragmas for the search (we don't want\n-            --  to have to deal with multiple arguments in the search.)\n+            --  to have to deal with multiple arguments in the search).\n \n             else\n                declare\n@@ -9230,7 +9221,6 @@ package body Sem_Prag is\n \n                   Make_Pragma_Argument_Association (Loc,\n                     Expression => Get_Pragma_Arg (Arg1)))));\n-\n             Analyze (N);\n \n          -------------"}, {"sha": "99fd9d52ab1f26c1a95fd455f2e28e7f695aa1f2", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -5899,8 +5899,7 @@ package body Sem_Res is\n       if Nkind (N) = N_Function_Call\n         and then Is_Tagged_Type (Etype (N))\n         and then Is_Entity_Name (Name (N))\n-        and then Is_Inherited_Operation_For_Type\n-                   (Entity (Name (N)), Etype (N))\n+        and then Is_Inherited_Operation_For_Type (Entity (Name (N)), Etype (N))\n       then\n          Check_SPARK_Restriction (\"function not inherited\", N);\n       end if;"}, {"sha": "ea4fe46125ae9915b074056fe8329041bde5b23f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -8462,8 +8462,7 @@ package body Sem_Util is\n       Typ : Entity_Id) return Boolean\n    is\n    begin\n-      --  Check that the operation has been created by the declaration for\n-      --  the type.\n+      --  Check that the operation has been created by the type declaration\n \n       return Is_Inherited_Operation (E)\n         and then Defining_Identifier (Parent (E)) = Typ;"}, {"sha": "3256e4cfacf53a1507d07023cdcebf41d2b3a7ed", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a83142efc31b14e550359fb637d4ed390222351/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=1a83142efc31b14e550359fb637d4ed390222351", "patch": "@@ -576,6 +576,7 @@ package Sem_Util is\n \n    function Get_Ensures_From_CTC_Pragma (N : Node_Id) return Node_Id;\n    --  Return the Ensures component of Test_Case pragma N, or Empty otherwise\n+   --  Bad name now that this no longer applies to Contract_Case ???\n \n    function Get_Generic_Entity (N : Node_Id) return Entity_Id;\n    --  Returns the true generic entity in an instantiation. If the name in the\n@@ -616,6 +617,7 @@ package Sem_Util is\n \n    function Get_Name_From_CTC_Pragma (N : Node_Id) return String_Id;\n    --  Return the Name component of Test_Case pragma N\n+   --  Bad name now that this no longer applies to Contract_Case ???\n \n    function Get_Pragma_Id (N : Node_Id) return Pragma_Id;\n    pragma Inline (Get_Pragma_Id);\n@@ -634,6 +636,7 @@ package Sem_Util is\n \n    function Get_Requires_From_CTC_Pragma (N : Node_Id) return Node_Id;\n    --  Return the Requires component of Test_Case pragma N, or Empty otherwise\n+   --  Bad name now that this no longer applies to Contract_Case ???\n \n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n    --  Nod is either a procedure call statement, or a function call, or an"}]}