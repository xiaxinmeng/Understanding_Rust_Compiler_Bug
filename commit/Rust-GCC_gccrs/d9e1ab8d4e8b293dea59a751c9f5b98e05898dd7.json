{"sha": "d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDllMWFiOGQ0ZThiMjkzZGVhNTlhNzUxYzlmNWI5OGUwNTg5OGRkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-02T22:10:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-02T22:10:30Z"}, "message": "(__floatdisf):  Protect against double-rounding error.\n\nFrom-SVN: r7431", "tree": {"sha": "ef103607021237ec626056d60dc673a2b864e568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef103607021237ec626056d60dc673a2b864e568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7/comments", "author": null, "committer": null, "parents": [{"sha": "a473029f5c7a80c2d328d594352ec13dcbeeb649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a473029f5c7a80c2d328d594352ec13dcbeeb649", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a473029f5c7a80c2d328d594352ec13dcbeeb649"}], "stats": {"total": 35, "additions": 35, "deletions": 0}, "files": [{"sha": "fc2e1ac64b425d5288d2ef758dc6462731f6a5de", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=d9e1ab8d4e8b293dea59a751c9f5b98e05898dd7", "patch": "@@ -1021,6 +1021,25 @@ __floatdidf (u)\n #define WORD_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n #define HIGH_HALFWORD_COEFF (((UDItype) 1) << (WORD_SIZE / 2))\n #define HIGH_WORD_COEFF (((UDItype) 1) << WORD_SIZE)\n+#define DI_SIZE (sizeof (DItype) * BITS_PER_UNIT)\n+#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n+#define DF_SIZE 53\n+#define SF_SIZE 24\n+#else\n+#if TARGET_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n+#define DF_SIZE 56\n+#define SF_SIZE 24\n+#else\n+#if TARGET_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n+#define DF_SIZE 56\n+#define SF_SIZE 24\n+#else\n+#define DF_SIZE 0\n+#define SF_SIZE 0\n+#endif\n+#endif\n+#endif\n+\n \n SFtype\n __floatdisf (u)\n@@ -1035,6 +1054,22 @@ __floatdisf (u)\n   if (u < 0)\n     u = -u, negate = 1;\n \n+  /* Protect against double-rounding error.\n+     Represent any low-order bits, that might be truncated in DFmode,\n+     by a bit that won't be lost.  The bit can go in anywhere below the\n+     rounding position of the SFmode.  A fixed mask and bit position\n+     handles all usual configurations.  It doesn't handle the case\n+     of 128-bit DImode, however.  */\n+  if (DF_SIZE < DI_SIZE\n+      && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))\n+    {\n+#define REP_BIT ((USItype) 1 << (DI_SIZE - DF_SIZE))\n+      if (u >= ((UDItype) 1 << DF_SIZE))\n+\t{\n+\t  if ((USItype) u & (REP_BIT - 1))\n+\t    u |= REP_BIT;\n+\t}\n+    }\n   f = (USItype) (u >> WORD_SIZE);\n   f *= HIGH_HALFWORD_COEFF;\n   f *= HIGH_HALFWORD_COEFF;"}]}