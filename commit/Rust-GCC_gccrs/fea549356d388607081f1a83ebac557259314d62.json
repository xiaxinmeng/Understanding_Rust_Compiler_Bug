{"sha": "fea549356d388607081f1a83ebac557259314d62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVhNTQ5MzU2ZDM4ODYwNzA4MWYxYTgzZWJhYzU1NzI1OTMxNGQ2Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-06-20T21:12:39Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-06-20T21:12:39Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-06-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.h (gfc_check_vardef_context): Update prototype.\n        (iso_fortran_env_symbol): Handle derived types.\n        (symbol_attribute): Add lock_comp.\n        * expr.c (gfc_check_vardef_context): Add LOCK_TYPE check.\n        * interface.c (compare_parameter, gfc_procedure_use): Handle\n        LOCK_TYPE.\n        (compare_actual_formal): Update\n        gfc_check_vardef_context call.\n        * check.c (gfc_check_atomic_def, gfc_check_atomic_ref): Ditto.\n        * intrinsic.c (check_arglist): Ditto.\n        * io.c (resolve_tag, gfc_resolve_dt, gfc_resolve_inquire):\n        * Ditto.\n        * iso-fortran-env.def (ISOFORTRAN_LOCK_TYPE): Add.\n        * intrinsic.texi (ISO_FORTRAN_ENV): Document LOCK_TYPE.\n        * module.c (mio_symbol_attribute): Handle lock_comp.\n        (create_derived_type): New function.\n        (use_iso_fortran_env_module): Call it to handle LOCK_TYPE.\n        * parse.c (parse_derived): Add constraint check for LOCK_TYPE.\n        * resolve.c (resolve_symbol, resolve_lock_unlock): Add\n        * constraint\n        checks for LOCK_TYPE.\n        (gfc_resolve_iterator, resolve_deallocate_expr,\n        resolve_allocate_expr, resolve_code, resolve_transfer): Update\n        gfc_check_vardef_context call.\n        * trans-stmt.h (gfc_trans_lock_unlock): New prototype.\n        * trans-stmt.c (gfc_trans_lock_unlock): New function.\n        * trans.c (trans_code): Handle LOCK and UNLOCK.\n\n2011-06-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_lock_1.f90: Update dg-error.\n        * gfortran.dg/coarray_lock_3.f90: New.\n        * gfortran.dg/coarray/lock_1.f90: New.\n\nFrom-SVN: r175228", "tree": {"sha": "712d69e7e3f4057ac1970712cd75e6aca85eeb88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/712d69e7e3f4057ac1970712cd75e6aca85eeb88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fea549356d388607081f1a83ebac557259314d62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea549356d388607081f1a83ebac557259314d62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fea549356d388607081f1a83ebac557259314d62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea549356d388607081f1a83ebac557259314d62/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "998c75b661fa518b79a33f523eb716c246cba756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998c75b661fa518b79a33f523eb716c246cba756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/998c75b661fa518b79a33f523eb716c246cba756"}], "stats": {"total": 478, "additions": 441, "deletions": 37}, "files": [{"sha": "2e73625d927c66835bc1d91b3dae58402e0d63de", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -1,3 +1,32 @@\n+2011-06-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.h (gfc_check_vardef_context): Update prototype.\n+\t(iso_fortran_env_symbol): Handle derived types.\n+\t(symbol_attribute): Add lock_comp.\n+\t* expr.c (gfc_check_vardef_context): Add LOCK_TYPE check.\n+\t* interface.c (compare_parameter, gfc_procedure_use): Handle\n+\tLOCK_TYPE.\n+\t(compare_actual_formal): Update\n+\tgfc_check_vardef_context call.\n+\t* check.c (gfc_check_atomic_def, gfc_check_atomic_ref): Ditto.\n+\t* intrinsic.c (check_arglist): Ditto.\n+\t* io.c (resolve_tag, gfc_resolve_dt, gfc_resolve_inquire): Ditto.\n+\t* iso-fortran-env.def (ISOFORTRAN_LOCK_TYPE): Add.\n+\t* intrinsic.texi (ISO_FORTRAN_ENV): Document LOCK_TYPE.\n+\t* module.c (mio_symbol_attribute): Handle lock_comp.\n+\t(create_derived_type): New function.\n+\t(use_iso_fortran_env_module): Call it to handle LOCK_TYPE.\n+\t* parse.c (parse_derived): Add constraint check for LOCK_TYPE.\n+\t* resolve.c (resolve_symbol, resolve_lock_unlock): Add constraint\n+\tchecks for LOCK_TYPE.\n+\t(gfc_resolve_iterator, resolve_deallocate_expr,\n+\tresolve_allocate_expr, resolve_code, resolve_transfer): Update\n+\tgfc_check_vardef_context call.\n+\t* trans-stmt.h (gfc_trans_lock_unlock): New prototype.\n+\t* trans-stmt.c (gfc_trans_lock_unlock): New function.\n+\t* trans.c (trans_code): Handle LOCK and UNLOCK.\n+\n 2011-06-18  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/49400"}, {"sha": "79e1c95b9e16445693a5b71e67a8e848353c38c9", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -1011,7 +1011,7 @@ gfc_check_atomic_def (gfc_expr *atom, gfc_expr *value)\n   if (scalar_check (atom, 0) == FAILURE || scalar_check (value, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_check_vardef_context (atom, false, NULL) == FAILURE)\n+  if (gfc_check_vardef_context (atom, false, false, NULL) == FAILURE)\n     {\n       gfc_error (\"ATOM argument of the %s intrinsic function at %L shall be \"\n \t\t \"definable\", gfc_current_intrinsic, &atom->where);\n@@ -1028,7 +1028,7 @@ gfc_check_atomic_ref (gfc_expr *value, gfc_expr *atom)\n   if (scalar_check (value, 0) == FAILURE || scalar_check (atom, 1) == FAILURE)\n     return FAILURE;\n \n-  if (gfc_check_vardef_context (value, false, NULL) == FAILURE)\n+  if (gfc_check_vardef_context (value, false, false, NULL) == FAILURE)\n     {\n       gfc_error (\"VALUE argument of the %s intrinsic function at %L shall be \"\n \t\t \"definable\", gfc_current_intrinsic, &value->where);"}, {"sha": "4a7a951b6d6f1bb3eecb0cdb01d064c71975c97c", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -4373,7 +4373,8 @@ gfc_build_intrinsic_call (const char* name, locus where, unsigned numarg, ...)\n    and just the return status (SUCCESS / FAILURE) be requested.  */\n \n gfc_try\n-gfc_check_vardef_context (gfc_expr* e, bool pointer, const char* context)\n+gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n+\t\t\t  const char* context)\n {\n   gfc_symbol* sym = NULL;\n   bool is_pointer;\n@@ -4441,6 +4442,19 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, const char* context)\n       return FAILURE;\n     }\n \n+  /* F2008, C1303.  */\n+  if (!alloc_obj\n+      && (attr.lock_comp\n+\t  || (e->ts.type == BT_DERIVED\n+\t      && e->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t      && e->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)))\n+    {\n+      if (context)\n+\tgfc_error (\"LOCK_TYPE in variable definition context (%s) at %L\",\n+\t\t   context, &e->where);\n+      return FAILURE;\n+    }\n+\n   /* INTENT(IN) dummy argument.  Check this, unless the object itself is\n      the component of sub-component of a pointer.  Obviously,\n      procedure pointers are of no interest here.  */\n@@ -4555,7 +4569,8 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, const char* context)\n \t}\n \n       /* Target must be allowed to appear in a variable definition context.  */\n-      if (gfc_check_vardef_context (assoc->target, pointer, NULL) == FAILURE)\n+      if (gfc_check_vardef_context (assoc->target, pointer, false, NULL)\n+\t  == FAILURE)\n \t{\n \t  if (context)\n \t    gfc_error (\"Associate-name '%s' can not appear in a variable\""}, {"sha": "8b834abe095bdb5b07f402fb0b8d4ba0f6ede4ea", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -596,6 +596,7 @@ gfc_reverse;\n #define NAMED_INTCST(a,b,c,d) a,\n #define NAMED_KINDARRAY(a,b,c,d) a,\n #define NAMED_FUNCTION(a,b,c,d) a,\n+#define NAMED_DERIVED_TYPE(a,b,c,d) a,\n typedef enum\n {\n   ISOFORTRANENV_INVALID = -1,\n@@ -606,6 +607,7 @@ iso_fortran_env_symbol;\n #undef NAMED_INTCST\n #undef NAMED_KINDARRAY\n #undef NAMED_FUNCTION\n+#undef NAMED_DERIVED_TYPE\n \n #define NAMED_INTCST(a,b,c,d) a,\n #define NAMED_REALCST(a,b,c) a,\n@@ -774,7 +776,7 @@ typedef struct\n      possibly nested.  zero_comp is true if the derived type has no\n      component at all.  */\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n-\t   private_comp:1, zero_comp:1, coarray_comp:1;\n+\t   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1;\n \n   /* This is a temporary selector for SELECT TYPE.  */\n   unsigned select_type_temporary:1;\n@@ -2735,7 +2737,7 @@ bool gfc_has_ultimate_allocatable (gfc_expr *);\n bool gfc_has_ultimate_pointer (gfc_expr *);\n \n gfc_expr* gfc_build_intrinsic_call (const char*, locus, unsigned, ...);\n-gfc_try gfc_check_vardef_context (gfc_expr*, bool, const char*);\n+gfc_try gfc_check_vardef_context (gfc_expr*, bool, bool, const char*);\n \n \n /* st.c */"}, {"sha": "dcf6c4e9bd15f66b77505917554262ecd1a9b596", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -1618,7 +1618,22 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t       \"contiguous\", formal->name, &actual->where);\n \t  return 0;\n \t}\n-    }\n+\n+      /* F2008, C1303 and C1304.  */\n+      if (formal->attr.intent != INTENT_INOUT\n+\t  && (((formal->ts.type == BT_DERIVED || formal->ts.type == BT_CLASS)\n+\t       && formal->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t       && formal->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n+\t      || formal->attr.lock_comp))\n+\n+    \t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument to non-INTENT(INOUT) dummy '%s' at %L, \"\n+\t\t       \"which is LOCK_TYPE or has a LOCK_TYPE component\",\n+\t\t       formal->name, &actual->where);\n+\t  return 0;\n+\t}\n+      }\n \n   /* F2008, C1239/C1240.  */\n   if (actual->expr_type == EXPR_VARIABLE\n@@ -2294,10 +2309,10 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t\t\t : NULL);\n \n \t  if (f->sym->attr.pointer\n-\t      && gfc_check_vardef_context (a->expr, true, context)\n+\t      && gfc_check_vardef_context (a->expr, true, false, context)\n \t\t   == FAILURE)\n \t    return 0;\n-\t  if (gfc_check_vardef_context (a->expr, false, context)\n+\t  if (gfc_check_vardef_context (a->expr, false, false, context)\n \t\t== FAILURE)\n \t    return 0;\n \t}\n@@ -2749,6 +2764,19 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t\t\t\"for procedure '%s' at %L\", sym->name, &a->expr->where);\n \t      break;\n \t    }\n+\n+\t  /* F2008, C1303 and C1304.  */\n+\t  if (a->expr\n+\t      && (a->expr->ts.type == BT_DERIVED || a->expr->ts.type == BT_CLASS)\n+\t      && ((a->expr->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t\t   && a->expr->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n+\t\t  || gfc_expr_attr (a->expr).lock_comp))\n+\t    {\n+\t      gfc_error(\"Actual argument of LOCK_TYPE or with LOCK_TYPE \"\n+\t\t\t\"component at %L requires an explicit interface for \"\n+\t\t\t\"procedure '%s'\", &a->expr->where, sym->name);\n+\t      break;\n+\t    }\n \t}\n \n       return;"}, {"sha": "a72da91defc962a47aa8cd87a021d92b0e90ac07", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -3642,7 +3642,7 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t\t\t\t : NULL);\n \n \t  /* No pointer arguments for intrinsics.  */\n-\t  if (gfc_check_vardef_context (actual->expr, false, context)\n+\t  if (gfc_check_vardef_context (actual->expr, false, false, context)\n \t\t== FAILURE)\n \t    return FAILURE;\n \t}"}, {"sha": "57338f141007361aeec81730bf6f4b8356c6a327", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -12963,6 +12963,16 @@ Scalar default-integer constant used as STAT= return value by @code{UNLOCK} to\n denote that the lock variable is unlocked. (Fortran 2008 or later.)\n @end table\n \n+The module provides the following derived type:\n+\n+@table @asis\n+@item @code{LOCK_TYPE}:\n+Derived type with private components to be use with the @code{LOCK} and\n+@code{UNLOCK} statement. A variable of its type has to be always declared\n+as coarray and may not appear in a variable-definition context.\n+(Fortran 2008 or later.)\n+@end table\n+\n The module also provides the following intrinsic procedures:\n @ref{COMPILER_OPTIONS} and @ref{COMPILER_VERSION}.\n "}, {"sha": "58c942f6d5b2cc9786b688a88c845d4be5d13f2f", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -1531,7 +1531,7 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n       char context[64];\n \n       sprintf (context, _(\"%s tag\"), tag->name);\n-      if (gfc_check_vardef_context (e, false, context) == FAILURE)\n+      if (gfc_check_vardef_context (e, false, false, context) == FAILURE)\n \treturn FAILURE;\n     }\n   \n@@ -2836,8 +2836,8 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n       /* If we are writing, make sure the internal unit can be changed.  */\n       gcc_assert (k != M_PRINT);\n       if (k == M_WRITE\n-\t  && gfc_check_vardef_context (e, false, _(\"internal unit in WRITE\"))\n-\t       == FAILURE)\n+\t  && gfc_check_vardef_context (e, false, false,\n+\t\t\t\t       _(\"internal unit in WRITE\")) == FAILURE)\n \treturn FAILURE;\n     }\n \n@@ -2866,7 +2866,7 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n \t  gfc_try t;\n \n \t  e = gfc_get_variable_expr (gfc_find_sym_in_symtree (n->sym));\n-\t  t = gfc_check_vardef_context (e, false, NULL);\n+\t  t = gfc_check_vardef_context (e, false, false, NULL);\n \t  gfc_free_expr (e);\n \n \t  if (t == FAILURE)\n@@ -4032,7 +4032,7 @@ gfc_resolve_inquire (gfc_inquire *inquire)\n     { \\\n       char context[64]; \\\n       sprintf (context, _(\"%s tag with INQUIRE\"), (tag)->name); \\\n-      if (gfc_check_vardef_context ((expr), false, context) == FAILURE) \\\n+      if (gfc_check_vardef_context ((expr), false, false, context) == FAILURE) \\\n \treturn FAILURE; \\\n     }\n   INQUIRE_RESOLVE_TAG (&tag_iomsg, inquire->iomsg);"}, {"sha": "240a02218ab7c6ed6d8387c5138380783857d28d", "filename": "gcc/fortran/iso-fortran-env.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fiso-fortran-env.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fiso-fortran-env.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-fortran-env.def?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -110,7 +110,14 @@ NAMED_FUNCTION (ISOFORTRAN_COMPILER_OPTIONS, \"compiler_options\", \\\n NAMED_FUNCTION (ISOFORTRAN_COMPILER_VERSION, \"compiler_version\", \\\n                 GFC_ISYM_COMPILER_VERSION, GFC_STD_F2008)\n \n+#ifndef NAMED_DERIVED_TYPE\n+# define NAMED_DERIVED_TYPE(a,b,c,d)\n+#endif\n+\n+NAMED_DERIVED_TYPE (ISOFORTRAN_LOCK_TYPE, \"lock_type\", \\\n+              get_int_kind_from_node (ptr_type_node), GFC_STD_F2008)\n \n #undef NAMED_INTCST\n #undef NAMED_KINDARRAY\n #undef NAMED_FUNCTION\n+#undef NAMED_DERIVED_TYPE"}, {"sha": "4afe4672db8a51b846797cfc90957bd2c33ccd4a", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -1673,7 +1673,7 @@ typedef enum\n   AB_ELEMENTAL, AB_PURE, AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT,\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE,\n   AB_ALLOC_COMP, AB_POINTER_COMP, AB_PROC_POINTER_COMP, AB_PRIVATE_COMP,\n-  AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n+  AB_VALUE, AB_VOLATILE, AB_PROTECTED, AB_LOCK_COMP,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n@@ -1716,6 +1716,7 @@ static const mstring attr_bits[] =\n     minit (\"VALUE\", AB_VALUE),\n     minit (\"ALLOC_COMP\", AB_ALLOC_COMP),\n     minit (\"COARRAY_COMP\", AB_COARRAY_COMP),\n+    minit (\"LOCK_COMP\", AB_LOCK_COMP),\n     minit (\"POINTER_COMP\", AB_POINTER_COMP),\n     minit (\"PROC_POINTER_COMP\", AB_PROC_POINTER_COMP),\n     minit (\"PRIVATE_COMP\", AB_PRIVATE_COMP),\n@@ -1889,6 +1890,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_PRIVATE_COMP, attr_bits);\n       if (attr->coarray_comp)\n \tMIO_NAME (ab_attribute) (AB_COARRAY_COMP, attr_bits);\n+      if (attr->lock_comp)\n+\tMIO_NAME (ab_attribute) (AB_LOCK_COMP, attr_bits);\n       if (attr->zero_comp)\n \tMIO_NAME (ab_attribute) (AB_ZERO_COMP, attr_bits);\n       if (attr->is_class)\n@@ -2028,6 +2031,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_COARRAY_COMP:\n \t      attr->coarray_comp = 1;\n \t      break;\n+\t    case AB_LOCK_COMP:\n+\t      attr->lock_comp = 1;\n+\t      break;\n \t    case AB_POINTER_COMP:\n \t      attr->pointer_comp = 1;\n \t      break;\n@@ -5469,6 +5475,37 @@ create_int_parameter_array (const char *name, int size, gfc_expr *value,\n }\n \n \n+/* Add an derived type for a given module.  */\n+\n+static void\n+create_derived_type (const char *name, const char *modname,\n+\t\t      intmod_id module, int id)\n+{\n+  gfc_symtree *tmp_symtree;\n+  gfc_symbol *sym;\n+\n+  tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);\n+  if (tmp_symtree != NULL)\n+    {\n+      if (strcmp (modname, tmp_symtree->n.sym->module) == 0)\n+\treturn;\n+      else\n+\tgfc_error (\"Symbol '%s' already declared\", name);\n+    }\n+\n+  gfc_get_sym_tree (name, gfc_current_ns, &tmp_symtree, false);\n+  sym = tmp_symtree->n.sym;\n+\n+  sym->module = gfc_get_string (modname);\n+  sym->from_intmod = module;\n+  sym->intmod_sym_id = id;\n+  sym->attr.flavor = FL_DERIVED;\n+  sym->attr.private_comp = 1;\n+  sym->attr.zero_comp = 1;\n+  sym->attr.use_assoc = 1;\n+}\n+\n+\n \n /* USE the ISO_FORTRAN_ENV intrinsic module.  */\n \n@@ -5489,6 +5526,9 @@ use_iso_fortran_env_module (void)\n #define NAMED_KINDARRAY(a,b,c,d) { a, b, 0, d },\n #include \"iso-fortran-env.def\"\n #undef NAMED_KINDARRAY\n+#define NAMED_DERIVED_TYPE(a,b,c,d) { a, b, 0, d },\n+#include \"iso-fortran-env.def\"\n+#undef NAMED_DERIVED_TYPE\n #define NAMED_FUNCTION(a,b,c,d) { a, b, c, d },\n #include \"iso-fortran-env.def\"\n #undef NAMED_FUNCTION\n@@ -5573,6 +5613,16 @@ use_iso_fortran_env_module (void)\n #include \"iso-fortran-env.def\"\n #undef NAMED_KINDARRAY\n \n+#define NAMED_DERIVED_TYPE(a,b,TYPE,STD) \\\n+\t\tcase a:\n+#include \"iso-fortran-env.def\"\n+                  create_derived_type (u->local_name[0] ? u->local_name\n+\t\t\t\t\t\t\t: u->use_name,\n+\t\t\t\t       mod, INTMOD_ISO_FORTRAN_ENV,\n+\t\t\t\t       symbol[i].id);\n+\t\t  break;\n+#undef NAMED_DERIVED_TYPE\n+\n #define NAMED_FUNCTION(a,b,c,d) \\\n \t\tcase a:\n #include \"iso-fortran-env.def\"\n@@ -5626,6 +5676,14 @@ use_iso_fortran_env_module (void)\n #include \"iso-fortran-env.def\"\n #undef NAMED_KINDARRAY\n \n+#define NAMED_DERIVED_TYPE(a,b,TYPE,STD) \\\n+\t  case a:\n+#include \"iso-fortran-env.def\"\n+\t    create_derived_type (symbol[i].name, mod, INTMOD_ISO_FORTRAN_ENV,\n+\t\t\t\t symbol[i].id);\n+\t    break;\n+#undef NAMED_DERIVED_TYPE\n+\n #define NAMED_FUNCTION(a,b,c,d) \\\n \t\tcase a:\n #include \"iso-fortran-env.def\""}, {"sha": "ba28648ec2cdb1693fa852b2ffb6b3c40a9d641d", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -2143,6 +2143,13 @@ parse_derived (void)\n \t  || (c->attr.coarray_comp && !c->attr.pointer && !c->attr.allocatable))\n \tsym->attr.coarray_comp = 1;\n \n+      /* Looking for lock_type components.  */\n+      if (c->attr.lock_comp\n+\t  || (sym->ts.type == BT_DERIVED\n+\t      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE))\n+\tsym->attr.lock_comp = 1;\n+\n       /* Look for private components.  */\n       if (sym->component_access == ACCESS_PRIVATE\n \t  || c->attr.access == ACCESS_PRIVATE"}, {"sha": "f484a223f9b1de9c7178db06ba3f05d20f6204df", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 73, "deletions": 19, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -6235,7 +6235,7 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok)\n       == FAILURE)\n     return FAILURE;\n \n-  if (gfc_check_vardef_context (iter->var, false, _(\"iterator variable\"))\n+  if (gfc_check_vardef_context (iter->var, false, false, _(\"iterator variable\"))\n       == FAILURE)\n     return FAILURE;\n \n@@ -6502,9 +6502,11 @@ resolve_deallocate_expr (gfc_expr *e)\n     }\n \n   if (pointer\n-      && gfc_check_vardef_context (e, true, _(\"DEALLOCATE object\")) == FAILURE)\n+      && gfc_check_vardef_context (e, true, true, _(\"DEALLOCATE object\"))\n+\t == FAILURE)\n     return FAILURE;\n-  if (gfc_check_vardef_context (e, false, _(\"DEALLOCATE object\")) == FAILURE)\n+  if (gfc_check_vardef_context (e, false, true, _(\"DEALLOCATE object\"))\n+      == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -6796,6 +6798,21 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t\t      &e->where, &code->expr3->where);\n \t  goto failure;\n \t}\n+\n+      /* Check F2008, C642.  */\n+      if (code->expr3->ts.type == BT_DERIVED\n+\t  && ((codimension &&  gfc_expr_attr (code->expr3).lock_comp)\n+\t      || (code->expr3->ts.u.derived->from_intmod\n+\t\t     == INTMOD_ISO_FORTRAN_ENV\n+\t\t  && code->expr3->ts.u.derived->intmod_sym_id\n+\t\t     == ISOFORTRAN_LOCK_TYPE)))\n+\t{\n+\t  gfc_error (\"The source-expr at %L shall neither be of type \"\n+\t\t     \"LOCK_TYPE nor have a LOCK_TYPE component if \"\n+\t\t      \"allocate-object at %L is a coarray\",\n+\t\t      &code->expr3->where, &e->where);\n+\t  goto failure;\n+\t}\n     }\n \n   /* Check F08:C629.  */\n@@ -6814,9 +6831,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   e2 = remove_last_array_ref (e);\n   t = SUCCESS;\n   if (t == SUCCESS && pointer)\n-    t = gfc_check_vardef_context (e2, true, _(\"ALLOCATE object\"));\n+    t = gfc_check_vardef_context (e2, true, true, _(\"ALLOCATE object\"));\n   if (t == SUCCESS)\n-    t = gfc_check_vardef_context (e2, false, _(\"ALLOCATE object\"));\n+    t = gfc_check_vardef_context (e2, false, true, _(\"ALLOCATE object\"));\n   gfc_free_expr (e2);\n   if (t == FAILURE)\n     goto failure;\n@@ -6992,7 +7009,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n   /* Check the stat variable.  */\n   if (stat)\n     {\n-      gfc_check_vardef_context (stat, false, _(\"STAT variable\"));\n+      gfc_check_vardef_context (stat, false, false, _(\"STAT variable\"));\n \n       if ((stat->ts.type != BT_INTEGER\n \t   && !(stat->ref && (stat->ref->type == REF_ARRAY\n@@ -7035,7 +7052,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \tgfc_warning (\"ERRMSG at %L is useless without a STAT tag\",\n \t\t     &errmsg->where);\n \n-      gfc_check_vardef_context (errmsg, false, _(\"ERRMSG variable\"));\n+      gfc_check_vardef_context (errmsg, false, false, _(\"ERRMSG variable\"));\n \n       if ((errmsg->ts.type != BT_CHARACTER\n \t   && !(errmsg->ref\n@@ -8100,7 +8117,8 @@ resolve_transfer (gfc_code *code)\n      code->ext.dt may be NULL if the TRANSFER is related to\n      an INQUIRE statement -- but in this case, we are not reading, either.  */\n   if (code->ext.dt && code->ext.dt->dt_io_kind->value.iokind == M_READ\n-      && gfc_check_vardef_context (exp, false, _(\"item in READ\")) == FAILURE)\n+      && gfc_check_vardef_context (exp, false, false, _(\"item in READ\"))\n+\t == FAILURE)\n     return;\n \n   sym = exp->symtree->n.sym;\n@@ -8201,13 +8219,15 @@ find_reachable_labels (gfc_code *block)\n static void\n resolve_lock_unlock (gfc_code *code)\n {\n-  /* FIXME: Add more lock-variable checks. For now, always reject it.\n-     Note that ISO_FORTRAN_ENV's LOCK_TYPE is not yet available.  */\n-  /* if (code->expr2->ts.type != BT_DERIVED\n-\t || code->expr2->rank != 0\n-\t || code->expr2->expr_type != EXPR_VARIABLE)  */\n-  gfc_error (\"Lock variable at %L must be a scalar of type LOCK_TYPE\",\n-\t     &code->expr1->where);\n+  if (code->expr1->ts.type != BT_DERIVED\n+      || code->expr1->expr_type != EXPR_VARIABLE\n+      || code->expr1->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV\n+      || code->expr1->ts.u.derived->intmod_sym_id != ISOFORTRAN_LOCK_TYPE\n+      || code->expr1->rank != 0\n+      || !(gfc_expr_attr (code->expr1).codimension\n+\t   || gfc_is_coindexed (code->expr1)))\n+    gfc_error (\"Lock variable at %L must be a scalar coarray of type \"\n+\t       \"LOCK_TYPE\", &code->expr1->where);\n \n   /* Check STAT.  */\n   if (code->expr2\n@@ -8216,19 +8236,34 @@ resolve_lock_unlock (gfc_code *code)\n     gfc_error (\"STAT= argument at %L must be a scalar INTEGER variable\",\n \t       &code->expr2->where);\n \n+  if (code->expr2\n+      && gfc_check_vardef_context (code->expr2, false, false,\n+\t\t\t\t   _(\"STAT variable\")) == FAILURE)\n+    return;\n+\n   /* Check ERRMSG.  */\n   if (code->expr3\n       && (code->expr3->ts.type != BT_CHARACTER || code->expr3->rank != 0\n \t  || code->expr3->expr_type != EXPR_VARIABLE))\n     gfc_error (\"ERRMSG= argument at %L must be a scalar CHARACTER variable\",\n \t       &code->expr3->where);\n \n+  if (code->expr3\n+      && gfc_check_vardef_context (code->expr3, false, false,\n+\t\t\t\t   _(\"ERRMSG variable\")) == FAILURE)\n+    return;\n+\n   /* Check ACQUIRED_LOCK.  */\n   if (code->expr4\n       && (code->expr4->ts.type != BT_LOGICAL || code->expr4->rank != 0\n \t  || code->expr4->expr_type != EXPR_VARIABLE))\n     gfc_error (\"ACQUIRED_LOCK= argument at %L must be a scalar LOGICAL \"\n \t       \"variable\", &code->expr4->where);\n+\n+  if (code->expr4\n+      && gfc_check_vardef_context (code->expr4, false, false,\n+\t\t\t\t   _(\"ACQUIRED_LOCK variable\")) == FAILURE)\n+    return;\n }\n \n \n@@ -9143,8 +9178,8 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (t == FAILURE)\n \t    break;\n \n-\t  if (gfc_check_vardef_context (code->expr1, false, _(\"assignment\"))\n-\t\t== FAILURE)\n+\t  if (gfc_check_vardef_context (code->expr1, false, false,\n+\t\t\t\t\t_(\"assignment\")) == FAILURE)\n \t    break;\n \n \t  if (resolve_ordinary_assign (code, ns))\n@@ -9182,9 +9217,11 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t       array ref may be present on the LHS and fool gfc_expr_attr\n \t       used in gfc_check_vardef_context.  Remove it.  */\n \t    e = remove_last_array_ref (code->expr1);\n-\t    t = gfc_check_vardef_context (e, true, _(\"pointer assignment\"));\n+\t    t = gfc_check_vardef_context (e, true, false,\n+\t\t\t\t\t  _(\"pointer assignment\"));\n \t    if (t == SUCCESS)\n-\t      t = gfc_check_vardef_context (e, false, _(\"pointer assignment\"));\n+\t      t = gfc_check_vardef_context (e, false, false,\n+\t\t\t\t\t    _(\"pointer assignment\"));\n \t    gfc_free_expr (e);\n \t    if (t == FAILURE)\n \t      break;\n@@ -12340,6 +12377,17 @@ resolve_symbol (gfc_symbol *sym)\n \t\t\t sym->ts.u.derived->name) == FAILURE)\n     return;\n \n+  /* F2008, C1302.  */\n+  if (sym->ts.type == BT_DERIVED\n+      && sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+      && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE\n+      && !sym->attr.codimension)\n+    {\n+      gfc_error (\"Variable '%s' at %L of type LOCK_TYPE must be a coarray\",\n+\t\t sym->name, &sym->declared_at);\n+      return;\n+    }\n+\n   /* An assumed-size array with INTENT(OUT) shall not be of a type for which\n      default initialization is defined (5.1.2.4.4).  */\n   if (sym->ts.type == BT_DERIVED\n@@ -12360,6 +12408,12 @@ resolve_symbol (gfc_symbol *sym)\n \t}\n     }\n \n+  /* F2008, C542.  */\n+  if (sym->ts.type == BT_DERIVED && sym->attr.dummy\n+      && sym->attr.intent == INTENT_OUT && sym->attr.lock_comp)\n+    gfc_error (\"Dummy argument '%s' at %L of LOCK_TYPE shall not be \"\n+\t       \"INTENT(OUT)\", sym->name, &sym->declared_at);\n+\n   /* F2008, C526.  */\n   if (((sym->ts.type == BT_DERIVED && sym->ts.u.derived->attr.coarray_comp)\n        || sym->attr.codimension)"}, {"sha": "a5f2d9efb9a33308dbc7f30d396a8e0cd9ce10c1", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -652,6 +652,48 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n }\n \n \n+tree\n+gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op type ATTRIBUTE_UNUSED)\n+{\n+  gfc_se se, argse;\n+  tree stat = NULL_TREE, lock_acquired = NULL_TREE;\n+\n+  /* Short cut: For single images without STAT= or LOCK_ACQUIRED\n+     return early. (ERRMSG= is always untouched for -fcoarray=single.)  */\n+  if (!code->expr2 && !code->expr4 && gfc_option.coarray != GFC_FCOARRAY_LIB)\n+    return NULL_TREE; \n+\n+  gfc_init_se (&se, NULL);\n+  gfc_start_block (&se.pre);\n+\n+  if (code->expr2)\n+    {\n+      gcc_assert (code->expr2->expr_type == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr2);\n+      stat = argse.expr;\n+    }\n+\n+  if (code->expr4)\n+    {\n+      gcc_assert (code->expr4->expr_type == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse, code->expr4);\n+      lock_acquired = argse.expr;\n+    }\n+\n+  if (stat != NULL_TREE)\n+    gfc_add_modify (&se.pre, stat, build_int_cst (TREE_TYPE (stat), 0));\n+\n+  if (lock_acquired != NULL_TREE)\n+    gfc_add_modify (&se.pre, lock_acquired,\n+\t\t    fold_convert (TREE_TYPE (lock_acquired),\n+\t\t\t\t  boolean_true_node));\n+\n+  return gfc_finish_block (&se.pre);\n+}\n+\n+\n tree\n gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n {"}, {"sha": "2d0faf17fb7c49db61dc175d4ebde1df33dbb2ce", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -54,6 +54,7 @@ tree gfc_trans_do (gfc_code *, tree);\n tree gfc_trans_do_while (gfc_code *);\n tree gfc_trans_select (gfc_code *);\n tree gfc_trans_sync (gfc_code *, gfc_exec_op);\n+tree gfc_trans_lock_unlock (gfc_code *, gfc_exec_op);\n tree gfc_trans_forall (gfc_code *);\n tree gfc_trans_where (gfc_code *);\n tree gfc_trans_allocate (gfc_code *);"}, {"sha": "33593c5626adb85f0fd52e9436d2acc493fa9344", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -1318,6 +1318,11 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_sync (code, code->op);\n \t  break;\n \n+\tcase EXEC_LOCK:\n+\tcase EXEC_UNLOCK:\n+\t  res = gfc_trans_lock_unlock (code, code->op);\n+\t  break;\n+\n \tcase EXEC_FORALL:\n \t  res = gfc_trans_forall (code);\n \t  break;"}, {"sha": "f18487f74b46d8eac7fd1262ccf8fe18364f64ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -1,3 +1,10 @@\n+2011-06-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_lock_1.f90: Update dg-error.\n+\t* gfortran.dg/coarray_lock_3.f90: New.\n+\t* gfortran.dg/coarray/lock_1.f90: New.\n+\n 2011-06-20  Janis Johnson  <janisjo@codesourcery.com>\n \n \t* lib/scandump.exp (scan-dump, scan-dump-times, scan-dump-not,"}, {"sha": "db4fbc8f7cb88d499594c90294e14a6e501e159b", "filename": "gcc/testsuite/gfortran.dg/coarray/lock_1.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flock_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flock_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flock_1.f90?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+!\n+! LOCK/UNLOCK check\n+!\n+! PR fortran/18918\n+!\n+\n+use iso_fortran_env\n+implicit none\n+\n+type(lock_type) :: lock[*]\n+integer :: stat\n+logical :: acquired\n+\n+LOCK(lock)\n+UNLOCK(lock)\n+\n+stat = 99\n+LOCK(lock, stat=stat)\n+if (stat /= 0) call abort()\n+stat = 99\n+UNLOCK(lock, stat=stat)\n+if (stat /= 0) call abort()\n+\n+if (this_image() == 1) then\n+  acquired = .false.\n+  LOCK (lock[this_image()], acquired_lock=acquired)\n+  if (.not. acquired) call abort()\n+  UNLOCK (lock[1])\n+end if\n+end\n+"}, {"sha": "f9ef581985066ea7e004b127f897675dfec73a59", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -10,6 +10,6 @@\n character(len=3) :: c\n logical :: bool\n \n-LOCK (a, stat=s, acquired_lock=bool, errmsg=c) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n-UNLOCK (a, stat=s, errmsg=c) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n+LOCK (a, stat=s, acquired_lock=bool, errmsg=c) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n+UNLOCK (a, stat=s, errmsg=c) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n end"}, {"sha": "5e4c73ffe1a2f93d3ee6e40f4472719d3fc2ba6c", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_3.f90", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea549356d388607081f1a83ebac557259314d62/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_3.f90?ref=fea549356d388607081f1a83ebac557259314d62", "patch": "@@ -0,0 +1,107 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+!\n+! LOCK/LOCK_TYPE checks \n+!\n+subroutine extends()\n+use iso_fortran_env\n+type t\n+end type t\n+type, extends(t) :: t2 ! { dg-error \"coarray component, parent type .t. shall also have one\" }\n+  type(lock_type), allocatable :: c(:)[:]\n+end type t2\n+end subroutine extends\n+\n+module m\n+  use iso_fortran_env\n+\n+  type t\n+    type(lock_type), allocatable :: x(:)[:]\n+  end type t\n+\n+  type t2\n+    type(lock_type), allocatable :: x\n+  end type t2\n+end module m\n+\n+subroutine sub(x)\n+  use iso_fortran_env\n+  type(lock_type), intent(out) :: x[*] ! OK\n+end subroutine sub\n+\n+subroutine sub1(x) ! { dg-error \"is INTENT.OUT. and can thus not be an allocatable coarray or have coarray components\" }\n+  use iso_fortran_env\n+  type(lock_type), allocatable, intent(out) :: x(:)[:]\n+end subroutine sub1\n+\n+subroutine sub2(x) ! { dg-error \"is INTENT.OUT. and can thus not be an allocatable coarray or have coarray components\" }\n+  use m\n+  type(t), intent(out) :: x\n+end subroutine sub2\n+\n+subroutine sub3(x) ! { dg-error \"with coarray component shall be a nonpointer, nonallocatable scalar\" }\n+  use m\n+  type(t), intent(inout) :: x[*]\n+end subroutine sub3\n+\n+subroutine sub4(x)\n+  use m\n+  type(t2), intent(inout) :: x[*] ! OK\n+end subroutine sub4\n+\n+subroutine lock_test\n+  use iso_fortran_env\n+  type t\n+  end type t\n+  type(lock_type) :: lock ! { dg-error \"type LOCK_TYPE must be a coarray\" }\n+end subroutine lock_test\n+\n+subroutine lock_test2\n+  use iso_fortran_env\n+  implicit none\n+  type t\n+  end type t\n+  type(t) :: x\n+  type(lock_type), save :: lock[*],lock2(2)[*]\n+  lock(t) ! { dg-error \"Syntax error in LOCK statement\" }\n+  lock(x) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n+  lock(lock)\n+  lock(lock2(1))\n+  lock(lock2) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n+  lock(lock[1]) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n+end subroutine lock_test2\n+\n+\n+subroutine lock_test3\n+  use iso_fortran_env\n+  type(lock_type), save :: a[*], b[*]\n+  a = b ! { dg-error \"LOCK_TYPE in variable definition context\" }\n+  b = lock_type() ! { dg-error \"LOCK_TYPE in variable definition context\" }\n+  print *, a ! { dg-error \"cannot have PRIVATE components\" }\n+end subroutine lock_test3\n+\n+\n+subroutine lock_test4\n+  use iso_fortran_env\n+  type(lock_type), allocatable :: A(:)[:]\n+  logical :: ob\n+  allocate(A(1)[*])\n+  lock(A(1), acquired_lock=ob)\n+  unlock(A(1))\n+  deallocate(A)\n+end subroutine lock_test4\n+\n+\n+subroutine argument_check()\n+  use iso_fortran_env\n+  type(lock_type), SAVE :: ll[*]\n+  call no_interface(ll) ! { dg-error \"Actual argument of LOCK_TYPE or with LOCK_TYPE component at .1. requires an explicit interface\" }\n+  call test(ll) ! { dg-error \"non-INTENT.INOUT. dummy .x. at .1., which is LOCK_TYPE or has a LOCK_TYPE component\" }\n+contains\n+  subroutine test(x)\n+    type(lock_type), intent(in) :: x[*]\n+  end subroutine test\n+end subroutine argument_check\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}