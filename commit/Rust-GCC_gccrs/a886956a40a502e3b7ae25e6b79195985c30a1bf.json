{"sha": "a886956a40a502e3b7ae25e6b79195985c30a1bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg4Njk1NmE0MGE1MDJlM2I3YWUyNWU2Yjc5MTk1OTg1YzMwYTFiZg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-09-10T18:02:02Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-09-10T18:02:02Z"}, "message": "2002-09-10  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/SocketImpl.java\n\t(connect): New method.\n\t(supportsUrgentData): New method.\n\t(sendUrgentData): New method.\n\t* java/net/PlainSocketImpl.java\n\t(connect): One new method and two new implementation.\n\t(sendUrgentData): New method.\n\t* java/natPlainSocketImpl.cc\n\t(connect): Arguments changed, added support for timeouts.\n\t(getOption): Another __java_boolean to jboolean.\n\nFrom-SVN: r57009", "tree": {"sha": "efa74de037bafc64f9022b0f9ef627af5465a3cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efa74de037bafc64f9022b0f9ef627af5465a3cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a886956a40a502e3b7ae25e6b79195985c30a1bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a886956a40a502e3b7ae25e6b79195985c30a1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a886956a40a502e3b7ae25e6b79195985c30a1bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a886956a40a502e3b7ae25e6b79195985c30a1bf/comments", "author": null, "committer": null, "parents": [{"sha": "bfae804050ac712d29b556ea0cd1f6e06199ae12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfae804050ac712d29b556ea0cd1f6e06199ae12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfae804050ac712d29b556ea0cd1f6e06199ae12"}], "stats": {"total": 130, "additions": 118, "deletions": 12}, "files": [{"sha": "9ba93259a1f11ecff6f44d5f57227229938b29e7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a886956a40a502e3b7ae25e6b79195985c30a1bf", "patch": "@@ -1,3 +1,16 @@\n+2002-09-10  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/SocketImpl.java\n+\t(connect): New method.\n+\t(supportsUrgentData): New method.\n+\t(sendUrgentData): New method.\n+\t* java/net/PlainSocketImpl.java\n+\t(connect): One new method and two new implementation.\n+\t(sendUrgentData): New method.\n+\t* java/natPlainSocketImpl.cc\n+\t(connect): Arguments changed, added support for timeouts.\n+\t(getOption): Another __java_boolean to jboolean.\n+\n 2002-09-07  Adam Megacz <adam@xwt.org>\n \n \t* java/net/natPlainDatagramSocket.cc: include ws2tcpip.h for"}, {"sha": "2b65ba08002d2fd3dc608f086e01f6c34c9ae882", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=a886956a40a502e3b7ae25e6b79195985c30a1bf", "patch": "@@ -67,10 +67,15 @@ class PlainSocketImpl extends SocketImpl\n \n   protected void connect (String host, int port) throws IOException\n   {\n-    connect(InetAddress.getByName(host), port);\n+    connect (new InetSocketAddress (InetAddress.getByName(host), port), 0);\n   }\n \n-  protected native void connect (InetAddress host, int port)\n+  protected void connect (InetAddress host, int port) throws IOException\n+  {\n+    connect (new InetSocketAddress (host, port), 0);\n+  }\n+\n+  protected native void connect (SocketAddress addr, int timeout)\n     throws IOException;\n \n   protected native void bind (InetAddress host, int port) throws IOException;\n@@ -88,6 +93,8 @@ protected void accept (SocketImpl s) throws IOException\n \n   protected native void close () throws IOException;\n \n+  protected native void sendUrgentData(int data)\n+    throws IOException;\n \n   // Stream handling.\n "}, {"sha": "1c9049950e561568092c528f8640970f5883530f", "filename": "libjava/java/net/SocketImpl.java", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2Fjava%2Fnet%2FSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2Fjava%2Fnet%2FSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImpl.java?ref=a886956a40a502e3b7ae25e6b79195985c30a1bf", "patch": "@@ -119,6 +119,21 @@ public SocketImpl()\n   protected abstract void connect(InetAddress host, int port)\n     throws IOException;\n \n+  /**\n+   * Connects to the socket to the host specified in address. This\n+   * method blocks until successful connected or the timeout occurs.\n+   * A timeout of zero means no timout.\n+   *\n+   * @param address Data of remote host\n+   * @param timeout time to wait to stop connecting\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  protected abstract void connect(SocketAddress address, int timeout)\n+    throws IOException;\n+\n   /**\n    * Binds to the specified port on the specified addr.  Note that this addr\n    * must represent a local IP address.\n@@ -214,6 +229,31 @@ protected abstract void connect(InetAddress host, int port)\n    */\n   protected int getPort() { return port; }\n \n+  /**\n+   * Returns true or false when this socket supports sending urgent data\n+   * or not.\n+   *\n+   * @since 1.4\n+   */\n+  protected boolean supportsUrgentData()\n+  {\n+    // This method has to be overwritten by socket classes that support\n+    // sending urgend data.\n+    return false;\n+  }\n+  \n+  /**\n+   * Sends one byte of urgent data to the socket.\n+   *\n+   * @param data The byte to send, the low eight bits of it\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  protected abstract void sendUrgentData(int data)\n+    throws IOException;\n+  \n   /**\n    * Returns the local port this socket is bound to\n    *"}, {"sha": "37813cbcc19ee64fac77219286e579ea2b41662e", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a886956a40a502e3b7ae25e6b79195985c30a1bf/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=a886956a40a502e3b7ae25e6b79195985c30a1bf", "patch": "@@ -118,7 +118,9 @@ _Jv_accept (int fd, struct sockaddr *addr, socklen_t *addrlen)\n #include <java/net/ConnectException.h>\n #include <java/net/PlainSocketImpl.h>\n #include <java/net/InetAddress.h>\n+#include <java/net/InetSocketAddress.h>\n #include <java/net/SocketException.h>\n+#include <java/net/SocketTimeoutException.h>\n #include <java/lang/InternalError.h>\n #include <java/lang/Object.h>\n #include <java/lang/Boolean.h>\n@@ -146,7 +148,7 @@ java::net::PlainSocketImpl::bind (java::net::InetAddress *, jint)\n }\n \n void\n-java::net::PlainSocketImpl::connect (java::net::InetAddress *, jint)\n+java::net::PlainSocketImpl::connect (java::net::SocketAddress *, jint)\n {\n   throw new ConnectException (\n     JvNewStringLatin1 (\"SocketImpl.connect: unimplemented\"));\n@@ -208,6 +210,13 @@ java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n     JvNewStringLatin1 (\"SocketImpl.write: unimplemented\"));\n }\n \n+void\n+java::net::PlainSocketImpl::sendUrgentData(jint data)\n+{\n+  throw new SocketException (\n+    JvNewStringLatin1 (\"SocketImpl.sendUrgentData: unimplemented\"));\n+}\n+\n jint\n java::net::PlainSocketImpl::available(void)\n {\n@@ -316,8 +325,13 @@ java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n }\n \n void\n-java::net::PlainSocketImpl::connect (java::net::InetAddress *host, jint rport)\n+java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n+\t\t                     jint timeout)\n {\n+  java::net::InetSocketAddress *tmp = (java::net::InetSocketAddress*) addr;\n+  java::net::InetAddress *host = tmp->getAddress();\n+  jint rport = tmp->getPort();\n+\t\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n   jbyteArray haddress = host->addr;\n@@ -343,8 +357,34 @@ java::net::PlainSocketImpl::connect (java::net::InetAddress *host, jint rport)\n   else\n     throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (_Jv_connect (fnum, ptr, len) != 0)\n-    goto error;\n+  if (timeout > 0)\n+    {\n+      int flags = ::fcntl (fnum, F_GETFL);\n+      ::fcntl (fnum, F_SETFL, flags | O_NONBLOCK);\n+      \n+      if ((_Jv_connect (fnum, ptr, len) != 0) && (errno != EINPROGRESS))\n+        goto error;\n+\n+      fd_set rset;\n+      struct timeval tv;\n+      FD_ZERO(&rset);\n+      FD_SET(fnum, &rset);\n+      tv.tv_sec = timeout / 1000;\n+      tv.tv_usec = (timeout % 1000) * 1000;\n+      int retval;\n+      \n+      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+\tgoto error;\n+      else if (retval == 0)\n+\tthrow new java::net::SocketTimeoutException ( \n+\t         JvNewStringUTF(\"Connect timed out\"));\n+    }\n+  else\n+    {\n+      if (_Jv_connect (fnum, ptr, len) != 0)\n+        goto error;\n+    }\n+\n   address = host;\n   port = rport;\n   // A bind may not have been done on this socket; if so, set localport now.\n@@ -518,6 +558,12 @@ java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n     }\n }\n \n+void\n+java::net::PlainSocketImpl::sendUrgentData (jint)\n+{\n+  throw new SocketException (JvNewStringLatin1 (\n+    \"PlainSocketImpl: sending of urgent data not supported by this socket\"));\n+}\n \n // Read a single byte from the socket.\n jint\n@@ -756,10 +802,10 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n \t\n       case _Jv_SO_OOBINLINE_ :\n         if (::setsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n-\t    val_len) != 0)\n-\t  goto error;\n-\tbreak;\n-\t\n+            val_len) != 0)\n+          goto error;\n+        break;\n+\n       case _Jv_SO_LINGER_ :\n #ifdef SO_LINGER\n         struct linger l_val;\n@@ -877,13 +923,13 @@ java::net::PlainSocketImpl::getOption (jint optID)\n         if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n \t   &val_len) != 0)\n \t  goto error;    \n-        return new java::lang::Boolean ((__java_boolean)val);\n+        return new java::lang::Boolean ((jboolean)val);\n \t\n       case _Jv_SO_OOBINLINE_ :\n         if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n \t    &val_len) != 0)\n \t  goto error;    \n-        return new java::lang::Boolean ((__java_boolean)val);\n+        return new java::lang::Boolean ((jboolean)val);\n \t\n       case _Jv_SO_RCVBUF_ :\n       case _Jv_SO_SNDBUF_ :"}]}