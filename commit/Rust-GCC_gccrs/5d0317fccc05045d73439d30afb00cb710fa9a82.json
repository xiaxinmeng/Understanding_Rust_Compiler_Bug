{"sha": "5d0317fccc05045d73439d30afb00cb710fa9a82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwMzE3ZmNjYzA1MDQ1ZDczNDM5ZDMwYWZiMDBjYjcxMGZhOWE4Mg==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2005-07-20T23:32:01Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2005-07-20T23:32:01Z"}, "message": "ffi.c (ffi_call): Handle small structures correctly.\n\n\t* src/sh/ffi.c (ffi_call): Handle small structures correctly.\n\tRemove empty line.\n\t* src/sh64/ffi.c (simple_type): Remove.\n\t(return_type): Handle small structures correctly.\n\t(ffi_prep_args): Likewise.\n\t(ffi_call): Likewise.\n\t(ffi_closure_helper_SYSV): Likewise.\n\t* src/sh64/sysv.S (ffi_call_SYSV): Handle 1, 2 and 4-byte return.\n\tEmit position independent code if PIC and remove wrong datalabel\n\tprefixes from EH data.\n\nFrom-SVN: r102210", "tree": {"sha": "e730225b648228a800a11c7a0182daab21d52360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e730225b648228a800a11c7a0182daab21d52360"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d0317fccc05045d73439d30afb00cb710fa9a82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0317fccc05045d73439d30afb00cb710fa9a82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d0317fccc05045d73439d30afb00cb710fa9a82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d0317fccc05045d73439d30afb00cb710fa9a82/comments", "author": null, "committer": null, "parents": [{"sha": "3a664c1c0057af42505542782c1a49eecce5597e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a664c1c0057af42505542782c1a49eecce5597e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a664c1c0057af42505542782c1a49eecce5597e"}], "stats": {"total": 173, "additions": 119, "deletions": 54}, "files": [{"sha": "bd6a638ac5fde7c07be7de7d988723f7d0cae856", "filename": "libffi/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=5d0317fccc05045d73439d30afb00cb710fa9a82", "patch": "@@ -1,3 +1,16 @@\n+2005-07-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* src/sh/ffi.c (ffi_call): Handle small structures correctly.\n+\tRemove empty line.\n+\t* src/sh64/ffi.c (simple_type): Remove.\n+\t(return_type): Handle small structures correctly.\n+\t(ffi_prep_args): Likewise.\n+\t(ffi_call): Likewise.\n+\t(ffi_closure_helper_SYSV): Likewise.\n+\t* src/sh64/sysv.S (ffi_call_SYSV): Handle 1, 2 and 4-byte return.\n+\tEmit position independent code if PIC and remove wrong datalabel\n+\tprefixes from EH data.\n+\n 2005-07-19  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* Makefile.am (nodist_libffi_la_SOURCES): Add POWERPC_FREEBSD."}, {"sha": "ddf562f048a05037c839cf233492415f52ee2130", "filename": "libffi/src/sh/ffi.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2Fsrc%2Fsh%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2Fsrc%2Fsh%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh%2Fffi.c?ref=5d0317fccc05045d73439d30afb00cb710fa9a82", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2002, 2003, 2004 Kaz Kojima\n+   ffi.c - Copyright (c) 2002, 2003, 2004, 2005 Kaz Kojima\n    \n    SuperH Foreign Function Interface \n \n@@ -427,14 +427,18 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \t      /*@dependent@*/ void **avalue)\n {\n   extended_cif ecif;\n+  UINT64 trvalue;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n   \n   /* If the return value is a struct and we don't have a return\t*/\n   /* value address then we need to make one\t\t        */\n \n-  if ((rvalue == NULL) && \n+  if (cif->rtype->type == FFI_TYPE_STRUCT\n+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)\n+    ecif.rvalue = &trvalue;\n+  else if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n       /*@-sysunrecog@*/\n@@ -443,7 +447,6 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n     }\n   else\n     ecif.rvalue = rvalue;\n-    \n \n   switch (cif->abi) \n     {\n@@ -457,6 +460,11 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n       FFI_ASSERT(0);\n       break;\n     }\n+\n+  if (rvalue\n+      && cif->rtype->type == FFI_TYPE_STRUCT\n+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)\n+    memcpy (rvalue, &trvalue, cif->rtype->size);\n }\n \n extern void ffi_closure_SYSV (void);"}, {"sha": "abf3f0d71ae30a0c34d799e09e9a0af8b16a6aad", "filename": "libffi/src/sh64/ffi.c", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2Fsrc%2Fsh64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2Fsrc%2Fsh64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh64%2Fffi.c?ref=5d0317fccc05045d73439d30afb00cb710fa9a82", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2003 Kaz Kojima\n+   ffi.c - Copyright (c) 2003, 2004 Kaz Kojima\n    \n    SuperH SHmedia Foreign Function Interface \n \n@@ -31,48 +31,21 @@\n #define NGREGARG 8\n #define NFREGARG 12\n \n-/* If the structure has essentialy an unique element, return its type.  */\n-static int\n-simple_type (ffi_type *arg)\n-{\n-  if (arg->type != FFI_TYPE_STRUCT)\n-    return arg->type;\n-  else if (arg->elements[1])\n-    return FFI_TYPE_STRUCT;\n-\n-  return simple_type (arg->elements[0]);\n-}\n-\n static int\n return_type (ffi_type *arg)\n {\n-  unsigned short type;\n \n   if (arg->type != FFI_TYPE_STRUCT)\n     return arg->type;\n \n-  type = simple_type (arg->elements[0]);\n-  if (! arg->elements[1])\n-    {\n-      switch (type)\n-\t{\n-\tcase FFI_TYPE_SINT8:\n-\tcase FFI_TYPE_UINT8:\n-\tcase FFI_TYPE_SINT16:\n-\tcase FFI_TYPE_UINT16:\n-\tcase FFI_TYPE_SINT32:\n-\tcase FFI_TYPE_UINT32:\n-\tcase FFI_TYPE_SINT64:\n-\tcase FFI_TYPE_UINT64:\n-\t  return FFI_TYPE_UINT64;\n-\n-\tdefault:\n-\t  return type;\n-\t}\n-    }\n-\n   /* gcc uses r2 if the result can be packed in on register.  */\n-  if (arg->size <= sizeof (UINT64))\n+  if (arg->size <= sizeof (UINT8))\n+    return FFI_TYPE_UINT8;\n+  else if (arg->size <= sizeof (UINT16))\n+    return FFI_TYPE_UINT16;\n+  else if (arg->size <= sizeof (UINT32))\n+    return FFI_TYPE_UINT32;\n+  else if (arg->size <= sizeof (UINT64))\n     return FFI_TYPE_UINT64;\n \n   return FFI_TYPE_STRUCT;\n@@ -105,8 +78,10 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n   for (i = 0, p_arg = ecif->cif->arg_types; i < avn; i++, p_arg++, p_argv++)\n     {\n       size_t z;\n+      int align;\n \n       z = (*p_arg)->size;\n+      align = (*p_arg)->alignment;\n       if (z < sizeof (UINT32))\n \t{\n \t  switch ((*p_arg)->type)\n@@ -128,20 +103,39 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \t      break;\n   \n \t    case FFI_TYPE_STRUCT:\n-\t      *(UINT64 *) argp = (UINT64) *(UINT32 *)(*p_argv);\n+\t      memcpy (argp, *p_argv, z);\n \t      break;\n \n \t    default:\n \t      FFI_ASSERT(0);\n \t    }\n \t  argp += sizeof (UINT64);\n \t}\n-      else if (z == sizeof (UINT32))\n+      else if (z == sizeof (UINT32) && align == sizeof (UINT32))\n \t{\n-\t  *(UINT64 *) argp = (UINT64) *(UINT32 *) (*p_argv);\n+\t  switch ((*p_arg)->type)\n+\t    {\n+\t    case FFI_TYPE_INT:\n+\t    case FFI_TYPE_SINT32:\n+\t      *(SINT64 *) argp = (SINT64) *(SINT32 *) (*p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_FLOAT:\n+\t    case FFI_TYPE_POINTER:\n+\t    case FFI_TYPE_UINT32:\n+\t    case FFI_TYPE_STRUCT:\n+\t      *(UINT64 *) argp = (UINT64) *(UINT32 *) (*p_argv);\n+\t      break;\n+\n+\t    default:\n+\t      FFI_ASSERT(0);\n+\t      break;\n+\t    }\n \t  argp += sizeof (UINT64);\n \t}\n-      else if (z == sizeof (UINT64))\n+      else if (z == sizeof (UINT64)\n+\t       && align == sizeof (UINT64)\n+\t       && ((int) *p_argv & (sizeof (UINT64) - 1)) == 0)\n \t{\n \t  *(UINT64 *) argp = *(UINT64 *) (*p_argv);\n \t  argp += sizeof (UINT64);\n@@ -254,14 +248,18 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \t      /*@dependent@*/ void **avalue)\n {\n   extended_cif ecif;\n+  UINT64 trvalue;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n   \n   /* If the return value is a struct and we don't have a return\t*/\n   /* value address then we need to make one\t\t        */\n \n-  if ((rvalue == NULL) && \n+  if (cif->rtype->type == FFI_TYPE_STRUCT\n+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)\n+    ecif.rvalue = &trvalue;\n+  else if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n       /*@-sysunrecog@*/\n@@ -283,6 +281,11 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n       FFI_ASSERT(0);\n       break;\n     }\n+\n+  if (rvalue\n+      && cif->rtype->type == FFI_TYPE_STRUCT\n+      && return_type (cif->rtype) != FFI_TYPE_STRUCT)\n+    memcpy (rvalue, &trvalue, cif->rtype->size);\n }\n \n extern void ffi_closure_SYSV (void);\n@@ -353,7 +356,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure, UINT64 *rvalue,\n \n   /* Copy the caller's structure return value address so that the closure\n      returns the data directly to the caller.  */\n-  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+  if (return_type (cif->rtype) == FFI_TYPE_STRUCT)\n     {\n       rvalue = *pgr;\n       greg = 1;\n@@ -443,6 +446,6 @@ ffi_closure_helper_SYSV (ffi_closure *closure, UINT64 *rvalue,\n   (closure->fun) (cif, rvalue, avalue, closure->user_data);\n \n   /* Tell ffi_closure_SYSV how to perform return type promotions.  */\n-  return cif->rtype->type;\n+  return return_type (cif->rtype);\n }\n "}, {"sha": "19f1b51b9a75885ed8c681a63cc379ad7c45f6cb", "filename": "libffi/src/sh64/sysv.S", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2Fsrc%2Fsh64%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d0317fccc05045d73439d30afb00cb710fa9a82/libffi%2Fsrc%2Fsh64%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh64%2Fsysv.S?ref=5d0317fccc05045d73439d30afb00cb710fa9a82", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   sysv.S - Copyright (c) 2003 Kaz Kojima\n+   sysv.S - Copyright (c) 2003, 2004 Kaz Kojima\n    \n    SuperH SHmedia Foreign Function Interface \n \n@@ -64,8 +64,9 @@ ENTRY(ffi_call_SYSV)\n \tst.q\tr15, 8, r28\n \tst.l\tr15, 4, r18\n \tst.l\tr15, 0, r14\n-\tadd.l\tr15, r63, r14\n .LCFI1:\n+\tadd.l\tr15, r63, r14\n+.LCFI2:\n #\tadd\tr4, r63, r28\n \tadd\tr5, r63, r29\n \tadd\tr6, r63, r30\n@@ -252,10 +253,17 @@ ENTRY(ffi_call_SYSV)\n \tpt/l\t.L_epilogue, tr4\n \n \tbeqi/l\tr29, FFI_TYPE_INT, tr0\n+\tbeqi/l\tr29, FFI_TYPE_UINT32, tr0\n \tbeqi/l\tr29, FFI_TYPE_SINT64, tr1\n \tbeqi/l\tr29, FFI_TYPE_UINT64, tr1\n \tbeqi/l\tr29, FFI_TYPE_DOUBLE, tr2\n \tbeqi/l\tr29, FFI_TYPE_FLOAT, tr3\n+\n+\tpt/l\t.L_ret_q, tr0\n+\tpt/l\t.L_ret_h, tr1\n+\n+\tbeqi/l\tr29, FFI_TYPE_UINT8, tr0\n+\tbeqi/l\tr29, FFI_TYPE_UINT16, tr1\n \tblink\ttr4, r63\n \n .L_ret_d:\n@@ -270,6 +278,14 @@ ENTRY(ffi_call_SYSV)\n \tfst.s\tr31, OFS_FLT, fr0\n \tblink\ttr4, r63\n \n+.L_ret_q:\n+\tst.b\tr31, 0, r2\n+\tblink\ttr4, r63\n+\n+.L_ret_h:\n+\tst.w\tr31, 0, r2\n+\tblink\ttr4, r63\n+\n .L_ret_i:\n \tst.l\tr31, 0, r2\n \t# Fall\n@@ -297,12 +313,13 @@ ENTRY(ffi_call_SYSV)\n ENTRY(ffi_closure_SYSV)\n .LFB2:\n \taddi.l\tr15, -136, r15\n-.LCFI2:\n+.LCFI3:\n \tst.l\tr15, 12, r18\n \tst.l\tr15, 8, r14\n \tst.l\tr15, 4, r12\n+.LCFI4:\n \tadd\tr15, r63, r14\n-.LCFI3:\n+.LCFI5:\n \t/* Stack layout:\t\n \t   ...\n \t   64 bytes (register parameters)\n@@ -418,12 +435,18 @@ __FRAME_BEGIN__:\n .LSCIE1:\n \t.4byte\t0x0\t/* CIE Identifier Tag */\n \t.byte\t0x1\t/* CIE Version */\n+#ifdef PIC\n \t.ascii \"zR\\0\"\t/* CIE Augmentation */\n+#else\n+\t.byte\t0x0\t/* CIE Augmentation */\n+#endif\n \t.uleb128 0x1\t/* CIE Code Alignment Factor */\n \t.sleb128 -4\t/* CIE Data Alignment Factor */\n \t.byte\t0x12\t/* CIE RA Column */\n+#ifdef PIC\n \t.uleb128 0x1\t/* Augmentation size */\n-\t.byte\t0x1b\t/* FDE Encoding (pcrel sdata4) */\n+\t.byte\t0x10\t/* FDE Encoding (pcrel) */\n+#endif\n \t.byte\t0xc\t/* DW_CFA_def_cfa */\n \t.uleb128 0xf\n \t.uleb128 0x0\n@@ -433,8 +456,15 @@ __FRAME_BEGIN__:\n \t.4byte\tdatalabel .LEFDE1-datalabel .LASFDE1\t/* FDE Length */\n .LASFDE1:\n \t.4byte\tdatalabel .LASFDE1-datalabel __FRAME_BEGIN__\n-\t.4byte\tdatalabel .LFB1-.\t\t/* FDE initial location */\n+#ifdef PIC\n+\t.4byte\t.LFB1-.\t/* FDE initial location */\n+#else\n+\t.4byte\t.LFB1\t/* FDE initial location */\n+#endif\n \t.4byte\tdatalabel .LFE1-datalabel .LFB1\t/* FDE address range */\n+#ifdef PIC\n+\t.uleb128 0x0\t/* Augmentation size */\n+#endif\n \t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n \t.4byte\tdatalabel .LCFI0-datalabel .LFB1\n \t.byte\t0xe\t/* DW_CFA_def_cfa_offset */\n@@ -455,6 +485,8 @@ __FRAME_BEGIN__:\n \t.uleb128 0x4\n \t.byte   0xa0\t/* DW_CFA_offset, column 0x20 */\n \t.uleb128 0x2\n+\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n+\t.4byte\tdatalabel .LCFI2-datalabel .LCFI1\n \t.byte\t0xd\t/* DW_CFA_def_cfa_register */\n \t.uleb128 0xe\n \t.align\t2\n@@ -464,20 +496,29 @@ __FRAME_BEGIN__:\n \t.4byte\tdatalabel .LEFDE3-datalabel .LASFDE3\t/* FDE Length */\n .LASFDE3:\n \t.4byte\tdatalabel .LASFDE3-datalabel __FRAME_BEGIN__\n-\t.4byte\tdatalabel .LFB2-.\t\t/* FDE initial location */\n+#ifdef PIC\n+\t.4byte\t.LFB2-.\t/* FDE initial location */\n+#else\n+\t.4byte\t.LFB2\t/* FDE initial location */\n+#endif\n \t.4byte\tdatalabel .LFE2-datalabel .LFB2\t/* FDE address range */\n+#ifdef PIC\n+\t.uleb128 0x0\t/* Augmentation size */\n+#endif\n \t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.4byte\tdatalabel .LCFI2-datalabel .LFB2\n+\t.4byte\tdatalabel .LCFI3-datalabel .LFB2\n \t.byte\t0xe\t/* DW_CFA_def_cfa_offset */\n \t.uleb128 0x88\n \t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.4byte\tdatalabel .LCFI3-datalabel .LCFI2\n+\t.4byte\tdatalabel .LCFI4-datalabel .LCFI3\n \t.byte   0x8c\t/* DW_CFA_offset, column 0xc */\n \t.uleb128 0x21\n \t.byte   0x8e\t/* DW_CFA_offset, column 0xe */\n \t.uleb128 0x20\n \t.byte   0x92\t/* DW_CFA_offset, column 0x12 */\n \t.uleb128 0x1f\n+\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n+\t.4byte\tdatalabel .LCFI5-datalabel .LCFI4\n \t.byte\t0xd\t/* DW_CFA_def_cfa_register */\n \t.uleb128 0xe\n \t.align\t2"}]}