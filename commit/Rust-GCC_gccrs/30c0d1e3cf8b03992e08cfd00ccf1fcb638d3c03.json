{"sha": "30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBjMGQxZTNjZjhiMDM5OTJlMDhjZmQwMGNjZjFmY2I2MzhkM2MwMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-21T11:34:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-21T11:34:00Z"}, "message": "tree-vectorizer.h (_slp_tree::ops): New member.\n\n2019-10-21  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_tree::ops): New member.\n\t(SLP_TREE_SCALAR_OPS): New.\n\t(vect_get_slp_defs): Adjust prototype.\n\t* tree-vect-slp.c (vect_free_slp_tree): Release\n\tSLP_TREE_SCALAR_OPS.\n\t(vect_create_new_slp_node): Initialize it.  New overload for\n\tinitializing by an operands array.\n\t(_slp_oprnd_info::ops): New member.\n\t(vect_create_oprnd_info): Initialize it.\n\t(vect_free_oprnd_info): Release it.\n\t(vect_get_and_check_slp_defs): Populate the operands array.\n\tDo not swap operands in the IL when not necessary.\n\t(vect_build_slp_tree_2): Build SLP nodes for invariant operands.\n\tRecord SLP_TREE_SCALAR_OPS for all invariant nodes.  Also\n\tswap operands in the operands array.  Do not swap operands in\n\tthe IL.\n\t(vect_slp_rearrange_stmts): Re-arrange SLP_TREE_SCALAR_OPS as well.\n\t(vect_gather_slp_loads): Fix.\n\t(vect_detect_hybrid_slp_stmts): Likewise.\n\t(vect_slp_analyze_node_operations_1): Search for a internal\n\tdef child for computing reduction SLP_TREE_NUMBER_OF_VEC_STMTS.\n\t(vect_slp_analyze_node_operations): Skip ops-only stmts for\n\tthe def-type push/pop dance.\n\t(vect_get_constant_vectors): Compute number_of_vectors here.\n\tUse SLP_TREE_SCALAR_OPS and simplify greatly.\n\t(vect_get_slp_vect_defs): Use gimple_get_lhs also for PHIs.\n\t(vect_get_slp_defs): Simplify greatly.\n\t* tree-vect-loop.c (vectorize_fold_left_reduction): Simplify.\n\t(vect_transform_reduction): Likewise.\n\t* tree-vect-stmts.c (vect_get_vec_defs): Simplify.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_comparison): Likewise.\n\nFrom-SVN: r277241", "tree": {"sha": "b33b83c1349ea50a692fcf52dd3a36aace307184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b33b83c1349ea50a692fcf52dd3a36aace307184"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae7f3143a3876378d051e64c8e68718f27c41075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae7f3143a3876378d051e64c8e68718f27c41075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae7f3143a3876378d051e64c8e68718f27c41075"}], "stats": {"total": 486, "additions": 206, "deletions": 280}, "files": [{"sha": "4139f7f0d6feadaa0378c1d75beea49c4ce229aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "patch": "@@ -1,3 +1,41 @@\n+2019-10-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_slp_tree::ops): New member.\n+\t(SLP_TREE_SCALAR_OPS): New.\n+\t(vect_get_slp_defs): Adjust prototype.\n+\t* tree-vect-slp.c (vect_free_slp_tree): Release\n+\tSLP_TREE_SCALAR_OPS.\n+\t(vect_create_new_slp_node): Initialize it.  New overload for\n+\tinitializing by an operands array.\n+\t(_slp_oprnd_info::ops): New member.\n+\t(vect_create_oprnd_info): Initialize it.\n+\t(vect_free_oprnd_info): Release it.\n+\t(vect_get_and_check_slp_defs): Populate the operands array.\n+\tDo not swap operands in the IL when not necessary.\n+\t(vect_build_slp_tree_2): Build SLP nodes for invariant operands.\n+\tRecord SLP_TREE_SCALAR_OPS for all invariant nodes.  Also\n+\tswap operands in the operands array.  Do not swap operands in\n+\tthe IL.\n+\t(vect_slp_rearrange_stmts): Re-arrange SLP_TREE_SCALAR_OPS as well.\n+\t(vect_gather_slp_loads): Fix.\n+\t(vect_detect_hybrid_slp_stmts): Likewise.\n+\t(vect_slp_analyze_node_operations_1): Search for a internal\n+\tdef child for computing reduction SLP_TREE_NUMBER_OF_VEC_STMTS.\n+\t(vect_slp_analyze_node_operations): Skip ops-only stmts for\n+\tthe def-type push/pop dance.\n+\t(vect_get_constant_vectors): Compute number_of_vectors here.\n+\tUse SLP_TREE_SCALAR_OPS and simplify greatly.\n+\t(vect_get_slp_vect_defs): Use gimple_get_lhs also for PHIs.\n+\t(vect_get_slp_defs): Simplify greatly.\n+\t* tree-vect-loop.c (vectorize_fold_left_reduction): Simplify.\n+\t(vect_transform_reduction): Likewise.\n+\t* tree-vect-stmts.c (vect_get_vec_defs): Simplify.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_comparison): Likewise.\n+\n 2019-10-21  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92161"}, {"sha": "9efb797cb77b37c17b614ba58aa65c9b18c7184c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "patch": "@@ -5312,10 +5312,7 @@ vectorize_fold_left_reduction (stmt_vec_info stmt_info,\n   if (slp_node)\n     {\n       auto_vec<vec<tree> > vec_defs (2);\n-      auto_vec<tree> sops(2);\n-      sops.quick_push (ops[0]);\n-      sops.quick_push (ops[1]);\n-      vect_get_slp_defs (sops, slp_node, &vec_defs);\n+      vect_get_slp_defs (slp_node, &vec_defs);\n       vec_oprnds0.safe_splice (vec_defs[1 - reduc_index]);\n       vec_defs[0].release ();\n       vec_defs[1].release ();\n@@ -6484,16 +6481,8 @@ vect_transform_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    {\n \t      /* Get vec defs for all the operands except the reduction index,\n \t\t ensuring the ordering of the ops in the vector is kept.  */\n-\t      auto_vec<tree, 3> slp_ops;\n \t      auto_vec<vec<tree>, 3> vec_defs;\n-\n-\t      slp_ops.quick_push (ops[0]);\n-\t      slp_ops.quick_push (ops[1]);\n-\t      if (op_type == ternary_op)\n-\t\tslp_ops.quick_push (ops[2]);\n-\n-\t      vect_get_slp_defs (slp_ops, slp_node, &vec_defs);\n-\n+\t      vect_get_slp_defs (slp_node, &vec_defs);\n \t      vec_oprnds0.safe_splice (vec_defs[0]);\n \t      vec_defs[0].release ();\n \t      vec_oprnds1.safe_splice (vec_defs[1]);"}, {"sha": "d482aa133d70787d33a3796f43789599b7302f0d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 154, "deletions": 225, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "patch": "@@ -79,6 +79,7 @@ vect_free_slp_tree (slp_tree node, bool final_p)\n \n   SLP_TREE_CHILDREN (node).release ();\n   SLP_TREE_SCALAR_STMTS (node).release ();\n+  SLP_TREE_SCALAR_OPS (node).release ();\n   SLP_TREE_VEC_STMTS (node).release ();\n   SLP_TREE_LOAD_PERMUTATION (node).release ();\n \n@@ -122,6 +123,7 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)\n \n   node = XNEW (struct _slp_tree);\n   SLP_TREE_SCALAR_STMTS (node) = scalar_stmts;\n+  SLP_TREE_SCALAR_OPS (node) = vNULL;\n   SLP_TREE_VEC_STMTS (node).create (0);\n   SLP_TREE_NUMBER_OF_VEC_STMTS (node) = 0;\n   SLP_TREE_CHILDREN (node).create (nops);\n@@ -138,6 +140,28 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts)\n   return node;\n }\n \n+/* Create an SLP node for OPS.  */\n+\n+static slp_tree\n+vect_create_new_slp_node (vec<tree> ops)\n+{\n+  slp_tree node;\n+\n+  node = XNEW (struct _slp_tree);\n+  SLP_TREE_SCALAR_STMTS (node) = vNULL;\n+  SLP_TREE_SCALAR_OPS (node) = ops;\n+  SLP_TREE_VEC_STMTS (node).create (0);\n+  SLP_TREE_NUMBER_OF_VEC_STMTS (node) = 0;\n+  SLP_TREE_CHILDREN (node) = vNULL;\n+  SLP_TREE_LOAD_PERMUTATION (node) = vNULL;\n+  SLP_TREE_TWO_OPERATORS (node) = false;\n+  SLP_TREE_DEF_TYPE (node) = vect_external_def;\n+  node->refcnt = 1;\n+  node->max_nunits = 1;\n+\n+  return node;\n+}\n+\n \n /* This structure is used in creation of an SLP tree.  Each instance\n    corresponds to the same operand in a group of scalar stmts in an SLP\n@@ -146,6 +170,8 @@ typedef struct _slp_oprnd_info\n {\n   /* Def-stmts for the operands.  */\n   vec<stmt_vec_info> def_stmts;\n+  /* Operands.  */\n+  vec<tree> ops;\n   /* Information about the first statement, its vector def-type, type, the\n      operand itself in case it's constant, and an indication if it's a pattern\n      stmt.  */\n@@ -170,6 +196,7 @@ vect_create_oprnd_info (int nops, int group_size)\n     {\n       oprnd_info = XNEW (struct _slp_oprnd_info);\n       oprnd_info->def_stmts.create (group_size);\n+      oprnd_info->ops.create (group_size);\n       oprnd_info->first_dt = vect_uninitialized_def;\n       oprnd_info->first_op_type = NULL_TREE;\n       oprnd_info->first_pattern = false;\n@@ -192,6 +219,7 @@ vect_free_oprnd_info (vec<slp_oprnd_info> &oprnds_info)\n   FOR_EACH_VEC_ELT (oprnds_info, i, oprnd_info)\n     {\n       oprnd_info->def_stmts.release ();\n+      oprnd_info->ops.release ();\n       XDELETE (oprnd_info);\n     }\n \n@@ -449,12 +477,15 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t{\n \tcase vect_constant_def:\n \tcase vect_external_def:\n+\t  oprnd_info->def_stmts.quick_push (NULL);\n+\t  oprnd_info->ops.quick_push (oprnd);\n \t  break;\n \n \tcase vect_reduction_def:\n \tcase vect_induction_def:\n \tcase vect_internal_def:\n \t  oprnd_info->def_stmts.quick_push (def_stmt_info);\n+\t  oprnd_info->ops.quick_push (oprnd);\n \t  break;\n \n \tdefault:\n@@ -484,6 +515,8 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \n       if (first_op_cond)\n \t{\n+\t  /* To get rid of this swapping we have to move the stmt code\n+\t     to the SLP tree as well (and gather it here per stmt).  */\n \t  gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n \t  tree cond = gimple_assign_rhs1 (stmt);\n \t  enum tree_code code = TREE_CODE (cond);\n@@ -508,10 +541,8 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t}\n       else\n \t{\n-\t  unsigned int op = commutative_op + first_op_idx;\n-\t  swap_ssa_operands (stmt_info->stmt,\n-\t\t\t     gimple_op_ptr (stmt_info->stmt, op),\n-\t\t\t     gimple_op_ptr (stmt_info->stmt, op + 1));\n+\t  /* Commutative ops need not reflect swapping, ops are in\n+\t     the SLP tree.  */\n \t}\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n@@ -1221,10 +1252,24 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n       unsigned old_tree_size = this_tree_size;\n       unsigned int j;\n \n+      if (oprnd_info->first_dt == vect_uninitialized_def)\n+\t{\n+\t  /* COND_EXPR have one too many eventually if the condition\n+\t     is a SSA name.  */\n+\t  gcc_assert (i == 3 && nops == 4);\n+\t  continue;\n+\t}\n+\n       if (oprnd_info->first_dt != vect_internal_def\n \t  && oprnd_info->first_dt != vect_reduction_def\n \t  && oprnd_info->first_dt != vect_induction_def)\n-        continue;\n+\t{\n+\t  slp_tree invnode = vect_create_new_slp_node (oprnd_info->ops);\n+\t  SLP_TREE_DEF_TYPE (invnode) = oprnd_info->first_dt;\n+\t  oprnd_info->ops = vNULL;\n+\t  children.safe_push (invnode);\n+\t  continue;\n+\t}\n \n       if ((child = vect_build_slp_tree (vinfo, oprnd_info->def_stmts,\n \t\t\t\t\tgroup_size, &this_max_nunits,\n@@ -1233,7 +1278,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t{\n \t  /* If we have all children of child built up from scalars then just\n \t     throw that away and build it up this node from scalars.  */\n-\t  if (!SLP_TREE_CHILDREN (child).is_empty ()\n+\t  if (is_a <bb_vec_info> (vinfo)\n+\t      && !SLP_TREE_CHILDREN (child).is_empty ()\n \t      /* ???  Rejecting patterns this way doesn't work.  We'd have to\n \t\t do extra work to cancel the pattern so the uses see the\n \t\t scalar version.  */\n@@ -1258,6 +1304,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t     \"scalars instead\\n\");\n \t\t  oprnd_info->def_stmts = vNULL;\n \t\t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n+\t\t  SLP_TREE_SCALAR_OPS (child) = oprnd_info->ops;\n+\t\t  oprnd_info->ops = vNULL;\n \t\t  ++this_tree_size;\n \t\t  children.safe_push (child);\n \t\t  continue;\n@@ -1290,7 +1338,9 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  this_tree_size++;\n \t  child = vect_create_new_slp_node (oprnd_info->def_stmts);\n \t  SLP_TREE_DEF_TYPE (child) = vect_external_def;\n+\t  SLP_TREE_SCALAR_OPS (child) = oprnd_info->ops;\n \t  children.safe_push (child);\n+\t  oprnd_info->ops = vNULL;\n \t  oprnd_info->def_stmts = vNULL;\n \t  continue;\n \t}\n@@ -1370,6 +1420,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t      {\n \t\tstd::swap (oprnds_info[0]->def_stmts[j],\n \t\t\t   oprnds_info[1]->def_stmts[j]);\n+\t\tstd::swap (oprnds_info[0]->ops[j],\n+\t\t\t   oprnds_info[1]->ops[j]);\n \t\tif (dump_enabled_p ())\n \t\t  dump_printf (MSG_NOTE, \"%d \", j);\n \t      }\n@@ -1382,34 +1434,10 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t\t    tem, npermutes,\n \t\t\t\t\t    &this_tree_size, bst_map)) != NULL)\n \t    {\n-\t      /* ... so if successful we can apply the operand swapping\n-\t\t to the GIMPLE IL.  This is necessary because for example\n-\t\t vect_get_slp_defs uses operand indexes and thus expects\n-\t\t canonical operand order.  This is also necessary even\n-\t\t if we end up building the operand from scalars as\n-\t\t we'll continue to process swapped operand two.  */\n-\t      for (j = 0; j < group_size; ++j)\n-\t\tgimple_set_plf (stmts[j]->stmt, GF_PLF_1, false);\n-\t      for (j = 0; j < group_size; ++j)\n-\t\tif (matches[j] == !swap_not_matching)\n-\t\t  {\n-\t\t    gassign *stmt = as_a <gassign *> (stmts[j]->stmt);\n-\t\t    /* Avoid swapping operands twice.  */\n-\t\t    if (gimple_plf (stmt, GF_PLF_1))\n-\t\t      continue;\n-\t\t    swap_ssa_operands (stmt, gimple_assign_rhs1_ptr (stmt),\n-\t\t\t\t       gimple_assign_rhs2_ptr (stmt));\n-\t\t    gimple_set_plf (stmt, GF_PLF_1, true);\n-\t\t  }\n-\t      /* Verify we swap all duplicates or none.  */\n-\t      if (flag_checking)\n-\t\tfor (j = 0; j < group_size; ++j)\n-\t\t  gcc_assert (gimple_plf (stmts[j]->stmt, GF_PLF_1)\n-\t\t\t      == (matches[j] == !swap_not_matching));\n-\n \t      /* If we have all children of child built up from scalars then\n \t\t just throw that away and build it up this node from scalars.  */\n-\t      if (!SLP_TREE_CHILDREN (child).is_empty ()\n+\t      if (is_a <bb_vec_info> (vinfo)\n+\t\t  && !SLP_TREE_CHILDREN (child).is_empty ()\n \t\t  /* ???  Rejecting patterns this way doesn't work.  We'd have\n \t\t     to do extra work to cancel the pattern so the uses see the\n \t\t     scalar version.  */\n@@ -1435,6 +1463,8 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t\t\t \"scalars instead\\n\");\n \t\t      oprnd_info->def_stmts = vNULL;\n \t\t      SLP_TREE_DEF_TYPE (child) = vect_external_def;\n+\t\t      SLP_TREE_SCALAR_OPS (child) = oprnd_info->ops;\n+\t\t      oprnd_info->ops = vNULL;\n \t\t      ++this_tree_size;\n \t\t      children.safe_push (child);\n \t\t      continue;\n@@ -1577,8 +1607,6 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n                           vec<unsigned> permutation,\n \t\t\t  hash_set<slp_tree> &visited)\n {\n-  stmt_vec_info stmt_info;\n-  vec<stmt_vec_info> tmp_stmts;\n   unsigned int i;\n   slp_tree child;\n \n@@ -1588,15 +1616,30 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     vect_slp_rearrange_stmts (child, group_size, permutation, visited);\n \n-  gcc_assert (group_size == SLP_TREE_SCALAR_STMTS (node).length ());\n-  tmp_stmts.create (group_size);\n-  tmp_stmts.quick_grow_cleared (group_size);\n-\n-  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n-    tmp_stmts[permutation[i]] = stmt_info;\n-\n-  SLP_TREE_SCALAR_STMTS (node).release ();\n-  SLP_TREE_SCALAR_STMTS (node) = tmp_stmts;\n+  if (SLP_TREE_SCALAR_STMTS (node).exists ())\n+    {\n+      gcc_assert (group_size == SLP_TREE_SCALAR_STMTS (node).length ());\n+      vec<stmt_vec_info> tmp_stmts;\n+      tmp_stmts.create (group_size);\n+      tmp_stmts.quick_grow (group_size);\n+      stmt_vec_info stmt_info;\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n+\ttmp_stmts[permutation[i]] = stmt_info;\n+      SLP_TREE_SCALAR_STMTS (node).release ();\n+      SLP_TREE_SCALAR_STMTS (node) = tmp_stmts;\n+    }\n+  if (SLP_TREE_SCALAR_OPS (node).exists ())\n+    {\n+      gcc_assert (group_size == SLP_TREE_SCALAR_OPS (node).length ());\n+      vec<tree> tmp_ops;\n+      tmp_ops.create (group_size);\n+      tmp_ops.quick_grow (group_size);\n+      tree op;\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_OPS (node), i, op)\n+\ttmp_ops[permutation[i]] = op;\n+      SLP_TREE_SCALAR_OPS (node).release ();\n+      SLP_TREE_SCALAR_OPS (node) = tmp_ops;\n+    }\n }\n \n \n@@ -1682,9 +1725,10 @@ vect_gather_slp_loads (slp_instance inst, slp_tree node,\n \n   if (SLP_TREE_CHILDREN (node).length () == 0)\n     {\n+      if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n+\treturn;\n       stmt_vec_info stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-      if (SLP_TREE_DEF_TYPE (node) == vect_internal_def\n-\t  && STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n \t  && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n \tSLP_INSTANCE_LOADS (inst).safe_push (node);\n     }\n@@ -2346,7 +2390,8 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype,\n \n   if (!only_edge)\n     FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-      if (SLP_TREE_DEF_TYPE (child) != vect_external_def)\n+      if (SLP_TREE_DEF_TYPE (child) != vect_external_def\n+\t  && SLP_TREE_DEF_TYPE (child) != vect_constant_def)\n \tvect_detect_hybrid_slp_stmts (child, i, stype, visited);\n }\n \n@@ -2533,8 +2578,15 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n      VF divided by the number of elements in a vector.  */\n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info)\n       && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n-      = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_CHILDREN (node)[0]);\n+    {\n+      for (unsigned i = 0; i < SLP_TREE_CHILDREN (node).length (); ++i)\n+\tif (SLP_TREE_DEF_TYPE (SLP_TREE_CHILDREN (node)[i]) == vect_internal_def)\n+\t  {\n+\t    SLP_TREE_NUMBER_OF_VEC_STMTS (node)\n+\t      = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_CHILDREN (node)[i]);\n+\t    break;\n+\t  }\n+    }\n   else\n     {\n       poly_uint64 vf;\n@@ -2598,25 +2650,31 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n   auto_vec<vect_def_type, 4> dt;\n   dt.safe_grow (SLP_TREE_CHILDREN (node).length ());\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    dt[j] = STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]);\n+    if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n+      dt[j] = STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]);\n \n   /* Push SLP node def-type to stmt operands.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def\n+\t&& SLP_TREE_SCALAR_STMTS (child).length () != 0)\n       STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n \t= SLP_TREE_DEF_TYPE (child);\n \n   /* Check everything worked out.  */\n   bool res = true;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n-      {\n-\tif (STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n-\t    != SLP_TREE_DEF_TYPE (child))\n-\t  res = false;\n-      }\n-    else if (STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]) != dt[j])\n-      res = false;\n+      if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n+\t{\n+\t  if (SLP_TREE_DEF_TYPE (child) != vect_internal_def)\n+\t    {\n+\t      if (STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n+\t\t  != SLP_TREE_DEF_TYPE (child))\n+\t\tres = false;\n+\t    }\n+\t  else if (STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0])\n+\t\t   != dt[j])\n+\t    res = false;\n+\t}\n   if (!res && dump_enabled_p ())\n     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t     \"not vectorized: same operand with different \"\n@@ -2628,7 +2686,8 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \n   /* Restore def-types.  */\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-    STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]) = dt[j];\n+    if (SLP_TREE_SCALAR_STMTS (child).length () != 0)\n+      STMT_VINFO_DEF_TYPE (SLP_TREE_SCALAR_STMTS (child)[0]) = dt[j];\n \n   return res;\n }\n@@ -3279,53 +3338,46 @@ duplicate_and_interleave (vec_info *vinfo, gimple_seq *seq, tree vector_type,\n \n /* For constant and loop invariant defs of SLP_NODE this function returns\n    (vector) defs (VEC_OPRNDS) that will be used in the vectorized stmts.\n-   OP_NUM determines if we gather defs for operand 0 or operand 1 of the RHS of\n-   scalar stmts.  NUMBER_OF_VECTORS is the number of vector defs to create.\n-   REDUC_INDEX is the index of the reduction operand in the statements, unless\n-   it is -1.  */\n+   OP_NODE determines the node for the operand containing the scalar\n+   operands.  */\n \n static void\n-vect_get_constant_vectors (tree op, slp_tree slp_node,\n-                           vec<tree> *vec_oprnds,\n-\t\t\t   unsigned int op_num, unsigned int number_of_vectors)\n+vect_get_constant_vectors (slp_tree op_node, slp_tree slp_node,\n+                           vec<tree> *vec_oprnds)\n {\n-  vec<stmt_vec_info> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n-  stmt_vec_info stmt_vinfo = stmts[0];\n+  stmt_vec_info stmt_vinfo = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n   vec_info *vinfo = stmt_vinfo->vinfo;\n-  gimple *stmt = stmt_vinfo->stmt;\n   unsigned HOST_WIDE_INT nunits;\n   tree vec_cst;\n   unsigned j, number_of_places_left_in_vector;\n   tree vector_type;\n   tree vop;\n-  int group_size = stmts.length ();\n+  int group_size = op_node->ops.length ();\n   unsigned int vec_num, i;\n   unsigned number_of_copies = 1;\n-  vec<tree> voprnds;\n-  voprnds.create (number_of_vectors);\n-  bool constant_p, is_store;\n+  bool constant_p;\n   tree neutral_op = NULL;\n-  enum tree_code code = gimple_expr_code (stmt);\n   gimple_seq ctor_seq = NULL;\n   auto_vec<tree, 16> permute_results;\n \n+  /* ???  SLP analysis should compute the vector type for the\n+     constant / invariant and store it in the SLP node.  */\n+  tree op = op_node->ops[0];\n   /* Check if vector type is a boolean vector.  */\n+  tree stmt_vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   if (VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (op))\n       && vect_mask_constant_operand_p (stmt_vinfo))\n     vector_type\n-      = build_same_sized_truth_vector_type (STMT_VINFO_VECTYPE (stmt_vinfo));\n+      = build_same_sized_truth_vector_type (stmt_vectype);\n   else\n     vector_type = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op));\n \n-  if (STMT_VINFO_DATA_REF (stmt_vinfo))\n-    {\n-      is_store = true;\n-      op = gimple_assign_rhs1 (stmt);\n-    }\n-  else\n-    is_store = false;\n-\n-  gcc_assert (op);\n+  unsigned int number_of_vectors\n+    = vect_get_num_vectors (SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node)\n+\t\t\t    * TYPE_VECTOR_SUBPARTS (stmt_vectype),\n+\t\t\t    vector_type);\n+  vec_oprnds->create (number_of_vectors);\n+  auto_vec<tree> voprnds (number_of_vectors);\n \n   /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n      created vectors. It is greater than 1 if unrolling is performed.\n@@ -3357,56 +3409,8 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   bool place_after_defs = false;\n   for (j = 0; j < number_of_copies; j++)\n     {\n-      for (i = group_size - 1; stmts.iterate (i, &stmt_vinfo); i--)\n+      for (i = group_size - 1; op_node->ops.iterate (i, &op); i--)\n         {\n-\t  stmt = stmt_vinfo->stmt;\n-          if (is_store)\n-            op = gimple_assign_rhs1 (stmt);\n-          else\n-\t    {\n-\t      switch (code)\n-\t\t{\n-\t\t  case COND_EXPR:\n-\t\t    {\n-\t\t      tree cond = gimple_assign_rhs1 (stmt);\n-\t\t      if (TREE_CODE (cond) == SSA_NAME)\n-\t\t\top = gimple_op (stmt, op_num + 1);\n-\t\t      else if (op_num == 0 || op_num == 1)\n-\t\t\top = TREE_OPERAND (cond, op_num);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (op_num == 2)\n-\t\t\t    op = gimple_assign_rhs2 (stmt);\n-\t\t\t  else\n-\t\t\t    op = gimple_assign_rhs3 (stmt);\n-\t\t\t}\n-\t\t    }\n-\t\t    break;\n-\n-\t\t  case CALL_EXPR:\n-\t\t    op = gimple_call_arg (stmt, op_num);\n-\t\t    break;\n-\n-\t\t  case LSHIFT_EXPR:\n-\t\t  case RSHIFT_EXPR:\n-\t\t  case LROTATE_EXPR:\n-\t\t  case RROTATE_EXPR:\n-\t\t    op = gimple_op (stmt, op_num + 1);\n-\t\t    /* Unlike the other binary operators, shifts/rotates have\n-\t\t       the shift count being int, instead of the same type as\n-\t\t       the lhs, so make sure the scalar is the right type if\n-\t\t       we are dealing with vectors of\n-\t\t       long long/long/short/char.  */\n-\t\t    if (op_num == 1 && TREE_CODE (op) == INTEGER_CST)\n-\t\t      op = fold_convert (TREE_TYPE (vector_type), op);\n-\t\t    break;\n-\n-\t\t  default:\n-\t\t    op = gimple_op (stmt, op_num + 1);\n-\t\t    break;\n-\t\t}\n-\t    }\n-\n           /* Create 'vect_ = {op0,op1,...,opn}'.  */\n           number_of_places_left_in_vector--;\n \t  tree orig_op = op;\n@@ -3476,7 +3480,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t\tvec_cst = gimple_build_vector (&ctor_seq, &elts);\n \t      else\n \t\t{\n-\t\t  if (vec_oprnds->is_empty ())\n+\t\t  if (permute_results.is_empty ())\n \t\t    duplicate_and_interleave (vinfo, &ctor_seq, vector_type,\n \t\t\t\t\t      elts, number_of_vectors,\n \t\t\t\t\t      permute_results);\n@@ -3520,8 +3524,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n       vec_oprnds->quick_push (vop);\n     }\n \n-  voprnds.release ();\n-\n   /* In case that VF is greater than the unrolling factor needed for the SLP\n      group of stmts, NUMBER_OF_VECTORS to be created is greater than\n      NUMBER_OF_SCALARS/NUNITS or NUNITS/NUMBER_OF_SCALARS, and hence we have\n@@ -3552,117 +3554,44 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n static void\n vect_get_slp_vect_defs (slp_tree slp_node, vec<tree> *vec_oprnds)\n {\n-  tree vec_oprnd;\n   stmt_vec_info vec_def_stmt_info;\n   unsigned int i;\n \n   gcc_assert (SLP_TREE_VEC_STMTS (slp_node).exists ());\n \n   FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt_info)\n-    {\n-      gcc_assert (vec_def_stmt_info);\n-      if (gphi *vec_def_phi = dyn_cast <gphi *> (vec_def_stmt_info->stmt))\n-\tvec_oprnd = gimple_phi_result (vec_def_phi);\n-      else\n-\tvec_oprnd = gimple_get_lhs (vec_def_stmt_info->stmt);\n-      vec_oprnds->quick_push (vec_oprnd);\n-    }\n+    vec_oprnds->quick_push (gimple_get_lhs (vec_def_stmt_info->stmt));\n }\n \n \n-/* Get vectorized definitions for SLP_NODE.\n+/* Get N vectorized definitions for SLP_NODE.\n    If the scalar definitions are loop invariants or constants, collect them and\n    call vect_get_constant_vectors() to create vector stmts.\n    Otherwise, the def-stmts must be already vectorized and the vectorized stmts\n    must be stored in the corresponding child of SLP_NODE, and we call\n    vect_get_slp_vect_defs () to retrieve them.  */\n \n void\n-vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n-\t\t   vec<vec<tree> > *vec_oprnds)\n+vect_get_slp_defs (slp_tree slp_node, vec<vec<tree> > *vec_oprnds, unsigned n)\n {\n-  int number_of_vects = 0, i;\n-  unsigned int child_index = 0;\n-  HOST_WIDE_INT lhs_size_unit, rhs_size_unit;\n-  slp_tree child = NULL;\n-  vec<tree> vec_defs;\n-  tree oprnd;\n-  bool vectorized_defs;\n+  if (n == -1U)\n+    n = SLP_TREE_CHILDREN (slp_node).length ();\n \n-  stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n-  FOR_EACH_VEC_ELT (ops, i, oprnd)\n+  for (unsigned i = 0; i < n; ++i)\n     {\n-      /* For each operand we check if it has vectorized definitions in a child\n-\t node or we need to create them (for invariants and constants).  We\n-\t check if the LHS of the first stmt of the next child matches OPRND.\n-\t If it does, we found the correct child.  Otherwise, we call\n-\t vect_get_constant_vectors (), and not advance CHILD_INDEX in order\n-\t to check this child node for the next operand.  */\n-      vectorized_defs = false;\n-      if (SLP_TREE_CHILDREN (slp_node).length () > child_index)\n-        {\n-          child = SLP_TREE_CHILDREN (slp_node)[child_index];\n-\n-\t  /* We have to check both pattern and original def, if available.  */\n-\t  if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n-\t    {\n-\t      stmt_vec_info first_def_info = SLP_TREE_SCALAR_STMTS (child)[0];\n-\t      stmt_vec_info related = STMT_VINFO_RELATED_STMT (first_def_info);\n-\t      tree first_def_op;\n+      slp_tree child = SLP_TREE_CHILDREN (slp_node)[i];\n \n-\t      if (gphi *first_def = dyn_cast <gphi *> (first_def_info->stmt))\n-\t\tfirst_def_op = gimple_phi_result (first_def);\n-\t      else\n-\t\tfirst_def_op = gimple_get_lhs (first_def_info->stmt);\n-\t      if (operand_equal_p (oprnd, first_def_op, 0)\n-\t\t  || (related\n-\t\t      && operand_equal_p (oprnd,\n-\t\t\t\t\t  gimple_get_lhs (related->stmt), 0)))\n-\t\t{\n-\t\t  /* The number of vector defs is determined by the number of\n-\t\t     vector statements in the node from which we get those\n-\t\t     statements.  */\n-\t\t  number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (child);\n-\t\t  vectorized_defs = true;\n-\t\t  child_index++;\n-\t\t}\n-\t    }\n-\t  else\n-\t    child_index++;\n-        }\n+      vec<tree> vec_defs = vNULL;\n \n-      if (!vectorized_defs)\n-        {\n-          if (i == 0)\n-            {\n-              number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-              /* Number of vector stmts was calculated according to LHS in\n-                 vect_schedule_slp_instance (), fix it by replacing LHS with\n-                 RHS, if necessary.  See vect_get_smallest_scalar_type () for\n-                 details.  */\n-\t      vect_get_smallest_scalar_type (first_stmt_info, &lhs_size_unit,\n-\t\t\t\t\t     &rhs_size_unit);\n-              if (rhs_size_unit != lhs_size_unit)\n-                {\n-                  number_of_vects *= rhs_size_unit;\n-                  number_of_vects /= lhs_size_unit;\n-                }\n-            }\n-        }\n-\n-      /* Allocate memory for vectorized defs.  */\n-      vec_defs = vNULL;\n-      vec_defs.create (number_of_vects);\n-\n-      /* For reduction defs we call vect_get_constant_vectors (), since we are\n-         looking for initial loop invariant values.  */\n-      if (vectorized_defs)\n-        /* The defs are already vectorized.  */\n-\tvect_get_slp_vect_defs (child, &vec_defs);\n+      /* For each operand we check if it has vectorized definitions in a child\n+\t node or we need to create them (for invariants and constants).  */\n+      if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+\t{\n+\t  vec_defs.create (SLP_TREE_NUMBER_OF_VEC_STMTS (child));\n+\t  vect_get_slp_vect_defs (child, &vec_defs);\n+\t}\n       else\n-\t/* Build vectors from scalar defs.  */\n-\tvect_get_constant_vectors (oprnd, slp_node, &vec_defs, i,\n-\t\t\t\t   number_of_vects);\n+\tvect_get_constant_vectors (child, slp_node, &vec_defs);\n \n       vec_oprnds->quick_push (vec_defs);\n     }"}, {"sha": "4c5d33ce952ad13ad66cc77a74502649a71b9e3d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "patch": "@@ -1726,16 +1726,8 @@ vect_get_vec_defs (tree op0, tree op1, stmt_vec_info stmt_info,\n {\n   if (slp_node)\n     {\n-      int nops = (op1 == NULL_TREE) ? 1 : 2;\n-      auto_vec<tree> ops (nops);\n-      auto_vec<vec<tree> > vec_defs (nops);\n-\n-      ops.quick_push (op0);\n-      if (op1)\n-        ops.quick_push (op1);\n-\n-      vect_get_slp_defs (ops, slp_node, &vec_defs);\n-\n+      auto_vec<vec<tree> > vec_defs (SLP_TREE_CHILDREN (slp_node).length ());\n+      vect_get_slp_defs (slp_node, &vec_defs, op1 ? 2 : 1);\n       *vec_oprnds0 = vec_defs[0];\n       if (op1)\n \t*vec_oprnds1 = vec_defs[1];\n@@ -3473,9 +3465,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      auto_vec<vec<tree> > vec_defs (nargs);\n \t      vec<tree> vec_oprnds0;\n \n-\t      for (i = 0; i < nargs; i++)\n-\t\tvargs[i] = gimple_call_arg (stmt, i);\n-\t      vect_get_slp_defs (vargs, slp_node, &vec_defs);\n+\t      vect_get_slp_defs (slp_node, &vec_defs);\n \t      vec_oprnds0 = vec_defs[0];\n \n \t      /* Arguments are ready.  Create the new vector stmt.  */\n@@ -3647,9 +3637,7 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t      auto_vec<vec<tree> > vec_defs (nargs);\n \t      vec<tree> vec_oprnds0;\n \n-\t      for (i = 0; i < nargs; i++)\n-\t\tvargs.quick_push (gimple_call_arg (stmt, i));\n-\t      vect_get_slp_defs (vargs, slp_node, &vec_defs);\n+\t      vect_get_slp_defs (slp_node, &vec_defs);\n \t      vec_oprnds0 = vec_defs[0];\n \n \t      /* Arguments are ready.  Create the new vector stmt.  */\n@@ -6195,12 +6183,8 @@ vectorizable_operation (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    {\n \t      if (slp_node)\n \t\t{\n-\t\t  auto_vec<tree> ops(3);\n-\t\t  ops.quick_push (op0);\n-\t\t  ops.quick_push (op1);\n-\t\t  ops.quick_push (op2);\n \t\t  auto_vec<vec<tree> > vec_defs(3);\n-\t\t  vect_get_slp_defs (ops, slp_node, &vec_defs);\n+\t\t  vect_get_slp_defs (slp_node, &vec_defs);\n \t\t  vec_oprnds0 = vec_defs[0];\n \t\t  vec_oprnds1 = vec_defs[1];\n \t\t  vec_oprnds2 = vec_defs[2];\n@@ -9271,10 +9255,8 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    {\n \t      if (slp_node)\n \t\t{\n-\t\t  auto_vec<tree> ops (1);\n \t\t  auto_vec<vec<tree> > vec_defs (1);\n-\t\t  ops.quick_push (mask);\n-\t\t  vect_get_slp_defs (ops, slp_node, &vec_defs);\n+\t\t  vect_get_slp_defs (slp_node, &vec_defs);\n \t\t  vec_mask = vec_defs[0][0];\n \t\t}\n \t      else\n@@ -10046,19 +10028,8 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t{\n           if (slp_node)\n             {\n-              auto_vec<tree, 4> ops;\n \t      auto_vec<vec<tree>, 4> vec_defs;\n-\n-\t      if (masked)\n-\t\tops.safe_push (cond_expr);\n-\t      else\n-\t\t{\n-\t\t  ops.safe_push (cond_expr0);\n-\t\t  ops.safe_push (cond_expr1);\n-\t\t}\n-              ops.safe_push (then_clause);\n-              ops.safe_push (else_clause);\n-              vect_get_slp_defs (ops, slp_node, &vec_defs);\n+              vect_get_slp_defs (slp_node, &vec_defs);\n \t      vec_oprnds3 = vec_defs.pop ();\n \t      vec_oprnds2 = vec_defs.pop ();\n \t      if (!masked)\n@@ -10461,12 +10432,8 @@ vectorizable_comparison (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t{\n \t  if (slp_node)\n \t    {\n-\t      auto_vec<tree, 2> ops;\n \t      auto_vec<vec<tree>, 2> vec_defs;\n-\n-\t      ops.safe_push (rhs1);\n-\t      ops.safe_push (rhs2);\n-\t      vect_get_slp_defs (ops, slp_node, &vec_defs);\n+\t      vect_get_slp_defs (slp_node, &vec_defs);\n \t      vec_oprnds1 = vec_defs.pop ();\n \t      vec_oprnds0 = vec_defs.pop ();\n \t      if (swap_p)"}, {"sha": "56be28b0cc5a77412f996e70636b08d5b615813e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=30c0d1e3cf8b03992e08cfd00ccf1fcb638d3c03", "patch": "@@ -120,6 +120,8 @@ struct _slp_tree {\n   vec<slp_tree> children;\n   /* A group of scalar stmts to be vectorized together.  */\n   vec<stmt_vec_info> stmts;\n+  /* A group of scalar operands to be vectorized together.  */\n+  vec<tree> ops;\n   /* Load permutation relative to the stores, NULL if there is no\n      permutation.  */\n   vec<unsigned> load_permutation;\n@@ -171,6 +173,7 @@ typedef class _slp_instance {\n \n #define SLP_TREE_CHILDREN(S)                     (S)->children\n #define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts\n+#define SLP_TREE_SCALAR_OPS(S)                   (S)->ops\n #define SLP_TREE_VEC_STMTS(S)                    (S)->vec_stmts\n #define SLP_TREE_NUMBER_OF_VEC_STMTS(S)          (S)->vec_stmts_size\n #define SLP_TREE_LOAD_PERMUTATION(S)             (S)->load_permutation\n@@ -1750,7 +1753,7 @@ extern void vect_schedule_slp (vec_info *);\n extern opt_result vect_analyze_slp (vec_info *, unsigned);\n extern bool vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n-extern void vect_get_slp_defs (vec<tree> , slp_tree, vec<vec<tree> > *);\n+extern void vect_get_slp_defs (slp_tree, vec<vec<tree> > *, unsigned n = -1U);\n extern bool vect_slp_bb (basic_block);\n extern stmt_vec_info vect_find_last_scalar_stmt_in_slp (slp_tree);\n extern bool is_simple_and_all_uses_invariant (stmt_vec_info, loop_vec_info);"}]}