{"sha": "10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "node_id": "C_kwDOANBUbNoAKDEwNDc4MjcwZmUwYzM5YzU5ZWIwZjM1ZDE5MzU2YTYzYmRmM2EyYWQ", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:33:06Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-12-13T23:58:10Z"}, "message": "ipa-sra: Treat REFERENCE_TYPES as always dereferencable\n\nC++ and especially Fortran pass data by references which are not\npointers potentially pointing anywhere and so can be assumed to be\nsafely dereferencable.  This patch teaches IPA-SRA to treat them as\nsuch and avoid the dance we do to prove that we can move loads from\nthem to the caller.\n\nWhen we do not know that a dereference will happen all the time, we\nneed a heuristics so that we do not force memory accesses that normally\nhappen only rarely.  The patch simply uses the (possibly guessed)\nprofile and checks whether the (expected) number of loads is at least\nhalf of function invocations invocations - the half is now\nconfigurable with a param as requested by Honza.\n\ngcc/ChangeLog:\n\n2022-12-13  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103585\n\t* params.opt (ipa-sra-deref-prob-threshold): New parameter.\n\t* doc/invoke.texi (ipa-sra-deref-prob-threshold): Document it.\n\t* ipa-sra.cc (struct gensum_param_access): New field load_count.\n\t(struct gensum_param_desc): New field safe_ref, adjusted comments.\n\t(by_ref_count): Renamed to unsafe_by_ref_count, adjusted all uses.\n\t(dump_gensum_access): Dump the new field.\n\t(dump_gensum_param_descriptor): Likewise.\n\t(create_parameter_descriptors): Set safe_ref field, move setting\n\tby_ref forward.  Only increment unsafe_by_ref_count for unsafe\n\tby_ref parameters.\n\t(allocate_access): Initialize new field.\n\t(mark_param_dereference): Adjust indentation.  Only add data to\n\tbb_dereferences for unsafe by_ref parameters.\n\t(scan_expr_access): For loads, accumulate BB counts.\n\t(dereference_probable_p): New function.\n\t(check_gensum_access): Fix leading comment, add parameter FUN.\n\tCheck cumulative counts of loads for safe by_ref accesses instead\n\tof dereferences.\n\t(process_scan_results): Do not propagate dereference distances for\n\tsafe by_ref parameters.  Pass fun to check_gensum_access.  Safe\n\tby_ref params do not need the postdominance check.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* g++.dg/ipa/ipa-sra-5.C: New test", "tree": {"sha": "10fd7181654aecbb9ea1a3b00ee566f3986ec364", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10fd7181654aecbb9ea1a3b00ee566f3986ec364"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmOZEZIACgkQv2PBvD+k\nNUDEmA//dcXoUlDLUdHY64eYktS59isHaLclaf2omvF4UmM/219HXMV+eI1TqRSX\ne66qWLNNKzAB8Dq9w56S0RAqrDLGoXWdlce+ayG0VZouDhMnc0gG4pDi9I2Fy9o2\ngKn1A8rHR8ORPOi5wmvJbZCBG5YRu7JM5gcjXCUzyem59xYpqWy6QZlWXSSFfG8S\nIr+pCmzt4ecepBelwc15wLwoCKBUga1x7XeNNGi04wDwNZDAShQvDVgS5xMrA25N\nbZtEiUqq4a7+wAABKOXf36jDF09pob5oWs2CEr0Dapi3+BOfeYAri4EOhUVV84VM\npiqooyjJwgDiSo7fzIVs2GO56qDNnL/55xwJeFxUn2mqt+DxtElNg8yLODzhlumn\nyjDuIIKBmFjS17EPKtkvEH7WyxkjbSsyyFj/snzYisUIhJFUz1Ohycft0363uBzi\np511CRp6YMslt9NgpIUVhiG/P2NKr6ZCYonWcd6Zoyu9WUNdMutXlv930ZFKqyPA\nu+yQWVtE4ocS9YDSfbNe/7+T2HUssEa06pPIADIx+v38GqBHPLp3Fyh6Lll7HC+d\nzFweWwYmDUyg+/zmAblKkfPYTx9u1o1CQH1xudtwfKMdpocR2E7YLQ5feUwLNqcF\np+e5Sd2gosPOJG5beH0NBuqkKGZjF6OUKMB0cO5BI42EDX9u+NE=\n=VsMF\n-----END PGP SIGNATURE-----", "payload": "tree 10fd7181654aecbb9ea1a3b00ee566f3986ec364\nparent 095a13eda2caf6842096a3ab78b2081c50fe8799\nauthor Martin Jambor <mjambor@suse.cz> 1670974386 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1670975890 +0100\n\nipa-sra: Treat REFERENCE_TYPES as always dereferencable\n\nC++ and especially Fortran pass data by references which are not\npointers potentially pointing anywhere and so can be assumed to be\nsafely dereferencable.  This patch teaches IPA-SRA to treat them as\nsuch and avoid the dance we do to prove that we can move loads from\nthem to the caller.\n\nWhen we do not know that a dereference will happen all the time, we\nneed a heuristics so that we do not force memory accesses that normally\nhappen only rarely.  The patch simply uses the (possibly guessed)\nprofile and checks whether the (expected) number of loads is at least\nhalf of function invocations invocations - the half is now\nconfigurable with a param as requested by Honza.\n\ngcc/ChangeLog:\n\n2022-12-13  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103585\n\t* params.opt (ipa-sra-deref-prob-threshold): New parameter.\n\t* doc/invoke.texi (ipa-sra-deref-prob-threshold): Document it.\n\t* ipa-sra.cc (struct gensum_param_access): New field load_count.\n\t(struct gensum_param_desc): New field safe_ref, adjusted comments.\n\t(by_ref_count): Renamed to unsafe_by_ref_count, adjusted all uses.\n\t(dump_gensum_access): Dump the new field.\n\t(dump_gensum_param_descriptor): Likewise.\n\t(create_parameter_descriptors): Set safe_ref field, move setting\n\tby_ref forward.  Only increment unsafe_by_ref_count for unsafe\n\tby_ref parameters.\n\t(allocate_access): Initialize new field.\n\t(mark_param_dereference): Adjust indentation.  Only add data to\n\tbb_dereferences for unsafe by_ref parameters.\n\t(scan_expr_access): For loads, accumulate BB counts.\n\t(dereference_probable_p): New function.\n\t(check_gensum_access): Fix leading comment, add parameter FUN.\n\tCheck cumulative counts of loads for safe by_ref accesses instead\n\tof dereferences.\n\t(process_scan_results): Do not propagate dereference distances for\n\tsafe by_ref parameters.  Pass fun to check_gensum_access.  Safe\n\tby_ref params do not need the postdominance check.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\t* g++.dg/ipa/ipa-sra-5.C: New test\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "095a13eda2caf6842096a3ab78b2081c50fe8799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095a13eda2caf6842096a3ab78b2081c50fe8799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095a13eda2caf6842096a3ab78b2081c50fe8799"}], "stats": {"total": 133, "additions": 105, "deletions": 28}, "files": [{"sha": "0459714d10013a0c25bd5212d597d48e52b294a2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "patch": "@@ -15509,6 +15509,11 @@ the parameter is reserved exclusively for debug insns created by\n @option{-fvar-tracking-assignments}, but debug insns may get\n (non-overlapping) uids above it if the reserved range is exhausted.\n \n+@item ipa-sra-deref-prob-threshold\n+IPA-SRA replaces a pointer which is known not be NULL with one or more\n+new parameters only when the probability (in percent, relative to\n+function entry) of it being dereferenced is higher than this parameter.\n+\n @item ipa-sra-ptr-growth-factor\n IPA-SRA replaces a pointer to an aggregate with one or more new\n parameters only when their cumulative size is less or equal to"}, {"sha": "866f52e89e0ecef707f6bcd0a589fce238c50db3", "filename": "gcc/ipa-sra.cc", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Fipa-sra.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Fipa-sra.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.cc?ref=10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "patch": "@@ -151,6 +151,8 @@ struct gensum_param_access\n      arguments.  */\n   tree alias_ptr_type;\n \n+  /* Cumulative count of all loads. */\n+  profile_count load_count;\n   /* Have there been writes to or reads from this exact location except for as\n      arguments to a function call that can be tracked.  */\n   bool nonarg;\n@@ -207,8 +209,13 @@ struct gensum_param_desc\n      by reference that is a candidate for being converted to a set of\n      parameters passing those data by value.  */\n   bool split_candidate;\n-  /* Is this a parameter passing stuff by reference?  */\n+  /* Is this a parameter passing stuff by reference (either a pointer or a\n+     source language reference type)?  */\n   bool by_ref;\n+  /* If this parameter passes stuff by reference, can it be safely dereferenced\n+     without performing further checks (for example because it is a\n+     REFERENCE_TYPE)?  */\n+  bool safe_ref;\n \n   /* The number of this parameter as they are ordered in function decl.  */\n   int param_number;\n@@ -561,7 +568,7 @@ int aa_walking_limit;\n    accessed in that BB.  */\n HOST_WIDE_INT *bb_dereferences = NULL;\n /* How many by-reference parameters there are in the current function.  */\n-int by_ref_count;\n+int unsafe_by_ref_count;\n \n /* Bitmap of BBs that can cause the function to \"stop\" progressing by\n    returning, throwing externally, looping infinitely or calling a function\n@@ -643,6 +650,8 @@ dump_gensum_access (FILE *f, gensum_param_access *access, unsigned indent)\n   print_generic_expr (f, access->type);\n   fprintf (f, \", alias_ptr_type: \");\n   print_generic_expr (f, access->alias_ptr_type);\n+  fprintf (f, \", load_count: \");\n+  access->load_count.dump (f);\n   fprintf (f, \", nonarg: %u, reverse: %u\\n\", access->nonarg, access->reverse);\n   for (gensum_param_access *ch = access->first_child;\n        ch;\n@@ -692,7 +701,8 @@ dump_gensum_param_descriptor (FILE *f, gensum_param_desc *desc)\n       return;\n     }\n   if (desc->by_ref)\n-    fprintf (f, \"    by_ref with %u pass throughs\\n\", desc->ptr_pt_count);\n+    fprintf (f, \"    %s by_ref with %u pass throughs\\n\",\n+\t     desc->safe_ref ? \"safe\" : \"unsafe\", desc->ptr_pt_count);\n \n   for (gensum_param_access *acc = desc->accesses; acc; acc = acc->next_sibling)\n     dump_gensum_access (f, acc, 2);\n@@ -1140,6 +1150,8 @@ create_parameter_descriptors (cgraph_node *node,\n \n       if (POINTER_TYPE_P (type))\n \t{\n+\t  desc->by_ref = true;\n+\t  desc->safe_ref = (TREE_CODE (type) == REFERENCE_TYPE);\n \t  type = TREE_TYPE (type);\n \n \t  if (TREE_CODE (type) == FUNCTION_TYPE\n@@ -1187,7 +1199,6 @@ create_parameter_descriptors (cgraph_node *node,\n \t\t\t \"nonarg uses\\n\");\n \t      continue;\n \t    }\n-\t  desc->by_ref = true;\n \t}\n       else if (!AGGREGATE_TYPE_P (type))\n \t{\n@@ -1231,8 +1242,8 @@ create_parameter_descriptors (cgraph_node *node,\n \n       ret = true;\n       desc->split_candidate = true;\n-      if (desc->by_ref)\n-\tdesc->deref_index = by_ref_count++;\n+      if (desc->by_ref && !desc->safe_ref)\n+\tdesc->deref_index = unsafe_by_ref_count++;\n     }\n   return ret;\n }\n@@ -1301,6 +1312,7 @@ allocate_access (gensum_param_desc *desc,\n   memset (access, 0, sizeof (*access));\n   access->offset = offset;\n   access->size = size;\n+  access->load_count = profile_count::zero ();\n   return access;\n }\n \n@@ -1555,15 +1567,16 @@ asm_visit_addr (gimple *, tree op, tree, void *)\n \n static void\n mark_param_dereference (gensum_param_desc *desc, HOST_WIDE_INT dist,\n-\t\t       basic_block bb)\n+\t\t\tbasic_block bb)\n {\n   gcc_assert (desc->by_ref);\n   gcc_checking_assert (desc->split_candidate);\n \n-  if (bitmap_bit_p (final_bbs, bb->index))\n+  if (desc->safe_ref\n+      || bitmap_bit_p (final_bbs, bb->index))\n     return;\n \n-  int idx = bb->index * by_ref_count + desc->deref_index;\n+  int idx = bb->index * unsafe_by_ref_count + desc->deref_index;\n   if (bb_dereferences[idx] < dist)\n     bb_dereferences[idx] = dist;\n }\n@@ -1811,6 +1824,8 @@ scan_expr_access (tree expr, gimple *stmt, isra_scan_context ctx,\n \t   other.  */\n \taccess->nonarg = true;\n     }\n+  else if (ctx == ISRA_CTX_LOAD && bb->count.initialized_p ())\n+    access->load_count += bb->count;\n \n   if (!access->type)\n     {\n@@ -2092,9 +2107,9 @@ dump_dereferences_table (FILE *f, struct function *fun, const char *str)\n       if (bb != EXIT_BLOCK_PTR_FOR_FN (fun))\n \t{\n \t  int i;\n-\t  for (i = 0; i < by_ref_count; i++)\n+\t  for (i = 0; i < unsafe_by_ref_count; i++)\n \t    {\n-\t      int idx = bb->index * by_ref_count + i;\n+\t      int idx = bb->index * unsafe_by_ref_count + i;\n \t      fprintf (f, \" %4\" HOST_WIDE_INT_PRINT \"d\", bb_dereferences[idx]);\n \t    }\n \t}\n@@ -2139,15 +2154,15 @@ propagate_dereference_distances (struct function *fun)\n       if (bitmap_bit_p (final_bbs, bb->index))\n \tcontinue;\n \n-      for (i = 0; i < by_ref_count; i++)\n+      for (i = 0; i < unsafe_by_ref_count; i++)\n \t{\n-\t  int idx = bb->index * by_ref_count + i;\n+\t  int idx = bb->index * unsafe_by_ref_count + i;\n \t  bool first = true;\n \t  HOST_WIDE_INT inh = 0;\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t  {\n-\t    int succ_idx = e->dest->index * by_ref_count + i;\n+\t    int succ_idx = e->dest->index * unsafe_by_ref_count + i;\n \n \t    if (e->dest == EXIT_BLOCK_PTR_FOR_FN (fun))\n \t      continue;\n@@ -2184,13 +2199,24 @@ propagate_dereference_distances (struct function *fun)\n \t\t\t     \"Dereference table after propagation:\\n\");\n }\n \n-/* Perform basic checks on ACCESS to PARM described by DESC and all its\n-   children, return true if the parameter cannot be split, otherwise return\n-   true and update *TOTAL_SIZE and *ONLY_CALLS.  ENTRY_BB_INDEX must be the\n-   index of the entry BB in the function of PARM.  */\n+/* Return true if the ACCESS loads happen frequently enough in FUN to risk\n+   moving them to the caller and only pass the result.  */\n \n static bool\n-check_gensum_access (tree parm, gensum_param_desc *desc,\n+dereference_probable_p (struct function *fun, gensum_param_access *access)\n+{\n+  int threshold = opt_for_fn (fun->decl, param_ipa_sra_deref_prob_threshold);\n+  return access->load_count\n+    >= ENTRY_BLOCK_PTR_FOR_FN (fun)->count.apply_scale (threshold, 100);\n+}\n+\n+/* Perform basic checks on ACCESS to PARM (of FUN) described by DESC and all\n+   its children, return true if the parameter cannot be split, otherwise return\n+   false and update *NONARG_ACC_SIZE and *ONLY_CALLS.  ENTRY_BB_INDEX must be\n+   the index of the entry BB in the function of PARM.  */\n+\n+static bool\n+check_gensum_access (struct function *fun, tree parm, gensum_param_desc *desc,\n \t\t     gensum_param_access *access,\n \t\t     HOST_WIDE_INT *nonarg_acc_size, bool *only_calls,\n \t\t     int entry_bb_index)\n@@ -2218,19 +2244,31 @@ check_gensum_access (tree parm, gensum_param_desc *desc,\n \n   if (desc->by_ref)\n     {\n-      int idx = (entry_bb_index * by_ref_count + desc->deref_index);\n-      if ((access->offset + access->size) > bb_dereferences[idx])\n+      if (desc->safe_ref)\n \t{\n-\t  disqualify_split_candidate (desc, \"Would create a possibly \"\n-\t\t\t\t      \"illegal dereference in a caller.\");\n-\t  return true;\n+\t  if (!dereference_probable_p (fun, access))\n+\t    {\n+\t      disqualify_split_candidate (desc, \"Dereferences in callers \"\n+\t\t\t\t\t  \"would happen much more frequently.\");\n+\t      return true;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  int idx = (entry_bb_index * unsafe_by_ref_count + desc->deref_index);\n+\t  if ((access->offset + access->size) > bb_dereferences[idx])\n+\t    {\n+\t      disqualify_split_candidate (desc, \"Would create a possibly \"\n+\t\t\t\t\t  \"illegal dereference in a caller.\");\n+\t      return true;\n+\t    }\n \t}\n     }\n \n   for (gensum_param_access *ch = access->first_child;\n        ch;\n        ch = ch->next_sibling)\n-    if (check_gensum_access (parm, desc, ch, nonarg_acc_size, only_calls,\n+    if (check_gensum_access (fun, parm, desc, ch, nonarg_acc_size, only_calls,\n \t\t\t     entry_bb_index))\n       return true;\n \n@@ -2288,6 +2326,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \n       if (!dereferences_propagated\n \t  && desc->by_ref\n+\t  && !desc->safe_ref\n \t  && desc->accesses)\n \t{\n \t  propagate_dereference_distances (fun);\n@@ -2302,8 +2341,8 @@ process_scan_results (cgraph_node *node, struct function *fun,\n       for (gensum_param_access *acc = desc->accesses;\n \t   acc;\n \t   acc = acc->next_sibling)\n-\tif (check_gensum_access (parm, desc, acc, &nonarg_acc_size, &only_calls,\n-\t\t\t\t entry_bb_index))\n+\tif (check_gensum_access (fun, parm, desc, acc, &nonarg_acc_size,\n+\t\t\t\t &only_calls, entry_bb_index))\n \t  {\n \t    check_failed = true;\n \t    break;\n@@ -2394,6 +2433,12 @@ process_scan_results (cgraph_node *node, struct function *fun,\n \t    if (!uses_memory_as_obtained)\n \t      continue;\n \n+\t    if (desc->safe_ref)\n+\t      {\n+\t\tcsum->m_arg_flow[argidx].safe_to_import_accesses = true;\n+\t\tcontinue;\n+\t      }\n+\n \t    /* Post-dominator check placed last, hoping that it usually won't\n \t       be needed.  */\n \t    if (!pdoms_calculated)\n@@ -4124,7 +4169,7 @@ ipa_sra_summarize_function (cgraph_node *node)\n \t  cfun_pushed = true;\n \t  final_bbs = BITMAP_ALLOC (NULL);\n \t  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n-\t\t\t\t      by_ref_count\n+\t\t\t\t      unsafe_by_ref_count\n \t\t\t\t      * last_basic_block_for_fn (fun));\n \t  aa_walking_limit = opt_for_fn (node->decl, param_ipa_max_aa_steps);\n \t  scan_function (node, fun);"}, {"sha": "a574f17bddb4343a65e1027f679855dd023b3773", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "patch": "@@ -282,6 +282,10 @@ Maximum number of different predicates used to track properties of loops in IPA\n Common Joined UInteger Var(param_ipa_max_switch_predicate_bounds) Init(5) Param Optimization\n Maximal number of boundary endpoints of case ranges of switch statement used during IPA function summary generation.\n \n+-param=ipa-sra-deref-prob-threshold=\n+Common Joined UInteger Var(param_ipa_sra_deref_prob_threshold) Init(50) IntegerRange(0, 100) Param Optimization\n+Minimum probability (in percent) of dereferencing of a function pointer parameter for it to be considered for replacement with simple values.\n+\n -param=ipa-sra-max-replacements=\n Common Joined UInteger Var(param_ipa_sra_max_replacements) Optimization Init(8) IntegerRange(0, 16) Param\n Maximum pieces that IPA-SRA tracks per formal parameter, as a consequence, also the maximum number of replacements of a formal parameter."}, {"sha": "26a221e1734e4fa28fc5ba05ca7f197e7f0defe1", "filename": "gcc/testsuite/g++.dg/ipa/ipa-sra-5.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10478270fe0c39c59eb0f35d19356a63bdf3a2ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fipa-sra-5.C?ref=10478270fe0c39c59eb0f35d19356a63bdf3a2ad", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-sra\"  } */\n+\n+volatile int vi;\n+\n+static void __attribute__((noinline))\n+foo (int c, int &r)\n+{\n+  int i;\n+  if (c)\n+    i = r;\n+  else\n+    i = 0;\n+  vi = i;\n+}\n+\n+void\n+bar (int c, int j)\n+{\n+  foo (c, j);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Will split parameter\" \"sra\" } } */"}]}