{"sha": "fdda361d74d0d7a3a1f3abba358139846e6a05c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRkYTM2MWQ3NGQwZDdhM2ExZjNhYmJhMzU4MTM5ODQ2ZTZhMDVjOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-07-20T06:39:38Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-07-20T06:39:38Z"}, "message": "config.gcc: Remove support for sparc-*-openbsd*...\n\ngcc/\n\t* config.gcc: Remove support for sparc-*-openbsd*,\n\ti860-*-sysv4*, ip2k-*-elf, ns32k-*-netbsdelf*,\n\tns32k-*-netbsd*.\n\t* config.host: Remove support for i860-*-sysv4* as a host.\n\t* config/i860/*, config/ip2k/*, config/ns32k/*,\n\tconfig/sparc/openbsd.h, config/sparc/t-openbsd: Remove.\n\t* doc/install.texi, doc/invoke.texi, doc/md.texi: Don't\n\tmention obsolete ports.\n\ntestsuite/\n\t* gcc.dg/20020312-2.c, gcc.dg/sibcall-3.c, gcc.dg/sibcall-4.c,\n\tgcc.dg/cpp/assert4.c: Don't mention obsolete ports.\n\nFrom-SVN: r102189", "tree": {"sha": "2b9e6529be54223bc03b5573062543f617b7d081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b9e6529be54223bc03b5573062543f617b7d081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdda361d74d0d7a3a1f3abba358139846e6a05c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdda361d74d0d7a3a1f3abba358139846e6a05c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdda361d74d0d7a3a1f3abba358139846e6a05c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdda361d74d0d7a3a1f3abba358139846e6a05c8/comments", "author": null, "committer": null, "parents": [{"sha": "96a2347e1d837369cf266b937faf59511f0307ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a2347e1d837369cf266b937faf59511f0307ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96a2347e1d837369cf266b937faf59511f0307ce"}], "stats": {"total": 28598, "additions": 19, "deletions": 28579}, "files": [{"sha": "61dbaef78e945b01305c87ec41c854aa1c0a66e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -1,3 +1,14 @@\n+2005-07-20  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config.gcc: Remove support for sparc-*-openbsd*,\n+\ti860-*-sysv4*, ip2k-*-elf, ns32k-*-netbsdelf*,\n+\tns32k-*-netbsd*.\n+\t* config.host: Remove support for i860-*-sysv4* as a host.\n+\t* config/i860/*, config/ip2k/*, config/ns32k/*,\n+\tconfig/sparc/openbsd.h, config/sparc/t-openbsd: Remove.\n+\t* doc/install.texi, doc/invoke.texi, doc/md.texi: Don't\n+\tmention obsolete ports.\n+\n 2005-07-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (regno_reg_class): Add GENERAL_REGS for"}, {"sha": "c33b491acd5d7316229ed02130fe058a1b7eeb07", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -184,12 +184,7 @@ md_file=\n \n # Obsolete configurations.\n case ${target} in\n-   sparc-*-openbsd*\t\\\n- | i860-*-sysv4*\t\\\n- | ip2k-*-elf\t\t\\\n- | ns32k-*-netbsdelf*\t\\\n- | ns32k-*-netbsd*\t\\\n- | c4x-*\t\t\\\n+   c4x-*\t\t\\\n  | tic4x-*\t\t\\\n  )\n     if test \"x$enable_obsolete\" != xyes; then\n@@ -1226,12 +1221,6 @@ i[34567]86-*-kaos*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h kaos.h i386/kaos-i386.h\"\n \ttmake_file=\"i386/t-i386elf t-svr4\"\n \t;;\n-i860-*-sysv4*)\n-        tm_file=\"${tm_file} elfos.h svr4.h i860/sysv4.h\"\n-        tmake_file=\"i860/t-i860 i860/t-svr4\"\n-        extra_parts=\"crtbegin.o crtend.o\"\n-\tuse_fixproto=yes\n-        ;;\n ia64*-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h ia64/sysv4.h ia64/elf.h\"\n \ttmake_file=\"ia64/t-ia64\"\n@@ -1279,10 +1268,6 @@ ia64*-*-hpux*)\n \t# in ia64/t-hpux, and also fix the definition of putenv in\n \t# sys-protos.h (const char not char).\n \t;;\n-ip2k-*-elf)\n-\ttm_file=\"elfos.h ${tm_file}\"\n-\tuse_fixproto=yes\n-\t;;\n iq2000*-*-elf*)\n         tm_file=\"svr4.h elfos.h iq2000/iq2000.h\"\n         tmake_file=iq2000/t-iq2000\n@@ -1557,16 +1542,6 @@ mn10300-*-*)\n \tuse_collect2=no\n \tuse_fixproto=yes\n \t;;\n-ns32k-*-netbsdelf*)\n-\techo \"GCC does not yet support the ${target} target\"; exit 1\n-\t;;\n-ns32k-*-netbsd*)\n-\ttm_file=\"${tm_file} netbsd.h netbsd-aout.h ns32k/netbsd.h\"\n-\t# On NetBSD, the headers are already okay, except for math.h.\n-\ttmake_file=\"t-netbsd ns32k/t-ns32k\"\n-\textra_parts=\"\"\n-\tuse_collect2=yes\n-\t;;\n pdp11-*-bsd)\n \ttm_file=\"${tm_file} pdp11/2bsd.h\"\n \tuse_fixproto=yes\n@@ -1995,14 +1970,6 @@ sparc-*-netbsdelf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h netbsd.h netbsd-elf.h sparc/netbsd-elf.h\"\n \textra_options=\"${extra_options} sparc/long-double-switch.opt\"\n \t;;\n-sparc-*-openbsd*)\n-\ttm_defines=OBSD_OLD_GAS\n-\ttm_file=\"sparc/sparc.h openbsd.h sparc/openbsd.h\"\n-\t# needed to unconfuse gdb\n-\ttmake_file=\"t-libc-ok t-openbsd sparc/t-openbsd\"\n-\t# we need collect2 until our bug is fixed...\n-\tuse_collect2=yes\n-\t;;\n sparc64-*-openbsd*)\n \ttm_file=\"sparc/openbsd1-64.h ${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp64-elf.h openbsd.h sparc/openbsd64.h\"\n \textra_options=\"${extra_options} sparc/little-endian.opt\""}, {"sha": "0f804aa543cb9bb53c6bf28ac80eeaea1547db65", "filename": "gcc/config.host", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -177,9 +177,6 @@ case ${host} in\n     out_host_hook_obj=\"${out_host_hook_obj} host-i386-darwin.o\"\n     host_xmake_file=\"${host_xmake_file} i386/x-darwin\"\n     ;;\n-  i860-*-sysv4*)\n-    host_xmake_file=i860/x-sysv4\n-    ;;\n   powerpc-*-beos*)\n     host_can_use_collect2=no\n     ;;"}, {"sha": "af5dfda84db0e977c132bb89a8f9c4144264e22e", "filename": "gcc/config/i860/i860-protos.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860-protos.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,53 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 860.\n-   Copyright (C) 2000, 2003, 2004 Free Software Foundation, Inc.\n-   Hacked substantially by Ron Guilmette (rfg@monkeys.com) to cater to\n-   the whims of the System V Release 4 assembler.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-/* Declare things which are defined in i860.c but called from\n-   insn-output.c.  */\n-\n-#ifdef RTX_CODE\n-extern unsigned long sfmode_constant_to_ulong (rtx);\n-extern const char *output_load (rtx *);\n-extern const char *output_store (rtx *);\n-extern const char *output_move_double (rtx *);\n-extern const char *output_fp_move_double (rtx *);\n-extern const char *output_block_move (rtx *);\n-extern void output_load_address (rtx *);\n-extern int safe_insn_src_p (rtx, enum machine_mode);\n-extern int operand_clobbered_before_used_after (rtx, rtx);\n-extern int reg_or_0_operand (rtx, enum machine_mode);\n-extern int arith_operand (rtx, enum machine_mode);\n-extern int logic_operand (rtx, enum machine_mode);\n-extern int shift_operand (rtx, enum machine_mode);\n-extern int compare_operand (rtx, enum machine_mode);\n-extern int bte_operand (rtx, enum machine_mode);\n-extern int indexed_operand (rtx, enum machine_mode);\n-extern int load_operand (rtx, enum machine_mode);\n-extern int small_int (rtx, enum machine_mode);\n-extern int logic_int (rtx, enum machine_mode);\n-extern int call_insn_operand (rtx, enum machine_mode);\n-#ifdef TREE_CODE\n-extern void i860_va_start (tree, rtx);\n-#endif /* TREE_CODE */\n-#endif /* RTX_CODE */\n-\n-extern void tdesc_section (void);\n-"}, {"sha": "bcc6477990d458c7972418fdbd2ccf4994e55b61", "filename": "gcc/config/i860/i860.c", "status": "removed", "additions": 0, "deletions": 2127, "changes": 2127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,2127 +0,0 @@\n-/* Subroutines for insn-output.c for Intel i860\n-   Copyright (C) 1989, 1991, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005\n-   Free Software Foundation, Inc.\n-   Derived from sparc.c.\n-\n-   Written by Richard Stallman (rms@ai.mit.edu).\n-\n-   Hacked substantially by Ron Guilmette (rfg@netcom.com) to cater\n-   to the whims of the System V Release 4 assembler.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"flags.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"recog.h\"\n-#include \"insn-attr.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-#include \"langhooks.h\"\n-#include \"tree-gimple.h\"\n-\n-static rtx find_addr_reg (rtx);\n-\n-#ifndef I860_REG_PREFIX\n-#define I860_REG_PREFIX \"\"\n-#endif\n-\n-const char *i860_reg_prefix = I860_REG_PREFIX;\n-\n-/* Save information from a \"cmpxx\" operation until the branch is emitted.  */\n-\n-rtx i860_compare_op0, i860_compare_op1;\n-\f\n-/* Return nonzero if this pattern, can be evaluated safely, even if it\n-   was not asked for.  */\n-int\n-safe_insn_src_p (rtx op, enum machine_mode mode)\n-{\n-  /* Just experimenting.  */\n-\n-  /* No floating point source is safe if it contains an arithmetic\n-     operation, since that operation may trap.  */\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST:\n-      return 1;\n-\n-    case REG:\n-      return 1;\n-\n-    case MEM:\n-      return CONSTANT_ADDRESS_P (XEXP (op, 0));\n-\n-      /* We never need to negate or complement constants.  */\n-    case NEG:\n-      return (mode != SFmode && mode != DFmode);\n-    case NOT:\n-    case ZERO_EXTEND:\n-      return 1;\n-\n-    case EQ:\n-    case NE:\n-    case LT:\n-    case GT:\n-    case LE:\n-    case GE:\n-    case LTU:\n-    case GTU:\n-    case LEU:\n-    case GEU:\n-    case MINUS:\n-    case PLUS:\n-      return (mode != SFmode && mode != DFmode);\n-    case AND:\n-    case IOR:\n-    case XOR:\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if ((GET_CODE (XEXP (op, 0)) == CONST_INT && ! SMALL_INT (XEXP (op, 0)))\n-\t  || (GET_CODE (XEXP (op, 1)) == CONST_INT && ! SMALL_INT (XEXP (op, 1))))\n-\treturn 0;\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return 1 if REG is clobbered in IN.\n-   Return 2 if REG is used in IN. \n-   Return 3 if REG is both used and clobbered in IN.\n-   Return 0 if none of the above.  */\n-\n-static int\n-reg_clobbered_p (rtx reg, rtx in)\n-{\n-  register enum rtx_code code;\n-\n-  if (in == 0)\n-    return 0;\n-\n-  code = GET_CODE (in);\n-\n-  if (code == SET || code == CLOBBER)\n-    {\n-      rtx dest = SET_DEST (in);\n-      int set = 0;\n-      int used = 0;\n-\n-      while (GET_CODE (dest) == STRICT_LOW_PART\n-\t     || GET_CODE (dest) == SUBREG\n-\t     || GET_CODE (dest) == ZERO_EXTRACT)\n-\tdest = XEXP (dest, 0);\n-\n-      if (dest == reg)\n-\tset = 1;\n-      else if (GET_CODE (dest) == REG\n-\t       && refers_to_regno_p (REGNO (reg),\n-\t\t\t\t     REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n-\t\t\t\t     SET_DEST (in), 0))\n-\t{\n-\t  set = 1;\n-\t  /* Anything that sets just part of the register\n-\t     is considered using as well as setting it.\n-\t     But note that a straight SUBREG of a single-word value\n-\t     clobbers the entire value.  */\n-\t  if (dest != SET_DEST (in)\n-\t      && ! (GET_CODE (SET_DEST (in)) == SUBREG\n-\t\t    || UNITS_PER_WORD >= GET_MODE_SIZE (GET_MODE (dest))))\n-\t    used = 1;\n-\t}\n-\n-      if (code == SET)\n-\t{\n-\t  if (set)\n-\t    used = refers_to_regno_p (REGNO (reg),\n-\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n-\t\t\t\t      SET_SRC (in), 0);\n-\t  else\n-\t    used = refers_to_regno_p (REGNO (reg),\n-\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n-\t\t\t\t      in, 0);\n-\t}\n-\n-      return set + used * 2;\n-    }\n-\n-  if (refers_to_regno_p (REGNO (reg),\n-\t\t\t REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n-\t\t\t in, 0))\n-    return 2;\n-  return 0;\n-}\n-\n-/* Return nonzero if OP can be written to without screwing up\n-   GCC's model of what's going on.  It is assumed that this operand\n-   appears in the dest position of a SET insn in a conditional\n-   branch's delay slot.  AFTER is the label to start looking from.  */\n-int\n-operand_clobbered_before_used_after (rtx op, rtx after)\n-{\n-  /* Just experimenting.  */\n-  if (GET_CODE (op) == CC0)\n-    return 1;\n-  if (GET_CODE (op) == REG)\n-    {\n-      rtx insn;\n-\n-      if (op == stack_pointer_rtx)\n-\treturn 0;\n-\n-      /* Scan forward from the label, to see if the value of OP\n-\t is clobbered before the first use.  */\n-\n-      for (insn = NEXT_INSN (after); insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == NOTE)\n-\t    continue;\n-\t  if (GET_CODE (insn) == INSN\n-\t      || GET_CODE (insn) == JUMP_INSN\n-\t      || GET_CODE (insn) == CALL_INSN)\n-\t    {\n-\t      switch (reg_clobbered_p (op, PATTERN (insn)))\n-\t\t{\n-\t\tdefault:\n-\t\t  return 0;\n-\t\tcase 1:\n-\t\t  return 1;\n-\t\tcase 0:\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  /* If we reach another label without clobbering OP,\n-\t     then we cannot safely write it here.  */\n-\t  else if (GET_CODE (insn) == CODE_LABEL)\n-\t    return 0;\n-\t  if (GET_CODE (insn) == JUMP_INSN)\n-\t    {\n-\t      if (condjump_p (insn))\n-\t\treturn 0;\n-\t      /* This is a jump insn which has already\n-\t\t been mangled.  We can't tell what it does.  */\n-\t      if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t\treturn 0;\n-\t      if (! JUMP_LABEL (insn))\n-\t\treturn 0;\n-\t      /* Keep following jumps.  */\n-\t      insn = JUMP_LABEL (insn);\n-\t    }\n-\t}\n-      return 1;\n-    }\n-\n-  /* In both of these cases, the first insn executed\n-     for this op will be a orh whatever%h,%r0,%r31,\n-     which is tolerable.  */\n-  if (GET_CODE (op) == MEM)\n-    return (CONSTANT_ADDRESS_P (XEXP (op, 0)));\n-\n-  return 0;\n-}\n-\n-\f\n-/* Return nonzero only if OP is a register of mode MODE,\n-   or const0_rtx.  */\n-int\n-reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  return (op == const0_rtx || register_operand (op, mode)\n-\t  || op == CONST0_RTX (mode));\n-}\n-\n-/* Return truth value of whether OP can be used as an operands in a three\n-   address add/subtract insn (such as add %o1,7,%l2) of mode MODE.  */\n-\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n-}\n-\n-/* Return 1 if OP is a valid first operand for a logical insn of mode MODE.  */\n-\n-int\n-logic_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && LOGIC_INT (op)));\n-}\n-\n-/* Return 1 if OP is a valid first operand for a shift insn of mode MODE.  */\n-\n-int\n-shift_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-          || (GET_CODE (op) == CONST_INT));\n-}\n-\n-/* Return 1 if OP is a valid first operand for either a logical insn\n-   or an add insn of mode MODE.  */\n-\n-int\n-compare_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op) && LOGIC_INT (op)));\n-}\n-\n-/* Return truth value of whether OP can be used as the 5-bit immediate\n-   operand of a bte or btne insn.  */\n-\n-int\n-bte_operand (rtx op, enum machine_mode mode)\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (unsigned) INTVAL (op) < 0x20));\n-}\n-\n-/* Return 1 if OP is an indexed memory reference of mode MODE.  */\n-\n-int\n-indexed_operand (rtx op, enum machine_mode mode)\n-{\n-  return (GET_CODE (op) == MEM && GET_MODE (op) == mode\n-\t  && GET_CODE (XEXP (op, 0)) == PLUS\n-\t  && GET_MODE (XEXP (op, 0)) == SImode\n-\t  && register_operand (XEXP (XEXP (op, 0), 0), SImode)\n-\t  && register_operand (XEXP (XEXP (op, 0), 1), SImode));\n-}\n-\n-/* Return 1 if OP is a suitable source operand for a load insn\n-   with mode MODE.  */\n-\n-int\n-load_operand (rtx op, enum machine_mode mode)\n-{\n-  return (memory_operand (op, mode) || indexed_operand (op, mode));\n-}\n-\n-/* Return truth value of whether OP is an integer which fits the\n-   range constraining immediate operands in add/subtract insns.  */\n-\n-int\n-small_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n-}\n-\n-/* Return truth value of whether OP is an integer which fits the\n-   range constraining immediate operands in logic insns.  */\n-\n-int\n-logic_int (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && LOGIC_INT (op));\n-}\n-\n-/* Test for a valid operand for a call instruction.\n-   Don't allow the arg pointer register or virtual regs\n-   since they may change into reg + const, which the patterns\n-   can't handle yet.  */\n-\n-int\n-call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == MEM\n-      && (CONSTANT_ADDRESS_P (XEXP (op, 0))\n-\t  || (GET_CODE (XEXP (op, 0)) == REG\n-\t      && XEXP (op, 0) != arg_pointer_rtx\n-\t      && !(REGNO (XEXP (op, 0)) >= FIRST_PSEUDO_REGISTER\n-\t\t   && REGNO (XEXP (op, 0)) <= LAST_VIRTUAL_REGISTER))))\n-    return 1;\n-  return 0;\n-}\n-\f\n-/* Return the best assembler insn template\n-   for moving operands[1] into operands[0] as a fullword.  */\n-\n-static const char *\n-singlemove_string (rtx *operands)\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (GET_CODE (operands[1]) != MEM)\n-\tif (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-\t  {\n-\t    if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t   && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t   && cc_prev_status.mdep == XEXP (operands[0], 0)))\n-\t      {\n-\t\tCC_STATUS_INIT;\n-\t        output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n-\t      }\n-\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t    cc_status.mdep = XEXP (operands[0], 0);\n-\t    return \"st.l %r1,%L0(%?r31)\";\n-\t  }\n-\telse\n-\t  return \"st.l %r1,%0\";\n-      else\n-\tabort ();\n-#if 0\n-\t{\n-\t  rtx xoperands[2];\n-\n-\t  cc_status.flags &= ~CC_F0_IS_0;\n-\t  xoperands[0] = gen_rtx_REG (SFmode, 32);\n-\t  xoperands[1] = operands[1];\n-\t  output_asm_insn (singlemove_string (xoperands), xoperands);\n-\t  xoperands[1] = xoperands[0];\n-\t  xoperands[0] = operands[0];\n-\t  output_asm_insn (singlemove_string (xoperands), xoperands);\n-\t  return \"\";\n-\t}\n-#endif\n-    }\n-  if (GET_CODE (operands[1]) == MEM)\n-    {\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-\t{\n-\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n-\t    }\n-\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t  cc_status.mdep = XEXP (operands[1], 0);\n-\t  return \"ld.l %L1(%?r31),%0\";\n-\t}\n-      return \"ld.l %m1,%0\";\n-    }\n- if (GET_CODE (operands[1]) == CONST_INT)\n-   {\n-     if (operands[1] == const0_rtx)\n-      return \"mov %?r0,%0\";\n-     if((INTVAL (operands[1]) & 0xffff0000) == 0)\n-      return \"or %L1,%?r0,%0\";\n-     if((INTVAL (operands[1]) & 0xffff8000) == 0xffff8000)\n-      return \"adds %1,%?r0,%0\";\n-     if((INTVAL (operands[1]) & 0x0000ffff) == 0)\n-      return \"orh %H1,%?r0,%0\";\n-\n-     return \"orh %H1,%?r0,%0\\n\\tor %L1,%0,%0\";\n-   }\n-  return \"mov %1,%0\";\n-}\n-\f\n-/* Output assembler code to perform a doubleword move insn\n-   with operands OPERANDS.  */\n-\n-const char *\n-output_move_double (rtx *operands)\n-{\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n-  rtx latehalf[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n-  int highest_first = 0;\n-  int no_addreg1_decrement = 0;\n-\n-  /* First classify both operands.  */\n-\n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (operands[0]) == MEM)\n-    optype0 = MEMOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1]))\n-    optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (operands[1]) == MEM)\n-    optype1 = MEMOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  if (optype0 == RNDOP || optype1 == RNDOP)\n-    abort ();\n-\n-  /* If an operand is an unoffsettable memory reference, find a register\n-     we can increment temporarily to make it refer to the second word.  */\n-\n-  if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n-\n-  if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n-\n-/* ??? Perhaps in some cases move double words\n-   if there is a spare pair of floating regs.  */\n-\n-  /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-\n-     In either case, set up in LATEHALF the operands to use\n-     for the high-numbered word and in some cases alter the\n-     operands in OPERANDS to be suitable for the low-numbered word.  */\n-\n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adjust_address (operands[0], SImode, 4);\n-  else\n-    latehalf[0] = operands[0];\n-\n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adjust_address (operands[1], SImode, 4);\n-  else if (optype1 == CNSTOP)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n-#if 0\n-      else if (CONSTANT_P (operands[1]))\n-\tlatehalf[1] = const0_rtx;\n-#else\n-      else if (CONSTANT_P (operands[1]))\n-        split_double (operands[1], &operands[1], &latehalf[1]);\n-#endif\n-    }\n-  else\n-    latehalf[1] = operands[1];\n-\n-  /* If the first move would clobber the source of the second one,\n-     do them in the other order.\n-\n-     RMS says \"This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.\"\n-\n-     But it happens on the sparc when loading parameter registers,\n-     so I am going to define that circumstance, and make it work\n-     as expected.  */\n-\n-  if (optype0 == REGOP && optype1 == REGOP\n-      && REGNO (operands[0]) == REGNO (latehalf[1]))\n-    {\n-      CC_STATUS_PARTIAL_INIT;\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"adds 0x4,%0,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"adds 0x4,%0,%0\", &addreg1);\n-\n-      /* Do that word.  */\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"adds -0x4,%0,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"adds -0x4,%0,%0\", &addreg1);\n-\n-      /* Do low-numbered word.  */\n-      return singlemove_string (operands);\n-    }\n-  else if (optype0 == REGOP && optype1 != REGOP\n-\t   && reg_overlap_mentioned_p (operands[0], operands[1]))\n-    {\n-      /* If both halves of dest are used in the src memory address,\n-\t add the two regs and put them in the low reg (operands[0]).\n-\t Then it works to load latehalf first.  */\n-      if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n-\t  && reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n-\t{\n-\t  rtx xops[2];\n-\t  xops[0] = latehalf[0];\n-\t  xops[1] = operands[0];\n-\t  output_asm_insn (\"adds %1,%0,%1\", xops);\n-\t  operands[1] = gen_rtx_MEM (DImode, operands[0]);\n-\t  latehalf[1] = adjust_address (operands[1], SImode, 4);\n-\t  addreg1 = 0;\n-\t  highest_first = 1;\n-\t}\n-      /* Only one register in the dest is used in the src memory address,\n-\t and this is the first register of the dest, so we want to do\n-\t the late half first here also.  */\n-      else if (! reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n-\thighest_first = 1;\n-      /* Only one register in the dest is used in the src memory address,\n-\t and this is the second register of the dest, so we want to do\n-\t the late half last.  If addreg1 is set, and addreg1 is the same\n-\t register as latehalf, then we must suppress the trailing decrement,\n-\t because it would clobber the value just loaded.  */\n-      else if (addreg1 && reg_mentioned_p (addreg1, latehalf[0]))\n-\tno_addreg1_decrement = 1;\n-    }\n-\n-  /* Normal case: do the two words, low-numbered first.\n-     Overlap case (highest_first set): do high-numbered word first.  */\n-\n-  if (! highest_first)\n-    output_asm_insn (singlemove_string (operands), operands);\n-\n-  CC_STATUS_PARTIAL_INIT;\n-  /* Make any unoffsettable addresses point at high-numbered word.  */\n-  if (addreg0)\n-    output_asm_insn (\"adds 0x4,%0,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"adds 0x4,%0,%0\", &addreg1);\n-\n-  /* Do that word.  */\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    output_asm_insn (\"adds -0x4,%0,%0\", &addreg0);\n-  if (addreg1 && !no_addreg1_decrement)\n-    output_asm_insn (\"adds -0x4,%0,%0\", &addreg1);\n-\n-  if (highest_first)\n-    output_asm_insn (singlemove_string (operands), operands);\n-\n-  return \"\";\n-}\n-\f\n-const char *\n-output_fp_move_double (rtx *operands)\n-{\n-  /* If the source operand is any sort of zero, use f0 instead.  */\n-\n-  if (operands[1] == CONST0_RTX (GET_MODE (operands[1])))\n-    operands[1] = gen_rtx_REG (DFmode, F0_REGNUM);\n-\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \"fmov.dd %1,%0\";\n-      if (GET_CODE (operands[1]) == REG)\n-\t{\n-\t  output_asm_insn (\"ixfr %1,%0\", operands);\n-\t  operands[0] = gen_rtx_REG (VOIDmode, REGNO (operands[0]) + 1);\n-\t  operands[1] = gen_rtx_REG (VOIDmode, REGNO (operands[1]) + 1);\n-\t  return \"ixfr %1,%0\";\n-\t}\n-      if (operands[1] == CONST0_RTX (DFmode))\n-\treturn \"fmov.dd f0,%0\";\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-\t{\n-\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n-\t    }\n-\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t  cc_status.mdep = XEXP (operands[1], 0);\n-\t  return \"fld.d %L1(%?r31),%0\";\n-\t}\n-      return \"fld.d %1,%0\";\n-    }\n-  else if (FP_REG_P (operands[1]))\n-    {\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  output_asm_insn (\"fxfr %1,%0\", operands);\n-\t  operands[0] = gen_rtx_REG (VOIDmode, REGNO (operands[0]) + 1);\n-\t  operands[1] = gen_rtx_REG (VOIDmode, REGNO (operands[1]) + 1);\n-\t  return \"fxfr %1,%0\";\n-\t}\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-\t{\n-\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t && cc_prev_status.mdep == XEXP (operands[0], 0)))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n-\t    }\n-\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t  cc_status.mdep = XEXP (operands[0], 0);\n-\t  return \"fst.d %1,%L0(%?r31)\";\n-\t}\n-      return \"fst.d %1,%0\";\n-    }\n-  else\n-    abort ();\n-  /* NOTREACHED */\n-  return NULL;\n-}\n-\f\n-/* Return a REG that occurs in ADDR with coefficient 1.\n-   ADDR can be effectively incremented by incrementing REG.  */\n-\n-static rtx\n-find_addr_reg (rtx addr)\n-{\n-  while (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\taddr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 0)))\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 1)))\n-\taddr = XEXP (addr, 0);\n-      else\n-\tabort ();\n-    }\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  abort ();\n-  /* NOTREACHED */\n-  return NULL;\n-}\n-\n-/* Return a template for a load instruction with mode MODE and\n-   arguments from the string ARGS.\n-\n-  This string is in static storage.  */\n-\n-static const char *\n-load_opcode (enum machine_mode mode, const char *args, rtx reg)\n-{\n-  static char buf[30];\n-  const char *opcode;\n-\n-  switch (mode)\n-    {\n-    case QImode:\n-      opcode = \"ld.b\";\n-      break;\n-\n-    case HImode:\n-      opcode = \"ld.s\";\n-      break;\n-\n-    case SImode:\n-    case SFmode:\n-      if (FP_REG_P (reg))\n-\topcode = \"fld.l\";\n-      else\n-\topcode = \"ld.l\";\n-      break;\n-\n-    case DImode:\n-      if (!FP_REG_P (reg))\n-\tabort ();\n-    case DFmode:\n-      opcode = \"fld.d\";\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  sprintf (buf, \"%s %s\", opcode, args);\n-  return buf;\n-}\n-\n-/* Return a template for a store instruction with mode MODE and\n-   arguments from the string ARGS.\n-\n-   This string is in static storage.  */\n-\n-static const char *\n-store_opcode (enum machine_mode mode, const char *args, rtx reg)\n-{\n-  static char buf[30];\n-  const char *opcode;\n-\n-  switch (mode)\n-    {\n-    case QImode:\n-      opcode = \"st.b\";\n-      break;\n-\n-    case HImode:\n-      opcode = \"st.s\";\n-      break;\n-\n-    case SImode:\n-    case SFmode:\n-      if (FP_REG_P (reg))\n-\topcode = \"fst.l\";\n-      else\n-\topcode = \"st.l\";\n-      break;\n-\n-    case DImode:\n-      if (!FP_REG_P (reg))\n-\tabort ();\n-    case DFmode:\n-      opcode = \"fst.d\";\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  sprintf (buf, \"%s %s\", opcode, args);\n-  return buf;\n-}\n-\f\n-/* Output a store-in-memory whose operands are OPERANDS[0,1].\n-   OPERANDS[0] is a MEM, and OPERANDS[1] is a reg or zero.\n-\n-   This function returns a template for an insn.\n-   This is in static storage.\n-\n-   It may also output some insns directly.\n-   It may alter the values of operands[0] and operands[1].  */\n-\n-const char *\n-output_store (rtx *operands)\n-{\n-  enum machine_mode mode = GET_MODE (operands[0]);\n-  rtx address = XEXP (operands[0], 0);\n-\n-  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-  cc_status.mdep = address;\n-\n-  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t && address == cc_prev_status.mdep))\n-    {\n-      CC_STATUS_INIT;\n-      output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n-      cc_prev_status.mdep = address;\n-    }\n-\n-  /* Store zero in two parts when appropriate.  */\n-  if (mode == DFmode && operands[1] == CONST0_RTX (DFmode))\n-    return store_opcode (DFmode, \"%r1,%L0(%?r31)\", operands[1]);\n-\n-  /* Code below isn't smart enough to move a doubleword in two parts,\n-     so use output_move_double to do that in the cases that require it.  */\n-  if ((mode == DImode || mode == DFmode)\n-      && ! FP_REG_P (operands[1]))\n-    return output_move_double (operands);\n-\n-  return store_opcode (mode, \"%r1,%L0(%?r31)\", operands[1]);\n-}\n-\n-/* Output a load-from-memory whose operands are OPERANDS[0,1].\n-   OPERANDS[0] is a reg, and OPERANDS[1] is a mem.\n-\n-   This function returns a template for an insn.\n-   This is in static storage.\n-\n-   It may also output some insns directly.\n-   It may alter the values of operands[0] and operands[1].  */\n-\n-const char *\n-output_load (rtx *operands)\n-{\n-  enum machine_mode mode = GET_MODE (operands[0]);\n-  rtx address = XEXP (operands[1], 0);\n-\n-  /* We don't bother trying to see if we know %hi(address).\n-     This is because we are doing a load, and if we know the\n-     %hi value, we probably also know that value in memory.  */\n-  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-  cc_status.mdep = address;\n-\n-  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t && address == cc_prev_status.mdep\n-\t && cc_prev_status.mdep == cc_status.mdep))\n-    {\n-      CC_STATUS_INIT;\n-      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n-      cc_prev_status.mdep = address;\n-    }\n-\n-  /* Code below isn't smart enough to move a doubleword in two parts,\n-     so use output_move_double to do that in the cases that require it.  */\n-  if ((mode == DImode || mode == DFmode)\n-      && ! FP_REG_P (operands[0]))\n-    return output_move_double (operands);\n-\n-  return load_opcode (mode, \"%L1(%?r31),%0\", operands[0]);\n-}\n-\f\n-#if 0\n-/* Load the address specified by OPERANDS[3] into the register\n-   specified by OPERANDS[0].\n-\n-   OPERANDS[3] may be the result of a sum, hence it could either be:\n-\n-   (1) CONST\n-   (2) REG\n-   (2) REG + CONST_INT\n-   (3) REG + REG + CONST_INT\n-   (4) REG + REG  (special case of 3).\n-\n-   Note that (3) is not a legitimate address.\n-   All cases are handled here.  */\n-\n-void\n-output_load_address (rtx *operands)\n-{\n-  rtx base, offset;\n-\n-  if (CONSTANT_P (operands[3]))\n-    {\n-      output_asm_insn (\"mov %3,%0\", operands);\n-      return;\n-    }\n-\n-  if (REG_P (operands[3]))\n-    {\n-      if (REGNO (operands[0]) != REGNO (operands[3]))\n-\toutput_asm_insn (\"shl %?r0,%3,%0\", operands);\n-      return;\n-    }\n-\n-  if (GET_CODE (operands[3]) != PLUS)\n-    abort ();\n-\n-  base = XEXP (operands[3], 0);\n-  offset = XEXP (operands[3], 1);\n-\n-  if (GET_CODE (base) == CONST_INT)\n-    {\n-      rtx tmp = base;\n-      base = offset;\n-      offset = tmp;\n-    }\n-\n-  if (GET_CODE (offset) != CONST_INT)\n-    {\n-      /* Operand is (PLUS (REG) (REG)).  */\n-      base = operands[3];\n-      offset = const0_rtx;\n-    }\n-\n-  if (REG_P (base))\n-    {\n-      operands[6] = base;\n-      operands[7] = offset;\n-      CC_STATUS_PARTIAL_INIT;\n-      if (SMALL_INT (offset))\n-\toutput_asm_insn (\"adds %7,%6,%0\", operands);\n-      else\n-\toutput_asm_insn (\"mov %7,%0\\n\\tadds %0,%6,%0\", operands);\n-    }\n-  else if (GET_CODE (base) == PLUS)\n-    {\n-      operands[6] = XEXP (base, 0);\n-      operands[7] = XEXP (base, 1);\n-      operands[8] = offset;\n-\n-      CC_STATUS_PARTIAL_INIT;\n-      if (SMALL_INT (offset))\n-\toutput_asm_insn (\"adds %6,%7,%0\\n\\tadds %8,%0,%0\", operands);\n-      else\n-\toutput_asm_insn (\"mov %8,%0\\n\\tadds %0,%6,%0\\n\\tadds %0,%7,%0\", operands);\n-    }\n-  else\n-    abort ();\n-}\n-#endif\n-\n-/* Output code to place a size count SIZE in register REG.\n-   Because block moves are pipelined, we don't include the\n-   first element in the transfer of SIZE to REG.\n-   For this, we subtract ALIGN.  (Actually, I think it is not\n-   right to subtract on this machine, so right now we don't.)  */\n-\n-static void\n-output_size_for_block_move (rtx size, rtx reg, rtx align)\n-{\n-  rtx xoperands[3];\n-\n-  xoperands[0] = reg;\n-  xoperands[1] = size;\n-  xoperands[2] = align;\n-\n-#if 1\n-  cc_status.flags &= ~ CC_KNOW_HI_R31;\n-  output_asm_insn (singlemove_string (xoperands), xoperands);\n-#else\n-  if (GET_CODE (size) == REG)\n-    output_asm_insn (\"sub %2,%1,%0\", xoperands);\n-  else\n-    {\n-      xoperands[1] = GEN_INT (INTVAL (size) - INTVAL (align));\n-      cc_status.flags &= ~ CC_KNOW_HI_R31;\n-      output_asm_insn (\"mov %1,%0\", xoperands);\n-    }\n-#endif\n-}\n-\n-/* Emit code to perform a block move.\n-\n-   OPERANDS[0] is the destination.\n-   OPERANDS[1] is the source.\n-   OPERANDS[2] is the size.\n-   OPERANDS[3] is the known safe alignment.\n-   OPERANDS[4..6] are pseudos we can safely clobber as temps.  */\n-\n-const char *\n-output_block_move (rtx *operands)\n-{\n-  /* A vector for our computed operands.  Note that load_output_address\n-     makes use of (and can clobber) up to the 8th element of this vector.  */\n-  rtx xoperands[10];\n-#if 0\n-  rtx zoperands[10];\n-#endif\n-  static int movmemsi_label = 0;\n-  int i;\n-  rtx temp1 = operands[4];\n-  rtx alignrtx = operands[3];\n-  int align = INTVAL (alignrtx);\n-  int chunk_size;\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[1];\n-  xoperands[2] = temp1;\n-\n-  /* We can't move more than four bytes at a time\n-     because we have only one register to move them through.  */\n-  if (align > 4)\n-    {\n-      align = 4;\n-      alignrtx = GEN_INT (4);\n-    }\n-\n-  /* Recognize special cases of block moves.  These occur\n-     when GNU C++ is forced to treat something as BLKmode\n-     to keep it in memory, when its mode could be represented\n-     with something smaller.\n-\n-     We cannot do this for global variables, since we don't know\n-     what pages they don't cross.  Sigh.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && ! CONSTANT_ADDRESS_P (operands[0])\n-      && ! CONSTANT_ADDRESS_P (operands[1]))\n-    {\n-      int size = INTVAL (operands[2]);\n-      rtx op0 = xoperands[0];\n-      rtx op1 = xoperands[1];\n-\n-      if ((align & 3) == 0 && (size & 3) == 0 && (size >> 2) <= 16)\n-\t{\n-\t  if (memory_address_p (SImode, plus_constant (op0, size))\n-\t      && memory_address_p (SImode, plus_constant (op1, size)))\n-\t    {\n-\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n-\t      for (i = (size>>2)-1; i >= 0; i--)\n-\t\t{\n-\t\t  xoperands[0] = plus_constant (op0, i * 4);\n-\t\t  xoperands[1] = plus_constant (op1, i * 4);\n-\t\t  output_asm_insn (\"ld.l %a1,%?r31\\n\\tst.l %?r31,%a0\",\n-\t\t\t\t   xoperands);\n-\t\t}\n-\t      return \"\";\n-\t    }\n-\t}\n-      else if ((align & 1) == 0 && (size & 1) == 0 && (size >> 1) <= 16)\n-\t{\n-\t  if (memory_address_p (HImode, plus_constant (op0, size))\n-\t      && memory_address_p (HImode, plus_constant (op1, size)))\n-\t    {\n-\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n-\t      for (i = (size>>1)-1; i >= 0; i--)\n-\t\t{\n-\t\t  xoperands[0] = plus_constant (op0, i * 2);\n-\t\t  xoperands[1] = plus_constant (op1, i * 2);\n-\t\t  output_asm_insn (\"ld.s %a1,%?r31\\n\\tst.s %?r31,%a0\",\n-\t\t\t\t   xoperands);\n-\t\t}\n-\t      return \"\";\n-\t    }\n-\t}\n-      else if (size <= 16)\n-\t{\n-\t  if (memory_address_p (QImode, plus_constant (op0, size))\n-\t      && memory_address_p (QImode, plus_constant (op1, size)))\n-\t    {\n-\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n-\t      for (i = size-1; i >= 0; i--)\n-\t\t{\n-\t\t  xoperands[0] = plus_constant (op0, i);\n-\t\t  xoperands[1] = plus_constant (op1, i);\n-\t\t  output_asm_insn (\"ld.b %a1,%?r31\\n\\tst.b %?r31,%a0\",\n-\t\t\t\t   xoperands);\n-\t\t}\n-\t      return \"\";\n-\t    }\n-\t}\n-    }\n-\n-  /* Since we clobber untold things, nix the condition codes.  */\n-  CC_STATUS_INIT;\n-\n-  /* This is the size of the transfer.\n-     Either use the register which already contains the size,\n-     or use a free register (used by no operands).  */\n-  output_size_for_block_move (operands[2], operands[4], alignrtx);\n-\n-#if 0\n-  /* Also emit code to decrement the size value by ALIGN.  */\n-  zoperands[0] = operands[0];\n-  zoperands[3] = plus_constant (operands[0], align);\n-  output_load_address (zoperands);\n-#endif\n-\n-  /* Generate number for unique label.  */\n-\n-  xoperands[3] = GEN_INT (movmemsi_label++);\n-\n-  /* Calculate the size of the chunks we will be trying to move first.  */\n-\n-#if 0\n-  if ((align & 3) == 0)\n-    chunk_size = 4;\n-  else if ((align & 1) == 0)\n-    chunk_size = 2;\n-  else\n-#endif\n-    chunk_size = 1;\n-\n-  /* Copy the increment (negative) to a register for bla insn.  */\n-\n-  xoperands[4] = GEN_INT (- chunk_size);\n-  xoperands[5] = operands[5];\n-  output_asm_insn (\"adds %4,%?r0,%5\", xoperands);\n-\n-  /* Predecrement the loop counter.  This happens again also in the `bla'\n-     instruction which precedes the loop, but we need to have it done\n-     two times before we enter the loop because of the bizarre semantics\n-     of the bla instruction.  */\n-\n-  output_asm_insn (\"adds %5,%2,%2\", xoperands);\n-\n-  /* Check for the case where the original count was less than or equal to\n-     zero.  Avoid going through the loop at all if the original count was\n-     indeed less than or equal to zero.  Note that we treat the count as\n-     if it were a signed 32-bit quantity here, rather than an unsigned one,\n-     even though we really shouldn't.  We have to do this because of the\n-     semantics of the `ble' instruction, which assume that the count is\n-     a signed 32-bit value.  Anyway, in practice it won't matter because\n-     nobody is going to try to do a memcpy() of more than half of the\n-     entire address space (i.e. 2 gigabytes) anyway.  */\n-\n-  output_asm_insn (\"bc .Le%3\", xoperands);\n-\n-  /* Make available a register which is a temporary.  */\n-\n-  xoperands[6] = operands[6];\n-\n-  /* Now the actual loop.\n-     In xoperands, elements 1 and 0 are the input and output vectors.\n-     Element 2 is the loop index.  Element 5 is the increment.  */\n-\n-  output_asm_insn (\"subs %1,%5,%1\", xoperands);\n-  output_asm_insn (\"bla %5,%2,.Lm%3\", xoperands);\n-  output_asm_insn (\"adds %0,%2,%6\", xoperands);\n-  output_asm_insn (\"\\n.Lm%3:\", xoperands);\t    /* Label for bla above.  */\n-  output_asm_insn (\"\\n.Ls%3:\",  xoperands);\t    /* Loop start label.  */\n-  output_asm_insn (\"adds %5,%6,%6\", xoperands);\n-\n-  /* NOTE:  The code here which is supposed to handle the cases where the\n-     sources and destinations are known to start on a 4 or 2 byte boundary\n-     are currently broken.  They fail to do anything about the overflow\n-     bytes which might still need to be copied even after we have copied\n-     some number of words or halfwords.  Thus, for now we use the lowest\n-     common denominator, i.e. the code which just copies some number of\n-     totally unaligned individual bytes.  (See the calculation of\n-     chunk_size above.  */\n-\n-  if (chunk_size == 4)\n-    {\n-      output_asm_insn (\"ld.l %2(%1),%?r31\", xoperands);\n-      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n-      output_asm_insn (\"st.l %?r31,8(%6)\", xoperands);\n-    }\n-  else if (chunk_size == 2)\n-    {\n-      output_asm_insn (\"ld.s %2(%1),%?r31\", xoperands);\n-      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n-      output_asm_insn (\"st.s %?r31,4(%6)\", xoperands);\n-    }\n-  else /* chunk_size == 1 */\n-    {\n-      output_asm_insn (\"ld.b %2(%1),%?r31\", xoperands);\n-      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n-      output_asm_insn (\"st.b %?r31,2(%6)\", xoperands);\n-    }\n-  output_asm_insn (\"\\n.Le%3:\", xoperands);\t    /* Here if count <= 0.  */\n-\n-  return \"\";\n-}\n-\f\n-/* Special routine to convert an SFmode value represented as a\n-   CONST_DOUBLE into its equivalent unsigned long bit pattern.\n-   We convert the value from a double precision floating-point\n-   value to single precision first, and thence to a bit-wise\n-   equivalent unsigned long value.  This routine is used when\n-   generating an immediate move of an SFmode value directly\n-   into a general register because the SVR4 assembler doesn't\n-   grok floating literals in instruction operand contexts.  */\n-\n-unsigned long\n-sfmode_constant_to_ulong (rtx x)\n-{\n-  REAL_VALUE_TYPE d;\n-  unsigned long l;\n-\n-  if (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != SFmode)\n-    abort ();\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n-  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n-  return l;\n-}\n-\f\n-/* This function generates the assembly code for function entry.\n-\n-   ASM_FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.\n-\n-   NOTE: `frame_lower_bytes' is the count of bytes which will lie\n-   between the new `fp' value and the new `sp' value after the\n-   prologue is done.  `frame_upper_bytes' is the count of bytes\n-   that will lie between the new `fp' and the *old* `sp' value\n-   after the new `fp' is setup (in the prologue).  The upper\n-   part of each frame always includes at least 2 words (8 bytes)\n-   to hold the saved frame pointer and the saved return address.\n-\n-   The SVR4 ABI for the i860 now requires that the values of the\n-   stack pointer and frame pointer registers be kept aligned to\n-   16-byte boundaries at all times.  We obey that restriction here.\n-\n-   The SVR4 ABI for the i860 is entirely vague when it comes to specifying\n-   exactly where the \"preserved\" registers should be saved.  The native\n-   SVR4 C compiler I now have doesn't help to clarify the requirements\n-   very much because it is plainly out-of-date and non-ABI-compliant\n-   (in at least one important way, i.e. how it generates function\n-   epilogues).\n-\n-   The native SVR4 C compiler saves the \"preserved\" registers (i.e.\n-   r4-r15 and f2-f7) in the lower part of a frame (i.e. at negative\n-   offsets from the frame pointer).\n-\n-   Previous versions of GCC also saved the \"preserved\" registers in the\n-   \"negative\" part of the frame, but they saved them using positive\n-   offsets from the (adjusted) stack pointer (after it had been adjusted\n-   to allocate space for the new frame).  That's just plain wrong\n-   because if the current function calls alloca(), the stack pointer\n-   will get moved, and it will be impossible to restore the registers\n-   properly again after that.\n-\n-   Both compilers handled parameter registers (i.e. r16-r27 and f8-f15)\n-   by copying their values either into various \"preserved\" registers or\n-   into stack slots in the lower part of the current frame (as seemed\n-   appropriate, depending upon subsequent usage of these values).\n-\n-   Here we want to save the preserved registers at some offset from the\n-   frame pointer register so as to avoid any possible problems arising\n-   from calls to alloca().  We can either save them at small positive\n-   offsets from the frame pointer, or at small negative offsets from\n-   the frame pointer.  If we save them at small negative offsets from\n-   the frame pointer (i.e. in the lower part of the frame) then we\n-   must tell the rest of GCC (via STARTING_FRAME_OFFSET) exactly how\n-   many bytes of space we plan to use in the lower part of the frame\n-   for this purpose.  Since other parts of the compiler reference the\n-   value of STARTING_FRAME_OFFSET long before final() calls this function,\n-   we would have to go ahead and assume the worst-case storage requirements\n-   for saving all of the \"preserved\" registers (and use that number, i.e.\n-   `80', to define STARTING_FRAME_OFFSET) if we wanted to save them in\n-   the lower part of the frame.  That could potentially be very wasteful,\n-   and that wastefulness could really hamper people compiling for embedded\n-   i860 targets with very tight limits on stack space.  Thus, we choose\n-   here to save the preserved registers in the upper part of the\n-   frame, so that we can decide at the very last minute how much (or how\n-   little) space we must allocate for this purpose.\n-\n-   To satisfy the needs of the SVR4 ABI \"tdesc\" scheme, preserved\n-   registers must always be saved so that the saved values of registers\n-   with higher numbers are at higher addresses.  We obey that restriction\n-   here.\n-\n-   There are two somewhat different ways that you can generate prologues\n-   here... i.e. pedantically ABI-compliant, and the \"other\" way.  The\n-   \"other\" way is more consistent with what is currently generated by the\n-   \"native\" SVR4 C compiler for the i860.  That's important if you want\n-   to use the current (as of 8/91) incarnation of SVR4 SDB for the i860.\n-   The SVR4 SDB for the i860 insists on having function prologues be\n-   non-ABI-compliant!\n-\n-   To get fully ABI-compliant prologues, define I860_STRICT_ABI_PROLOGUES\n-   in the i860/sysv4.h file.  (By default this is *not* defined).\n-\n-   The differences between the ABI-compliant and non-ABI-compliant prologues\n-   are that (a) the ABI version seems to require the use of *signed*\n-   (rather than unsigned) adds and subtracts, and (b) the ordering of\n-   the various steps (e.g. saving preserved registers, saving the\n-   return address, setting up the new frame pointer value) is different.\n-\n-   For strict ABI compliance, it seems to be the case that the very last\n-   thing that is supposed to happen in the prologue is getting the frame\n-   pointer set to its new value (but only after everything else has\n-   already been properly setup).  We do that here, but only if the symbol\n-   I860_STRICT_ABI_PROLOGUES is defined.  */\n-\n-#ifndef STACK_ALIGNMENT\n-#define STACK_ALIGNMENT\t16\n-#endif\n-\n-const char *current_function_original_name;\n-\n-static int must_preserve_r1;\n-static unsigned must_preserve_bytes;\n-\n-static void\n-i860_output_function_prologue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n-{\n-  register HOST_WIDE_INT frame_lower_bytes;\n-  register HOST_WIDE_INT frame_upper_bytes;\n-  register HOST_WIDE_INT total_fsize;\n-  register unsigned preserved_reg_bytes = 0;\n-  register unsigned i;\n-  register unsigned preserved_so_far = 0;\n-\n-  must_preserve_r1 = (optimize < 2 || ! leaf_function_p ());\n-  must_preserve_bytes = 4 + (must_preserve_r1 ? 4 : 0);\n-\n-  /* Count registers that need preserving.  Ignore r0.  It never needs\n-     preserving.  */\n-\n-  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (regs_ever_live[i] && ! call_used_regs[i])\n-        preserved_reg_bytes += 4;\n-    }\n-\n-  /* Round-up the frame_lower_bytes so that it's a multiple of 16.  */\n-\n-  frame_lower_bytes = (local_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n-\n-  /* The upper part of each frame will contain the saved fp,\n-     the saved r1, and stack slots for all of the other \"preserved\"\n-     registers that we find we will need to save & restore.  */\n-\n-  frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n-\n-  /* Round-up the frame_upper_bytes so that it's a multiple of 16.  */\n-\n-  frame_upper_bytes\n-    = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n-\n-  total_fsize = frame_upper_bytes + frame_lower_bytes;\n-\n-#ifndef I860_STRICT_ABI_PROLOGUES\n-\n-  /* There are two kinds of function prologues.\n-     You use the \"small\" version if the total frame size is\n-     small enough so that it can fit into an immediate 16-bit\n-     value in one instruction.  Otherwise, you use the \"large\"\n-     version of the function prologue.  */\n-\n-  if (total_fsize > 0x7fff)\n-    {\n-      /* Adjust the stack pointer.  The ABI specifies using `adds' for\n-\t this, but the native C compiler on SVR4 uses `addu'.  */\n-\n-      fprintf (asm_file, \"\\taddu -\" HOST_WIDE_INT_PRINT_DEC \",%ssp,%ssp\\n\",\n-\tframe_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Save the old frame pointer.  */\n-\n-      fprintf (asm_file, \"\\tst.l %sfp,0(%ssp)\\n\",\n-\ti860_reg_prefix, i860_reg_prefix);\n-\n-      /* Setup the new frame pointer.  The ABI specifies that this is to\n-\t be done after preserving registers (using `adds'), but that's not\n-\t what the native C compiler on SVR4 does.  */\n-\n-      fprintf (asm_file, \"\\taddu 0,%ssp,%sfp\\n\",\n-\ti860_reg_prefix, i860_reg_prefix);\n-\n-      /* Get the value of frame_lower_bytes into r31.  */\n-\n-      fprintf (asm_file, \"\\torh \" HOST_WIDE_INT_PRINT_DEC \",%sr0,%sr31\\n\",\n-\tframe_lower_bytes >> 16, i860_reg_prefix, i860_reg_prefix);\n-      fprintf (asm_file, \"\\tor \" HOST_WIDE_INT_PRINT_DEC \",%sr31,%sr31\\n\",\n-\tframe_lower_bytes & 0xffff, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Now re-adjust the stack pointer using the value in r31.\n-\t The ABI specifies that this is done with `subs' but SDB may\n-\t prefer `subu'.  */\n-\n-      fprintf (asm_file, \"\\tsubu %ssp,%sr31,%ssp\\n\",\n-\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Preserve registers.  The ABI specifies that this is to be done\n-\t before setting up the new frame pointer, but that's not what the\n-\t native C compiler on SVR4 does.  */\n-\n-      for (i = 1; i < 32; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tst.l %s%s,%d(%sfp)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    must_preserve_bytes  + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      for (i = 32; i < 64; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sfp)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    must_preserve_bytes + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      /* Save the return address.  */\n-\n-      if (must_preserve_r1)\n-        fprintf (asm_file, \"\\tst.l %sr1,4(%sfp)\\n\",\n-\t  i860_reg_prefix, i860_reg_prefix);\n-    }\n-  else\n-    {\n-      /* Adjust the stack pointer.  The ABI specifies using `adds' for this,\n-\t but the native C compiler on SVR4 uses `addu'.  */\n-\n-      fprintf (asm_file, \"\\taddu -\" HOST_WIDE_INT_PRINT_DEC \",%ssp,%ssp\\n\",\n-\ttotal_fsize, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Save the old frame pointer.  */\n-\n-      fprintf (asm_file, \"\\tst.l %sfp,\" HOST_WIDE_INT_PRINT_DEC \"(%ssp)\\n\",\n-\ti860_reg_prefix, frame_lower_bytes, i860_reg_prefix);\n-\n-      /* Setup the new frame pointer.  The ABI specifies that this is to be\n-\t done after preserving registers and after saving the return address,\n-\t (and to do it using `adds'), but that's not what the native C\n-\t compiler on SVR4 does.  */\n-\n-      fprintf (asm_file, \"\\taddu \" HOST_WIDE_INT_PRINT_DEC \",%ssp,%sfp\\n\",\n-\tframe_lower_bytes, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Preserve registers.  The ABI specifies that this is to be done\n-\t before setting up the new frame pointer, but that's not what the\n-\t native compiler on SVR4 does.  */\n-\n-      for (i = 1; i < 32; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tst.l %s%s,%d(%sfp)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    must_preserve_bytes + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      for (i = 32; i < 64; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sfp)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    must_preserve_bytes + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      /* Save the return address.  The ABI specifies that this is to be\n-\t done earlier, and also via an offset from %sp, but the native C\n-\t compiler on SVR4 does it later (i.e. now) and uses an offset from\n-\t %fp.  */\n-\n-      if (must_preserve_r1)\n-        fprintf (asm_file, \"\\tst.l %sr1,4(%sfp)\\n\",\n-\t  i860_reg_prefix, i860_reg_prefix);\n-    }\n-\n-#else /* defined(I860_STRICT_ABI_PROLOGUES) */\n-\n-  /* There are two kinds of function prologues.\n-     You use the \"small\" version if the total frame size is\n-     small enough so that it can fit into an immediate 16-bit\n-     value in one instruction.  Otherwise, you use the \"large\"\n-     version of the function prologue.  */\n-\n-  if (total_fsize > 0x7fff)\n-    {\n-      /* Adjust the stack pointer (thereby allocating a new frame).  */\n-\n-      fprintf (asm_file, \"\\tadds -%d,%ssp,%ssp\\n\",\n-\tframe_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Save the caller's frame pointer.  */\n-\n-      fprintf (asm_file, \"\\tst.l %sfp,0(%ssp)\\n\",\n-\ti860_reg_prefix, i860_reg_prefix);\n-\n-      /* Save return address.  */\n-\n-      if (must_preserve_r1)\n-        fprintf (asm_file, \"\\tst.l %sr1,4(%ssp)\\n\",\n-\t  i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Get the value of frame_lower_bytes into r31 for later use.  */\n-\n-      fprintf (asm_file, \"\\torh %d,%sr0,%sr31\\n\",\n-\tframe_lower_bytes >> 16, i860_reg_prefix, i860_reg_prefix);\n-      fprintf (asm_file, \"\\tor %d,%sr31,%sr31\\n\",\n-\tframe_lower_bytes & 0xffff, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Now re-adjust the stack pointer using the value in r31.  */\n-\n-      fprintf (asm_file, \"\\tsubs %ssp,%sr31,%ssp\\n\",\n-\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Pre-compute value to be used as the new frame pointer.  */\n-\n-      fprintf (asm_file, \"\\tadds %ssp,%sr31,%sr31\\n\",\n-\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Preserve registers.  */\n-\n-      for (i = 1; i < 32; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tst.l %s%s,%d(%sr31)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    must_preserve_bytes + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      for (i = 32; i < 64; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sr31)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    must_preserve_bytes + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      /* Actually set the new value of the frame pointer.  */\n-\n-      fprintf (asm_file, \"\\tmov %sr31,%sfp\\n\",\n-\ti860_reg_prefix, i860_reg_prefix);\n-    }\n-  else\n-    {\n-      /* Adjust the stack pointer.  */\n-\n-      fprintf (asm_file, \"\\tadds -%d,%ssp,%ssp\\n\",\n-\ttotal_fsize, i860_reg_prefix, i860_reg_prefix);\n-\n-      /* Save the caller's frame pointer.  */\n-\n-      fprintf (asm_file, \"\\tst.l %sfp,%d(%ssp)\\n\",\n-\ti860_reg_prefix, frame_lower_bytes, i860_reg_prefix);\n-\n-      /* Save the return address.  */\n-\n-      if (must_preserve_r1)\n-        fprintf (asm_file, \"\\tst.l %sr1,%d(%ssp)\\n\",\n-\t  i860_reg_prefix, frame_lower_bytes + 4, i860_reg_prefix);\n-\n-      /* Preserve registers.  */\n-\n-      for (i = 1; i < 32; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tst.l %s%s,%d(%ssp)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    frame_lower_bytes + must_preserve_bytes + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      for (i = 32; i < 64; i++)\n-        if (regs_ever_live[i] && ! call_used_regs[i])\n-          fprintf (asm_file, \"\\tfst.l %s%s,%d(%ssp)\\n\",\n-\t    i860_reg_prefix, reg_names[i],\n-\t    frame_lower_bytes + must_preserve_bytes + (4 * preserved_so_far++),\n-\t    i860_reg_prefix);\n-\n-      /* Setup the new frame pointer.  */\n-\n-      fprintf (asm_file, \"\\tadds %d,%ssp,%sfp\\n\",\n-\tframe_lower_bytes, i860_reg_prefix, i860_reg_prefix);\n-    }\n-#endif /* defined(I860_STRICT_ABI_PROLOGUES) */\n-\n-#ifdef ASM_OUTPUT_PROLOGUE_SUFFIX\n-  ASM_OUTPUT_PROLOGUE_SUFFIX (asm_file);\n-#endif /* defined(ASM_OUTPUT_PROLOGUE_SUFFIX) */\n-}\n-\f\n-/* This function generates the assembly code for function exit.\n-\n-   ASM_FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.\n-\n-   Note that when we go to restore the preserved register values we must\n-   not try to address their slots by using offsets from the stack pointer.\n-   That's because the stack pointer may have been moved during the function\n-   execution due to a call to alloca().  Rather, we must restore all\n-   preserved registers via offsets from the frame pointer value.\n-\n-   Note also that when the current frame is being \"popped\" (by adjusting\n-   the value of the stack pointer) on function exit, we must (for the\n-   sake of alloca) set the new value of the stack pointer based upon\n-   the current value of the frame pointer.  We can't just add what we\n-   believe to be the (static) frame size to the stack pointer because\n-   if we did that, and alloca() had been called during this function,\n-   we would end up returning *without* having fully deallocated all of\n-   the space grabbed by alloca.  If that happened, and a function\n-   containing one or more alloca() calls was called over and over again,\n-   then the stack would grow without limit!\n-\n-   Finally note that the epilogues generated here are completely ABI\n-   compliant.  They go out of their way to insure that the value in\n-   the frame pointer register is never less than the value in the stack\n-   pointer register.  It's not clear why this relationship needs to be\n-   maintained at all times, but maintaining it only costs one extra\n-   instruction, so what the hell.  */\n-\n-/* This corresponds to a version 4 TDESC structure. Lower numbered\n-   versions successively omit the last word of the structure. We\n-   don't try to handle version 5 here.  */\n-\n-typedef struct TDESC_flags {\n-\tint version:4;\n-\tint reg_packing:1;\n-\tint callable_block:1;\n-\tint reserved:4;\n-\tint fregs:6;\t/* fp regs 2-7 */\n-\tint iregs:16;\t/* regs 0-15 */\n-} TDESC_flags;\n-\n-typedef struct TDESC {\n-\tTDESC_flags flags;\n-\tint integer_reg_offset;\t\t/* same as must_preserve_bytes */\n-\tint floating_point_reg_offset;\n-\tunsigned int positive_frame_size;\t/* same as frame_upper_bytes */\n-\tunsigned int negative_frame_size;\t/* same as frame_lower_bytes */\n-} TDESC;\n-\n-static void\n-i860_output_function_epilogue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n-{\n-  register HOST_WIDE_INT frame_upper_bytes;\n-  register HOST_WIDE_INT frame_lower_bytes;\n-  register HOST_WIDE_INT preserved_reg_bytes = 0;\n-  register unsigned i;\n-  register unsigned restored_so_far = 0;\n-  register unsigned int_restored;\n-  register unsigned mask;\n-  unsigned intflags=0;\n-  register TDESC_flags *flags = (TDESC_flags *) &intflags;\n-#ifdef\tOUTPUT_TDESC\t/* Output an ABI-compliant TDESC entry */\n-  const char *long_op = integer_asm_op (4, TRUE);\n-#endif\n-\n-  flags->version = 4;\n-  flags->reg_packing = 1;\n-  flags->iregs = 8;\t/* old fp always gets saved */\n-\n-  /* Round-up the frame_lower_bytes so that it's a multiple of 16.  */\n-\n-  frame_lower_bytes = (local_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n-\n-  /* Count the number of registers that were preserved in the prologue.\n-     Ignore r0.  It is never preserved.  */\n-\n-  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (regs_ever_live[i] && ! call_used_regs[i])\n-        preserved_reg_bytes += 4;\n-    }\n-\n-  /* The upper part of each frame will contain only saved fp,\n-     the saved r1, and stack slots for all of the other \"preserved\"\n-     registers that we find we will need to save & restore.  */\n-\n-  frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n-\n-  /* Round-up frame_upper_bytes so that t is a multiple of 16.  */\n-\n-  frame_upper_bytes\n-    = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n-\n-  /* Restore all of the \"preserved\" registers that need restoring.  */\n-\n-  mask = 2;\n-\n-  for (i = 1; i < 32; i++, mask<<=1)\n-    if (regs_ever_live[i] && ! call_used_regs[i]) {\n-      fprintf (asm_file, \"\\tld.l %d(%sfp),%s%s\\n\",\n-\tmust_preserve_bytes + (4 * restored_so_far++),\n-\ti860_reg_prefix, i860_reg_prefix, reg_names[i]);\n-      if (i > 3 && i < 16)\n-\tflags->iregs |= mask;\n-    }\n-\n-  int_restored = restored_so_far;\n-  mask = 1;\n-\n-  for (i = 32; i < 64; i++) {\n-    if (regs_ever_live[i] && ! call_used_regs[i]) {\n-      fprintf (asm_file, \"\\tfld.l %d(%sfp),%s%s\\n\",\n-\tmust_preserve_bytes + (4 * restored_so_far++),\n-\ti860_reg_prefix, i860_reg_prefix, reg_names[i]);\n-      if (i > 33 && i < 40)\n-\tflags->fregs |= mask;\n-    }\n-    if (i > 33 && i < 40)\n-      mask<<=1;\n-  }\n-\n-  /* Get the value we plan to use to restore the stack pointer into r31.  */\n-\n-  fprintf (asm_file, \"\\tadds \" HOST_WIDE_INT_PRINT_DEC \",%sfp,%sr31\\n\",\n-    frame_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n-\n-  /* Restore the return address and the old frame pointer.  */\n-\n-  if (must_preserve_r1) {\n-    fprintf (asm_file, \"\\tld.l 4(%sfp),%sr1\\n\",\n-      i860_reg_prefix, i860_reg_prefix);\n-    flags->iregs |= 2;\n-  }\n-\n-  fprintf (asm_file, \"\\tld.l 0(%sfp),%sfp\\n\",\n-    i860_reg_prefix, i860_reg_prefix);\n-\n-  /* Return and restore the old stack pointer value.  */\n-\n-  fprintf (asm_file, \"\\tbri %sr1\\n\\tmov %sr31,%ssp\\n\",\n-    i860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n-\n-#ifdef\tOUTPUT_TDESC\t/* Output an ABI-compliant TDESC entry.  */\n-  if (! frame_lower_bytes) {\n-    flags->version--;\n-    if (! frame_upper_bytes) {\n-      flags->version--;\n-      if (restored_so_far == int_restored)\t/* No FP saves.  */\n-\tflags->version--;\n-    }\n-  }\n-  assemble_name(asm_file,current_function_original_name);\n-  fputs(\".TDESC:\\n\", asm_file);\n-  fprintf(asm_file, \"%s 0x%0x\\n\", long_op, intflags);\n-  fprintf(asm_file, \"%s %d\\n\", long_op,\n-\tint_restored ? must_preserve_bytes : 0);\n-  if (flags->version > 1) {\n-    fprintf(asm_file, \"%s %d\\n\", long_op,\n-\t(restored_so_far == int_restored) ? 0 : must_preserve_bytes +\n-\t  (4 * int_restored));\n-    if (flags->version > 2) {\n-      fprintf(asm_file, \"%s %d\\n\", long_op, frame_upper_bytes);\n-      if (flags->version > 3)\n-\tfprintf(asm_file, \"%s %d\\n\", long_op, frame_lower_bytes);\n-    }\n-  }\n-  tdesc_section();\n-  fprintf(asm_file, \"%s \", long_op);\n-  assemble_name(asm_file, current_function_original_name);\n-  fprintf(asm_file, \"\\n%s \", long_op);\n-  assemble_name(asm_file, current_function_original_name);\n-  fputs(\".TDESC\\n\", asm_file);\n-  text_section();\n-#endif\n-}\n-\f\n-\n-/* Expand a library call to __builtin_saveregs.  */\n-\n-static rtx\n-i860_saveregs (void)\n-{\n-  rtx fn = gen_rtx_SYMBOL_REF (Pmode, \"__builtin_saveregs\");\n-  rtx save = gen_reg_rtx (Pmode);\n-  rtx valreg = LIBCALL_VALUE (Pmode);\n-  rtx ret;\n-\n-  /* The return value register overlaps the first argument register.\n-     Save and restore it around the call.  */\n-  emit_move_insn (save, valreg);\n-  ret = emit_library_call_value (fn, NULL_RTX, 1, Pmode, 0);\n-  if (GET_CODE (ret) != REG || REGNO (ret) < FIRST_PSEUDO_REGISTER)\n-    ret = copy_to_reg (ret);\n-  emit_move_insn (valreg, save);\n-\n-  return ret;\n-}\n-\n-/* Create the va_list data type.\n-   The SVR4 ABI requires the following structure:\n-        typedef struct {\n-            unsigned long  ireg_used;\n-            unsigned long  freg_used;\n-            long          *reg_base;\n-            long          *mem_ptr;\n-        } va_list;\n-\n-   Otherwise, this structure is used:\n-        typedef struct {\n-            long          *reg_base;\n-            long          *mem_ptr;\n-            unsigned long  ireg_used;\n-            unsigned long  freg_used;\n-        } va_list;\n-\n-   The tree representing the va_list declaration is returned.  */\n-\n-static tree\n-i860_build_builtin_va_list (void)\n-{\n-  tree f_gpr, f_fpr, f_mem, f_sav, record, type_decl;\n-\n-  record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  type_decl = build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n-\n-  f_gpr = build_decl (FIELD_DECL, get_identifier (\"__ireg_used\"),\n-\t\t      unsigned_type_node);\n-  f_fpr = build_decl (FIELD_DECL, get_identifier (\"__freg_used\"),\n-\t\t      unsigned_type_node);\n-  f_sav = build_decl (FIELD_DECL, get_identifier (\"__reg_base\"),\n-\t\t      ptr_type_node);\n-  f_mem = build_decl (FIELD_DECL, get_identifier (\"__mem_ptr\"),\n-\t\t      ptr_type_node);\n-\n-  DECL_FIELD_CONTEXT (f_gpr) = record;\n-  DECL_FIELD_CONTEXT (f_fpr) = record;\n-  DECL_FIELD_CONTEXT (f_sav) = record;\n-  DECL_FIELD_CONTEXT (f_mem) = record;\n-\n-  TREE_CHAIN (record) = type_decl;\n-  TYPE_NAME (record) = type_decl;\n-\n-#ifdef I860_SVR4_VA_LIST\n-  TYPE_FIELDS (record) = f_gpr;\n-  TREE_CHAIN (f_gpr) = f_fpr;\n-  TREE_CHAIN (f_fpr) = f_sav;\n-  TREE_CHAIN (f_sav) = f_mem;\n-#else\n-  TYPE_FIELDS (record) = f_sav;\n-  TREE_CHAIN (f_sav) = f_mem;\n-  TREE_CHAIN (f_mem) = f_gpr;\n-  TREE_CHAIN (f_gpr) = f_fpr;\n-#endif\n-\n-  layout_type (record);\n-  return record;\n-}\n-\n-/* Initialize the va_list structure.  */\n-\n-void\n-i860_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n-{\n-  tree saveregs, t;\n-  tree f_gpr, f_fpr, f_mem, f_sav;\n-  tree gpr, fpr, mem, sav;\n-  int off = 0;\n-  saveregs = make_tree (ptr_type_node, expand_builtin_saveregs ());\n-\n-#ifdef I860_SVR4_VA_LIST\n-  f_gpr = TYPE_FIELDS (va_list_type_node);\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_sav = TREE_CHAIN (f_fpr);\n-  f_mem = TREE_CHAIN (f_sav);\n-#else\n-  f_sav = TYPE_FIELDS (va_list_type_node);\n-  f_mem = TREE_CHAIN (f_sav);\n-  f_gpr = TREE_CHAIN (f_mem);\n-  f_fpr = TREE_CHAIN (f_gpr);\n-#endif\n-\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n-  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem, NULL_TREE);\n-\n-  /* Initialize the `mem_ptr' field to the address of the first anonymous\n-     stack argument.  */\n-  t = make_tree (TREE_TYPE (mem), virtual_incoming_args_rtx);\n-  off = INTVAL (current_function_arg_offset_rtx);\n-  off = off < 0 ? 0 : off;\n-  t = build (PLUS_EXPR, TREE_TYPE (mem), t, build_int_cst (NULL_TREE, off, 0));\n-  t = build (MODIFY_EXPR, TREE_TYPE (mem), mem, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* Initialize the `ireg_used' field.  */\n-  t = build_int_cst (NULL_TREE,\n-\t\t     current_function_args_info.ints / UNITS_PER_WORD, 0);\n-  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-     \n-  /* Initialize the `freg_used' field.  */\n-  t = build_int_cst (NULL_TREE,\n-\t\t     current_function_args_info.floats / UNITS_PER_WORD, 0);\n-  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      \n-  /* Initialize the `reg_base' field.  */\n-  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, saveregs);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-}\n-\n-#define NUM_PARM_FREGS\t8\n-#define NUM_PARM_IREGS\t12\n-#ifdef I860_SVR4_VA_LIST\n-#define FREG_OFFSET 0\n-#define IREG_OFFSET (NUM_PARM_FREGS * UNITS_PER_WORD)\n-#else\n-#define FREG_OFFSET (NUM_PARM_IREGS * UNITS_PER_WORD)\n-#define IREG_OFFSET 0\n-#endif\n-\n-/* Update the VALIST structure as necessary for an\n-   argument of the given TYPE, and return the argument.  */\n-\n-static tree\n-i860_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n-{\n-  tree f_gpr, f_fpr, f_mem, f_sav;\n-  tree gpr, fpr, mem, sav;\n-  tree size, t, u, addr, type_ptr;\n-  tree reg, n_reg, sav_ofs, lim_reg;\n-  HOST_WIDE_INT isize;\n-  bool indirect;\n-\n-#ifdef I860_SVR4_VA_LIST\n-  f_gpr = TYPE_FIELDS (va_list_type_node);\n-  f_fpr = TREE_CHAIN (f_gpr);\n-  f_sav = TREE_CHAIN (f_fpr);\n-  f_mem = TREE_CHAIN (f_sav);\n-#else\n-  f_sav = TYPE_FIELDS (va_list_type_node);\n-  f_mem = TREE_CHAIN (f_sav);\n-  f_gpr = TREE_CHAIN (f_mem);\n-  f_fpr = TREE_CHAIN (f_gpr);\n-#endif\n-\n-  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem, NULL_TREE);\n-  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n-\n-  indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n-  if (indirect)\n-    type = build_pointer_type (type);\n-  size = size_in_bytes (type);\n-  type_ptr = build_pointer_type (type);\n-\n-  if (AGGREGATE_TYPE_P (type))\n-    {\n-      /* Aggregates are passed on the stack.  */\n-      HOST_WIDE_INT align;\n-\n-      align = TYPE_ALIGN (type);\n-      if (align < BITS_PER_WORD)\n-        align = BITS_PER_WORD;\n-      align /= BITS_PER_UNIT;\n-\n-      u = fold_convert (ptr_type_node, size_int (align - 1));\n-      t = build (PLUS_EXPR, ptr_type_node, mem, u);\n-      u = fold (build (BIT_NOT_EXPR, ptr_type_node, u));\n-      t = build (BIT_AND_EXPR, ptr_type_node, t, u);\n-      addr = get_initialized_tmp_var (t, pre_p, post_p);\n-\n-      u = fold_convert (ptr_type_node, size);\n-      t = build (PLUS_EXPR, ptr_type_node, addr, size);\n-      t = build (MODIFY_EXPR, ptr_type_node, mem, t);\n-      gimplify_and_add (t, pre_p);\n-    }\n-  else\n-    {\n-      isize = tree_low_cst (size, 0);\n-\n-      if (FLOAT_TYPE_P (type) || (INTEGRAL_TYPE_P (type) && isize == 8))\n-\t{\n-\t  /* Floats and long longs are passed in the fp registers.  */\n-\t  reg = fpr;\n-\t  n_reg = size_int (isize / UNITS_PER_WORD);\n-\t  n_reg = fold_convert (unsigned_type_node, n_reg);\n-\t  lim_reg = size_int (NUM_PARM_FREGS - (isize / UNITS_PER_WORD));\n-\t  lim_reg = fold_convert (unsigned_type_node, lim_reg);\n-\t  sav_ofs = size_int (FREG_OFFSET);\n-\t}\n-      else\n-\t{\n-\t  /* Everything else is passed in general registers.  */\n-\t  reg = gpr;\n-\t  if ((isize + UNITS_PER_WORD - 1) / UNITS_PER_WORD > 1)\n-\t    abort ();\n-\t  n_reg = fold_convert (unsigned_type_node, integer_one_node);\n-\t  lim_reg = size_int (NUM_PARM_IREGS - 1);\n-\t  lim_reg = fold_convert (unsigned_type_node, lim_reg);\n-\t  sav_ofs = size_int (IREG_OFFSET);\n-\t}\n-\n-      u = build (LE_EXPR, boolean_type_node, reg, lim_reg);\n-      addr = build (COND_EXPR, ptr_type_node, u, NULL, NULL);\n-\n-      /* The value was passed in a register, so read it from the register\n-\t save area initialized by __builtin_saveregs.  */\n-\n-      sav_ofs = fold_convert (ptr_type_node, sav_ofs);\n-      sav_ofs = fold (build (PLUS_EXPR, ptr_type_node, sav, sav_ofs));\n-\n-      u = fold_convert (unsigned_type_node, size_int (UNITS_PER_WORD));\n-      u = build (MULT_EXPR, unsigned_type_node, reg, u);\n-      u = fold_convert (ptr_type_node, u);\n-      u = build (PLUS_EXPR, ptr_type_node, sav_ofs, u);\n-      COND_EXPR_THEN (addr) = u;\n-\n-      /* The value was passed in memory, so read it from the overflow area.  */\n-\n-      t = fold_convert (ptr_type_node, size);\n-      u = build (POSTINCREMENT_EXPR, ptr_type_node, mem, t);\n-      COND_EXPR_ELSE (addr) = u;\n-\n-      /* Increment either the ireg_used or freg_used field.  */\n-\n-      t = build (PLUS_EXPR, unsigned_type_node, reg, n_reg);\n-      t = build (MODIFY_EXPR, unsigned_type_node, reg, t);\n-      gimplify_and_add (t, post_p);\n-    }\n-\n-  addr = fold_convert (type_ptr, addr);\n-  if (indirect)\n-    addr = build_va_arg_indirect_ref (addr);\n-  return build_va_arg_indirect_ref (addr);\n-}\n-\n-/* Compute a (partial) cost for rtx X.  Return true if the complete\n-   cost has been computed, and false if subexpressions should be\n-   scanned.  In either case, *TOTAL contains the cost result.  */\n-\n-static bool\n-i860_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n-{\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if (INTVAL (x) == 0)\n-        *total = 0;\n-      else if (INTVAL (x) < 0x2000 && INTVAL (x) >= -0x2000)\n-        *total = 1;\n-      return true;\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = 4;\n-      return true;\n-    case CONST_DOUBLE:\n-      *total = 6;\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-static void\n-i860_internal_label (FILE *stream, const char *prefix, unsigned long labelno)\n-{\n-  fprintf (stream, \".%s%ld:\\n\", prefix, labelno);\n-}\n-\n-static void\n-i860_file_start (void)\n-{\n-  output_file_directive (asm_out_file, main_input_filename);\n-  fprintf (asm_out_file, \"\\t.version\\t\\\"01.01\\\"\\n\");\n-}\n-\n-static void\n-i860_init_libfuncs (void)\n-{\n-  set_optab_libfunc (sdiv_optab, SImode, \"*.div\");\n-  set_optab_libfunc (udiv_optab, SImode, \"*.udiv\");\n-  set_optab_libfunc (smod_optab, SImode, \"*.rem\");\n-  set_optab_libfunc (umod_optab, SImode, \"*.urem\");\n-}\n-\n-static rtx\n-i860_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n-\t\t       int incoming ATTRIBUTE_UNUSED)\n-{\n-  return gen_rtx_REG (Pmode, I860_STRUCT_VALUE_REGNUM);\n-}\n-\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS i860_rtx_costs\n-\n-#undef  TARGET_ASM_INTERNAL_LABEL\n-#define TARGET_ASM_INTERNAL_LABEL i860_internal_label\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE i860_output_function_prologue\n-\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE i860_output_function_epilogue\n-\n-#undef TARGET_INIT_LIBFUNCS\n-#define TARGET_INIT_LIBFUNCS i860_init_libfuncs\n-\n-#undef TARGET_BUILD_BUILTIN_VA_LIST\n-#define TARGET_BUILD_BUILTIN_VA_LIST i860_build_builtin_va_list\n-#undef TARGET_GIMPLIFY_VA_ARG_EXPR\n-#define TARGET_GIMPLIFY_VA_ARG_EXPR i860_gimplify_va_arg_expr\n-\n-#undef TARGET_STRUCT_VALUE_RTX\n-#define TARGET_STRUCT_VALUE_RTX i860_struct_value_rtx\n-\n-#undef TARGET_EXPAND_BUILTIN_SAVEREGS\n-#define TARGET_EXPAND_BUILTIN_SAVEREGS i860_saveregs\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "07da9b9311a170315bfec23a1a0ee2120459cee7", "filename": "gcc/config/i860/i860.h", "status": "removed", "additions": 0, "deletions": 1217, "changes": 1217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,1217 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 860.\n-   Copyright (C) 1989, 1991, 1993, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n-   Hacked substantially by Ron Guilmette (rfg@monkeys.com) to cater to\n-   the whims of the System V Release 4 assembler.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-\n-/* Note that some other tm.h files include this one and then override\n-   many of the definitions that relate to assembler syntax.  */\n-\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-#define TARGET_CPU_CPP_BUILTINS()               \\\n-do {                                            \\\n-        builtin_define (\"i860\");                \\\n-        builtin_assert (\"cpu=i860\");            \\\n-        builtin_assert (\"machine=i860\");        \\\n-} while (0)\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION fprintf (stderr, \" (i860)\");\n-\f\n-/* target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   This is a moot question on the i860 due to the lack of bit-field insns.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* That is not true on i860 in the mode we will use.  */\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n-/* For the i860 this goes with BYTES_BIG_ENDIAN.  */\n-/* NOTE: GCC probably cannot support a big-endian i860\n-   because GCC fundamentally assumes that the order of words\n-   in memory as the same as the order in registers.\n-   That's not true for the big-endian i860.\n-   The big-endian i860 isn't important enough to\n-   justify the trouble of changing this assumption.  */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 128\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 64\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* Minimum size in bits of the largest boundary to which any\n-   and all fundamental data types supported by the hardware\n-   might need to be aligned. No data type wants to be aligned\n-   rounder than this.  The i860 supports 128-bit (long double)\n-   floating point quantities, and the System V Release 4 i860\n-   ABI requires these to be aligned to 16-byte (128-bit)\n-   boundaries.  */\n-#define BIGGEST_ALIGNMENT 128\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\n-/* If bit field type is int, don't let it cross an int,\n-   and give entire struct the alignment of an int.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   i860 has 32 fullword registers and 32 floating point registers.  */\n-\n-#define FIRST_PSEUDO_REGISTER 64\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   On the i860, this includes the always-0 registers\n-   and fp, sp, arg pointer, and the return address.\n-   Also r31, used for special purposes for constant addresses.  */\n-#define FIXED_REGISTERS  \\\n- {1, 1, 1, 1, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n-  1, 1, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   On the i860, these are r0-r3, r16-r31, f0, f1, and f16-f31.  */\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 1, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1}\n-\n-/* Try to get a non-preserved register before trying to get one we will\n-   have to preserve.  Try to get an FP register only *after* trying to\n-   get a general register, because it is relatively expensive to move\n-   into or out of an FP register.  */\n-\n-#define REG_ALLOC_ORDER\t\t\t\\\n- {31, 30, 29, 28, 27, 26, 25, 24,\t\\\n-  23, 22, 21, 20, 19, 18, 17, 16,\t\\\n-  15, 14, 13, 12, 11, 10,  9,  8,\t\\\n-   7,  6,  5,  4,  3,  2,  1,  0,\t\\\n-  63, 62, 61, 60, 59, 58, 57, 56,\t\\\n-  55, 54, 53, 52, 51, 50, 49, 48,\t\\\n-  47, 46, 45, 44, 43, 42, 41, 40,\t\\\n-  39, 38, 37, 36, 35, 34, 33, 32}\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the i860, all registers hold 32 bits worth.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-#define REGNO_MODE_ALIGNED(REGNO, MODE) \\\n-  (((REGNO) % ((GET_MODE_UNIT_SIZE (MODE) + 3) / 4)) == 0)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-\n-   On the i860, we allow anything to go into any registers, but we require\n-   any sort of value going into the FP registers to be properly aligned\n-   (based on its size) within the FP register set.\n-*/\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  (((REGNO) < 32) \t\t\t\t\t\t\t\\\n-   || (MODE) == VOIDmode || (MODE) == BLKmode\t\t\t\t\\\n-   || REGNO_MODE_ALIGNED (REGNO, MODE))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-/* I think that is not always true; alignment restrictions for doubles\n-   should not prevent tying them with singles.  So try allowing that.\n-   On the other hand, don't let fixed and floating be tied;\n-   this restriction is not necessary, but may make better code.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n-    || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n-       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* i860 pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 2\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 3\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 28\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 29\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define I860_STRUCT_VALUE_REGNUM 16\n-\n-/* Register to use when a source of a floating-point zero is needed.  */\n-#define F0_REGNUM\t32\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-/* The i860 has two kinds of registers, hence four classes.  */\n-\n-enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS\t\\\n- {{0, 0}, {0xffffffff, 0},\t\\\n-  {0, 0xffffffff}, {0xffffffff, 0xffffffff}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) \\\n- ((REGNO) >= 32 ? FP_REGS : GENERAL_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS : NO_REGS)\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For the i860, `I' is used for the range of constants \n-   an add/subtract insn can actually contain.\n-   But not including -0x8000, since we need\n-   to negate the constant sometimes.\n-   `J' is used for the range which is just zero (since that is R0).\n-   `K' is used for the range allowed in bte.\n-   `L' is used for the range allowed in logical insns.  */\n-\n-#define SMALL_INT(X) ((unsigned) (INTVAL (X) + 0x7fff) < 0xffff)\n-\n-#define LOGIC_INT(X) ((unsigned) INTVAL (X) < 0x10000)\n-\n-#define SMALL_INTVAL(X) ((unsigned) ((X) + 0x7fff) < 0xffff)\n-\n-#define LOGIC_INTVAL(X) ((unsigned) (X) < 0x10000)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? ((unsigned) (VALUE) + 0x7fff) < 0xffff\t\\\n-   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\\\n-   : (C) == 'K' ? (unsigned) (VALUE) < 0x20\t\\\n-   : (C) == 'L' ? (unsigned) (VALUE) < 0x10000\t\\\n-   : 0)\n-\n-/* Return nonzero if the given VALUE is acceptable for the\n-   constraint letter C.  For the i860, constraint letter 'G'\n-   permits only a floating-point zero value.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \t\\\n-  ((C) == 'G' && CONST_DOUBLE_LOW ((VALUE)) == 0\t\\\n-   && CONST_DOUBLE_HIGH ((VALUE)) == 0)\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-\n-   If we are trying to put an integer constant into some register, prefer an\n-   integer register to an FP register.  If we are trying to put a \n-   nonzero floating-point constant into some register, use an integer\n-   register if the constant is SFmode and GENERAL_REGS is one of our options.\n-   Otherwise, put the constant into memory.\n-\n-   When reloading something smaller than a word, use a general reg\n-   rather than an FP reg.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n-  ((CLASS) == ALL_REGS && GET_CODE (X) == CONST_INT ? GENERAL_REGS\t\\\n-   : ((GET_MODE (X) == HImode || GET_MODE (X) == QImode)\t\t\\\n-      && (CLASS) == ALL_REGS)\t\t\t\t\t\t\\\n-   ? GENERAL_REGS\t\t\t\t\t\t\t\\\n-   : (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n-      && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n-      && ! CONST_DOUBLE_OK_FOR_LETTER_P (X, 'G'))\t\t\t\\\n-   ? ((CLASS) == ALL_REGS && GET_MODE (X) == SFmode ? GENERAL_REGS\t\\\n-      : (CLASS) == GENERAL_REGS && GET_MODE (X) == SFmode ? (CLASS)\t\\\n-      : NO_REGS)\t\t\t\t\t\t\t\\\n-   : (CLASS))\n-\n-/* Return the register class of a scratch register needed to copy IN into\n-   a register in CLASS in MODE.  If it can be done directly, NO_REGS is\n-   returned.  */\n-\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  ((CLASS) == FP_REGS && CONSTANT_P (IN) ? GENERAL_REGS : NO_REGS)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On the i860, this is the size of MODE in words.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this to non-zero if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD 1\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On the i860, don't define this because there are no push insns.  */\n-/*  #define PUSH_ROUNDING(BYTES) */\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-/* On the i860, the value register depends on the mode.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\t\t\\\n-\t       (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT\t\\\n-\t\t? 40 : 16))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)\t\t\t\t\\\n-  gen_rtx_REG (MODE,\t\t\t\t\t\\\n-\t       (GET_MODE_CLASS ((MODE)) == MODE_FLOAT\t\\\n-\t\t? 40 : 16))\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 40 || (N) == 16)\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On the i860, these are r16-r27 and f8-f15.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N)\t\t\\\n-  (((N) < 28 && (N) > 15) || ((N) < 48 && (N) >= 40))\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On the i860, we must count separately the number of general registers used\n-   and the number of float registers used.  */\n-\n-struct cumulative_args { int ints, floats; };\n-#define CUMULATIVE_ARGS struct cumulative_args\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On the i860, the general-reg offset normally starts at 0,\n-   but starts at 4 bytes\n-   when the function gets a structure-value-address as an\n-   invisible first argument.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n- ((CUM).ints = ((FNTYPE) != 0 && aggregate_value_p (TREE_TYPE ((FNTYPE)), 0) \\\n-\t\t? 4 : 0),\t\t\t\\\n-  (CUM).floats = 0)\n-\n-/* Machine-specific subroutines of the following macros.  */\n-#define CEILING(X,Y)  (((X) + (Y) - 1) / (Y))\n-#define ROUNDUP(X,Y)  (CEILING ((X), (Y)) * (Y))\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)\n-   Floats, and doubleword ints, are returned in f regs;\n-   other ints, in r regs.\n-   Aggregates, even short ones, are passed in memory.  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n- ((TYPE) != 0 && (TREE_CODE ((TYPE)) == RECORD_TYPE\t\t\\\n-\t\t  || TREE_CODE ((TYPE)) == UNION_TYPE)\t\t\\\n-  ? 0\t\t\t\t\t\t\t\t\\\n-  : GET_MODE_CLASS ((MODE)) == MODE_FLOAT || (MODE) == DImode\t\\\n-  ? ((CUM).floats = (ROUNDUP ((CUM).floats, GET_MODE_SIZE ((MODE)))\t\\\n-\t\t     + ROUNDUP (GET_MODE_SIZE (MODE), 4)))\t\\\n-  : GET_MODE_CLASS ((MODE)) == MODE_INT\t\t\t\t\\\n-  ? ((CUM).ints = (ROUNDUP ((CUM).ints, GET_MODE_SIZE ((MODE))) \\\n-\t\t   + ROUNDUP (GET_MODE_SIZE (MODE), 4)))\t\\\n-  : 0)\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On the i860, the first 12 words of integer arguments go in r16-r27,\n-   and the first 8 words of floating arguments go in f8-f15.\n-   DImode values are treated as floats.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\\\n- ((TYPE) != 0 && (TREE_CODE ((TYPE)) == RECORD_TYPE\t\\\n-\t\t  || TREE_CODE ((TYPE)) == UNION_TYPE)\t\\\n-  ? 0\t\t\t\t\t\t\t\\\n-  : GET_MODE_CLASS ((MODE)) == MODE_FLOAT || (MODE) == DImode\t\\\n-  ? (ROUNDUP ((CUM).floats, GET_MODE_SIZE ((MODE))) < 32\t\\\n-     ? gen_rtx_REG ((MODE),\t\t\t\t\\\n-\t\t    40 + (ROUNDUP ((CUM).floats,\t\\\n-\t\t\t\t   GET_MODE_SIZE ((MODE)))\t\\\n-\t\t\t  / 4))\t\t\t\t\\\n-     : 0)\t\t\t\t\t\t\\\n-  : GET_MODE_CLASS ((MODE)) == MODE_INT\t\t\t\\\n-  ? (ROUNDUP ((CUM).ints, GET_MODE_SIZE ((MODE))) < 48\t\\\n-     ? gen_rtx_REG ((MODE),\t\t\t\t\\\n-\t\t    16 + (ROUNDUP ((CUM).ints,\t\t\\\n-\t\t\t\t   GET_MODE_SIZE ((MODE)))\t\\\n-\t\t\t  / 4))\t\t\t\t\\\n-     : 0)\t\t\t\t\t\t\\\n-  : 0)\n-\n-/* If defined, a C expression that gives the alignment boundary, in\n-   bits, of an argument with the specified mode and type.  If it is\n-   not defined,  `PARM_BOUNDARY' is used for all arguments.  */\n-\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\\\n-  (((TYPE) != 0)\t\t\t\t\t\t\\\n-   ? ((TYPE_ALIGN(TYPE) <= PARM_BOUNDARY)\t\t\t\\\n-      ? PARM_BOUNDARY\t\t\t\t\t\t\\\n-      : TYPE_ALIGN(TYPE))\t\t\t\t\t\\\n-   : ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\\\n-      ? PARM_BOUNDARY\t\t\t\t\t\t\\\n-      : GET_MODE_ALIGNMENT(MODE)))\n-\n-/* Output a no-op just before the beginning of the function,\n-   to ensure that there does not appear to be a delayed branch there.\n-   Such a thing would confuse interrupt recovery.  */\n-#define ASM_OUTPUT_FUNCTION_PREFIX(FILE,NAME) \\\n-  fprintf (FILE, \"\\tnop\\n\")\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   abort ();\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n-  i860_va_start (valist, nextarg)\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.\n-\n-   On the i860, FRAME_POINTER_REQUIRED is always 1, so the definition of this\n-   macro doesn't matter.  But it must be defined.  */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) \\\n-  do { (DEPTH) = 0; } while (0)\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-/* On the i860, the trampoline contains five instructions:\n-     orh #TOP_OF_FUNCTION,r0,r31\n-     or #BOTTOM_OF_FUNCTION,r31,r31\n-     orh #TOP_OF_STATIC,r0,r29\n-     bri r31\n-     or #BOTTOM_OF_STATIC,r29,r29  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xec1f0000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xe7ff0000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xec1d0000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x4000f800));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xe7bd0000));\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.\n-\n-   Store hi function at +0, low function at +4,\n-   hi static at +8, low static at +16  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx cxt = force_reg (Pmode, CXT);\t\t\t\t\t\\\n-  rtx fn = force_reg (Pmode, FNADDR);\t\t\t\t\t\\\n-  rtx hi_cxt = expand_shift (RSHIFT_EXPR, SImode, cxt,\t\t\t\\\n-\t\t\t     size_int (16), 0, 0);\t\t\t\\\n-  rtx hi_fn = expand_shift (RSHIFT_EXPR, SImode, fn,\t\t\t\\\n-\t\t\t    size_int (16), 0, 0);\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 16)),\t\\\n-\t\t  gen_lowpart (HImode, cxt));\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 4)),\t\\\n-\t\t  gen_lowpart (HImode, fn));\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 8)),\t\\\n-\t\t  gen_lowpart (HImode, hi_cxt));\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 0)),\t\\\n-\t\t  gen_lowpart (HImode, hi_fn));\t\t\t\t\\\n-}\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* #define HAVE_POST_INCREMENT 0 */\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-/* #define HAVE_PRE_DECREMENT 0 */\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_FP_P(REGNO) \\\n-(((REGNO) ^ 0x20) < 32 || (unsigned) (reg_renumber[REGNO] ^ 0x20) < 32)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.\n-\n-   These macros are specific to the i860, and may be used only\n-   in code for printing assembler insns and in conditions for\n-   define_optimization.  */\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n-\n-   On the Sparc, this is anything but a CONST_DOUBLE.\n-   Let's try permitting CONST_DOUBLEs and see what happens.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the i860, the actual addresses must be REG+REG or REG+SMALLINT.\n-   But we can treat a SYMBOL_REF as legitimate if it is part of this\n-   function's constant-pool, because such addresses can actually\n-   be output as REG+SMALLINT.\n-\n-   The displacement in an address must be a multiple of the alignment.\n-\n-   Try making SYMBOL_REF (and other things which are CONSTANT_ADDRESS_P)\n-   a legitimate address, regardless.  Because the only insns which can use\n-   memory are load or store insns, the added hair in the machine description\n-   is not that bad.  It should also speed up the compiler by halving the number\n-   of insns it must manage for each (MEM (SYMBOL_REF ...)) involved.  */\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{ if (GET_CODE (X) == REG)\t\t\t\t\\\n-    { if (REG_OK_FOR_BASE_P (X)) goto ADDR; }\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n-\t      && INTVAL (XEXP (X, 1)) >= -0x8000\t\\\n-\t      && INTVAL (XEXP (X, 1)) < 0x8000\t\t\\\n-\t      && (INTVAL (XEXP (X, 1)) & (GET_MODE_SIZE (MODE) - 1)) == 0) \\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 1)) == REG\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (X, 0)) == CONST_INT\t\\\n-\t      && INTVAL (XEXP (X, 0)) >= -0x8000\t\\\n-\t      && INTVAL (XEXP (X, 0)) < 0x8000\t\t\\\n-\t      && (INTVAL (XEXP (X, 0)) & (GET_MODE_SIZE (MODE) - 1)) == 0) \\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (CONSTANT_ADDRESS_P (X))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-/* On the i860, change COMPLICATED + CONSTANT to REG+CONSTANT.\n-   Also change a symbolic constant to a REG,\n-   though that may not be necessary.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n-{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) != REG\t\\\n-      && GET_CODE (XEXP (X, 0)) != CONST_INT)\t\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0))); \\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) != REG\t\\\n-      && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1))); \\\n-  if (GET_CODE (x) == SYMBOL_REF)\t\t\t\t\\\n-    (X) = copy_to_reg (X);\t\t\t\t\t\\\n-  if (GET_CODE (x) == CONST)\t\t\t\t\t\\\n-    (X) = copy_to_reg (X);\t\t\t\t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\\\n-    goto WIN; }\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the i860 this is never true.\n-   There are some addresses that are invalid in wide modes\n-   but valid for narrower modes, but they shouldn't affect\n-   the places that use this macro.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 16\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Value is 1 if it generates better code to perform an unsigned comparison\n-   on the given literal integer value in the given mode when we are only\n-   looking for an equal/non-equal result.  */\n-/* For the i860, if the immediate value has its high-order 27 bits zero,\n-   then we want to engineer an unsigned comparison for EQ/NE because\n-   such values can fit in the 5-bit immediate field of a bte or btne\n-   instruction (which gets zero extended before comparing).  For all\n-   other immediate values on the i860, we will use signed compares\n-   because that avoids the need for doing explicit xor's to zero_extend\n-   the non-constant operand in cases where it was (mem:QI ...) or a\n-   (mem:HI ...) which always gets automatically sign-extended by the\n-   hardware upon loading.  */\n-\n-#define LITERAL_COMPARE_BETTER_UNSIGNED(intval, mode)                   \\\n-  (((unsigned) (intval) & 0x1f) == (unsigned) (intval))\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE SImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Specify the cost of a branch insn; roughly the number of extra insns that\n-   should be added to avoid a branch.\n-\n-   Set this to 3 on the i860 since branches may often take three cycles.  */\n-\n-#define BRANCH_COST 3\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* This holds the value sourcing h%r31.  We keep this info\n-   around so that mem/mem ops, such as increment and decrement,\n-   etc, can be performed reasonably.  */\n-#define CC_STATUS_MDEP rtx\n-\n-#define CC_STATUS_MDEP_INIT (cc_status.mdep = 0)\n-\n-#define CC_NEGATED\t01000\n-\n-/* We use this macro in those places in the i860.md file where we would\n-   normally just do a CC_STATUS_INIT (for other machines).  This macro\n-   differs from CC_STATUS_INIT in that it doesn't mess with the special\n-   bits or fields which describe what is currently in the special r31\n-   scratch register, but it does clear out everything that actually\n-   relates to the condition code bit of the i860.  */\n-\n-#define CC_STATUS_PARTIAL_INIT\t\t\t\t\t\t\\\n- (cc_status.flags &= (CC_KNOW_HI_R31 | CC_HI_R31_ADJ),\t\t\t\\\n-  cc_status.value1 = 0,\t\t\t\t\t\t\t\\\n-  cc_status.value2 = 0)\n-\n-/* Nonzero if we know the value of h%r31.  */\n-#define CC_KNOW_HI_R31 0100000\n-\n-/* Nonzero if h%r31 is actually ha%something, rather than h%something.  */\n-#define CC_HI_R31_ADJ 0200000\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-/* On the i860, only compare insns set a useful condition code.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-{ cc_status.flags &= (CC_KNOW_HI_R31 | CC_HI_R31_ADJ);\t\\\n-  cc_status.value1 = 0; cc_status.value2 = 0; }\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Assembler pseudos to introduce constants of various size.  */\n-\n-#define ASM_DOUBLE \"\\t.double\"\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"sp\", \"fp\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\t\t\\\n- \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\",\t\\\n- \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",\t\\\n- \"r30\", \"r31\",\t\t\t\t\t\t\t\t\\\n- \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\",\t\t\\\n- \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\", \"f16\", \"f17\", \"f18\", \"f19\",\t\\\n- \"f20\", \"f21\", \"f22\", \"f23\", \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\",\t\\\n- \"f30\", \"f31\" }\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* The prefix to add to user-visible assembler symbols.\n-\n-   This definition is overridden in i860/sysv4.h because under System V\n-   Release 4, user-level symbols are *not* prefixed with underscores in\n-   the generated assembly code.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an internal numbered label which\n-   labels a jump table.  */\n-\n-#undef ASM_OUTPUT_CASE_LABEL\n-#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n-do { ASM_OUTPUT_ALIGN ((FILE), 2);\t\t\t\t\t\\\n-     (*targetm.asm_out.internal_label) ((FILE), PREFIX, NUM);\t\t\\\n-   } while (0)\n-\n-/* Output at the end of a jump table.  */\n-\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,INSN)\t\\\n-  fprintf (FILE, \".text\\n\")\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM)\n-\n-/* This is how to output code to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n-  fprintf (FILE, \"\\taddu -16,%ssp,%ssp\\n\\t%sst.l %s%s,0(%ssp)\\n\",\t\\\n-\ti860_reg_prefix, i860_reg_prefix,\t\t\t\t\\\n-\t((REGNO) < 32 ? \"\" : \"f\"),\t\t\t\t\t\\\n-\ti860_reg_prefix, reg_names[REGNO],\t\t\t\t\\\n-\ti860_reg_prefix)\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t%sld.l 0(%ssp),%s%s\\n\\taddu 16,%ssp,%ssp\\n\",\t\\\n-\t((REGNO) < 32 ? \"\" : \"f\"),\t\t\t\t\t\\\n-\ti860_reg_prefix,\t\t\t\t\t\t\\\n-\ti860_reg_prefix, reg_names[REGNO],\t\t\t\t\\\n-\ti860_reg_prefix, i860_reg_prefix)\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.\n-   (The i860 does not use such vectors,\n-   but we must define this macro anyway.)  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.blkb %u\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-\n-   In the following comments, the term \"constant address\" is used frequently.\n-   For an exact definition of what constitutes a \"constant address\" see the\n-   output_addr_const routine in final.c\n-\n-   On the i860, the following target-specific special codes are recognized:\n-\n-\t`r'\tThe operand can be anything, but if it is an immediate zero\n-\t\tvalue (either integer or floating point) then it will be\n-\t\trepresented as `r0' or as `f0' (respectively).\n-\n-\t`m'\tThe operand is a memory ref (to a constant address) but print\n-\t\tits address as a constant.\n-\n-\t`L'\tThe operand is a numeric constant, a constant address, or\n-\t\ta memory ref to a constant address.  Print the correct\n-\t\tnotation to yield the low part of the given value or\n-\t\taddress or the low part of the address of the referred\n-\t\tto memory object.\n-\n-\t`H'\tThe operand is a numeric constant, a constant address, or\n-\t\ta memory ref to a constant address.  Print the correct\n-\t\tnotation to yield the high part of the given value or\n-\t\taddress or the high part of the address of the referred\n-\t\tto memory object.\n-\n-\t`h'\tThe operand is a numeric constant, a constant address, or\n-\t\ta memory ref to a constant address.  Either print the\n-\t\tcorrect notation to yield the plain high part of the\n-\t\tgiven value or address (or the plain high part of the\n-\t\taddress of the memory object) or else print the correct\n-\t\tnotation to yield the \"adjusted\" high part of the given\n-\t\taddress (or of the address of the referred to memory object).\n-\n-\t\tThe choice of what to print depends upon whether the address\n-\t\tin question is relocatable or not.  If it is relocatable,\n-\t\tprint the notation to get the adjusted high part.  Otherwise\n-\t\tjust print the notation to get the plain high part.  Note\n-\t\tthat \"adjusted\" high parts are generally used *only* when\n-\t\tthe next following instruction uses the low part of the\n-\t\taddress as an offset, as in `offset(reg)'.\n-\n-\t`R'\tThe operand is a floating-pointer register.  Print the\n-\t\tname of the next following (32-bit) floating-point register.\n-\t\t(This is used when moving a value into just the most\n-\t\tsignificant part of a floating-point register pair.)\n-\n-\t`?'\t(takes no operand) Substitute the value of i860_reg_prefix\n-\t\tat this point.  The value of i860_reg_prefix is typically\n-\t\ta null string for most i860 targets, but for System V\n-\t\tRelease 4 the i860 assembler syntax requires that all\n-\t\tnames of registers be prefixed with a percent-sign, so\n-\t\tfor SVR4, the value of i860_reg_prefix is initialized to\n-\t\t\"%\" in i860.c.\n-*/\n-\n-extern const char *i860_reg_prefix;\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '?')\n-\n-/* The following macro definition is overridden in i860v4.h\n-   because the svr4 i860 assembler required a different syntax\n-   for getting parts of constant/relocatable values.  */\n-\n-#define PRINT_OPERAND_PART(FILE, X, PART_CODE)\t\t\t\t\\\n-  do { fprintf (FILE, \"%s%%\", PART_CODE);\t\t\t\t\\\n-\toutput_address (X);\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define OPERAND_LOW_PART\t\"l\"\n-#define OPERAND_HIGH_PART\t\"h\"\n-/* NOTE: All documentation available for the i860 sez that you must\n-   use \"ha\" to get the relocated high part of a relocatable, but\n-   reality sez different.  */\n-#define OPERAND_HIGH_ADJ_PART\t\"ha\"\n-\n-#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n-{ if ((CODE) == '?')\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", i860_reg_prefix);\t\t\t\t\\\n-  else if (CODE == 'R')\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s%s\", i860_reg_prefix, reg_names[REGNO (X) + 1]);\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s%s\", i860_reg_prefix, reg_names[REGNO (X)]);\t\\\n-  else if ((CODE) == 'm')\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if ((CODE) == 'L')\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-\tPRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_LOW_PART);\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tPRINT_OPERAND_PART (FILE, X, OPERAND_LOW_PART);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((CODE) == 'H')\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-\tPRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_HIGH_PART);\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tPRINT_OPERAND_PART (FILE, X, OPERAND_HIGH_PART);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((CODE) == 'h')\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-\tPRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_HIGH_ADJ_PART);\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tPRINT_OPERAND_PART (FILE, X, OPERAND_HIGH_ADJ_PART);\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if ((CODE) == 'r' && (X) == const0_rtx)\t\t\t\t\\\n-    fprintf (FILE, \"%sr0\", i860_reg_prefix);\t\t\t\t\\\n-  else if ((CODE) == 'r' && (X) == CONST0_RTX (GET_MODE (X)))\t\t\\\n-    fprintf (FILE, \"%sf0\", i860_reg_prefix);\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE)\t\t\t\t\\\n-    fprintf (FILE, \"0x%lx\", sfmode_constant_to_ulong (X));\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    output_addr_const (FILE, X); }\n-\f\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx addr = ADDR;\t\t\t\t\t\\\n-  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"0(%s%s)\",\t\t\t\t\t\\\n-\ti860_reg_prefix, reg_names[REGNO (addr)]);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (addr) == CONST_DOUBLE\t\t\t\\\n-            && GET_MODE (addr) == SFmode)\t\t\t\\\n-    fprintf (FILE, \"0x%lx\", sfmode_constant_to_ulong (addr));\t\\\n-  else if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((GET_CODE (XEXP (addr, 0)) == CONST_INT)\t\t\\\n-\t  && (GET_CODE (XEXP (addr, 1)) == REG))\t\t\\\n-\tfprintf (FILE, \"%d(%s%s)\", INTVAL (XEXP (addr, 0)),\t\\\n-\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 1))]);\\\n-      else if ((GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\t\\\n-\t  && (GET_CODE (XEXP (addr, 0)) == REG))\t\t\\\n-\tfprintf (FILE, \"%d(%s%s)\", INTVAL (XEXP (addr, 1)),\t\\\n-\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 0))]);\\\n-      else if ((GET_CODE (XEXP (addr, 0)) == REG)\t\t\\\n-\t  && (GET_CODE (XEXP (addr, 1)) == REG))\t\t\\\n-\tfprintf (FILE, \"%s%s(%s%s)\",\t\t\t\t\\\n-\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 0))],\t\\\n-\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 1))]);\\\n-      else\t\t\t\t\t\t\t\\\n-\toutput_addr_const (FILE, addr);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      output_addr_const (FILE, addr);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Optionally define this if you have added predicates to\n-   `MACHINE.c'.  This macro is called within an initializer of an\n-   array of structures.  The first field in the structure is the\n-   name of a predicate and the second field is an array of rtl\n-   codes.  For each predicate, list all rtl codes that can be in\n-   expressions matched by the predicate.  The list should have a\n-   trailing comma.  Here is an example of two entries in the list\n-   for a typical RISC machine:\n-\n-   #define PREDICATE_CODES \\\n-     {\"gen_reg_rtx_operand\", {SUBREG, REG}},  \\\n-     {\"reg_or_short_cint_operand\", {SUBREG, REG, CONST_INT}},\n-\n-   Defining this macro does not affect the generated code (however,\n-   incorrect definitions that omit an rtl code that may be matched\n-   by the predicate can cause the compiler to malfunction). \n-   Instead, it allows the table built by `genrecog' to be more\n-   compact and efficient, thus speeding up the compiler.  The most\n-   important predicates to include in the list specified by this\n-   macro are thoses used in the most insn patterns.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-   {\"reg_or_0_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n-   {\"arith_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n-   {\"logic_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n-   {\"shift_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n-   {\"compare_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n-   {\"bte_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n-   {\"indexed_operand\",\t\t{MEM}},\t\t\t\t\t\\\n-   {\"load_operand\",\t\t{MEM}},\t\t\t\t\t\\\n-   {\"small_int\",\t\t{CONST_INT}},\t\t\t\t\\\n-   {\"logic_int\",\t\t{CONST_INT}},\t\t\t\t\\\n-   {\"call_insn_operand\",\t{MEM}},\n-\n-/* Define the information needed to generate branch insns.  This is stored\n-   from the compare operation.  Note that we can't use \"rtx\" here since it\n-   hasn't been defined!  */\n-\n-extern struct rtx_def *i860_compare_op0, *i860_compare_op1;"}, {"sha": "385d369d9bcf96496d3e7dbd2da6f2032fdcdc02", "filename": "gcc/config/i860/i860.md", "status": "removed", "additions": 0, "deletions": 2231, "changes": 2231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,2231 +0,0 @@\n-;;  GCC Machine description for the Intel i860 microprocessor\n-;;  Copyright (C) 1989, 1990, 1997, 1998, 1999, 2000, 2003, 2004\n-;;  Free Software Foundation, Inc.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-;; Boston, MA 02110-1301, USA.\n-\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;;- updates for most instructions.\n-\n-;;\n-;; UNSPEC_VOLATILE usage\n-;;\n-\n-(define_constants\n-  [; Blockage\n-   (UNSPECV_BLOCKAGE\t\t0)\n-  ])\n-\n-;;- Operand classes for the register allocator:\n-\f\n-/* Bit-test instructions.  */\n-\n-(define_insn \"\"\n-  [(set (cc0) (eq (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"logic_operand\" \"rL\"))\n-\t\t  (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"and %1,%0,%?r0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (ne (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"logic_operand\" \"rL\"))\n-\t\t  (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"and %1,%0,%?r0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (eq (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"i\"))\n-\t\t  (const_int 0)))]\n-  \"GET_CODE (operands[1]) == CONST_INT && (INTVAL (operands[1]) & 0xffff) == 0\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"andh %H1,%0,%?r0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (ne (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"i\"))\n-\t\t  (const_int 0)))]\n-  \"GET_CODE (operands[1]) == CONST_INT && (INTVAL (operands[1]) & 0xffff) == 0\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"andh %H1,%0,%?r0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (eq (ashiftrt:SI\n-\t\t   (sign_extend:SI\n-\t\t    (ashift:QI (match_operand:QI 0 \"register_operand\" \"r\")\n-\t\t\t       (match_operand:QI 1 \"logic_int\" \"n\")))\n-\t\t   (match_operand:SI 2 \"logic_int\" \"n\"))\n-\t\t  (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  int width = 8 - INTVAL (operands[2]);\n-  int pos = 8 - width - INTVAL (operands[1]);\n-\n-  CC_STATUS_PARTIAL_INIT;\n-  operands[2] = GEN_INT (~((-1) << width) << pos);\n-  return \\\"and %2,%0,%?r0\\\";\n-}\")\n-\f\n-;; -------------------------------------------------------------------------\n-;; SImode signed integer comparisons\n-;; -------------------------------------------------------------------------\n-\n-(define_insn \"cmpeqsi\"\n-  [(set (cc0) (eq (match_operand:SI 0 \"logic_operand\" \"r,rL\")\n-\t\t  (match_operand:SI 1 \"logic_operand\" \"L,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[0]))\n-    return \\\"xor %1,%0,%?r0\\\";\n-  else\n-    return \\\"xor %0,%1,%?r0\\\";\n-}\")\n-\n-(define_insn \"cmpnesi\"\n-  [(set (cc0) (ne (match_operand:SI 0 \"logic_operand\" \"r,rL\")\n-\t\t  (match_operand:SI 1 \"logic_operand\" \"L,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  if (REG_P (operands[0]))\n-    return \\\"xor %1,%0,%?r0\\\";\n-  else\n-    return \\\"xor %0,%1,%?r0\\\";\n-}\")\n-\n-(define_insn \"cmpltsi\"\n-  [(set (cc0) (lt (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n-\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[1]))\n-    return \\\"subs %0,%1,%?r0\\\";\n-  else\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      operands[1] = GEN_INT (- INTVAL (operands[1]));\n-      return \\\"adds %1,%0,%?r0\\\";\n-    }\n-}\")\n-\n-(define_insn \"cmpgtsi\"\n-  [(set (cc0) (gt (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n-\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[0]))\n-    return \\\"subs %1,%0,%?r0\\\";\n-  else\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      operands[0] = GEN_INT (- INTVAL (operands[0]));\n-      return \\\"adds %0,%1,%?r0\\\";\n-    }\n-}\")\n-\n-(define_insn \"cmplesi\"\n-  [(set (cc0) (le (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n-\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  if (REG_P (operands[0]))\n-    return \\\"subs %1,%0,%?r0\\\";\n-  else\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      operands[0] = GEN_INT (- INTVAL (operands[0]));\n-      return \\\"adds %0,%1,%?r0\\\";\n-    }\n-}\")\n-\n-(define_insn \"cmpgesi\"\n-  [(set (cc0) (ge (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n-\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  if (REG_P (operands[1]))\n-    return \\\"subs %0,%1,%?r0\\\";\n-  else\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      operands[1] = GEN_INT (- INTVAL (operands[1]));\n-      return \\\"adds %1,%0,%?r0\\\";\n-    }\n-}\")\n-\n-;; -------------------------------------------------------------------------\n-;; SImode unsigned integer comparisons\n-;; -------------------------------------------------------------------------\n-\n-;; WARNING!  There is a small i860 hardware limitation (bug?) which we\n-;; may run up against (if we are not careful) when we are trying to do\n-;; unsigned comparisons like (x >= 0), (x < 0), (0 <= x), and (0 > x).\n-;; Specifically, we must avoid using an `addu' instruction to perform\n-;; such comparisons because the result (in the CC bit register) will\n-;; come out wrong.  (This fact is documented in a footnote on page 7-10\n-;; of the 1991 version of the i860 Microprocessor Family Programmer's\n-;; Reference Manual).  Note that unsigned comparisons of this sort are\n-;; always redundant anyway, because an unsigned quantity can never be\n-;; less than zero.  When we see cases like this, we generate an\n-;; `or K,%r0,%r0' instruction instead (where K is a constant 0 or -1)\n-;; so as to get the CC bit register set properly for any subsequent\n-;; conditional jump instruction.\n-\n-(define_insn \"cmpgeusi\"\n-  [(set (cc0) (geu (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n-\t\t   (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[1]))\n-    return \\\"subu %0,%1,%?r0\\\";\n-  else\n-    {\n-      if (INTVAL (operands[1]) == 0)\n-\treturn \\\"or 0,%?r0,%?r0\\\";\n-      else\n-\t{\n-\t  cc_status.flags |= CC_REVERSED;\n-\t  operands[1] = GEN_INT (- INTVAL (operands[1]));\n-\t  return \\\"addu %1,%0,%?r0\\\";\n-\t}\n-    }\n-}\")\n-\n-(define_insn \"cmpleusi\"\n-  [(set (cc0) (leu (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n-\t\t   (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[0]))\n-    return \\\"subu %1,%0,%?r0\\\";\n-  else\n-    {\n-      if (INTVAL (operands[0]) == 0)\n-\treturn \\\"or 0,%?r0,%?r0\\\";\n-      else\n-\t{\n-\t  cc_status.flags |= CC_REVERSED;\n-\t  operands[0] = GEN_INT (- INTVAL (operands[0]));\n-\t  return \\\"addu %0,%1,%?r0\\\";\n-\t}\n-    }\n-}\")\n-\n-;; -------------------------------------------------------------------------\n-;; SFmode floating-point comparisons\n-;; -------------------------------------------------------------------------\n-\n-(define_insn \"cmpeqsf\"\n-  [(set (cc0) (eq (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"pfeq.ss %r0,%r1,%?f0\\\";\n-}\")\n-\n-(define_insn \"cmpnesf\"\n-  [(set (cc0) (ne (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"pfeq.ss %r1,%r0,%?f0\\\";\n-}\")\n-\n-;; NOTE:  The i860 Programmer's Reference Manual says that when we are\n-;; doing (A < B) or (A > B) comparisons, we have to use pfgt for these\n-;; in order to be IEEE compliant (in case a trap occurs during these\n-;; operations).  Conversely, for (A <= B) or (A >= B) comparisons, we\n-;; must use pfle to be IEEE compliant.\n-\n-(define_insn \"cmpltsf\"\n-  [(set (cc0) (lt (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"pfgt.ss %r1,%r0,%?f0\\\";\n-}\")\n-\n-(define_insn \"cmpgtsf\"\n-  [(set (cc0) (gt (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"pfgt.ss %r0,%r1,%?f0\\\";\n-}\")\n-\n-;; NOTE:  The pfle opcode *clears* the CC flag if the first operand is\n-;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n-;; for the following two patterns.\n-\n-(define_insn \"cmplesf\"\n-  [(set (cc0) (le (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"pfle.ss %r0,%r1,%?f0\\\";\n-}\")\n-\n-(define_insn \"cmpgesf\"\n-  [(set (cc0) (ge (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"pfle.ss %r1,%r0,%?f0\\\";\n-}\")\n-\n-;; -------------------------------------------------------------------------\n-;; DFmode floating-point comparisons\n-;; -------------------------------------------------------------------------\n-\n-(define_insn \"cmpeqdf\"\n-  [(set (cc0) (eq (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"pfeq.dd %r0,%r1,%?f0\\\";\n-}\")\n-\n-(define_insn \"cmpnedf\"\n-  [(set (cc0) (ne (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"pfeq.dd %r1,%r0,%?f0\\\";\n-}\")\n-\n-;; NOTE:  The i860 Programmer's Reference Manual says that when we are\n-;; doing (A < B) or (A > B) comparisons, we have to use pfgt for these\n-;; in order to be IEEE compliant (in case a trap occurs during these\n-;; operations).  Conversely, for (A <= B) or (A >= B) comparisons, we\n-;; must use pfle to be IEEE compliant.\n-\n-(define_insn \"cmpltdf\"\n-  [(set (cc0) (lt (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"pfgt.dd %r1,%r0,%?f0\\\";\n-}\")\n-\n-(define_insn \"cmpgtdf\"\n-  [(set (cc0) (gt (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"pfgt.dd %r0,%r1,%?f0\\\";\n-}\")\n-\n-;; NOTE:  The pfle opcode *clears* the CC flag if the first operand is\n-;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n-;; for the following two patterns.\n-\n-(define_insn \"cmpledf\"\n-  [(set (cc0) (le (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"pfle.dd %r0,%r1,%?f0\\\";\n-}\")\n-\n-(define_insn \"cmpgedf\"\n-  [(set (cc0) (ge (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n-\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  cc_status.flags |= CC_NEGATED;\n-  return \\\"pfle.dd %r1,%r0,%?f0\\\";\n-}\")\n-\n-;; ------------------------------------------------------------------------\n-;; Integer EQ/NE comparisons against constant values which will fit in the\n-;; 16-bit immediate field of an instruction.  These are made by combining.\n-;; ------------------------------------------------------------------------\n-\n-(define_insn \"\"\n-  [(set (cc0) (eq (zero_extend:SI (match_operand:HI 0 \"load_operand\" \"m\"))\n-\t          (match_operand:SI 1 \"small_int\" \"I\")))]\n-  \"INTVAL (operands[1]) >= 0\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"ld.s %0,%?r31\\;xor %1,%?r31,%?r0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (eq (match_operand:SI 0 \"small_int\" \"I\")\n-\t          (zero_extend:SI (match_operand:HI 1 \"load_operand\" \"m\"))))]\n-  \"INTVAL (operands[0]) >= 0\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"ld.s %1,%?r31\\;xor %0,%?r31,%?r0\\\";\n-}\")\n-\f\n-;; ------------------------------------------------------------------------\n-;; Define the real conditional branch instructions.\n-;; ------------------------------------------------------------------------\n-\n-(define_insn \"cbranch\"\n-  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n-    return \\\"bnc %l0\\\";\n-  else\n-    return \\\"bc %l0\\\";\n-}\")\n-\n-(define_insn \"flipped_cbranch\"\n-  [(set (pc) (if_then_else (ne (cc0)\n-\t\t\t       (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n-    return \\\"bnc %l0\\\";\n-  else\n-    return \\\"bc %l0\\\";\n-}\")\n-\n-(define_insn \"inverse_cbranch\"\n-  [(set (pc) (if_then_else (eq (cc0)\n-\t\t\t       (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n-    return \\\"bc %l0\\\";\n-  else\n-    return \\\"bnc %l0\\\";\n-}\")\n-\n-\n-(define_insn \"flipped_inverse_cbranch\"\n-  [(set (pc) (if_then_else (ne (cc0)\n-\t\t\t       (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n-    return \\\"bc %l0\\\";\n-  else\n-    return \\\"bnc %l0\\\";\n-}\")\n-\n-;; Simple BTE/BTNE compare-and-branch insns made by combining.\n-;; Note that it is wrong to add similar patterns for QI or HImode\n-;; because bte/btne always compare the whole register.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"bte %1,%0,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"btne %1,%0,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"btne %1,%0,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n-  \"\"\n-  \"bte %1,%0,%2\")\n-\n-;; Load byte/halfword, zero-extend, & compare-and-branch insns.\n-;; These are made by combining.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (eq (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (label_ref (match_operand 2 \"\" \"\"))\n-                      (pc)))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.b %0,%3;bte %1,%3,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ne (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (label_ref (match_operand 2 \"\" \"\"))\n-                      (pc)))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.b %0,%3;btne %1,%3,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (eq (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (pc)\n-                      (label_ref (match_operand 2 \"\" \"\"))))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.b %0,%3;btne %1,%3,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ne (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (pc)\n-                      (label_ref (match_operand 2 \"\" \"\"))))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.b %0,%3;bte %1,%3,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (eq (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (label_ref (match_operand 2 \"\" \"\"))\n-                      (pc)))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.s %0,%3;bte %1,%3,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ne (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (label_ref (match_operand 2 \"\" \"\"))\n-                      (pc)))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.s %0,%3;btne %1,%3,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (eq (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (pc)\n-                      (label_ref (match_operand 2 \"\" \"\"))))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.s %0,%3;btne %1,%3,%2\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-        (if_then_else (ne (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n-                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n-                      (pc)\n-                      (label_ref (match_operand 2 \"\" \"\"))))\n-   (match_scratch:SI 3 \"=r\")]\n-  \"\"\n-  \"ld.s %0,%3;bte %1,%3,%2\")\n-\n-\f\n-;; Generation of conditionals.\n-\n-;; We save the compare operands in the cmpxx patterns and use then when\n-;; we generate the branch.\n-\n-(define_expand \"cmpsi\"\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t       (match_operand:SI 1 \"compare_operand\" \"\")))]\n-  \"\"\n-  \"\n-{ i860_compare_op0 = operands[0];\n-  i860_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpsf\"\n-  [(set (cc0) (compare (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t       (match_operand:SF 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\n-{ i860_compare_op0 = operands[0];\n-  i860_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(set (cc0) (compare (match_operand:DF 0 \"register_operand\" \"\")\n-\t\t       (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\n-{ i860_compare_op0 = operands[0];\n-  i860_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-;; These are the standard-named conditional branch patterns.\n-;; Detailed comments are found in the first one only.\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  /* Emit a single-condition compare insn according to\n-     the type of operands and the condition to be tested.  */\n-\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n-    emit_insn (gen_cmpeqsi (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == SFmode)\n-    emit_insn (gen_cmpeqsf (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == DFmode)\n-    emit_insn (gen_cmpeqdf (i860_compare_op0, i860_compare_op1));\n-  else\n-    abort ();\n-\n-  /* Emit branch-if-true.  */\n-\n-  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n-  DONE;\n-}\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n-    emit_insn (gen_cmpeqsi (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == SFmode)\n-    emit_insn (gen_cmpeqsf (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == DFmode)\n-    emit_insn (gen_cmpeqdf (i860_compare_op0, i860_compare_op1));\n-  else\n-    abort ();\n-\n-  emit_jump_insn (gen_flipped_cbranch (operands[0]));\n-\n-  DONE;\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n-    emit_insn (gen_cmpgtsi (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == SFmode)\n-    emit_insn (gen_cmpgtsf (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == DFmode)\n-    emit_insn (gen_cmpgtdf (i860_compare_op0, i860_compare_op1));\n-  else\n-    abort ();\n-\n-  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n-  DONE;\n-}\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n-    emit_insn (gen_cmpltsi (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == SFmode)\n-    emit_insn (gen_cmpltsf (i860_compare_op0, i860_compare_op1));\n-  else if (GET_MODE (i860_compare_op0) == DFmode)\n-    emit_insn (gen_cmpltdf (i860_compare_op0, i860_compare_op1));\n-  else\n-    abort ();\n-\n-  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n-  DONE;\n-}\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n-    {\n-      emit_insn (gen_cmpgtsi (i860_compare_op0, i860_compare_op1));\n-      emit_jump_insn (gen_flipped_cbranch (operands[0]));\n-    }\n-  else\n-    {\n-      if (GET_MODE (i860_compare_op0) == SFmode)\n-\temit_insn (gen_cmplesf (i860_compare_op0, i860_compare_op1));\n-      else if (GET_MODE (i860_compare_op0) == DFmode)\n-\temit_insn (gen_cmpledf (i860_compare_op0, i860_compare_op1));\n-      else\n-\tabort ();\n-      emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n-    }\n-  DONE;\n-}\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n-    {\n-      emit_insn (gen_cmpltsi (i860_compare_op0, i860_compare_op1));\n-      emit_jump_insn (gen_flipped_cbranch (operands[0]));\n-    }\n-  else\n-    {\n-      if (GET_MODE (i860_compare_op0) == SFmode)\n-\temit_insn (gen_cmpgesf (i860_compare_op0, i860_compare_op1));\n-      else if (GET_MODE (i860_compare_op0) == DFmode)\n-\temit_insn (gen_cmpgedf (i860_compare_op0, i860_compare_op1));\n-      else\n-\tabort ();\n-      emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n-    }\n-  DONE;\n-}\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n-    abort ();\n-\n-  emit_insn (gen_cmpleusi (i860_compare_op0, i860_compare_op1));\n-  emit_jump_insn (gen_flipped_cbranch (operands[0]));\n-  DONE;\n-}\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n-    abort ();\n-\n-  emit_insn (gen_cmpgeusi (i860_compare_op0, i860_compare_op1));\n-  emit_jump_insn (gen_flipped_cbranch (operands[0]));\n-  DONE;\n-}\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n-    abort ();\n-\n-  emit_insn (gen_cmpgeusi (i860_compare_op0, i860_compare_op1));\n-  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n-  DONE;\n-}\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n-    abort ();\n-\n-  emit_insn (gen_cmpleusi (i860_compare_op0, i860_compare_op1));\n-  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n-  DONE;\n-}\")\n-\f\n-;; Move instructions\n-\n-;; Note that source operands for `mov' pseudo-instructions are no longer\n-;; allowed (by the SVR4 assembler) to be \"big\" things, i.e. constants that\n-;; won't fit in 16-bits.  (This includes any sort of a relocatable address\n-;; also.)  Thus, we must use an explicit orh/or pair of instructions if\n-;; the source operand is something \"big\".\n-\n-(define_insn \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,m,f\")\n-\t(match_operand:SI 1 \"general_operand\" \"rmif,rfJ,rmfJ\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-\treturn output_store (operands);\n-      if (FP_REG_P (operands[1]))\n-\treturn \\\"fst.l %1,%0\\\";\n-      return \\\"st.l %r1,%0\\\";\n-    }\n-  if (GET_CODE (operands[1]) == MEM)\n-    {\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-\treturn output_load (operands);\n-      if (FP_REG_P (operands[0]))\n-\treturn \\\"fld.l %1,%0\\\";\n-      return \\\"ld.l %1,%0\\\";\n-    }\n-  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n-    return \\\"fmov.ss %1,%0\\\";\n-  if (FP_REG_P (operands[1]))\n-    return \\\"fxfr %1,%0\\\";\n-  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n-    return \\\"fmov.ss %?f0,%0\\\";\n-  if (FP_REG_P (operands[0]))\n-    return \\\"ixfr %1,%0\\\";\n-\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"shl %?r0,%1,%0\\\";\n-\n-  CC_STATUS_PARTIAL_INIT;\n-\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      if((INTVAL (operands[1]) & 0xffff0000) == 0)\n-        return \\\"or %L1,%?r0,%0\\\";\n-      if((INTVAL (operands[1]) & 0x0000ffff) == 0)\n-        return \\\"orh %H1,%?r0,%0\\\";\n-    }\n-  return \\\"orh %H1,%?r0,%0\\;or %L1,%0,%0\\\";\n-}\")\n- \n-(define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,m,!*f,!r\")\n-\t(match_operand:HI 1 \"general_operand\" \"rmi,rJ,rJ*f,*f\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-\treturn output_store (operands);\n-      return \\\"st.s %r1,%0\\\";\n-    }\n-  if (GET_CODE (operands[1]) == MEM)\n-    {\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-\treturn output_load (operands);\n-      return \\\"ld.s %1,%0\\\";\n-    }\n-  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n-    return \\\"fmov.ss %1,%0\\\";\n-  if (FP_REG_P (operands[1]))\n-    return \\\"fxfr %1,%0\\\";\n-  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n-    return \\\"fmov.ss %?f0,%0\\\";\n-  if (FP_REG_P (operands[0]))\n-    return \\\"ixfr %1,%0\\\";\n-\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"shl %?r0,%1,%0\\\";\n-\n-  CC_STATUS_PARTIAL_INIT;\n-\n-  return \\\"or %L1,%?r0,%0\\\";\n-}\")\n-\n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,m,!*f,!r\")\n-\t(match_operand:QI 1 \"general_operand\" \"rmi,rJ,rJ*f,*f\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-\treturn output_store (operands);\n-      return \\\"st.b %r1,%0\\\";\n-    }\n-  if (GET_CODE (operands[1]) == MEM)\n-    {\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-\treturn output_load (operands);\n-      return \\\"ld.b %1,%0\\\";\n-    }\n-  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n-    return \\\"fmov.ss %1,%0\\\";\n-  if (FP_REG_P (operands[1]))\n-    return \\\"fxfr %1,%0\\\";\n-  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n-    return \\\"fmov.ss %?f0,%0\\\";\n-  if (FP_REG_P (operands[0]))\n-    return \\\"ixfr %1,%0\\\";\n-\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"shl %?r0,%1,%0\\\";\n-\n-  CC_STATUS_PARTIAL_INIT;\n-\n-  return \\\"or %L1,%?r0,%0\\\";\n-}\")\n-\n-;; The definition of this insn does not really explain what it does,\n-;; but it should suffice\n-;; that anything generated as this insn will be recognized as one\n-;; and that it won't successfully combine with anything.\n-(define_expand \"movmemsi\"\n-  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n-\t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n-\t      (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n-\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n-\t      (clobber (match_dup 4))\n-\t      (clobber (match_dup 5))\n-\t      (clobber (match_dup 6))\n-\t      (clobber (match_dup 7))\n-\t      (clobber (match_dup 8))])]\n-  \"\"\n-  \"\n-{\n-  operands[4] = gen_reg_rtx (SImode);\n-  operands[5] = gen_reg_rtx (SImode);\n-  operands[6] = gen_reg_rtx (SImode);\n-  operands[7] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n-  operands[8] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n-\n-  operands[0] = replace_equiv_address (operands[0], operands[7]);\n-  operands[1] = replace_equiv_address (operands[1], operands[8]);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\n-\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\n-   (use (match_operand:SI 2 \"general_operand\" \"rn\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_operand:SI 4 \"register_operand\" \"=r\"))\n-   (clobber (match_operand:SI 5 \"register_operand\" \"=r\"))\n-   (clobber (match_operand:SI 6 \"register_operand\" \"=r\"))\n-   (clobber (match_dup 0))\n-   (clobber (match_dup 1))]\n-  \"\"\n-  \"* return output_block_move (operands);\")\n-\f\n-;; Floating point move insns\n-\n-;; This pattern forces (set (reg:DF ...) (const_double ...))\n-;; to be reloaded by putting the constant into memory.\n-;; It must come before the more general movdf pattern.\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,f,o\")\n-\t(match_operand:DF 1 \"\" \"mG,m,G\"))]\n-  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]) || operands[1] == CONST0_RTX (DFmode))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n-}\")\n-\n-(define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=*rm,*r,?f,?*rm\")\n-\t(match_operand:DF 1 \"general_operand\" \"*r,m,*rfmG,f\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM\n-      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-    return output_store (operands);\n-  if (GET_CODE (operands[1]) == MEM\n-      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-    return output_load (operands);\n-\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n-}\")\n-\n-(define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=rm,r,?f,?rm\")\n-\t(match_operand:DI 1 \"general_operand\" \"r,miF,rfmG,f\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM\n-      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-    return output_store (operands);\n-  if (GET_CODE (operands[1]) == MEM\n-      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-    return output_load (operands);\n-\n-  /* ??? How can we have a DFmode arg here with DImode above?  */\n-  if (FP_REG_P (operands[0]) && operands[1] == CONST0_RTX (DFmode))\n-    return \\\"fmov.dd %?f0,%0\\\";\n-\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n-}\")\n-\n-;; The alternative m/r is separate from m/f\n-;; The first alternative is separate from the second for the same reason.\n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=*rf,*rf,*r,m,m\")\n-\t(match_operand:SF 1 \"general_operand\" \"*r,fmG,F,*r,f\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM\n-      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-    return output_store (operands);\n-  if (GET_CODE (operands[1]) == MEM\n-      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-    return output_load (operands);\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \\\"fmov.ss %1,%0\\\";\n-      if (GET_CODE (operands[1]) == REG)\n-\treturn \\\"ixfr %1,%0\\\";\n-      if (operands[1] == CONST0_RTX (SFmode))\n-        return \\\"fmov.ss %?f0,%0\\\";\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-\t{\n-\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t && cc_prev_status.mdep == XEXP(operands[1],0)))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t      cc_status.mdep = XEXP (operands[1], 0);\n-\t      return \\\"orh %h1,%?r0,%?r31\\;fld.l %L1(%?r31),%0\\\";\n-\t    }\n-\t  return \\\"fld.l %L1(%?r31),%0\\\";\n-\t}\n-      return \\\"fld.l %1,%0\\\";\n-    }\n-  if (FP_REG_P (operands[1]) || GET_CODE (operands[1]) == CONST_DOUBLE)\n-    {\n-      if (GET_CODE (operands[0]) == REG && FP_REG_P (operands[1]))\n-\treturn \\\"fxfr %1,%0\\\";\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  CC_STATUS_PARTIAL_INIT;\n-\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t    {\n-\t      register unsigned long ul;\n-\n-              ul = sfmode_constant_to_ulong (operands[1]);\n-\t      if ((ul & 0x0000ffff) == 0)\n-\t\treturn \\\"orh %H1,%?r0,%0\\\";\n-\t      if ((ul & 0xffff0000) == 0)\n-\t\treturn \\\"or %L1,%?r0,%0\\\";\n-\t    }\n-          return \\\"orh %H1,%?r0,%0\\;or %L1,%0,%0\\\";\n-\t}\n-      /* Now operand 0 must be memory.\n-         If operand 1 is CONST_DOUBLE, its value must be 0.  */\n-      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-\t{\n-\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t\t && XEXP (operands[0], 0) == cc_prev_status.mdep))\n-\t    {\n-\t      CC_STATUS_INIT;\n-\t      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t      cc_status.mdep = XEXP (operands[0], 0);\n-\t      output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n-\t    }\n-\t  return \\\"fst.l %r1,%L0(%?r31)\\\";\n-\t}\n-      return \\\"fst.l %r1,%0\\\";\n-    }\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st.l %r1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"ld.l %1,%0\\\";\n-  if (operands[1] == CONST0_RTX (SFmode))\n-    return \\\"shl %?r0,%?r0,%0\\\";\n-  return \\\"mov %1,%0\\\";\n-}\")\n-\f\n-;; Special load insns for REG+REG addresses.\n-;; Such addresses are not \"legitimate\" because st rejects them.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=rf\")\n-\t(match_operand:DF 1 \"indexed_operand\" \"m\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=rf\")\n-\t(match_operand:SF 1 \"indexed_operand\" \"m\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    return \\\"fld.l %1,%0\\\";\n-  return \\\"ld.l %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n-\t(match_operand:SI 1 \"indexed_operand\" \"m\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    return \\\"fld.l %1,%0\\\";\n-  return \\\"ld.l %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(match_operand:HI 1 \"indexed_operand\" \"m\"))]\n-  \"\"\n-  \"ld.s %1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_operand:QI 1 \"indexed_operand\" \"m\"))]\n-  \"\"\n-  \"ld.b %1,%0\")\n-\n-;; Likewise for floating-point store insns.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"indexed_operand\" \"=m\")\n-\t(match_operand:DF 1 \"register_operand\" \"f\"))]\n-  \"\"\n-  \"fst.d %1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"indexed_operand\" \"=m\")\n-\t(match_operand:SF 1 \"register_operand\" \"f\"))]\n-  \"\"\n-  \"fst.l %1,%0\")\n-\f\n-;;- truncation instructions\n-(define_insn \"truncsiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n-\t(truncate:QI\n-\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-  {\n-    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-      {\n-\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n-\t  {\n-\t    CC_STATUS_INIT;\n-\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t    cc_status.mdep = XEXP (operands[0], 0);\n-\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n-\t  }\n-\treturn \\\"st.b %1,%L0(%?r31)\\\";\n-      }\n-    else\n-      return \\\"st.b %1,%0\\\";\n-  }\n-  return \\\"shl %?r0,%1,%0\\\";\n-}\")\n-\n-(define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n-\t(truncate:QI\n-\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-  {\n-    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-      {\n-\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n-\t  {\n-\t    CC_STATUS_INIT;\n-\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t    cc_status.mdep = XEXP (operands[0], 0);\n-\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n-\t  }\n-\treturn \\\"st.b %1,%L0(%?r31)\\\";\n-      }\n-    else\n-      return \\\"st.b %1,%0\\\";\n-  }\n-  return \\\"shl %?r0,%1,%0\\\";\n-}\")\n-\n-(define_insn \"truncsihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n-\t(truncate:HI\n-\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-  {\n-    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n-      {\n-\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n-\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n-\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n-\t  {\n-\t    CC_STATUS_INIT;\n-\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-\t    cc_status.mdep = XEXP (operands[0], 0);\n-\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n-\t  }\n-\treturn \\\"st.s %1,%L0(%?r31)\\\";\n-      }\n-    else\n-      return \\\"st.s %1,%0\\\";\n-  }\n-  return \\\"shl %?r0,%1,%0\\\";\n-}\")\n-\f\n-;;- zero extension instructions\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"and 0xffff,%1,%0\\\";\n-}\")\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI\n-\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"and 0xff,%1,%0\\\";\n-}\")\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI\n-\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"and 0xff,%1,%0\\\";\n-}\")\n-\f\n-;; Sign extension instructions.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI\n-\t (match_operand:HI 1 \"indexed_operand\" \"m\")))]\n-  \"\"\n-  \"ld.s %1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:HI\n-\t (match_operand:QI 1 \"indexed_operand\" \"m\")))]\n-  \"\"\n-  \"ld.b %1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI\n-\t (match_operand:QI 1 \"indexed_operand\" \"m\")))]\n-  \"\"\n-  \"ld.b %1,%0\")\n-\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"mr\")))]\n-  \"\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    return \\\"shl 16,%1,%0\\;shra 16,%0,%0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    abort ();\n-  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-    {\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-      cc_status.mdep = XEXP (operands[1], 0);\n-      return \\\"orh %h1,%?r0,%?r31\\;ld.s %L1(%?r31),%0\\\";\n-    }\n-  else\n-    return \\\"ld.s %1,%0\\\";\n-}\")\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:HI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"mr\")))]\n-  \"\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    return \\\"shl 24,%1,%0\\;shra 24,%0,%0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    abort ();\n-  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-    {\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-      cc_status.mdep = XEXP (operands[1], 0);\n-      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n-    }\n-  else\n-    return \\\"ld.b %1,%0\\\";\n-}\")\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"mr\")))]\n-  \"\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    return \\\"shl 24,%1,%0\\;shra 24,%0,%0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    abort ();\n-  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-    {\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-      cc_status.mdep = XEXP (operands[1], 0);\n-      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n-    }\n-  else\n-    return \\\"ld.b %1,%0\\\";\n-}\")\n-\n-;; Signed bitfield extractions come out looking like\n-;;\t(shiftrt (sign_extend (shift <Y> <C1>)) <C2>)\n-;; which we expand poorly as four shift insns.\n-;; These patterns yield two shifts:\n-;;\t(shiftrt (shift <Y> <C3>) <C4>)\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI\n-\t (sign_extend:SI\n-\t  (match_operand:QI 1 \"register_operand\" \"r\"))\n-\t (match_operand:SI 2 \"logic_int\" \"n\")))]\n-  \"INTVAL (operands[2]) < 8\"\n-  \"*\n-{\n-  return \\\"shl 24,%1,%0\\;shra 24+%2,%0,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI\n-\t (sign_extend:SI\n-\t  (subreg:QI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t(match_operand:SI 2 \"logic_int\" \"n\")) 0))\n-\t (match_operand:SI 3 \"logic_int\" \"n\")))]\n-  \"INTVAL (operands[3]) < 8\"\n-  \"*\n-{\n-  return \\\"shl 0x18+%2,%1,%0\\;shra 0x18+%3,%0,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI\n-\t (sign_extend:SI\n-\t  (ashift:QI (match_operand:QI 1 \"register_operand\" \"r\")\n-\t\t     (match_operand:QI 2 \"logic_int\" \"n\")))\n-\t (match_operand:SI 3 \"logic_int\" \"n\")))]\n-  \"INTVAL (operands[3]) < 8\"\n-  \"*\n-{\n-  return \\\"shl 0x18+%2,%1,%0\\;shra 0x18+%3,%0,%0\\\";\n-}\")\n-\f\n-;; Special patterns for optimizing bit-field instructions.\n-\n-;; First two patterns are for bitfields that came from memory\n-;; testing only the high bit.  They work with old combiner.\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(eq (zero_extend:SI (subreg:QI (lshiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t\t\t\t    (const_int 7)) 0))\n-\t    (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"and 128,%0,%?r0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(eq (sign_extend:SI (subreg:QI (ashiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t\t\t\t    (const_int 7)) 0))\n-\t    (const_int 0)))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"and 128,%0,%?r0\\\";\n-}\")\n-\n-;; The next two patterns are good for bitfields coming from memory\n-;; (via pseudo-register) or from a register, though this optimization\n-;; is only good for values contained wholly within the bottom 13 bits.\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(eq \n-\t (and:SI (lshiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t      (match_operand:SI 1 \"logic_int\" \"n\"))\n-\t\t (match_operand:SI 2 \"logic_int\" \"n\"))\n-\t (const_int 0)))]\n-  \"LOGIC_INTVAL (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  operands[2] = GEN_INT (INTVAL (operands[2]) << INTVAL (operands[1]));\n-  return \\\"and %2,%0,%?r0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(eq \n-\t (and:SI (ashiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t      (match_operand:SI 1 \"logic_int\" \"n\"))\n-\t\t (match_operand:SI 2 \"logic_int\" \"n\"))\n-\t (const_int 0)))]\n-  \"LOGIC_INTVAL (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  operands[2] = GEN_INT (INTVAL (operands[2]) << INTVAL (operands[1]));\n-  return \\\"and %2,%0,%?r0\\\";\n-}\")\n-\f\n-;; Conversions between float and double.\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float_extend:DF\n-\t (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fmov.sd %1,%0\")\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(float_truncate:SF\n-\t (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fmov.ds %1,%0\")\n-\f\n-;; Conversion between fixed point and floating point.\n-;; Note that among the fix-to-float insns\n-;; the ones that start with SImode come first.\n-;; That is so that an operand that is a CONST_INT\n-;; (and therefore lacks a specific machine mode)\n-;; will be recognized as SImode (which is always valid)\n-;; rather than as QImode or HImode.\n-\n-;; This pattern forces (set (reg:SF ...) (float:SF (const_int ...)))\n-;; to be reloaded by putting the constant into memory.\n-;; It must come before the more general floatsisf2 pattern.\n-(define_expand \"floatsidf2\"\n-  [(set (match_dup 2) (match_dup 3))\n-   (set (match_dup 4) (xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t      (const_int -2147483648)))\n-   (set (match_dup 5) (match_dup 3))\n-   (set (subreg:SI (match_dup 5) 0) (match_dup 4))\n-   (set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(minus:DF (match_dup 5) (match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  REAL_VALUE_TYPE d;\n-  /* 4503601774854144 is  (1 << 30) * ((1 << 22) + (1 << 1)).  */\n-  d = REAL_VALUE_ATOF (\\\"4503601774854144\\\", DFmode);\n-  operands[2] = gen_reg_rtx (DFmode);\n-  operands[3] = CONST_DOUBLE_FROM_REAL_VALUE (d, DFmode);\n-  operands[4] = gen_reg_rtx (SImode);\n-  operands[5] = gen_reg_rtx (DFmode);\n-}\")\n-\f\n-;; Floating to fixed conversion.\n-\n-(define_expand \"fix_truncdfsi2\"\n-  ;; This first insn produces a double-word value\n-  ;; in which only the low word is valid.\n-  [(set (match_dup 2)\n-\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=f\")\n-\t(subreg:SI (match_dup 2) 0))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DImode);\n-}\")\n-\n-;; Recognize the first insn generated above.\n-;; This RTL looks like a fix_truncdfdi2 insn,\n-;; but we don't call it that, because only 32 bits\n-;; of the result are valid.\n-;; This pattern will work for the intended purposes \n-;; as long as we do not have any fixdfdi2 or fix_truncdfdi2.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n-\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n-  \"\"\n-  \"ftrunc.dd %1,%0\")\n-\n-(define_expand \"fix_truncsfsi2\"\n-  ;; This first insn produces a double-word value\n-  ;; in which only the low word is valid.\n-  [(set (match_dup 2)\n-\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))\n-   (set (match_operand:SI 0 \"register_operand\" \"=f\")\n-\t(subreg:SI (match_dup 2) 0))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = gen_reg_rtx (DImode);\n-}\")\n-\n-;; Recognize the first insn generated above.\n-;; This RTL looks like a fix_truncsfdi2 insn,\n-;; but we don't call it that, because only 32 bits\n-;; of the result are valid.\n-;; This pattern will work for the intended purposes \n-;; as long as we do not have any fixsfdi2 or fix_truncsfdi2.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n-\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n-  \"\"\n-  \"ftrunc.sd %1,%0\")\n-\f\n-;;- arithmetic instructions\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,*f\")\n-\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r,*f\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"rI,*f\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 1)\n-    return \\\"fiadd.ss %2,%1,%0\\\";\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"addu %2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%f\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fiadd.dd %1,%2,%0\")\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,*f\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r,I,*f\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"rI,r,*f\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 2)\n-    return \\\"fisub.ss %1,%2,%0\\\";\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[2]))\n-    return \\\"subu %1,%2,%0\\\";\n-  operands[2] = GEN_INT (- INTVAL (operands[2]));\n-  return \\\"addu %2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"f\")\n-\t\t  (match_operand:DI 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fisub.dd %1,%2,%0\")\n-\n-(define_expand \"mulsi3\"\n-  [(set (subreg:SI (match_dup 4) 0) (match_operand:SI 1 \"general_operand\" \"\"))\n-   (set (subreg:SI (match_dup 5) 0) (match_operand:SI 2 \"general_operand\" \"\"))\n-   (clobber (match_dup 3))\n-   (set (subreg:SI (match_dup 3) 0)\n-\t(mult:SI (subreg:SI (match_dup 4) 0) (subreg:SI (match_dup 5) 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 0))]\n-  \"\"\n-  \"\n-{\n-  if (WORDS_BIG_ENDIAN)\n-    emit_insn (gen_mulsi3_big (operands[0], operands[1], operands[2]));\n-  else\n-    emit_insn (gen_mulsi3_little (operands[0], operands[1], operands[2]));\n-  DONE;\n-}\")\n-\n-(define_expand \"mulsi3_little\"\n-  [(set (subreg:SI (match_dup 4) 0) (match_operand:SI 1 \"general_operand\" \"\"))\n-   (set (subreg:SI (match_dup 5) 0) (match_operand:SI 2 \"general_operand\" \"\"))\n-   (clobber (match_dup 3))\n-   (set (subreg:SI (match_dup 3) 0)\n-\t(mult:SI (subreg:SI (match_dup 4) 0) (subreg:SI (match_dup 5) 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 0))]\n-  \"! WORDS_BIG_ENDIAN\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (DImode);\n-  operands[4] = gen_reg_rtx (DImode);\n-  operands[5] = gen_reg_rtx (DImode);\n-}\")\n-\n-(define_expand \"mulsi3_big\"\n-  [(set (subreg:SI (match_dup 4) 4) (match_operand:SI 1 \"general_operand\" \"\"))\n-   (set (subreg:SI (match_dup 5) 4) (match_operand:SI 2 \"general_operand\" \"\"))\n-   (clobber (match_dup 3))\n-   (set (subreg:SI (match_dup 3) 4)\n-\t(mult:SI (subreg:SI (match_dup 4) 4) (subreg:SI (match_dup 5) 4)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 4))]\n-  \"WORDS_BIG_ENDIAN\"\n-  \"\n-{\n-  operands[3] = gen_reg_rtx (DImode);\n-  operands[4] = gen_reg_rtx (DImode);\n-  operands[5] = gen_reg_rtx (DImode);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=f\") 0)\n-\t(mult:SI (subreg:SI (match_operand:DI 1 \"register_operand\" \"f\") 0)\n-\t\t (subreg:SI (match_operand:DI 2 \"register_operand\" \"f\") 0)))]\n-  \"! WORDS_BIG_ENDIAN\"\n-  \"fmlow.dd %2,%1,%0\")\n-\n-(define_insn \"\"\n-  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=f\") 4)\n-\t(mult:SI (subreg:SI (match_operand:DI 1 \"register_operand\" \"f\") 4)\n-\t\t (subreg:SI (match_operand:DI 2 \"register_operand\" \"f\") 4)))]\n-  \"WORDS_BIG_ENDIAN\"\n-  \"fmlow.dd %2,%1,%0\")\n-\f\n-;;- and instructions (with compliment also)\t\t\t   \n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xop[3];\n-\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n-    return \\\"and %2,%1,%0\\\";\n-  if ((INTVAL (operands[2]) & 0xffff) == 0)\n-    {\n-      operands[2]\n-\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n-      return \\\"andh %2,%1,%0\\\";\n-    }\n-  xop[0] = operands[0];\n-  xop[1] = operands[1];\n-  xop[2] = GEN_INT (~INTVAL (operands[2]) & 0xffff);\n-  output_asm_insn (\\\"andnot %2,%1,%0\\\", xop);\n-  operands[2] = GEN_INT (~(unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n-  return \\\"andnoth %2,%0,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"rn\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xop[3];\n-\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[1]) || LOGIC_INT (operands[1]))\n-    return \\\"andnot %1,%2,%0\\\";\n-  if ((INTVAL (operands[1]) & 0xffff) == 0)\n-    {\n-      operands[1]\n-\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[1]) >> 16);\n-      return \\\"andnoth %1,%2,%0\\\";\n-    }\n-  xop[0] = operands[0];\n-  xop[1] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n-  xop[2] = operands[2];\n-  output_asm_insn (\\\"andnot %1,%2,%0\\\", xop);\n-  operands[1] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[1]) >> 16);\n-  return \\\"andnoth %1,%0,%0\\\";\n-}\")\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xop[3];\n-\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n-    return \\\"or %2,%1,%0\\\";\n-  if ((INTVAL (operands[2]) & 0xffff) == 0)\n-    {\n-      operands[2]\n-\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n-      return \\\"orh %2,%1,%0\\\";\n-    }\n-  xop[0] = operands[0];\n-  xop[1] = operands[1];\n-  xop[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-  output_asm_insn (\\\"or %2,%1,%0\\\", xop);\n-  operands[2] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n-  return \\\"orh %2,%0,%0\\\";\n-}\")\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xop[3];\n-\n-  CC_STATUS_PARTIAL_INIT;\n-  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n-    return \\\"xor %2,%1,%0\\\";\n-  if ((INTVAL (operands[2]) & 0xffff) == 0)\n-    {\n-      operands[2]\n-\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n-      return \\\"xorh %2,%1,%0\\\";\n-    }\n-  xop[0] = operands[0];\n-  xop[1] = operands[1];\n-  xop[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-  output_asm_insn (\\\"xor %2,%1,%0\\\", xop);\n-  operands[2] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n-  return \\\"xorh %2,%0,%0\\\";\n-}\")\n-\n-;(The i860 instruction set doesn't allow an immediate second operand in\n-; a subtraction.)\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"subu %?r0,%1,%0\\\";\n-}\")\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"arith_operand\" \"r\")))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  return \\\"subu -1,%1,%0\\\";\n-}\")\n-\f\n-;; Floating point arithmetic instructions.\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fadd.dd %1,%2,%0\")\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fadd.ss %1,%2,%0\")\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fsub.dd %1,%2,%0\")\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fsub.ss %1,%2,%0\")\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fmul.dd %1,%2,%0\")\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fmul.ss %1,%2,%0\")\n-\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fsub.dd %?f0,%1,%0\")\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"\"\n-  \"fsub.ss %?f0,%1,%0\")\n-\f\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"f\")))\n-   (clobber (match_scratch:DF 3 \"=&f\"))\n-   (clobber (match_scratch:DF 4 \"=&f\"))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  if (((cc_prev_status.flags & CC_KNOW_HI_R31) == 0)\n-      || (cc_prev_status.flags & CC_HI_R31_ADJ)\n-      || (cc_prev_status.mdep != CONST2_RTX (SFmode)))\n-    {\n-      cc_status.flags |= CC_KNOW_HI_R31;\n-      cc_status.flags &= ~CC_HI_R31_ADJ;\n-      cc_status.mdep = CONST2_RTX (SFmode); \n-      return \\\"frcp.dd %2,%3\\;fmul.dd %2,%3,%0\\;fmov.dd %?f0,%4\\;\\\\\n-orh 0x4000,%?r0,%?r31\\;ixfr %?r31,%R4\\;fsub.dd %4,%0,%0\\;\\\\\n-fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n-fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n-fmul.dd %3,%1,%3\\;fmul.dd %0,%3,%0\\\";\n-    }\n-  else\n-    return \\\"frcp.dd %2,%3\\;fmul.dd %2,%3,%0\\;fmov.dd %?f0,%4\\;\\\\\n-ixfr %?r31,%R4\\;fsub.dd %4,%0,%0\\;\\\\\n-fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n-fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n-fmul.dd %3,%1,%3\\;fmul.dd %0,%3,%0\\\";\n-}\")\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"f\")))\n-   (clobber (match_scratch:SF 3 \"=&f\"))\n-   (clobber (match_scratch:SF 4 \"=&f\"))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_PARTIAL_INIT;\n-  if (((cc_prev_status.flags & CC_KNOW_HI_R31) == 0)\n-      || (cc_prev_status.flags & CC_HI_R31_ADJ)\n-      || (cc_prev_status.mdep != CONST2_RTX (SFmode)))\n-    {\n-      cc_status.flags |= CC_KNOW_HI_R31;\n-      cc_status.flags &= ~CC_HI_R31_ADJ;\n-      cc_status.mdep = CONST2_RTX (SFmode);\n-      output_asm_insn (\\\"orh 0x4000,%?r0,%?r31\\\", operands);\n-    }\n-  return \\\"ixfr %?r31,%4\\;frcp.ss %2,%0\\;\\\\\n-fmul.ss %2,%0,%3\\;fsub.ss %4,%3,%3\\;fmul.ss %0,%3,%0\\;\\\\\n-fmul.ss %2,%0,%3\\;fsub.ss %4,%3,%3\\;\\\\\n-fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n-}\")\n-\f\n-;; Shift instructions\n-\n-;; Optimized special case of shifting, which must precede the general case.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t\t     (const_int 24)))]\n-  \"\"\n-  \"*\n-{\n-  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n-    {\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n-      cc_status.mdep = XEXP (operands[1], 0);\n-      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n-    }\n-  return \\\"ld.b %1,%0\\\";\n-}\")\n-\n-\f\n-;;- Arithmetic shift instructions.\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"shl %2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:HI 2 \"shift_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"shl %2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:QI 2 \"shift_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"shl %2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t     (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"shra %2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t     (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"shr %2,%1,%0\\\";\n-}\")\n-\f\n-;; Unconditional and other jump instructions.\n-\n-(define_insn \"jump\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"br %l0\\;nop\\\";\n-}\")\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"bri %0\\;nop\")\n-\n-;;- jump to subroutine\n-(define_expand \"call\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand 1 \"\" \"i\"))]\n-  ;; operand[2] is next_arg_register\n-  \"\"\n-  \"\n-{\n-  /* Make sure the address is just one reg and will stay that way.  */\n-  if (! call_insn_operand (operands[0], QImode))\n-    operands[0]\n-      = replace_equiv_address (operands[0],\n-\t\t\t       copy_to_mode_reg (Pmode,\n-\t\t\t\t\t\t XEXP (operands[0], 0)));\n-  if (INTVAL (operands[1]) > 0)\n-    {\n-      emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n-      emit_insn (gen_rtx_USE (VOIDmode, arg_pointer_rtx));\n-    }\n-}\")\n-\n-;;- Jump to subroutine.\n-(define_insn \"\"\n-  [(call (match_operand:SI 0 \"call_insn_operand\" \"m\")\n-\t (match_operand 1 \"\" \"i\"))]\n-  ;; operand[2] is next_arg_register\n-  \"\"\n-  \"*\n-{\n-  /* strip the MEM.  */\n-  operands[0] = XEXP (operands[0], 0);\n-  CC_STATUS_INIT;\n-  if (GET_CODE (operands[0]) == REG)\n-    return \\\"calli %0\\;nop\\\";\n-  return \\\"call %0\\;nop\\\";\n-}\")\n-\n-(define_expand \"call_value\"\n-  [(set (match_operand 0 \"register_operand\" \"=rf\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand 2 \"\" \"i\")))]\n-  ;; operand 3 is next_arg_register\n-  \"\"\n-  \"\n-{\n-  /* Make sure the address is just one reg and will stay that way.  */\n-  if (! call_insn_operand (operands[1], QImode))\n-    operands[1]\n-      = replace_equiv_address (operands[1],\n-\t\t\t       copy_to_mode_reg (Pmode,\n-\t\t\t\t\t\t XEXP (operands[1], 0)));\n-  if (INTVAL (operands[2]) > 0)\n-    {\n-      emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n-      emit_insn (gen_rtx_USE (VOIDmode, arg_pointer_rtx));\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand 0 \"register_operand\" \"=rf\")\n-\t(call (match_operand:SI 1 \"call_insn_operand\" \"m\")\n-\t      (match_operand 2 \"\" \"i\")))]\n-  ;; operand 3 is next_arg_register\n-  \"\"\n-  \"*\n-{\n-  /* Strip the MEM.  */\n-  operands[1] = XEXP (operands[1], 0);\n-  CC_STATUS_INIT;\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"calli %1\\;nop\\\";\n-  return \\\"call %1\\;nop\\\";\n-}\")\n-\n-;; Call subroutine returning any type.\n-\n-(define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-\t\t    (const_int 0))\n-\t      (match_operand 1 \"\" \"\")\n-\t      (match_operand 2 \"\" \"\")])]\n-  \"\"\n-  \"\n-{\n-  int i;\n-\n-  emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));\n-\n-  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n-    {\n-      rtx set = XVECEXP (operands[2], 0, i);\n-      emit_move_insn (SET_DEST (set), SET_SRC (set));\n-    }\n-\n-  /* The optimizer does not know that the call sets the function value\n-     registers we stored in the result block.  We avoid problems by\n-     claiming that all hard registers are used and clobbered at this\n-     point.  */\n-  emit_insn (gen_blockage ());\n-\n-  DONE;\n-}\")\n-\n-;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n-;; all of memory.  This blocks insns from being moved across this point.\n-\n-(define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_BLOCKAGE)]\n-  \"\"\n-  \"\")\n-\f\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\")\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"bri %0\")\n-\f\n-;;\n-;; A special insn that does the work to get setup just\n-;; before a table jump.\n-;;\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (label_ref (match_operand 2 \"\" \"\")))))]\n-  \"\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  return \\\"orh %H2,%?r0,%?r31\\;or %L2,%?r31,%?r31\\;ld.l %?r31(%1),%0\\\";\n-}\")\n-"}, {"sha": "588832547cfbb313150c26e1f9e0fc8763b76045", "filename": "gcc/config/i860/i860.opt", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fi860.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.opt?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,32 +0,0 @@\n-; Options for the Intel i860 port of the compiler.\n-\n-; Copyright (C) 2005 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 2, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING.  If not, write to the Free\n-; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-; 02110-1301, USA.\n-\n-mxp\n-Target Report RejectNegative Mask(XP)\n-Generate code which uses the FPU\n-\n-mnoxp\n-Target Report RejectNegative InverseMask(XP)\n-Do not generate code which uses the FPU\n-\n-mxr\n-Target Report RejectNegative InverseMask(XP)\n-Do not generate code which uses the FPU"}, {"sha": "78e62826e96ff140164f67579a8012b742f6a1f4", "filename": "gcc/config/i860/sysv4.h", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv4.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,155 +0,0 @@\n-/* Target definitions for GNU compiler for Intel 80860 running System V.4\n-   Copyright (C) 1991, 1996, 2000, 2002, 2003 Free Software Foundation, Inc.\n-   Contributed by Ron Guilmette (rfg@monkeys.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (i860 System V Release 4)\");\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"\"\n-\n-/* Provide a set of pre-definitions and pre-assertions appropriate for\n-   the i860 running svr4.  Note that the symbol `__svr4__' MUST BE\n-   DEFINED!  It is needed so that the va_list struct in va-i860.h\n-   will get correctly defined for the svr4 (ABI compliant) case rather\n-   than for the previous (svr3, svr2, ...) case.  It also needs to be\n-   defined so that the correct (svr4) version of __builtin_saveregs\n-   will be selected when we are building gnulib2.c.\n-   __svr4__ is our extension.  */\n-\n-#define TARGET_OS_CPP_BUILTINS()                \\\n-  do                                            \\\n-    {                                           \\\n-        builtin_define_std (\"unix\");            \\\n-        builtin_define (\"SVR4\");                \\\n-        builtin_define (\"__svr4__\");            \\\n-        builtin_assert (\"system=unix\");         \\\n-        builtin_assert (\"system=svr4\");         \\\n-    }                                           \\\n-  while (0)\n-\n-/* For the benefit of i860_va_arg, flag it this way too.  */\n-\n-#define I860_SVR4_VA_LIST 1\n-\n-/* The prefix to be used in assembler output for all names of registers.\n-   This string gets prepended to all i860 register names (svr4 only).  */\n-\n-#define I860_REG_PREFIX\t\"%\"\n-\n-#define ASM_COMMENT_START \"#\"\n-\n-#undef TYPE_OPERAND_FMT\n-#define TYPE_OPERAND_FMT      \"\\\"%s\\\"\"\n-\n-#define GLOBAL_ASM_OP \".globl \"\n-\n-/* The following macro definition overrides the one in i860.h\n-   because the svr4 i860 assembler requires a different syntax\n-   for getting parts of constant/relocatable values.  */\n-\n-#undef PRINT_OPERAND_PART\n-#define PRINT_OPERAND_PART(FILE, X, PART_CODE)\t\t\t\t\\\n-  do { fprintf (FILE, \"[\");\t\t\t\t\t\t\\\n-\toutput_address (X);\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"]@%s\", PART_CODE);\t\t\t\t\\\n-  } while (0)\n-\n-#undef TARGET_ASM_FILE_START_FILE_DIRECTIVE\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START i860_file_start\n-\n-/* Output the special word the svr4 SDB wants to see just before\n-   the first word of each function's prologue code.  */\n-\n-extern const char *current_function_original_name;\n-\n-/* This special macro is used to output a magic word just before the\n-   first word of each function.  On some versions of UNIX running on\n-   the i860, this word can be any word that looks like a NOP, however\n-   under svr4, this neds to be an `shr r0,r0,r0' instruction in which\n-   the normally unused low-order bits contain the length of the function\n-   prologue code (in bytes).  This is needed to make the svr4 SDB debugger\n-   happy.  */\n-\n-#undef ASM_OUTPUT_FUNCTION_PREFIX\n-#define ASM_OUTPUT_FUNCTION_PREFIX(FILE, FNNAME)\t\t\t\\\n-  do {\tASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n-  \tfprintf ((FILE), \"\\t.long\\t.ep.\");\t\t\t\t\\\n-\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n-\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n-\tfprintf (FILE, \"+0xc8000000\\n\");\t\t\t\t\\\n-\tcurrent_function_original_name = (FNNAME);\t\t\t\\\n-  } while (0)\n-\n-/* Output the special label that must go just after each function's\n-   prologue code to support svr4 SDB.  */\n-\n-#define ASM_OUTPUT_PROLOGUE_SUFFIX(FILE)\t\t\t\t\\\n-  do {\tfprintf (FILE, \".ep.\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, current_function_original_name);\t\t\\\n-\tfprintf (FILE, \":\\n\");\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n- \n-   Note that we want to give these sections the SHF_WRITE attribute\n-   because these sections will actually contain data (i.e. tables of\n-   addresses of functions in the current root executable or shared library\n-   file) and, in the case of a shared library, the relocatable addresses\n-   will have to be properly resolved/relocated (and then written into) by\n-   the dynamic linker when it actually attaches the given shared library\n-   to the executing process.  (Note that on SVR4, you may wish to use the\n-   `-z text' option to the ELF linker, when building a shared library, as\n-   an additional check that you are doing everything right.  But if you do\n-   use the `-z text' option when building a shared library, you will get\n-   errors unless the .ctors and .dtors sections are marked as writable\n-   via the SHF_WRITE attribute.)  */\n- \n-#undef CTORS_SECTION_ASM_OP\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"aw\\\"\"\n-#undef DTORS_SECTION_ASM_OP\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"aw\\\"\"\n-\n-/* Add definitions to support the .tdesc section as specified in the svr4\n-   ABI for the i860.  */\n-\n-#define TDESC_SECTION_ASM_OP    \"\\t.section\\t.tdesc\"\n-\n-#undef EXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_tdesc\n-\n-#undef EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n-  TDESC_SECTION_FUNCTION\n-\n-#define TDESC_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-tdesc_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_tdesc)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", TDESC_SECTION_ASM_OP);\t\t\\\n-      in_section = in_tdesc;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-"}, {"sha": "e3ec2091883c338e55934ffe9543188c5ee2e13b", "filename": "gcc/config/i860/t-i860", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Ft-i860", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Ft-i860", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Ft-i860?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,5 +0,0 @@\n-LIB2FUNCS_EXTRA = varargs.asm\n-\n-varargs.asm: $(srcdir)/config/i860/varargs.asm\n-\tcp $(srcdir)/config/i860/varargs.asm .\n-"}, {"sha": "27ca7f3303243747b2bdbfbded1cac11eec45889", "filename": "gcc/config/i860/varargs.asm", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fvarargs.asm?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,212 +0,0 @@\n-/* Special varargs support for i860.\n-   Copyright (C) 2001, 2003  Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#if defined(__svr4__) || defined(__alliant__)\n-\t.text\n-\t.align\t4\n-\n-/* The Alliant needs the added underscore.  */\n-\t.globl\t__builtin_saveregs\n-__builtin_saveregs:\n-\t.globl\t___builtin_saveregs\n-___builtin_saveregs:\n-\n-\tandnot\t0x0f,%sp,%sp\t/* round down to 16-byte boundary */\n-#if 0\n-\tadds\t-96,%sp,%sp  /* allocate stack space for reg save\n-\t\t\t   area and also for a new va_list\n-\t\t\t   structure */\n-#else\n-\tadds\t-80,%sp,%sp  /* allocate stack space for reg save area */\n-#endif\n-\t/* Save all argument registers in the arg reg save area.  The\n-\t   arg reg save area must have the following layout (according\n-\t   to the svr4 ABI):\n-\n-\tstruct {\n-\t  union  {\n-\t    float freg[8];\n-\t    double dreg[4];\n-\t  } float_regs;\n-\t  long\tireg[12];\n-\t};\n-\t*/\n-\n-\tfst.q\t%f8,  0(%sp) /* save floating regs (f8-f15)  */\n-\tfst.q\t%f12,16(%sp) \n-\n-\tst.l\t%r16,32(%sp) /* save integer regs (r16-r27) */\n-\tst.l\t%r17,36(%sp) \n-\tst.l\t%r18,40(%sp)\n-\tst.l\t%r19,44(%sp)\n-\tst.l\t%r20,48(%sp)\n-\tst.l\t%r21,52(%sp)\n-\tst.l\t%r22,56(%sp)\n-\tst.l\t%r23,60(%sp)\n-\tst.l\t%r24,64(%sp)\n-\tst.l\t%r25,68(%sp)\n-\tst.l\t%r26,72(%sp)\n-\tst.l\t%r27,76(%sp)\n-\n-#if 0\n-\tadds\t80,%sp,%r16  /* compute the address of the new\n-\t\t\t   va_list structure.  Put in into\n-\t\t\t   r16 so that it will be returned\n-\t\t\t   to the caller.  */\n-#endif\n-\n-\t/* Initialize all fields of the new va_list structure.  This\n-\t   structure looks like:\n-\n-\ttypedef struct {\n-\t    unsigned long\tireg_used;\n-\t    unsigned long\tfreg_used;\n-\t    long\t*reg_base;\n-\t    long\t*mem_ptr;\n-\t} va_list;\n-\t*/\n-\n-#if 0\n-\tst.l\t%r0, 0(%r16) /* nfixed */\n-\tst.l\t%r0, 4(%r16) /* nfloating */\n-\tst.l    %sp, 8(%r16) /* __va_ctl points to __va_struct.  */\n-\tbri\t%r1\t/* delayed return */\n-\tst.l\t%r28,12(%r16) /* pointer to overflow args */\n-#else\n-\tbri\t%r1\t/* delayed return */\n-\tor\t%sp,%r0,%r16  /* Return the address of the reg save area.  */\n-#endif\n-\n-#else /* not __svr4__ */\n-#if defined(__PARAGON__)\n-\t/*\n-\t *\twe'll use SVR4-ish varargs but need SVR3.2 assembler syntax,\n-\t *\tand we stand a better chance of hooking into libraries\n-\t *\tcompiled by PGI.  [andyp@ssd.intel.com]\n-\t */\n-\t.text\n-\t.align\t4\n-\t.globl\t__builtin_saveregs\n-__builtin_saveregs:\n-\t.globl\t___builtin_saveregs\n-___builtin_saveregs:\n-\n-\tandnot\t0x0f,sp,sp\t/* round down to 16-byte boundary */\n-\tadds\t-96,sp,sp\t/* allocate stack space for reg save\n-\t\t\t   area and also for a new va_list\n-\t\t\t   structure */\n-\t/* Save all argument registers in the arg reg save area.  The\n-\t   arg reg save area must have the following layout (according\n-\t   to the svr4 ABI):\n-\n-\tstruct {\n-\t  union  {\n-\t    float freg[8];\n-\t    double dreg[4];\n-\t  } float_regs;\n-\t  long\tireg[12];\n-\t};\n-\t*/\n-\n-\tfst.q\tf8,  0(sp)\n-\tfst.q\tf12,16(sp) \n-\tst.l\tr16,32(sp)\n-\tst.l\tr17,36(sp) \n-\tst.l\tr18,40(sp)\n-\tst.l\tr19,44(sp)\n-\tst.l\tr20,48(sp)\n-\tst.l\tr21,52(sp)\n-\tst.l\tr22,56(sp)\n-\tst.l\tr23,60(sp)\n-\tst.l\tr24,64(sp)\n-\tst.l\tr25,68(sp)\n-\tst.l\tr26,72(sp)\n-\tst.l\tr27,76(sp)\n-\n-\tadds\t80,sp,r16  /* compute the address of the new\n-\t\t\t   va_list structure.  Put in into\n-\t\t\t   r16 so that it will be returned\n-\t\t\t   to the caller.  */\n-\n-\t/* Initialize all fields of the new va_list structure.  This\n-\t   structure looks like:\n-\n-\ttypedef struct {\n-\t    unsigned long\tireg_used;\n-\t    unsigned long\tfreg_used;\n-\t    long\t*reg_base;\n-\t    long\t*mem_ptr;\n-\t} va_list;\n-\t*/\n-\n-\tst.l\tr0, 0(r16) /* nfixed */\n-\tst.l\tr0, 4(r16) /* nfloating */\n-\tst.l    sp, 8(r16) /* __va_ctl points to __va_struct.  */\n-\tbri\tr1\t/* delayed return */\n-\tst.l\tr28,12(r16) /* pointer to overflow args */\n-#else /* not __PARAGON__ */\n-\t.text\n-\t.align\t4\n-\n-\t.globl\t___builtin_saveregs\n-___builtin_saveregs:\n-\tmov\tsp,r30\n-\tandnot\t0x0f,sp,sp\n-\tadds\t-96,sp,sp  /* allocate sufficient space on the stack */\n-\n-/* Fill in the __va_struct.  */\n-\tst.l\tr16, 0(sp) /* save integer regs (r16-r27) */\n-\tst.l\tr17, 4(sp) /* int\tfixed[12] */\n-\tst.l\tr18, 8(sp)\n-\tst.l\tr19,12(sp)\n-\tst.l\tr20,16(sp)\n-\tst.l\tr21,20(sp)\n-\tst.l\tr22,24(sp)\n-\tst.l\tr23,28(sp)\n-\tst.l\tr24,32(sp)\n-\tst.l\tr25,36(sp)\n-\tst.l\tr26,40(sp)\n-\tst.l\tr27,44(sp)\n-\n-\tfst.q\tf8, 48(sp) /* save floating regs (f8-f15) */\n-\tfst.q\tf12,64(sp) /* int floating[8] */\n-\n-/* Fill in the __va_ctl.  */\n-\tst.l    sp, 80(sp) /* __va_ctl points to __va_struct.  */\n-\tst.l\tr28,84(sp) /* pointer to more args */\n-\tst.l\tr0, 88(sp) /* nfixed */\n-\tst.l\tr0, 92(sp) /* nfloating */\n-\n-\tadds\t80,sp,r16  /* return address of the __va_ctl.  */\n-\tbri\tr1\n-\tmov\tr30,sp\n-\t\t/* recover stack and pass address to start \n-\t\t   of data.  */\n-#endif /* not __PARAGON__ */\n-#endif /* not __svr4__ */"}, {"sha": "c01fb887dcafc7b2ad239fd0a6895037f2521e2e", "filename": "gcc/config/i860/x-sysv4", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fx-sysv4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fi860%2Fx-sysv4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fx-sysv4?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,44 +0,0 @@\n-# The svr4 reference port for the i860 contains an alloca.o routine\n-# in /usr/ucblib/libucb.a, but we can't just try to get that by\n-# setting CLIB to /usr/ucblib/libucb.a because (unfortunately)\n-# there are a lot of other routines in libucb.a which are supposed\n-# to be the Berkeley versions of library routines normally found in\n-# libc.a and many of these Berkeley versions are badly broken.  Thus,\n-# if we try to link programs with libucb.a before libc.a, those\n-# programs tend to crash.\n-\n-# Also, the alloca() routine supplied in early version of svr4 for\n-# the i860 is non-ABI compliant.  It doesn't keep the stack aligned\n-# to a 16-byte boundary as the ABI requires.\n-\n-# More importantly however, even a fully ABI compliant alloca() routine\n-# would fail to work correctly with some versions of the native svr4 C\n-# compiler currently being distributed for the i860 (as of 1/29/92).\n-# The problem is that the native C compiler generates non-ABI-compliant\n-# function epilogues which cut back the stack (upon function exit) in\n-# an incorrect manner.  Specifically, they cut back the stack by adding\n-# the nominal *static* frame size (determined statically at compile-time)\n-# to the stack pointer rather than setting the stack pointer based upon\n-# the current value of the frame pointer (as called for in the i860 ABI).\n-# This can cause serious trouble in cases where you repeatedly call a\n-# routine which itself calls alloca().  In such cases, the stack will\n-# grow continuously until you finally run out of swap space or exceed\n-# the system's process size limit.  To avoid this problem (which can\n-# arise when a stage1 gcc is being used to build a stage2 gcc) you\n-# *must* link in the C language version of alloca() which is supplied\n-# with gcc to your stage1 version of gcc.  The following definition\n-# forces that to happen.\n-\n-ALLOCA=alloca.o\n-\n-# We build all stages *without* shared libraries because that may make\n-# debugging the compiler easier (until there is a GDB which supports\n-# both Dwarf *and* svr4 shared libraries).\n-\n-# Note that the native C compiler for the svr4 reference port on the\n-# i860 recognizes a special -gg option.  Using that option causes *full*\n-# Dwarf debugging information to be generated, whereas using only -g\n-# causes only limited Dwarf debugging information to be generated.\n-# (This is an undocumented feature of the native svr4 C compiler.)\n-\n-CCLIBFLAGS=-Bstatic -dn -gg"}, {"sha": "23390efb6a40050a8ba6c0f7bbe81c853014b361", "filename": "gcc/config/ip2k/crt0.S", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fcrt0.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fcrt0.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fcrt0.S?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,53 +0,0 @@\n-;\n-;   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n-;   Contributed by Red Hat, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify\n-; it under the terms of the GNU General Public License as published by\n-; the Free Software Foundation; either version 2, or (at your option)\n-; any later version.\n-;\n-; In addition to the permissions in the GNU General Public License, the\n-; Free Software Foundation gives you unlimited permission to link the\n-; compiled version of this file with other programs, and to distribute\n-; those programs without any restriction coming from the use of this\n-; file.  (The General Public License restrictions do apply in other\n-; respects; for example, they cover modification of the file, and\n-; distribution when not linked into another program.)\n-;\n-; GCC is distributed in the hope that it will be useful,\n-; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-; GNU General Public License for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING.  If not, write to\n-; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-; Boston, MA 02110-1301, USA.\n-;\n-\t\n-\t.file\t\"crt0.S\"\n-\t.text\n-\t.global\t__start\n-\t.func\t__start\n-__start:\n-\tclr\t$ff\t\t; Insure we have a zero available\n-\tmov\tw,#%hi8data(__stack) ; set up stack\n-\tmov\tsph,w\t\t;  \n-\tmov\tw,#%lo8data(__stack)\n-\tmov\tspl,w\n-\n-\tpush\t#0\t\t; Set argc/argv.\n-\tpush\t#0\t\t; Only required for testing\n-\tpush\t#0\t\t;  purposes and \"ansi\" main.\n-\tpush\t#0\n-\tpage\t_main\n-\tcall\t_main\n-\tpush\t$81\t\t; use return value to call exit()\n-\tpush\t$80\n-\tpage\t_exit\n-\tcall\t_exit\n-\tbreak\t\t\t; Should never return\n-\t.endfunc"}, {"sha": "b26ced8344c9dec9f45c3c243ee107c28662a9c5", "filename": "gcc/config/ip2k/ip2k-protos.h", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k-protos.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,83 +0,0 @@\n-/* Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n-   Contributed by Red Hat, Inc and Ubicom, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-   Boston, MA 02110-1301, USA.  */\n-\n-extern void function_prologue (FILE *, HOST_WIDE_INT);\n-extern void function_epilogue (FILE *, HOST_WIDE_INT);\n-extern int find_one_set_bit_p (HOST_WIDE_INT);\n-extern int find_one_clear_bit_p (HOST_WIDE_INT);\n-\n-#ifdef TREE_CODE\n-extern void unique_section (tree, int);\n-extern int valid_machine_type_attribute (tree, tree, tree, tree);\n-extern int valid_machine_decl_attribute (tree, tree, tree, tree);\n-extern int ip2k_return_pops_args (tree, tree, int);\n-#endif /* TREE_CODE */\n-\n-#ifdef RTX_CODE\n-extern int legitimate_address_p (enum machine_mode, rtx, int);\n-extern int ip2k_extra_constraint (rtx, int);\n-extern rtx legitimize_address (rtx, rtx, enum machine_mode, rtx);\n-extern int adjust_insn_length (rtx insn, int len);\n-extern void asm_output_char (FILE *, rtx);\n-extern void asm_output_short (FILE *, rtx);\n-extern void asm_output_byte (FILE *, int);\n-extern void print_operand (FILE *, rtx, int);\n-extern void print_operand_address (FILE *, rtx);\n-extern int ip2k_jump_mode (rtx, rtx);\n-extern void ip2k_split_words (enum machine_mode, enum machine_mode, rtx *);\n-extern rtx ip2k_get_low_half (rtx, enum machine_mode);\n-extern rtx ip2k_get_high_half (rtx, enum machine_mode);\n-extern int ip2k_nonptr_operand (rtx, enum machine_mode);\n-extern int ip2k_ptr_operand (rtx, enum machine_mode);\n-extern int ip2k_ip_operand (rtx, enum machine_mode);\n-extern int ip2k_short_operand (rtx, enum machine_mode);\n-extern int ip2k_gen_operand (rtx, enum machine_mode);\n-extern int ip2k_nonsp_reg_operand (rtx, enum machine_mode);\n-extern int ip2k_symbol_ref_operand (rtx, enum machine_mode);\n-extern const char *ip2k_set_compare (rtx, rtx);\n-extern const char *ip2k_gen_sCOND (rtx, enum rtx_code, rtx);\n-extern const char *ip2k_gen_signed_comp_branch (rtx, enum rtx_code, rtx);\n-extern const char *ip2k_gen_unsigned_comp_branch (rtx, enum rtx_code, rtx);\n-extern int is_regfile_address (rtx);\n-extern int ip2k_mode_dependent_address (rtx);\n-extern int ip2k_address_uses_reg_p (rtx, unsigned int);\n-extern int ip2k_xexp_not_uses_reg_p (rtx, unsigned int, int);\n-extern int ip2k_composite_xexp_not_uses_reg_p (rtx, unsigned int, int);\n-extern int ip2k_composite_xexp_not_uses_cc0_p (rtx);\n-extern int ip2k_signed_comparison_operator (rtx, enum machine_mode);\n-extern int ip2k_unsigned_comparison_operator (rtx, enum machine_mode);\n-extern int ip2k_unary_operator (rtx, enum machine_mode);\n-extern int ip2k_binary_operator (rtx, enum machine_mode);\n-\n-extern rtx ip2k_compare_operands[3];\n-#endif /* RTX_CODE */\n-\n-#ifdef HAVE_MACHINE_MODES\n-extern int class_max_nregs (enum reg_class, enum machine_mode);\n-extern enum reg_class class_likely_spilled_p (int c);\n-#endif /* HAVE_MACHINE_MODES */\n-\n-#ifdef REAL_VALUE_TYPE\n-extern void asm_output_float (FILE *, REAL_VALUE_TYPE);\n-#endif \n-\n-extern int ip2k_init_elim_offset (int, int);\n-extern void ip2k_init_local_alloc (int *);\n-"}, {"sha": "e38ee5c47218daf2900a748be97f8d115a7fb48e", "filename": "gcc/config/ip2k/ip2k.c", "status": "removed", "additions": 0, "deletions": 6217, "changes": 6217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.c?ref=96a2347e1d837369cf266b937faf59511f0307ce"}, {"sha": "0b88e3a4e6b242c98a7ff539a8c81305026c8239", "filename": "gcc/config/ip2k/ip2k.h", "status": "removed", "additions": 0, "deletions": 851, "changes": 851, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,851 +0,0 @@\n-/* Definitions of target machine for GCC,\n-   For Ubicom IP2022 Communications Controller\n-\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n-   Contributed by Red Hat, Inc and Ubicom, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-\f\n-#undef ASM_SPEC\t/* We have a GAS assembler.  */\n-\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"IP2K\");\t\t\\\n-      builtin_define (\"_DOUBLE_IS_32BITS\");\t\\\n-      builtin_define (\"_BUFSIZ=512\");\t\t\\\n-      builtin_define (\"__FILENAME_MAX__=128\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define TARGET_VERSION fprintf (stderr, \" (ip2k, GNU assembler syntax)\")\n-\n-/* Caller-saves is not a win for the IP2K.  Pretty much anywhere that\n-   a register is permitted allows SP-relative addresses too.\n-\n-   This machine doesn't have PIC addressing modes, so disable that also.  */\n-\n-#define OVERRIDE_OPTIONS\t\\\n-    do {\t\t\t\\\n-\tflag_caller_saves = 0;\t\\\n-\tflag_pic = 0;\t\t\\\n-    } while (0)\n-\n-/* Put each function in its own section so that PAGE-instruction\n-   relaxation can do its best.  */\n-#define OPTIMIZATION_OPTIONS(LEVEL, SIZEFLAG)\t\\\n-    do {\t\t\t\t\t\\\n-\tif ((LEVEL) || (SIZEFLAG))\t\t\\\n-\t    flag_function_sections = 1;\t\\\n-    } while (0)\n-\n-#define BITS_BIG_ENDIAN 0\n-#define BYTES_BIG_ENDIAN 1\n-#define WORDS_BIG_ENDIAN 1\n-#define BITS_PER_WORD 8\n-#define UNITS_PER_WORD (BITS_PER_WORD / BITS_PER_UNIT)\n-\n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 16\n-\n-/* Maximum sized of reasonable data type DImode or Dfmode ...  */\n-#define MAX_FIXED_MODE_SIZE 64\n-\n-#define PARM_BOUNDARY 8\n-#define FUNCTION_BOUNDARY 16\n-#define EMPTY_FIELD_BOUNDARY 8\n-#define BIGGEST_ALIGNMENT 8\n-\n-#define STRICT_ALIGNMENT 0\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-#undef INT_TYPE_SIZE\n-#define INT_TYPE_SIZE 16\n-\n-#undef SHORT_TYPE_SIZE\n-#define SHORT_TYPE_SIZE 16\n-\n-#undef LONG_TYPE_SIZE\n-#define LONG_TYPE_SIZE 32\n-\n-#undef LONG_LONG_TYPE_SIZE\n-#define LONG_LONG_TYPE_SIZE\t64\n-\n-#undef CHAR_TYPE_SIZE\n-#define  CHAR_TYPE_SIZE 8\n-\n-#undef FLOAT_TYPE_SIZE\n-#define FLOAT_TYPE_SIZE 32\n-\n-#undef DOUBLE_TYPE_SIZE\n-#define DOUBLE_TYPE_SIZE 32\n-\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE\t32\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE\t16\n-\n-#define HARD_REG_SIZE           (UNITS_PER_WORD)\n-/* Standard register usage.\n-\n-   for the IP2K, we are going to have a LOT of registers, but only some of them\n-   are named.  */\n- \n-#define FIRST_PSEUDO_REGISTER (0x104) /* Skip over physical regs, VFP, AP.  */\n-\n-#define REG_IP\t\t0x4\n-#define REG_IPH\t\tREG_IP\n-#define REG_IPL\t\t0x5\n-\n-#define REG_SP\t\t0x6\n-#define REG_SPH\t\tREG_SP\n-#define REG_SPL\t\t0x7\n-\n-#define REG_PCH\t\t0x8\n-#define REG_PCL\t\t0x9\n-\n-#define REG_W\t\t0xa\n-#define REG_STATUS\t0xb\n-\n-#define REG_DP\t\t0xc\n-#define REG_DPH\t\tREG_DP\n-#define REG_DPL\t\t0xd\n-\n-#define REG_MULH\t0xf\n-\n-#define REG_CALLH\t0x7e\t\t/* Call-stack readout.  */\n-#define REG_CALLL\t0x7f\n-\n-\n-#define REG_RESULT\t0x80\t/* Result register (upto 8 bytes).  */\n-#define REG_FP\t\t0xfd\t/* 2 bytes for FRAME chain  */\n-\n-#define REG_ZERO\t0xff\t/* Initialized to zero by runtime.  */\n-\n-#define REG_VFP\t\t0x100\t/* Virtual frame pointer.  */\n-#define REG_AP\t\t0x102\t/* Virtual arg pointer.  */\n-\n-/* Status register bits.  */\n-#define Z_FLAG\t0x2\t \n-#define DC_FLAG\t0x1\n-#define C_FLAG\t0x0\n-\n-#define FIXED_REGISTERS {\\\n-1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*  r0.. r31*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/* r32.. r63*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/* r64.. r95*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/* r96..r127*/\\\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,/*r128..r159*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r160..r191*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r192..r223*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r224..r255*/\\\n-1,1,1,1}\n-\n-#define CALL_USED_REGISTERS {\t\t\t\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*  r0.. r31*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/* r32.. r63*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/* r64.. r95*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/* r96..r127*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r128..r159*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r160..r191*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r192..r223*/\\\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r224..r255*/\\\n-1,1,1,1}\n-\n-#define REG_ALLOC_ORDER {\t\t\t\\\n-    0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\t\\\n-    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,\t\\\n-    0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\t\\\n-    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,\t\\\n-    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,\t\\\n-    0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,\t\\\n-    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,\t\\\n-    0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,\t\\\n-    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,\t\\\n-    0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,\t\\\n-    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,\t\\\n-    0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,\t\\\n-    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,\t\\\n-    0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,\t\\\n-    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,\t\\\n-    0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,\t\\\n-    0x00,0x01,0x02,0x03,0x0c,0x0d,0x06,0x07,\t\\\n-    0x08,0x09,0x0a,0x0b,0x04,0x05,0x0e,0x0f,\t\\\n-    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,\t\\\n-    0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\t\\\n-    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,\t\\\n-    0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,\t\\\n-    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,\t\\\n-    0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,\t\\\n-    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,\t\\\n-    0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,\t\\\n-    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,\t\\\n-    0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,\t\\\n-    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,\t\\\n-    0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,\t\\\n-    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,\t\\\n-    0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\t\\\n-    0x100,0x101,0x102,0x103}\n-\n-\n-#define ORDER_REGS_FOR_LOCAL_ALLOC ip2k_init_local_alloc (reg_alloc_order)\n-\n-/* Are we allowed to rename registers?  For some reason, regrename was\n-   changing DP to IP (when it appeared in addresses like (plus:HI\n-   (reg: DP) (const_int 37)) - and that's bad because IP doesn't\n-   permit offsets!  */\n-\n-#define HARD_REGNO_RENAME_OK(REG, NREG)\t\t\t\t\\\n-  (((REG) == REG_DPH) ? 0\t\t\t\t\t\\\n-    : ((REG) == REG_IPH) ? ((NREG) == REG_DPH)\t\t\t\\\n-    : (((NREG) == REG_IPL) || ((NREG) == REG_DPL)) ? 0 : 1)\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n-   (((MODE1) == QImode && (MODE2) == HImode)\t\\\n-    || ((MODE2) == QImode && (MODE1) == HImode))\n-/* We originally had this as follows - this isn't a win on the IP2k\n-   though as registers just get in our way!\n-   \n-   #define MODES_TIEABLE_P(MODE1, MODE2) \\\n-    (((MODE1) > HImode && (MODE2) == HImode)\n-     || ((MODE1) == HImode && (MODE2) > HImode))  */\n-\n-enum reg_class {\n-  NO_REGS,\n-  DPH_REGS,\n-  DPL_REGS,\n-  DP_REGS,\n-  SP_REGS,\n-  IPH_REGS,\n-  IPL_REGS,\n-  IP_REGS,\n-  DP_SP_REGS,\n-  PTR_REGS,\n-  NONPTR_REGS,\n-  NONSP_REGS,\n-  GENERAL_REGS,\n-  ALL_REGS = GENERAL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define N_REG_CLASSES (int)LIM_REG_CLASSES\n-\n-#define REG_CLASS_NAMES {\t\t\t\\\n-\t\t\"NO_REGS\",\t\t\t\\\n-\t\t\"DPH_REGS\",\t\t\t\\\n-\t\t\"DPL_REGS\",\t\t\t\\\n-\t\t\"DP_REGS\",\t\t\t\\\n-\t\t\"SP_REGS\",\t\t\t\\\n-\t\t\"IPH_REGS\",\t\t\t\\\n-\t\t\"IPL_REGS\",\t\t\t\\\n-\t\t\"IP_REGS\",\t\t\t\\\n-\t\t\"DP_SP_REGS\",\t\t\t\\\n-\t\t\"PTR_REGS\",\t\t\t\\\n-\t        \"NONPTR_REGS\",\t\t\t\\\n-\t\t\"NONSP_REGS\",\t\t\t\\\n-\t\t\"GENERAL_REGS\"\t\t\t\\\n-\t\t}\n-\n-\n-#define REG_CLASS_CONTENTS {\t\t\t \t\\\n-{0x00000000, 0, 0, 0, 0, 0, 0, 0, 0}, /* NO_REGS */\t\\\n-{0x00001000, 0, 0, 0, 0, 0, 0, 0, 0}, /* DPH_REGS */\t\\\n-{0x00002000, 0, 0, 0, 0, 0, 0, 0, 0}, /* DPL_REGS */\t\\\n-{0x00003000, 0, 0, 0, 0, 0, 0, 0, 0}, /* DP_REGS */\t\\\n-{0x000000c0, 0, 0, 0, 0, 0, 0, 0, 0}, /* SP_REGS */\t\\\n-{0x00000010, 0, 0, 0, 0, 0, 0, 0, 0}, /* IPH_REGS */\t\\\n-{0x00000020, 0, 0, 0, 0, 0, 0, 0, 0}, /* IPL_REGS */\t\\\n-{0x00000030, 0, 0, 0, 0, 0, 0, 0, 0}, /* IP_REGS */\t\\\n-{0x000030c0, 0, 0, 0, 0, 0, 0, 0, 0}, /* DP_SP_REGS */\t\\\n-{0x000030f0, 0, 0, 0, 0, 0, 0, 0, 0}, /* PTR_REGS */\t\\\n-{0xffffcf0f,-1,-1,-1,-1,-1,-1,-1, 0}, /* NONPTR_REGS */\t\\\n-{0xffffff3f,-1,-1,-1,-1,-1,-1,-1, 0}, /* NONSP_REGS */\t\\\n-{0xffffffff,-1,-1,-1,-1,-1,-1,-1,15}  /* GENERAL_REGS */ \\\n-}\n-\n-#define REGNO_REG_CLASS(R)\t\\\n-  ( (R) == REG_IPH ? IPH_REGS\t\\\n-  : (R) == REG_IPL ? IPL_REGS\t\\\n-  : (R) == REG_DPH ? DPH_REGS\t\\\n-  : (R) == REG_DPL ? DPL_REGS\t\\\n-  : (R) == REG_SPH ? SP_REGS\t\\\n-  : (R) == REG_SPL ? SP_REGS\t\\\n-  : NONPTR_REGS)\n-\n-#define MODE_BASE_REG_CLASS(MODE) ((MODE) == QImode ? PTR_REGS : DP_SP_REGS)\n-\n-#define BASE_REG_CLASS PTR_REGS\n-\n-#define INDEX_REG_CLASS NO_REGS\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\\\n-  ( (C) == 'j' ? IPH_REGS\t\t\\\n-  : (C) == 'k' ? IPL_REGS\t\t\\\n-  : (C) == 'f' ? IP_REGS\t\t\\\n-  : (C) == 'y' ? DPH_REGS\t\t\\\n-  : (C) == 'z' ? DPL_REGS\t\t\\\n-  : (C) == 'b' ? DP_REGS\t\t\\\n-  : (C) == 'u' ? NONSP_REGS\t\t\\\n-  : (C) == 'q' ? SP_REGS\t\t\\\n-  : (C) == 'c' ? DP_SP_REGS\t\t\\\n-  : (C) == 'a' ? PTR_REGS\t\t\\\n-  : (C) == 'd' ? NONPTR_REGS \t\t\\\n-  : NO_REGS)\n-\n-#define REGNO_OK_FOR_BASE_P(R) \\\n-  ((R) == REG_DP || (R) == REG_IP || (R) == REG_SP)\n-\n-#define REGNO_MODE_OK_FOR_BASE_P(R,M) \t\t\\\n-  ((R) == REG_DP || (R) == REG_SP\t\t\\\n-   || ((R) == REG_IP && GET_MODE_SIZE (M) <= 1))\n-\n-#define REGNO_OK_FOR_INDEX_P(NUM) 0\n-\n-#define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n-\n-#define SMALL_REGISTER_CLASSES 1\n-\n-#define CLASS_LIKELY_SPILLED_P(CLASS)  class_likely_spilled_p(CLASS)\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)   GET_MODE_SIZE (MODE)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'I' ? (VALUE) >= -255 && (VALUE) <= -1 :\t\t\\\n-   (C) == 'J' ? (VALUE) >= 0 && (VALUE) <= 7 :\t\t\t\\\n-   (C) == 'K' ? (VALUE) >= 0 && (VALUE) <= 127 :\t\t\\\n-   (C) == 'L' ? (VALUE) > 0 && (VALUE) < 128:\t\t\t\\\n-   (C) == 'M' ? (VALUE) == -1:\t\t\t\t\t\\\n-   (C) == 'N' ? (VALUE) == 1:\t\t\t\t\t\\\n-   (C) == 'O' ? (VALUE) == 0:\t\t\t\t\t\\\n-   (C) == 'P' ? (VALUE) >= 0 && (VALUE) <= 255:\t\t\t\\\n-   0)\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n-\n-#define EXTRA_CONSTRAINT(X, C) ip2k_extra_constraint (X, C)\n-\n-/* This is an undocumented variable which describes\n-   how GCC will pop a data.  */\n-#define STACK_POP_CODE PRE_INC\n-\n-#define STACK_PUSH_CODE POST_DEC\n-\n-#define STACK_CHECK_BUILTIN\t1\n-/* Prologue code will do stack checking as necessary.  */\n-  \n-#define STARTING_FRAME_OFFSET (0)\t\n-\n-#define FRAME_GROWS_DOWNWARD\t1\n-#define STACK_GROWS_DOWNWARD\t1\n-\n-/* On IP2K arg pointer is virtual and resolves to either SP or FP\n-   after we've resolved what registers are saved (fp chain, return\n-   pc, etc.  */\n-\n-#define FIRST_PARM_OFFSET(FUNDECL) 0\n-\n-#define STACK_POINTER_OFFSET 1\n-/* IP2K stack is post-decremented, so 0(sp) is address of open space\n-   and 1(sp) is offset to the location avobe the forst location at which\n-   outgoing arguments are placed.  */\n-\n-#define STACK_BOUNDARY 8\n-\n-#define STACK_POINTER_REGNUM REG_SP\n-\n-#define FRAME_POINTER_REGNUM REG_VFP\n-#define HARD_FRAME_POINTER_REGNUM REG_FP\n-\n-#define ARG_POINTER_REGNUM  REG_AP\n-\n-/* We don't really want to support nested functions.  But we'll crash\n-   in various testsuite tests if we don't at least define the register\n-   to contain the static chain. The return value register is about as\n-   bad a place as any for this.  */\n-\n-#define STATIC_CHAIN_REGNUM\tREG_RESULT\n-\n-#define FRAME_POINTER_REQUIRED (!flag_omit_frame_pointer)\n-\n-#define ELIMINABLE_REGS\t{ \t\t\t\t\t\\\n-        {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n-\t{ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n-\t{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n-\t{FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n-\t{HARD_FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n-}\n-\n-#define CAN_ELIMINATE(FROM, TO) \t\t\t\t\\\n-  ((FROM) == HARD_FRAME_POINTER_REGNUM\t\t\t\t\\\n-   ? (flag_omit_frame_pointer && !frame_pointer_needed) : 1)\n-/* Don't eliminate FP unless we EXPLICITLY_ASKED  */\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-  ((OFFSET) = ip2k_init_elim_offset ((FROM), (TO)))\n-\n-#define RETURN_ADDR_RTX(COUNT, X) \\\n-  (((COUNT) == 0) ? gen_rtx_REG (HImode, REG_CALLH) : NULL_RTX)\n-\n-#define PUSH_ROUNDING(NPUSHED) (NPUSHED)\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n-  ip2k_return_pops_args ((FUNDECL), (FUNTYPE), (SIZE))\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n-\n-#define CUMULATIVE_ARGS\tint\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  ((CUM) = 0)\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\n-\n-/* All arguments are passed on stack - do nothing here.  */\n-\n-#define FUNCTION_ARG_REGNO_P(R) 0\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \t\t\t\t\\\n-   ((TYPE_MODE (VALTYPE) == QImode)\t\t\t\t\\\n-    ? gen_rtx_REG (TYPE_MODE (VALTYPE), REG_RESULT + 1)\t\\\n-    : gen_rtx_REG (TYPE_MODE (VALTYPE), REG_RESULT))\n-\n-/* Because functions returning 'char' actually widen to 'int', we have to\n-   use $81 as the return location if we think we only have a 'char'.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG ((MODE), REG_RESULT)\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_RESULT)\n-\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-#define EPILOGUE_USES(REGNO) 0\n-\n-\n-/*  Hmmm.  We don't actually like constants as addresses - they always need\n-    to be loaded to a register, except for function calls which take an\n-    address by immediate value.  But changing this to zero had negative\n-    effects, causing the compiler to get very confused....  */\n-\n-#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n-\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-#ifdef REG_OK_STRICT\n-#  define GO_IF_LEGITIMATE_ADDRESS(MODE, OPERAND, ADDR)\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p ((MODE), (OPERAND), 1))\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-#else\n-#  define GO_IF_LEGITIMATE_ADDRESS(MODE, OPERAND, ADDR)\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (legitimate_address_p ((MODE), (OPERAND), 0))\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-#endif\n-\n-#define REG_OK_FOR_BASE_STRICT_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#define REG_OK_FOR_BASE_NOSTRICT_P(X) \t\\\n-  (REGNO (X) >= FIRST_PSEUDO_REGISTER \t\\\n-   || (REGNO (X) == REG_FP)\t\t\\\n-   || (REGNO (X) == REG_VFP)\t\t\\\n-   || (REGNO (X) == REG_AP)\t\t\\\n-   || REG_OK_FOR_BASE_STRICT_P(X))\n-\n-#ifdef REG_OK_STRICT\n-#  define REG_OK_FOR_BASE_P(X) REG_OK_FOR_BASE_STRICT_P (X)\n-#else\n-#  define REG_OK_FOR_BASE_P(X) REG_OK_FOR_BASE_NOSTRICT_P (X)\n-#endif\n-\n-#define REG_OK_FOR_INDEX_P(X) 0\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\\\n-do { rtx orig_x = (X);\t\t\t\t\t\\\n-  (X) = legitimize_address ((X), (OLDX), (MODE), 0);\t\\\n-  if ((X) != orig_x && memory_address_p ((MODE), (X)))\t\\\n-    goto WIN;\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Is X a legitimate register to reload, or is it a pseudo stack-temp\n-   that is problematic for push_reload() ?  */\n-\n-#define LRA_REG(X)\t\t\t\t\t\t\\\n-  (! (reg_equiv_memory_loc[REGNO (X)]\t\t\t\t\\\n-      && (reg_equiv_address[REGNO (X)]\t\t\t\t\\\n-\t  || num_not_at_initial_offset)))\n-\n-/* Given a register X that failed the LRA_REG test, replace X\n-   by its memory equivalent, find the reloads needed for THAT memory\n-   location and substitute that back for the higher-level reload\n-   that we're conducting...  */\n-\n-/* WARNING: we reference 'ind_levels' and 'insn' which are local variables\n-   in find_reloads_address (), where the LEGITIMIZE_RELOAD_ADDRESS macro\n-   expands.  */\n-\n-#define FRA_REG(X,MODE,OPNUM,TYPE)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  rtx tem = make_memloc ((X), REGNO (X));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (! strict_memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Note that we're doing address in address - cf. ADDR_TYPE  */\t\\\n-      find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\t\\\n- \t\t\t    &XEXP (tem, 0), (OPNUM),\t\t\t\\\n-\t\t\t    ADDR_TYPE (TYPE), ind_levels, insn);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  (X) = tem;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-\n-/* For the IP2K, we want to be clever about picking IP vs DP for a\n-   base pointer since IP only directly supports a zero displacement.\n-   (Note that we have modified all the HI patterns to correctly handle\n-   IP references by manipulating iph:ipl as we fetch the pieces).  */\n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND,WIN)\t\t     \\\n-{\t\t\t\t\t\t\t\t\t     \\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t     \\\n-      && REG_P (XEXP (X, 0))\t\t\t\t\t\t     \\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t     \\\n-    {\t\t\t\t\t\t\t\t\t     \\\n-      int disp = INTVAL (XEXP (X, 1));\t\t\t\t\t     \\\n-      int fit = (disp >= 0 && disp <= (127 - 2 * GET_MODE_SIZE (MODE)));     \\\n-      rtx reg = XEXP (X, 0);\t\t\t\t\t\t     \\\n-      if (!fit)\t\t\t\t\t\t\t\t     \\\n-\t{\t\t\t\t\t\t\t\t     \\\n-          push_reload ((X), NULL_RTX, &(X),\t\t\t\t     \\\n-\t\t       NULL, MODE_BASE_REG_CLASS (MODE), GET_MODE (X),\t     \\\n-\t\t       VOIDmode, 0, 0, OPNUM, TYPE);\t\t\t     \\\n-\t  goto WIN;\t\t\t\t\t\t\t     \\\n-\t}\t\t\t\t\t\t\t\t     \\\n-      if (reg_equiv_memory_loc[REGNO (reg)]\t\t\t\t     \\\n-          && (reg_equiv_address[REGNO (reg)] || num_not_at_initial_offset))  \\\n-        {\t\t\t\t\t\t\t\t     \\\n-\t  rtx mem = make_memloc (reg, REGNO (reg));\t\t\t     \\\n-\t  if (! strict_memory_address_p (GET_MODE (mem), XEXP (mem, 0)))     \\\n-\t    {\t\t\t\t\t\t\t\t     \\\n-\t      /* Note that we're doing address in address - cf. ADDR_TYPE  */\\\n-               find_reloads_address (GET_MODE (mem), &mem, XEXP (mem, 0),    \\\n- \t\t\t            &XEXP (mem, 0), (OPNUM),\t\t     \\\n-\t\t\t            ADDR_TYPE (TYPE), (IND), insn);\t     \\\n-\t    }\t\t\t\t\t\t\t\t     \\\n-          push_reload (mem, NULL, &XEXP (X, 0), NULL,\t\t\t     \\\n-\t\t       GENERAL_REGS, Pmode, VOIDmode, 0, 0,\t\t     \\\n-\t\t       OPNUM, TYPE);\t\t\t\t\t     \\\n-          push_reload (X, NULL, &X, NULL,\t\t\t\t     \\\n-\t\t       MODE_BASE_REG_CLASS (MODE), GET_MODE (X), VOIDmode,   \\\n-\t\t       0, 0, OPNUM, TYPE);\t\t\t\t     \\\n-\t  goto WIN;\t\t\t\t\t\t\t     \\\n-\t}\t\t\t\t\t\t\t\t     \\\n-   }\t\t\t\t\t\t\t\t\t     \\\n-}\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n-    do {\t\t\t\t\t\t\t\\\n-\tif (ip2k_mode_dependent_address (ADDR)) goto LABEL;\t\\\n-    } while (0)\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) 7\n-\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) 6\n-\n-#define SLOW_BYTE_ACCESS 0\n-\n-#define NO_FUNCTION_CSE\n-\n-#define TEXT_SECTION_ASM_OP \".text\"\n-#define DATA_SECTION_ASM_OP \".data\"\n-\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-#define ASM_COMMENT_START \" ; \"\n-\n-#define ASM_APP_ON \"/* #APP */\\n\"\n-\n-#define ASM_APP_OFF \"/* #NOAPP */\\n\"\n-\n-#define ASM_OUTPUT_DOUBLE(STREAM, VALUE) \\\n-  fprintf ((STREAM), \".double %.20e\\n\", (VALUE))\n-#define ASM_OUTPUT_FLOAT(STREAM, VALUE) \\\n-  asm_output_float ((STREAM), (VALUE))\n-\n-#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\t\\\n- ( fprintf ((FILE), \"\\t.long \"),\t\t\t\\\n-   output_addr_const ((FILE), (VALUE)),\t\t\t\\\n-   fputs (\"\\n\", (FILE)))\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE) \\\n-  asm_output_short ((FILE), (VALUE))\n-#define ASM_OUTPUT_CHAR(FILE,VALUE) \\\n-  asm_output_char ((FILE), (VALUE))\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE) \\\n-  asm_output_byte ((FILE), (VALUE))\n-\n-#define IS_ASM_LOGICAL_LINE_SEPARATOR(C) \\\n-  ((C) == '\\n' || ((C) == '$'))\n-\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\\\n-do {\t\t\t\t\t\t\t\\\n-     fputs (\"\\t.comm \", (STREAM));\t\t\t\\\n-     assemble_name ((STREAM), (NAME));\t\t\t\\\n-     fprintf ((STREAM), \",%d\\n\", (int)(SIZE));\t\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\\\n-do {\t\t\t\t\t\t\t\\\n-     fputs (\"\\t.lcomm \", (STREAM));\t\t\t\\\n-     assemble_name ((STREAM), (NAME));\t\t\t\\\n-     fprintf ((STREAM), \",%d\\n\", (int)(SIZE));\t\t\\\n-} while (0)\n-\n-#undef WEAK_ASM_OP\n-#define WEAK_ASM_OP\t\".weak\"\n-\n-#undef ASM_DECLARE_FUNCTION_SIZE\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive)\t\t\t\t\\\n-      ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);\t\t\t\\\n-  } while (0)\n-\n-#define ESCAPES \\\n-\"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n-\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n-\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n-\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n-/* A table of bytes codes used by the ASM_OUTPUT_ASCII and\n-   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table\n-   corresponds to a particular byte value [0..255].  For any\n-   given byte value, if the value in the corresponding table\n-   position is zero, the given character can be output directly.\n-   If the table value is 1, the byte must be output as a \\ooo\n-   octal escape.  If the tables value is anything else, then the\n-   byte value should be output as a \\ followed by the value\n-   in the table.  Note that we can use standard UN*X escape\n-   sequences for many control characters, but we don't use\n-   \\a to represent BEL because some svr4 assemblers (e.g. on\n-   the i386) don't know about that.  Also, we don't use \\v\n-   since some versions of gas, such as 2.2 did not accept it.  */\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \".global\\t\"\n-\n-#define REGISTER_NAMES\t{\t\t\t\t\t\\\n-  \"$00\",\"$01\",\"$02\",\"$03\",\"iph\",\"ipl\",\"sph\",\"spl\",\t\t\\\n-  \"pch\",\"pcl\",\"wreg\",\"status\",\"dph\",\"dpl\",\"$0e\",\"mulh\",\t\t\\\n-  \"$10\",\"$11\",\"$12\",\"$13\",\"$14\",\"$15\",\"$16\",\"$17\",\t\t\\\n-  \"$18\",\"$19\",\"$1a\",\"$1b\",\"$1c\",\"$1d\",\"$1e\",\"$1f\",\t\t\\\n-  \"$20\",\"$21\",\"$22\",\"$23\",\"$24\",\"$25\",\"$26\",\"$27\",\t\t\\\n-  \"$28\",\"$29\",\"$2a\",\"$2b\",\"$2c\",\"$2d\",\"$2e\",\"$2f\",\t\t\\\n-  \"$30\",\"$31\",\"$32\",\"$33\",\"$34\",\"$35\",\"$36\",\"$37\",\t\t\\\n-  \"$38\",\"$39\",\"$3a\",\"$3b\",\"$3c\",\"$3d\",\"$3e\",\"$3f\",\t\t\\\n-  \"$40\",\"$41\",\"$42\",\"$43\",\"$44\",\"$45\",\"$46\",\"$47\",\t\t\\\n-  \"$48\",\"$49\",\"$4a\",\"$4b\",\"$4c\",\"$4d\",\"$4e\",\"$4f\",\t\t\\\n-  \"$50\",\"$51\",\"$52\",\"$53\",\"$54\",\"$55\",\"$56\",\"$57\",\t\t\\\n-  \"$58\",\"$59\",\"$5a\",\"$5b\",\"$5c\",\"$5d\",\"$5e\",\"$5f\",\t\t\\\n-  \"$60\",\"$61\",\"$62\",\"$63\",\"$64\",\"$65\",\"$66\",\"$67\",\t\t\\\n-  \"$68\",\"$69\",\"$6a\",\"$6b\",\"$6c\",\"$6d\",\"$6e\",\"$6f\",\t\t\\\n-  \"$70\",\"$71\",\"$72\",\"$73\",\"$74\",\"$75\",\"$76\",\"$77\",\t\t\\\n-  \"$78\",\"$79\",\"$7a\",\"$7b\",\"$7c\",\"$7d\",\"callh\",\"calll\",\t\t\\\n-  \"$80\",\"$81\",\"$82\",\"$83\",\"$84\",\"$85\",\"$86\",\"$87\",\t\t\\\n-  \"$88\",\"$89\",\"$8a\",\"$8b\",\"$8c\",\"$8d\",\"$8e\",\"$8f\",\t\t\\\n-  \"$90\",\"$91\",\"$92\",\"$93\",\"$94\",\"$95\",\"$96\",\"$97\",\t\t\\\n-  \"$98\",\"$99\",\"$9a\",\"$9b\",\"$9c\",\"$9d\",\"$9e\",\"$9f\",\t\t\\\n-  \"$a0\",\"$a1\",\"$a2\",\"$a3\",\"$a4\",\"$a5\",\"$a6\",\"$a7\",\t\t\\\n-  \"$a8\",\"$a9\",\"$aa\",\"$ab\",\"$ac\",\"$ad\",\"$ae\",\"$af\",\t\t\\\n-  \"$b0\",\"$b1\",\"$b2\",\"$b3\",\"$b4\",\"$b5\",\"$b6\",\"$b7\",\t\t\\\n-  \"$b8\",\"$b9\",\"$ba\",\"$bb\",\"$bc\",\"$bd\",\"$be\",\"$bf\",\t\t\\\n-  \"$c0\",\"$c1\",\"$c2\",\"$c3\",\"$c4\",\"$c5\",\"$c6\",\"$c7\",\t\t\\\n-  \"$c8\",\"$c9\",\"$ca\",\"$cb\",\"$cc\",\"$cd\",\"$ce\",\"$cf\",\t\t\\\n-  \"$d0\",\"$d1\",\"$d2\",\"$d3\",\"$d4\",\"$d5\",\"$d6\",\"$d7\",\t\t\\\n-  \"$d8\",\"$d9\",\"$da\",\"$db\",\"$dc\",\"$dd\",\"$de\",\"$df\",\t\t\\\n-  \"$e0\",\"$e1\",\"$e2\",\"$e3\",\"$e4\",\"$e5\",\"$e6\",\"$e7\",\t\t\\\n-  \"$e8\",\"$e9\",\"$ea\",\"$eb\",\"$ec\",\"$ed\",\"$ee\",\"$ef\",\t\t\\\n-  \"$f0\",\"$f1\",\"$f2\",\"$f3\",\"$f4\",\"$f5\",\"$f6\",\"$f7\",\t\t\\\n-  \"$f8\",\"$f9\",\"$fa\",\"$fb\",\"$fc\",\"$fd\",\"$fe\",\"$ff\",\t\t\\\n-  \"vfph\",\"vfpl\",\"vaph\",\"vapl\"}\n-\n-#define PRINT_OPERAND(STREAM, X, CODE) \\\n-  print_operand ((STREAM), (X), (CODE))\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n-  ((CODE) == '<' || (CODE) == '>')\n-\n-#define PRINT_OPERAND_ADDRESS(STREAM, X) print_operand_address(STREAM, X)\n-\n-/* Since register names don't have a prefix, we must preface all\n-   user identifiers with the '_' to prevent confusion.  */\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"_\"\n-#define LOCAL_LABEL_PREFIX \".L\"\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n-  asm_fprintf ((STREAM), \"\\tpage\\t%L%d\\n\\tjmp\\t%L%d\\n\", (VALUE), (VALUE))\n-\n-/* elfos.h presumes that we will want switch/case dispatch tables aligned.\n-   This is not so for the ip2k.  */\n-#undef ASM_OUTPUT_CASE_LABEL\n-\n-#undef ASM_OUTPUT_ADDR_VEC_ELT\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n-  asm_fprintf ((STREAM), \"\\tpage\\t%L%d\\n\\tjmp\\t%L%d\\n\", (VALUE), (VALUE))\n-\n-#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n-  fprintf ((STREAM), \"\\t.align %d\\n\", (POWER))\n-\n-/* Since instructions are 16 bit word addresses, we should lie and claim that\n-   the dispatch vectors are in QImode.  Otherwise the offset into the jump\n-   table will be scaled by the MODE_SIZE.  */\n-\n-#define CASE_VECTOR_MODE QImode\n-\n-#undef WORD_REGISTER_OPERATIONS\n-\n-#define MOVE_MAX 1\n-\n-#define MOVE_RATIO\t\t3\n-/* MOVE_RATIO is the number of move instructions that is better than a\n-   block move.  Make this small on the IP2k, since the code size grows very\n-   large with each move.  */\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-#define Pmode HImode\n-\n-#define FUNCTION_MODE HImode\n-\n-#define DOLLARS_IN_IDENTIFIERS 0\n-\n-extern int ip2k_reorg_in_progress;\n-/* Flag if we're in the middle of IP2k-specific reorganization.  */\n-\n-extern int ip2k_reorg_completed;\n-/* Flag if we've completed our IP2k-specific reorganization.  If we have\n-   then we allow quite a few more tricks than before.  */\n-\n-extern int ip2k_reorg_split_dimode;\n-extern int ip2k_reorg_split_simode;\n-extern int ip2k_reorg_split_qimode;\n-extern int ip2k_reorg_split_himode;\n-/* Flags for various split operations that we run in sequence.  */\n-\n-extern int ip2k_reorg_merge_qimode;\n-/* Flag to indicate that it's safe to merge QImode operands.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE) abort ()\n-\n-#define TRAMPOLINE_SIZE 4\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (HImode, plus_constant ((TRAMP), 2)),\t\\\n-\t\t   \t   CXT);    \t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (HImode, plus_constant ((TRAMP), 6)),\t\\\n-\t\t\t   FNADDR);\t\t\t\t\t\\\n-}\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) (void)(0)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-  fprintf ((FILE), \"/* profiler %d */\", (LABELNO))\n-\n-#undef ENDFILE_SPEC\n-#undef LINK_SPEC\n-#undef STARTFILE_SPEC\n-\n-#if defined(__STDC__) || defined(ALMOST_STDC)\n-#define AS2(a,b,c) #a \"\\t\" #b \",\" #c\n-#define AS1(a,b) #a \"\\t\" #b\n-#else\n-#define AS1(a,b) \"a\tb\"\n-#define AS2(a,b,c) \"a\tb,c\"\n-#endif\n-#define OUT_AS1(a,b) output_asm_insn (AS1 (a,b), operands)\n-#define OUT_AS2(a,b,c) output_asm_insn (AS2 (a,b,c), operands)\n-#define CR_TAB \"\\n\\t\"\n-\n-#define PREDICATE_CODES\t\t\t\t\t\\\n-  {\"ip2k_ip_operand\", {MEM}},\t\t\t\t\\\n-  {\"ip2k_short_operand\", {MEM}},\t\t\t\\\n-  {\"ip2k_gen_operand\", {MEM, REG, SUBREG}},\t\t\\\n-  {\"ip2k_nonptr_operand\", {REG, SUBREG}},\t\t\\\n-  {\"ip2k_ptr_operand\", {REG, SUBREG}},\t\t\t\\\n-  {\"ip2k_split_dest_operand\", {REG, SUBREG, MEM}}, \t\\\n-  {\"ip2k_sp_operand\", {REG}},\t\t\t\t\\\n-  {\"ip2k_nonsp_reg_operand\", {REG, SUBREG}}, \t\t\\\n-  {\"ip2k_symbol_ref_operand\", {SYMBOL_REF}}, \t\t\\\n-  {\"ip2k_binary_operator\", {PLUS, MINUS, MULT, DIV,\t\\\n-\t\t\t    UDIV, MOD, UMOD, AND, IOR,\t\\\n-\t\t\t    XOR, COMPARE, ASHIFT,\t\\\n-\t\t\t    ASHIFTRT, LSHIFTRT}},\t\\\n-  {\"ip2k_unary_operator\", {NEG, NOT, SIGN_EXTEND,\t\\\n-\t\t\t   ZERO_EXTEND}},\t\t\\\n-  {\"ip2k_unsigned_comparison_operator\", {LTU, GTU, NE,\t\\\n-\t\t\t\t\t EQ, LEU, GEU}},\\\n-  {\"ip2k_signed_comparison_operator\", {LT, GT, LE, GE}},\n-\n-#define DWARF2_DEBUGGING_INFO 1\n-\n-#define DWARF2_ASM_LINE_DEBUG_INFO\t1\n-\n-#define DBX_REGISTER_NUMBER(REGNO)\t(REGNO)\n-\n-/* Miscellaneous macros to describe machine specifics.  */\n-\n-#define IS_PSEUDO_P(R)\t(REGNO (R) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Default calculations would cause DWARF address sizes to be 2 bytes,\n-   but the Harvard architecture of the IP2k and the word-addressed 64k\n-   of instruction memory causes us to want a 32-bit \"address\" field.  */\n-#undef DWARF2_ADDR_SIZE\n-#define DWARF2_ADDR_SIZE\t4\n-"}, {"sha": "b79a8ffcb4d4f34e79604257951eedad6df8a753", "filename": "gcc/config/ip2k/ip2k.md", "status": "removed", "additions": 0, "deletions": 6903, "changes": 6903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Fip2k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.md?ref=96a2347e1d837369cf266b937faf59511f0307ce"}, {"sha": "624037608fe848464822a9e6138ba4f033dedda7", "filename": "gcc/config/ip2k/libgcc.S", "status": "removed", "additions": 0, "deletions": 1516, "changes": 1516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Flibgcc.S?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,1516 +0,0 @@\n-;\n-; Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n-; Contributed by Red Hat, Inc and Ubicom, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify\n-; it under the terms of the GNU General Public License as published by\n-; the Free Software Foundation; either version 2, or (at your option)\n-; any later version.\n-;\n-; In addition to the permissions in the GNU General Public License, the\n-; Free Software Foundation gives you unlimited permission to link the\n-; compiled version of this file with other programs, and to distribute\n-; those programs without any restriction coming from the use of this\n-; file.  (The General Public License restrictions do apply in other\n-; respects; for example, they cover modification of the file, and\n-; distribution when not linked into another program.)\n-;\n-; GCC is distributed in the hope that it will be useful,\n-; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-; GNU General Public License for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING.  If not, write to\n-; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-; Boston, MA 02110-1301, USA.  */\n-\n-/*******************************************************\n-\tload byte from arbitrary memory\n-\taddress passed in first bank register, result in W\n-\n-*******************************************************/\n-\t.macro\tmovb\tto, from\n-\tmov\tw, \\from\n-\tmov\t\\to, w\n-\t.endm\n-\n-\f\n-#if defined (L_indcall)\n-/* __indcall - given register containing an address, call the function\n- *\tat that address.\n- */\n-\n-\t.sect\t.pram.libgcc,\"ax\"\n-\t.global\t__indcall\n-\t.func\t_indcall,__indcall\n-\n-__indcall:\n-\tpage\t1f\n-\tcall\t1f\n-1:\tpop\tcallh\t\t\t; Get the call target\n-\tpop\tcalll\n-\tret\t\t\t\t; Transfer to new function\n-\n-\t.endfunc\n-#endif\n-\f\n-\n-#if defined (L_mulhi3)\n-\t.sect\t.pram.libgcc,\"ax\"\n-\t.global\t__mulhi3\n-\t.func\t_mulhi3, __mulhi3\n-\n-__mulhi3:\n-\tmov\tw, 2(SP)\t\t; First upper half partial product\n-\tmulu\tw, 3(SP)\n-\tmov\t3(SP), w\n-\tmov\tw, 1(SP)\t\t; Second upper half partial product\n-\tmulu\tw, 4(SP)\n-\tadd\t3(SP), w\n-\tmov\tw, 2(SP)\t\t; Lower half partial product\n-\tmulu\tw, 4(SP)\n-\tmov\t4(SP), w\n-\tmov\tw, MULH\n-\tadd\t3(SP), w\n-\n-\tmov\tw, #2\t\t\t; Adjust the stack leaving the result to\n-\tadd\tspl, w\t\t\t; be popped off later.\n-\tret\n-\n-\t.endfunc\n-\n-#endif /* defined (L_mulhi3) */\n-\n-#if defined (L_mulsi3)\n-/*******************************************************\n-               Multiplication  32 x 32\n-*******************************************************/\n-\t\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__mulsi3\n-\t.func\t_mulsi3, __mulsi3\n-\n-__mulsi3:\n-\tclr\t$80\t\t\t; Assume zero result\n-\tclr\t$81\n-\tclr\t$82\n-\tclr\t$83\n-\n-2:\tmov\tw, 1(sp)\n-\tor\tw, 2(sp)\n-\tor\tw, 3(sp)\n-\tor\tw, 4(sp)\n-\tsnz\t\t\t\t; Any more significant bits to multiply?\n-\tpage\t3f\n-\tjmp\t3f\n-\n-\tsb\t4(sp), 0\t\t; Check LSB of multiplier\n-\tpage\t1f\t\t\t; zero => scale multiplicand & multiplier\n-\tjmp\t1f\n-\n-\tmov\tw, 8(sp)\t\t; Accumulate product\n-\tadd\t$83, w\n-\tmov\tw, 7(sp)\n-\taddc\t$82, w\n-\tmov\tw, 6(sp)\n-\taddc\t$81, w\n-\tmov\tw, 5(sp)\n-\taddc\t$80, w\n-1:\tclrb\tstatus, 0\t\t; scale multiplier down\n-\trr\t1(sp)\t\n-\trr\t2(sp)\n-\trr\t3(sp)\n-\trr\t4(sp)\n-\tclrb\tstatus, 0\n-\trl\t8(sp)\n-\trl\t7(sp)\n-\trl\t6(sp)\n-\trl\t5(sp)\n-\tpage\t2b\n-\tjmp\t2b\n-\n-3:\tmov\tw, #8\n-\tadd\tspl ,w\n-\tret\n-\n-\t.endfunc\n-\n-#endif /* defined (L_mulsi3) */\n-\t\n-#if defined (L_muldi3)\n-/*******************************************************\n-               Multiplication  64 x 64\n-*******************************************************/\n-\t\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__muldi3\n-\t.func\t_muldi3, __muldi3\n-\n-__muldi3:\n-\tclr\t$80\t\t\t; Assume zero result\n-\tclr\t$81\n-\tclr\t$82\n-\tclr\t$83\n-\tclr\t$84\n-\tclr\t$85\n-\tclr\t$86\n-\tclr\t$87\n-\n-2:\tmov\tw, 1(sp)\n-\tor\tw, 2(sp)\n-\tor\tw, 3(sp)\n-\tor\tw, 4(sp)\n-\tor\tw, 5(sp)\n-\tor\tw, 6(sp)\n-\tor\tw, 7(sp)\n-\tor\tw, 8(sp)\n-\tsnz\t\t\t\t; Any more significant bits to multiply?\n-\tpage\t3f\n-\tjmp\t3f\n-\n-\tsb\t8(sp), 0\t\t; Check LSB of multiplier\n-\tpage\t1f\t\t\t; zero => scale multiplicand & multiplier\n-\tjmp\t1f\n-\n-\tmov\tw, 16(sp)\t\t; Accumulate product\n-\tadd\t$87, w\n-\tmov\tw, 15(sp)\n-\taddc\t$86, w\n-\tmov\tw, 14(sp)\n-\taddc\t$85, w\n-\tmov\tw, 13(sp)\n-\taddc\t$84, w\n-\tmov\tw, 12(sp)\n-\taddc\t$83, w\n-\tmov\tw, 11(sp)\n-\taddc\t$82, w\n-\tmov\tw, 10(sp)\n-\taddc\t$81, w\n-\tmov\tw, 9(sp)\n-\taddc\t$80, w\n-\n-1:\tclrb\tstatus, 0\t\t; scale multiplier down\n-\trr\t1(sp)\t\n-\trr\t2(sp)\n-\trr\t3(sp)\n-\trr\t4(sp)\n-\trr\t5(sp)\n-\trr\t6(sp)\n-\trr\t7(sp)\n-\trr\t8(sp)\n-\tclrb\tstatus, 0\n-\trl\t16(sp)\n-\trl\t15(sp)\n-\trl\t14(sp)\n-\trl\t13(sp)\n-\trl\t12(sp)\n-\trl\t11(sp)\n-\trl\t10(sp)\n-\trl\t9(sp)\n-\tpage\t2b\n-\tjmp\t2b\n-\n-3:\tmov\tw, #16\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-\n-#endif /* defined (L_muldi3) */\n-\n-#if defined (L_divmodhi4)\n-#define\targ1h 1(SP)\n-#define arg1l 2(SP)\n-#define arg2h 3(SP)\n-#define arg2l 4(SP)\n-#define resl $81\n-#define resh $80\n-#define reml $83\n-#define remh $82\n-#define tmp_var\t$84\n-#define cnt $85\n-#define arg1_sign $86\n-#define res_sign $87\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__divmodhi4\n-\t.func\t_divmodhi4, __divmodhi4\n-\n-__divmodhi4:\n-\tmov\tw,arg2h\n-\tmov\tres_sign,w\n-\tmov\tw,arg1h\n-\tmov\targ1_sign,w\n-\txor\tres_sign,w\n-\n-\tsb\targ1h,7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\targ1h\n-\tnot\targ1l\n-\tincsnz\targ1l\n-\tinc\targ1h\n-\n-1:\tsb\targ2h, 7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\targ2h\n-\tnot\targ2l\n-\tincsnz\targ2l\n-\tinc\targ2h\n-\n-1:\tpage\t__udivmodhi4\t\t; Do the unsigned div/mod\n-\tcall\t__udivmodhi4\n-\n-\tsb\targ1_sign, 7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\treml\n-\tnot\tremh\n-\tincsnz\treml\n-\tinc\tremh\n-\n-1:\tsb\tres_sign, 7\n-\tret\n-\n-\tnot\tresl\n-\tnot\tresh\n-\tincsnz\tresl\n-\tinc\tresh\n-\tret\n-\n-\t.endfunc\n-\n-#undef arg1h\n-#undef arg1l\n-#undef arg2h\n-#undef arg2l\n-#undef resl\n-#undef resh\n-#undef reml\n-#undef remh\n-#undef tmp_var\n-#undef cnt\n-#undef arg1_sign\n-#undef res_sign\n-\n-#endif /* defined (L_divmodhi4) */\n-\t\n-#if defined (L_udivmodhi4)\n-\n-#define\targ1h 1(SP)\n-#define arg1l 2(SP)\n-#define arg2h 3(SP)\n-#define arg2l 4(SP)\n-#define resl $81\n-#define resh $80\n-#define reml $83\n-#define remh $82\n-#define tmp_var\t$84\n-#define cnt $85\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__udivmodhi4\n-\t.func\t_udivmodhi4, __udivmodhi4\n-\n-__udivmodhi4:\n-\tclr\treml\n-\tclr\tremh\n-\tmov\tw, #17\n-\tmov\tcnt,w\n-\tclrb\tstatus, 0\n-\tpage\t1f\n-\tjmp\t1f\n-\n-2:\trl\treml\n-\trl\tremh\n-\tmov\tw, arg2l\n-\tsub\tw, reml\n-\tmov\ttmp_var, w\n-\tmov\tw, arg2h\n-\tsubc\tw, remh\n-\tsc\n-\tpage\t1f\n-\tjmp\t1f\n-\tmov\tremh, w\n-\tmov\tw, tmp_var\n-\tmov\treml, w\n-\n-1:\trl\targ1l\n-\trl\targ1h\n-\tdecsz\tcnt\n-\tpage\t2b\n-\tjmp\t2b\n-\t\n-\tpop\tresh\n-\tpop\tresl\t\n-\tmov\tw, #2\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-\n-#undef arg1h\n-#undef arg1l\n-#undef arg2h\n-#undef arg2l\n-#undef resl\n-#undef resh\n-#undef reml\n-#undef remh\n-#undef tmp_var\n-#undef cnt\n-\n-#endif\t/* defined (L_udivmodhi4) */\n-\n-#if defined (L_divmodsi4)\n-\n-#define\targ1a 1(SP)\n-#define arg1b 2(SP)\n-#define arg1c 3(SP)\n-#define arg1d 4(SP)\n-\n-#define arg2a 5(SP)\n-#define arg2b 6(SP)\n-#define arg2c 7(SP)\n-#define arg2d 8(SP)\n-\t\n-#define resa $80\n-#define resb $81\n-#define resc $82\n-#define resd $83\n-\n-#define rema $84\n-#define remb $85\n-#define remc $86\n-#define remd $87\n-\n-#define tmp_var\t$88\n-#define tmp_var1 $89\n-#define tmp_var2 $8a\n-#define cnt $8b\n-#define arg1_sign $8c\n-#define res_sign $8d\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__divmodsi4\n-\t.func\t_divmodsi4, __divmodsi4\n-\n-__divmodsi4:\n-\tmov\tw, arg2a\n-\tmov\tres_sign, w\n-\tmov\tw, arg1a\n-\tmov\targ1_sign, w\n-\txor\tres_sign, w\n-\n-\tsb\targ1a, 7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\targ1d\n-\tnot\targ1c\n-\tnot\targ1b\n-\tnot\targ1a\n-\tincsnz\targ1d\n-\tincsz\targ1c\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ1b\n-\tinc\targ1a\n-\n-1:\tsb\targ2a, 7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\targ2d\n-\tnot\targ2c\n-\tnot\targ2b\n-\tnot\targ2a\n-\tincsnz\targ2d\n-\tincsz\targ2c\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ2b\n-\tinc\targ2a\n-\n-1:\tpage\t__udivmodsi4\t\t; Do the unsigned div/mod.\n-\tcall\t__udivmodsi4\n-\n-\tsb\targ1_sign, 7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\tremd\n-\tnot\tremc\n-\tnot\tremb\n-\tnot\trema\n-\tincsnz\tremd\n-\tincsz\tremc\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\tremb\n-\tinc\trema\n-\n-1:\tsb\tres_sign, 7\n-\tret\n-\n-\tnot\tresd\n-\tnot\tresc\n-\tnot\tresb\n-\tnot\tresa\n-\tincsnz\tresd\n-\tincsz\tresc\n-\tret\n-\tincsnz\tresb\n-\tinc\tresa\n-\tret\n-\n-\t.endfunc\n-\n-#undef arg1a\n-#undef arg1b\n-#undef arg1c\n-#undef arg1d\n-\n-#undef arg2a\n-#undef arg2b\n-#undef arg2c\n-#undef arg2d\n-\t\n-#undef resa\n-#undef resb\n-#undef resc\n-#undef resd\n-\n-#undef rema\n-#undef remb\n-#undef remc\n-#undef remd\n-\n-#undef tmp_var\n-#undef tmp_var1\n-#undef tmp_var2\n-#undef cnt\n-#undef arg1_sign\n-#undef res_sign\n-\n-#endif /* defined (L_divmodsi4) */\n-\n-#if defined (L_udivmodsi4)\t\t\n-#define\targ1a 1(SP)\n-#define arg1b 2(SP)\n-#define arg1c 3(SP)\n-#define arg1d 4(SP)\n-\n-#define arg2a 5(SP)\n-#define arg2b 6(SP)\n-#define arg2c 7(SP)\n-#define arg2d 8(SP)\n-\t\n-#define resa $80\n-#define resb $81\n-#define resc $82\n-#define resd $83\n-\n-#define rema $84\n-#define remb $85\n-#define remc $86\n-#define remd $87\n-\n-#define tmp_var\t$88\n-#define tmp_var1 $89\n-#define tmp_var2 $8a\n-#define cnt $8b\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__udivmodsi4\n-\t.func\t_udivmodsi4, __udivmodsi4\n-\n-__udivmodsi4:\n-\tclr\tremd\n-\tclr\tremc\n-\tclr\tremb\n-\tclr\trema\n-\tmov\tw, #33\n-\tmov\tcnt, w\n-\tclrb\tstatus, 0\n-\tpage\t1f\n-\tjmp\t1f\n-\n-2:\trl\tremd\n-\trl\tremc\n-\trl\tremb\n-\trl\trema\n-\tmov\tw, arg2d\n-\tsub\tw, remd\n-\tmov\ttmp_var, w\n-\tmov\tw, arg2c\n-\tsubc\tw, remc\n-\tmov\ttmp_var1, w\n-\tmov\tw, arg2b\n-\tsubc\tw, remb\n-\tmov\ttmp_var2, w\n-\tmov\tw, arg2a\n-\tsubc\tw, rema\n-\tsc\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tmov\trema, w\n-\tmov\tw, tmp_var2\n-\tmov\tremb, w\n-\tmov\tw, tmp_var1\n-\tmov\tremc, w\n-\tmov\tw, tmp_var\n-\tmov\tremd, w\n-\n-1:\trl\targ1d\n-\trl\targ1c\n-\trl\targ1b\n-\trl\targ1a\n-\tdecsz\tcnt\n-\tpage\t2b\n-\tjmp\t2b\n-\n-\tpop\tresa\n-\tpop\tresb\n-\tpop\tresc\n-\tpop\tresd\n-\tmov\tw, #4\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-\n-#undef arg1a\n-#undef arg1b\n-#undef arg1c\n-#undef arg1d\n-\n-#undef arg2a\n-#undef arg2b\n-#undef arg2c\n-#undef arg2d\n-\t\n-#undef resa\n-#undef resb\n-#undef resc\n-#undef resd\n-\n-#undef rema\n-#undef remb\n-#undef remc\n-#undef remd\n-\n-#undef tmp_var\n-#undef tmp_var1\n-#undef tmp_var2\n-#undef cnt\n-\n-#endif /* defined (L_udivmodsi4) */\n-\n-#if defined (L_divmoddi4)\n-\n-#define\targ1s 1(SP)\n-#define arg1t 2(SP)\n-#define arg1u 3(SP)\n-#define arg1v 4(SP)\n-#define arg1w 5(SP)\n-#define arg1x 6(SP)\n-#define arg1y 7(SP)\n-#define arg1z 8(SP)\n-\n-#define arg2s 9(SP)\n-#define arg2t 10(SP)\n-#define arg2u 11(SP)\n-#define arg2v 12(SP)\n-#define arg2w 13(SP)\n-#define arg2x 14(SP)\n-#define arg2y 15(SP)\n-#define arg2z 16(SP)\n-\t\n-#define ress $80\n-#define rest $81\n-#define resu $82\n-#define resv $83\n-#define resw $84\n-#define resx $85\n-#define resy $86\n-#define resz $87\n-\n-#define rems $88\n-#define remt $89\n-#define remu $8a\n-#define remv $8b\n-#define remw $8c\n-#define remx $8d\n-#define remy $8e\n-#define remz $8f\n-\n-#define tmp_var\t$90\n-#define tmp_var1 $91\n-#define tmp_var2 $92\n-#define tmp_var3 $93\n-#define tmp_var4 $94\n-#define tmp_var5 $95\n-#define tmp_var6 $96\n-#define cnt $97\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__divmoddi4\n-\t.func\t_divmoddi4, __divmoddi4\n-\n-__divmoddi4:\n-\trl\tw, arg2s\t\t; Use MULH to track sign bits.\n-\trl\tMULH\n-\trl\tw, arg1s\n-\trl\tWREG\n-\txor\tMULH, w\n-\trl\tw, arg1s\n-\trl\tMULH\n-\n-\tsb\targ1s, 7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\targ1s\n-\tnot\targ1t\n-\tnot\targ1u\n-\tnot\targ1v\n-\tnot\targ1w\n-\tnot\targ1x\n-\tnot\targ1y\n-\tnot\targ1z\n-\tincsnz\targ1z\n-\tincsz\targ1y\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ1x\n-\tincsz\targ1w\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ1v\n-\tincsz\targ1u\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ1t\n-\tinc\targ1s\n-\n-1:\tsb\targ2s, 7\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\targ2s\n-\tnot\targ2t\n-\tnot\targ2u\n-\tnot\targ2v\n-\tnot\targ2w\n-\tnot\targ2x\n-\tnot\targ2y\n-\tnot\targ2z\n-\tincsnz\targ2z\n-\tincsz\targ2y\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ2x\n-\tincsz\targ2w\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ2v\n-\tincsz\targ2u\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\targ2t\n-\tinc\targ2s\n-\n-1:\tpage\t__udivmoddi4\t\t; Do the unsigned div/mod.\n-\tcall\t__udivmoddi4\n-\n-\tsb\tMULH, 0\t\t\t; Look at the save sign bit for arg 1.\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tnot\trems\n-\tnot\tremt\n-\tnot\tremu\n-\tnot\tremv\n-\tnot\tremw\n-\tnot\tremx\n-\tnot\tremy\n-\tnot\tremz\n-\tincsnz\tremz\n-\tincsz\tremy\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\tremx\n-\tincsz\tremw\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\tremv\n-\tincsz\tremu\n-\tpage\t1f\n-\tjmp\t1f\n-\tincsnz\tremt\n-\tinc\trems\n-\n-1:\tsb\tMULH, 1\n-\tret\n-\n-\tnot\tress\n-\tnot\trest\n-\tnot\tresu\n-\tnot\tresv\n-\tnot\tresw\n-\tnot\tresx\n-\tnot\tresy\n-\tnot\tresz\n-\tincsnz\tresz\n-\tincsz\tresy\n-\tret\n-\tincsnz\tresx\n-\tincsz\tresw\n-\tret\n-\tincsnz\tresv\n-\tincsz\tresu\n-\tret\n-\tincsnz\trest\n-\tinc\tress\n-\tret\n-\n-\t.endfunc\n-\n-#undef arg1s\n-#undef arg1t\n-#undef arg1u\n-#undef arg1v\n-#undef arg1w\n-#undef arg1x\n-#undef arg1y\n-#undef arg1z\n-\n-#undef arg2s\n-#undef arg2t\n-#undef arg2u\n-#undef arg2v\n-#undef arg2w\n-#undef arg2x\n-#undef arg2y\n-#undef arg2z\n-\t\n-#undef ress\n-#undef rest\n-#undef resu\n-#undef resv\n-#undef resw\n-#undef resx\n-#undef resy\n-#undef resz\n-\n-#undef rems\n-#undef remt\n-#undef remu\n-#undef remv\n-#undef remw\n-#undef remx\n-#undef remy\n-#undef remz\n-\n-#undef tmp_var\n-#undef tmp_var1\n-#undef tmp_var2\n-#undef tmp_var3\n-#undef tmp_var4\n-#undef tmp_var5\n-#undef tmp_var6\n-#undef cnt\n-\n-#endif /* defined (L_divmoddi4) */\n-\n-#if defined (L_udivmoddi4)\t\t\n-#define\targ1s 1(SP)\n-#define arg1t 2(SP)\n-#define arg1u 3(SP)\n-#define arg1v 4(SP)\n-#define arg1w 5(SP)\n-#define arg1x 6(SP)\n-#define arg1y 7(SP)\n-#define arg1z 8(SP)\n-\n-#define arg2s 9(SP)\n-#define arg2t 10(SP)\n-#define arg2u 11(SP)\n-#define arg2v 12(SP)\n-#define arg2w 13(SP)\n-#define arg2x 14(SP)\n-#define arg2y 15(SP)\n-#define arg2z 16(SP)\n-\t\n-#define ress $80\n-#define rest $81\n-#define resu $82\n-#define resv $83\n-#define resw $84\n-#define resx $85\n-#define resy $86\n-#define resz $87\n-\n-#define rems $88\n-#define remt $89\n-#define remu $8a\n-#define remv $8b\n-#define remw $8c\n-#define remx $8d\n-#define remy $8e\n-#define remz $8f\n-\n-#define tmp_var\t$90\n-#define tmp_var1 $91\n-#define tmp_var2 $92\n-#define tmp_var3 $93\n-#define tmp_var4 $94\n-#define tmp_var5 $95\n-#define tmp_var6 $96\n-#define cnt $97\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__udivmoddi4\n-\t.func\t_udivmoddi4, __udivmoddi4\n-\n-__udivmoddi4:\n-\tclr\trems\n-\tclr\tremt\n-\tclr\tremu\n-\tclr\tremv\n-\tclr\tremw\n-\tclr\tremx\n-\tclr\tremy\n-\tclr\tremz\n-\tmov\tw, #65\n-\tmov\tcnt, w\n-\tclrb\tstatus, 0\n-\tpage\t1f\n-\tjmp\t1f\n-\n-2:\trl\tremz\n-\trl\tremy\n-\trl\tremx\n-\trl\tremw\n-\trl\tremv\n-\trl\tremu\n-\trl\tremt\n-\trl\trems\n-\tmov\tw, arg2z\n-\tsub\tw, remz\n-\tmov\ttmp_var, w\n-\tmov\tw, arg2y\n-\tsubc\tw, remy\n-\tmov\ttmp_var1, w\n-\tmov\tw, arg2x\n-\tsubc\tw, remx\n-\tmov\ttmp_var2, w\n-\tmov\tw, arg2w\n-\tsubc\tw, remw\n-\tmov\ttmp_var3, w\n-\tmov\tw, arg2v\n-\tsubc\tw, remv\n-\tmov\ttmp_var4, w\n-\tmov\tw, arg2u\n-\tsubc\tw, remu\n-\tmov\ttmp_var5, w\n-\tmov\tw, arg2t\n-\tsubc\tw, remt\n-\tmov\ttmp_var6, w\n-\tmov\tw, arg2s\n-\tsubc\tw, rems\n-\tsc\n-\tpage\t1f\n-\tjmp\t1f\n-\n-\tmov\trems, w\n-\tmov\tw, tmp_var6\n-\tmov\tremt, w\n-\tmov\tw, tmp_var5\n-\tmov\tremu, w\n-\tmov\tw, tmp_var4\n-\tmov\tremv, w\n-\tmov\tw, tmp_var3\n-\tmov\tremw, w\n-\tmov\tw, tmp_var2\n-\tmov\tremx, w\n-\tmov\tw, tmp_var1\n-\tmov\tremy, w\n-\tmov\tw, tmp_var\n-\tmov\tremz, w\n-\n-1:\trl\targ1z\n-\trl\targ1y\n-\trl\targ1x\n-\trl\targ1w\n-\trl\targ1v\n-\trl\targ1u\n-\trl\targ1t\n-\trl\targ1s\n-\tdecsz\tcnt\n-\tpage\t2b\n-\tjmp\t2b\n-\n-\tpop\tress\n-\tpop\trest\n-\tpop\tresu\n-\tpop\tresv\n-\tpop\tresw\n-\tpop\tresx\n-\tpop\tresy\n-\tpop\tresz\n-\tmov\tw, #8\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-\n-#undef arg1s\n-#undef arg1t\n-#undef arg1u\n-#undef arg1v\n-#undef arg1w\n-#undef arg1x\n-#undef arg1y\n-#undef arg1z\n-\n-#undef arg2s\n-#undef arg2t\n-#undef arg2u\n-#undef arg2v\n-#undef arg2w\n-#undef arg2x\n-#undef arg2y\n-#undef arg2z\n-\t\n-#undef ress\n-#undef rest\n-#undef resu\n-#undef resv\n-#undef resw\n-#undef resx\n-#undef resy\n-#undef resz\n-\n-#undef rems\n-#undef remt\n-#undef remu\n-#undef remv\n-#undef remw\n-#undef remx\n-#undef remy\n-#undef remz\n-\n-#undef tmp_var\n-#undef tmp_var1\n-#undef tmp_var2\n-#undef tmp_var3\n-#undef tmp_var4\n-#undef tmp_var5\n-#undef tmp_var6\n-#undef cnt\n-\n-#endif /* defined (L_udivmoddi4) */\n-\n-#define LT\t#0\n-#define EQ\t#1\n-#define GT\t#2\n-\n-#if defined(L_cmphi2)\n-#define arg1l 2(sp)\n-#define arg1h 1(sp)\n-#define arg2l 4(sp)\n-#define arg2h 3(sp)\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__cmphi2\n-\t.global\t__cmp_ret\n-\t.global\t__cmpqi_ret\n-\t.func\t_cmphi2, __cmphi2\n-\n-__cmphi2:\n-\tmov\tw,arg1l\t\n-\tsub\tw,arg2l\n-\tsnz\n-\tpage\t2f\n-\tjmp\t2f\n-\tmov\tw,arg1h\n-1:\n-\tsubc\tw,arg2h\n-\tclr\targ2l\n-\trl\targ2l\n-\tsnb\targ1h,7\n-\tsetb\targ2l,2\n-\tsnb\targ2h,7\n-\tsetb\targ2l,1\n-\tmov\tw,#3\n-\n-__cmp_ret:\n-\tadd\tspl,w\t\t\t;  sign1\n-\tpop\twreg\t\t\t;   sign2\n-\n-__cmpqi_ret:\n-\tadd\tpcl,w\t\t\t;    carry of arg1 - arg2\n-\tretw\tGT\t\t\t; [000] arg1 > arg2\n-\tretw\tLT\t\t\t; [001] arg1 < arg2\n-\tretw\tGT\t\t\t; [010] arg1 > arg2\n-\tretw\tGT\t\t\t; [011] arg1 > arg2\n-\tretw\tLT\t\t\t; [100] arg1 < arg2\n-\tretw\tLT\t\t\t; [101] arg1 < arg2\n-\tretw\tGT\t\t\t; [110] arg1 > arg2\n-\tretw\tLT\t\t\t; [111] arg1 < arg2\n-2:\n-\tmov\tw,arg1h\n-\tcse\tw,arg2h\n-\tpage\t1b\n-\tjmp\t1b\n-\tmov\tw,#4\n-\tadd\tspl,w\n-\tretw\tEQ\n-\n-\t.endfunc\n-#undef arg1l\n-#undef arg1h\n-#undef arg2l\n-#undef arg2h\n-#endif  /* L_cmphi2 */\n-\n-#if defined(L_cmpqi2)\n-#define arg1 1(sp)\n-#define arg2 2(sp)\n-\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__cmpqi2\n-\t.func\t_cmpqi2, __cmpqi2\n-\n-__cmpqi2:\n-\tmov\tw, arg1\n-\tsub\tw, arg2\n-\tsnz\n-\tpage\t2f\n-\tjmp\t2f\n-\n-\tclr\twreg\n-\trl\twreg\n-\tsnb\targ1, 7\n-\tsetb\twreg, 2\n-\tsnb\targ2, 7\n-\tsetb\twreg, 1\n-\tinc\tspl\n-\tinc\tspl\n-\tpage\t__cmpqi_ret\n-\tjmp\t__cmpqi_ret\n-\n-2:\tmov\tw, #2\n-\tadd\tspl, w\n-\tretw\tEQ\n-\n-\t.endfunc\n-#undef arg1l\n-#undef arg2l\n-#endif  /* L_cmpqi2 */\n-\n-#if defined(L_cmpsi2)\n-#define arg1d 4(sp)\n-#define arg1c 3(sp)\n-#define arg1b 2(sp)\n-#define arg1a 1(sp)\n-#define arg2d 8(sp)\n-#define arg2c 7(sp)\n-#define arg2b 6(sp)\n-#define arg2a 5(sp)\n-\t\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__cmpsi2\n-\t.func\t_cmpsi2, __cmpsi2\n-\n-__cmpsi2:\n-\tmov\tw, arg1d\n-\tsub\tw, arg2d\n-\tsnz\n-\tpage\t2f\n-\tjmp\t2f\n-\n-1:\tmov\tw, arg1c\n-\tsubc\tw, arg2c\n-\tmov\tw, arg1b\n-\tsubc\tw, arg2b\n-\tmov\tw, arg1a\n-\tsubc\tw, arg2a\n-\n-\tclr\targ2d\n-\trl\targ2d\n-\tsnb\targ1a, 7\n-\tsetb\targ2d, 2\n-\tsnb\targ2a, 7\n-\tsetb\targ2d, 1\n-\tmov\tw, #7\n-\tpage\t__cmp_ret\n-\tjmp\t__cmp_ret\n-\n-2:\tmov\tw, arg1c\n-\tcse\tw, arg2c\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1b\n-\tcse\tw, arg2b\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1a\n-\tcse\tw, arg2a\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, #8\n-\tadd\tspl, w\n-\tretw\tEQ\n-\n-\t.endfunc\n-\n-#undef arg1d\n-#undef arg1c\n-#undef arg1b\n-#undef arg1a\n-#undef arg2d\n-#undef arg2c\n-#undef arg2b\n-#undef arg2a\n-#endif  /* L_cmpsi2 */\n-\n-#if defined(L_cmpdi2)\n-#define arg1z 8(sp)\n-#define arg1y 7(sp)\n-#define arg1x 6(sp)\n-#define arg1w 5(sp)\n-#define arg1v 4(sp)\n-#define arg1u 3(sp)\n-#define arg1t 2(sp)\n-#define arg1s 1(sp)\n-\n-#define arg2z 16(sp)\n-#define arg2y 15(sp)\n-#define arg2x 14(sp)\n-#define arg2w 13(sp)\n-#define arg2v 12(sp)\n-#define arg2u 11(sp)\n-#define arg2t 10(sp)\n-#define arg2s 9(sp)\n-\t\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__cmpdi2\n-\t.func\t_cmpdi2, __cmpdi2\n-\n-__cmpdi2:\n-\tmov\tw, arg1z\n-\tsub\tw, arg2z\n-\tsnz\n-\tpage\t2f\n-\tjmp\t2f\n-\n-1:\tmov\tw, arg1y\n-\tsubc\tw, arg2y\n-\tmov\tw, arg1x\n-\tsubc\tw, arg2x\n-\tmov\tw, arg1w\n-\tsubc\tw, arg2w\n-\tmov\tw, arg1v\n-\tsubc\tw, arg2v\n-\tmov\tw, arg1u\n-\tsubc\tw, arg2u\n-\tmov\tw, arg1t\n-\tsubc\tw, arg2t\n-\tmov\tw, arg1s\n-\tsubc\tw, arg2s\n-\tclr\targ2z\n-\trl\targ2z\n-\tsnb\targ1s, 7\n-\tsetb\targ2z, 2\n-\tsnb\targ2s, 7\n-\tsetb\targ2z, 1\n-\tmov\tw, #15\n-\tpage\t__cmp_ret\n-\tjmp\t__cmp_ret\n-\n-2:\tmov\tw, arg1y\n-\tcse\tw, arg2y\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1x\n-\tcse\tw, arg2x\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1w\n-\tcse\tw, arg2w\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1v\n-\tcse\tw, arg2v\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1u\n-\tcse\tw, arg2u\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1t\n-\tcse\tw, arg2t\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, arg1s\n-\tcse\tw, arg2s\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tmov\tw, #16\n-\tadd\tspl, w\n-\tretw\tEQ\n-\n-\t.endfunc\n-\t\n-#undef arg1z\n-#undef arg1y\n-#undef arg1x\n-#undef arg1w\n-#undef arg1v\n-#undef arg1u\n-#undef arg1t\n-#undef arg1s\n-#undef arg2z\n-#undef arg2y\n-#undef arg2x\n-#undef arg2w\n-#undef arg2v\n-#undef arg2u\n-#undef arg2t\n-#undef arg2s\n-\n-#endif  /* L_cmpdi2 */\n-\t\n-#if defined(L_cmpdi2_dp)\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__cmpdi2_dp\n-\t.func\t_cmpdi2_dp, __cmpdi2_dp\n-\n-__cmpdi2_dp:\n-\tpush\t7(dp)\n-\tpush\t6(dp)\n-\tpush\t5(dp)\n-\tpush\t4(dp)\n-\tpush\t3(dp)\n-\tpush\t2(dp)\n-\tpush\t1(dp)\n-\tpush\t(dp)\n-\tpage\t__cmpdi2\n-\tjmp\t__cmpdi2\n-\n-\t.endfunc\n-#endif  /* L_cmpdi2_dp */\n-\n-#if defined(L_fp_pop_args_ret)\n-\t.sect\t.pram.libgcc,\"ax\"\n-\t.global\t__fp_pop_args_ret\n-\t.global\t__pop_args_ret\n-\t.global\t__pop2_args_ret\n-\t.func\t__fp_pop2_args_ret, __fp_pop2_args_ret\n-\n-__fp_pop2_args_ret:\n-\tmov\tw, #2\n-__fp_pop_args_ret:\n-\tpop\t0xfd\n-\tpop\t0xfe\n-__pop_args_ret:\n-\tpop\tcallh\n-\tpop\tcalll\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-#endif /* L_fp_pop_args_ret */\n-\n-#if defined(L__pop2_args_ret)\n-\t.sect\t.pram.libgcc,\"ax\"\n-\t.global\t__pop2_args_ret\n-\t.func\t__pop2_args_ret, __pop2_args_ret\n-\n-__pop2_args_ret:\n-\tmov\tw, #2\n-\tpop\tcallh\n-\tpop\tcalll\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-#endif /* L__pop2_args_ret */\n-\n-#if defined(L_leaf_fp_pop_args_ret)\n-\t.sect\t.pram.libgcc,\"ax\"\n-\t.global\t__leaf_fp_pop_args_ret, __leaf_fp_pop2_args_ret\n-\t.func\t__leaf_fp2_pop_args_ret, __leaf_fp_pop2_args_ret\n-\n-__leaf_fp_pop2_args_ret:\n-\tmov\tw, #2\n-__leaf_fp_pop_args_ret:\n-\tpop\t0xfd\n-\tpop\t0xfe\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-#endif /* L_leaf_fp_pop_args_ret */\n-\n-#if defined(L_movmemhi_countqi)\n-\t.sect\t.pram.libgcc,\"ax\"\n-\t.global\t__movmemhi_countqi\n-\t.func\t_movmemhi_countqi, __movmemhi_countqi\n-\n-__movmemhi_countqi:\n-\tpush\tdph\t\t\t; Save our pointer regs\n-\tpush\tdpl\n-\tpush\tiph\n-\tpush\tipl\n-\n-\tmov\tw, 5(SP)\t\t; Get our dest pointer\n-\tmov\tdph, w\n-\tmov\tw, 6(SP)\n-\tmov\tdpl, w\n-\tmov\tw, 7(SP)\t\t; And our source pointer\n-\tmov\tiph, w\n-\tmov\tw, 8(SP)\n-\tmov\tipl, w\n-\n-1:\tpush\t(IP)\t\t\t; *dest++ = *src++\n-\tpop\t0(DP)\n-\tinc\tipl\n-\tinc\tdpl\n-\tdecsz\t9(SP)\t\t\t; Loop until completed\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tpop\tipl\t\t\t; Restore our pointer regs\n-\tpop\tiph\n-\tpop\tdpl\n-\tpop\tdph\n-\n-\tmov\tw, #5\t\t\t; Tidy up our stack args\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-#endif\n-\n-#if defined(L_movmemhi_counthi)\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__movmemhi_counthi\n-\t.func\t_movmemhi_counthi, __movmemhi_counthi\n-\n-__movmemhi_counthi:\n-\tpush\tdph\t\t\t; Save our pointer regs\n-\tpush\tdpl\n-\tpush\tiph\n-\tpush\tipl\n-\n-\tmov\tw, 5(SP)\t\t; Get our dest pointer\n-\tmov\tdph, w\n-\tmov\tw, 6(SP)\n-\tmov\tdpl, w\n-\tmov\tw, 7(SP)\t\t; And our source pointer\n-\tmov\tiph, w\n-\tmov\tw, 8(SP)\n-\tmov\tipl, w\n-\n-\ttest\t10(SP)\t\t\t; If we have a nonzero LSB then adjust the\n-\tsz\t\t\t\t; MSB of the loop count to allow us to use\n-\tinc\t9(SP)\t\t\t; skip tricks!\n-\n-1:\tpush\t(IP)\t\t\t; *dest++ = *src++\n-\tpop\t0(DP)\n-\tinc\tipl\n-\tinc\tdpl\n-\tdecsnz\t10(SP)\t\t\t; Loop until completed - note the skip trick\n-\tdecsz\t9(SP)\t\t\t; on the MSB!\n-\tpage\t1b\n-\tjmp\t1b\n-\n-\tpop\tipl\t\t\t; Restore our pointer regs\n-\tpop\tiph\n-\tpop\tdpl\n-\tpop\tdph\n-\n-\tmov\tw, #6\t\t\t; Tidy up our stacked args.\n-\tadd\tspl, w\n-\tret\n-\n-\t.endfunc\n-#endif\n-\n-#if defined(L_exit)\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t__exit\n-\t.global\t_exit\n-\t.func\t_exit, __exit\n-\t.weak\t__exit\n-\t.weak\t_exit\n-\n-_exit:\t\t\n-__exit:\n-\tpop\t$88\n-\tpop\twreg\n-\tor\tw, $88\n-\tpush    wreg\n-\tpush\t#0\n-\tpush\t#1\n-\tsystem\t\t\t\t; Exit wreg\n-\tpage\t__exit\t\t\t; Never return\n-\tjmp\t__exit\n-\n-\t.endfunc\n-#endif\n-\n-#if defined(Labort)\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t_abort\n-\t.func\tabort, _abort\n-\n-_abort:\n-\tpush\t#1\n-\tpush\t#0\n-\tpush\t#1\n-\tsystem\t\t\t\t; Exit 1\n-\tret\n-\n-\t.endfunc\n-#endif\n-\n-#if defined(Lwrite)\n-\t/* Dummy entry point to suppress problems with glue code.  */\n-\t.sect\t.text.libgcc,\"ax\"\n-\t.global\t_write\n-\t.func\twrite, _write\n-;;\n-;; write (fil,buf,len) - say that write succeeds....\n-;; \n-_write:\n-\tmovb\t$80, 5(SP)\n-\tmovb\t$81, 6(SP)\t\t; Return length written\n-\tmov\tw, #6\n-\tadd\tspl, w\n-\tret\n-\t\n-\t.endfunc\n-#endif"}, {"sha": "f3d93542c3a48af27076160f09c00f0246555f48", "filename": "gcc/config/ip2k/t-ip2k", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Ft-ip2k", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fip2k%2Ft-ip2k", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Ft-ip2k?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,49 +0,0 @@\n-LIB1ASMSRC = ip2k/libgcc.S\n-\n-LIB1ASMFUNCS = \\\n-\t_indcall \\\n-\t_mulhi3 \\\n-\t_mulsi3 \\\n-\t_muldi3 \\\n-\t_udivmodhi4 \\\n-\t_divmodhi4 \\\n-\t_udivmodsi4 \\\n-\t_divmodsi4 \\\n-\t_udivmoddi4 \\\n-\t_divmoddi4 \\\n-\t_cmpqi2 \\\n-\t_cmphi2 \\\n-\t_cmpsi2 \\\n-\t_cmpdi2 \\\n-\t_cmpdi2_dp \\\n-\t_fp_pop_args_ret \\\n-\t_pop2_args_ret \\\n-\t_leaf_fp_pop_args_ret \\\n-\t_movmemhi_countqi \\\n-\t_movmemhi_counthi \\\n-\tabort \\\n-\t_exit\n-\n-# libgcc2.h thinks that nobody would have SI mode when\n-# MIN_UNITS_PER_WORD == 1, so lie to keep from major compiler errors.\n-\n-TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -DDF=SF -g -DMIN_UNITS_PER_WORD=2\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/ip2k/t-ip2k crt0.o\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#define FLOAT_ONLY' >> fp-bit.c\n-\techo '#define DF SF' >> fp-bit.c\n-\techo '#define DI SI' >> fp-bit.c\n-\techo '#define CMPtype QItype' >> fp-bit.c\n-\techo '#define SMALL_MACHINE' >> fp-bit.c\n-\techo 'typedef int QItype __attribute__ ((mode (QI)));' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-\n-FPBIT = fp-bit.c\n-\n-# Our crt0 is written in assembler and we don't really support profiling.\n-\n-CRT0_S = $(srcdir)/config/ip2k/crt0.S\n-MCRT0_S = $(CRT0_S)\n-"}, {"sha": "32e9704d95f7d7048febad52223ebd36f1e6a742", "filename": "gcc/config/ns32k/NOTES", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2FNOTES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2FNOTES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2FNOTES?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,97 +0,0 @@\n-Copyright (C) 2002\n-Free Software Foundation, Inc.\n-\n-\t\t\t Implementation Notes\n-\t\t\t ====================\n-\n-IEEE floating point comparisons\n-\n-Ian Dall <ian@beware.dropbear.id.au>\n-------------------------------------\n-\n-The ns32x81 fpu handles most operands in hardware, but traps on NaN,\n-Inf and Denormalized numbers. The correct behavior can be handled by\n-the trap handler. This is mostly transparent to the compiler, but in\n-the case of floating point comparisons, the trap handler and the\n-compiler must co-operate.\n-\n-Comparing a Nan with anything (including another Nan) is an unordered\n-comparison and a NE test should be true and any other test should be\n-false. There is nothing the trap handler can do to the condition codes\n-to make, for example ble and bgt (the machine instructions, not the\n-gcc insn's) both fail.\n-\n-The L flag (normally used for unsigned comparisons) is cleared by a floating\n-point compare. So, it is possible for the trap handler to communicate that\n-it has seen a NaN by setting this flag.\n-\n-This can get confusing so the following documents the reasoning. There\n-are only 3 flags of significance, N, Z and L. In what follows AB is\n-the conjunction of A and B (\"and\") A+B is the disjunction of A and B\n-(\"or\"), upper case represents true and lower case represents false. So\n-\"Zl\" is \"Z AND (NOT L)\".\n-\n-Also, we can require that the trap handler clears N and Z, whenever it\n-sets L. This means that in many cases, we do not need to test if L is\n-set or clear. The operations we require are:\n-\n-\tOperator\tExpression\tCheck L\n-\tGT\t\tNl\t\tNo\n-\tLT\t\tznl\t\tYes\n-\tGE\t\t(Z+N)l\t\tNo\n-\tLE\t\tnl\t\tYes\n-\tEQ\t\tZl\t\tNo\n-\tNE\t\tz+L\t\tNo\n-\n-\n-For example, the emitted code for the case of LT is\n-\n-\t  bhi 0f\n-\t  blt %0\n-\t0:\n-\n-which is, in effect, \"branch if ordered and less than.\"\n-\n-We also need insns for the reverse branches. These have the PC and\n-the label ref operands reversed. Thus the reverse bgt has a pattern:\n-\n- (set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n-\n-This is identical to a normal branch with the test complimented:\n-\n- (set (pc)\n-\t(if_then_else (not (gt (cc0)\n-\t\t\t  (const_int 0)))\n-\t\t      (label_ref (match_operand 0 \"\" \"\")\n-\t\t      (pc))))\n-\n-Thus we need a family of (NOT cond) tests. For integers this is easy,\n-a reverse blt becomes bge. However, the possibility of unordered\n-comparison complicates the floating point case. So, we need to\n-compliment the above expressions, using deMorgan's theorem, for the reverse\n-branch:\n-\n-\tOperator\tExpression\tCheck L\n-\tRGT\t\tn+L\t\tYes\n-\tRLT\t\tZ+N+L\t\tYes\n-\tRGE\t\tzn+L\t\tYes\n-\tRLE\t\tN+L\t\tYes\n-\tREQ\t\tz+L\t\tNo\n-\tRNE\t\tZl\t\tNo\n-\n-For example the emitted code for the case of RLT is\n-\n-   bge %0\n-   bhi %0\n-\n-which is, in effect \"branch if not less than and not unordered.\"\n-\n-These extra comparisons are safe if the trap handler doesn't set the\n-L flag, since in that case the additional \"bhi\" instructions are never\n-taken. Also, these extra branch instructions are controlled by the\n-\"-mieee-compare\" option.\n-"}, {"sha": "546725580139914269b103b099328b2f19515ff5", "filename": "gcc/config/ns32k/STATUS", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2FSTATUS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2FSTATUS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2FSTATUS?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,68 +0,0 @@\n-NS32K Port Status\tLast updated 19 Dec 2002\n-\n-Recent development of the ns32k port has been as a cross compiler. As\n-such a native bootstrap has not been performed.  Currently the\n-compiler successfully builds a NetBSD kernel and has been tested on\n-the testsuite with \"make check\" configured to remotely execute\n-tests on a pc532-netbsd.\n-\n-There are a few remaining failures in the testsuite, none of which\n-result in incorrect code generation or unexpected ICEs.\n-\n-Here follows comments on the outstanding testsuite failures:\n-\n-gcc.c-torture/compile/20001226-1.c,  -Os\n-This typically fails due to a time out or exhausting available memory.\n-In the past it has been found to eventually compile in under 6\n-minutes, with consuming up to 90MB. The timeout in dejagnu is 5\n-minutes.\n-\n-gcc.c-torture/execute/builtin-constant.c\n-I don't understand why this fails. Looking at the generated assembler,\n-the first invocation of btest returns \"1\" and the second \"0\". Presumably\n-the flow analysis is meant to indicate this is a \"builtin constant\".\n-The documentation for __builtin_constant says it is allowed to fail if the\n-compiler can't deduce that something is a constant, so the compiler is\n-correct if not ideal.\n-\n-gcc.dg/debug/debug-1.c scan-assembler xyzzy:\n-At -O3 level of optimization, variable xyzzy gets eliminated. Isn't it\n-reasonable that the debugging info is gone too? Indeed, the\n-documentation says this is expected behavior.\n-\n-gcc.dg/debug/debug-2.c scan-assembler xyzzy:\n-As for the above.\n-\n-gcc.dg/20010912-1.c\n-PIC is supported for the compiler, but we get a link error until we get a\n-cross linker which can handle dynamic linking.\n-\n-gcc.dg/20020304-1.c -O -fssa -fssa-ccp\n-ICE -fssa and -fssa-ccp are \"experimental\" options. Assume not a\n-backend problem.\n-\n-gcc.dg/20021014-1.c (test for excess errors)\n-This is a test of the \"-p\" option. Fails due to lack of mcrt0.o. This\n-platform support \"-pg\" but not \"-p\"\n-\n-gcc.dg/20021018-1.c (test for excess errors)\n-Fail due to lack of dynamic link support at link time.\n-\n-gcc.dg/bitfld-3.c (test for excess errors)\n-Execution passes, but compilation produces excessive warnings. These warnings\n-actually seem reasonable. The code uses __attribute__((aligned (8)), and\n-the maximum alignment which makes any sense for this architecture is 4.\n-\n-gcc.dg/duff-2.c (test for excess errors)\n-Execution passes, but compilation produces excessive warnings. Doesn't look\n-like a backend problem.\n-\n-gcc.dg/uninit-A.c -O2 -Wall -S\n-Bogus warnings, almost certainly not backend.\n-\n-gcc.dg/special/weak-1.c execution test\n-X  This fails for i386 too. I don't understand what the correct behavior\n-for this test is.\n-\n-gcc.dg/special/gcsec-1.c (test for excess errors)\n-a.out deficiency. -ffunction-sections and -fdata-sections not supported."}, {"sha": "27e218c5bb3d3a1b7b9b473642b37719576d482d", "filename": "gcc/config/ns32k/__unorddf2.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2F__unorddf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2F__unorddf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2F__unorddf2.c?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,34 +0,0 @@\n-/* Lightweight function to test for ieee unordered comparison\n-   Copyright (C) 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Ian Dall <ian@beware.dropbear.id.au>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-# define ISNAN(x) (\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    union u { double d; unsigned int i[2]; } *t = (union u *)&(x);\t\\\n-    ((t->i[1] & 0x7ff00000) == 0x7ff00000) &&\t\t\t\t\\\n-    (t->i[0] != 0 || (t->i[1] & 0xfffff) != 0);\t\t\t\t\\\n-  })\n-\n-int __unorddf2 (double, double);\n-int __unorddf2 (double a, double b)\n-{\n-  return ISNAN(a) || ISNAN(b);\n-}"}, {"sha": "1c186cee4d72b25a48fd38a033b0f59b283bb680", "filename": "gcc/config/ns32k/__unordsf2.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2F__unordsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2F__unordsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2F__unordsf2.c?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,34 +0,0 @@\n-/* Lightweight function to test for ieee unordered comparison\n-   Copyright (C) 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Ian Dall <ian@beware.dropbear.id.au>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-# define ISNAN(x) (\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    union u { float f; unsigned int i; } *t = (union u *)&(x);\t\\\n-    ((t->i & 0x7f800000) == 0x7f800000) &&\t\t\t\\\n-    ((t->i & 0x7fffff) != 0);\t\t\t\t\t\\\n-  })\n-\n-int __unordsf2 ( float, float);\n-int __unordsf2 ( float a, float b)\n-{\n-  return ISNAN(a) || ISNAN(b);\n-}"}, {"sha": "04c972624770fe03787771efe1c1718f840f25d8", "filename": "gcc/config/ns32k/netbsd.h", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fnetbsd.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,109 +0,0 @@\n-/* Configuration for a ns32532 running NetBSD as the target machine.\n-   Copyright (C) 1988, 1994, 1995, 1996, 1998, 2002, 2004, 2005\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      NETBSD_OS_CPP_BUILTINS_AOUT();\t\t\t\\\n-      builtin_define (\"__ns32k__\");\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Compile for the floating point unit & 32532 by default;\n-   Don't assume SB is zero;\n-   Don't use bit-field instructions;\n-   FPU is 32381;\n-   Use multiply-add instructions */\n-\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT \\\n-  (MASK_32532 | MASK_32381 | MASK_IEEE_COMPARE | MASK_MULT_ADD)\n-\n-/* 32-bit alignment for efficiency */\n-\n-#undef POINTER_BOUNDARY\n-#define POINTER_BOUNDARY 32\n-\n-/* 32-bit alignment for efficiency */\n-\n-#undef FUNCTION_BOUNDARY\n-#define FUNCTION_BOUNDARY 32\n-\n-/* 32532 spec says it can handle any alignment.  Rumor from tm-ns32k.h\n-   tells this might not be actually true (but it's for 32032, perhaps\n-   National has fixed the bug for 32532).  You might have to change this\n-   if the bug still exists.  */\n-\n-#undef STRICT_ALIGNMENT\n-#define STRICT_ALIGNMENT 0\n-\n-/* Use pc relative addressing whenever possible,\n-   it's more efficient than absolute (ns32k.c)\n-   You have to fix a bug in gas 1.38.1 to make this work with gas,\n-   patch available from jkp@cs.hut.fi.\n-   (NetBSD's gas version has this patch already applied) */\n-\n-#define PC_RELATIVE\n-\n-/* Operand of bsr or jsr should be just the address.  */\n-\n-#define CALL_MEMREF_IMPLICIT\n-\n-/* movd insns may have floating point constant operands.  */\n-\n-#define MOVD_FLOAT_OK\n-\n-/* Define a CPP_SPEC appropriate for NetBSD.  */\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC NETBSD_CPP_SPEC\n-\n-/* Make gcc agree with <machine/ansi.h> */\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* This is the char to use for continuation (in case we need to turn\n-   continuation back on).  */\n-\n-#define DBX_CONTIN_CHAR '?'\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-\n-#undef PCC_STATIC_STRUCT_RETURN\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* Until they use ELF or something that handles dwarf2 unwinds\n-   and initialization stuff better.  */\n-#define DWARF2_UNWIND_INFO 0"}, {"sha": "6103f8fb3a44a22f31f5433fc50b94cfb77ac8db", "filename": "gcc/config/ns32k/ns32k-protos.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k-protos.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,46 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  NS32000 version.\n-   Copyright (C) 2000, 2004 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-/* Prototypes for functions in ns32k.c */\n-\n-#ifdef RTX_CODE\n-extern enum reg_class secondary_reload_class (enum reg_class,\n-\t\t\t\t\t      enum machine_mode, rtx);\n-extern int reg_or_mem_operand (rtx, enum machine_mode);\n-\n-extern void split_di (rtx[], int, rtx[], rtx[]);\n-extern void expand_block_move (rtx[]);\n-extern int global_symbolic_reference_mentioned_p (rtx, int);\n-extern void print_operand (FILE *, rtx, int);\n-extern void print_operand_address (FILE *, rtx);\n-extern const char *output_move_double (rtx *);\n-extern const char *output_shift_insn (rtx *);\n-extern int symbolic_reference_mentioned_p (rtx);\n-extern void ns32k_notice_update_cc (rtx, rtx);\n-#endif /* RTX_CODE */\n-\n-#ifdef TREE_CODE\n-extern int ns32k_return_pops_args (tree, tree, int);\n-#endif /* TREE_CODE */\n-\n-extern int hard_regno_mode_ok (int, enum machine_mode);\n-extern int register_move_cost (enum reg_class, enum reg_class);\n-extern const char *output_move_dconst (int, const char *);"}, {"sha": "a8aff906ca955946109d209a3cc90a13f9b56af3", "filename": "gcc/config/ns32k/ns32k.c", "status": "removed", "additions": 0, "deletions": 1706, "changes": 1706, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,1706 +0,0 @@\n-/* Subroutines for assembler code output on the NS32000.\n-   Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2004, 2005\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-#include \"toplev.h\"\n-\n-#ifdef OSF_OS\n-int ns32k_num_files = 0;\n-#endif\n-\n-/* This duplicates reg_class_contents in reg_class.c, but maybe that isn't\n-   initialized in time. Also this is more convenient as an array of ints.\n-   We know that HARD_REG_SET fits in an unsigned int */\n-\n-const unsigned int ns32k_reg_class_contents[N_REG_CLASSES][1] = REG_CLASS_CONTENTS;\n-\n-const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n-{\n-  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n-  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n-  FLOAT_REG0, LONG_FLOAT_REG0, FLOAT_REGS, FLOAT_REGS,\n-  FLOAT_REGS, FLOAT_REGS, FLOAT_REGS, FLOAT_REGS,\n-  LONG_REGS, LONG_REGS, LONG_REGS, LONG_REGS,\n-  LONG_REGS, LONG_REGS, LONG_REGS, LONG_REGS,\n-  FRAME_POINTER_REG, STACK_POINTER_REG\n-};\n-\n-static const char *const ns32k_out_reg_names[] = OUTPUT_REGISTER_NAMES;\n-\n-static bool ns32k_handle_option (size_t, const char *, int);\n-static rtx gen_indexed_expr (rtx, rtx, rtx);\n-static const char *singlemove_string (rtx *);\n-static void move_tail (rtx[], int, int);\n-static tree ns32k_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n-const struct attribute_spec ns32k_attribute_table[];\n-static void ns32k_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void ns32k_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static bool ns32k_rtx_costs (rtx, int, int, int *);\n-static int ns32k_address_cost (rtx);\n-static rtx ns32k_struct_value_rtx (tree, int);\n-static int ns32k_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t    tree, bool);\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE ns32k_attribute_table\n-\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.word\\t\"\n-\n-#ifdef ENCORE_ASM\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP \"\\t.double\\t\"\n-#endif\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE ns32k_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE ns32k_output_function_epilogue\n-\n-#undef TARGET_DEFAULT_TARGET_FLAGS\n-#define TARGET_DEFAULT_TARGET_FLAGS TARGET_DEFAULT\n-#undef TARGET_HANDLE_OPTION\n-#define TARGET_HANDLE_OPTION ns32k_handle_option\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS ns32k_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST ns32k_address_cost\n-\n-#undef TARGET_STRUCT_VALUE_RTX\n-#define TARGET_STRUCT_VALUE_RTX ns32k_struct_value_rtx\n-\n-#undef TARGET_ARG_PARTIAL_BYTES\n-#define TARGET_ARG_PARTIAL_BYTES ns32k_arg_partial_bytes\n-\n-#undef TARGET_ASM_FILE_START_APP_OFF\n-#define TARGET_ASM_FILE_START_APP_OFF true\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Implement TARGET_HANDLE_OPTION.  */\n-\n-static bool\n-ns32k_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED,\n-\t\t     int value ATTRIBUTE_UNUSED)\n-{\n-  switch (code)\n-    {\n-    case OPT_m32081:\n-      target_flags &= ~MASK_32381;\n-      return true;\n-\n-    case OPT_msoft_float:\n-      target_flags &= ~(MASK_32081 | MASK_32381);\n-      return true;\n-\n-    case OPT_m32332:\n-      target_flags &= ~MASK_32532;\n-      return true;\n-\n-    case OPT_m32032:\n-      target_flags &= ~(MASK_32332 | MASK_32532);\n-      return true;\n-\n-    default:\n-      return true;\n-    }\n-}\n-\f\n-/* Generate the assembly code for function entry.  FILE is a stdio\n-   stream to output the code to.  SIZE is an int: how many units of\n-   temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers to\n-   save; `regs_ever_live[I]' is nonzero if register number I is ever\n-   used in the function.  This function is responsible for knowing\n-   which registers should not be saved even if used.  */\n-\n-/*\n- * The function prologue for the ns32k is fairly simple.\n- * If a frame pointer is needed (decided in reload.c ?) then\n- * we need assembler of the form\n- *\n- *  # Save the oldframe pointer, set the new frame pointer, make space\n- *  # on the stack and save any general purpose registers necessary\n- *\n- *  enter [<general purpose regs to save>], <local stack space>\n- *\n- *  movf  fn, tos    # Save any floating point registers necessary\n- *  .\n- *  .\n- *\n- * If a frame pointer is not needed we need assembler of the form\n- *\n- *  # Make space on the stack\n- *\n- *  adjspd <local stack space + 4>\n- *\n- *  # Save any general purpose registers necessary\n- *\n- *  save [<general purpose regs to save>]\n- *\n- *  movf  fn, tos    # Save any floating point registers necessary\n- *  .\n- *  .\n- */\n-\n-#if !defined (MERLIN_TARGET) && !defined (UTEK_ASM)\n-\n-#if defined(IMMEDIATE_PREFIX) && IMMEDIATE_PREFIX\n-#define ADJSP(FILE, N) \\\n-        fprintf (FILE, \"\\tadjspd %c\" HOST_WIDE_INT_PRINT_DEC \"\\n\", IMMEDIATE_PREFIX, (N))\n-#else\n-#define ADJSP(FILE, N) \\\n-        fprintf (FILE, \"\\tadjspd \" HOST_WIDE_INT_PRINT_DEC \"\\n\", (N))\n-#endif\n-\n-static void\n-ns32k_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n-{\n-  register int regno, g_regs_used = 0;\n-  int used_regs_buf[8], *bufp = used_regs_buf;\n-  int used_fregs_buf[17], *fbufp = used_fregs_buf;\n-\n-  for (regno = R0_REGNUM; regno < F0_REGNUM; regno++)\n-    if (regs_ever_live[regno]\n-\t&& ! call_used_regs[regno])\n-      {\n-        *bufp++ = regno; g_regs_used++;\n-      }\n-  *bufp = -1;\n-\n-  for (; regno < FRAME_POINTER_REGNUM; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\n-      {\n-        *fbufp++ = regno;\n-      }\n-  *fbufp = -1;\n-\n-  bufp = used_regs_buf;\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\tenter [\");\n-  else\n-    {\n-      if (size)\n-        ADJSP (file, size + 4);\n-      if (g_regs_used && g_regs_used > 4)\n-        fprintf (file, \"\\tsave [\");\n-      else\n-\t{\n-\t  while (*bufp >= 0)\n-            fprintf (file, \"\\tmovd r%d,tos\\n\", *bufp++);\n-\t  g_regs_used = 0;\n-\t}\n-    }\n-\n-  while (*bufp >= 0)\n-    {\n-      fprintf (file, \"r%d\", *bufp++);\n-      if (*bufp >= 0)\n-\tfputc (',', file);\n-    }\n-\n-  if (frame_pointer_needed)\n-    fprintf (file, \"],\" HOST_WIDE_INT_PRINT_DEC \"\\n\", size);\n-  else if (g_regs_used)\n-    fprintf (file, \"]\\n\");\n-\n-  fbufp = used_fregs_buf;\n-  while (*fbufp >= 0)\n-    {\n-      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\n-\tfprintf (file, \"\\tmovf %s,tos\\n\", ns32k_out_reg_names[*fbufp++]);\n-      else\n-\t{\n-\t  fprintf (file, \"\\tmovl %s,tos\\n\",\n-\t\t   ns32k_out_reg_names[fbufp[0]]);\n-\t  fbufp += 2;\n-\t}\n-    }\n-\n-  if (flag_pic && current_function_uses_pic_offset_table)\n-    {\n-      fprintf (file, \"\\tsprd sb,tos\\n\");\n-      if (TARGET_REGPARM)\n-\t{\n-\t  fprintf (file, \"\\taddr __GLOBAL_OFFSET_TABLE_(pc),tos\\n\");\n-\t  fprintf (file, \"\\tlprd sb,tos\\n\");\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, \"\\taddr __GLOBAL_OFFSET_TABLE_(pc),r0\\n\");\n-\t  fprintf (file, \"\\tlprd sb,r0\\n\");\n-\t}\n-    }\n-}\n-\n-#else /* MERLIN_TARGET || UTEK_ASM  */\n-\n-/* This differs from the standard one above in printing a bitmask\n-   rather than a register list in the enter or save instruction.  */\n-\n-static void\n-ns32k_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  register int regno, g_regs_used = 0;\n-  int used_regs_buf[8], *bufp = used_regs_buf;\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\n-\n-  for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno]\n-\t&& ! call_used_regs[regno])\n-      {\n-\t*bufp++ = regno; g_regs_used++;\n-      }\n-  *bufp = -1;\n-\n-  for (; regno < 16; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno]) {\n-      *fbufp++ = regno;\n-    }\n-  *fbufp = -1;\n-\n-  bufp = used_regs_buf;\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\tenter \");\n-  else if (g_regs_used)\n-    fprintf (file, \"\\tsave \");\n-\n-  if (frame_pointer_needed || g_regs_used)\n-    {\n-      char mask = 0;\n-      while (*bufp >= 0)\n-\tmask |= 1 << *bufp++;\n-      fprintf (file, \"$0x%x\", (int) mask & 0xff);\n-    }\n-\n-  if (frame_pointer_needed)\n-#ifdef UTEK_ASM\n-    fprintf (file, \",$%d\\n\", size);\n-#else\n-    fprintf (file, \",%d\\n\", size);\n-#endif\n-  else if (g_regs_used)\n-    fprintf (file, \"\\n\");\n-\n-  fbufp = used_fregs_buf;\n-  while (*fbufp >= 0)\n-    {\n-      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\n-\tfprintf (file, \"\\tmovf f%d,tos\\n\", *fbufp++ - 8);\n-      else\n-\t{\n-\t  fprintf (file, \"\\tmovl f%d,tos\\n\", fbufp[0] - 8);\n-\t  fbufp += 2;\n-\t}\n-    }\n-}\n-\n-#endif /* MERLIN_TARGET || UTEK_ASM  */\n-\n-/* This function generates the assembly code for function exit,\n-   on machines that need it.\n-\n-   The function epilogue should not depend on the current stack pointer,\n-   if EXIT_IGNORE_STACK is nonzero.  That doesn't apply here.\n-\n-   If a frame pointer is needed (decided in reload.c ?) then\n-   we need assembler of the form\n-\n-    movf  tos, fn\t# Restore any saved floating point registers\n-    .\n-    .\n-\n-    # Restore any saved general purpose registers, restore the stack\n-    # pointer from the frame pointer, restore the old frame pointer.\n-    exit [<general purpose regs to save>]\n-\n-   If a frame pointer is not needed we need assembler of the form\n-    # Restore any general purpose registers saved\n-\n-    movf  tos, fn\t# Restore any saved floating point registers\n-    .\n-    .\n-    .\n-    restore [<general purpose regs to save>]\n-\n-    # reclaim space allocated on stack\n-\n-    adjspd <-(local stack space + 4)> */\n-\n-#if !defined (MERLIN_TARGET) && !defined (UTEK_ASM)\n-\n-static void\n-ns32k_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n-{\n-  register int regno, g_regs_used = 0, f_regs_used = 0;\n-  int used_regs_buf[8], *bufp = used_regs_buf;\n-  int used_fregs_buf[17], *fbufp = used_fregs_buf;\n-\n-  if (flag_pic && current_function_uses_pic_offset_table)\n-    fprintf (file, \"\\tlprd sb,tos\\n\");\n-\n-  *fbufp++ = -2;\n-  for (regno = F0_REGNUM; regno < FRAME_POINTER_REGNUM; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\n-      {\n-\t*fbufp++ = regno; f_regs_used++;\n-      }\n-  fbufp--;\n-\n-  for (regno = 0; regno < F0_REGNUM; regno++)\n-    if (regs_ever_live[regno]\n-\t&& ! call_used_regs[regno])\n-      {\n-        *bufp++ = regno; g_regs_used++;\n-      }\n-\n-  while (fbufp > used_fregs_buf)\n-    {\n-      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\n-\t{\n-\t  fprintf (file, \"\\tmovl tos,%s\\n\",\n-\t\t   ns32k_out_reg_names[fbufp[-1]]);\n-\t  fbufp -= 2;\n-\t}\n-      else fprintf (file, \"\\tmovf tos,%s\\n\", ns32k_out_reg_names[*fbufp--]);\n-    }\n-\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\texit [\");\n-  else\n-    {\n-      if (g_regs_used && g_regs_used > 4)\n-        fprintf (file, \"\\trestore [\");\n-      else\n-        {\n-\t  while (bufp > used_regs_buf)\n-            fprintf (file, \"\\tmovd tos,r%d\\n\", *--bufp);\n-\t  g_regs_used = 0;\n-        }\n-    }\n-\n-  while (bufp > used_regs_buf)\n-    {\n-      fprintf (file, \"r%d\", *--bufp);\n-      if (bufp > used_regs_buf)\n-\tfputc (',', file);\n-    }\n-\n-  if (g_regs_used || frame_pointer_needed)\n-    fprintf (file, \"]\\n\");\n-\n-  if (size && !frame_pointer_needed)\n-    ADJSP (file, -(size + 4));\n-\n-  if (current_function_pops_args)\n-    fprintf (file, \"\\tret %d\\n\", current_function_pops_args);\n-  else\n-    fprintf (file, \"\\tret 0\\n\");\n-}\n-\n-#else /* MERLIN_TARGET || UTEK_ASM  */\n-\n-/* This differs from the standard one above in printing a bitmask\n-   rather than a register list in the exit or restore instruction.  */\n-\n-static void\n-ns32k_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  register int regno, g_regs_used = 0, f_regs_used = 0;\n-  int used_regs_buf[8], *bufp = used_regs_buf;\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\n-\n-  *fbufp++ = -2;\n-  for (regno = 8; regno < 16; regno++)\n-    if (regs_ever_live[regno] && !call_used_regs[regno]) {\n-      *fbufp++ = regno; f_regs_used++;\n-    }\n-  fbufp--;\n-\n-  for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno]\n-\t&& ! call_used_regs[regno])\n-      {\n-\t*bufp++ = regno; g_regs_used++;\n-      }\n-\n-  while (fbufp > used_fregs_buf)\n-    {\n-      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\n-\t{\n-\t  fprintf (file, \"\\tmovl tos,f%d\\n\", fbufp[-1] - 8);\n-\t  fbufp -= 2;\n-\t}\n-      else fprintf (file, \"\\tmovf tos,f%d\\n\", *fbufp-- - 8);\n-    }\n-\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\texit \");\n-  else if (g_regs_used)\n-    fprintf (file, \"\\trestore \");\n-\n-  if (g_regs_used || frame_pointer_needed)\n-    {\n-      char mask = 0;\n-\n-      while (bufp > used_regs_buf)\n-\t{\n-\t  /* Utek assembler takes care of reversing this */\n-\t  mask |= 1 << *--bufp;\n-\t}\n-      fprintf (file, \"$0x%x\\n\", (int) mask & 0xff);\n-    }\n-\n-#ifdef UTEK_ASM\n-  if (current_function_pops_args)\n-    fprintf (file, \"\\tret $%d\\n\", current_function_pops_args);\n-  else\n-    fprintf (file, \"\\tret $0\\n\");\n-#else\n-  if (current_function_pops_args)\n-    fprintf (file, \"\\tret %d\\n\", current_function_pops_args);\n-  else\n-    fprintf (file, \"\\tret 0\\n\");\n-#endif\n-}\n-\n-#endif /* MERLIN_TARGET || UTEK_ASM  */\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */ \n-int\n-hard_regno_mode_ok (int regno, enum machine_mode mode)\n-{\n-  int size = GET_MODE_UNIT_SIZE (mode);\n-\n-  if (FLOAT_MODE_P (mode))\n-    {\n-      if (size == UNITS_PER_WORD && regno < L1_REGNUM)\n-\treturn 1;\n-      if (size == UNITS_PER_WORD * 2\n-\t  && (((regno & 1) == 0 && regno < FRAME_POINTER_REGNUM)))\n-\treturn 1;\n-      return 0;\n-    }\n-  if (size == UNITS_PER_WORD * 2\n-      && (regno & 1) == 0 && regno < F0_REGNUM)\n-    return 1;\n-  if (size <= UNITS_PER_WORD\n-      && (regno < F0_REGNUM || regno == FRAME_POINTER_REGNUM\n-\t  || regno == STACK_POINTER_REGNUM))\n-    return 1;\n-  return 0;\n-}\n-\n-static bool\n-ns32k_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total)\n-{\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if (INTVAL (x) <= 7 && INTVAL (x) >= -8)\n-\t*total = 0;\n-      else if (INTVAL (x) < 0x2000 && INTVAL (x) >= -0x2000)\n-        *total = 1;\n-      else\n-\t*total = 3;\n-      return true;\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = 3;\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      *total = 5;\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-int\n-register_move_cost (enum reg_class CLASS1, enum reg_class CLASS2)\n-{\n-  if (CLASS1 == NO_REGS || CLASS2 == NO_REGS)\n-    return 2;\n-  if ((SUBSET_P (CLASS1, FP_REGS) && !SUBSET_P (CLASS2, FP_REGS))\n-   || (!SUBSET_P (CLASS1, FP_REGS) && SUBSET_P (CLASS2, FP_REGS)))\n-    return 8;\n-  if (((CLASS1) == STACK_POINTER_REG && !SUBSET_P (CLASS2,GENERAL_REGS))\n-      || ((CLASS2) == STACK_POINTER_REG && !SUBSET_P (CLASS1,GENERAL_REGS)))\n-    return 6;\n-  if (((CLASS1) == FRAME_POINTER_REG && !SUBSET_P (CLASS2,GENERAL_REGS))\n-      || ((CLASS2) == FRAME_POINTER_REG && !SUBSET_P (CLASS1,GENERAL_REGS)))\n-    return 6;\n-  return 2;\n-}\n-\n-#if 0\n-/* We made the insn definitions copy from floating point to general\n-  registers via the stack.  */\n-int\n-secondary_memory_needed (enum reg_class CLASS1,\n-\t\t\t enum reg_class CLASS2,\n-\t\t\t enum machine_mode M)\n-{\n-  int ret = ((SUBSET_P (CLASS1, FP_REGS) && !SUBSET_P (CLASS2, FP_REGS))\n-   || (!SUBSET_P (CLASS1, FP_REGS) && SUBSET_P (CLASS2, FP_REGS)));\n-  return ret;\n-}\n-#endif\n-    \n-\n-/* TARGET_ADDRESS_COST calls this.  This function is not optimal\n-   for the 32032 & 32332, but it probably is better than\n-   the default.  */\n-\n-static int\n-ns32k_address_cost (rtx operand)\n-{\n-  int cost = 0;\n-\n-  switch (GET_CODE (operand))\n-    {\n-    case REG:\n-      cost += 1;\n-      break;\n-\n-    case POST_DEC:\n-    case PRE_DEC:\n-      break;\n-\n-    case CONST_INT:\n-      if (INTVAL (operand) <= 7 && INTVAL (operand) >= -8)\n-\tbreak;\n-      if (INTVAL (operand) < 0x2000 && INTVAL (operand) >= -0x2000)\n-\t{\n-\t  cost +=1;\n-\t  break;\n-\t}\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      cost +=3;\n-      break;\n-    case CONST_DOUBLE:\n-      cost += 5;\n-      break;\n-\n-    case MEM:\n-      cost += ns32k_address_cost (XEXP (operand, 0)) + 3;\n-      break;\n-\n-    case MULT:\n-      cost += 2;\n-      /* FALLTHRU */\n-    case PLUS:\n-      cost += ns32k_address_cost (XEXP (operand, 0));\n-      cost += ns32k_address_cost (XEXP (operand, 1));\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return cost;\n-}\n-\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-enum reg_class\n-secondary_reload_class (enum reg_class class,\n-\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\trtx in)\n-{\n-  int regno = true_regnum (in);\n-\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    regno = -1;\n-\n-  if ((class == FRAME_POINTER_REG && regno == STACK_POINTER_REGNUM)\n-      || ( class == STACK_POINTER_REG && regno == FRAME_POINTER_REGNUM))\n-    return GENERAL_REGS;\n-  else\n-    return NO_REGS;\n-}\n-\n-/* Generate the rtx that comes from an address expression in the md file */\n-/* The expression to be build is BASE[INDEX:SCALE].  To recognize this,\n-   scale must be converted from an exponent (from ASHIFT) to a\n-   multiplier (for MULT). */\n-\n-static rtx\n-gen_indexed_expr (rtx base, rtx index, rtx scale)\n-{\n-  rtx addr;\n-\n-  /* This generates an invalid addressing mode, if BASE is\n-     fp or sp.  This is handled by PRINT_OPERAND_ADDRESS.  */\n-  if (GET_CODE (base) != REG && GET_CODE (base) != CONST_INT)\n-    base = gen_rtx_MEM (SImode, base);\n-  addr = gen_rtx_MULT (SImode, index,\n-\t\t       GEN_INT (1 << INTVAL (scale)));\n-  addr = gen_rtx_PLUS (SImode, base, addr);\n-  return addr;\n-}\n-\n-\f\n-/* Split one or more DImode RTL references into pairs of SImode\n-   references.  The RTL can be REG, offsettable MEM, integer constant, or\n-   CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n-   split and \"num\" is its length.  lo_half and hi_half are output arrays\n-   that parallel \"operands\". */\n-\n-void\n-split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n-{\n-  while (num--)\n-    {\n-      if (GET_CODE (operands[num]) == REG)\n-\t{\n-\t  lo_half[num] = gen_rtx_REG (SImode, REGNO (operands[num]));\n-\t  hi_half[num] = gen_rtx_REG (SImode, REGNO (operands[num]) + 1);\n-\t}\n-      else if (CONSTANT_P (operands[num]))\n-\t{\n-\t  split_double (operands[num], &lo_half[num], &hi_half[num]);\n-\t}\n-      else if (offsettable_memref_p (operands[num]))\n-\t{\n-\t  lo_half[num] = operands[num];\n-\t  hi_half[num] = adjust_address (operands[num], SImode, 4);\n-\t}\n-      else\n-\tabort ();\n-    }\n-}\n-\f\n-/* Return the best assembler insn template\n-   for moving operands[1] into operands[0] as a fullword.  */\n-\n-static const char *\n-singlemove_string (rtx *operands)\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && INTVAL (operands[1]) <= 7\n-      && INTVAL (operands[1]) >= -8)\n-    return \"movqd %1,%0\";\n-  return \"movd %1,%0\";\n-}\n-\n-const char *\n-output_move_double (rtx *operands)\n-{\n-  enum anon1 { REGOP, OFFSOP, PUSHOP, CNSTOP, RNDOP } optype0, optype1;\n-  rtx latehalf[2];\n-\n-  /* First classify both operands.  */\n-\n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    optype0 = PUSHOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1])\n-\t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n-    optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n-    optype1 = PUSHOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  if (optype0 == RNDOP || optype1 == RNDOP)\n-    abort ();\n-\n-  /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-\n-     In either case, set up in LATEHALF the operands to use\n-     for the high-numbered word and in some cases alter the\n-     operands in OPERANDS to be suitable for the low-numbered word.  */\n-\n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adjust_address (operands[0], SImode, 4);\n-  else\n-    latehalf[0] = operands[0];\n-\n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adjust_address (operands[1], SImode, 4);\n-  else if (optype1 == CNSTOP)\n-    split_double (operands[1], &operands[1], &latehalf[1]);\n-  else\n-    latehalf[1] = operands[1];\n-\n-  /* If insn is effectively movd N(sp),tos then we will do the\n-     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n-     for the low word as well, to compensate for the first decrement of sp.\n-     Given this, it doesn't matter which half we do \"first\".  */\n-  if (optype0 == PUSHOP\n-      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n-      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n-    operands[1] = latehalf[1];\n-\n-  /* If one or both operands autodecrementing,\n-     do the two words, high-numbered first.  */\n-  else if (optype0 == PUSHOP || optype1 == PUSHOP)\n-    {\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-      return singlemove_string (operands);\n-    }\n-\n-  /* If the first move would clobber the source of the second one,\n-     do them in the other order.  */\n-\n-  /* Overlapping registers.  */\n-  if (optype0 == REGOP && optype1 == REGOP\n-      && REGNO (operands[0]) == REGNO (latehalf[1]))\n-    {\n-      /* Do that word.  */\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-      /* Do low-numbered word.  */\n-      return singlemove_string (operands);\n-    }\n-  /* Loading into a register which overlaps a register used in the address.  */\n-  else if (optype0 == REGOP && optype1 != REGOP\n-\t   && reg_overlap_mentioned_p (operands[0], operands[1]))\n-    {\n-      if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n-\t  && reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n-\t{\n-\t  /* If both halves of dest are used in the src memory address,\n-\t     load the destination address into the low reg (operands[0]).\n-\t     Then it works to load latehalf first.  */\n-\t  rtx xops[2];\n-\t  xops[0] = XEXP (operands[1], 0);\n-\t  xops[1] = operands[0];\n-\t  output_asm_insn (\"addr %a0,%1\", xops);\n-\t  operands[1] = gen_rtx_MEM (DImode, operands[0]);\n-\t  latehalf[1] = adjust_address (operands[1], SImode, 4);\n-\t  /* The first half has the overlap, Do the late half first.  */\n-\t  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\t  /* Then clobber.  */\n-\t  return singlemove_string (operands);\n-\t}\n-      if (reg_mentioned_p (operands[0], XEXP (operands[1], 0)))\n-\t{\n-\t  /* The first half has the overlap, Do the late half first.  */\n-\t  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\t  /* Then clobber.  */\n-\t  return singlemove_string (operands);\n-\t}\n-    }\n-\n-  /* Normal case.  Do the two words, low-numbered first.  */\n-\n-  output_asm_insn (singlemove_string (operands), operands);\n-\n-  operands[0] = latehalf[0];\n-  operands[1] = latehalf[1];\n-  return singlemove_string (operands);\n-}\n-\n-\f\n-#define MAX_UNALIGNED_COPY (32)\n-/* Expand string/block move operations.\n-\n-   operands[0] is the pointer to the destination.\n-   operands[1] is the pointer to the source.\n-   operands[2] is the number of bytes to move.\n-   operands[3] is the alignment.  */\n-\n-static void\n-move_tail (rtx operands[], int bytes, int offset)\n-{\n-  if (bytes & 2)\n-    {\n-      emit_move_insn (adjust_address (operands[0], HImode, offset),\n-\t\t      adjust_address (operands[1], HImode, offset));\n-      offset += 2;\n-    }\n-  if (bytes & 1)\n-    emit_move_insn (adjust_address (operands[0], QImode, offset),\n-\t\t    adjust_address (operands[1], QImode, offset));\n-}\n-\n-void\n-expand_block_move (rtx operands[])\n-{\n-  rtx bytes_rtx\t= operands[2];\n-  rtx align_rtx = operands[3];\n-  int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n-  int bytes\t= (constp ? INTVAL (bytes_rtx) : 0);\n-  int align\t= INTVAL (align_rtx);\n-  rtx src_reg = gen_rtx_REG (Pmode, 1);\n-  rtx dest_reg = gen_rtx_REG (Pmode, 2);\n-  rtx count_reg = gen_rtx_REG (SImode, 0);\n-\n-  if (constp && bytes <= 0)\n-    return;\n-\n-  if (constp && bytes < 20)\n-    {\n-      int words = bytes >> 2;\n-\n-      if (words)\n-\t{\n-\t  if (words < 3)\n-\t    {\n-\t      int offset = 0;\n-\n-\t      for (; words; words--, offset += 4)\n-\t\temit_move_insn (adjust_address (operands[0], SImode, offset),\n-\t\t\t\tadjust_address (operands[1], SImode, offset));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Use movmd. It is slower than multiple movd's but more\n-\t\t compact. It is also slower than movsd for large copies\n-\t\t but causes less registers reloading so is better than movsd\n-\t\t for small copies.  */\n-\t      rtx src, dest;\n-\t      dest = copy_addr_to_reg (XEXP (operands[0], 0));\n-\t      src = copy_addr_to_reg (XEXP (operands[1], 0));\n-\t    \n-\t      emit_insn (gen_movmemsi2(dest, src, GEN_INT (words)));\n-\t    }\n-\t}\n-      move_tail (operands, bytes & 3, bytes & ~3);\n-      return;\n-    }\n-\n-  if (align > UNITS_PER_WORD)\n-    align = UNITS_PER_WORD;\n-\n-  /* Move the address into scratch registers.  */\n-  emit_insn (gen_rtx_CLOBBER (VOIDmode, dest_reg));\n-  emit_move_insn (dest_reg, XEXP (operands[0], 0));\n-  operands[0] = gen_rtx_MEM (SImode, dest_reg);\n-  emit_insn (gen_rtx_CLOBBER (VOIDmode, src_reg));\n-  emit_move_insn (src_reg, XEXP (operands[1], 0));\n-  operands[1] = gen_rtx_MEM (SImode, src_reg);\n-  emit_insn (gen_rtx_CLOBBER (VOIDmode, count_reg));\n-\n-  if (constp && (align == UNITS_PER_WORD || bytes < MAX_UNALIGNED_COPY))\n-    {\n-      /* constant no of bytes and aligned or small enough copy to not bother\n-       * aligning. Emit insns to copy by words.\n-       */\n-      if (bytes >> 2)\n-\t{\n-\t  emit_move_insn (count_reg, GEN_INT (bytes >> 2));\n-\t  emit_insn (gen_movmemsi1 (GEN_INT (4)));\n-\t}\n-      /* insns to copy rest */\n-      move_tail (operands, bytes & 3, 0);\n-    }\n-  else if (align == UNITS_PER_WORD)\n-    {\n-      /* insns to copy by words */\n-      emit_insn (gen_lshrsi3 (count_reg, bytes_rtx, const2_rtx));\n-      emit_insn (gen_movmemsi1 (GEN_INT (4)));\n-      if (constp)\n-\t{\n-\t  move_tail (operands, bytes & 3, 0);\n-\t}\n-      else\n-\t{\n-\t  /* insns to copy rest */\n-\t  emit_insn (gen_andsi3 (count_reg, bytes_rtx, GEN_INT (3)));\n-\t  emit_insn (gen_movmemsi1 (const1_rtx));\n-\t}\n-    }\n-  else\n-    {\n-      /* Not aligned and we may have a lot to copy so it is worth\n-       * aligning.\n-       */\n-      rtx aligned_label = gen_label_rtx ();\n-      rtx bytes_reg;\n-\n-      bytes_reg = copy_to_mode_reg (SImode, bytes_rtx);\n-      if (!constp)\n-\t{\n-\t  /* Emit insns to test and skip over the alignment if it is\n-\t   * not worth it. This doubles as a test to ensure that the alignment\n-\t   * operation can't copy too many bytes\n-\t   */\n-\t  emit_insn (gen_cmpsi (bytes_reg, GEN_INT (MAX_UNALIGNED_COPY)));\n-\t  emit_jump_insn (gen_blt (aligned_label));\n-\t}\n-\n-      /* Emit insns to do alignment at run time */\n-      emit_insn (gen_negsi2 (count_reg, src_reg));\n-      emit_insn (gen_andsi3 (count_reg, count_reg, GEN_INT (3)));\n-      emit_insn (gen_subsi3 (bytes_reg, bytes_reg, count_reg));\n-      emit_insn (gen_movmemsi1 (const1_rtx));\n-      if (!constp)\n-\temit_label (aligned_label);\n-\n-      /* insns to copy by words */\n-      emit_insn (gen_lshrsi3 (count_reg, bytes_reg, const2_rtx));\n-      emit_insn (gen_movmemsi1 (GEN_INT (4)));\n-\n-      /* insns to copy rest */\n-      emit_insn (gen_andsi3 (count_reg, bytes_reg, GEN_INT (3)));\n-      emit_insn (gen_movmemsi1 (const1_rtx));\n-    }\n-}\n-\f\n-\n-/* Returns 1 if OP contains a global symbol reference */\n-\n-int\n-global_symbolic_reference_mentioned_p (rtx op, int f)\n-{\n-  register const char *fmt;\n-  register int i;\n-\n-  if (GET_CODE (op) == SYMBOL_REF)\n-    {\n-      if (! SYMBOL_REF_LOCAL_P (op))\n-\treturn 1;\n-      else\n-        return 0;\n-    }\n-  else if (f && GET_CODE (op) != CONST)\n-    return 0;\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (op));\n-  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\n-\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n-\t    if (global_symbolic_reference_mentioned_p (XVECEXP (op, i, j), 0))\n-\t      return 1;\n-\t}\n-      else if (fmt[i] == 'e' \n-\t       && global_symbolic_reference_mentioned_p (XEXP (op, i), 0))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-\f\n-/* Returns 1 if OP contains a symbol reference */\n-\n-int\n-symbolic_reference_mentioned_p (rtx op)\n-{\n-  register const char *fmt;\n-  register int i;\n-\n-  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (op));\n-  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\n-\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n-\t    if (symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n-\t      return 1;\n-\t}\n-      else if (fmt[i] == 'e' && symbolic_reference_mentioned_p (XEXP (op, i)))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\f\n-/* Table of machine-specific attributes.  */\n-\n-const struct attribute_spec ns32k_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  /* Stdcall attribute says callee is responsible for popping arguments\n-     if they are not variable.  */\n-  { \"stdcall\", 0, 0, false, true,  true,  ns32k_handle_fntype_attribute },\n-  /* Cdecl attribute says the callee is a normal C declaration */\n-  { \"cdecl\",   0, 0, false, true,  true,  ns32k_handle_fntype_attribute },\n-  { NULL,      0, 0, false, false, false, NULL }\n-};\n-\n-/* Handle an attribute requiring a FUNCTION_TYPE, FIELD_DECL or TYPE_DECL;\n-   arguments as in struct attribute_spec.handler.  */\n-static tree\n-ns32k_handle_fntype_attribute (tree *node, tree name,\n-\t\t\t       tree args ATTRIBUTE_UNUSED,\n-\t\t\t       int flags ATTRIBUTE_UNUSED,\n-\t\t\t       bool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) != FUNCTION_TYPE\n-      && TREE_CODE (*node) != FIELD_DECL\n-      && TREE_CODE (*node) != TYPE_DECL)\n-    {\n-      warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n-\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-\f\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.\n-\n-   On the ns32k, the RET insn may be used to pop them if the number\n-     of args is fixed, but if the number is variable then the caller\n-     must pop them all.  RET can't be used for library calls now\n-     because the library is compiled with the Unix compiler.\n-   Use of RET is a selectable option, since it is incompatible with\n-   standard Unix calling sequences.  If the option is not selected,\n-   the caller must always pop the args.\n-\n-   The attribute stdcall is equivalent to RET on a per module basis.  */\n-\n-int\n-ns32k_return_pops_args (tree fundecl ATTRIBUTE_UNUSED, tree funtype, int size)\n-{\n-  int rtd = TARGET_RTD;\n-\n-  if (TREE_CODE (funtype) == IDENTIFIER_NODE)\n-    return rtd ? size : 0;\n-\n-  /* Cdecl functions override -mrtd, and never pop the stack */\n-  if (lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (funtype)))\n-    return 0;\n-\n-  /* Stdcall functions will pop the stack if not variable args */\n-  if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (funtype)))\n-    rtd = 1;\n-\n-  if (rtd)\n-    {\n-      if (TYPE_ARG_TYPES (funtype) == NULL_TREE\n-\t  || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (funtype))) == void_type_node))\n-\treturn size;\n-    }\n-\n-  return 0;\n-}\n-\f\n-/* PRINT_OPERAND is defined to call this function,\n-   which is easier to debug than putting all the code in\n-   a macro definition in ns32k.h.  */\n-\n-/* XXX time 12% of cpu time is in fprintf for non optimizing */\n-void\n-print_operand (FILE *file, rtx x, int code)\n-{\n-  if (code == '$')\n-    PUT_IMMEDIATE_PREFIX (file);\n-  else if (code == '?')\n-    PUT_EXTERNAL_PREFIX (file);\n-  else if (GET_CODE (x) == REG)\n-    fprintf (file, \"%s\", ns32k_out_reg_names[REGNO (x)]);\n-  else if (GET_CODE (x) == MEM)\n-    {\n-      output_address (XEXP (x, 0));\n-    }\n-  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n-    {\n-      REAL_VALUE_TYPE r;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-      PUT_IMMEDIATE_PREFIX (file);\n-      if (GET_MODE (x) == DFmode)\n-\t{ \n-#ifdef SEQUENT_ASM\n-\t  /* Sequent likes its floating point constants as integers */\n-\t  long l[2];\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-\t  fprintf (file, \"0Dx%08x%08x\",\n-\t\t   l[!WORDS_BIG_ENDIAN], l[WORDS_BIG_ENDIAN]);\n-#else\n-\t  char s[30];\n-\t  real_to_decimal (s, &r, sizeof (s), 0, 1);\n-#ifdef ENCORE_ASM\n-\t  fprintf (file, \"0f%s\", s);\n-#else\n-\t  fprintf (file, \"0d%s\", s);\n-#endif\n-#endif\n-\t}\n-      else\n-\t{\n-#ifdef SEQUENT_ASM\n-\t  long l;\n-\t  REAL_VALUE_TO_TARGET_SINGLE (r, l);\n-\t  fprintf (file, \"0Fx%08lx\", l);\n-#else\n-\t  char s[30];\n-\t  real_to_decimal (s, &r, sizeof (s), 0, 1);\n-\t  fprintf (file, \"0f%s\", s);\n-#endif\n-\t}\n-    }\n-  else\n-    {\n-      if (flag_pic\n-          && GET_CODE (x) == CONST\n-          && symbolic_reference_mentioned_p (x))\n-        {\n-\t  fprintf (stderr, \"illegal constant for pic-mode: \\n\");\n-\t  print_rtl (stderr, x);\n-          fprintf (stderr, \"\\nGET_CODE (x) == %d, CONST == %d, symbolic_reference_mentioned_p (x) == %d\\n\",\n-\t\t  GET_CODE (x), CONST, symbolic_reference_mentioned_p (x));\n-\t  abort ();\n-\t}\n-      else if (flag_pic\n-               && (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF))\n-\t{\n-\t  output_addr_const (file, x);\n-\t  fprintf (file, \"(sb)\");\n-\t}\n-      else\n-        {\n-#ifdef NO_IMMEDIATE_PREFIX_IF_SYMBOLIC\n-          if (GET_CODE (x) == CONST_INT)\n-#endif\n-\t    PUT_IMMEDIATE_PREFIX (file);\n-          output_addr_const (file, x);\n-\t}\n-    }\n-}\n-\f\n-/* PRINT_OPERAND_ADDRESS is defined to call this function,\n-   which is easier to debug than putting all the code in\n-   a macro definition in ns32k.h .  */\n-\n-/* Completely rewritten to get this to work with Gas for PC532 Mach.\n-   This function didn't work and I just wasn't able (nor very willing) to\n-   figure out how it worked.\n-   90-11-25 Tatu Yl|nen <ylo@cs.hut.fi> */\n-\n-void\n-print_operand_address (register FILE *file, register rtx addr)\n-{\n-  static const char scales[] = { 'b', 'w', 'd', 0, 'q', };\n-  rtx offset, base, indexexp, tmp;\n-  int scale;\n-  extern int flag_pic;\n-\n-  if (GET_CODE (addr) == PRE_DEC || GET_CODE (addr) == POST_DEC)\n-    {\n-      fprintf (file, \"tos\");\n-      return;\n-    }\n-\n-  offset = NULL;\n-  base = NULL;\n-  indexexp = NULL;\n-  while (addr != NULL)\n-    {\n-      if (GET_CODE (addr) == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (addr, 0)) == PLUS)\n-\t    {\n-\t      tmp = XEXP (addr, 1);\n-\t      addr = XEXP (addr, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      tmp = XEXP (addr,0);\n-\t      addr = XEXP (addr,1);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  tmp = addr;\n-\t  addr = NULL;\n-\t}\n-      switch (GET_CODE (tmp))\n-\t{\n-\tcase PLUS:\n-\t  abort ();\n-\tcase MEM:\n-\t  if (base)\n-\t    {\n-\t      indexexp = base;\n-\t      base = tmp;\n-\t    }\n-\t  else\n-\t    base = tmp;\n-\t  break;\n-\tcase REG:\n-\t  if (REGNO (tmp) < F0_REGNUM)\n-\t    if (base)\n-\t      {\n-\t\tindexexp = tmp;\n-\t      }\n-\t    else\n-\t      base = tmp;\n-\t  else\n-\t    if (base)\n-\t      {\n-\t\tindexexp = base;\n-\t\tbase = tmp;\n-\t      }\n-\t    else\n-\t      base = tmp;\n-\t  break;\n-\tcase MULT:\n-\t  indexexp = tmp;\n-\t  break;\n-\tcase SYMBOL_REF:\n-\t  if (flag_pic && ! SYMBOL_REF_LOCAL_P (tmp))\n-\t    {\n-\t      if (base)\n-\t\t{\n-\t\t  if (indexexp)\n-\t\t    abort ();\n-\t\t  indexexp = base;\n-\t\t}\n-\t      base = tmp;\n-\t      break;\n-\t    }\n-\tcase CONST:\n-\t  if (flag_pic && GET_CODE (tmp) == CONST)\n-\t    {\n-\t      rtx sym, off, tmp1;\n-\t      tmp1 = XEXP (tmp,0);\n-\t      if (GET_CODE (tmp1)  != PLUS)\n-\t\tabort ();\n-\n-\t      sym = XEXP (tmp1,0);\n-\t      if (GET_CODE (sym) != SYMBOL_REF)\n-\t        {\n-\t          off = sym;\n-\t\t  sym = XEXP (tmp1,1);\n-\t\t}\n-\t      else\n-\t        off = XEXP (tmp1,1);\n-\t      if (GET_CODE (sym) == SYMBOL_REF)\n-\t\t{\n-\t\t  if (GET_CODE (off) != CONST_INT)\n-\t\t    abort ();\n-\n-\t\t  if (! SYMBOL_REF_LOCAL_P (sym))\n-\t\t    {\n-\t\t      if (base)\n-\t\t\t{\n-\t\t\t  if (indexexp)\n-\t\t\t    abort ();\n-\n-\t\t\t  indexexp = base;\n-\t\t\t}\n-\n-\t\t      if (offset != 0)\n-\t\t\tabort ();\n-\n-\t\t      base = sym;\n-\t\t      offset = off;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\tcase CONST_INT:\n-\tcase LABEL_REF:\n-\t  if (offset)\n-\t    offset = gen_rtx_PLUS (SImode, tmp, offset);\n-\t  else\n-\t    offset = tmp;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  if (! offset)\n-    offset = const0_rtx;\n-\n-  if (base\n-#ifndef INDEX_RATHER_THAN_BASE\n-      && (flag_pic || TARGET_HIMEM)\n-      && GET_CODE (base) != SYMBOL_REF \n-      && GET_CODE (offset) != CONST_INT\n-#else\n-  /* This is a re-implementation of the SEQUENT_ADDRESS_BUG fix.  */\n-#endif\n-      && !indexexp && GET_CODE (base) == REG\n-      && REG_OK_FOR_INDEX_P (base))\n-    {\n-      indexexp = base;\n-      base = NULL;\n-    }\n-\n-  /* now, offset, base and indexexp are set */\n-#ifndef BASE_REG_NEEDED\n-  if (! base)\n-    {\n-#if defined (PC_RELATIVE) || defined (NO_ABSOLUTE_PREFIX_IF_SYMBOLIC)\n-      if (GET_CODE (offset) == CONST_INT)\n-#endif\n-\tPUT_ABSOLUTE_PREFIX (file);\n-    }\n-#endif\n-\n-  output_addr_const (file, offset);\n-  if (base) /* base can be (REG ...) or (MEM ...) */\n-    switch (GET_CODE (base))\n-      {\n-\t/* now we must output base.  Possible alternatives are:\n-\t   (rN)       (REG ...)\n-\t   (sp)\t      (REG ...)\n-\t   (fp)       (REG ...)\n-\t   (pc)       (REG ...)  used for SYMBOL_REF and LABEL_REF, output\n-\t   (disp(fp)) (MEM ...)       just before possible [rX:y]\n-\t   (disp(sp)) (MEM ...)\n-\t   (disp(sb)) (MEM ...)\n-\t   */\n-      case REG:\n-\tfprintf (file, \"(%s)\", ns32k_out_reg_names[REGNO (base)]);\n-\tbreak;\n-      case SYMBOL_REF:\n-\tif (! flag_pic)\n-\t  abort ();\n-\n-        fprintf (file, \"(\");\n-\toutput_addr_const (file, base);\n-\tfprintf (file, \"(sb))\");\n-        break;\n-      case MEM:\n-\taddr = XEXP (base,0);\n-\tbase = NULL;\n-\toffset = NULL;\n-\twhile (addr != NULL)\n-\t  {\n-\t    if (GET_CODE (addr) == PLUS)\n-\t      {\n-\t\tif (GET_CODE (XEXP (addr, 0)) == PLUS)\n-\t\t  {\n-\t\t    tmp = XEXP (addr, 1);\n-\t\t    addr = XEXP (addr, 0);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    tmp = XEXP (addr, 0);\n-\t\t    addr = XEXP (addr, 1);\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\ttmp = addr;\n-\t\taddr = NULL;\n-\t      }\n-\t    switch (GET_CODE (tmp))\n-\t      {\n-\t      case REG:\n-\t\tbase = tmp;\n-\t\tbreak;\n-\t      case CONST:\n-\t      case CONST_INT:\n-\t      case SYMBOL_REF:\n-\t      case LABEL_REF:\n-\t\tif (offset)\n-\t\t  offset = gen_rtx_PLUS (SImode, tmp, offset);\n-\t\telse\n-\t\t  offset = tmp;\n-\t\tbreak;\n-\t      default:\n-\t\tabort ();\n-\t      }\n-\t  }\n-\tif (! offset)\n-\t  offset = const0_rtx;\n-\tfprintf (file, \"(\");\n-\toutput_addr_const (file, offset);\n-\tif (base)\n-\t  fprintf (file, \"(%s)\", ns32k_out_reg_names[REGNO (base)]);\n-\telse if (TARGET_SB)\n-\t  fprintf (file, \"(sb)\");\n-\telse\n-\t  abort ();\n-\tfprintf (file, \")\");\n-\tbreak;\n-      default:\n-\tabort ();\n-      }\n-#ifdef PC_RELATIVE\n-  else if (GET_CODE (offset) != CONST_INT)\n-    fprintf (file, \"(pc)\");\n-#ifdef BASE_REG_NEEDED\n-  else if (TARGET_SB)\n-    fprintf (file, \"(sb)\");\n-  else\n-    abort ();\n-#endif\n-#endif /* PC_RELATIVE */\n-\n-  /* now print index if we have one */\n-  if (indexexp)\n-    {\n-      if (GET_CODE (indexexp) == MULT)\n-\t{\n-\t  scale = INTVAL (XEXP (indexexp, 1)) >> 1;\n-\t  indexexp = XEXP (indexexp, 0);\n-\t}\n-      else\n-\tscale = 0;\n-      if (GET_CODE (indexexp) != REG || REGNO (indexexp) >= F0_REGNUM)\n-\tabort ();\n-\n-#ifdef UTEK_ASM\n-      fprintf (file, \"[%c`%s]\",\n-\t       scales[scale],\n-\t       ns32k_out_reg_names[REGNO (indexexp)]);\n-#else\n-      fprintf (file, \"[%s:%c]\",\n-\t       ns32k_out_reg_names[REGNO (indexexp)],\n-\t       scales[scale]);\n-#endif\n-    }\n-}\n-\f\n-/* National 32032 shifting is so bad that we can get\n-   better performance in many common cases by using other\n-   techniques.  */\n-const char *\n-output_shift_insn (rtx *operands)\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) > 0\n-      && INTVAL (operands[2]) <= 3)\n-    {\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    {\n-\t      if (REGNO (operands[0]) == REGNO (operands[1]))\n-\t\t{\n-\t\t  if (operands[2] == const1_rtx)\n-\t\t    return \"addd %0,%0\";\n-\t\t  else if (INTVAL (operands[2]) == 2)\n-\t\t    return \"addd %0,%0\\n\\taddd %0,%0\";\n-\t\t}\n-\t      if (operands[2] == const1_rtx)\n-\t\treturn \"movd %1,%0\\n\\taddd %0,%0\";\n-\t    \n-\t      operands[1] = gen_indexed_expr (const0_rtx, operands[1], operands[2]);\n-\t      return \"addr %a1,%0\";\n-\t    }\n-\t  if (operands[2] == const1_rtx)\n-\t    return \"movd %1,%0\\n\\taddd %0,%0\";\n-\t}\n-      else if (GET_CODE (operands[1]) == REG)\n-\t{\n-\t  operands[1] = gen_indexed_expr (const0_rtx, operands[1], operands[2]);\n-\t  return \"addr %a1,%0\";\n-\t}\n-      else if (INTVAL (operands[2]) == 1\n-\t       && GET_CODE (operands[1]) == MEM\n-\t       && rtx_equal_p (operands [0], operands[1]))\n-\t{\n-\t  rtx temp = XEXP (operands[1], 0);\n-\t\n-\t  if (GET_CODE (temp) == REG\n-\t      || (GET_CODE (temp) == PLUS\n-\t\t  && GET_CODE (XEXP (temp, 0)) == REG\n-\t\t  && GET_CODE (XEXP (temp, 1)) == CONST_INT))\n-\t    return \"addd %0,%0\";\n-\t}\n-      else return \"ashd %2,%0\";\n-    }\n-  return \"ashd %2,%0\";\n-}\n-\n-const char *\n-output_move_dconst (int n, const char *s)\n-{\n-  static char r[32];\n-\n-  if (n > -9 && n < 8)\n-    strcpy (r, \"movqd \");\n-  else if (n > 0 && n < 256)\n-    strcpy (r, \"movzbd \");\n-  else if (n > 0 && n < 65536)\n-    strcpy (r, \"movzwd \");\n-  else if (n < 0 && n > -129)\n-    strcpy (r, \"movxbd \");\n-  else if (n < 0 && n > -32769)\n-    strcpy (r, \"movxwd \");\n-  else\n-    strcpy (r, \"movd \");\n-  strcat (r, s);\n-  return r;\n-}\n-\n-static rtx\n-ns32k_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n-\t\t\tint incoming ATTRIBUTE_UNUSED)\n-{\n-  return gen_rtx_REG (Pmode, NS32K_STRUCT_VALUE_REGNUM);\n-}\n-\n-/* Worker function for NOTICE_UPDATE_CC.  */\n-\n-void\n-ns32k_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (exp) == SET)\n-    {\n-      if (GET_CODE (SET_DEST (exp)) == CC0)\n-\t{\n-\t  cc_status.flags = 0;\n-\t  cc_status.value1 = SET_DEST (exp);\n-\t  cc_status.value2 = SET_SRC (exp);\n-\t}\n-      else if (GET_CODE (SET_SRC (exp)) == CALL)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t}\n-      else if (GET_CODE (SET_DEST (exp)) == REG)\n-\t{\n-\t  if (cc_status.value1\n-\t      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1))\n-\t    cc_status.value1 = 0;\n-\t  if (cc_status.value2\n-\t      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2))\n-\t    cc_status.value2 = 0;\n-\t}\n-      else if (GET_CODE (SET_DEST (exp)) == MEM)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t}\n-    }\n-  else if (GET_CODE (exp) == PARALLEL\n-\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n-    {\n-      if (GET_CODE (SET_DEST (XVECEXP (exp, 0, 0))) == CC0)\n-\t{\n-\t  cc_status.flags = 0;\n-\t  cc_status.value1 = SET_DEST (XVECEXP (exp, 0, 0));\n-\t  cc_status.value2 = SET_SRC (XVECEXP (exp, 0, 0));\n-\t}\n-      else if (GET_CODE (SET_DEST (XVECEXP (exp, 0, 0))) == REG)\n-\t{\n-\t  if (cc_status.value1\n-\t      && reg_overlap_mentioned_p (SET_DEST (XVECEXP (exp, 0, 0)),\n-\t\t\t\t\t  cc_status.value1))\n-\t    cc_status.value1 = 0;\n-\t  if (cc_status.value2\n-\t      && reg_overlap_mentioned_p (SET_DEST (XVECEXP (exp, 0, 0)),\n-\t\t\t\t\t  cc_status.value2))\n-\t    cc_status.value2 = 0;\n-\t}\n-      else if (GET_CODE (SET_DEST (XVECEXP (exp, 0, 0))) == MEM)\n-\t{\n-\t  CC_STATUS_INIT;\n-\t}\n-    }\n-  else if (GET_CODE (exp) == CALL)\n-    {\n-      /* all bets are off */\n-      CC_STATUS_INIT;\n-    }\n-  else\n-    {\n-      /* nothing happens? CC_STATUS_INIT; */\n-    }\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\n-      && cc_status.value2\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n-    abort ();\n-}\n-\n-/* Implement TARGET_ARG_PARTIAL_BYTES.  */\n-\n-static int\n-ns32k_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n-\t\t\t tree type, bool named ATTRIBUTE_UNUSED)\n-{\n-  int cum = *pcum;\n-\n-  if (TARGET_REGPARM && cum < 8)\n-    {\n-      HOST_WIDE_INT size;\n-\n-      if (mode == BLKmode)\n-\tsize = int_size_in_bytes (type);\n-      else\n-\tsize = GET_MODE_SIZE (mode);\n-\n-      if (8 < cum + size)\n-\treturn 8 - cum;\n-    }\n-\n-  return 0;\n-}"}, {"sha": "1e503cf5f86821165c7d8a4f29608ef883ed40ea", "filename": "gcc/config/ns32k/ns32k.h", "status": "removed", "additions": 0, "deletions": 1182, "changes": 1182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,1182 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  NS32000 version.\n-   Copyright (C) 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      builtin_define (\"__ns32000__\");\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      /* CPU type */\t\t\t\t\t\\\n-      if (TARGET_32532)\t\t\t\t\t\\\n-\tbuiltin_define (\"__ns32532__\");\t\t\t\\\n-      else if (TARGET_32332)\t\t\t\t\\\n-\tbuiltin_define (\"__ns32332__\");\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__ns32032__\");\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      /* FPU type */\t\t\t\t\t\\\n-      if (TARGET_32381)\t\t\t\t\t\\\n-\tbuiltin_define (\"__ns32381__\");\t\t\t\\\n-      else if (TARGET_32081)\t\t\t\t\\\n-\tbuiltin_define (\"__ns32081__\");\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      /* Misc.  */\t\t\t\t\t\\\n-      if (TARGET_RTD)\t\t\t\t\t\\\n-\tbuiltin_define (\"__RTD__\");\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      builtin_assert (\"cpu=ns32k\");\t\t\t\\\n-      builtin_assert (\"machine=ns32k\");\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION fprintf (stderr, \" (32000, GAS syntax)\");\n-\n-\f\n-/* ABSOLUTE PREFIX, IMMEDIATE_PREFIX and EXTERNAL_PREFIX can be defined\n-   to cover most NS32k addressing syntax variations.  This way we don't\n-   need to redefine long macros in all the tm.h files for just slight\n-   variations in assembler syntax.  */\n-\n-#ifndef ABSOLUTE_PREFIX\n-#define ABSOLUTE_PREFIX '@'\n-#endif\n-\n-#if defined(IMMEDIATE_PREFIX) && IMMEDIATE_PREFIX\n-#define PUT_IMMEDIATE_PREFIX(FILE) putc(IMMEDIATE_PREFIX, FILE)\n-#else\n-#define PUT_IMMEDIATE_PREFIX(FILE)\n-#endif\n-#if defined(ABSOLUTE_PREFIX) && ABSOLUTE_PREFIX\n-#define PUT_ABSOLUTE_PREFIX(FILE) putc(ABSOLUTE_PREFIX, FILE)\n-#else\n-#define PUT_ABSOLUTE_PREFIX(FILE)\n-#endif\n-#if defined(EXTERNAL_PREFIX) && EXTERNAL_PREFIX\n-#define PUT_EXTERNAL_PREFIX(FILE) putc(EXTERNAL_PREFIX, FILE)\n-#else\n-#define PUT_EXTERNAL_PREFIX(FILE)\n-#endif\n-\n-/* When we are generating PIC, the sb is used as a pointer\n-   to the GOT. 32381 is a superset of 32081  */\n-\n-#define OVERRIDE_OPTIONS\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  if (target_flags & MASK_32532)\t\t\\\n-    target_flags |= MASK_32332; \t\t\\\n-  if (flag_pic || TARGET_HIMEM)\t\t\t\\\n-    target_flags &= ~MASK_SB;\t\t\t\\\n-  if (TARGET_32381)\t\t\t\t\\\n-    target_flags |= MASK_32081;\t\t\t\\\n-  else\t\t\t\t\t\t\\\n-    target_flags &= ~MASK_MULT_ADD;\t\t\\\n-  if (flag_unsafe_math_optimizations)\t\t\\\n-     target_flags &= ~MASK_IEEE_COMPARE;\t\t\\\n-}\n-\n-/* Zero or more C statements that may conditionally modify two\n-   variables `fixed_regs' and `call_used_regs' (both of type `char\n-   []') after they have been initialized from the two preceding\n-   macros.\n-\n-   This is necessary in case the fixed or call-clobbered registers\n-   depend on target flags.\n-\n-   You need not define this macro if it has no work to do.\n-\n-   If the usage of an entire class of registers depends on the target\n-   flags, you may indicate this to GCC by using this macro to modify\n-   `fixed_regs' and `call_used_regs' to 1 for each of the registers in\n-   the classes which should not be used by GCC.  Also define the macro\n-   `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called with a\n-   letter for a class that shouldn't be used.\n-\n-   (However, if this class is not included in `GENERAL_REGS' and all\n-   of the insn patterns whose constraints permit this class are\n-   controlled by target switches, then GCC will automatically avoid\n-   using these registers when the target switches are opposed to\n-   them.)  */\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_32081)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (regno = F0_REGNUM; regno <= F0_REGNUM + 8; regno++)\t\\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_32381)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (regno = L1_REGNUM; regno <= L1_REGNUM + 8; regno++)\t\\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-\f\n-/* target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   This is not true on the ns32k.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* That is not true on the ns32k.  */\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is lowest\n-   numbered. This is not true on the ns32k.  */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  National claims that the NS32032\n-   works without strict alignment, but rumor has it that operands\n-   crossing a page boundary cause unpredictable results.  */\n-#define STRICT_ALIGNMENT 1\n-\n-/* If bit field type is int, don't let it cross an int,\n-   and give entire struct the alignment of an int.  */\n-/* Required on the 386 since it doesn't have a full set of bit-field insns.\n-   (There is no signed extv insn.)  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER 26\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   On the ns32k, these are the FP, SP, (SB and PC are not included here).  */\n-#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, \\\n-\t\t\t 0, 0, 0, 0, 0, 0, 0, 0, \\\n-                         0, 0, 0, 0, 0, 0, 0, 0, \\\n-\t\t\t 1, 1}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS {1, 1, 1, 0, 0, 0, 0, 0, \\\n-\t\t\t     1, 1, 1, 1, 0, 0, 0, 0, \\\n-\t\t\t     1, 1, 0, 0, 0, 0, 0, 0, \\\n-\t\t\t     1, 1}\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \\\n- \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \\\n- \"l1\", \"l1h\",\"l3\", \"l3h\",\"l5\", \"l5h\",\"l7\", \"l7h\", \\\n- \"fp\", \"sp\"}\n-\n-\n-#define ADDITIONAL_REGISTER_NAMES \\\n-{{\"l0\", 8}, {\"l2\", 10}, {\"l4\", 12}, {\"l6\", 14}}\n-\n-/* l0-7 are not recognized by the assembler. These are the names to use,\n- * but we don't want ambiguous names in REGISTER_NAMES\n- */\n-#define OUTPUT_REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \\\n- \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \\\n- \"f1\", \"l1h\",\"f3\", \"l3h\",\"f5\", \"l5h\",\"f7\", \"f7h\", \\\n- \"fp\", \"sp\"}\n-\n-#define REG_ALLOC_ORDER \\\n-{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 10, 11, 18, 12, 13, 20, 14, 15, 22, 24, 25, 17, 19, 23}\n-\n-/* How to renumber registers for dbx and gdb.\n-   NS32000 may need more change in the numeration. XXX */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) \\\n-  ((REGNO) < L1_REGNUM? (REGNO) \\\n-   : (REGNO) < FRAME_POINTER_REGNUM? (REGNO) - L1_REGNUM + 22 \\\n-   : (REGNO) == FRAME_POINTER_REGNUM? 17 \\\n-   : 16)\n-\n-/* dwarf2out.c can't understand the funny DBX register numbering.\n- * We use dwarf2out.c for exception handling even though we use DBX\n- * for debugging\n- */\n-#define DWARF_FRAME_REGNUM(REGNO) (REGNO)\n-\n-\n-\n-#define R0_REGNUM 0\n-#define F0_REGNUM 8\n-#define L1_REGNUM 16\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* NS32000 pc is not overloaded on a register.  */\n-/* #define PC_REGNUM */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 25\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 24\n-\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-   On the ns32k, all registers are 32 bits long except for the 32381 \"long\"\n-   registers but we treat those as pairs  */\n-#define LONG_FP_REGS_P(REGNO) ((REGNO) >= L1_REGNUM && (REGNO) < L1_REGNUM + 8)\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok (REGNO, MODE)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n-  ((FLOAT_MODE_P(MODE1) && FLOAT_MODE_P(MODE2)\t\t\t\t\\\n-    && (GET_MODE_UNIT_SIZE(MODE1) == GET_MODE_UNIT_SIZE(MODE2)))\t\\\n-   || (!FLOAT_MODE_P(MODE1) && !FLOAT_MODE_P(MODE2)))\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 24\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 1\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define NS32K_STRUCT_VALUE_REGNUM 2\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-enum reg_class\n-{ NO_REGS, GENERAL_REGS, FLOAT_REG0, LONG_FLOAT_REG0, FLOAT_REGS,\n-  LONG_REGS, FP_REGS, GEN_AND_FP_REGS, FRAME_POINTER_REG,\n-  STACK_POINTER_REG, GEN_AND_MEM_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES\t\t\t\t\t\t\t    \\\n- {\"NO_REGS\", \"GENERAL_REGS\", \"FLOAT_REG0\", \"LONG_FLOAT_REG0\", \"FLOAT_REGS\", \\\n-  \"LONG_REGS\", \"FP_REGS\", \"GEN_AND_FP_REGS\", \"FRAME_POINTER_REG\", \t    \\\n-  \"STACK_POINTER_REG\", \"GEN_AND_MEM_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS\t\t\t\t\\\n-\t{{0},\t\t\t/* NO_REGS */\t\t\\\n-\t {0x00ff},\t\t/* GENERAL_REGS */\t\\\n-\t {0x100},\t\t/* FLOAT_REG0 */\t\\\n-\t {0x300},\t\t/* LONG_FLOAT_REG0 */\t\\\n-\t {0xff00},\t\t/* FLOAT_REGS */\t\\\n-         {0xff0000},            /* LONG_REGS */         \\\n-         {0xffff00},\t\t/* FP_REGS */\t\t\\\n-         {0xffffff},\t\t/* GEN_AND_FP_REGS */\t\\\n-         {0x1000000},\t\t/* FRAME_POINTER_REG */\t\\\n-         {0x2000000},\t\t/* STACK_POINTER_REG */\t\\\n-         {0x30000ff},\t\t/* GEN_AND_MEM_REGS */\t\\\n-\t {0x3ffffff}\t\t/* ALL_REGS */\t\t\\\n-\t}\n-\n-#define SUBSET_P(CLASS1, CLASS2)\t\t\t\\\n-   ((ns32k_reg_class_contents[CLASS1][0]\t\t\\\n-     & ~ns32k_reg_class_contents[CLASS2][0]) == 0)\n-\n-\n-/* LONG_REGS are registers which can only hold double precision floats\n- * and can only be accessible by long float instructions.\n- */\n-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\\\n-   ? reg_classes_intersect_p (LONG_REGS, CLASS) : 0)\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO)  (regclass_map[REGNO])\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS  GEN_AND_MEM_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\t\\\n- ((C) == 'u' ? FLOAT_REG0\t\t\t\\\n-  : (C) == 'v' ? LONG_FLOAT_REG0\t\t\\\n-  : (C) == 'f' ? FLOAT_REGS\t\t\t\\\n-  : (C) == 'l' ? FP_REGS\t\t\t\\\n-  : (C) == 'x' ? FRAME_POINTER_REG\t\t\\\n-  : (C) == 'y' ? STACK_POINTER_REG\t\t\\\n-  : NO_REGS)\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   On the ns32k, these letters are used as follows:\n-\n-   I : Matches integers which are valid shift amounts for scaled indexing.\n-       These are 0, 1, 2, 3 for byte, word, double, and quadword.\n-       Used for matching arithmetic shifts only on 32032 & 32332.\n-   J : Matches integers which fit a \"quick\" operand.\n-   K : Matches integers 0 to 7 (for inss and exts instructions).\n-  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((VALUE) < 8 && (VALUE) + 8 >= 0 ?\t\t\\\n-   ((C) == 'I' ? (!TARGET_32532 && 0 <= (VALUE) && (VALUE) <= 3) : \\\n-    (C) == 'J' ? (VALUE) <= 7 :\t\t\t\\\n-    (C) == 'K' ? 0 <= (VALUE) : 0) : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 1\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-/* We return GENERAL_REGS instead of GEN_AND_MEM_REGS.\n-   The latter offers no real additional possibilities\n-   and can cause spurious secondary reloading.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n- ((CLASS) == GEN_AND_MEM_REGS ? GENERAL_REGS : (CLASS))\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On the 32000, this is the size of MODE in words */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this to non-zero if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD 1\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* A C expression whose value is RTL representing the location of the\n-   incoming return address at the beginning of any function, before\n-   the prologue.  This RTL is either a `REG', indicating that the\n-   return value is saved in `REG', or a `MEM' representing a location\n-   in the stack.\n-\n-   You only need to define this macro if you want to support call\n-   frame debugging information like that provided by DWARF 2.\n-\n-   Before the prologue, RA is at 0(sp).  */\n-\n-#define INCOMING_RETURN_ADDR_RTX \\\n-  gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))\n-\n-/* A C expression whose value is RTL representing the value of the\n-   return address for the frame COUNT steps up from the current frame,\n-   after the prologue.  FRAMEADDR is the frame pointer of the COUNT\n-   frame, or the frame pointer of the COUNT - 1 frame if\n-   `RETURN_ADDR_IN_PREVIOUS_FRAME' is defined.\n-\n-   After the prologue, RA is at 4(fp) in the current frame.  */\n-\n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n-  ((COUNT> 0 && flag_omit_frame_pointer)? NULL_RTX\t\t\t\\\n-   : gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, (FRAME), GEN_INT(4))))\n-\n-/* A C expression whose value is an integer giving the offset, in\n-   bytes, from the value of the stack pointer register to the top of\n-   the stack frame at the beginning of any function, before the\n-   prologue.  The top of the frame is defined to be the value of the\n-   stack pointer in the previous frame, just before the call\n-   instruction.\n-\n-   You only need to define this macro if you want to support call\n-   frame debugging information like that provided by DWARF 2. */\n-\n-#define INCOMING_FRAME_SP_OFFSET 4\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On the 32000, sp@- in a byte insn really pushes a BYTE.  */\n-#define PUSH_ROUNDING(BYTES) (BYTES)\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 8\n-\n-/* Value is the number of byte of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.\n-\n-   On the 32000, the RET insn may be used to pop them if the number\n-     of args is fixed, but if the number is variable then the caller\n-     must pop them all.  RET can't be used for library calls now\n-     because the library is compiled with the Unix compiler.\n-   Use of RET is a selectable option, since it is incompatible with\n-   standard Unix calling sequences.  If the option is not selected,\n-   the caller must always pop the args.\n-\n-   The attribute stdcall is equivalent to RTD on a per module basis.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n-  (ns32k_return_pops_args (FUNDECL, FUNTYPE, SIZE))\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-/* On the 32000 the return value is in R0,\n-   or perhaps in F0 if there is fp support.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) LIBCALL_VALUE(TYPE_MODE (VALTYPE))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-/* On the 32000 the return value is in R0,\n-   or perhaps F0 is there is fp support.  */\n-\n-#define LIBCALL_VALUE(MODE)  \\\n-  gen_rtx_REG (MODE,\t\t\t\t  \\\n-\t       FLOAT_MODE_P(MODE) && TARGET_32081 ? F0_REGNUM: R0_REGNUM)\n-\n-/* Define this if PCC uses the nonreentrant convention for returning\n-   structure and union values.  */\n-\n-#define PCC_STATIC_STRUCT_RETURN\n-\n-/* 1 if N is a possible register number for a function value.\n-   On the 32000, R0 and F0 are the only registers thus used.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) (((N) & ~8) == 0)\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On the 32000, no registers are used in this way.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On the ns32k, this is a single integer, which is a number of bytes\n-   of arguments scanned so far.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On the ns32k, the offset starts at 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n- ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On the 32000 all args are pushed, except if -mregparm is specified\n-   then the first two words of arguments are passed in r0, r1.\n-   *NOTE* -mregparm does not work.\n-   It exists only to test register calling conventions.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8) ? gen_rtx_REG ((MODE), (CUM) / 4) : 0)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.\n-\n-   THIS DEFINITION FOR THE 32000 IS A GUESS.  IT HAS NOT BEEN TESTED.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   fprintf (FILE, \"\\taddr LP%d,r0\\n\\tbsr mcount\\n\", (LABELNO))\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.\n-\n-   We use 0, because using 1 requires hair in output_function_epilogue()\n-   that is worse than the stack adjust we could save.  */\n-\n-/* #define EXIT_IGNORE_STACK 1 */\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.  */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  int regno;\t\t\t\t\t\t\t\\\n-  int offset = -4;\t\t\t\t\t\t\\\n-  for (regno = 0; regno < FRAME_POINTER_REGNUM; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      offset += 4;\t\t\t\t\t\t\\\n-  if (flag_pic && current_function_uses_pic_offset_table)\t\\\n-    offset += 4;\t\t\t\t\t\t\\\n-  (DEPTH) = (offset + get_frame_size ()\t\t\t\t\\\n-\t     + (get_frame_size () == 0 ? 0 : 4));\t\t\\\n-}\n-\f\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-/* On the 32k, the trampoline looks like this:\n-\n-\taddr    0(pc),r2\n-        movd    16(r2),tos\n-        movd    12(r2),r1\n-        ret     0\n-\t.align 4\n-\t.int STATIC\n-\t.int FUNCTION\n-  \n-   Putting the data in following data is easier than figuring out how to\n-   do stores to memory in reverse byte order (the way immediate operands\n-   on the 32k are stored).  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\taddr 0(pc),r2\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tmovd 16(r2),tos\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\tmovd 12(r2),r1\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tret 0\\n\");\t\t\t\t\t\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t     \\\n-{\t\t\t\t\t\t\t\t\t     \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT);    \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n-}\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-/* note that FP and SP cannot be used as an index. What about PC? */\n-#define REGNO_OK_FOR_INDEX_P(REGNO)  \\\n-((REGNO) < F0_REGNUM || (unsigned)reg_renumber[REGNO] < F0_REGNUM)\n-#define REGNO_OK_FOR_BASE_P(REGNO)   \\\n-((REGNO) < F0_REGNUM || (unsigned)reg_renumber[REGNO] < F0_REGNUM \\\n- || (REGNO) == FRAME_POINTER_REGNUM || (REGNO) == STACK_POINTER_REGNUM)\n-\n-#define FP_REG_P(X) \\\n- (GET_CODE (X) == REG && REGNO (X) >= F0_REGNUM && REGNO (X) < FRAME_POINTER_REGNUM)\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* Recognize any constant value that is a valid address.\n-   This might not work on future ns32k processors as negative\n-   displacements are not officially allowed but a mode reserved\n-   to National.  This works on processors up to 32532, though,\n-   and we don't expect any new ones in the series ;-( */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n-       && NS32K_DISPLACEMENT_P (INTVAL (X))))\n-\n-#define CONSTANT_ADDRESS_NO_LABEL_P(X)   \\\n-  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n-   && NS32K_DISPLACEMENT_P (INTVAL (X)))\n-\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  secondary_reload_class (CLASS, MODE, IN)\n-\n-/*  Certain machines have the property that some registers cannot be\n-    copied to some other registers without using memory.  Define this\n-    macro on those machines to be a C expression that is nonzero if\n-    objects of mode M in registers of CLASS1 can only be copied to\n-    registers of class CLASS2 by storing a register of CLASS1 into\n-    memory and loading that memory location into a register of CLASS2.\n-\n-    On the ns32k, floating point regs can only be loaded through memory\n-\n-    The movdf and movsf insns in ns32k.md copy between general and\n-    floating registers using the stack. In principle, we could get\n-    better code not allowing that case in the constraints and defining\n-    SECONDARY_MEMORY_NEEDED in practice, though the stack slots used\n-    are not available for optimization.  */\n-\n-#if 0\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, M)\t\t\t\\\n-     secondary_memory_needed(CLASS1, CLASS2, M)\n-#endif\n-\n-/* SMALL_REGISTER_CLASSES is a run time option. This should no longer\n-   be necessary and should go when we have confidence that we won't run\n-   out of spill registers */\n-#define SMALL_REGISTER_CLASSES (target_flags & MASK_SRC)\n-\n-/* A C expression whose value is nonzero if pseudos that have been\n-   assigned to registers of class CLASS would likely be spilled\n-   because registers of CLASS are needed for spill registers.\n-\n-   The default definition won't do because class LONG_FLOAT_REG0 has two\n-   registers which are always accessed as a pair */\n-\n-#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n-  (reg_class_size[(int) (CLASS)] == 1 || (CLASS) == LONG_FLOAT_REG0)\n-\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) < F0_REGNUM || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   of if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) (REGNO (X) < F0_REGNUM || REGNO (X) >= FRAME_POINTER_REGNUM)\n-/* Nonzero if X is a floating point reg or a pseudo reg.  */\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n-\n-/* 1 if X is an address that we could indirect through.  */\n-/***** NOTE ***** There is a bug in the Sequent assembler which fails\n- to fixup addressing information for symbols used as offsets\n- from registers which are not FP or SP (or SB or PC).  This\n- makes _x(fp) valid, while _x(r0) is invalid.  */\n-\n-#define INDIRECTABLE_1_ADDRESS_P(X)  \\\n-  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-       && ((flag_pic || TARGET_HIMEM) ? \t\t\t\t\\\n-\t     CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1))\t \t\t\\\n-\t   :\t\t\t\t\t\t\t\t\\\n-\t     CONSTANT_ADDRESS_P (XEXP (X, 1))) \t\t\t\t\\\n-       && (GET_CODE (X) != CONST_INT || NS32K_DISPLACEMENT_P (INTVAL (X)))))\n-\n-/* 1 if integer I will fit in a 4 byte displacement field.\n-   Strictly speaking, we can't be sure that a symbol will fit this range.\n-   But, in practice, it always will.  */\n-\n-/* idall@eleceng.adelaide.edu.au says that the 32016 and 32032\n-   can handle the full range of displacements--it is only the addresses\n-   that have a limited range.  So the following was deleted:\n- (((i) <= 16777215 && (i) >= -16777216)\n-  || ((TARGET_32532 || TARGET_32332) && ...))  */\n-#define NS32K_DISPLACEMENT_P(i) \t\t\t\t\\\n-  ((i) < (1 << 29) && (i) >= - (1 << 29))\n-\n-/* Check for frame pointer or stack pointer.  */\n-#define MEM_REG(X) \\\n-  (GET_CODE (X) == REG && (REGNO (X) == FRAME_POINTER_REGNUM  \\\n-\t\t\t   || REGNO(X) == STACK_POINTER_REGNUM))\n-\n-/* A memory ref whose address is the FP or SP, with optional integer offset,\n-   or (on certain machines) a constant address.  */\n-#define INDIRECTABLE_2_ADDRESS_P(X)  \\\n-  (GET_CODE (X) == MEM\t\t\t\t\t\t\t\\\n-   && (((xfoo0 = XEXP (X, 0), MEM_REG (xfoo0))\t\t\t\t\\\n-       || (GET_CODE (xfoo0) == PLUS\t\t\t\t\t\\\n-\t   && MEM_REG (XEXP (xfoo0, 0))\t\t\t\t\t\\\n-\t   && CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfoo0, 1))))\t\t\\\n-       || (TARGET_SB && CONSTANT_ADDRESS_P (xfoo0))))\n-\n-/* Go to ADDR if X is a valid address not using indexing.\n-   (This much is the easy part.)  */\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)\t\t\\\n-{ \t\t\t\t\t\t\t\\\n-  if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR;\t\t\\\n-  if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\\\n-    if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1)))\t\\\n-      if (INDIRECTABLE_2_ADDRESS_P (XEXP (X, 0)))\t\\\n-\tgoto ADDR;\t\t\t\t\t\\\n-}\n-\n-/* Go to ADDR if X is a valid address not using indexing.\n-   (This much is the easy part.)  */\n-#define GO_IF_INDEXING(X, MODE, ADDR)  \\\n-{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if (GET_CODE (xfoob) == PLUS && INDEX_TERM_P (XEXP (xfoob, 0), MODE))\t\\\n-    GO_IF_INDEXABLE_ADDRESS (XEXP (xfoob, 1), ADDR);\t\t\t\\\n-  if (GET_CODE (xfoob) == PLUS && INDEX_TERM_P (XEXP (xfoob, 1), MODE))\t\\\n-    GO_IF_INDEXABLE_ADDRESS (XEXP (xfoob, 0), ADDR); }\t\t\t\\\n-\n-#define GO_IF_INDEXABLE_ADDRESS(X, ADDR) \\\n-{ if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X)) goto ADDR;\t\t\\\n-  if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n-  if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n-}\n-\n-/* 1 if PROD is either a reg times size of mode MODE\n-   or just a reg, if MODE is just one byte. Actually, on the ns32k,\n-   since the index mode is independent of the operand size,\n-   we can match more stuff...\n-\n-   This macro's expansion uses the temporary variables xfoo0, xfoo1\n-   and xfoo2 that must be declared in the surrounding context.  */\n-#define INDEX_TERM_P(PROD, MODE)   \\\n-((GET_CODE (PROD) == REG && REG_OK_FOR_INDEX_P (PROD))\t\t\t\\\n- || (GET_CODE (PROD) == MULT\t\t\t\t\t\t\\\n-     &&\t(xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\\\n-\t (GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n-\t  && GET_CODE (xfoo0) == REG\t\t\t\t\t\\\n-\t  && FITS_INDEX_RANGE (INTVAL (xfoo1))\t\t\t\t\\\n-\t  && REG_OK_FOR_INDEX_P (xfoo0)))))\n-\n-#define FITS_INDEX_RANGE(X)  \\\n-  ((xfoo2 = (unsigned)(X)-1),\t\t\t\t\t\t\\\n-   ((xfoo2 < 4 && xfoo2 != 2) || xfoo2 == 7))\n-\n-/* Note that xfoo0, xfoo1, xfoo2 are used in some of the submacros above.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{ register rtx xfooy, xfoo0, xfoo1;\t\t\t\t\t\\\n-  unsigned xfoo2;\t\t\t\t\t\t\t\\\n-  xfooy = X;\t\t\t\t\t\t\t\t\\\n-  if (flag_pic && cfun && ! current_function_uses_pic_offset_table\t\\\n-      && global_symbolic_reference_mentioned_p (X, 1))\t\t\t\\\n-    current_function_uses_pic_offset_table = 1;\t\t\t\t\\\n-  GO_IF_NONINDEXED_ADDRESS (xfooy, ADDR);\t\t\t\t\\\n-  if (GET_CODE (xfooy) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfooy, 1))\t\t\t\\\n-\t  && GET_CODE (XEXP (xfooy, 0)) == PLUS)\t\t\t\\\n-\txfooy = XEXP (xfooy, 0);\t\t\t\t\t\\\n-      else if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfooy, 0))\t\t\\\n-\t  && GET_CODE (XEXP (xfooy, 1)) == PLUS)\t\t\t\\\n-\txfooy = XEXP (xfooy, 1);\t\t\t\t\t\\\n-      GO_IF_INDEXING (xfooy, MODE, ADDR);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (INDEX_TERM_P (xfooy, MODE))\t\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (xfooy) == PRE_DEC)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (REGNO (XEXP (xfooy, 0)) == STACK_POINTER_REGNUM) goto ADDR;\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Nonzero if the constant value X is a legitimate general operand\n-   when generating PIC code.  It is given that flag_pic is on and\n-   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_PIC_OPERAND_P(X) \\\n-  (((! current_function_uses_pic_offset_table\t\t\t\\\n-     && symbolic_reference_mentioned_p (X))?\t\t\t\\\n-      (current_function_uses_pic_offset_table = 1):0\t\t\\\n-   ), (! SYMBOLIC_CONST (X)\t\t\t\t\t\\\n-   || GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF))\n-\n-#define SYMBOLIC_CONST(X)\t\\\n-(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n- || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n- || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the ns32k, only predecrement and postincrement address depend thus\n-   (the amount of decrement or increment being the length of the operand).  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n-     goto LABEL;}\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.\n-   HI mode is more efficient but the range is not wide enough for\n-   all programs.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-#define CASE_VECTOR_PC_RELATIVE 1\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n-\n-/* The number of scalar move insns which should be generated instead\n-   of a string move insn or a library call.\n-   \n-   We have a smart movmemsi insn */\n-#define MOVE_RATIO 0\n-\n-#define STORE_RATIO (optimize_size ? 3 : 15)\n-#define STORE_BY_PIECES_P(SIZE, ALIGN) \\\n-  (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n-   < (unsigned int) STORE_RATIO)\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Define if shifts truncate the shift count\n-   which implies one can omit a sign-extension or zero-extension\n-   of a shift count.  */\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE QImode\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* This bit means that what ought to be in the Z bit\n-   should be tested in the F bit.  */\n-#define CC_Z_IN_F 04000\n-\n-/* This bit means that what ought to be in the Z bit\n-   is complemented in the F bit.  */\n-#define CC_Z_IN_NOT_F 010000\n-\n-/* This bit means that the L bit indicates unordered (IEEE) comparison.\n- */\n-#define CC_UNORD 020000\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-  ns32k_notice_update_cc ((EXP), (INSN))\n-\n-/* Describe the costs of the following register moves which are discouraged:\n-   1.) Moves between the Floating point registers and the frame pointer and stack pointer\n-   2.) Moves between the stack pointer and the frame pointer\n-   3.) Moves between the floating point and general registers\n-\n-  These all involve two memory references. This is worse than a memory\n-  to memory move (default cost 4)\n- */\n-\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n-  register_move_cost (CLASS1, CLASS2)\n-\n-#define OUTPUT_JUMP(NORMAL, NO_OV)  \\\n-{ if (cc_status.flags & CC_NO_OVERFLOW)\t\t\t\t\\\n-    return NO_OV;\t\t\t\t\t\t\\\n-  return NORMAL; }\n-\f\n-/* Dividing the output into sections */\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* Define the output Assembly Language */\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* Output of Data */\n-\n-/* This is how to output an assembler line defining an external/static\n-   address which is not in tree format (for collect.c).  */\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovd %s,tos\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovd tos,%s\\n\", reg_names[REGNO])\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \".globl \"\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%ld\", PREFIX, (long) NUM)\n-\n-/* This is how to align the code that follows an unconditional branch.  */\n-\n-#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (2)\n-\n-/* This is how to output an element of a case-vector that is absolute.\n-   (The ns32k does not use such vectors,\n-   but we must define this macro anyway.)  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-/* ** Notice that the second element is LI format! */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.long L%d-LI%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %u\\n\", (int)(SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n-\n-/* Print an instruction operand X on file FILE.\n-   CODE is the code from the %-spec that requested printing this operand;\n-   if `%z3' was used to print operand 3, then CODE is 'z'. */\n-\n-/* %$ means print the prefix for an immediate operand.  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '$' || (CODE) == '?')\n-\n-#define PRINT_OPERAND(FILE, X, CODE)       print_operand(FILE, X, CODE)\n-\n-/* Print a memory operand whose address is X, on file FILE.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address(FILE, ADDR)\n-\n-extern const unsigned int ns32k_reg_class_contents[N_REG_CLASSES][1];\n-extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER]; /* smallest class containing REGNO */\n-\n-/*\n-Local variables:\n-version-control: t\n-End:\n-*/"}, {"sha": "9159bc36863ac5b5d18681c1717f4f8d9d56d8db", "filename": "gcc/config/ns32k/ns32k.md", "status": "removed", "additions": 0, "deletions": 3082, "changes": 3082, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=96a2347e1d837369cf266b937faf59511f0307ce"}, {"sha": "94e578e33dfbe6b857cc07b0ae8e49a2137109b8", "filename": "gcc/config/ns32k/ns32k.opt", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Fns32k.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.opt?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,108 +0,0 @@\n-; Options for the NS32000 port of the compiler.\n-\n-; Copyright (C) 2005 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 2, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING.  If not, write to the Free\n-; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n-; 02110-1301, USA.\n-\n-m32032\n-Target RejectNegative\n-Optimize for 32032\n-\n-m32081\n-Target RejectNegative Report Mask(32081)\n-Use hardware fp\n-\n-m32332\n-Target RejectNegative Report Mask(32332)\n-Optimize for 32332\n-\n-m32381\n-Target RejectNegative Report Mask(32381)\n-Use the 32381 fpu\n-\n-m32532\n-Target RejectNegative Report Mask(32532)\n-Optimize for 32532\n-\n-mbitfield\n-Target RejectNegative Report Mask(BITFIELD)\n-Use bit-field instructions\n-\n-mhimem\n-Target RejectNegative Report Mask(HIMEM)\n-Generate code for high memory\n-\n-mieee-compare\n-Target RejectNegative Report Mask(IEEE_COMPARE)\n-Use IEEE math for fp comparisons\n-\n-mmult-add\n-Target RejectNegative Report Mask(MULT_ADD)\n-Use multiply-accumulate fp instructions\n-\n-mnobitfield\n-Target RejectNegative Report InverseMask(BITFIELD)\n-Do not use bit-field instructions\n-\n-mnohimem\n-Target RejectNegative Report InverseMask(HIMEM)\n-Generate code for low memory\n-\n-mnoieee-compare\n-Target RejectNegative Report InverseMask(IEEE_COMPARE)\n-Do not use IEEE math for fp comparisons\n-\n-mnomult-add\n-Target RejectNegative Report InverseMask(MULT_ADD)\n-Do not use multiply-accumulate fp instructions\n-\n-mnoregparm\n-Target RejectNegative Report InverseMask(REGPARM)\n-Pass all arguments on the stack\n-\n-mnortd\n-Target RejectNegative Report InverseMask(RTD)\n-Use the normal calling convention\n-\n-mnosb\n-Target RejectNegative Report InverseMask(SB)\n-Do not use register sb\n-\n-mnosrc\n-Target RejectNegative Report InverseMask(SRC)\n-Do not use the 'small register classes' kludge\n-\n-mregparm\n-Target RejectNegative Report Mask(REGPARM)\n-Pass some arguments in registers\n-\n-mrtd\n-Target RejectNegative Report Mask(RTD)\n-Use an alternative calling convention\n-\n-msb\n-Target RejectNegative Report Mask(SB)\n-Register sb is zero, use it for absolute addressing\n-\n-msoft-float\n-Target RejectNegative\n-Do not use hardware fp\n-\n-msrc\n-Target RejectNegative Report Mask(SRC)\n-Use the 'small register classes' kludge"}, {"sha": "a8b6329d47ff7a5f2dda2af3c0c9a01c86e13300", "filename": "gcc/config/ns32k/t-ns32k", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Ft-ns32k", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fns32k%2Ft-ns32k", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Ft-ns32k?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,4 +0,0 @@\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-LIB2FUNCS_EXTRA = $(srcdir)/config/ns32k/__unorddf2.c \\\n-                  $(srcdir)/config/ns32k/__unordsf2.c"}, {"sha": "99fd5169b160757b33f6884d211ca9eb9fa0baf9", "filename": "gcc/config/sparc/openbsd.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fsparc%2Fopenbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fsparc%2Fopenbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fopenbsd.h?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,68 +0,0 @@\n-/* Configuration file for sparc OpenBSD target.\n-   Copyright (C) 1999, 2002, 2003, 2004 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-/* Target OS builtins.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__unix__\");\t\t\\\n-\tbuiltin_define (\"__OpenBSD__\");\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-\tbuiltin_assert (\"system=OpenBSD\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Layout of source language data types */\n-\n-/* This must agree with <machine/ansi.h> */\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 32\n-\n-/* Specific options for DBX Output.  */\n-\n-/* This is BSD, so it wants DBX format.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* This is the char to use for continuation */\n-#define DBX_CONTIN_CHAR '?'\n-\n-/* Stack & calling: aggregate returns.  */\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-#undef DEFAULT_PCC_STRUCT_RETURN\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* Assembler format: exception region output.  */\n-\n-/* All configurations that don't use elf must be explicit about not using\n-   dwarf unwind information.  */\n-#define DWARF2_UNWIND_INFO 0\n-\n-#undef ASM_PREFERRED_EH_DATA_FORMAT"}, {"sha": "898a24e079d9912234612ff3a43cd7620abff182", "filename": "gcc/config/sparc/t-openbsd", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fsparc%2Ft-openbsd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a2347e1d837369cf266b937faf59511f0307ce/gcc%2Fconfig%2Fsparc%2Ft-openbsd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-openbsd?ref=96a2347e1d837369cf266b937faf59511f0307ce", "patch": "@@ -1,5 +0,0 @@\n-# The native linker doesn't handle linking -fpic code with -fPIC code.  Ugh.\n-# We cope by building both variants of libgcc.\n-MULTILIB_OPTIONS = fpic/fPIC\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib"}, {"sha": "c1b54630b2682e148a4feb3cde5fe795a3db57f2", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -2244,8 +2244,6 @@ GNU Compiler Collection on your machine.\n @item\n @uref{#x-ibm-aix,,*-ibm-aix*}\n @item\n-@uref{#ip2k-x-elf,,ip2k-*-elf}\n-@item\n @uref{#iq2000-x-elf,,iq2000-*-elf}\n @item\n @uref{#m32r-x-elf,,m32r-*-elf}\n@@ -3175,16 +3173,6 @@ both Power or PowerPC processors.\n A default can be specified with the @option{-mcpu=@var{cpu_type}}\n switch and using the configure option @option{--with-cpu-@var{cpu_type}}.\n \n-@html\n-<hr />\n-@end html\n-@heading @anchor{ip2k-x-elf}ip2k-*-elf\n-Ubicom IP2022 micro controller.\n-This configuration is intended for embedded systems.\n-There are no standard Unix configurations.\n-\n-Use @samp{configure --target=ip2k-elf --enable-languages=c} to configure GCC@.\n-\n @html\n <hr />\n @end html"}, {"sha": "3fde0683694377fae3b37b71e58245883baea54f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -599,12 +599,6 @@ Objective-C and Objective-C++ Dialects}.\n -mam33-2  -mno-am33-2 @gol\n -mno-crt0  -mrelax}\n \n-@emph{NS32K Options}\n-@gccoptlist{-m32032  -m32332  -m32532  -m32081  -m32381 @gol\n--mmult-add  -mnomult-add  -msoft-float  -mrtd  -mnortd @gol\n--mregparam  -mnoregparam  -msb  -mnosb @gol\n--mbitfield  -mnobitfield  -mhimem  -mnohimem}\n-\n @emph{PDP-11 Options}\n @gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol\n -mbcopy  -mbcopy-builtin  -mint32  -mno-int16 @gol\n@@ -6970,7 +6964,6 @@ platform.\n * MIPS Options::\n * MMIX Options::\n * MN10300 Options::\n-* NS32K Options::\n * PDP-11 Options::\n * PowerPC Options::\n * RS/6000 and PowerPC Options::\n@@ -10407,148 +10400,6 @@ has an effect when used on the command line for the final link step.\n This option makes symbolic debugging impossible.\n @end table\n \n-@node NS32K Options\n-@subsection NS32K Options\n-@cindex NS32K options\n-\n-These are the @samp{-m} options defined for the 32000 series.  The default\n-values for these options depends on which style of 32000 was selected when\n-the compiler was configured; the defaults for the most common choices are\n-given below.\n-\n-@table @gcctabopt\n-@item -m32032\n-@itemx -m32032\n-@opindex m32032\n-@opindex m32032\n-Generate output for a 32032.  This is the default\n-when the compiler is configured for 32032 and 32016 based systems.\n-\n-@item -m32332\n-@itemx -m32332\n-@opindex m32332\n-@opindex m32332\n-Generate output for a 32332.  This is the default\n-when the compiler is configured for 32332-based systems.\n-\n-@item -m32532\n-@itemx -m32532\n-@opindex m32532\n-@opindex m32532\n-Generate output for a 32532.  This is the default\n-when the compiler is configured for 32532-based systems.\n-\n-@item -m32081\n-@opindex m32081\n-Generate output containing 32081 instructions for floating point.\n-This is the default for all systems.\n-\n-@item -m32381\n-@opindex m32381\n-Generate output containing 32381 instructions for floating point.  This\n-also implies @option{-m32081}.  The 32381 is only compatible with the 32332\n-and 32532 cpus.  This is the default for the pc532-netbsd configuration.\n-\n-@item -mmulti-add\n-@opindex mmulti-add\n-Try and generate multiply-add floating point instructions @code{polyF}\n-and @code{dotF}.  This option is only available if the @option{-m32381}\n-option is in effect.  Using these instructions requires changes to\n-register allocation which generally has a negative impact on\n-performance.  This option should only be enabled when compiling code\n-particularly likely to make heavy use of multiply-add instructions.\n-\n-@item -mnomulti-add\n-@opindex mnomulti-add\n-Do not try and generate multiply-add floating point instructions\n-@code{polyF} and @code{dotF}.  This is the default on all platforms.\n-\n-@item -msoft-float\n-@opindex msoft-float\n-Generate output containing library calls for floating point.\n-@strong{Warning:} the requisite libraries may not be available.\n-\n-@item -mieee-compare\n-@itemx -mno-ieee-compare\n-@opindex mieee-compare\n-@opindex mno-ieee-compare\n-Control whether or not the compiler uses IEEE floating point\n-comparisons.  These handle correctly the case where the result of a\n-comparison is unordered.\n-@strong{Warning:} the requisite kernel support may not be available.\n-\n-@item -mnobitfield\n-@opindex mnobitfield\n-Do not use the bit-field instructions.  On some machines it is faster to\n-use shifting and masking operations.  This is the default for the pc532.\n-\n-@item -mbitfield\n-@opindex mbitfield\n-Do use the bit-field instructions.  This is the default for all platforms\n-except the pc532.\n-\n-@item -mrtd\n-@opindex mrtd\n-Use a different function-calling convention, in which functions\n-that take a fixed number of arguments return pop their\n-arguments on return with the @code{ret} instruction.\n-\n-This calling convention is incompatible with the one normally\n-used on Unix, so you cannot use it if you need to call libraries\n-compiled with the Unix compiler.\n-\n-Also, you must provide function prototypes for all functions that\n-take variable numbers of arguments (including @code{printf});\n-otherwise incorrect code will be generated for calls to those\n-functions.\n-\n-In addition, seriously incorrect code will result if you call a\n-function with too many arguments.  (Normally, extra arguments are\n-harmlessly ignored.)\n-\n-This option takes its name from the 680x0 @code{rtd} instruction.\n-\n-\n-@item -mregparam\n-@opindex mregparam\n-Use a different function-calling convention where the first two arguments\n-are passed in registers.\n-\n-This calling convention is incompatible with the one normally\n-used on Unix, so you cannot use it if you need to call libraries\n-compiled with the Unix compiler.\n-\n-@item -mnoregparam\n-@opindex mnoregparam\n-Do not pass any arguments in registers.  This is the default for all\n-targets.\n-\n-@item -msb\n-@opindex msb\n-It is OK to use the sb as an index register which is always loaded with\n-zero.  This is the default for the pc532-netbsd target.\n-\n-@item -mnosb\n-@opindex mnosb\n-The sb register is not available for use or has not been initialized to\n-zero by the run time system.  This is the default for all targets except\n-the pc532-netbsd.  It is also implied whenever @option{-mhimem} or\n-@option{-fpic} is set.\n-\n-@item -mhimem\n-@opindex mhimem\n-Many ns32000 series addressing modes use displacements of up to 512MB@.\n-If an address is above 512MB then displacements from zero can not be used.\n-This option causes code to be generated which can be loaded above 512MB@.\n-This may be useful for operating systems or ROM code.\n-\n-@item -mnohimem\n-@opindex mnohimem\n-Assume code will be loaded in the first 512MB of virtual address space.\n-This is the default for all platforms.\n-\n-@end table\n-\n @node PDP-11 Options\n @subsection PDP-11 Options\n @cindex PDP-11 Options"}, {"sha": "bf71b7a80ab4fb974d2673f5572c4fad2f1e9a22", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -2165,76 +2165,6 @@ An integer constant with all bits set except exactly one.\n Any SYMBOL_REF.\n @end table\n \n-@item IP2K---@file{ip2k.h}\n-@table @code\n-@item a\n-@samp{DP} or @samp{IP} registers (general address)\n-\n-@item f\n-@samp{IP} register\n-\n-@item j\n-@samp{IPL} register\n-\n-@item k\n-@samp{IPH} register\n-\n-@item b\n-@samp{DP} register\n-\n-@item y\n-@samp{DPH} register\n-\n-@item z\n-@samp{DPL} register\n-\n-@item q\n-@samp{SP} register\n-\n-@item c\n-@samp{DP} or @samp{SP} registers (offsettable address)\n-\n-@item d\n-Non-pointer registers (not @samp{SP}, @samp{DP}, @samp{IP})\n-\n-@item u\n-Non-SP registers (everything except @samp{SP})\n-\n-@item R\n-Indirect through @samp{IP}---Avoid this except for @code{QImode}, since we\n-can't access extra bytes\n-\n-@item S\n-Indirect through @samp{SP} or @samp{DP} with short displacement (0..127)\n-\n-@item T\n-Data-section immediate value\n-\n-@item I\n-Integers from @minus{}255 to @minus{}1\n-\n-@item J\n-Integers from 0 to 7---valid bit number in a register\n-\n-@item K\n-Integers from 0 to 127---valid displacement for addressing mode\n-\n-@item L\n-Integers from 1 to 127\n-\n-@item M\n-Integer @minus{}1\n-\n-@item N\n-Integer 1\n-\n-@item O\n-Zero\n-\n-@item P\n-Integers from 0 to 255\n-@end table\n-\n @item MIPS---@file{mips.h}\n @table @code\n @item d"}, {"sha": "ab5287beb73ed5d7d039b55555e037f566fe1c28", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -1,3 +1,8 @@\n+2005-07-20  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* gcc.dg/20020312-2.c, gcc.dg/sibcall-3.c, gcc.dg/sibcall-4.c,\n+\tgcc.dg/cpp/assert4.c: Don't mention obsolete ports.\n+\n 2005-07-19  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* gcc.dg/fold-abs-1.c: New test."}, {"sha": "211fd755ad8afd9c0e2d41cff6756ec2cd65c9d1", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -44,8 +44,6 @@ extern void abort (void);\n /* No pic register.  */\n #elif defined(__mn10300__)\n /* No pic register.  */\n-#elif #cpu(ns32k)\n-/* No pic register.  */\n #elif defined(__hppa__)\n /* PIC register is %r27 or %r19, but is used even without -fpic.  */\n #elif defined(__pdp11__)"}, {"sha": "99b1f5e509af3cf721ca4e2c7fb8cdc8e814d6a8", "filename": "gcc/testsuite/gcc.dg/cpp/assert4.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -254,14 +254,6 @@\n # error\n #endif\n \n-#if defined __i860__\n-# if !#cpu(i860) || !#machine(i860)\n-#  error\n-# endif\n-#elif #cpu(i860) || #machine(i860)\n-# error\n-#endif\n-\n #if defined __ia64__\n # if !#cpu(ia64) || !#machine(ia64)\n #  error\n@@ -319,14 +311,6 @@\n # error\n #endif\n \n-#if defined __ns32k__\n-# if !#cpu(ns32k) || !#machine(ns32k)\n-#  error\n-# endif\n-#elif #cpu(ns32k) || #machine(ns32k)\n-# error\n-#endif\n-\n #if defined __pdp11__\n # if !#cpu(pdp11) || !#machine(pdp11)\n #  error"}, {"sha": "95edee107d8cf54c81b62918a9c4eef32e6e9482", "filename": "gcc/testsuite/gcc.dg/sibcall-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* hppa*64*-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mn10300-*-* ns32k-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n \n /* The option -foptimize-sibling-calls is the default, but serves as"}, {"sha": "3991ecc92793cd98314639743cf561a026b3e814", "filename": "gcc/testsuite/gcc.dg/sibcall-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdda361d74d0d7a3a1f3abba358139846e6a05c8/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c?ref=fdda361d74d0d7a3a1f3abba358139846e6a05c8", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* hppa*64*-*-* ip2k-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mn10300-*-* ns32k-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* m681?-*-* m680*-*-* m68k-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */\n \n /* The option -foptimize-sibling-calls is the default, but serves as"}]}