{"sha": "2c6c322a97713bff059648c8d2bbe87c16cd6b77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM2YzMyMmE5NzcxM2JmZjA1OTY0OGM4ZDJiYmU4N2MxNmNkNmI3Nw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-03-16T01:32:12Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-03-16T01:32:12Z"}, "message": "decl.c (init_decl_processing): Set type of `sync_info' to be pointer to Object.\n\n\t* decl.c (init_decl_processing): Set type of `sync_info' to be\n\tpointer to Object.\n\n\t* boehm.c (get_boehm_type_descriptor): Correctly compute `bits'.\n\tCorrectly compute bit number for current slot.  Zero `high' and\n\t`low' in DS_LENGTH case.  Don't skip inherited fields.  Use\n\tmark_reference_fields.\n\t(mark_reference_fields): New function.\n\nFrom-SVN: r32572", "tree": {"sha": "c1cbde9c844b02e5fd41dcfca6c56a415ebb6c99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1cbde9c844b02e5fd41dcfca6c56a415ebb6c99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c6c322a97713bff059648c8d2bbe87c16cd6b77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c6c322a97713bff059648c8d2bbe87c16cd6b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c6c322a97713bff059648c8d2bbe87c16cd6b77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c6c322a97713bff059648c8d2bbe87c16cd6b77/comments", "author": null, "committer": null, "parents": [{"sha": "d7d01975ad2e01f5ac4dfd5670687eaf2a98574a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7d01975ad2e01f5ac4dfd5670687eaf2a98574a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7d01975ad2e01f5ac4dfd5670687eaf2a98574a"}], "stats": {"total": 89, "additions": 66, "deletions": 23}, "files": [{"sha": "685972e1f76b9708640742b5e2068a50db0062ee", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6c322a97713bff059648c8d2bbe87c16cd6b77/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6c322a97713bff059648c8d2bbe87c16cd6b77/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2c6c322a97713bff059648c8d2bbe87c16cd6b77", "patch": "@@ -1,3 +1,14 @@\n+2000-03-15  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* decl.c (init_decl_processing): Set type of `sync_info' to be\n+\tpointer to Object.\n+\n+\t* boehm.c (get_boehm_type_descriptor): Correctly compute `bits'.\n+\tCorrectly compute bit number for current slot.  Zero `high' and\n+\t`low' in DS_LENGTH case.  Don't skip inherited fields.  Use\n+\tmark_reference_fields.\n+\t(mark_reference_fields): New function.\n+\n Tue Mar 14 17:15:41 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (register_incomplete_type): Fixed initialization of"}, {"sha": "504637e5fd9c18eb0c64e950be3af06dfba82e86", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6c322a97713bff059648c8d2bbe87c16cd6b77/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6c322a97713bff059648c8d2bbe87c16cd6b77/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=2c6c322a97713bff059648c8d2bbe87c16cd6b77", "patch": "@@ -58,6 +58,50 @@ set_bit (unsigned HOST_WIDE_INT *low, unsigned HOST_WIDE_INT *high,\n   *which |= (HOST_WIDE_INT) 1 << n;\n }\n \n+/* Recursively mark reference fields.  */\n+static unsigned int\n+mark_reference_fields (field, low, high, ubit,\n+\t\t       pointer_after_end, all_bits_set, last_set_index)\n+     tree field;\n+     unsigned HOST_WIDE_INT *low, *high;\n+     unsigned int ubit;\n+     int *pointer_after_end, *all_bits_set, *last_set_index;\n+{\n+  unsigned int count = 0;\n+\n+  /* See if we have fields from our superclass.  */\n+  if (DECL_NAME (field) == NULL_TREE)\n+    {\n+      count += mark_reference_fields (TYPE_FIELDS (TREE_TYPE (field)),\n+\t\t\t\t      low, high, ubit,\n+\t\t\t\t      pointer_after_end, all_bits_set,\n+\t\t\t\t      last_set_index);\n+      field = TREE_CHAIN (field);\n+    }\n+\n+  for (; field != NULL_TREE; field = TREE_CHAIN (field))\n+    {\n+      if (FIELD_STATIC (field))\n+\tcontinue;\n+\n+      if (JREFERENCE_TYPE_P (TREE_TYPE (field)))\n+\t{\n+\t  *last_set_index = count;\n+\t  /* First word in object corresponds to most significant byte\n+\t     of bitmap.  */\n+\t  set_bit (low, high, ubit - count - 1);\n+\t  if (count > ubit - 2)\n+\t    *pointer_after_end = 1;\n+\t}\n+      else\n+\t*all_bits_set = 0;\n+\n+      ++count;\n+    }\n+\n+  return count;\n+}\n+\n /* Return the marking bitmap for the class TYPE.  For now this is a\n    single word describing the type.  */\n tree\n@@ -79,7 +123,7 @@ get_boehm_type_descriptor (tree type)\n   if (int_size_in_bytes (type) == -1)\n     return PROCEDURE_OBJECT_DESCRIPTOR;\n \n-  bit = POINTER_SIZE;\n+  bit = POINTER_SIZE / BITS_PER_UNIT;\n   /* The size of this node has to be known.  And, we only support 32\n      and 64 bit targets, so we need to know that the log2 is one of\n      our values.  */\n@@ -97,27 +141,9 @@ get_boehm_type_descriptor (tree type)\n   ubit = (unsigned int) bit;\n \n   field = TYPE_FIELDS (type);\n-  if (DECL_NAME (field) == NULL_TREE)\n-    field = TREE_CHAIN (field);  /* Skip dummy field for inherited data. */\n-  for (count = 0; field != NULL_TREE; field = TREE_CHAIN (field))\n-    {\n-      if (FIELD_STATIC (field))\n-\tcontinue;\n-\n-      if (JREFERENCE_TYPE_P (TREE_TYPE (field)))\n-\t{\n-\t  last_set_index = count;\n-\t  /* First word in object corresponds to most significant byte\n-\t     of bitmap.  */\n-\t  set_bit (&low, &high, ubit - count);\n-\t  if (count > ubit - 2)\n-\t    pointer_after_end = 1;\n-\t}\n-      else\n-\tall_bits_set = 0;\n-\n-      ++count;\n-    }\n+  count = mark_reference_fields (field, &low, &high, ubit,\n+\t\t\t\t &pointer_after_end, &all_bits_set,\n+\t\t\t\t &last_set_index);\n \n   /* If the object is all pointers, or if the part with pointers fits\n      in our bitmap, then we are ok.  Otherwise we have to allocate it\n@@ -129,6 +155,8 @@ get_boehm_type_descriptor (tree type)\n \t DS_LENGTH is 0.\n \t WORDS_TO_BYTES shifts by log2(bytes-per-pointer).  */\n       count = 0;\n+      low = 0;\n+      high = 0;\n       ++last_set_index;\n       while (last_set_index)\n \t{"}, {"sha": "a0c37340b38d555b274268b00ecaa4157a1bd9f0", "filename": "gcc/java/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6c322a97713bff059648c8d2bbe87c16cd6b77/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6c322a97713bff059648c8d2bbe87c16cd6b77/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=2c6c322a97713bff059648c8d2bbe87c16cd6b77", "patch": "@@ -626,7 +626,11 @@ init_decl_processing ()\n   dtable_ptr_type = build_pointer_type (dtable_type);\n \n   PUSH_FIELD (object_type_node, field, \"vtable\", dtable_ptr_type);\n-  PUSH_FIELD (object_type_node, field, \"sync_info\", ptr_type_node);\n+  /* This isn't exactly true, but it is what we have in the source.\n+     There is an unresolved issue here, which is whether the vtable\n+     should be marked by the GC.  */\n+  PUSH_FIELD (object_type_node, field, \"sync_info\",\n+\t      build_pointer_type (object_type_node));\n   for (t = TYPE_FIELDS (object_type_node); t != NULL_TREE; t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   FINISH_RECORD (object_type_node);"}]}