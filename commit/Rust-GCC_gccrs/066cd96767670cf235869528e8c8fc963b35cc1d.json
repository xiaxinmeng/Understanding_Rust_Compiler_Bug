{"sha": "066cd96767670cf235869528e8c8fc963b35cc1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY2Y2Q5Njc2NzY3MGNmMjM1ODY5NTI4ZThjOGZjOTYzYjM1Y2MxZA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2004-08-03T15:31:38Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2004-08-03T15:31:38Z"}, "message": "rs6000.c (rs6000_rtx_costs): Calculate cost of constants more accurately.\n\n        * config/rs6000/rs6000.c (rs6000_rtx_costs): Calculate cost of\n        constants more accurately.  Adjust costs for FMA instructions.\n        Add cases for most logical and float operations.  Recurse into\n        most operands.\n\nCo-Authored-By: Dale Johannesen <dalej@apple.com>\nCo-Authored-By: Roger Sayle <roger@eyesopen.com>\n\nFrom-SVN: r85488", "tree": {"sha": "3b0bf6b11fb046e48534253a14dcb690c105425b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b0bf6b11fb046e48534253a14dcb690c105425b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/066cd96767670cf235869528e8c8fc963b35cc1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066cd96767670cf235869528e8c8fc963b35cc1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066cd96767670cf235869528e8c8fc963b35cc1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066cd96767670cf235869528e8c8fc963b35cc1d/comments", "author": null, "committer": null, "parents": [{"sha": "315cd6b5a6352f32134e60b28e3bb98cd32c80c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315cd6b5a6352f32134e60b28e3bb98cd32c80c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315cd6b5a6352f32134e60b28e3bb98cd32c80c7"}], "stats": {"total": 229, "additions": 179, "deletions": 50}, "files": [{"sha": "8828ae1191c0abb4567317ae34bedc3c66d0878d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066cd96767670cf235869528e8c8fc963b35cc1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066cd96767670cf235869528e8c8fc963b35cc1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=066cd96767670cf235869528e8c8fc963b35cc1d", "patch": "@@ -1,3 +1,12 @@\n+2004-08-03  David Edelsohn  <edelsohn@gnu.org>\n+\t    Dale Johannesen  <dalej@apple.com>\n+\t    Roger Sayle  <roger@eyesopen.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_rtx_costs): Calculate cost of\n+\tconstants more accurately.  Adjust costs for FMA instructions.\n+\tAdd cases for most logical and float operations.  Recurse into\n+\tmost operands.\n+\n 2004-08-03  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config.gcc (strongarm-*, xscale-*): Add t-arm to tmake_files."}, {"sha": "1a9cf8d1fe21507e97b0f549753417d67cc25339", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 170, "deletions": 50, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/066cd96767670cf235869528e8c8fc963b35cc1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/066cd96767670cf235869528e8c8fc963b35cc1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=066cd96767670cf235869528e8c8fc963b35cc1d", "patch": "@@ -16517,43 +16517,137 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n       /* On the RS/6000, if it is valid in the insn, it is free.\n \t So this always returns 0.  */\n     case CONST_INT:\n+      if (((outer_code == SET\n+\t    || outer_code == PLUS\n+\t    || outer_code == MINUS)\n+\t   && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+\t       || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L')))\n+\t  || ((outer_code == IOR || outer_code == XOR)\n+\t      && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'K')\n+\t\t  || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L')))\n+\t  || (outer_code == AND\n+\t      && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'K')\n+\t\t  || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L')\n+\t\t  || CONST_OK_FOR_LETTER_P (INTVAL (x), 'T')))\n+\t  || outer_code == ASHIFT\n+\t  || outer_code == ASHIFTRT\n+\t  || outer_code == LSHIFTRT\n+\t  || outer_code == ROTATE\n+\t  || outer_code == ROTATERT\n+\t  || (outer_code == MULT\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL (x), 'I'))\n+\t  || (outer_code == COMPARE\n+\t      && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'I')\n+\t\t  || CONST_OK_FOR_LETTER_P (INTVAL (x), 'K'))))\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      else if ((outer_code == PLUS\n+\t\t&& reg_or_add_cint64_operand (x, VOIDmode))\n+\t       || (outer_code == MINUS\n+\t\t   && reg_or_sub_cint64_operand (x, VOIDmode))\n+\t       || ((outer_code == SET\n+\t\t    || outer_code == IOR\n+\t\t    || outer_code == XOR)\n+\t\t   && (INTVAL (x)\n+\t\t       & ~ (unsigned HOST_WIDE_INT) 0xffffffff) == 0))\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n+    case CONST_DOUBLE:\n+      if (mode == DImode\n+\t  && ((outer_code == AND\n+\t       && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'K')\n+\t\t   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L')\n+\t\t   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'S')))\n+\t      || ((outer_code == IOR || outer_code == XOR)\n+\t\t  && CONST_DOUBLE_HIGH (x) == 0\n+\t\t  && (CONST_DOUBLE_LOW (x)\n+\t\t      & ~ (unsigned HOST_WIDE_INT) 0xffff) == 0)))\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n+      else if (mode == DImode\n+\t       && (outer_code == SET\n+\t\t   || outer_code == IOR\n+\t\t   || outer_code == XOR)\n+\t       && CONST_DOUBLE_HIGH (x) == 0)\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      /* FALLTHRU */\n+\n     case CONST:\n+    case HIGH:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-    case CONST_DOUBLE:\n-    case HIGH:\n-      *total = 0;\n+    case MEM:\n+      /* When optimizing for size, MEM should be slightly more expensive\n+\t than generating address, e.g., (plus (reg) (const)).\n+\t L1 cache latecy is about two instructions.  */\n+      *total = optimize_size ? COSTS_N_INSNS (1) + 1 : COSTS_N_INSNS (2);\n       return true;\n \n     case PLUS:\n       if (mode == DFmode)\n-\t*total = GET_CODE (XEXP (x, 0)) == MULT\n-\t\t ? rs6000_cost->dmul\n-\t\t : rs6000_cost->fp;\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == MULT)\n+\t    {\n+\t      /* FNMA accounted in outer NEG.  */\n+\t      if (outer_code == NEG)\n+\t\t*total = rs6000_cost->dmul - rs6000_cost->fp;\n+\t      else\n+\t\t*total = rs6000_cost->dmul;\n+\t    }\n+\t  else\n+\t    *total = rs6000_cost->fp;\n+\t}\n       else if (mode == SFmode)\n-\t*total = rs6000_cost->fp;\n+\t{\n+\t  /* FNMA accounted in outer NEG.  */\n+\t  if (outer_code == NEG && GET_CODE (XEXP (x, 0)) == MULT)\n+\t    *total = 0;\n+\t  else\n+\t    *total = rs6000_cost->fp;\n+\t}\n       else if (GET_CODE (XEXP (x, 0)) == MULT)\n \t{\n \t  /* The rs6000 doesn't have shift-and-add instructions.  */\n \t  rs6000_rtx_costs (XEXP (x, 0), MULT, PLUS, total);\n \t  *total += COSTS_N_INSNS (1);\n \t}\n       else\n-\t*total = ((GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t\t  && ((unsigned HOST_WIDE_INT) (INTVAL (XEXP (x, 1))\n-\t\t\t\t\t\t+ 0x8000) >= 0x10000)\n-\t\t  && ((INTVAL (XEXP (x, 1)) & 0xffff) != 0))\n-\t\t ? COSTS_N_INSNS (2)\n-\t\t : COSTS_N_INSNS (1));\n-      return true;\n+\t*total = COSTS_N_INSNS (1);\n+      return false;\n \n     case MINUS:\n       if (mode == DFmode)\n-\t*total = GET_CODE (XEXP (x, 0)) == MULT\n-\t\t ? rs6000_cost->dmul\n-\t\t : rs6000_cost->fp;\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == MULT)\n+\t    {\n+\t      /* FNMA accounted in outer NEG.  */\n+\t      if (outer_code == NEG)\n+\t\t*total = 0;\n+\t      else\n+\t\t*total = rs6000_cost->dmul;\n+\t    }\n+\t  else\n+\t    *total = rs6000_cost->fp;\n+\t}\n       else if (mode == SFmode)\n-\t*total = rs6000_cost->fp;\n+\t{\n+\t  /* FNMA accounted in outer NEG.  */\n+\t  if (outer_code == NEG && GET_CODE (XEXP (x, 0)) == MULT)\n+\t    *total = 0;\n+\t  else\n+\t    *total = rs6000_cost->fp;\n+\t}\n       else if (GET_CODE (XEXP (x, 0)) == MULT)\n \t{\n \t  /* The rs6000 doesn't have shift-and-sub instructions.  */\n@@ -16562,17 +16656,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t}\n       else\n         *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      *total = ((GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t\t && (INTVAL (XEXP (x, 1)) & (~ (HOST_WIDE_INT) 0xffff)) != 0\n-\t\t && ((INTVAL (XEXP (x, 1)) & 0xffff) != 0))\n-\t\t? COSTS_N_INSNS (2)\n-\t\t: COSTS_N_INSNS (1));\n-      return true;\n+      return false;\n \n     case MULT:\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n@@ -16583,6 +16667,10 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t  else\n \t    *total = rs6000_cost->mulsi_const;\n \t}\n+      /* FMA accounted in outer PLUS/MINUS.  */\n+      else if ((mode == DFmode || mode == SFmode)\n+\t       && (outer_code == PLUS || outer_code == MINUS))\n+\t*total = 0;\n       else if (mode == DFmode)\n \t*total = rs6000_cost->dmul;\n       else if (mode == SFmode)\n@@ -16591,21 +16679,21 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t*total = rs6000_cost->muldi;\n       else\n \t*total = rs6000_cost->mulsi;\n-      return true;\n+      return false;\n \n     case DIV:\n     case MOD:\n       if (FLOAT_MODE_P (mode))\n \t{\n \t  *total = mode == DFmode ? rs6000_cost->ddiv\n \t\t\t\t  : rs6000_cost->sdiv;\n-\t  return true;\n+\t  return false;\n \t}\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n \t{\n \t  *total = COSTS_N_INSNS (2);\n-\t  return true;\n+\t  return false;\n \t}\n       /* FALLTHRU */\n \n@@ -16615,35 +16703,60 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t*total = rs6000_cost->divdi;\n       else\n \t*total = rs6000_cost->divsi;\n-      return true;\n+      return false;\n \n     case FFS:\n       *total = COSTS_N_INSNS (4);\n-      return true;\n-\n-    case NEG:\n-    case ABS:\n-      if (FLOAT_MODE_P (mode))\n-\t*total = rs6000_cost->fp;\n-      else\n-\t*total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case MEM:\n-      /* MEM should be slightly more expensive than (plus (reg) (const)).  */\n-      *total = COSTS_N_INSNS (1) + 1;\n-      return true;\n+      return false;\n \n     case NOT:\n+      if (outer_code == AND || outer_code == IOR || outer_code == XOR)\n+\t{\n+\t  *total = 0;\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ROTATE:\n+    case ROTATERT:\n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-    case COMPARE:\n+      if (outer_code == TRUNCATE\n+\t  && GET_CODE (XEXP (x, 0)) == MULT)\n+\t{\n+\t  if (mode == DImode)\n+\t    *total = rs6000_cost->muldi;\n+\t  else\n+\t    *total = rs6000_cost->mulsi;\n+\t  return true;\n+\t}\n       *total = COSTS_N_INSNS (1);\n-      break;\n+      return false;\n \n+    case COMPARE:\n+    case NEG:\n+    case ABS:\n+      if (!FLOAT_MODE_P (mode))\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n+\t}\n+      /* FALLTHRU */\n+\n+    case FLOAT:\n+    case UNSIGNED_FLOAT:\n+    case FIX:\n+    case UNSIGNED_FIX:\n+    case FLOAT_EXTEND:\n     case FLOAT_TRUNCATE:\n       *total = rs6000_cost->fp;\n-      return true;\n+      return false;\n \n     case UNSPEC:\n       switch (XINT (x, 1))\n@@ -16664,6 +16777,13 @@ rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED,\n \t  *total = COSTS_N_INSNS (1);\n \t  return true;\n \t}\n+      else if (FLOAT_MODE_P (mode)\n+\t       && TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT && TARGET_FPRS)\n+\t{\n+\t  *total = rs6000_cost->fp;\n+\t  return false;\n+\t}\n+\n       break;\n \n     default:"}]}