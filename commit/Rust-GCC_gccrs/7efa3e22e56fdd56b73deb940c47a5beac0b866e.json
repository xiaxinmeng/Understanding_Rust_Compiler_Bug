{"sha": "7efa3e22e56fdd56b73deb940c47a5beac0b866e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VmYTNlMjJlNTZmZGQ1NmI3M2RlYjk0MGM0N2E1YmVhYzBiODY2ZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-07-11T09:18:01Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-11T09:18:01Z"}, "message": "re PR c++/11050 (\"some string\" __FUNCTION__ is accepted)\n\ncp:\n\tPR c++/11050\n\t* parser.c (cp_parser_expression_list): Rename to ...\n\t(cp_parser_parenthesized_expression_list): ... here. Add attribute\n\tparameter, parse the surounding parentheses.\n\t(cp_parser_skip_to_closing_parenthesis): Add recover and or_comma\n\tparameters. Return int.\n\t(cp_parser_skip_to_closing_parenthesis or comma): Remove.\n\t(cp_parser_postfix_expression): Adjust function call parsing.\n\t(cp_parser_new_placement): Adjust.\n\t(cp_parser_new_initializer): Likewise.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_selection_statement): Likewise.\n\t(cp_parser_mem_initializer): Likewise.\n\t(cp_parser_asm_definition): Likewise.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_declarator): Make\n\tcdtor_or_conv_p an int ptr.\n\t(cp_parser_direct_declarator): Likewise. Check for a parameter\n\tlist on cdtors & conv functions.\n\t(cp_parser_initializer): Adjust.\n\t(cp_parser_member_declaration): Adjust.\n\t(cp_parser_attribute_list): Move code into\n\tcp_parser_parens_expression_list.\n\t(cp_parser_functional_cast): Adjust.\n\t* pt.c (type_dependent_expression_p): Erroneous expressions are\n\tnon-dependent.\ntestsuite:\n\tPR c++/11050\n\t* g++.dg/parse/args1.C: New test.\n\t* g++.pt/defarg8.C: Change expected errors.\n\nFrom-SVN: r69230", "tree": {"sha": "37b398ebca5e5e9e4db16502deb7f9b40fb49cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37b398ebca5e5e9e4db16502deb7f9b40fb49cff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7efa3e22e56fdd56b73deb940c47a5beac0b866e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efa3e22e56fdd56b73deb940c47a5beac0b866e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7efa3e22e56fdd56b73deb940c47a5beac0b866e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efa3e22e56fdd56b73deb940c47a5beac0b866e/comments", "author": null, "committer": null, "parents": [{"sha": "87ca53f644a27a18266933cf0996e8bf1097cf24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ca53f644a27a18266933cf0996e8bf1097cf24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ca53f644a27a18266933cf0996e8bf1097cf24"}], "stats": {"total": 407, "additions": 220, "deletions": 187}, "files": [{"sha": "c91df8ebbe7905277b3b44ca213b9090cd81b9e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7efa3e22e56fdd56b73deb940c47a5beac0b866e", "patch": "@@ -1,3 +1,32 @@\n+2003-07-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11050\n+\t* parser.c (cp_parser_expression_list): Rename to ...\n+\t(cp_parser_parenthesized_expression_list): ... here. Add attribute\n+\tparameter, parse the surounding parentheses.\n+\t(cp_parser_skip_to_closing_parenthesis): Add recover and or_comma\n+\tparameters. Return int.\n+\t(cp_parser_skip_to_closing_parenthesis or comma): Remove.\n+\t(cp_parser_postfix_expression): Adjust function call parsing.\n+\t(cp_parser_new_placement): Adjust.\n+\t(cp_parser_new_initializer): Likewise.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_selection_statement): Likewise.\n+\t(cp_parser_mem_initializer): Likewise.\n+\t(cp_parser_asm_definition): Likewise.\n+\t(cp_parser_init_declarator): Likewise.\n+\t(cp_parser_declarator): Make\n+\tcdtor_or_conv_p an int ptr.\n+\t(cp_parser_direct_declarator): Likewise. Check for a parameter\n+\tlist on cdtors & conv functions.\n+\t(cp_parser_initializer): Adjust.\n+\t(cp_parser_member_declaration): Adjust.\n+\t(cp_parser_attribute_list): Move code into\n+\tcp_parser_parens_expression_list.\n+\t(cp_parser_functional_cast): Adjust.\n+\t* pt.c (type_dependent_expression_p): Erroneous expressions are\n+\tnon-dependent.\n+\n 2003-07-11  Geoffrey Keating  <geoffk@apple.com>\n \n \t* decl.c (cp_finish_decl): Handle 'used' attribute."}, {"sha": "33c88b16fadf39b9ba253c014111a2d84cf13c9a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 163, "deletions": 185, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7efa3e22e56fdd56b73deb940c47a5beac0b866e", "patch": "@@ -1324,8 +1324,8 @@ static tree cp_parser_class_or_namespace_name\n   (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n   (cp_parser *, bool);\n-static tree cp_parser_expression_list\n-  (cp_parser *);\n+static tree cp_parser_parenthesized_expression_list\n+  (cp_parser *, bool);\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree *, tree *);\n static tree cp_parser_unary_expression\n@@ -1467,9 +1467,9 @@ static void cp_parser_linkage_specification\n static tree cp_parser_init_declarator\n   (cp_parser *, tree, tree, bool, bool, bool *);\n static tree cp_parser_declarator\n-  (cp_parser *, cp_parser_declarator_kind, bool *);\n+  (cp_parser *, cp_parser_declarator_kind, int *);\n static tree cp_parser_direct_declarator\n-  (cp_parser *, cp_parser_declarator_kind, bool *);\n+  (cp_parser *, cp_parser_declarator_kind, int *);\n static enum tree_code cp_parser_ptr_operator\n   (cp_parser *, tree *, tree *);\n static tree cp_parser_cv_qualifier_seq_opt\n@@ -1699,10 +1699,8 @@ static tree cp_parser_non_constant_id_expression\n   (tree);\n static bool cp_parser_diagnose_invalid_type_name\n   (cp_parser *);\n-static bool cp_parser_skip_to_closing_parenthesis\n-  (cp_parser *);\n-static bool cp_parser_skip_to_closing_parenthesis_or_comma\n-  (cp_parser *);\n+static int cp_parser_skip_to_closing_parenthesis\n+  (cp_parser *, bool, bool);\n static void cp_parser_skip_to_end_of_statement\n   (cp_parser *);\n static void cp_parser_consume_semicolon_at_end_of_statement\n@@ -1880,57 +1878,60 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser)\n }\n \n /* Consume tokens up to, and including, the next non-nested closing `)'. \n-   Returns TRUE iff we found a closing `)'.  */\n+   Returns 1 iff we found a closing `)'.  RECOVERING is true, if we\n+   are doing error recovery. Returns -1 if OR_COMMA is true and we\n+   found an unnested comma.  */\n \n-static bool\n-cp_parser_skip_to_closing_parenthesis (cp_parser *parser)\n+static int\n+cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n+\t\t\t\t       bool recovering, bool or_comma)\n {\n-  unsigned nesting_depth = 0;\n+  unsigned paren_depth = 0;\n+  unsigned brace_depth = 0;\n \n+  if (recovering && !or_comma && cp_parser_parsing_tentatively (parser)\n+      && !cp_parser_committed_to_tentative_parse (parser))\n+    return 0;\n+  \n   while (true)\n     {\n       cp_token *token;\n-\n+      \n       /* If we've run out of tokens, then there is no closing `)'.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n-\treturn false;\n-      /* Consume the token.  */\n-      token = cp_lexer_consume_token (parser->lexer);\n-      /* If it is an `(', we have entered another level of nesting.  */\n-      if (token->type == CPP_OPEN_PAREN)\n-\t++nesting_depth;\n-      /* If it is a `)', then we might be done.  */\n-      else if (token->type == CPP_CLOSE_PAREN && nesting_depth-- == 0)\n-\treturn true;\n-    }\n-}\n-\n-/* Consume tokens until the next token is a `)', or a `,'.  Returns\n-   TRUE if the next token is a `,'.  */\n+\treturn 0;\n \n-static bool\n-cp_parser_skip_to_closing_parenthesis_or_comma (cp_parser *parser)\n-{\n-  unsigned nesting_depth = 0;\n-\n-  while (true)\n-    {\n-      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      if (recovering)\n+\t{\n+\t  token = cp_lexer_peek_token (parser->lexer);\n \n-      /* If we've run out of tokens, then there is no closing `)'.  */\n-      if (token->type == CPP_EOF)\n-\treturn false;\n-      /* If it is a `,' stop.  */\n-      else if (token->type == CPP_COMMA && nesting_depth-- == 0)\n-\treturn true;\n-      /* If it is a `)', stop.  */\n-      else if (token->type == CPP_CLOSE_PAREN && nesting_depth-- == 0)\n-\treturn false;\n-      /* If it is an `(', we have entered another level of nesting.  */\n-      else if (token->type == CPP_OPEN_PAREN)\n-\t++nesting_depth;\n+\t  /* This matches the processing in skip_to_end_of_statement */\n+\t  if (token->type == CPP_SEMICOLON && !brace_depth)\n+\t    return 0;\n+\t  if (token->type == CPP_OPEN_BRACE)\n+\t    ++brace_depth;\n+\t  if (token->type == CPP_CLOSE_BRACE)\n+\t    {\n+\t      if (!brace_depth--)\n+\t\treturn 0;\n+\t    }\n+\t  if (or_comma && token->type == CPP_COMMA\n+\t      && !brace_depth && !paren_depth)\n+\t    return -1;\n+\t}\n+      \n       /* Consume the token.  */\n       token = cp_lexer_consume_token (parser->lexer);\n+\n+      if (!brace_depth)\n+\t{\n+\t  /* If it is an `(', we have entered another level of nesting.  */\n+\t  if (token->type == CPP_OPEN_PAREN)\n+\t    ++paren_depth;\n+\t  /* If it is a `)', then we might be done.  */\n+\t  else if (token->type == CPP_CLOSE_PAREN && !paren_depth--)\n+\t    return 1;\n+\t}\n     }\n }\n \n@@ -3762,19 +3763,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \tcase CPP_OPEN_PAREN:\n \t  /* postfix-expression ( expression-list [opt] ) */\n \t  {\n-\t    tree args;\n+\t    tree args = cp_parser_parenthesized_expression_list (parser, false);\n \n-\t    /* Consume the `(' token.  */\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t    /* If the next token is not a `)', then there are some\n-               arguments.  */\n-\t    if (cp_lexer_next_token_is_not (parser->lexer, \n-\t\t\t\t\t    CPP_CLOSE_PAREN))\n-\t      args = cp_parser_expression_list (parser);\n-\t    else\n-\t      args = NULL_TREE;\n-\t    /* Look for the closing `)'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\t    if (args == error_mark_node)\n+\t      {\n+\t\tpostfix_expression = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    \n \t    /* Function calls are not permitted in\n \t       constant-expressions.  */\n \t    if (parser->constant_expression_p)\n@@ -4054,51 +4050,100 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n   return error_mark_node;\n }\n \n-/* Parse an expression-list.\n+/* Parse a parenthesized expression-list.\n \n    expression-list:\n      assignment-expression\n      expression-list, assignment-expression\n \n+   attribute-list:\n+     expression-list\n+     identifier\n+     identifier, expression-list\n+\n    Returns a TREE_LIST.  The TREE_VALUE of each node is a\n    representation of an assignment-expression.  Note that a TREE_LIST\n-   is returned even if there is only a single expression in the list.  */\n+   is returned even if there is only a single expression in the list.\n+   error_mark_node is returned if the ( and or ) are\n+   missing. NULL_TREE is returned on no expressions. The parentheses\n+   are eaten. IS_ATTRIBUTE_LIST is true if this is really an attribute\n+   list being parsed. */\n \n static tree\n-cp_parser_expression_list (cp_parser* parser)\n+cp_parser_parenthesized_expression_list (cp_parser* parser, bool is_attribute_list)\n {\n   tree expression_list = NULL_TREE;\n-\n+  tree identifier = NULL_TREE;\n+  \n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+    return error_mark_node;\n+  \n   /* Consume expressions until there are no more.  */\n-  while (true)\n-    {\n-      tree expr;\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+    while (true)\n+      {\n+\ttree expr;\n+\t\n+\t/* At the beginning of attribute lists, check to see if the\n+\t   next token is an identifier.  */\n+\tif (is_attribute_list\n+\t    && cp_lexer_peek_token (parser->lexer)->type == CPP_NAME)\n+\t  {\n+\t    cp_token *token;\n+\t    \n+\t    /* Consume the identifier.  */\n+\t    token = cp_lexer_consume_token (parser->lexer);\n+\t    /* Save the identifier.  */\n+\t    identifier = token->value;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Parse the next assignment-expression.  */\n+\t    expr = cp_parser_assignment_expression (parser);\n \n-      /* Parse the next assignment-expression.  */\n-      expr = cp_parser_assignment_expression (parser);\n-      /* Add it to the list.  */\n-      expression_list = tree_cons (NULL_TREE, expr, expression_list);\n+\t     /* Add it to the list.  We add error_mark_node\n+\t\texpressions to the list, so that we can still tell if\n+\t\tthe correct form for a parenthesized expression-list\n+\t\tis found. That gives better errors.  */\n+\t    expression_list = tree_cons (NULL_TREE, expr, expression_list);\n \n-      /* If the next token isn't a `,', then we are done.  */\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n-\t{\n-\t  /* All uses of expression-list in the grammar are followed\n-\t     by a `)'.  Therefore, if the next token is not a `)' an\n-\t     error will be issued, unless we are parsing tentatively.\n-\t     Skip ahead to see if there is another `,' before the `)';\n-\t     if so, we can go there and recover.  */\n-\t  if (cp_parser_parsing_tentatively (parser)\n-\t      || cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN)\n-\t      || !cp_parser_skip_to_closing_parenthesis_or_comma (parser))\n-\t    break;\n-\t}\n+\t    if (expr == error_mark_node)\n+\t      goto skip_comma;\n+\t  }\n \n-      /* Otherwise, consume the `,' and keep going.  */\n-      cp_lexer_consume_token (parser->lexer);\n+\t/* After the first item, attribute lists look the same as\n+\t   expression lists.  */\n+\tis_attribute_list = false;\n+\t\n+      get_comma:;\n+\t/* If the next token isn't a `,', then we are done.  */\n+\tif (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\t  break;\n+\n+\t/* Otherwise, consume the `,' and keep going.  */\n+\tcp_lexer_consume_token (parser->lexer);\n+      }\n+  \n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+    {\n+      int ending;\n+      \n+    skip_comma:;\n+      /* We try and resync to an unnested comma, as that will give the\n+\t user better diagnostics.  */\n+      ending = cp_parser_skip_to_closing_parenthesis (parser, true, true);\n+      if (ending < 0)\n+\tgoto get_comma;\n+      if (!ending)\n+\treturn error_mark_node;\n     }\n \n   /* We built up the list in reverse order so we must reverse it now.  */\n-  return nreverse (expression_list);\n+  expression_list = nreverse (expression_list);\n+  if (identifier)\n+    expression_list = tree_cons (NULL_TREE, identifier, expression_list);\n+  \n+  return expression_list;\n }\n \n /* Parse a pseudo-destructor-name.\n@@ -4463,13 +4508,8 @@ cp_parser_new_placement (cp_parser* parser)\n {\n   tree expression_list;\n \n-  /* Look for the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n-    return error_mark_node;\n   /* Parse the expression-list.  */\n-  expression_list = cp_parser_expression_list (parser);\n-  /* Look for the closing `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n \n   return expression_list;\n }\n@@ -4633,16 +4673,9 @@ cp_parser_new_initializer (cp_parser* parser)\n {\n   tree expression_list;\n \n-  /* Look for the opening parenthesis.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n-  /* If the next token is not a `)', then there is an\n-     expression-list.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-    expression_list = cp_parser_expression_list (parser);\n-  else\n+  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n+  if (!expression_list)\n     expression_list = void_zero_node;\n-  /* Look for the closing parenthesis.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \n   return expression_list;\n }\n@@ -4738,7 +4771,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n \t If we find the closing `)', and the next token is a `{', then\n \t we are looking at a compound-literal.  */\n       compound_literal_p \n-\t= (cp_parser_skip_to_closing_parenthesis (parser)\n+\t= (cp_parser_skip_to_closing_parenthesis (parser, false, false)\n \t   && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n       /* Roll back the tokens we skipped.  */\n       cp_lexer_rollback_tokens (parser->lexer);\n@@ -5673,7 +5706,7 @@ cp_parser_selection_statement (cp_parser* parser)\n \tcondition = cp_parser_condition (parser);\n \t/* Look for the `)'.  */\n \tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n-\t  cp_parser_skip_to_closing_parenthesis (parser);\n+\t  cp_parser_skip_to_closing_parenthesis (parser, true, false);\n \n \tif (keyword == RID_IF)\n \t  {\n@@ -7072,17 +7105,10 @@ cp_parser_mem_initializer (cp_parser* parser)\n   member = expand_member_init (mem_initializer_id);\n   if (member && !DECL_P (member))\n     in_base_initializer = 1;\n-  \n-  /* Look for the opening `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n-  /* Parse the expression-list.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t  CPP_CLOSE_PAREN))\n-    expression_list = cp_parser_expression_list (parser);\n-  else\n+\n+  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n+  if (!expression_list)\n     expression_list = void_type_node;\n-  /* Look for the closing `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \n   in_base_initializer = 0;\n   \n@@ -9401,7 +9427,7 @@ cp_parser_asm_definition (cp_parser* parser)\n     }\n   /* Look for the closing `)'.  */\n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n-    cp_parser_skip_to_closing_parenthesis (parser);\n+    cp_parser_skip_to_closing_parenthesis (parser, true, false);\n   cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n \n   /* Create the ASM_STMT.  */\n@@ -9462,7 +9488,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   tree scope;\n   bool is_initialized;\n   bool is_parenthesized_init;\n-  bool ctor_dtor_or_conv_p;\n+  int ctor_dtor_or_conv_p;\n   bool friend_p;\n \n   /* Assume that this is not the declarator for a function\n@@ -9548,7 +9574,7 @@ cp_parser_init_declarator (cp_parser* parser,\n      We explicitly postpone this check past the point where we handle\n      function-definitions because we tolerate function-definitions\n      that are missing their return types in some modes.  */\n-  if (!decl_specifiers && !ctor_dtor_or_conv_p)\n+  if (!decl_specifiers && ctor_dtor_or_conv_p <= 0)\n     {\n       cp_parser_error (parser, \n \t\t       \"expected constructor, destructor, or type conversion\");\n@@ -9720,10 +9746,12 @@ cp_parser_init_declarator (cp_parser* parser,\n    cv-qualifiers will be stored in the TREE_TYPE of the INDIRECT_REF\n    node.\n \n-   If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is set to\n-   true if this declarator represents a constructor, destructor, or\n-   type conversion operator.  Otherwise, it is set to false.  \n-\n+   If CTOR_DTOR_OR_CONV_P is not NULL, *CTOR_DTOR_OR_CONV_P is used to\n+   detect constructor, destructor or conversion operators. It is set\n+   to -1 if the declarator is a name, and +1 if it is a\n+   function. Otherwise it is set to zero. Usually you just want to\n+   test for >0, but internally the negative value is used.\n+   \n    (The reason for CTOR_DTOR_OR_CONV_P is that a declaration must have\n    a decl-specifier-seq unless it declares a constructor, destructor,\n    or conversion.  It might seem that we could check this condition in\n@@ -9735,7 +9763,7 @@ cp_parser_init_declarator (cp_parser* parser,\n static tree\n cp_parser_declarator (cp_parser* parser, \n                       cp_parser_declarator_kind dcl_kind, \n-                      bool* ctor_dtor_or_conv_p)\n+                      int* ctor_dtor_or_conv_p)\n {\n   cp_token *token;\n   tree declarator;\n@@ -9747,7 +9775,7 @@ cp_parser_declarator (cp_parser* parser,\n   /* Assume this is not a constructor, destructor, or type-conversion\n      operator.  */\n   if (ctor_dtor_or_conv_p)\n-    *ctor_dtor_or_conv_p = false;\n+    *ctor_dtor_or_conv_p = 0;\n \n   if (cp_parser_allow_gnu_extensions_p (parser))\n     attributes = cp_parser_attributes_opt (parser);\n@@ -9792,8 +9820,7 @@ cp_parser_declarator (cp_parser* parser,\n     }\n   /* Everything else is a direct-declarator.  */\n   else\n-    declarator = cp_parser_direct_declarator (parser, \n-\t\t\t\t\t      dcl_kind,\n+    declarator = cp_parser_direct_declarator (parser, dcl_kind,\n \t\t\t\t\t      ctor_dtor_or_conv_p);\n \n   if (attributes && declarator != error_mark_node)\n@@ -9841,7 +9868,7 @@ cp_parser_declarator (cp_parser* parser,\n static tree\n cp_parser_direct_declarator (cp_parser* parser,\n                              cp_parser_declarator_kind dcl_kind,\n-                             bool* ctor_dtor_or_conv_p)\n+                             int* ctor_dtor_or_conv_p)\n {\n   cp_token *token;\n   tree declarator = NULL_TREE;\n@@ -9919,7 +9946,9 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t{\n \t\t  tree cv_qualifiers;\n \t\t  tree exception_specification;\n-\t\t  \n+\n+\t\t  if (ctor_dtor_or_conv_p)\n+\t\t    *ctor_dtor_or_conv_p = *ctor_dtor_or_conv_p < 0;\n \t\t  first = false;\n \t\t  /* Consume the `)'.  */\n \t\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n@@ -9976,6 +10005,9 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  /* Parse an array-declarator.  */\n \t  tree bounds;\n \n+\t  if (ctor_dtor_or_conv_p)\n+\t    *ctor_dtor_or_conv_p = 0;\n+\t  \n \t  first = false;\n \t  parser->default_arg_ok_p = false;\n \t  parser->in_declarator_p = true;\n@@ -10091,7 +10123,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      if (TREE_CODE (unqualified_name) == BIT_NOT_EXPR\n \t\t  || IDENTIFIER_TYPENAME_P (unqualified_name)\n \t\t  || constructor_name_p (unqualified_name, class_type))\n-\t\t*ctor_dtor_or_conv_p = true;\n+\t\t*ctor_dtor_or_conv_p = -1;\n \t    }\n \n \thandle_declarator:;\n@@ -11052,15 +11084,7 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init)\n       init = cp_parser_initializer_clause (parser);\n     }\n   else if (token->type == CPP_OPEN_PAREN)\n-    {\n-      /* Consume the `('.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      /* Parse the expression-list.  */\n-      init = cp_parser_expression_list (parser);\n-      /* Consume the `)' token.  */\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n-\tcp_parser_skip_to_closing_parenthesis (parser);\n-    }\n+    init = cp_parser_parenthesized_expression_list (parser, false);\n   else\n     {\n       /* Anything else is an error.  */\n@@ -12057,7 +12081,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      tree declarator;\n \t      tree initializer;\n \t      tree asm_specification;\n-\t      bool ctor_dtor_or_conv_p;\n+\t      int ctor_dtor_or_conv_p;\n \n \t      /* Parse the declarator.  */\n \t      declarator \n@@ -12923,47 +12947,11 @@ cp_parser_attribute_list (cp_parser* parser)\n       if (token->type == CPP_OPEN_PAREN)\n \t{\n \t  tree arguments;\n-\t  int arguments_allowed_p = 1;\n-\n-\t  /* Consume the `('.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  /* Peek at the next token.  */\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\t  /* Check to see if the next token is an identifier.  */\n-\t  if (token->type == CPP_NAME)\n-\t    {\n-\t      /* Save the identifier.  */\n-\t      identifier = token->value;\n-\t      /* Consume the identifier.  */\n-\t      cp_lexer_consume_token (parser->lexer);\n-\t      /* Peek at the next token.  */\n-\t      token = cp_lexer_peek_token (parser->lexer);\n-\t      /* If the next token is a `,', then there are some other\n-\t\t expressions as well.  */\n-\t      if (token->type == CPP_COMMA)\n-\t\t/* Consume the comma.  */\n-\t\tcp_lexer_consume_token (parser->lexer);\n-\t      else\n-\t\targuments_allowed_p = 0;\n-\t    }\n-\t  else\n-\t    identifier = NULL_TREE;\n \n-\t  /* If there are arguments, parse them too.  */\n-\t  if (arguments_allowed_p)\n-\t    arguments = cp_parser_expression_list (parser);\n-\t  else\n-\t    arguments = NULL_TREE;\n-\n-\t  /* Combine the identifier and the arguments.  */\n-\t  if (identifier)\n-\t    arguments = tree_cons (NULL_TREE, identifier, arguments);\n+\t  arguments = cp_parser_parenthesized_expression_list (parser, true);\n \n \t  /* Save the identifier and arguments away.  */\n \t  TREE_VALUE (attribute) = arguments;\n-\n-\t  /* Look for the closing `)'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \t}\n \n       /* Add this attribute to the list.  */\n@@ -13926,17 +13914,7 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n {\n   tree expression_list;\n \n-  /* Look for the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n-    return error_mark_node;\n-  /* If the next token is not an `)', there are arguments to the\n-     cast.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-    expression_list = cp_parser_expression_list (parser);\n-  else\n-    expression_list = NULL_TREE;\n-  /* Look for the closing `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+  expression_list = cp_parser_parenthesized_expression_list (parser, false);\n \n   return build_functional_cast (type, expression_list);\n }"}, {"sha": "b9c64acea4f87fda0ce7a5409c7903dfda88fa95", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7efa3e22e56fdd56b73deb940c47a5beac0b866e", "patch": "@@ -11567,6 +11567,9 @@ type_dependent_expression_p (tree expression)\n   if (!processing_template_decl)\n     return false;\n \n+  if (expression == error_mark_node)\n+    return false;\n+  \n   /* Some expression forms are never type-dependent.  */\n   if (TREE_CODE (expression) == PSEUDO_DTOR_EXPR\n       || TREE_CODE (expression) == SIZEOF_EXPR\n@@ -11675,7 +11678,9 @@ any_type_dependent_arguments_p (tree args)\n {\n   while (args)\n     {\n-      if (type_dependent_expression_p (TREE_VALUE (args)))\n+      tree arg = TREE_VALUE (args);\n+\n+      if (type_dependent_expression_p (arg))\n \treturn true;\n       args = TREE_CHAIN (args);\n     }"}, {"sha": "a4e85cf38edf564e8007dea4e5211b3f054d6047", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7efa3e22e56fdd56b73deb940c47a5beac0b866e", "patch": "@@ -1,3 +1,9 @@\n+2003-07-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11050\n+\t* g++.dg/parse/args1.C: New test.\n+\t* g++.pt/defarg8.C: Change expected errors.\n+\n 2003-07-11  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/8164"}, {"sha": "0eb6e64b6346f4470d582b4cbd26b6c69ee8b2fc", "filename": "gcc/testsuite/g++.dg/parse/args1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fargs1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fargs1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fargs1.C?ref=7efa3e22e56fdd56b73deb940c47a5beac0b866e", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 9 Jul 2003 <nathan@codesourcery.com>\n+\n+// PR c++ 11050. Accepted ill-formed\n+\n+\n+void Foo (int)\n+{\n+  Foo(2 2); // { dg-error \"expected\" \"\" }\n+}"}, {"sha": "f60fffa99a6c9e4c5011b14790b13b71801fbe3b", "filename": "gcc/testsuite/g++.old-deja/g++.pt/defarg8.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efa3e22e56fdd56b73deb940c47a5beac0b866e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdefarg8.C?ref=7efa3e22e56fdd56b73deb940c47a5beac0b866e", "patch": "@@ -3,12 +3,15 @@\n // Default arguments containing more than one non-nested explicit\n // template argument leads to parse error\n \n+// This might be ill formed. See DR 325 (which would like to make it\n+// so)\n+\n template <class T> class foo1;\n template <class T, class U> class foo2;\n \n struct bar {\n   template <class T, class U>\n   bar(int i = foo1<T>::baz, // { dg-bogus \"\" \"\" { xfail *-*-* } }  - \n       int j = int(foo2<T, U>::baz), // ok\n-      int k = foo2<T, U>::baz) {} // { dg-bogus \"\" \"\" { xfail *-*-* } }  - before > - \n+      int k = foo2<T, U>::baz) {} // this is the problematic one.\n };"}]}