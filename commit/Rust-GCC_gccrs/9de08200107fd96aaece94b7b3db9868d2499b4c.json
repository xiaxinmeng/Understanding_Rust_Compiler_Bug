{"sha": "9de08200107fd96aaece94b7b3db9868d2499b4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRlMDgyMDAxMDdmZDk2YWFlY2U5NGI3YjNkYjk4NjhkMjQ5OWI0Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T11:37:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-24T11:37:15Z"}, "message": "(struct clear_by_pieces): New structure.\n\n(clear_by_pieces{,_1}, {is,mostly}_zeros_p): New functions.\n(clrstr_optab): New optab.\n(clear_storage): Rework to try to use clear_by_pieces, then\nnew clrstr insn, then library call.\n(store_constructor): Track if target is already cleared.\nClear target first if CONSTRUCTOR is mostly zeros.\nDon't write zeros if target has been cleared.\nAdd new arg to clear_storage call.\n(expand_expr, case CONSTRUCTOR): Don't put static constructor\nin memory if mostly zero.\n\nFrom-SVN: r10842", "tree": {"sha": "0e268edb54f8cd9413167b2de093ad8b555a5bce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e268edb54f8cd9413167b2de093ad8b555a5bce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9de08200107fd96aaece94b7b3db9868d2499b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de08200107fd96aaece94b7b3db9868d2499b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de08200107fd96aaece94b7b3db9868d2499b4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de08200107fd96aaece94b7b3db9868d2499b4c/comments", "author": null, "committer": null, "parents": [{"sha": "45169d1213d6566380b1309a2f1cd96326d38858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45169d1213d6566380b1309a2f1cd96326d38858", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45169d1213d6566380b1309a2f1cd96326d38858"}], "stats": {"total": 373, "additions": 347, "deletions": 26}, "files": [{"sha": "76da54f6117e67b0fa98e27ca3d09b82a6672989", "filename": "gcc/expr.c", "status": "modified", "additions": 347, "deletions": 26, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9de08200107fd96aaece94b7b3db9868d2499b4c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9de08200107fd96aaece94b7b3db9868d2499b4c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9de08200107fd96aaece94b7b3db9868d2499b4c", "patch": "@@ -130,6 +130,21 @@ struct move_by_pieces\n   int reverse;\n };\n \n+/* This structure is used by clear_by_pieces to describe the clear to\n+   be performed.  */\n+\n+struct clear_by_pieces\n+{\n+  rtx to;\n+  rtx to_addr;\n+  int autinc_to;\n+  int explicit_inc_to;\n+  int to_struct;\n+  int len;\n+  int offset;\n+  int reverse;\n+};\n+\n /* Used to generate bytecodes: keep track of size of local variables,\n    as well as depth of arithmetic stack. (Notice that variables are\n    stored on the machine's stack, not the arithmetic stack.) */\n@@ -147,6 +162,11 @@ static void move_by_pieces\tPROTO((rtx, rtx, int, int));\n static int move_by_pieces_ninsns PROTO((unsigned int, int));\n static void move_by_pieces_1\tPROTO((rtx (*) (), enum machine_mode,\n \t\t\t\t       struct move_by_pieces *));\n+static void clear_by_pieces\tPROTO((rtx, int, int));\n+static void clear_by_pieces_1\tPROTO((rtx (*) (), enum machine_mode,\n+\t\t\t\t       struct clear_by_pieces *));\n+static int is_zeros_p\t\tPROTO((tree));\n+static int mostly_zeros_p\tPROTO((tree));\n static void store_constructor\tPROTO((tree, rtx));\n static rtx store_field\t\tPROTO((rtx, int, int, enum machine_mode, tree,\n \t\t\t\t       enum machine_mode, int, int, int));\n@@ -216,6 +236,9 @@ static char direct_store[NUM_MACHINE_MODES];\n /* This array records the insn_code of insns to perform block moves.  */\n enum insn_code movstr_optab[NUM_MACHINE_MODES];\n \n+/* This array records the insn_code of insns to perform block clears.  */\n+enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n+\n /* SLOW_UNALIGNED_ACCESS is non-zero if unaligned accesses are very slow. */\n \n #ifndef SLOW_UNALIGNED_ACCESS\n@@ -1828,33 +1851,224 @@ use_regs (call_fusage, regno, nregs)\n     use_reg (call_fusage, gen_rtx (REG, reg_raw_mode[regno + i], regno + i));\n }\n \f\n+/* Generate several move instructions to clear LEN bytes of block TO.\n+   (A MEM rtx with BLKmode).   The caller must pass TO through\n+   protect_from_queue before calling. ALIGN (in bytes) is maximum alignment\n+   we can assume.  */\n+\n+static void\n+clear_by_pieces (to, len, align)\n+     rtx to;\n+     int len, align;\n+{\n+  struct clear_by_pieces data;\n+  rtx to_addr = XEXP (to, 0);\n+  int max_size = MOVE_MAX + 1;\n+\n+  data.offset = 0;\n+  data.to_addr = to_addr;\n+  data.to = to;\n+  data.autinc_to\n+    = (GET_CODE (to_addr) == PRE_INC || GET_CODE (to_addr) == PRE_DEC\n+       || GET_CODE (to_addr) == POST_INC || GET_CODE (to_addr) == POST_DEC);\n+\n+  data.explicit_inc_to = 0;\n+  data.reverse\n+    = (GET_CODE (to_addr) == PRE_DEC || GET_CODE (to_addr) == POST_DEC);\n+  if (data.reverse) data.offset = len;\n+  data.len = len;\n+\n+  data.to_struct = MEM_IN_STRUCT_P (to);\n+\n+  /* If copying requires more than two move insns,\n+     copy addresses to registers (to make displacements shorter)\n+     and use post-increment if available.  */\n+  if (!data.autinc_to\n+      && move_by_pieces_ninsns (len, align) > 2)\n+    {\n+#ifdef HAVE_PRE_DECREMENT\n+      if (data.reverse && ! data.autinc_to)\n+\t{\n+\t  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len));\n+\t  data.autinc_to = 1;\n+\t  data.explicit_inc_to = -1;\n+\t}\n+#endif\n+#ifdef HAVE_POST_INCREMENT\n+      if (! data.reverse && ! data.autinc_to)\n+\t{\n+\t  data.to_addr = copy_addr_to_reg (to_addr);\n+\t  data.autinc_to = 1;\n+\t  data.explicit_inc_to = 1;\n+\t}\n+#endif\n+      if (!data.autinc_to && CONSTANT_P (to_addr))\n+\tdata.to_addr = copy_addr_to_reg (to_addr);\n+    }\n+\n+  if (! SLOW_UNALIGNED_ACCESS\n+      || align > MOVE_MAX || align >= BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n+    align = MOVE_MAX;\n+\n+  /* First move what we can in the largest integer mode, then go to\n+     successively smaller modes.  */\n+\n+  while (max_size > 1)\n+    {\n+      enum machine_mode mode = VOIDmode, tmode;\n+      enum insn_code icode;\n+\n+      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+\tif (GET_MODE_SIZE (tmode) < max_size)\n+\t  mode = tmode;\n+\n+      if (mode == VOIDmode)\n+\tbreak;\n+\n+      icode = mov_optab->handlers[(int) mode].insn_code;\n+      if (icode != CODE_FOR_nothing\n+\t  && align >= MIN (BIGGEST_ALIGNMENT / BITS_PER_UNIT,\n+\t\t\t   GET_MODE_SIZE (mode)))\n+\tclear_by_pieces_1 (GEN_FCN (icode), mode, &data);\n+\n+      max_size = GET_MODE_SIZE (mode);\n+    }\n+\n+  /* The code above should have handled everything.  */\n+  if (data.len != 0)\n+    abort ();\n+}\n+\n+/* Subroutine of clear_by_pieces.  Clear as many bytes as appropriate\n+   with move instructions for mode MODE.  GENFUN is the gen_... function\n+   to make a move insn for that mode.  DATA has all the other info.  */\n+\n+static void\n+clear_by_pieces_1 (genfun, mode, data)\n+     rtx (*genfun) ();\n+     enum machine_mode mode;\n+     struct clear_by_pieces *data;\n+{\n+  register int size = GET_MODE_SIZE (mode);\n+  register rtx to1;\n+\n+  while (data->len >= size)\n+    {\n+      if (data->reverse) data->offset -= size;\n+\n+      to1 = (data->autinc_to\n+\t     ? gen_rtx (MEM, mode, data->to_addr)\n+\t     : change_address (data->to, mode,\n+\t\t\t       plus_constant (data->to_addr, data->offset)));\n+      MEM_IN_STRUCT_P (to1) = data->to_struct;\n+\n+#ifdef HAVE_PRE_DECREMENT\n+      if (data->explicit_inc_to < 0)\n+\temit_insn (gen_add2_insn (data->to_addr, GEN_INT (-size)));\n+#endif\n+\n+      emit_insn ((*genfun) (to1, const0_rtx));\n+#ifdef HAVE_POST_INCREMENT\n+      if (data->explicit_inc_to > 0)\n+\temit_insn (gen_add2_insn (data->to_addr, GEN_INT (size)));\n+#endif\n+\n+      if (! data->reverse) data->offset += size;\n+\n+      data->len -= size;\n+    }\n+}\n+\f\n /* Write zeros through the storage of OBJECT.\n-   If OBJECT has BLKmode, SIZE is its length in bytes.  */\n+   If OBJECT has BLKmode, SIZE is its length in bytes and ALIGN is\n+   the maximum alignment we can is has, measured in bytes.  */\n \n void\n-clear_storage (object, size)\n+clear_storage (object, size, align)\n      rtx object;\n      rtx size;\n+     int align;\n {\n   if (GET_MODE (object) == BLKmode)\n     {\n+      object = protect_from_queue (object, 1);\n+      size = protect_from_queue (size, 0);\n+\n+      if (GET_CODE (size) == CONST_INT\n+\t  && (move_by_pieces_ninsns (INTVAL (size), align) < MOVE_RATIO))\n+\tclear_by_pieces (object, INTVAL (size), align);\n+\n+      else\n+\t{\n+\t  /* Try the most limited insn first, because there's no point\n+\t     including more than one in the machine description unless\n+\t     the more limited one has some advantage.  */\n+\n+\t  rtx opalign = GEN_INT (align);\n+\t  enum machine_mode mode;\n+\n+\t  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+\t       mode = GET_MODE_WIDER_MODE (mode))\n+\t    {\n+\t      enum insn_code code = clrstr_optab[(int) mode];\n+\n+\t      if (code != CODE_FOR_nothing\n+\t\t  /* We don't need MODE to be narrower than\n+\t\t     BITS_PER_HOST_WIDE_INT here because if SIZE is less than\n+\t\t     the mode mask, as it is returned by the macro, it will\n+\t\t     definitely be less than the actual mode mask.  */\n+\t\t  && ((GET_CODE (size) == CONST_INT\n+\t\t       && ((unsigned HOST_WIDE_INT) INTVAL (size)\n+\t\t\t   <= GET_MODE_MASK (mode)))\n+\t\t      || GET_MODE_BITSIZE (mode) >= BITS_PER_WORD)\n+\t\t  && (insn_operand_predicate[(int) code][0] == 0\n+\t\t      || (*insn_operand_predicate[(int) code][0]) (object,\n+\t\t\t\t\t\t\t\t   BLKmode))\n+\t\t  && (insn_operand_predicate[(int) code][2] == 0\n+\t\t      || (*insn_operand_predicate[(int) code][2]) (opalign,\n+\t\t\t\t\t\t\t\t   VOIDmode)))\n+\t\t{\n+\t\t  rtx op1;\n+\t\t  rtx last = get_last_insn ();\n+\t\t  rtx pat;\n+\n+\t\t  op1 = convert_to_mode (mode, size, 1);\n+\t\t  if (insn_operand_predicate[(int) code][1] != 0\n+\t\t      && ! (*insn_operand_predicate[(int) code][1]) (op1,\n+\t\t\t\t\t\t\t\t     mode))\n+\t\t    op1 = copy_to_mode_reg (mode, op1);\n+\n+\t\t  pat = GEN_FCN ((int) code) (object, op1, opalign);\n+\t\t  if (pat)\n+\t\t    {\n+\t\t      emit_insn (pat);\n+\t\t      return;\n+\t\t    }\n+\t\t  else\n+\t\t    delete_insns_since (last);\n+\t\t}\n+\t    }\n+\n+\n #ifdef TARGET_MEM_FUNCTIONS\n-      emit_library_call (memset_libfunc, 0,\n-\t\t\t VOIDmode, 3,\n-\t\t\t XEXP (object, 0), Pmode,\n-\t\t\t const0_rtx, TYPE_MODE (integer_type_node),\n-\t\t\t convert_to_mode (TYPE_MODE (sizetype),\n-\t\t\t\t\t  size, TREE_UNSIGNED (sizetype)),\n-\t\t\t TYPE_MODE (sizetype));\n+\t  emit_library_call (memset_libfunc, 0,\n+\t\t\t     VOIDmode, 3,\n+\t\t\t     XEXP (object, 0), Pmode,\n+\t\t\t     const0_rtx, TYPE_MODE (integer_type_node),\n+\t\t\t     convert_to_mode (TYPE_MODE (sizetype),\n+\t\t\t\t\t      size, TREE_UNSIGNED (sizetype)),\n+\t\t\t     TYPE_MODE (sizetype));\n #else\n-      emit_library_call (bzero_libfunc, 0,\n-\t\t\t VOIDmode, 2,\n-\t\t\t XEXP (object, 0), Pmode,\t\n-\t\t\t convert_to_mode (TYPE_MODE (integer_type_node),\n-\t\t\t\t\t  size,\n-\t\t\t\t\t  TREE_UNSIGNED (integer_type_node)),\n-\t\t\t TYPE_MODE (integer_type_node));\n+\t  emit_library_call (bzero_libfunc, 0,\n+\t\t\t     VOIDmode, 2,\n+\t\t\t     XEXP (object, 0), Pmode,\t\n+\t\t\t     convert_to_mode (TYPE_MODE (integer_type_node),\n+\t\t\t\t\t      size,\n+\t\t\t\t\t      TREE_UNSIGNED (integer_type_node)),\n+\t\t\t     TYPE_MODE (integer_type_node));\n #endif\n+\t}\n     }\n   else\n     emit_move_insn (object, const0_rtx);\n@@ -2971,6 +3185,63 @@ store_expr (exp, target, want_value)\n     return target;\n }\n \f\n+/* Return 1 if EXP just contains zeros.  */\n+\n+static int\n+is_zeros_p (exp)\n+     tree exp;\n+{\n+  tree elt;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return is_zeros_p (TREE_OPERAND (exp, 0));\n+\n+    case INTEGER_CST:\n+      return TREE_INT_CST_LOW (exp) == 0 && TREE_INT_CST_HIGH (exp) == 0;\n+\n+    case COMPLEX_CST:\n+      return\n+\tis_zeros_p (TREE_REALPART (exp)) && is_zeros_p (TREE_IMAGPART (exp));\n+\n+    case REAL_CST:\n+      return REAL_VALUES_EQUAL (TREE_REAL_CST (exp), dconst0);\n+\n+    case CONSTRUCTOR:\n+      for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n+\tif (! is_zeros_p (TREE_VALUE (elt)))\n+\t  return 0;\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 1 if EXP contains mostly (3/4)  zeros.  */\n+\n+static int\n+mostly_zeros_p (exp)\n+     tree exp;\n+{\n+  tree elt;\n+  int elts = 0, zeros = 0;\n+\n+  if (TREE_CODE (exp) == CONSTRUCTOR)\n+    {\n+      for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt), elts++)\n+\tif (mostly_zeros_p (TREE_VALUE (elt)))\n+\t  zeros++;\n+\n+      return 4 * zeros >= 3 * elts;\n+    }\n+\n+  return is_zeros_p (exp);\n+}\n+\f\n /* Store the value of constructor EXP into the rtx TARGET.\n    TARGET is either a REG or a MEM.  */\n \n@@ -2999,6 +3270,7 @@ store_constructor (exp, target)\n       || TREE_CODE (type) == QUAL_UNION_TYPE)\n     {\n       register tree elt;\n+      int cleared = CONSTRUCTOR_TARGET_CLEARED_P (exp);\n \n       /* Inform later passes that the whole union value is dead.  */\n       if (TREE_CODE (type) == UNION_TYPE\n@@ -3011,13 +3283,26 @@ store_constructor (exp, target)\n \t this probably loses.  */\n       else if (GET_CODE (target) == REG && TREE_STATIC (exp)\n \t       && GET_MODE_SIZE (GET_MODE (target)) <= UNITS_PER_WORD)\n-\temit_move_insn (target, const0_rtx);\n+\t{\n+\t  if (! cleared)\n+\t    emit_move_insn (target, const0_rtx);\n \n-      /* If the constructor has fewer fields than the structure,\n+\t  cleared = 1;\n+\t}\n+\n+      /* If the constructor has fewer fields than the structure\n+\t or if we are initializing the structure to mostly zeros,\n \t clear the whole structure first.  */\n-      else if (list_length (CONSTRUCTOR_ELTS (exp))\n-\t       != list_length (TYPE_FIELDS (type)))\n-\tclear_storage (target, expr_size (exp));\n+      else if ((list_length (CONSTRUCTOR_ELTS (exp))\n+\t\t!= list_length (TYPE_FIELDS (type)))\n+\t       || mostly_zeros_p (exp))\n+\t{\n+\t  if (! cleared)\n+\t    clear_storage (target, expr_size (exp),\n+\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\n+\t  cleared = 1;\n+\t}\n       else\n \t/* Inform later passes that the old value is dead.  */\n \temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n@@ -3041,6 +3326,15 @@ store_constructor (exp, target)\n \t  if (field == 0)\n \t    continue;\n \n+\t  if (cleared)\n+\t    {\n+\t      if (is_zeros_p (TREE_VALUE (elt)))\n+\t\tcontinue;\n+\n+\t      else if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n+\t\tCONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = cleared;\n+\t    }\n+\n \t  bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n \t  unsignedp = TREE_UNSIGNED (field);\n \t  mode = DECL_MODE (field);\n@@ -3094,6 +3388,9 @@ store_constructor (exp, target)\n \t\t       VOIDmode, 0,\n \t\t       TYPE_ALIGN (type) / BITS_PER_UNIT,\n \t\t       int_size_in_bytes (type));\n+\n+\t  if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n+\t    CONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = 0;\n \t}\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -3104,14 +3401,22 @@ store_constructor (exp, target)\n       HOST_WIDE_INT minelt = TREE_INT_CST_LOW (TYPE_MIN_VALUE (domain));\n       HOST_WIDE_INT maxelt = TREE_INT_CST_LOW (TYPE_MAX_VALUE (domain));\n       tree elttype = TREE_TYPE (type);\n+      int cleared = CONSTRUCTOR_TARGET_CLEARED_P (exp);\n \n       /* If the constructor has fewer fields than the structure,\n \t clear the whole structure first.  Similarly if this this is\n \t static constructor of a non-BLKmode object.  */\n \n       if (list_length (CONSTRUCTOR_ELTS (exp)) < maxelt - minelt + 1\n+\t  || mostly_zeros_p (exp)\n \t  || (GET_CODE (target) == REG && TREE_STATIC (exp)))\n-\tclear_storage (target, expr_size (exp));\n+\t{\n+\t  if (! cleared)\n+\t    clear_storage (target, expr_size (exp),\n+\t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT);\n+\n+\t  cleared = 1;\n+\t}\n       else\n \t/* Inform later passes that the old value is dead.  */\n \temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n@@ -3130,6 +3435,15 @@ store_constructor (exp, target)\n \t  tree index = TREE_PURPOSE (elt);\n \t  rtx xtarget = target;\n \n+\t  if (cleared)\n+\t    {\n+\t      if (is_zeros_p (TREE_VALUE (elt)))\n+\t\tcontinue;\n+\n+\t      else if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n+\t\tCONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = cleared;\n+\t    }\n+\n \t  mode = TYPE_MODE (elttype);\n \t  bitsize = GET_MODE_BITSIZE (mode);\n \t  unsignedp = TREE_UNSIGNED (elttype);\n@@ -3166,6 +3480,9 @@ store_constructor (exp, target)\n \t\t\t   TYPE_ALIGN (type) / BITS_PER_UNIT,\n \t\t\t   int_size_in_bytes (type));\n \t    }\n+\n+\t  if (TREE_CODE (TREE_VALUE (elt)) == CONSTRUCTOR)\n+\t    CONSTRUCTOR_TARGET_CLEARED_P (TREE_VALUE (elt)) = 0;\n \t}\n     }\n   /* set constructor assignments */\n@@ -3193,7 +3510,8 @@ store_constructor (exp, target)\n       /* Check for all zeros. */\n       if (CONSTRUCTOR_ELTS (exp) == NULL_TREE)\n \t{\n-\t  clear_storage (target, expr_size (exp));\n+\t  clear_storage (target, expr_size (exp),\n+\t\t\t TYPE_ALIGN (type) / BITS_PER_UNIT);\n \t  return;\n \t}\n \n@@ -3315,7 +3633,8 @@ store_constructor (exp, target)\n \t\t\n \t      if (need_to_clear_first\n \t\t  && endb - startb != nbytes * BITS_PER_UNIT)\n-\t\tclear_storage (target, expr_size (exp));\n+\t\tclear_storage (target, expr_size (exp),\n+\t\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT);\n \t      need_to_clear_first = 0;\n \t      emit_library_call (memset_libfunc, 0,\n \t\t\t\t VOIDmode, 3,\n@@ -3330,7 +3649,8 @@ store_constructor (exp, target)\n \t    {\n \t      if (need_to_clear_first)\n \t\t{\n-\t\t  clear_storage (target, expr_size (exp));\n+\t\t  clear_storage (target, expr_size (exp),\n+\t\t\t\t TYPE_ALIGN (type) / BITS_PER_UNIT);\n \t\t  need_to_clear_first = 0;\n \t\t}\n \t      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__setbits\"),\n@@ -4521,7 +4841,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t&& (move_by_pieces_ninsns\n \t\t\t    (TREE_INT_CST_LOW (TYPE_SIZE (type))/BITS_PER_UNIT,\n \t\t\t     TYPE_ALIGN (type) / BITS_PER_UNIT)\n-\t\t\t    > MOVE_RATIO))))\n+\t\t\t    > MOVE_RATIO)\n+\t\t\t&& ! mostly_zeros_p (exp))))\n \t       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))\n \t{\n \t  rtx constructor = output_constant_def (exp);"}]}