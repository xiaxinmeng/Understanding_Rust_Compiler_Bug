{"sha": "b086a2eaf8ae0e915c0db1343687b924c680d2b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA4NmEyZWFmOGFlMGU5MTVjMGRiMTM0MzY4N2I5MjRjNjgwZDJiOA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-12-06T17:24:16Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-12-06T17:24:16Z"}, "message": "c-gimplify.c (gimplify_c_loop): Improve initial implementations for loops whose conditions are known at...\n\n\n\t* c-gimplify.c (gimplify_c_loop): Improve initial implementations\n\tfor loops whose conditions are known at compile-time.\n\t* gimplify.c (append_to_statement_list_1): Remove side_effects\n\tparameter, this function should never be called if its false.\n\t(append_to_statement_list): Only call append_to_statement_list_1\n\tif t is non-NULL tree with side-effects.\n\t(append_to_statement_list_force):  Likewise, if t is not NULL.\n\nFrom-SVN: r91784", "tree": {"sha": "f74af4b0c552ada8c4014524ef63c52b6957b4be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f74af4b0c552ada8c4014524ef63c52b6957b4be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b086a2eaf8ae0e915c0db1343687b924c680d2b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b086a2eaf8ae0e915c0db1343687b924c680d2b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b086a2eaf8ae0e915c0db1343687b924c680d2b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b086a2eaf8ae0e915c0db1343687b924c680d2b8/comments", "author": null, "committer": null, "parents": [{"sha": "ff8b369ad3ebb96866bc3fa10cdeaafc293e1a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff8b369ad3ebb96866bc3fa10cdeaafc293e1a1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff8b369ad3ebb96866bc3fa10cdeaafc293e1a1c"}], "stats": {"total": 76, "additions": 45, "deletions": 31}, "files": [{"sha": "f5e676e1afe1345f4bbadf44f1f9971677f478fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086a2eaf8ae0e915c0db1343687b924c680d2b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086a2eaf8ae0e915c0db1343687b924c680d2b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b086a2eaf8ae0e915c0db1343687b924c680d2b8", "patch": "@@ -1,3 +1,13 @@\n+2004-12-06  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* c-gimplify.c (gimplify_c_loop): Improve initial implementations\n+\tfor loops whose conditions are known at compile-time.\n+\t* gimplify.c (append_to_statement_list_1): Remove side_effects\n+\tparameter, this function should never be called if its false.\n+\t(append_to_statement_list): Only call append_to_statement_list_1\n+\tif t is non-NULL tree with side-effects.\n+\t(append_to_statement_list_force):  Likewise, if t is not NULL.\n+\n 2004-12-06  J\"orn Rennecke <joern.rennecke@st.com>\n \n \t* bt-load.c (btr_def_s): New member own_end;"}, {"sha": "db6cd88fd9b566459572b90937e03b9315cd9e4c", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086a2eaf8ae0e915c0db1343687b924c680d2b8/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086a2eaf8ae0e915c0db1343687b924c680d2b8/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=b086a2eaf8ae0e915c0db1343687b924c680d2b8", "patch": "@@ -338,56 +338,61 @@ gimplify_c_loop (tree cond, tree body, tree incr, bool cond_is_first)\n   location_t stmt_locus;\n \n   stmt_locus = input_location;\n+  stmt_list = NULL_TREE;\n+  entry = NULL_TREE;\n \n-  /* Detect do { ... } while (0) and don't generate loop construct.  */\n-  if (!cond_is_first && cond && integer_zerop (cond))\n-    top = cond = NULL;\n+  break_block = begin_bc_block (bc_break);\n+  cont_block = begin_bc_block (bc_continue);\n+\n+  /* If condition is zero don't generate a loop construct.  */\n+  if (cond && integer_zerop (cond))\n+    {\n+      top = NULL_TREE;\n+      exit = NULL_TREE;\n+      if (cond_is_first)\n+\t{\n+\t  t = build_bc_goto (bc_break);\n+\t  append_to_statement_list (t, &stmt_list);\n+\t}\n+    }\n   else\n     {\n       /* If we use a LOOP_EXPR here, we have to feed the whole thing\n \t back through the main gimplifier to lower it.  Given that we\n \t have to gimplify the loop body NOW so that we can resolve\n \t break/continue stmts, seems easier to just expand to gotos.  */\n       top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-    }\n-\n-  break_block = begin_bc_block (bc_break);\n \n-  if (top)\n-    {\n       /* If we have an exit condition, then we build an IF with gotos either\n \t out of the loop, or to the top of it.  If there's no exit condition,\n \t then we just build a jump back to the top.  */\n       exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n-      if (cond)\n+      if (cond && !integer_nonzerop (cond))\n \t{\n \t  t = build_bc_goto (bc_break);\n \t  exit = build3 (COND_EXPR, void_type_node, cond, exit, t);\n \t  exit = fold (exit);\n \t  gimplify_stmt (&exit);\n+\n+\t  if (cond_is_first)\n+\t    {\n+\t      if (incr)\n+\t\t{\n+\t\t  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+\t\t  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n+\t\t}\n+\t      else\n+\t\tt = build_bc_goto (bc_continue);\n+\t      append_to_statement_list (t, &stmt_list);\n+\t    }\n \t}\n     }\n-  else\n-    exit = NULL_TREE;\n-\n-  cont_block = begin_bc_block (bc_continue);\n \n   gimplify_stmt (&body);\n   gimplify_stmt (&incr);\n \n   body = finish_bc_block (cont_block, body);\n \n-  stmt_list = NULL;\n-\n-  if (cond_is_first && cond)\n-    {\n-      entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-      t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n-      append_to_statement_list (t, &stmt_list);\n-    }\n-  else\n-    entry = NULL_TREE;\n-\n   append_to_statement_list (top, &stmt_list);\n   append_to_statement_list (body, &stmt_list);\n   append_to_statement_list (incr, &stmt_list);"}, {"sha": "41814a7fddf305a9f172281b592e5b5a1b178767", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086a2eaf8ae0e915c0db1343687b924c680d2b8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086a2eaf8ae0e915c0db1343687b924c680d2b8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b086a2eaf8ae0e915c0db1343687b924c680d2b8", "patch": "@@ -214,17 +214,14 @@ gimple_pop_condition (tree *pre_p)\n     }\n }\n \n-/* A subroutine of append_to_statement_list{,_force}.  */\n+/* A subroutine of append_to_statement_list{,_force}.  T is not NULL.  */\n \n static void\n-append_to_statement_list_1 (tree t, tree *list_p, bool side_effects)\n+append_to_statement_list_1 (tree t, tree *list_p)\n {\n   tree list = *list_p;\n   tree_stmt_iterator i;\n \n-  if (!side_effects)\n-    return;\n-\n   if (!list)\n     {\n       if (t && TREE_CODE (t) == STATEMENT_LIST)\n@@ -245,15 +242,17 @@ append_to_statement_list_1 (tree t, tree *list_p, bool side_effects)\n void\n append_to_statement_list (tree t, tree *list_p)\n {\n-  append_to_statement_list_1 (t, list_p, t ? TREE_SIDE_EFFECTS (t) : false);\n+  if (t && TREE_SIDE_EFFECTS (t))\n+    append_to_statement_list_1 (t, list_p);\n }\n \n /* Similar, but the statement is always added, regardless of side effects.  */\n \n void\n append_to_statement_list_force (tree t, tree *list_p)\n {\n-  append_to_statement_list_1 (t, list_p, t != NULL);\n+  if (t != NULL_TREE)\n+    append_to_statement_list_1 (t, list_p);\n }\n \n /* Both gimplify the statement T and append it to LIST_P.  */"}]}