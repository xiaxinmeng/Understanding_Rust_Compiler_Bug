{"sha": "3553f0bb324124195a64ce30c0832463e9082461", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1M2YwYmIzMjQxMjQxOTVhNjRjZTMwYzA4MzI0NjNlOTA4MjQ2MQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-11-19T21:20:44Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-11-19T21:20:44Z"}, "message": "re PR middle-end/37790 (limits-fnargs.c takes very long time to compile at -O2)\n\n2008-11-15  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR bootstrap/37790\n\t* ira-int.h (ira_copy_allocno_live_range_list,\n\tira_merge_allocno_live_ranges,\n\tira_allocno_live_ranges_intersect_p,\n\tira_finish_allocno_live_range_list): New prototypes.\n\t(ira_allocno_live_ranges_intersect_p,\n\tira_pseudo_live_ranges_intersect_p): Remove.\n\t\n\t* ira-conflicts.c (ira_allocno_live_ranges_intersect_p,\n\tira_pseudo_live_ranges_intersect_p): Rename to\n\tallocnos_have_intersected_live_ranges_p and\n\tpseudos_have_intersected_live_ranges_p.  Move them from here to\n\t...\n\n\t* ira-color.c: ... here\n\t(coalesced_allocno_conflict_p): Use\n\tallocnos_have_intersected_live_ranges_p.\n\t(coalesced_allocnos_living_at_program_points,\n\tcoalesced_allocnos_live_at_points_p,\n\tset_coalesced_allocnos_live_points): Remove.\n\t(slot_coalesced_allocnos_live_ranges,\n\tslot_coalesced_allocno_live_ranges_intersect_p,\n\tsetup_slot_coalesced_allocno_live_ranges): New.\n\t(coalesce_spill_slots): Use ranges of coalesced allocnos.\n\t(ira_sort_regnos_for_alter_reg): Use\n\tallocnos_have_intersected_live_ranges_p.\n\t(ira_reuse_stack_slot): Use\n\tpseudos_have_intersected_live_ranges_p.\n\n\t* global.c (pseudo_for_reload_consideration_p): Check\n\tflag_ira_share_spill_slots too.\n\n\t* ira-build.c (copy_allocno_live_range_list): Rename to\n\tira_copy_allocno_live_range_list.  Make it external.\n\t(merge_ranges): Rename to ira_merge_allocno_live_ranges.  Make it\n\texternal.\n\t(ira_allocno_live_ranges_intersect_p): New.\n\t(ira_finish_allocno_live_range_list): New.\n\t(finish_allocno): Use it.\n\t(remove_unnecessary_allocnos): Use ira_merge_allocno_live_ranges.\n\t(copy_info_to_removed_store_destinations): Ditto.  Use\n\tira_copy_allocno_live_range_list.\n\t(ira_flattening): Use ira_merge_allocno_live_ranges.\n\t\n\t* ira.c (too_high_register_pressure_p): New function.\n\t(ira): Switch off sharing spill slots if the pressure is too high.\n\nFrom-SVN: r142017", "tree": {"sha": "5b79c7c3d997c7b687af33f6229b6111cc84177b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b79c7c3d997c7b687af33f6229b6111cc84177b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3553f0bb324124195a64ce30c0832463e9082461", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3553f0bb324124195a64ce30c0832463e9082461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3553f0bb324124195a64ce30c0832463e9082461", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3553f0bb324124195a64ce30c0832463e9082461/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2de6c675d3b3c7a32dee10fee434e120f8cbd05f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de6c675d3b3c7a32dee10fee434e120f8cbd05f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de6c675d3b3c7a32dee10fee434e120f8cbd05f"}], "stats": {"total": 468, "additions": 289, "deletions": 179}, "files": [{"sha": "eacb5e0e5888790dbbff06b32ac42ac7c998eab7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553f0bb324124195a64ce30c0832463e9082461/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553f0bb324124195a64ce30c0832463e9082461/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3553f0bb324124195a64ce30c0832463e9082461", "patch": "@@ -1,3 +1,52 @@\n+2008-11-15  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR bootstrap/37790\n+\t* ira-int.h (ira_copy_allocno_live_range_list,\n+\tira_merge_allocno_live_ranges,\n+\tira_allocno_live_ranges_intersect_p,\n+\tira_finish_allocno_live_range_list): New prototypes.\n+\t(ira_allocno_live_ranges_intersect_p,\n+\tira_pseudo_live_ranges_intersect_p): Remove.\n+\t\n+\t* ira-conflicts.c (ira_allocno_live_ranges_intersect_p,\n+\tira_pseudo_live_ranges_intersect_p): Rename to\n+\tallocnos_have_intersected_live_ranges_p and\n+\tpseudos_have_intersected_live_ranges_p.  Move them from here to\n+\t...\n+\n+\t* ira-color.c: ... here\n+\t(coalesced_allocno_conflict_p): Use\n+\tallocnos_have_intersected_live_ranges_p.\n+\t(coalesced_allocnos_living_at_program_points,\n+\tcoalesced_allocnos_live_at_points_p,\n+\tset_coalesced_allocnos_live_points): Remove.\n+\t(slot_coalesced_allocnos_live_ranges,\n+\tslot_coalesced_allocno_live_ranges_intersect_p,\n+\tsetup_slot_coalesced_allocno_live_ranges): New.\n+\t(coalesce_spill_slots): Use ranges of coalesced allocnos.\n+\t(ira_sort_regnos_for_alter_reg): Use\n+\tallocnos_have_intersected_live_ranges_p.\n+\t(ira_reuse_stack_slot): Use\n+\tpseudos_have_intersected_live_ranges_p.\n+\n+\t* global.c (pseudo_for_reload_consideration_p): Check\n+\tflag_ira_share_spill_slots too.\n+\n+\t* ira-build.c (copy_allocno_live_range_list): Rename to\n+\tira_copy_allocno_live_range_list.  Make it external.\n+\t(merge_ranges): Rename to ira_merge_allocno_live_ranges.  Make it\n+\texternal.\n+\t(ira_allocno_live_ranges_intersect_p): New.\n+\t(ira_finish_allocno_live_range_list): New.\n+\t(finish_allocno): Use it.\n+\t(remove_unnecessary_allocnos): Use ira_merge_allocno_live_ranges.\n+\t(copy_info_to_removed_store_destinations): Ditto.  Use\n+\tira_copy_allocno_live_range_list.\n+\t(ira_flattening): Use ira_merge_allocno_live_ranges.\n+\t\n+\t* ira.c (too_high_register_pressure_p): New function.\n+\t(ira): Switch off sharing spill slots if the pressure is too high.\n+\n 2008-11-19  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.c (build2_stat): Allow non-POINTER_PLUS_EXPRs with"}, {"sha": "824fcf0f702f1e49bb41ec2aea63691ed887f66e", "filename": "gcc/global.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=3553f0bb324124195a64ce30c0832463e9082461", "patch": "@@ -1393,7 +1393,8 @@ pseudo_for_reload_consideration_p (int regno)\n {\n   /* Consider spilled pseudos too for IRA because they still have a\n      chance to get hard-registers in the reload when IRA is used.  */\n-  return reg_renumber[regno] >= 0 || (flag_ira && optimize);\n+  return (reg_renumber[regno] >= 0\n+\t  || (flag_ira && optimize && flag_ira_share_spill_slots));\n }\n \n /* Walk the insns of the current function and build reload_insn_chain,"}, {"sha": "af1d1747a5bda7cbb0b1b2f908308da3c8251a0b", "filename": "gcc/ira-build.c", "status": "modified", "additions": 119, "deletions": 91, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=3553f0bb324124195a64ce30c0832463e9082461", "patch": "@@ -826,8 +826,8 @@ copy_allocno_live_range (allocno_live_range_t r)\n \n /* Copy allocno live range list given by its head R and return the\n    result.  */\n-static allocno_live_range_t\n-copy_allocno_live_range_list (allocno_live_range_t r)\n+allocno_live_range_t\n+ira_copy_allocno_live_range_list (allocno_live_range_t r)\n {\n   allocno_live_range_t p, first, last;\n \n@@ -845,13 +845,123 @@ copy_allocno_live_range_list (allocno_live_range_t r)\n   return first;\n }\n \n+/* Merge ranges R1 and R2 and returns the result.  The function\n+   maintains the order of ranges and tries to minimize number of the\n+   result ranges.  */\n+allocno_live_range_t \n+ira_merge_allocno_live_ranges (allocno_live_range_t r1,\n+\t\t\t       allocno_live_range_t r2)\n+{\n+  allocno_live_range_t first, last, temp;\n+\n+  if (r1 == NULL)\n+    return r2;\n+  if (r2 == NULL)\n+    return r1;\n+  for (first = last = NULL; r1 != NULL && r2 != NULL;)\n+    {\n+      if (r1->start < r2->start)\n+\t{\n+\t  temp = r1;\n+\t  r1 = r2;\n+\t  r2 = temp;\n+\t}\n+      if (r1->start <= r2->finish + 1)\n+\t{\n+\t  /* Intersected ranges: merge r1 and r2 into r1.  */\n+\t  r1->start = r2->start;\n+\t  if (r1->finish < r2->finish)\n+\t    r1->finish = r2->finish;\n+\t  temp = r2;\n+\t  r2 = r2->next;\n+\t  ira_finish_allocno_live_range (temp);\n+\t  if (r2 == NULL)\n+\t    {\n+\t      /* To try to merge with subsequent ranges in r1.  */\n+\t      r2 = r1->next;\n+\t      r1->next = NULL;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Add r1 to the result.  */\n+\t  if (first == NULL)\n+\t    first = last = r1;\n+\t  else\n+\t    {\n+\t      last->next = r1;\n+\t      last = r1;\n+\t    }\n+\t  r1 = r1->next;\n+\t  if (r1 == NULL)\n+\t    {\n+\t      /* To try to merge with subsequent ranges in r2.  */\n+\t      r1 = r2->next;\n+\t      r2->next = NULL;\n+\t    }\n+\t}\n+    }\n+  if (r1 != NULL)\n+    {\n+      if (first == NULL)\n+\tfirst = r1;\n+      else\n+\tlast->next = r1;\n+      ira_assert (r1->next == NULL);\n+    }\n+  else if (r2 != NULL)\n+    {\n+      if (first == NULL)\n+\tfirst = r2;\n+      else\n+\tlast->next = r2;\n+      ira_assert (r2->next == NULL);\n+    }\n+  else\n+    {\n+      ira_assert (last->next == NULL);\n+    }\n+  return first;\n+}\n+\n+/* Return TRUE if live ranges R1 and R2 intersect.  */\n+bool\n+ira_allocno_live_ranges_intersect_p (allocno_live_range_t r1,\n+\t\t\t\t     allocno_live_range_t r2)\n+{\n+  /* Remember the live ranges are always kept ordered.  */\n+  while (r1 != NULL && r2 != NULL)\n+    {\n+      if (r1->start > r2->finish)\n+\tr1 = r1->next;\n+      else if (r2->start > r1->finish)\n+\tr2 = r2->next;\n+      else\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Free allocno live range R.  */\n void\n ira_finish_allocno_live_range (allocno_live_range_t r)\n {\n   pool_free (allocno_live_range_pool, r);\n }\n \n+/* Free list of allocno live ranges starting with R.  */\n+void\n+ira_finish_allocno_live_range_list (allocno_live_range_t r)\n+{\n+  allocno_live_range_t next_r;\n+\n+  for (; r != NULL; r = next_r)\n+    {\n+      next_r = r->next;\n+      ira_finish_allocno_live_range (r);\n+    }\n+}\n+\n /* Free updated register costs of allocno A.  */\n void\n ira_free_allocno_updated_costs (ira_allocno_t a)\n@@ -872,7 +982,6 @@ ira_free_allocno_updated_costs (ira_allocno_t a)\n static void\n finish_allocno (ira_allocno_t a)\n {\n-  allocno_live_range_t r, next_r;\n   enum reg_class cover_class = ALLOCNO_COVER_CLASS (a);\n \n   ira_allocnos[ALLOCNO_NUM (a)] = NULL;\n@@ -888,11 +997,7 @@ finish_allocno (ira_allocno_t a)\n   if (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a) != NULL)\n     ira_free_cost_vector (ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (a),\n \t\t\t  cover_class);\n-  for (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = next_r)\n-    {\n-      next_r = r->next;\n-      ira_finish_allocno_live_range (r);\n-    }\n+  ira_finish_allocno_live_range_list (ALLOCNO_LIVE_RANGES (a));\n   pool_free (allocno_pool, a);\n }\n \n@@ -1543,84 +1648,6 @@ create_allocnos (void)\n    will hardly improve the result.  As a result we speed up regional\n    register allocation.  */\n \n-/* Merge ranges R1 and R2 and returns the result.  The function\n-   maintains the order of ranges and tries to minimize number of the\n-   result ranges.  */\n-static allocno_live_range_t \n-merge_ranges (allocno_live_range_t r1, allocno_live_range_t r2)\n-{\n-  allocno_live_range_t first, last, temp;\n-\n-  if (r1 == NULL)\n-    return r2;\n-  if (r2 == NULL)\n-    return r1;\n-  for (first = last = NULL; r1 != NULL && r2 != NULL;)\n-    {\n-      if (r1->start < r2->start)\n-\t{\n-\t  temp = r1;\n-\t  r1 = r2;\n-\t  r2 = temp;\n-\t}\n-      if (r1->start <= r2->finish + 1)\n-\t{\n-\t  /* Intersected ranges: merge r1 and r2 into r1.  */\n-\t  r1->start = r2->start;\n-\t  if (r1->finish < r2->finish)\n-\t    r1->finish = r2->finish;\n-\t  temp = r2;\n-\t  r2 = r2->next;\n-\t  ira_finish_allocno_live_range (temp);\n-\t  if (r2 == NULL)\n-\t    {\n-\t      /* To try to merge with subsequent ranges in r1.  */\n-\t      r2 = r1->next;\n-\t      r1->next = NULL;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Add r1 to the result.  */\n-\t  if (first == NULL)\n-\t    first = last = r1;\n-\t  else\n-\t    {\n-\t      last->next = r1;\n-\t      last = r1;\n-\t    }\n-\t  r1 = r1->next;\n-\t  if (r1 == NULL)\n-\t    {\n-\t      /* To try to merge with subsequent ranges in r2.  */\n-\t      r1 = r2->next;\n-\t      r2->next = NULL;\n-\t    }\n-\t}\n-    }\n-  if (r1 != NULL)\n-    {\n-      if (first == NULL)\n-\tfirst = r1;\n-      else\n-\tlast->next = r1;\n-      ira_assert (r1->next == NULL);\n-    }\n-  else if (r2 != NULL)\n-    {\n-      if (first == NULL)\n-\tfirst = r2;\n-      else\n-\tlast->next = r2;\n-      ira_assert (r2->next == NULL);\n-    }\n-  else\n-    {\n-      ira_assert (last->next == NULL);\n-    }\n-  return first;\n-}\n-\n /* The function changes allocno in range list given by R onto A.  */\n static void\n change_allocno_in_range_list (allocno_live_range_t r, ira_allocno_t a)\n@@ -1762,7 +1789,8 @@ remove_unnecessary_allocnos (void)\n \t\tr = ALLOCNO_LIVE_RANGES (a);\n \t\tchange_allocno_in_range_list (r, parent_a);\n \t\tALLOCNO_LIVE_RANGES (parent_a)\n-\t\t  = merge_ranges (r, ALLOCNO_LIVE_RANGES (parent_a));\n+\t\t  = ira_merge_allocno_live_ranges\n+\t\t    (r, ALLOCNO_LIVE_RANGES (parent_a));\n \t\tmerged_p = true;\n \t\tALLOCNO_LIVE_RANGES (a) = NULL;\n \t\tIOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (parent_a),\n@@ -2155,10 +2183,10 @@ copy_info_to_removed_store_destinations (int regno)\n \t  ira_print_live_range_list (ira_dump_file,\n \t\t\t\t     ALLOCNO_LIVE_RANGES (a));\n \t}\n-      r = copy_allocno_live_range_list (ALLOCNO_LIVE_RANGES (a));\n+      r = ira_copy_allocno_live_range_list (ALLOCNO_LIVE_RANGES (a));\n       change_allocno_in_range_list (r, parent_a);\n       ALLOCNO_LIVE_RANGES (parent_a)\n-\t= merge_ranges (r, ALLOCNO_LIVE_RANGES (parent_a));\n+\t= ira_merge_allocno_live_ranges (r, ALLOCNO_LIVE_RANGES (parent_a));\n       IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (parent_a),\n \t\t\tALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n #ifdef STACK_REGS\n@@ -2255,8 +2283,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t\t}\n \t      change_allocno_in_range_list (ALLOCNO_LIVE_RANGES (a), parent_a);\n \t      ALLOCNO_LIVE_RANGES (parent_a)\n-\t\t= merge_ranges (ALLOCNO_LIVE_RANGES (a),\n-\t\t\t\tALLOCNO_LIVE_RANGES (parent_a));\n+\t\t= ira_merge_allocno_live_ranges\n+\t\t  (ALLOCNO_LIVE_RANGES (a), ALLOCNO_LIVE_RANGES (parent_a));\n \t      merged_p = true;\n \t      ALLOCNO_LIVE_RANGES (a) = NULL;\n \t      ALLOCNO_MEM_OPTIMIZED_DEST_P (parent_a)"}, {"sha": "7343e0c8078a38a4e85b000457d69f2578ad1955", "filename": "gcc/ira-color.c", "status": "modified", "additions": 85, "deletions": 39, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=3553f0bb324124195a64ce30c0832463e9082461", "patch": "@@ -84,6 +84,49 @@ static VEC(ira_allocno_t,heap) *removed_splay_allocno_vec;\n \n \f\n \n+/* This page contains functions used to find conflicts using allocno\n+   live ranges.  */\n+\n+/* Return TRUE if live ranges of allocnos A1 and A2 intersect.  It is\n+   used to find a conflict for new allocnos or allocnos with the\n+   different cover classes.  */\n+static bool\n+allocnos_have_intersected_live_ranges_p (ira_allocno_t a1, ira_allocno_t a2)\n+{\n+  if (a1 == a2)\n+    return false;\n+  if (ALLOCNO_REG (a1) != NULL && ALLOCNO_REG (a2) != NULL\n+      && (ORIGINAL_REGNO (ALLOCNO_REG (a1))\n+\t  == ORIGINAL_REGNO (ALLOCNO_REG (a2))))\n+    return false;\n+  return ira_allocno_live_ranges_intersect_p (ALLOCNO_LIVE_RANGES (a1),\n+\t\t\t\t\t      ALLOCNO_LIVE_RANGES (a2));\n+}\n+\n+#ifdef ENABLE_IRA_CHECKING\n+\n+/* Return TRUE if live ranges of pseudo-registers REGNO1 and REGNO2\n+   intersect.  This should be used when there is only one region.\n+   Currently this is used during reload.  */\n+static bool\n+pseudos_have_intersected_live_ranges_p (int regno1, int regno2)\n+{\n+  ira_allocno_t a1, a2;\n+\n+  ira_assert (regno1 >= FIRST_PSEUDO_REGISTER\n+\t      && regno2 >= FIRST_PSEUDO_REGISTER);\n+  /* Reg info caclulated by dataflow infrastructure can be different\n+     from one calculated by regclass.  */\n+  if ((a1 = ira_loop_tree_root->regno_allocno_map[regno1]) == NULL\n+      || (a2 = ira_loop_tree_root->regno_allocno_map[regno2]) == NULL)\n+    return false;\n+  return allocnos_have_intersected_live_ranges_p (a1, a2);\n+}\n+\n+#endif\n+\n+\f\n+\n /* This page contains functions used to choose hard registers for\n    allocnos.  */\n \n@@ -1489,7 +1532,8 @@ coalesced_allocno_conflict_p (ira_allocno_t a1, ira_allocno_t a2,\n \t       conflict_allocno\n \t\t = ALLOCNO_NEXT_COALESCED_ALLOCNO (conflict_allocno))\n \t    {\n-\t      if (ira_allocno_live_ranges_intersect_p (a, conflict_allocno))\n+\t      if (allocnos_have_intersected_live_ranges_p (a,\n+\t\t\t\t\t\t\t   conflict_allocno))\n \t\treturn true;\n \t      if (conflict_allocno == a1)\n \t\tbreak;\n@@ -2319,48 +2363,48 @@ collect_spilled_coalesced_allocnos (int *pseudo_regnos, int n,\n   return num;\n }\n \n-/* Array of bitmaps of size IRA_MAX_POINT.  Bitmap for given point\n-   contains numbers of coalesced allocnos living at this point.  */\n-static regset_head *coalesced_allocnos_living_at_program_points;\n+/* Array of live ranges of size IRA_ALLOCNOS_NUM.  Live range for\n+   given slot contains live ranges of coalesced allocnos assigned to\n+   given slot.  */\n+static allocno_live_range_t *slot_coalesced_allocnos_live_ranges;\n \n-/* Return TRUE if coalesced allocnos represented by ALLOCNO live at\n-   program points of coalesced allocnos with number N.  */\n+/* Return TRUE if coalesced allocnos represented by ALLOCNO has live\n+   ranges intersected with live ranges of coalesced allocnos assigned\n+   to slot with number N.  */\n static bool\n-coalesced_allocnos_live_at_points_p (ira_allocno_t allocno, int n)\n+slot_coalesced_allocno_live_ranges_intersect_p (ira_allocno_t allocno, int n)\n {\n-  int i;\n   ira_allocno_t a;\n-  allocno_live_range_t r;\n \n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      for (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = r->next)\n-\tfor (i = r->start; i <= r->finish; i++)\n-\t  if (bitmap_bit_p (&coalesced_allocnos_living_at_program_points[i], n))\n-\t      return true;\n+      if (ira_allocno_live_ranges_intersect_p\n+\t  (slot_coalesced_allocnos_live_ranges[n], ALLOCNO_LIVE_RANGES (a)))\n+\treturn true;\n       if (a == allocno)\n \tbreak;\n     }\n   return false;\n }\n \n-/* Mark program points where coalesced allocnos represented by ALLOCNO\n-   live.  */\n+/* Update live ranges of slot to which coalesced allocnos represented\n+   by ALLOCNO were assigned.  */\n static void\n-set_coalesced_allocnos_live_points (ira_allocno_t allocno)\n+setup_slot_coalesced_allocno_live_ranges (ira_allocno_t allocno)\n {\n-  int i, n;\n+  int n;\n   ira_allocno_t a;\n   allocno_live_range_t r;\n \n   n = ALLOCNO_TEMP (allocno);\n   for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n-      for (r = ALLOCNO_LIVE_RANGES (a); r != NULL; r = r->next)\n-\tfor (i = r->start; i <= r->finish; i++)\n-\t  bitmap_set_bit (&coalesced_allocnos_living_at_program_points[i], n);\n+      r = ira_copy_allocno_live_range_list (ALLOCNO_LIVE_RANGES (a));\n+      slot_coalesced_allocnos_live_ranges[n]\n+\t= ira_merge_allocno_live_ranges\n+\t  (slot_coalesced_allocnos_live_ranges[n], r);\n       if (a == allocno)\n \tbreak;\n     }\n@@ -2374,14 +2418,15 @@ set_coalesced_allocnos_live_points (ira_allocno_t allocno)\n static bool\n coalesce_spill_slots (ira_allocno_t *spilled_coalesced_allocnos, int num)\n {\n-  int i, j, last_coalesced_allocno_num;\n+  int i, j, n, last_coalesced_allocno_num;\n   ira_allocno_t allocno, a;\n   bool merged_p = false;\n \n-  coalesced_allocnos_living_at_program_points\n-    = (regset_head *) ira_allocate (sizeof (regset_head) * ira_max_point);\n-  for (i = 0; i < ira_max_point; i++)\n-    INIT_REG_SET (&coalesced_allocnos_living_at_program_points[i]);\n+  slot_coalesced_allocnos_live_ranges\n+    = (allocno_live_range_t *) ira_allocate (sizeof (allocno_live_range_t)\n+\t\t\t\t\t     * ira_allocnos_num);\n+  memset (slot_coalesced_allocnos_live_ranges, 0,\n+\t  sizeof (allocno_live_range_t) * ira_allocnos_num);\n   last_coalesced_allocno_num = 0;\n   /* Coalesce non-conflicting spilled allocnos preferring most\n      frequently used.  */\n@@ -2390,26 +2435,26 @@ coalesce_spill_slots (ira_allocno_t *spilled_coalesced_allocnos, int num)\n       allocno = spilled_coalesced_allocnos[i];\n       if (ALLOCNO_FIRST_COALESCED_ALLOCNO (allocno) != allocno\n \t  || (ALLOCNO_REGNO (allocno) < ira_reg_equiv_len\n-\t      && (ira_reg_equiv_invariant_p[ALLOCNO_REGNO (allocno)]\n-\t\t  || ira_reg_equiv_const[ALLOCNO_REGNO (allocno)] != NULL_RTX)))\n+\t      && (ira_reg_equiv_const[ALLOCNO_REGNO (allocno)] != NULL_RTX\n+\t\t  || ira_reg_equiv_invariant_p[ALLOCNO_REGNO (allocno)])))\n \tcontinue;\n       for (j = 0; j < i; j++)\n \t{\n \t  a = spilled_coalesced_allocnos[j];\n+\t  n = ALLOCNO_TEMP (a);\n \t  if (ALLOCNO_FIRST_COALESCED_ALLOCNO (a) == a\n \t      && (ALLOCNO_REGNO (a) >= ira_reg_equiv_len\n \t\t  || (! ira_reg_equiv_invariant_p[ALLOCNO_REGNO (a)]\n \t\t      && ira_reg_equiv_const[ALLOCNO_REGNO (a)] == NULL_RTX))\n-\t      && ! coalesced_allocnos_live_at_points_p (allocno,\n-\t\t\t\t\t\t\tALLOCNO_TEMP (a)))\n+\t      && ! slot_coalesced_allocno_live_ranges_intersect_p (allocno, n))\n \t    break;\n \t}\n       if (j >= i)\n \t{\n \t  /* No coalescing: set up number for coalesced allocnos\n \t     represented by ALLOCNO.  */\n \t  ALLOCNO_TEMP (allocno) = last_coalesced_allocno_num++;\n-\t  set_coalesced_allocnos_live_points (allocno);\n+\t  setup_slot_coalesced_allocno_live_ranges (allocno);\n \t}\n       else\n \t{\n@@ -2421,14 +2466,15 @@ coalesce_spill_slots (ira_allocno_t *spilled_coalesced_allocnos, int num)\n \t\t     ALLOCNO_NUM (allocno), ALLOCNO_REGNO (allocno),\n \t\t     ALLOCNO_NUM (a), ALLOCNO_REGNO (a));\n \t  ALLOCNO_TEMP (allocno) = ALLOCNO_TEMP (a);\n-\t  set_coalesced_allocnos_live_points (allocno);\n+\t  setup_slot_coalesced_allocno_live_ranges (allocno);\n \t  merge_allocnos (a, allocno);\n \t  ira_assert (ALLOCNO_FIRST_COALESCED_ALLOCNO (a) == a);\n \t}\n     }\n-  for (i = 0; i < ira_max_point; i++)\n-    CLEAR_REG_SET (&coalesced_allocnos_living_at_program_points[i]);\n-  ira_free (coalesced_allocnos_living_at_program_points);\n+  for (i = 0; i < ira_allocnos_num; i++)\n+    ira_finish_allocno_live_range_list\n+      (slot_coalesced_allocnos_live_ranges[i]);\n+  ira_free (slot_coalesced_allocnos_live_ranges);\n   return merged_p;\n }\n \n@@ -2499,8 +2545,8 @@ ira_sort_regnos_for_alter_reg (int *pseudo_regnos, int n,\n       if (ALLOCNO_FIRST_COALESCED_ALLOCNO (allocno) != allocno\n \t  || ALLOCNO_HARD_REGNO (allocno) >= 0\n \t  || (ALLOCNO_REGNO (allocno) < ira_reg_equiv_len\n-\t      && (ira_reg_equiv_invariant_p[ALLOCNO_REGNO (allocno)]\n-\t\t  || ira_reg_equiv_const[ALLOCNO_REGNO (allocno)] != NULL_RTX)))\n+\t      && (ira_reg_equiv_const[ALLOCNO_REGNO (allocno)] != NULL_RTX\n+\t\t  || ira_reg_equiv_invariant_p[ALLOCNO_REGNO (allocno)])))\n \tcontinue;\n       if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file, \"      Slot %d (freq,size):\", slot_num);\n@@ -2829,8 +2875,8 @@ ira_reuse_stack_slot (int regno, unsigned int inherent_size,\n \t\t\t\t    FIRST_PSEUDO_REGISTER, i, bi)\n \t    {\n \t      another_allocno = ira_regno_allocno_map[i];\n-\t      if (ira_allocno_live_ranges_intersect_p (allocno,\n-\t\t\t\t\t\t       another_allocno))\n+\t      if (allocnos_have_intersected_live_ranges_p (allocno,\n+\t\t\t\t\t\t\t   another_allocno))\n \t\tgoto cont;\n \t    }\n \t  for (cost = 0, cp = ALLOCNO_COPIES (allocno);\n@@ -2878,7 +2924,7 @@ ira_reuse_stack_slot (int regno, unsigned int inherent_size,\n       EXECUTE_IF_SET_IN_BITMAP (&slot->spilled_regs,\n \t\t\t\tFIRST_PSEUDO_REGISTER, i, bi)\n \t{\n-\t  ira_assert (! ira_pseudo_live_ranges_intersect_p (regno, i));\n+\t  ira_assert (! pseudos_have_intersected_live_ranges_p (regno, i));\n \t}\n       SET_REGNO_REG_SET (&slot->spilled_regs, regno);\n       if (internal_flag_ira_verbose > 3 && ira_dump_file)"}, {"sha": "6e7d7692b678120ca5caaabf5bc339c638033a5e", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=3553f0bb324124195a64ce30c0832463e9082461", "patch": "@@ -532,52 +532,6 @@ propagate_copies (void)\n     }\n }\n \n-/* Return TRUE if live ranges of allocnos A1 and A2 intersect.  It is\n-   used to find a conflict for new allocnos or allocnos with the\n-   different cover classes.  */\n-bool\n-ira_allocno_live_ranges_intersect_p (ira_allocno_t a1, ira_allocno_t a2)\n-{\n-  allocno_live_range_t r1, r2;\n-\n-  if (a1 == a2)\n-    return false;\n-  if (ALLOCNO_REG (a1) != NULL && ALLOCNO_REG (a2) != NULL\n-      && (ORIGINAL_REGNO (ALLOCNO_REG (a1))\n-\t  == ORIGINAL_REGNO (ALLOCNO_REG (a2))))\n-    return false;\n-  /* Remember the ranges are always kept ordered.  */\n-  for (r1 = ALLOCNO_LIVE_RANGES (a1), r2 = ALLOCNO_LIVE_RANGES (a2);\n-       r1 != NULL && r2 != NULL;)\n-    {\n-      if (r1->start > r2->finish)\n-\tr1 = r1->next;\n-      else if (r2->start > r1->finish)\n-\tr2 = r2->next;\n-      else\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n-/* Return TRUE if live ranges of pseudo-registers REGNO1 and REGNO2\n-   intersect.  This should be used when there is only one region.\n-   Currently this is used during reload.  */\n-bool\n-ira_pseudo_live_ranges_intersect_p (int regno1, int regno2)\n-{\n-  ira_allocno_t a1, a2;\n-\n-  ira_assert (regno1 >= FIRST_PSEUDO_REGISTER\n-\t      && regno2 >= FIRST_PSEUDO_REGISTER);\n-  /* Reg info caclulated by dataflow infrastructure can be different\n-     from one calculated by regclass.  */\n-  if ((a1 = ira_loop_tree_root->regno_allocno_map[regno1]) == NULL\n-      || (a2 = ira_loop_tree_root->regno_allocno_map[regno2]) == NULL)\n-    return false;\n-  return ira_allocno_live_ranges_intersect_p (a1, a2);\n-}\n-\n /* Array used to collect all conflict allocnos for given allocno.  */\n static ira_allocno_t *collected_conflict_allocnos;\n "}, {"sha": "7f5479b7b57dcc9b9fd14c780ac38a50943dc014", "filename": "gcc/ira-int.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=3553f0bb324124195a64ce30c0832463e9082461", "patch": "@@ -862,7 +862,14 @@ extern void ira_add_allocno_conflict (ira_allocno_t, ira_allocno_t);\n extern void ira_print_expanded_allocno (ira_allocno_t);\n extern allocno_live_range_t ira_create_allocno_live_range\n \t                    (ira_allocno_t, int, int, allocno_live_range_t);\n+extern allocno_live_range_t ira_copy_allocno_live_range_list\n+                            (allocno_live_range_t);\n+extern allocno_live_range_t ira_merge_allocno_live_ranges\n+                            (allocno_live_range_t, allocno_live_range_t);\n+extern bool ira_allocno_live_ranges_intersect_p (allocno_live_range_t,\n+\t\t\t\t\t\t allocno_live_range_t);\n extern void ira_finish_allocno_live_range (allocno_live_range_t);\n+extern void ira_finish_allocno_live_range_list (allocno_live_range_t);\n extern void ira_free_allocno_updated_costs (ira_allocno_t);\n extern ira_copy_t ira_create_copy (ira_allocno_t, ira_allocno_t,\n \t\t\t\t   int, bool, rtx, ira_loop_tree_node_t);\n@@ -898,8 +905,6 @@ extern void ira_compress_allocno_live_ranges (void);\n extern void ira_finish_allocno_live_ranges (void);\n \n /* ira-conflicts.c */\n-extern bool ira_allocno_live_ranges_intersect_p (ira_allocno_t, ira_allocno_t);\n-extern bool ira_pseudo_live_ranges_intersect_p (int, int);\n extern void ira_debug_conflicts (bool);\n extern void ira_build_conflicts (void);\n "}, {"sha": "d7f4e3d0dabfeb37d9d5a2322b5513e9fdf22f4b", "filename": "gcc/ira.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553f0bb324124195a64ce30c0832463e9082461/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=3553f0bb324124195a64ce30c0832463e9082461", "patch": "@@ -1695,6 +1695,23 @@ expand_reg_info (int old_size)\n     }\n }\n \n+/* Return TRUE if there is too high register pressure in the function.\n+   It is used to decide when stack slot sharing is worth to do.  */\n+static bool\n+too_high_register_pressure_p (void)\n+{\n+  int i;\n+  enum reg_class cover_class;\n+  \n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    {\n+      cover_class = ira_reg_class_cover[i];\n+      if (ira_loop_tree_root->reg_pressure[cover_class] > 10000)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n \f\n \n /* All natural loops.  */\n@@ -1709,6 +1726,7 @@ ira (FILE *f)\n   int max_regno_before_ira, ira_max_point_before_emit;\n   int rebuild_p;\n   int saved_flag_ira_algorithm;\n+  int saved_flag_ira_share_spill_slots;\n   basic_block bb;\n \n   timevar_push (TV_IRA);\n@@ -1792,6 +1810,13 @@ ira (FILE *f)\n   loops_p = ira_build (optimize\n \t\t       && (flag_ira_algorithm == IRA_ALGORITHM_REGIONAL\n \t\t\t   || flag_ira_algorithm == IRA_ALGORITHM_MIXED));\n+\n+  saved_flag_ira_share_spill_slots = flag_ira_share_spill_slots;\n+  if (too_high_register_pressure_p ())\n+    /* It is just wasting compiler's time to pack spilled pseudos into\n+       stack slots in this case -- prohibit it.  */ \n+    flag_ira_share_spill_slots = FALSE;\n+\n   ira_color ();\n       \n   ira_max_point_before_emit = ira_max_point;\n@@ -1902,6 +1927,8 @@ ira (FILE *f)\n     fprintf (ira_dump_file, \"+++Overall after reload %d\\n\", ira_overall_cost);\n   ira_destroy ();\n   \n+  flag_ira_share_spill_slots = saved_flag_ira_share_spill_slots;\n+\n   flow_loops_free (&ira_loops);\n   free_dominance_info (CDI_DOMINATORS);\n   FOR_ALL_BB (bb)"}]}