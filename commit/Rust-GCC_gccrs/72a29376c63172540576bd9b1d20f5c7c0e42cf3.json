{"sha": "72a29376c63172540576bd9b1d20f5c7c0e42cf3", "node_id": "C_kwDOANBUbNoAKDcyYTI5Mzc2YzYzMTcyNTQwNTc2YmQ5YjFkMjBmNWM3YzBlNDJjZjM", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2021-12-09T17:06:20Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-07T16:24:13Z"}, "message": "[Ada] Cleanup and modification of unreferenced warnings\n\ngcc/ada/\n\n\t* comperr.adb (Delete_SCIL_Files): Replace unnecessary\n\tUnreferenced pragma with specific pragma Warnings.\n\t* doc/gnat_rm/implementation_defined_pragmas.rst (Unreferenced):\n\tAdd documentation for new behavior.\n\t* gnat_rm.texi: Regenerate.\n\t* erroutc.adb (Set_At): Remove useless assignment.\n\t* exp_ch2.adb (In_Assignment_Context): Deleted.\n\t(Is_Object_Renaming_Name): Replace calls to Is_LHS with calls to\n\tKnown_To_Be_Assigned.\n\t(Expand_Current_Value): Replace calls to May_Be_Lvalue with\n\tcalls to Known_To_Be_Assigned.\n\t(Expand_Entry_Paramter): Replace calls to In_Assignment_Context\n\twith calls to Known_To_Be_Assigned.\n\t* exp_ch4.adb (Expand_N_Op_Rem): Remove unnecessary Unreferenced\n\tpragma.\n\t* exp_imgv.adb (Build_Enumeration_Image_Tables): Default\n\tinitialize S_N.\n\t* ghost.adb (Check_Ghost_Policy): Replace call to May_Be_Lvalue\n\twith call to Known_To_Be_Assigned.\n\t* lib-xref.adb (Is_On_LHS): Deleted.\n\t(OK_To_Set_Referenced): Rewrite subprogram to encompass the new\n\tpragma Unreferenced behavior.\n\t(Process_Deferred_References): Replace call to Is_LHS with call\n\tto Known_To_Be_Assigned.\n\t* libgnarl/s-taasde.adb, libgnarl/s-tasren.adb,\n\tlibgnarl/s-tpobop.adb, libgnat/a-calend.adb,\n\tlibgnat/a-calfor.adb, libgnat/a-cbdlli.adb,\n\tlibgnat/a-cbhama.adb, libgnat/a-cbhase.adb,\n\tlibgnat/a-cbmutr.adb, libgnat/a-cborma.adb,\n\tlibgnat/a-cborse.adb, libgnat/a-cdlili.adb,\n\tlibgnat/a-cfhama.adb, libgnat/a-cforse.adb,\n\tlibgnat/a-cidlli.adb, libgnat/a-cihama.adb,\n\tlibgnat/a-cihase.adb, libgnat/a-cimutr.adb,\n\tlibgnat/a-ciorma.adb, libgnat/a-ciormu.adb,\n\tlibgnat/a-ciorse.adb, libgnat/a-cohama.adb,\n\tlibgnat/a-cohase.adb, libgnat/a-comutr.adb,\n\tlibgnat/a-convec.adb, libgnat/a-coorma.adb,\n\tlibgnat/a-coormu.adb, libgnat/a-coorse.adb,\n\tlibgnat/a-crdlli.adb, libgnat/a-tigeau.adb,\n\tlibgnat/a-wtgeau.adb, libgnat/a-ztgeau.adb,\n\tlibgnat/g-calend.adb, libgnat/g-comlin.adb,\n\tlibgnat/g-expect.adb, libgnat/g-mbflra.adb,\n\tlibgnat/g-spipat.adb, libgnat/s-fatgen.adb,\n\tlibgnat/s-fileio.adb, libgnat/s-os_lib.adb,\n\tlibgnat/s-regpat.adb, libgnat/s-valued.adb,\n\tlibgnat/s-valuer.adb: Remove unnecessary Unreferenced pragmas\n\t* sem_ch10.adb (Process_Spec_Clauses): Remove useless\n\tassignments.\n\t* sem_ch13.adb (Validate_Literal_Aspect): Default initialize I.\n\t* sem_ch3.adb (Build_Derived_Concurrent_Type): Default\n\tinitialize Corr_Decl.\n\t* sem_ch8.adb (Undefined): Replace calls to Is_LHS with calls to\n\tKnown_To_Be_Assigned.\n\t(In_Abstract_View_Pragma): Likewise.\n\t* sem_eval.adb (Eval_Selected_Component): Replace calls to\n\tIs_LHS with calls to Known_To_Be_Assigned.\n\t* sem_res.adb (Init_Component): Replace calls to May_Be_Lvalue\n\twith calls to Known_To_Be_Assigned.\n\t* sem_util.adb, sem_util.ads (End_Label_Loc): Default initialize\n\tOwner.\n\t(Explain_Limited_Type): Default initialize Expr_Func.\n\t(Find_Actual): Modified to handle entry families.\n\t(Is_LHS): Deleted.\n\t(May_Be_Lvalue): Deleted.\n\t(Known_To_Be_Assigned): Modified and improved to handle all\n\tcases.\n\t* sem_warn.adb (Traverse_Result): Replace calls to May_Be_Lvalue\n\twith calls to Known_To_Be_Assigned.\n\t(Check_Ref): Modify error on unreferenced out parameters to take\n\tinto account different warning flags.", "tree": {"sha": "d89ba0df82e77fdccc8d5236f819bda97624049c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d89ba0df82e77fdccc8d5236f819bda97624049c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72a29376c63172540576bd9b1d20f5c7c0e42cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a29376c63172540576bd9b1d20f5c7c0e42cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a29376c63172540576bd9b1d20f5c7c0e42cf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a29376c63172540576bd9b1d20f5c7c0e42cf3/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2b07ba054daa896795e0932626f259c87417ec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2b07ba054daa896795e0932626f259c87417ec0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2b07ba054daa896795e0932626f259c87417ec0"}], "stats": {"total": 1008, "additions": 255, "deletions": 753}, "files": [{"sha": "be40288b90e6a461af31695823ff20a7c0877c66", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -424,7 +424,7 @@ package body Comperr is\n       Unit_Name : Node_Id;\n \n       Success : Boolean;\n-      pragma Unreferenced (Success);\n+      pragma Warnings (Off, \"modified by call\");\n \n       procedure Decode_Name_Buffer;\n       --  Replace \"__\" by \".\" in Name_Buffer, and adjust Name_Len accordingly"}, {"sha": "fbd60eba12693d99afc8d558655a0057634f2ba1", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -7137,7 +7137,9 @@ or not to be given individually for each accept statement.\n \n The left hand side of an assignment does not count as a reference for the\n purpose of this pragma. Thus it is fine to assign to an entity for which\n-pragma Unreferenced is given.\n+pragma Unreferenced is given. However, use of an entity as an actual for\n+an out parameter does count as a reference unless warnings for unread output\n+parameters are enabled via :switch:`-gnatw.o`.\n \n Note that if a warning is desired for all calls to a given subprogram,\n regardless of whether they occur in the same unit as the subprogram"}, {"sha": "bdb0b13936b36674bc7db6002107a1c755c32e7e", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1226,7 +1226,6 @@ package body Erroutc is\n          else\n             Set_At;\n             Set_Msg_Str (\"line \");\n-            Int_File := False;\n             Set_Msg_Int (Int (Get_Logical_Line_Number (Loc)));\n          end if;\n "}, {"sha": "e687736791d15d39ea64b59807e97ad9926919dc", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -144,7 +144,7 @@ package body Exp_Ch2 is\n \n          --  Do not replace lvalues\n \n-         and then not May_Be_Lvalue (N)\n+         and then not Known_To_Be_Assigned (N)\n \n          --  Check that entity is suitable for replacement\n \n@@ -423,7 +423,7 @@ package body Exp_Ch2 is\n         and then Is_Scalar_Type (Etype (N))\n         and then (Is_Assignable (E) or else Is_Constant_Object (E))\n         and then Comes_From_Source (N)\n-        and then Is_LHS (N) = No\n+        and then not Known_To_Be_Assigned (N)\n         and then not Is_Actual_Out_Parameter (N)\n         and then (Nkind (Parent (N)) /= N_Attribute_Reference\n                    or else Attribute_Name (Parent (N)) /= Name_Valid)\n@@ -541,51 +541,6 @@ package body Exp_Ch2 is\n       Addr_Ent   : constant Entity_Id  := Node (Last_Elmt (Acc_Stack));\n       P_Comp_Ref : Entity_Id;\n \n-      function In_Assignment_Context (N : Node_Id) return Boolean;\n-      --  Check whether this is a context in which the entry formal may be\n-      --  assigned to.\n-\n-      ---------------------------\n-      -- In_Assignment_Context --\n-      ---------------------------\n-\n-      function In_Assignment_Context (N : Node_Id) return Boolean is\n-      begin\n-         --  Case of use in a call\n-\n-         --  ??? passing a formal as actual for a mode IN formal is\n-         --  considered as an assignment?\n-\n-         if Nkind (Parent (N)) in\n-              N_Procedure_Call_Statement | N_Entry_Call_Statement\n-           or else (Nkind (Parent (N)) = N_Assignment_Statement\n-                      and then N = Name (Parent (N)))\n-         then\n-            return True;\n-\n-         --  Case of a parameter association: climb up to enclosing call\n-\n-         elsif Nkind (Parent (N)) = N_Parameter_Association then\n-            return In_Assignment_Context (Parent (N));\n-\n-         --  Case of a selected component, indexed component or slice prefix:\n-         --  climb up the tree, unless the prefix is of an access type (in\n-         --  which case there is an implicit dereference, and the formal itself\n-         --  is not being assigned to).\n-\n-         elsif Nkind (Parent (N)) in\n-                 N_Selected_Component | N_Indexed_Component | N_Slice\n-           and then N = Prefix (Parent (N))\n-           and then not Is_Access_Type (Etype (N))\n-           and then In_Assignment_Context (Parent (N))\n-         then\n-            return True;\n-\n-         else\n-            return False;\n-         end if;\n-      end In_Assignment_Context;\n-\n    --  Start of processing for Expand_Entry_Parameter\n \n    begin\n@@ -604,7 +559,7 @@ package body Exp_Ch2 is\n          --  done during semantic processing so it is called in -gnatc mode???\n \n          if Ekind (Entity (N)) /= E_In_Parameter\n-           and then In_Assignment_Context (N)\n+           and then Known_To_Be_Assigned (N)\n          then\n             Note_Possible_Modification (N, Sure => True);\n          end if;"}, {"sha": "5347238adaec744c55a80c308f5356c3219af2d0", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -10413,8 +10413,6 @@ package body Exp_Ch4 is\n       Rneg : Boolean;\n       --  Set if corresponding operand can be negative\n \n-      pragma Unreferenced (Hi);\n-\n    begin\n       Binary_Op_Validity_Checks (N);\n "}, {"sha": "64b11fb8f1ecbd69c484b3004057dd001464009f", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -90,7 +90,7 @@ package body Exp_Imgv is\n       Lit  : Entity_Id;\n       Nlit : Nat;\n       S_Id : Entity_Id;\n-      S_N  : Nat;\n+      S_N  : Nat := 0;\n       Str  : String_Id;\n \n       package SPHG renames System.Perfect_Hash_Generators;"}, {"sha": "c7d474180e081d26766d6c490038e374bcad3f5a", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -530,7 +530,7 @@ package body Ghost is\n \n          if Is_Checked_Ghost_Entity (Id)\n            and then Policy = Name_Ignore\n-           and then May_Be_Lvalue (Ref)\n+           and then Known_To_Be_Assigned (Ref)\n          then\n             Error_Msg_Sloc := Sloc (Ref);\n "}, {"sha": "687e2e4fb9ee1ce94ce4455db7a5b534bae8ce36", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -8662,7 +8662,9 @@ or not to be given individually for each accept statement.\n \n The left hand side of an assignment does not count as a reference for the\n purpose of this pragma. Thus it is fine to assign to an entity for which\n-pragma Unreferenced is given.\n+pragma Unreferenced is given. However, use of an entity as an actual for\n+an out parameter does count as a reference unless warnings for unread output\n+parameters are enabled via @code{-gnatw.o}.\n \n Note that if a warning is desired for all calls to a given subprogram,\n regardless of whether they occur in the same unit as the subprogram"}, {"sha": "93ea4bbecb3f6a25483f74dfa99bf5c499240212", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 97, "deletions": 180, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -415,22 +415,6 @@ package body Lib.Xref is\n       --  Get the enclosing entity through renamings, which may come from\n       --  source or from the translation of generic instantiations.\n \n-      function Is_On_LHS (Node : Node_Id) return Boolean;\n-      --  Used to check if a node is on the left hand side of an assignment.\n-      --  The following cases are handled:\n-      --\n-      --   Variable    Node is a direct descendant of left hand side of an\n-      --               assignment statement.\n-      --\n-      --   Prefix      Of an indexed or selected component that is present in\n-      --               a subtree rooted by an assignment statement. There is\n-      --               no restriction of nesting of components, thus cases\n-      --               such as A.B (C).D are handled properly. However a prefix\n-      --               of a dereference (either implicit or explicit) is never\n-      --               considered as on a LHS.\n-      --\n-      --   Out param   Same as above cases, but OUT parameter\n-\n       function OK_To_Set_Referenced return Boolean;\n       --  Returns True if the Referenced flag can be set. There are a few\n       --  exceptions where we do not want to set this flag, see body for\n@@ -499,85 +483,6 @@ package body Lib.Xref is\n          end case;\n       end Get_Through_Renamings;\n \n-      ---------------\n-      -- Is_On_LHS --\n-      ---------------\n-\n-      --  ??? There are several routines here and there that perform a similar\n-      --      (but subtly different) computation, which should be factored:\n-\n-      --      Sem_Util.Is_LHS\n-      --      Sem_Util.May_Be_Lvalue\n-      --      Sem_Util.Known_To_Be_Assigned\n-      --      Exp_Ch2.Expand_Entry_Parameter.In_Assignment_Context\n-      --      Exp_Smem.Is_Out_Actual\n-\n-      function Is_On_LHS (Node : Node_Id) return Boolean is\n-         N : Node_Id;\n-         P : Node_Id;\n-         K : Node_Kind;\n-\n-      begin\n-         --  Only identifiers are considered, is this necessary???\n-\n-         if Nkind (Node) /= N_Identifier then\n-            return False;\n-         end if;\n-\n-         --  Immediate return if appeared as OUT parameter\n-\n-         if Kind = E_Out_Parameter then\n-            return True;\n-         end if;\n-\n-         --  Search for assignment statement subtree root\n-\n-         N := Node;\n-         loop\n-            P := Parent (N);\n-            K := Nkind (P);\n-\n-            if K = N_Assignment_Statement then\n-               return Name (P) = N;\n-\n-            --  Check whether the parent is a component and the current node is\n-            --  its prefix, but return False if the current node has an access\n-            --  type, as in that case the selected or indexed component is an\n-            --  implicit dereference, and the LHS is the designated object, not\n-            --  the access object.\n-\n-            --  ??? case of a slice assignment?\n-\n-            elsif (K = N_Selected_Component or else K = N_Indexed_Component)\n-              and then Prefix (P) = N\n-            then\n-               --  Check for access type. First a special test, In some cases\n-               --  this is called too early (see comments in Find_Direct_Name),\n-               --  at a point where the tree is not fully typed yet. In that\n-               --  case we may lack an Etype for N, and we can't check the\n-               --  Etype. For now, we always return False in such a case,\n-               --  but this is clearly not right in all cases ???\n-\n-               if No (Etype (N)) then\n-                  return False;\n-\n-               elsif Is_Access_Type (Etype (N)) then\n-                  return False;\n-\n-               --  Access type case dealt with, keep going\n-\n-               else\n-                  N := P;\n-               end if;\n-\n-            --  All other cases, definitely not on left side\n-\n-            else\n-               return False;\n-            end if;\n-         end loop;\n-      end Is_On_LHS;\n-\n       ---------------------------\n       -- OK_To_Set_Referenced --\n       ---------------------------\n@@ -822,46 +727,32 @@ package body Lib.Xref is\n \n       if Set_Ref then\n \n-         --  Assignable object appearing on left side of assignment or as\n-         --  an out parameter.\n+         --  When E itself is an IN OUT parameter mark it referenced\n \n          if Is_Assignable (E)\n-           and then Is_On_LHS (N)\n-           and then Ekind (E) /= E_In_Out_Parameter\n+           and then Ekind (E) = E_In_Out_Parameter\n+           and then Known_To_Be_Assigned (N)\n          then\n-            --  For objects that are renamings, just set as simply referenced\n-            --  we do not try to do assignment type tracking in this case.\n-\n-            if Present (Renamed_Object (E)) then\n-               Set_Referenced (E);\n-\n-            --  Out parameter case\n-\n-            elsif Kind = E_Out_Parameter then\n-\n-               --  If warning mode for all out parameters is set, or this is\n-               --  the only warning parameter, then we want to mark this for\n-               --  later warning logic by setting Referenced_As_Out_Parameter\n+            Set_Referenced (E);\n \n-               if Warn_On_Modified_As_Out_Parameter (Formal) then\n-                  Set_Referenced_As_Out_Parameter (E, True);\n-                  Set_Referenced_As_LHS (E, False);\n+         --  For the case where the entity is on the left hand side of an\n+         --  assignment statment, we do nothing here.\n \n-               --  For OUT parameter not covered by the above cases, we simply\n-               --  regard it as a normal reference (in this case we do not\n-               --  want any of the warning machinery for out parameters).\n+         --  The processing for Analyze_Assignment_Statement will set the\n+         --  Referenced_As_LHS flag.\n \n-               else\n-                  Set_Referenced (E);\n-               end if;\n+         elsif Is_Assignable (E)\n+           and then Known_To_Be_Assigned (N, Only_LHS => True)\n+         then\n+            null;\n \n-            --  For the left hand of an assignment case, we do nothing here.\n-            --  The processing for Analyze_Assignment will set the\n-            --  Referenced_As_LHS flag.\n+         --  For objects that are renamings, just set as simply referenced.\n+         --  We do not try to do assignment type tracking in this case.\n \n-            else\n-               null;\n-            end if;\n+         elsif Is_Assignable (E)\n+           and then Present (Renamed_Object (E))\n+         then\n+            Set_Referenced (E);\n \n          --  Check for a reference in a pragma that should not count as a\n          --  making the variable referenced for warning purposes.\n@@ -901,58 +792,75 @@ package body Lib.Xref is\n          then\n             null;\n \n-         --  All other cases\n+         --  Out parameter case\n \n-         else\n-            --  Special processing for IN OUT parameters, where we have an\n-            --  implicit assignment to a simple variable.\n+         elsif Kind = E_Out_Parameter\n+           and then Is_Assignable (E)\n+         then\n+            --  If warning mode for all out parameters is set, or this is\n+            --  the only warning parameter, then we want to mark this for\n+            --  later warning logic by setting Referenced_As_Out_Parameter\n \n-            if Kind = E_In_Out_Parameter\n-              and then Is_Assignable (E)\n-            then\n-               --  For sure this counts as a normal read reference\n+            if Warn_On_Modified_As_Out_Parameter (Formal) then\n+               Set_Referenced_As_Out_Parameter (E, True);\n+               Set_Referenced_As_LHS (E, False);\n+\n+            --  For OUT parameter not covered by the above cases, we simply\n+            --  regard it as a non-reference.\n \n+            else\n+               Set_Referenced_As_Out_Parameter (E);\n                Set_Referenced (E);\n-               Set_Last_Assignment (E, Empty);\n+            end if;\n \n-               --  We count it as being referenced as an out parameter if the\n-               --  option is set to warn on all out parameters, except that we\n-               --  have a special exclusion for an intrinsic subprogram, which\n-               --  is most likely an instantiation of Unchecked_Deallocation\n-               --  which we do not want to consider as an assignment since it\n-               --  generates false positives. We also exclude the case of an\n-               --  IN OUT parameter if the name of the procedure is Free,\n-               --  since we suspect similar semantics.\n-\n-               if Warn_On_All_Unread_Out_Parameters\n-                 and then Is_Entity_Name (Name (Call))\n-                 and then not Is_Intrinsic_Subprogram (Entity (Name (Call)))\n-                 and then Chars (Name (Call)) /= Name_Free\n-               then\n-                  Set_Referenced_As_Out_Parameter (E, True);\n-                  Set_Referenced_As_LHS (E, False);\n-               end if;\n+         --  Special processing for IN OUT parameters, where we have an\n+         --  implicit assignment to a simple variable.\n \n-            --  Don't count a recursive reference within a subprogram as a\n-            --  reference (that allows detection of a recursive subprogram\n-            --  whose only references are recursive calls as unreferenced).\n+         elsif Kind = E_In_Out_Parameter\n+           and then Is_Assignable (E)\n+         then\n+            --  For sure this counts as a normal read reference\n \n-            elsif Is_Subprogram (E)\n-              and then E = Nearest_Dynamic_Scope (Current_Scope)\n+            Set_Referenced (E);\n+            Set_Last_Assignment (E, Empty);\n+\n+            --  We count it as being referenced as an out parameter if the\n+            --  option is set to warn on all out parameters, except that we\n+            --  have a special exclusion for an intrinsic subprogram, which\n+            --  is most likely an instantiation of Unchecked_Deallocation\n+            --  which we do not want to consider as an assignment since it\n+            --  generates false positives. We also exclude the case of an\n+            --  IN OUT parameter if the name of the procedure is Free,\n+            --  since we suspect similar semantics.\n+\n+            if Warn_On_All_Unread_Out_Parameters\n+              and then Is_Entity_Name (Name (Call))\n+              and then not Is_Intrinsic_Subprogram (Entity (Name (Call)))\n+              and then Chars (Name (Call)) /= Name_Free\n             then\n-               null;\n+               Set_Referenced_As_Out_Parameter (E, True);\n+               Set_Referenced_As_LHS (E, False);\n+            end if;\n \n-            --  Any other occurrence counts as referencing the entity\n+         --  Don't count a recursive reference within a subprogram as a\n+         --  reference (that allows detection of a recursive subprogram\n+         --  whose only references are recursive calls as unreferenced).\n \n-            elsif OK_To_Set_Referenced then\n-               Set_Referenced (E);\n+         elsif Is_Subprogram (E)\n+           and then E = Nearest_Dynamic_Scope (Current_Scope)\n+         then\n+            null;\n \n-               --  If variable, this is an OK reference after an assignment\n-               --  so we can clear the Last_Assignment indication.\n+         --  Any other occurrence counts as referencing the entity\n \n-               if Is_Assignable (E) then\n-                  Set_Last_Assignment (E, Empty);\n-               end if;\n+         elsif OK_To_Set_Referenced then\n+            Set_Referenced (E);\n+\n+            --  If variable, this is an OK reference after an assignment\n+            --  so we can clear the Last_Assignment indication.\n+\n+            if Is_Assignable (E) then\n+               Set_Last_Assignment (E, Empty);\n             end if;\n          end if;\n \n@@ -965,18 +873,32 @@ package body Lib.Xref is\n            and then In_Same_Extended_Unit (E, N)\n          then\n             --  A reference as a named parameter in a call does not count as a\n-            --  violation of pragma Unreferenced for this purpose...\n+            --  violation of pragma Unreferenced for this purpose.\n \n             if Nkind (N) = N_Identifier\n               and then Nkind (Parent (N)) = N_Parameter_Association\n               and then Selector_Name (Parent (N)) = N\n             then\n                null;\n \n-            --  ... Neither does a reference to a variable on the left side of\n-            --  an assignment.\n-\n-            elsif Is_On_LHS (N) then\n+            --  Neither does a reference to a variable on the left side of\n+            --  an assignment or use of an out parameter with warnings for\n+            --  unread out parameters specified (via -gnatw.o).\n+\n+            --  The reason for treating unread out parameters in a special\n+            --  way is so that when pragma Unreferenced is specified on such\n+            --  an out parameter we do not want to issue a warning about the\n+            --  pragma being unnecessary - because the purpose of the flag\n+            --  is to warn about them not being read (e.g. unreferenced)\n+            --  after use.\n+\n+            elsif (Known_To_Be_Assigned (N, Only_LHS => True)\n+                    or else (Present (Formal)\n+                              and then Ekind (Formal) = E_Out_Parameter\n+                              and then Warn_On_All_Unread_Out_Parameters))\n+              and then not (Ekind (E) = E_In_Out_Parameter\n+                             and then Known_To_Be_Assigned (N))\n+            then\n                null;\n \n             --  Do not consider F'Result as a violation of pragma Unreferenced\n@@ -2841,18 +2763,13 @@ package body Lib.Xref is\n             D : Deferred_Reference_Entry renames Deferred_References.Table (J);\n \n          begin\n-            case Is_LHS (D.N) is\n-               when Yes =>\n+            case Known_To_Be_Assigned (D.N) is\n+               when True =>\n                   Generate_Reference (D.E, D.N, 'm');\n \n-               when No =>\n+               when False =>\n                   Generate_Reference (D.E, D.N, 'r');\n \n-               --  Not clear if Unknown can occur at this stage, but if it\n-               --  does we will treat it as a normal reference.\n-\n-               when Unknown =>\n-                  Generate_Reference (D.E, D.N, 'r');\n             end case;\n          end;\n       end loop;"}, {"sha": "cf04b063d24bf715489105320382cb38220b0306", "filename": "gcc/ada/libgnarl/s-taasde.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnarl%2Fs-taasde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnarl%2Fs-taasde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taasde.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -264,8 +264,6 @@ package body System.Tasking.Async_Delays is\n       Dequeued         : Delay_Block_Access;\n       Dequeued_Task    : Task_Id;\n \n-      pragma Unreferenced (Timedout, Yielded);\n-\n    begin\n       pragma Assert (Timer_Server_ID = STPO.Self);\n "}, {"sha": "3a3739a6e9dc62c862d1a29686776a41afc99d90", "filename": "gcc/ada/libgnarl/s-tasren.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnarl%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnarl%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tasren.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -305,7 +305,6 @@ package body System.Tasking.Rendezvous is\n       Uninterpreted_Data : System.Address)\n    is\n       Rendezvous_Successful : Boolean;\n-      pragma Unreferenced (Rendezvous_Successful);\n \n    begin\n       --  If pragma Detect_Blocking is active then Program_Error must be\n@@ -1438,7 +1437,6 @@ package body System.Tasking.Rendezvous is\n       Entry_Call : Entry_Call_Link;\n \n       Yielded : Boolean;\n-      pragma Unreferenced (Yielded);\n \n    begin\n       --  If pragma Detect_Blocking is active then Program_Error must be"}, {"sha": "7be4c9f60175cf2c26601a098770afb5f0271ef6", "filename": "gcc/ada/libgnarl/s-tpobop.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpobop.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -857,7 +857,6 @@ package body System.Tasking.Protected_Objects.Operations is\n       Ceiling_Violation : Boolean;\n \n       Yielded : Boolean;\n-      pragma Unreferenced (Yielded);\n \n    begin\n       if Self_Id.ATC_Nesting_Level = ATC_Level'Last then"}, {"sha": "f7d839513af6ff6e7c5bcec58b27f861ca7d105f", "filename": "gcc/ada/libgnat/a-calend.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-calend.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -490,7 +490,6 @@ is\n       Y : Year_Number;\n       M : Month_Number;\n       S : Day_Duration;\n-      pragma Unreferenced (Y, M, S);\n    begin\n       Split (Date, Y, M, D, S);\n       return D;\n@@ -537,7 +536,6 @@ is\n       M : Month_Number;\n       D : Day_Number;\n       S : Day_Duration;\n-      pragma Unreferenced (Y, D, S);\n    begin\n       Split (Date, Y, M, D, S);\n       return M;\n@@ -552,7 +550,6 @@ is\n       M : Month_Number;\n       D : Day_Number;\n       S : Day_Duration;\n-      pragma Unreferenced (Y, M, D);\n    begin\n       Split (Date, Y, M, D, S);\n       return S;\n@@ -575,8 +572,6 @@ is\n       Ss : Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (H, M, Se, Ss, Le);\n-\n    begin\n       --  Even though the input time zone is UTC (0), the flag Use_TZ will\n       --  ensure that Split picks up the local time zone.\n@@ -769,7 +764,6 @@ is\n       M : Month_Number;\n       D : Day_Number;\n       S : Day_Duration;\n-      pragma Unreferenced (M, D, S);\n    begin\n       Split (Date, Y, M, D, S);\n       return Y;"}, {"sha": "82b6ef48a6f7ef11fc733c4601f40e8120ff8099", "filename": "gcc/ada/libgnat/a-calfor.adb", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-calfor.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-calfor.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-calfor.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -99,8 +99,6 @@ package body Ada.Calendar.Formatting is\n       Ss : Second_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Y, Mo, H, Mi);\n-\n    begin\n       Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n       return D;\n@@ -132,8 +130,6 @@ package body Ada.Calendar.Formatting is\n       Ss : Second_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Y, Mo, D, Mi);\n-\n    begin\n       Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n       return H;\n@@ -290,8 +286,6 @@ package body Ada.Calendar.Formatting is\n       Ss : Second_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Y, Mo, D, H);\n-\n    begin\n       Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n       return Mi;\n@@ -314,8 +308,6 @@ package body Ada.Calendar.Formatting is\n       Ss : Second_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Y, D, H, Mi);\n-\n    begin\n       Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n       return Mo;\n@@ -335,8 +327,6 @@ package body Ada.Calendar.Formatting is\n       Ss : Second_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Y, Mo, D, H, Mi);\n-\n    begin\n       Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le);\n       return Se;\n@@ -583,8 +573,6 @@ package body Ada.Calendar.Formatting is\n       Ss : Second_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Y, Mo, D, H, Mi);\n-\n    begin\n       Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le);\n       return Ss;\n@@ -897,8 +885,6 @@ package body Ada.Calendar.Formatting is\n       Ss : Second_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Mo, D, H, Mi);\n-\n    begin\n       Split (Date, Y, Mo, D, H, Mi, Se, Ss, Le, Time_Zone);\n       return Y;"}, {"sha": "4939b4d8819e9d333e13d001f2770b965808ebd4", "filename": "gcc/ada/libgnat/a-cbdlli.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -995,7 +995,6 @@ is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;"}, {"sha": "c4a9cc2b1f5ce367eff638d40db84c36302a17b9", "filename": "gcc/ada/libgnat/a-cbhama.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbhama.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -697,8 +697,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "bc0a1ca586ff121098806d75e6b9d441f6f45bfb", "filename": "gcc/ada/libgnat/a-cbhase.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbhase.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -736,8 +736,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "8b8ffc37e0cc53cbcf675441e85afd1ad65cd7b9", "filename": "gcc/ada/libgnat/a-cbmutr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbmutr.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1490,7 +1490,6 @@ is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n \n    begin\n       Insert_Child (Container, Parent, Before, New_Item, Position, Count);"}, {"sha": "74e1d4dc6dea3974add6c025bf7db04fee04f3a3", "filename": "gcc/ada/libgnat/a-cborma.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cborma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cborma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cborma.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -824,8 +824,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "fd1e0feffbce6435d52c1a5262f6d6d091e822bb", "filename": "gcc/ada/libgnat/a-cborse.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cborse.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1099,8 +1099,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin\n@@ -1180,7 +1178,6 @@ is\n       Dst_Node : out Count_Type)\n    is\n       Success : Boolean;\n-      pragma Unreferenced (Success);\n \n       procedure Set_Element (Node : in out Node_Type);\n       pragma Inline (Set_Element);\n@@ -1987,6 +1984,7 @@ is\n    function To_Set (New_Item : Element_Type) return Set is\n       Node     : Count_Type;\n       Inserted : Boolean;\n+\n    begin\n       return S : Set (1) do\n          Insert_Sans_Hint (S, New_Item, Node, Inserted);"}, {"sha": "7d8dbed5999283847ddf30feae2a9f3c9b15d27a", "filename": "gcc/ada/libgnat/a-cdlili.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -810,7 +810,6 @@ is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;"}, {"sha": "b897b41d652d66dfa1bcc6ddb2f6a2e53ad48576", "filename": "gcc/ada/libgnat/a-cfhama.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -670,8 +670,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "df2b7af3503c0d8d69b66d19e11ce4fecaae6856", "filename": "gcc/ada/libgnat/a-cforse.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforse.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1420,7 +1420,6 @@ is\n       Dst_Node : out Count_Type)\n    is\n       Success : Boolean;\n-      pragma Unreferenced (Success);\n \n       procedure Set_Element (Node : in out Node_Type);\n \n@@ -1900,6 +1899,7 @@ is\n    function To_Set (New_Item : Element_Type) return Set is\n       Node     : Count_Type;\n       Inserted : Boolean;\n+\n    begin\n       return S : Set (Capacity => 1) do\n          Insert_Sans_Hint (S.Content, New_Item, Node, Inserted);"}, {"sha": "b55e5bbaef41b781194ac842a3a1ce99b4f316a0", "filename": "gcc/ada/libgnat/a-cidlli.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -902,7 +902,6 @@ is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;"}, {"sha": "7217b5d7600aa13813b8047c7db5839ecba1a114", "filename": "gcc/ada/libgnat/a-cihama.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cihama.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -758,8 +758,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "804aa31b758b087f2fcf0e50c7178540d439b5a0", "filename": "gcc/ada/libgnat/a-cihase.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cihase.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -854,8 +854,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin\n@@ -1728,7 +1726,6 @@ is\n       HT       : Hash_Table_Type;\n       Node     : Node_Access;\n       Inserted : Boolean;\n-      pragma Unreferenced (Node, Inserted);\n    begin\n       Insert (HT, New_Item, Node, Inserted);\n       return Set'(Controlled with HT);\n@@ -1776,7 +1773,6 @@ is\n \n          Tgt_Node : Node_Access;\n          Success  : Boolean;\n-         pragma Unreferenced (Tgt_Node, Success);\n \n       --  Start of processing for Process\n "}, {"sha": "a04db9c4e2d6fba9113078c41e1c35d24d62a4a4", "filename": "gcc/ada/libgnat/a-cimutr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cimutr.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1175,7 +1175,6 @@ is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n \n    begin\n       Insert_Child (Container, Parent, Before, New_Item, Position, Count);"}, {"sha": "03da5eb6524450f809c67de09ef4bc4fb628bdd4", "filename": "gcc/ada/libgnat/a-ciorma.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ciorma.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -866,8 +866,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "32926370959ccecfaa616d3acde69abb2e951985", "filename": "gcc/ada/libgnat/a-ciormu.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ciormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ciormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ciormu.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1120,7 +1120,6 @@ is\n \n    procedure Insert (Container : in out Set; New_Item : Element_Type) is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n    begin\n       Insert (Container, New_Item, Position);\n    end Insert;\n@@ -1975,7 +1974,6 @@ is\n    function To_Set (New_Item : Element_Type) return Set is\n       Tree : Tree_Type;\n       Node : Node_Access;\n-      pragma Unreferenced (Node);\n    begin\n       Insert_Sans_Hint (Tree, New_Item, Node);\n       return Set'(Controlled with Tree);"}, {"sha": "4f129c57d293e62c6e49722e45a1331093b560a0", "filename": "gcc/ada/libgnat/a-ciorse.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ciorse.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1160,8 +1160,6 @@ is\n \n    procedure Insert (Container : in out Set; New_Item  : Element_Type) is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin\n@@ -1239,7 +1237,6 @@ is\n       Dst_Node : out Node_Access)\n    is\n       Success : Boolean;\n-      pragma Unreferenced (Success);\n \n       function New_Node return Node_Access;\n \n@@ -2120,7 +2117,6 @@ is\n       Tree     : Tree_Type;\n       Node     : Node_Access;\n       Inserted : Boolean;\n-      pragma Unreferenced (Node, Inserted);\n    begin\n       Insert_Sans_Hint (Tree, New_Item, Node, Inserted);\n       return Set'(Controlled with Tree);"}, {"sha": "973b91dc22a5e69c7f8bcb0b322f128196b8c0ec", "filename": "gcc/ada/libgnat/a-cohama.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cohama.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -698,8 +698,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "3fe5b53ba2a048d6f9ac3c8ed8535f8dc964a92e", "filename": "gcc/ada/libgnat/a-cohase.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cohase.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -785,8 +785,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin\n@@ -1562,7 +1560,6 @@ is\n \n       Node     : Node_Access;\n       Inserted : Boolean;\n-      pragma Unreferenced (Node, Inserted);\n \n    begin\n       Insert (HT, New_Item, Node, Inserted);\n@@ -1606,7 +1603,6 @@ is\n \n          Tgt_Node : Node_Access;\n          Success  : Boolean;\n-         pragma Unreferenced (Tgt_Node, Success);\n \n       --  Start of processing for Process\n "}, {"sha": "a592b8f75256c30a8bbe7f2e0ffe86d33ddfd9de", "filename": "gcc/ada/libgnat/a-comutr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-comutr.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1130,7 +1130,6 @@ is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n \n    begin\n       Insert_Child (Container, Parent, Before, New_Item, Position, Count);"}, {"sha": "e6d6a1952a6b1ad8b0b5b1a45bfb0769706717f1", "filename": "gcc/ada/libgnat/a-convec.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-convec.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1264,6 +1264,7 @@ is\n       declare\n          SA : Elements_Array renames Container.Elements.EA; -- source\n          DA : Elements_Array renames Dst.EA;                -- destination\n+         pragma Unreferenced (DA);\n \n       begin\n          DA (Index_Type'First .. Before - 1) :=\n@@ -1918,6 +1919,7 @@ is\n       declare\n          SA : Elements_Array renames Container.Elements.EA;  -- source\n          DA : Elements_Array renames Dst.EA;                 -- destination\n+         pragma Unreferenced (DA);\n \n       begin\n          DA (Index_Type'First .. Before - 1) :="}, {"sha": "d575ddb9828d16b7ea110df93867294a8217682f", "filename": "gcc/ada/libgnat/a-coorma.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coorma.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -752,8 +752,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin"}, {"sha": "e34e90864ba3295e388bda8897502dd26ec48137", "filename": "gcc/ada/libgnat/a-coormu.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-coormu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-coormu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coormu.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1053,7 +1053,6 @@ is\n \n    procedure Insert (Container : in out Set; New_Item : Element_Type) is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n    begin\n       Insert (Container, New_Item, Position);\n    end Insert;\n@@ -1858,7 +1857,6 @@ is\n    function To_Set (New_Item : Element_Type) return Set is\n       Tree : Tree_Type;\n       Node : Node_Access;\n-      pragma Unreferenced (Node);\n    begin\n       Insert_Sans_Hint (Tree, New_Item, Node);\n       return Set'(Controlled with Tree);"}, {"sha": "83f3885d42f734aebbfdf4dce05724596321cc74", "filename": "gcc/ada/libgnat/a-coorse.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coorse.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1057,8 +1057,6 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n-\n       Inserted : Boolean;\n \n    begin\n@@ -1123,7 +1121,6 @@ is\n       Dst_Node : out Node_Access)\n    is\n       Success : Boolean;\n-      pragma Unreferenced (Success);\n \n       function New_Node return Node_Access;\n       pragma Inline (New_Node);\n@@ -1935,7 +1932,6 @@ is\n       Tree     : Tree_Type;\n       Node     : Node_Access;\n       Inserted : Boolean;\n-      pragma Unreferenced (Node, Inserted);\n    begin\n       Insert_Sans_Hint (Tree, New_Item, Node, Inserted);\n       return Set'(Controlled with Tree);"}, {"sha": "c0ff2da8a54d733ca548b47011e74eeb546f35ff", "filename": "gcc/ada/libgnat/a-crdlli.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-crdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-crdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-crdlli.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -630,7 +630,6 @@ package body Ada.Containers.Restricted_Doubly_Linked_Lists is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-      pragma Unreferenced (Position);\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;"}, {"sha": "263b6025b329a7c54cbe5d31c9a1ffc6ef843d3b", "filename": "gcc/ada/libgnat/a-tigeau.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-tigeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-tigeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tigeau.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -317,7 +317,6 @@ package body Ada.Text_IO.Generic_Aux is\n       Ptr    : in out Integer)\n    is\n       Junk : Boolean;\n-      pragma Unreferenced (Junk);\n    begin\n       Load_Extended_Digits (File, Buf, Ptr, Junk);\n    end Load_Extended_Digits;"}, {"sha": "39b8776b64cd0642ed42c10a992c734c21ad37c0", "filename": "gcc/ada/libgnat/a-wtgeau.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-wtgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-wtgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtgeau.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -343,7 +343,6 @@ package body Ada.Wide_Text_IO.Generic_Aux is\n       Ptr    : in out Integer)\n    is\n       Junk : Boolean;\n-      pragma Unreferenced (Junk);\n    begin\n       Load_Extended_Digits (File, Buf, Ptr, Junk);\n    end Load_Extended_Digits;"}, {"sha": "0659d2559232f001eb2f246a25563ba3b72624d5", "filename": "gcc/ada/libgnat/a-ztgeau.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ztgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fa-ztgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztgeau.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -343,7 +343,6 @@ package body Ada.Wide_Wide_Text_IO.Generic_Aux is\n       Ptr    : in out Integer)\n    is\n       Junk : Boolean;\n-      pragma Unreferenced (Junk);\n    begin\n       Load_Extended_Digits (File, Buf, Ptr, Junk);\n    end Load_Extended_Digits;"}, {"sha": "f073f1ed949e7a89a5242807f61c55aaf69d72c8", "filename": "gcc/ada/libgnat/g-calend.adb", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-calend.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -44,7 +44,6 @@ package body GNAT.Calendar is\n       Month    : Month_Number;\n       Day      : Day_Number;\n       Day_Secs : Day_Duration;\n-      pragma Unreferenced (Day_Secs);\n    begin\n       Split (Date, Year, Month, Day, Day_Secs);\n       return Julian_Day (Year, Month, Day) - Julian_Day (Year, 1, 1) + 1;\n@@ -59,7 +58,6 @@ package body GNAT.Calendar is\n       Month    : Month_Number;\n       Day      : Day_Number;\n       Day_Secs : Day_Duration;\n-      pragma Unreferenced (Day_Secs);\n    begin\n       Split (Date, Year, Month, Day, Day_Secs);\n       return Day_Name'Val ((Julian_Day (Year, Month, Day)) mod 7);\n@@ -77,7 +75,6 @@ package body GNAT.Calendar is\n       Minute     : Minute_Number;\n       Second     : Second_Number;\n       Sub_Second : Second_Duration;\n-      pragma Unreferenced (Year, Month, Day, Minute, Second, Sub_Second);\n    begin\n       Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n       return Hour;\n@@ -137,7 +134,6 @@ package body GNAT.Calendar is\n       Minute     : Minute_Number;\n       Second     : Second_Number;\n       Sub_Second : Second_Duration;\n-      pragma Unreferenced (Year, Month, Day, Hour, Second, Sub_Second);\n    begin\n       Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n       return Minute;\n@@ -155,7 +151,6 @@ package body GNAT.Calendar is\n       Minute     : Minute_Number;\n       Second     : Second_Number;\n       Sub_Second : Second_Duration;\n-      pragma Unreferenced (Year, Month, Day, Hour, Minute, Sub_Second);\n    begin\n       Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n       return Second;\n@@ -222,8 +217,6 @@ package body GNAT.Calendar is\n       Ds : Day_Duration;\n       Le : Boolean;\n \n-      pragma Unreferenced (Ds, Le);\n-\n    begin\n       --  Even though the input time zone is UTC (0), the flag Use_TZ will\n       --  ensure that Split picks up the local time zone. ???But Use_TZ is\n@@ -257,7 +250,6 @@ package body GNAT.Calendar is\n       Minute     : Minute_Number;\n       Second     : Second_Number;\n       Sub_Second : Second_Duration;\n-      pragma Unreferenced (Year, Month, Day, Hour, Minute, Second);\n    begin\n       Split (Date, Year, Month, Day, Hour, Minute, Second, Sub_Second);\n       return Sub_Second;\n@@ -398,7 +390,6 @@ package body GNAT.Calendar is\n    function Week_In_Year (Date : Time) return Week_In_Year_Number is\n       Year : Year_Number;\n       Week : Week_In_Year_Number;\n-      pragma Unreferenced (Year);\n    begin\n       Year_Week_In_Year (Date, Year, Week);\n       return Week;\n@@ -423,8 +414,6 @@ package body GNAT.Calendar is\n       Shift      : Week_In_Year_Number;\n       Start_Week : Week_In_Year_Number;\n \n-      pragma Unreferenced (Hour, Minute, Second, Sub_Second);\n-\n       function Is_Leap (Year : Year_Number) return Boolean;\n       --  Return True if Year denotes a leap year. Leap centennial years are\n       --  properly handled."}, {"sha": "09a765db4be232eece6c591826240f02b15cfa63", "filename": "gcc/ada/libgnat/g-comlin.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-comlin.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -2235,7 +2235,6 @@ package body GNAT.Command_Line is\n       Add_Before : Boolean   := False)\n    is\n       Success : Boolean;\n-      pragma Unreferenced (Success);\n    begin\n       Add_Switch (Cmd, Switch, Parameter, Separator,\n                   Section, Add_Before, Success);\n@@ -2453,7 +2452,6 @@ package body GNAT.Command_Line is\n       Section       : String := \"\")\n    is\n       Success : Boolean;\n-      pragma Unreferenced (Success);\n    begin\n       Remove_Switch (Cmd, Switch, Remove_All, Has_Parameter, Section, Success);\n    end Remove_Switch;"}, {"sha": "de045acaeda5ee7be6c8f3f7412b02d6fa4ab8b3", "filename": "gcc/ada/libgnat/g-expect.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-expect.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -264,7 +264,6 @@ package body GNAT.Expect is\n \n    procedure Close (Descriptor : in out Process_Descriptor) is\n       Status : Integer;\n-      pragma Unreferenced (Status);\n    begin\n       Close (Descriptor, Status);\n    end Close;\n@@ -976,7 +975,6 @@ package body GNAT.Expect is\n \n       declare\n          Result : Expect_Match;\n-         pragma Unreferenced (Result);\n \n       begin\n          --  This loop runs until the call to Expect raises Process_Died\n@@ -1439,7 +1437,7 @@ package body GNAT.Expect is\n       Pipe3      : not null access Pipe_Type)\n    is\n       Status : Boolean;\n-      pragma Unreferenced (Status);\n+      pragma Warnings (Off, \"modified by call, but value overwritten\");\n \n    begin\n       --  Create the pipes"}, {"sha": "174e44cd60087d8681cab624223662de7f0597c0", "filename": "gcc/ada/libgnat/g-mbflra.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-mbflra.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-mbflra.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-mbflra.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -118,7 +118,6 @@ package body GNAT.MBBS_Float_Random is\n \n    function Euclid (P, Q : Int) return Int is\n       X, Y, GCD : Int;\n-      pragma Unreferenced (Y, GCD);\n    begin\n       Euclid (P, Q, X, Y, GCD);\n       return X;"}, {"sha": "845a77d4afbf780fbf06823f67155d45bb7a35a2", "filename": "gcc/ada/libgnat/g-spipat.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-spipat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fg-spipat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-spipat.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -2836,7 +2836,6 @@ package body GNAT.Spitbol.Patterns is\n       L     : Natural;\n       Start : Natural;\n       Stop  : Natural;\n-      pragma Unreferenced (Stop);\n \n    begin\n       Get_String (Subject, S, L);\n@@ -2855,7 +2854,6 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : Pattern) return Boolean\n    is\n       Start, Stop : Natural;\n-      pragma Unreferenced (Stop);\n \n       subtype String1 is String (1 .. Subject'Length);\n \n@@ -2935,7 +2933,6 @@ package body GNAT.Spitbol.Patterns is\n \n       Start : Natural;\n       Stop  : Natural;\n-      pragma Unreferenced (Start, Stop);\n \n    begin\n       Get_String (Subject, S, L);\n@@ -2952,7 +2949,6 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : Pattern)\n    is\n       Start, Stop : Natural;\n-      pragma Unreferenced (Start, Stop);\n \n       subtype String1 is String (1 .. Subject'Length);\n \n@@ -3135,7 +3131,6 @@ package body GNAT.Spitbol.Patterns is\n \n       Start : Natural;\n       Stop  : Natural;\n-      pragma Unreferenced (Start, Stop);\n \n    begin\n       Get_String (Subject, S, L);\n@@ -3152,7 +3147,6 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : PString)\n    is\n       Start, Stop : Natural;\n-      pragma Unreferenced (Start, Stop);\n \n       subtype String1 is String (1 .. Subject'Length);\n "}, {"sha": "77a1a98f81a8630515a9b5759bd514ade3c310ae", "filename": "gcc/ada/libgnat/s-fatgen.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -194,7 +194,6 @@ package body System.Fat_Gen is\n    function Compose (Fraction : T; Exponent : UI) return T is\n       Arg_Frac : T;\n       Arg_Exp  : UI;\n-      pragma Unreferenced (Arg_Exp);\n    begin\n       Decompose (Fraction, Arg_Frac, Arg_Exp);\n       return Scaling (Arg_Frac, Exponent);\n@@ -285,7 +284,6 @@ package body System.Fat_Gen is\n    function Exponent (X : T) return UI is\n       X_Frac : T;\n       X_Exp  : UI;\n-      pragma Unreferenced (X_Frac);\n    begin\n       Decompose (X, X_Frac, X_Exp);\n       return X_Exp;\n@@ -487,7 +485,6 @@ package body System.Fat_Gen is\n    function Fraction (X : T) return T is\n       X_Frac : T;\n       X_Exp  : UI;\n-      pragma Unreferenced (X_Exp);\n    begin\n       Decompose (X, X_Frac, X_Exp);\n       return X_Frac;\n@@ -624,7 +621,6 @@ package body System.Fat_Gen is\n       P_Even   : Boolean;\n \n       Arg_Frac : T;\n-      pragma Unreferenced (Arg_Frac);\n \n    begin\n       if Y = 0.0 then"}, {"sha": "0a7ed3aed18d1eebb1842c3ac94dc4282f0440c9", "filename": "gcc/ada/libgnat/s-fileio.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fileio.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -576,7 +576,6 @@ package body System.File_IO is\n       Default : Boolean) return Boolean\n    is\n       V1, V2 : Natural;\n-      pragma Unreferenced (V2);\n \n    begin\n       Form_Parameter (Form, Keyword, V1, V2);"}, {"sha": "043f530af7b463cab39b4e46a24db4b02bc248c6", "filename": "gcc/ada/libgnat/s-os_lib.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1211,7 +1211,6 @@ package body System.OS_Lib is\n       H  : Hour_Type;\n       Mn : Minute_Type;\n       S  : Second_Type;\n-      pragma Unreferenced (Y, Mo, H, Mn, S);\n \n    begin\n       GM_Split (Date, Y, Mo, D, H, Mn, S);\n@@ -1230,7 +1229,6 @@ package body System.OS_Lib is\n       D  : Day_Type;\n       Mn : Minute_Type;\n       S  : Second_Type;\n-      pragma Unreferenced (Y, Mo, D, Mn, S);\n \n    begin\n       GM_Split (Date, Y, Mo, D, H, Mn, S);\n@@ -1249,7 +1247,6 @@ package body System.OS_Lib is\n       D  : Day_Type;\n       H  : Hour_Type;\n       S  : Second_Type;\n-      pragma Unreferenced (Y, Mo, D, H, S);\n \n    begin\n       GM_Split (Date, Y, Mo, D, H, Mn, S);\n@@ -1268,7 +1265,6 @@ package body System.OS_Lib is\n       H  : Hour_Type;\n       Mn : Minute_Type;\n       S  : Second_Type;\n-      pragma Unreferenced (Y, D, H, Mn, S);\n \n    begin\n       GM_Split (Date, Y, Mo, D, H, Mn, S);\n@@ -1287,7 +1283,6 @@ package body System.OS_Lib is\n       D  : Day_Type;\n       H  : Hour_Type;\n       Mn : Minute_Type;\n-      pragma Unreferenced (Y, Mo, D, H, Mn);\n \n    begin\n       GM_Split (Date, Y, Mo, D, H, Mn, S);\n@@ -1425,7 +1420,6 @@ package body System.OS_Lib is\n       H  : Hour_Type;\n       Mn : Minute_Type;\n       S  : Second_Type;\n-      pragma Unreferenced (Mo, D, H, Mn, S);\n \n    begin\n       GM_Split (Date, Y, Mo, D, H, Mn, S);"}, {"sha": "f1c0f87d64c5e348500efc7be7f74bd19e8049b1", "filename": "gcc/ada/libgnat/s-regpat.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-regpat.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -1974,7 +1974,6 @@ package body System.Regpat is\n       Result : Pointer;\n \n       Expr_Flags : Expression_Flags;\n-      pragma Unreferenced (Expr_Flags);\n \n    --  Start of processing for Compile\n \n@@ -3582,7 +3581,6 @@ package body System.Regpat is\n    is\n       PM            : Pattern_Matcher (Size);\n       Finalize_Size : Program_Size;\n-      pragma Unreferenced (Finalize_Size);\n    begin\n       if Size = 0 then\n          Match (Compile (Expression), Data, Matches, Data_First, Data_Last);\n@@ -3605,7 +3603,6 @@ package body System.Regpat is\n    is\n       PM         : Pattern_Matcher (Size);\n       Final_Size : Program_Size;\n-      pragma Unreferenced (Final_Size);\n    begin\n       if Size = 0 then\n          return Match (Compile (Expression), Data, Data_First, Data_Last);\n@@ -3629,7 +3626,6 @@ package body System.Regpat is\n       Matches    : Match_Array (0 .. 0);\n       PM         : Pattern_Matcher (Size);\n       Final_Size : Program_Size;\n-      pragma Unreferenced (Final_Size);\n    begin\n       if Size = 0 then\n          Match (Compile (Expression), Data, Matches, Data_First, Data_Last);"}, {"sha": "4931e13d94039e16233285f6653072c6617dba34", "filename": "gcc/ada/libgnat/s-valued.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valued.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -232,7 +232,6 @@ package body System.Value_D is\n       Base   : Unsigned;\n       ScaleB : Integer;\n       Extra  : Unsigned;\n-      pragma Unreferenced (Extra);\n       Minus  : Boolean;\n       Val    : Uns;\n \n@@ -250,7 +249,6 @@ package body System.Value_D is\n       Base   : Unsigned;\n       ScaleB : Integer;\n       Extra  : Unsigned;\n-      pragma Unreferenced (Extra);\n       Minus  : Boolean;\n       Val    : Uns;\n "}, {"sha": "8b95ba24f69b3f59f02c1b150697711e140a6bff", "filename": "gcc/ada/libgnat/s-valuer.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuer.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -506,7 +506,6 @@ package body System.Value_R is\n       --  Local copy of string pointer\n \n       Start : Positive;\n-      pragma Unreferenced (Start);\n \n       Value : Uns;\n       --  Mantissa as an Integer"}, {"sha": "24d897dd7f81f0975b203a32c93fe69f97fa2c5b", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -579,11 +579,6 @@ package body Sem_Ch10 is\n                         Error_Msg_N -- CODEFIX\n                           (\"redundant with clause in body?r?\", Clause);\n                      end if;\n-\n-                     Used_In_Body      := False;\n-                     Used_In_Spec      := False;\n-                     Used_Type_Or_Elab := False;\n-                     Withed_In_Spec    := False;\n                   end;\n \n                --  Standalone package spec or body check"}, {"sha": "dae76b476e8735769c3e9f4cabcaa080110cb5b8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -17131,7 +17131,7 @@ package body Sem_Ch13 is\n       Func_Name   : constant Node_Id := Expression (ASN);\n       Overloaded  : Boolean := Is_Overloaded (Func_Name);\n \n-      I            : Interp_Index;\n+      I            : Interp_Index := 0;\n       It           : Interp;\n       Param_Type   : Entity_Id;\n       Match_Found  : Boolean := False;"}, {"sha": "19da3330c5ee83ffd33b4b80bcc61c8f50660579", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -7059,7 +7059,7 @@ package body Sem_Ch3 is\n       Indic : constant Node_Id    := Subtype_Indication (Def);\n \n       Corr_Record      : constant Entity_Id := Make_Temporary (Loc, 'C');\n-      Corr_Decl        : Node_Id;\n+      Corr_Decl        : Node_Id := Empty;\n       Corr_Decl_Needed : Boolean;\n       --  If the derived type has fewer discriminants than its parent, the\n       --  corresponding record is also a derived type, in order to account for"}, {"sha": "d204e31bed2b33a5690c6d46437f00655a2eb00b", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -6432,17 +6432,13 @@ package body Sem_Ch8 is\n                   --  Else see if we have a left hand side\n \n                   else\n-                     case Is_LHS (N) is\n-                        when Yes =>\n+                     case Known_To_Be_Assigned (N, Only_LHS => True) is\n+                        when True =>\n                            Generate_Reference (E, N, 'm');\n \n-                        when No =>\n+                        when False =>\n                            Generate_Reference (E, N, 'r');\n \n-                        --  If we don't know now, generate reference later\n-\n-                        when Unknown =>\n-                           Defer_Reference ((E, N));\n                      end case;\n                   end if;\n                end if;\n@@ -6493,7 +6489,7 @@ package body Sem_Ch8 is\n \n       if Needs_Variable_Reference_Marker (N => N, Calls_OK => False) then\n          declare\n-            Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n+            Is_Assignment_LHS : constant Boolean := Known_To_Be_Assigned (N);\n \n          begin\n             Build_Variable_Reference_Marker\n@@ -7086,15 +7082,13 @@ package body Sem_Ch8 is\n       else\n          Set_Entity_Or_Discriminal (N, Id);\n \n-         case Is_LHS (N) is\n-            when Yes =>\n+         case Known_To_Be_Assigned (N, Only_LHS => True) is\n+            when True =>\n                Generate_Reference (Id, N, 'm');\n \n-            when No =>\n+            when False =>\n                Generate_Reference (Id, N, 'r');\n \n-            when Unknown =>\n-               Defer_Reference ((Id, N));\n          end case;\n       end if;\n \n@@ -7190,7 +7184,7 @@ package body Sem_Ch8 is\n             Calls_OK => False)\n       then\n          declare\n-            Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n+            Is_Assignment_LHS : constant Boolean := Known_To_Be_Assigned (N);\n \n          begin\n             Build_Variable_Reference_Marker"}, {"sha": "99ba5d902b325b4a606e8819760030fa5955dad6", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -3886,7 +3886,7 @@ package body Sem_Eval is\n       --  Fold will perform the other relevant tests.\n \n       if Nkind (Parent (N)) /= N_Attribute_Reference\n-        and then Is_LHS (N) = No\n+        and then not Known_To_Be_Assigned (N)\n         and then not Is_Actual_Out_Or_In_Out_Parameter (N)\n       then\n          --  Simplify a selected_component on an aggregate by extracting"}, {"sha": "843e820fd7face7725eb7d9b31383984ce656b24", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -11070,7 +11070,7 @@ package body Sem_Res is\n       --  resolution was complete to do this, since otherwise we can't tell if\n       --  we are an lvalue or not.\n \n-      if May_Be_Lvalue (N) then\n+      if Known_To_Be_Assigned (N) then\n          Generate_Reference (Entity (S), S, 'm');\n       else\n          Generate_Reference (Entity (S), S, 'r');\n@@ -11096,7 +11096,7 @@ package body Sem_Res is\n          if Is_Entity_Name (P)\n            and then Has_Deferred_Reference (Entity (P))\n          then\n-            if May_Be_Lvalue (N) then\n+            if Known_To_Be_Assigned (N) then\n                Generate_Reference (Entity (P), P, 'm');\n             else\n                Generate_Reference (Entity (P), P, 'r');"}, {"sha": "38d84832c1a3dac0907d4b0fa0fdf027f786bc99", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 116, "deletions": 346, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -8361,7 +8361,7 @@ package body Sem_Util is\n \n       --  Local variables\n \n-      Owner : Node_Id;\n+      Owner : Node_Id := Empty;\n \n    --  Start of processing for End_Keyword_Location\n \n@@ -8979,7 +8979,7 @@ package body Sem_Util is\n    function Expression_Of_Expression_Function\n      (Subp : Entity_Id) return Node_Id\n    is\n-      Expr_Func : Node_Id;\n+      Expr_Func : Node_Id := Empty;\n \n    begin\n       pragma Assert (Is_Expression_Function_Or_Completion (Subp));\n@@ -9158,6 +9158,12 @@ package body Sem_Util is\n       then\n          Call_Nam := Name (Call);\n \n+         --  A call to an entry family may appear as an indexed component\n+\n+         if Nkind (Call_Nam) = N_Indexed_Component then\n+            Call_Nam := Prefix (Call_Nam);\n+         end if;\n+\n          --  A call to a protected or task entry appears as a selected\n          --  component rather than an expanded name.\n \n@@ -9167,7 +9173,11 @@ package body Sem_Util is\n \n          if Is_Entity_Name (Call_Nam)\n            and then Present (Entity (Call_Nam))\n-           and then Is_Overloadable (Entity (Call_Nam))\n+           and then (Is_Generic_Subprogram (Entity (Call_Nam))\n+                      or else Is_Overloadable (Entity (Call_Nam))\n+                      or else Ekind (Entity (Call_Nam)) in E_Entry_Family\n+                                                         | E_Subprogram_Body\n+                                                         | E_Subprogram_Type)\n            and then not Is_Overloaded (Call_Nam)\n          then\n             --  If node is name in call it is not an actual\n@@ -18252,60 +18262,124 @@ package body Sem_Util is\n       return Is_Array_Type (Container_Typ);\n    end Is_Iterator_Over_Array;\n \n-   ------------\n-   -- Is_LHS --\n-   ------------\n+   --------------------------\n+   -- Known_To_Be_Assigned --\n+   --------------------------\n \n-   --  We seem to have a lot of overlapping functions that do similar things\n-   --  (testing for left hand sides or lvalues???).\n+   function Known_To_Be_Assigned\n+     (N        : Node_Id;\n+      Only_LHS : Boolean := False) return Boolean\n+   is\n+      function Known_Assn (N : Node_Id) return Boolean is\n+        (Known_To_Be_Assigned (N, Only_LHS));\n+      --  Local function to simplify the passing of parameters for recursive\n+      --  calls.\n \n-   function Is_LHS (N : Node_Id) return Is_LHS_Result is\n-      P : constant Node_Id := Parent (N);\n+      P    : constant Node_Id := Parent (N);\n+      Form : Entity_Id := Empty;\n+      Call : Node_Id   := Empty;\n+\n+   --  Start of processing for Known_To_Be_Assigned\n \n    begin\n-      --  Return True if we are the left hand side of an assignment statement\n+      --  Check for out parameters\n \n-      if Nkind (P) = N_Assignment_Statement then\n-         if Name (P) = N then\n-            return Yes;\n-         else\n-            return No;\n-         end if;\n+      Find_Actual (N, Form, Call);\n \n-      --  Case of prefix of indexed or selected component or slice\n+      if Present (Form) then\n+         return Ekind (Form) /= E_In_Parameter and then not Only_LHS;\n+      end if;\n \n-      elsif Nkind (P) in N_Indexed_Component | N_Selected_Component | N_Slice\n-        and then N = Prefix (P)\n-      then\n-         --  Here we have the case where the parent P is N.Q or N(Q .. R).\n-         --  If P is an LHS, then N is also effectively an LHS, but there\n-         --  is an important exception. If N is of an access type, then\n-         --  what we really have is N.all.Q (or N.all(Q .. R)). In either\n-         --  case this makes N.all a left hand side but not N itself.\n+      --  Otherwise look at the parent\n \n-         --  If we don't know the type yet, this is the case where we return\n-         --  Unknown, since the answer depends on the type which is unknown.\n+      case Nkind (P) is\n \n-         if No (Etype (N)) then\n-            return Unknown;\n+         --  Test left side of assignment\n \n-         --  We have an Etype set, so we can check it\n+         when N_Assignment_Statement =>\n+            return N = Name (P);\n \n-         elsif Is_Access_Type (Etype (N)) then\n-            return No;\n+         --  Test prefix of component or attribute. Note that the prefix of an\n+         --  explicit or implicit dereference cannot be an l-value. In the case\n+         --  of a 'Read attribute, the reference can be an actual in the\n+         --  argument list of the attribute.\n \n-         --  OK, not access type case, so just test whole expression\n+         when N_Attribute_Reference =>\n+            return\n+              not Only_LHS and then\n+                ((N = Prefix (P)\n+                   and then Name_Implies_Lvalue_Prefix (Attribute_Name (P)))\n+                 or else\n+                   Attribute_Name (P) = Name_Read);\n \n-         else\n-            return Is_LHS (P);\n-         end if;\n+         --  For an expanded name, the name is an lvalue if the expanded name\n+         --  is an lvalue, but the prefix is never an lvalue, since it is just\n+         --  the scope where the name is found.\n+\n+         when N_Expanded_Name =>\n+            if N = Prefix (P) then\n+               return Known_Assn (P);\n+            else\n+               return False;\n+            end if;\n \n-      --  All other cases are not left hand sides\n+         --  For a selected component A.B, A is certainly an lvalue if A.B is.\n+         --  B is a little interesting, if we have A.B := 3, there is some\n+         --  discussion as to whether B is an lvalue or not, we choose to say\n+         --  it is. Note however that A is not an lvalue if it is of an access\n+         --  type since this is an implicit dereference.\n \n-      else\n-         return No;\n-      end if;\n-   end Is_LHS;\n+         when N_Selected_Component =>\n+            if N = Prefix (P)\n+              and then Present (Etype (N))\n+              and then Is_Access_Type (Etype (N))\n+            then\n+               return False;\n+            else\n+               return Known_Assn (P);\n+            end if;\n+\n+         --  For an indexed component or slice, the index or slice bounds is\n+         --  never an lvalue. The prefix is an lvalue if the indexed component\n+         --  or slice is an lvalue, except if it is an access type, where we\n+         --  have an implicit dereference.\n+\n+         when N_Indexed_Component | N_Slice =>\n+            if N /= Prefix (P)\n+              or else (Present (Etype (N)) and then Is_Access_Type (Etype (N)))\n+            then\n+               return False;\n+            else\n+               return Known_Assn (P);\n+            end if;\n+\n+         --  Prefix of a reference is an lvalue if the reference is an lvalue\n+\n+         when N_Reference =>\n+            return Known_Assn (P);\n+\n+         --  Prefix of explicit dereference is never an lvalue\n+\n+         when N_Explicit_Dereference =>\n+            return False;\n+\n+         --  Test for appearing in a conversion that itself appears in an\n+         --  lvalue context, since this should be an lvalue.\n+\n+         when N_Type_Conversion =>\n+            return Known_Assn (P);\n+\n+         --  Test for appearance in object renaming declaration\n+\n+         when N_Object_Renaming_Declaration =>\n+            return not Only_LHS;\n+\n+         --  All other references are definitely not lvalues\n+\n+         when others =>\n+            return False;\n+      end case;\n+   end Known_To_Be_Assigned;\n \n    -----------------------------\n    -- Is_Library_Level_Entity --\n@@ -22149,121 +22223,6 @@ package body Sem_Util is\n       return False;\n    end Known_Null;\n \n-   --------------------------\n-   -- Known_To_Be_Assigned --\n-   --------------------------\n-\n-   function Known_To_Be_Assigned (N : Node_Id) return Boolean is\n-      P : constant Node_Id := Parent (N);\n-\n-   begin\n-      case Nkind (P) is\n-\n-         --  Test left side of assignment\n-\n-         when N_Assignment_Statement =>\n-            return N = Name (P);\n-\n-         --  Function call arguments are never lvalues\n-\n-         when N_Function_Call =>\n-            return False;\n-\n-         --  Positional parameter for procedure or accept call\n-\n-         when N_Accept_Statement\n-            | N_Procedure_Call_Statement\n-         =>\n-            declare\n-               Proc : Entity_Id;\n-               Form : Entity_Id;\n-               Act  : Node_Id;\n-\n-            begin\n-               Proc := Get_Subprogram_Entity (P);\n-\n-               if No (Proc) then\n-                  return False;\n-               end if;\n-\n-               --  If we are not a list member, something is strange, so\n-               --  be conservative and return False.\n-\n-               if not Is_List_Member (N) then\n-                  return False;\n-               end if;\n-\n-               --  We are going to find the right formal by stepping forward\n-               --  through the formals, as we step backwards in the actuals.\n-\n-               Form := First_Formal (Proc);\n-               Act  := N;\n-               loop\n-                  --  If no formal, something is weird, so be conservative\n-                  --  and return False.\n-\n-                  if No (Form) then\n-                     return False;\n-                  end if;\n-\n-                  Prev (Act);\n-                  exit when No (Act);\n-                  Next_Formal (Form);\n-               end loop;\n-\n-               return Ekind (Form) /= E_In_Parameter;\n-            end;\n-\n-         --  Named parameter for procedure or accept call\n-\n-         when N_Parameter_Association =>\n-            declare\n-               Proc : Entity_Id;\n-               Form : Entity_Id;\n-\n-            begin\n-               Proc := Get_Subprogram_Entity (Parent (P));\n-\n-               if No (Proc) then\n-                  return False;\n-               end if;\n-\n-               --  Loop through formals to find the one that matches\n-\n-               Form := First_Formal (Proc);\n-               loop\n-                  --  If no matching formal, that's peculiar, some kind of\n-                  --  previous error, so return False to be conservative.\n-                  --  Actually this also happens in legal code in the case\n-                  --  where P is a parameter association for an Extra_Formal???\n-\n-                  if No (Form) then\n-                     return False;\n-                  end if;\n-\n-                  --  Else test for match\n-\n-                  if Chars (Form) = Chars (Selector_Name (P)) then\n-                     return Ekind (Form) /= E_In_Parameter;\n-                  end if;\n-\n-                  Next_Formal (Form);\n-               end loop;\n-            end;\n-\n-         --  Test for appearing in a conversion that itself appears\n-         --  in an lvalue context, since this should be an lvalue.\n-\n-         when N_Type_Conversion =>\n-            return Known_To_Be_Assigned (P);\n-\n-         --  All other references are definitely not known to be modifications\n-\n-         when others =>\n-            return False;\n-      end case;\n-   end Known_To_Be_Assigned;\n-\n    ---------------------------\n    -- Last_Source_Statement --\n    ---------------------------\n@@ -22749,195 +22708,6 @@ package body Sem_Util is\n       return True;\n    end Matching_Static_Array_Bounds;\n \n-   -------------------\n-   -- May_Be_Lvalue --\n-   -------------------\n-\n-   function May_Be_Lvalue (N : Node_Id) return Boolean is\n-      P : constant Node_Id := Parent (N);\n-\n-   begin\n-      case Nkind (P) is\n-\n-         --  Test left side of assignment\n-\n-         when N_Assignment_Statement =>\n-            return N = Name (P);\n-\n-         --  Test prefix of component or attribute. Note that the prefix of an\n-         --  explicit or implicit dereference cannot be an l-value. In the case\n-         --  of a 'Read attribute, the reference can be an actual in the\n-         --  argument list of the attribute.\n-\n-         when N_Attribute_Reference =>\n-            return (N = Prefix (P)\n-                     and then Name_Implies_Lvalue_Prefix (Attribute_Name (P)))\n-                 or else\n-                   Attribute_Name (P) = Name_Read;\n-\n-         --  For an expanded name, the name is an lvalue if the expanded name\n-         --  is an lvalue, but the prefix is never an lvalue, since it is just\n-         --  the scope where the name is found.\n-\n-         when N_Expanded_Name =>\n-            if N = Prefix (P) then\n-               return May_Be_Lvalue (P);\n-            else\n-               return False;\n-            end if;\n-\n-         --  For a selected component A.B, A is certainly an lvalue if A.B is.\n-         --  B is a little interesting, if we have A.B := 3, there is some\n-         --  discussion as to whether B is an lvalue or not, we choose to say\n-         --  it is. Note however that A is not an lvalue if it is of an access\n-         --  type since this is an implicit dereference.\n-\n-         when N_Selected_Component =>\n-            if N = Prefix (P)\n-              and then Present (Etype (N))\n-              and then Is_Access_Type (Etype (N))\n-            then\n-               return False;\n-            else\n-               return May_Be_Lvalue (P);\n-            end if;\n-\n-         --  For an indexed component or slice, the index or slice bounds is\n-         --  never an lvalue. The prefix is an lvalue if the indexed component\n-         --  or slice is an lvalue, except if it is an access type, where we\n-         --  have an implicit dereference.\n-\n-         when N_Indexed_Component\n-            | N_Slice\n-         =>\n-            if N /= Prefix (P)\n-              or else (Present (Etype (N)) and then Is_Access_Type (Etype (N)))\n-            then\n-               return False;\n-            else\n-               return May_Be_Lvalue (P);\n-            end if;\n-\n-         --  Prefix of a reference is an lvalue if the reference is an lvalue\n-\n-         when N_Reference =>\n-            return May_Be_Lvalue (P);\n-\n-         --  Prefix of explicit dereference is never an lvalue\n-\n-         when N_Explicit_Dereference =>\n-            return False;\n-\n-         --  Positional parameter for subprogram, entry, or accept call.\n-         --  In older versions of Ada function call arguments are never\n-         --  lvalues. In Ada 2012 functions can have in-out parameters.\n-\n-         when N_Accept_Statement\n-            | N_Entry_Call_Statement\n-            | N_Subprogram_Call\n-         =>\n-            if Nkind (P) = N_Function_Call and then Ada_Version < Ada_2012 then\n-               return False;\n-            end if;\n-\n-            --  The following mechanism is clumsy and fragile. A single flag\n-            --  set in Resolve_Actuals would be preferable ???\n-\n-            declare\n-               Proc : Entity_Id;\n-               Form : Entity_Id;\n-               Act  : Node_Id;\n-\n-            begin\n-               Proc := Get_Subprogram_Entity (P);\n-\n-               if No (Proc) then\n-                  return True;\n-               end if;\n-\n-               --  If we are not a list member, something is strange, so be\n-               --  conservative and return True.\n-\n-               if not Is_List_Member (N) then\n-                  return True;\n-               end if;\n-\n-               --  We are going to find the right formal by stepping forward\n-               --  through the formals, as we step backwards in the actuals.\n-\n-               Form := First_Formal (Proc);\n-               Act  := N;\n-               loop\n-                  --  If no formal, something is weird, so be conservative and\n-                  --  return True.\n-\n-                  if No (Form) then\n-                     return True;\n-                  end if;\n-\n-                  Prev (Act);\n-                  exit when No (Act);\n-                  Next_Formal (Form);\n-               end loop;\n-\n-               return Ekind (Form) /= E_In_Parameter;\n-            end;\n-\n-         --  Named parameter for procedure or accept call\n-\n-         when N_Parameter_Association =>\n-            declare\n-               Proc : Entity_Id;\n-               Form : Entity_Id;\n-\n-            begin\n-               Proc := Get_Subprogram_Entity (Parent (P));\n-\n-               if No (Proc) then\n-                  return True;\n-               end if;\n-\n-               --  Loop through formals to find the one that matches\n-\n-               Form := First_Formal (Proc);\n-               loop\n-                  --  If no matching formal, that's peculiar, some kind of\n-                  --  previous error, so return True to be conservative.\n-                  --  Actually happens with legal code for an unresolved call\n-                  --  where we may get the wrong homonym???\n-\n-                  if No (Form) then\n-                     return True;\n-                  end if;\n-\n-                  --  Else test for match\n-\n-                  if Chars (Form) = Chars (Selector_Name (P)) then\n-                     return Ekind (Form) /= E_In_Parameter;\n-                  end if;\n-\n-                  Next_Formal (Form);\n-               end loop;\n-            end;\n-\n-         --  Test for appearing in a conversion that itself appears in an\n-         --  lvalue context, since this should be an lvalue.\n-\n-         when N_Type_Conversion =>\n-            return May_Be_Lvalue (P);\n-\n-         --  Test for appearance in object renaming declaration\n-\n-         when N_Object_Renaming_Declaration =>\n-            return True;\n-\n-         --  All other references are definitely not lvalues\n-\n-         when others =>\n-            return False;\n-      end case;\n-   end May_Be_Lvalue;\n-\n    -----------------\n    -- Might_Raise --\n    -----------------"}, {"sha": "911cc2deeefe4e0ac87a605c5ceb9f32e350edde", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -2159,16 +2159,6 @@ package Sem_Util is\n    --  an array, either inside a loop of the form 'for X of A' or a quantified\n    --  expression of the form 'for all/some X of A' where A is of array type.\n \n-   type Is_LHS_Result is (Yes, No, Unknown);\n-   function Is_LHS (N : Node_Id) return Is_LHS_Result;\n-   --  Returns Yes if N is definitely used as Name in an assignment statement.\n-   --  Returns No if N is definitely NOT used as a Name in an assignment\n-   --  statement. Returns Unknown if we can't tell at this stage (happens in\n-   --  the case where we don't know the type of N yet, and we have something\n-   --  like N.A := 3, where this counts as N being used on the left side of\n-   --  an assignment only if N is not an access type. If it is an access type\n-   --  then it is N.all.A that is assigned, not N.\n-\n    function Is_Library_Level_Entity (E : Entity_Id) return Boolean;\n    --  A library-level declaration is one that is accessible from Standard,\n    --  i.e. a library unit or an entity declared in a library package.\n@@ -2589,12 +2579,13 @@ package Sem_Util is\n    --  and returns True if so. Returns False otherwise. It is an error to call\n    --  this function if N is not of an access type.\n \n-   function Known_To_Be_Assigned (N : Node_Id) return Boolean;\n+   function Known_To_Be_Assigned\n+     (N        : Node_Id;\n+      Only_LHS : Boolean := False) return Boolean;\n    --  The node N is an entity reference. This function determines whether the\n    --  reference is for sure an assignment of the entity, returning True if\n-   --  so. This differs from May_Be_Lvalue in that it defaults in the other\n-   --  direction. Cases which may possibly be assignments but are not known to\n-   --  be may return True from May_Be_Lvalue, but False from this function.\n+   --  so. Only_LHS will modify this behavior such that actuals for out or\n+   --  in out parameters will not be considered assigned.\n \n    function Last_Source_Statement (HSS : Node_Id) return Node_Id;\n    --  HSS is a handled statement sequence. This function returns the last\n@@ -2633,17 +2624,6 @@ package Sem_Util is\n    --  same number of dimensions, and the same static bounds for each index\n    --  position.\n \n-   function May_Be_Lvalue (N : Node_Id) return Boolean;\n-   --  Determines if N could be an lvalue (e.g. an assignment left hand side).\n-   --  An lvalue is defined as any expression which appears in a context where\n-   --  a name is required by the syntax, and the identity, rather than merely\n-   --  the value of the node is needed (for example, the prefix of an Access\n-   --  attribute is in this category). Note that, as implied by the name, this\n-   --  test is conservative. If it cannot be sure that N is NOT an lvalue, then\n-   --  it returns True. It tries hard to get the answer right, but it is hard\n-   --  to guarantee this in all cases. Note that it is more possible to give\n-   --  correct answer if the tree is fully analyzed.\n-\n    function Might_Raise (N : Node_Id) return Boolean;\n    --  True if evaluation of N might raise an exception. This is conservative;\n    --  if we're not sure, we return True. If N is a subprogram body, this is"}, {"sha": "85d5365ba103d0becae8583a0211dd6c908d6407", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a29376c63172540576bd9b1d20f5c7c0e42cf3/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=72a29376c63172540576bd9b1d20f5c7c0e42cf3", "patch": "@@ -513,7 +513,7 @@ package body Sem_Warn is\n             --  If this is an lvalue, then definitely abandon, since\n             --  this could be a direct modification of the variable.\n \n-            if May_Be_Lvalue (N) then\n+            if Known_To_Be_Assigned (N) then\n                return Abandon;\n             end if;\n \n@@ -559,7 +559,7 @@ package body Sem_Warn is\n            and then Present (Renamed_Object (Entity (N)))\n            and then Is_Entity_Name (Renamed_Object (Entity (N)))\n            and then Entity (Renamed_Object (Entity (N))) = Var\n-           and then May_Be_Lvalue (N)\n+           and then Known_To_Be_Assigned (N)\n          then\n             return Abandon;\n \n@@ -4596,10 +4596,11 @@ package body Sem_Warn is\n                         if Nkind (Parent (LA)) in N_Parameter_Association\n                                                 | N_Procedure_Call_Statement\n                         then\n-                           Error_Msg_NE\n-                             (\"?m?& modified by call, but value might not be \"\n-                              & \"referenced\", LA, Ent);\n-\n+                           if Warn_On_All_Unread_Out_Parameters then\n+                              Error_Msg_NE\n+                                (\"?m?& modified by call, but value might not \"\n+                                 & \"be referenced\", LA, Ent);\n+                           end if;\n                         else\n                            Error_Msg_NE -- CODEFIX\n                              (\"?m?possibly useless assignment to&, value \""}]}