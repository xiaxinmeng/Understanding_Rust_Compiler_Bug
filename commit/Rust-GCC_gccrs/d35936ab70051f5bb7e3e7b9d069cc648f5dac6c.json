{"sha": "d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM1OTM2YWI3MDA1MWY1YmI3ZTNlN2I5ZDA2OWNjNjQ4ZjVkYWM2Yw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-04T09:04:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-04T09:04:53Z"}, "message": "tree.h (int_const_binop): Remove notrunc argument.\n\n2011-05-04  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (int_const_binop): Remove notrunc argument.\n\t* fold-const.c (int_const_binop): Remove notrunc argument.  Always\n\tcreate integer constants that are properly truncated.\n\t(extract_muldiv_1): Expand one notrunc int_const_binop caller.\n\t(const_binop): Remove zero notrunc argument to int_const_binop.\n\t(size_binop_loc): Likewise.\n\t(fold_div_compare): Likewise.\n\t(maybe_canonicalize_comparison_1): Likewise.\n\t(fold_comparison): Likewise.\n\t(fold_binary_loc): Likewise.\n\t(multiple_of_p): Likewise.\n\t* expr.c (store_constructor): Likewise.\n\t* gimple-fold.c (maybe_fold_offset_to_array_ref): Likewise.\n\t(maybe_fold_stmt_addition): Likewise.\n\t* ipa-prop.c (ipa_modify_call_arguments): Likewise.\n\t* stor-layout.c (layout_type): Likewise.\n\t* tree-data-ref.c (tree_fold_divides_p): Likewise.\n\t* tree-sra.c (build_ref_for_offset): Likewise.\n\t(build_user_friendly_ref_for_offset): Likewise.\n\t* tree-ssa-address.c (maybe_fold_tmr): Likewise.\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n\t* tree-ssa-loop-niter.c (inverse): Likewise.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n\t* tree-ssa.c (maybe_rewrite_mem_ref_base): Likewise.\n\t* tree-switch-conversion.c (check_range): Likewise.\n\t(build_constructors): Likewise.\n\t* tree-vect-generic.c (expand_vector_piecewise): Likewise.\n\t* tree-vrp.c (set_and_canonicalize_value_range): Likewise.\n\t(extract_range_from_assert): Likewise.\n\t(vrp_int_const_binop): Likewise.\n\t(extract_range_from_binary_expr): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\n\t(check_array_ref): Likewise.\n\t(find_case_label_range): Likewise.\n\t(simplify_div_or_mod_using_ranges): Likewise.\n\t* tree-cfg.c (group_case_labels_stmt): Use double-ints for\n\tcomparing case labels for merging.\n\n\n\tada/\n\t* gcc-interface/trans.c (gnat_to_gnu): Remove zero notrunc argument to\n\tint_const_binop.\n\t(pos_to_constructor): Likewise.\n\n\tfortran/\n\t* trans-types.c (gfc_get_array_type_bounds): Remove zero notrunc\n\targument to int_const_binop.\n\nFrom-SVN: r173356", "tree": {"sha": "5c3cd9ce515aaedc793b4255fad9d3b6f6f3f621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c3cd9ce515aaedc793b4255fad9d3b6f6f3f621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8992c063a6de3bce68f41c42147e829bf0fd671f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8992c063a6de3bce68f41c42147e829bf0fd671f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8992c063a6de3bce68f41c42147e829bf0fd671f"}], "stats": {"total": 249, "additions": 151, "deletions": 98}, "files": [{"sha": "5f31ad8fd70ddeec7005d4e95db3ebca4b84a16c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1,3 +1,43 @@\n+2011-05-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (int_const_binop): Remove notrunc argument.\n+\t* fold-const.c (int_const_binop): Remove notrunc argument.  Always\n+\tcreate integer constants that are properly truncated.\n+\t(extract_muldiv_1): Expand one notrunc int_const_binop caller.\n+\t(const_binop): Remove zero notrunc argument to int_const_binop.\n+\t(size_binop_loc): Likewise.\n+\t(fold_div_compare): Likewise.\n+\t(maybe_canonicalize_comparison_1): Likewise.\n+\t(fold_comparison): Likewise.\n+\t(fold_binary_loc): Likewise.\n+\t(multiple_of_p): Likewise.\n+\t* expr.c (store_constructor): Likewise.\n+\t* gimple-fold.c (maybe_fold_offset_to_array_ref): Likewise.\n+\t(maybe_fold_stmt_addition): Likewise.\n+\t* ipa-prop.c (ipa_modify_call_arguments): Likewise.\n+\t* stor-layout.c (layout_type): Likewise.\n+\t* tree-data-ref.c (tree_fold_divides_p): Likewise.\n+\t* tree-sra.c (build_ref_for_offset): Likewise.\n+\t(build_user_friendly_ref_for_offset): Likewise.\n+\t* tree-ssa-address.c (maybe_fold_tmr): Likewise.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n+\t* tree-ssa-loop-niter.c (inverse): Likewise.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Likewise.\n+\t* tree-ssa.c (maybe_rewrite_mem_ref_base): Likewise.\n+\t* tree-switch-conversion.c (check_range): Likewise.\n+\t(build_constructors): Likewise.\n+\t* tree-vect-generic.c (expand_vector_piecewise): Likewise.\n+\t* tree-vrp.c (set_and_canonicalize_value_range): Likewise.\n+\t(extract_range_from_assert): Likewise.\n+\t(vrp_int_const_binop): Likewise.\n+\t(extract_range_from_binary_expr): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t(check_array_ref): Likewise.\n+\t(find_case_label_range): Likewise.\n+\t(simplify_div_or_mod_using_ranges): Likewise.\n+\t* tree-cfg.c (group_case_labels_stmt): Use double-ints for\n+\tcomparing case labels for merging.\n+\n 2011-05-03  Mark Wielaard  <mjw@redhat.com>\n \n \t* dwarf2out.c (debug_str_hash_forced): Removed."}, {"sha": "5f234a2fb54f444525014a66deda35a73d333b73", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1,3 +1,9 @@\n+2011-05-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu): Remove zero notrunc argument to\n+\tint_const_binop.\n+\t(pos_to_constructor): Likewise.\n+\n 2011-05-03  Nathan Froyd  <froydnj@codesourcery.com>\n             Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "06b778b27baf5538f1f6561af481c1f887515d11", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -4121,8 +4121,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t      Get_String_Char (gnat_string, i + 1));\n \n \t      CONSTRUCTOR_APPEND_ELT (gnu_vec, gnu_idx, t);\n-\t      gnu_idx = int_const_binop (PLUS_EXPR, gnu_idx, integer_one_node,\n-\t\t\t\t\t 0);\n+\t      gnu_idx = int_const_binop (PLUS_EXPR, gnu_idx, integer_one_node);\n \t    }\n \n \t  gnu_result = gnat_build_constructor (gnu_result_type, gnu_vec);\n@@ -7601,7 +7600,7 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n       CONSTRUCTOR_APPEND_ELT (gnu_expr_vec, gnu_index,\n \t\t\t      convert (TREE_TYPE (gnu_array_type), gnu_expr));\n \n-      gnu_index = int_const_binop (PLUS_EXPR, gnu_index, integer_one_node, 0);\n+      gnu_index = int_const_binop (PLUS_EXPR, gnu_index, integer_one_node);\n     }\n \n   return gnat_build_constructor (gnu_array_type, gnu_expr_vec);"}, {"sha": "dde55711067fa6303739428d131bc42af51c859f", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -5665,7 +5665,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\tint n_elts_here = tree_low_cst\n \t\t  (int_const_binop (TRUNC_DIV_EXPR,\n \t\t\t\t    TYPE_SIZE (TREE_TYPE (value)),\n-\t\t\t\t    TYPE_SIZE (elttype), 0), 1);\n+\t\t\t\t    TYPE_SIZE (elttype)), 1);\n \n \t\tcount += n_elts_here;\n \t\tif (mostly_zeros_p (value))"}, {"sha": "f7d4e5f05c957d0548c3f0d0e5bdb513598d0ee9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -936,12 +936,10 @@ int_binop_types_match_p (enum tree_code code, const_tree type1, const_tree type2\n \n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n    to produce a new constant.  Return NULL_TREE if we don't know how\n-   to evaluate CODE at compile-time.\n-\n-   If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n+   to evaluate CODE at compile-time.  */\n \n tree\n-int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2, int notrunc)\n+int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2)\n {\n   double_int op1, op2, res, tmp;\n   tree t;\n@@ -1083,22 +1081,9 @@ int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2, int notr\n       return NULL_TREE;\n     }\n \n-  if (notrunc)\n-    {\n-      t = build_int_cst_wide (TREE_TYPE (arg1), res.low, res.high);\n-\n-      /* Propagate overflow flags ourselves.  */\n-      if (((!uns || is_sizetype) && overflow)\n-\t  | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2))\n-\t{\n-\t  t = copy_node (t);\n-\t  TREE_OVERFLOW (t) = 1;\n-\t}\n-    }\n-  else\n-    t = force_fit_type_double (TREE_TYPE (arg1), res, 1,\n-\t\t\t       ((!uns || is_sizetype) && overflow)\n-\t\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n+  t = force_fit_type_double (TREE_TYPE (arg1), res, 1,\n+\t\t\t     ((!uns || is_sizetype) && overflow)\n+\t\t\t     | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n \n   return t;\n }\n@@ -1119,7 +1104,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n   STRIP_NOPS (arg2);\n \n   if (TREE_CODE (arg1) == INTEGER_CST)\n-    return int_const_binop (code, arg1, arg2, 0);\n+    return int_const_binop (code, arg1, arg2);\n \n   if (TREE_CODE (arg1) == REAL_CST)\n     {\n@@ -1464,7 +1449,7 @@ size_binop_loc (location_t loc, enum tree_code code, tree arg0, tree arg1)\n \t}\n \n       /* Handle general case of two integer constants.  */\n-      return int_const_binop (code, arg0, arg1, 0);\n+      return int_const_binop (code, arg0, arg1);\n     }\n \n   return fold_build2_loc (loc, code, type, arg0, arg1);\n@@ -5873,16 +5858,33 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \n       /* If these are the same operation types, we can associate them\n \t assuming no overflow.  */\n-      if (tcode == code\n-\t  && 0 != (t1 = int_const_binop (MULT_EXPR,\n-\t\t\t\t\t fold_convert (ctype, op1),\n-\t\t\t\t\t fold_convert (ctype, c), 1))\n-\t  && 0 != (t1 = force_fit_type_double (ctype, tree_to_double_int (t1),\n-\t\t\t\t\t       (TYPE_UNSIGNED (ctype)\n-\t\t\t\t\t        && tcode != MULT_EXPR) ? -1 : 1,\n-\t\t\t\t\t       TREE_OVERFLOW (t1)))\n-\t  && !TREE_OVERFLOW (t1))\n-\treturn fold_build2 (tcode, ctype, fold_convert (ctype, op0), t1);\n+      if (tcode == code)\n+\t{\n+\t  double_int mul;\n+\t  int overflow_p;\n+\t  mul = double_int_mul_with_sign\n+\t          (double_int_ext\n+\t\t     (tree_to_double_int (op1),\n+\t\t      TYPE_PRECISION (ctype), TYPE_UNSIGNED (ctype)),\n+\t\t   double_int_ext\n+\t\t     (tree_to_double_int (c),\n+\t\t      TYPE_PRECISION (ctype), TYPE_UNSIGNED (ctype)),\n+\t\t   false, &overflow_p);\n+\t  overflow_p = (((!TYPE_UNSIGNED (ctype)\n+\t\t\t  || (TREE_CODE (ctype) == INTEGER_TYPE\n+\t\t\t      && TYPE_IS_SIZETYPE (ctype)))\n+\t\t\t && overflow_p)\n+\t\t\t| TREE_OVERFLOW (c) | TREE_OVERFLOW (op1));\n+\t  if (!double_int_fits_to_tree_p (ctype, mul)\n+\t      && ((TYPE_UNSIGNED (ctype) && tcode != MULT_EXPR)\n+\t\t  || !TYPE_UNSIGNED (ctype)\n+\t\t  || (TREE_CODE (ctype) == INTEGER_TYPE\n+\t\t      && TYPE_IS_SIZETYPE (ctype))))\n+\t    overflow_p = 1;\n+\t  if (!overflow_p)\n+\t    return fold_build2 (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t\tdouble_int_to_tree (ctype, mul));\n+\t}\n \n       /* If these operations \"cancel\" each other, we have the main\n \t optimizations of this pass, which occur when either constant is a\n@@ -6287,7 +6289,7 @@ fold_div_compare (location_t loc,\n   int overflow;\n \n   /* We have to do this the hard way to detect unsigned overflow.\n-     prod = int_const_binop (MULT_EXPR, arg01, arg1, 0);  */\n+     prod = int_const_binop (MULT_EXPR, arg01, arg1);  */\n   overflow = mul_double_with_sign (TREE_INT_CST_LOW (arg01),\n \t\t\t\t   TREE_INT_CST_HIGH (arg01),\n \t\t\t\t   TREE_INT_CST_LOW (arg1),\n@@ -6299,10 +6301,10 @@ fold_div_compare (location_t loc,\n   if (unsigned_p)\n     {\n       tmp = int_const_binop (MINUS_EXPR, arg01,\n-                             build_int_cst (TREE_TYPE (arg01), 1), 0);\n+                             build_int_cst (TREE_TYPE (arg01), 1));\n       lo = prod;\n \n-      /* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp, 0).  */\n+      /* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp).  */\n       overflow = add_double_with_sign (TREE_INT_CST_LOW (prod),\n \t\t\t\t       TREE_INT_CST_HIGH (prod),\n \t\t\t\t       TREE_INT_CST_LOW (tmp),\n@@ -6314,12 +6316,12 @@ fold_div_compare (location_t loc,\n   else if (tree_int_cst_sgn (arg01) >= 0)\n     {\n       tmp = int_const_binop (MINUS_EXPR, arg01,\n-\t\t\t     build_int_cst (TREE_TYPE (arg01), 1), 0);\n+\t\t\t     build_int_cst (TREE_TYPE (arg01), 1));\n       switch (tree_int_cst_sgn (arg1))\n \t{\n \tcase -1:\n \t  neg_overflow = true;\n-\t  lo = int_const_binop (MINUS_EXPR, prod, tmp, 0);\n+\t  lo = int_const_binop (MINUS_EXPR, prod, tmp);\n \t  hi = prod;\n \t  break;\n \n@@ -6329,7 +6331,7 @@ fold_div_compare (location_t loc,\n \t  break;\n \n \tcase  1:\n-          hi = int_const_binop (PLUS_EXPR, prod, tmp, 0);\n+          hi = int_const_binop (PLUS_EXPR, prod, tmp);\n \t  lo = prod;\n \t  break;\n \n@@ -6343,11 +6345,11 @@ fold_div_compare (location_t loc,\n       code = swap_tree_comparison (code);\n \n       tmp = int_const_binop (PLUS_EXPR, arg01,\n-\t\t\t     build_int_cst (TREE_TYPE (arg01), 1), 0);\n+\t\t\t     build_int_cst (TREE_TYPE (arg01), 1));\n       switch (tree_int_cst_sgn (arg1))\n \t{\n \tcase -1:\n-\t  hi = int_const_binop (MINUS_EXPR, prod, tmp, 0);\n+\t  hi = int_const_binop (MINUS_EXPR, prod, tmp);\n \t  lo = prod;\n \t  break;\n \n@@ -6358,7 +6360,7 @@ fold_div_compare (location_t loc,\n \n \tcase  1:\n \t  neg_overflow = true;\n-\t  lo = int_const_binop (PLUS_EXPR, prod, tmp, 0);\n+\t  lo = int_const_binop (PLUS_EXPR, prod, tmp);\n \t  hi = prod;\n \t  break;\n \n@@ -8368,7 +8370,7 @@ maybe_canonicalize_comparison_1 (location_t loc, enum tree_code code, tree type,\n     return NULL_TREE;\n \n   t = int_const_binop (sgn0 == -1 ? PLUS_EXPR : MINUS_EXPR,\n-\t\t       cst0, build_int_cst (TREE_TYPE (cst0), 1), 0);\n+\t\t       cst0, build_int_cst (TREE_TYPE (cst0), 1));\n   if (code0 != INTEGER_CST)\n     t = fold_build2_loc (loc, code0, TREE_TYPE (arg0), TREE_OPERAND (arg0, 0), t);\n \n@@ -8803,7 +8805,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t of lower absolute value than before.  */\n       cst = int_const_binop (TREE_CODE (arg0) == TREE_CODE (arg1)\n \t\t\t     ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t     const2, const1, 0);\n+\t\t\t     const2, const1);\n       if (!TREE_OVERFLOW (cst)\n \t  && tree_int_cst_compare (const2, cst) == tree_int_cst_sgn (const2))\n \t{\n@@ -8817,7 +8819,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \n       cst = int_const_binop (TREE_CODE (arg0) == TREE_CODE (arg1)\n \t\t\t     ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t     const1, const2, 0);\n+\t\t\t     const1, const2);\n       if (!TREE_OVERFLOW (cst)\n \t  && tree_int_cst_compare (const1, cst) == tree_int_cst_sgn (const1))\n \t{\n@@ -9458,7 +9460,7 @@ fold_binary_loc (location_t loc,\n \t  return fold_build2 (MEM_REF, type,\n \t\t\t      TREE_OPERAND (iref, 0),\n \t\t\t      int_const_binop (PLUS_EXPR, arg1,\n-\t\t\t\t\t       TREE_OPERAND (iref, 1), 0));\n+\t\t\t\t\t       TREE_OPERAND (iref, 1)));\n \t}\n \n       /* MEM[&a.b, CST2] -> MEM[&a, offsetof (a, b) + CST2].  */\n@@ -9474,7 +9476,7 @@ fold_binary_loc (location_t loc,\n \t  return fold_build2 (MEM_REF, type,\n \t\t\t      build_fold_addr_expr (base),\n \t\t\t      int_const_binop (PLUS_EXPR, arg1,\n-\t\t\t\t\t       size_int (coffset), 0));\n+\t\t\t\t\t       size_int (coffset)));\n \t}\n \n       return NULL_TREE;\n@@ -11815,7 +11817,7 @@ fold_binary_loc (location_t loc,\n \t      arg00 = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n \n \t      lshift = build_int_cst (type, -1);\n-\t      lshift = int_const_binop (code, lshift, arg1, 0);\n+\t      lshift = int_const_binop (code, lshift, arg1);\n \n \t      return fold_build2_loc (loc, BIT_AND_EXPR, type, arg00, lshift);\n \t    }\n@@ -14371,7 +14373,7 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n \t\t  || tree_int_cst_sgn (bottom) < 0)))\n \treturn 0;\n       return integer_zerop (int_const_binop (TRUNC_MOD_EXPR,\n-\t\t\t\t\t     top, bottom, 0));\n+\t\t\t\t\t     top, bottom));\n \n     default:\n       return 0;"}, {"sha": "f5e8ba6109682a86fc2795b0ad739cd049d42359", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1,3 +1,8 @@\n+2011-05-04  Richard Guenther  <rguenther@suse.de>\n+\n+\t* trans-types.c (gfc_get_array_type_bounds): Remove zero notrunc\n+\targument to int_const_binop.\n+\n 2011-05-03  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/18918"}, {"sha": "27dcf828c441aaeaa2535f4b340d264a60dedf80", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1745,7 +1745,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n   if (stride)\n     rtype = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t      int_const_binop (MINUS_EXPR, stride,\n-\t\t\t\t\t       integer_one_node, 0));\n+\t\t\t\t\t       integer_one_node));\n   else\n     rtype = gfc_array_range_type;\n   arraytype = build_array_type (etype, rtype);"}, {"sha": "e5303e31f7e93bae2341cfff3d84ddbdc865af60", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -230,7 +230,7 @@ maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset)\n \t  || TREE_CODE (elt_offset) != INTEGER_CST)\n \treturn NULL_TREE;\n \n-      elt_offset = int_const_binop (MINUS_EXPR, elt_offset, low_bound, 0);\n+      elt_offset = int_const_binop (MINUS_EXPR, elt_offset, low_bound);\n       base = TREE_OPERAND (base, 0);\n     }\n \n@@ -300,9 +300,9 @@ maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset)\n     }\n \n   if (!integer_zerop (min_idx))\n-    idx = int_const_binop (PLUS_EXPR, idx, min_idx, 0);\n+    idx = int_const_binop (PLUS_EXPR, idx, min_idx);\n   if (!integer_zerop (elt_offset))\n-    idx = int_const_binop (PLUS_EXPR, idx, elt_offset, 0);\n+    idx = int_const_binop (PLUS_EXPR, idx, elt_offset);\n \n   /* Make sure to possibly truncate late after offsetting.  */\n   idx = fold_convert (idx_type, idx);\n@@ -517,17 +517,17 @@ maybe_fold_stmt_addition (location_t loc, tree res_type, tree op0, tree op1)\n \t      array_idx = fold_convert (TREE_TYPE (min_idx), array_idx);\n \t      if (!integer_zerop (min_idx))\n \t\tarray_idx = int_const_binop (MINUS_EXPR, array_idx,\n-\t\t\t\t\t     min_idx, 0);\n+\t\t\t\t\t     min_idx);\n \t    }\n \t}\n \n       /* Convert the index to a byte offset.  */\n       array_idx = fold_convert (sizetype, array_idx);\n-      array_idx = int_const_binop (MULT_EXPR, array_idx, elt_size, 0);\n+      array_idx = int_const_binop (MULT_EXPR, array_idx, elt_size);\n \n       /* Update the operands for the next round, or for folding.  */\n       op1 = int_const_binop (PLUS_EXPR,\n-\t\t\t     array_idx, op1, 0);\n+\t\t\t     array_idx, op1);\n       op0 = array_obj;\n     }\n "}, {"sha": "3026197d13d819e45e75eaf7085e9fa851b4cdda", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -2465,7 +2465,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \t\t\t\t       base_offset\n \t\t\t\t       + adj->offset / BITS_PER_UNIT);\n \t\t  off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1),\n-\t\t\t\t\t off, 0);\n+\t\t\t\t\t off);\n \t\t  base = TREE_OPERAND (base, 0);\n \t\t}\n \t      else"}, {"sha": "37865a75d6b66ea34b90088be21e8a16fdfe3af1", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1950,9 +1950,9 @@ layout_type (tree type)\n         TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n \tTYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n \t\t\t\t\t         TYPE_SIZE_UNIT (innertype),\n-\t\t\t\t\t         size_int (nunits), 0);\n+\t\t\t\t\t         size_int (nunits));\n \tTYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),\n-\t\t\t\t\t    bitsize_int (nunits), 0);\n+\t\t\t\t\t    bitsize_int (nunits));\n \n \t/* Always naturally align vectors.  This prevents ABI changes\n \t   depending on whether or not native vector modes are supported.  */"}, {"sha": "e1f8707e809cb6bd8ab714949c871ac6bc1e640f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1358,13 +1358,14 @@ group_case_labels_stmt (gimple stmt)\n \t{\n \t  tree merge_case = gimple_switch_label (stmt, i);\n \t  tree merge_label = CASE_LABEL (merge_case);\n-\t  tree t = int_const_binop (PLUS_EXPR, base_high,\n-\t\t\t\t    integer_one_node, 1);\n+\t  double_int bhp1 = double_int_add (tree_to_double_int (base_high),\n+\t\t\t\t\t    double_int_one);\n \n \t  /* Merge the cases if they jump to the same place,\n \t     and their ranges are consecutive.  */\n \t  if (merge_label == base_label\n-\t      && tree_int_cst_equal (CASE_LOW (merge_case), t))\n+\t      && double_int_equal_p (tree_to_double_int (CASE_LOW (merge_case)),\n+\t\t\t\t     bhp1))\n \t    {\n \t      base_high = CASE_HIGH (merge_case) ?\n \t\t  CASE_HIGH (merge_case) : CASE_LOW (merge_case);"}, {"sha": "d2d469fea661137f7ef51e748ec4f73375ebbad4", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -123,7 +123,7 @@ tree_fold_divides_p (const_tree a, const_tree b)\n {\n   gcc_assert (TREE_CODE (a) == INTEGER_CST);\n   gcc_assert (TREE_CODE (b) == INTEGER_CST);\n-  return integer_zerop (int_const_binop (TRUNC_MOD_EXPR, b, a, 0));\n+  return integer_zerop (int_const_binop (TRUNC_MOD_EXPR, b, a));\n }\n \n /* Returns true iff A divides B.  */"}, {"sha": "3183b935af3bf9bee7768347e7263afc323fdf9d", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1395,7 +1395,7 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n     {\n       off = build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)),\n \t\t\t   base_offset + offset / BITS_PER_UNIT);\n-      off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1), off, 0);\n+      off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1), off);\n       base = unshare_expr (TREE_OPERAND (base, 0));\n     }\n   else\n@@ -1505,7 +1505,7 @@ build_user_friendly_ref_for_offset (tree *res, tree type, HOST_WIDE_INT offset,\n \t    return false;\n \t  index = build_int_cst (TYPE_DOMAIN (type), offset / el_size);\n \t  if (!integer_zerop (minidx))\n-\t    index = int_const_binop (PLUS_EXPR, index, minidx, 0);\n+\t    index = int_const_binop (PLUS_EXPR, index, minidx);\n \t  *res = build4 (ARRAY_REF, TREE_TYPE (type), *res, index,\n \t\t\t NULL_TREE, NULL_TREE);\n \t  offset = offset % el_size;"}, {"sha": "07d1d4db43b6295b6ca0deed4fe272df3760b9ba", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -877,7 +877,7 @@ maybe_fold_tmr (tree ref)\n \t\t      (get_addr_base_and_unit_offset\n \t\t         (TREE_OPERAND (addr.symbol, 0), &offset));\n       addr.offset = int_const_binop (PLUS_EXPR,\n-\t\t\t\t     addr.offset, size_int (offset), 0);\n+\t\t\t\t     addr.offset, size_int (offset));\n       changed = true;\n     }\n "}, {"sha": "7990c5b55983f49a2c2fd7613b1aaf89145208cd", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -885,7 +885,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n \t      new_base = TREE_OPERAND (*def_rhs_basep, 0);\n \t      new_offset\n \t\t= int_const_binop (PLUS_EXPR, TREE_OPERAND (lhs, 1),\n-\t\t\t\t   TREE_OPERAND (*def_rhs_basep, 1), 0);\n+\t\t\t\t   TREE_OPERAND (*def_rhs_basep, 1));\n \t    }\n \t  else\n \t    {\n@@ -964,7 +964,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n \t      new_base = TREE_OPERAND (*def_rhs_basep, 0);\n \t      new_offset\n \t\t= int_const_binop (PLUS_EXPR, TREE_OPERAND (rhs, 1),\n-\t\t\t\t   TREE_OPERAND (*def_rhs_basep, 1), 0);\n+\t\t\t\t   TREE_OPERAND (*def_rhs_basep, 1));\n \t    }\n \t  else\n \t    {"}, {"sha": "2ec2e0ce5104c049c2fb25317600ccd9b92baaf6", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -525,10 +525,10 @@ inverse (tree x, tree mask)\n       rslt = build_int_cst (type, 1);\n       for (; ctr; ctr--)\n \t{\n-\t  rslt = int_const_binop (MULT_EXPR, rslt, x, 0);\n-\t  x = int_const_binop (MULT_EXPR, x, x, 0);\n+\t  rslt = int_const_binop (MULT_EXPR, rslt, x);\n+\t  x = int_const_binop (MULT_EXPR, x, x);\n \t}\n-      rslt = int_const_binop (BIT_AND_EXPR, rslt, mask, 0);\n+      rslt = int_const_binop (BIT_AND_EXPR, rslt, mask);\n     }\n \n   return rslt;"}, {"sha": "27e84c22c5c7915b83234b2d5e90cf5896377653", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -2771,7 +2771,7 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t    gcc_assert (base);\n \t    offset = int_const_binop (PLUS_EXPR, offset,\n \t\t\t\t      build_int_cst (TREE_TYPE (offset),\n-\t\t\t\t\t\t     off), 0);\n+\t\t\t\t\t\t     off));\n \t    baseop = build_fold_addr_expr (base);\n \t  }\n \treturn fold_build2 (MEM_REF, currop->type, baseop, offset);"}, {"sha": "fe8a74c59cf01074eda5e4cd6679f5a35a106175", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -1855,7 +1855,7 @@ maybe_rewrite_mem_ref_base (tree *tp)\n \t\t\tTYPE_SIZE (TREE_TYPE (*tp)),\n \t\t\tint_const_binop (MULT_EXPR,\n \t\t\t\t\t bitsize_int (BITS_PER_UNIT),\n-\t\t\t\t\t TREE_OPERAND (*tp, 1), 0));\n+\t\t\t\t\t TREE_OPERAND (*tp, 1)));\n \t}\n       else if (TREE_CODE (TREE_TYPE (sym)) == COMPLEX_TYPE\n \t       && useless_type_conversion_p (TREE_TYPE (*tp),"}, {"sha": "c7a6f817ea5f6a6637d79e289c7a6b007222d988", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -194,7 +194,7 @@ check_range (gimple swtch)\n   gcc_assert (info.range_min);\n   gcc_assert (range_max);\n \n-  info.range_size = int_const_binop (MINUS_EXPR, range_max, info.range_min, 0);\n+  info.range_size = int_const_binop (MINUS_EXPR, range_max, info.range_min);\n \n   gcc_assert (info.range_size);\n   if (!host_integerp (info.range_size, 1))\n@@ -441,11 +441,11 @@ build_constructors (gimple swtch)\n \t      elt = VEC_quick_push (constructor_elt,\n \t\t\t\t    info.constructors[k], NULL);\n \t      elt->index = int_const_binop (MINUS_EXPR, pos,\n-\t\t\t\t\t    info.range_min, 0);\n+\t\t\t\t\t    info.range_min);\n \t      elt->value = info.default_values[k];\n \t    }\n \n-\t  pos = int_const_binop (PLUS_EXPR, pos, integer_one_node, 0);\n+\t  pos = int_const_binop (PLUS_EXPR, pos, integer_one_node);\n \t}\n       gcc_assert (tree_int_cst_equal (pos, CASE_LOW (cs)));\n \n@@ -468,10 +468,10 @@ build_constructors (gimple swtch)\n \n \t      elt = VEC_quick_push (constructor_elt,\n \t\t\t\t    info.constructors[j], NULL);\n-\t      elt->index = int_const_binop (MINUS_EXPR, pos, info.range_min, 0);\n+\t      elt->index = int_const_binop (MINUS_EXPR, pos, info.range_min);\n \t      elt->value = val;\n \n-\t      pos = int_const_binop (PLUS_EXPR, pos, integer_one_node, 0);\n+\t      pos = int_const_binop (PLUS_EXPR, pos, integer_one_node);\n \t    } while (!tree_int_cst_lt (high, pos)\n \t\t     && tree_int_cst_lt (low, pos));\n \t  j++;"}, {"sha": "41e21b4dd05aadf1eae9c85dffd24dc2184e240c", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -209,7 +209,7 @@ expand_vector_piecewise (gimple_stmt_iterator *gsi, elem_op_func f,\n \n   v = VEC_alloc(constructor_elt, gc, (nunits + delta - 1) / delta);\n   for (i = 0; i < nunits;\n-       i += delta, index = int_const_binop (PLUS_EXPR, index, part_width, 0))\n+       i += delta, index = int_const_binop (PLUS_EXPR, index, part_width))\n     {\n       tree result = f (gsi, inner_type, a, b, index, part_width, code);\n       constructor_elt *ce = VEC_quick_push (constructor_elt, v, NULL);"}, {"sha": "d940336b40df41cea832972511bf0bdbed986566", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -472,8 +472,8 @@ set_and_canonicalize_value_range (value_range_t *vr, enum value_range_type t,\n   if (tree_int_cst_lt (max, min))\n     {\n       tree one = build_int_cst (TREE_TYPE (min), 1);\n-      tree tmp = int_const_binop (PLUS_EXPR, max, one, 0);\n-      max = int_const_binop (MINUS_EXPR, min, one, 0);\n+      tree tmp = int_const_binop (PLUS_EXPR, max, one);\n+      max = int_const_binop (MINUS_EXPR, min, one);\n       min = tmp;\n \n       /* There's one corner case, if we had [C+1, C] before we now have\n@@ -506,14 +506,14 @@ set_and_canonicalize_value_range (value_range_t *vr, enum value_range_type t,\n \t\t    && integer_zerop (max)))\n         {\n \t  tree one = build_int_cst (TREE_TYPE (max), 1);\n-\t  min = int_const_binop (PLUS_EXPR, max, one, 0);\n+\t  min = int_const_binop (PLUS_EXPR, max, one);\n \t  max = vrp_val_max (TREE_TYPE (max));\n \t  t = VR_RANGE;\n         }\n       else if (is_max)\n         {\n \t  tree one = build_int_cst (TREE_TYPE (min), 1);\n-\t  max = int_const_binop (MINUS_EXPR, min, one, 0);\n+\t  max = int_const_binop (MINUS_EXPR, min, one);\n \t  min = vrp_val_min (TREE_TYPE (min));\n \t  t = VR_RANGE;\n         }\n@@ -1526,7 +1526,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n         {\n           min = fold_build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (cond, 1)),\n \t\t\t     TREE_OPERAND (cond, 1));\n-          max = int_const_binop (PLUS_EXPR, limit, min, 0);\n+          max = int_const_binop (PLUS_EXPR, limit, min);\n \t  cond = TREE_OPERAND (cond, 0);\n \t}\n       else\n@@ -1954,7 +1954,7 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n {\n   tree res;\n \n-  res = int_const_binop (code, val1, val2, 0);\n+  res = int_const_binop (code, val1, val2);\n \n   /* If we are using unsigned arithmetic, operate symbolically\n      on -INF and +INF as int_const_binop only handles signed overflow.  */\n@@ -1981,7 +1981,7 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n \t{\n \t  tree tmp = int_const_binop (TRUNC_DIV_EXPR,\n \t\t\t\t      res,\n-\t\t\t\t      val1, 0);\n+\t\t\t\t      val1);\n \t  int check = compare_values (tmp, val2);\n \n \t  if (check != 0)\n@@ -2636,7 +2636,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n       max = fold_unary_to_constant (ABS_EXPR, TREE_TYPE (vr1.min), vr1.min);\n       if (tree_int_cst_lt (max, vr1.max))\n \tmax = vr1.max;\n-      max = int_const_binop (MINUS_EXPR, max, integer_one_node, 0);\n+      max = int_const_binop (MINUS_EXPR, max, integer_one_node);\n       /* If the dividend is non-negative the modulus will be\n \t non-negative as well.  */\n       if (TYPE_UNSIGNED (TREE_TYPE (max))\n@@ -2681,7 +2681,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n \n       type = VR_RANGE;\n       if (vr0_int_cst_singleton_p && vr1_int_cst_singleton_p)\n-\tmin = max = int_const_binop (code, vr0.max, vr1.max, 0);\n+\tmin = max = int_const_binop (code, vr0.max, vr1.max);\n       else if (!int_cst_range0 && !int_cst_range1)\n \t{\n \t  set_value_range_to_varying (vr);\n@@ -2905,8 +2905,8 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n \t  && (TYPE_PRECISION (outer_type) >= TYPE_PRECISION (inner_type)\n \t      || (vr0.type == VR_RANGE\n \t\t  && integer_zerop (int_const_binop (RSHIFT_EXPR,\n-\t\t       int_const_binop (MINUS_EXPR, vr0.max, vr0.min, 0),\n-\t\t         size_int (TYPE_PRECISION (outer_type)), 0)))))\n+\t\t       int_const_binop (MINUS_EXPR, vr0.max, vr0.min),\n+\t\t         size_int (TYPE_PRECISION (outer_type)))))))\n \t{\n \t  tree new_min, new_max;\n \t  new_min = force_fit_type_double (outer_type,\n@@ -3073,7 +3073,7 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n \n \t\t  min = (vr0.min != type_min_value\n \t\t\t ? int_const_binop (PLUS_EXPR, type_min_value,\n-\t\t\t\t\t    integer_one_node, 0)\n+\t\t\t\t\t    integer_one_node)\n \t\t\t : type_min_value);\n \t\t}\n \t      else\n@@ -5248,7 +5248,7 @@ check_array_ref (location_t location, tree ref, bool ignore_off_by_one)\n     }\n \n   low_bound = array_ref_low_bound (ref);\n-  up_bound_p1 = int_const_binop (PLUS_EXPR, up_bound, integer_one_node, 0);\n+  up_bound_p1 = int_const_binop (PLUS_EXPR, up_bound, integer_one_node);\n \n   if (TREE_CODE (low_sub) == SSA_NAME)\n     {\n@@ -6260,7 +6260,7 @@ find_case_label_range (gimple stmt, tree min, tree max, size_t *min_idx,\n       for (k = i + 1; k <= j; ++k)\n \t{\n \t  low = CASE_LOW (gimple_switch_label (stmt, k));\n-\t  if (!integer_onep (int_const_binop (MINUS_EXPR, low, high, 0)))\n+\t  if (!integer_onep (int_const_binop (MINUS_EXPR, low, high)))\n \t    {\n \t      take_default = true;\n \t      break;\n@@ -6917,7 +6917,7 @@ simplify_div_or_mod_using_ranges (gimple stmt)\n       else\n \t{\n \t  t = build_int_cst (TREE_TYPE (op1), 1);\n-\t  t = int_const_binop (MINUS_EXPR, op1, t, 0);\n+\t  t = int_const_binop (MINUS_EXPR, op1, t);\n \t  t = fold_convert (TREE_TYPE (op0), t);\n \n \t  gimple_assign_set_rhs_code (stmt, BIT_AND_EXPR);"}, {"sha": "9b4c8308e2c329e2f748bf9e07a3ea264923400f", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d35936ab70051f5bb7e3e7b9d069cc648f5dac6c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d35936ab70051f5bb7e3e7b9d069cc648f5dac6c", "patch": "@@ -5142,7 +5142,7 @@ extern tree fold_truth_not_expr (location_t, tree);\n extern tree fold_unary_to_constant (enum tree_code, tree, tree);\n extern tree fold_binary_to_constant (enum tree_code, tree, tree, tree);\n extern tree fold_read_from_constant_string (tree);\n-extern tree int_const_binop (enum tree_code, const_tree, const_tree, int);\n+extern tree int_const_binop (enum tree_code, const_tree, const_tree);\n #define build_fold_addr_expr(T)\\\n         build_fold_addr_expr_loc (UNKNOWN_LOCATION, (T))\n extern tree build_fold_addr_expr_loc (location_t, tree);"}]}