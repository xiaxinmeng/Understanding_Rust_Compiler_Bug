{"sha": "848eed924951d98a61ad8ad98f24e871e0485cec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4ZWVkOTI0OTUxZDk4YTYxYWQ4YWQ5OGYyNGU4NzFlMDQ4NWNlYw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2002-12-29T14:53:05Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-12-29T14:53:05Z"}, "message": "Remove traditional C constructs 4/n.\n\n\t* decl2.c (grok_method_quals, warn_if_unknown_interface,\n\tgrok_x_components, cp_build_parm_decl, build_artificial_parm,\n\tmaybe_retrofit_in_chrg, grokclassfn, grok_array_decl,\n\tdelete_sanity, check_member_template, check_java_method,\n\tcheck_classfn, finish_static_data_member_decl, grokfield,\n\tgrokbitfield, grokoptypename, grok_function_init,\n\tcplus_decl_attributes, constructor_name, defer_fn,\n\tbuild_anon_union_vars, finish_anon_union, coerce_new_type,\n\tcoerce_delete_type, comdat_linkage, maybe_make_one_only,\n\tkey_method, import_export_vtable, import_export_class,\n\toutput_vtable_inherit, import_export_decl, import_export_tinfo,\n\tbuild_cleanup, get_guard, get_guard_bits, get_guard_cond,\n\tset_guard, start_objects, finish_objects,\n\tstart_static_storage_duration_function,\n\tfinish_static_storage_duration_function, get_priority_info,\n\tstart_static_initialization_or_destruction,\n\tfinish_static_initialization_or_destruction,\n\tdo_static_initialization, do_static_destruction,\n\tprune_vars_needing_no_initialization, write_out_vars,\n\treparse_decl_as_expr, finish_decl_parsing, namespace_ancestor,\n\tadd_using_namespace, merge_functions, ambiguous_decl,\n\tlookup_using_namespace, lookup_using_namespace,\n\tqualified_lookup_using_namespace, set_decl_namespace,\n\tdecl_namespace, current_decl_namespace, push_decl_namespace,\n\tpop_decl_namespace, push_scope, pop_scope, add_function,\n\targ_assoc_namespace, arg_assoc_template_arg, arg_assoc,\n\tlookup_arg_dependent, do_namespace_alias,\n\tvalidate_nonmember_using_decl, do_nonmember_using_decl,\n\tdo_toplevel_using_decl, do_local_using_decl,\n\tdo_class_using_decl, do_using_directive, check_default_args,\n\tmark_used, handle_class_head): Use C90 prototypings.  Use booleans.\n\t* parser.c (cp_parser_class_head): Use booleanss.\n\t* decl.c (walk_globals, walk_vtables): Likewise.\n\t* cp-tree.h (walk_globals_pred, walk_globals_fn, walk_vtables,\n\twalk_globals): Change return type from 'int' to 'bool'.\n\t* rtti.c (init_rtti_processing, build_headof, throw_bad_cast\n\tthrow_bad_typeid, get_tinfo_decl_dynamic, typeid_ok_p,\n\tbuild_typeid, tinfo_name, get_tinfo_decl, get_tinfo_ptr,\n\tget_typeid, ifnonnull, build_dynamic_cast_1, build_dynamic_cast,\n\tqualifier_flags, tinfo_base_init, generic_initializer,\n\tptr_initializer, dfs_class_hint_mark, ptm_initializer,\n\tdfs_class_hint_unmark, class_hint_flags, class_initializer,\n\ttypeinfo_in_lib_p, get_pseudo_ti_init, create_pseudo_type_info,\n\tget_pseudo_ti_desc, create_tinfo_types, emit_support_tinfos,\n\tunemitted_tinfo_decl_p, emit_tinfo_decl): Likewise.\n\t* repo.c (repo_compile_flags, repo_template_declared,\n\trepo_template_defined, repo_class_defined, repo_get_id,\n\trepo_template_used, repo_vtable_used, repo_inline_used,\n\trepo_tinfo_used, repo_template_instantiated, extract_string,\n\topen_repo_file, afgets, init_repo, reopen_repo_file_for_write,\n\tfinish_repo): Likewise.\n\t* ptree.c (cxx_print_decl, cxx_print_type, cxx_print_identifier,\n\tcxx_print_xnode): Likewise..\n\t* cp-lang.c (ok_to_generate_alias_set_for_type, cxx_get_alias_set,\n\tcxx_warn_unused_global_decl, cp_expr_size): Likewise.\n\t* cxxfilt.c (demangle_it, print_demangler_list, usage,\n\tstandard_symbol_characters, hp_symbol_characters, main, fatal):\n\tLikewise.\n\t(strip_underscore):  Change type from 'int' to 'bool'.\n\t(main): Use boolean constants.\n\nFrom-SVN: r60601", "tree": {"sha": "ae76e7c8c3d469c1d1902136e9f7aeb0a5261651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae76e7c8c3d469c1d1902136e9f7aeb0a5261651"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848eed924951d98a61ad8ad98f24e871e0485cec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848eed924951d98a61ad8ad98f24e871e0485cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848eed924951d98a61ad8ad98f24e871e0485cec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848eed924951d98a61ad8ad98f24e871e0485cec/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2873836bd934145499b517508acf2efb0e0857f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2873836bd934145499b517508acf2efb0e0857f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2873836bd934145499b517508acf2efb0e0857f9"}], "stats": {"total": 1111, "additions": 479, "deletions": 632}, "files": [{"sha": "920c6cb6d4c17a625836485085fe5c54c624282e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -1,3 +1,67 @@\n+2002-12-28  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tRemove traditional C constructs 4/n.\n+\t* decl2.c (grok_method_quals, warn_if_unknown_interface,\n+\tgrok_x_components, cp_build_parm_decl, build_artificial_parm,\n+\tmaybe_retrofit_in_chrg, grokclassfn, grok_array_decl,\n+\tdelete_sanity, check_member_template, check_java_method,\n+\tcheck_classfn, finish_static_data_member_decl, grokfield,\n+\tgrokbitfield, grokoptypename, grok_function_init,\n+\tcplus_decl_attributes, constructor_name, defer_fn,\n+\tbuild_anon_union_vars, finish_anon_union, coerce_new_type,\n+\tcoerce_delete_type, comdat_linkage, maybe_make_one_only,\n+\tkey_method, import_export_vtable, import_export_class,\n+\toutput_vtable_inherit, import_export_decl, import_export_tinfo,\n+\tbuild_cleanup, get_guard, get_guard_bits, get_guard_cond,\n+\tset_guard, start_objects, finish_objects,\n+\tstart_static_storage_duration_function,\n+\tfinish_static_storage_duration_function, get_priority_info,\n+\tstart_static_initialization_or_destruction,\n+\tfinish_static_initialization_or_destruction,\n+\tdo_static_initialization, do_static_destruction,\n+\tprune_vars_needing_no_initialization, write_out_vars,\n+\treparse_decl_as_expr, finish_decl_parsing, namespace_ancestor,\n+\tadd_using_namespace, merge_functions, ambiguous_decl,\n+\tlookup_using_namespace, lookup_using_namespace,\n+\tqualified_lookup_using_namespace, set_decl_namespace,\n+\tdecl_namespace, current_decl_namespace, push_decl_namespace,\n+\tpop_decl_namespace, push_scope, pop_scope, add_function,\n+\targ_assoc_namespace, arg_assoc_template_arg, arg_assoc,\n+\tlookup_arg_dependent, do_namespace_alias,\n+\tvalidate_nonmember_using_decl, do_nonmember_using_decl,\n+\tdo_toplevel_using_decl, do_local_using_decl,\n+\tdo_class_using_decl, do_using_directive, check_default_args,\n+\tmark_used, handle_class_head): Use C90 prototypings.  Use booleans.\n+\t* parser.c (cp_parser_class_head): Use booleanss.\n+\t* decl.c (walk_globals, walk_vtables): Likewise.\n+\t* cp-tree.h (walk_globals_pred, walk_globals_fn, walk_vtables,\n+\twalk_globals): Change return type from 'int' to 'bool'.\n+\t* rtti.c (init_rtti_processing, build_headof, throw_bad_cast\n+\tthrow_bad_typeid, get_tinfo_decl_dynamic, typeid_ok_p,\n+\tbuild_typeid, tinfo_name, get_tinfo_decl, get_tinfo_ptr,\n+\tget_typeid, ifnonnull, build_dynamic_cast_1, build_dynamic_cast,\n+\tqualifier_flags, tinfo_base_init, generic_initializer,\n+\tptr_initializer, dfs_class_hint_mark, ptm_initializer,\n+\tdfs_class_hint_unmark, class_hint_flags, class_initializer,\n+\ttypeinfo_in_lib_p, get_pseudo_ti_init, create_pseudo_type_info,\n+\tget_pseudo_ti_desc, create_tinfo_types, emit_support_tinfos,\n+\tunemitted_tinfo_decl_p, emit_tinfo_decl): Likewise.\n+\t* repo.c (repo_compile_flags, repo_template_declared,\n+\trepo_template_defined, repo_class_defined, repo_get_id,\n+\trepo_template_used, repo_vtable_used, repo_inline_used,\n+\trepo_tinfo_used, repo_template_instantiated, extract_string,\n+\topen_repo_file, afgets, init_repo, reopen_repo_file_for_write,\n+\tfinish_repo): Likewise.\n+\t* ptree.c (cxx_print_decl, cxx_print_type, cxx_print_identifier,\n+\tcxx_print_xnode): Likewise..\n+\t* cp-lang.c (ok_to_generate_alias_set_for_type, cxx_get_alias_set,\n+\tcxx_warn_unused_global_decl, cp_expr_size): Likewise.\n+\t* cxxfilt.c (demangle_it, print_demangler_list, usage,\n+\tstandard_symbol_characters, hp_symbol_characters, main, fatal):\n+\tLikewise. \n+\t(strip_underscore):  Change type from 'int' to 'bool'.\n+\t(main): Use boolean constants.\n+\n 2002-12-28  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tRemove traditional C constructs 3/n."}, {"sha": "8fe7c580029b4efdc8856f6b1d22dc806b8bfefa", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -30,11 +30,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n \n-static HOST_WIDE_INT cxx_get_alias_set PARAMS ((tree));\n-static bool ok_to_generate_alias_set_for_type PARAMS ((tree));\n-static bool cxx_warn_unused_global_decl PARAMS ((tree));\n-static tree cp_expr_size PARAMS ((tree));\n-static bool cp_var_mod_type_p PARAMS ((tree));\n+static HOST_WIDE_INT cxx_get_alias_set (tree);\n+static bool ok_to_generate_alias_set_for_type (tree);\n+static bool cxx_warn_unused_global_decl (tree);\n+static tree cp_expr_size (tree);\n+static bool cp_var_mod_type_p (tree);\n \n #undef LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME \"GNU C++\"\n@@ -204,8 +204,7 @@ const char *const tree_code_name[] = {\n    Return TRUE if T safe for aliasing FALSE otherwise.  */\n \n static bool\n-ok_to_generate_alias_set_for_type (t)\n-     tree t;\n+ok_to_generate_alias_set_for_type (tree t)\n {\n   if (TYPE_PTRMEMFUNC_P (t))\n     return true;\n@@ -258,8 +257,7 @@ ok_to_generate_alias_set_for_type (t)\n /* Special routine to get the alias set for C++.  */\n \n static HOST_WIDE_INT\n-cxx_get_alias_set (t)\n-     tree t;\n+cxx_get_alias_set (tree t)\n {\n   /* It's not yet safe to use alias sets for classes in C++.  */\n   if (!ok_to_generate_alias_set_for_type(t))\n@@ -271,8 +269,7 @@ cxx_get_alias_set (t)\n /* Called from check_global_declarations.  */\n \n static bool\n-cxx_warn_unused_global_decl (decl)\n-     tree decl;\n+cxx_warn_unused_global_decl (tree decl)\n {\n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl))\n     return false;\n@@ -291,8 +288,7 @@ cxx_warn_unused_global_decl (decl)\n    might have allocated something there.  */\n \n static tree\n-cp_expr_size (exp)\n-     tree exp;\n+cp_expr_size (tree exp)\n {\n   if (CLASS_TYPE_P (TREE_TYPE (exp)))\n     {"}, {"sha": "c224e2a4f77b4d9031a39555f31fede8749f75f5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -3620,10 +3620,10 @@ extern void pop_lang_context\t\t\tPARAMS ((void));\n extern tree instantiate_type\t\t\tPARAMS ((tree, tree, tsubst_flags_t));\n extern void print_class_statistics              PARAMS ((void));\n extern void cxx_print_statistics\t\tPARAMS ((void));\n-extern void cxx_print_xnode\t\t\tPARAMS ((FILE *, tree, int));\n-extern void cxx_print_decl\t\t\tPARAMS ((FILE *, tree, int));\n-extern void cxx_print_type\t\t\tPARAMS ((FILE *, tree, int));\n-extern void cxx_print_identifier\t\tPARAMS ((FILE *, tree, int));\n+extern void cxx_print_xnode (FILE *, tree, int);\n+extern void cxx_print_decl (FILE *, tree, int);\n+extern void cxx_print_type (FILE *, tree, int);\n+extern void cxx_print_identifier (FILE *, tree, int);\n extern void cxx_print_error_function\tPARAMS ((struct diagnostic_context *,\n \t\t\t\t\t\t const char *));\n extern void build_self_reference\t\tPARAMS ((void));\n@@ -3738,8 +3738,8 @@ extern void end_only_namespace_names            PARAMS ((void));\n extern tree namespace_ancestor\t\t\tPARAMS ((tree, tree));\n extern tree unqualified_namespace_lookup\tPARAMS ((tree, int, tree *));\n extern tree check_for_out_of_scope_variable     (tree);\n-extern int  lookup_using_namespace              PARAMS ((tree, tree, tree, tree, int, tree *));\n-extern int  qualified_lookup_using_namespace    PARAMS ((tree, tree, tree, int));\n+extern bool lookup_using_namespace (tree, tree, tree, tree, int, tree *);\n+extern bool qualified_lookup_using_namespace (tree, tree, tree, int);\n extern tree build_library_fn\t\t\tPARAMS ((tree, tree));\n extern tree build_library_fn_ptr\t\tPARAMS ((const char *, tree));\n extern tree build_cp_library_fn_ptr\t\tPARAMS ((const char *, tree));\n@@ -3795,14 +3795,10 @@ extern void storetags                           PARAMS ((tree));\n extern int vtable_decl_p                        PARAMS ((tree, void *));\n extern int vtype_decl_p                         PARAMS ((tree, void *));\n extern int sigtable_decl_p                      PARAMS ((tree, void *));\n-typedef int (*walk_globals_pred)                PARAMS ((tree, void *));\n-typedef int (*walk_globals_fn)                  PARAMS ((tree *, void *));\n-extern int walk_globals                         PARAMS ((walk_globals_pred,\n-\t\t\t\t\t\t       walk_globals_fn,\n-\t\t\t\t\t\t       void *));\n-extern int walk_vtables                         PARAMS ((walk_globals_pred, \n-                                                       walk_globals_fn, \n-\t\t\t\t\t\t       void *));\n+typedef bool (*walk_globals_pred) (tree, void *);\n+typedef bool (*walk_globals_fn) (tree *, void *);\n+extern bool walk_globals (walk_globals_pred, walk_globals_fn, void *);\n+extern bool walk_vtables (walk_globals_pred, walk_globals_fn, void *);\n typedef int (*walk_namespaces_fn)               PARAMS ((tree, void *));\n extern int walk_namespaces                      PARAMS ((walk_namespaces_fn,\n \t\t\t\t\t\t       void *));\n@@ -3820,64 +3816,64 @@ extern tree cp_fname_init\t\t\tPARAMS ((const char *));\n extern bool have_extern_spec;\n \n /* in decl2.c */\n-extern int check_java_method\t\t\tPARAMS ((tree));\n-extern int grok_method_quals\t\t\tPARAMS ((tree, tree, tree));\n-extern void warn_if_unknown_interface\t\tPARAMS ((tree));\n-extern void grok_x_components\t\t\tPARAMS ((tree));\n-extern void maybe_retrofit_in_chrg\t\tPARAMS ((tree));\n-extern void maybe_make_one_only\t\t\tPARAMS ((tree));\n-extern void grokclassfn\t\t\t\tPARAMS ((tree, tree, enum overload_flags, tree));\n-extern tree grok_array_decl\t\t\tPARAMS ((tree, tree));\n-extern tree delete_sanity\t\t\tPARAMS ((tree, tree, int, int));\n-extern tree check_classfn\t\t\tPARAMS ((tree, tree));\n-extern void check_member_template               PARAMS ((tree));\n-extern tree grokfield\t\t\t\tPARAMS ((tree, tree, tree, tree, tree));\n-extern tree grokbitfield\t\t\tPARAMS ((tree, tree, tree));\n+extern bool check_java_method (tree);\n+extern int grok_method_quals (tree, tree, tree);\n+extern void warn_if_unknown_interface (tree);\n+extern void grok_x_components (tree);\n+extern void maybe_retrofit_in_chrg (tree);\n+extern void maybe_make_one_only\t(tree);\n+extern void grokclassfn\t(tree, tree, enum overload_flags, tree);\n+extern tree grok_array_decl (tree, tree);\n+extern tree delete_sanity (tree, tree, int, int);\n+extern tree check_classfn (tree, tree);\n+extern void check_member_template (tree);\n+extern tree grokfield (tree, tree, tree, tree, tree);\n+extern tree grokbitfield (tree, tree, tree);\n extern tree groktypefield\t\t\tPARAMS ((tree, tree));\n-extern tree grokoptypename\t\t\tPARAMS ((tree, tree, tree));\n-extern void cplus_decl_attributes\t\tPARAMS ((tree *, tree, int));\n+extern tree grokoptypename (tree, tree, tree);\n+extern void cplus_decl_attributes (tree *, tree, int);\n extern tree constructor_name_full\t\tPARAMS ((tree));\n-extern tree constructor_name\t\t\tPARAMS ((tree));\n+extern tree constructor_name (tree);\n extern bool constructor_name_p                  (tree, tree);\n-extern void defer_fn            \t\tPARAMS ((tree));\n-extern void finish_anon_union\t\t\tPARAMS ((tree));\n-extern tree finish_table\t\t\tPARAMS ((tree, tree, tree, int));\n-extern tree coerce_new_type\t\t\tPARAMS ((tree));\n-extern tree coerce_delete_type\t\t\tPARAMS ((tree));\n-extern void comdat_linkage\t\t\tPARAMS ((tree));\n-extern void import_export_vtable\t\tPARAMS ((tree, tree, int));\n-extern void import_export_decl\t\t\tPARAMS ((tree));\n-extern void import_export_tinfo\t\t\tPARAMS ((tree, tree, int));\n+extern void defer_fn (tree);\n+extern void finish_anon_union (tree);\n+extern tree finish_table (tree, tree, tree, int);\n+extern tree coerce_new_type (tree);\n+extern tree coerce_delete_type (tree);\n+extern void comdat_linkage (tree);\n+extern void import_export_vtable (tree, tree, int);\n+extern void import_export_decl (tree);\n+extern void import_export_tinfo\t(tree, tree, bool);\n extern tree build_cleanup\t\t\tPARAMS ((tree));\n extern void finish_file\t\t\t\tPARAMS ((void));\n extern tree reparse_absdcl_as_expr\t\tPARAMS ((tree, tree));\n extern tree reparse_absdcl_as_casts\t\tPARAMS ((tree, tree));\n extern tree build_expr_from_tree\t\tPARAMS ((tree));\n extern tree build_offset_ref_call_from_tree     (tree, tree);\n extern tree build_call_from_tree                (tree, tree, bool);\n-extern tree reparse_decl_as_expr\t\tPARAMS ((tree, tree));\n-extern tree finish_decl_parsing\t\t\tPARAMS ((tree));\n-extern void set_decl_namespace                  PARAMS ((tree, tree, int));\n+extern tree reparse_decl_as_expr (tree, tree);\n+extern tree finish_decl_parsing (tree);\n+extern void set_decl_namespace (tree, tree, bool);\n extern tree current_decl_namespace              PARAMS ((void));\n extern void push_decl_namespace                 PARAMS ((tree));\n extern void pop_decl_namespace                  PARAMS ((void));\n extern void push_scope\t\t\t\tPARAMS ((tree));\n extern void pop_scope\t\t\t\tPARAMS ((tree));\n-extern void do_namespace_alias\t\t\tPARAMS ((tree, tree));\n-extern void do_toplevel_using_decl\t\tPARAMS ((tree));\n-extern void do_local_using_decl                 PARAMS ((tree));\n-extern tree do_class_using_decl\t\t\tPARAMS ((tree));\n-extern void do_using_directive\t\t\tPARAMS ((tree));\n-extern void check_default_args\t\t\tPARAMS ((tree));\n-extern void mark_used\t\t\t\tPARAMS ((tree));\n-extern tree handle_class_head\t\t\t(enum tag_types, tree, tree, tree, int, int *);\n-extern tree lookup_arg_dependent                PARAMS ((tree, tree, tree));\n-extern void finish_static_data_member_decl      PARAMS ((tree, tree, tree, int));\n-extern tree cp_build_parm_decl                  PARAMS ((tree, tree));\n-extern tree build_artificial_parm               PARAMS ((tree, tree));\n-extern tree get_guard                           PARAMS ((tree));\n-extern tree get_guard_cond                      PARAMS ((tree));\n-extern tree set_guard                           PARAMS ((tree));\n+extern void do_namespace_alias (tree, tree);\n+extern void do_toplevel_using_decl (tree);\n+extern void do_local_using_decl (tree);\n+extern tree do_class_using_decl (tree);\n+extern void do_using_directive (tree);\n+extern void check_default_args (tree);\n+extern void mark_used (tree);\n+extern tree handle_class_head (enum tag_types, tree, tree, tree, bool, bool *);\n+extern tree lookup_arg_dependent (tree, tree, tree);\n+extern void finish_static_data_member_decl (tree, tree, tree, int);\n+extern tree cp_build_parm_decl (tree, tree);\n+extern tree build_artificial_parm (tree, tree);\n+extern tree get_guard (tree);\n+extern tree get_guard_cond (tree);\n+extern tree set_guard (tree);\n \n extern void cp_error_at\t\tPARAMS ((const char *msgid, ...));\n extern void cp_warning_at\tPARAMS ((const char *msgid, ...));\n@@ -4065,20 +4061,20 @@ extern tree maybe_get_template_decl_from_type_decl (tree);\n extern int processing_template_parmlist;\n \n /* in repo.c */\n-extern void repo_template_used\t\t\tPARAMS ((tree));\n-extern void repo_template_instantiated\t\tPARAMS ((tree, int));\n-extern void init_repo\t\t\t\tPARAMS ((const char *));\n-extern void finish_repo\t\t\t\tPARAMS ((void));\n+extern void repo_template_used (tree);\n+extern void repo_template_instantiated (tree, bool);\n+extern void init_repo (const char *);\n+extern void finish_repo (void);\n \n /* in rtti.c */\n-extern void init_rtti_processing\t\tPARAMS((void));\n-extern tree build_typeid\t\t\tPARAMS((tree));\n-extern tree get_tinfo_decl                      PARAMS((tree));\n-extern tree get_typeid\t\t\t\tPARAMS((tree));\n-extern tree build_dynamic_cast\t\t\tPARAMS((tree, tree));\n-extern void emit_support_tinfos                 PARAMS((void));\n-extern int unemitted_tinfo_decl_p    \t        PARAMS((tree, void *));\n-extern int emit_tinfo_decl                      PARAMS((tree *, void *));\n+extern void init_rtti_processing (void);\n+extern tree build_typeid (tree);\n+extern tree get_tinfo_decl (tree);\n+extern tree get_typeid (tree);\n+extern tree build_dynamic_cast (tree, tree);\n+extern void emit_support_tinfos (void);\n+extern bool unemitted_tinfo_decl_p (tree, void *);\n+extern bool emit_tinfo_decl (tree *, void *);\n \n /* in search.c */\n extern tree lookup_base PARAMS ((tree, tree, base_access, base_kind *));"}, {"sha": "289f6adcec0c7b59b5fae3207950374730f31c6b", "filename": "gcc/cp/cxxfilt.c", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fcxxfilt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fcxxfilt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxxfilt.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -33,14 +33,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static const char *program_name;\n static int flags = DMGL_PARAMS | DMGL_ANSI | DMGL_VERBOSE;\n \n-static void demangle_it PARAMS ((char *));\n-static void usage PARAMS ((FILE *, int)) ATTRIBUTE_NORETURN;\n-static void fatal PARAMS ((const char *)) ATTRIBUTE_NORETURN;\n-static void print_demangler_list PARAMS ((FILE *));\n+static void demangle_it (char *);\n+static void usage (FILE *, int) ATTRIBUTE_NORETURN;\n+static void fatal (const char *) ATTRIBUTE_NORETURN;\n+static void print_demangler_list (FILE *);\n \n static void\n-demangle_it (mangled_name)\n-     char *mangled_name;\n+demangle_it (char *mangled_name)\n {\n   char *result;\n \n@@ -58,8 +57,7 @@ demangle_it (mangled_name)\n }\n \n static void \n-print_demangler_list (stream)\n-     FILE *stream;\n+print_demangler_list (FILE *stream)\n {\n   const struct demangler_engine *demangler; \n \n@@ -74,9 +72,7 @@ print_demangler_list (stream)\n }\n \n static void\n-usage (stream, status)\n-     FILE *stream;\n-     int status;\n+usage (FILE *stream, int status)\n {\n   fprintf (stream, \"\\\n Usage: %s [-_] [-n] [--strip-underscores] [--no-strip-underscores] \\n\",\n@@ -100,7 +96,7 @@ Usage: %s [-_] [-n] [--strip-underscores] [--no-strip-underscores] \\n\",\n #define MBUF_SIZE 32767\n char mbuffer[MBUF_SIZE];\n \n-int strip_underscore = 0;\n+bool strip_underscore = false;\n \n static const struct option long_options[] = {\n   {\"strip-underscores\", no_argument, 0, '_'},\n@@ -111,18 +107,16 @@ static const struct option long_options[] = {\n   {0, no_argument, 0, 0}\n };\n \n-static const char *\n-standard_symbol_characters PARAMS ((void));\n+static const char *standard_symbol_characters (void);\n \n-static const char *\n-hp_symbol_characters PARAMS ((void));\n+static const char *hp_symbol_characters (void);\n \n /* Return the string of non-alnum characters that may occur \n    as a valid symbol component, in the standard assembler symbol\n    syntax.  */\n \n static const char *\n-standard_symbol_characters ()\n+standard_symbol_characters (void)\n {\n   return \"_$.\";\n }\n@@ -159,17 +153,15 @@ standard_symbol_characters ()\n \n    So have fun.  */\n static const char *\n-hp_symbol_characters ()\n+hp_symbol_characters (void)\n {\n   return \"_$.<>#,*&[]:(){}\";\n }\n \n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   char *result;\n   int c;\n@@ -190,14 +182,14 @@ main (argc, argv)\n \tcase 'h':\n \t  usage (stdout, 0);\n \tcase 'n':\n-\t  strip_underscore = 0;\n+\t  strip_underscore = false;\n \t  break;\n \tcase 'v':\n \t  printf (\"GNU %s (C++ demangler), version %s\\n\",\n \t\t  program_name, version_string);\n \t  return (0);\n \tcase '_':\n-\t  strip_underscore = 1;\n+\t  strip_underscore = true;\n \t  break;\n \tcase 's':\n \t  {\n@@ -296,8 +288,7 @@ main (argc, argv)\n }\n \n static void\n-fatal (str)\n-     const char *str;\n+fatal (const char *str)\n {\n   fprintf (stderr, \"%s: %s\\n\", program_name, str);\n   exit (1);"}, {"sha": "97593e7abe30c1b2ad02fa043a092a498ae0d709", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -1805,11 +1805,8 @@ walk_vtables_r (namespace, data)\n /* Walk the vtable declarations.  Whenever one is found for which P\n    returns nonzero, call F with its address.  If any call to F\n    returns a nonzero value, return a nonzero value.  */\n-int\n-walk_vtables (p, f, data)\n-     walk_globals_pred p;\n-     walk_globals_fn f;\n-     void *data;\n+bool\n+walk_vtables (walk_globals_pred p, walk_globals_fn f, void *data)\n {    \n   struct walk_globals_data wgd;\n   wgd.p = p;    \n@@ -1885,14 +1882,11 @@ walk_globals_r (namespace, data)\n }\n \n /* Walk the global declarations.  Whenever one is found for which P\n-   returns nonzero, call F with its address.  If any call to F\n-   returns a nonzero value, return a nonzero value.  */\n+   returns true, call F with its address.  If any call to F\n+   returns true, return true.  */\n \n-int\n-walk_globals (p, f, data)\n-     walk_globals_pred p;\n-     walk_globals_fn f;\n-     void *data;\n+bool\n+walk_globals (walk_globals_pred p, walk_globals_fn f, void *data)\n {\n   struct walk_globals_data wgd;\n   wgd.p = p;"}, {"sha": "70a9b47ce4c0b9101ce39df884498f968bb05bad", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 217, "deletions": 343, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -60,37 +60,36 @@ typedef struct priority_info_s {\n   int destructions_p;\n } *priority_info;\n \n-static void mark_vtable_entries PARAMS ((tree));\n-static void grok_function_init PARAMS ((tree, tree));\n-static int maybe_emit_vtables (tree);\n-static int is_namespace_ancestor PARAMS ((tree, tree));\n-static void add_using_namespace PARAMS ((tree, tree, int));\n-static tree ambiguous_decl PARAMS ((tree, tree, tree,int));\n-static tree build_anon_union_vars PARAMS ((tree));\n-static int acceptable_java_type PARAMS ((tree));\n-static void output_vtable_inherit PARAMS ((tree));\n-static tree start_objects PARAMS ((int, int));\n-static void finish_objects PARAMS ((int, int, tree));\n-static tree merge_functions PARAMS ((tree, tree));\n-static tree decl_namespace PARAMS ((tree));\n-static tree validate_nonmember_using_decl PARAMS ((tree, tree *, tree *));\n-static void do_nonmember_using_decl PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t   tree *, tree *));\n-static tree start_static_storage_duration_function PARAMS ((void));\n-static void finish_static_storage_duration_function PARAMS ((tree));\n-static priority_info get_priority_info PARAMS ((int));\n-static void do_static_initialization PARAMS ((tree, tree));\n-static void do_static_destruction PARAMS ((tree));\n-static tree start_static_initialization_or_destruction PARAMS ((tree, int));\n-static void finish_static_initialization_or_destruction PARAMS ((tree));\n-static void generate_ctor_or_dtor_function PARAMS ((int, int));\n-static int generate_ctor_and_dtor_functions_for_priority\n-                                  PARAMS ((splay_tree_node, void *));\n-static tree prune_vars_needing_no_initialization PARAMS ((tree));\n-static void write_out_vars PARAMS ((tree));\n-static void import_export_class\tPARAMS ((tree));\n-static tree key_method PARAMS ((tree));\n-static tree get_guard_bits PARAMS ((tree));\n+static void mark_vtable_entries (tree);\n+static void grok_function_init (tree, tree);\n+static bool maybe_emit_vtables (tree);\n+static bool is_namespace_ancestor (tree, tree);\n+static void add_using_namespace (tree, tree, bool);\n+static tree ambiguous_decl (tree, tree, tree,int);\n+static tree build_anon_union_vars (tree);\n+static bool acceptable_java_type (tree);\n+static void output_vtable_inherit (tree);\n+static tree start_objects (int, int);\n+static void finish_objects (int, int, tree);\n+static tree merge_functions (tree, tree);\n+static tree decl_namespace (tree);\n+static tree validate_nonmember_using_decl (tree, tree *, tree *);\n+static void do_nonmember_using_decl (tree, tree, tree, tree, tree *, tree *);\n+static tree start_static_storage_duration_function (void);\n+static void finish_static_storage_duration_function (tree);\n+static priority_info get_priority_info (int);\n+static void do_static_initialization (tree, tree);\n+static void do_static_destruction (tree);\n+static tree start_static_initialization_or_destruction (tree, int);\n+static void finish_static_initialization_or_destruction (tree);\n+static void generate_ctor_or_dtor_function (bool, int);\n+static int generate_ctor_and_dtor_functions_for_priority (splay_tree_node,\n+                                                          void *);\n+static tree prune_vars_needing_no_initialization (tree);\n+static void write_out_vars (tree);\n+static void import_export_class (tree);\n+static tree key_method (tree); \n+static tree get_guard_bits (tree);\n \n /* A list of static class variables.  This is needed, because a\n    static class variable can be declared inside the class without\n@@ -129,8 +128,7 @@ tree global_namespace;\n    TYPE_UNQUALIFIED will be an extension.  */\n \n int\n-grok_method_quals (ctype, function, quals)\n-     tree ctype, function, quals;\n+grok_method_quals (tree ctype, tree function, tree quals)\n {\n   tree fntype = TREE_TYPE (function);\n   tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n@@ -174,8 +172,7 @@ grok_method_quals (ctype, function, quals)\n    inform the user.  */\n \n void\n-warn_if_unknown_interface (decl)\n-     tree decl;\n+warn_if_unknown_interface (tree decl)\n {\n   static int already_warned = 0;\n   if (already_warned++)\n@@ -205,8 +202,7 @@ warn_if_unknown_interface (decl)\n /* A subroutine of the parser, to handle a component list.  */\n \n void\n-grok_x_components (specs)\n-     tree specs;\n+grok_x_components (tree specs)\n {\n   tree t;\n \n@@ -228,9 +224,7 @@ grok_x_components (specs)\n    appropriately.  */\n \n tree\n-cp_build_parm_decl (name, type)\n-     tree name;\n-     tree type;\n+cp_build_parm_decl (tree name, tree type)\n {\n   tree parm = build_decl (PARM_DECL, name, type);\n   DECL_ARG_TYPE (parm) = type_passed_as (type);\n@@ -241,9 +235,7 @@ cp_build_parm_decl (name, type)\n    indicated NAME.  */\n \n tree\n-build_artificial_parm (name, type)\n-     tree name;\n-     tree type;\n+build_artificial_parm (tree name, tree type)\n {\n   tree parm = cp_build_parm_decl (name, type);\n   DECL_ARTIFICIAL (parm) = 1;\n@@ -267,8 +259,7 @@ build_artificial_parm (name, type)\n    VTT parm (if any), then the user-written parms.  */\n \n void\n-maybe_retrofit_in_chrg (fn)\n-     tree fn;\n+maybe_retrofit_in_chrg (tree fn)\n {\n   tree basetype, arg_types, parms, parm, fntype;\n \n@@ -351,10 +342,7 @@ maybe_retrofit_in_chrg (fn)\n    QUALS are the qualifiers for the this pointer.  */\n \n void\n-grokclassfn (ctype, function, flags, quals)\n-     tree ctype, function;\n-     enum overload_flags flags;\n-     tree quals;\n+grokclassfn (tree ctype, tree function, enum overload_flags flags, tree quals)\n {\n   tree fn_name = DECL_NAME (function);\n   int this_quals = TYPE_UNQUALIFIED;\n@@ -412,8 +400,7 @@ grokclassfn (ctype, function, flags, quals)\n    along the way.  */\n \n tree\n-grok_array_decl (array_expr, index_exp)\n-     tree array_expr, index_exp;\n+grok_array_decl (tree array_expr, tree index_exp)\n {\n   tree type = TREE_TYPE (array_expr);\n   tree p1, p2, i1, i2;\n@@ -487,9 +474,7 @@ grok_array_decl (array_expr, index_exp)\n    Implements ARM $5.3.4.  This is called from the parser.  */\n \n tree\n-delete_sanity (exp, size, doing_vec, use_global_delete)\n-     tree exp, size;\n-     int doing_vec, use_global_delete;\n+delete_sanity (tree exp, tree size, int doing_vec, int use_global_delete)\n {\n   tree t, type;\n   /* For a regular vector delete (aka, no size argument) we will pass\n@@ -566,8 +551,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n    sort of thing that should be a member template.  */\n \n void\n-check_member_template (tmpl)\n-     tree tmpl;\n+check_member_template (tree tmpl)\n {\n   tree decl;\n \n@@ -606,9 +590,8 @@ check_member_template (tmpl)\n \n /* Return true iff TYPE is a valid Java parameter or return type.  */\n \n-static int\n-acceptable_java_type (type)\n-     tree type;\n+static bool\n+acceptable_java_type (tree type)\n {\n   if (TREE_CODE (type) == VOID_TYPE || TYPE_FOR_JAVA (type))\n     return 1;\n@@ -619,9 +602,9 @@ acceptable_java_type (type)\n \t{\n \t  tree args;  int i;\n \t  if (! TYPE_FOR_JAVA (type))\n-\t    return 0;\n+\t    return false;\n \t  if (! CLASSTYPE_TEMPLATE_INFO (type))\n-\t    return 1;\n+\t    return true;\n \t  args = CLASSTYPE_TI_ARGS (type);\n \t  i = TREE_VEC_LENGTH (args);\n \t  while (--i >= 0)\n@@ -630,51 +613,49 @@ acceptable_java_type (type)\n \t      if (TREE_CODE (type) == POINTER_TYPE)\n \t\ttype = TREE_TYPE (type);\n \t      if (! TYPE_FOR_JAVA (type))\n-\t\treturn 0;\n+\t\treturn false;\n \t    }\n-\t  return 1;\n+\t  return true;\n \t}\n     }\n-  return 0;\n+  return false;\n }\n \n-/* For a METHOD in a Java class CTYPE, return 1 if\n+/* For a METHOD in a Java class CTYPE, return true if\n    the parameter and return types are valid Java types.\n-   Otherwise, print appropriate error messages, and return 0.  */\n+   Otherwise, print appropriate error messages, and return false.  */\n \n-int\n-check_java_method (method)\n-     tree method;\n+bool\n+check_java_method (tree method)\n {\n-  int jerr = 0;\n+  bool jerr = false;\n   tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (method));\n   tree ret_type = TREE_TYPE (TREE_TYPE (method));\n-  if (! acceptable_java_type (ret_type))\n+  if (!acceptable_java_type (ret_type))\n     {\n       error (\"Java method '%D' has non-Java return type `%T'\",\n \t\tmethod, ret_type);\n-      jerr++;\n+      jerr = true;\n     }\n   for (; arg_types != NULL_TREE; arg_types = TREE_CHAIN (arg_types))\n     {\n       tree type = TREE_VALUE (arg_types);\n-      if (! acceptable_java_type (type))\n+      if (!acceptable_java_type (type))\n \t{\n \t  error (\"Java method '%D' has non-Java parameter type `%T'\",\n \t\t    method, type);\n-\t  jerr++;\n+\t  jerr = true;\n \t}\n     }\n-  return jerr ? 0 : 1;\n+  return !jerr;\n }\n \n /* Sanity check: report error if this function FUNCTION is not\n    really a member of the class (CTYPE) it is supposed to belong to.\n    CNAME is the same here as it is for grokclassfn above.  */\n \n tree\n-check_classfn (ctype, function)\n-     tree ctype, function;\n+check_classfn (tree ctype, tree function)\n {\n   int ix;\n   \n@@ -793,11 +774,8 @@ check_classfn (ctype, function)\n    FLAGS is as for cp_finish_decl.  */\n \n void\n-finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n-     tree decl;\n-     tree init;\n-     tree asmspec_tree;\n-     int flags;\n+finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n+                                int flags)\n {\n   my_friendly_assert (TREE_PUBLIC (decl), 0);\n \n@@ -863,8 +841,8 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n    CHANGES TO CODE IN `start_method'.  */\n \n tree\n-grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n-     tree declarator, declspecs, init, asmspec_tree, attrlist;\n+grokfield (tree declarator, tree declspecs, tree init, tree asmspec_tree,\n+           tree attrlist)\n {\n   tree value;\n   const char *asmspec = 0;\n@@ -1071,8 +1049,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */\n \n tree\n-grokbitfield (declarator, declspecs, width)\n-     tree declarator, declspecs, width;\n+grokbitfield (tree declarator, tree declspecs, tree width)\n {\n   register tree value = grokdeclarator (declarator, declspecs, BITFIELD,\n \t\t\t\t\t0, NULL);\n@@ -1129,9 +1106,7 @@ grokbitfield (declarator, declspecs, width)\n    scope of the conversion operator, if explicit.  */\n \n tree\n-grokoptypename (declspecs, declarator, scope)\n-     tree declspecs, declarator;\n-     tree scope;\n+grokoptypename (tree declspecs, tree declarator, tree scope)\n {\n   tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL);\n \n@@ -1187,9 +1162,7 @@ grokoptypename (declspecs, declarator, scope)\n */\n \n static void\n-grok_function_init (decl, init)\n-     tree decl;\n-     tree init;\n+grok_function_init (tree decl, tree init)\n {\n   /* An initializer for a function tells how this function should\n      be inherited.  */\n@@ -1204,9 +1177,7 @@ grok_function_init (decl, init)\n }\n \f\n void\n-cplus_decl_attributes (decl, attributes, flags)\n-     tree *decl, attributes;\n-     int flags;\n+cplus_decl_attributes (tree *decl, tree attributes, int flags)\n {\n   if (*decl == NULL_TREE || *decl == void_type_node)\n     return;\n@@ -1240,8 +1211,7 @@ constructor_name_full (tree type)\n    unspecialized name.  */\n \n tree\n-constructor_name (type)\n-     tree type;\n+constructor_name (tree type)\n {\n   tree name;\n   name = constructor_name_full (type);\n@@ -1263,8 +1233,7 @@ constructor_name_p (tree name, tree type)\n /* Defer the compilation of the FN until the end of compilation.  */\n \n void\n-defer_fn (fn)\n-     tree fn;\n+defer_fn (tree fn)\n {\n   if (DECL_DEFERRED_FN (fn))\n     return;\n@@ -1280,8 +1249,7 @@ defer_fn (fn)\n    the mangled name.  */\n \n static tree\n-build_anon_union_vars (object)\n-     tree object;\n+build_anon_union_vars (tree object)\n {\n   tree type = TREE_TYPE (object);\n   tree main_decl = NULL_TREE;\n@@ -1341,12 +1309,11 @@ build_anon_union_vars (object)\n    is nonzero if this union is not declared static.  */\n \n void\n-finish_anon_union (anon_union_decl)\n-     tree anon_union_decl;\n+finish_anon_union (tree anon_union_decl)\n {\n   tree type = TREE_TYPE (anon_union_decl);\n   tree main_decl;\n-  int public_p = TREE_PUBLIC (anon_union_decl);\n+  bool public_p = TREE_PUBLIC (anon_union_decl);\n \n   /* The VAR_DECL's context is the same as the TYPE's context.  */\n   DECL_CONTEXT (anon_union_decl) = DECL_CONTEXT (TYPE_NAME (type));\n@@ -1390,8 +1357,7 @@ finish_anon_union (anon_union_decl)\n    what compiler will be expecting.  */\n \n tree\n-coerce_new_type (type)\n-     tree type;\n+coerce_new_type (tree type)\n {\n   int e = 0;\n   tree args = TYPE_ARG_TYPES (type);\n@@ -1425,8 +1391,7 @@ coerce_new_type (type)\n }\n \n tree\n-coerce_delete_type (type)\n-     tree type;\n+coerce_delete_type (tree type)\n {\n   int e = 0;\n   tree args = TYPE_ARG_TYPES (type);\n@@ -1461,8 +1426,7 @@ coerce_delete_type (type)\n }\n \f\n static void\n-mark_vtable_entries (decl)\n-     tree decl;\n+mark_vtable_entries (tree decl)\n {\n   tree entries = CONSTRUCTOR_ELTS (DECL_INITIAL (decl));\n \n@@ -1493,8 +1457,7 @@ mark_vtable_entries (decl)\n    linkage available.  */\n \n void\n-comdat_linkage (decl)\n-     tree decl;\n+comdat_linkage (tree decl)\n {\n   if (flag_weak)\n     make_decl_one_only (decl);\n@@ -1547,8 +1510,7 @@ comdat_linkage (decl)\n    instantiations; otherwise we get duplicate symbol errors.  */\n \n void\n-maybe_make_one_only (decl)\n-     tree decl;\n+maybe_make_one_only (tree decl)\n {\n   /* We used to say that this was not necessary on targets that support weak\n      symbols, because the implicit instantiations will defer to the explicit\n@@ -1578,8 +1540,7 @@ maybe_make_one_only (decl)\n    emitted, or NULL_TREE if that heuristic is not applicable to TYPE.  */\n \n static tree\n-key_method (type)\n-     tree type;\n+key_method (tree type)\n {\n   tree method;\n \n@@ -1605,9 +1566,7 @@ key_method (type)\n    it's public in this file or in another one.  */\n \n void\n-import_export_vtable (decl, type, final)\n-     tree decl, type;\n-     int final;\n+import_export_vtable (tree decl, tree type, int final)\n {\n   if (DECL_INTERFACE_KNOWN (decl))\n     return;\n@@ -1649,8 +1608,7 @@ import_export_vtable (decl, type, final)\n    using various heuristics.  */\n \n static void\n-import_export_class (ctype)\n-     tree ctype;\n+import_export_class (tree ctype)\n {\n   /* -1 for imported, 1 for exported.  */\n   int import_export = 0;\n@@ -1711,8 +1669,7 @@ import_export_class (ctype)\n    a vtable and the vtable of the parent class.  */\n \n static void\n-output_vtable_inherit (vars)\n-     tree vars;\n+output_vtable_inherit (tree vars)\n {\n   tree parent;\n   rtx child_rtx, parent_rtx;\n@@ -1735,9 +1692,9 @@ output_vtable_inherit (vars)\n }\n \n /* If necessary, write out the vtables for the dynamic class CTYPE.\n-   Returns nonzero if any vtables were emitted.  */\n+   Returns true if any vtables were emitted.  */\n \n-static int\n+static bool\n maybe_emit_vtables (tree ctype)\n {\n   tree vtbl;\n@@ -1747,10 +1704,10 @@ maybe_emit_vtables (tree ctype)\n      nothing more to do.  */\n   primary_vtbl = CLASSTYPE_VTABLES (ctype);\n   if (TREE_ASM_WRITTEN (primary_vtbl))\n-    return 0;\n+    return false;\n   /* Ignore dummy vtables made by get_vtable_decl.  */\n   if (TREE_TYPE (primary_vtbl) == void_type_node)\n-    return 0;\n+    return false;\n \n   import_export_class (ctype);\n   import_export_vtable (primary_vtbl, ctype, 1);\n@@ -1768,7 +1725,7 @@ maybe_emit_vtables (tree ctype)\n       if (DECL_COMDAT (primary_vtbl) \n \t  && CLASSTYPE_DEBUG_REQUESTED (ctype))\n \tnote_debug_info_needed (ctype);\n-      return 0;\n+      return false;\n     }\n \n   /* The ABI requires that we emit all of the vtables if we emit any\n@@ -1826,15 +1783,14 @@ maybe_emit_vtables (tree ctype)\n      info.  */\n   note_debug_info_needed (ctype);\n \n-  return 1;\n+  return true;\n }\n \n /* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an\n    inline function or template instantiation at end-of-file.  */\n \n void\n-import_export_decl (decl)\n-     tree decl;\n+import_export_decl (tree decl)\n {\n   if (DECL_INTERFACE_KNOWN (decl))\n     return;\n@@ -1900,10 +1856,7 @@ import_export_decl (decl)\n    typeinfo for TYPE should be in the runtime library.  */\n \n void\n-import_export_tinfo (decl, type, is_in_library)\n-     tree decl;\n-     tree type;\n-     int is_in_library;\n+import_export_tinfo (tree decl, tree type, bool is_in_library)\n {\n   if (DECL_INTERFACE_KNOWN (decl))\n     return;\n@@ -1937,8 +1890,7 @@ import_export_tinfo (decl, type, is_in_library)\n }\n \n tree\n-build_cleanup (decl)\n-     tree decl;\n+build_cleanup (tree decl)\n {\n   tree temp;\n   tree type = TREE_TYPE (decl);\n@@ -1960,8 +1912,7 @@ build_cleanup (decl)\n    which has static storage duration.  */\n \n tree\n-get_guard (decl)\n-     tree decl;\n+get_guard (tree decl)\n {\n   tree sname;\n   tree guard;\n@@ -1997,8 +1948,7 @@ get_guard (decl)\n    guarded entity is actually initialized.  */\n \n static tree\n-get_guard_bits (guard)\n-     tree guard;\n+get_guard_bits (tree guard)\n {\n   /* We only set the first byte of the guard, in order to leave room\n      for a mutex in the high-order bits.  */\n@@ -2017,8 +1967,7 @@ get_guard_bits (guard)\n    variable has already been initialized.  */\n \n tree\n-get_guard_cond (guard)\n-     tree guard;\n+get_guard_cond (tree guard)\n {\n   tree guard_value;\n \n@@ -2034,8 +1983,7 @@ get_guard_cond (guard)\n    the variable being guarded has been initialized.  */\n \n tree\n-set_guard (guard)\n-     tree guard;\n+set_guard (tree guard)\n {\n   tree guard_init;\n \n@@ -2051,8 +1999,7 @@ set_guard (guard)\n    or destructors.  Subroutine of do_[cd]tors.  */\n \n static tree\n-start_objects (method_type, initp)\n-     int method_type, initp;\n+start_objects (int method_type, int initp)\n {\n   tree fnname;\n   tree body;\n@@ -2112,9 +2059,7 @@ start_objects (method_type, initp)\n    or destructors.  Subroutine of do_[cd]tors.  */\n \n static void\n-finish_objects (method_type, initp, body)\n-     int method_type, initp;\n-     tree body;\n+finish_objects (int method_type, int initp, tree body)\n {\n   tree fn;\n \n@@ -2180,7 +2125,7 @@ static splay_tree priority_info_map;\n    translation unit.  */\n \n static tree\n-start_static_storage_duration_function ()\n+start_static_storage_duration_function (void)\n {\n   static unsigned ssdf_number;\n \n@@ -2279,8 +2224,7 @@ start_static_storage_duration_function ()\n    this point, no more such objects can be created.  */\n \n static void\n-finish_static_storage_duration_function (body)\n-     tree body;\n+finish_static_storage_duration_function (tree body)\n {\n   /* Close out the function.  */\n   finish_compound_stmt (/*has_no_scope=*/0, body);\n@@ -2292,8 +2236,7 @@ finish_static_storage_duration_function (body)\n    appropriate prologue.  */\n \n static priority_info\n-get_priority_info (priority)\n-     int priority;\n+get_priority_info (int priority)\n {\n   priority_info pi;\n   splay_tree_node n;\n@@ -2322,9 +2265,7 @@ get_priority_info (priority)\n    are destroying it.  */\n \n static tree\n-start_static_initialization_or_destruction (decl, initp)\n-     tree decl;\n-     int initp;\n+start_static_initialization_or_destruction (tree decl, int initp)\n {\n   tree guard_if_stmt = NULL_TREE;\n   int priority;\n@@ -2446,8 +2387,7 @@ start_static_initialization_or_destruction (decl, initp)\n    the initialization.  */\n \n static void\n-finish_static_initialization_or_destruction (guard_if_stmt)\n-     tree guard_if_stmt;\n+finish_static_initialization_or_destruction (tree guard_if_stmt)\n {\n   finish_then_clause (guard_if_stmt);\n   finish_if_stmt ();\n@@ -2462,9 +2402,7 @@ finish_static_initialization_or_destruction (guard_if_stmt)\n    static storage duration.  The initialization is INIT.  */\n \n static void\n-do_static_initialization (decl, init)\n-     tree decl;\n-     tree init;\n+do_static_initialization (tree decl, tree init)\n {\n   tree guard_if_stmt;\n \n@@ -2492,8 +2430,7 @@ do_static_initialization (decl, init)\n    destruction.  */\n \n static void\n-do_static_destruction (decl)\n-     tree decl;\n+do_static_destruction (tree decl)\n {\n   tree guard_if_stmt;\n \n@@ -2521,8 +2458,7 @@ do_static_destruction (decl)\n    i.e., the first variable should be initialized first.  */\n \n static tree\n-prune_vars_needing_no_initialization (vars)\n-     tree vars;\n+prune_vars_needing_no_initialization (tree vars)\n {\n   tree var;\n   tree result;\n@@ -2564,8 +2500,7 @@ prune_vars_needing_no_initialization (vars)\n    VARS.  */\n \n static void\n-write_out_vars (vars)\n-     tree vars;\n+write_out_vars (tree vars)\n {\n   tree v;\n \n@@ -2579,9 +2514,7 @@ write_out_vars (vars)\n    storage duration having the indicated PRIORITY.  */\n \n static void\n-generate_ctor_or_dtor_function (constructor_p, priority)\n-     int constructor_p;\n-     int priority;\n+generate_ctor_or_dtor_function (bool constructor_p, int priority)\n {\n   char function_key;\n   tree arguments;\n@@ -2631,9 +2564,8 @@ generate_ctor_or_dtor_function (constructor_p, priority)\n    indicated by N.  */\n \n static int\n-generate_ctor_and_dtor_functions_for_priority (n, data)\n-     splay_tree_node n;\n-     void *data ATTRIBUTE_UNUSED;\n+generate_ctor_and_dtor_functions_for_priority (splay_tree_node n,\n+                                               void * data ATTRIBUTE_UNUSED)\n {\n   int priority = (int) n->key;\n   priority_info pi = (priority_info) n->value;\n@@ -2642,12 +2574,10 @@ generate_ctor_and_dtor_functions_for_priority (n, data)\n      needed.  */\n   if (pi->initializations_p\n       || (priority == DEFAULT_INIT_PRIORITY && static_ctors))\n-    generate_ctor_or_dtor_function (/*constructor_p=*/1,\n-\t\t\t\t    priority);\n+    generate_ctor_or_dtor_function (/*constructor_p=*/true, priority);\n   if (pi->destructions_p\n       || (priority == DEFAULT_INIT_PRIORITY && static_dtors))\n-    generate_ctor_or_dtor_function (/*constructor_p=*/0,\n-\t\t\t\t    priority);\n+    generate_ctor_or_dtor_function (/*constructor_p=*/false, priority);\n \n   /* Keep iterating.  */\n   return 0;\n@@ -2662,7 +2592,7 @@ void\n finish_file ()\n {\n   tree vars;\n-  int reconsider;\n+  bool reconsider;\n   size_t i;\n \n   at_eof = 1;\n@@ -2702,7 +2632,7 @@ finish_file ()\n     {\n       tree t;\n \n-      reconsider = 0;\n+      reconsider = false;\n \n       /* If there are templates that we've put off instantiating, do\n \t them now.  */\n@@ -2713,12 +2643,12 @@ finish_file ()\n \t instantiation of members of that class.  */\n       for (t = dynamic_classes; t; t = TREE_CHAIN (t))\n \tif (maybe_emit_vtables (TREE_VALUE (t)))\n-\t  reconsider = 1;\n+\t  reconsider = true;\n       \n       /* Write out needed type info variables. Writing out one variable\n          might cause others to be needed.  */\n       if (walk_globals (unemitted_tinfo_decl_p, emit_tinfo_decl, /*data=*/0))\n-\treconsider = 1;\n+\treconsider = true;\n \n       /* The list of objects with static storage duration is built up\n \t in reverse order.  We clear STATIC_AGGREGATES so that any new\n@@ -2771,7 +2701,7 @@ finish_file ()\n \t  /* All those initializations and finalizations might cause\n \t     us to need more inline functions, more template\n \t     instantiations, etc.  */\n-\t  reconsider = 1;\n+\t  reconsider = true;\n \t}\n       \n       for (i = 0; i < deferred_fns_used; ++i)\n@@ -2793,7 +2723,7 @@ finish_file ()\n \t      push_to_top_level ();\n \t      synthesize_method (decl);\n \t      pop_from_top_level ();\n-\t      reconsider = 1;\n+\t      reconsider = true;\n \t    }\n \n \t  /* We lie to the back-end, pretending that some functions\n@@ -2837,16 +2767,16 @@ finish_file ()\n \t\t expand it again.  */\n \t      if (flag_syntax_only)\n \t\tTREE_ASM_WRITTEN (decl) = 1;\n-\t      reconsider = 1;\n+\t      reconsider = true;\n \t    }\n \t}\n \n       if (deferred_fns_used\n \t  && wrapup_global_declarations (&VARRAY_TREE (deferred_fns, 0),\n \t\t\t\t\t deferred_fns_used))\n-\treconsider = 1;\n+\treconsider = true;\n       if (walk_namespaces (wrapup_globals_for_namespace, /*data=*/0))\n-\treconsider = 1;\n+\treconsider = true;\n \n       /* Static data members are just like namespace-scope globals.  */\n       for (i = 0; i < pending_statics_used; ++i) \n@@ -2861,7 +2791,7 @@ finish_file ()\n       if (pending_statics\n \t  && wrapup_global_declarations (&VARRAY_TREE (pending_statics, 0),\n \t\t\t\t\t pending_statics_used))\n-\treconsider = 1;\n+\treconsider = true;\n     } \n   while (reconsider);\n \n@@ -3517,8 +3447,7 @@ build_call_from_tree (tree fn, tree args, bool disallow_virtual)\n    In the above example, TYPE is `int' and DECL is `*a'.  */\n \n tree\n-reparse_decl_as_expr (type, decl)\n-     tree type, decl;\n+reparse_decl_as_expr (tree type, tree decl)\n {\n   decl = build_expr_from_tree (decl);\n   if (type)\n@@ -3532,8 +3461,7 @@ reparse_decl_as_expr (type, decl)\n    checking that make_{pointer,reference}_declarator do.  */\n \n tree\n-finish_decl_parsing (decl)\n-     tree decl;\n+finish_decl_parsing (tree decl)\n {\n   switch (TREE_CODE (decl))\n     {\n@@ -3569,16 +3497,15 @@ finish_decl_parsing (decl)\n \n /* Return 1 if root encloses child.  */\n \n-static int\n-is_namespace_ancestor (root, child)\n-     tree root, child;\n+static bool\n+is_namespace_ancestor (tree root, tree child)\n {\n   if (root == child)\n-    return 1;\n+    return true;\n   if (root == global_namespace)\n-    return 1;\n+    return true;\n   if (child == global_namespace)\n-    return 0;\n+    return false;\n   return is_namespace_ancestor (root, CP_DECL_CONTEXT (child));\n }\n   \n@@ -3587,22 +3514,18 @@ is_namespace_ancestor (root, child)\n    of two given namespaces.  */\n \n tree\n-namespace_ancestor (ns1, ns2)\n-     tree ns1, ns2;\n+namespace_ancestor (tree ns1, tree ns2)\n {\n   if (is_namespace_ancestor (ns1, ns2))\n     return ns1;\n   return namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2);\n }\n \n-/* Insert used into the using list of user. Set indirect_flag if this\n+/* Insert USED into the using list of USER. Set INDIRECT_flag if this\n    directive is not directly from the source. Also find the common\n    ancestor and let our users know about the new namespace */\n static void \n-add_using_namespace (user, used, indirect)\n-     tree user;\n-     tree used;\n-     int indirect;\n+add_using_namespace (tree user, tree used, bool indirect)\n {\n   tree t;\n   /* Using oneself is a no-op.  */\n@@ -3649,9 +3572,7 @@ add_using_namespace (user, used, indirect)\n    necessary.  */\n \n static tree\n-merge_functions (s1, s2)\n-     tree s1;\n-     tree s2;\n+merge_functions (tree s1, tree s2)\n {\n   for (; s2; s2 = OVL_NEXT (s2))\n     {\n@@ -3688,11 +3609,7 @@ merge_functions (s1, s2)\n    XXX I don't want to repeat the entire duplicate_decls here */\n \n static tree\n-ambiguous_decl (name, old, new, flags)\n-     tree name;\n-     tree old;\n-     tree new;\n-     int flags;\n+ambiguous_decl (tree name, tree old, tree new, int flags)\n {\n   tree val, type;\n   my_friendly_assert (old != NULL_TREE, 393);\n@@ -3778,13 +3695,11 @@ ambiguous_decl (name, old, new, flags)\n    We are currently looking for names in namespace SCOPE, so we\n    look through USINGS for using-directives of namespaces\n    which have SCOPE as a common ancestor with the current scope.\n-   Returns zero on errors.  */\n+   Returns false on errors.  */\n \n-int\n-lookup_using_namespace (name, val, usings, scope, flags, spacesp)\n-     tree name, val, usings, scope;\n-     int flags;\n-     tree *spacesp;\n+bool\n+lookup_using_namespace (tree name, tree val, tree usings, tree scope,\n+                        int flags, tree *spacesp)\n {\n   tree iter;\n   tree val1;\n@@ -3806,14 +3721,11 @@ lookup_using_namespace (name, val, usings, scope, flags, spacesp)\n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n    Returns the name/type pair found into the CPLUS_BINDING RESULT,\n-   or 0 on error.  */\n+   or false on error.  */\n \n-int\n-qualified_lookup_using_namespace (name, scope, result, flags)\n-     tree name;\n-     tree scope;\n-     tree result;\n-     int flags;\n+bool\n+qualified_lookup_using_namespace (tree name, tree scope, tree result,\n+                                  int flags)\n {\n   /* Maintain a list of namespaces visited...  */\n   tree seen = NULL_TREE;\n@@ -3852,10 +3764,7 @@ qualified_lookup_using_namespace (name, scope, result, flags)\n    outside scope.  */\n \n void\n-set_decl_namespace (decl, scope, friendp)\n-     tree decl;\n-     tree scope;\n-     int friendp;\n+set_decl_namespace (tree decl, tree scope, bool friendp)\n {\n   tree old;\n   \n@@ -3911,8 +3820,7 @@ set_decl_namespace (decl, scope, friendp)\n /* Compute the namespace where a declaration is defined.  */\n \n static tree\n-decl_namespace (decl)\n-     tree decl;\n+decl_namespace (tree decl)\n {\n   if (TYPE_P (decl))\n     decl = TYPE_STUB_DECL (decl);\n@@ -3932,7 +3840,7 @@ decl_namespace (decl)\n /* Return the namespace where the current declaration is declared.  */\n \n tree\n-current_decl_namespace ()\n+current_decl_namespace (void)\n {\n   tree result;\n   /* If we have been pushed into a different namespace, use it.  */\n@@ -3951,8 +3859,7 @@ current_decl_namespace ()\n /* Temporarily set the namespace for the current declaration.  */\n \n void\n-push_decl_namespace (decl)\n-     tree decl;\n+push_decl_namespace (tree decl)\n {\n   if (TREE_CODE (decl) != NAMESPACE_DECL)\n     decl = decl_namespace (decl);\n@@ -3961,16 +3868,15 @@ push_decl_namespace (decl)\n }\n \n void\n-pop_decl_namespace ()\n+pop_decl_namespace (void)\n {\n   decl_namespace_list = TREE_CHAIN (decl_namespace_list);\n }\n \n /* Enter a class or namespace scope.  */\n \n void\n-push_scope (t)\n-     tree t;\n+push_scope (tree t)\n {\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     push_decl_namespace (t);\n@@ -3981,8 +3887,7 @@ push_scope (t)\n /* Leave scope pushed by push_scope.  */\n \n void\n-pop_scope (t)\n-     tree t;\n+pop_scope (tree t)\n {\n   if (TREE_CODE (t) == NAMESPACE_DECL)\n     pop_decl_namespace ();\n@@ -4001,21 +3906,19 @@ struct arg_lookup\n   tree functions;\n };\n \n-static int arg_assoc         PARAMS ((struct arg_lookup*, tree));\n-static int arg_assoc_args    PARAMS ((struct arg_lookup*, tree));\n-static int arg_assoc_type    PARAMS ((struct arg_lookup*, tree));\n-static int add_function      PARAMS ((struct arg_lookup *, tree));\n-static int arg_assoc_namespace PARAMS ((struct arg_lookup *, tree));\n-static int arg_assoc_class   PARAMS ((struct arg_lookup *, tree));\n-static int arg_assoc_template_arg PARAMS ((struct arg_lookup*, tree));\n+static bool arg_assoc (struct arg_lookup*, tree);\n+static bool arg_assoc_args (struct arg_lookup*, tree);\n+static bool arg_assoc_type (struct arg_lookup*, tree);\n+static bool add_function (struct arg_lookup *, tree);\n+static bool arg_assoc_namespace (struct arg_lookup *, tree);\n+static bool arg_assoc_class (struct arg_lookup *, tree);\n+static bool arg_assoc_template_arg (struct arg_lookup*, tree);\n \n /* Add a function to the lookup structure.\n-   Returns 1 on error.  */\n+   Returns true on error.  */\n \n-static int\n-add_function (k, fn)\n-     struct arg_lookup *k;\n-     tree fn;\n+static bool\n+add_function (struct arg_lookup *k, tree fn)\n {\n   /* We used to check here to see if the function was already in the list,\n      but that's O(n^2), which is just too expensive for function lookup.\n@@ -4040,19 +3943,17 @@ add_function (k, fn)\n       cp_error_at (\"`%D' is not a function,\", f1);\n       cp_error_at (\"  conflict with `%D'\", f2);\n       error (\"  in call to `%D'\", k->name);\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Add functions of a namespace to the lookup structure.\n-   Returns 1 on error.  */\n+   Returns true on error.  */\n \n-static int\n-arg_assoc_namespace (k, scope)\n-     struct arg_lookup *k;\n-     tree scope;\n+static bool\n+arg_assoc_namespace (struct arg_lookup *k, tree scope)\n {\n   tree value;\n \n@@ -4062,22 +3963,20 @@ arg_assoc_namespace (k, scope)\n   \n   value = namespace_binding (k->name, scope);\n   if (!value)\n-    return 0;\n+    return false;\n \n   for (; value; value = OVL_NEXT (value))\n     if (add_function (k, OVL_CURRENT (value)))\n-      return 1;\n+      return true;\n   \n-  return 0;\n+  return false;\n }\n \n /* Adds everything associated with a template argument to the lookup\n-   structure.  Returns 1 on error.  */\n+   structure.  Returns true on error.  */\n \n-static int\n-arg_assoc_template_arg (k, arg)\n-     struct arg_lookup* k;\n-     tree arg;\n+static bool\n+arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n {\n   /* [basic.lookup.koenig]\n \n@@ -4093,7 +3992,7 @@ arg_assoc_template_arg (k, arg)\n   /* Consider first template template arguments.  */\n   if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n       || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE)\n-    return 0;\n+    return false;\n   else if (TREE_CODE (arg) == TEMPLATE_DECL)\n     {\n       tree ctx = CP_DECL_CONTEXT (arg);\n@@ -4111,37 +4010,35 @@ arg_assoc_template_arg (k, arg)\n     return arg_assoc_type (k, arg);\n   /* It's a non-type template argument.  */\n   else\n-    return 0;\n+    return false;\n }\n \n /* Adds everything associated with class to the lookup structure.\n-   Returns 1 on error.  */\n+   Returns true on error.  */\n \n-static int\n-arg_assoc_class (k, type)\n-     struct arg_lookup* k;\n-     tree type;\n+static bool\n+arg_assoc_class (struct arg_lookup *k, tree type)\n {\n   tree list, friends, context;\n   int i;\n   \n   /* Backend build structures, such as __builtin_va_list, aren't\n      affected by all this.  */\n   if (!CLASS_TYPE_P (type))\n-    return 0;\n+    return false;\n \n   if (purpose_member (type, k->classes))\n-    return 0;\n+    return false;\n   k->classes = tree_cons (type, NULL_TREE, k->classes);\n   \n   context = decl_namespace (TYPE_MAIN_DECL (type));\n   if (arg_assoc_namespace (k, context))\n-    return 1;\n+    return true;\n   \n   /* Process baseclasses.  */\n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); i++)\n     if (arg_assoc_class (k, TYPE_BINFO_BASETYPE (type, i)))\n-      return 1;\n+      return true;\n   \n   /* Process friends.  */\n   for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; \n@@ -4154,7 +4051,7 @@ arg_assoc_class (k, type)\n \tif (TREE_PURPOSE (friends) == error_mark_node && TREE_VALUE (friends)\n \t    && decl_namespace (TREE_VALUE (friends)) == context)\n \t  if (add_function (k, TREE_VALUE (friends)))\n-\t    return 1;\n+\t    return true;\n \n   /* Process template arguments.  */\n   if (CLASSTYPE_TEMPLATE_INFO (type))\n@@ -4164,16 +4061,14 @@ arg_assoc_class (k, type)\n         arg_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Adds everything associated with a given type.\n    Returns 1 on error.  */\n \n-static int\n-arg_assoc_type (k, type)\n-     struct arg_lookup *k;\n-     tree type;\n+static bool\n+arg_assoc_type (struct arg_lookup *k, tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -4184,7 +4079,7 @@ arg_assoc_type (k, type)\n     case VECTOR_TYPE:\n     case CHAR_TYPE:\n     case BOOLEAN_TYPE:\n-      return 0;\n+      return false;\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (type))\n \treturn arg_assoc_type (k, TYPE_PTRMEMFUNC_FN_TYPE (type));\n@@ -4199,54 +4094,50 @@ arg_assoc_type (k, type)\n     case OFFSET_TYPE:\n       /* Pointer to member: associate class type and value type.  */\n       if (arg_assoc_type (k, TYPE_OFFSET_BASETYPE (type)))\n-\treturn 1;\n+\treturn true;\n       return arg_assoc_type (k, TREE_TYPE (type));\n     case METHOD_TYPE:\n       /* The basetype is referenced in the first arg type, so just\n \t fall through.  */\n     case FUNCTION_TYPE:\n       /* Associate the parameter types.  */\n       if (arg_assoc_args (k, TYPE_ARG_TYPES (type)))\n-\treturn 1;\n+\treturn true;\n       /* Associate the return type.  */\n       return arg_assoc_type (k, TREE_TYPE (type));\n     case TEMPLATE_TYPE_PARM:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n-      return 0;\n+      return false;\n     case TYPENAME_TYPE:\n-      return 0;\n+      return false;\n     case LANG_TYPE:\n       if (type == unknown_type_node)\n-\treturn 0;\n+\treturn false;\n       /* else fall through */\n     default:\n       abort ();\n     }\n-  return 0;\n+  return false;\n }\n \n-/* Adds everything associated with arguments.  Returns 1 on error.  */\n+/* Adds everything associated with arguments.  Returns true on error.  */\n \n-static int\n-arg_assoc_args (k, args)\n-     struct arg_lookup* k;\n-     tree args;\n+static bool\n+arg_assoc_args (struct arg_lookup *k, tree args)\n {\n   for (; args; args = TREE_CHAIN (args))\n     if (arg_assoc (k, TREE_VALUE (args)))\n-      return 1;\n-  return 0;\n+      return true;\n+  return false;\n }\n \n /* Adds everything associated with a given tree_node.  Returns 1 on error.  */\n \n-static int\n-arg_assoc (k, n)\n-     struct arg_lookup* k;\n-     tree n;\n+static bool\n+arg_assoc (struct arg_lookup *k, tree n)\n {\n   if (n == error_mark_node)\n-    return 0;\n+    return false;\n \n   if (TYPE_P (n))\n     return arg_assoc_type (k, n);\n@@ -4293,37 +4184,34 @@ arg_assoc (k, n)\n       if (TREE_CODE (ctx) == NAMESPACE_DECL)\n \t{\n \t  if (arg_assoc_namespace (k, ctx) == 1)\n-\t    return 1;\n+\t    return true;\n \t}\n       /* It must be a member template.  */\n       else if (arg_assoc_class (k, ctx) == 1)\n-\treturn 1;\n+\treturn true;\n \n       /* Now the arguments.  */\n       for (arg = args; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n \tif (arg_assoc_template_arg (k, TREE_VALUE (arg)) == 1)\n-\t  return 1;\n+\t  return true;\n     }\n   else\n     {\n       my_friendly_assert (TREE_CODE (n) == OVERLOAD, 980715);\n       \n       for (; n; n = OVL_CHAIN (n))\n \tif (arg_assoc_type (k, TREE_TYPE (OVL_FUNCTION (n))))\n-\t  return 1;\n+\t  return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Performs Koenig lookup depending on arguments, where fns\n    are the functions found in normal lookup.  */\n \n tree\n-lookup_arg_dependent (name, fns, args)\n-     tree name;\n-     tree fns;\n-     tree args;\n+lookup_arg_dependent (tree name, tree fns, tree args)\n {\n   struct arg_lookup k;\n   tree fn = NULL_TREE;\n@@ -4348,8 +4236,7 @@ lookup_arg_dependent (name, fns, args)\n /* Process a namespace-alias declaration.  */\n \n void\n-do_namespace_alias (alias, namespace)\n-     tree alias, namespace;\n+do_namespace_alias (tree alias, tree namespace)\n {\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n@@ -4370,10 +4257,7 @@ do_namespace_alias (alias, namespace)\n    being used, and the USING_DECL, or NULL_TREE on failure.  */\n \n static tree\n-validate_nonmember_using_decl (decl, scope, name)\n-     tree decl;\n-     tree *scope;\n-     tree *name;\n+validate_nonmember_using_decl (tree decl, tree *scope, tree *name)\n {\n   *scope = global_namespace;\n   *name = NULL_TREE;\n@@ -4422,10 +4306,8 @@ validate_nonmember_using_decl (decl, scope, name)\n /* Process local and global using-declarations.  */\n \n static void\n-do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n-     tree scope, name;\n-     tree oldval, oldtype;\n-     tree *newval, *newtype;\n+do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n+                         tree *newval, tree *newtype)\n {\n   tree decls;\n \n@@ -4524,8 +4406,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n /* Process a using-declaration not appearing in class or local scope.  */\n \n void\n-do_toplevel_using_decl (decl)\n-     tree decl;\n+do_toplevel_using_decl (tree decl)\n {\n   tree scope, name, binding;\n   tree oldval, oldtype, newval, newtype;\n@@ -4552,8 +4433,7 @@ do_toplevel_using_decl (decl)\n /* Process a using-declaration at function scope.  */\n \n void\n-do_local_using_decl (decl)\n-     tree decl;\n+do_local_using_decl (tree decl)\n {\n   tree scope, name;\n   tree oldval, oldtype, newval, newtype;\n@@ -4598,8 +4478,7 @@ do_local_using_decl (decl)\n }\n \n tree\n-do_class_using_decl (decl)\n-     tree decl;\n+do_class_using_decl (tree decl)\n {\n   tree name, value;\n \n@@ -4659,8 +4538,7 @@ do_class_using_decl (decl)\n /* Process a using-directive.  */\n \n void\n-do_using_directive (namespace)\n-     tree namespace;\n+do_using_directive (tree namespace)\n {\n   if (building_stmt_tree ())\n     add_stmt (build_stmt (USING_STMT, namespace));\n@@ -4690,15 +4568,15 @@ do_using_directive (namespace)\n }\n \n void\n-check_default_args (x)\n-     tree x;\n+check_default_args (tree x)\n {\n   tree arg = TYPE_ARG_TYPES (TREE_TYPE (x));\n-  int saw_def = 0, i = 0 - (TREE_CODE (TREE_TYPE (x)) == METHOD_TYPE);\n+  bool saw_def = false;\n+  int i = 0 - (TREE_CODE (TREE_TYPE (x)) == METHOD_TYPE);\n   for (; arg && arg != void_list_node; arg = TREE_CHAIN (arg), ++i)\n     {\n       if (TREE_PURPOSE (arg))\n-\tsaw_def = 1;\n+\tsaw_def = true;\n       else if (saw_def)\n \t{\n \t  cp_error_at (\"default argument missing for parameter %P of `%+#D'\",\n@@ -4709,8 +4587,7 @@ check_default_args (x)\n }\n \n void\n-mark_used (decl)\n-     tree decl;\n+mark_used (tree decl)\n {\n   TREE_USED (decl) = 1;\n   if (processing_template_decl)\n@@ -4759,11 +4636,8 @@ mark_used (decl)\n    Return a TYPE_DECL for the type declared by ID in SCOPE.  */\n \n tree\n-handle_class_head (tag_kind, scope, id, attributes, defn_p, new_type_p)\n-     enum tag_types tag_kind;\n-     tree scope, id, attributes;\n-     int defn_p;\n-     int *new_type_p;\n+handle_class_head (enum tag_types tag_kind, tree scope, tree id,\n+                   tree attributes, bool defn_p, bool *new_type_p)\n {\n   tree decl = NULL_TREE;\n   tree current = current_scope ();\n@@ -4772,7 +4646,7 @@ handle_class_head (tag_kind, scope, id, attributes, defn_p, new_type_p)\n   if (current == NULL_TREE)\n     current = current_namespace;\n \n-  *new_type_p = 0;\n+  *new_type_p = false;\n   \n   if (scope)\n     {"}, {"sha": "70bf5eff4ba21ba2aae02d66ae9511009f76f8ba", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -11755,7 +11755,7 @@ cp_parser_class_head (parser,\n     }\n   else\n     {\n-      int new_type_p;\n+      bool new_type_p;\n       tree class_type;\n \n       /* Given:\n@@ -11779,7 +11779,7 @@ cp_parser_class_head (parser,\n \t\t\t\t\t   nested_name_specifier,\n \t\t\t\t\t   type,\n \t\t\t\t\t   attributes,\n-\t\t\t\t\t   /*defn_p=*/1,\n+\t\t\t\t\t   /*defn_p=*/true,\n \t\t\t\t\t   &new_type_p));\n       if (type != error_mark_node)\n \t{"}, {"sha": "e50836ab6d1dbff0ba066a4517df7131f893406d", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -29,10 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n \n void\n-cxx_print_decl (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+cxx_print_decl (FILE *file, tree node, int indent)\n {\n   if (TREE_CODE (node) == FIELD_DECL)\n     {\n@@ -68,10 +65,7 @@ cxx_print_decl (file, node, indent)\n }\n \n void\n-cxx_print_type (file, node, indent)\n-     FILE *file;\n-     register tree node;\n-     int indent;\n+cxx_print_type (FILE *file, tree node, int indent)\n {\n   switch (TREE_CODE (node))\n     {\n@@ -160,10 +154,7 @@ cxx_print_type (file, node, indent)\n }\n \n void\n-cxx_print_identifier (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+cxx_print_identifier (FILE *file, tree node, int indent)\n {\n   print_node (file, \"bindings\", IDENTIFIER_NAMESPACE_BINDINGS (node), indent + 4);\n   print_node (file, \"class\", IDENTIFIER_CLASS_VALUE (node), indent + 4);\n@@ -175,10 +166,7 @@ cxx_print_identifier (file, node, indent)\n }\n \n void\n-cxx_print_xnode (file, node, indent)\n-     FILE *file;\n-     tree node;\n-     int indent;\n+cxx_print_xnode (FILE *file, tree node, int indent)\n {\n   switch (TREE_CODE (node))\n     {"}, {"sha": "bfeaa22c48dc497fb17c2077b7e9fc03252c901b", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -37,12 +37,12 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"diagnostic.h\"\n \n-static tree repo_get_id PARAMS ((tree));\n-static char *extract_string PARAMS ((char **));\n-static const char *get_base_filename PARAMS ((const char *));\n-static void open_repo_file PARAMS ((const char *));\n-static char *afgets PARAMS ((FILE *));\n-static void reopen_repo_file_for_write PARAMS ((void));\n+static tree repo_get_id (tree);\n+static char *extract_string (char **);\n+static const char *get_base_filename (const char *);\n+static void open_repo_file (const char *);\n+static char *afgets (FILE *);\n+static void reopen_repo_file_for_write (void);\n \n static GTY(()) tree pending_repo;\n static GTY(()) tree original_repo;\n@@ -60,9 +60,7 @@ static struct obstack temporary_obstack;\n /* Record the flags used to compile this translation unit.  */\n \n void\n-repo_compile_flags (argc, argv)\n-     int argc;\n-     char **argv;\n+repo_compile_flags (int argc, char **argv)\n {\n }\n \n@@ -71,30 +69,26 @@ repo_compile_flags (argc, argv)\n    definition at link time.  */\n \n void\n-repo_template_declared (t)\n-     tree t;\n+repo_template_declared (tree t)\n {}\n \n /* Note where the definition of a template lives so that instantiations can\n    be generated later.  */\n \n void\n-repo_template_defined (t)\n-     tree t;\n+repo_template_defined (tree t)\n {}\n \n /* Note where the definition of a class lives to that template\n    instantiations can use it.  */\n \n void\n-repo_class_defined (t)\n-     tree t;\n+repo_class_defined (tree t)\n {}\n #endif\n \n static tree\n-repo_get_id (t)\n-     tree t;\n+repo_get_id (tree t)\n {\n   if (TYPE_P (t))\n     {\n@@ -119,8 +113,7 @@ repo_get_id (t)\n    to emit it.  */\n \n void\n-repo_template_used (t)\n-     tree t;\n+repo_template_used (tree t)\n {\n   tree id;\n \n@@ -161,8 +154,7 @@ repo_template_used (t)\n /* Note that the vtable for a class has been used, and offer to emit it.  */\n \n static void\n-repo_vtable_used (t)\n-     tree t;\n+repo_vtable_used (tree t)\n {\n   if (! flag_use_repository)\n     return;\n@@ -174,8 +166,7 @@ repo_vtable_used (t)\n    emit it.  */\n \n void\n-repo_inline_used (fn)\n-     tree fn;\n+repo_inline_used (tree fn)\n {\n   if (! flag_use_repository)\n     return;\n@@ -195,16 +186,13 @@ repo_inline_used (fn)\n    emit it.  */\n \n void\n-repo_tinfo_used (ti)\n-     tree ti;\n+repo_tinfo_used (tree ti)\n {\n }\n #endif\n \n void\n-repo_template_instantiated (t, extern_p)\n-     tree t;\n-     int extern_p;\n+repo_template_instantiated (tree t, bool extern_p)\n {\n   if (! extern_p)\n     {\n@@ -217,8 +205,7 @@ repo_template_instantiated (t, extern_p)\n /* Parse a reasonable subset of shell quoting syntax.  */\n \n static char *\n-extract_string (pp)\n-     char **pp;\n+extract_string (char **pp)\n {\n   char *p = *pp;\n   int backquote = 0;\n@@ -248,8 +235,7 @@ extract_string (pp)\n }\n \n const char *\n-get_base_filename (filename)\n-     const char *filename;\n+get_base_filename (const char *filename)\n {\n   char *p = getenv (\"COLLECT_GCC_OPTIONS\");\n   char *output = NULL;\n@@ -279,8 +265,7 @@ get_base_filename (filename)\n }        \n \n static void\n-open_repo_file (filename)\n-     const char *filename;\n+open_repo_file (const char *filename)\n {\n   register const char *p;\n   const char *s = get_base_filename (filename);\n@@ -301,8 +286,7 @@ open_repo_file (filename)\n }\n \n static char *\n-afgets (stream)\n-     FILE *stream;\n+afgets (FILE *stream)\n {\n   int c;\n   while ((c = getc (stream)) != EOF && c != '\\n')\n@@ -314,8 +298,7 @@ afgets (stream)\n }\n \n void\n-init_repo (filename)\n-     const char *filename;\n+init_repo (const char *filename)\n {\n   char *buf;\n \n@@ -367,7 +350,7 @@ init_repo (filename)\n }\n \n static void\n-reopen_repo_file_for_write ()\n+reopen_repo_file_for_write (void)\n {\n   if (repo_file)\n     fclose (repo_file);\n@@ -383,13 +366,13 @@ reopen_repo_file_for_write ()\n /* Emit any pending repos.  */\n \n void\n-finish_repo ()\n+finish_repo (void)\n {\n   tree t;\n-  int repo_changed = 0;\n+  bool repo_changed = false;\n   char *dir, *args;\n \n-  if (! flag_use_repository)\n+  if (!flag_use_repository)\n     return;\n \n   /* Do we have to write out a new info file?  */\n@@ -399,38 +382,38 @@ finish_repo ()\n   \n   for (t = original_repo; t; t = TREE_CHAIN (t))\n     {\n-      if (! IDENTIFIER_REPO_USED (TREE_VALUE (t))\n-\t  || (! TREE_PURPOSE (t) && IDENTIFIER_REPO_CHOSEN (TREE_VALUE (t))))\n+      if (!IDENTIFIER_REPO_USED (TREE_VALUE (t))\n+\t  || (!TREE_PURPOSE (t) && IDENTIFIER_REPO_CHOSEN (TREE_VALUE (t))))\n \t{\n-\t  repo_changed = 1;\n+\t  repo_changed = true;\n \t  break;\n \t}\n       IDENTIFIER_REPO_USED (TREE_VALUE (t)) = 0;\n     }\n \n   /* Are there any templates that are newly used?  */\n   \n-  if (! repo_changed)\n+  if (!repo_changed)\n     for (t = pending_repo; t; t = TREE_CHAIN (t))\n       {\n \tif (IDENTIFIER_REPO_USED (TREE_VALUE (t)))\n \t  {\n-\t    repo_changed = 1;\n+\t    repo_changed = true;\n \t    break;\n \t  }\n       }\n \n   dir = getpwd ();\n   args = getenv (\"COLLECT_GCC_OPTIONS\");\n \n-  if (! repo_changed && pending_repo)\n+  if (!repo_changed && pending_repo)\n     if (strcmp (old_main, main_input_filename) != 0\n \t|| strcmp (old_dir, dir) != 0\n \t|| (args == NULL) != (old_args == NULL)\n \t|| (args && strcmp (old_args, args) != 0))\n-      repo_changed = 1;\n+      repo_changed = true;\n \n-  if (! repo_changed || errorcount || sorrycount)\n+  if (!repo_changed || errorcount || sorrycount)\n     goto out;\n \n   reopen_repo_file_for_write ();"}, {"sha": "1f1356856ad0f24a1440223483733fb9532d1d16", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 62, "deletions": 101, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848eed924951d98a61ad8ad98f24e871e0485cec/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=848eed924951d98a61ad8ad98f24e871e0485cec", "patch": "@@ -83,20 +83,20 @@ static tree get_tinfo_decl_dynamic PARAMS((tree));\n static tree get_tinfo_ptr PARAMS((tree));\n static bool typeid_ok_p PARAMS((void));\n static int qualifier_flags PARAMS((tree));\n-static int target_incomplete_p PARAMS((tree));\n+static bool target_incomplete_p (tree);\n static tree tinfo_base_init PARAMS((tree, tree));\n static tree generic_initializer PARAMS((tree, tree));\n-static tree ptr_initializer PARAMS((tree, tree, int *));\n-static tree ptm_initializer PARAMS((tree, tree, int *));\n+static tree ptr_initializer (tree, tree, bool *);\n+static tree ptm_initializer (tree, tree, bool *);\n static tree dfs_class_hint_mark PARAMS ((tree, void *));\n static tree dfs_class_hint_unmark PARAMS ((tree, void *));\n static int class_hint_flags PARAMS((tree));\n static tree class_initializer PARAMS((tree, tree, tree));\n static tree create_pseudo_type_info PARAMS((const char *, int, ...));\n-static tree get_pseudo_ti_init PARAMS ((tree, tree, int *));\n+static tree get_pseudo_ti_init PARAMS ((tree, tree, bool *));\n static tree get_pseudo_ti_desc PARAMS((tree));\n static void create_tinfo_types PARAMS((void));\n-static int typeinfo_in_lib_p PARAMS((tree));\n+static bool typeinfo_in_lib_p (tree);\n \n static int doing_runtime = 0;\n \f\n@@ -108,7 +108,7 @@ static int doing_runtime = 0;\n    the internal versions of the ABI types.  */\n \n void\n-init_rtti_processing ()\n+init_rtti_processing (void)\n {\n   tree const_type_info_type;\n \n@@ -131,8 +131,7 @@ init_rtti_processing ()\n    expression.  */\n \n static tree\n-build_headof (exp)\n-     tree exp;\n+build_headof (tree exp)\n {\n   tree type = TREE_TYPE (exp);\n   tree offset;\n@@ -163,7 +162,7 @@ build_headof (exp)\n    See libstdc++/exception.cc for __throw_bad_cast */\n \n static tree\n-throw_bad_cast ()\n+throw_bad_cast (void)\n {\n   tree fn = get_identifier (\"__cxa_bad_cast\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n@@ -176,7 +175,7 @@ throw_bad_cast ()\n }\n \n static tree\n-throw_bad_typeid ()\n+throw_bad_typeid (void)\n {\n   tree fn = get_identifier (\"__cxa_bad_typeid\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n@@ -196,8 +195,7 @@ throw_bad_typeid ()\n    otherwise return the static type of the expression.  */\n \n static tree\n-get_tinfo_decl_dynamic (exp)\n-     tree exp;\n+get_tinfo_decl_dynamic (tree exp)\n {\n   tree type;\n   \n@@ -238,7 +236,7 @@ get_tinfo_decl_dynamic (exp)\n }\n \n static bool\n-typeid_ok_p ()\n+typeid_ok_p (void)\n {\n   if (! flag_rtti)\n     {\n@@ -256,8 +254,7 @@ typeid_ok_p ()\n }\n \n tree\n-build_typeid (exp)\n-     tree exp;\n+build_typeid (tree exp)\n {\n   tree cond = NULL_TREE;\n   int nonnull = 0;\n@@ -297,8 +294,7 @@ build_typeid (exp)\n \n /* Generate the NTBS name of a type.  */\n static tree\n-tinfo_name (type)\n-     tree type;\n+tinfo_name (tree type)\n {\n   const char *name;\n   tree name_string;\n@@ -313,8 +309,7 @@ tinfo_name (type)\n    it --- decls in vtables are only used if the vtable is output.  */ \n \n tree\n-get_tinfo_decl (type)\n-     tree type;\n+get_tinfo_decl (tree type)\n {\n   tree name;\n   tree d;\n@@ -375,8 +370,7 @@ get_tinfo_decl (type)\n    cast to the language defined type.  */\n \n static tree\n-get_tinfo_ptr (type)\n-     tree type;\n+get_tinfo_ptr (tree type)\n {\n   tree exp = get_tinfo_decl (type);\n   \n@@ -390,8 +384,7 @@ get_tinfo_ptr (type)\n /* Return the type_info object for TYPE.  */\n \n tree\n-get_typeid (type)\n-     tree type;\n+get_typeid (tree type)\n {\n   if (type == error_mark_node || !typeid_ok_p ())\n     return error_mark_node;\n@@ -422,8 +415,7 @@ get_typeid (type)\n    RESULT, it must have previously had a save_expr applied to it.  */\n \n static tree\n-ifnonnull (test, result)\n-     tree test, result;\n+ifnonnull (tree test, tree result)\n {\n   return build (COND_EXPR, TREE_TYPE (result),\n \t\tbuild (EQ_EXPR, boolean_type_node, test, integer_zero_node),\n@@ -435,8 +427,7 @@ ifnonnull (test, result)\n    paper.  */\n \n static tree\n-build_dynamic_cast_1 (type, expr)\n-     tree type, expr;\n+build_dynamic_cast_1 (tree type, tree expr)\n {\n   enum tree_code tc = TREE_CODE (type);\n   tree exprtype = TREE_TYPE (expr);\n@@ -683,8 +674,7 @@ build_dynamic_cast_1 (type, expr)\n }\n \n tree\n-build_dynamic_cast (type, expr)\n-     tree type, expr;\n+build_dynamic_cast (tree type, tree expr)\n {\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -698,8 +688,7 @@ build_dynamic_cast (type, expr)\n /* Return the runtime bit mask encoding the qualifiers of TYPE.  */\n \n static int\n-qualifier_flags (type)\n-     tree type;\n+qualifier_flags (tree type)\n {\n   int flags = 0;\n   int quals = cp_type_quals (type);\n@@ -713,26 +702,25 @@ qualifier_flags (type)\n   return flags;\n }\n \n-/* Return nonzero, if the pointer chain TYPE ends at an incomplete type, or\n+/* Return true, if the pointer chain TYPE ends at an incomplete type, or\n    contains a pointer to member of an incomplete class.  */\n \n-static int\n-target_incomplete_p (type)\n-     tree type;\n+static bool\n+target_incomplete_p (tree type)\n {\n   while (TREE_CODE (type) == POINTER_TYPE)\n     if (TYPE_PTRMEM_P (type))\n       {\n         if (!COMPLETE_TYPE_P (TYPE_PTRMEM_CLASS_TYPE (type)))\n-          return 1;\n+          return true;\n         type = TYPE_PTRMEM_POINTED_TO_TYPE (type);\n       }\n     else\n       type = TREE_TYPE (type);\n   if (!COMPLETE_OR_VOID_TYPE_P (type))\n-    return 1;\n+    return true;\n   \n-  return 0;\n+  return false;\n }\n \n /* Return a CONSTRUCTOR for the common part of the type_info objects. This\n@@ -742,9 +730,7 @@ target_incomplete_p (type)\n    as comdat, because of pointers to incomplete.) */\n \n static tree\n-tinfo_base_init (desc, target)\n-     tree desc;\n-     tree target;\n+tinfo_base_init (tree desc, tree target)\n {\n   tree init = NULL_TREE;\n   tree name_decl;\n@@ -826,9 +812,7 @@ tinfo_base_init (desc, target)\n    additional fields to the type_info base.  */\n \n static tree\n-generic_initializer (desc, target)\n-     tree desc;\n-     tree target;\n+generic_initializer (tree desc, tree target)\n {\n   tree init = tinfo_base_init (desc, target);\n   \n@@ -842,20 +826,17 @@ generic_initializer (desc, target)\n    which adds target type and qualifier flags members to the type_info base.  */\n \n static tree\n-ptr_initializer (desc, target, non_public_ptr)\n-     tree desc;\n-     tree target;\n-     int *non_public_ptr;\n+ptr_initializer (tree desc, tree target, bool *non_public_ptr)\n {\n   tree init = tinfo_base_init (desc, target);\n   tree to = TREE_TYPE (target);\n   int flags = qualifier_flags (to);\n-  int incomplete = target_incomplete_p (to);\n+  bool incomplete = target_incomplete_p (to);\n   \n   if (incomplete)\n     {\n       flags |= 8;\n-      *non_public_ptr = 1;\n+      *non_public_ptr = true;\n     }\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n@@ -873,26 +854,23 @@ ptr_initializer (desc, target, non_public_ptr)\n    base.  */\n \n static tree\n-ptm_initializer (desc, target, non_public_ptr)\n-     tree desc;\n-     tree target;\n-     int *non_public_ptr;\n+ptm_initializer (tree desc, tree target, bool *non_public_ptr)\n {\n   tree init = tinfo_base_init (desc, target);\n   tree to = TYPE_PTRMEM_POINTED_TO_TYPE (target);\n   tree klass = TYPE_PTRMEM_CLASS_TYPE (target);\n   int flags = qualifier_flags (to);\n-  int incomplete = target_incomplete_p (to);\n+  bool incomplete = target_incomplete_p (to);\n   \n   if (incomplete)\n     {\n       flags |= 0x8;\n-      *non_public_ptr = 1;\n+      *non_public_ptr = true;\n     }\n   if (!COMPLETE_TYPE_P (klass))\n     {\n       flags |= 0x10;\n-      *non_public_ptr = 1;\n+      *non_public_ptr = true;\n     }\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n@@ -913,9 +891,7 @@ ptm_initializer (desc, target, non_public_ptr)\n    possible for a type to be both a virtual and non-virtual base.  */\n \n static tree\n-dfs_class_hint_mark (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_class_hint_mark (tree binfo, void *data)\n {\n   tree basetype = BINFO_TYPE (binfo);\n   int *hint = (int *) data;\n@@ -942,9 +918,7 @@ dfs_class_hint_mark (binfo, data)\n /* Clear the base's dfs marks, after searching for duplicate bases.  */\n \n static tree\n-dfs_class_hint_unmark (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_class_hint_unmark (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   tree basetype = BINFO_TYPE (binfo);\n   \n@@ -956,8 +930,7 @@ dfs_class_hint_unmark (binfo, data)\n /* Determine the hint flags describing the features of a class's hierarchy.  */\n \n static int\n-class_hint_flags (type)\n-     tree type;\n+class_hint_flags (tree type)\n {\n   int hint_flags = 0;\n   int i;\n@@ -980,10 +953,7 @@ class_hint_flags (type)\n    which adds hint flags and TRAIL initializers to the type_info base.  */\n \n static tree\n-class_initializer (desc, target, trail)\n-     tree desc;\n-     tree target;\n-     tree trail;\n+class_initializer (tree desc, tree target, tree trail)\n {\n   tree init = tinfo_base_init (desc, target);\n   \n@@ -993,12 +963,11 @@ class_initializer (desc, target, trail)\n   return init;  \n }\n \n-/* Returns nonzero if the typeinfo for type should be placed in\n+/* Returns true if the typeinfo for type should be placed in\n    the runtime library.  */\n \n-static int\n-typeinfo_in_lib_p (type)\n-     tree type;\n+static bool\n+typeinfo_in_lib_p (tree type)\n {\n   /* The typeinfo objects for `T*' and `const T*' are in the runtime\n      library for simple types T.  */\n@@ -1014,10 +983,10 @@ typeinfo_in_lib_p (type)\n     case CHAR_TYPE:\n     case REAL_TYPE:\n     case VOID_TYPE:\n-      return 1;\n+      return true;\n     \n     default:\n-      return 0;\n+      return false;\n     }\n }\n \n@@ -1028,10 +997,7 @@ typeinfo_in_lib_p (type)\n    types will be completed.  */\n \n static tree\n-get_pseudo_ti_init (type, var_desc, non_public_p)\n-     tree type;\n-     tree var_desc;\n-     int *non_public_p;\n+get_pseudo_ti_init (tree type, tree var_desc, bool *non_public_p)\n {\n   my_friendly_assert (at_eof, 20021120);\n   switch (TREE_CODE (type))\n@@ -1059,7 +1025,7 @@ get_pseudo_ti_init (type, var_desc, non_public_p)\n         {\n \t  if (!COMPLETE_TYPE_P (type))\n \t    /* Emit a non-public class_type_info.  */\n-\t    *non_public_p = 1;\n+\t    *non_public_p = true;\n \t  return class_initializer (var_desc, type, NULL_TREE);\n         }\n       else if (var_desc == si_class_desc_type_node)\n@@ -1151,7 +1117,7 @@ get_pseudo_ti_init (type, var_desc, non_public_p)\n    NULL.  */\n \n static tree\n-create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n+create_pseudo_type_info (const char *real_name, int ident, ...)\n {\n   tree pseudo_type;\n   char *pseudo_name;\n@@ -1199,8 +1165,7 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n    translation unit.  */\n \n static tree\n-get_pseudo_ti_desc (type)\n-     tree type;\n+get_pseudo_ti_desc (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -1283,7 +1248,7 @@ get_pseudo_ti_desc (type)\n    varable definitions.  */\n \n static void\n-create_tinfo_types ()\n+create_tinfo_types (void)\n {\n   my_friendly_assert (!ti_desc_type_node, 20020609);\n \n@@ -1385,7 +1350,7 @@ create_tinfo_types ()\n    destructor is defined, then the runtime is being built.  */\n \n void\n-emit_support_tinfos ()\n+emit_support_tinfos (void)\n {\n   static tree *const fundamentals[] =\n   {\n@@ -1437,13 +1402,11 @@ emit_support_tinfos ()\n     }\n }\n \n-/* Return nonzero, iff T is a type_info variable which has not had a\n+/* Return true, iff T is a type_info variable which has not had a\n    definition emitted for it.  */\n \n-int\n-unemitted_tinfo_decl_p (t, data)\n-     tree t;\n-     void *data ATTRIBUTE_UNUSED;\n+bool\n+unemitted_tinfo_decl_p (tree t, void *data ATTRIBUTE_UNUSED)\n {\n   if (/* It's a var decl */\n       TREE_CODE (t) == VAR_DECL\n@@ -1459,33 +1422,31 @@ unemitted_tinfo_decl_p (t, data)\n       && TYPE_FIELDS (TREE_TYPE (t))\n       /* which is our pseudo type info */\n       && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (t))) == ti_desc_type_node)\n-    return 1;\n-  return 0;\n+    return true;\n+  return false;\n }\n \n /* Finish a type info decl. DECL_PTR is a pointer to an unemitted\n    tinfo decl.  Determine whether it needs emitting, and if so\n    generate the initializer.  */\n \n-int\n-emit_tinfo_decl (decl_ptr, data)\n-     tree *decl_ptr;\n-     void *data ATTRIBUTE_UNUSED;\n+bool\n+emit_tinfo_decl (tree *decl_ptr, void *data ATTRIBUTE_UNUSED)\n {\n   tree decl = *decl_ptr;\n   tree type = TREE_TYPE (DECL_NAME (decl));\n-  int non_public;\n+  bool non_public;\n   int in_library = typeinfo_in_lib_p (type);\n   tree var_desc, var_init;\n   \n   import_export_tinfo (decl, type, in_library);\n   if (DECL_REALLY_EXTERN (decl) || !DECL_NEEDED_P (decl))\n-    return 0;\n+    return false;\n \n   if (!doing_runtime && in_library)\n-    return 0;\n+    return false;\n \n-  non_public = 0;\n+  non_public = false;\n   var_desc = get_pseudo_ti_desc (type);\n   var_init = get_pseudo_ti_init (type, var_desc, &non_public);\n   \n@@ -1501,5 +1462,5 @@ emit_tinfo_decl (decl_ptr, data)\n   /* Say we've dealt with it.  */\n   TREE_TYPE (DECL_NAME (decl)) = NULL_TREE;\n \n-  return 1;\n+  return true;\n }"}]}