{"sha": "31bc9eba585e7b705173fe4d7dfa552a452a0669", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFiYzllYmE1ODVlN2I3MDUxNzNmZTRkN2RmYTU1MmE0NTJhMDY2OQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-07-22T23:41:48Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-07-22T23:41:48Z"}, "message": "* sparc/sparc.c (gen_v9_scc): Handle early clobber of result.\n\nFrom-SVN: r14519", "tree": {"sha": "5438ea25a416d81f99f3088f177c31969f9eeb29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5438ea25a416d81f99f3088f177c31969f9eeb29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31bc9eba585e7b705173fe4d7dfa552a452a0669", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31bc9eba585e7b705173fe4d7dfa552a452a0669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31bc9eba585e7b705173fe4d7dfa552a452a0669", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31bc9eba585e7b705173fe4d7dfa552a452a0669/comments", "author": null, "committer": null, "parents": [{"sha": "7671d67b18474ccaf6e8422bf48f6fa67694bbc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7671d67b18474ccaf6e8422bf48f6fa67694bbc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7671d67b18474ccaf6e8422bf48f6fa67694bbc4"}], "stats": {"total": 56, "additions": 27, "deletions": 29}, "files": [{"sha": "ead4da0314446852b6c353c0a7927017de50aecf", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31bc9eba585e7b705173fe4d7dfa552a452a0669/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31bc9eba585e7b705173fe4d7dfa552a452a0669/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=31bc9eba585e7b705173fe4d7dfa552a452a0669", "patch": "@@ -967,77 +967,76 @@ gen_compare_reg (code, x, y)\n    This function is needed to turn\n \n \t   (set (reg:SI 110)\n-\t       (gt (reg:CCX 0 %g0)\n+\t       (gt (reg:CCX 100 %icc)\n \t           (const_int 0)))\n    into\n \t   (set (reg:SI 110)\n-\t       (gt:DI (reg:CCX 0 %g0)\n+\t       (gt:DI (reg:CCX 100 %icc)\n \t           (const_int 0)))\n \n    IE: The instruction recognizer needs to see the mode of the comparison to\n    find the right instruction. We could use \"gt:DI\" right in the\n    define_expand, but leaving it out allows us to handle DI, SI, etc.\n \n    We refer to the global sparc compare operands sparc_compare_op0 and\n-   sparc_compare_op1.  \n-\n-   ??? Some of this is outdated as the scc insns set the mode of the\n-   comparison now.\n-\n-   ??? We optimize for the case where op1 is 0 and the comparison allows us to\n-   use the \"movrCC\" insns. This reduces the generated code from three to two\n-   insns.  This way seems too brute force though.  Is there a more elegant way\n-   to achieve the same effect?\n-*/\n+   sparc_compare_op1.  */\n \n int\n gen_v9_scc (compare_code, operands)\n      enum rtx_code compare_code;\n      register rtx *operands;\n {\n-  rtx temp;\n+  rtx temp, op0, op1;\n \n-  /* It might be that we'll never be called if this is true,\n-     but keep this here for documentation at least.  */\n   if (! TARGET_ARCH64\n       && (GET_MODE (sparc_compare_op0) == DImode\n \t  || GET_MODE (operands[0]) == DImode))\n     return 0;\n \n+  /* Handle the case where operands[0] == sparc_compare_op0.\n+     We \"early clobber\" the result.  */\n+  if (REGNO (operands[0]) == REGNO (sparc_compare_op0))\n+    {\n+      op0 = gen_reg_rtx (GET_MODE (sparc_compare_op0));\n+      emit_move_insn (op0, sparc_compare_op0);\n+    }\n+  else\n+    op0 = sparc_compare_op0;\n+  /* For consistency in the following.  */\n+  op1 = sparc_compare_op1;\n+\n   /* Try to use the movrCC insns.  */\n   if (TARGET_ARCH64\n-      && GET_MODE_CLASS (GET_MODE (sparc_compare_op0)) == MODE_INT\n-      && sparc_compare_op1 == const0_rtx\n+      && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n+      && op1 == const0_rtx\n       && v9_regcmp_p (compare_code))\n     {\n       /* Special case for op0 != 0.  This can be done with one instruction if\n-\t op0 can be clobbered.  We store to a temp, and then clobber the temp,\n-\t but the combiner will remove the first insn.  */\n+\t operands[0] == sparc_compare_op0.  We don't assume they are equal\n+\t now though.  */\n \n       if (compare_code == NE\n \t  && GET_MODE (operands[0]) == DImode\n-\t  && GET_MODE (sparc_compare_op0) == DImode)\n+\t  && GET_MODE (op0) == DImode)\n \t{\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operands[0], sparc_compare_op0));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operands[0], op0));\n \t  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n \t\t\t      gen_rtx (IF_THEN_ELSE, DImode,\n \t\t\t\t       gen_rtx (compare_code, DImode,\n-\t\t\t\t\t\tsparc_compare_op0, const0_rtx),\n+\t\t\t\t\t\top0, const0_rtx),\n \t\t\t\t       const1_rtx,\n \t\t\t\t       operands[0])));\n \t  return 1;\n \t}\n \n       emit_insn (gen_rtx (SET, VOIDmode, operands[0], const0_rtx));\n-      if (GET_MODE (sparc_compare_op0) != DImode)\n+      if (GET_MODE (op0) != DImode)\n \t{\n \t  temp = gen_reg_rtx (DImode);\n-\t  convert_move (temp, sparc_compare_op0, 0);\n+\t  convert_move (temp, op0, 0);\n \t}\n       else\n-\t{\n-\t  temp = sparc_compare_op0;\n-\t}\n+\ttemp = op0;\n       emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n \t\t\t  gen_rtx (IF_THEN_ELSE, GET_MODE (operands[0]),\n \t\t\t\t   gen_rtx (compare_code, DImode,\n@@ -1048,8 +1047,7 @@ gen_v9_scc (compare_code, operands)\n     }\n   else\n     {\n-      operands[1] = gen_compare_reg (compare_code,\n-\t\t\t\t     sparc_compare_op0, sparc_compare_op1);\n+      operands[1] = gen_compare_reg (compare_code, op0, op1);\n \n       switch (GET_MODE (operands[1]))\n \t{"}]}