{"sha": "8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY0NGE2NzNkMzJhOGZlZjUyY2MzNGQ0ZGQwZGM4YjY3ODhmNTE2ZQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2009-04-28T08:08:25Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2009-04-28T08:08:25Z"}, "message": "tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Use REPORT_VECTORIZED_LOCATIONS instead REPORT_VECTORIZED_LOOPS.\n\n\n\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n\tUse REPORT_VECTORIZED_LOCATIONS instead \n\tREPORT_VECTORIZED_LOOPS.\n\t* tree-vectorizer.c (vect_verbosity_level): Make static.\n\t(vect_loop_location): Rename to vect_location.\n\t(vect_set_verbosity_level): Update comment.\n\t(vect_set_dump_settings): Use REPORT_VECTORIZED_LOCATIONS\n\tand vect_location.\n\t(vectorize_loops): Fix comment. Use REPORT_VECTORIZED_LOCATIONS\n\tand vect_location. Use REPORT_UNVECTORIZED_LOCATIONS\n\tinstead REPORT_UNVECTORIZED_LOOPS.\n\t* tree-vectorizer.h (enum vect_def_type): Rename vect_invariant_def and\n\tvect_loop_def to vect_external_def and vect_internal_def.\n\t(enum verbosity_levels): Rename REPORT_VECTORIZED_LOOPS\n        and REPORT_UNVECTORIZED_LOOPS to \n\tREPORT_VECTORIZED_LOCATIONS and \n\tREPORT_UNVECTORIZED_LOCATIONS.\n\t(enum vect_relevant): Update comment. Rename vect_unused_in_loop\n\tand vect_used_in_loop and to vect_unused_in_scope and \n\tvect_used_in_scope.\n\t(STMT_VINFO_RELEVANT_P): Use vect_unused_in_scope.\n\t(vect_verbosity_level): Remove declaration.\n\t(vect_analyze_operations): Likewise.\n\t(vect_analyze_stmt): Declare.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Use\n\tREPORT_UNVECTORIZED_LOCATIONS.\n\t(vect_get_loop_niters): Fix indentation.\n\t(vect_analyze_loop_form): Use REPORT_UNVECTORIZED_LOCATIONS.\n\t(vect_analyze_loop_operations): New function.\n\t(vect_analyze_loop): Call vect_analyze_loop_operations instead of\n\tvect_analyze_operations.\n\t(vect_is_simple_reduction): Use new names.\n\t(vectorizable_live_operation, vect_transform_loop): Likewise.\n\t* tree-vect-data-refs.c (vect_check_interleaving): Add a return value to\n\tspecify whether the data references can be a part of interleaving chain.\n\t(vect_analyze_data_ref_dependence): Use new names.\n\t(vect_analyze_data_refs_alignment, vect_analyze_data_refs): Likewise.\n\t(vect_create_addr_base_for_vector_ref): Remove redundant code.\n\t* tree-vect-patterns.c (widened_name_p): Use new names.\n\t(vect_recog_dot_prod_pattern): Likewise.\n\t* tree-vect-stmts.c (vect_stmt_relevant_p): Use new names.\n\t(process_use, vect_mark_stmts_to_be_vectorized, \n\tvect_model_simple_cost, vect_model_store_cost,\n\tvect_get_vec_def_for_operand, vect_get_vec_def_for_stmt_copy,\n\tvectorizable_call, vectorizable_conversion, vectorizable_assignment,\n\tvectorizable_operation, vectorizable_type_demotion,\n\tvectorizable_type_promotion, vectorizable_store, vectorizable_load,\n\tvectorizable_condition): Likewise.\n\t(vect_analyze_operations): Split into vect_analyze_loop_operations\n\tand ...\n\t(vect_analyze_stmt): ... new function.\n\t(new_stmt_vec_info): Use new names.\n\t(vect_is_simple_use): Use new names and fix comment.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Use new names.\n\t(vect_build_slp_tree, vect_analyze_slp, vect_schedule_slp): Likewise.\n\nFrom-SVN: r146875", "tree": {"sha": "3bdf6e3f659927c90efbcc5b6f34fb955ee5595b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bdf6e3f659927c90efbcc5b6f34fb955ee5595b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b91322f2ba88548f5137cea907c85cd74b0b90a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91322f2ba88548f5137cea907c85cd74b0b90a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91322f2ba88548f5137cea907c85cd74b0b90a8"}], "stats": {"total": 932, "additions": 506, "deletions": 426}, "files": [{"sha": "4ca02a38b31426568c837c8f1c0319dc196afde6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -1,3 +1,60 @@\n+2009-04-28  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n+\tUse REPORT_VECTORIZED_LOCATIONS instead \n+\tREPORT_VECTORIZED_LOOPS.\n+\t* tree-vectorizer.c (vect_verbosity_level): Make static.\n+\t(vect_loop_location): Rename to vect_location.\n+\t(vect_set_verbosity_level): Update comment.\n+\t(vect_set_dump_settings): Use REPORT_VECTORIZED_LOCATIONS\n+\tand vect_location.\n+\t(vectorize_loops): Fix comment. Use REPORT_VECTORIZED_LOCATIONS\n+\tand vect_location. Use REPORT_UNVECTORIZED_LOCATIONS\n+\tinstead REPORT_UNVECTORIZED_LOOPS.\n+\t* tree-vectorizer.h (enum vect_def_type): Rename vect_invariant_def and\n+\tvect_loop_def to vect_external_def and vect_internal_def.\n+\t(enum verbosity_levels): Rename REPORT_VECTORIZED_LOOPS\n+        and REPORT_UNVECTORIZED_LOOPS to REPORT_VECTORIZED_LOCATIONS and \n+\tREPORT_UNVECTORIZED_LOCATIONS.\n+\t(enum vect_relevant): Update comment. Rename vect_unused_in_loop\n+\tand vect_used_in_loop and to vect_unused_in_scope and \n+\tvect_used_in_scope.\n+\t(STMT_VINFO_RELEVANT_P): Use vect_unused_in_scope.\n+\t(vect_verbosity_level): Remove declaration.\n+\t(vect_analyze_operations): Likewise.\n+\t(vect_analyze_stmt): Declare.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Use\n+\tREPORT_UNVECTORIZED_LOCATIONS.\n+\t(vect_get_loop_niters): Fix indentation.\n+\t(vect_analyze_loop_form): Use REPORT_UNVECTORIZED_LOCATIONS.\n+\t(vect_analyze_loop_operations): New function.\n+\t(vect_analyze_loop): Call vect_analyze_loop_operations instead of\n+\tvect_analyze_operations.\n+\t(vect_is_simple_reduction): Use new names.\n+\t(vectorizable_live_operation, vect_transform_loop): Likewise.\n+\t* tree-vect-data-refs.c (vect_check_interleaving): Add a return value to\n+\tspecify whether the data references can be a part of interleaving chain.\n+\t(vect_analyze_data_ref_dependence): Use new names.\n+\t(vect_analyze_data_refs_alignment, vect_analyze_data_refs): Likewise.\n+\t(vect_create_addr_base_for_vector_ref): Remove redundant code.\n+\t* tree-vect-patterns.c (widened_name_p): Use new names.\n+\t(vect_recog_dot_prod_pattern): Likewise.\n+\t* tree-vect-stmts.c (vect_stmt_relevant_p): Use new names.\n+\t(process_use, vect_mark_stmts_to_be_vectorized, \n+\tvect_model_simple_cost, vect_model_store_cost,\n+\tvect_get_vec_def_for_operand, vect_get_vec_def_for_stmt_copy,\n+\tvectorizable_call, vectorizable_conversion, vectorizable_assignment,\n+\tvectorizable_operation, vectorizable_type_demotion,\n+\tvectorizable_type_promotion, vectorizable_store, vectorizable_load,\n+\tvectorizable_condition): Likewise.\n+\t(vect_analyze_operations): Split into vect_analyze_loop_operations\n+\tand ...\n+\t(vect_analyze_stmt): ... new function.\n+\t(new_stmt_vec_info): Use new names.\n+\t(vect_is_simple_use): Use new names and fix comment.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Use new names.\n+\t(vect_build_slp_tree, vect_analyze_slp, vect_schedule_slp): Likewise.\n+\n 2009-04-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/39911"}, {"sha": "a117898e146bb5b46b4a6d3144098eb48b2b2827", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -321,7 +321,7 @@ vect_equal_offsets (tree offset1, tree offset2)\n    Check if DRA and DRB are a part of interleaving. In case they are, insert\n    DRA and DRB in an interleaving chain.  */\n \n-static void\n+static bool \n vect_check_interleaving (struct data_reference *dra,\n \t\t\t struct data_reference *drb)\n {\n@@ -337,20 +337,21 @@ vect_check_interleaving (struct data_reference *dra,\n       || !vect_equal_offsets (DR_OFFSET (dra), DR_OFFSET (drb))\n       || !tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb)) \n       || DR_IS_READ (dra) != DR_IS_READ (drb))\n-    return;\n+    return false;\n \n   /* Check:\n      1. data-refs are of the same type\n      2. their steps are equal\n-     3. the step is greater than the difference between data-refs' inits  */\n+     3. the step (if greater than zero) is greater than the difference between \n+        data-refs' inits.  */\n   type_size_a = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))));\n   type_size_b = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n \n   if (type_size_a != type_size_b\n       || tree_int_cst_compare (DR_STEP (dra), DR_STEP (drb))\n       || !types_compatible_p (TREE_TYPE (DR_REF (dra)), \n                               TREE_TYPE (DR_REF (drb))))\n-    return;\n+    return false;\n \n   init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n   init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n@@ -363,7 +364,7 @@ vect_check_interleaving (struct data_reference *dra,\n       diff_mod_size = (init_a - init_b) % type_size_a;\n \n       if ((init_a - init_b) > step)\n-         return; \n+         return false; \n \n       if (diff_mod_size == 0)\n \t{\n@@ -375,7 +376,7 @@ vect_check_interleaving (struct data_reference *dra,\n \t      fprintf (vect_dump, \" and \");\n \t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n \t    }\n-\t  return;\n+\t  return true;\n \t} \n     }\n   else \n@@ -385,7 +386,7 @@ vect_check_interleaving (struct data_reference *dra,\n       diff_mod_size = (init_b - init_a) % type_size_a;\n \n       if ((init_b - init_a) > step)\n-         return;\n+         return false;\n \n       if (diff_mod_size == 0)\n \t{\n@@ -397,9 +398,11 @@ vect_check_interleaving (struct data_reference *dra,\n \t      fprintf (vect_dump, \" and \");\n \t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n \t    }\n-\t  return;\n+\t  return true;\n \t} \n     }\n+    \n+  return false;\n }\n \n /* Check if data references pointed by DR_I and DR_J are same or\n@@ -584,7 +587,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  continue;\n \t}\n \n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t{\n \t  fprintf (vect_dump,\n \t\t   \"not vectorized, possible dependence \"\n@@ -868,7 +871,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n             {\n               if (DR_IS_READ (dr))\n                 fprintf (vect_dump, \n@@ -1347,14 +1350,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n bool\n-vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n+vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo) \n {\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs_alignment ===\");\n \n   if (!vect_compute_data_refs_alignment (loop_vinfo))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \tfprintf (vect_dump, \n \t\t \"not vectorized: can't calculate alignment for data ref.\");\n       return false;\n@@ -1663,7 +1666,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     if (!vect_analyze_data_ref_access (dr))\n       {\n-\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t  fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n \treturn false;\n       }\n@@ -1787,7 +1790,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n    \n       if (!dr || !DR_REF (dr))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t    fprintf (vect_dump, \"not vectorized: unhandled data-ref \");\n           return false;\n         }\n@@ -1799,7 +1802,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n       if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr) || !DR_INIT (dr)\n           || !DR_STEP (dr))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n             {\n               fprintf (vect_dump, \"not vectorized: data ref analysis failed \");\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n@@ -1809,7 +1812,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n       if (TREE_CODE (DR_BASE_ADDRESS (dr)) == INTEGER_CST)\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n             fprintf (vect_dump, \"not vectorized: base addr of dr is a \"\n                      \"constant\");\n           return false;\n@@ -1930,14 +1933,15 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \n       if (STMT_VINFO_DATA_REF (stmt_info))\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n             {\n               fprintf (vect_dump,\n                        \"not vectorized: more than one data ref in stmt: \");\n               print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n             }\n           return false;\n         }\n+\n       STMT_VINFO_DATA_REF (stmt_info) = dr;\n      \n       /* Set vectype for STMT.  */\n@@ -1946,7 +1950,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n                 get_vectype_for_scalar_type (scalar_type);\n       if (!STMT_VINFO_VECTYPE (stmt_info)) \n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n             {\n               fprintf (vect_dump,\n                        \"not vectorized: no vectype for stmt: \");\n@@ -2056,7 +2060,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n   gimple_seq seq = NULL;\n   tree base_offset = unshare_expr (DR_OFFSET (dr));\n   tree init = unshare_expr (DR_INIT (dr));\n-  tree vect_ptr_type, addr_expr2;\n+  tree vect_ptr_type;\n   tree step = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n \n   gcc_assert (loop);\n@@ -2108,22 +2112,20 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n \n   vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));\n \n-  /* addr_expr = addr_base */\n+  vec_stmt = fold_convert (vect_ptr_type, addr_base);\n   addr_expr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n                                      get_name (base_name));\n+\n   add_referenced_var (addr_expr);\n-  vec_stmt = fold_convert (vect_ptr_type, addr_base);\n-  addr_expr2 = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n-                                     get_name (base_name));\n-  add_referenced_var (addr_expr2);\n-  vec_stmt = force_gimple_operand (vec_stmt, &seq, false, addr_expr2);\n+  vec_stmt = force_gimple_operand (vec_stmt, &seq, false, addr_expr);\n   gimple_seq_add_seq (new_stmt_list, seq);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"created \");\n       print_generic_expr (vect_dump, vec_stmt, TDF_SLIM);\n     }\n+\n   return vec_stmt;\n }\n "}, {"sha": "3d7f5938afa81da542c4fa8eb1e79e3282b7fd77", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -2290,7 +2290,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n       else\n \t*cond_expr = part_cond_expr;\n     }\n-    if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n+    if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n       fprintf (vect_dump, \"created %u versioning for alias checks.\\n\",\n                VEC_length (ddr_p, may_alias_ddrs));\n "}, {"sha": "a7c6caef0a7133c3e3ef06431db3c6242dce1492", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 254, "deletions": 23, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -212,7 +212,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t\t    {\n \t\t      fprintf (vect_dump,\n \t\t               \"not vectorized: unsupported data-type \");\n@@ -262,7 +262,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t\t{\n \t          fprintf (vect_dump, \"not vectorized: irregular stmt.\");\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n@@ -272,7 +272,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t  if (VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))))\n \t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t        {\n \t          fprintf (vect_dump, \"not vectorized: vector stmt in loop:\");\n \t          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n@@ -306,7 +306,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n-\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t\t    {\n \t\t      fprintf (vect_dump, \n \t\t\t       \"not vectorized: unsupported data-type \");\n@@ -339,7 +339,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n     fprintf (vect_dump, \"vectorization factor = %d\", vectorization_factor);\n   if (vectorization_factor <= 1)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n         fprintf (vect_dump, \"not vectorized: unsupported data-type\");\n       return false;\n     }\n@@ -533,7 +533,6 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n     vect_analyze_scalar_cycles_1 (loop_vinfo, loop->inner);\n }\n \n-\n /* Function vect_get_loop_niters.\n \n    Determine how many iterations the loop is executed.\n@@ -557,10 +556,10 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n       *number_of_iterations = niters;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n-\t{\n-\t  fprintf (vect_dump, \"==> get_loop_niters:\" );\n-\t  print_generic_expr (vect_dump, *number_of_iterations, TDF_SLIM);\n-\t}\n+        {\n+          fprintf (vect_dump, \"==> get_loop_niters:\" );\n+          print_generic_expr (vect_dump, *number_of_iterations, TDF_SLIM);\n+        }\n     }\n \n   return get_loop_exit_condition (loop);\n@@ -1025,7 +1024,7 @@ vect_analyze_loop_form (struct loop *loop)\n     }\n   else if (TREE_INT_CST_LOW (number_of_iterations) == 0)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n         fprintf (vect_dump, \"not vectorized: number of iterations = 0.\");\n       if (inner_loop_vinfo)\n         destroy_loop_vec_info (inner_loop_vinfo, false);\n@@ -1047,6 +1046,237 @@ vect_analyze_loop_form (struct loop *loop)\n   return loop_vinfo;\n }\n \n+\n+/* Function vect_analyze_loop_operations.\n+\n+   Scan the loop stmts and make sure they are all vectorizable.  */\n+\n+static bool\n+vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+  int nbbs = loop->num_nodes;\n+  gimple_stmt_iterator si;\n+  unsigned int vectorization_factor = 0;\n+  int i;\n+  gimple phi;\n+  stmt_vec_info stmt_info;\n+  bool need_to_vectorize = false;\n+  int min_profitable_iters;\n+  int min_scalar_loop_bound;\n+  unsigned int th;\n+  bool only_slp_in_loop = true, ok;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"=== vect_analyze_loop_operations ===\");\n+\n+  gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+        {\n+          phi = gsi_stmt (si);\n+          ok = true;\n+\n+          stmt_info = vinfo_for_stmt (phi);\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"examining phi: \");\n+              print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+            }\n+\n+          if (! is_loop_header_bb_p (bb))\n+            {\n+              /* inner-loop loop-closed exit phi in outer-loop vectorization\n+                 (i.e. a phi in the tail of the outer-loop).\n+                 FORNOW: we currently don't support the case that these phis\n+                 are not used in the outerloop, cause this case requires\n+                 to actually do something here.  */\n+              if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+                  || STMT_VINFO_LIVE_P (stmt_info))\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    fprintf (vect_dump,\n+                             \"Unsupported loop-closed phi in outer-loop.\");\n+                  return false;\n+                }\n+              continue;\n+            }\n+\n+          gcc_assert (stmt_info);\n+\n+          if (STMT_VINFO_LIVE_P (stmt_info))\n+            {\n+              /* FORNOW: not yet supported.  */\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+                fprintf (vect_dump, \"not vectorized: value used after loop.\");\n+              return false;\n+            }\n+\n+          if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_scope\n+              && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n+            {\n+              /* A scalar-dependence cycle that we don't support.  */\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+                fprintf (vect_dump, \"not vectorized: scalar dependence cycle.\");\n+              return false;\n+            }\n+\n+          if (STMT_VINFO_RELEVANT_P (stmt_info))\n+            {\n+              need_to_vectorize = true;\n+              if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n+                ok = vectorizable_induction (phi, NULL, NULL);\n+            }\n+\n+          if (!ok)\n+            {\n+              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+                {\n+                  fprintf (vect_dump,\n+                           \"not vectorized: relevant phi not supported: \");\n+                  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n+                }\n+              return false;\n+            }\n+        }\n+\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+        {\n+          gimple stmt = gsi_stmt (si);\n+          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+          gcc_assert (stmt_info);\n+\n+\t  if (!vect_analyze_stmt (stmt, &need_to_vectorize))\n+\t    return false;\n+\n+          if (STMT_VINFO_RELEVANT_P (stmt_info) && !PURE_SLP_STMT (stmt_info))\n+            /* STMT needs both SLP and loop-based vectorization.  */\n+            only_slp_in_loop = false;\n+        } \n+    } /* bbs */\n+\n+  /* All operations in the loop are either irrelevant (deal with loop\n+     control, or dead), or only used outside the loop and can be moved\n+     out of the loop (e.g. invariants, inductions).  The loop can be\n+     optimized away by scalar optimizations.  We're better off not\n+     touching this loop.  */\n+  if (!need_to_vectorize)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump,\n+                 \"All the computation can be taken out of the loop.\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump,\n+                 \"not vectorized: redundant loop. no profit to vectorize.\");\n+      return false;\n+    }\n+\n+  /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n+     vectorization factor of the loop is the unrolling factor required by the\n+     SLP instances.  If that unrolling factor is 1, we say, that we perform\n+     pure SLP on loop - cross iteration parallelism is not exploited.  */\n+  if (only_slp_in_loop)\n+    vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n+  else\n+    vectorization_factor = least_common_multiple (vectorization_factor,\n+                                LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n+\n+  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump,\n+        \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n+        vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && (LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: iteration count too small.\");\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump,\"not vectorized: iteration count smaller than \"\n+                 \"vectorization factor.\");\n+      return false;\n+    }\n+\n+  /* Analyze cost. Decide if worth while to vectorize.  */\n+\n+  /* Once VF is set, SLP costs should be updated since the number of created\n+     vector stmts depends on VF.  */\n+  vect_update_slp_costs_according_to_vf (loop_vinfo);\n+\n+  min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n+  LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n+\n+  if (min_profitable_iters < 0)\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: vectorization not profitable.\");\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"not vectorized: vector version will never be \"\n+                 \"profitable.\");\n+      return false;\n+    }\n+\n+  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+                            * vectorization_factor) - 1);\n+\n+  /* Use the cost model only if it is more conservative than user specified\n+     threshold.  */\n+\n+  th = (unsigned) min_scalar_loop_bound;\n+  if (min_profitable_iters\n+      && (!min_scalar_loop_bound\n+          || min_profitable_iters > min_scalar_loop_bound))\n+    th = (unsigned) min_profitable_iters;\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: vectorization not \"\n+                 \"profitable.\");\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"not vectorized: iteration count smaller than \"\n+                 \"user specified loop bound parameter or minimum \"\n+                 \"profitable iterations (whichever is more conservative).\");\n+      return false;\n+    }\n+\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n+      || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"epilog loop required.\");\n+      if (!vect_can_advance_ivs_p (loop_vinfo))\n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+            fprintf (vect_dump,\n+                     \"not vectorized: can't create epilog loop 1.\");\n+          return false;\n+        }\n+      if (!slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+            fprintf (vect_dump,\n+                     \"not vectorized: can't create epilog loop 2.\");\n+          return false;\n+        }\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Function vect_analyze_loop.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n@@ -1197,7 +1427,7 @@ vect_analyze_loop (struct loop *loop)\n   /* Scan all the operations in the loop and make sure they are\n      vectorizable.  */\n \n-  ok = vect_analyze_operations (loop_vinfo);\n+  ok = vect_analyze_loop_operations (loop_vinfo);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1445,15 +1675,15 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n \n \n   /* Check that one def is the reduction def, defined by PHI,\n-     the other def is either defined in the loop (\"vect_loop_def\"),\n+     the other def is either defined in the loop (\"vect_internal_def\"),\n      or it's an induction (defined by a loop-header phi-node).  */\n \n   if (def2 == phi\n       && flow_bb_inside_loop_p (loop, gimple_bb (def1))\n       && (is_gimple_assign (def1)\n \t  || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_induction_def\n \t  || (gimple_code (def1) == GIMPLE_PHI\n-\t      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_loop_def\n+\t      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def1)) == vect_internal_def\n \t      && !is_loop_header_bb_p (gimple_bb (def1)))))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1465,7 +1695,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi)\n \t   && (is_gimple_assign (def2)\n \t       || STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_induction_def\n \t       || (gimple_code (def2) == GIMPLE_PHI\n-\t\t   && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_loop_def\n+\t\t   && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def2)) == vect_internal_def\n \t\t   && !is_loop_header_bb_p (gimple_bb (def2)))))\n     {\n       /* Swap operands (just for simplicity - so that the rest of the code\n@@ -2895,7 +3125,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /* Reductions that are not used even in an enclosing outer-loop,\n      are expected to be \"live\" (used out of the loop).  */\n-  if (STMT_VINFO_RELEVANT (stmt_info) == vect_unused_in_loop\n+  if (STMT_VINFO_RELEVANT (stmt_info) == vect_unused_in_scope\n       && !STMT_VINFO_LIVE_P (stmt_info))\n     return false;\n \n@@ -2970,14 +3200,15 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt,\n \t\t\t\t\t  &def, &dt);\n       gcc_assert (is_simple_use);\n-      if (dt != vect_loop_def\n-\t  && dt != vect_invariant_def\n+      if (dt != vect_internal_def\n+\t  && dt != vect_external_def\n \t  && dt != vect_constant_def\n \t  && dt != vect_induction_def)\n \treturn false;\n     }\n \n-  is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt, &def, &dt);\n+  is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt, &def, \n+                                      &dt);\n   gcc_assert (is_simple_use);\n   gcc_assert (dt == vect_reduction_def);\n   gcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n@@ -3140,7 +3371,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n    from the vectorized reduction operation generated in the previous iteration.\n   */\n \n-  if (STMT_VINFO_RELEVANT (stmt_info) == vect_unused_in_loop)\n+  if (STMT_VINFO_RELEVANT (stmt_info) == vect_unused_in_scope)\n     {\n       single_defuse_cycle = true;\n       epilog_copies = 1;\n@@ -3361,7 +3592,7 @@ vectorizable_live_operation (gimple stmt,\n           return false;\n         }\n \n-      if (dt != vect_invariant_def && dt != vect_constant_def)\n+      if (dt != vect_external_def && dt != vect_constant_def)\n         return false;\n     }\n \n@@ -3577,8 +3808,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      until all the loops have been transformed?  */\n   update_ssa (TODO_update_ssa);\n \n-  if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n+  if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n     fprintf (vect_dump, \"LOOP VECTORIZED.\");\n-  if (loop->inner && vect_print_dump_info (REPORT_VECTORIZED_LOOPS))\n+  if (loop->inner && vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n     fprintf (vect_dump, \"OUTER LOOP VECTORIZED.\");\n }"}, {"sha": "febbd6436802fe6fe5b52af137e234162c19e4ae", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -81,8 +81,8 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt)\n   if (!vect_is_simple_use (name, loop_vinfo, def_stmt, &def, &dt))\n     return false;\n \n-  if (dt != vect_loop_def\n-      && dt != vect_invariant_def && dt != vect_constant_def)\n+  if (dt != vect_internal_def\n+      && dt != vect_external_def && dt != vect_constant_def)\n     return false;\n \n   if (! *def_stmt)\n@@ -259,7 +259,7 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n     return NULL; \n   stmt_vinfo = vinfo_for_stmt (stmt);\n   gcc_assert (stmt_vinfo);\n-  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_internal_def)\n     return NULL;\n   if (gimple_assign_rhs_code (stmt) != MULT_EXPR)\n     return NULL;\n@@ -272,7 +272,7 @@ vect_recog_dot_prod_pattern (gimple last_stmt, tree *type_in, tree *type_out)\n         return NULL;\n       stmt_vinfo = vinfo_for_stmt (stmt);\n       gcc_assert (stmt_vinfo);\n-      gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_loop_def);\n+      gcc_assert (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_internal_def);\n       oprnd00 = gimple_assign_rhs1 (stmt);\n       oprnd01 = gimple_assign_rhs2 (stmt);\n     }"}, {"sha": "eb1ca62a3a35f460659e7357cef786770763add9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -239,10 +239,10 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n       switch (dt[i])\n \t{\n \tcase vect_constant_def:\n-\tcase vect_invariant_def:\n+\tcase vect_external_def:\n \t  break;\n \t  \n-\tcase vect_loop_def:\n+\tcase vect_internal_def:\n \t  if (i == 0)\n \t    VEC_safe_push (gimple, heap, *def_stmts0, def_stmt);\n \t  else\n@@ -581,7 +581,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n     }\n \n   /* Create SLP_TREE nodes for the definition node/s.  */ \n-  if (first_stmt_dt0 == vect_loop_def)\n+  if (first_stmt_dt0 == vect_internal_def)\n     {\n       slp_tree left_node = XNEW (struct _slp_tree);\n       SLP_TREE_SCALAR_STMTS (left_node) = def_stmts0;\n@@ -598,7 +598,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       SLP_TREE_LEFT (*node) = left_node;\n     }\n \n-  if (first_stmt_dt1 == vect_loop_def)\n+  if (first_stmt_dt1 == vect_internal_def)\n     {\n       slp_tree right_node = XNEW (struct _slp_tree);\n       SLP_TREE_SCALAR_STMTS (right_node) = def_stmts1;\n@@ -952,7 +952,7 @@ vect_analyze_slp (loop_vec_info loop_vinfo)\n     if (!vect_analyze_slp_instance (loop_vinfo, store))\n       {\n \t/* SLP failed. No instance can be SLPed in the loop.  */\n-\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\t\n+\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\t\n \t  fprintf (vect_dump, \"SLP failed.\");\n \n \treturn false;\n@@ -1694,8 +1694,8 @@ vect_schedule_slp (loop_vec_info loop_vinfo)\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n                             instance, LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n \t\t\t  \n-      if (vect_print_dump_info (REPORT_VECTORIZED_LOOPS)\n-\t  || vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS)\n+\t  || vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \tfprintf (vect_dump, \"vectorizing stmts using SLP.\");\n     }\n "}, {"sha": "7afaef3f02a6e777c439b8e8719ab4e5a5f0f67e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 132, "deletions": 341, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -116,21 +116,22 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n   use_operand_p use_p;\n   def_operand_p def_p;\n \n-  *relevant = vect_unused_in_loop;\n+  *relevant = vect_unused_in_scope;\n   *live_p = false;\n \n   /* cond stmt other than loop exit cond.  */\n   if (is_ctrl_stmt (stmt) \n-      && STMT_VINFO_TYPE (vinfo_for_stmt (stmt)) != loop_exit_ctrl_vec_info_type) \n-    *relevant = vect_used_in_loop;\n+      && STMT_VINFO_TYPE (vinfo_for_stmt (stmt)) \n+         != loop_exit_ctrl_vec_info_type) \n+    *relevant = vect_used_in_scope;\n \n   /* changing memory.  */\n   if (gimple_code (stmt) != GIMPLE_PHI)\n     if (gimple_vdef (stmt))\n       {\n \tif (vect_print_dump_info (REPORT_DETAILS))\n \t  fprintf (vect_dump, \"vec_stmt_relevant_p: stmt has vdefs.\");\n-\t*relevant = vect_used_in_loop;\n+\t*relevant = vect_used_in_scope;\n       }\n \n   /* uses outside the loop.  */\n@@ -249,7 +250,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \n   if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n     { \n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n         fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n       return false;\n     }\n@@ -284,7 +285,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \tdstmt_vinfo = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (dstmt_vinfo));\n       gcc_assert (STMT_VINFO_RELEVANT (dstmt_vinfo) < vect_used_by_reduction);\n       gcc_assert (STMT_VINFO_LIVE_P (dstmt_vinfo) \n-\t\t  || STMT_VINFO_RELEVANT (dstmt_vinfo) > vect_unused_in_loop);\n+\t\t  || STMT_VINFO_RELEVANT (dstmt_vinfo) > vect_unused_in_scope);\n       return true;\n     }\n \n@@ -301,18 +302,18 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \tfprintf (vect_dump, \"outer-loop def-stmt defining inner-loop stmt.\");\n       switch (relevant)\n \t{\n-\tcase vect_unused_in_loop:\n+\tcase vect_unused_in_scope:\n \t  relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n-\t\t\tvect_used_by_reduction : vect_unused_in_loop;\n+\t\t\tvect_used_by_reduction : vect_unused_in_scope;\n \t  break;\n \tcase vect_used_in_outer_by_reduction:\n \t  relevant = vect_used_by_reduction;\n \t  break;\n \tcase vect_used_in_outer:\n-\t  relevant = vect_used_in_loop;\n+\t  relevant = vect_used_in_scope;\n \t  break;\n \tcase vect_used_by_reduction: \n-\tcase vect_used_in_loop:\n+\tcase vect_used_in_scope:\n \t  break;\n \n \tdefault:\n@@ -333,9 +334,9 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \tfprintf (vect_dump, \"inner-loop def-stmt defining outer-loop stmt.\");\n       switch (relevant)\n         {\n-        case vect_unused_in_loop:\n+        case vect_unused_in_scope:\n           relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n-                        vect_used_in_outer_by_reduction : vect_unused_in_loop;\n+                        vect_used_in_outer_by_reduction : vect_unused_in_scope;\n           break;\n \n         case vect_used_in_outer_by_reduction:\n@@ -346,7 +347,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n           relevant = vect_used_in_outer_by_reduction;\n           break;\n \n-        case vect_used_in_loop:\n+        case vect_used_in_scope:\n           relevant = vect_used_in_outer;\n           break;\n \n@@ -468,18 +469,18 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t Here are the expected values of \"relevant\" for reduction phis/stmts:\n \n \t relevance:\t\t\t\tphi\tstmt\n-\t vect_unused_in_loop\t\t\t\tok\n+\t vect_unused_in_scope\t\t\t\tok\n \t vect_used_in_outer_by_reduction\tok\tok\n \t vect_used_in_outer\t\t\tok\tok\n \t vect_used_by_reduction\t\t\tok\n-\t vect_used_in_loop \t\t\t\t\t\t  */\n+\t vect_used_in_scope\t\t\t\t              */\n \n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n         {\n \t  enum vect_relevant tmp_relevant = relevant;\n \t  switch (tmp_relevant)\n \t    {\n-\t    case vect_unused_in_loop:\n+\t    case vect_unused_in_scope:\n \t      gcc_assert (gimple_code (stmt) != GIMPLE_PHI);\n \t      relevant = vect_used_by_reduction;\n \t      break;\n@@ -496,7 +497,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      if (gimple_code (stmt) == GIMPLE_PHI)\n \t\tbreak;\n \t      /* fall through */\n-\t    case vect_used_in_loop:\n+\t    case vect_used_in_scope:\n \t    default:\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t        fprintf (vect_dump, \"unsupported use of reduction.\");\n@@ -571,7 +572,7 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n     {\n-      if (dt[i] == vect_constant_def || dt[i] == vect_invariant_def)\n+      if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n \toutside_cost += TARG_SCALAR_TO_VEC_COST; \n     }\n   \n@@ -619,7 +620,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n-  if (dt == vect_constant_def || dt == vect_invariant_def)\n+  if (dt == vect_constant_def || dt == vect_external_def)\n     outside_cost = TARG_SCALAR_TO_VEC_COST;\n \n   /* Strided access?  */\n@@ -905,7 +906,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n       }\n \n     /* Case 2: operand is defined outside the loop - loop invariant.  */\n-    case vect_invariant_def:\n+    case vect_external_def:\n       {\n \tvector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n \tgcc_assert (vector_type);\n@@ -929,7 +930,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n       }\n \n     /* Case 3: operand is defined inside the loop.  */\n-    case vect_loop_def:\n+    case vect_internal_def:\n       {\n \tif (scalar_def) \n \t  *scalar_def = NULL/* FIXME tuples: def_stmt*/;\n@@ -1042,7 +1043,7 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n   stmt_vec_info def_stmt_info;\n \n   /* Do nothing; can reuse same def.  */\n-  if (dt == vect_invariant_def || dt == vect_constant_def )\n+  if (dt == vect_external_def || dt == vect_constant_def )\n     return vec_oprnd;\n \n   vec_stmt_for_operand = SSA_NAME_DEF_STMT (vec_oprnd);\n@@ -1190,7 +1191,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* FORNOW: SLP not supported.  */\n@@ -1508,7 +1509,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   if (!is_gimple_assign (stmt))\n@@ -1771,7 +1772,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* Is vectorizable assignment?  */\n@@ -1885,7 +1886,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* Is STMT a vectorizable binary/unary operation?   */\n@@ -1947,7 +1948,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       shift_p = true;\n \n       /* vector shifted by vector */\n-      if (dt[1] == vect_loop_def)\n+      if (dt[1] == vect_internal_def)\n \t{\n \t  optab = optab_for_tree_code (code, vectype, optab_vector);\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1956,7 +1957,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n       /* See if the machine has a vector shifted by scalar insn and if not\n \t then see if it has a vector shifted by vector insn */\n-      else if (dt[1] == vect_constant_def || dt[1] == vect_invariant_def)\n+      else if (dt[1] == vect_constant_def || dt[1] == vect_external_def)\n \t{\n \t  optab = optab_for_tree_code (code, vectype, optab_scalar);\n \t  if (optab\n@@ -2323,7 +2324,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* Is STMT a vectorizable type-demotion operation?  */\n@@ -2590,7 +2591,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* Is STMT a vectorizable type-promotion operation?  */\n@@ -2836,7 +2837,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* Is vectorizable store? */\n@@ -3204,7 +3205,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* Is vectorizable load? */\n@@ -3703,7 +3704,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_loop_def)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n     return false;\n \n   /* FORNOW: SLP not supported.  */\n@@ -3803,336 +3804,125 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n }\n \n \n-/* Function vect_analyze_operations.\n-\n-   Scan the loop stmts and make sure they are all vectorizable.  */\n+/* Make sure the statement is vectorizable.  */\n \n bool\n-vect_analyze_operations (loop_vec_info loop_vinfo)\n+vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-  int nbbs = loop->num_nodes;\n-  gimple_stmt_iterator si;\n-  unsigned int vectorization_factor = 0;\n-  int i;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n   bool ok;\n-  gimple phi;\n-  stmt_vec_info stmt_info;\n-  bool need_to_vectorize = false;\n-  int min_profitable_iters;\n-  int min_scalar_loop_bound;\n-  unsigned int th;\n-  bool only_slp_in_loop = true;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"=== vect_analyze_operations ===\");\n-\n-  gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n-  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-\n-  for (i = 0; i < nbbs; i++)\n     {\n-      basic_block bb = bbs[i];\n-\n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n-        {\n-          phi = gsi_stmt (si);\n-          ok = true;\n-\n-          stmt_info = vinfo_for_stmt (phi);\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"examining phi: \");\n-              print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n-            }\n-\n-          if (! is_loop_header_bb_p (bb))\n-            {\n-              /* inner-loop loop-closed exit phi in outer-loop vectorization\n-                 (i.e. a phi in the tail of the outer-loop).\n-                 FORNOW: we currently don't support the case that these phis\n-                 are not used in the outerloop, cause this case requires\n-                 to actually do something here.  */\n-              if (!STMT_VINFO_RELEVANT_P (stmt_info)\n-                  || STMT_VINFO_LIVE_P (stmt_info))\n-                {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    fprintf (vect_dump,\n-                             \"Unsupported loop-closed phi in outer-loop.\");\n-                  return false;\n-                }\n-              continue;\n-            }\n-\n-          gcc_assert (stmt_info);\n-\n-          if (STMT_VINFO_LIVE_P (stmt_info))\n-            {\n-              /* FORNOW: not yet supported.  */\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                fprintf (vect_dump, \"not vectorized: value used after loop.\");\n-              return false;\n-            }\n-\n-          if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_loop\n-              && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n-            {\n-              /* A scalar-dependence cycle that we don't support.  */\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                fprintf (vect_dump, \"not vectorized: scalar dependence cycle.\");\n-              return false;\n-            }\n-\n-          if (STMT_VINFO_RELEVANT_P (stmt_info))\n-            {\n-              need_to_vectorize = true;\n-              if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n-                ok = vectorizable_induction (phi, NULL, NULL);\n-            }\n-\n-          if (!ok)\n-            {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                {\n-                  fprintf (vect_dump,\n-                           \"not vectorized: relevant phi not supported: \");\n-                  print_gimple_stmt (vect_dump, phi, 0, TDF_SLIM);\n-                }\n-              return false;\n-            }\n-        }\n-\n-      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-        {\n-          gimple stmt = gsi_stmt (si);\n-          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-          enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n-\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"==> examining statement: \");\n-              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-            }\n-\n-          gcc_assert (stmt_info);\n-\n-          /* skip stmts which do not need to be vectorized.\n-             this is expected to include:\n-             - the COND_EXPR which is the loop exit condition\n-             - any LABEL_EXPRs in the loop\n-             - computations that are used only for array indexing or loop\n-             control  */\n-\n-          if (!STMT_VINFO_RELEVANT_P (stmt_info)\n-              && !STMT_VINFO_LIVE_P (stmt_info))\n-            {\n-              if (vect_print_dump_info (REPORT_DETAILS))\n-                fprintf (vect_dump, \"irrelevant.\");\n-              continue;\n-            }\n-\n-          switch (STMT_VINFO_DEF_TYPE (stmt_info))\n-            {\n-            case vect_loop_def:\n-              break;\n-\n-            case vect_reduction_def:\n-              gcc_assert (relevance == vect_used_in_outer\n-                          || relevance == vect_used_in_outer_by_reduction\n-                          || relevance == vect_unused_in_loop);\n-              break;\n-\n-            case vect_induction_def:\n-            case vect_constant_def:\n-            case vect_invariant_def:\n-            case vect_unknown_def_type:\n-            default:\n-              gcc_unreachable ();\n-            }\n-\n-          if (STMT_VINFO_RELEVANT_P (stmt_info))\n-            {\n-              gcc_assert (!VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))));\n-              gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n-              need_to_vectorize = true;\n-            }\n-\n-          ok = true;\n-          if (STMT_VINFO_RELEVANT_P (stmt_info)\n-              || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n-            ok = (vectorizable_type_promotion (stmt, NULL, NULL, NULL)\n-                || vectorizable_type_demotion (stmt, NULL, NULL, NULL)\n-                || vectorizable_conversion (stmt, NULL, NULL, NULL)\n-                || vectorizable_operation (stmt, NULL, NULL, NULL)\n-                || vectorizable_assignment (stmt, NULL, NULL, NULL)\n-                || vectorizable_load (stmt, NULL, NULL, NULL, NULL)\n-                || vectorizable_call (stmt, NULL, NULL)\n-                || vectorizable_store (stmt, NULL, NULL, NULL)\n-                || vectorizable_condition (stmt, NULL, NULL)\n-                || vectorizable_reduction (stmt, NULL, NULL));\n-\n-          if (!ok)\n-            {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                {\n-                  fprintf (vect_dump, \"not vectorized: relevant stmt not \");\n-                  fprintf (vect_dump, \"supported: \");\n-                  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-                }\n-              return false;\n-            }\n-\n-          /* Stmts that are (also) \"live\" (i.e. - that are used out of the loop)\n-             need extra handling, except for vectorizable reductions.  */\n-          if (STMT_VINFO_LIVE_P (stmt_info)\n-              && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n-            ok = vectorizable_live_operation (stmt, NULL, NULL);\n+      fprintf (vect_dump, \"==> examining statement: \");\n+      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+    }\n \n-          if (!ok)\n-            {\n-              if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-                {\n-                  fprintf (vect_dump, \"not vectorized: live stmt not \");\n-                  fprintf (vect_dump, \"supported: \");\n-                  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-                }\n-              return false;\n-            }\n+  /* Skip stmts that do not need to be vectorized. In loops this is expected\n+     to include:\n+     - the COND_EXPR which is the loop exit condition\n+     - any LABEL_EXPRs in the loop\n+     - computations that are used only for array indexing or loop control.\n+     In basic blocks we only analyze statements that are a part of some SLP\n+     instance, therefore, all the statements are relevant.  */\n \n-          if (!PURE_SLP_STMT (stmt_info))\n-            {\n-              /* STMT needs loop-based vectorization.  */\n-              only_slp_in_loop = false;\n-\n-              /* Groups of strided accesses whose size is not a power of 2 are\n-                 not vectorizable yet using loop-vectorization. Therefore, if\n-                 this stmt feeds non-SLP-able stmts (i.e., this stmt has to be\n-                 both SLPed and loop-based vectorized), the loop cannot be\n-                 vectorized.  */\n-              if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n-                  && exact_log2 (DR_GROUP_SIZE (vinfo_for_stmt (\n-                                  DR_GROUP_FIRST_DR (stmt_info)))) == -1)\n-                {\n-                  if (vect_print_dump_info (REPORT_DETAILS))\n-                    {\n-                      fprintf (vect_dump, \"not vectorized: the size of group \"\n-                               \"of strided accesses is not a power of 2\");\n-                      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n-                    }\n-                  return false;\n-                }\n-            }\n-        } /* stmts in bb */\n-    } /* bbs */\n-\n-  /* All operations in the loop are either irrelevant (deal with loop\n-     control, or dead), or only used outside the loop and can be moved\n-     out of the loop (e.g. invariants, inductions).  The loop can be\n-     optimized away by scalar optimizations.  We're better off not\n-     touching this loop.  */\n-  if (!need_to_vectorize)\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+      && !STMT_VINFO_LIVE_P (stmt_info))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump,\n-                 \"All the computation can be taken out of the loop.\");\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-        fprintf (vect_dump,\n-                 \"not vectorized: redundant loop. no profit to vectorize.\");\n-      return false;\n-    }\n+        fprintf (vect_dump, \"irrelevant.\");\n \n-  /* If all the stmts in the loop can be SLPed, we perform only SLP, and\n-     vectorization factor of the loop is the unrolling factor required by the\n-     SLP instances.  If that unrolling factor is 1, we say, that we perform\n-     pure SLP on loop - cross iteration parallelism is not exploited.  */\n-  if (only_slp_in_loop)\n-    vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n-  else\n-    vectorization_factor = least_common_multiple (vectorization_factor,\n-                                LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n+      return true;\n+    }\n \n-  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n+  switch (STMT_VINFO_DEF_TYPE (stmt_info))\n+    {\n+      case vect_internal_def:\n+        break;\n \n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump,\n-        \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n-        vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n+      case vect_reduction_def:\n+         gcc_assert (relevance == vect_used_in_outer\n+                     || relevance == vect_used_in_outer_by_reduction\n+                     || relevance == vect_unused_in_scope);\n+         break;\n+\n+      case vect_induction_def:\n+      case vect_constant_def:\n+      case vect_external_def:\n+      case vect_unknown_def_type:\n+      default:\n+        gcc_unreachable ();\n+    }\n \n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && (LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor))\n+  if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-        fprintf (vect_dump, \"not vectorized: iteration count too small.\");\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump,\"not vectorized: iteration count smaller than \"\n-                 \"vectorization factor.\");\n-      return false;\n+      gcc_assert (!VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))));\n+      gcc_assert (STMT_VINFO_VECTYPE (stmt_info));\n+      *need_to_vectorize = true;\n     }\n \n-  /* Analyze cost. Decide if worth while to vectorize.  */\n-\n-  /* Once VF is set, SLP costs should be updated since the number of created\n-     vector stmts depends on VF.  */\n-  vect_update_slp_costs_according_to_vf (loop_vinfo);\n-\n-  min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n-  LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n-\n-  if (min_profitable_iters < 0)\n+   ok = true;\n+   if (STMT_VINFO_RELEVANT_P (stmt_info)\n+       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n+      ok = (vectorizable_type_promotion (stmt, NULL, NULL, NULL)\n+            || vectorizable_type_demotion (stmt, NULL, NULL, NULL)\n+            || vectorizable_conversion (stmt, NULL, NULL, NULL)\n+            || vectorizable_operation (stmt, NULL, NULL, NULL)\n+            || vectorizable_assignment (stmt, NULL, NULL, NULL)\n+            || vectorizable_load (stmt, NULL, NULL, NULL, NULL)\n+            || vectorizable_call (stmt, NULL, NULL)\n+            || vectorizable_store (stmt, NULL, NULL, NULL)\n+            || vectorizable_condition (stmt, NULL, NULL)\n+            || vectorizable_reduction (stmt, NULL, NULL));\n+\n+  if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-        fprintf (vect_dump, \"not vectorized: vectorization not profitable.\");\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"not vectorized: vector version will never be \"\n-                 \"profitable.\");\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        {\n+          fprintf (vect_dump, \"not vectorized: relevant stmt not \");\n+          fprintf (vect_dump, \"supported: \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n       return false;\n     }\n \n-  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-                            * vectorization_factor) - 1);\n-\n-  /* Use the cost model only if it is more conservative than user specified\n-     threshold.  */\n-\n-  th = (unsigned) min_scalar_loop_bound;\n-  if (min_profitable_iters\n-      && (!min_scalar_loop_bound\n-          || min_profitable_iters > min_scalar_loop_bound))\n-    th = (unsigned) min_profitable_iters;\n+  /* Stmts that are (also) \"live\" (i.e. - that are used out of the loop)\n+      need extra handling, except for vectorizable reductions.  */\n+  if (STMT_VINFO_LIVE_P (stmt_info)\n+      && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n+    ok = vectorizable_live_operation (stmt, NULL, NULL);\n \n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n+  if (!ok)\n     {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-        fprintf (vect_dump, \"not vectorized: vectorization not \"\n-                 \"profitable.\");\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"not vectorized: iteration count smaller than \"\n-                 \"user specified loop bound parameter or minimum \"\n-                 \"profitable iterations (whichever is more conservative).\");\n-      return false;\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        {\n+          fprintf (vect_dump, \"not vectorized: live stmt not \");\n+          fprintf (vect_dump, \"supported: \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n+       return false;\n     }\n \n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n-      || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+  if (!PURE_SLP_STMT (stmt_info))\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"epilog loop required.\");\n-      if (!vect_can_advance_ivs_p (loop_vinfo))\n+      /* Groups of strided accesses whose size is not a power of 2 are not\n+         vectorizable yet using loop-vectorization. Therefore, if this stmt\n+         feeds non-SLP-able stmts (i.e., this stmt has to be both SLPed and\n+         loop-based vectorized), the loop cannot be vectorized.  */\n+      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n+          && exact_log2 (DR_GROUP_SIZE (vinfo_for_stmt (\n+                                        DR_GROUP_FIRST_DR (stmt_info)))) == -1)\n         {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-            fprintf (vect_dump,\n-                     \"not vectorized: can't create epilog loop 1.\");\n-          return false;\n-        }\n-      if (!slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n-        {\n-          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-            fprintf (vect_dump,\n-                     \"not vectorized: can't create epilog loop 2.\");\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+              fprintf (vect_dump, \"not vectorized: the size of group \"\n+                                  \"of strided accesses is not a power of 2\");\n+              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+            }\n+\n           return false;\n         }\n     }\n@@ -4343,7 +4133,7 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo)\n   STMT_VINFO_TYPE (res) = undef_vec_info_type;\n   STMT_VINFO_STMT (res) = stmt;\n   STMT_VINFO_LOOP_VINFO (res) = loop_vinfo;\n-  STMT_VINFO_RELEVANT (res) = vect_unused_in_loop;\n+  STMT_VINFO_RELEVANT (res) = vect_unused_in_scope;\n   STMT_VINFO_LIVE_P (res) = false;\n   STMT_VINFO_VECTYPE (res) = NULL;\n   STMT_VINFO_VEC_STMT (res) = NULL;\n@@ -4361,7 +4151,8 @@ new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo)\n       && is_loop_header_bb_p (gimple_bb (stmt)))\n     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;\n   else\n-    STMT_VINFO_DEF_TYPE (res) = vect_loop_def;\n+    STMT_VINFO_DEF_TYPE (res) = vect_internal_def;\n+\n   STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n   STMT_VINFO_INSIDE_OF_LOOP_COST (res) = 0;\n   STMT_VINFO_OUTSIDE_OF_LOOP_COST (res) = 0;\n@@ -4499,7 +4290,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n   if (is_gimple_min_invariant (operand))\n     {\n       *def = operand;\n-      *dt = vect_invariant_def;\n+      *dt = vect_external_def;\n       return true;\n     }\n \n@@ -4530,18 +4321,18 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n       print_gimple_stmt (vect_dump, *def_stmt, 0, TDF_SLIM);\n     }\n \n-  /* empty stmt is expected only in case of a function argument.\n+  /* Empty stmt is expected only in case of a function argument.\n      (Otherwise - we expect a phi_node or a GIMPLE_ASSIGN).  */\n   if (gimple_nop_p (*def_stmt))\n     {\n       *def = operand;\n-      *dt = vect_invariant_def;\n+      *dt = vect_external_def;\n       return true;\n     }\n \n   bb = gimple_bb (*def_stmt);\n   if (!flow_bb_inside_loop_p (loop, bb))\n-    *dt = vect_invariant_def;\n+    *dt = vect_external_def;\n   else\n     {\n       stmt_vinfo = vinfo_for_stmt (*def_stmt);"}, {"sha": "b4985475d78e501833e59864b7bec18dc07e25a2", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -74,10 +74,10 @@ FILE *vect_dump;\n \n /* vect_verbosity_level set to an invalid value \n    to mark that it's uninitialized.  */\n-enum verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n+static enum verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n \n /* Loop location.  */\n-LOC vect_loop_location;\n+LOC vect_location;\n \n /* Bitmap of virtual variables to be renamed.  */\n bitmap vect_memsyms_to_rename;\n@@ -89,7 +89,7 @@ VEC(vec_void_p,heap) *stmt_vec_info_vec;\n \n /* Function vect_set_verbosity_level.\n \n-   Called from toplev.c upon detection of the\n+   Called from opts.c upon detection of the\n    -ftree-vectorizer-verbose=N option.  */\n \n void\n@@ -132,7 +132,7 @@ vect_set_dump_settings (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     vect_verbosity_level = REPORT_DETAILS;\n   else if (dump_file && (dump_flags & TDF_STATS))\n-    vect_verbosity_level = REPORT_UNVECTORIZED_LOOPS;\n+    vect_verbosity_level = REPORT_UNVECTORIZED_LOCATIONS;\n   else\n     vect_verbosity_level = REPORT_NONE;\n \n@@ -153,21 +153,21 @@ vect_print_dump_info (enum verbosity_levels vl)\n   if (!current_function_decl || !vect_dump)\n     return false;\n \n-  if (vect_loop_location == UNKNOWN_LOC)\n+  if (vect_location == UNKNOWN_LOC)\n     fprintf (vect_dump, \"\\n%s:%d: note: \",\n \t     DECL_SOURCE_FILE (current_function_decl),\n \t     DECL_SOURCE_LINE (current_function_decl));\n   else\n     fprintf (vect_dump, \"\\n%s:%d: note: \", \n-\t     LOC_FILE (vect_loop_location), LOC_LINE (vect_loop_location));\n+\t     LOC_FILE (vect_location), LOC_LINE (vect_location));\n \n   return true;\n }\n \n \n /* Function vectorize_loops.\n    \n-   Entry Point to loop vectorization phase.  */\n+   Entry point to loop vectorization phase.  */\n \n unsigned\n vectorize_loops (void)\n@@ -187,7 +187,7 @@ vectorize_loops (void)\n   /* Fix the verbosity level if not defined explicitly by the user.  */\n   vect_set_dump_settings ();\n \n-  /* Allocate the bitmap that records which virtual variables that \n+  /* Allocate the bitmap that records which virtual variables  \n      need to be renamed.  */\n   vect_memsyms_to_rename = BITMAP_ALLOC (NULL);\n \n@@ -203,7 +203,7 @@ vectorize_loops (void)\n       {\n \tloop_vec_info loop_vinfo;\n \n-\tvect_loop_location = find_loop_location (loop);\n+\tvect_location = find_loop_location (loop);\n \tloop_vinfo = vect_analyze_loop (loop);\n \tloop->aux = loop_vinfo;\n \n@@ -213,11 +213,12 @@ vectorize_loops (void)\n \tvect_transform_loop (loop_vinfo);\n \tnum_vectorized_loops++;\n       }\n-  vect_loop_location = UNKNOWN_LOC;\n+\n+  vect_location = UNKNOWN_LOC;\n \n   statistics_counter_event (cfun, \"Vectorized loops\", num_vectorized_loops);\n-  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS)\n-      || (vect_print_dump_info (REPORT_VECTORIZED_LOOPS)\n+  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS)\n+      || (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS)\n \t  && num_vectorized_loops > 0))\n     fprintf (vect_dump, \"vectorized %u loops in function.\\n\",\n \t     num_vectorized_loops);"}, {"sha": "2422f4416e1b7b3ba0085715de288b9656b67b6a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8644a673d32a8fef52cc34d4dd0dc8b6788f516e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=8644a673d32a8fef52cc34d4dd0dc8b6788f516e", "patch": "@@ -56,9 +56,9 @@ enum dr_alignment_support {\n /* Define type of def-use cross-iteration cycle.  */\n enum vect_def_type {\n   vect_uninitialized_def = 0,\n-  vect_constant_def,\n-  vect_invariant_def,\n-  vect_loop_def,\n+  vect_constant_def = 1,\n+  vect_external_def,\n+  vect_internal_def,\n   vect_induction_def,\n   vect_reduction_def,\n   vect_unknown_def_type\n@@ -67,8 +67,8 @@ enum vect_def_type {\n /* Define verbosity levels.  */\n enum verbosity_levels {\n   REPORT_NONE,\n-  REPORT_VECTORIZED_LOOPS,\n-  REPORT_UNVECTORIZED_LOOPS,\n+  REPORT_VECTORIZED_LOCATIONS,\n+  REPORT_UNVECTORIZED_LOCATIONS,\n   REPORT_COST,\n   REPORT_ALIGNMENT,\n   REPORT_DR_DETAILS,\n@@ -300,9 +300,10 @@ enum stmt_vec_info_type {\n   loop_exit_ctrl_vec_info_type\n };\n \n-/* Indicates whether/how a variable is used in the loop.  */\n+/* Indicates whether/how a variable is used in the scope of loop/basic \n+   block.  */\n enum vect_relevant {\n-  vect_unused_in_loop = 0,\n+  vect_unused_in_scope = 0,\n   vect_used_in_outer_by_reduction,\n   vect_used_in_outer,\n \n@@ -314,7 +315,7 @@ enum vect_relevant {\n      computed.  */\n   vect_used_by_reduction,\n \n-  vect_used_in_loop  \n+  vect_used_in_scope \n };\n \n /* The type of vectorization that can be applied to the stmt: regular loop-based\n@@ -475,7 +476,7 @@ typedef struct _stmt_vec_info {\n #define DR_GROUP_SAME_DR_STMT(S)           (S)->same_dr_stmt\n #define DR_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n \n-#define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_loop)\n+#define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_scope)\n #define STMT_VINFO_OUTSIDE_OF_LOOP_COST(S) (S)->cost.outside_of_loop\n #define STMT_VINFO_INSIDE_OF_LOOP_COST(S)  (S)->cost.inside_of_loop\n \n@@ -693,12 +694,9 @@ known_alignment_for_access_p (struct data_reference *data_ref_info)\n extern FILE *vect_dump;\n extern LOC vect_loop_location;\n \n-extern enum verbosity_levels vect_verbosity_level;\n-\n /* Bitmap of virtual variables to be renamed.  */\n extern bitmap vect_memsyms_to_rename;\n \n-\n /*-----------------------------------------------------------------*/\n /* Function prototypes.                                            */\n /*-----------------------------------------------------------------*/\n@@ -744,7 +742,7 @@ extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);\n extern bool vect_transform_stmt (gimple, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n extern void vect_remove_stores (gimple);\n-extern bool vect_analyze_operations (loop_vec_info);\n+extern bool vect_analyze_stmt (gimple, bool *);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);"}]}