{"sha": "f96bf49a02464e07526289799c14c1333a71a02b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk2YmY0OWEwMjQ2NGUwNzUyNjI4OTc5OWMxNGMxMzMzYTcxYTAyYg==", "commit": {"author": {"name": "Jim Wilson", "email": "jim.wilson@linaro.org", "date": "2017-05-13T01:32:40Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2017-05-13T01:32:40Z"}, "message": "Patch for RTL expand bug affecting aarch64 vector code.\n\n\tgcc/\n\tPR middle-end/79794\n    \t* expmed.c (extract_bit_field_1): Add alt_rtl argument.  Before\n\tmaybe_expand_insn call, set ops[0].target.  If still set after call,\n\tset alt_rtl.  Add extra arg to recursive calls.\n\t(extract_bit_field): Add alt_rtl argument.  Pass to\n\textract_bit_field.\n\t* expmed.h (extract_bit_field): Fix prototype.\n\t* expr.c (emit_group_load_1, copy_blkmode_from_reg)\n\t(copy_blkmode_to_reg, read_complex_part, store_field): Pass extra NULL\n\tto extract_bit_field_calls.\n\t(expand_expr_real_1): Pass alt_rtl to expand_expr_real instead of 0.\n\tPass alt_rtl to extract_bit_field calls.\n\t* calls.c (store_unaligned_arguments_into_psuedos)\n\tload_register_parameters): Pass extra NULL to extract_bit_field calls.\n\t* optabs.c (maybe_legitimize_operand): Clear op->target when call\n\tgen_reg_rtx.\n\t* optabs.h (struct expand_operand): Add target bitfield.\n\nFrom-SVN: r248004", "tree": {"sha": "255e553b1d2aa340ebdd900f20d69044173c367d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/255e553b1d2aa340ebdd900f20d69044173c367d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f96bf49a02464e07526289799c14c1333a71a02b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f96bf49a02464e07526289799c14c1333a71a02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f96bf49a02464e07526289799c14c1333a71a02b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f96bf49a02464e07526289799c14c1333a71a02b/comments", "author": null, "committer": null, "parents": [{"sha": "7f390a7b6ce8491fb89c9f4f393b161c8075823a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f390a7b6ce8491fb89c9f4f393b161c8075823a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f390a7b6ce8491fb89c9f4f393b161c8075823a"}], "stats": {"total": 72, "additions": 52, "deletions": 20}, "files": [{"sha": "b58aacf9b53845a38fb40c76b042d62b0fb199ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f96bf49a02464e07526289799c14c1333a71a02b", "patch": "@@ -1,3 +1,23 @@\n+2017-05-12  Jim Wilson  <jim.wilson@linaro.org>\n+\n+\tPR middle-end/79794\n+    \t* expmed.c (extract_bit_field_1): Add alt_rtl argument.  Before\n+\tmaybe_expand_insn call, set ops[0].target.  If still set after call,\n+\tset alt_rtl.  Add extra arg to recursive calls.\n+\t(extract_bit_field): Add alt_rtl argument.  Pass to\n+\textract_bit_field.\n+\t* expmed.h (extract_bit_field): Fix prototype.\n+\t* expr.c (emit_group_load_1, copy_blkmode_from_reg)\n+\t(copy_blkmode_to_reg, read_complex_part, store_field): Pass extra NULL\n+\tto extract_bit_field_calls.\n+\t(expand_expr_real_1): Pass alt_rtl to expand_expr_real instead of 0.\n+\tPass alt_rtl to extract_bit_field calls.\n+\t* calls.c (store_unaligned_arguments_into_psuedos)\n+\tload_register_parameters): Pass extra NULL to extract_bit_field calls.\n+\t* optabs.c (maybe_legitimize_operand): Clear op->target when call\n+\tgen_reg_rtx.\n+\t* optabs.h (struct expand_operand): Add target bitfield.\n+\n 2017-05-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* compare-elim.c (try_eliminate_compare): Canonicalize"}, {"sha": "91a4466b00bec4f514344b80aacbe0ca30aac8fe", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f96bf49a02464e07526289799c14c1333a71a02b", "patch": "@@ -1164,7 +1164,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \n \t    args[i].aligned_regs[j] = reg;\n \t    word = extract_bit_field (word, bitsize, 0, 1, NULL_RTX,\n-\t\t\t\t      word_mode, word_mode, false);\n+\t\t\t\t      word_mode, word_mode, false, NULL);\n \n \t    /* There is no need to restrict this code to loading items\n \t       in TYPE_ALIGN sized hunks.  The bitfield instructions can\n@@ -2557,7 +2557,8 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t  unsigned int bitoff = (nregs - 1) * BITS_PER_WORD;\n \t\t  unsigned int bitsize = size * BITS_PER_UNIT - bitoff;\n \t\t  rtx x = extract_bit_field (mem, bitsize, bitoff, 1, dest,\n-\t\t\t\t\t     word_mode, word_mode, false);\n+\t\t\t\t\t     word_mode, word_mode, false,\n+\t\t\t\t\t     NULL);\n \t\t  if (BYTES_BIG_ENDIAN)\n \t\t    x = expand_shift (LSHIFT_EXPR, word_mode, x,\n \t\t\t\t      BITS_PER_WORD - bitsize, dest, 1);"}, {"sha": "0c812806f9bfbf5eb75842345c3580de8aadc668", "filename": "gcc/expmed.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f96bf49a02464e07526289799c14c1333a71a02b", "patch": "@@ -1534,7 +1534,7 @@ static rtx\n extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t     unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n \t\t     machine_mode mode, machine_mode tmode,\n-\t\t     bool reverse, bool fallback_p)\n+\t\t     bool reverse, bool fallback_p, rtx *alt_rtl)\n {\n   rtx op0 = str_rtx;\n   machine_mode int_mode;\n@@ -1610,10 +1610,13 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n \n       create_output_operand (&ops[0], target, innermode);\n+      ops[0].target = 1;\n       create_input_operand (&ops[1], op0, outermode);\n       create_integer_operand (&ops[2], pos);\n       if (maybe_expand_insn (icode, 3, ops))\n \t{\n+\t  if (alt_rtl && ops[0].target)\n+\t    *alt_rtl = target;\n \t  target = ops[0].value;\n       \t  if (GET_MODE (target) != mode)\n \t    return gen_lowpart (tmode, target);\n@@ -1735,7 +1738,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t    = extract_bit_field_1 (op0, MIN (BITS_PER_WORD,\n \t\t\t\t\t     bitsize - i * BITS_PER_WORD),\n \t\t\t\t   bitnum + bit_offset, 1, target_part,\n-\t\t\t\t   mode, word_mode, reverse, fallback_p);\n+\t\t\t\t   mode, word_mode, reverse, fallback_p, NULL);\n \n \t  gcc_assert (target_part);\n \t  if (!result_part)\n@@ -1838,7 +1841,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  xop0 = copy_to_reg (xop0);\n \t  rtx result = extract_bit_field_1 (xop0, bitsize, bitpos,\n \t\t\t\t\t    unsignedp, target,\n-\t\t\t\t\t    mode, tmode, reverse, false);\n+\t\t\t\t\t    mode, tmode, reverse, false, NULL);\n \t  if (result)\n \t    return result;\n \t  delete_insns_since (last);\n@@ -1894,7 +1897,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n rtx\n extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n-\t\t   machine_mode mode, machine_mode tmode, bool reverse)\n+\t\t   machine_mode mode, machine_mode tmode, bool reverse,\n+\t\t   rtx *alt_rtl)\n {\n   machine_mode mode1;\n \n@@ -1929,7 +1933,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     }\n \n   return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,\n-\t\t\t      target, mode, tmode, reverse, true);\n+\t\t\t      target, mode, tmode, reverse, true, alt_rtl);\n }\n \f\n /* Use shifts and boolean operations to extract a field of BITSIZE bits"}, {"sha": "64476c3b4b2ff55c97a98e9bb6b9a6e501c3ca12", "filename": "gcc/expmed.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=f96bf49a02464e07526289799c14c1333a71a02b", "patch": "@@ -725,7 +725,7 @@ extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t     machine_mode, rtx, bool);\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n-\t\t\t      machine_mode, machine_mode, bool);\n+\t\t\t      machine_mode, machine_mode, bool, rtx *);\n extern rtx extract_low_bits (machine_mode, machine_mode, rtx);\n extern rtx expand_mult (machine_mode, rtx, rtx, rtx, int);\n extern rtx expand_mult_highpart_adjust (machine_mode, rtx, rtx, rtx, rtx, int);"}, {"sha": "5febf07929d0add0ad0ae1356baef008524f0c7c", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f96bf49a02464e07526289799c14c1333a71a02b", "patch": "@@ -2192,7 +2192,8 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t\t      && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode)))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n \t\t\t\t\t     subpos * BITS_PER_UNIT,\n-\t\t\t\t\t     1, NULL_RTX, mode, mode, false);\n+\t\t\t\t\t     1, NULL_RTX, mode, mode, false,\n+\t\t\t\t\t     NULL);\n \t    }\n \t  else\n \t    {\n@@ -2202,7 +2203,8 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t      mem = assign_stack_temp (GET_MODE (src), slen);\n \t      emit_move_insn (mem, src);\n \t      tmps[i] = extract_bit_field (mem, bytelen * BITS_PER_UNIT,\n-\t\t\t\t\t   0, 1, NULL_RTX, mode, mode, false);\n+\t\t\t\t\t   0, 1, NULL_RTX, mode, mode, false,\n+\t\t\t\t\t   NULL);\n \t    }\n \t}\n       /* FIXME: A SIMD parallel will eventually lead to a subreg of a\n@@ -2245,7 +2247,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n       else\n \ttmps[i] = extract_bit_field (src, bytelen * BITS_PER_UNIT,\n \t\t\t\t     bytepos * BITS_PER_UNIT, 1, NULL_RTX,\n-\t\t\t\t     mode, mode, false);\n+\t\t\t\t     mode, mode, false, NULL);\n \n       if (shift)\n \ttmps[i] = expand_shift (LSHIFT_EXPR, mode, tmps[i],\n@@ -2697,7 +2699,7 @@ copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n \t\t       extract_bit_field (src, bitsize,\n \t\t\t\t\t  xbitpos % BITS_PER_WORD, 1,\n \t\t\t\t\t  NULL_RTX, copy_mode, copy_mode,\n-\t\t\t\t\t  false),\n+\t\t\t\t\t  false, NULL),\n \t\t       false);\n     }\n }\n@@ -2776,7 +2778,7 @@ copy_blkmode_to_reg (machine_mode mode, tree src)\n \t\t       extract_bit_field (src_word, bitsize,\n \t\t\t\t\t  bitpos % BITS_PER_WORD, 1,\n \t\t\t\t\t  NULL_RTX, word_mode, word_mode,\n-\t\t\t\t\t  false),\n+\t\t\t\t\t  false, NULL),\n \t\t       false);\n     }\n \n@@ -3225,7 +3227,7 @@ read_complex_part (rtx cplx, bool imag_p)\n     }\n \n   return extract_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0,\n-\t\t\t    true, NULL_RTX, imode, imode, false);\n+\t\t\t    true, NULL_RTX, imode, imode, false, NULL);\n }\n \f\n /* A subroutine of emit_move_insn_1.  Yet another lowpart generator.\n@@ -6911,7 +6913,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t{\n \t  machine_mode temp_mode = smallest_mode_for_size (bitsize, MODE_INT);\n \t  temp = extract_bit_field (temp, bitsize, 0, 1, NULL_RTX, temp_mode,\n-\t\t\t\t    temp_mode, false);\n+\t\t\t\t    temp_mode, false, NULL);\n \t}\n \n       /* Store the value in the bitfield.  */\n@@ -9780,7 +9782,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    case GIMPLE_SINGLE_RHS:\n \t      {\n \t\tr = expand_expr_real (gimple_assign_rhs1 (g), target,\n-\t\t\t\t      tmode, modifier, NULL, inner_reference_p);\n+\t\t\t\t      tmode, modifier, alt_rtl,\n+\t\t\t\t      inner_reference_p);\n \t\tbreak;\n \t      }\n \t    default:\n@@ -10210,7 +10213,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\t\t\t0, TYPE_UNSIGNED (TREE_TYPE (exp)),\n \t\t\t\t\t(modifier == EXPAND_STACK_PARM\n \t\t\t\t\t ? NULL_RTX : target),\n-\t\t\t\t\tmode, mode, false);\n+\t\t\t\t\tmode, mode, false, alt_rtl);\n \t  }\n \tif (reverse\n \t    && modifier != EXPAND_MEMORY\n@@ -10707,7 +10710,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,\n \t\t\t\t     (modifier == EXPAND_STACK_PARM\n \t\t\t\t      ? NULL_RTX : target),\n-\t\t\t\t     ext_mode, ext_mode, reversep);\n+\t\t\t\t     ext_mode, ext_mode, reversep, alt_rtl);\n \n \t    /* If the result has a record type and the mode of OP0 is an\n \t       integral mode then, if BITSIZE is narrower than this mode\n@@ -10928,7 +10931,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       else if (reduce_bit_field)\n \treturn extract_bit_field (op0, TYPE_PRECISION (type), 0,\n \t\t\t\t  TYPE_UNSIGNED (type), NULL_RTX,\n-\t\t\t\t  mode, mode, false);\n+\t\t\t\t  mode, mode, false, NULL);\n       /* As a last resort, spill op0 to memory, and reload it in a\n \t different mode.  */\n       else if (!MEM_P (op0))"}, {"sha": "b69e75943cc99d6c5792ae2f151f5343d2bdbc1a", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f96bf49a02464e07526289799c14c1333a71a02b", "patch": "@@ -6962,6 +6962,7 @@ maybe_legitimize_operand (enum insn_code icode, unsigned int opno,\n \treturn true;\n \n       op->value = gen_reg_rtx (mode);\n+      op->target = 0;\n       break;\n \n     case EXPAND_INPUT:"}, {"sha": "728b866f08db01de2cc330ad29088ab252f4d3ad", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f96bf49a02464e07526289799c14c1333a71a02b/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=f96bf49a02464e07526289799c14c1333a71a02b", "patch": "@@ -48,8 +48,11 @@ struct expand_operand {\n      rather than signed.  Only meaningful for certain types.  */\n   unsigned int unsigned_p : 1;\n \n+  /* Is the target operand.  */\n+  unsigned int target : 1;\n+\n   /* Unused; available for future use.  */\n-  unsigned int unused : 7;\n+  unsigned int unused : 6;\n \n   /* The mode passed to the convert_*_operand function.  It has a\n      type-dependent meaning.  */"}]}