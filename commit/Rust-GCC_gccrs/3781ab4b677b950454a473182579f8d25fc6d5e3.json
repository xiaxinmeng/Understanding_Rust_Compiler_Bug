{"sha": "3781ab4b677b950454a473182579f8d25fc6d5e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc4MWFiNGI2NzdiOTUwNDU0YTQ3MzE4MjU3OWY4ZDI1ZmM2ZDVlMw==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-10-28T15:09:12Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-10-28T15:09:12Z"}, "message": "Improve alias dump info\n\n2015-10-28  Tom de Vries  <tom@codesourcery.com>\n\n\t* tree-ssa-structalias.c (new_var_info, make_heapvar)\n\t(make_constraint_from_restrict, make_constraint_from_global_restrict)\n\t(create_function_info_for, create_variable_info_for_1)\n\t(create_variable_info_for): Add and handle add_id parameter.\n\t(get_call_vi, new_scalar_tmp_constraint_exp, handle_rhs_call)\n\t(init_base_vars): Add extra argument to calls to new_var_info.\n\t(get_vi_for_tree): Add extra argument to call to\n\tcreate_variable_info_for.\n\t(process_constraint, do_deref, process_all_all_constraints): Add extra\n\targument to calls to new_scalar_tmp_constraint_exp.\n\t(handle_lhs_call, find_func_aliases_for_builtin_call): Add extra\n\targument to calls to make_heapvar.\n\t(make_restrict_var_constraints): Add extra argument to call to\n\tmake_constraint_from_global_restrict.\n\t(intra_create_variable_infos): Add extra argument to call to\n\tcreate_variable_info_for_1.\n\t(ipa_pta_execute): Add extra argument to call to\n\tcreate_function_info_for.\n\n\t* gcc.dg/tree-ssa/pta-callused.c: Update to scan for CALLUSED(id).\n\nFrom-SVN: r229489", "tree": {"sha": "24a003e4198afc632df7539bcea0f512b03e52ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a003e4198afc632df7539bcea0f512b03e52ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3781ab4b677b950454a473182579f8d25fc6d5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3781ab4b677b950454a473182579f8d25fc6d5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3781ab4b677b950454a473182579f8d25fc6d5e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3781ab4b677b950454a473182579f8d25fc6d5e3/comments", "author": null, "committer": null, "parents": [{"sha": "eb9678e7193f97b21d45d4cfe0534c7f22052563", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb9678e7193f97b21d45d4cfe0534c7f22052563", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb9678e7193f97b21d45d4cfe0534c7f22052563"}], "stats": {"total": 139, "additions": 88, "deletions": 51}, "files": [{"sha": "440d84354c7c63bee967faa26cd4a09ae8abe20f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3781ab4b677b950454a473182579f8d25fc6d5e3", "patch": "@@ -1,3 +1,24 @@\n+2015-10-28  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* tree-ssa-structalias.c (new_var_info, make_heapvar)\n+\t(make_constraint_from_restrict, make_constraint_from_global_restrict)\n+\t(create_function_info_for, create_variable_info_for_1)\n+\t(create_variable_info_for): Add and handle add_id parameter.\n+\t(get_call_vi, new_scalar_tmp_constraint_exp, handle_rhs_call)\n+\t(init_base_vars): Add extra argument to calls to new_var_info.\n+\t(get_vi_for_tree): Add extra argument to call to\n+\tcreate_variable_info_for.\n+\t(process_constraint, do_deref, process_all_all_constraints): Add extra\n+\targument to calls to new_scalar_tmp_constraint_exp.\n+\t(handle_lhs_call, find_func_aliases_for_builtin_call): Add extra\n+\targument to calls to make_heapvar.\n+\t(make_restrict_var_constraints): Add extra argument to call to\n+\tmake_constraint_from_global_restrict.\n+\t(intra_create_variable_infos): Add extra argument to call to\n+\tcreate_variable_info_for_1.\n+\t(ipa_pta_execute): Add extra argument to call to\n+\tcreate_function_info_for.\n+\n 2015-10-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/aarch64/aarch64.md (call, call_value, sibcall): Handle noplt."}, {"sha": "b28a986107dab3cd6362a461f32c725a05e2d726", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3781ab4b677b950454a473182579f8d25fc6d5e3", "patch": "@@ -1,3 +1,7 @@\n+2015-10-28  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* gcc.dg/tree-ssa/pta-callused.c: Update to scan for CALLUSED(id).\n+\n 2015-10-28  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/67600"}, {"sha": "b9a57d8d13513c17abfd5c28a4a872589d53d814", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-callused.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c?ref=3781ab4b677b950454a473182579f8d25fc6d5e3", "patch": "@@ -22,5 +22,5 @@ int bar (int b)\n   return *foo (&q);\n }\n \n-/* { dg-final { scan-tree-dump \"CALLUSED = { ESCAPED NONLOCAL f.* i q }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"CALLUSED\\\\(\\[0-9\\]+\\\\) = { ESCAPED NONLOCAL f.* i q }\" \"alias\" } } */\n "}, {"sha": "711b5a0059d1b1b37eeea660fbdb8fb717543546", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 62, "deletions": 50, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3781ab4b677b950454a473182579f8d25fc6d5e3/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=3781ab4b677b950454a473182579f8d25fc6d5e3", "patch": "@@ -220,7 +220,7 @@ static bitmap_obstack oldpta_obstack;\n /* Used for per-solver-iteration bitmaps.  */\n static bitmap_obstack iteration_obstack;\n \n-static unsigned int create_variable_info_for (tree, const char *);\n+static unsigned int create_variable_info_for (tree, const char *, bool);\n typedef struct constraint_graph *constraint_graph_t;\n static void unify_nodes (constraint_graph_t, unsigned int, unsigned int, bool);\n \n@@ -361,11 +361,18 @@ enum { nothing_id = 1, anything_id = 2, string_id = 3,\n    to the vector of variable info structures.  */\n \n static varinfo_t\n-new_var_info (tree t, const char *name)\n+new_var_info (tree t, const char *name, bool add_id)\n {\n   unsigned index = varmap.length ();\n   varinfo_t ret = variable_info_pool.allocate ();\n \n+  if (dump_file && add_id)\n+    {\n+      char *tempname = xasprintf (\"%s(%d)\", name, index);\n+      name = ggc_strdup (tempname);\n+      free (tempname);\n+    }\n+\n   ret->id = index;\n   ret->name = name;\n   ret->decl = t;\n@@ -416,13 +423,13 @@ get_call_vi (gcall *call)\n   if (existed)\n     return *slot_p;\n \n-  vi = new_var_info (NULL_TREE, \"CALLUSED\");\n+  vi = new_var_info (NULL_TREE, \"CALLUSED\", true);\n   vi->offset = 0;\n   vi->size = 1;\n   vi->fullsize = 2;\n   vi->is_full_var = true;\n \n-  vi2 = new_var_info (NULL_TREE, \"CALLCLOBBERED\");\n+  vi2 = new_var_info (NULL_TREE, \"CALLCLOBBERED\", true);\n   vi2->offset = 1;\n   vi2->size = 1;\n   vi2->fullsize = 2;\n@@ -2884,20 +2891,23 @@ get_vi_for_tree (tree t)\n {\n   varinfo_t *slot = vi_for_tree->get (t);\n   if (slot == NULL)\n-    return get_varinfo (create_variable_info_for (t, alias_get_name (t)));\n+    {\n+      unsigned int id = create_variable_info_for (t, alias_get_name (t), false);\n+      return get_varinfo (id);\n+    }\n \n   return *slot;\n }\n \n /* Get a scalar constraint expression for a new temporary variable.  */\n \n static struct constraint_expr\n-new_scalar_tmp_constraint_exp (const char *name)\n+new_scalar_tmp_constraint_exp (const char *name, bool add_id)\n {\n   struct constraint_expr tmp;\n   varinfo_t vi;\n \n-  vi = new_var_info (NULL_TREE, name);\n+  vi = new_var_info (NULL_TREE, name, add_id);\n   vi->offset = 0;\n   vi->size = -1;\n   vi->fullsize = -1;\n@@ -3003,15 +3013,15 @@ process_constraint (constraint_t t)\n     {\n       /* Split into tmp = *rhs, *lhs = tmp */\n       struct constraint_expr tmplhs;\n-      tmplhs = new_scalar_tmp_constraint_exp (\"doubledereftmp\");\n+      tmplhs = new_scalar_tmp_constraint_exp (\"doubledereftmp\", true);\n       process_constraint (new_constraint (tmplhs, rhs));\n       process_constraint (new_constraint (lhs, tmplhs));\n     }\n   else if (rhs.type == ADDRESSOF && lhs.type == DEREF)\n     {\n       /* Split into tmp = &rhs, *lhs = tmp */\n       struct constraint_expr tmplhs;\n-      tmplhs = new_scalar_tmp_constraint_exp (\"derefaddrtmp\");\n+      tmplhs = new_scalar_tmp_constraint_exp (\"derefaddrtmp\", true);\n       process_constraint (new_constraint (tmplhs, rhs));\n       process_constraint (new_constraint (lhs, tmplhs));\n     }\n@@ -3315,7 +3325,7 @@ do_deref (vec<ce_s> *constraints)\n       else if (c->type == DEREF)\n \t{\n \t  struct constraint_expr tmplhs;\n-\t  tmplhs = new_scalar_tmp_constraint_exp (\"dereftmp\");\n+\t  tmplhs = new_scalar_tmp_constraint_exp (\"dereftmp\", true);\n \t  process_constraint (new_constraint (tmplhs, *c));\n \t  c->var = tmplhs.var;\n \t}\n@@ -3573,7 +3583,7 @@ process_all_all_constraints (vec<ce_s> lhsc,\n   else\n     {\n       struct constraint_expr tmp;\n-      tmp = new_scalar_tmp_constraint_exp (\"allalltmp\");\n+      tmp = new_scalar_tmp_constraint_exp (\"allalltmp\", true);\n       FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n \tprocess_constraint (new_constraint (tmp, *rhsp));\n       FOR_EACH_VEC_ELT (lhsc, i, lhsp)\n@@ -3758,15 +3768,15 @@ build_fake_var_decl (tree type)\n    Return the created variable.  */\n \n static varinfo_t\n-make_heapvar (const char *name)\n+make_heapvar (const char *name, bool add_id)\n {\n   varinfo_t vi;\n   tree heapvar;\n   \n   heapvar = build_fake_var_decl (ptr_type_node);\n   DECL_EXTERNAL (heapvar) = 1;\n \n-  vi = new_var_info (heapvar, name);\n+  vi = new_var_info (heapvar, name, add_id);\n   vi->is_artificial_var = true;\n   vi->is_heap_var = true;\n   vi->is_unknown_size_var = true;\n@@ -3784,9 +3794,9 @@ make_heapvar (const char *name)\n    for tracking restrict pointers.  */\n \n static varinfo_t\n-make_constraint_from_restrict (varinfo_t lhs, const char *name)\n+make_constraint_from_restrict (varinfo_t lhs, const char *name, bool add_id)\n {\n-  varinfo_t vi = make_heapvar (name);\n+  varinfo_t vi = make_heapvar (name, add_id);\n   vi->is_restrict_var = 1;\n   vi->is_global_var = 1;\n   vi->may_have_pointers = 1;\n@@ -3800,9 +3810,10 @@ make_constraint_from_restrict (varinfo_t lhs, const char *name)\n    point to global memory.  */\n \n static varinfo_t\n-make_constraint_from_global_restrict (varinfo_t lhs, const char *name)\n+make_constraint_from_global_restrict (varinfo_t lhs, const char *name,\n+\t\t\t\t      bool add_id)\n {\n-  varinfo_t vi = make_constraint_from_restrict (lhs, name);\n+  varinfo_t vi = make_constraint_from_restrict (lhs, name, add_id);\n   make_copy_constraint (vi, nonlocal_id);\n   return vi;\n }\n@@ -3882,7 +3893,7 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  varinfo_t uses = get_call_use_vi (stmt);\n \t  if (!(flags & EAF_DIRECT))\n \t    {\n-\t      varinfo_t tem = new_var_info (NULL_TREE, \"callarg\");\n+\t      varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n \t      make_constraint_to (tem->id, arg);\n \t      make_transitive_closure_constraints (tem);\n \t      make_copy_constraint (uses, tem->id);\n@@ -3896,7 +3907,7 @@ handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n \t  struct constraint_expr lhs, rhs;\n \t  varinfo_t uses = get_call_use_vi (stmt);\n \t  varinfo_t clobbers = get_call_clobber_vi (stmt);\n-\t  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\");\n+\t  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n \t  make_constraint_to (tem->id, arg);\n \t  if (!(flags & EAF_DIRECT))\n \t    make_transitive_closure_constraints (tem);\n@@ -3996,7 +4007,7 @@ handle_lhs_call (gcall *stmt, tree lhs, int flags, vec<ce_s> rhsc,\n       varinfo_t vi;\n       struct constraint_expr tmpc;\n       rhsc.create (0);\n-      vi = make_heapvar (\"HEAP\");\n+      vi = make_heapvar (\"HEAP\", true);\n       /* We are marking allocated storage local, we deal with it becoming\n          global by escaping and setting of vars_contains_escaped_heap.  */\n       DECL_EXTERNAL (vi->decl) = 0;\n@@ -4247,7 +4258,7 @@ find_func_aliases_for_builtin_call (struct function *fn, gcall *t)\n \t  tree ptrptr = gimple_call_arg (t, 0);\n \t  get_constraint_for (ptrptr, &lhsc);\n \t  do_deref (&lhsc);\n-\t  varinfo_t vi = make_heapvar (\"HEAP\");\n+\t  varinfo_t vi = make_heapvar (\"HEAP\", true);\n \t  /* We are marking allocated storage local, we deal with it becoming\n \t     global by escaping and setting of vars_contains_escaped_heap.  */\n \t  DECL_EXTERNAL (vi->decl) = 0;\n@@ -5414,7 +5425,7 @@ count_num_arguments (tree decl, bool *is_varargs)\n    of the variable we've created for the function.  */\n \n static varinfo_t\n-create_function_info_for (tree decl, const char *name)\n+create_function_info_for (tree decl, const char *name, bool add_id)\n {\n   struct function *fn = DECL_STRUCT_FUNCTION (decl);\n   varinfo_t vi, prev_vi;\n@@ -5425,7 +5436,7 @@ create_function_info_for (tree decl, const char *name)\n \n   /* Create the variable info.  */\n \n-  vi = new_var_info (decl, name);\n+  vi = new_var_info (decl, name, add_id);\n   vi->offset = 0;\n   vi->size = 1;\n   vi->fullsize = fi_parm_base + num_args;\n@@ -5448,7 +5459,7 @@ create_function_info_for (tree decl, const char *name)\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      clobbervi = new_var_info (NULL, newname);\n+      clobbervi = new_var_info (NULL, newname, false);\n       clobbervi->offset = fi_clobbers;\n       clobbervi->size = 1;\n       clobbervi->fullsize = vi->fullsize;\n@@ -5462,7 +5473,7 @@ create_function_info_for (tree decl, const char *name)\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      usevi = new_var_info (NULL, newname);\n+      usevi = new_var_info (NULL, newname, false);\n       usevi->offset = fi_uses;\n       usevi->size = 1;\n       usevi->fullsize = vi->fullsize;\n@@ -5484,7 +5495,7 @@ create_function_info_for (tree decl, const char *name)\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      chainvi = new_var_info (fn->static_chain_decl, newname);\n+      chainvi = new_var_info (fn->static_chain_decl, newname, false);\n       chainvi->offset = fi_static_chain;\n       chainvi->size = 1;\n       chainvi->fullsize = vi->fullsize;\n@@ -5512,7 +5523,7 @@ create_function_info_for (tree decl, const char *name)\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      resultvi = new_var_info (resultdecl, newname);\n+      resultvi = new_var_info (resultdecl, newname, false);\n       resultvi->offset = fi_result;\n       resultvi->size = 1;\n       resultvi->fullsize = vi->fullsize;\n@@ -5542,7 +5553,7 @@ create_function_info_for (tree decl, const char *name)\n       newname = ggc_strdup (tempname);\n       free (tempname);\n \n-      argvi = new_var_info (argdecl, newname);\n+      argvi = new_var_info (argdecl, newname, false);\n       argvi->offset = fi_parm_base + i;\n       argvi->size = 1;\n       argvi->is_full_var = true;\n@@ -5574,7 +5585,7 @@ create_function_info_for (tree decl, const char *name)\n       /* We need sth that can be pointed to for va_start.  */\n       decl = build_fake_var_decl (ptr_type_node);\n \n-      argvi = new_var_info (decl, newname);\n+      argvi = new_var_info (decl, newname, false);\n       argvi->offset = fi_parm_base + num_args;\n       argvi->size = ~0;\n       argvi->is_full_var = true;\n@@ -5613,7 +5624,7 @@ check_for_overlaps (vec<fieldoff_s> fieldstack)\n    of DECL.  */\n \n static varinfo_t\n-create_variable_info_for_1 (tree decl, const char *name)\n+create_variable_info_for_1 (tree decl, const char *name, bool add_id)\n {\n   varinfo_t vi, newvi;\n   tree decl_type = TREE_TYPE (decl);\n@@ -5625,7 +5636,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n   if (!declsize\n       || !tree_fits_uhwi_p (declsize))\n     {\n-      vi = new_var_info (decl, name);\n+      vi = new_var_info (decl, name, add_id);\n       vi->offset = 0;\n       vi->size = ~0;\n       vi->fullsize = ~0;\n@@ -5680,7 +5691,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n   if (fieldstack.length () == 0\n       || fieldstack.length () > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n     {\n-      vi = new_var_info (decl, name);\n+      vi = new_var_info (decl, name, add_id);\n       vi->offset = 0;\n       vi->may_have_pointers = true;\n       vi->fullsize = tree_to_uhwi (declsize);\n@@ -5693,7 +5704,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n       return vi;\n     }\n \n-  vi = new_var_info (decl, name);\n+  vi = new_var_info (decl, name, add_id);\n   vi->fullsize = tree_to_uhwi (declsize);\n   if (fieldstack.length () == 1)\n     vi->is_full_var = true;\n@@ -5728,7 +5739,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n       newvi->only_restrict_pointers = fo->only_restrict_pointers;\n       if (i + 1 < fieldstack.length ())\n \t{\n-\t  varinfo_t tem = new_var_info (decl, name);\n+\t  varinfo_t tem = new_var_info (decl, name, false);\n \t  newvi->next = tem->id;\n \t  tem->head = vi->id;\n \t}\n@@ -5738,9 +5749,9 @@ create_variable_info_for_1 (tree decl, const char *name)\n }\n \n static unsigned int\n-create_variable_info_for (tree decl, const char *name)\n+create_variable_info_for (tree decl, const char *name, bool add_id)\n {\n-  varinfo_t vi = create_variable_info_for_1 (decl, name);\n+  varinfo_t vi = create_variable_info_for_1 (decl, name, add_id);\n   unsigned int id = vi->id;\n \n   insert_vi_for_tree (decl, vi);\n@@ -5761,7 +5772,8 @@ create_variable_info_for (tree decl, const char *name)\n \t  || vi->only_restrict_pointers)\n \t{\n \t  varinfo_t rvi\n-\t    = make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t    = make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\",\n+\t\t\t\t\t\t    true);\n \t  /* ???  For now exclude reads from globals as restrict sources\n \t     if those are not (indirectly) from incoming parameters.  */\n \t  rvi->is_restrict_var = false;\n@@ -5855,7 +5867,7 @@ make_restrict_var_constraints (varinfo_t vi)\n     if (vi->may_have_pointers)\n       {\n \tif (vi->only_restrict_pointers)\n-\t  make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t  make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\", true);\n \telse\n \t  make_copy_constraint (vi, nonlocal_id);\n       }\n@@ -5882,7 +5894,7 @@ intra_create_variable_infos (struct function *fn)\n       varinfo_t p = lookup_vi_for_tree (t);\n       if (p == NULL)\n \t{\n-\t  p = create_variable_info_for_1 (t, alias_get_name (t));\n+\t  p = create_variable_info_for_1 (t, alias_get_name (t), false);\n \t  insert_vi_for_tree (t, p);\n \t}\n \n@@ -5895,7 +5907,7 @@ intra_create_variable_infos (struct function *fn)\n \t  varinfo_t vi;\n \t  tree heapvar = build_fake_var_decl (TREE_TYPE (TREE_TYPE (t)));\n \t  DECL_EXTERNAL (heapvar) = 1;\n-\t  vi = create_variable_info_for_1 (heapvar, \"PARM_NOALIAS\");\n+\t  vi = create_variable_info_for_1 (heapvar, \"PARM_NOALIAS\", true);\n \t  vi->is_restrict_var = 1;\n \t  insert_vi_for_tree (heapvar, vi);\n \t  make_constraint_from (p, vi->id);\n@@ -5904,13 +5916,13 @@ intra_create_variable_infos (struct function *fn)\n \t}\n \n       if (restrict_pointer_p)\n-\tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\");\n+\tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\", true);\n       else\n \t{\n \t  for (; p; p = vi_next (p))\n \t    {\n \t      if (p->only_restrict_pointers)\n-\t\tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\");\n+\t\tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\", true);\n \t      else if (p->may_have_pointers)\n \t\tmake_constraint_from (p, nonlocal_id);\n \t    }\n@@ -6512,7 +6524,7 @@ init_base_vars (void)\n \n   /* Create the NULL variable, used to represent that a variable points\n      to NULL.  */\n-  var_nothing = new_var_info (NULL_TREE, \"NULL\");\n+  var_nothing = new_var_info (NULL_TREE, \"NULL\", false);\n   gcc_assert (var_nothing->id == nothing_id);\n   var_nothing->is_artificial_var = 1;\n   var_nothing->offset = 0;\n@@ -6524,7 +6536,7 @@ init_base_vars (void)\n \n   /* Create the ANYTHING variable, used to represent that a variable\n      points to some unknown piece of memory.  */\n-  var_anything = new_var_info (NULL_TREE, \"ANYTHING\");\n+  var_anything = new_var_info (NULL_TREE, \"ANYTHING\", false);\n   gcc_assert (var_anything->id == anything_id);\n   var_anything->is_artificial_var = 1;\n   var_anything->size = ~0;\n@@ -6550,7 +6562,7 @@ init_base_vars (void)\n   /* Create the STRING variable, used to represent that a variable\n      points to a string literal.  String literals don't contain\n      pointers so STRING doesn't point to anything.  */\n-  var_string = new_var_info (NULL_TREE, \"STRING\");\n+  var_string = new_var_info (NULL_TREE, \"STRING\", false);\n   gcc_assert (var_string->id == string_id);\n   var_string->is_artificial_var = 1;\n   var_string->offset = 0;\n@@ -6561,7 +6573,7 @@ init_base_vars (void)\n \n   /* Create the ESCAPED variable, used to represent the set of escaped\n      memory.  */\n-  var_escaped = new_var_info (NULL_TREE, \"ESCAPED\");\n+  var_escaped = new_var_info (NULL_TREE, \"ESCAPED\", false);\n   gcc_assert (var_escaped->id == escaped_id);\n   var_escaped->is_artificial_var = 1;\n   var_escaped->offset = 0;\n@@ -6571,7 +6583,7 @@ init_base_vars (void)\n \n   /* Create the NONLOCAL variable, used to represent the set of nonlocal\n      memory.  */\n-  var_nonlocal = new_var_info (NULL_TREE, \"NONLOCAL\");\n+  var_nonlocal = new_var_info (NULL_TREE, \"NONLOCAL\", false);\n   gcc_assert (var_nonlocal->id == nonlocal_id);\n   var_nonlocal->is_artificial_var = 1;\n   var_nonlocal->offset = 0;\n@@ -6625,7 +6637,7 @@ init_base_vars (void)\n \n   /* Create the STOREDANYTHING variable, used to represent the set of\n      variables stored to *ANYTHING.  */\n-  var_storedanything = new_var_info (NULL_TREE, \"STOREDANYTHING\");\n+  var_storedanything = new_var_info (NULL_TREE, \"STOREDANYTHING\", false);\n   gcc_assert (var_storedanything->id == storedanything_id);\n   var_storedanything->is_artificial_var = 1;\n   var_storedanything->offset = 0;\n@@ -6635,7 +6647,7 @@ init_base_vars (void)\n \n   /* Create the INTEGER variable, used to represent that a variable points\n      to what an INTEGER \"points to\".  */\n-  var_integer = new_var_info (NULL_TREE, \"INTEGER\");\n+  var_integer = new_var_info (NULL_TREE, \"INTEGER\", false);\n   gcc_assert (var_integer->id == integer_id);\n   var_integer->is_artificial_var = 1;\n   var_integer->size = ~0;\n@@ -7301,7 +7313,7 @@ ipa_pta_execute (void)\n       gcc_assert (!node->clone_of);\n \n       vi = create_function_info_for (node->decl,\n-\t\t\t             alias_get_name (node->decl));\n+\t\t\t\t     alias_get_name (node->decl), false);\n       node->call_for_symbol_thunks_and_aliases\n \t(associate_varinfo_to_alias, vi, true);\n     }"}]}