{"sha": "233ce289250944dde071638799f9ba1a51a0a9bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMzY2UyODkyNTA5NDRkZGUwNzE2Mzg3OTlmOWJhMWE1MWEwYTliZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-24T19:38:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-24T19:38:14Z"}, "message": "re PR lto/66180 (many -Wodr false positives when building LLVM with -flto)\n\n\n\tPR lto/66180\n\t* ipa-devirt.c (type_with_linkage): Check that TYPE_STUB_DECL\n\tis set; check for assembler name at LTO time.\n\t(type_in_anonymous_namespace): Remove hacks, check that all\n\tanonymous types are called \"<anon>\"\n\t(odr_type_p): Simplify; add check for \"<anon>\"\n\t(odr_subtypes_equivalent): Add odr_type_p check.\n\t* tree.c (need_assembler_name_p): Even anonymous namespace needs\n\tassembler name.\n\t* mangle.c (mangle_decl): Mangle anonymous namespace types as\n\t\"<anon>\".\n\t* g++.dg/lto/pr66180_0.C: New testcase.\n\t* g++.dg/lto/pr66180_1.C: New testcase.\n\nFrom-SVN: r223633", "tree": {"sha": "fcafa16d16e0f29657b3cc4999c520546d0e89f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcafa16d16e0f29657b3cc4999c520546d0e89f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/233ce289250944dde071638799f9ba1a51a0a9bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/233ce289250944dde071638799f9ba1a51a0a9bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/233ce289250944dde071638799f9ba1a51a0a9bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/233ce289250944dde071638799f9ba1a51a0a9bf/comments", "author": null, "committer": null, "parents": [{"sha": "bc0c7f396b0c9648365aee462e25107db00227e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc0c7f396b0c9648365aee462e25107db00227e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc0c7f396b0c9648365aee462e25107db00227e8"}], "stats": {"total": 135, "additions": 114, "deletions": 21}, "files": [{"sha": "ac0301700ad03f9ec28f2e297320b1ac23ad8e55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -1,3 +1,15 @@\n+2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/66180\n+\t* ipa-devirt.c (type_with_linkage): Check that TYPE_STUB_DECL\n+\tis set; check for assembler name at LTO time.\n+\t(type_in_anonymous_namespace): Remove hacks, check that all\n+\tanonymous types are called \"<anon>\"\n+\t(odr_type_p): Simplify; add check for \"<anon>\"\n+\t(odr_subtypes_equivalent): Add odr_type_p check.\n+\t* tree.c (need_assembler_name_p): Even anonymous namespace needs\n+\tassembler name.\n+\n 2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-utils.h (method_class_type): Remove."}, {"sha": "b5168c2a2cb98a171b3c8063108a78c88acd146b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -1,3 +1,9 @@\n+2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/66180\n+\t* mangle.c (mangle_decl): Mangle anonymous namespace types as\n+\t\"<anon>\".\n+\n 2015-05-23  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/65936"}, {"sha": "aa466cdd0fee34c0d3ccde246f64c002940db7b7", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -3511,7 +3511,20 @@ mangle_decl (const tree decl)\n   if (dep)\n     return;\n \n-  id = get_mangled_id (decl);\n+  /* During LTO we keep mangled names of TYPE_DECLs for ODR type merging.\n+     It is not needed to assign names to anonymous namespace, but we use the\n+     \"<anon>\" marker to be able to tell if type is C++ ODR type or type\n+     produced by other language.  */\n+  if (TREE_CODE (decl) == TYPE_DECL\n+      && TYPE_STUB_DECL (TREE_TYPE (decl))\n+      && !TREE_PUBLIC (TYPE_STUB_DECL (TREE_TYPE (decl))))\n+    id = get_identifier (\"<anon>\");\n+  else\n+    {\n+      gcc_assert (TREE_CODE (decl) != TYPE_DECL\n+\t\t  || !no_linkage_check (TREE_TYPE (decl), true));\n+      id = get_mangled_id (decl);\n+    }\n   SET_DECL_ASSEMBLER_NAME (decl, id);\n \n   if (G.need_abi_warning"}, {"sha": "29438740db39c65992af9e07dec6a0cfd9eeca8e", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -252,9 +252,25 @@ type_with_linkage_p (const_tree t)\n {\n   /* Builtin types do not define linkage, their TYPE_CONTEXT is NULL.  */\n   if (!TYPE_CONTEXT (t)\n-      || !TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL)\n+      || !TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL\n+      || !TYPE_STUB_DECL (t))\n     return false;\n \n+  /* In LTO do not get confused by non-C++ produced types or types built\n+     with -fno-lto-odr-type-merigng.  */\n+  if (in_lto_p)\n+    {\n+      /* To support -fno-lto-odr-type-merigng recognize types with vtables\n+         to have linkage.  */\n+      if (RECORD_OR_UNION_TYPE_P (t)\n+\t  && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n+        return true;\n+      /* Do not accept any other types - we do not know if they were produced\n+         by C++ FE.  */\n+      if (!DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n+        return false;\n+    }\n+\n   return (RECORD_OR_UNION_TYPE_P (t)\n \t  || TREE_CODE (t) == ENUMERAL_TYPE);\n }\n@@ -267,20 +283,22 @@ type_in_anonymous_namespace_p (const_tree t)\n {\n   gcc_assert (type_with_linkage_p (t));\n \n+  /* Keep -fno-lto-odr-type-merging working by recognizing classes with vtables\n+     properly into anonymous namespaces.  */\n+  if (RECORD_OR_UNION_TYPE_P (t)\n+      && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n+    return (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)));\n+\n   if (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)))\n     {\n-      if (DECL_ARTIFICIAL (TYPE_NAME (t)))\n-\treturn true;\n-      tree ctx = DECL_CONTEXT (TYPE_NAME (t));\n-      while (ctx)\n-\t{\n-\t  if (TREE_CODE (ctx) == NAMESPACE_DECL)\n-\t    return !TREE_PUBLIC (ctx);\n-\t  if (TREE_CODE (ctx) == BLOCK)\n-\t    ctx = BLOCK_SUPERCONTEXT (ctx);\n-\t  else\n-\t    ctx = get_containing_scope (ctx);\n-\t}\n+      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n+ \t verify that this match with type_in_anonymous_namespace_p.  */\n+#ifdef ENABLE_CHECKING\n+      if (in_lto_p)\n+\tgcc_assert (!strcmp (\"<anon>\",\n+\t\t    IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n+#endif\n+      return true;\n     }\n   return false;\n }\n@@ -292,14 +310,29 @@ type_in_anonymous_namespace_p (const_tree t)\n bool\n odr_type_p (const_tree t)\n {\n-  if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n-    return true;\n   /* We do not have this information when not in LTO, but we do not need\n      to care, since it is used only for type merging.  */\n   gcc_checking_assert (in_lto_p || flag_lto);\n \n-  return (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n-          && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n+  /* To support -fno-lto-odr-type-merging consider types with vtables ODR.  */\n+  if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n+    return true;\n+\n+  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n+      && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))))\n+    {\n+#ifdef ENABLE_CHECKING\n+      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n+ \t verify that this match with type_in_anonymous_namespace_p.  */\n+      gcc_assert (!type_with_linkage_p (t)\n+\t\t  || strcmp (\"<anon>\",\n+\t\t\t     IDENTIFIER_POINTER\n+\t\t\t        (DECL_ASSEMBLER_NAME (TYPE_NAME (t))))\n+\t\t  || type_in_anonymous_namespace_p (t));\n+#endif\n+      return true;\n+    }\n+  return false;\n }\n \n /* Return TRUE if all derived types of T are known and thus\n@@ -774,7 +807,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n         return false;\n       /* Limit recursion: If subtypes are ODR types and we know\n          that they are same, be happy.  */\n-      if (!get_odr_type (t1, true)->odr_violated)\n+      if (!odr_type_p (t1) || !get_odr_type (t1, true)->odr_violated)\n         return true;\n     }\n "}, {"sha": "7e6122da27119a3a3fb2a3a772cf6b74bb96bed9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -1,3 +1,9 @@\n+2015-05-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/66180\n+\t* g++.dg/lto/pr66180_0.C: New testcase.\n+\t* g++.dg/lto/pr66180_1.C: New testcase.\n+\n 2015-05-24  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/66257"}, {"sha": "c22dc284b1bd8bb1fb272f90774fc7e53b33edf0", "filename": "gcc/testsuite/g++.dg/lto/pr66180_0.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr66180_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr66180_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr66180_0.C?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -0,0 +1,13 @@\n+// { dg-lto-do link }\n+// { dg-lto-options { { -flto -std=c++14 -r -nostdlib } } }\n+#include <memory>\n+namespace {\n+class A {\n+  int i;\n+};\n+}\n+class G {\n+  std::unique_ptr<A> foo() const;\n+};\n+std::unique_ptr<A> G::foo() const { return std::make_unique<A>(); }\n+"}, {"sha": "a4deb96f1fb050180ac24a6b64c55e36e5b6df7c", "filename": "gcc/testsuite/g++.dg/lto/pr66180_1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr66180_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr66180_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr66180_1.C?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -0,0 +1,11 @@\n+#include <memory>\n+namespace {\n+class A {\n+  bool a;\n+};\n+}\n+class H {\n+  std::unique_ptr<A> bar() const;\n+};\n+std::unique_ptr<A> H::bar() const { return std::make_unique<A>(); }\n+"}, {"sha": "119bcbe18464673b5f7ed850c8217b20fe98b2ad", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/233ce289250944dde071638799f9ba1a51a0a9bf/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=233ce289250944dde071638799f9ba1a51a0a9bf", "patch": "@@ -5182,8 +5182,7 @@ need_assembler_name_p (tree decl)\n       && DECL_NAME (decl)\n       && decl == TYPE_NAME (TREE_TYPE (decl))\n       && !TYPE_ARTIFICIAL (TREE_TYPE (decl))\n-      && ((type_with_linkage_p (TREE_TYPE (decl))\n-\t   && !type_in_anonymous_namespace_p (TREE_TYPE (decl)))\n+      && (type_with_linkage_p (TREE_TYPE (decl))\n \t  || TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE)\n       && !variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n     return !DECL_ASSEMBLER_NAME_SET_P (decl);"}]}