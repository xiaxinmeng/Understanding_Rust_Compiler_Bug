{"sha": "d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJlYzI5ZmJmMWI4ZDliYzY3NzhmNjRlM2QyYzdhMjVlYTA5NTg0NQ==", "commit": {"author": {"name": "Mumit Khan", "email": "khan@xraylith.wisc.edu", "date": "1999-04-12T01:25:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-12T01:25:38Z"}, "message": "dtime_.c: Handle all variants of WIN32.\n\n        * libU77/dtime_.c: Handle all variants of WIN32.\n        * libU77/etime_.c: Likewise.\n\nFrom-SVN: r26358", "tree": {"sha": "cdf55b40c9ba161ea134658a8cdee7bdd388d271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdf55b40c9ba161ea134658a8cdee7bdd388d271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845/comments", "author": null, "committer": null, "parents": [{"sha": "2206b47188d5736643c6ce70694aa5c89e3b0bd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2206b47188d5736643c6ce70694aa5c89e3b0bd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2206b47188d5736643c6ce70694aa5c89e3b0bd5"}], "stats": {"total": 148, "additions": 146, "deletions": 2}, "files": [{"sha": "b932c06ba32bce0ae48cdecb15098aacc371b1d1", "filename": "libf2c/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845/libf2c%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845/libf2c%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FChangeLog?ref=d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845", "patch": "@@ -1,5 +1,8 @@\n Sun Apr 11 23:30:42 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \n+\t* libU77/dtime_.c: Handle all variants of WIN32.\n+\t* libU77/etime_.c: Likewise.\n+\n \t* libU77/aclocal.m4: New file.\n \t* libU77/configure.in (LIBU77_HAVE_STRUCT_TIMEZONE): Add test.\n \t* libU77/acconfig.h (HAVE_STRUCT_TIMEZONE): Add macro."}, {"sha": "0200a01af6fb3e1be949f4a5b8447e15c4564884", "filename": "libf2c/libU77/dtime_.c", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845/libf2c%2FlibU77%2Fdtime_.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845/libf2c%2FlibU77%2Fdtime_.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibU77%2Fdtime_.c?ref=d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845", "patch": "@@ -33,6 +33,11 @@ Boston, MA 02111-1307, USA.  */\n #  include <sys/time.h>\n #  include <sys/resource.h>\n #endif\n+#if defined (_WIN32)\n+#  include <windows.h>\n+#  undef min\n+#  undef max\n+#endif\n #include <errno.h>\t\t/* for ENOSYS */\n #include \"f2c.h\"\n \n@@ -50,7 +55,73 @@ double G77_dtime_0 (tarray)\n double G77_dtime_0 (real tarray[2])\n #endif\n {\n-#if defined (HAVE_GETRUSAGE) || defined (HAVE_TIMES)\n+#if defined (_WIN32)\n+  static int win32_platform = -1;\n+\n+  if (win32_platform == -1)\n+    {\n+      OSVERSIONINFO osv;\n+      osv.dwOSVersionInfoSize = sizeof (osv);\n+      GetVersionEx (&osv);\n+      win32_platform = osv.dwPlatformId;\n+    }\n+  \n+  /* We need to use this hack on non-NT platforms, where the first call\n+     returns 0.0 and subsequent ones return the correct value. */\n+  if (win32_platform != VER_PLATFORM_WIN32_NT)\n+    {\n+      static unsigned long long clock_freq;\n+      static unsigned long long old_count;\n+      unsigned long long count;\n+      double delta;\n+      LARGE_INTEGER counter_val;\n+\n+      if (clock_freq == 0)\n+\t{\n+\t  LARGE_INTEGER freq;\n+\t  if (! QueryPerformanceFrequency (&freq))\n+\t    {\n+\t      errno = ENOSYS;\n+\t      return 0.0;\n+\t    }\n+\t  else\n+\t    {\n+\t      clock_freq = ((unsigned long long) freq.HighPart << 32)\n+                           + ((unsigned) freq.LowPart);\n+\t    }\n+\t}\n+\n+      if (! QueryPerformanceCounter (&counter_val))\n+\treturn -1.0;\n+\n+      count = ((unsigned long long) counter_val.HighPart << 32)\n+              + (unsigned) counter_val.LowPart;\n+      delta = ((double) (count - old_count)) / clock_freq;\n+      tarray[0] = (float) delta;\n+      tarray[1] = 0.0;\n+      old_count = count;\n+    }\n+  else\n+    {\n+      static unsigned long long old_utime, old_stime;\n+      unsigned long long utime, stime;\n+      FILETIME creation_time, exit_time, kernel_time, user_time;\n+\n+      GetProcessTimes (GetCurrentProcess (), &creation_time, &exit_time,\n+\t\t       &kernel_time, &user_time);\n+      utime = ((unsigned long long) user_time.dwHighDateTime << 32) \n+\t      + (unsigned) user_time.dwLowDateTime;\n+      stime = ((unsigned long long) kernel_time.dwHighDateTime << 32) \n+\t      + (unsigned) kernel_time.dwLowDateTime;\n+\n+      tarray[0] = (utime - old_utime) / 1.0e7;\n+      tarray[1] = (stime - old_stime) / 1.0e7;\n+      old_utime = utime;\n+      old_stime = stime;\n+    }\n+  return tarray[0] + tarray[1];\n+\n+#elif defined (HAVE_GETRUSAGE) || defined (HAVE_TIMES)\n   /* The getrusage version is only the default for convenience. */\n #ifdef HAVE_GETRUSAGE\n   float utime, stime;"}, {"sha": "374fc2feba239ed3fd1f9fcf153894095176cea8", "filename": "libf2c/libU77/etime_.c", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845/libf2c%2FlibU77%2Fetime_.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845/libf2c%2FlibU77%2Fetime_.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libf2c%2FlibU77%2Fetime_.c?ref=d2ec29fbf1b8d9bc6778f64e3d2c7a25ea095845", "patch": "@@ -33,6 +33,11 @@ Boston, MA 02111-1307, USA.  */\n #  include <sys/time.h>\n #  include <sys/resource.h>\n #endif\n+#if defined (_WIN32)\n+#  include <windows.h>\n+#  undef min\n+#  undef max\n+#endif\n #include <errno.h>\t\t/* for ENOSYS */\n #include \"f2c.h\"\n \n@@ -50,7 +55,72 @@ double G77_etime_0 (tarray)\n double G77_etime_0 (real tarray[2])\n #endif\n {\n-#if defined (HAVE_GETRUSAGE) || defined (HAVE_TIMES)\n+#if defined (_WIN32)\n+  static int win32_platform = -1;\n+  double usertime, systime;\n+\n+  if (win32_platform == -1)\n+    {\n+      OSVERSIONINFO osv;\n+      osv.dwOSVersionInfoSize = sizeof (osv);\n+      GetVersionEx (&osv);\n+      win32_platform = osv.dwPlatformId;\n+    }\n+  \n+  /* non-NT platforms don't have a clue as to how long a process has\n+     been running, so simply return the uptime. Bad judgement call? */\n+  if (win32_platform != VER_PLATFORM_WIN32_NT)\n+    {\n+      static unsigned long long clock_freq;\n+      static unsigned long long old_count;\n+      unsigned long long count;\n+      LARGE_INTEGER counter_val;\n+\n+      if (clock_freq == 0)\n+\t{\n+\t  LARGE_INTEGER freq;\n+\t  if (! QueryPerformanceFrequency (&freq))\n+\t    {\n+\t      errno = ENOSYS;\n+\t      return 0.0;\n+\t    }\n+\t  else\n+\t    {\n+\t      clock_freq = ((unsigned long long) freq.HighPart << 32)\n+                           + ((unsigned) freq.LowPart);\n+\t      if (! QueryPerformanceCounter (&counter_val))\n+\t\treturn -1.0;\n+\t      old_count = ((unsigned long long) counter_val.HighPart << 32)\n+\t                  + (unsigned) counter_val.LowPart;\n+\t    }\n+\t}\n+\n+      if (! QueryPerformanceCounter (&counter_val))\n+\treturn -1.0;\n+\n+      count = ((unsigned long long) counter_val.HighPart << 32)\n+              + (unsigned) counter_val.LowPart;\n+      tarray[0] = usertime = (double) (count - old_count) / clock_freq;\n+      tarray[1] = systime = 0.0;\n+    }\n+  else\n+    {\n+      FILETIME creation_time, exit_time, kernel_time, user_time;\n+      unsigned long long utime, stime;\n+\n+      GetProcessTimes (GetCurrentProcess (), &creation_time, &exit_time,\n+\t\t       &kernel_time, &user_time);\n+      utime = ((unsigned long long) user_time.dwHighDateTime << 32)\n+\t      + (unsigned) user_time.dwLowDateTime;\n+      stime = ((unsigned long long) kernel_time.dwHighDateTime << 32)\n+\t      + (unsigned) kernel_time.dwLowDateTime;\n+\n+      tarray[0] = usertime = utime / 1.0e7;\n+      tarray[1] = systime = stime / 1.0e7;\n+  }\n+  return usertime + systime;\n+\n+#elif defined (HAVE_GETRUSAGE) || defined (HAVE_TIMES)\n   /* The getrusage version is only the default for convenience. */\n #ifdef HAVE_GETRUSAGE\n   struct rusage rbuff;"}]}