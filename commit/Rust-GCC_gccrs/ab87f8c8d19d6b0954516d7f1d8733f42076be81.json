{"sha": "ab87f8c8d19d6b0954516d7f1d8733f42076be81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI4N2Y4YzhkMTlkNmIwOTU0NTE2ZDdmMWQ4NzMzZjQyMDc2YmU4MQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-01-27T01:43:17Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-27T01:43:17Z"}, "message": "Merge in gcc2 snapshot 19980929.  See gcc/ChangeLog and gcc/FSFChangeLog for\ndetails.\n\nFrom-SVN: r24879", "tree": {"sha": "e7daf0f28ecb5da9660b21aee68e6919f846c183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7daf0f28ecb5da9660b21aee68e6919f846c183"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab87f8c8d19d6b0954516d7f1d8733f42076be81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab87f8c8d19d6b0954516d7f1d8733f42076be81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab87f8c8d19d6b0954516d7f1d8733f42076be81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab87f8c8d19d6b0954516d7f1d8733f42076be81/comments", "author": null, "committer": null, "parents": [{"sha": "01b4cf2b7a1fe9a3f6f070217be5f93854c54545", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b4cf2b7a1fe9a3f6f070217be5f93854c54545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b4cf2b7a1fe9a3f6f070217be5f93854c54545"}], "stats": {"total": 8625, "additions": 6191, "deletions": 2434}, "files": [{"sha": "e717b20e073b9288aa6d693d3d746c570ddd0c4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,3 +1,25 @@\n+Wed Jan 27 02:20:48 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Merge gcc2 snapshot 19980929.\n+\n+\t* cccp.c (PRINTF_PROTO): Remove.\n+\t(PRINTF_PROTO_{1,2,3,4}: Likewise.\n+\t* cexp.y: Likewise.\n+\t* system.h: Add PRINTF_PROTO and PRINTF_PROTO_{1,2,3,4}.\n+\n+\t* fix-header.c (cpp_file_lin_for_message): Delete.  In libcpp.\n+\t(cpp_print_containing_files, v_cpp_message, cpp_message): Likewise.\n+\t(cpp_fatal, cpp-Pfatal_with_name): Likewise.\n+\n+\t* gen-protos.c (hashf): Delete in cpphash.o\n+\t* gen-protos.c (hashf): Delete in cpphash.o\n+\n+\t* expr.c: Do not merge SAVE_STACKAREA_MODE changes.\n+\t* expmed.c: Likewise.\n+\t* rs6000.md: Likewise.\n+\n+\t* rs6000.c, rs6000.md: Do not merge formatting changes yet.\n+\n Wed Jan 27 01:13:42 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* rs6000.c (input_operand): Don't expect CONST around CONSTANT_P_RTX."}, {"sha": "261934c3d1232b8475a5e9dcce111bd040bbbc5c", "filename": "gcc/FSFChangeLog", "status": "modified", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FFSFChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FFSFChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FFSFChangeLog?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,652 @@\n+Tue Sep 29 09:57:26 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (get_inner_reference): Fix typo in last change.\n+\n+Mon Sep 27 21:34:00 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* po/en_UK.po (Project-Id-Version): Set to cc 2.8.1.19980813 for now.\n+\t(PO-Revision-Date): Set to the current date.\n+\n+Sun Sep 27 07:33:18 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* m68k/vxm68k.h (LINK_SPEC): Always use -r.\n+\t(WIDEST_HARDWARE_FP_SIZE): Define.\n+\n+\t* reload.c (push_reload): If in STRICT_LOW_PART, always reload\n+\tinside even if SUBREG_WORD is not zero.\n+\n+\t* flow.c (print_rtl_with_bb): Don't say not in basic block if we\n+\taren't making basic blocks.8\n+\n+Sat Sep 26 10:57:09 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* function.c (optimize_bit_field): Don't remove SUBREG from dest\n+\tif SUBREG_REG is multi-word.\n+\n+Wed Sep 23 05:43:23 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload.c (find_reloads_address): Deal with address which is\n+\tan AND; clean up return values some more.\n+\n+Fri Sep 11 13:02:26 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* function.c (purge_addressof_1): Properly copy flags when making MEM.\n+\n+Mon Sep  7 18:33:06 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (get_inner_reference): If not COMPONENT_REF or BITFIELD_REF\n+\tand mode is BLKmode, set size_tree.\n+\n+\t* expr.c (expand_builtin, case BUILT_IN_LONGJMP): Fix typo in\n+\tlast change.\n+\n+Wed Sep  2 15:38:01 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\t* libgcc2.c (__floatdisf): Use signed comparison to test\n+\twhether u is close to zero; unsigned comparison is not what's\n+\twanted here.\n+\n+Mon Aug 17 02:19:30 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* xcoffout.c (UNKNOWN_STAB): Fix typo in previous change; missing\n+ \tbackslash before newline.\n+\n+Mon Aug 17 00:12:42 1998  Paul Eggert  <eggert@twinsun.com>\n+  \t\n+\t* reorg.c (check_annul_list_true_false): Fix typo in Jul 17 change.\n+\n+Sun Aug  2 01:10:15 1998  Paul Eggert  <eggert@twinsun.com>\n+\n+\tAdd Native Language Support.\n+\n+\t* intl/, ABOUT-NLS, mkinstalldirs, po/Makefile.in.in: New\n+\tsubdirectory and files.  They should be kept identical to the\n+\tcorresponding items from the GNU gettext distribution.\n+\n+\t* ABOUT-GCC-NLS, exgettext, intl.c, intl.h, po/POTFILES.in,\n+\tpo/en_UK.po: New files.\n+\n+\t* Makefile.in (AWK, datadir, localedir, top_builddir, USE_NLS,\n+\tINTLLIBS, POSUB, INTL_SUBDIRS, HOST_INTLLIBS,\n+\tPREPEND_DOTDOT_TO_RELATIVE_PATHS, SUBDIR_FLAGS_TO_PASS, GCC_OBJS,\n+\tCOLLECT2_OBJS, CCCP_OBJS, CPPMAIN_OBJS, PROTO_OBJS, GCOV_OBJS,\n+\tINTL_DISTCLEAN, GEN_PROTOS_OBJS): New vars.\n+\t(LIBDEPS, LIBS): Add $(INTLLIBS).\n+\t(HOST_LIBDEPS, HOST_LIBS): Add $(HOST_INTLLIBS).\n+\t(LIBS): Add @LIBS@.\n+\t(ORDINARY_FLAGS_TO_PASS): New var, containing all the old values\n+\tfrom FLAGS_TO_PASS, except for CC.\n+\t(FLAGS_TO_PASS): Pass datadir, distdir, localedir.\n+\t(OBJS): Add intl.o.\n+\t(GEN): Add gencheck.\n+\t(STAGESTUFF): Add tree-check.h, gencheck$(exeext).\n+\t(native): Depend on intl.all.\n+\t(xgcc, collect2, cccp, cppmain, protoize, unprotoize, gcov): Link\n+\tintl.o.\n+\t(c-typeck.o, c-lex.o, collect2.o, gcc.o, toplev.o, integrate.o,\n+\tfinal.o, cccp.o, cppmain.o, cpplib.o, cpperror.o, s-proto,\n+\tgcov.o): Depend on intl.h.\n+\t(gencheck): Depend on $(HOST_LIBDEPS) instead of tree.h and\n+\ttree.def.\n+\t(gencheck.o, intl.o, $(top_builddir)/intl/libintl.a,\n+\t$(srcdir)/cp/parse.c, intl.all, intl.install, intl.uninstall,\n+\tintl.distdir, intl.mostlyclean, intl.clean, intl.distclean,\n+\tintl.maintainer-clean, intl.distdir-fixup, distdir-check): New\n+\trules.\n+\t(gen-protos): Link cpperror.o, cppexp.o, cpphash.o, cpplib.o,\n+\tprefix.o, version.o; needed for `cpp_notice'.\n+\t(mostlyclean): Depend on intl.mostlyclean.\n+\t(clean): Depend on intl.clean.\n+\t(distclean): Depend on intl.disclean, unless the invoker defines\n+\tINTL_DISTCLEAN to be empty.  Remove intl/libintl.h and libintl.h\n+\t(created by configure).\n+\t(maintainer-clean): Make intl.maintainer-clean, but define\n+\tINTL_DISTCLEAN to be empty.\n+\t(install-normal): Depend on intl.install.\n+\t(uninstall): Depend on intl.uninstall.\n+\t(distdir-start): Make sure invoker configured with --enable-nls.\n+\tUse $(AWK), not awk.  Make tmp/intl and tmp/po directories.\n+\t(distdir-finish): Make distdir-check at the end.\n+\t(distdir): Depend on intl.distdir, intl.distdir-fixup.\n+\t(compare, compare3, gnucompare, gnucompare3, stage1-start,\n+\tstage2-start, stage3-start, stage4-start): Handle intl\n+\tsubdirectory.\n+\n+\t* acconfig.h (ENABLE_NLS, HAVE_CATGETS, HAVE_GETTEXT,\n+\tHAVE_LC_MESSAGES, HAVE_STPCPY, PACKAGE, VERSION): New macros.\n+\n+\t* aclocal.m4 (AC_ISC_POSIX, AM_WITH_NLS, AM_GNU_GETTEXT,\n+\tAM_LC_MESSAGES, AM_PATH_PROG_WITH_TEST): New functions; taken from\n+\tgettext distribution.\n+\n+\t* bi-arity.c, bi-opcode.c, bi-opname.c: Include config file first.\n+\n+\t* c-common.c: Don't include <ctype.h>.\n+\t(tfaff): Now a function, not a string.  All users changed.\n+\t(check_format_info): Use is_C_digit, not isdigit.\n+\tReword messages to ease localization.\n+\n+\t* c-decl.c (redeclaration_error_message): Now returns int, not\n+\tmessage.\n+\t(poplevel, duplicate_decls, pushdecl): Revamp to pass explicit\n+\tstrings to diagnostic generators.\n+\t(duplicate_decls, parmlist_tags_warning, finish_struct): Reword\n+\tmessages to ease localization.\n+\n+\t* c-iterate.c (prdecl): Reword messages so that they do not require\n+\tlocalization.\n+\n+\t* c-lex.c: Include limits.h if available.\n+\tInclude intl.h.\n+\tInclude ctype.h only if MAP_CHARACTER is defined.\n+\t(UCHAR_MAX): Define if limits.h doesn't.\n+\t(C_alnum_array): New var.\n+\t(init_lex): Initialize it.\n+\t(yyerror): Localize msgid arg.\n+\t(yylex): Use is_C_alnum and is_C_digit, not isalnum and isdigit.\n+\n+\t* c-lex.h (C_alnum_array): New decl.\n+\t(is_C_alnum, is_C_digit): New macros.\n+\n+\t* c-typeck.c: Include intl.h.\n+\t(warning_init): Now takes just one arg.\n+\t(incomplete_type_error, build_unary_op, lvalue_or_else,\n+\treadonly_warning, build_modify_expr): Reword messages to ease\n+\tlocalization.\n+\t(build_unary_op, readonly_warning): Revamp to pass explicit\n+\tstrings to diagnostic generators.\n+\t(build_modify_expr, warn_for_assignment, c_expand_return):\n+\tTranslate strings passed to functions expecting translated\n+\tstrings.\n+\t(get_spelling): Remove; it was a no-op.  All callers changed.\n+\t(error_init, pedwarn_init): Now takes just one arg.  All callers\n+\tand decls changed.  This makes it easier to localize.\n+\n+\t* cccp.c: Include intl.h.\n+\t(char_name): Remove.\n+\t(check_macro_name): Now takes int 2nd arg, not char *.  All\n+\tcallers changed.\n+\t(macarg): Now returns int, not char *.  All callers changed.\n+\t(notice, vnotice, pedwarn_strange_white_space): New functions.\n+\t(verror): Now extern; used by cexp.y.\n+\t(main): Set message locale, and defer memory allocation until\n+\tafter.\n+\t(main, do_include, print_containing_files): Invoke `notice' to\n+\tlocalize notices.\n+\t(handle_directive): Invoke pedwarn_strange_white_space instead of\n+\tusing char_name.\n+\t(do_include, check_macro_name): Reword messages to ease\n+\tlocalization.\n+\t(my_strerror): Reword message so that it does not require\n+\tlocalization.\n+\t(verror, vwarning, verror_with_line, vwarning_with_line,\n+\tpedwarn_with_file_and_line, fatal): Invoke vnotice to localize\n+\tmsgid.\n+\t(initialize_char_syntax): No need to initialize char_name.\n+\n+\t* cexp.y (yyerror): Now takes msgid format and args, not just string.\n+\t(verror): New decl.\n+\t(parse_number, yylex): Reword messages to ease\n+\tlocalization.\n+\t(verror): New test function.\n+\t(pedwarn, warning): Translate msgid arg.\n+\n+\t* collect2.c: Include intl.h.\n+\t(my_strerror, main, collect_execute, scan_prog_file,\n+\tscan_libraries, read_file, end_file): Reword messages so that they\n+\tdo not require localization.\n+\t(notice): Nwe function.\n+\t(fatal, error, main, collect_execute, maybe_unlink,\n+\twrite_c_file_stat, locatelib, scan_libraries, scan_prog_file,\n+\tadd_func_table): Use it to translate msgid strings.\n+\t(main): Set message locale, and defer memory allocation until\n+\tafter.\n+\t(collect_wait): Reword messages to ease localization.\n+\t(bad_header): Revamp to pass explicit strings to diagnostic\n+\tgenerators.\n+\n+\t* combine.c (dump_combine_stats, dump_combine_total_stats):\n+\tUse fnotice to translate diagnostic messages.\n+\n+\t* config/1750a/1750a.c (memop_valid): Don't use `valid' as an\n+\tidentifier; it runs afoul of SunOS 4.1.4 <locale.h>.\n+\n+\t* config/arc/initfini.c (__do_global_dtors): Put backslash before\n+\tnewline in strings, to pacify xgettext.\n+\n+\t* config/dsp16xx/dsp16xx.c, config/dsp16xx/dsp16xx.h\n+\t(dsp16xx_invalid_register_for_compare): New function.\n+\t* config/dsp16xx/dsp16xx.md: Use it to report invalid registers.\n+\n+\t* config/i370/i370.h: Include <ctype.h>.\n+\n+\t* config/i386/i386.c: Include config.h first.\n+\n+\t* config/m32r/initfini.c  (__do_global_dtors): Put backslash before\n+\tnewline in strings, to pacify xgettext.\n+\t* config/m88k/dguxbcs.h (CPP_SPEC): Likewise.\n+\n+\t* config/rs6000/rs6000.c: Include config.h first.\n+\t* config/rs6000/rs6000.c, config/rs6000/rs6000.h\n+\t(rs6000_fatal_bad_address): New function.\n+\t* config/rs6000/rs6000.md: Use it to report bad addresses.\n+\n+\t* config/v850/v850.c: Include config.h first.\n+\n+\t* configure.in: When generating config.h and mentioning a file\n+\ttaken from the config directory, surround it with #ifdef IN_GCC,\n+\tso that programs compiled without IN_GCC -- notably in the intl\n+\tsubdirectory -- don't need to be compiled with -Iconfig.\n+\t(PACKAGE, VERSION, ALL_LINGUAS): New vars.\n+\t(AC_ARG_ENABLE): Add --enable-nls.\n+\t(AM_GNU_GETTEXT): Add.  Override XGETTEXT so that we use exgettext\n+\tinstead of xgettext to extract strings.\n+\t(all_outputs): Add intl/Makefile, po/Makefile.in.\n+\tDo not use the shell variable 'l'; it runs afoul of gettext's\n+\taclocal mechanism!\n+\tIf libintl.h is created, echo '#include \"intl/libintl.h\"'\n+\t>libintl.h so that we don't have to futz with our include paths.\n+\n+\t* cp/Make-lang.in (g++.o): Depend on gansidecl.h, intl.h, Makefile;\n+\tdo not depend on config.status.\n+\t(GXX_OBJS): New var.\n+\t(g++$(exeext)): Link intl.o.\n+\n+\t* cp/Makefile.in (top_builddir, INTLLIBS): New vars.\n+\t(LIBS): Add $(INTLLIBS).\n+\n+\t* cppalloc.c (memory_full): Use `cpp_notice' to print diagnostic.\n+\n+\t* cpperror.c: Include intl.h.\n+\t(cpp_print_containing_files): Use cpp_notice to translate messages.\n+\t(cpp_message): is_error is -1 for notices.  Translate \"warning:\".\n+\t(cpp_fatal): Translate msgid arg.\n+\n+\t* cppexp.c (cpp_lex): Revamp to pass explicit strings to\n+\tdiagnostic generators.\n+\t(cpp_parse_expr): Use cpp_error, not fprintf, to report\n+\tunimplemented operators.\n+\n+\t* cpplib.c: Include intl.h.\n+\t(check_macro_name): Now takes int 2nd arg, not char *.  All\n+\tcallers changed.\n+\t(check_macro_name, do_define): Reword messages to ease\n+\tlocalization.\n+\t(do_define): Revamp to pass explicit strings to diagnostic\n+\tgenerators.\n+\t(do_define, cpp_start_read, cpp_handle_options): Use cpp_notice to\n+\ttranslate messages.\n+\t(cpp_error, cpp_warning, cpp_warning_with_line,\n+\tcpp_pedwarn_with_file_and_line): Translate msgid arg.\n+\t(cpp_notice): New function.\n+\t(my_strerror): Reword message so that it does not require\n+\tlocalization.\n+\n+\t* cpplib.h (cpp_notice): New decl.\n+\n+\t* cppmain.c: Include intl.h.\n+\t(main): Set message locale.\n+\n+\t* cse.c (cse_main): Use fnotice to print diagnostic.\n+\n+\t* final.c: Include intl.h; do not include ctype.h.\n+\t(output_operand_lossage): Translate msgid arg.\n+\n+\t* fold-const.c (optimize_bit_field_compare, fold_truthop): Reword\n+\tmessages to ease localization.\n+\n+\t* gcc.c: Include intl.h.\n+\t(my_strerror, snapshot_warning): Reword messages so that they do\n+\tnot require localization.\n+\t(init_spec, set_spec, read_specs, execute, do_spec_1, main,\n+\tsnapshot_warning): Invoke `notice' to localize notices.\n+\t(struct switchstr): Don't use `valid' as an identifier; it runs\n+\tafoul of SunOS 4.1.4 <locale.h>.  All uses changed.\n+\t(do_spec_1): Treat %e string as msgid format, which needs\n+\ttranslation.\n+\t(main): Set message locale.\n+\t(pfatal_with_name): Invoke perror_with_name, not fatal, so that we\n+\tdon't have to translate \"%s: %s\".\n+\t(perror_with_name): Invoke printf, not error, so that we don't\n+\thave to translate \"%s: %s\".\n+\t(pfatal_pexecute): Invoke pfatal_with_name, not fatal, so that we\n+\tdon't have to translate \"%s: %s\".\n+\t(fatal, error): Translate msgid arg.\n+\t(notice): New function.\n+\n+\t* gcov.c: Include intl.h; include stdarg.h if __STDC__ is defined.\n+\t(main): Set message locale.\n+\t(fnotice): New function.\n+\t(xmalloc, fancy_abort, print_usage, open_files, read_files,\n+\tfunction_summary, output_data): Use it to to print diagnostics.\n+\n+\t* install.texi: Explain new configure options --enable-nls,\n+\t--with-included-gettext, --with-catgets.\n+\n+\t* integrate.c: Include intl.h.\n+\t(function_cannot_inline_p): Mark msgids with N_.\n+\n+\t* invoke.texi: Describe environment variables affecting locale.\n+\n+\t* pexecute.c: Include libintl.h if ENABLE_NLS, otherwise define\n+\tgettext to be a noop.\n+\t(_, N_): New macros.\n+\t(install_error_msg): Wrap inside N_.\n+\t(pexecute): Translate diagnostics.\n+\n+\t* protoize.c: Include intl.h.\n+\t(__attribute__): New macro.\n+\t(notice): New function.\n+\t(my_strerror): Reword message so that it does not require\n+\tlocalization.\n+\t(xmalloc, xrealloc, fancy_abort, safe_write, usage,\n+\tfile_normally_convertible, abspath, find_file, aux_info_corrupted,\n+\tsave_def_or_dec, gen_aux_info_file, process_aux_info_file,\n+\trename_c_file, find_extern_def, find_static_definition,\n+\tdeclare_source_confusing, edit_fn_declaration, edit_formals_lists,\n+\tadd_local_decl, add_global_decls, edit_fn_definition,\n+\tscan_for_missed_items, edit_file, main): Use `notice' to print\n+\tdiagnostic.\n+\t(main): Set message locale.\n+\n+\t* real.c (NMSGS, ermsg): Remove.\n+\t(mtherr): Revamp to pass explicit strings to diagnostic\n+\tgenerators.  Abort on invalid operations.\n+\n+\t* regclass.c (fix_register): Reword messages to ease localization.\n+\n+\t* toplev.c: Include intl.h; do not include ctype.h.\n+\t(v_really_sorry, really_sorry): Remove unused functions.\n+\t(count_error, fatal_io_error): Translate strings.\n+\t(default_print_error_function, report_error_function, main,\n+\tprint_version): Reword messages to ease localization.  Use\n+\t`notice' to translate diagnostics.\n+\t(vnotice, notice, fnotice): New functions.\n+\t(vmessage): Remove.\n+\t(v_message_with_file_and_line, vsorry): Translate msgid with\n+\tvnotice.\n+\t(v_message_with_file_and_line, v_message_with_decl): Use\n+\treport_file_and_line.  Now takes int warning flag, not prefix;\n+\tthis is easier to localize.  All callers changed.\n+\t(v_message_with_decl): Abort if first format spec is neither %%\n+\tnor %s.  Translate \"((anonymous))\".\n+\t(main): Set message locale.\n+\t(set_target_switch): Don't use `valid' as an identifier; it runs\n+\tafoul of SunOS 4.1.4 <locale.h>.\n+\t(__VERSION__): Reword message so that it does not require\n+\tlocalization.\n+\t(print_switch_values): Translate \"options passed\" and \"options\n+\tenabled\".\n+\n+\t* tree.c (valid_machine_attribute): Don't use `valid' as an\n+\tidentifier; it runs afoul of SunOS 4.1.4 <locale.h>.\n+\n+\t* xcoffout.c (xcoff_output_standard_types): Use `error' to\n+\toutput diagnostic, so that it gets translated.\n+\n+\t* patch-apollo-includes: Remove; this is part of README.APOLLO.\n+\n+Mon Jul 27 18:28:58 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload.c (find_reloads): If no_input_reloads, abort if \n+\treloads were made for addresses.\n+\t* m68k.md (sxx): Operand 0 cannot be memory.\n+\n+Fri Jul 17 07:31:04 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* m68k.c (output_move_simode_const): Use subl to move 0 into addr reg.\n+\t(output_move_[hq]imode): Likewise.\n+\n+\t* m68k.md (extend[sd]fxf2): Accept constants and general reg as\n+\tsource operand if the destination is a floating point register.\n+\n+Fri Jul 17 07:23:49 1998  Herman ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n+\n+\t* reorg.c (check_annul_list_true_false): New function.\n+\t(steal_delay_list_from_{target,fallthrough}): Call it and also\n+\trefine tests for when we may annul if already filled a slot.\n+\t(fill_slots_from_thread): Likewise.\n+\t(delete_from_delay_slot): Return newly-created thread.\n+\t(try_merge_delay_isns): Use its new return value.\n+\n+Sat Jul  4 11:07:33 1998  Eberhard Mattes  <mattes@azu.informatik.uni-stuttgart.de>\n+\n+\t* function.c (assign_parms): Handle PARALLEL which include stack.\n+\n+Sat Jul  4 09:44:29 1998  Paul Edwards  <avon@matra.com.au>\n+\n+\t* tree.c, print-tree.c, c-lang.c: Include stdio.h before tree.h.\n+\t* expr.c (bc_expand_component_address): Correct args to\n+\tbc_push_offset_and_size.\n+\t* reload1.c (reload_cse_simplify_operands): Add missing return value.\n+\n+Fri Jul  3 07:17:19 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alpha.c (normal_memory_operand): Handle case when REG will be\n+\teliminated by reload.\n+\n+Thu Jul  2 18:43:53 1998  James Carlson  <carlson@ironbridgenetworks.com>\n+ \n+\t* floatlib.c (HIDDEND_LL, MANTD_LL, PACKD_LL): New macros.\n+\t(__addsf3): Fixed cases returning wrong type and causing unintended\n+\tconversions and data corruption.\n+\t(__mulsf3): Fixed rounding flaws caused wrong scaling.\n+\t(__float{didf,sisf,disf},__fix{,uns}dfdi): New functions.\n+\t(__{gt,ge,lt,le,eq,ne}df2): Likewise.\n+\t(__truncdfsf2): Fixed normalization problems\n+\t(__fixunsdfsi): Fixed compiler warning\n+\t(__{add,sub,mul}df3): Rewrite to do real DP math.\n+\t(__divdf3): Removed previous version by Barrett Richardson.\n+\n+Thu Jul  2 17:57:20 1998  Douglas B. Rupp  <rupp@gnat.com>\n+\n+\t* cpperror.c: Include errno.h.\n+\n+Thu Jul  2 16:46:36 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* c-decl.c (grokdeclarator): Don't warn about implicit int in\n+\t`typedef foo = bar'.\n+\n+Tue Jun 30 18:32:49 1998  Geert Bosch  <bosch@gnat.com>\n+\n+\t* alpha/vxworks.h (LINK_SPEC): Add -taso -T 0.\n+\n+Tue Jun 30 09:39:32 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n+\n+\t* expr.c (expand_builtin_{set,long}jmp): If STACK_SAVEAREA_MODE\n+\tdefined, override sa_mode using its value.\n+\t* explow.c (emit_stack_save): Likewise.\n+\n+\t* rs6000/aix41.h (ASM_CPU_SPEC): Define relative to ASM_DEFAULT_SPEC.\n+\t(CPP_CPU_SPEC): Define relative to CPU_DEFAULT_SPEC.\n+\t* rs6000.c (processor_target_table, 620): Don't affect MASK_POWERPC64.\n+\t(rs6000_override_options): Ignore flag_pic for AIX.\n+\t(rs6000_immed_double_const): Delete.\n+\t({reg_or_u_short,u_short_cint}_operand): Don't assume 32-bit CONST_INT.\n+\t({non_logical_cint,logical}_operand): Likewise.\n+\t(num_insns_constant): mask64_operand is 2 insns.\n+\t(easy_fp_constant): Any CONST_DOUBLE_HIGH is okay for 64-bit.\n+\t(mask_constant): HOST_WIDE_INT parameter.\n+\t(non_and_cint_operand): Delete.\n+\t({mask,and}64_operand): New functions.\n+\t(function_arg{,_advance}): DImode arguments don't need special\n+\talignment when 64-bit.\n+\t(setup_incoming_varargs): Reverse reg_size assignment.\n+\t(print_operand): HOST_WIDE_INT second parameter.\n+\t(print_operand, case 'B', 'S'): New cases.\n+\t(print_operand, case 'M'): Fix typo in lossage string.\n+\t(rs6000_stack_info): Reverse reg_size assignment.  Use total_raw_size\n+\tto compute AIX push_p.  Use reg_size to compute {cr,lr}_save_offset.\n+\t(rs6000_output_load_toc_table): Reverse init_ptr assignment.  Use\n+\tTARGET_64BIT not TARGET_POWERPC64.  Convert fprintf to fputs.\n+\tLoad GOT highpart, don't add it.  Add lowpart with {cal|la}.\n+\t(rs6000_allocate_stack_space): Use {cal|la}.\n+\t(output_epilog): Use {cal|la}\n+\t(output_function_profiler): Add call glue to mcount call.\n+\tLoad GOT highpart, don't add it.  Add lowpart with {cal|la}.\n+\tUse asm_fprintf and convert fprintf to fputs.\n+\n+\t* rs6000.h (TARGET_SWITCHES): Add powerpc64.\n+\t(STACK_BOUNDARY): Depend on TARGET_32BIT.\n+\t(ADJUST_FIELD_ALIGN): Calculate array alignment using innermost type.\n+\t(CONST_OK_FOR_LETTER_P): Don't assume 32-bit CONST_INT.\n+\t(EXTRA_CONSTRAINTS): Remove 'S' and 'T'.  Replace 'S' with\n+\t64-bit mask operand.\n+\t(RS6000_SAVE_TOC): Depend on TARGET_32BIT.\n+\t(STACK_SAVEAREA_MODE): New macro.\n+\t(LEGITIMATE_CONSTANT_P): DImode okay for 64bit.\n+\t(RTX_COSTS, AND/IOR/XOR): Reflect current machine description.\n+\t(ASM_FILE_START): Emit 64-bit ABI directive.\n+\t(ASM_DECLARE_FUNCTION_NAME): Align CSECT on doubleword in 64-bit mode.\n+\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): DImode okay for 64-bit.\n+\t(PREDICATE_CODES): Add \"and64_operand\" and \"mask64_operand\".\n+\tDelete \"non_and_cint_operand\".  \"input_operand\" includes CONST_DOUBLE.\n+\n+\t* rs6000.md (iorsi3, xorsi3): Use HOST_WIDE_INT for mask.\n+\tRestore define_split.\n+\t(floatsidf2, floatunssidf2): Remove !TARGET_POWERPC64 final constraint.\n+\t(floatsidf2_internal, floatunssidf2_internal2): Likewise.\n+\tDo not specify base register operand mode.\n+\t(floatsidf2_loadaddr): Don't specify base register operand mode.\n+\t(floatsidf2_store1, floatsidf2_store2): Operand 1 must be base\n+\tregister; do not specify mode.  Remove !TARGET_POWERPC64 final\n+\tconstraint.\n+\t(floatsidf2_load): Don't specify base register operand mode.\n+\tRemove !TARGET_POWERPC64 final constraint.\n+\t(fix_truncdfsi2_internal, fix_truncdfsi2_{store,load}): Don't specify\n+\tbase register operand mode.\n+\t(mulsidi3): Add !TARGET_POWERPC64 constraint.\n+\t(adddi3): Split large constants early.\n+\t(absdi3): Shift by 63, not 31.\n+\t(rotldi3): Add masking combiner patterns.\n+\t(anddi3): Add rldic{r,l} masking.  Remove split of large constants.\n+\t(iordi3, xordi3): Split large constants early.\n+\t(movsi matcher): Remove S and T constraints.\n+\t(movsf const_double): create SImode constant from TARGET_DOUBLE.\n+\t(movdf_hardfloat32): Add default abort case.\n+\t(movdf easy_fp_const): create DImode constant from TARGET_DOUBLE.\n+\t(movdi): Remove 64-bit constant generator.  Try to convert\n+\tCONST_DOUBLE to CONST_INT.  Handle TOC memory constants.\n+\t(movdi_32): Add default abort case.\n+\t(movdi_64): Add numerous ways to split 64-bit constants.\n+\tMake catch-all define_split more optimal and never FAIL.\n+\t(movti_ppc64): Add default abort case.\n+\t(allocate_stack): Remove operand modes; use Pmode.\n+\t(restore_stack_block): Remove operand modes.  Generate Pmode\n+\ttemporary.  Generate MEM and specify mode.\n+\t(save_stack_nonlocal, restore_stack_nonlocal):  Generate Pmode\n+\ttemporary.  Save area is double Pmode.\n+\t(call_indirect_aix64, call_value_indirect_aix64): New patterns.\n+\t(call, call_value): Do not specify address operand mode.  Choose\n+\tappropriate AIX ABI.\n+\t(*call_local64, *ret_call_local64): New patterns.\n+\t(*call_nonlocal_aix64, *ret_call_nonlocal_aix64): New patterns.\n+\t(*ret_call_nonlocal_aix32): Use call_value_indirect for REG.\n+\t(compare): Materialize DImode truthvalues.\n+\n+Tue Jun 30 06:31:40 1998  Richard Henderson <rth@dot.cygnus.com>\n+\n+\t* alpha.h (PRINT_OPERAND_PUNCT_VALID_P): Add '`'.\n+\t* alpha.c (print_operand): Handle it.\n+\t* alpha.md (fix_truncdfsi2, fix_truncsfsi2): New patterns and\n+\trelated define_splits.\n+\n+Tue Jun 30 06:02:07 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* calls.c (emit_library_call{,_value}): Pass null\n+ \tto REG_PARM_STACK_SPACE.\n+\n+\t* alpha.c (normal_memory_operand): New function.\n+\t* alpha.h (EXTRA_CONSTRAINT, case 'Q'): Call it.\n+\n+\t* fold-const.c (count_cond): New function.\n+\t(fold): Don't try to build COND_EXPR from binary op when both sides\n+\tare COND_EXPR unless not nested too deeply.\n+\n+Thu Jun 25 09:54:55 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* arm.h (REG_ALLOC_ORDER): Add ARG_POINTER_REGNUM, noticed by\n+\tgrahams@rcp.co.uk.\n+\n+Mon Jun 15 17:41:33 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload1.c (reload): Issue guidance message on stack frame too large\n+\tfor reliable stack check.\n+\n+\t* fold-const.c (fold_range_test): Prevent falling through with no ret.\n+\n+Sat Jun 13 15:49:53 1998  Carol LePage  <carolo@kemah.hal.com>\n+\n+\t* configure.in (sparc-hal-solaris2*): New target.\n+\t* sparc/hal.h, sparc/t-halos: New files.\n+\n+Sat Jun 13 14:30:25 1998  David W. Schuler  <schuld@btv.ibm.com>\n+\n+\t* i386/aix386ng.h (CPP_SPEC): Remove bogus quote.\n+\n+Sat Jun 13 14:16:34 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* regmove.c (try_auto_increment): Fix typo.\n+\n+\t* c-common.c (truthvalue_conversion): Protect side effects in the\n+\texpression when splitting a complex value.\n+\t* fold-const.c (fold): Likewise.\n+\n+\t* expr.c (do_jump, case EQ_EXPR, NE_EXPR): When comparing complex\n+\tprevent operands from being evaluated twice.\n+\n+Sat Jun 13 12:53:22 1998  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* unroll.c (verify_addresses): Use validate_replace_rtx to undo \n+\tchanges; abort if undo fails.\n+\n+Sat Jun 13 11:46:38 1998  Anders Blomdell <anders.blomdell@control.lth.se>\n+\n+\t* flags.h (flag_volatile_static): Declare.\n+\t* toplev.c (flag_volatile_static): Define.\n+\t(f_options): Include -fvolatile-static.\n+\t* varasm.c (make_decl_rtl): Support -fvolatile-static.\n+\n+Sat Jun 13 08:26:21 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* reload1.c (reload_cse_regno_equal_p): If -ffloat-store, don't\n+\tconsider a MEM in FP mode as equal.\n+\n+\t* varasm.c (assemble_variable): Never put decl with specified section\n+\tname into bss.\n+\n+\t* output.h (current_function_addresses_labels): Declare.\n+\t* function.h (struct function): New field `addresses_labels'.\n+\t* function.c (current_function_addresses_labels): Define.\n+\t({push,pop}_function_context): Save/restore it.\n+\t(init_function_start): Initialize it.\n+\t* rtl.h (FUNCTION_FLAGS_ADDRESSES_LABELS): New flag.\n+\t* expr.c (expand_expr, case LABEL_DECL): Show addresses labels.\n+\t* integrate.c (function_cannot_inline_p): Can't if addresses labels.\n+\t(initialize_for_inline): Save current_function_addresses_labels.\n+\t(output_inline_function): Restore it.\n+\n+\t* reload.c (find_reloads, case 'o'): All reloaded addresses\n+\tare offsettable.\n+\t(find_reloads_address): If replacing address, don't return 1.\n+\n+\t* profile.c (output_func_start_profiler): Add missing steps in\n+\tdefining function.\n+\n+Fri Jun 12 17:10:16 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* m68k.md (extendqidi2): Operand 1 must be in data register.\n+\n Tue Jun  9 07:24:01 1998  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* cccp.c (handle_directive): If -dM, also include #undef.\n+\t* cpplib.c (handle_directive): Likewise.\n+\n+\t* calls.c (expand_call): Allow function pointer to be a REFERENCE_TYPE.\n+\n+\t* function.c (assign_parms): Use proper mode for location of arg\n+\ton stack when promotions are occurring.\n+\n \t* regmove.c ({next,prev}_insn_for_regmove): Properly handle end of\n  \tfunction.\n "}, {"sha": "a7d3837d103a46f74eca4e4f0bb5f1ae85dbd9b2", "filename": "gcc/FSFChangeLog.10", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FFSFChangeLog.10", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FFSFChangeLog.10", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FFSFChangeLog.10?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -4259,7 +4259,7 @@ Wed Nov 29 14:06:13 1995  Jim Wilson  <wilson@cygnus.com>\n \n Wed Nov 29 13:59:58 1995  J\"orn Rennecke (amylaar@meolyon.hanse.de)\n \n-\t* c-decl.c (duplicate_decls): Add new parameter different_binding_level.\n+\t* c-decl.c (duplicate_decls): Add new paramter different_binding_level.\n \tLots of changes to use new new parameter.\n \t(pushdecl): Delete variable declared_global.  New variable\n \tdifferent_binding_level and code to set it.  Move extern/static\n@@ -5226,7 +5226,7 @@ Thu Sep 14 14:15:16 1995  Stan Cox  (coxs@dg-rtp.dg.com)\n \n \t* m88k.h (VERSION_INFO1): Removed BCS reference.\n \t* m88k/dgux.h (ASM_SPEC, *_LEGEND):\n-\tAdded -mno-legend option. -mstandard no longer implies that\n+\tAdded -mno-legend option. -mstandard no longer implies that legend\n \tlegend information not be produced.\n \t(LINK_SPEC): Removed -z text\n \n@@ -5422,7 +5422,7 @@ Thu Aug 31 08:31:40 1995  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n \n \t* va-alpha.h (__gnuc_va_list): Make __offset an int.\n \t* alpha.c (alpha_builtin_saveregs): Properly compute address\n-\tof __offset both OSF and WINNT.\n+\tof __offset both both OSF and WINNT.\n \n \t* xm-alpha.h (sbrk): Don't define here.\n \t* gmon.c (sbrk): Define here for __alpha."}, {"sha": "c244bb65eb563ab7f901b0f46a59c2478df88800", "filename": "gcc/FSFChangeLog.11", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FFSFChangeLog.11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FFSFChangeLog.11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FFSFChangeLog.11?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -6291,7 +6291,7 @@ Sun Apr 20 10:45:35 1997  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(based_loc_descr): Likewise.\n \t(add_bound_info): Delete default case.\n \tAdd cases for CONVERT_EXPR and NON_LVALUE_EXPR; treat like NOP_EXPR.\n-\tChange NOP_EXPR to recursive call.\n+\tChange NOP_EXPR to to recursive call.\n \t(add_type_attribute): Ignore unnamed subtype of integral or FP.\n \t(gen_subprogram_die): Use reg_loc_descriptor.\n \t(dwarf2out_decl): Ignore nested functions.\n@@ -11751,7 +11751,7 @@ Mon Jul  8 18:00:33 1996  Jim Wilson  <wilson@cygnus.com>\n \tenclose it in a PARALLEL and set the PARALLEL mode correctly.\n \t* mips.md (call_value): Call gen_call_value_multiple_internal0\n \tonly if there are multiple return values.  Strip the PARALLEL off\n-\tif there is only one return value.\n+\tif there there is only one return value.\n \n Mon Jul  8 16:27:33 1996  Jeffrey A. Law  <law@cygnus.com>\n "}, {"sha": "b71d196634a5218b24fdaacd24ce5c22873da5f8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 177, "deletions": 70, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -73,6 +73,7 @@ T_CFLAGS =\n X_CPPFLAGS =\n T_CPPFLAGS =\n \n+AWK = @AWK@\n CC = @CC@\n # srcdir might be a relative pathname which won't be valid in a subdirectory,\n # so we must use objdir/srcdir instead to make it safe.  objdir is always\n@@ -293,6 +294,9 @@ includedir = $(local_prefix)/include\n assertdir = $(gcc_tooldir)/include\n # where the info files go\n infodir = @infodir@\n+# where the locale files go\n+datadir = $(prefix)/@DATADIRNAME@\n+localedir = $(datadir)/locale\n # Extension (if any) to put in installed man-page filename.\n manext = .1\n objext = .o\n@@ -305,6 +309,19 @@ man1dir = $(mandir)/man1\n # Dir for temp files.\n tmpdir = /tmp\n \n+# Top build directory, relative to here.\n+top_builddir = .\n+\n+# Whether we were configured with NLS.\n+USE_NLS = @USE_NLS@\n+\n+# Internationalization library.\n+INTLLIBS = @INTLLIBS@\n+\n+# List of internationalization subdirectories.\n+POSUB = @POSUB@\n+INTL_SUBDIRS = intl $(POSUB)\n+\n # Additional system libraries to link with.\n CLIB=\n \n@@ -454,6 +471,7 @@ HOST_PREFIX_1=loser-\n HOST_CC=$(CC)\n HOST_CFLAGS=$(ALL_CFLAGS)\n HOST_CLIB=$(CLIB)\n+HOST_INTLLIBS=$(INTLLIBS)\n HOST_LDFLAGS=$(LDFLAGS)\n HOST_CPPFLAGS=$(ALL_CPPFLAGS)\n HOST_ALLOCA=$(ALLOCA)\n@@ -553,22 +571,22 @@ USE_HOST_DOPRINT= ` case \"${HOST_DOPRINT}\" in ?*) echo ${HOST_PREFIX}${HOST_DOPR\n # Dependency on obstack, alloca, malloc or whatever library facilities\n # are not installed in the system libraries.\n # We don't use USE_ALLOCA because backquote expansion doesn't work in deps.\n-LIBDEPS= $(OBSTACK) $(ALLOCA) $(MALLOC) $(VFPRINTF) $(DOPRINT)\n+LIBDEPS= $(INTLLIBS) $(OBSTACK) $(ALLOCA) $(MALLOC) $(VFPRINTF) $(DOPRINT)\n \n # Likewise, for use in the tools that must run on this machine\n # even if we are cross-building GCC.\n # We don't use USE_ALLOCA because backquote expansion doesn't work in deps.\n-HOST_LIBDEPS= $(HOST_PREFIX)$(HOST_OBSTACK) $(HOST_PREFIX)$(HOST_ALLOCA) $(HOST_PREFIX)$(HOST_MALLOC) $(HOST_PREFIX)$(HOST_VFPRINTF) $(HOST_PREFIX)$(HOST_DOPRINT)\n+HOST_LIBDEPS= $(HOST_PREFIX)$(HOST_INTLLIBS) $(HOST_PREFIX)$(HOST_OBSTACK) $(HOST_PREFIX)$(HOST_ALLOCA) $(HOST_PREFIX)$(HOST_MALLOC) $(HOST_PREFIX)$(HOST_VFPRINTF) $(HOST_PREFIX)$(HOST_DOPRINT)\n \n # How to link with both our special library facilities\n # and the system's installed libraries.\n-LIBS = $(OBSTACK) $(USE_ALLOCA) $(MALLOC) $(VFPRINTF) $(DOPRINT) $(CLIB) \\\n-\t../libiberty/libiberty.a\n+LIBS = $(OBSTACK) $(USE_ALLOCA) $(MALLOC) $(INTLLIBS) @LIBS@ $(VFPRINTF) $(DOPRINT) $(CLIB) ../libiberty/libiberty.a\n \n # Likewise, for use in the tools that must run on this machine\n # even if we are cross-building GCC.\n HOST_LIBS = $(USE_HOST_OBSTACK) $(USE_HOST_ALLOCA) $(USE_HOST_MALLOC)  \\\n-\t    $(USE_HOST_VFPRINTF) $(USE_HOST_DOPRINT) $(HOST_CLIB)\n+\t    $(HOST_INTLLIBS) $(USE_HOST_VFPRINTF) $(USE_HOST_DOPRINT) \\\n+\t    $(HOST_CLIB)\n \n HOST_RTL = $(HOST_PREFIX)rtl.o $(HOST_PREFIX)bitmap.o\n HOST_RTLANAL = $(HOST_PREFIX)rtlanal.o\n@@ -633,7 +651,19 @@ FLAGS_TO_PASS = \\\n \t\"tooldir=$(tooldir)\" \\\n \t\"gcc_tooldir=$(gcc_tooldir)\" \\\n \t\"bindir=$(bindir)\" \\\n-\t\"libsubdir=$(libsubdir)\"\n+\t\"libsubdir=$(libsubdir)\" \\\n+\t\"datadir=$(datadir)\" \\\n+\t\"distdir=../tmp/\\$$(subdir)\" \\\n+\t\"localedir=$(localedir)\"\n+\n+PREPEND_DOTDOT_TO_RELATIVE_PATHS = sed \\\n+\t-e 's|^ *[^ /][^ /]*/|%&|' \\\n+\t-e 's| -B| -B%|g' \\\n+\t-e 's|% *[^- /]|%&|g' \\\n+\t-e 's|%% *|../|g' \\\n+\t-e 's|%||g'\n+SUBDIR_FLAGS_TO_PASS = $(ORDINARY_FLAGS_TO_PASS) \\\n+  \"CC=`echo @cc_set_by_configure@ | $(PREPEND_DOTDOT_TO_RELATIVE_PATHS)`\"\n #\f\n # Lists of files for various purposes.\n \n@@ -650,10 +680,10 @@ SCHED_CFLAGS = @sched_cflags@\n # Language-independent object files.\n OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o \\\n- varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o real.o regmove.o \\\n- dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o \\\n+ intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o real.o \\\n+ dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o \\\n  integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o varray.o \\\n- regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o gcse.o \\\n+ regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n@@ -670,7 +700,7 @@ CCCP=@cpp_main@\n # Files to be copied away after each stage in building.\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n- insn-attr.h insn-attrtab.c insn-opinit.c genrtl.c genrtl.h tree-check.h \\\n+ insn-attr.h insn-attrtab.c insn-opinit.c tree-check.h \\\n  s-flags s-config s-codes s-mlib s-under\\\n  s-output s-recog s-emit s-extract s-peep s-check \\\n  s-attr s-attrtab s-opinit s-crt s-crtS s-crt0 \\\n@@ -822,7 +852,7 @@ start.encap: native xgcc$(exeext) specs $(LIBGCC1) xlimits.h lang.start.encap\n rest.encap: stmp-headers $(STMP_FIXPROTO) $(LIBGCC) $(EXTRA_PARTS) lang.rest.encap\n # This is what is made with the host's compiler\n # whether making a cross compiler or not.\n-native: config.status auto-host.h cpp$(exeext) $(LANGUAGES) \\\n+native: config.status auto-host.h cpp$(exeext) intl.all $(LANGUAGES) \\\n \t$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)\n \n # Define the names for selecting languages in LANGUAGES.\n@@ -857,8 +887,8 @@ stamp-objlist: $(OBJS)\n # We call this executable `xgcc' rather than `gcc'\n # to avoid confusion if the current directory is in the path\n # and CC is `gcc'.  It is renamed to `gcc' when it is installed.\n-xgcc$(exeext): gcc.o version.o choose-temp.o pexecute.o prefix.o version.o \\\n-   mkstemp.o $(LIBDEPS) $(EXTRA_GCC_OBJS)\n+xgcc$(exeext): gcc.o version.o choose-temp.o intl.o pexecute.o prefix.o \\\n+   version.o mkstemp.o $(LIBDEPS) $(EXTRA_GCC_OBJS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o prefix.o version.o \\\n \t  choose-temp.o pexecute.o mkstemp.o $(EXTRA_GCC_OBJS) $(LIBS)\n \n@@ -1286,11 +1316,11 @@ $(srcdir)/c-gperf.h: c-parse.gperf\n c-decl.o : c-decl.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-lex.h flags.h \\\n     output.h toplev.h\n c-typeck.o : c-typeck.c $(CONFIG_H) system.h $(TREE_H) c-tree.h flags.h \\\n-    output.h $(EXPR_H) $(RTL_H) toplev.h\n+    intl.h output.h $(EXPR_H) $(RTL_H) toplev.h\n c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-lex.h toplev.h \\\n     output.h\n c-lex.o : c-lex.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-lex.h c-tree.h \\\n-    $(srcdir)/c-parse.h input.h flags.h $(srcdir)/c-gperf.h c-pragma.h \\\n+    $(srcdir)/c-parse.h input.h intl.h flags.h $(srcdir)/c-gperf.h c-pragma.h \\\n     toplev.h output.h mbchar.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) system.h $(TREE_H) c-tree.h flags.h\n c-convert.o : c-convert.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h\n@@ -1305,12 +1335,15 @@ sbitmap.o: sbitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H)\n \n collect2$(exeext): collect2.o tlink.o hash.o cplus-dem.o underscore.o \\\n \tversion.o choose-temp.o mkstemp.o $(LIBDEPS)\n+\n+COLLECT2_OBJS = collect2.o tlink.o hash.o choose-temp.o cplus-dem.o \\\n+ intl.o underscore.o version.o mkstemp.o \n+collect2 : $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n \t-rm -f collect2$(exeext)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ collect2.o tlink.o hash.o \\\n-\t  cplus-dem.o underscore.o version.o choose-temp.o mkstemp.o $(LIBS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(COLLECT2_OBJS) $(LIBS)\n \n-collect2.o : collect2.c $(CONFIG_H) system.h gstab.h \\\n+collect2.o : collect2.c $(CONFIG_H) system.h gstab.h intl.h \\\n \t$(srcdir)/../include/obstack.h $(DEMANGLE_H) collect2.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)  \\\n \t-DTARGET_MACHINE=\\\"$(target_alias)\\\" $(MAYBE_USE_COLLECT2) \\\n@@ -1368,8 +1401,8 @@ DRIVER_DEFINES = \\\n   -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n   -DDEFAULT_TARGET_MACHINE=\\\"$(target_alias)\\\" \\\n   -DTOOLDIR_BASE_PREFIX=\\\"$(exec_prefix)/\\\"\n-gcc.o: gcc.c $(CONFIG_H) system.h multilib.h Makefile prefix.h \\\n-\t$(lang_specs_files)\n+gcc.o: gcc.c $(CONFIG_H) system.h intl.h multilib.h \\\n+    Makefile $(lang_specs_files) prefix.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n   $(DRIVER_DEFINES) \\\n   -c `echo $(srcdir)/gcc.c | sed 's,^\\./,,'`\n@@ -1380,12 +1413,13 @@ s-check : gencheck $(srcdir)/move-if-change\n \t$(srcdir)/move-if-change tmp-check.h tree-check.h\n \ttouch s-check\n \n-gencheck : gencheck.o tree.def $(lang_tree_files) $(HOST_LIBDEPS)\n+gencheck : gencheck.o $(lang_tree_files) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n \t gencheck.o $(HOST_LIBS)\n \n-gencheck.o : gencheck.c hconfig.h system.h\n-\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gencheck.c\n+gencheck.o : gencheck.c tree.def $(CONFIG_H) hconfig.h system.h\n+\t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) \\\n+\t  $(srcdir)/gencheck.c\n \n dumpvers: dumpvers.c\n \n@@ -1420,7 +1454,7 @@ fold-const.o : fold-const.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h \\\n    $(RTL_H)\n toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n-   insn-codes.h insn-config.h $(RECOG_H) Makefile toplev.h dwarfout.h \\\n+   insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) \\\n    $(lang_options_files)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(MAYBE_USE_COLLECT2) \\\n@@ -1477,7 +1511,7 @@ getpwd.o : getpwd.c $(CONFIG_H) system.h\n \n integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    integrate.h insn-flags.h insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n-   function.h output.h $(RECOG_H) except.h toplev.h\n+   intl.h function.h output.h $(RECOG_H) except.h toplev.h\n \n jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h \\\n@@ -1533,10 +1567,10 @@ regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n $(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) system.h $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h \\\n    insn-attr.h toplev.h recog.h\n-final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h $(REGS_H) \\\n-   $(RECOG_H) conditions.h insn-config.h insn-attr.h except.h real.h output.h \\\n-   hard-reg-set.h insn-flags.h insn-codes.h gstab.h xcoffout.h defaults.h \\\n-   toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h dbxout.h\n+final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n+   $(REGS_H) $(RECOG_H) conditions.h insn-config.h insn-attr.h except.h real.h \\\n+   output.h hard-reg-set.h insn-flags.h insn-codes.h gstab.h xcoffout.h \\\n+   defaults.h toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h dbxout.h\n recog.o : recog.c $(CONFIG_H) system.h $(RTL_H)  \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n    insn-flags.h insn-codes.h real.h toplev.h\n@@ -1867,25 +1901,69 @@ $(HOST_PREFIX_1)malloc.o: malloc.c\n $(HOST_PREFIX_1): \n \ttouch $(HOST_PREFIX_1)\n \n+\n+#\f\n+# Remake internationalization support.\n+\n+intl.o: intl.c intl.h gansidecl.h Makefile\n+\t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t  -DLOCALEDIR=\\\"$(localedir)\\\" \\\n+\t  -c `echo $(srcdir)/intl.c | sed 's,^\\./,,'`\n+\n+# This is needed to when doing a partial build after a `make clean'.\n+# libintl.a does not depend on intl.all,\n+# as that would force a lot of recompiling.\n+$(top_builddir)/intl/libintl.a:\n+\t@echo \"$(MAKE) intl.all\"\n+\t@$(MAKE) $(FLAGS_TO_PASS) intl.all\n+\n+# Make sure all the headers are there for xgettext to scan.\n+# FIXME: extend the language interface\n+# so that we needn't jump into language build internals like this.\n+intl.all intl.install intl.distdir: \\\n+    $(srcdir)/c-gperf.h \\\n+    $(srcdir)/c-parse.c $(srcdir)/c-parse.h $(srcdir)/cexp.c \\\n+    $(srcdir)/cp/parse.c $(srcdir)/objc/objc-parse.c\n+$(srcdir)/cp/parse.c:\n+\t@cp_srcdir=`sed -n 's/^srcdir[ \t]*=[\t ]*//p' cp/Makefile` && \\\n+\techo \"cd cp && $(MAKE) $$cp_srcdir/parse.c\" && \\\n+\tcd cp && \\\n+\t  $(MAKE) $(SUBDIR_FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) \\\n+\t    $$cp_srcdir/parse.c\n+\n+intl.all intl.install intl.uninstall intl.distdir \\\n+  intl.mostlyclean intl.clean intl.distclean intl.maintainer-clean:\n+\t@for d in $(INTL_SUBDIRS); do \\\n+\t  target=`expr $@ : 'intl.\\(.*\\)'` && \\\n+\t  echo \"(cd $$d && $(MAKE) $$target)\" && \\\n+\t  (cd $$d && AWK='$(AWK)' $(MAKE) $(SUBDIR_FLAGS_TO_PASS) $$target); \\\n+\tdone\n+\n+# intl.distdir doesn't copy the intl makefiles (since they aren't distributed),\n+# but we need them for the `make extraclean' in distdir-finish.\n+intl.distdir-fixup:\n+\tfor d in $(INTL_SUBDIRS); do \\\n+\t  ln $$d/Makefile tmp/$$d || cp $$d/Makefile tmp/$$d || exit; \\\n+\tdone\n #\f\n # Remake cpp and protoize.\n \n # Making the preprocessor\n cpp$(exeext): $(CCCP)$(exeext)\n \t-rm -f cpp$(exeext)\n \t$(LN) $(CCCP)$(exeext) cpp$(exeext)\n-cccp$(exeext): cccp.o cexp.o version.o prefix.o mbchar.o @extra_cpp_objs@ $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ cccp.o cexp.o prefix.o mbchar.o \\\n-\t  version.o @extra_cpp_objs@ $(LIBS)\n+CCCP_OBJS = cccp.o cexp.o intl.o prefix.o version.o @extra_cpp_objs@ mbchar.o \n+cccp$(exeext): $(CCCP_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(CCCP_OBJS) $(LIBS)\n cexp.o: $(srcdir)/cexp.c $(CONFIG_H) system.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $(srcdir)/cexp.c\n $(srcdir)/cexp.c: $(srcdir)/cexp.y\n \tcd $(srcdir); $(BISON) -o cexp.c cexp.y\n \n # We use $(libsubdir)/$(unlibsubdir) to match the\n # -iprefix argument which gcc will pass if GCC_EXEC_PREFIX is used.\n-cccp.o: cccp.c $(CONFIG_H) pcp.h version.c config.status system.h \\\n-           mbchar.h prefix.h Makefile\n+cccp.o: cccp.c $(CONFIG_H) intl.h pcp.h version.c config.status system.h \\\n+           mbchar.h prefix.h Makefile.in\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DGCC_INCLUDE_DIR=\\\"$(libsubdir)/include\\\" \\\n \t  -DGPLUSPLUS_INCLUDE_DIR=\\\"$(gxx_include_dir)\\\" \\\n@@ -1895,7 +1973,7 @@ cccp.o: cccp.c $(CONFIG_H) pcp.h version.c config.status system.h \\\n \t  -c `echo $(srcdir)/cccp.c | sed 's,^\\./,,'`\n \n LIBCPP_OBJS =\tcpplib.o cpphash.o cppalloc.o cpperror.o cppexp.o cppfiles.o \\\n-\t\tcppulp.o prefix.o version.o mbchar.o @extra_cpp_objs@\n+\t\tcppulp.o prefix.o version.o mbchar.o @extra_cpp_objs@ intl.o\n \n # All the other archives built/used by this makefile are for targets.  This\n # one is strictly for the host.\n@@ -1911,10 +1989,10 @@ cppmain$(exeext): cppmain.o libcpp.a $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cppmain$(exeext) cppmain.o \\\n \tlibcpp.a $(LIBS)\n \n-cppmain.o: cppmain.c $(CONFIG_H) cpplib.h machmode.h system.h\n+cppmain.o: cppmain.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n \n-cpplib.o: cpplib.c $(CONFIG_H) cpplib.h machmode.h cpphash.h config.status \\\n-\tsystem.h prefix.h Makefile\n+cpplib.o: cpplib.c $(CONFIG_H) cpplib.h machmode.h cpphash.h intl.h \\\n+\tconfig.status system.h prefix.h Makefile\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DGCC_INCLUDE_DIR=\\\"$(libsubdir)/include\\\" \\\n \t  -DGPLUSPLUS_INCLUDE_DIR=\\\"$(gxx_include_dir)\\\" \\\n@@ -1923,11 +2001,11 @@ cpplib.o: cpplib.c $(CONFIG_H) cpplib.h machmode.h cpphash.h config.status \\\n \t  -DTOOL_INCLUDE_DIR=\\\"$(gcc_tooldir)/include\\\" \\\n \t  -c `echo $(srcdir)/cpplib.c | sed 's,^\\./,,'`\n \n-cpperror.o: cpperror.c $(CONFIG_H) cpplib.h machmode.h system.h\n+cpperror.o: cpperror.c $(CONFIG_H) cpplib.h intl.h machmode.h system.h\n \n cppulp.o: cppulp.c $(CONFIG_H) system.h output.h\n \n-cppexp.o: cppexp.c $(CONFIG_H) cpplib.h machmode.h system.h\n+cppexp.o: cppexp.c $(CONFIG_H) cpplib.h intl machmode.h system.h\n \n cppfiles.o: cppfiles.c $(CONFIG_H) cpplib.h machmode.h system.h\n \n@@ -1940,17 +2018,14 @@ cppalloc.o: cppalloc.c $(CONFIG_H) cpplib.h machmode.h system.h\n \n proto: config.status protoize$(exeext) unprotoize$(exeext) SYSCALLS.c.X\n \n-protoize$(exeext): protoize.o getopt.o getopt1.o getpwd.o version.o \\\n-    pexecute.o choose-temp.o mkstemp.o $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n-\t  protoize.o getopt.o getopt1.o getpwd.o version.o \\\n-\t  pexecute.o choose-temp.o mkstemp.o $(LIBS)\n+PROTO_OBJS = choose-temp.o getopt.o getopt1.o getpwd.o \\\n+  intl.o pexecute.o version.o mkstemp.o\n+\n+protoize$(exeext): protoize.o $(PROTO_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ protoize.o $(PROTO_OBJS) $(LIBS)\n \n-unprotoize$(exeext): unprotoize.o getopt.o getopt1.o getpwd.o version.o \\\n-    pexecute.o choose-temp.o mkstemp.o $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n-\t  unprotoize.o getopt.o getopt1.o getpwd.o version.o \\\n-\t  pexecute.o choose-temp.o mkstemp.o $(LIBS)\n+unprotoize$(exeext): unprotoize.o $(PROTO_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ unprotoize.o $(PROTO_OBJS) $(LIBS)\n \n protoize.o: protoize.c $(srcdir)/../include/getopt.h $(CONFIG_H) system.h \\\n    Makefile\n@@ -2019,12 +2094,13 @@ test-protoize-simple: ./protoize ./unprotoize $(GCC_PASSES)\n \tdiff $(srcdir)/protoize.c tmp-proto.c | cat\n \t-rm -f tmp-proto.[cs] tmp-proto$(objext)\n \n-gcov.o: gcov.c gcov-io.h system.h\n+gcov.o: gcov.c gcov-io.h intl.h system.h\n \n # Only one of 'gcov' or 'gcov.exe' is actually built, depending\n # upon whether $(exeext) is empty or not.\n-gcov$(exeext): gcov.o $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) gcov.o $(LIBS) -o $@\n+GCOV_OBJS = gcov.o intl.o\n+gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) -o $@\n #\f\n # Build the include directory.  The stamp files are stmp-* rather than\n # s-* so that mostlyclean does not force the include directory to\n@@ -2127,9 +2203,11 @@ deduced.h: $(GCC_PASSES) $(srcdir)/scan-types.sh stmp-int-hdrs\n \t  touch deduced.h; \\\n \tfi\n \n-gen-protos: gen-protos.o scan.o cppalloc.o $(HOST_LIBDEPS)\n+GEN_PROTOS_OBJS = gen-protos.o cppalloc.o cpperror.o cppexp.o \\\n+  cpphash.o cpplib.o prefix.o scan.o version.o cppfiles.o cppulp.o\n+gen-protos: $(GEN_PROTOS_OBJS) $(HOST_LIBDEPS)\n \t${HOST_CC} $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t  gen-protos.o scan.o cppalloc.o $(HOST_LIBS)\n+\t  $(GEN_PROTOS_OBJS) $(HOST_LIBS)\n \n gen-protos.o: gen-protos.c scan.h $(build_xm_file) system.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gen-protos.c\n@@ -2233,7 +2311,7 @@ INSTALL: $(srcdir)/install1.texi $(srcdir)/install.texi\n # (less duplicated code).\n \n \n-mostlyclean: lang.mostlyclean\n+mostlyclean: intl.mostlyclean lang.mostlyclean\n \t-rm -f $(STAGESTUFF)\n # Delete the temporary source copies for cross compilation.\n \t-rm -f $(HOST_PREFIX_1)rtl.c $(HOST_PREFIX_1)rtlanal.c\n@@ -2271,7 +2349,7 @@ mostlyclean: lang.mostlyclean\n \n # Delete all files made by compilation\n # that don't exist in the distribution.\n-clean: mostlyclean lang.clean\n+clean: mostlyclean intl.clean lang.clean\n # It may not be quite desirable to delete unprotoize.c here,\n # but the spec for `make clean' requires it.\n # Using unprotoize.c is not quite right in the first place, \n@@ -2296,7 +2374,8 @@ clean: mostlyclean lang.clean\n \n # Delete all files that users would normally create\n # while building and installing GCC.\n-distclean: clean lang.distclean\n+INTL_DISTCLEAN = intl.distclean\n+distclean: clean $(INTL_DISTCLEAN) lang.distclean\n \t-rm -f tm.h config.h auto-host.h auto-build.h tconfig.h hconfig.h\n \t-rm -f md cstamp-h\n \t-rm -f config.status config.run config.cache config.bak\n@@ -2309,6 +2388,7 @@ distclean: clean lang.distclean\n \t-rm -f float.h\n \t-rm -f site.exp site.bak testsuite/site.exp testsuite/site.bak\n \t-rm -f testsuite/{gcc,g++}.{log,sum}\n+\t-rm -f intl/libintl.h libintl.h\n \n # Delete anything likely to be found in the source directory\n # that shouldn't be in the distribution.\n@@ -2321,6 +2401,7 @@ extraclean: distclean lang.extraclean\n \t-rm -f *.tar *.xtar *diff *.diff.* *.tar.* *.xtar.* *diffs\n \t-rm -f *lose config/*lose config/*/*lose\n \t-rm -f *.s *.s[0-9] *.i config/ChangeLog\n+\t-rm -f y.tab.c yacc.*\n \t-rm -f */=* */\"#\"* */*~*\n \t-rm -f */patch* */*.orig */*.rej\n \t-rm -f */*.dvi */*.oaux */*.d */*.[zZ] */*.gz\n@@ -2329,10 +2410,13 @@ extraclean: distclean lang.extraclean\n \n # Get rid of every file that's generated from some other file, except for `configure'.\n # Most of these files ARE PRESENT in the GCC distribution.\n+# We define INTL_DISTCLEAN to be empty in the submake, so that\n+# we don't descend into intl after its makefile has been removed.\n maintainer-clean:\n \t@echo 'This command is intended for maintainers to use; it'\n \t@echo 'deletes files that may need special tools to rebuild.'\n-\t$(MAKE) distclean lang.maintainer-clean\n+\t$(MAKE) INTL_DISTCLEAN= distclean \\\n+\t\tintl.maintainer-clean lang.maintainer-clean\n \t-rm -f c-parse.y c-gperf.h\n \t-rm -f c-parse.c c-parse.h c-parse.output\n \t-rm -f cexp.c cexp.output TAGS \n@@ -2351,7 +2435,7 @@ install: $(INSTALL_TARGET) ; @true\n # Install the driver last so that the window when things are\n # broken is small.\n install-normal: install-common $(INSTALL_HEADERS) $(INSTALL_LIBGCC) \\\n-    install-man install-info lang.install-normal install-driver\n+    install-man install-info intl.install lang.install-normal install-driver\n \n # Do nothing while making gcc with a cross-compiler. The person who\n # makes gcc for the target machine has to know how to put a complete\n@@ -2592,7 +2676,7 @@ install-collect2: collect2 installdirs\n \t$(INSTALL_PROGRAM) xgcc$(exeext) $(libsubdir)/gcc$(exeext)\n \n # Cancel installation by deleting the installed files.\n-uninstall: lang.uninstall\n+uninstall: intl.uninstall lang.uninstall\n \t-rm -rf $(libsubdir)\n \t-rm -rf $(bindir)/$(GCC_INSTALL_NAME)$(exeext)\n \t-rm -rf $(bindir)/$(GCC_CROSS_NAME)$(exeext)\n@@ -2741,12 +2825,17 @@ distdir-cvs: force\n distdir-start: doc $(srcdir)/INSTALL $(srcdir)/c-parse.y $(srcdir)/c-gperf.h \\\n   $(srcdir)/c-parse.c $(srcdir)/cexp.c $(srcdir)/config.in \\\n   $(srcdir)/version.c TAGS\n+\t@case '$(USE_NLS)' in \\\n+\tyes) ;; \\\n+\t*) echo \"configure with --enable-nls before making a distribution\"; \\\n+\t   exit 1;; \\\n+\tesac\n \t@if grep -s \"for version ${mainversion}\" gcc.texi > /dev/null; \\\n \tthen true; \\\n \telse echo \"You must update the version number in \\`gcc.texi'\"; sleep 10;\\\n \tfi\n # Update the version number in README\n-\tawk '$$1 \" \" $$2 \" \" $$3 == \"This directory contains\" \\\n+\t$(AWK) '$$1 \" \" $$2 \" \" $$3 == \"This directory contains\" \\\n \t\t{ $$6 = version; print $$0 } \\\n \t     $$1 \" \" $$2 \" \" $$3 != \"This directory contains\"' \\\n \t  version=$(version) $(srcdir)/README > tmp.README\n@@ -2758,6 +2847,8 @@ distdir-start: doc $(srcdir)/INSTALL $(srcdir)/c-parse.y $(srcdir)/c-gperf.h \\\n \tmkdir tmp/config\n \tmkdir tmp/ginclude\n \tmkdir tmp/objc\n+\tmkdir tmp/intl\n+\tmkdir tmp/po\n \tfor file in `(cd $(srcdir) && echo *[0-9a-zA-Z+])`; do \\\n \t  test -f $(srcdir)/$$file && $(LN_S) $(srcdir)/$$file tmp; \\\n \tdone\n@@ -2791,9 +2882,21 @@ distdir-finish:\n # Get rid of everything we don't want in the distribution.  We'd want\n # this to use Makefile.in, but it doesn't have the `lang.foo' targets\n # expanded.\n-\tcd gcc-$(version); make extraclean VERSION_DEP=\n+\tcd gcc-$(version); make extraclean distdir-check VERSION_DEP=\n+\n+distdir-check:\n+\t($(AWK) '/^[^#]/{print} /^#[A-Za-z]/{print substr($$1, 2)}' | sort) \\\n+\t  < po/POTFILES.in > tmp.POTFILES\n+\tls [A-Za-z]*.[ch] [a-z]*/[A-Za-z]*.[ch] \\\n+\t  [a-z]*/[a-z]*/[A-Za-z]*.[ch] | sort > tmp.src\n+\tdiff tmp.POTFILES tmp.src || { \\\n+\t  echo \"po/POTFILES.in and sources do not match -- please fix\"; \\\n+\t  exit 1; \\\n+\t}\n+\trm -f tmp.*\n \n-distdir: distdir-cvs distdir-start lang.distdir distdir-finish\n+distdir: distdir-cvs distdir-start intl.distdir intl.distdir-fixup \\\n+  lang.distdir distdir-finish\n \n # make diff oldversion=M.N \n # creates a diff file between an older distribution and this one.\n@@ -2848,7 +2951,7 @@ compare compare3 compare4 compare-lean compare3-lean compare4-lean: force\n \t    && (cmp tmp-foo1 tmp-foo2 > /dev/null 2>&1 || echo $$file differs >> .bad_compare) || true; \\\n \tdone\n \tcase \"$@\" in compare | compare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^compare\\([0-9][0-9]*\\).*,\\1,'` ;; esac; \\\n-\tfor dir in tmp-foo $(SUBDIRS); do \\\n+\tfor dir in tmp-foo intl $(SUBDIRS); do \\\n \t  if [ \"`echo $$dir/*$(objext)`\" != \"$$dir/*$(objext)\" ] ; then \\\n \t    for file in $$dir/*$(objext); do \\\n \t      tail +16c ./$$file > tmp-foo1; \\\n@@ -2881,7 +2984,7 @@ gnucompare gnucompare3 gnucompare4 gnucompare-lean gnucompare3-lean gnucompare4-\n \t  (cmp --ignore-initial=16 $$file stage$$stage/$$file > /dev/null 2>&1 || echo $$file differs >> .bad_compare) || true; \\\n \tdone\n \tcase \"$@\" in gnucompare | gnucompare-lean ) stage=2 ;; * ) stage=`echo $@ | sed -e 's,^gnucompare\\([0-9][0-9]*\\).*,\\1,'` ;; esac; \\\n-\tfor dir in tmp-foo $(SUBDIRS); do \\\n+\tfor dir in tmp-foo intl $(SUBDIRS); do \\\n \t  if [ \"`echo $$dir/*$(objext)`\" != \"$$dir/*$(objext)\" ] ; then \\\n \t    for file in $$dir/*$(objext); do \\\n \t      (cmp --ignore-initial=16 $$file stage$$stage/$$file > /dev/null 2>&1 || echo $$file differs >> .bad_compare) || true; \\\n@@ -2902,11 +3005,12 @@ gnucompare gnucompare3 gnucompare4 gnucompare-lean gnucompare3-lean gnucompare4-\n # Copy the object files from a particular stage into a subdirectory.\n stage1-start:\n \t-if [ -d stage1 ] ; then true ; else mkdir stage1 ; fi\n-\t-for dir in . $(SUBDIRS) ; \\\n+\t-for dir in intl $(SUBDIRS) ; \\\n \t do \\\n \t   if [ -d stage1/$$dir ] ; then true ; else mkdir stage1/$$dir ; fi ; \\\n \t done\n \t-mv $(STAGESTUFF) stage1\n+\t-mv intl/*$(objext) stage1/intl\n # Copy as/ld if they exist to stage dir, so that running xgcc from the stage\n # dir will work properly.\n \t-if [ -f as$(exeext) ] ; then $(LN_S) ../as$(exeext) stage1 ; else true ; fi\n@@ -2923,11 +3027,12 @@ stage1: force stage1-start lang.stage1\n \n stage2-start:\n \t-if [ -d stage2 ] ; then true ; else mkdir stage2 ; fi\n-\t-for dir in . $(SUBDIRS) ; \\\n+\t-for dir in intl $(SUBDIRS) ; \\\n \t do \\\n \t   if [ -d stage2/$$dir ] ; then true ; else mkdir stage2/$$dir ; fi ; \\\n \t done\n \t-mv $(STAGESTUFF) stage2\n+\t-mv intl/*$(objext) stage2/intl\n # Copy as/ld if they exist to stage dir, so that running xgcc from the stage\n # dir will work properly.\n \t-if [ -f as$(exeext) ] ; then $(LN_S) ../as$(exeext) stage2 ; else true ; fi\n@@ -2944,11 +3049,12 @@ stage2: force stage2-start lang.stage2\n \n stage3-start:\n \t-if [ -d stage3 ] ; then true ; else mkdir stage3 ; fi\n-\t-for dir in . $(SUBDIRS) ; \\\n+\t-for dir in intl $(SUBDIRS) ; \\\n \t do \\\n \t   if [ -d stage3/$$dir ] ; then true ; else mkdir stage3/$$dir ; fi ; \\\n \t done\n \t-mv $(STAGESTUFF) stage3\n+\t-mv intl/*$(objext) stage3/intl\n # Copy as/ld if they exist to stage dir, so that running xgcc from the stage\n # dir will work properly.\n \t-if [ -f as$(exeext) ] ; then $(LN_S) ../as$(exeext) stage3 ; else true ; fi\n@@ -2965,11 +3071,12 @@ stage3: force stage3-start lang.stage3\n \n stage4-start:\n \t-if [ -d stage4 ] ; then true ; else mkdir stage4 ; fi\n-\t-for dir in . $(SUBDIRS) ; \\\n+\t-for dir in intl $(SUBDIRS) ; \\\n \t do \\\n \t   if [ -d stage4/$$dir ] ; then true ; else mkdir stage4/$$dir ; fi ; \\\n \t done\n \t-mv $(STAGESTUFF) stage4\n+\t-mv intl/*$(objext) stage4/intl\n # Copy as/ld if they exist to stage dir, so that running xgcc from the stage\n # dir will work properly.\n \t-if [ -f as$(exeext) ] ; then $(LN_S) ../as$(exeext) stage4 ; else true ; fi"}, {"sha": "5c78dbea5d8d4deb0f8ebeb9d73f92a5ba2f8b84", "filename": "gcc/acconfig.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Facconfig.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -7,6 +7,15 @@\n /* Define if you want expensive run-time checks. */\n #undef ENABLE_CHECKING\n \n+/* Define to 1 if NLS is requested.  */\n+#undef ENABLE_NLS\n+\n+/* Define as 1 if you have catgets and don't want to use GNU gettext.  */\n+#undef HAVE_CATGETS\n+\n+/* Define as 1 if you have gettext and don't want to use GNU gettext.  */\n+#undef HAVE_GETTEXT\n+\n /* Define if your cpp understands the stringify operator.  */\n #undef HAVE_CPP_STRINGIFY\n \n@@ -27,6 +36,12 @@\n /* Define if you have a working <inttypes.h> header file.  */\n #undef HAVE_INTTYPES_H\n \n+/* Define if your locale.h file contains LC_MESSAGES.  */\n+#undef HAVE_LC_MESSAGES\n+\n+/* Define as 1 if you have the stpcpy function.  */\n+#undef HAVE_STPCPY\n+\n /* Whether malloc must be declared even if <stdlib.h> is included.  */\n #undef NEED_DECLARATION_MALLOC\n \n@@ -93,4 +108,9 @@\n /* Define to enable the use of a default linker. */\n #undef DEFAULT_LINKER\n \n+/* Define to the name of the distribution.  */\n+#undef PACKAGE\n+\n+/* Define to the version of the distribution.  */\n+#undef VERSION\n @TOP@"}, {"sha": "b656d65b4d014bae69778ddac2a250906d9a0607", "filename": "gcc/aclocal.m4", "status": "modified", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faclocal.m4?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -235,3 +235,404 @@ AC_SUBST(INSTALL_PROGRAM)dnl\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n AC_SUBST(INSTALL_DATA)dnl\n ])\n+\n+#serial 1\n+dnl This test replaces the one in autoconf.\n+dnl Currently this macro should have the same name as the autoconf macro\n+dnl because gettext's gettext.m4 (distributed in the automake package)\n+dnl still uses it.  Otherwise, the use in gettext.m4 makes autoheader\n+dnl give these diagnostics:\n+dnl   configure.in:556: AC_TRY_COMPILE was called before AC_ISC_POSIX\n+dnl   configure.in:556: AC_TRY_RUN was called before AC_ISC_POSIX\n+\n+undefine([AC_ISC_POSIX])\n+AC_DEFUN(AC_ISC_POSIX,\n+  [\n+    dnl This test replaces the obsolescent AC_ISC_POSIX kludge.\n+    AC_CHECK_LIB(cposix, strerror, [LIBS=\"$LIBS -lcposix\"])\n+  ]\n+)\n+\n+# Macro to add for using GNU gettext.\n+# Ulrich Drepper <drepper@cygnus.com>, 1995.\n+#\n+# This file can be copied and used freely without restrictions.  It can\n+# be used in projects which are not available under the GNU Public License\n+# but which still want to provide support for the GNU gettext functionality.\n+# Please note that the actual code is *not* freely available.\n+\n+# serial 5\n+\n+AC_DEFUN(AM_WITH_NLS,\n+  [AC_MSG_CHECKING([whether NLS is requested])\n+    dnl Default is enabled NLS\n+    AC_ARG_ENABLE(nls,\n+      [  --disable-nls           do not use Native Language Support],\n+      USE_NLS=$enableval, USE_NLS=yes)\n+    AC_MSG_RESULT($USE_NLS)\n+    AC_SUBST(USE_NLS)\n+\n+    USE_INCLUDED_LIBINTL=no\n+\n+    dnl If we use NLS figure out what method\n+    if test \"$USE_NLS\" = \"yes\"; then\n+      AC_DEFINE(ENABLE_NLS)\n+      AC_MSG_CHECKING([whether included gettext is requested])\n+      AC_ARG_WITH(included-gettext,\n+        [  --with-included-gettext use the GNU gettext library included here],\n+        nls_cv_force_use_gnu_gettext=$withval,\n+        nls_cv_force_use_gnu_gettext=no)\n+      AC_MSG_RESULT($nls_cv_force_use_gnu_gettext)\n+\n+      nls_cv_use_gnu_gettext=\"$nls_cv_force_use_gnu_gettext\"\n+      if test \"$nls_cv_force_use_gnu_gettext\" != \"yes\"; then\n+        dnl User does not insist on using GNU NLS library.  Figure out what\n+        dnl to use.  If gettext or catgets are available (in this order) we\n+        dnl use this.  Else we have to fall back to GNU NLS library.\n+\tdnl catgets is only used if permitted by option --with-catgets.\n+\tnls_cv_header_intl=\n+\tnls_cv_header_libgt=\n+\tCATOBJEXT=NONE\n+\n+\tAC_CHECK_HEADER(libintl.h,\n+\t  [AC_CACHE_CHECK([for gettext in libc], gt_cv_func_gettext_libc,\n+\t    [AC_TRY_LINK([#include <libintl.h>], [return (int) gettext (\"\")],\n+\t       gt_cv_func_gettext_libc=yes, gt_cv_func_gettext_libc=no)])\n+\n+\t   if test \"$gt_cv_func_gettext_libc\" != \"yes\"; then\n+\t     AC_CHECK_LIB(intl, bindtextdomain,\n+\t       [AC_CACHE_CHECK([for gettext in libintl],\n+\t\t gt_cv_func_gettext_libintl,\n+\t\t [AC_CHECK_LIB(intl, gettext,\n+\t\t  gt_cv_func_gettext_libintl=yes,\n+\t\t  gt_cv_func_gettext_libintl=no)],\n+\t\t gt_cv_func_gettext_libintl=no)])\n+\t   fi\n+\n+\t   if test \"$gt_cv_func_gettext_libc\" = \"yes\" \\\n+\t      || test \"$gt_cv_func_gettext_libintl\" = \"yes\"; then\n+\t      AC_DEFINE(HAVE_GETTEXT)\n+\t      AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,\n+\t\t[test -z \"`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`\"], no)dnl\n+\t      if test \"$MSGFMT\" != \"no\"; then\n+\t\tAC_CHECK_FUNCS(dcgettext)\n+\t\tAC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)\n+\t\tAM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,\n+\t\t  [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`\"], :)\n+\t\tAC_TRY_LINK(, [extern int _nl_msg_cat_cntr;\n+\t\t\t       return _nl_msg_cat_cntr],\n+\t\t  [CATOBJEXT=.gmo\n+\t\t   DATADIRNAME=share],\n+\t\t  [CATOBJEXT=.mo\n+\t\t   DATADIRNAME=lib])\n+\t\tINSTOBJEXT=.mo\n+\t      fi\n+\t    fi\n+\t])\n+\n+        if test \"$CATOBJEXT\" = \"NONE\"; then\n+\t  AC_MSG_CHECKING([whether catgets can be used])\n+\t  AC_ARG_WITH(catgets,\n+\t    [  --with-catgets          use catgets functions if available],\n+\t    nls_cv_use_catgets=$withval, nls_cv_use_catgets=no)\n+\t  AC_MSG_RESULT($nls_cv_use_catgets)\n+\n+\t  if test \"$nls_cv_use_catgets\" = \"yes\"; then\n+\t    dnl No gettext in C library.  Try catgets next.\n+\t    AC_CHECK_LIB(i, main)\n+\t    AC_CHECK_FUNC(catgets,\n+\t      [AC_DEFINE(HAVE_CATGETS)\n+\t       INTLOBJS=\"\\$(CATOBJS)\"\n+\t       AC_PATH_PROG(GENCAT, gencat, no)dnl\n+\t       if test \"$GENCAT\" != \"no\"; then\n+\t\t AC_PATH_PROG(GMSGFMT, gmsgfmt, no)\n+\t\t if test \"$GMSGFMT\" = \"no\"; then\n+\t\t   AM_PATH_PROG_WITH_TEST(GMSGFMT, msgfmt,\n+\t\t    [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`\"], no)\n+\t\t fi\n+\t\t AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,\n+\t\t   [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`\"], :)\n+\t\t USE_INCLUDED_LIBINTL=yes\n+\t\t CATOBJEXT=.cat\n+\t\t INSTOBJEXT=.cat\n+\t\t DATADIRNAME=lib\n+\t\t INTLDEPS='$(top_builddir)/intl/libintl.a'\n+\t\t INTLLIBS=$INTLDEPS\n+\t\t LIBS=`echo $LIBS | sed -e 's/-lintl//'`\n+\t\t nls_cv_header_intl=intl/libintl.h\n+\t\t nls_cv_header_libgt=intl/libgettext.h\n+\t       fi])\n+\t  fi\n+        fi\n+\n+        if test \"$CATOBJEXT\" = \"NONE\"; then\n+\t  dnl Neither gettext nor catgets in included in the C library.\n+\t  dnl Fall back on GNU gettext library.\n+\t  nls_cv_use_gnu_gettext=yes\n+        fi\n+      fi\n+\n+      if test \"$nls_cv_use_gnu_gettext\" = \"yes\"; then\n+        dnl Mark actions used to generate GNU NLS library.\n+        INTLOBJS=\"\\$(GETTOBJS)\"\n+        AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,\n+\t  [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep 'dv '`\"], msgfmt)\n+        AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)\n+        AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,\n+\t  [test -z \"`$ac_dir/$ac_word -h 2>&1 | grep '(HELP)'`\"], :)\n+        AC_SUBST(MSGFMT)\n+\tUSE_INCLUDED_LIBINTL=yes\n+        CATOBJEXT=.gmo\n+        INSTOBJEXT=.mo\n+        DATADIRNAME=share\n+\tINTLDEPS='$(top_builddir)/intl/libintl.a'\n+\tINTLLIBS=$INTLDEPS\n+\tLIBS=`echo $LIBS | sed -e 's/-lintl//'`\n+        nls_cv_header_intl=intl/libintl.h\n+        nls_cv_header_libgt=intl/libgettext.h\n+      fi\n+\n+      dnl Test whether we really found GNU xgettext.\n+      if test \"$XGETTEXT\" != \":\"; then\n+\tdnl If it is no GNU xgettext we define it as : so that the\n+\tdnl Makefiles still can work.\n+\tif $XGETTEXT --omit-header /dev/null 2> /dev/null; then\n+\t  : ;\n+\telse\n+\t  AC_MSG_RESULT(\n+\t    [found xgettext program is not GNU xgettext; ignore it])\n+\t  XGETTEXT=\":\"\n+\tfi\n+      fi\n+\n+      # We need to process the po/ directory.\n+      POSUB=po\n+    else\n+      DATADIRNAME=share\n+      nls_cv_header_intl=intl/libintl.h\n+      nls_cv_header_libgt=intl/libgettext.h\n+    fi\n+    AC_LINK_FILES($nls_cv_header_libgt, $nls_cv_header_intl)\n+    AC_OUTPUT_COMMANDS(\n+     [case \"$CONFIG_FILES\" in *po/Makefile.in*)\n+        sed -e \"/POTFILES =/r po/POTFILES\" po/Makefile.in > po/Makefile\n+      esac])\n+\n+\n+    # If this is used in GNU gettext we have to set USE_NLS to `yes'\n+    # because some of the sources are only built for this goal.\n+    if test \"$PACKAGE\" = gettext; then\n+      USE_NLS=yes\n+      USE_INCLUDED_LIBINTL=yes\n+    fi\n+\n+    dnl These rules are solely for the distribution goal.  While doing this\n+    dnl we only have to keep exactly one list of the available catalogs\n+    dnl in configure.in.\n+    for lang in $ALL_LINGUAS; do\n+      GMOFILES=\"$GMOFILES $lang.gmo\"\n+      POFILES=\"$POFILES $lang.po\"\n+    done\n+\n+    dnl Make all variables we use known to autoconf.\n+    AC_SUBST(USE_INCLUDED_LIBINTL)\n+    AC_SUBST(CATALOGS)\n+    AC_SUBST(CATOBJEXT)\n+    AC_SUBST(DATADIRNAME)\n+    AC_SUBST(GMOFILES)\n+    AC_SUBST(INSTOBJEXT)\n+    AC_SUBST(INTLDEPS)\n+    AC_SUBST(INTLLIBS)\n+    AC_SUBST(INTLOBJS)\n+    AC_SUBST(POFILES)\n+    AC_SUBST(POSUB)\n+  ])\n+\n+AC_DEFUN(AM_GNU_GETTEXT,\n+  [AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+   AC_REQUIRE([AC_PROG_CC])dnl\n+   AC_REQUIRE([AC_PROG_RANLIB])dnl\n+   AC_REQUIRE([AC_ISC_POSIX])dnl\n+   AC_REQUIRE([AC_HEADER_STDC])dnl\n+   AC_REQUIRE([AC_C_CONST])dnl\n+   AC_REQUIRE([AC_C_INLINE])dnl\n+   AC_REQUIRE([AC_TYPE_OFF_T])dnl\n+   AC_REQUIRE([AC_TYPE_SIZE_T])dnl\n+   AC_REQUIRE([AC_FUNC_ALLOCA])dnl\n+   AC_REQUIRE([AC_FUNC_MMAP])dnl\n+\n+   AC_CHECK_HEADERS([argz.h limits.h locale.h nl_types.h malloc.h string.h \\\n+unistd.h sys/param.h])\n+   AC_CHECK_FUNCS([getcwd munmap putenv setenv setlocale strchr strcasecmp \\\n+strdup __argz_count __argz_stringify __argz_next])\n+\n+   if test \"${ac_cv_func_stpcpy+set}\" != \"set\"; then\n+     AC_CHECK_FUNCS(stpcpy)\n+   fi\n+   if test \"${ac_cv_func_stpcpy}\" = \"yes\"; then\n+     AC_DEFINE(HAVE_STPCPY)\n+   fi\n+\n+   AM_LC_MESSAGES\n+   AM_WITH_NLS\n+\n+   if test \"x$CATOBJEXT\" != \"x\"; then\n+     if test \"x$ALL_LINGUAS\" = \"x\"; then\n+       LINGUAS=\n+     else\n+       AC_MSG_CHECKING(for catalogs to be installed)\n+       NEW_LINGUAS=\n+       for lang in ${LINGUAS=$ALL_LINGUAS}; do\n+         case \"$ALL_LINGUAS\" in\n+          *$lang*) NEW_LINGUAS=\"$NEW_LINGUAS $lang\" ;;\n+         esac\n+       done\n+       LINGUAS=$NEW_LINGUAS\n+       AC_MSG_RESULT($LINGUAS)\n+     fi\n+\n+     dnl Construct list of names of catalog files to be constructed.\n+     if test -n \"$LINGUAS\"; then\n+       for lang in $LINGUAS; do CATALOGS=\"$CATALOGS $lang$CATOBJEXT\"; done\n+     fi\n+   fi\n+\n+   dnl The reference to <locale.h> in the installed <libintl.h> file\n+   dnl must be resolved because we cannot expect the users of this\n+   dnl to define HAVE_LOCALE_H.\n+   if test $ac_cv_header_locale_h = yes; then\n+     INCLUDE_LOCALE_H=\"#include <locale.h>\"\n+   else\n+     INCLUDE_LOCALE_H=\"\\\n+/* The system does not provide the header <locale.h>.  Take care yourself.  */\"\n+   fi\n+   AC_SUBST(INCLUDE_LOCALE_H)\n+\n+   dnl Determine which catalog format we have (if any is needed)\n+   dnl For now we know about two different formats:\n+   dnl   Linux libc-5 and the normal X/Open format\n+   test -d intl || mkdir intl\n+   if test \"$CATOBJEXT\" = \".cat\"; then\n+     AC_CHECK_HEADER(linux/version.h, msgformat=linux, msgformat=xopen)\n+\n+     dnl Transform the SED scripts while copying because some dumb SEDs\n+     dnl cannot handle comments.\n+     sed -e '/^#/d' $srcdir/intl/$msgformat-msg.sed > intl/po2msg.sed\n+   fi\n+   dnl po2tbl.sed is always needed.\n+   sed -e '/^#.*[^\\\\]$/d' -e '/^#$/d' \\\n+     $srcdir/intl/po2tbl.sed.in > intl/po2tbl.sed\n+\n+   dnl In the intl/Makefile.in we have a special dependency which makes\n+   dnl only sense for gettext.  We comment this out for non-gettext\n+   dnl packages.\n+   if test \"$PACKAGE\" = \"gettext\"; then\n+     GT_NO=\"#NO#\"\n+     GT_YES=\n+   else\n+     GT_NO=\n+     GT_YES=\"#YES#\"\n+   fi\n+   AC_SUBST(GT_NO)\n+   AC_SUBST(GT_YES)\n+\n+   dnl If the AC_CONFIG_AUX_DIR macro for autoconf is used we possibly\n+   dnl find the mkinstalldirs script in another subdir but ($top_srcdir).\n+   dnl Try to locate is.\n+   MKINSTALLDIRS=\n+   if test -n \"$ac_aux_dir\"; then\n+     MKINSTALLDIRS=\"$ac_aux_dir/mkinstalldirs\"\n+   fi\n+   if test -z \"$MKINSTALLDIRS\"; then\n+     MKINSTALLDIRS=\"\\$(top_srcdir)/mkinstalldirs\"\n+   fi\n+   AC_SUBST(MKINSTALLDIRS)\n+\n+   dnl *** For now the libtool support in intl/Makefile is not for real.\n+   l=\n+   AC_SUBST(l)\n+\n+   dnl Generate list of files to be processed by xgettext which will\n+   dnl be included in po/Makefile.\n+   test -d po || mkdir po\n+   if test \"x$srcdir\" != \"x.\"; then\n+     if test \"x`echo $srcdir | sed 's@/.*@@'`\" = \"x\"; then\n+       posrcprefix=\"$srcdir/\"\n+     else\n+       posrcprefix=\"../$srcdir/\"\n+     fi\n+   else\n+     posrcprefix=\"../\"\n+   fi\n+   rm -f po/POTFILES\n+   sed -e \"/^#/d\" -e \"/^\\$/d\" -e \"s,.*,\t$posrcprefix& \\\\\\\\,\" -e \"\\$s/\\(.*\\) \\\\\\\\/\\1/\" \\\n+\t< $srcdir/po/POTFILES.in > po/POTFILES\n+  ])\n+\n+# Check whether LC_MESSAGES is available in <locale.h>.\n+# Ulrich Drepper <drepper@cygnus.com>, 1995.\n+#\n+# This file can be copied and used freely without restrictions.  It can\n+# be used in projects which are not available under the GNU Public License\n+# but which still want to provide support for the GNU gettext functionality.\n+# Please note that the actual code is *not* freely available.\n+\n+# serial 1\n+\n+AC_DEFUN(AM_LC_MESSAGES,\n+  [if test $ac_cv_header_locale_h = yes; then\n+    AC_CACHE_CHECK([for LC_MESSAGES], am_cv_val_LC_MESSAGES,\n+      [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],\n+       am_cv_val_LC_MESSAGES=yes, am_cv_val_LC_MESSAGES=no)])\n+    if test $am_cv_val_LC_MESSAGES = yes; then\n+      AC_DEFINE(HAVE_LC_MESSAGES)\n+    fi\n+  fi])\n+\n+# Search path for a program which passes the given test.\n+# Ulrich Drepper <drepper@cygnus.com>, 1996.\n+#\n+# This file can be copied and used freely without restrictions.  It can\n+# be used in projects which are not available under the GNU Public License\n+# but which still want to provide support for the GNU gettext functionality.\n+# Please note that the actual code is *not* freely available.\n+\n+# serial 1\n+\n+dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,\n+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])\n+AC_DEFUN(AM_PATH_PROG_WITH_TEST,\n+[# Extract the first word of \"$2\", so it can be a program name with args.\n+set dummy $2; ac_word=[$]2\n+AC_MSG_CHECKING([for $ac_word])\n+AC_CACHE_VAL(ac_cv_path_$1,\n+[case \"[$]$1\" in\n+  /*)\n+  ac_cv_path_$1=\"[$]$1\" # Let the user override the test with a path.\n+  ;;\n+  *)\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:\"\n+  for ac_dir in ifelse([$5], , $PATH, [$5]); do\n+    test -z \"$ac_dir\" && ac_dir=.\n+    if test -f $ac_dir/$ac_word; then\n+      if [$3]; then\n+\tac_cv_path_$1=\"$ac_dir/$ac_word\"\n+\tbreak\n+      fi\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+dnl If no 4th arg is given, leave the cache variable unset,\n+dnl so AC_PATH_PROGS will keep looking.\n+ifelse([$4], , , [  test -z \"[$]ac_cv_path_$1\" && ac_cv_path_$1=\"$4\"\n+])dnl\n+  ;;\n+esac])dnl\n+$1=\"$ac_cv_path_$1\"\n+if test -n \"[$]$1\"; then\n+  AC_MSG_RESULT([$]$1)\n+else\n+  AC_MSG_RESULT(no)\n+fi\n+AC_SUBST($1)dnl\n+])"}, {"sha": "ca7bb006c6c468f3b7a161a4f02a5ecab1857e8b", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -81,6 +81,7 @@ typedef struct\n   char *file;\n   int needs_warning;\n } if_elt;\n+static void tfaff\t\t\tPROTO((void));\n \n static if_elt *if_stack;\n \n@@ -1327,7 +1328,11 @@ record_international_format (name, assembler_name, format_num)\n   info->format_num = format_num;\n }\n \n-static char\ttfaff[] = \"too few arguments for format\";\n+static void\n+tfaff ()\n+{\n+  warning (\"too few arguments for format\");\n+}\n \f\n /* Check the argument list of a call to printf, scanf, etc.\n    NAME is the function identifier.\n@@ -1594,7 +1599,7 @@ check_format_info (info, params)\n \t      ++format_chars;\n \t      if (params == 0)\n \t\t{\n-\t\t  warning (tfaff);\n+\t\t  tfaff ();\n \t\t  return;\n \t\t}\n \t      if (info->first_arg_num != 0)\n@@ -1637,7 +1642,7 @@ check_format_info (info, params)\n \t\t      ++format_chars;\n \t\t      if (params == 0)\n \t\t        {\n-\t\t\t  warning (tfaff);\n+\t\t\t  tfaff ();\n \t\t\t  return;\n \t\t\t}\n \t\t      cur_param = TREE_VALUE (params);\n@@ -1832,7 +1837,7 @@ check_format_info (info, params)\n \tcontinue;\n       if (params == 0)\n \t{\n-\t  warning (tfaff);\n+\t  tfaff ();\n \t  return;\n \t}\n       cur_param = TREE_VALUE (params);\n@@ -1858,9 +1863,9 @@ check_format_info (info, params)\n \t      continue;\n \t    }\n \t  if (TREE_CODE (cur_type) != ERROR_MARK)\n-\t    warning (\"format argument is not a %s (arg %d)\",\n-\t\t     ((fci->pointer_count + aflag == 1)\n-\t\t      ? \"pointer\" : \"pointer to a pointer\"),\n+\t    warning ((fci->pointer_count + aflag == 1\n+\t\t      ? \"format argument is not a pointer (arg %d)\"\n+\t\t      : \"format argument is not a pointer to a pointer (arg %d)\"),\n \t\t     arg_num);\n \t  break;\n \t}"}, {"sha": "35d06255b7e90fd3721200a7988a0022044b841e", "filename": "gcc/c-decl.c", "status": "modified", "additions": 59, "deletions": 51, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -426,7 +426,7 @@ tree static_ctors, static_dtors;\n static struct binding_level * make_binding_level\tPROTO((void));\n static void clear_limbo_values\t\tPROTO((tree));\n static int duplicate_decls\t\tPROTO((tree, tree, int));\n-static char *redeclaration_error_message PROTO((tree, tree));\n+static int redeclaration_error_message\tPROTO((tree, tree));\n static void storedecls\t\t\tPROTO((tree));\n static void storetags\t\t\tPROTO((tree));\n static tree lookup_tag\t\t\tPROTO((enum tree_code, tree,\n@@ -1123,24 +1123,22 @@ poplevel (keep, reverse, functionbody)\n     if (TYPE_SIZE (TREE_VALUE (link)) == 0)\n       {\n \ttree type = TREE_VALUE (link);\n-\tchar *errmsg;\n+\ttree type_name = TYPE_NAME (type);\n+\tchar *id = IDENTIFIER_POINTER (TREE_CODE (type_name) == IDENTIFIER_NODE\n+\t\t\t\t       ? type_name\n+\t\t\t\t       : DECL_NAME (type_name));\n \tswitch (TREE_CODE (type))\n \t  {\n \t  case RECORD_TYPE:\n-\t    errmsg = \"`struct %s' incomplete in scope ending here\";\n+\t    error (\"`struct %s' incomplete in scope ending here\", id);\n \t    break;\n \t  case UNION_TYPE:\n-\t    errmsg = \"`union %s' incomplete in scope ending here\";\n+\t    error (\"`union %s' incomplete in scope ending here\", id);\n \t    break;\n \t  case ENUMERAL_TYPE:\n-\t    errmsg = \"`enum %s' incomplete in scope ending here\";\n+\t    error (\"`enum %s' incomplete in scope ending here\", id);\n \t    break;\n \t  }\n-\tif (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\t  error (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type)));\n-\telse\n-\t  /* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */\n-\t  error (errmsg, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n       }\n #endif /* 0 */\n \n@@ -1520,7 +1518,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t\t\t   && DECL_INITIAL (newdecl) != 0);\n   tree oldtype = TREE_TYPE (olddecl);\n   tree newtype = TREE_TYPE (newdecl);\n-  char *errmsg = 0;\n+  int errmsg = 0;\n \n   if (TREE_CODE_CLASS (TREE_CODE (olddecl)) == 'd')\n     DECL_MACHINE_ATTRIBUTES (newdecl)\n@@ -1747,16 +1745,14 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t      if (TREE_CHAIN (t) == 0\n \t\t  && TYPE_MAIN_VARIANT (type) != void_type_node)\n \t\t{\n-\t\t  error (\"A parameter list with an ellipsis can't match\");\n-\t\t  error (\"an empty parameter name list declaration.\");\n+\t\t  error (\"A parameter list with an ellipsis can't match an empty parameter name list declaration.\");\n \t\t  break;\n \t\t}\n \n \t      if (TYPE_MAIN_VARIANT (type) == float_type_node\n \t\t  || C_PROMOTING_INTEGER_TYPE_P (type))\n \t\t{\n-\t\t  error (\"An argument type that has a default promotion\");\n-\t\t  error (\"can't match an empty parameter name list declaration.\");\n+\t\t  error (\"An argument type that has a default promotion can't match an empty parameter name list declaration.\");\n \t\t  break;\n \t\t}\n \t    }\n@@ -1768,7 +1764,21 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n       errmsg = redeclaration_error_message (newdecl, olddecl);\n       if (errmsg)\n \t{\n-\t  error_with_decl (newdecl, errmsg);\n+\t  switch (errmsg)\n+\t    {\n+\t    case 1:\n+\t      error_with_decl (newdecl, \"redefinition of `%s'\");\n+\t      break;\n+\t    case 2:\n+\t      error_with_decl (newdecl, \"redeclaration of `%s'\");\n+\t      break;\n+\t    case 3:\n+\t      error_with_decl (newdecl, \"conflicting declarations of `%s'\");\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n+\n \t  error_with_decl (olddecl,\n \t\t\t   ((DECL_INITIAL (olddecl)\n \t\t\t     && current_binding_level == global_binding_level)\n@@ -1800,14 +1810,22 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t  for (parm = TYPE_ACTUAL_ARG_TYPES (oldtype),\n \t       type = TYPE_ARG_TYPES (newtype),\n \t       nargs = 1;\n-\t       (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) != void_type_node\n-\t\t|| TYPE_MAIN_VARIANT (TREE_VALUE (type)) != void_type_node);\n+\t       ;\n \t       parm = TREE_CHAIN (parm), type = TREE_CHAIN (type), nargs++)\n \t    {\n+\t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n+\t\t  && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n+\t\t{\n+\t\t  warning_with_decl (newdecl, \"prototype for `%s' follows\");\n+\t\t  warning_with_decl (olddecl, \"non-prototype definition here\");\n+\t\t  break;\n+\t\t}\n \t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n \t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n-\t\t  errmsg = \"prototype for `%s' follows and number of arguments\";\n+\t\t  error_with_decl (newdecl, \"prototype for `%s' follows and number of arguments doesn't match\");\n+\t\t  error_with_decl (olddecl, \"non-prototype definition here\");\n+\t\t  errmsg = 1;\n \t\t  break;\n \t\t}\n \t      /* Type for passing arg must be consistent\n@@ -1819,21 +1837,14 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t\t\t && TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == integer_type_node\n \t\t\t && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == unsigned_type_node)))\n \t\t{\n-\t\t  errmsg = \"prototype for `%s' follows and argument %d\";\n+\t\t  error_with_decl (newdecl,\n+\t\t\t\t   \"prototype for `%s' follows and argument %d doesn't match\",\n+\t\t\t\t   nargs);\n+\t\t  error_with_decl (olddecl, \"non-prototype definition here\");\n+\t\t  errmsg = 1;\n \t\t  break;\n \t\t}\n \t    }\n-\t  if (errmsg)\n-\t    {\n-\t      error_with_decl (newdecl, errmsg, nargs);\n-\t      error_with_decl (olddecl,\n-\t\t\t       \"doesn't match non-prototype definition here\");\n-\t    }\n-\t  else\n-\t    {\n-\t      warning_with_decl (newdecl, \"prototype for `%s' follows\");\n-\t      warning_with_decl (olddecl, \"non-prototype definition here\");\n-\t    }\n \t}\n       /* Warn about mismatches in various flags.  */\n       else\n@@ -2531,7 +2542,7 @@ pushdecl (x)\n \t\t   /* No shadow warnings for vars made for inlining.  */\n \t\t   && ! DECL_FROM_INLINE (x))\n \t    {\n-\t      char *warnstring = 0;\n+\t      char *id = IDENTIFIER_POINTER (name);\n \n \t      if (TREE_CODE (x) == PARM_DECL\n \t\t  && current_binding_level->level_chain->parm_flag)\n@@ -2542,15 +2553,12 @@ pushdecl (x)\n \t\t   but there is no way to tell it's not a definition.  */\n \t\t;\n \t      else if (oldlocal != 0 && TREE_CODE (oldlocal) == PARM_DECL)\n-\t\twarnstring = \"declaration of `%s' shadows a parameter\";\n+\t\twarning (\"declaration of `%s' shadows a parameter\", id);\n \t      else if (oldlocal != 0)\n-\t\twarnstring = \"declaration of `%s' shadows previous local\";\n+\t\twarning (\"declaration of `%s' shadows previous local\", id);\n \t      else if (IDENTIFIER_GLOBAL_VALUE (name) != 0\n \t\t       && IDENTIFIER_GLOBAL_VALUE (name) != error_mark_node)\n-\t\twarnstring = \"declaration of `%s' shadows global declaration\";\n-\n-\t      if (warnstring)\n-\t\twarning (warnstring, IDENTIFIER_POINTER (name));\n+\t\twarning (\"declaration of `%s' shadows global declaration\", id);\n \t    }\n \n \t  /* If storing a local value, there may already be one (inherited).\n@@ -2661,10 +2669,10 @@ implicitly_declare (functionid)\n /* Return zero if the declaration NEWDECL is valid\n    when the declaration OLDDECL (assumed to be for the same name)\n    has already been seen.\n-   Otherwise return an error message format string with a %s\n-   where the identifier should go.  */\n+   Otherwise return 1 if NEWDECL is a redefinition, 2 if it is a redeclaration,\n+   and 3 if it is a conflicting declaration.  */\n \n-static char *\n+static int\n redeclaration_error_message (newdecl, olddecl)\n      tree newdecl, olddecl;\n {\n@@ -2683,7 +2691,7 @@ redeclaration_error_message (newdecl, olddecl)\n \treturn 0;\n       if (DECL_IN_SYSTEM_HEADER (olddecl) || DECL_IN_SYSTEM_HEADER (newdecl))\n \treturn 0;\n-      return \"redefinition of `%s'\";\n+      return 1;\n     }\n   else if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n@@ -2696,7 +2704,7 @@ redeclaration_error_message (newdecl, olddecl)\n \t     time in another way is ok.  */\n \t  && !(DECL_INLINE (olddecl) && DECL_EXTERNAL (olddecl)\n \t       && !(DECL_INLINE (newdecl) && DECL_EXTERNAL (newdecl))))\n-\treturn \"redefinition of `%s'\";\n+\treturn 1;\n       return 0;\n     }\n   else if (current_binding_level == global_binding_level)\n@@ -2707,11 +2715,11 @@ redeclaration_error_message (newdecl, olddecl)\n \treturn 0;\n       /* Reject two definitions.  */\n       if (DECL_INITIAL (olddecl) != 0 && DECL_INITIAL (newdecl) != 0)\n-\treturn \"redefinition of `%s'\";\n+\treturn 1;\n       /* Now we have two tentative defs, or one tentative and one real def.  */\n       /* Insist that the linkage match.  */\n       if (TREE_PUBLIC (olddecl) != TREE_PUBLIC (newdecl))\n-\treturn \"conflicting declarations of `%s'\";\n+\treturn 3;\n       return 0;\n     }\n   else if (current_binding_level->parm_flag\n@@ -2725,7 +2733,7 @@ redeclaration_error_message (newdecl, olddecl)\n \t be an extern reference to olddecl.  */\n       if (!(DECL_EXTERNAL (newdecl) && DECL_EXTERNAL (olddecl))\n \t  && DECL_CONTEXT (newdecl) == DECL_CONTEXT (olddecl))\n-\treturn \"redeclaration of `%s'\";\n+\treturn 2;\n       return 0;\n     }\n }\n@@ -5656,8 +5664,7 @@ parmlist_tags_warning ()\n \n       if (! already)\n \t{\n-\t  warning (\"its scope is only this definition or declaration,\");\n-\t  warning (\"which is probably not what you want.\");\n+\t  warning (\"its scope is only this definition or declaration, which is probably not what you want.\");\n \t  already = 1;\n \t}\n     }\n@@ -5854,9 +5861,10 @@ finish_struct (t, fieldlist, attributes)\n \t  break;\n \n       if (x == 0)\n-\tpedwarn (\"%s has no %smembers\",\n-\t\t (TREE_CODE (t) == UNION_TYPE ? \"union\" : \"structure\"),\n-\t\t (fieldlist ? \"named \" : \"\"));\n+\tpedwarn ((fieldlist\n+\t\t  ? \"%s has no named members\"\n+\t\t  : \"%s has no members\"),\n+\t\t TREE_CODE (t) == UNION_TYPE ? \"union\" : \"struct\");\n     }\n \n   /* Install struct as DECL_CONTEXT of each field decl."}, {"sha": "dc0cc8a84af4cdfba8c160caf7dbbe571edf9d23", "filename": "gcc/c-iterate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -539,10 +539,10 @@ prdecl (d)\n \t  fprintf (stderr, dname);\n \t}\n       else\n-\tfprintf (stderr, \"<<Not a Decl!!!>>\");\n+\tfprintf (stderr, \"<<?>>\");\n     }\n   else\n-    fprintf (stderr, \"<<NULL!!>>\");\n+    fprintf (stderr, \"<<0>>\");\n }\n \n /* Print Iterator List -- names only */"}, {"sha": "71a21aae8cb6e2c0c5fc085178dfd370df9dbba2", "filename": "gcc/c-lex.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -22,6 +22,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include <setjmp.h>\n \n+#if HAVE_LIMITS_H\n+# include <limits.h>\n+#endif\n+\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"input.h\"\n@@ -32,6 +36,18 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-parse.h\"\n #include \"c-pragma.h\"\n #include \"toplev.h\"\n+#include \"intl.h\"\n+\n+#ifdef MAP_CHARACTER\n+#include <ctype.h>\n+#endif\n+\n+/* MULTIBYTE_CHARS support only works for native compilers.\n+   ??? Ideally what we want is to model widechar support after\n+   the current floating point support.  */\n+#ifdef CROSS_COMPILE\n+#undef MULTIBYTE_CHARS\n+#endif\n \n #ifdef MULTIBYTE_CHARS\n #include \"mbchar.h\"\n@@ -221,6 +237,8 @@ finish_parse ()\n void\n init_lex ()\n {\n+  char *p;\n+\n   /* Make identifier nodes long enough for the language-specific slots.  */\n   set_identifier_size (sizeof (struct lang_identifier));\n \n@@ -1040,30 +1058,25 @@ readescape (ignore_ptr)\n }\n \f\n void\n-yyerror (string)\n-     char *string;\n+yyerror (msgid)\n+     char *msgid;\n {\n-  char buf[200];\n-\n-  strcpy (buf, string);\n+  char *string = _(msgid);\n \n   /* We can't print string and character constants well\n      because the token_buffer contains the result of processing escapes.  */\n   if (end_of_file)\n-    strcat (buf, \" at end of input\");\n+    error (\"%s at end of input\", string);\n   else if (token_buffer[0] == 0)\n-    strcat (buf, \" at null character\");\n+    error (\"%s at null character\", string);\n   else if (token_buffer[0] == '\"')\n-    strcat (buf, \" before string constant\");\n+    error (\"%s before string constant\", string);\n   else if (token_buffer[0] == '\\'')\n-    strcat (buf, \" before character constant\");\n+    error (\"%s before character constant\", string);\n   else if (token_buffer[0] < 040 || (unsigned char) token_buffer[0] >= 0177)\n-    sprintf (buf + strlen (buf), \" before character 0%o\",\n-\t     (unsigned char) token_buffer[0]);\n+    error (\"%s before character 0%o\", string, (unsigned char) token_buffer[0]);\n   else\n-    strcat (buf, \" before `%s'\");\n-\n-  error (buf, token_buffer);\n+    error (\"%s before `%s'\", string, token_buffer);\n }\n \n #if 0\n@@ -1197,8 +1210,6 @@ yylex ()\n       while (ISALNUM (c) || c == '_' || c == '$' || c == '@')\n \t{\n \t  /* Make sure this char really belongs in an identifier.  */\n-\t  if (c == '@' && ! doing_objc_thang)\n-\t    break;\n \t  if (c == '$')\n \t    {\n \t      if (! dollars_in_ident)"}, {"sha": "e38b7babe94d0d6705859ea89075226fb7f25886", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for C parsing and type checking.\n-   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 93, 94, 95, 97, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -385,10 +385,8 @@ extern tree build_modify_expr                   PROTO((tree, enum tree_code,\n \t\t\t\t\t\t       tree));\n extern tree initializer_constant_valid_p\tPROTO((tree, tree));\n extern void store_init_value                    PROTO((tree, tree));\n-extern void error_init\t\t\t\tPROTO((char *, char *,\n-\t\t\t\t\t\t       char *));\n-extern void pedwarn_init\t\t\tPROTO((char *, char *,\n-\t\t\t\t\t\t       char *));\n+extern void error_init\t\t\t\tPROTO((char *));\n+extern void pedwarn_init\t\t\tPROTO((char *));\n extern void start_init\t\t\t\tPROTO((tree, tree, int));\n extern void finish_init\t\t\t\tPROTO((void));\n extern void really_start_incremental_init\tPROTO((tree));"}, {"sha": "a16760282b4cf8e9348e99563d313f0f08dc0716", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 147, "deletions": 239, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n+#include \"intl.h\"\n \n /* Nonzero if we've already printed a \"missing braces around initializer\"\n    message within this initializer.  */\n@@ -64,9 +65,7 @@ static void push_member_name\t\tPROTO((tree));\n static void push_array_bounds\t\tPROTO((int));\n static int spelling_length\t\tPROTO((void));\n static char *print_spelling\t\tPROTO((char *));\n-static char *get_spelling\t\tPROTO((char *));\n-static void warning_init\t\tPROTO((char *, char *,\n-\t\t\t\t\t       char *));\n+static void warning_init\t\tPROTO((char *));\n static tree digest_init\t\t\tPROTO((tree, tree, int, int));\n static void check_init_type_bitfields\tPROTO((tree));\n static void output_init_element\t\tPROTO((tree, tree, tree, int));\n@@ -101,7 +100,7 @@ incomplete_type_error (value, type)\n      tree value;\n      tree type;\n {\n-  char *errmsg;\n+  char *type_code_string;\n \n   /* Avoid duplicate error message.  */\n   if (TREE_CODE (type) == ERROR_MARK)\n@@ -119,15 +118,15 @@ incomplete_type_error (value, type)\n       switch (TREE_CODE (type))\n \t{\n \tcase RECORD_TYPE:\n-\t  errmsg = \"invalid use of undefined type `struct %s'\";\n+\t  type_code_string = \"struct\";\n \t  break;\n \n \tcase UNION_TYPE:\n-\t  errmsg = \"invalid use of undefined type `union %s'\";\n+\t  type_code_string = \"union\";\n \t  break;\n \n \tcase ENUMERAL_TYPE:\n-\t  errmsg = \"invalid use of undefined type `enum %s'\";\n+\t  type_code_string = \"enum\";\n \t  break;\n \n \tcase VOID_TYPE:\n@@ -148,7 +147,8 @@ incomplete_type_error (value, type)\n \t}\n \n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\terror (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type)));\n+\terror (\"invalid use of undefined type `%s %s'\",\n+\t       type_code_string, IDENTIFIER_POINTER (TYPE_NAME (type)));\n       else\n \t/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */\n \terror (\"invalid use of incomplete typedef `%s'\",\n@@ -2790,7 +2790,6 @@ build_unary_op (code, xarg, noconvert)\n   register tree arg = xarg;\n   register tree argtype = 0;\n   register enum tree_code typecode = TREE_CODE (TREE_TYPE (arg));\n-  char *errstring = NULL;\n   tree val;\n \n   if (typecode == ERROR_MARK)\n@@ -2806,15 +2805,21 @@ build_unary_op (code, xarg, noconvert)\n \t associativity, but won't generate any code.  */\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n \t    || typecode == COMPLEX_TYPE))\n-        errstring = \"wrong type argument to unary plus\";\n+\t{\n+\t  error (\"wrong type argument to unary plus\");\n+\t  return error_mark_node;\n+\t}\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case NEGATE_EXPR:\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n \t    || typecode == COMPLEX_TYPE))\n-        errstring = \"wrong type argument to unary minus\";\n+\t{\n+\t  error (\"wrong type argument to unary minus\");\n+\t  return error_mark_node;\n+\t}\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n@@ -2827,15 +2832,21 @@ build_unary_op (code, xarg, noconvert)\n \t    arg = default_conversion (arg);\n \t}\n       else if (typecode != INTEGER_TYPE)\n-        errstring = \"wrong type argument to bit-complement\";\n+\t{\n+\t  error (\"wrong type argument to bit-complement\");\n+\t  return error_mark_node;\n+\t}\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case ABS_EXPR:\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n \t    || typecode == COMPLEX_TYPE))\n-        errstring = \"wrong type argument to abs\";\n+\t{\n+\t  error (\"wrong type argument to abs\");\n+\t  return error_mark_node;\n+\t}\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n@@ -2844,7 +2855,10 @@ build_unary_op (code, xarg, noconvert)\n       /* Conjugating a real value is a no-op, but allow it anyway.  */\n       if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n \t    || typecode == COMPLEX_TYPE))\n-\terrstring = \"wrong type argument to conjugation\";\n+\t{\n+\t  error (\"wrong type argument to conjugation\");\n+\t  return error_mark_node;\n+\t}\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n@@ -2856,8 +2870,8 @@ build_unary_op (code, xarg, noconvert)\n \t  /* These will convert to a pointer.  */\n \t  && typecode != ARRAY_TYPE && typecode != FUNCTION_TYPE)\n \t{\n-\t  errstring = \"wrong type argument to unary exclamation mark\";\n-\t  break;\n+\t  error (\"wrong type argument to unary exclamation mark\");\n+\t  return error_mark_node;\n \t}\n       arg = truthvalue_conversion (arg);\n       return invert_truthvalue (arg);\n@@ -2910,11 +2924,10 @@ build_unary_op (code, xarg, noconvert)\n       if (typecode != POINTER_TYPE\n \t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE)\n \t{\n-\t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t    errstring =\"wrong type argument to increment\";\n-\t  else\n-\t    errstring =\"wrong type argument to decrement\";\n-\t  break;\n+\t  error (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR\n+\t\t ? \"wrong type argument to increment\"\n+\t\t : \"wrong type argument to decrement\");\n+\t  return error_mark_node;\n \t}\n \n       {\n@@ -2931,17 +2944,15 @@ build_unary_op (code, xarg, noconvert)\n \t    /* If pointer target is an undefined struct,\n \t       we just cannot know how to do the arithmetic.  */\n \t    if (TYPE_SIZE (TREE_TYPE (result_type)) == 0)\n-\t      error (\"%s of pointer to unknown structure\",\n-\t\t       ((code == PREINCREMENT_EXPR\n-\t\t\t || code == POSTINCREMENT_EXPR)\n-\t\t\t? \"increment\" : \"decrement\"));\n+\t      error (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR\n+\t\t     ? \"increment of pointer to unknown structure\"\n+\t\t     : \"decrement of pointer to unknown structure\");\n \t    else if ((pedantic || warn_pointer_arith)\n \t\t     && (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE\n \t\t\t || TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE))\n-\t      pedwarn (\"wrong type argument to %s\",\n-\t\t       ((code == PREINCREMENT_EXPR\n-\t\t\t || code == POSTINCREMENT_EXPR)\n-\t\t\t? \"increment\" : \"decrement\"));\n+\t      pedwarn (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR\n+\t\t       ? \"wrong type argument to increment\"\n+\t\t       : \"wrong type argument to decrement\");\n \t    inc = c_size_in_bytes (TREE_TYPE (result_type));\n \t  }\n \telse\n@@ -2998,7 +3009,8 @@ build_unary_op (code, xarg, noconvert)\n \t/* Complain about anything else that is not a true lvalue.  */\n \tif (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n \t\t\t\t    || code == POSTINCREMENT_EXPR)\n-\t\t\t\t   ? \"increment\" : \"decrement\")))\n+\t\t\t\t   ? \"invalid lvalue in increment\"\n+\t\t\t\t   : \"invalid lvalue in decrement\")))\n \t  return error_mark_node;\n \n \t/* Report a read-only lvalue.  */\n@@ -3072,7 +3084,8 @@ build_unary_op (code, xarg, noconvert)\n \t;\n       /* Anything not already handled and not a true memory reference\n \t is an error.  */\n-      else if (typecode != FUNCTION_TYPE && !lvalue_or_else (arg, \"unary `&'\"))\n+      else if (typecode != FUNCTION_TYPE\n+\t       && !lvalue_or_else (arg, \"invalid lvalue in unary `&'\"))\n \treturn error_mark_node;\n \n       /* Ordinary case; arg is a COMPONENT_REF or a decl.  */\n@@ -3140,15 +3153,9 @@ build_unary_op (code, xarg, noconvert)\n       break;\n     }\n \n-  if (!errstring)\n-    {\n-      if (argtype == 0)\n-\targtype = TREE_TYPE (arg);\n-      return fold (build1 (code, argtype, arg));\n-    }\n-\n-  error (errstring);\n-  return error_mark_node;\n+  if (argtype == 0)\n+    argtype = TREE_TYPE (arg);\n+  return fold (build1 (code, argtype, arg));\n }\n \n #if 0\n@@ -3222,13 +3229,13 @@ lvalue_p (ref)\n    otherwise, print an error message and return zero.  */\n \n int\n-lvalue_or_else (ref, string)\n+lvalue_or_else (ref, msgid)\n      tree ref;\n-     char *string;\n+     char *msgid;\n {\n   int win = lvalue_p (ref);\n   if (! win)\n-    error (\"invalid lvalue in %s\", string);\n+    error (msgid);\n   return win;\n }\n \n@@ -3281,47 +3288,38 @@ pedantic_lvalue_warning (code)\n      enum tree_code code;\n {\n   if (pedantic)\n-    pedwarn (\"ANSI C forbids use of %s expressions as lvalues\",\n-\t     code == COND_EXPR ? \"conditional\"\n-\t     : code == COMPOUND_EXPR ? \"compound\" : \"cast\");\n+    pedwarn (code == COND_EXPR\n+\t     ? \"ANSI C forbids use of conditional expressions as lvalues\"\n+\t     : code == COMPOUND_EXPR\n+\t     ? \"ANSI C forbids use of compound expressions as lvalues\"\n+\t     : \"ANSI C forbids use of cast expressions as lvalues\");\n }\n \f\n /* Warn about storing in something that is `const'.  */\n \n void\n-readonly_warning (arg, string)\n+readonly_warning (arg, msgid)\n      tree arg;\n-     char *string;\n+     char *msgid;\n {\n-  char buf[80];\n-  strcpy (buf, string);\n-\n   /* Forbid assignments to iterators.  */\n   if (TREE_CODE (arg) == VAR_DECL && ITERATOR_P (arg))\n-    {\n-      strcat (buf, \" of iterator `%s'\");\n-      pedwarn (buf, IDENTIFIER_POINTER (DECL_NAME (arg)));\n-    }\n+    pedwarn (\"%s of iterator `%s'\",  _(msgid), \n+\t     IDENTIFIER_POINTER (DECL_NAME (arg)));\n \n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-\treadonly_warning (TREE_OPERAND (arg, 0), string);\n+\treadonly_warning (TREE_OPERAND (arg, 0), msgid);\n       else\n-\t{\n-\t  strcat (buf, \" of read-only member `%s'\");\n-\t  pedwarn (buf, IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (arg, 1))));\n-\t}\n+\tpedwarn (\"%s of read-only member `%s'\", _(msgid),\n+\t\t IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (arg, 1))));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n-    {\n-      strcat (buf, \" of read-only variable `%s'\");\n-      pedwarn (buf, IDENTIFIER_POINTER (DECL_NAME (arg)));\n-    }\n+    pedwarn (\"%s of read-only variable `%s'\", _(msgid),\n+\t     IDENTIFIER_POINTER (DECL_NAME (arg)));\n   else\n-    {\n-      pedwarn (\"%s of read-only location\", buf);\n-    }\n+    pedwarn (\"%s of read-only location\", _(msgid));\n }\n \f\n /* Mark EXP saying that we need to be able to take the\n@@ -3963,7 +3961,7 @@ build_modify_expr (lhs, modifycode, rhs)\n   /* Now we have handled acceptable kinds of LHS that are not truly lvalues.\n      Reject anything strange now.  */\n \n-  if (!lvalue_or_else (lhs, \"assignment\"))\n+  if (!lvalue_or_else (lhs, \"invalid lvalue in assignment\"))\n     return error_mark_node;\n \n   /* Warn about storing in something that is `const'.  */\n@@ -3996,7 +3994,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   /* Convert new value to destination type.  */\n \n-  newrhs = convert_for_assignment (lhstype, newrhs, \"assignment\",\n+  newrhs = convert_for_assignment (lhstype, newrhs, _(\"assignment\"),\n \t\t\t\t   NULL_TREE, NULL_TREE, 0);\n   if (TREE_CODE (newrhs) == ERROR_MARK)\n     return error_mark_node;\n@@ -4011,7 +4009,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   if (olhstype == TREE_TYPE (result))\n     return result;\n-  return convert_for_assignment (olhstype, result, \"assignment\",\n+  return convert_for_assignment (olhstype, result, _(\"assignment\"),\n \t\t\t\t NULL_TREE, NULL_TREE, 0);\n }\n \f\n@@ -4022,9 +4020,7 @@ build_modify_expr (lhs, modifycode, rhs)\n    for assignments that are not allowed in C.\n    ERRTYPE is a string to use in error messages:\n    \"assignment\", \"return\", etc.  If it is null, this is parameter passing\n-   for a function call (and different error messages are output).  Otherwise,\n-   it may be a name stored in the spelling stack and interpreted by\n-   get_spelling.\n+   for a function call (and different error messages are output).\n \n    FUNNAME is the name of the function being called,\n    as an IDENTIFIER_NODE, or null.\n@@ -4159,12 +4155,11 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t     vice-versa.  */\n \t\t  if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n \t\t    warn_for_assignment (\"%s makes qualified function pointer from unqualified\",\n-\t\t\t\t\t get_spelling (errtype), funname,\n-\t\t\t\t\t parmnum);\n+\t\t\t\t\t errtype, funname, parmnum);\n \t\t}\n \t      else if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n \t\twarn_for_assignment (\"%s discards qualifiers from pointer target type\",\n-\t\t\t\t     get_spelling (errtype), funname,\n+\t\t\t\t     errtype, funname,\n \t\t\t\t     parmnum);\n \t    }\n \t  \n@@ -4200,15 +4195,15 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t   && (!integer_zerop (rhs) || TREE_CODE (rhs) == NOP_EXPR)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n \t    warn_for_assignment (\"ANSI forbids %s between function pointer and `void *'\",\n-\t\t\t\t get_spelling (errtype), funname, parmnum);\n+\t\t\t\t errtype, funname, parmnum);\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n \t      if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n \t\twarn_for_assignment (\"%s discards qualifiers from pointer target type\",\n-\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t\t     errtype, funname, parmnum);\n \t      /* If this is not a case of ignoring a mismatch in signedness,\n \t\t no warning.  */\n \t      else if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n@@ -4218,7 +4213,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t      /* If there is a mismatch, do warn.  */\n \t      else if (pedantic)\n \t\twarn_for_assignment (\"pointer targets in %s differ in signedness\",\n-\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t\t     errtype, funname, parmnum);\n \t    }\n \t  else if (TREE_CODE (ttl) == FUNCTION_TYPE\n \t\t   && TREE_CODE (ttr) == FUNCTION_TYPE)\n@@ -4229,12 +4224,12 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n \t      if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n \t\twarn_for_assignment (\"%s makes qualified function pointer from unqualified\",\n-\t\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t\t     errtype, funname, parmnum);\n \t    }\n \t}\n       else\n \twarn_for_assignment (\"%s from incompatible pointer type\",\n-\t\t\t     get_spelling (errtype), funname, parmnum);\n+\t\t\t     errtype, funname, parmnum);\n       return convert (type, rhs);\n     }\n   else if (codel == POINTER_TYPE && coder == INTEGER_TYPE)\n@@ -4250,15 +4245,15 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t     && integer_zerop (TREE_OPERAND (rhs, 0))))\n \t{\n \t  warn_for_assignment (\"%s makes pointer from integer without a cast\",\n-\t\t\t       get_spelling (errtype), funname, parmnum);\n+\t\t\t       errtype, funname, parmnum);\n \t  return convert (type, rhs);\n \t}\n       return null_pointer_node;\n     }\n   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)\n     {\n       warn_for_assignment (\"%s makes integer from pointer without a cast\",\n-\t\t\t   get_spelling (errtype), funname, parmnum);\n+\t\t\t   errtype, funname, parmnum);\n       return convert (type, rhs);\n     }\n \n@@ -4280,27 +4275,24 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t       parmnum);\n     }\n   else\n-    error (\"incompatible types in %s\", get_spelling (errtype));\n+    error (\"incompatible types in %s\", errtype);\n \n   return error_mark_node;\n }\n \n-/* Print a warning using MSG.\n+/* Print a warning using MSGID.\n    It gets OPNAME as its one parameter.\n    If OPNAME is null, it is replaced by \"passing arg ARGNUM of `FUNCTION'\".\n    FUNCTION and ARGNUM are handled specially if we are building an\n    Objective-C selector.  */\n \n static void\n-warn_for_assignment (msg, opname, function, argnum)\n-     char *msg;\n+warn_for_assignment (msgid, opname, function, argnum)\n+     char *msgid;\n      char *opname;\n      tree function;\n      int argnum;\n {\n-  static char argstring[] = \"passing arg %d of `%s'\";\n-  static char argnofun[] =  \"passing arg %d\";\n-\n   if (opname == 0)\n     {\n       tree selector = maybe_building_objc_message_expr ();\n@@ -4313,18 +4305,20 @@ warn_for_assignment (msg, opname, function, argnum)\n       if (function)\n \t{\n \t  /* Function name is known; supply it.  */\n+\t  char *argstring = _(\"passing arg %d of `%s'\");\n \t  opname = (char *) alloca (IDENTIFIER_LENGTH (function)\n-\t\t\t\t    + sizeof (argstring) + 25 /*%d*/ + 1);\n+\t\t\t\t    + strlen (argstring) + 1 + 25 /*%d*/ + 1);\n \t  sprintf (opname, argstring, argnum, IDENTIFIER_POINTER (function));\n \t}\n       else\n \t{\n \t  /* Function name unknown (call through ptr); just give arg number.  */\n-\t  opname = (char *) alloca (sizeof (argnofun) + 25 /*%d*/ + 1);\n+\t  char *argnofun = _(\"passing arg %d of pointer to function\");\n+\t  opname = (char *) alloca (strlen (argnofun) + 1 + 25 /*%d*/ + 1);\n \t  sprintf (opname, argnofun, argnum);\n \t}\n     }\n-  pedwarn (msg, opname);\n+  pedwarn (msgid, opname);\n }\n \f\n /* Return nonzero if VALUE is a valid constant-valued expression\n@@ -4691,115 +4685,52 @@ print_spelling (buffer)\n   return buffer;\n }\n \n-/* Provide a means to pass component names derived from the spelling stack.  */\n-\n-char initialization_message;\n-\n-/* Interpret the spelling of the given ERRTYPE message.  */\n-\n-static char *\n-get_spelling (errtype)\n-     char *errtype;\n-{\n-  static char *buffer;\n-  static int size = -1;\n-\n-  if (errtype == &initialization_message)\n-    {\n-      /* Avoid counting chars */\n-      static char message[] = \"initialization of `%s'\";\n-      register int needed = sizeof (message) + spelling_length () + 1;\n-      char *temp;\n-\n-      if (size < 0)\n-\tbuffer = (char *) xmalloc (size = needed);\n-      if (needed > size)\n-\tbuffer = (char *) xrealloc (buffer, size = needed);\n-\n-      temp = (char *) alloca (needed);\n-      sprintf (buffer, message, print_spelling (temp));\n-      return buffer;\n-    }\n-\n-  return errtype;\n-}\n-\n /* Issue an error message for a bad initializer component.\n-   FORMAT describes the message.  OFWHAT is the name for the component.\n-   LOCAL is a format string for formatting the insertion of the name\n-   into the message.\n-\n-   If OFWHAT is null, the component name is stored on the spelling stack.\n-   If the component name is a null string, then LOCAL is omitted entirely.  */\n+   MSGID identifies the message.\n+   The component name is taken from the spelling stack.  */\n \n void\n-error_init (format, local, ofwhat)\n-     char *format, *local, *ofwhat;\n+error_init (msgid)\n+     char *msgid;\n {\n-  char *buffer;\n-\n-  if (ofwhat == 0)\n-    ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n-  buffer = (char *) alloca (strlen (local) + strlen (ofwhat) + 2);\n+  char *ofwhat;\n \n+  error (msgid);\n+  ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    sprintf (buffer, local, ofwhat);\n-  else\n-    buffer[0] = 0;\n-\n-  error (format, buffer);\n+    error (\"(near initialization for `%s')\", ofwhat);\n }\n \n /* Issue a pedantic warning for a bad initializer component.\n-   FORMAT describes the message.  OFWHAT is the name for the component.\n-   LOCAL is a format string for formatting the insertion of the name\n-   into the message.\n-\n-   If OFWHAT is null, the component name is stored on the spelling stack.\n-   If the component name is a null string, then LOCAL is omitted entirely.  */\n+   MSGID identifies the message.\n+   The component name is taken from the spelling stack.  */\n \n void\n-pedwarn_init (format, local, ofwhat)\n-     char *format, *local, *ofwhat;\n+pedwarn_init (msgid)\n+     char *msgid;\n {\n-  char *buffer;\n-\n-  if (ofwhat == 0)\n-    ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n-  buffer = (char *) alloca (strlen (local) + strlen (ofwhat) + 2);\n+  char *ofwhat;\n \n+  pedwarn (msgid);\n+  ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    sprintf (buffer, local, ofwhat);\n-  else\n-    buffer[0] = 0;\n-\n-  pedwarn (format, buffer);\n+    pedwarn (\"(near initialization for `%s')\", ofwhat);\n }\n \n /* Issue a warning for a bad initializer component.\n-   FORMAT describes the message.  OFWHAT is the name for the component.\n-   LOCAL is a format string for formatting the insertion of the name\n-   into the message.\n-\n-   If OFWHAT is null, the component name is stored on the spelling stack.\n-   If the component name is a null string, then LOCAL is omitted entirely.  */\n+   MSGID identifies the message.\n+   The component name is taken from the spelling stack.  */\n \n static void\n-warning_init (format, local, ofwhat)\n-     char *format, *local, *ofwhat;\n+warning_init (msgid)\n+     char *msgid;\n {\n-  char *buffer;\n-\n-  if (ofwhat == 0)\n-    ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n-  buffer = (char *) alloca (strlen (local) + strlen (ofwhat) + 2);\n+  char *ofwhat;\n \n+  warning (msgid);\n+  ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    sprintf (buffer, local, ofwhat);\n-  else\n-    buffer[0] = 0;\n-\n-  warning (format, buffer);\n+    warning (\"(near initialization for `%s')\", ofwhat);\n }\n \f\n /* Digest the parser output INIT as an initializer for type TYPE.\n@@ -4847,16 +4778,14 @@ digest_init (type, init, require_constant, constructor_constant)\n \t       != char_type_node)\n \t      && TYPE_PRECISION (typ1) == TYPE_PRECISION (char_type_node))\n \t    {\n-\t      error_init (\"char-array%s initialized from wide string\",\n-\t\t\t  \" `%s'\", NULL);\n+\t      error_init (\"char-array initialized from wide string\");\n \t      return error_mark_node;\n \t    }\n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (inside_init)))\n \t       == char_type_node)\n \t      && TYPE_PRECISION (typ1) != TYPE_PRECISION (char_type_node))\n \t    {\n-\t      error_init (\"int-array%s initialized from non-wide string\",\n-\t\t\t  \" `%s'\", NULL);\n+\t      error_init (\"int-array initialized from non-wide string\");\n \t      return error_mark_node;\n \t    }\n \n@@ -4873,9 +4802,7 @@ digest_init (type, init, require_constant, constructor_constant)\n \t\t  - (TYPE_PRECISION (typ1) != TYPE_PRECISION (char_type_node)\n \t\t     ? TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT\n \t\t     : 1))\n-\t\tpedwarn_init (\n-\t\t  \"initializer-string for array of chars%s is too long\",\n-\t\t  \" `%s'\", NULL);\n+\t\tpedwarn_init (\"initializer-string for array of chars is too long\");\n \t    }\n \t  return inside_init;\n \t}\n@@ -4902,8 +4829,7 @@ digest_init (type, init, require_constant, constructor_constant)\n       else if (code == ARRAY_TYPE && TREE_CODE (inside_init) != STRING_CST\n \t       && TREE_CODE (inside_init) != CONSTRUCTOR)\n \t{\n-\t  error_init (\"array%s initialized from non-constant array expression\",\n-\t\t      \" `%s'\", NULL);\n+\t  error_init (\"array initialized from non-constant array expression\");\n \t  return error_mark_node;\n \t}\n \n@@ -4920,25 +4846,21 @@ digest_init (type, init, require_constant, constructor_constant)\n \t    = valid_compound_expr_initializer (inside_init,\n \t\t\t\t\t       TREE_TYPE (inside_init));\n \t  if (inside_init == error_mark_node)\n-\t    error_init (\"initializer element%s is not constant\",\n-\t\t\t\" for `%s'\", NULL);\n+\t    error_init (\"initializer element is not constant\");\n \t  else\n-\t    pedwarn_init (\"initializer element%s is not constant\",\n-\t\t\t  \" for `%s'\", NULL);\n+\t    pedwarn_init (\"initializer element is not constant\");\n \t  if (flag_pedantic_errors)\n \t    inside_init = error_mark_node;\n \t}\n       else if (require_constant && ! TREE_CONSTANT (inside_init))\n \t{\n-\t  error_init (\"initializer element%s is not constant\",\n-\t\t      \" for `%s'\", NULL);\n+\t  error_init (\"initializer element is not constant\");\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant\n \t       && initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)) == 0)\n \t{\n-\t  error_init (\"initializer element%s is not computable at load time\",\n-\t\t      \" for `%s'\", NULL);\n+\t  error_init (\"initializer element is not computable at load time\");\n \t  inside_init = error_mark_node;\n \t}\n \n@@ -4954,20 +4876,18 @@ digest_init (type, init, require_constant, constructor_constant)\n \t for arrays and functions.  We must not call it in the\n \t case where inside_init is a null pointer constant.  */\n       inside_init\n-\t= convert_for_assignment (type, init, \"initialization\",\n+\t= convert_for_assignment (type, init, _(\"initialization\"),\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n \n       if (require_constant && ! TREE_CONSTANT (inside_init))\n \t{\n-\t  error_init (\"initializer element%s is not constant\",\n-\t\t      \" for `%s'\", NULL);\n+\t  error_init (\"initializer element is not constant\");\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant\n \t       && initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)) == 0)\n \t{\n-\t  error_init (\"initializer element%s is not computable at load time\",\n-\t\t      \" for `%s'\", NULL);\n+\t  error_init (\"initializer element is not computable at load time\");\n \t  inside_init = error_mark_node;\n \t}\n \n@@ -4978,8 +4898,7 @@ digest_init (type, init, require_constant, constructor_constant)\n \n   if (TYPE_SIZE (type) && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n-      error_init (\"variable-sized object%s may not be initialized\",\n-\t\t  \" `%s'\", NULL);\n+      error_init (\"variable-sized object may not be initialized\");\n       return error_mark_node;\n     }\n \n@@ -5005,7 +4924,7 @@ digest_init (type, init, require_constant, constructor_constant)\n \t    type = TREE_TYPE (TYPE_FIELDS (type));\n \t  else\n \t    {\n-\t      error_init (\"invalid initializer%s\", \" for `%s'\", NULL);\n+\t      error_init (\"invalid initializer\");\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -5021,7 +4940,7 @@ digest_init (type, init, require_constant, constructor_constant)\n       else\n \treturn error_mark_node;\n     }\n-  error_init (\"invalid initializer%s\", \" for `%s'\", NULL);\n+  error_init (\"invalid initializer\");\n   return error_mark_node;\n }\n \f\n@@ -5498,8 +5417,7 @@ push_init_level (implicit)\n \n   if (constructor_type == 0)\n     {\n-      error_init (\"extra brace group at end of initializer%s\",\n-\t\t  \" for `%s'\", NULL);\n+      error_init (\"extra brace group at end of initializer\");\n       constructor_fields = 0;\n       constructor_unfilled_fields = 0;\n       return;\n@@ -5511,7 +5429,7 @@ push_init_level (implicit)\n   if (implicit && warn_missing_braces && !missing_braces_mentioned)\n     {\n       missing_braces_mentioned = 1;\n-      warning_init (\"missing braces around initializer%s\", \" for `%s'\", NULL);\n+      warning_init (\"missing braces around initializer\");\n     }\n \n   if (TREE_CODE (constructor_type) == RECORD_TYPE\n@@ -5542,7 +5460,7 @@ push_init_level (implicit)\n     }\n   else\n     {\n-      warning_init (\"braces around scalar initializer%s\", \" for `%s'\", NULL);\n+      warning_init (\"braces around scalar initializer\");\n       constructor_fields = constructor_type;\n       constructor_unfilled_fields = constructor_type;\n     }\n@@ -5614,7 +5532,7 @@ pop_init_level (implicit)\n       && constructor_unfilled_fields)\n     {\n       push_member_name (constructor_unfilled_fields);\n-      warning_init (\"missing initializer%s\", \" for `%s'\", NULL);\n+      warning_init (\"missing initializer\");\n       RESTORE_SPELLING_DEPTH (constructor_depth);\n     }\n \n@@ -5627,7 +5545,7 @@ pop_init_level (implicit)\n       && (TREE_CODE (constructor_type) == ARRAY_TYPE\n \t  ? integer_zerop (constructor_unfilled_index)\n \t  : constructor_unfilled_fields == TYPE_FIELDS (constructor_type)))\n-    pedwarn_init (\"empty braces in initializer%s\", \" for `%s'\", NULL);\n+    pedwarn_init (\"empty braces in initializer\");\n #endif\n \n   /* Pad out the end of the structure.  */\n@@ -5691,14 +5609,12 @@ pop_init_level (implicit)\n \t the element, after verifying there is just one.  */\n       if (constructor_elements == 0)\n \t{\n-\t  error_init (\"empty scalar initializer%s\",\n-\t\t      \" for `%s'\", NULL);\n+\t  error_init (\"empty scalar initializer\");\n \t  constructor = error_mark_node;\n \t}\n       else if (TREE_CHAIN (constructor_elements) != 0)\n \t{\n-\t  error_init (\"extra elements in scalar initializer%s\",\n-\t\t      \" for `%s'\", NULL);\n+\t  error_init (\"extra elements in scalar initializer\");\n \t  constructor = TREE_VALUE (constructor_elements);\n \t}\n       else\n@@ -5832,20 +5748,20 @@ set_init_index (first, last)\n       (last) = TREE_OPERAND (last, 0);\n \n   if (TREE_CODE (first) != INTEGER_CST)\n-    error_init (\"nonconstant array index in initializer%s\", \" for `%s'\", NULL);\n+    error_init (\"nonconstant array index in initializer\");\n   else if (last != 0 && TREE_CODE (last) != INTEGER_CST)\n-    error_init (\"nonconstant array index in initializer%s\", \" for `%s'\", NULL);\n+    error_init (\"nonconstant array index in initializer\");\n   else if (! constructor_unfilled_index)\n-    error_init (\"array index in non-array initializer%s\", \" for `%s'\", NULL);\n+    error_init (\"array index in non-array initializer\");\n   else if (tree_int_cst_lt (first, constructor_unfilled_index))\n-    error_init (\"duplicate array index in initializer%s\", \" for `%s'\", NULL);\n+    error_init (\"duplicate array index in initializer\");\n   else\n     {\n       TREE_INT_CST_LOW (constructor_index) = TREE_INT_CST_LOW (first);\n       TREE_INT_CST_HIGH (constructor_index) = TREE_INT_CST_HIGH (first);\n \n       if (last != 0 && tree_int_cst_lt (last, first))\n-\terror_init (\"empty index range in initializer%s\", \" for `%s'\", NULL);\n+\terror_init (\"empty index range in initializer\");\n       else\n \t{\n \t  if (pedantic)\n@@ -6176,15 +6092,13 @@ output_init_element (value, type, field, pending)\n \n   if (require_constant_value && ! TREE_CONSTANT (value))\n     {\n-      error_init (\"initializer element%s is not constant\",\n-\t\t  \" for `%s'\", NULL);\n+      error_init (\"initializer element is not constant\");\n       value = error_mark_node;\n     }\n   else if (require_constant_elements\n \t   && initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)\n     {\n-      error_init (\"initializer element%s is not computable at load time\",\n-\t\t  \" for `%s'\", NULL);\n+      error_init (\"initializer element is not computable at load time\");\n       value = error_mark_node;\n     }\n \n@@ -6200,7 +6114,7 @@ output_init_element (value, type, field, pending)\n \t{\n \t  if (pending_init_member (field))\n \t    {\n-\t      error_init (\"duplicate initializer%s\", \" for `%s'\", NULL);\n+\t      error_init (\"duplicate initializer\");\n \t      duplicate = 1;\n \t    }\n \t}\n@@ -6553,8 +6467,7 @@ process_init_element (value)\n \n   if (constructor_stack->replacement_value != 0)\n     {\n-      error_init (\"excess elements in struct initializer%s\",\n-\t\t  \" after `%s'\", NULL_PTR);\n+      error_init (\"excess elements in struct initializer\");\n       return;\n     }\n \n@@ -6589,8 +6502,7 @@ process_init_element (value)\n \n \t  if (constructor_fields == 0)\n \t    {\n-\t      pedwarn_init (\"excess elements in struct initializer%s\",\n-\t\t\t    \" after `%s'\", NULL_PTR);\n+\t      pedwarn_init (\"excess elements in struct initializer\");\n \t      break;\n \t    }\n \n@@ -6654,8 +6566,7 @@ process_init_element (value)\n \n \t  if (constructor_fields == 0)\n \t    {\n-\t      pedwarn_init (\"excess elements in union initializer%s\",\n-\t\t\t    \" after `%s'\", NULL_PTR);\n+\t      pedwarn_init (\"excess elements in union initializer\");\n \t      break;\n \t    }\n \n@@ -6729,8 +6640,7 @@ process_init_element (value)\n \t  if (constructor_max_index != 0\n \t      && tree_int_cst_lt (constructor_max_index, constructor_index))\n \t    {\n-\t      pedwarn_init (\"excess elements in array initializer%s\",\n-\t\t\t    \" after `%s'\", NULL_PTR);\n+\t      pedwarn_init (\"excess elements in array initializer\");\n \t      break;\n \t    }\n \n@@ -6741,8 +6651,7 @@ process_init_element (value)\n \t\t  && tree_int_cst_lt (constructor_max_index, \n \t\t\t\t      constructor_range_end))\n \t\t{\n-\t\t  pedwarn_init (\"excess elements in array initializer%s\",\n-\t\t\t\t\" after `%s'\", NULL_PTR);\n+\t\t  pedwarn_init (\"excess elements in array initializer\");\n \t\t  TREE_INT_CST_HIGH (constructor_range_end)\n \t\t    = TREE_INT_CST_HIGH (constructor_max_index);\n \t\t  TREE_INT_CST_LOW (constructor_range_end)\n@@ -6793,8 +6702,7 @@ process_init_element (value)\n \t for a scalar variable.  */\n       if (constructor_fields == 0)\n \t{\n-\t  pedwarn_init (\"excess elements in scalar initializer%s\",\n-\t\t\t\" after `%s'\", NULL_PTR);\n+\t  pedwarn_init (\"excess elements in scalar initializer\");\n \t  break;\n \t}\n \n@@ -6911,7 +6819,7 @@ c_expand_return (retval)\n     }\n   else\n     {\n-      tree t = convert_for_assignment (valtype, retval, \"return\",\n+      tree t = convert_for_assignment (valtype, retval, _(\"return\"),\n \t\t\t\t       NULL_TREE, NULL_TREE, 0);\n       tree res = DECL_RESULT (current_function_decl);\n       tree inner;"}, {"sha": "b5bb745c7e7b91657f26c2aa137d98800956886a", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1192,8 +1192,9 @@ expand_call (exp, target, ignore)\n \n   /* Operand 0 is a pointer-to-function; get the type of the function.  */\n   funtype = TREE_TYPE (TREE_OPERAND (exp, 0));\n-  if (TREE_CODE (funtype) != POINTER_TYPE)\n+  if (! POINTER_TYPE_P (funtype))\n     abort ();\n+\n   funtype = TREE_TYPE (funtype);\n \n   /* Push the temporary stack slot level so that we can free any temporaries\n@@ -2393,7 +2394,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n #else\n-  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE ((tree) 0);\n #endif\n #endif\n \n@@ -2891,7 +2892,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n   reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n #else\n-  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE ((tree) 0);\n #endif\n #endif\n "}, {"sha": "551f8d730dd8b760fc4d215325ae4b687ddcc3c2", "filename": "gcc/cccp.c", "status": "modified", "additions": 182, "deletions": 130, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -20,13 +20,6 @@ Boston, MA 02111-1307, USA. */\n \n #include \"config.h\"\n \n-#define PRINTF_PROTO(ARGS, m, n) PVPROTO (ARGS) ATTRIBUTE_PRINTF(m, n)\n-\n-#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n-#define PRINTF_PROTO_2(ARGS) PRINTF_PROTO(ARGS, 2, 3)\n-#define PRINTF_PROTO_3(ARGS) PRINTF_PROTO(ARGS, 3, 4)\n-#define PRINTF_PROTO_4(ARGS) PRINTF_PROTO(ARGS, 4, 5)\n-\n #include \"system.h\"\n #include <signal.h>\n \n@@ -37,6 +30,7 @@ Boston, MA 02111-1307, USA. */\n typedef unsigned char U_CHAR;\n \n #include \"pcp.h\"\n+#include \"intl.h\"\n #include \"prefix.h\"\n \n #ifdef MULTIBYTE_CHARS\n@@ -851,8 +845,6 @@ U_CHAR is_idstart[256];\n static U_CHAR is_hor_space[256];\n /* table to tell if c is horizontal or vertical space.  */\n U_CHAR is_space[256];\n-/* names of some characters */\n-static char *char_name[256];\n \n #define SKIP_WHITE_SPACE(p) do { while (is_hor_space[*p]) p++; } while (0)\n #define SKIP_ALL_WHITE_SPACE(p) do { while (is_space[*p]) p++; } while (0)\n@@ -949,7 +941,7 @@ static void pass_thru_directive PROTO((U_CHAR *, U_CHAR *, FILE_BUF *, struct di\n \n static MACRODEF create_definition PROTO((U_CHAR *, U_CHAR *, FILE_BUF *));\n \n-static int check_macro_name PROTO((U_CHAR *, char *));\n+static int check_macro_name PROTO((U_CHAR *, int));\n static int compare_defs PROTO((DEFINITION *, DEFINITION *));\n static int comp_def_part PROTO((int, U_CHAR *, int, U_CHAR *, int, int));\n \n@@ -984,7 +976,7 @@ static void output_line_directive PROTO((FILE_BUF *, FILE_BUF *, int, enum file_\n static void macroexpand PROTO((HASHNODE *, FILE_BUF *));\n \n struct argdata;\n-static char *macarg PROTO((struct argdata *, int));\n+static int macarg PROTO((struct argdata *, int));\n \n static U_CHAR *macarg1 PROTO((U_CHAR *, U_CHAR *, struct hashnode *, int *, int *, int *, int));\n \n@@ -993,18 +985,21 @@ static int discard_comments PROTO((U_CHAR *, int, int));\n static int change_newlines PROTO((U_CHAR *, int));\n \n static char *my_strerror PROTO((int));\n-void error PRINTF_PROTO_1((char *, ...));\n-static void verror PROTO((char *, va_list));\n+static void notice VPROTO((char *, ...));\n+static void vnotice PROTO((char *, va_list));\n+void error VPROTO((char *, ...));\n+void verror PROTO((char *, va_list));\n static void error_from_errno PROTO((char *));\n-void warning PRINTF_PROTO_1((char *, ...));\n+void warning VPROTO((char *, ...));\n static void vwarning PROTO((char *, va_list));\n-static void error_with_line PRINTF_PROTO_2((int, char *, ...));\n+static void error_with_line VPROTO((int, char *, ...));\n static void verror_with_line PROTO((int, char *, va_list));\n static void vwarning_with_line PROTO((int, char *, va_list));\n-static void warning_with_line PRINTF_PROTO_2((int, char *, ...));\n-void pedwarn PRINTF_PROTO_1((char *, ...));\n-void pedwarn_with_line PRINTF_PROTO_2((int, char *, ...));\n-static void pedwarn_with_file_and_line PRINTF_PROTO_4((char *, size_t, int, char *, ...));\n+static void warning_with_line VPROTO((int, char *, ...));\n+void pedwarn VPROTO((char *, ...));\n+void pedwarn_with_line VPROTO((int, char *, ...));\n+static void pedwarn_with_file_and_line VPROTO((char *, size_t, int, char *, ...));\n+static void pedwarn_strange_white_space PROTO((int));\n \n static void print_containing_files PROTO((void));\n \n@@ -1035,7 +1030,7 @@ static void append_include_chain PROTO((struct file_name_list *, struct file_nam\n static int quote_string_for_make PROTO((char *, char *));\n static void deps_output PROTO((char *, int));\n \n-static void fatal PRINTF_PROTO_1((char *, ...)) __attribute__ ((noreturn));\n+static void fatal VPROTO((char *, ...)) __attribute__ ((noreturn));\n void fancy_abort PROTO((void)) __attribute__ ((noreturn));\n static void perror_with_name PROTO((char *));\n static void pfatal_with_name PROTO((char *)) __attribute__ ((noreturn));\n@@ -1222,16 +1217,17 @@ main (argc, argv)\n   char *cp;\n   int f, i;\n   FILE_BUF *fp;\n-  char **pend_files = (char **) xmalloc (argc * sizeof (char *));\n-  char **pend_defs = (char **) xmalloc (argc * sizeof (char *));\n-  char **pend_undefs = (char **) xmalloc (argc * sizeof (char *));\n-  char **pend_assertions = (char **) xmalloc (argc * sizeof (char *));\n-  char **pend_includes = (char **) xmalloc (argc * sizeof (char *));\n+\n+  char **pend_files;\n+  char **pend_defs;\n+  char **pend_undefs;\n+  char **pend_assertions;\n+  char **pend_includes;\n \n   /* Record the option used with each element of pend_assertions.\n      This is preparation for supporting more than one option for making\n      an assertion.  */\n-  char **pend_assertion_options = (char **) xmalloc (argc * sizeof (char *));\n+  char **pend_assertion_options;\n   int inhibit_predefs = 0;\n   int no_standard_includes = 0;\n   int no_standard_cplusplus_includes = 0;\n@@ -1269,6 +1265,10 @@ main (argc, argv)\n   signal (SIGPIPE, pipe_closed);\n #endif\n \n+  setlocale (LC_MESSAGES, \"\");\n+  bindtextdomain (PACKAGE, localedir);\n+  textdomain (PACKAGE);\n+\n   progname = base_name (argv[0]);\n \n #ifdef VMS\n@@ -1287,6 +1287,16 @@ main (argc, argv)\n   }\n #endif\n \n+  /* Do not invoke xmalloc before this point, since locale and\n+     progname need to be set first, in case a diagnostic is issued.  */\n+     \n+  pend_files = (char **) xmalloc (argc * sizeof (char *));\n+  pend_defs = (char **) xmalloc (argc * sizeof (char *));\n+  pend_undefs = (char **) xmalloc (argc * sizeof (char *));\n+  pend_assertions = (char **) xmalloc (argc * sizeof (char *));\n+  pend_includes = (char **) xmalloc (argc * sizeof (char *));\n+  pend_assertion_options = (char **) xmalloc (argc * sizeof (char *));\n+\n   in_fname = NULL;\n   out_fname = NULL;\n \n@@ -1627,7 +1637,7 @@ main (argc, argv)\n \tbreak;\n \n       case 'v':\n-\tfprintf (stderr, \"GNU CPP version %s\", version_string);\n+\tnotice (\"GNU CPP version %s\", version_string);\n #ifdef TARGET_VERSION\n \tTARGET_VERSION;\n #endif\n@@ -2054,10 +2064,10 @@ main (argc, argv)\n   /* With -v, print the list of dirs to search.  */\n   if (verbose) {\n     struct file_name_list *p;\n-    fprintf (stderr, \"#include \\\"...\\\" search starts here:\\n\");\n+    notice (\"#include \\\"...\\\" search starts here:\\n\");\n     for (p = include; p; p = p->next) {\n       if (p == first_bracket_include)\n-\tfprintf (stderr, \"#include <...> search starts here:\\n\");\n+\tnotice (\"#include <...> search starts here:\\n\");\n       if (!p->fname[0])\n \tfprintf (stderr, \" .\\n\");\n       else if (!strcmp (p->fname, \"/\") || !strcmp (p->fname, \"//\"))\n@@ -2066,7 +2076,7 @@ main (argc, argv)\n \t/* Omit trailing '/'.  */\n \tfprintf (stderr, \" %.*s\\n\", (int) strlen (p->fname) - 1, p->fname);\n     }\n-    fprintf (stderr, \"End of search list.\\n\");\n+    notice (\"End of search list.\\n\");\n   }\n \n   /* -MG doesn't select the form of output and must be specified with one of\n@@ -3810,7 +3820,7 @@ handle_directive (ip, op)\n   while (1) {\n     if (is_hor_space[*bp]) {\n       if (*bp != ' ' && *bp != '\\t' && pedantic)\n-\tpedwarn (\"%s in preprocessing directive\", char_name[*bp]);\n+\tpedwarn_strange_white_space (*bp);\n       bp++;\n     } else if (*bp == '/') {\n       if (bp[1] == '\\\\' && bp[2] == '\\n')\n@@ -4013,7 +4023,7 @@ handle_directive (ip, op)\n \tcase '\\r':\n \tcase '\\v':\n \t  if (pedantic)\n-\t    pedwarn (\"%s in preprocessing directive\", char_name[c]);\n+\t    pedwarn_strange_white_space (c);\n \t  break;\n \n \tcase '\\n':\n@@ -4033,7 +4043,8 @@ handle_directive (ip, op)\n       /* If a directive should be copied through, and -C was given,\n \t pass it through before removing comments.  */\n       if (!no_output && put_out_comments\n-\t  && (kt->type == T_DEFINE ? dump_macros == dump_definitions\n+\t  && ((kt->type == T_DEFINE || kt->type == T_UNDEF)\n+\t      ? dump_macros == dump_definitions\n \t      : IS_INCLUDE_DIRECTIVE_TYPE (kt->type) ? dump_includes\n \t      : kt->type == T_PRAGMA)) {\n         int len;\n@@ -4454,16 +4465,18 @@ do_include (buf, limit, op, keyword)\n       && !instack[indepth].system_header_p && !import_warning) {\n     import_warning = 1;\n     warning (\"using `#import' is not recommended\");\n-    fprintf (stderr, \"The fact that a certain header file need not be processed more than once\\n\");\n-    fprintf (stderr, \"should be indicated in the header file, not where it is used.\\n\");\n-    fprintf (stderr, \"The best way to do this is with a conditional of this form:\\n\\n\");\n-    fprintf (stderr, \"  #ifndef _FOO_H_INCLUDED\\n\");\n-    fprintf (stderr, \"  #define _FOO_H_INCLUDED\\n\");\n-    fprintf (stderr, \"  ... <real contents of file> ...\\n\");\n-    fprintf (stderr, \"  #endif /* Not _FOO_H_INCLUDED */\\n\\n\");\n-    fprintf (stderr, \"Then users can use `#include' any number of times.\\n\");\n-    fprintf (stderr, \"GNU C automatically avoids processing the file more than once\\n\");\n-    fprintf (stderr, \"when it is equipped with such a conditional.\\n\");\n+    notice (\"The fact that a certain header file need not be processed more than once\\n\\\n+should be indicated in the header file, not where it is used.\\n\\\n+The best way to do this is with a conditional of this form:\\n\\\n+\\n\\\n+  #ifndef _FOO_H_INCLUDED\\n\\\n+  #define _FOO_H_INCLUDED\\n\\\n+  ... <real contents of file> ...\\n\\\n+  #endif /* Not _FOO_H_INCLUDED */\\n\\\n+\\n\\\n+Then users can use `#include' any number of times.\\n\\\n+GNU C automatically avoids processing the file more than once\\n\\\n+when it is equipped with such a conditional.\\n\");\n   }\n \n get_filename:\n@@ -5794,7 +5807,7 @@ create_definition (buf, limit, op)\n     bp++;\n \n   symname = bp;\t\t\t/* remember where it starts */\n-  sym_length = check_macro_name (bp, \"macro\");\n+  sym_length = check_macro_name (bp, 0);\n   bp += sym_length;\n \n   /* Lossage will occur if identifiers or control keywords are broken\n@@ -6045,12 +6058,12 @@ do_define (buf, limit, op, keyword)\n }\n \f\n /* Check a purported macro name SYMNAME, and yield its length.\n-   USAGE is the kind of name this is intended for.  */\n+   ASSERTION is nonzero if this is really for an assertion name.  */\n \n static int\n-check_macro_name (symname, usage)\n+check_macro_name (symname, assertion)\n      U_CHAR *symname;\n-     char *usage;\n+     int assertion;\n {\n   U_CHAR *p;\n   int sym_length;\n@@ -6060,10 +6073,13 @@ check_macro_name (symname, usage)\n   sym_length = p - symname;\n   if (sym_length == 0\n       || (sym_length == 1 && *symname == 'L' && (*p == '\\'' || *p == '\"')))\n-    error (\"invalid %s name\", usage);\n+    error (assertion ? \"invalid assertion name\" : \"invalid macro name\");\n   else if (!is_idstart[*symname]\n \t   || (sym_length == 7 && ! bcmp (symname, \"defined\", 7)))\n-    error (\"invalid %s name `%.*s'\", usage, sym_length, symname);\n+    error ((assertion\n+\t    ? \"invalid assertion name `%.*s'\"\n+\t    : \"invalid macro name `%.*s'\"),\n+\t   sym_length, symname);\n   return sym_length;\n }\n \n@@ -6489,7 +6505,7 @@ do_assert (buf, limit, op, keyword)\n     bp++;\n \n   symname = bp;\t\t\t/* remember where it starts */\n-  sym_length = check_macro_name (bp, \"assertion\");\n+  sym_length = check_macro_name (bp, 1);\n   bp += sym_length;\n   /* #define doesn't do this, but we should.  */\n   SKIP_WHITE_SPACE (bp);\n@@ -6568,7 +6584,7 @@ do_unassert (buf, limit, op, keyword)\n     bp++;\n \n   symname = bp;\t\t\t/* remember where it starts */\n-  sym_length = check_macro_name (bp, \"assertion\");\n+  sym_length = check_macro_name (bp, 1);\n   bp += sym_length;\n   /* #define doesn't do this, but we should.  */\n   SKIP_WHITE_SPACE (bp);\n@@ -7043,7 +7059,7 @@ do_undef (buf, limit, op, keyword)\n     pass_thru_directive (buf, limit, op, keyword);\n \n   SKIP_WHITE_SPACE (buf);\n-  sym_length = check_macro_name (buf, \"macro\");\n+  sym_length = check_macro_name (buf, 0);\n \n   while ((hp = lookup (buf, sym_length, -1)) != NULL) {\n     /* If we are generating additional info for debugging (with -g) we\n@@ -8441,7 +8457,7 @@ macroexpand (hp, op)\n   if (nargs >= 0) {\n     register int i;\n     struct argdata *args;\n-    char *parse_error = 0;\n+    int parse_error = 0;\n \n     args = (struct argdata *) alloca ((nargs + 1) * sizeof (struct argdata));\n \n@@ -8475,7 +8491,8 @@ macroexpand (hp, op)\n       else\n \tparse_error = macarg (NULL_PTR, 0);\n       if (parse_error) {\n-\terror_with_line (line_for_error (start_line), parse_error);\n+\terror_with_line (line_for_error (start_line),\n+\t\t\t \"unterminated macro call\");\n \tbreak;\n       }\n       i++;\n@@ -8820,7 +8837,7 @@ macroexpand (hp, op)\n    REST_ARGS is passed to macarg1 to make it absorb the rest of the args.\n    Return nonzero to indicate a syntax error.  */\n \n-static char *\n+static int\n macarg (argptr, rest_args)\n      register struct argdata *argptr;\n      int rest_args;\n@@ -8829,7 +8846,7 @@ macarg (argptr, rest_args)\n   int paren = 0;\n   int newlines = 0;\n   int comments = 0;\n-  char *result = 0;\n+  int result = 0;\n \n   /* Try to parse as much of the argument as exists at this\n      input stack level.  */\n@@ -8862,7 +8879,7 @@ macarg (argptr, rest_args)\n \n     while (bp == ip->buf + ip->length) {\n       if (instack[indepth].macro == 0) {\n-\tresult = \"unterminated macro call\";\n+\tresult = 1;\n \tbreak;\n       }\n       ip->macro->type = T_MACRO;\n@@ -9344,34 +9361,62 @@ my_strerror (errnum)\n #endif\n \n   if (!result)\n-    result = \"undocumented I/O error\";\n+    result = \"errno = ?\";\n \n   return result;\n }\n \n+/* notice - output message to stderr */\n+\n+static void\n+notice VPROTO ((char * msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  char * msgid;\n+#endif\n+  va_list args;\n+\n+  VA_START (args, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (args, char *);\n+#endif\n+ \n+  vnotice (msgid, args);\n+  va_end (args);\n+}\n+\n+static void\n+vnotice (msgid, args)\n+     char *msgid;\n+     va_list args;\n+{\n+  vfprintf (stderr, _(msgid), args);\n+}\n+\n /* error - print error message and increment count of errors.  */\n \n void\n-error VPROTO ((char * msg, ...))\n+error VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n+  VA_START (args, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n-\n-  verror (msg, args);\n+ \n+  verror (msgid, args);\n   va_end (args);\n }\n \n-static void\n-verror (msg, args)\n-     char *msg;\n+void\n+verror (msgid, args)\n+     char *msgid;\n      va_list args;\n {\n   int i;\n@@ -9389,7 +9434,7 @@ verror (msg, args)\n     eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n     fprintf (stderr, \":%d: \", ip->lineno);\n   }\n-  vfprintf (stderr, msg, args);\n+  vnotice (msgid, args);\n   fprintf (stderr, \"\\n\");\n   errors++;\n }\n@@ -9425,26 +9470,26 @@ error_from_errno (name)\n /* Print error message but don't count it.  */\n \n void\n-warning VPROTO ((char * msg, ...))\n+warning VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n+  VA_START (args, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n \n-  vwarning (msg, args);\n+  vwarning (msgid, args);\n   va_end (args);\n }\n \n static void\n-vwarning (msg, args)\n-     char *msg;\n+vwarning (msgid, args)\n+     char *msgid;\n      va_list args;\n {\n   int i;\n@@ -9468,35 +9513,36 @@ vwarning (msg, args)\n     eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n     fprintf (stderr, \":%d: \", ip->lineno);\n   }\n-  fprintf (stderr, \"warning: \");\n-  vfprintf (stderr, msg, args);\n+  notice (\"warning: \");\n+  vnotice (msgid, args);\n   fprintf (stderr, \"\\n\");\n }\n \n static void\n-error_with_line VPROTO ((int line, char * msg, ...))\n+error_with_line VPROTO ((int line, char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   int line;\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n+  VA_START (args, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   line = va_arg (args, int);\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n \n-  verror_with_line (line, msg, args);\n+  verror_with_line (line, msgid, args);\n   va_end (args);\n }\n \n+\n static void\n-verror_with_line (line, msg, args)\n+verror_with_line (line, msgid, args)\n      int line;\n-     char *msg;\n+     char *msgid;\n      va_list args;\n {\n   int i;\n@@ -9514,35 +9560,35 @@ verror_with_line (line, msg, args)\n     eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n     fprintf (stderr, \":%d: \", line);\n   }\n-  vfprintf (stderr, msg, args);\n+  vnotice (msgid, args);\n   fprintf (stderr, \"\\n\");\n   errors++;\n }\n \n static void\n-warning_with_line VPROTO ((int line, char * msg, ...))\n+warning_with_line VPROTO ((int line, char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   int line;\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n+  VA_START (args, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   line = va_arg (args, int);\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n \n-  vwarning_with_line (line, msg, args);\n+  vwarning_with_line (line, msgid, args);\n   va_end (args);\n }\n \n static void\n-vwarning_with_line (line, msg, args)\n+vwarning_with_line (line, msgid, args)\n      int line;\n-     char *msg;\n+     char *msgid;\n      va_list args;\n {\n   int i;\n@@ -9566,54 +9612,54 @@ vwarning_with_line (line, msg, args)\n     eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n     fprintf (stderr, line ? \":%d: \" : \": \", line);\n   }\n-  fprintf (stderr, \"warning: \");\n-  vfprintf (stderr, msg, args);\n+  notice (\"warning: \");\n+  vnotice (msgid, args);\n   fprintf (stderr, \"\\n\");\n }\n \n /* Print an error message and maybe count it.  */\n \n void\n-pedwarn VPROTO ((char * msg, ...))\n+pedwarn VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   if (pedantic_errors)\n-    verror (msg, args);\n+    verror (msgid, args);\n   else\n-    vwarning (msg, args);\n+    vwarning (msgid, args);\n   va_end (args);\n }\n \n void\n-pedwarn_with_line VPROTO ((int line, char * msg, ...))\n+pedwarn_with_line VPROTO ((int line, char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   int line;\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n   line = va_arg (args, int);\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   if (pedantic_errors)\n-    verror_with_line (line, msg, args);\n+    verror_with_line (line, msgid, args);\n   else\n-    vwarning_with_line (line, msg, args);\n+    vwarning_with_line (line, msgid, args);\n   va_end (args);\n }\n \n@@ -9622,7 +9668,7 @@ pedwarn_with_line VPROTO ((int line, char * msg, ...))\n \n static void\n pedwarn_with_file_and_line VPROTO ((char *file, size_t file_len, int line,\n-\t\t\t\t    char * msg, ...))\n+\t\t\t\t    char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   char *file;\n@@ -9635,13 +9681,13 @@ pedwarn_with_file_and_line VPROTO ((char *file, size_t file_len, int line,\n   if (!pedantic_errors && inhibit_warnings)\n     return;\n \n-  VA_START (args, msg);\n+  VA_START (args, msgid);\n  \n #ifndef ANSI_PROTOTYPES\n   file = va_arg (args, char *);\n   file_len = va_arg (args, size_t);\n   line = va_arg (args, int);\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n  \n   if (file) {\n@@ -9651,12 +9697,24 @@ pedwarn_with_file_and_line VPROTO ((char *file, size_t file_len, int line,\n   if (pedantic_errors)\n     errors++;\n   if (!pedantic_errors)\n-    fprintf (stderr, \"warning: \");\n-\n-  vfprintf (stderr, msg, args);\n+    notice (\"warning: \");\n+  vnotice (msgid, args);\n   va_end (args);\n   fprintf (stderr, \"\\n\");\n }\n+\n+static void\n+pedwarn_strange_white_space (ch)\n+     int ch;\n+{\n+  switch (ch)\n+    {\n+    case '\\f': pedwarn (\"formfeed in preprocessing directive\"); break;\n+    case '\\r': pedwarn (\"carriage return in preprocessing directive\"); break;\n+    case '\\v': pedwarn (\"vertical tab in preprocessing directive\"); break;\n+    default: abort ();\n+    }\n+}\n \f\n /* Print the file names and line numbers of the #include\n    directives which led to the current file.  */\n@@ -9689,12 +9747,11 @@ print_containing_files ()\n       ip = &instack[i];\n       if (first) {\n \tfirst = 0;\n-\tfprintf (stderr, \"In file included\");\n+\tnotice (   \"In file included from \");\n       } else {\n-\tfprintf (stderr, \",\\n                \");\n+\tnotice (\",\\n                 from \");\n       }\n \n-      fprintf (stderr, \" from \");\n       eprint_string (ip->nominal_fname, ip->nominal_fname_len);\n       fprintf (stderr, \":%d\", ip->lineno);\n     }\n@@ -10132,10 +10189,6 @@ initialize_char_syntax ()\n   is_space['\\f'] = 1;\n   is_space['\\n'] = 1;\n   is_space['\\r'] = 1;\n-\n-  char_name['\\v'] = \"vertical tab\";\n-  char_name['\\f'] = \"formfeed\";\n-  char_name['\\r'] = \"carriage return\";\n }\n \n /* Initialize the built-in macros.  */\n@@ -10663,21 +10716,20 @@ deps_output (string, spacer)\n }\n \f\n static void\n-fatal VPROTO ((char * msg, ...))\n+fatal VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n   fprintf (stderr, \"%s: \", progname);\n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n-  vfprintf (stderr, msg, args);\n+  vnotice (msgid, args);\n   va_end (args);\n   fprintf (stderr, \"\\n\");\n   exit (FATAL_EXIT_CODE);"}, {"sha": "c19ab24b93a5ad70a69bb21a276831eb59ebdd39", "filename": "gcc/cexp.c", "status": "modified", "additions": 98, "deletions": 95, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -23,10 +23,6 @@\n \n #include \"config.h\"\n \n-#define PRINTF_PROTO(ARGS, m, n) PVPROTO (ARGS) ATTRIBUTE_PRINTF(m, n)\n-\n-#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n-\n #include \"system.h\"\n #include <setjmp.h>\n /* #define YYDEBUG 1 */\n@@ -82,7 +78,7 @@ struct arglist {\n HOST_WIDE_INT parse_c_expression PROTO((char *, int));\n \n static int yylex PROTO((void));\n-static void yyerror PROTO((char *)) __attribute__ ((noreturn));\n+static void yyerror PRINTF_PROTO_1((char *, ...)) __attribute__ ((noreturn));\n static HOST_WIDE_INT expression_value;\n #ifdef TEST_EXP_READER\n static int expression_signedp;\n@@ -180,7 +176,7 @@ static void integer_overflow PROTO((void));\n #define SIGNED (~0)\n #define UNSIGNED 0\n \n-#line 188 \"cexp.y\"\n+#line 184 \"cexp.y\"\n typedef union {\n   struct constant {HOST_WIDE_INT value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n@@ -261,10 +257,10 @@ static const short yyrhs[] = {    35,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   218,   228,   229,   236,   241,   244,   246,   249,   253,   255,\n-   260,   265,   278,   295,   308,   314,   320,   326,   332,   335,\n-   338,   345,   352,   359,   366,   369,   372,   375,   378,   381,\n-   384,   387,   389,   392,   395,   397,   399,   407,   409,   422\n+   214,   224,   225,   232,   237,   240,   242,   245,   249,   251,\n+   256,   261,   274,   291,   304,   310,   316,   322,   328,   331,\n+   334,   341,   348,   355,   362,   365,   368,   371,   374,   377,\n+   380,   383,   385,   388,   391,   393,   395,   403,   405,   418\n };\n #endif\n \n@@ -370,7 +366,7 @@ static const short yycheck[] = {     4,\n     26,    27,    23,    24,    25,    26,    27,     0,     9\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -387,8 +383,7 @@ static const short yycheck[] = {     4,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n@@ -564,7 +559,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 196 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -869,7 +864,7 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 219 \"cexp.y\"\n+#line 215 \"cexp.y\"\n {\n \t\t  expression_value = yyvsp[0].integer.value;\n #ifdef TEST_EXP_READER\n@@ -878,55 +873,55 @@ case 1:\n \t\t;\n     break;}\n case 3:\n-#line 230 \"cexp.y\"\n+#line 226 \"cexp.y\"\n { if (pedantic)\n \t\t\t    pedwarn (\"comma operator in operand of `#if'\");\n \t\t\t  yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 4:\n-#line 237 \"cexp.y\"\n+#line 233 \"cexp.y\"\n { yyval.integer.value = - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp;\n \t\t\t  if ((yyval.integer.value & yyvsp[0].integer.value & yyval.integer.signedp) < 0)\n \t\t\t    integer_overflow (); ;\n     break;}\n case 5:\n-#line 242 \"cexp.y\"\n+#line 238 \"cexp.y\"\n { yyval.integer.value = ! yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 6:\n-#line 245 \"cexp.y\"\n+#line 241 \"cexp.y\"\n { yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 7:\n-#line 247 \"cexp.y\"\n+#line 243 \"cexp.y\"\n { yyval.integer.value = ~ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp; ;\n     break;}\n case 8:\n-#line 250 \"cexp.y\"\n+#line 246 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[0].name.address, yyvsp[0].name.length,\n \t\t\t\t\t\t      0, NULL_PTR);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 9:\n-#line 254 \"cexp.y\"\n+#line 250 \"cexp.y\"\n { keyword_parsing = 1; ;\n     break;}\n case 10:\n-#line 256 \"cexp.y\"\n+#line 252 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[-4].name.address, yyvsp[-4].name.length,\n \t\t\t\t\t\t      1, yyvsp[-1].keywords);\n \t\t\t  keyword_parsing = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 11:\n-#line 261 \"cexp.y\"\n+#line 257 \"cexp.y\"\n { yyval.integer = yyvsp[-1].integer; ;\n     break;}\n case 12:\n-#line 266 \"cexp.y\"\n+#line 262 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (yyval.integer.signedp)\n \t\t\t    {\n@@ -941,7 +936,7 @@ case 12:\n \t\t\t\t\t* yyvsp[0].integer.value); ;\n     break;}\n case 13:\n-#line 279 \"cexp.y\"\n+#line 275 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -960,7 +955,7 @@ case 13:\n \t\t\t\t\t/ yyvsp[0].integer.value); ;\n     break;}\n case 14:\n-#line 296 \"cexp.y\"\n+#line 292 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -975,49 +970,49 @@ case 14:\n \t\t\t\t\t% yyvsp[0].integer.value); ;\n     break;}\n case 15:\n-#line 309 \"cexp.y\"\n+#line 305 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value + yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyvsp[-2].integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyval.integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 16:\n-#line 315 \"cexp.y\"\n+#line 311 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyval.integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyvsp[-2].integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 17:\n-#line 321 \"cexp.y\"\n+#line 317 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 18:\n-#line 327 \"cexp.y\"\n+#line 323 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 19:\n-#line 333 \"cexp.y\"\n+#line 329 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value == yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 20:\n-#line 336 \"cexp.y\"\n+#line 332 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value != yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 21:\n-#line 339 \"cexp.y\"\n+#line 335 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value <= yyvsp[0].integer.value;\n@@ -1026,7 +1021,7 @@ case 21:\n \t\t\t\t\t<= yyvsp[0].integer.value); ;\n     break;}\n case 22:\n-#line 346 \"cexp.y\"\n+#line 342 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value >= yyvsp[0].integer.value;\n@@ -1035,7 +1030,7 @@ case 22:\n \t\t\t\t\t>= yyvsp[0].integer.value); ;\n     break;}\n case 23:\n-#line 353 \"cexp.y\"\n+#line 349 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value < yyvsp[0].integer.value;\n@@ -1044,7 +1039,7 @@ case 23:\n \t\t\t\t\t< yyvsp[0].integer.value); ;\n     break;}\n case 24:\n-#line 360 \"cexp.y\"\n+#line 356 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value > yyvsp[0].integer.value;\n@@ -1053,76 +1048,76 @@ case 24:\n \t\t\t\t\t> yyvsp[0].integer.value); ;\n     break;}\n case 25:\n-#line 367 \"cexp.y\"\n+#line 363 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value & yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 26:\n-#line 370 \"cexp.y\"\n+#line 366 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value ^ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 27:\n-#line 373 \"cexp.y\"\n+#line 369 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value | yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 28:\n-#line 376 \"cexp.y\"\n+#line 372 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 29:\n-#line 378 \"cexp.y\"\n+#line 374 \"cexp.y\"\n { skip_evaluation -= !yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value && yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 30:\n-#line 382 \"cexp.y\"\n+#line 378 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-1].integer.value; ;\n     break;}\n case 31:\n-#line 384 \"cexp.y\"\n+#line 380 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value || yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 32:\n-#line 388 \"cexp.y\"\n+#line 384 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 33:\n-#line 390 \"cexp.y\"\n+#line 386 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-4].integer.value - !yyvsp[-4].integer.value; ;\n     break;}\n case 34:\n-#line 392 \"cexp.y\"\n+#line 388 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-6].integer.value;\n \t\t\t  yyval.integer.value = yyvsp[-6].integer.value ? yyvsp[-3].integer.value : yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-3].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 35:\n-#line 396 \"cexp.y\"\n+#line 392 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 36:\n-#line 398 \"cexp.y\"\n+#line 394 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 37:\n-#line 400 \"cexp.y\"\n+#line 396 \"cexp.y\"\n { if (warn_undef && !skip_evaluation)\n \t\t\t    warning (\"`%.*s' is not defined\",\n \t\t\t\t     yyvsp[0].name.length, yyvsp[0].name.address);\n \t\t\t  yyval.integer.value = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 38:\n-#line 408 \"cexp.y\"\n+#line 404 \"cexp.y\"\n { yyval.keywords = 0; ;\n     break;}\n case 39:\n-#line 410 \"cexp.y\"\n+#line 406 \"cexp.y\"\n { struct arglist *temp;\n \t\t\t  yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->next = yyvsp[-2].keywords;\n@@ -1137,15 +1132,15 @@ case 39:\n \t\t\t  temp->next->length = 1; ;\n     break;}\n case 40:\n-#line 423 \"cexp.y\"\n+#line 419 \"cexp.y\"\n { yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->name = yyvsp[-1].name.address;\n \t\t\t  yyval.keywords->length = yyvsp[-1].name.length;\n \t\t\t  yyval.keywords->next = yyvsp[0].keywords; ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n+#line 498 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -1341,7 +1336,7 @@ case 40:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 428 \"cexp.y\"\n+#line 424 \"cexp.y\"\n \n \f\n /* During parsing of a C expression, the pointer to the next character\n@@ -1408,12 +1403,9 @@ parse_number (olen)\n \telse {\n \t  if (c == '.' || c == 'e' || c == 'E' || c == 'p' || c == 'P')\n \t    yyerror (\"Floating point numbers not allowed in #if expressions\");\n-\t  else {\n-\t    char *buf = (char *) alloca (p - lexptr + 40);\n-\t    sprintf (buf, \"missing white space after number `%.*s'\",\n+\t  else\n+\t    yyerror (\"missing white space after number `%.*s'\",\n \t\t     (int) (p - lexptr - 1), lexptr);\n-\t    yyerror (buf);\n-\t  }\n \t}\n \n \tif (--len == 0)\n@@ -1490,11 +1482,7 @@ yylex ()\n       if (c == *toktab->operator && tokstart[1] == toktab->operator[1]) {\n \tlexptr += 2;\n \tif (toktab->token == ERROR)\n-\t  {\n-\t    char *buf = (char *) alloca (40);\n-\t    sprintf (buf, \"`%s' not allowed in operand of `#if'\", toktab->operator);\n-\t    yyerror (buf);\n-\t  }\n+\t  yyerror (\"`%s' not allowed in operand of `#if'\", toktab->operator);\n \treturn toktab->token;\n       }\n \n@@ -1893,15 +1881,6 @@ parse_escape (string_ptr, result_mask)\n     }\n }\n \n-static void\n-yyerror (s)\n-     char *s;\n-{\n-  error (\"%s\", s);\n-  skip_evaluation = 0;\n-  longjmp (parse_return_error, 1);\n-}\n-\n static void\n integer_overflow ()\n {\n@@ -1968,6 +1947,29 @@ parse_c_expression (string, warn_undefined)\n \n   return expression_value;\t/* set by yyparse () */\n }\n+\n+static void\n+yyerror VPROTO ((char * msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  char * msgid;\n+#endif\n+  va_list args;\n+\n+  VA_START (args, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (args, char *);\n+#endif\n+\n+  fprintf (stderr, \"error: \");\n+  vfprintf (stderr, _(msgid), args);\n+  fprintf (stderr, \"\\n\");\n+  va_end (args);\n+  skip_evaluation = 0;\n+  longjmp (parse_return_error, 1);\n+}\n+\n \f\n #ifdef TEST_EXP_READER\n \n@@ -2078,65 +2080,66 @@ initialize_random_junk ()\n }\n \n void\n-error VPROTO ((char * msg, ...))\n+error VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   fprintf (stderr, \"error: \");\n-  vfprintf (stderr, msg, args);\n+  vfprintf (stderr, _(msgid), args);\n   fprintf (stderr, \"\\n\");\n   va_end (args);\n }\n \n void\n-pedwarn VPROTO ((char * msg, ...))\n+pedwarn VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   fprintf (stderr, \"pedwarn: \");\n-  vfprintf (stderr, msg, args);\n+  vfprintf (stderr, _(msgid), args);\n   fprintf (stderr, \"\\n\");\n   va_end (args);\n }\n \n void\n-warning VPROTO ((char * msg, ...))\n+warning VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   fprintf (stderr, \"warning: \");\n-  vfprintf (stderr, msg, args);\n+  vfprintf (stderr, _(msgid), args);\n   fprintf (stderr, \"\\n\");\n   va_end (args);\n }\n \n+\n int\n check_assertion (name, sym_length, tokens_specified, tokens)\n      U_CHAR *name;"}, {"sha": "a94dcf8fddd042a62bf9d57c9d87fec3a5ded84d", "filename": "gcc/cexp.y", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n /* Parse C expressions for CCCP.\n-   Copyright (C) 1987, 1992, 94 - 97, 1998 Free Software Foundation.\n+   Copyright (C) 1987, 92, 94, 95, 96, 97, 1998 Free Software Foundation.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -27,10 +27,6 @@ Boston, MA 02111-1307, USA.\n %{\n #include \"config.h\"\n \n-#define PRINTF_PROTO(ARGS, m, n) PVPROTO (ARGS) ATTRIBUTE_PRINTF(m, n)\n-\n-#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n-\n #include \"system.h\"\n #include <setjmp.h>\n /* #define YYDEBUG 1 */\n@@ -86,7 +82,7 @@ struct arglist {\n HOST_WIDE_INT parse_c_expression PROTO((char *, int));\n \n static int yylex PROTO((void));\n-static void yyerror PROTO((char *)) __attribute__ ((noreturn));\n+static void yyerror PRINTF_PROTO_1((char *, ...)) __attribute__ ((noreturn));\n static HOST_WIDE_INT expression_value;\n #ifdef TEST_EXP_READER\n static int expression_signedp;\n@@ -491,12 +487,9 @@ parse_number (olen)\n \telse {\n \t  if (c == '.' || c == 'e' || c == 'E' || c == 'p' || c == 'P')\n \t    yyerror (\"Floating point numbers not allowed in #if expressions\");\n-\t  else {\n-\t    char *buf = (char *) alloca (p - lexptr + 40);\n-\t    sprintf (buf, \"missing white space after number `%.*s'\",\n+\t  else\n+\t    yyerror (\"missing white space after number `%.*s'\",\n \t\t     (int) (p - lexptr - 1), lexptr);\n-\t    yyerror (buf);\n-\t  }\n \t}\n \n \tif (--len == 0)\n@@ -573,11 +566,7 @@ yylex ()\n       if (c == *toktab->operator && tokstart[1] == toktab->operator[1]) {\n \tlexptr += 2;\n \tif (toktab->token == ERROR)\n-\t  {\n-\t    char *buf = (char *) alloca (40);\n-\t    sprintf (buf, \"`%s' not allowed in operand of `#if'\", toktab->operator);\n-\t    yyerror (buf);\n-\t  }\n+\t  yyerror (\"`%s' not allowed in operand of `#if'\", toktab->operator);\n \treturn toktab->token;\n       }\n \n@@ -976,15 +965,6 @@ parse_escape (string_ptr, result_mask)\n     }\n }\n \n-static void\n-yyerror (s)\n-     char *s;\n-{\n-  error (\"%s\", s);\n-  skip_evaluation = 0;\n-  longjmp (parse_return_error, 1);\n-}\n-\n static void\n integer_overflow ()\n {\n@@ -1051,6 +1031,29 @@ parse_c_expression (string, warn_undefined)\n \n   return expression_value;\t/* set by yyparse () */\n }\n+\n+static void\n+yyerror VPROTO ((char * msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  char * msgid;\n+#endif\n+  va_list args;\n+\n+  VA_START (args, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (args, char *);\n+#endif\n+\n+  fprintf (stderr, \"error: \");\n+  vfprintf (stderr, _(msgid), args);\n+  fprintf (stderr, \"\\n\");\n+  va_end (args);\n+  skip_evaluation = 0;\n+  longjmp (parse_return_error, 1);\n+}\n+\n \f\n #ifdef TEST_EXP_READER\n \n@@ -1161,65 +1164,66 @@ initialize_random_junk ()\n }\n \n void\n-error VPROTO ((char * msg, ...))\n+error VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   fprintf (stderr, \"error: \");\n-  vfprintf (stderr, msg, args);\n+  vfprintf (stderr, _(msgid), args);\n   fprintf (stderr, \"\\n\");\n   va_end (args);\n }\n \n void\n-pedwarn VPROTO ((char * msg, ...))\n+pedwarn VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   fprintf (stderr, \"pedwarn: \");\n-  vfprintf (stderr, msg, args);\n+  vfprintf (stderr, _(msgid), args);\n   fprintf (stderr, \"\\n\");\n   va_end (args);\n }\n \n void\n-warning VPROTO ((char * msg, ...))\n+warning VPROTO ((char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char * msg;\n+  char * msgid;\n #endif\n   va_list args;\n \n-  VA_START (args, msg);\n- \n+  VA_START (args, msgid);\n+\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (args, char *);\n+  msgid = va_arg (args, char *);\n #endif\n- \n+\n   fprintf (stderr, \"warning: \");\n-  vfprintf (stderr, msg, args);\n+  vfprintf (stderr, _(msgid), args);\n   fprintf (stderr, \"\\n\");\n   va_end (args);\n }\n \n+\n int\n check_assertion (name, sym_length, tokens_specified, tokens)\n      U_CHAR *name;"}, {"sha": "b6407750f6fac90da05dbdbe6d4b354721f0a4a8", "filename": "gcc/collect2.c", "status": "modified", "additions": 111, "deletions": 89, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -47,6 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"collect2.h\"\n #include \"demangle.h\"\n #include \"obstack.h\"\n+#include \"intl.h\"\n #ifdef __CYGWIN__\n #include <process.h>\n #endif\n@@ -335,15 +336,13 @@ my_strerror (e)\n \n #else\n \n-  static char buffer[30];\n   if (!e)\n     return \"\";\n \n   if (e > 0 && e < sys_nerr)\n     return sys_errlist[e];\n \n-  sprintf (buffer, \"Unknown error %d\", e);\n-  return buffer;\n+  return \"errno = ?\";\n #endif\n }\n \n@@ -403,25 +402,44 @@ collect_exit (status)\n }\n \n \f\n+/* Notify user of a non-error.  */\n+void\n+notice VPROTO((char *msgid, ...))\n+{\n+#ifndef __STDC__\n+  char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef __STDC__\n+  msgid = va_arg (ap, char *);\n+#endif\n+\n+  vfprintf (stderr, _(msgid), ap);\n+  va_end (ap);\n+}\n+\n /* Die when sys call fails.  */\n \n void\n-fatal_perror VPROTO((const char * string, ...))\n+fatal_perror VPROTO((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  const char *string;\n+  const char *msgid;\n #endif\n   int e = errno;\n   va_list ap;\n \n-  VA_START (ap, string);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  string = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n   fprintf (stderr, \"collect2: \");\n-  vfprintf (stderr, string, ap);\n+  vfprintf (stderr, _(msgid), ap);\n   fprintf (stderr, \": %s\\n\", my_strerror (e));\n   va_end (ap);\n \n@@ -431,21 +449,21 @@ fatal_perror VPROTO((const char * string, ...))\n /* Just die.  */\n \n void\n-fatal VPROTO((const char * string, ...))\n+fatal VPROTO((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  const char *string;\n+  const char *msgid;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, string);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  string = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n   \n   fprintf (stderr, \"collect2: \");\n-  vfprintf (stderr, string, ap);\n+  vfprintf (stderr, _(msgid), ap);\n   fprintf (stderr, \"\\n\");\n   va_end (ap);\n \n@@ -455,21 +473,21 @@ fatal VPROTO((const char * string, ...))\n /* Write error message.  */\n \n void\n-error VPROTO((const char * string, ...))\n+error VPROTO((const char * msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char * string;\n #endif\n   va_list ap;\n  \n-  VA_START (ap, string);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n-  string = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n   fprintf (stderr, \"collect2: \");\n-  vfprintf (stderr, string, ap);\n+  vfprintf (stderr, _(msgid), ap);\n   fprintf (stderr, \"\\n\");\n   va_end(ap);\n }\n@@ -482,7 +500,6 @@ fancy_abort ()\n {\n   fatal (\"internal error\");\n }\n-\n \f\n static void\n handler (signo)\n@@ -976,15 +993,26 @@ main (argc, argv)\n   char *p;\n   char **c_argv;\n   char **c_ptr;\n-  char **ld1_argv\t= (char **) xcalloc (sizeof (char *), argc+3);\n-  char **ld1\t\t= ld1_argv;\n-  char **ld2_argv\t= (char **) xcalloc (sizeof (char *), argc+6);\n-  char **ld2\t\t= ld2_argv;\n-  char **object_lst\t= (char **) xcalloc (sizeof (char *), argc);\n-  char **object\t\t= object_lst;\n+  char **ld1_argv;\n+  char **ld1;\n+  char **ld2_argv;\n+  char **ld2;\n+  char **object_lst;\n+  char **object;\n   int first_file;\n   int num_c_args\t= argc+9;\n \n+  setlocale (LC_MESSAGES, \"\");\n+  bindtextdomain (PACKAGE, localedir);\n+  textdomain (PACKAGE);\n+\n+  /* Do not invoke xcalloc before this point, since locale needs to be\n+     set first, in case a diagnostic is issued.  */\n+\n+  ld1 = ld1_argv = (char **) xcalloc (sizeof (char *), argc+3);\n+  ld2 = ld2_argv = (char **) xcalloc (sizeof (char *), argc+6);\n+  object = object_lst = (char **) xcalloc (sizeof (char *), argc);\n+\n #ifdef DEBUG\n   debug = 1;\n #endif\n@@ -1402,16 +1430,16 @@ main (argc, argv)\n     *ld2++ = buf2;\n     exportf = fopen (export_file, \"w\");\n     if (exportf == (FILE *) 0)\n-      fatal_perror (\"%s\", export_file);\n+      fatal_perror (\"fopen %s\", export_file);\n     write_export_file (exportf);\n     if (fclose (exportf))\n-      fatal_perror (\"closing %s\", export_file);\n+      fatal_perror (\"fclose %s\", export_file);\n     importf = fopen (import_file, \"w\");\n     if (importf == (FILE *) 0)\n       fatal_perror (\"%s\", import_file);\n     write_import_file (importf);\n     if (fclose (importf))\n-      fatal_perror (\"closing %s\", import_file);\n+      fatal_perror (\"fclose %s\", import_file);\n   }\n #endif\n \n@@ -1420,7 +1448,7 @@ main (argc, argv)\n \n   if (vflag)\n     {\n-      fprintf (stderr, \"collect2 version %s\", version_string);\n+      notice (\"collect2 version %s\", version_string);\n #ifdef TARGET_VERSION\n       TARGET_VERSION;\n #endif\n@@ -1509,8 +1537,8 @@ main (argc, argv)\n \n   if (debug)\n     {\n-      fprintf (stderr, \"%d constructor(s) found\\n\", constructors.number);\n-      fprintf (stderr, \"%d destructor(s)  found\\n\", destructors.number);\n+      notice (\"%d constructor(s) found\\n\", constructors.number);\n+      notice (\"%d destructor(s)  found\\n\", destructors.number);\n     }\n \n   if (constructors.number == 0 && destructors.number == 0\n@@ -1553,12 +1581,12 @@ main (argc, argv)\n   maybe_unlink(output_file);\n   outf = fopen (c_file, \"w\");\n   if (outf == (FILE *) 0)\n-    fatal_perror (\"%s\", c_file);\n+    fatal_perror (\"fopen %s\", c_file);\n \n   write_c_file (outf, c_file);\n \n   if (fclose (outf))\n-    fatal_perror (\"closing %s\", c_file);\n+    fatal_perror (\"fclose %s\", c_file);\n \n   /* Tell the linker that we have initializer and finalizer functions.  */\n #ifdef LD_INIT_SWITCH\n@@ -1578,10 +1606,10 @@ main (argc, argv)\n       add_to_list (&exports, \"_GLOBAL__DD\");\n       exportf = fopen (export_file, \"w\");\n       if (exportf == (FILE *) 0)\n-\tfatal_perror (\"%s\", export_file);\n+\tfatal_perror (\"fopen %s\", export_file);\n       write_export_file (exportf);\n       if (fclose (exportf))\n-\tfatal_perror (\"closing %s\", export_file);\n+\tfatal_perror (\"fclose %s\", export_file);\n     }\n #endif\n \n@@ -1640,12 +1668,12 @@ collect_wait (prog)\n       if (WIFSIGNALED (status))\n \t{\n \t  int sig = WTERMSIG (status);\n-\t  error (\"%s terminated with signal %d [%s]%s\",\n+\t  error ((status & 0200\n+\t\t  ? \"%s terminated with signal %d [%s]\"\n+\t\t  : \"%s terminated with signal %d [%s], core dumped\"),\n \t\t prog,\n \t\t sig,\n-\t\t my_strsignal(sig),\n-\t\t (status & 0200) ? \", core dumped\" : \"\");\n-\n+\t\t my_strsignal(sig));\n \t  collect_exit (FATAL_EXIT_CODE);\n \t}\n \n@@ -1686,7 +1714,7 @@ collect_execute (prog, argv, redir)\n       if (argv[0])\n \tfprintf (stderr, \"%s\", argv[0]);\n       else\n-\tfprintf (stderr, \"[cannot find %s]\", prog);\n+\tnotice (\"[cannot find %s]\", prog);\n \n       for (p_argv = &argv[1]; (str = *p_argv) != (char *) 0; p_argv++)\n \tfprintf (stderr, \" %s\", str);\n@@ -1714,13 +1742,13 @@ collect_execute (prog, argv, redir)\n \t{\n \t  unlink (redir);\n \t  if (freopen (redir, \"a\", stdout) == NULL)\n-\t    fatal_perror (\"redirecting stdout: %s\", redir);\n+\t    fatal_perror (\"freopen stdout %s\", redir);\n \t  if (freopen (redir, \"a\", stderr) == NULL)\n-\t    fatal_perror (\"redirecting stderr: %s\", redir);\n+\t    fatal_perror (\"freopen stderr %s\", redir);\n \t}\n \n       execvp (argv[0], argv);\n-      fatal_perror (\"executing %s\", prog);\n+      fatal_perror (\"execvp %s\", prog);\n     }\n #else\n   pid = _spawnvp (_P_NOWAIT, argv[0], argv);\n@@ -1747,7 +1775,7 @@ maybe_unlink (file)\n   if (!debug)\n     unlink (file);\n   else\n-    fprintf (stderr, \"[Leaving %s]\\n\", file);\n+    notice (\"[Leaving %s]\\n\", file);\n }\n \n \f\n@@ -1969,8 +1997,8 @@ write_c_file_stat (stream, name)\n     if (!ISALNUM ((unsigned char)*q))\n       *q = '_';\n   if (debug)\n-    fprintf (stderr, \"\\nwrite_c_file - output name is %s, prefix is %s\\n\",\n-\t     output_file, prefix);\n+    notice (\"\\nwrite_c_file - output name is %s, prefix is %s\\n\",\n+\t    output_file, prefix);\n \n #define INIT_NAME_FORMAT \"_GLOBAL__FI_%s\"\n   initname = xmalloc (strlen (prefix) + sizeof (INIT_NAME_FORMAT) - 2);\n@@ -2233,16 +2261,16 @@ scan_prog_file (prog_name, which_pass)\n     {\n       /* setup stdout */\n       if (dup2 (pipe_fd[1], 1) < 0)\n-\tfatal_perror (\"dup2 (%d, 1)\", pipe_fd[1]);\n+\tfatal_perror (\"dup2 %d 1\", pipe_fd[1]);\n \n       if (close (pipe_fd[0]) < 0)\n-\tfatal_perror (\"close (%d)\", pipe_fd[0]);\n+\tfatal_perror (\"close %d\", pipe_fd[0]);\n \n       if (close (pipe_fd[1]) < 0)\n-\tfatal_perror (\"close (%d)\", pipe_fd[1]);\n+\tfatal_perror (\"close %d\", pipe_fd[1]);\n \n       execv (nm_file_name, nm_argv);\n-      fatal_perror (\"executing %s\", nm_file_name);\n+      fatal_perror (\"execvp %s\", nm_file_name);\n     }\n \n   /* Parent context from here on.  */\n@@ -2252,7 +2280,7 @@ scan_prog_file (prog_name, which_pass)\n #endif\n \n   if (close (pipe_fd[1]) < 0)\n-    fatal_perror (\"close (%d)\", pipe_fd[1]);\n+    fatal_perror (\"close %d\", pipe_fd[1]);\n \n   if (debug)\n     fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n@@ -2326,7 +2354,7 @@ scan_prog_file (prog_name, which_pass)\n     fprintf (stderr, \"\\n\");\n \n   if (fclose (inf) != 0)\n-    fatal_perror (\"fclose of pipe\");\n+    fatal_perror (\"fclose\");\n \n   do_wait (nm_file_name);\n \n@@ -2528,7 +2556,7 @@ locatelib (name)\n   if (*pp == 0)\n     {\n       if (debug)\n-\tfprintf (stderr, \"not found\\n\");\n+\tnotice (\"not found\\n\");\n       else\n \tfatal (\"dynamic dependency %s not found\", name);\n     }\n@@ -2572,7 +2600,7 @@ scan_libraries (prog_name)\n     }\n \n   if (debug)\n-    fprintf (stderr, \"dynamic dependencies.\\n\");\n+    notice (\"dynamic dependencies.\\n\");\n \n   ld_2 = (struct link_dynamic_2 *) ((long) ld->ld_un.ld_2 + (long)base);\n   for (lo = (struct link_object *) ld_2->ld_need; lo;\n@@ -2669,16 +2697,16 @@ scan_libraries (prog_name)\n     {\n       /* setup stdout */\n       if (dup2 (pipe_fd[1], 1) < 0)\n-\tfatal_perror (\"dup2 (%d, 1)\", pipe_fd[1]);\n+\tfatal_perror (\"dup2 %d 1\", pipe_fd[1]);\n \n       if (close (pipe_fd[0]) < 0)\n-\tfatal_perror (\"close (%d)\", pipe_fd[0]);\n+\tfatal_perror (\"close %d\", pipe_fd[0]);\n \n       if (close (pipe_fd[1]) < 0)\n-\tfatal_perror (\"close (%d)\", pipe_fd[1]);\n+\tfatal_perror (\"close %d\", pipe_fd[1]);\n \n       execv (ldd_file_name, ldd_argv);\n-      fatal_perror (\"executing %s\", ldd_file_name);\n+      fatal_perror (\"execv %s\", ldd_file_name);\n     }\n \n   /* Parent context from here on.  */\n@@ -2688,10 +2716,10 @@ scan_libraries (prog_name)\n #endif\n \n   if (close (pipe_fd[1]) < 0)\n-    fatal_perror (\"close (%d)\", pipe_fd[1]);\n+    fatal_perror (\"close %d\", pipe_fd[1]);\n \n   if (debug)\n-    fprintf (stderr, \"\\nldd output with constructors/destructors.\\n\");\n+    notice (\"\\nldd output with constructors/destructors.\\n\");\n \n   /* Read each line of ldd output.  */\n   while (fgets (buf, sizeof buf, inf) != (char *) 0)\n@@ -2727,7 +2755,7 @@ scan_libraries (prog_name)\n     fprintf (stderr, \"\\n\");\n \n   if (fclose (inf) != 0)\n-    fatal_perror (\"fclose of pipe\");\n+    fatal_perror (\"fclose\");\n \n   do_wait (ldd_file_name);\n \n@@ -3160,7 +3188,7 @@ scan_prog_file (prog_name, which_pass)\n \n   prog_fd = open (prog_name, (rw) ? O_RDWR : O_RDONLY);\n   if (prog_fd < 0)\n-    fatal_perror (\"cannot read %s\", prog_name);\n+    fatal_perror (\"open %s\", prog_name);\n \n   obj_file = read_file (prog_name, prog_fd, rw);\n   obj = obj_file->start;\n@@ -3256,8 +3284,8 @@ scan_prog_file (prog_name, which_pass)\n \t\tcase SYMC_STABS:\t   kind = \"stabs\";   break;\n \t\t}\n \n-\t      fprintf (stderr, \"\\nProcessing symbol table #%d, offset = 0x%.8lx, kind = %s\\n\",\n-\t\t       symbol_load_cmds, load_hdr->hdr.ldci_section_off, kind);\n+\t      notice (\"\\nProcessing symbol table #%d, offset = 0x%.8lx, kind = %s\\n\",\n+\t\t      symbol_load_cmds, load_hdr->hdr.ldci_section_off, kind);\n \t    }\n \n \t  if (load_hdr->sym.symc_kind != SYMC_DEFINED_SYMBOLS)\n@@ -3341,15 +3369,15 @@ scan_prog_file (prog_name, which_pass)\n \tadd_func_table (&hdr, load_array, main_sym, FNTC_INITIALIZATION);\n \n       if (debug)\n-\tfprintf (stderr, \"\\nUpdating header and load commands.\\n\\n\");\n+\tnotice (\"\\nUpdating header and load commands.\\n\\n\");\n \n       hdr.moh_n_load_cmds++;\n       size = sizeof (load_cmd_map_command_t) + (sizeof (mo_offset_t) * (hdr.moh_n_load_cmds - 1));\n \n       /* Create new load command map.  */\n       if (debug)\n-\tfprintf (stderr, \"load command map, %d cmds, new size %ld.\\n\",\n-\t\t (int)hdr.moh_n_load_cmds, (long)size);\n+\tnotice (\"load command map, %d cmds, new size %ld.\\n\",\n+\t\t(int) hdr.moh_n_load_cmds, (long) size);\n \n       load_map = (load_union_t *) xcalloc (1, size);\n       load_map->map.ldc_header.ldci_cmd_type = LDC_CMD_MAP;\n@@ -3379,7 +3407,7 @@ scan_prog_file (prog_name, which_pass)\n \tbad_header (status);\n \n       if (debug)\n-\tfprintf (stderr, \"writing load commands.\\n\\n\");\n+\tnotice (\"writing load commands.\\n\\n\");\n \n       /* Write load commands */\n       offset = hdr.moh_first_cmd_off;\n@@ -3399,7 +3427,7 @@ scan_prog_file (prog_name, which_pass)\n   end_file (obj_file);\n \n   if (close (prog_fd))\n-    fatal_perror (\"closing %s\", prog_name);\n+    fatal_perror (\"close %s\", prog_name);\n \n   if (debug)\n     fprintf (stderr, \"\\n\");\n@@ -3477,12 +3505,11 @@ add_func_table (hdr_p, load_array, sym, type)\n     }\n \n   if (debug)\n-    fprintf (stderr,\n-\t     \"%s function, region %d, offset = %ld (0x%.8lx)\\n\",\n-\t     (type == FNTC_INITIALIZATION) ? \"init\" : \"term\",\n-\t     (int)ptr->func.fntc_entry_loc[i].adr_lcid,\n-\t     (long)ptr->func.fntc_entry_loc[i].adr_sctoff,\n-\t     (long)ptr->func.fntc_entry_loc[i].adr_sctoff);\n+    notice (\"%s function, region %d, offset = %ld (0x%.8lx)\\n\",\n+\t    type == FNTC_INITIALIZATION ? \"init\" : \"term\",\n+\t    (int) ptr->func.fntc_entry_loc[i].adr_lcid,\n+\t    (long) ptr->func.fntc_entry_loc[i].adr_sctoff,\n+\t    (long) ptr->func.fntc_entry_loc[i].adr_sctoff);\n \n }\n \n@@ -3603,22 +3630,17 @@ static void\n bad_header (status)\n      int status;\n {\n-  char *msg = (char *) 0;\n-\n   switch (status)\n     {\n-    case MO_ERROR_BAD_MAGIC:\t\tmsg = \"bad magic number\";\t\tbreak;\n-    case MO_ERROR_BAD_HDR_VERS:\t\tmsg = \"bad header version\";\t\tbreak;\n-    case MO_ERROR_BAD_RAW_HDR_VERS:\tmsg = \"bad raw header version\";\t\tbreak;\n-    case MO_ERROR_BUF2SML:\t\tmsg = \"raw header buffer too small\";\tbreak;\n-    case MO_ERROR_OLD_RAW_HDR_FILE:\tmsg = \"old raw header file\";\t\tbreak;\n-    case MO_ERROR_UNSUPPORTED_VERS:\tmsg = \"unsupported version\";\t\tbreak;\n+    case MO_ERROR_BAD_MAGIC:\t\tfatal (\"bad magic number\");\n+    case MO_ERROR_BAD_HDR_VERS:\t\tfatal (\"bad header version\");\n+    case MO_ERROR_BAD_RAW_HDR_VERS:\tfatal (\"bad raw header version\");\n+    case MO_ERROR_BUF2SML:\t\tfatal (\"raw header buffer too small\");\n+    case MO_ERROR_OLD_RAW_HDR_FILE:\tfatal (\"old raw header file\");\n+    case MO_ERROR_UNSUPPORTED_VERS:\tfatal (\"unsupported version\");\n+    default:\n+      fatal (\"unknown {de,en}code_mach_o_hdr return value %d\", status);\n     }\n-\n-  if (msg == (char *) 0)\n-    fatal (\"unknown {de,en}code_mach_o_hdr return value %d\", status);\n-  else\n-    fatal (\"%s\", msg);\n }\n \n \f\n@@ -3674,7 +3696,7 @@ read_file (name, fd, rw)\n       p->use_mmap = 0;\n       p->start = xmalloc (p->size);\n       if (lseek (fd, 0L, SEEK_SET) < 0)\n-\tfatal_perror (\"lseek to 0 on %s\", name);\n+\tfatal_perror (\"lseek %s 0\", name);\n \n       len = read (fd, p->start, p->size);\n       if (len < 0)\n@@ -3722,7 +3744,7 @@ end_file (ptr)\n \t    fprintf (stderr, \"write %s\\n\", ptr->name);\n \n \t  if (lseek (ptr->fd, 0L, SEEK_SET) < 0)\n-\t    fatal_perror (\"lseek to 0 on %s\", ptr->name);\n+\t    fatal_perror (\"lseek %s 0\", ptr->name);\n \n \t  len = write (ptr->fd, ptr->start, ptr->size);\n \t  if (len < 0)"}, {"sha": "5fc5231638b39506a8eecd92b0979933d9c9b5e7", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -11984,7 +11984,7 @@ void\n dump_combine_stats (file)\n      FILE *file;\n {\n-  fprintf\n+  fnotice\n     (file,\n      \";; Combiner statistics: %d attempts, %d substitutions (%d requiring new space),\\n;; %d successes.\\n\\n\",\n      combine_attempts, combine_merges, combine_extras, combine_successes);\n@@ -11994,7 +11994,7 @@ void\n dump_combine_total_stats (file)\n      FILE *file;\n {\n-  fprintf\n+  fnotice\n     (file,\n      \"\\n;; Combiner totals: %d attempts, %d substitutions (%d requiring new space),\\n;; %d successes.\\n\",\n      total_attempts, total_merges, total_extras, total_successes);"}, {"sha": "b2aeaf4049e92773638521687ee1aecf0ffa47bc", "filename": "gcc/config.in", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -8,6 +8,15 @@\n /* Define if you want expensive run-time checks. */\n #undef ENABLE_CHECKING\n \n+/* Define to 1 if NLS is requested.  */\n+#undef ENABLE_NLS\n+\n+/* Define as 1 if you have catgets and don't want to use GNU gettext.  */\n+#undef HAVE_CATGETS\n+\n+/* Define as 1 if you have gettext and don't want to use GNU gettext.  */\n+#undef HAVE_GETTEXT\n+\n /* Define if your cpp understands the stringify operator.  */\n #undef HAVE_CPP_STRINGIFY\n \n@@ -28,6 +37,12 @@\n /* Define if you have a working <inttypes.h> header file.  */\n #undef HAVE_INTTYPES_H\n \n+/* Define if your locale.h file contains LC_MESSAGES.  */\n+#undef HAVE_LC_MESSAGES\n+\n+/* Define as 1 if you have the stpcpy function.  */\n+#undef HAVE_STPCPY\n+\n /* Whether malloc must be declared even if <stdlib.h> is included.  */\n #undef NEED_DECLARATION_MALLOC\n \n@@ -94,10 +109,34 @@\n /* Define to enable the use of a default linker. */\n #undef DEFAULT_LINKER\n \n+/* Define to the name of the distribution.  */\n+#undef PACKAGE\n+\n+/* Define to the version of the distribution.  */\n+#undef VERSION\n+\n+/* Define if using alloca.c.  */\n+#undef C_ALLOCA\n+\n+/* Define to empty if the keyword does not work.  */\n+#undef const\n+\n+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.\n+   This function is required for alloca.c support on those systems.  */\n+#undef CRAY_STACKSEG_END\n+\n+/* Define if you have alloca, as a function or macro.  */\n+#undef HAVE_ALLOCA\n+\n+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */\n+#undef HAVE_ALLOCA_H\n \n /* Define if you don't have vprintf but do have _doprnt.  */\n #undef HAVE_DOPRNT\n \n+/* Define if you have a working `mmap' system call.  */\n+#undef HAVE_MMAP\n+\n /* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */\n #undef HAVE_SYS_WAIT_H\n \n@@ -107,9 +146,27 @@\n /* Define if you have the vprintf function.  */\n #undef HAVE_VPRINTF\n \n+/* Define as __inline if that's what the C compiler calls it.  */\n+#undef inline\n+\n+/* Define to `long' if <sys/types.h> doesn't define.  */\n+#undef off_t\n+\n /* Define to `int' if <sys/types.h> doesn't define.  */\n #undef pid_t\n \n+/* Define to `unsigned' if <sys/types.h> doesn't define.  */\n+#undef size_t\n+\n+/* If using the C implementation of alloca, define if you know the\n+   direction of stack growth for your system; otherwise it will be\n+   automatically deduced at run-time.\n+ STACK_DIRECTION > 0 => grows toward higher addresses\n+ STACK_DIRECTION < 0 => grows toward lower addresses\n+ STACK_DIRECTION = 0 => direction of growth unknown\n+ */\n+#undef STACK_DIRECTION\n+\n /* Define if you have the ANSI C header files.  */\n #undef STDC_HEADERS\n \n@@ -122,6 +179,15 @@\n /* Define vfork as fork if vfork does not work.  */\n #undef vfork\n \n+/* Define if you have the __argz_count function.  */\n+#undef HAVE___ARGZ_COUNT\n+\n+/* Define if you have the __argz_next function.  */\n+#undef HAVE___ARGZ_NEXT\n+\n+/* Define if you have the __argz_stringify function.  */\n+#undef HAVE___ARGZ_STRINGIFY\n+\n /* Define if you have the atoll function.  */\n #undef HAVE_ATOLL\n \n@@ -140,12 +206,21 @@\n /* Define if you have the bzero function.  */\n #undef HAVE_BZERO\n \n+/* Define if you have the dcgettext function.  */\n+#undef HAVE_DCGETTEXT\n+\n /* Define if you have the fputc_unlocked function.  */\n #undef HAVE_FPUTC_UNLOCKED\n \n /* Define if you have the fputs_unlocked function.  */\n #undef HAVE_FPUTS_UNLOCKED\n \n+/* Define if you have the getcwd function.  */\n+#undef HAVE_GETCWD\n+\n+/* Define if you have the getpagesize function.  */\n+#undef HAVE_GETPAGESIZE\n+\n /* Define if you have the getrlimit function.  */\n #undef HAVE_GETRLIMIT\n \n@@ -161,6 +236,9 @@\n /* Define if you have the kill function.  */\n #undef HAVE_KILL\n \n+/* Define if you have the munmap function.  */\n+#undef HAVE_MUNMAP\n+\n /* Define if you have the popen function.  */\n #undef HAVE_POPEN\n \n@@ -173,12 +251,27 @@\n /* Define if you have the rindex function.  */\n #undef HAVE_RINDEX\n \n+/* Define if you have the setenv function.  */\n+#undef HAVE_SETENV\n+\n+/* Define if you have the setlocale function.  */\n+#undef HAVE_SETLOCALE\n+\n /* Define if you have the setrlimit function.  */\n #undef HAVE_SETRLIMIT\n \n+/* Define if you have the stpcpy function.  */\n+#undef HAVE_STPCPY\n+\n+/* Define if you have the strcasecmp function.  */\n+#undef HAVE_STRCASECMP\n+\n /* Define if you have the strchr function.  */\n #undef HAVE_STRCHR\n \n+/* Define if you have the strdup function.  */\n+#undef HAVE_STRDUP\n+\n /* Define if you have the strerror function.  */\n #undef HAVE_STRERROR\n \n@@ -194,12 +287,24 @@\n /* Define if you have the sysconf function.  */\n #undef HAVE_SYSCONF\n \n+/* Define if you have the <argz.h> header file.  */\n+#undef HAVE_ARGZ_H\n+\n /* Define if you have the <fcntl.h> header file.  */\n #undef HAVE_FCNTL_H\n \n /* Define if you have the <limits.h> header file.  */\n #undef HAVE_LIMITS_H\n \n+/* Define if you have the <locale.h> header file.  */\n+#undef HAVE_LOCALE_H\n+\n+/* Define if you have the <malloc.h> header file.  */\n+#undef HAVE_MALLOC_H\n+\n+/* Define if you have the <nl_types.h> header file.  */\n+#undef HAVE_NL_TYPES_H\n+\n /* Define if you have the <stab.h> header file.  */\n #undef HAVE_STAB_H\n \n@@ -238,3 +343,6 @@\n \n /* Define if you have the <unistd.h> header file.  */\n #undef HAVE_UNISTD_H\n+\n+/* Define if you have the i library (-li).  */\n+#undef HAVE_LIBI"}, {"sha": "ff9ae37e880dbbc5581f6a9ef07dbe5d0cdfb9ea", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for MIL-STD-1750.\n-   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by O.M.Kellogg, DASA (kellogg@space.otn.dasa.de)\n \n This file is part of GNU CC.\n@@ -222,7 +222,7 @@ memop_valid (op)\n      rtx op;\n {\n   static int recurred = 0;\n-  int valid;\n+  int valid_operand;\n \n   if (GET_MODE (op) != Pmode && GET_MODE (op) != VOIDmode\n       && GET_MODE (op) != QImode)\n@@ -238,11 +238,11 @@ memop_valid (op)\n       return 0;\n     case PLUS:\n       recurred = 1;\n-      valid = memop_valid (XEXP (op, 0));\n-      if (valid)\n-\tvalid = memop_valid (XEXP (op, 1));\n+      valid_operand = memop_valid (XEXP (op, 0));\n+      if (valid_operand)\n+\tvalid_operand = memop_valid (XEXP (op, 1));\n        recurred = 0;\n-       return valid;\n+       return valid_operand;\n     case REG:\n       if (REGNO (op) > 0)\n \treturn 1;"}, {"sha": "8370329b81ea2d42c2427976cfbbb1612c99aa1e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -860,6 +860,29 @@ direct_return ()\n \t  && current_function_pretend_args_size == 0);\n }\n \n+/* Return 1 is OP is a memory location that is not an reference (using\n+   an AND) to an unaligned location.  Take into account what reload\n+   will do.  */\n+\n+int\n+normal_memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (reload_in_progress && GET_CODE (op) == REG\n+      && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      op = reg_equiv_mem[REGNO (op)];\n+\n+      /* This may not have been assigned an equivalent address if it will\n+\t be eliminated.  In that case, it doesn't matter what we do.  */\n+      if (op == 0)\n+\treturn 1;\n+    }\n+\n+  return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) != AND;\n+}\n+\n /* REF is an alignable memory location.  Place an aligned SImode\n    reference into *PALIGNED_MEM and the number of bits to shift into\n    *PBITNUM.  */"}, {"sha": "a995ed77416878d1e793f2cf7bcf9dd056f202ec", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -778,7 +778,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    'S' is a 6-bit constant (valid for a shift insn).  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) != AND\t\\\n+  ((C) == 'Q' ? normal_memory_operand (OP, VOIDmode)\t\t\t\\\n    : (C) == 'R' ? current_file_function_operand (OP, Pmode)\t\t\\\n    : (C) == 'S' ? (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n \t\t   && (unsigned HOST_WIDE_INT) INTVAL (OP) < 64)\t\\"}, {"sha": "7ef1feeb8028ba5ee74d0d33028666b37a66e8b9", "filename": "gcc/config/alpha/vxworks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Falpha%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Falpha%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvxworks.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -36,11 +36,11 @@ Boston, MA 02111-1307, USA.  */\n #undef LIB_SPEC\n #define LIB_SPEC \"\"\n \n-/* VxWorks uses object files, not loadable images.  make linker just\n-   combine objects. */\n+/* VxWorks uses object files, not loadable images.  Make linker just combine\n+   objects.  Also show using 32 bit mode and set start of text to 0.  */\n \n #undef LINK_SPEC\n-#define LINK_SPEC \"-r\"\n+#define LINK_SPEC \"-r -taso -T 0\"\n \n /* VxWorks provides the functionality of crt0.o and friends itself.  */\n "}, {"sha": "6f8e2688188f3d147da83b903b2f88333f6dfee8", "filename": "gcc/config/arc/initfini.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Farc%2Finitfini.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Farc%2Finitfini.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Finitfini.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,7 +1,7 @@\n /* .init/.fini section handling + C++ global constructor/destructor handling.\n    This file is based on crtstuff.c, sol2-crti.asm, sol2-crtn.asm.\n \n-Copyright (C) 1995, 1997 Free Software Foundation, Inc.\n+Copyright (C) 1995, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -77,30 +77,30 @@ __do_global_dtors ()\n /* .init section start.\n    This must appear at the start of the .init section.  */\n \n-asm (\"\n-\t.section .init\\n\n-\t.global init\\n\n-\t.word 0\\n\n-init:\\n\n-\tst blink,[sp,4]\\n\n-\tst fp,[sp]\\n\n-\tmov fp,sp\\n\n-\tsub sp,sp,16\\n\n+asm (\"\\n\\\n+\t.section .init\\n\\\n+\t.global init\\n\\\n+\t.word 0\\n\\\n+init:\\n\\\n+\tst blink,[sp,4]\\n\\\n+\tst fp,[sp]\\n\\\n+\tmov fp,sp\\n\\\n+\tsub sp,sp,16\\n\\\n \");\n \n /* .fini section start.\n    This must appear at the start of the .init section.  */\n \n-asm (\"\n-\t.section .fini\\n\n-\t.global fini\\n\n-\t.word 0\\n\n-fini:\\n\n-\tst blink,[sp,4]\\n\n-\tst fp,[sp]\\n\n-\tmov fp,sp\\n\n-\tsub sp,sp,16\\n\n-\tbl.nd __do_global_dtors\n+asm (\"\\n\\\n+\t.section .fini\\n\\\n+\t.global fini\\n\\\n+\t.word 0\\n\\\n+fini:\\n\\\n+\tst blink,[sp,4]\\n\\\n+\tst fp,[sp]\\n\\\n+\tmov fp,sp\\n\\\n+\tsub sp,sp,16\\n\\\n+\tbl.nd __do_global_dtors\\n\\\n \");\n \n #endif /* CRT_INIT */\n@@ -136,22 +136,22 @@ __do_global_ctors ()\n /* .init section end.\n    This must live at the end of the .init section.  */\n \n-asm (\"\n-\t.section .init\\n\n-\tbl.nd __do_global_ctors\n-\tld blink,[fp,4]\\n\n-\tj.d blink\\n\n-\tld.a fp,[sp,16]\\n\n+asm (\"\\n\\\n+\t.section .init\\n\\\n+\tbl.nd __do_global_ctors\\\n+\tld blink,[fp,4]\\n\\\n+\tj.d blink\\n\\\n+\tld.a fp,[sp,16]\\n\\\n \");\n \n /* .fini section end.\n    This must live at the end of the .fini section.  */\n \n-asm (\"\n-\t.section .fini\\n\n-\tld blink,[fp,4]\\n\n-\tj.d blink\\n\n-\tld.a fp,[sp,16]\\n\n+asm (\"\\n\\\n+\t.section .fini\\n\\\n+\tld blink,[fp,4]\\n\\\n+\tj.d blink\\n\\\n+\tld.a fp,[sp,16]\\n\\\n \");\n \n #endif /* CRT_FINI */"}, {"sha": "69f40c7fe5fd489a2b2d92f2801c10d724e31132", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for assembler code output on the DSP1610.\n-   Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Michael Collison (collison@world.std.com).\n \n This file is part of GNU CC.\n@@ -2239,3 +2239,9 @@ output_block_move (operands)\n   fprintf (asm_out_file, \"\\t}\\n\");\n   return \"\";\n }\n+\n+void\n+dsp16xx_invalid_register_for_compare ()\n+{\n+  fatal (\"Invalid register for compare\");\n+}"}, {"sha": "f48de0968ca385ed9a081c8d0ef467ece2ee92e8", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1970,3 +1970,5 @@ const_section ()                                                   \\\n /* Define this so gcc does not output a call to __main, since we\n    are not currently supporting c++. */\n #define INIT_SECTION_ASM_OP  1\n+\n+void dsp16xx_invalid_register_for_compare ();"}, {"sha": "6029489628bf0bc554b8e007eea251e8074cba19", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for the AT&T DSP1600 for GNU C compiler\n-;;  Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.\n+;;  Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n ;;  Contributed by Michael Collison (collison@world.std.com).\n \n ;; This file is part of GNU CC.\n@@ -178,7 +178,7 @@\n \t  output_asm_insn (\\\"a0=%u0\\;a0l=%w0\\\", operands);\n \t}\n       else\n-\tfatal (\\\"Invalid register for compare\\\");\n+\tdsp16xx_invalid_register_for_compare ();\n     }\n   else if (GET_CODE(operands[0]) == CONST_INT)\n     {\n@@ -205,7 +205,7 @@\n \t  output_asm_insn (\\\"a1=%u1\\;a1l=%w1\\\", operands);\n \t}\n       else\n-\tfatal (\\\"Invalid register for compare\\\");\n+\tdsp16xx_invalid_register_for_compare ();\n     }\n   else if (GET_CODE (operands[1]) == MEM)\n     {"}, {"sha": "51444279e52b080efa574230ae5ea4c3a8eafec1", "filename": "gcc/config/m32r/initfini.c", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fm32r%2Finitfini.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fm32r%2Finitfini.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Finitfini.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,7 +1,7 @@\n /* .init/.fini section handling + C++ global constructor/destructor handling.\n    This file is based on crtstuff.c, sol2-crti.asm, sol2-crtn.asm.\n \n-Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -80,32 +80,32 @@ __do_global_dtors ()\n /* .init section start.\n    This must appear at the start of the .init section.  */\n \n-asm (\"\n-\t.section .init,\\\"ax\\\",@progbits\n-\t.balign 4\n-\t.global __init\n-__init:\n-\tpush fp\n-\tpush lr\n-\tmv fp,sp\n-\tld24 r0,#__fini\n-\tbl atexit\n-\t.fillinsn\n+asm (\"\\n\\\n+\t.section .init,\\\"ax\\\",@progbits\\n\\\n+\t.balign 4\\n\\\n+\t.global __init\\n\\\n+__init:\\n\\\n+\tpush fp\\n\\\n+\tpush lr\\n\\\n+\tmv fp,sp\\n\\\n+\tld24 r0,#__fini\\n\\\n+\tbl atexit\\n\\\n+\t.fillinsn\\n\\\n \");\n \n /* .fini section start.\n    This must appear at the start of the .init section.  */\n \n-asm (\"\n-\t.section .fini,\\\"ax\\\",@progbits\n-\t.balign 4\n-\t.global __fini\n-__fini:\n-\tpush fp\n-\tpush lr\n-\tmv fp,sp\n-\tbl __do_global_dtors\n-\t.fillinsn\n+asm (\"\\n\\\n+\t.section .fini,\\\"ax\\\",@progbits\\n\\\n+\t.balign 4\\n\\\n+\t.global __fini\\n\\\n+__fini:\\n\\\n+\tpush fp\\n\\\n+\tpush lr\\n\\\n+\tmv fp,sp\\n\\\n+\tbl __do_global_dtors\\n\\\n+\t.fillinsn\\n\\\n \");\n \n #endif /* CRT_INIT */\n@@ -144,26 +144,26 @@ __do_global_ctors ()\n /* .init section end.\n    This must live at the end of the .init section.  */\n \n-asm (\"\n-\t.section .init,\\\"ax\\\",@progbits\n-\tbl __do_global_ctors\n-\tmv sp,fp\n-\tpop lr\n-\tpop fp\n-\tjmp lr\n-\t.fillinsn\n+asm (\"\\n\\\n+\t.section .init,\\\"ax\\\",@progbits\\n\\\n+\tbl __do_global_ctors\\n\\\n+\tmv sp,fp\\n\\\n+\tpop lr\\n\\\n+\tpop fp\\n\\\n+\tjmp lr\\n\\\n+\t.fillinsn\\n\\\n \");\n \n /* .fini section end.\n    This must live at the end of the .fini section.  */\n \n-asm (\"\n-\t.section .fini,\\\"ax\\\",@progbits\n-\tmv sp,fp\n-\tpop lr\n-\tpop fp\n-\tjmp lr\n-\t.fillinsn\n+asm (\"\\n\\\n+\t.section .fini,\\\"ax\\\",@progbits\\n\\\n+\tmv sp,fp\\n\\\n+\tpop lr\\n\\\n+\tpop fp\\n\\\n+\tjmp lr\\n\\\n+\t.fillinsn\\n\\\n \");\n \n #endif /* CRT_FINI */"}, {"sha": "236bd9a00624e8cfc7a5dc479434c79ca2f18ab6", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 77, "deletions": 126, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1675,8 +1675,7 @@\n \n (define_insn \"extendqidi2\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n-\t(sign_extend:DI\n-\t (match_operand:QI 1 \"general_operand\" \"rm\")))]\n+\t(sign_extend:DI (match_operand:QI 1 \"general_operand\" \"dm\")))]\n   \"\"\n   \"*\n {\n@@ -5675,8 +5674,12 @@\n   return output_scc_di (operands[1], operands[2], operands[3], operands[0]);\n } \")\n \n+;; Note that operand 0 of an SCC insn is supported in the hardware as\n+;; memory, but we cannot allow it to be in memory in case the address\n+;; needs to be reloaded.\n+\n (define_expand \"seq\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(eq:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\n@@ -5689,25 +5692,16 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(eq:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"seq %0\\\", \\\"fseq %0\\\", \\\"seq %0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(eq:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n+  \"\"\n   \"*\n   cc_status = cc_prev_status;\n   OUTPUT_JUMP (\\\"seq %0\\\", \\\"fseq %0\\\", \\\"seq %0\\\");\n \")\n \n (define_expand \"sne\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ne:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\n@@ -5720,25 +5714,16 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(ne:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"sne %0\\\", \\\"fsne %0\\\", \\\"sne %0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ne:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n+  \"\"\n   \"*\n   cc_status = cc_prev_status;\n   OUTPUT_JUMP (\\\"sne %0\\\", \\\"fsne %0\\\", \\\"sne %0\\\");\n \")\n \n (define_expand \"sgt\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(gt:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\n@@ -5751,45 +5736,30 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(gt:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"sgt %0\\\", \\\"fsgt %0\\\", 0);\n-\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(gt:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n+  \"\"\n   \"*\n   cc_status = cc_prev_status;\n   OUTPUT_JUMP (\\\"sgt %0\\\", \\\"fsgt %0\\\", 0);\n \")\n \n (define_expand \"sgtu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(gtu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(gtu:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"shi %0\\\"; \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(gtu:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"shi %0\\\"; \")\n+  \"\"\n+  \"*\n+   cc_status = cc_prev_status;\n+   return \\\"shi %0\\\"; \")\n \n (define_expand \"slt\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(lt:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\n@@ -5802,41 +5772,29 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(lt:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     OUTPUT_JUMP (\\\"slt %0\\\", \\\"fslt %0\\\", \\\"smi %0\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(lt:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     OUTPUT_JUMP (\\\"slt %0\\\", \\\"fslt %0\\\", \\\"smi %0\\\"); \")\n+  \"\"\n+  \"*\n+   cc_status = cc_prev_status;\n+   OUTPUT_JUMP (\\\"slt %0\\\", \\\"fslt %0\\\", \\\"smi %0\\\"); \")\n \n (define_expand \"sltu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ltu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(ltu:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"scs %0\\\"; \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ltu:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"scs %0\\\"; \")\n+  \"\"\n+  \"*\n+   cc_status = cc_prev_status;\n+   return \\\"scs %0\\\"; \")\n \n (define_expand \"sge\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(ge:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\n@@ -5849,41 +5807,29 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(ge:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     OUTPUT_JUMP (\\\"sge %0\\\", \\\"fsge %0\\\", \\\"spl %0\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ge:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     OUTPUT_JUMP (\\\"sge %0\\\", \\\"fsge %0\\\", \\\"spl %0\\\"); \")\n+  \"\"\n+  \"*\n+   cc_status = cc_prev_status;\n+   OUTPUT_JUMP (\\\"sge %0\\\", \\\"fsge %0\\\", \\\"spl %0\\\"); \")\n \n (define_expand \"sgeu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(geu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(geu:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"scc %0\\\"; \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(geu:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"scc %0\\\"; \")\n+  \"\"\n+  \"*\n+   cc_status = cc_prev_status;\n+   return \\\"scc %0\\\"; \")\n \n (define_expand \"sle\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(le:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\n@@ -5896,42 +5842,27 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(le:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"sle %0\\\", \\\"fsle %0\\\", 0);\n-\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(le:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n+  \"\"\n   \"*\n   cc_status = cc_prev_status;\n   OUTPUT_JUMP (\\\"sle %0\\\", \\\"fsle %0\\\", 0);\n \")\n \n (define_expand \"sleu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n \t(leu:QI (cc0) (const_int 0)))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(leu:QI (cc0) (const_int 0)))]\n-  \"! TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"sls %0\\\"; \")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(leu:QI (cc0) (const_int 0)))]\n-  \"TARGET_5200\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"sls %0\\\"; \")\n+  \"\"\n+  \"*\n+   cc_status = cc_prev_status;\n+   return \\\"sls %0\\\"; \")\n \f\n ;; Basic conditional jump instructions.\n \n@@ -7504,7 +7435,7 @@\n \n (define_insn \"extendsfxf2\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=fm,f\")\n-\t(float_extend:XF (match_operand:SF 1 \"general_operand\" \"f,m\")))]\n+\t(float_extend:XF (match_operand:SF 1 \"general_operand\" \"f,rmF\")))]\n   \"TARGET_68881\"\n   \"*\n {\n@@ -7521,15 +7452,23 @@\n       return \\\"f%$move%.x %1,%0\\\";\n     }\n   if (FP_REG_P (operands[0]))\n-    return \\\"f%$move%.s %f1,%0\\\";\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"f%$move%.x %1,%0\\\";\n+      else if (ADDRESS_REG_P (operands[1]))\n+\treturn \\\"move%.l %1,%-\\;f%$move%.s %+,%0\\\";\n+      else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_single (operands);\n+      return \\\"f%$move%.s %f1,%0\\\";\n+    }\n   return \\\"fmove%.x %f1,%0\\\";\n }\")\n \n \n (define_insn \"extenddfxf2\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=fm,f\")\n \t(float_extend:XF\n-          (match_operand:DF 1 \"general_operand\" \"f,m\")))]\n+          (match_operand:DF 1 \"general_operand\" \"f,rmE\")))]\n   \"TARGET_68881\"\n   \"*\n {\n@@ -7546,7 +7485,19 @@\n       return \\\"fmove%.x %1,%0\\\";\n     }\n   if (FP_REG_P (operands[0]))\n-    return \\\"f%&move%.d %f1,%0\\\";\n+    {\n+      if (REG_P (operands[1]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn (\\\"move%.l %1,%-\\\", xoperands);\n+\t  output_asm_insn (\\\"move%.l %1,%-\\\", operands);\n+\t  return \\\"f%&move%.d %+,%0\\\";\n+\t}\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\treturn output_move_const_double (operands);\n+      return \\\"f%&move%.d %f1,%0\\\";\n+    }\n   return \\\"fmove%.x %f1,%0\\\";\n }\")\n "}, {"sha": "86884db9719322293f82d470f44456b78ae578f1", "filename": "gcc/config/m68k/vxm68k.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fm68k%2Fvxm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fm68k%2Fvxm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fvxm68k.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Vxworks m68k version.\n-   Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1996, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -82,9 +82,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \n #define LIB_SPEC \"\"\n \n-/* Provide required defaults for linker -e. */\n+/* Provide required defaults for linker. */\n  \n-#define LINK_SPEC \"%{!nostdlib:%{!r*:%{!e*:-e start}}}\"\n+#define LINK_SPEC \"-r\"\n \n /* VxWorks provides the functionality of crt0.o and friends itself.  */\n \n@@ -99,3 +99,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \n /* GCC is the primary compiler for VxWorks, so we don't need this.  */\n #undef PCC_STATIC_STRUCT_RETURN\n+\n+/* Restrict use of 128 bit floating-point by default since VxWorks doesn't\n+   have the proper accuracy routines for that size; this is not done because\n+   the hardware doesn't support it, despite the name.  */\n+#define WIDEST_HARDWARE_FP_SIZE 64"}, {"sha": "b27f12cdb013c7d5eb1ecdd3a4706f37c331c632", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -19,9 +19,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#include \"config.h\"\n #include <stdio.h>\n #include <ctype.h>\n-#include \"config.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\""}, {"sha": "d3a7bc1e6865192b7810d7d441a4bf661875430c", "filename": "gcc/configure", "status": "modified", "additions": 2248, "deletions": 281, "changes": 2529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81"}, {"sha": "2b2b46a1d3c451c3cb50f5186cb492c581696ad1", "filename": "gcc/configure.in", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -3037,6 +3037,15 @@ changequote([,])dnl\n \t\t    fi\n \t\tfi\n \t\t;;\n+        sparc-hal-solaris2*)\n+                xm_file=sparc/xm-sol2.h\n+                tm_file=\"sparc/sol2.h sparc/hal.h\"\n+                tmake_file=\"sparc/t-halos sparc/t-sol2\"\n+                xmake_file=sparc/x-sysv4\n+                extra_parts=\"crt1.o crti.o crtn.o gmon.o crtbegin.o crtend.o\"\n+                fixincludes=fixinc.svr4\n+                broken_install=yes\n+                ;;\n \tsparc-*-solaris2*)\n \t\tif test x$gnu_ld = xyes\n \t\tthen\n@@ -3574,7 +3583,21 @@ do\n \tfi\n \n \tfor file in `eval echo '$'$var`; do\n+\t\tcase $file in\n+\t\tauto-config.h)\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo '#ifdef IN_GCC' >>$link\n+\t\t\t;;\n+\t\tesac\n \t\techo \"#include \\\"$file\\\"\" >>$link\n+\t\tcase $file in\n+\t\tauto-config.h)\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo '#endif' >>$link\n+\t\t\t;;\n+\t\tesac\n \tdone\n \n \tfor def in `eval echo '$'$define`; do\n@@ -3599,6 +3622,24 @@ changequote(,)dnl\n gcc_version=`sed -e 's/.*\\\"\\([^ \\\"]*\\)[ \\\"].*/\\1/' < ${gcc_version_trigger}`\n changequote([,])dnl\n \n+# Internationalization\n+PACKAGE=gcc\n+VERSION=\"$gcc_version\"\n+AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\")\n+AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\")\n+AC_SUBST(PACKAGE)\n+AC_SUBST(VERSION)\n+\n+ALL_LINGUAS=\"en_UK\"\n+\n+# NLS support is still experimental, so disable it by default for now.\n+AC_ARG_ENABLE(nls,\n+  [  --enable-nls            use Native Language Support (disabled by default)],\n+  , enable_nls=no)\n+\n+AM_GNU_GETTEXT\n+XGETTEXT=\"AWK='$AWK' \\$(SHELL) \\$(top_srcdir)/exgettext $XGETTEXT\"\n+\n # Get an absolute path to the GCC top-level source directory\n holddir=`pwd`\n cd $srcdir\n@@ -3960,7 +4001,7 @@ all_boot_languages=\n all_compilers=\n all_stagestuff=\n all_diff_excludes=\n-all_outputs=Makefile\n+all_outputs='Makefile intl/Makefile po/Makefile.in'\n # List of language makefile fragments.\n all_lang_makefiles=\n all_headers=\n@@ -4028,10 +4069,10 @@ target_list=\"all.build all.cross start.encap rest.encap \\\n for t in $target_list\n do\n \tx=\n-\tfor l in .. $all_languages\n+\tfor lang in .. $all_languages\n \tdo\n-\t\tif test $l != \"..\"; then\n-\t\t\tx=\"$x $l.$t\"\n+\t\tif test $lang != \"..\"; then\n+\t\t\tx=\"$x $lang.$t\"\n \t\tfi\n \tdone\n \techo \"lang.$t: $x\" >> Make-hooks\n@@ -4246,6 +4287,11 @@ if test \"$symbolic_link\" = \"ln -s\"; then\n    fi\n  done\n else true ; fi\n+# Avoid having to add intl to our include paths.\n+if test -f intl/libintl.h; then\n+  echo creating libintl.h\n+  echo '#include \"intl/libintl.h\"' >libintl.h\n+fi\n ],\n [\n host='${host}'"}, {"sha": "22893d1bedab7fe368ec490e04cee8e2d7ad6cea", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -86,17 +86,19 @@ g++spec.o: $(srcdir)/cp/g++spec.c\n # It'd be nice if we could find an easier way to do this---rather than have\n # to track changes to the toplevel gcc Makefile as well.\n # We depend on g++.c last, to make it obvious where it came from.\n-g++.o: $(CONFIG_H) multilib.h config.status $(lang_specs_files) g++.c \\\n-       system.h prefix.h\n+g++.o: $(CONFIG_H) intl.h multilib.h config.status system.h \\\n+    Makefile $(lang_specs_files) g++.c prefix.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t$(DRIVER_DEFINES) \\\n \t-DLANG_SPECIFIC_DRIVER \\\n   -c g++.c\n \n # Create the compiler driver for g++.\n-g++$(exeext): g++.o g++spec.o version.o choose-temp.o pexecute.o prefix.o mkstemp.o $(LIBDEPS) $(EXTRA_GCC_OBJS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ g++.o g++spec.o prefix.o \\\n-\t  version.o choose-temp.o pexecute.o mkstemp.o $(EXTRA_GCC_OBJS) $(LIBS)\n+GXX_OBJS = g++.o g++spec.o choose-temp.o intl.o pexecute.o prefix.o version.o \\\n+    mkstemp.o\n+g++$(exeext): $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n+\t  $(GXX_OBJS) $(EXTRA_GCC_OBJS) $(LIBS)\n \n # Create a version of the g++ driver which calls the cross-compiler.\n g++-cross$(exeext): g++$(exeext)"}, {"sha": "5b07d216c673e9872f6f0225cb8055e50aea6409", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n # Makefile for GNU C++ compiler.\n-#   Copyright (C) 1987, 88, 90-5, 1998 Free Software Foundation, Inc.\n+#   Copyright (C) 1987, 88, 90-4, 1995, 1998 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -105,6 +105,12 @@ VPATH = @srcdir@\n \n # Additional system libraries to link with.\n CLIB=\n+ \n+# Top build directory, relative to here.\n+top_builddir = ..\n+\n+# Internationalization library.\n+INTLLIBS = @INTLLIBS@\n \n # Change this to a null string if obstacks are installed in the\n # system library.\n@@ -154,7 +160,8 @@ SUBDIR_MALLOC = `if [ x$(MALLOC) != x ]; then echo ../$(MALLOC); else true; fi`\n \n # How to link with both our special library facilities\n # and the system's installed libraries.\n-LIBS = $(SUBDIR_OBSTACK) $(SUBDIR_USE_ALLOCA) $(SUBDIR_MALLOC) $(CLIB)\n+LIBS = $(SUBDIR_OBSTACK) $(SUBDIR_USE_ALLOCA) $(SUBDIR_MALLOC) \\\n+  $(INTLLIBS) $(CLIB)\n \n # Specify the directories to be searched for header files.\n # Both . and srcdir are used, in that order,"}, {"sha": "5c96aff7cb817e7c2b1d4d0f433ab19f9330db2d", "filename": "gcc/cppalloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcppalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcppalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppalloc.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n /* Part of CPP library.  (memory allocation - xmalloc etc)\n-   Copyright (C) 1986, 87, 89, 92 - 95, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 87, 89, 92, 93, 94, 1995, 1998 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -31,7 +31,7 @@ static void memory_full PROTO ((void)) ATTRIBUTE_NORETURN;\n static void\n memory_full ()\n {\n-  fprintf (stderr, \"%s: Memory exhausted.\\n\", progname);\n+  cpp_notice (\"%s: Memory exhausted.\\n\", progname);\n   exit (FATAL_EXIT_CODE);\n }\n "}, {"sha": "af7ab8c9a6391163f0369b5199837e785eb944bd", "filename": "gcc/cpperror.c", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,5 +1,5 @@\n /* Default error handlers for CPP Library.\n-   Copyright (C) 1986, 87, 89, 92 - 95, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 87, 89, 92-95, 1998 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -30,6 +30,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #endif /* not EMACS */\n \n #include \"cpplib.h\"\n+#include \"intl.h\"\n \n /* Print the file names and line numbers of the #include\n    commands which led to the current file.  */\n@@ -62,10 +63,10 @@ cpp_print_containing_files (pfile)\n \t  if (first)\n \t    {\n \t      first = 0;\n-\t      fprintf (stderr, \"In file included\");\n+\t      cpp_notice (\"In file included from \");\n \t    }\n \t  else\n-\t    fprintf (stderr, \",\\n                \");\n+\t    cpp_notice (\",\\n                 from \");\n \t}\n \n       fprintf (stderr, \" from %s:%ld\", ip->nominal_fname, line);\n@@ -89,27 +90,41 @@ cpp_file_line_for_message (pfile, filename, line, column)\n     fprintf (stderr, \"%s:%d: \", filename, line);\n }\n \n-/* IS_ERROR is 2 for \"fatal\" error, 1 for error, 0 for warning */\n+/* IS_ERROR is 2 for \"fatal\" error, 1 for error, 0 for warning, -1 for notice */\n \n void\n-v_cpp_message (pfile, is_error, msg, ap)\n+v_cpp_message (pfile, is_error, msgid, ap)\n   cpp_reader * pfile;\n   int is_error;\n-  const char *msg;\n+  const char *msgid;\n   va_list ap;\n {\n-  if (!is_error)\n-    fprintf (stderr, \"warning: \");\n-  else if (is_error == 2)\n-    pfile->errors = CPP_FATAL_LIMIT;\n-  else if (pfile->errors < CPP_FATAL_LIMIT)\n-    pfile->errors++;\n-  vfprintf (stderr, msg, ap);\n-  fprintf (stderr, \"\\n\");\n+  switch (is_error)\n+    {\n+    case -1:\n+      break;\n+    case 0:\n+      fprintf (stderr, _(\"warning: \"));\n+      break;\n+    case 1:\n+      if (pfile->errors < CPP_FATAL_LIMIT)\n+\tpfile->errors++;\n+      break;\n+    case 2:\n+      pfile->errors = CPP_FATAL_LIMIT;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  vfprintf (stderr, _(msgid), ap);\n+\n+  if (0 <= is_error)\n+    fprintf (stderr, \"\\n\");\n }\n \n void\n-cpp_message VPROTO ((cpp_reader *pfile, int is_error, const char *msg, ...))\n+cpp_message VPROTO ((cpp_reader *pfile, int is_error, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n@@ -118,15 +133,15 @@ cpp_message VPROTO ((cpp_reader *pfile, int is_error, const char *msg, ...))\n #endif\n   va_list ap;\n   \n-  VA_START (ap, msg);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n   is_error = va_arg (ap, int);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_message(pfile, is_error, msg, ap);\n+  v_cpp_message(pfile, is_error, msgid, ap);\n   va_end(ap);\n }\n \n@@ -137,23 +152,23 @@ cpp_message VPROTO ((cpp_reader *pfile, int is_error, const char *msg, ...))\n    CPP_FATAL_ERRORS.  */\n \n void\n-cpp_fatal VPROTO ((cpp_reader *pfile, const char *str, ...))\n+cpp_fatal VPROTO ((cpp_reader *pfile, const char *msgid, ...))\n {  \n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n-  const char *str;\n+  const char *msgid;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, str);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n-  str = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n   fprintf (stderr, \"%s: \", progname);\n-  v_cpp_message (pfile, 2, str, ap);\n+  v_cpp_message (pfile, 2, msgid, ap);\n   va_end(ap);\n }\n \f\n@@ -169,3 +184,25 @@ cpp_pfatal_with_name (pfile, name)\n   exit (FATAL_EXIT_CODE);\n #endif\n }\n+\n+/* Print an error message.  */\n+\n+void\n+cpp_notice VPROTO ((const char *msgid, ...))\n+{  \n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  \n+  VA_START (ap, msgid);\n+  \n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  fprintf (stderr, \"%s: \", progname);\n+  v_cpp_message ((cpp_reader *) 0, -1, msgid, ap);\n+  va_end(ap);\n+}\n+\f"}, {"sha": "09c1a0504d1948f53c8e2fe071b3c86b32658dc7", "filename": "gcc/cppexp.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -452,11 +452,8 @@ cpp_lex (pfile, skip_evaluation)\n \t\t&& tok_start[1] == toktab->operator[1])\n \t\tbreak;\n \t  if (toktab->token == ERROR)\n-\t    {\n-\t      char *buf = (char *) alloca (40);\n-\t      sprintf (buf, \"`%s' not allowed in operand of `#if'\", tok_start);\n-\t      cpp_error (pfile, buf);\n-\t    }\n+\t    cpp_error (pfile, \"`%s' not allowed in operand of `#if'\",\n+\t\t       tok_start);\n \t  op.op = toktab->token; \n \t  return op;\n \t}\n@@ -968,11 +965,11 @@ cpp_parse_expr (pfile)\n \t\t}\n \t      break;\n \t    default:\n-\t      fprintf (stderr,\n-\t\t       top[1].op >= ' ' && top[1].op <= '~'\n-\t\t       ? \"unimplemented operator '%c'\\n\"\n-\t\t       : \"unimplemented operator '\\\\%03o'\\n\",\n-\t\t       top[1].op);\n+\t      cpp_error (pfile,\n+\t\t\t (top[1].op >= ' ' && top[1].op <= '~'\n+\t\t\t  ? \"unimplemented operator '%c'\\n\"\n+\t\t\t  : \"unimplemented operator '\\\\%03o'\\n\"),\n+\t\t\t top[1].op);\n \t    }\n \t}\n       if (op.op == 0)"}, {"sha": "b1c2f6da52330f27e871924e12edd8e165e36b9f", "filename": "gcc/cpplib.c", "status": "modified", "additions": 88, "deletions": 74, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -28,6 +28,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n #include \"output.h\"\n+#include \"intl.h\"\n #include \"prefix.h\"\n \n #ifndef GET_ENV_PATH_LIST\n@@ -136,7 +137,7 @@ static int comp_def_part\t\tPROTO ((int, U_CHAR *, int, U_CHAR *,\n #ifdef abort\n extern void fancy_abort ();\n #endif\n-static int check_macro_name\t\tPROTO ((cpp_reader *, U_CHAR *, char *));\n+static int check_macro_name\t\tPROTO ((cpp_reader *, U_CHAR *, int));\n static int compare_defs\t\t\tPROTO ((cpp_reader *,\n \t\t\t\t\t\tDEFINITION *, DEFINITION *));\n static HOST_WIDE_INT eval_if_expression\tPROTO ((cpp_reader *));\n@@ -853,7 +854,7 @@ handle_directive (pfile)\n       break;\n   }\n \n-  /* We may want to pass through #define, #pragma, and #include.\n+  /* We may want to pass through #define, #undef, #pragma, and #include.\n      Other directives may create output, but we don't want the directive\n      itself out, so we pop it now.  For example conditionals may emit\n      #failed ... #endfailed stuff.  */\n@@ -1259,7 +1260,7 @@ create_definition (buf, limit, pfile, predefinition)\n \n   symname = bp;\t\t\t/* remember where it starts */\n \n-  sym_length = check_macro_name (pfile, bp, \"macro\");\n+  sym_length = check_macro_name (pfile, bp, 0);\n   bp += sym_length;\n \n   /* Lossage will occur if identifiers or control keywords are broken\n@@ -1407,13 +1408,13 @@ create_definition (buf, limit, pfile, predefinition)\n }\n \n /* Check a purported macro name SYMNAME, and yield its length.\n-   USAGE is the kind of name this is intended for.  */\n+   ASSERTION is nonzero if this is really for an assertion name.  */\n \n static int\n-check_macro_name (pfile, symname, usage)\n+check_macro_name (pfile, symname, assertion)\n      cpp_reader *pfile;\n      U_CHAR *symname;\n-     char *usage;\n+     int assertion;\n {\n   U_CHAR *p;\n   int sym_length;\n@@ -1423,16 +1424,19 @@ check_macro_name (pfile, symname, usage)\n   sym_length = p - symname;\n   if (sym_length == 0\n       || (sym_length == 1 && *symname == 'L' && (*p == '\\'' || *p == '\"')))\n-    cpp_error (pfile, \"invalid %s name\", usage);\n-  else if (!is_idstart[*symname]) {\n+    cpp_error (pfile,\n+\t       assertion ? \"invalid assertion name\" : \"invalid macro name\");\n+  else if (!is_idstart[*symname]\n+\t   || (! strncmp (symname, \"defined\", 7) && sym_length == 7)) {\n     U_CHAR *msg;\t\t\t/* what pain...  */\n     msg = (U_CHAR *) alloca (sym_length + 1);\n     bcopy (symname, msg, sym_length);\n     msg[sym_length] = 0;\n-    cpp_error (pfile, \"invalid %s name `%s'\", usage, msg);\n-  } else {\n-    if (! strncmp (symname, \"defined\", 7) && sym_length == 7)\n-      cpp_error (pfile, \"invalid %s name `defined'\", usage);\n+    cpp_error (pfile,\n+\t       (assertion\n+\t\t? \"invalid assertion name `%s'\"\n+\t\t: \"invalid macro name `%s'\"),\n+\t       msg);\n   }\n   return sym_length;\n }\n@@ -1571,18 +1575,12 @@ do_define (pfile, keyword)\n       /* Print the warning if it's not ok.  */\n       if (!ok)\n \t{\n-\t  U_CHAR *msg;\t\t/* what pain...  */\n-\n \t  /* If we are passing through #define and #undef directives, do\n \t     that for this re-definition now.  */\n \t  if (CPP_OPTIONS (pfile)->debug_output && keyword)\n \t    pass_thru_directive (macro, end, pfile, keyword);\n \n-\t  msg = (U_CHAR *) alloca (mdef.symlen + 22);\n-\t  *msg = '`';\n-\t  bcopy (mdef.symnam, msg + 1, mdef.symlen);\n-\t  strcpy ((char *) (msg + mdef.symlen + 1), \"' redefined\");\n-\t  cpp_pedwarn (pfile, msg);\n+\t  cpp_pedwarn (pfile, \"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n \t  if (hp->type == T_MACRO)\n \t    cpp_pedwarn_with_file_and_line (pfile, hp->value.defn->file, hp->value.defn->line,\n \t\t\t\t      \"this is the location of the previous definition\");\n@@ -2934,7 +2932,19 @@ do_include (pfile, keyword)\n       && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n     {\n       pfile->import_warning = 1;\n-      cpp_warning (pfile, \"`#import' is obsolete, use an #ifdef wrapper in the header file\");\n+      cpp_warning (pfile, \"using `#import' is not recommended\");\n+      cpp_notice (\"The fact that a certain header file need not be processed more than once\\n\\\n+should be indicated in the header file, not where it is used.\\n\\\n+The best way to do this is with a conditional of this form:\\n\\\n+\\n\\\n+  #ifndef _FOO_H_INCLUDED\\n\\\n+  #define _FOO_H_INCLUDED\\n\\\n+  ... <real contents of file> ...\\n\\\n+  #endif /* Not _FOO_H_INCLUDED */\\n\\\n+\\n\\\n+Then users can use `#include' any number of times.\\n\\\n+GNU C automatically avoids processing the file more than once\\n\\\n+when it is equipped with such a conditional.\\n\");\n     }\n \n   pfile->parsing_include_directive++;\n@@ -3356,7 +3366,7 @@ do_undef (pfile, keyword)\n     pass_thru_directive (buf, limit, pfile, keyword);\n #endif\n \n-  sym_length = check_macro_name (pfile, name, \"macro\");\n+  sym_length = check_macro_name (pfile, buf, 0);\n \n   while ((hp = cpp_lookup (pfile, name, sym_length, -1)) != NULL)\n     {\n@@ -4954,13 +4964,13 @@ cpp_start_read (pfile, fname)\n   /* With -v, print the list of dirs to search.  */\n   if (opts->verbose) {\n     struct file_name_list *p;\n-    fprintf (stderr, \"#include \\\"...\\\" search starts here:\\n\");\n+    cpp_notice (\"#include \\\"...\\\" search starts here:\\n\");\n     for (p = opts->quote_include; p; p = p->next) {\n       if (p == opts->bracket_include)\n-\tfprintf (stderr, \"#include <...> search starts here:\\n\");\n+\tcpp_notice (\"#include <...> search starts here:\\n\");\n       fprintf (stderr, \" %s\\n\", p->name);\n     }\n-    fprintf (stderr, \"End of search list.\\n\");\n+    cpp_notice (\"End of search list.\\n\");\n   }\n \n   /* Copy the entire contents of the main input file into\n@@ -5654,7 +5664,7 @@ cpp_handle_option (pfile, argc, argv)\n       break;\n \t\n     case 'v':\n-      fprintf (stderr, \"GNU CPP version %s\", version_string);\n+      cpp_notice (\"GNU CPP version %s\", version_string);\n #ifdef TARGET_VERSION\n       TARGET_VERSION;\n #endif\n@@ -6213,42 +6223,42 @@ cpp_print_file_and_line (pfile)\n }\n \n static void\n-v_cpp_error (pfile, msg, ap)\n+v_cpp_error (pfile, msgid, ap)\n   cpp_reader *pfile;\n-  const char *msg;\n+  const char *msgid;\n   va_list ap;\n {\n   cpp_print_containing_files (pfile);\n   cpp_print_file_and_line (pfile);\n-  v_cpp_message (pfile, 1, msg, ap);\n+  v_cpp_message (pfile, 1, msgid, ap);\n }\n \n void\n-cpp_error VPROTO ((cpp_reader * pfile, const char *msg, ...))\n+cpp_error VPROTO ((cpp_reader * pfile, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n-  const char *msg;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START(ap, msg);\n+  VA_START(ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_error (pfile, msg, ap);\n+  v_cpp_error (pfile, msgid, ap);\n   va_end(ap);\n }\n \n /* Print error message but don't count it.  */\n \n static void\n-v_cpp_warning (pfile, msg, ap)\n+v_cpp_warning (pfile, msgid, ap)\n   cpp_reader *pfile;\n-  const char *msg;\n+  const char *msgid;\n   va_list ap;\n {\n   if (CPP_OPTIONS (pfile)->inhibit_warnings)\n@@ -6259,60 +6269,60 @@ v_cpp_warning (pfile, msg, ap)\n \n   cpp_print_containing_files (pfile);\n   cpp_print_file_and_line (pfile);\n-  v_cpp_message (pfile, 0, msg, ap);\n+  v_cpp_message (pfile, 0, msgid, ap);\n }\n \n void\n-cpp_warning VPROTO ((cpp_reader * pfile, const char *msg, ...))\n+cpp_warning VPROTO ((cpp_reader * pfile, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n   const char *msg;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, msg);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_warning (pfile, msg, ap);\n+  v_cpp_warning (pfile, msgid, ap);\n   va_end(ap);\n }\n \n /* Print an error message and maybe count it.  */\n \n void\n-cpp_pedwarn VPROTO ((cpp_reader * pfile, const char *msg, ...))\n+cpp_pedwarn VPROTO ((cpp_reader * pfile, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n-  const char *msg;\n+  const char *msgid;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, msg);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n   if (CPP_OPTIONS (pfile)->pedantic_errors)\n-    v_cpp_error (pfile, msg, ap);\n+    v_cpp_error (pfile, msgid, ap);\n   else\n-    v_cpp_warning (pfile, msg, ap);\n+    v_cpp_warning (pfile, msgid, ap);\n   va_end(ap);\n }\n \n static void\n-v_cpp_error_with_line (pfile, line, column, msg, ap)\n+v_cpp_error_with_line (pfile, line, column, msgid, ap)\n   cpp_reader * pfile;\n   int line;\n   int column;\n-  const char * msg;\n+  const char * msgid;\n   va_list ap;\n {\n   cpp_buffer *ip = cpp_file_buffer (pfile);\n@@ -6322,39 +6332,40 @@ v_cpp_error_with_line (pfile, line, column, msg, ap)\n   if (ip != NULL)\n     cpp_file_line_for_message (pfile, ip->nominal_fname, line, column);\n \n-  v_cpp_message (pfile, 1, msg, ap);\n+  v_cpp_message (pfile, 1, msgid, ap);\n }\n \n void\n-cpp_error_with_line VPROTO ((cpp_reader * pfile, int line, int column, const char *msg, ...))\n+cpp_error_with_line VPROTO ((cpp_reader * pfile, int line, int column,\n+\t\t\t     const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n   int line;\n   int column;\n-  const char *msg;\n+  const char *msgid;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, msg);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n   line = va_arg (ap, int);\n   column = va_arg (ap, int);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_error_with_line(pfile, line, column, msg, ap);\n+  v_cpp_error_with_line(pfile, line, column, msgid, ap);\n   va_end(ap);\n }\n \n static void\n-v_cpp_warning_with_line (pfile, line, column, msg, ap)\n+v_cpp_warning_with_line (pfile, line, column, msgid, ap)\n   cpp_reader * pfile;\n   int line;\n   int column;\n-  const char *msg;\n+  const char *msgid;\n   va_list ap;\n {\n   cpp_buffer *ip;\n@@ -6372,89 +6383,92 @@ v_cpp_warning_with_line (pfile, line, column, msg, ap)\n   if (ip != NULL)\n     cpp_file_line_for_message (pfile, ip->nominal_fname, line, column);\n \n-  v_cpp_message (pfile, 0, msg, ap);\n+  v_cpp_message (pfile, 0, msgid, ap);\n }  \n \n void\n-cpp_warning_with_line VPROTO ((cpp_reader * pfile, int line, int column, const char *msg, ...))\n+cpp_warning_with_line VPROTO ((cpp_reader * pfile, int line, int column,\n+\t\t\t       const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n   int line;\n   int column;\n-  const char *msg;\n+  const char *msgid;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, msg);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n   line = va_arg (ap, int);\n   column = va_arg (ap, int);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_cpp_warning_with_line (pfile, line, column, msg, ap);\n+  v_cpp_warning_with_line (pfile, line, column, msgid, ap);\n   va_end(ap);\n }\n \n void\n-cpp_pedwarn_with_line VPROTO ((cpp_reader * pfile, int line, int column, const char *msg, ...))\n+cpp_pedwarn_with_line VPROTO ((cpp_reader * pfile, int line, int column,\n+\t\t\t       const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n   int line;\n   int column;\n-  const char *msg;\n+  const char *msgid;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, msg);\n+  VA_START (ap, msgid);\n   \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n   line = va_arg (ap, int);\n   column = va_arg (ap, int);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n   if (CPP_OPTIONS (pfile)->pedantic_errors)\n-    v_cpp_error_with_line (pfile, column, line, msg, ap);\n+    v_cpp_error_with_line (pfile, column, line, msgid, ap);\n   else\n-    v_cpp_warning_with_line (pfile, line, column, msg, ap);\n+    v_cpp_warning_with_line (pfile, line, column, msgid, ap);\n   va_end(ap);\n }\n \n /* Report a warning (or an error if pedantic_errors)\n    giving specified file name and line number, not current.  */\n \n void\n-cpp_pedwarn_with_file_and_line VPROTO ((cpp_reader *pfile, char *file, int line, const char *msg, ...))\n+cpp_pedwarn_with_file_and_line VPROTO ((cpp_reader *pfile, char *file, int line,\n+\t\t\t\t\tconst char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   cpp_reader *pfile;\n   char *file;\n   int line;\n-  const char *msg;\n+  const char *msgid;\n #endif\n   va_list ap;\n   \n-  VA_START (ap, msg);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   pfile = va_arg (ap, cpp_reader *);\n   file = va_arg (ap, char *);\n   line = va_arg (ap, int);\n-  msg = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n   if (!CPP_OPTIONS (pfile)->pedantic_errors\n       && CPP_OPTIONS (pfile)->inhibit_warnings)\n     return;\n   if (file != NULL)\n     cpp_file_line_for_message (pfile, file, line, -1);\n-  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors, msg, ap);\n+  v_cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors, msgid, ap);\n   va_end(ap);\n }\n \n@@ -6485,7 +6499,7 @@ my_strerror (errnum)\n #endif\n \n   if (!result)\n-    result = \"undocumented I/O error\";\n+    result = \"errno = ?\";\n \n   return result;\n }"}, {"sha": "764114f388076b25c9fa83a600717ec2e860c3f1", "filename": "gcc/cppmain.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -30,6 +30,7 @@ extern char *getenv ();\n #endif /* not EMACS */\n \n #include \"cpplib.h\"\n+#include \"intl.h\"\n \n char *progname;\n \n@@ -68,6 +69,10 @@ main (argc, argv)\n   while (p != argv[0] && p[-1] != '/') --p;\n   progname = p;\n \n+  setlocale (LC_MESSAGES, \"\");\n+  bindtextdomain (PACKAGE, localedir);\n+  textdomain (PACKAGE);\n+\n   cpp_reader_init (&parse_in);\n   parse_in.opts = opts;\n "}, {"sha": "4e52bb46b0ece26dfd2bbb4dc4c5003f8cc0c117", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -8621,7 +8621,7 @@ cse_main (f, nregs, after_loop, file)\n       max_qty = val.nsets * 2;\n       \n       if (file)\n-\tfprintf (file, \";; Processing block from %d to %d, %d sets.\\n\",\n+\tfnotice (file, \";; Processing block from %d to %d, %d sets.\\n\",\n \t\t INSN_UID (insn), val.last ? INSN_UID (val.last) : 0,\n \t\t val.nsets);\n "}, {"sha": "4b53a55e65cc2c0dc85b8283d482fd85c7ed708b", "filename": "gcc/expr.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -4771,6 +4771,9 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n   else\n     {\n       mode = TYPE_MODE (TREE_TYPE (exp));\n+      if (mode == BLKmode)\n+\tsize_tree = TYPE_SIZE (TREE_TYPE (exp));\n+\n       *pbitsize = GET_MODE_BITSIZE (mode);\n       *punsignedp = TREE_UNSIGNED (TREE_TYPE (exp));\n     }\n@@ -5600,11 +5603,17 @@ expand_expr (exp, target, tmode, modifier)\n \t    p->forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t\t  label_rtx (exp),\n \t\t\t\t\t\t  p->forced_labels);\n+\t    p->addresses_labels = 1;\n \t    pop_obstacks ();\n \t  }\n-\telse if (modifier == EXPAND_INITIALIZER)\n-\t  forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t     label_rtx (exp), forced_labels);\n+\telse\n+\t  {\n+\t    current_function_addresses_labels = 1;\n+\t    if (modifier == EXPAND_INITIALIZER)\n+\t      forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t label_rtx (exp),\n+\t\t\t\t\t\t forced_labels);\n+\t  }\n \ttemp = gen_rtx_MEM (FUNCTION_MODE,\n \t\t\t    gen_rtx_LABEL_REF (Pmode, label_rtx (exp)));\n \tif (function != current_function_decl\n@@ -6012,7 +6021,7 @@ expand_expr (exp, target, tmode, modifier)\n \n     case EXIT_BLOCK_EXPR:\n       if (EXIT_BLOCK_RETURN (exp))\n-\treally_sorry (\"returned value in block_exit_expr\");\n+\tsorry (\"returned value in block_exit_expr\");\n       expand_goto (LABELED_BLOCK_LABEL (EXIT_BLOCK_LABELED_BLOCK (exp)));\n       return const0_rtx;\n "}, {"sha": "74c36c2467b923433bacd98196c85fd1ee473154", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -64,6 +64,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"reload.h\"\n+#include \"intl.h\"\n \n /* Get N_SLINE and N_SOL from stab.h if we can expect the file to exist.  */\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n@@ -3298,13 +3299,13 @@ alter_cond (cond)\n    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */\n \n void\n-output_operand_lossage (str)\n-  const char *str;\n+output_operand_lossage (msgid)\n+     const char *msgid;\n {\n   if (this_is_asm_operands)\n-    error_for_asm (this_is_asm_operands, \"invalid `asm': %s\", str);\n+    error_for_asm (this_is_asm_operands, \"invalid `asm': %s\", _(msgid));\n   else\n-    fatal (\"Internal compiler error, output_operand_lossage `%s'\", str);\n+    fatal (\"Internal compiler error, output_operand_lossage `%s'\", _(msgid));\n }\n \f\n /* Output of assembler code from a template, and its subroutines.  */"}, {"sha": "35942d25db6a3a3aa537c05f36bda8ab24aa4524", "filename": "gcc/fix-header.c", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1311,71 +1311,6 @@ main (argc, argv)\n   return 0;\n }\n \f\n-/* Stub error functions.  These replace cpperror.c,\n-   because we want to suppress error messages.  */\n-\n-void\n-cpp_file_line_for_message (pfile, filename, line, column)\n-     cpp_reader * pfile ATTRIBUTE_UNUSED;\n-     char *filename;\n-     int line, column;\n-{\n-  if (!verbose)\n-    return;\n-  if (column > 0)\n-    fprintf (stderr, \"%s:%d:%d: \", filename, line, column);\n-  else\n-    fprintf (stderr, \"%s:%d: \", filename, line);\n-}\n-\n-void\n-cpp_print_containing_files (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-}\n-\n-/* IS_ERROR is 2 for fatal error, 1 for error, 0 for warning */\n-\n-void\n-v_cpp_message (pfile, is_error, msg, ap)\n-     cpp_reader *pfile;\n-     int is_error;\n-     const char *msg;\n-     va_list ap;\n-{\n-  if (is_error == 1)\n-    pfile->errors++;\n-  else if (is_error > 1)\n-    pfile->errors = CPP_FATAL_LIMIT;\n-  if (!verbose)\n-    return;\n-  if (!is_error)\n-    fprintf (stderr, \"warning: \");\n-  vfprintf (stderr, msg, ap);\n-  fprintf (stderr, \"\\n\");\n-}\n-\n-void\n-cpp_message VPROTO ((cpp_reader *pfile, int is_error, const char *msg, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  int is_error;\n-  const char *msg;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msg);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  is_error = va_arg (ap, const int);\n-  msg = va_arg (ap, const char *);\n-#endif\n-\n-  v_cpp_message(pfile, is_error, msg, ap);\n-  va_end(ap);\n-}\n \n static void\n v_fatal (str, ap)\n@@ -1406,32 +1341,3 @@ fatal VPROTO ((const char *str, ...))\n   v_fatal(str, ap);\n   va_end(ap);\n }\n-\n-void\n-cpp_fatal VPROTO ((cpp_reader * pfile ATTRIBUTE_UNUSED, const char *str, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader * pfile;\n-  const char *str;\n-#endif\n-  va_list ap;\n-  \n-  VA_START(ap, str);\n-\n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  str = va_arg (ap, const char *);\n-#endif\n-\n-  v_fatal(str, ap);\n-  va_end(ap);\n-}\n-\n-void\n-cpp_pfatal_with_name (pfile, name)\n-     cpp_reader *pfile;\n-     const char *name;\n-{\n-  cpp_perror_with_name (pfile, name);\n-  exit (FATAL_EXIT_CODE);\n-}"}, {"sha": "9db5e19f42d8bf26037da04b83a3d205f6b9d1f0", "filename": "gcc/flags.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -276,10 +276,14 @@ extern int flag_no_peephole;\n \n extern int flag_volatile;\n \n-/* Nonzero means treat all global and extern variables as global.  */\n+/* Nonzero means treat all global and extern variables as volatile.  */\n \n extern int flag_volatile_global;\n \n+/* Nonzero means treat all static variables as volatile.  */\n+\n+extern int flag_volatile_static;\n+\n /* Nonzero allows GCC to violate some IEEE or ANSI rules regarding math\n    operations in the interest of optimization.  For example it allows\n    GCC to assume arguments to sqrt are nonnegative numbers, allowing"}, {"sha": "dc7913937245130b89b0120669916012ee23d573", "filename": "gcc/floatlib.c", "status": "modified", "additions": 367, "deletions": 260, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffloatlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffloatlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffloatlib.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -17,6 +17,7 @@ host such as a VAX.\n \n If you'd like to work on completing this, please talk to rms@gnu.ai.mit.edu.\n \n+--> Double precision floating support added by James Carlson on 20 April 1998.\n \n **\n ** Pat Wood\n@@ -54,7 +55,6 @@ If you'd like to work on completing this, please talk to rms@gnu.ai.mit.edu.\n */\n \n /* the following deal with IEEE single-precision numbers */\n-#define D_PHANTOM_BIT   0x00100000\n #define EXCESS\t\t126\n #define SIGNBIT\t\t0x80000000\n #define HIDDEN\t\t(1 << 23)\n@@ -70,10 +70,12 @@ If you'd like to work on completing this, please talk to rms@gnu.ai.mit.edu.\n #define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n #define MANTD(fp)\t(((((fp.l.upper) & 0xFFFFF) | HIDDEND) << 10) | \\\n \t\t\t\t(fp.l.lower >> 22))\n+#define HIDDEND_LL\t((long long)1 << 52)\n+#define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n+#define PACKD_LL(s,e,m)\t(((long long)((s)+((e)<<20))<<32)|(m))\n \n /* define SWAP for 386/960 reverse-byte-order brain-damaged CPUs */\n-union double_long\n-  {\n+union double_long {\n     double d;\n #ifdef SWAP\n     struct {\n@@ -86,46 +88,16 @@ union double_long\n       unsigned long lower;\n     } l;\n #endif\n-  };\n+    long long ll;\n+};\n \n union float_long\n   {\n     float f;\n     long l;\n   };\n \n-   struct _ieee {\n-#ifdef SWAP\n-      unsigned mantissa2 : 32;\n-      unsigned mantissa1 : 20;\n-      unsigned exponent  : 11;\n-      unsigned sign      : 1;\n-#else\n-      unsigned exponent  : 11;\n-      unsigned sign      : 1;\n-      unsigned mantissa2 : 32;\n-      unsigned mantissa1 : 20;\n-#endif\n-   };\n-\n-   union _doubleu {\n-      double d;\n-      struct _ieee ieee;\n-#ifdef SWAP\n-      struct {\n-         unsigned long lower;\n-         long upper;\n-      } l;\n-#else\n-      struct {\n-         long upper;\n-         unsigned long lower;\n-      } l;\n-#endif\n-   };\n-\n /* add two floats */\n-\n float\n __addsf3 (float a1, float a2)\n {\n@@ -138,18 +110,22 @@ __addsf3 (float a1, float a2)\n   fl2.f = a2;\n \n   /* check for zero args */\n-  if (!fl1.l)\n-    return (fl2.f);\n+  if (!fl1.l) {\n+      fl1.f = fl2.f;\n+      goto test_done;\n+  }\n   if (!fl2.l)\n-    return (fl1.f);\n+      goto test_done;\n \n   exp1 = EXP (fl1.l);\n   exp2 = EXP (fl2.l);\n \n   if (exp1 > exp2 + 25)\n-    return (fl1.l);\n-  if (exp2 > exp1 + 25)\n-    return (fl2.l);\n+      goto test_done;\n+  if (exp2 > exp1 + 25) {\n+      fl1.f = fl2.f;\n+      goto test_done;\n+  }\n \n   /* do everything in excess precision so's we can round later */\n   mant1 = MANT (fl1.l) << 6;\n@@ -176,8 +152,10 @@ __addsf3 (float a1, float a2)\n       mant1 = -mant1;\n       sign = SIGNBIT;\n     }\n-  else if (!mant1)\n-    return (0);\n+  else if (!mant1) {\n+      fl1.f = 0;\n+      goto test_done;\n+  }\n \n   /* normalize up */\n   while (!(mant1 & 0xE0000000))\n@@ -211,11 +189,11 @@ __addsf3 (float a1, float a2)\n \n   /* pack up and go home */\n   fl1.l = PACK (sign, exp1, mant1);\n+test_done:\n   return (fl1.f);\n }\n \n /* subtract two floats */\n-\n float\n __subsf3 (float a1, float a2)\n {\n@@ -236,7 +214,6 @@ __subsf3 (float a1, float a2)\n }\n \n /* compare two floats */\n-\n long\n __cmpsf2 (float a1, float a2)\n {\n@@ -258,7 +235,6 @@ __cmpsf2 (float a1, float a2)\n }\n \n /* multiply two floats */\n-\n float\n __mulsf3 (float a1, float a2)\n {\n@@ -270,8 +246,10 @@ __mulsf3 (float a1, float a2)\n   fl1.f = a1;\n   fl2.f = a2;\n \n-  if (!fl1.l || !fl2.l)\n-    return (0);\n+  if (!fl1.l || !fl2.l) {\n+      fl1.f = 0;\n+      goto test_done;\n+  }\n \n   /* compute sign and exponent */\n   sign = SIGN (fl1.l) ^ SIGN (fl2.l);\n@@ -286,29 +264,34 @@ __mulsf3 (float a1, float a2)\n   result += ((fl1.l & 0xFF) * (fl2.l >> 8)) >> 8;\n   result += ((fl2.l & 0xFF) * (fl1.l >> 8)) >> 8;\n \n-  if (result & 0x80000000)\n+  result >>= 2;\n+  if (result & 0x20000000)\n     {\n       /* round */\n-      result += 0x80;\n-      result >>= 8;\n+      result += 0x20;\n+      result >>= 6;\n     }\n   else\n     {\n       /* round */\n-      result += 0x40;\n-      result >>= 7;\n+      result += 0x10;\n+      result >>= 5;\n       exp--;\n     }\n+  if (result & (HIDDEN<<1)) {\n+    result >>= 1;\n+    exp++;\n+  }\n \n   result &= ~HIDDEN;\n \n   /* pack up and go home */\n   fl1.l = PACK (sign, exp, result);\n+test_done:\n   return (fl1.f);\n }\n \n /* divide two floats */\n-\n float\n __divsf3 (float a1, float a2)\n {\n@@ -375,7 +358,6 @@ __divsf3 (float a1, float a2)\n }\n \n /* convert int to double */\n-\n double\n __floatsidf (register long a1)\n {\n@@ -415,8 +397,50 @@ __floatsidf (register long a1)\n   return (dl.d);\n }\n \n-/* negate a float */\n+double\n+__floatdidf (register long long a1)\n+{\n+    register int exp = 63 + EXCESSD;\n+    union double_long dl;\n+\n+    dl.l.upper = dl.l.lower = 0;\n+    if (a1 == 0)\n+\treturn (dl.d);\n+\n+    if (a1 < 0) {\n+\tdl.l.upper = SIGNBIT;\n+\ta1 = -a1;\n+    }\n+\n+    while (a1 < (long long)1<<54) {\n+\ta1 <<= 8;\n+\texp -= 8;\n+    }\n+    while (a1 < (long long)1<<62) {\n+\ta1 <<= 1;\n+\texp -= 1;\n+    }\n+\n+  /* pack up and go home */\n+    dl.ll |= (a1 >> 10) & ~HIDDEND_LL;\n+    dl.l.upper |= exp << 20;\n+\n+    return (dl.d);\n+}\n \n+float\n+__floatsisf (register long a1)\n+{\n+    (float)__floatsidf(a1);\n+}\n+\n+float\n+__floatdisf (register long long a1)\n+{\n+    (float)__floatdidf(a1);\n+}\n+\n+/* negate a float */\n float\n __negsf2 (float a1)\n {\n@@ -431,7 +455,6 @@ __negsf2 (float a1)\n }\n \n /* negate a double */\n-\n double\n __negdf2 (double a1)\n {\n@@ -447,7 +470,6 @@ __negdf2 (double a1)\n }\n \n /* convert float to double */\n-\n double\n __extendsfdf2 (float a1)\n {\n@@ -473,7 +495,6 @@ __extendsfdf2 (float a1)\n }\n \n /* convert double to float */\n-\n float\n __truncdfsf2 (double a1)\n {\n@@ -485,7 +506,7 @@ __truncdfsf2 (double a1)\n   dl1.d = a1;\n \n   if (!dl1.l.upper && !dl1.l.lower)\n-    return (0);\n+    return (float)(0);\n \n   exp = EXPD (dl1) - EXCESSD + EXCESS;\n \n@@ -497,7 +518,7 @@ __truncdfsf2 (double a1)\n   mant >>= 1;\n \n   /* did the round overflow? */\n-  if (mant & 0xFF000000)\n+  if (mant & 0xFE000000)\n     {\n       mant >>= 1;\n       exp++;\n@@ -511,7 +532,6 @@ __truncdfsf2 (double a1)\n }\n \n /* compare two doubles */\n-\n long\n __cmpdf2 (double a1, double a2)\n {\n@@ -537,7 +557,6 @@ __cmpdf2 (double a1, double a2)\n }\n \n /* convert double to int */\n-\n long\n __fixdfsi (double a1)\n {\n@@ -554,7 +573,7 @@ __fixdfsi (double a1)\n   l = MANTD (dl1);\n \n   if (exp > 0)\n-    return (0x7FFFFFFF | SIGND (dl1)); /* largest integer */\n+      return SIGND(dl1) ? (1<<31) : ((1ul<<31)-1);\n \n   /* shift down until exp = 0 or l = 0 */\n   if (exp < 0 && exp > -32 && l)\n@@ -565,10 +584,41 @@ __fixdfsi (double a1)\n   return (SIGND (dl1) ? -l : l);\n }\n \n-/* convert double to unsigned int */\n+/* convert double to int */\n+long long\n+__fixdfdi (double a1)\n+{\n+    register union double_long dl1;\n+    register int exp;\n+    register long long l;\n+\n+    dl1.d = a1;\n+\n+    if (!dl1.l.upper && !dl1.l.lower)\n+\treturn (0);\n+\n+    exp = EXPD (dl1) - EXCESSD - 64;\n+    l = MANTD_LL(dl1);\n+\n+    if (exp > 0) {\n+\tl = (long long)1<<63;\n+\tif (!SIGND(dl1))\n+\t    l--;\n+\treturn l;\n+    }\n+\n+    /* shift down until exp = 0 or l = 0 */\n+    if (exp < 0 && exp > -64 && l)\n+\tl >>= -exp;\n+    else\n+\treturn (0);\n+\n+    return (SIGND (dl1) ? -l : l);\n+}\n \n-unsigned\n-long __fixunsdfsi (double a1)\n+/* convert double to unsigned int */\n+unsigned long\n+__fixunsdfsi (double a1)\n {\n   register union double_long dl1;\n   register int exp;\n@@ -583,7 +633,7 @@ long __fixunsdfsi (double a1)\n   l = (((((dl1.l.upper) & 0xFFFFF) | HIDDEND) << 11) | (dl1.l.lower >> 21));\n \n   if (exp > 0)\n-    return (0xFFFFFFFF);\t/* largest integer */\n+    return (0xFFFFFFFFul);\t/* largest integer */\n \n   /* shift down until exp = 0 or l = 0 */\n   if (exp < 0 && exp > -32 && l)\n@@ -594,245 +644,302 @@ long __fixunsdfsi (double a1)\n   return (l);\n }\n \n-/* For now, the hard double-precision routines simply\n-   punt and do it in single */\n-/* addtwo doubles */\n-\n-double\n-__adddf3 (double a1, double a2)\n-{\n-  return ((float) a1 + (float) a2);\n-}\n-\n-/* subtract two doubles */\n-\n-double\n-__subdf3 (double a1, double a2)\n-{\n-  return ((float) a1 - (float) a2);\n-}\n-\n-/* multiply two doubles */\n-\n-double\n-__muldf3 (double a1, double a2)\n+/* convert double to unsigned int */\n+unsigned long long\n+__fixunsdfdi (double a1)\n {\n-  return ((float) a1 * (float) a2);\n-}\n-\n-/*\n- *\n- * Name:   Barrett Richardson\n- * E-mail: barrett@iglou.com\n- * When:   Thu Dec 15 10:31:11 EST 1994\n- *\n- *    callable function:\n- *\n- *       double __divdf3(double a1, double a2);\n- *\n- *       Does software divide of a1 / a2.\n- *\n- *       Based largely on __divsf3() in floatlib.c in the gcc\n- *       distribution.\n- *\n- *    Purpose: To be used in conjunction with the -msoft-float\n- *             option of gcc. You should be able to tack it to the\n- *             end of floatlib.c included in the gcc distribution,\n- *             and delete the __divdf3() already there which just \n- *             calls the single precision function (or may just\n- *             use the floating point processor with some configurations).\n- *\n- *   You may use this code for whatever your heart desires.\n- */\n+    register union double_long dl1;\n+    register int exp;\n+    register unsigned long long l;\n \n+    dl1.d = a1;\n \n+    if (dl1.ll == 0)\n+\treturn (0);\n \n+    exp = EXPD (dl1) - EXCESSD - 64;\n \n-/*\n- * Compare the mantissas of two doubles.\n- * Each mantissa is in two longs.\n- * \n- *   return      1   if x1's mantissa is greater than x2's\n- *              -1   if x1's mantissa is less than x2's\n- *               0   if the two mantissa's are equal.\n- *\n- *   The Mantissas won't fit into a 4 byte word, so they are\n- *   broken up into two parts.\n- *\n- *   This function is used internally by __divdf3()\n- */\n-\n-int\n-__dcmp (long x1m1, long x1m2, long x2m1, long x2m2)\n-{\n-   if (x1m1 > x2m1)\n-      return 1;\n-\n-   if (x1m1 < x2m1)\n-      return -1;\n+    l = dl1.ll;\n \n- /*  If the first word in the two mantissas were equal check the second word */\n+    if (exp > 0)\n+\treturn (unsigned long long)-1;\n \n-   if (x1m2 > x2m2)\n-      return 1;\n+    /* shift down until exp = 0 or l = 0 */\n+    if (exp < 0 && exp > -64 && l)\n+\tl >>= -exp;\n+    else\n+\treturn (0);\n \n-   if (x1m2 < x2m2)\n-      return -1;\n-\n-   return 0;\n+    return (l);\n }\n \n-\n-/* divide two doubles */\n-\n+/* addtwo doubles */\n double\n-__divdf3 (double a1, double a2)\n+__adddf3 (double a1, double a2)\n {\n+    register long long mant1, mant2;\n+    register union double_long fl1, fl2;\n+    register int exp1, exp2;\n+    int sign = 0;\n+\n+    fl1.d = a1;\n+    fl2.d = a2;\n+\n+    /* check for zero args */\n+    if (!fl2.ll)\n+\tgoto test_done;\n+    if (!fl1.ll) {\n+\tfl1.d = fl2.d;\n+\tgoto test_done;\n+    }\n \n-   int  sign,\n-        exponent,\n-        bit_bucket;\n-\n-   register unsigned long mantissa1,\n-                          mantissa2,\n-                          x1m1,\n-                          x1m2,\n-                          x2m1,\n-                          x2m2,\n-                          mask;\n-\n-   union _doubleu x1,\n-                  x2,\n-                  result;\n-\n-\n-   x1.d = a1;\n-   x2.d = a2;\n-\n-   exponent = x1.ieee.exponent - x2.ieee.exponent + EXCESSD;\n-\n-   sign = x1.ieee.sign ^ x2.ieee.sign;\n-\n-   x2.ieee.sign = 0;  /* don't want the sign bit to affect any zero */\n-                      /* comparisons when checking for zero divide  */\n-\n-   if (!x2.l.lower && !x2.l.upper) { /* check for zero divide */\n-      result.l.lower = 0x0;\n-      if (sign)\n-         result.l.upper = 0xFFF00000;   /* negative infinity */\n-      else\n-         result.l.upper = 0x7FF00000;   /* positive infinity */\n-      return result.d;\n-   }\n+    exp1 = EXPD(fl1);\n+    exp2 = EXPD(fl2);\n \n-   if (!x1.l.upper && !x1.l.lower)  /* check for 0.0 numerator */\n-      return (0.0);\n+    if (exp1 > exp2 + 54)\n+\tgoto test_done;\n+    if (exp2 > exp1 + 54) {\n+\tfl1.d = fl2.d;\n+\tgoto test_done;\n+    }\n \n-   x1m1 = x1.ieee.mantissa1 | D_PHANTOM_BIT;  /* turn on phantom bit */\n-   x1m2 = x1.ieee.mantissa2;\n+    /* do everything in excess precision so's we can round later */\n+    mant1 = MANTD_LL(fl1) << 9;\n+    mant2 = MANTD_LL(fl2) << 9;\n \n-   x2m1 = x2.ieee.mantissa1 | D_PHANTOM_BIT;  /* turn on phantom bit */\n-   x2m2 = x2.ieee.mantissa2;\n+    if (SIGND(fl1))\n+\tmant1 = -mant1;\n+    if (SIGND(fl2))\n+\tmant2 = -mant2;\n \n-   if (__dcmp(x1m1,x1m2,x2m1,x2m2) < 0) {\n+    if (exp1 > exp2)\n+\tmant2 >>= exp1 - exp2;\n+    else {\n+\tmant1 >>= exp2 - exp1;\n+\texp1 = exp2;\n+    }\n+    mant1 += mant2;\n+\n+    if (mant1 < 0) {\n+\tmant1 = -mant1;\n+\tsign = SIGNBIT;\n+    } else if (!mant1) {\n+\tfl1.d = 0;\n+\tgoto test_done;\n+    }\n \n-   /* if x1's mantissa is less than x2's shift it left one and decrement */\n-   /* the exponent to accommodate the change in the mantissa             */\n+    /* normalize up */\n+    while (!(mant1 & ((long long)7<<61))) {\n+\tmant1 <<= 1;\n+\texp1--;\n+    }\n \n-      x1m1 <<= 1;               /*                          */\n-      bit_bucket = x1m2 >> 31;  /*  Shift mantissa left one */\n-      x1m1 |= bit_bucket;       /*                          */\n-      x1m2 <<= 1;               /*                          */\n+    /* normalize down? */\n+    if (mant1 & ((long long)3<<62)) {\n+\tmant1 >>= 1;\n+\texp1++;\n+    }\n \n-      exponent--;\n-   }\n+    /* round to even */\n+    mant1 += (mant1 & (1<<9)) ? (1<<8) : ((1<<8)-1);\n \n+    /* normalize down? */\n+    if (mant1 & ((long long)3<<62)) {\n+\tmant1 >>= 1;\n+\texp1++;\n+    }\n \n-   mantissa1 = 0;\n-   mantissa2 = 0;\n+    /* lose extra precision */\n+    mant1 >>= 9;\n \n+    /* turn off hidden bit */\n+    mant1 &= ~HIDDEND_LL;\n \n-  /* Get the first part of the results mantissa using successive */\n-  /* subtraction.                                                */\n+    /* pack up and go home */\n+    fl1.ll = PACKD_LL(sign,exp1,mant1);\n \n-   mask = 0x00200000;\n-   while (mask) {\n+test_done:\n+    return (fl1.d);\n+}\n \n-      if (__dcmp(x1m1,x1m2,x2m1,x2m2) >= 0) {\n+/* subtract two doubles */\n+double\n+__subdf3 (double a1, double a2)\n+{\n+    register union double_long fl1, fl2;\n+\n+    fl1.d = a1;\n+    fl2.d = a2;\n+\n+    /* check for zero args */\n+    if (!fl2.ll)\n+\treturn (fl1.d);\n+    /* twiddle sign bit and add */\n+    fl2.l.upper ^= SIGNBIT;\n+    if (!fl1.ll)\n+\treturn (fl2.d);\n+    return __adddf3 (a1, fl2.d);\n+}\n \n-     /* subtract x2's mantissa from x1's */\n+/* multiply two doubles */\n+double\n+__muldf3 (double a1, double a2)\n+{\n+    register union double_long fl1, fl2;\n+    register unsigned long long result;\n+    register int exp;\n+    int sign;\n \n-         mantissa1 |= mask;   /* turn on a bit in the result */\n+    fl1.d = a1;\n+    fl2.d = a2;\n \n-         if (x2m2 > x1m2)\n-            x1m1--;\n-         x1m2 -= x2m2; \n-         x1m1 -= x2m1;\n-      }\n+    if (!fl1.ll || !fl2.ll) {\n+\tfl1.d = 0;\n+\tgoto test_done;\n+    }\n \n-      x1m1 <<= 1;               /*                          */\n-      bit_bucket = x1m2 >> 31;  /*  Shift mantissa left one */\n-      x1m1 |= bit_bucket;       /*                          */\n-      x1m2 <<= 1;               /*                          */\n+    /* compute sign and exponent */\n+    sign = SIGND(fl1) ^ SIGND(fl2);\n+    exp = EXPD(fl1) - EXCESSD;\n+    exp += EXPD(fl2);\n+\n+    fl1.ll = MANTD_LL(fl1);\n+    fl2.ll = MANTD_LL(fl2);\n+\n+  /* the multiply is done as one 31x31 multiply and two 31x21 multiples */\n+    result = (fl1.ll >> 21) * (fl2.ll >> 21);\n+    result += ((fl1.ll & 0x1FFFFF) * (fl2.ll >> 21)) >> 21;\n+    result += ((fl2.ll & 0x1FFFFF) * (fl1.ll >> 21)) >> 21;\n+\n+    result >>= 2;\n+    if (result & ((long long)1<<61)) {\n+\t/* round */\n+\tresult += 1<<8;\n+\tresult >>= 9;\n+    } else {\n+\t/* round */\n+\tresult += 1<<7;\n+\tresult >>= 8;\n+\texp--;\n+    }\n+    if (result & (HIDDEND_LL<<1)) {\n+\tresult >>= 1;\n+\texp++;\n+    }\n \n-      mask >>= 1;\n-   }\n+    result &= ~HIDDEND_LL;\n \n-  /* Get the second part of the results mantissa using successive */\n-  /* subtraction.                                                 */\n+    /* pack up and go home */\n+    fl1.ll = PACKD_LL(sign,exp,result);\n+test_done:\n+    return (fl1.d);\n+}\n \n-   mask = 0x80000000;\n-   while (mask) {\n+/* divide two doubles */\n+double\n+__divdf3 (double a1, double a2)\n+{\n+    register union double_long fl1, fl2;\n+    register long long mask,result;\n+    register int exp, sign;\n+\n+    fl1.d = a1;\n+    fl2.d = a2;\n+\n+    /* subtract exponents */\n+    exp = EXPD(fl1) - EXPD(fl2) + EXCESSD;\n+\n+    /* compute sign */\n+    sign = SIGND(fl1) ^ SIGND(fl2);\n+\n+    /* numerator zero??? */\n+    if (fl1.ll == 0) {\n+\t/* divide by zero??? */\n+\tif (fl2.ll == 0)\n+\t    fl1.ll = ((unsigned long long)1<<63)-1;\t/* NaN */\n+\telse\n+\t    fl1.ll = 0;\n+\tgoto test_done;\n+    }\n \n-      if (__dcmp(x1m1,x1m2,x2m1,x2m2) >= 0) {\n+    /* return +Inf or -Inf */\n+    if (fl2.ll == 0) {\n+\tfl1.ll = PACKD_LL(SIGND(fl1),2047,0);\n+\tgoto test_done;\n+    }\n \n-     /* subtract x2's mantissa from x1's */\n \n-         mantissa2 |= mask;   /* turn on a bit in the result */\n+    /* now get mantissas */\n+    fl1.ll = MANTD_LL(fl1);\n+    fl2.ll = MANTD_LL(fl2);\n \n-         if (x2m2 > x1m2)\n-            x1m1--;\n-         x1m2 -= x2m2; \n-         x1m1 -= x2m1;\n-      }\n-      x1m1 <<= 1;               /*                          */\n-      bit_bucket = x1m2 >> 31;  /*  Shift mantissa left one */\n-      x1m1 |= bit_bucket;       /*                          */\n-      x1m2 <<= 1;               /*                          */\n+    /* this assures we have 54 bits of precision in the end */\n+    if (fl1.ll < fl2.ll) {\n+\tfl1.ll <<= 1;\n+\texp--;\n+    }\n \n-      mask >>= 1;\n-   }\n+    /* now we perform repeated subtraction of fl2.ll from fl1.ll */\n+    mask = (long long)1<<53;\n+    result = 0;\n+    while (mask) {\n+\tif (fl1.ll >= fl2.ll)\n+\t{\n+\t    result |= mask;\n+\t    fl1.ll -= fl2.ll;\n+\t}\n+\tfl1.ll <<= 1;\n+\tmask >>= 1;\n+    }\n \n-  /* round up by adding 1 to mantissa */\n+    /* round */\n+    result += 1;\n \n-   if (mantissa2 == 0xFFFFFFFF) {  /* check for over flow */\n+    /* normalize down */\n+    exp++;\n+    result >>= 1;\n \n-   /* spill if overflow */\n+    result &= ~HIDDEND_LL;\n \n-      mantissa2 = 0;\n-      mantissa1++;\n-   }\n-   else\n-      mantissa2++;\n+    /* pack up and go home */\n+    fl1.ll = PACKD_LL(sign, exp, result);\n \n-   exponent++;   /* increment exponent (mantissa must be shifted right */\n-                 /* also)                                              */\n+test_done:\n+    return (fl1.d);\n+}\n \n- /* shift mantissa right one and assume a phantom bit (which really gives */\n- /* 53 bits of precision in the mantissa)                                 */\n+int\n+__gtdf2 (double a1, double a2)\n+{\n+    return __cmpdf2 ((float) a1, (float) a2) > 0;\n+}\n \n-   mantissa2 >>= 1;\n-   bit_bucket = mantissa1 & 1;\n-   mantissa2 |= (bit_bucket << 31);\n-   mantissa1 >>= 1;\n+int\n+__gedf2 (double a1, double a2)\n+{\n+    return (__cmpdf2 ((float) a1, (float) a2) >= 0) - 1;\n+}\n \n-  /* put all the info into the result */\n+int\n+__ltdf2 (double a1, double a2)\n+{\n+    return - (__cmpdf2 ((float) a1, (float) a2) < 0);\n+}\n \n-   result.ieee.exponent  = exponent;\n-   result.ieee.sign      = sign;\n-   result.ieee.mantissa1 = mantissa1;\n-   result.ieee.mantissa2 = mantissa2;\n+int\n+__ledf2 (double a1, double a2)\n+{\n+    return __cmpdf2 ((float) a1, (float) a2) > 0;\n+}\n \n+int\n+__eqdf2 (double a1, double a2)\n+{\n+    return *(long long *) &a1 == *(long long *) &a2;\n+}\n \n-   return result.d;\n+int\n+__nedf2 (double a1, double a2)\n+{\n+    return *(long long *) &a1 != *(long long *) &a2;\n }"}, {"sha": "6b48fa6e7282479ac967dc340f6b22b47c6e224c", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -3400,9 +3400,10 @@ print_rtl_with_bb (outf, rtx_first)\n \t      putc ('\\n', outf);\n \t    }\n \n-\t  if (in_bb_p[ INSN_UID(tmp_rtx)] == NOT_IN_BB\n+\t  if (in_bb_p[INSN_UID(tmp_rtx)] == NOT_IN_BB\n \t      && GET_CODE (tmp_rtx) != NOTE\n-\t      && GET_CODE (tmp_rtx) != BARRIER)\n+\t      && GET_CODE (tmp_rtx) != BARRIER\n+\t      && ! obey_regdecls)\n \t    fprintf (outf, \";; Insn is not within a basic block\\n\");\n \t  else if (in_bb_p[ INSN_UID(tmp_rtx)] == IN_MULTIPLE_BB)\n \t    fprintf (outf, \";; Insn is in multiple basic blocks\\n\");"}, {"sha": "2beab08c3aa1210370495dc34cc1bdeefe3cf22a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -96,6 +96,7 @@ static tree fold_truthop\tPROTO((enum tree_code, tree, tree, tree));\n static tree strip_compound_expr PROTO((tree, tree));\n static int multiple_of_p\tPROTO((tree, tree, tree));\n static tree constant_boolean_node PROTO((int, tree));\n+static int count_cond\t\tPROTO((tree, int));\n \n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n@@ -2760,8 +2761,8 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \t\t\t\t\tconvert (unsigned_type, rhs),\n \t\t\t\t\tsize_int (lbitsize), 0)))\n \t{\n-\t  warning (\"comparison is always %s due to width of bitfield\",\n-\t\t   code == NE_EXPR ? \"one\" : \"zero\");\n+\t  warning (\"comparison is always %d due to width of bitfield\",\n+\t\t   code == NE_EXPR);\n \t  return convert (compare_type,\n \t\t\t  (code == NE_EXPR\n \t\t\t   ? integer_one_node : integer_zero_node));\n@@ -2773,8 +2774,8 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \t\t\t      size_int (lbitsize - 1), 0);\n       if (! integer_zerop (tem) && ! integer_all_onesp (tem))\n \t{\n-\t  warning (\"comparison is always %s due to width of bitfield\",\n-\t\t   code == NE_EXPR ? \"one\" : \"zero\");\n+\t  warning (\"comparison is always %d due to width of bitfield\",\n+\t\t   code == NE_EXPR);\n \t  return convert (compare_type,\n \t\t\t  (code == NE_EXPR\n \t\t\t   ? integer_one_node : integer_zero_node));\n@@ -3541,7 +3542,6 @@ fold_range_test (exp)\n \t}\n     }\n \n-\n   return 0;\n }\n \f\n@@ -3804,8 +3804,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t\t\t\t\t\t      type, ll_mask)),\n \t\t\t\t\t0)))\n \t{\n-\t  warning (\"comparison is always %s\",\n-\t\t   wanted_code == NE_EXPR ? \"one\" : \"zero\");\n+\t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n \t  \n \t  return convert (truth_type,\n \t\t\t  wanted_code == NE_EXPR\n@@ -3822,9 +3821,8 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t\t\t\t\t\t      type, rl_mask)),\n \t\t\t\t\t0)))\n \t{\n-\t  warning (\"comparison is always %s\",\n-\t\t   wanted_code == NE_EXPR ? \"one\" : \"zero\");\n-\t  \n+\t  warning (\"comparison is always %d\", wanted_code == NE_EXPR);\n+\n \t  return convert (truth_type,\n \t\t\t  wanted_code == NE_EXPR\n \t\t\t  ? integer_one_node : integer_zero_node);\n@@ -3922,7 +3920,7 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t}\n       else\n \t{\n-\t  warning (\"`and' of mutually exclusive equal-tests is always zero\");\n+\t  warning (\"`and' of mutually exclusive equal-tests is always 0\");\n \t  return convert (truth_type, integer_zero_node);\n \t}\n     }\n@@ -3999,6 +3997,27 @@ constant_boolean_node (value, type)\n     }\n }\n \n+/* Utility function for the following routine, to see how complex a nesting of\n+   COND_EXPRs can be.  EXPR is the expression and LIMIT is a count beyond which\n+   we don't care (to avoid spending too much time on complex expressions.).  */\n+\n+static int\n+count_cond (expr, lim)\n+     tree expr;\n+     int lim;\n+{\n+  int true, false;\n+\n+  if (TREE_CODE (expr) != COND_EXPR)\n+    return 0;\n+  else if (lim <= 0)\n+    return 0;\n+\n+  true = count_cond (TREE_OPERAND (expr, 1), lim - 1);\n+  false = count_cond (TREE_OPERAND (expr, 2), lim - 1 - true);\n+  return MIN (lim, 1 + true + false);\n+}\n+\f\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -4222,6 +4241,8 @@ fold (expr)\n       else if ((TREE_CODE (arg1) == COND_EXPR\n \t\t|| (TREE_CODE_CLASS (TREE_CODE (arg1)) == '<'\n \t\t    && TREE_CODE_CLASS (code) != '<'))\n+\t       && (TREE_CODE (arg0) != COND_EXPR\n+\t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg0)\n \t\t   || (current_function_decl != 0\n \t\t       && ! contains_placeholder_p (arg0))))\n@@ -4295,6 +4316,8 @@ fold (expr)\n       else if ((TREE_CODE (arg0) == COND_EXPR\n \t\t|| (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n \t\t    && TREE_CODE_CLASS (code) != '<'))\n+\t       && (TREE_CODE (arg1) != COND_EXPR\n+\t\t   || count_cond (arg0, 25) + count_cond (arg1, 25) <= 25)\n \t       && (! TREE_SIDE_EFFECTS (arg1)\n \t\t   || (current_function_decl != 0\n \t\t       && ! contains_placeholder_p (arg1))))"}, {"sha": "90540d792cda0c009d8e59046a532f408e034d53", "filename": "gcc/function.c", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -148,6 +148,11 @@ int current_function_contains_functions;\n \n int current_function_sp_is_unchanging;\n \n+/* Nonzero if the function being compiled has the address of its\n+   labels taken. */\n+\n+int current_function_addresses_labels;\n+\n /* Nonzero if the current function is a thunk (a lightweight function that\n    just adjusts one of its arguments and forwards to another function), so\n    we should try to cut corners where we can.  */\n@@ -520,6 +525,7 @@ push_function_context_to (context)\n   p->has_nonlocal_label = current_function_has_nonlocal_label;\n   p->has_nonlocal_goto = current_function_has_nonlocal_goto;\n   p->contains_functions = current_function_contains_functions;\n+  p->addresses_labels = current_function_addresses_labels;\n   p->is_thunk = current_function_is_thunk;\n   p->args_size = current_function_args_size;\n   p->pretend_args_size = current_function_pretend_args_size;\n@@ -592,6 +598,7 @@ pop_function_context_from (context)\n   current_function_contains_functions\n     = p->contains_functions || p->inline_obstacks\n       || context == current_function_decl;\n+  current_function_addresses_labels = p->addresses_labels;\n   current_function_name = p->name;\n   current_function_decl = p->decl;\n   current_function_pops_args = p->pops_args;\n@@ -2670,7 +2677,9 @@ optimize_bit_field (body, insn, equiv_mem)\n \t      while (GET_CODE (dest) == SUBREG\n \t\t     && SUBREG_WORD (dest) == 0\n \t\t     && (GET_MODE_CLASS (GET_MODE (dest))\n-\t\t\t == GET_MODE_CLASS (GET_MODE (SUBREG_REG (dest)))))\n+\t\t\t == GET_MODE_CLASS (GET_MODE (SUBREG_REG (dest))))\n+\t\t     && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n+\t\t\t <= UNITS_PER_WORD))\n \t\tdest = SUBREG_REG (dest);\n \n \t      validate_change (insn, &SET_DEST (body), dest, 1);\n@@ -2860,13 +2869,14 @@ purge_addressof_1 (loc, insn, force, store)\n \t overwriting a REG rtx which is always shared.  */\n       rtx sub = copy_rtx (XEXP (XEXP (x, 0), 0));\n \n-      if (validate_change (insn, loc, sub, 0))\n+      if (validate_change (insn, loc, sub, 0)\n+\t  || validate_replace_rtx (x, sub, insn))\n \treturn;\n-\n+  \n       start_sequence ();\n-      if (! validate_change (insn, loc,\n-\t\t\t     force_operand (sub, NULL_RTX),\n-\t\t\t     0))\n+      sub = force_operand (sub, NULL_RTX);\n+      if (! validate_change (insn, loc, sub, 0)\n+\t  && ! validate_replace_rtx (x, sub, insn))\n \tabort ();\n \n       insns = gen_sequence ();\n@@ -2877,9 +2887,15 @@ purge_addressof_1 (loc, insn, force, store)\n   else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)\n     {\n       rtx sub = XEXP (XEXP (x, 0), 0);\n+      rtx sub2;\n \n       if (GET_CODE (sub) == MEM)\n-\tsub = gen_rtx_MEM (GET_MODE (x), copy_rtx (XEXP (sub, 0)));\n+\t{\n+\t  sub2 = gen_rtx_MEM (GET_MODE (x), copy_rtx (XEXP (sub, 0)));\n+\t  MEM_COPY_ATTRIBUTES (sub2, sub);\n+\t  RTX_UNCHANGING_P (sub2) = RTX_UNCHANGING_P (sub);\n+\t  sub = sub2;\n+\t}\n \n       if (GET_CODE (sub) == REG\n \t  && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))\n@@ -4083,7 +4099,7 @@ assign_parms (fndecl, second_time)\n \t In this case, we call FUNCTION_ARG with NAMED set to 1 instead of\n \t 0 as it was the previous time.  */\n \n-      locate_and_pad_parm (promoted_mode, passed_type,\n+      locate_and_pad_parm (nominal_mode, passed_type,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n \t\t\t   1,\n #else\n@@ -4105,9 +4121,9 @@ assign_parms (fndecl, second_time)\n \t  rtx offset_rtx = ARGS_SIZE_RTX (stack_offset);\n \n \t  if (offset_rtx == const0_rtx)\n-\t    stack_parm = gen_rtx_MEM (promoted_mode, internal_arg_pointer);\n+\t    stack_parm = gen_rtx_MEM (nominal_mode, internal_arg_pointer);\n \t  else\n-\t    stack_parm = gen_rtx_MEM (promoted_mode,\n+\t    stack_parm = gen_rtx_MEM (nominal_mode,\n \t\t\t\t      gen_rtx_PLUS (Pmode,\n \t\t\t\t\t\t    internal_arg_pointer,\n \t\t\t\t\t\t    offset_rtx));\n@@ -4179,6 +4195,8 @@ assign_parms (fndecl, second_time)\n \t to indicate there is no preallocated stack slot for the parm.  */\n \n       if (entry_parm == stack_parm\n+          || (GET_CODE (entry_parm) == PARALLEL\n+              && XEXP (XVECEXP (entry_parm, 0, 0), 0) == NULL_RTX)\n #if defined (REG_PARM_STACK_SPACE) && ! defined (MAYBE_REG_PARM_STACK_SPACE)\n \t  /* On some machines, even if a parm value arrives in a register\n \t     there is still an (uninitialized) stack slot allocated for it.\n@@ -5546,6 +5564,7 @@ init_function_start (subr, filename, line)\n   current_function_has_nonlocal_goto = 0;\n   current_function_contains_functions = 0;\n   current_function_sp_is_unchanging = 0;\n+  current_function_addresses_labels = 0;\n   current_function_is_thunk = 0;\n \n   current_function_returns_pcc_struct = 0;"}, {"sha": "e5295e97bd429a92a601c49efa65ee6ce8f31064", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -80,6 +80,7 @@ struct function\n   int has_nonlocal_label;\n   int has_nonlocal_goto;\n   int contains_functions;\n+  int addresses_labels;\n   int is_thunk;\n   rtx nonlocal_goto_handler_slots;\n   rtx nonlocal_goto_stack_level;"}, {"sha": "db84dbdf3930a997f15cbc4802265ac901499296", "filename": "gcc/gcc.c", "status": "modified", "additions": 76, "deletions": 47, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -36,6 +36,7 @@ compilation is specified by a string called a \"spec\".  */\n #include <signal.h>\n \n #include \"obstack.h\"\n+#include \"intl.h\"\n #include \"prefix.h\"\n \n #ifdef VMS\n@@ -194,9 +195,12 @@ static void print_multilib_info\tPROTO((void));\n static void pfatal_with_name\tPROTO((char *)) ATTRIBUTE_NORETURN;\n static void perror_with_name\tPROTO((char *));\n static void pfatal_pexecute\tPROTO((char *, char *)) ATTRIBUTE_NORETURN;\n+static void fatal\t\tPVPROTO((char *, ...)) ATTRIBUTE_NORETURN;\n+static void error\t\tPVPROTO((char *, ...));\n static void fatal\t\tPVPROTO((char *, ...))\n   ATTRIBUTE_NORETURN ATTRIBUTE_PRINTF_1;\n static void error\t\tPVPROTO((char *, ...)) ATTRIBUTE_PRINTF_1;\n+static void notice\t\tPVPROTO((char *, ...));\n static void display_help \tPROTO((void));\n \n void fancy_abort\t\tPROTO((void)) ATTRIBUTE_NORETURN;\n@@ -1039,15 +1043,13 @@ xstrerror(e)\n \n #else\n \n-  static char buffer[30];\n   if (!e)\n-    return \"cannot access\";\n+    return \"errno = 0\";\n \n   if (e > 0 && e < sys_nerr)\n     return sys_errlist[e];\n \n-  sprintf (buffer, \"Unknown error %d\", e);\n-  return buffer;\n+  return \"errno = ?\";\n #endif\n }\n \f\n@@ -1152,7 +1154,7 @@ init_spec ()\n     return;\t\t\t/* already initialized */\n \n   if (verbose_flag)\n-    fprintf (stderr, \"Using builtin specs.\\n\");\n+    notice (\"Using builtin specs.\\n\");\n \n #ifdef EXTRA_SPECS\n   extra_specs = (struct spec_list *)\n@@ -1237,7 +1239,7 @@ set_spec (name, spec)\n \n #ifdef DEBUG_SPECS\n   if (verbose_flag)\n-    fprintf (stderr, \"Setting spec %s to '%s'\\n\\n\", name, *(sl->ptr_spec));\n+    notice (\"Setting spec %s to '%s'\\n\\n\", name, *(sl->ptr_spec));\n #endif\n \n   /* Free the old spec */\n@@ -1435,7 +1437,7 @@ read_specs (filename, main_p)\n   register char *p;\n \n   if (verbose_flag)\n-    fprintf (stderr, \"Reading specs from %s\\n\", filename);\n+    notice (\"Reading specs from %s\\n\", filename);\n \n   /* Open and stat the file.  */\n   desc = open (filename, O_RDONLY, 0);\n@@ -1513,7 +1515,7 @@ read_specs (filename, main_p)\n \t      if (new_filename)\n \t\tread_specs (new_filename, FALSE);\n \t      else if (verbose_flag)\n-\t\tfprintf (stderr, \"Could not find specs file %s\\n\", p1);\n+\t\tnotice (\"Could not find specs file %s\\n\", p1);\n \t      continue;\n \t    }\n \t  else if (!strncmp (p1, \"%rename\", sizeof \"%rename\" - 1)\n@@ -1571,9 +1573,9 @@ read_specs (filename, main_p)\n \n \t      if (verbose_flag)\n \t\t{\n-\t\t  fprintf (stderr, \"rename spec %s to %s\\n\", p1, p2);\n+\t\t  notice (\"rename spec %s to %s\\n\", p1, p2);\n #ifdef DEBUG_SPECS\n-\t\t  fprintf (stderr, \"spec is '%s'\\n\\n\", *(sl->ptr_spec));\n+\t\t  notice (\"spec is '%s'\\n\\n\", *(sl->ptr_spec));\n #endif\n \t\t}\n \n@@ -2246,7 +2248,7 @@ execute ()\n \t}\n       fflush (stderr);\n #ifdef DEBUG\n-      fprintf (stderr, \"\\nGo ahead? (y or n) \");\n+      notice (\"\\nGo ahead? (y or n) \");\n       fflush (stderr);\n       i = getchar ();\n       if (i != '\\n')\n@@ -2334,15 +2336,15 @@ execute ()\n    is a null-terminated vector containing the following arguments.\n    The `live_cond' field is 1 if the switch is true in a conditional spec,\n    -1 if false (overridden by a later switch), and is initialized to zero.\n-   The `valid' field is nonzero if any spec has looked at this switch;\n+   The `validated' field is nonzero if any spec has looked at this switch;\n    if it remains zero at the end of the run, it must be meaningless.  */\n \n struct switchstr\n {\n   char *part1;\n   char **args;\n   int live_cond;\n-  int valid;\n+  int validated;\n };\n \n static struct switchstr *switches;\n@@ -3129,7 +3131,7 @@ process_command (argc, argv)\n \t      switches[n_switches].part1     = \"--help\";\n \t      switches[n_switches].args      = 0;\n \t      switches[n_switches].live_cond = 0;\n-\t      switches[n_switches].valid     = 0;\n+\t      switches[n_switches].validated     = 0;\n \t      \n \t      n_switches++;\n \t    }\n@@ -3144,7 +3146,7 @@ process_command (argc, argv)\n \t  switches[n_switches].part1 = &argv[i][0];\n \t  switches[n_switches].args = 0;\n \t  switches[n_switches].live_cond = 0;\n-\t  switches[n_switches].valid = 0;\n+\t  switches[n_switches].validated = 0;\n \t  n_switches++;\n \t}\n       else if (strncmp (argv[i], \"-Wl,\", 4) == 0)\n@@ -3243,15 +3245,15 @@ process_command (argc, argv)\n \t    switches[n_switches].args = 0;\n \n \t  switches[n_switches].live_cond = 0;\n-\t  switches[n_switches].valid = 0;\n+\t  switches[n_switches].validated = 0;\n \t  /* This is always valid, since gcc.c itself understands it.  */\n \t  if (!strcmp (p, \"save-temps\"))\n-\t    switches[n_switches].valid = 1;\n+\t    switches[n_switches].validated = 1;\n           else\n             {\n               char ch = switches[n_switches].part1[0];\n               if (ch == 'V' || ch == 'b' || ch == 'B')\n-                switches[n_switches].valid = 1;\n+                switches[n_switches].validated = 1;\n             }\n \t  n_switches++;\n \t}\n@@ -3407,7 +3409,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    if (i < n_switches)\n \t      {\n \t\tinput_from_pipe = 1;\n-\t\tswitches[i].valid = 1;\n+\t\tswitches[i].validated = 1;\n \t\tbreak;\n \t      }\n \t    else\n@@ -3593,7 +3595,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t    break;\n \n \t  case 'e':\n-\t    /* {...:%efoo} means report an error with `foo' as error message\n+\t    /* %efoo means report an error with `foo' as error message\n \t       and don't execute any more commands for this file.  */\n \t    {\n \t      char *q = p;\n@@ -3602,7 +3604,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t      buf = (char *) alloca (p - q + 1);\n \t      strncpy (buf, q, p - q);\n \t      buf[p - q] = 0;\n-\t      error (\"%s\", buf);\n+\t      error (buf);\n \t      return -1;\n \t    }\n \t    break;\n@@ -4072,8 +4074,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t  {\n \t\t    name = *(sl->ptr_spec);\n #ifdef DEBUG_SPECS\n-\t\t    fprintf (stderr, \"Processing spec %c%s%c, which is '%s'\\n\",\n-\t\t\t     c, sl->name, (c == '(') ? ')' : ']', name);\n+\t\t    notice (\"Processing spec %c%s%c, which is '%s'\\n\",\n+\t\t\t    c, sl->name, (c == '(') ? ')' : ']', name);\n #endif\n \t\t    break;\n \t\t  }\n@@ -4434,7 +4436,7 @@ check_live_switch (switchnum, prefix_length)\n \tfor (i = switchnum + 1; i < n_switches; i++)\n \t  if (switches[i].part1[0] == 'O')\n \t    {\n-\t      switches[switchnum].valid = 1;\n+\t      switches[switchnum].validated = 1;\n \t      switches[switchnum].live_cond = -1;\n \t      return 0;\n \t    }\n@@ -4448,7 +4450,7 @@ check_live_switch (switchnum, prefix_length)\n \t    if (switches[i].part1[0] == name[0]\n \t\t&& ! strcmp (&switches[i].part1[1], &name[4]))\n \t    {\n-\t      switches[switchnum].valid = 1;\n+\t      switches[switchnum].validated = 1;\n \t      switches[switchnum].live_cond = -1;\n \t      return 0;\n \t    }\n@@ -4463,7 +4465,7 @@ check_live_switch (switchnum, prefix_length)\n \t\t&& switches[i].part1[3] == '-'\n \t\t&& !strcmp (&switches[i].part1[4], &name[1]))\n \t    {\n-\t      switches[switchnum].valid = 1;\n+\t      switches[switchnum].validated = 1;\n \t      switches[switchnum].live_cond = -1;\n \t      return 0;\n \t    }\n@@ -4511,7 +4513,7 @@ give_switch (switchnum, omit_first_word, include_blanks)\n     }\n \n   do_spec_1 (\" \", 0, NULL_PTR);\n-  switches[switchnum].valid = 1;\n+  switches[switchnum].validated = 1;\n }\n \f\n /* Search for a file named NAME trying various prefixes including the\n@@ -4625,6 +4627,10 @@ main (argc, argv)\n   while (p != argv[0] && p[-1] != '/' && p[-1] != DIR_SEPARATOR) --p;\n   programname = p;\n \n+  setlocale (LC_MESSAGES, \"\");\n+  bindtextdomain (PACKAGE, localedir);\n+  textdomain (PACKAGE);\n+\n   if (signal (SIGINT, SIG_IGN) != SIG_IGN)\n     signal (SIGINT, fatal_error);\n #ifdef SIGHUP\n@@ -4887,7 +4893,7 @@ main (argc, argv)\n   /* Warn about any switches that no pass was interested in.  */\n \n   for (i = 0; (int)i < n_switches; i++)\n-    if (! switches[i].valid)\n+    if (! switches[i].validated)\n       error (\"unrecognized option `-%s'\", switches[i].part1);\n \n   /* Obey some of the options.  */\n@@ -4958,10 +4964,10 @@ main (argc, argv)\n \n       if (! strncmp (version_string, compiler_version, n)\n \t  && compiler_version[n] == 0)\n-\tfprintf (stderr, \"gcc version %s\\n\", version_string);\n+\tnotice (\"gcc version %s\\n\", version_string);\n       else\n-\tfprintf (stderr, \"gcc driver version %s executing gcc version %s\\n\",\n-\t\t version_string, compiler_version);\n+\tnotice (\"gcc driver version %s executing gcc version %s\\n\",\n+\t\tversion_string, compiler_version);\n \n       if (n_infiles == 0)\n \texit (0);\n@@ -5249,7 +5255,9 @@ static void\n pfatal_with_name (name)\n      char *name;\n {\n-  fatal (\"%s: %s\", name, xstrerror (errno));\n+  perror_with_name (name);\n+  delete_temp_files ();\n+  exit (1);\n }\n \n static void\n@@ -5264,17 +5272,19 @@ pfatal_pexecute (errmsg_fmt, errmsg_arg)\n      char *errmsg_fmt;\n      char *errmsg_arg;\n {\n-  int save_errno = errno;\n-\n   if (errmsg_arg)\n     {\n+      int save_errno = errno;\n+\n       /* Space for trailing '\\0' is in %s.  */\n       char *msg = xmalloc (strlen (errmsg_fmt) + strlen (errmsg_arg));\n       sprintf (msg, errmsg_fmt, errmsg_arg);\n       errmsg_fmt = msg;\n+\n+      errno = save_errno;\n     }\n \n-  fatal (\"%s: %s\", errmsg_fmt, xstrerror (save_errno));\n+  pfatal_with_name (errmsg_fmt);\n }\n \n /* More 'friendly' abort that prints the line and file.\n@@ -5289,47 +5299,66 @@ fancy_abort ()\n /* Output an error message and exit */\n \n static void\n-fatal VPROTO((char *format, ...))\n+fatal VPROTO((char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *format;\n+  char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, format);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  format = va_arg (ap, char *);\n+  msgid = va_arg (ap, char *);\n #endif\n \n   fprintf (stderr, \"%s: \", programname);\n-  vfprintf (stderr, format, ap);\n+  vfprintf (stderr, _(msgid), ap);\n   va_end (ap);\n   fprintf (stderr, \"\\n\");\n   delete_temp_files ();\n   exit (1);\n }\n \n static void\n-error VPROTO((char *format, ...))\n+error VPROTO((char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *format;\n+  char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, format);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  format = va_arg (ap, char *);\n+  msgid = va_arg (ap, char *);\n #endif\n \n   fprintf (stderr, \"%s: \", programname);\n-  vfprintf (stderr, format, ap);\n+  vfprintf (stderr, _(msgid), ap);\n   va_end (ap);\n \n   fprintf (stderr, \"\\n\");\n }\n+\n+static void\n+notice VPROTO((char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, char *);\n+#endif\n+\n+  vfprintf (stderr, _(msgid), ap);\n+  va_end (ap);\n+}\n+\n \f\n static void\n validate_all_switches ()\n@@ -5401,7 +5430,7 @@ validate_switches (start)\n       --p;\n       for (i = 0; i < n_switches; i++)\n \tif (!strncmp (switches[i].part1, filter, p - filter))\n-\t  switches[i].valid = 1;\n+\t  switches[i].validated = 1;\n     }\n   else\n     {\n@@ -5410,7 +5439,7 @@ validate_switches (start)\n \t{\n \t  if (!strncmp (switches[i].part1, filter, p - filter)\n \t      && switches[i].part1[p - filter] == 0)\n-\t    switches[i].valid = 1;\n+\t    switches[i].validated = 1;\n \t}\n     }\n }"}, {"sha": "9c0798d3bc36d95af618a91c0ca80bbacafe3257", "filename": "gcc/gcov.c", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,6 +1,6 @@\n /* Gcov.c: prepend line execution counts and branch probabilities to a\n    source file.\n-   Copyright (C) 1990, 91, 92, 93, 94, 96, 97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 91, 92, 93, 94, 96, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by James E. Wilson of Cygnus Support.\n    Mangled by Bob Manson of Cygnus Support.\n \n@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"intl.h\"\n \n #include \"gcov-io.h\"\n \n@@ -224,6 +225,10 @@ main (argc, argv)\n      int argc;\n      char **argv;\n {\n+  setlocale (LC_MESSAGES, \"\");\n+  bindtextdomain (PACKAGE, localedir);\n+  textdomain (PACKAGE);\n+\n   process_args (argc, argv);\n \n   open_files ();\n@@ -237,14 +242,34 @@ main (argc, argv)\n   return 0;\n }\n \n+static void fnotice\tPVPROTO ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+static void\n+fnotice VPROTO ((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  vfprintf (stderr, _(msgid), ap);\n+  va_end (ap);\n+}\n+\n+\n PTR\n xmalloc (size)\n   size_t size;\n {\n   register PTR value = (PTR) malloc (size);\n   if (value == 0)\n     {\n-      fprintf (stderr, \"error: virtual memory exhausted\");\n+      fnotice (stderr, \"error: virtual memory exhausted\");\n       exit (FATAL_EXIT_CODE);\n     }\n   return value;\n@@ -256,7 +281,7 @@ xmalloc (size)\n void\n fancy_abort ()\n {\n-  fprintf (stderr, \"Internal gcc abort.\\n\");\n+  fnotice (stderr, \"Internal gcc abort.\\n\");\n   exit (FATAL_EXIT_CODE);\n }\n \f\n@@ -265,7 +290,7 @@ fancy_abort ()\n static void\n print_usage ()\n {\n-  fprintf (stderr, \"gcov [-b] [-v] [-n] [-l] [-f] [-o OBJDIR] file\\n\");\n+  fnotice (stderr, \"gcov [-b] [-v] [-n] [-l] [-f] [-o OBJDIR] file\\n\");\n   exit (FATAL_EXIT_CODE);\n }\n \n@@ -383,7 +408,7 @@ open_files ()\n   bb_file = fopen (bb_file_name, \"r\");\n   if (bb_file == NULL)\n     {\n-      fprintf (stderr, \"Could not open basic block file %s.\\n\", bb_file_name);\n+      fnotice (stderr, \"Could not open basic block file %s.\\n\", bb_file_name);\n       exit (FATAL_EXIT_CODE);\n     }\n \n@@ -392,14 +417,14 @@ open_files ()\n   da_file = fopen (da_file_name, \"r\");\n   if (da_file == NULL)\n     {\n-      fprintf (stderr, \"Could not open data file %s.\\n\", da_file_name);\n-      fprintf (stderr, \"Assuming that all execution counts are zero.\\n\");\n+      fnotice (stderr, \"Could not open data file %s.\\n\", da_file_name);\n+      fnotice (stderr, \"Assuming that all execution counts are zero.\\n\");\n     }\n     \n   bbg_file = fopen (bbg_file_name, \"r\");\n   if (bbg_file == NULL)\n     {\n-      fprintf (stderr, \"Could not open program flow graph file %s.\\n\",\n+      fnotice (stderr, \"Could not open program flow graph file %s.\\n\",\n \t       bbg_file_name);\n       exit (FATAL_EXIT_CODE);\n     }\n@@ -410,7 +435,7 @@ open_files ()\n   ungetc (getc (bbg_file), bbg_file);\n   if (feof (bbg_file))\n     {\n-      fprintf (stderr, \"No executable code associated with file %s.\\n\",\n+      fnotice (stderr, \"No executable code associated with file %s.\\n\",\n \t       input_file_name);\n       exit (FATAL_EXIT_CODE);\n     }\n@@ -711,10 +736,10 @@ read_files ()\n   if (da_file)\n     {\n       if (feof (da_file))\n-\tfprintf (stderr, \".da file contents exhausted too early\\n\");\n+\tfnotice (stderr, \".da file contents exhausted too early\\n\");\n       /* Should be at end of file now.  */\n       if (__read_long (&total, da_file, 8) == 0)\n-\tfprintf (stderr, \".da file contents not exhausted\\n\");\n+\tfnotice (stderr, \".da file contents not exhausted\\n\");\n     }\n \n   /* Calculate all of the basic block execution counts and branch\n@@ -895,33 +920,33 @@ static void\n function_summary ()\n {\n   if (function_source_lines)\n-    fprintf (stdout, \"%6.2f%% of %d source lines executed in function %s\\n\",\n+    fnotice (stdout, \"%6.2lf%% of %d source lines executed in function %s\\n\",\n \t     (((double) function_source_lines_executed / function_source_lines)\n \t      * 100), function_source_lines, function_name);\n   else\n-    fprintf (stdout, \"No executable source lines in function %s\\n\",\n+    fnotice (stdout, \"No executable source lines in function %s\\n\",\n \t     function_name);\n \n   if (output_branch_probs)\n     {\n       if (function_branches)\n \t{\n-\t  fprintf (stdout, \"%6.2f%% of %d branches executed in function %s\\n\",\n+\t  fnotice (stdout, \"%6.2lf%% of %d branches executed in function %s\\n\",\n \t\t   (((double) function_branches_executed / function_branches)\n \t\t    * 100), function_branches, function_name);\n-\t  fprintf (stdout,\n-\t\t\"%6.2f%% of %d branches taken at least once in function %s\\n\",\n+\t  fnotice (stdout,\n+\t\t\"%6.2lf%% of %d branches taken at least once in function %s\\n\",\n \t\t   (((double) function_branches_taken / function_branches)\n \t\t    * 100), function_branches, function_name);\n \t}\n       else\n-\tfprintf (stdout, \"No branches in function %s\\n\", function_name);\n+\tfnotice (stdout, \"No branches in function %s\\n\", function_name);\n       if (function_calls)\n-\tfprintf (stdout, \"%6.2f%% of %d calls executed in function %s\\n\",\n+\tfnotice (stdout, \"%6.2lf%% of %d calls executed in function %s\\n\",\n \t\t (((double) function_calls_executed / function_calls)\n \t\t  * 100), function_calls, function_name);\n       else\n-\tfprintf (stdout, \"No calls in function %s\\n\", function_name);\n+\tfnotice (stdout, \"No calls in function %s\\n\", function_name);\n     }\n }\n \n@@ -1052,10 +1077,10 @@ output_data ()\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\tfprintf (stderr,\n+\t\t\tfnotice (stderr,\n \t\t\t\t \"didn't use all bb entries of graph, function %s\\n\",\n \t\t\t\t function_name);\n-\t\t\tfprintf (stderr, \"block_num = %ld, num_blocks = %d\\n\",\n+\t\t\tfnotice (stderr, \"block_num = %d, num_blocks = %d\\n\",\n \t\t\t\t block_num, current_graph->num_blocks);\n \t\t      }\n \n@@ -1093,7 +1118,7 @@ output_data ()\n \n \t\tif (block_num >= current_graph->num_blocks)\n \t\t  {\n-\t\t    fprintf (stderr, \"ERROR: too many basic blocks in .bb file %s\\n\",\n+\t\t    fnotice (stderr, \"ERROR: too many basic blocks in .bb file %s\\n\",\n \t\t\t     function_name);\n \t\t    abort ();\n \t\t  }\n@@ -1169,34 +1194,34 @@ output_data ()\n \t}\n \n       if (total_source_lines)\n-\tfprintf (stdout,\n-\t\t \"%6.2f%% of %d source lines executed in file %s\\n\",\n+\tfnotice (stdout,\n+\t\t \"%6.2lf%% of %d source lines executed in file %s\\n\",\n \t\t (((double) total_source_lines_executed / total_source_lines)\n \t\t  * 100), total_source_lines, source_file_name);\n       else\n-\tfprintf (stdout, \"No executable source lines in file %s\\n\",\n+\tfnotice (stdout, \"No executable source lines in file %s\\n\",\n \t\t source_file_name);\n \n       if (output_branch_probs)\n \t{\n \t  if (total_branches)\n \t    {\n-\t      fprintf (stdout, \"%6.2f%% of %d branches executed in file %s\\n\",\n+\t      fnotice (stdout, \"%6.2lf%% of %d branches executed in file %s\\n\",\n \t\t       (((double) total_branches_executed / total_branches)\n \t\t\t* 100), total_branches, source_file_name);\n-\t      fprintf (stdout,\n-\t\t    \"%6.2f%% of %d branches taken at least once in file %s\\n\",\n+\t      fnotice (stdout,\n+\t\t    \"%6.2lf%% of %d branches taken at least once in file %s\\n\",\n \t\t       (((double) total_branches_taken / total_branches)\n \t\t\t* 100), total_branches, source_file_name);\n \t    }\n \t  else\n-\t    fprintf (stdout, \"No branches in file %s\\n\", source_file_name);\n+\t    fnotice (stdout, \"No branches in file %s\\n\", source_file_name);\n \t  if (total_calls)\n-\t    fprintf (stdout, \"%6.2f%% of %d calls executed in file %s\\n\",\n+\t    fnotice (stdout, \"%6.2lf%% of %d calls executed in file %s\\n\",\n \t\t     (((double) total_calls_executed / total_calls)\n \t\t      * 100), total_calls, source_file_name);\n \t  else\n-\t    fprintf (stdout, \"No calls in file %s\\n\", source_file_name);\n+\t    fnotice (stdout, \"No calls in file %s\\n\", source_file_name);\n \t}\n \n       if (output_gcov_file)\n@@ -1208,7 +1233,7 @@ output_data ()\n \t  source_file = fopen (source_file_name, \"r\");\n \t  if (source_file == NULL)\n \t    {\n-\t      fprintf (stderr, \"Could not open source file %s.\\n\",\n+\t      fnotice (stderr, \"Could not open source file %s.\\n\",\n \t\t       source_file_name);\n \t      free (line_counts);\n \t      free (line_exists);\n@@ -1258,15 +1283,15 @@ output_data ()\n \n \t  if (gcov_file == NULL)\n \t    {\n-\t      fprintf (stderr, \"Could not open output file %s.\\n\",\n+\t      fnotice (stderr, \"Could not open output file %s.\\n\",\n \t\t       gcov_file_name);\n \t      fclose (source_file);\n \t      free (line_counts);\n \t      free (line_exists);\n \t      continue;\n \t    }\n \n-\t  fprintf (stdout, \"Creating %s.\\n\", gcov_file_name);\n+\t  fnotice (stdout, \"Creating %s.\\n\", gcov_file_name);\n \n \t  for (count = 1; count < s_ptr->maxlineno; count++)\n \t    {\n@@ -1310,19 +1335,19 @@ output_data ()\n \t\t      if (a_ptr->call_insn)\n \t\t\t{\n \t\t\t  if (a_ptr->prob == -1)\n-\t\t\t    fprintf (gcov_file, \"call %d never executed\\n\", i);\n+\t\t\t    fnotice (gcov_file, \"call %d never executed\\n\", i);\n \t\t\t  else\n-\t\t\t    fprintf (gcov_file,\n+\t\t\t    fnotice (gcov_file,\n \t\t\t\t     \"call %d returns = %d%%\\n\",\n \t\t\t\t     i, 100 - a_ptr->prob);\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  if (a_ptr->prob == -1)\n-\t\t\t    fprintf (gcov_file, \"branch %d never executed\\n\",\n+\t\t\t    fnotice (gcov_file, \"branch %d never executed\\n\",\n \t\t\t\t     i);\n \t\t\t  else\n-\t\t\t    fprintf (gcov_file, \"branch %d taken = %d%%\\n\", i,\n+\t\t\t    fnotice (gcov_file, \"branch %d taken = %d%%\\n\", i,\n \t\t\t\t     a_ptr->prob);\n \t\t\t}\n \t\t    }\n@@ -1331,7 +1356,7 @@ output_data ()\n \t      /* Gracefully handle errors while reading the source file.  */\n \t      if (retval == NULL)\n \t\t{\n-\t\t  fprintf (stderr,\n+\t\t  fnotice (stderr,\n \t\t\t   \"Unexpected EOF while reading source file %s.\\n\",\n \t\t\t   source_file_name);\n \t\t  break;"}, {"sha": "08b7ea85ddc5ecef4de8244234c0bd1a1492a262", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -28,20 +28,6 @@ char *progname;\n int hash_tab[HASH_SIZE];\n int next_index;\n \n-int\n-hashf (name, len, hashsize)\n-     register const U_CHAR *name;\n-     register int len;\n-     int hashsize;\n-{\n-  register int r = 0;\n-\n-  while (len--)\n-    r = HASHSTEP (r, *name++);\n-\n-  return MAKE_POS (r) % hashsize;\n-}\n-\n static void\n add_hash (fname)\n      char *fname;"}, {"sha": "5436aa8446a2019154641aaf42175f81b1eca80e", "filename": "gcc/install.texi", "status": "modified", "additions": 124, "deletions": 49, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finstall.texi?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -15,6 +15,7 @@ install procedures.  It is provided for historical reference only.\n @cindex installing GNU CC\n \n @menu\n+* Configuration Files::  Files created by running @code{configure}.\n * Configurations::    Configurations Supported by GNU CC.\n * Other Dir::     Compiling in a separate directory (not where the source is).\n * Cross-Compiler::   Building and installing a cross-compiler.\n@@ -24,11 +25,11 @@ install procedures.  It is provided for historical reference only.\n * Header Dirs::   Understanding the standard header file directories.\n @end menu\n \n-Here is the procedure for installing GNU CC on a Unix system.  See\n-@ref{VMS Install}, for VMS systems.  In this section we assume you\n+Here is the procedure for installing GNU CC on a GNU or Unix system.\n+See @ref{VMS Install}, for VMS systems.  In this section we assume you\n compile in the same directory that contains the source files; see\n-@ref{Other Dir}, to find out how to compile in a separate directory on Unix\n-systems.\n+@ref{Other Dir}, to find out how to compile in a separate directory on\n+Unix systems.\n \n You cannot install GNU C by itself on MSDOS; it will not compile under\n any MSDOS compiler except itself.  You need to get the complete\n@@ -49,9 +50,32 @@ On a System V release 4 system, make sure @file{/usr/bin} precedes\n @file{/usr/ucb} in @code{PATH}.  The @code{cc} command in\n @file{/usr/ucb} uses libraries which have bugs.\n \n+@cindex Bison parser generator\n+@cindex parser generator, Bison\n+@item\n+Make sure the Bison parser generator is installed.  (This is\n+unnecessary if the Bison output files @file{c-parse.c} and\n+@file{cexp.c} are more recent than @file{c-parse.y} and @file{cexp.y}\n+and you do not plan to change the @samp{.y} files.)\n+\n+Bison versions older than Sept 8, 1988 will produce incorrect output\n+for @file{c-parse.c}.\n+\n+@item\n+If you have chosen a configuration for GNU CC which requires other GNU\n+tools (such as GAS or the GNU linker) instead of the standard system\n+tools, install the required tools in the build directory under the names\n+@file{as}, @file{ld} or whatever is appropriate.  This will enable the\n+compiler to find the proper tools for compilation of the program\n+@file{enquire}.\n+\n+Alternatively, you can do subsequent compilation using a value of the\n+@code{PATH} environment variable such that the necessary GNU tools come\n+before the standard system tools.\n+\n @item\n Specify the host, build and target machine configurations.  You do this\n-by running the file @file{configure}.\n+when you run the @file{configure} script.\n \n The @dfn{build} machine is the system which you are using, the\n @dfn{host} machine is the system where you want to run the resulting\n@@ -100,10 +124,11 @@ See @ref{Configurations}, for a list of supported configuration names and\n notes on many of the configurations.  You should check the notes in that\n section before proceeding any further with the installation of GNU CC.\n \n-There are four additional options you can specify independently to\n-describe variant hardware and software configurations.  These are\n-@samp{--with-gnu-as}, @samp{--with-gnu-ld}, @samp{--with-stabs} and\n-@samp{--nfp}.\n+@item\n+When running @code{configure}, you may also need to specify certain\n+additional options that describe variant hardware and software\n+configurations.  These are @samp{--with-gnu-as}, @samp{--with-gnu-ld},\n+@samp{--with-stabs} and @samp{--nfp}.\n \n @table @samp\n @item --with-gnu-as\n@@ -253,15 +278,40 @@ machine-description macro file for your target machine.  It should be in\n the subdirectory @file{config} and its name is often\n @file{@var{machine}.h}.\n \n+@cindex Native Language Support\n+@cindex NLS\n+@item --enable-nls\n+@itemx --disable-nls\n+The @samp{--enable-nls} option enables Native Language Support (NLS),\n+which lets GCC output diagnostics in languages other than American\n+English.  No translations are available yet, so the main users of this\n+option now are those translating GCC's diagnostics who want to test\n+their work.  Once translations become available, Native Language Support\n+will become enabled by default.  The @samp{--disable-nls} option\n+disables NLS.\n+\n+@cindex @code{gettext}\n+@item --with-included-gettext\n+If NLS is enabled, the GCC build procedure normally attempts to use the\n+host's @code{gettext} libraries, and falls back on GCC's copy of the GNU\n+@code{gettext} library only if the host libraries do not suffice.  The\n+@samp{--with-included-gettext} option causes the build procedure to\n+prefer its copy of GNU @code{gettext}.\n+\n+@cindex @code{catgets}\n+@item --with-catgets\n+If NLS is enabled, and if the host lacks @code{gettext} but has the\n+inferior @code{catgets} interface, the GCC build procedure normally\n+ignores @code{catgets} and instead uses GCC's copy of the GNU\n+@code{gettext} library.  The @samp{--with-catgets} option causes the\n+build procedure to use the host's @code{catgets} in this situation.\n+@end table\n+\n @item\n-The command file @file{configure} also constructs the file\n-@file{Makefile} by adding some text to the template file\n-@file{Makefile.in}.  The additional text comes from files in the\n-@file{config} directory, named @file{t-@var{target}} and\n-@file{x-@var{host}}.  If these files do not exist, it means nothing\n-needs to be added for a given target or host.\n-@end itemize\n+In certain cases, you should specify certain other options when you run\n+@code{configure}.\n \n+@itemize @bullet\n @item\n The standard directory for installing GNU CC is @file{/usr/local/lib}.\n If you want to install its files somewhere else, specify\n@@ -303,29 +353,7 @@ Indications are that people who use this option use it based on\n mistaken ideas of what it is for.  People use it as if it specified\n where to install part of GNU CC.  Perhaps they make this assumption\n because installing GNU CC creates the directory.\n-\n-@cindex Bison parser generator\n-@cindex parser generator, Bison\n-@item\n-Make sure the Bison parser generator is installed.  (This is\n-unnecessary if the Bison output files @file{c-parse.c} and\n-@file{cexp.c} are more recent than @file{c-parse.y} and @file{cexp.y}\n-and you do not plan to change the @samp{.y} files.)\n-\n-Bison versions older than Sept 8, 1988 will produce incorrect output\n-for @file{c-parse.c}.\n-\n-@item\n-If you have chosen a configuration for GNU CC which requires other GNU\n-tools (such as GAS or the GNU linker) instead of the standard system\n-tools, install the required tools in the build directory under the names\n-@file{as}, @file{ld} or whatever is appropriate.  This will enable the\n-compiler to find the proper tools for compilation of the program\n-@file{enquire}.\n-\n-Alternatively, you can do subsequent compilation using a value of the\n-@code{PATH} environment variable such that the necessary GNU tools come\n-before the standard system tools.\n+@end itemize\n \n @item\n Build the compiler.  Just type @samp{make LANGUAGES=c} in the compiler\n@@ -360,9 +388,9 @@ should be investigated and reported (@pxref{Bugs}).\n should be investigated and reported.\n @end ifset\n \n-Some commercial compilers fail to compile GNU CC because they have bugs\n-or limitations.  For example, the Microsoft compiler is said to run out\n-of macro space.  Some Ultrix compilers run out of expression space; then\n+Some compilers fail to compile GNU CC because they have bugs or\n+limitations.  For example, the Microsoft compiler is said to run out of\n+macro space.  Some Ultrix compilers run out of expression space; then\n you need to break up the statement where the problem happens.\n \n @item\n@@ -457,8 +485,8 @@ instead of making @file{stage1}, @file{stage2}, and performing\n the two compiler builds.\n \n @item\n-Then compare the latest object files with the stage 2 object\n-files---they ought to be identical, aside from time stamps (if any).\n+Compare the latest object files with the stage 2 object files---they\n+ought to be identical, aside from time stamps (if any).\n \n On some systems, meaningful comparison of object files is impossible;\n they always appear ``different.''  This is currently true on Solaris and\n@@ -546,11 +574,8 @@ compiler.)\n @item\n @cindex C++ runtime library\n @cindex @code{libstdc++}\n-If you're going to use C++, it's likely that you need to also install\n-a C++ runtime library.  Just as GNU C does not\n-distribute a C runtime library, it also does not include a C++ runtime\n-library.  All I/O functionality, special class libraries, etc., are\n-provided by the C++ runtime library.\n+If you're going to use C++, you need to install the C++ runtime library.\n+This includes all I/O functionality, special class libraries, etc.\n \n The standard C++ runtime library for GNU CC is called @samp{libstdc++}.\n An obsolescent library @samp{libg++} may also be available, but it's\n@@ -643,6 +668,56 @@ Microsoft Win32 API thread support.\n @end itemize\n @end enumerate\n \n+@node Configuration Files\n+@section Files Created by @code{configure}\n+\n+Here we spell out what files will be set up by @code{configure}.  Normally\n+you need not be concerned with these files.\n+\n+@itemize @bullet\n+@item\n+@ifset INTERNALS\n+A file named @file{config.h} is created that contains a @samp{#include}\n+of the top-level config file for the machine you will run the compiler\n+on (@pxref{Config}).  This file is responsible for defining information\n+about the host machine.  It includes @file{tm.h}.\n+@end ifset\n+@ifclear INTERNALS\n+A file named @file{config.h} is created that contains a @samp{#include}\n+of the top-level config file for the machine you will run the compiler\n+on (@pxref{Config,,The Configuration File, gcc.info, Using and Porting\n+GCC}).  This file is responsible for defining information about the host\n+machine.  It includes @file{tm.h}.\n+@end ifclear\n+\n+The top-level config file is located in the subdirectory @file{config}.\n+Its name is always @file{xm-@var{something}.h}; usually\n+@file{xm-@var{machine}.h}, but there are some exceptions.\n+\n+If your system does not support symbolic links, you might want to\n+set up @file{config.h} to contain a @samp{#include} command which\n+refers to the appropriate file.\n+\n+@item\n+A file named @file{tconfig.h} is created which includes the top-level config\n+file for your target machine.  This is used for compiling certain\n+programs to run on that machine.\n+\n+@item\n+A file named @file{tm.h} is created which includes the\n+machine-description macro file for your target machine.  It should be in\n+the subdirectory @file{config} and its name is often\n+@file{@var{machine}.h}.\n+\n+@item\n+The command file @file{configure} also constructs the file\n+@file{Makefile} by adding some text to the template file\n+@file{Makefile.in}.  The additional text comes from files in the\n+@file{config} directory, named @file{t-@var{target}} and\n+@file{x-@var{host}}.  If these files do not exist, it means nothing\n+needs to be added for a given target or host.\n+@end itemize\n+\n @node Configurations\n @section Configurations Supported by GNU CC\n @cindex configurations supported by GNU CC"}, {"sha": "b3da453cf8071e30055b428e18890b83a938ebd0", "filename": "gcc/integrate.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"function.h\"\n #include \"toplev.h\"\n+#include \"intl.h\"\n \n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n@@ -106,7 +107,7 @@ get_label_from_map (map, i)\n \n /* Zero if the current function (whose FUNCTION_DECL is FNDECL)\n    is safe and reasonable to integrate into other functions.\n-   Nonzero means value is a warning message with a single %s\n+   Nonzero means value is a warning msgid with a single %s\n    for the function's name.  */\n \n char *\n@@ -123,20 +124,20 @@ function_cannot_inline_p (fndecl)\n   /* No inlines with varargs.  */\n   if ((last && TREE_VALUE (last) != void_type_node)\n       || current_function_varargs)\n-    return \"varargs function cannot be inline\";\n+    return N_(\"varargs function cannot be inline\");\n \n   if (current_function_calls_alloca)\n-    return \"function using alloca cannot be inline\";\n+    return N_(\"function using alloca cannot be inline\");\n \n   if (current_function_contains_functions)\n-    return \"function with nested functions cannot be inline\";\n+    return N_(\"function with nested functions cannot be inline\");\n \n   if (current_function_cannot_inline)\n     return current_function_cannot_inline;\n \n   /* If its not even close, don't even look.  */\n   if (!DECL_INLINE (fndecl) && get_max_uid () > 3 * max_insns)\n-    return \"function too large to be inline\";\n+    return N_(\"function too large to be inline\");\n \n #if 0\n   /* Don't inline functions which do not specify a function prototype and\n@@ -146,27 +147,27 @@ function_cannot_inline_p (fndecl)\n       if (TYPE_MODE (TREE_TYPE (parms)) == BLKmode)\n \tTREE_ADDRESSABLE (parms) = 1;\n       if (last == NULL_TREE && TREE_ADDRESSABLE (parms))\n-\treturn \"no prototype, and parameter address used; cannot be inline\";\n+\treturn N_(\"no prototype, and parameter address used; cannot be inline\");\n     }\n #endif\n \n   /* We can't inline functions that return structures\n      the old-fashioned PCC way, copying into a static block.  */\n   if (current_function_returns_pcc_struct)\n-    return \"inline functions not supported for this return value type\";\n+    return N_(\"inline functions not supported for this return value type\");\n \n   /* We can't inline functions that return structures of varying size.  */\n   if (int_size_in_bytes (TREE_TYPE (TREE_TYPE (fndecl))) < 0)\n-    return \"function with varying-size return value cannot be inline\";\n+    return N_(\"function with varying-size return value cannot be inline\");\n \n   /* Cannot inline a function with a varying size argument or one that\n      receives a transparent union.  */\n   for (parms = DECL_ARGUMENTS (fndecl); parms; parms = TREE_CHAIN (parms))\n     {\n       if (int_size_in_bytes (TREE_TYPE (parms)) < 0)\n-\treturn \"function with varying-size parameter cannot be inline\";\n+\treturn N_(\"function with varying-size parameter cannot be inline\");\n       else if (TYPE_TRANSPARENT_UNION (TREE_TYPE (parms)))\n-\treturn \"function with transparent unit parameter cannot be inline\";\n+\treturn N_(\"function with transparent unit parameter cannot be inline\");\n     }\n \n   if (!DECL_INLINE (fndecl) && get_max_uid () > max_insns)\n@@ -178,22 +179,23 @@ function_cannot_inline_p (fndecl)\n \t  ninsns++;\n \n       if (ninsns >= max_insns)\n-\treturn \"function too large to be inline\";\n+\treturn N_(\"function too large to be inline\");\n     }\n \n-  /* We cannot inline this function if forced_labels is non-zero.  This\n-     implies that a label in this function was used as an initializer.\n-     Because labels can not be duplicated, all labels in the function\n-     will be renamed when it is inlined.  However, there is no way to find\n-     and fix all variables initialized with addresses of labels in this\n+  /* We cannot inline this function it has the addresses of its labels\n+     taken.  This can mean that a label in this function was used as an\n+     initializer either statically or dynamically or stored outside the\n+     function.  Because labels can not be duplicated, all labels in the\n+     function will be renamed when it is inlined.  However, there is no way\n+     to find and fix all variables initialized with addresses of labels in this\n      function, hence inlining is impossible.  */\n \n-  if (forced_labels)\n-    return \"function with label addresses used in initializers cannot inline\";\n+  if (current_function_addresses_labels)\n+    return N_(\"function with label addresses taken cannot inline\");\n \n   /* We cannot inline a nested function that jumps to a nonlocal label.  */\n   if (current_function_has_nonlocal_goto)\n-    return \"function with nonlocal goto cannot be inline\";\n+    return N_(\"function with nonlocal goto cannot be inline\");\n \n   /* This is a hack, until the inliner is taught about eh regions at\n      the start of the function.  */\n@@ -205,13 +207,13 @@ function_cannot_inline_p (fndecl)\n     {\n       if (insn && GET_CODE (insn) == NOTE\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n-\treturn \"function with complex parameters cannot be inline\";\n+\treturn N_(\"function with complex parameters cannot be inline\");\n     }\n \n   /* We can't inline functions that return a PARALLEL rtx.  */\n   result = DECL_RTL (DECL_RESULT (fndecl));\n   if (result && GET_CODE (result) == PARALLEL)\n-    return \"inline functions not supported for this return value type\";\n+    return N_(\"inline functions not supported for this return value type\");\n \n   return 0;\n }\n@@ -292,12 +294,16 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n        + current_function_calls_setjmp * FUNCTION_FLAGS_CALLS_SETJMP\n        + current_function_calls_longjmp * FUNCTION_FLAGS_CALLS_LONGJMP\n        + current_function_returns_struct * FUNCTION_FLAGS_RETURNS_STRUCT\n-       + current_function_returns_pcc_struct * FUNCTION_FLAGS_RETURNS_PCC_STRUCT\n+       + (current_function_returns_pcc_struct\n+\t  * FUNCTION_FLAGS_RETURNS_PCC_STRUCT)\n        + current_function_needs_context * FUNCTION_FLAGS_NEEDS_CONTEXT\n-       + current_function_has_nonlocal_label * FUNCTION_FLAGS_HAS_NONLOCAL_LABEL\n+       + (current_function_has_nonlocal_label\n+\t  * FUNCTION_FLAGS_HAS_NONLOCAL_LABEL)\n        + current_function_returns_pointer * FUNCTION_FLAGS_RETURNS_POINTER\n        + current_function_uses_const_pool * FUNCTION_FLAGS_USES_CONST_POOL\n-       + current_function_uses_pic_offset_table * FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE);\n+       + (current_function_uses_pic_offset_table\n+\t  * FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE)\n+       + current_function_addresses_labels * FUNCTION_FLAGS_ADDRESSES_LABELS);\n \n   /* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */\n   bzero ((char *) parmdecl_map, max_parm_reg * sizeof (tree));\n@@ -3403,6 +3409,9 @@ output_inline_function (fndecl)\n   stack_slot_list = STACK_SLOT_LIST (head);\n   forced_labels = FORCED_LABELS (head);\n \n+  if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_ADDRESSES_LABELS)\n+    current_function_addresses_labels = 1;\n+\n   if (FUNCTION_FLAGS (head) & FUNCTION_FLAGS_CALLS_ALLOCA)\n     current_function_calls_alloca = 1;\n "}, {"sha": "e35ae4905b7c5ee38b9d4c0a8b7b7372438e2b38", "filename": "gcc/invoke.texi", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -409,7 +409,7 @@ in the following sections.\n -fno-common  -fno-ident  -fno-gnu-linker\n -fpcc-struct-return  -fpic  -fPIC\n -freg-struct-return  -fshared-data  -fshort-enums\n--fshort-double  -fvolatile  -fvolatile-global\n+-fshort-double  -fvolatile  -fvolatile-global -fvolatile-static\n -fverbose-asm -fpack-struct  -fstack-check\n -fargument-alias  -fargument-noalias\n -fargument-noalias-global\n@@ -696,7 +696,7 @@ other, C++-specific, extension keywords such as @code{headof}.\n @findex strcmp\n @findex strcpy\n @findex strlen\n-Don't recognize builtin functions that do not begin with `__builtin_'\n+Don't recognize builtin functions that do not begin with @samp{__builtin_}\n as prefix.  Currently, the functions affected include @code{abort},\n @code{abs}, @code{alloca}, @code{cos}, @code{exit}, @code{fabs},\n @code{ffs}, @code{labs}, @code{memcmp}, @code{memcpy}, @code{sin},\n@@ -5938,7 +5938,11 @@ Consider all memory references through pointers to be volatile.\n \n @item -fvolatile-global\n Consider all memory references to extern and global data items to\n-be volatile.\n+be volatile.  GNU CC does not consider static data items to be volatile\n+because of this switch.\n+\n+@item -fvolatile-static\n+Consider all memory references to static data to be volatile.\n \n @item -fpic\n @cindex global offset table\n@@ -6173,6 +6177,46 @@ CC.  @xref{Driver}.\n @end ifset\n \n @table @code\n+@item LANG\n+@itemx LC_CTYPE\n+@c @itemx LC_COLLATE\n+@itemx LC_MESSAGES\n+@c @itemx LC_MONETARY\n+@c @itemx LC_NUMERIC\n+@c @itemx LC_TIME\n+@itemx LC_ALL\n+@findex LANG\n+@findex LC_CTYPE\n+@c @findex LC_COLLATE\n+@findex LC_MESSAGES\n+@c @findex LC_MONETARY\n+@c @findex LC_NUMERIC\n+@c @findex LC_TIME\n+@findex LC_ALL\n+@cindex locale\n+These environment variables control the way that GNU CC uses\n+localization information that allow GNU CC to work with different\n+national conventions.  GNU CC inspects the locale categories\n+@code{LC_CTYPE} and @code{LC_MESSAGES} if it has been configured to do\n+so.  These locale categories can be set to any value supported by your\n+installation.  A typical value is @samp{en_UK} for English in the United\n+Kingdom.\n+\n+The @code{LC_CTYPE} environment variable specifies character\n+classification.  GNU CC uses it to determine the character boundaries in\n+a string; this is needed for some multibyte encodings that contain quote\n+and escape characters that would otherwise be interpreted as a string\n+end or escape.\n+\n+The @code{LC_MESSAGES} environment variable specifies the language to\n+use in diagnostic messages.\n+\n+If the @code{LC_ALL} environment variable is set, it overrides the value\n+of @code{LC_CTYPE} and @code{LC_MESSAGES}; otherwise, @code{LC_CTYPE}\n+and @code{LC_MESSAGES} default to the value of the @code{LANG}\n+environment variable.  If none of these variables are set, GNU CC\n+defaults to traditional C English behavior.\n+\n @item TMPDIR\n @findex TMPDIR\n If @code{TMPDIR} is set, it specifies the directory to use for temporary"}, {"sha": "b2f374279649fcae51b05a24a5969401015b90b0", "filename": "gcc/objc/objc-parse.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fobjc%2Fobjc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fobjc%2Fobjc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-parse.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1657,7 +1657,7 @@ static const short yycheck[] = {    56,\n     47,    48,    49,    50,    51,    52\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/local/gnu/share/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1674,8 +1674,7 @@ static const short yycheck[] = {    56,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n@@ -1851,7 +1850,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/local/gnu/share/bison.simple\"\n+#line 196 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4965,7 +4964,7 @@ case 566:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/local/gnu/share/bison.simple\"\n+#line 498 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "a1cf569cfdad4944f38bf8b5b9654cd7b90ec55f", "filename": "gcc/output.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -389,6 +389,11 @@ extern int current_function_contains_functions;\n \n extern int current_function_sp_is_unchanging;\n \n+/* Nonzero if the function being compiled has the address of its\n+   labels taken. */\n+\n+extern int current_function_addresses_labels;\n+\n /* Nonzero if the current function returns a pointer type */\n \n extern int current_function_returns_pointer;"}, {"sha": "17923c543941c58c3c8d1cf2986103b16c6de832", "filename": "gcc/profile.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1667,7 +1667,13 @@ output_func_start_profiler ()\n   TREE_PUBLIC (fndecl) = 1;\n   DECL_ASSEMBLER_NAME (fndecl) = fnname;\n   DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+\n+  fndecl = pushdecl (fndecl);\n+  rest_of_decl_compilation (fndecl, 0, 1, 0);\n+  announce_function (fndecl);\n   current_function_decl = fndecl;\n+  DECL_INITIAL (fndecl) = error_mark_node;\n+  temporary_allocation ();\n   pushlevel (0);\n   make_function_rtl (fndecl);\n   init_function_start (fndecl, input_filename, lineno);"}, {"sha": "9e4bfc2d2f7d70869fdab7e1dbbc9724393f2493", "filename": "gcc/protoize.c", "status": "modified", "additions": 200, "deletions": 176, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -39,6 +39,8 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n \n+#include \"intl.h\"\n+\n #if 0\n /* Users are not supposed to use _POSIX_SOURCE to say the\n    system is a POSIX system.  That is not what _POSIX_SOURCE means! -- rms  */ \n@@ -562,6 +564,28 @@ static char * saved_repl_write_ptr;\n /* Forward declaration.  */\n \n static const char *shortpath ();\n+\f\n+/* Translate and output an error message.  */\n+static void notice\t\t\tPVPROTO ((const char *, ...))\n+  ATTRIBUTE_PRINTF_1;\n+static void\n+notice VPROTO ((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  vfprintf (stderr, _(msgid), ap);\n+  va_end (ap);\n+}\n+\n \f\n char *\n xstrerror(e)\n@@ -572,16 +596,13 @@ xstrerror(e)\n   return strerror(e);\n \n #else\n-\n-  static char buffer[30];\n   if (!e)\n     return \"\";\n \n   if (e > 0 && e < sys_nerr)\n     return sys_errlist[e];\n \n-  sprintf (buffer, \"Unknown error %d\", e);\n-  return buffer;\n+  return \"errno = ?\";\n #endif\n }\n \f\n@@ -595,7 +616,7 @@ xmalloc (byte_count)\n   register pointer_type rv = (pointer_type) malloc (byte_count);\n   if (rv == NULL)\n     {\n-      fprintf (stderr, \"\\n%s: virtual memory exceeded\\n\", pname);\n+      notice (\"\\n%s: virtual memory exceeded\\n\", pname);\n       exit (FATAL_EXIT_CODE);\n     }\n   return rv;\n@@ -615,7 +636,7 @@ xrealloc (old_space, byte_count)\n     rv = (pointer_type) malloc (byte_count);\n   if (rv == NULL)\n     {\n-      fprintf (stderr, \"\\n%s: virtual memory exceeded\\n\", pname);\n+      notice (\"\\n%s: virtual memory exceeded\\n\", pname);\n       exit (FATAL_EXIT_CODE);\n     }\n   return rv;\n@@ -666,7 +687,7 @@ savestring2 (input1, size1, input2, size2)\n void\n fancy_abort ()\n {\n-  fprintf (stderr, \"%s: internal abort\\n\", pname);\n+  notice (\"%s: internal abort\\n\", pname);\n   exit (FATAL_EXIT_CODE);\n }\n \f\n@@ -756,8 +777,8 @@ safe_write (desc, ptr, len, out_fname)\n \tif (errno_val == EINTR)\n \t  continue;\n #endif\n-\tfprintf (stderr, \"%s: error writing file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, out_fname), xstrerror (errno_val));\n+\tnotice (\"%s: error writing file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, out_fname), xstrerror (errno_val));\n \treturn;\n       }\n     ptr += written;\n@@ -800,11 +821,11 @@ static void\n usage ()\n {\n #ifdef UNPROTOIZE\n-  fprintf (stderr, \"%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ filename ... ]'\\n\",\n-\t   pname, pname);\n+  notice (\"%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ filename ... ]'\\n\",\n+\t  pname, pname);\n #else /* !defined (UNPROTOIZE) */\n-  fprintf (stderr, \"%s: usage '%s [ -VqfnkNlgC ] [ -B <dirname> ] [ filename ... ]'\\n\",\n-\t   pname, pname);\n+  notice (\"%s: usage '%s [ -VqfnkNlgC ] [ -B <dirname> ] [ filename ... ]'\\n\",\n+\t  pname, pname);\n #endif /* !defined (UNPROTOIZE) */\n   exit (FATAL_EXIT_CODE);\n }\n@@ -890,24 +911,24 @@ file_normally_convertible (const char *path)\n   if (my_access (path, R_OK))\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: warning: no read access for file `%s'\\n\",\n-\t\t pname, shortpath (NULL, path));\n+        notice (\"%s: warning: no read access for file `%s'\\n\",\n+\t\tpname, shortpath (NULL, path));\n       return 0;\n     }\n \n   if (my_access (path, W_OK))\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: warning: no write access for file `%s'\\n\",\n-\t\t pname, shortpath (NULL, path));\n+        notice (\"%s: warning: no write access for file `%s'\\n\",\n+\t\tpname, shortpath (NULL, path));\n       return 0;\n     }\n \n   if (my_access (dir_name, W_OK))\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: warning: no write access for dir containing `%s'\\n\",\n-\t\t pname, shortpath (NULL, path));\n+        notice (\"%s: warning: no write access for dir containing `%s'\\n\",\n+\t\tpname, shortpath (NULL, path));\n       return 0;\n     }\n \n@@ -1298,8 +1319,8 @@ abspath (cwd, rel_filename)\n \t\t\t   point above the absolute root of the logical file\n \t\t\t   system.  */\n \n-\t\t\tfprintf (stderr, \"%s: invalid file name: %s\\n\",\n-\t\t\t\t pname, rel_filename);\n+\t\t\tnotice (\"%s: invalid file name: %s\\n\",\n+\t\t\t\tpname, rel_filename);\n \t\t\texit (FATAL_EXIT_CODE);\n \t\t      }\n                     *++outp = '\\0';\n@@ -1449,9 +1470,9 @@ find_file (filename, do_not_stat)\n           if (my_stat (filename, &stat_buf) == -1)\n             {\n \t      int errno_val = errno;\n-              fprintf (stderr, \"%s: %s: can't get status: %s\\n\",\n-\t\t       pname, shortpath (NULL, filename),\n-\t\t       xstrerror (errno_val));\n+              notice (\"%s: %s: can't get status: %s\\n\",\n+\t\t      pname, shortpath (NULL, filename),\n+\t\t      xstrerror (errno_val));\n               stat_buf.st_mtime = (time_t) -1;\n             }\n         }\n@@ -1470,8 +1491,8 @@ find_file (filename, do_not_stat)\n static void\n aux_info_corrupted ()\n {\n-  fprintf (stderr, \"\\n%s: fatal error: aux info file corrupted at line %d\\n\",\n-\t   pname, current_aux_info_lineno);\n+  notice (\"\\n%s: fatal error: aux info file corrupted at line %d\\n\",\n+\t  pname, current_aux_info_lineno);\n   exit (FATAL_EXIT_CODE);\n }\n \n@@ -1794,10 +1815,10 @@ save_def_or_dec (l, is_syscalls)\n           {\n             if (strcmp (def_dec_p->ansi_decl, other->ansi_decl))\n               {\n-                fprintf (stderr, \"%s:%d: declaration of function `%s' takes different forms\\n\",\n-\t\t\t def_dec_p->file->hash_entry->symbol,\n-\t\t\t def_dec_p->line,\n-\t\t\t def_dec_p->hash_entry->symbol);\n+                notice (\"%s:%d: declaration of function `%s' takes different forms\\n\",\n+\t\t\tdef_dec_p->file->hash_entry->symbol,\n+\t\t\tdef_dec_p->line,\n+\t\t\tdef_dec_p->hash_entry->symbol);\n                 exit (FATAL_EXIT_CODE);\n               }\n             free_def_dec (def_dec_p);\n@@ -2045,8 +2066,8 @@ gen_aux_info_file (base_filename)\n \t\t   2);\n \n   if (!quiet_flag)\n-    fprintf (stderr, \"%s: compiling `%s'\\n\",\n-\t     pname, compile_params[input_file_name_index]);\n+    notice (\"%s: compiling `%s'\\n\",\n+\t    pname, compile_params[input_file_name_index]);\n \n   {\n     char *errmsg_fmt, *errmsg_arg;\n@@ -2069,21 +2090,21 @@ gen_aux_info_file (base_filename)\n     pid = pwait (pid, &wait_status, 0);\n     if (pid == -1)\n       {\n-\tfprintf (stderr, \"%s: wait: %s\\n\", pname, xstrerror (errno));\n+\tnotice (\"%s: wait: %s\\n\", pname, xstrerror (errno));\n \treturn 0;\n       }\n     if (WIFSIGNALED (wait_status))\n       {\n-\tfprintf (stderr, \"%s: subprocess got fatal signal %d\\n\",\n-\t\t pname, WTERMSIG (wait_status));\n+\tnotice (\"%s: subprocess got fatal signal %d\\n\",\n+\t\tpname, WTERMSIG (wait_status));\n \treturn 0;\n       }\n     if (WIFEXITED (wait_status))\n       {\n \tif (WEXITSTATUS (wait_status) != 0)\n \t  {\n-\t    fprintf (stderr, \"%s: %s exited with status %d\\n\",\n-\t\t     pname, compile_params[0], WEXITSTATUS (wait_status));\n+\t    notice (\"%s: %s exited with status %d\\n\",\n+\t\t    pname, compile_params[0], WEXITSTATUS (wait_status));\n \t    return 0;\n \t  }\n \treturn 1;\n@@ -2134,18 +2155,18 @@ start_over: ;\n \t{\n \t  if (is_syscalls)\n \t    {\n-\t      fprintf (stderr, \"%s: warning: missing SYSCALLS file `%s'\\n\",\n-\t\t       pname, aux_info_filename);\n+\t      notice (\"%s: warning: missing SYSCALLS file `%s'\\n\",\n+\t\t      pname, aux_info_filename);\n \t      return;\n \t    }\n \t  must_create = 1;\n \t}\n       else\n \t{\n \t  int errno_val = errno;\n-\t  fprintf (stderr, \"%s: can't read aux info file `%s': %s\\n\",\n-\t\t   pname, shortpath (NULL, aux_info_filename),\n-\t\t   xstrerror (errno_val));\n+\t  notice (\"%s: can't read aux info file `%s': %s\\n\",\n+\t\t  pname, shortpath (NULL, aux_info_filename),\n+\t\t  xstrerror (errno_val));\n \t  errors++;\n \t  return;\n \t}\n@@ -2172,9 +2193,9 @@ start_over: ;\n       if (my_access (aux_info_filename, R_OK) == -1)\n \t{\n \t  int errno_val = errno;\n-\t  fprintf (stderr, \"%s: can't read aux info file `%s': %s\\n\",\n-\t\t   pname, shortpath (NULL, aux_info_filename),\n-\t\t   xstrerror (errno_val));\n+\t  notice (\"%s: can't read aux info file `%s': %s\\n\",\n+\t\t  pname, shortpath (NULL, aux_info_filename),\n+\t\t  xstrerror (errno_val));\n \t  errors++;\n \t  return;\n \t}\n@@ -2188,9 +2209,9 @@ start_over: ;\n     if (my_stat (aux_info_filename, &stat_buf) == -1)\n       {\n \tint errno_val = errno;\n-        fprintf (stderr, \"%s: can't get status of aux info file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"%s: can't get status of aux info file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, aux_info_filename),\n+\t\txstrerror (errno_val));\n         errors++;\n         return;\n       }\n@@ -2216,9 +2237,9 @@ start_over: ;\n \tif (my_stat (base_source_filename, &stat_buf) == -1)\n \t  {\n \t    int errno_val = errno;\n-\t    fprintf (stderr, \"%s: can't get status of aux info file `%s': %s\\n\",\n-\t\t     pname, shortpath (NULL, base_source_filename),\n-\t\t     xstrerror (errno_val));\n+\t    notice (\"%s: can't get status of aux info file `%s': %s\\n\",\n+\t\t    pname, shortpath (NULL, base_source_filename),\n+\t\t    xstrerror (errno_val));\n \t    errors++;\n \t    return;\n \t  }\n@@ -2238,9 +2259,9 @@ start_over: ;\n     if ((aux_info_file = my_open (aux_info_filename, O_RDONLY, 0444 )) == -1)\n       {\n \tint errno_val = errno;\n-        fprintf (stderr, \"%s: can't open aux info file `%s' for reading: %s\\n\",\n-\t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"%s: can't open aux info file `%s' for reading: %s\\n\",\n+\t\tpname, shortpath (NULL, aux_info_filename),\n+\t\txstrerror (errno_val));\n         return;\n       }\n   \n@@ -2256,9 +2277,9 @@ start_over: ;\n \t(int) aux_info_size)\n       {\n \tint errno_val = errno;\n-        fprintf (stderr, \"%s: error reading aux info file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"%s: error reading aux info file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, aux_info_filename),\n+\t\txstrerror (errno_val));\n         free (aux_info_base);\n         close (aux_info_file);\n         return;\n@@ -2269,9 +2290,9 @@ start_over: ;\n     if (close (aux_info_file))\n       {\n \tint errno_val = errno;\n-        fprintf (stderr, \"%s: error closing aux info file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"%s: error closing aux info file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, aux_info_filename),\n+\t\txstrerror (errno_val));\n         free (aux_info_base);\n         close (aux_info_file);\n         return;\n@@ -2285,9 +2306,9 @@ start_over: ;\n     if (my_unlink (aux_info_filename) == -1)\n       {\n \tint errno_val = errno;\n-\tfprintf (stderr, \"%s: can't delete aux info file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, aux_info_filename),\n-\t\t xstrerror (errno_val));\n+\tnotice (\"%s: can't delete aux info file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, aux_info_filename),\n+\t\txstrerror (errno_val));\n       }\n \n   /* Save a pointer into the first line of the aux_info file which\n@@ -2353,9 +2374,9 @@ start_over: ;\n                 if (keep_it && my_unlink (aux_info_filename) == -1)\n                   {\n \t\t    int errno_val = errno;\n-                    fprintf (stderr, \"%s: can't delete file `%s': %s\\n\",\n-\t\t\t     pname, shortpath (NULL, aux_info_filename),\n-\t\t\t     xstrerror (errno_val));\n+                    notice (\"%s: can't delete file `%s': %s\\n\",\n+\t\t\t    pname, shortpath (NULL, aux_info_filename),\n+\t\t\t    xstrerror (errno_val));\n                     return;\n                   }\n \t\tmust_create = 1;\n@@ -2430,18 +2451,18 @@ rename_c_file (hp)\n   if (my_link (filename, new_filename) == -1)\n     {\n       int errno_val = errno;\n-      fprintf (stderr, \"%s: warning: can't link file `%s' to `%s': %s\\n\",\n-\t       pname, shortpath (NULL, filename),\n-\t       shortpath (NULL, new_filename), xstrerror (errno_val));\n+      notice (\"%s: warning: can't link file `%s' to `%s': %s\\n\",\n+\t      pname, shortpath (NULL, filename),\n+\t      shortpath (NULL, new_filename), xstrerror (errno_val));\n       errors++;\n       return;\n     }\n \n   if (my_unlink (filename) == -1)\n     {\n       int errno_val = errno;\n-      fprintf (stderr, \"%s: warning: can't delete file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, filename), xstrerror (errno_val));\n+      notice (\"%s: warning: can't delete file `%s': %s\\n\",\n+\t      pname, shortpath (NULL, filename), xstrerror (errno_val));\n       errors++;\n       return;\n     }\n@@ -2564,14 +2585,14 @@ find_extern_def (head, user)\n             if (!conflict_noted)\t/* first time we noticed? */\n               {\n                 conflict_noted = 1;\n-                fprintf (stderr, \"%s: conflicting extern definitions of '%s'\\n\",\n-\t\t\t pname, head->hash_entry->symbol);\n+                notice (\"%s: conflicting extern definitions of '%s'\\n\",\n+\t\t\tpname, head->hash_entry->symbol);\n                 if (!quiet_flag)\n                   {\n-                    fprintf (stderr, \"%s: declarations of '%s' will not be converted\\n\",\n-\t\t\t     pname, head->hash_entry->symbol);\n-                    fprintf (stderr, \"%s: conflict list for '%s' follows:\\n\",\n-\t\t\t     pname, head->hash_entry->symbol);\n+                    notice (\"%s: declarations of '%s' will not be converted\\n\",\n+\t\t\t    pname, head->hash_entry->symbol);\n+                    notice (\"%s: conflict list for '%s' follows:\\n\",\n+\t\t\t    pname, head->hash_entry->symbol);\n                     fprintf (stderr, \"%s:     %s(%d): %s\\n\",\n \t\t\t     pname,\n \t\t\t     shortpath (NULL, extern_def_p->file->hash_entry->symbol),\n@@ -2603,10 +2624,10 @@ find_extern_def (head, user)\n           {\n             extern_def_p = dd_p;\t/* save a pointer to the definition */\n             if (!quiet_flag)\n-              fprintf (stderr, \"%s: warning: using formals list from %s(%d) for function `%s'\\n\",\n-\t\t       pname,\n-\t\t       shortpath (NULL, dd_p->file->hash_entry->symbol),\n-\t\t       dd_p->line, dd_p->hash_entry->symbol);\n+              notice (\"%s: warning: using formals list from %s(%d) for function `%s'\\n\",\n+\t\t      pname,\n+\t\t      shortpath (NULL, dd_p->file->hash_entry->symbol),\n+\t\t      dd_p->line, dd_p->hash_entry->symbol);\n             break;\n           }\n \n@@ -2643,15 +2664,15 @@ find_extern_def (head, user)\n \t\t*p++ = '?';\n                 strcpy (p, \");\");\n \n-                fprintf (stderr, \"%s: %d: `%s' used but missing from SYSCALLS\\n\",\n-\t\t\t shortpath (NULL, file), user->line,\n-\t\t\t needed+7);\t/* Don't print \"extern \" */\n+                notice (\"%s: %d: `%s' used but missing from SYSCALLS\\n\",\n+\t\t\tshortpath (NULL, file), user->line,\n+\t\t\tneeded+7);\t/* Don't print \"extern \" */\n               }\n #if 0\n             else\n-              fprintf (stderr, \"%s: %d: warning: no extern definition for `%s'\\n\",\n-\t\t       shortpath (NULL, file), user->line,\n-\t\t       user->hash_entry->symbol);\n+              notice (\"%s: %d: warning: no extern definition for `%s'\\n\",\n+\t\t      shortpath (NULL, file), user->line,\n+\t\t      user->hash_entry->symbol);\n #endif\n         }\n     }\n@@ -2680,15 +2701,15 @@ find_static_definition (user)\n   if (num_static_defs == 0)\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: warning: no static definition for `%s' in file `%s'\\n\",\n-\t\t pname, head->hash_entry->symbol,\n-\t\t shortpath (NULL, user->file->hash_entry->symbol));\n+        notice (\"%s: warning: no static definition for `%s' in file `%s'\\n\",\n+\t\tpname, head->hash_entry->symbol,\n+\t\tshortpath (NULL, user->file->hash_entry->symbol));\n     }\n   else if (num_static_defs > 1)\n     {\n-      fprintf (stderr, \"%s: multiple static defs of `%s' in file `%s'\\n\",\n-\t       pname, head->hash_entry->symbol,\n-\t       shortpath (NULL, user->file->hash_entry->symbol));\n+      notice (\"%s: multiple static defs of `%s' in file `%s'\\n\",\n+\t      pname, head->hash_entry->symbol,\n+\t      shortpath (NULL, user->file->hash_entry->symbol));\n       return NULL;\n     }\n   return static_def_p;\n@@ -2859,12 +2880,12 @@ declare_source_confusing (clean_p)\n   if (!quiet_flag)\n     {\n       if (clean_p == 0)\n-        fprintf (stderr, \"%s: %d: warning: source too confusing\\n\",\n-\t\t shortpath (NULL, convert_filename), last_known_line_number);\n+        notice (\"%s: %d: warning: source too confusing\\n\",\n+\t\tshortpath (NULL, convert_filename), last_known_line_number);\n       else\n-        fprintf (stderr, \"%s: %d: warning: source too confusing\\n\",\n-\t\t shortpath (NULL, convert_filename),\n-\t\t identify_lineno (clean_p));\n+        notice (\"%s: %d: warning: source too confusing\\n\",\n+\t\tshortpath (NULL, convert_filename),\n+\t\tidentify_lineno (clean_p));\n     }\n   longjmp (source_confusion_recovery, 1);\n }\n@@ -3068,9 +3089,9 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n   if (other_variable_style_function (definition->ansi_decl))\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: %d: warning: varargs function declaration not converted\\n\",\n-\t\t shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n-\t\t def_dec_p->line);\n+        notice (\"%s: %d: warning: varargs function declaration not converted\\n\",\n+\t\tshortpath (NULL, def_dec_p->file->hash_entry->symbol),\n+\t\tdef_dec_p->line);\n       return;\n     }\n \n@@ -3083,8 +3104,8 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n   if (setjmp (source_confusion_recovery))\n     {\n       restore_pointers ();\n-      fprintf (stderr, \"%s: declaration of function `%s' not converted\\n\",\n-\t       pname, function_to_edit);\n+      notice (\"%s: declaration of function `%s' not converted\\n\",\n+\t      pname, function_to_edit);\n       return;\n     }\n \n@@ -3206,8 +3227,8 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n       else\n         {\n           if (!quiet_flag)\n-            fprintf (stderr, \"%s: warning: too many parameter lists in declaration of `%s'\\n\",\n-\t\t     pname, def_dec_p->hash_entry->symbol);\n+            notice (\"%s: warning: too many parameter lists in declaration of `%s'\\n\",\n+\t\t    pname, def_dec_p->hash_entry->symbol);\n           check_source (0, end_formals);  /* leave the declaration intact */\n         }\n #endif /* !defined (UNPROTOIZE) */\n@@ -3227,8 +3248,8 @@ edit_fn_declaration (def_dec_p, clean_text_p)\n             if (this_f_list_chain_item)\n               {\n                 if (!quiet_flag)\n-                  fprintf (stderr, \"\\n%s: warning: too few parameter lists in declaration of `%s'\\n\",\n-\t\t\t   pname, def_dec_p->hash_entry->symbol);\n+                  notice (\"\\n%s: warning: too few parameter lists in declaration of `%s'\\n\",\n+\t\t\t  pname, def_dec_p->hash_entry->symbol);\n                 check_source (0, start_formals); /* leave the decl intact */\n               }\n #endif /* !defined (UNPROTOIZE) */\n@@ -3325,11 +3346,11 @@ edit_formals_lists (end_formals, f_list_count, def_dec_p)\n       if (func_name_len != strlen (expected)\n \t  || strncmp (func_name_start, expected, func_name_len))\n         {\n-          fprintf (stderr, \"%s: %d: warning: found `%s' but expected `%s'\\n\",\n-\t\t   shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n-\t\t   identify_lineno (func_name_start),\n-\t\t   dupnstr (func_name_start, func_name_len),\n-\t\t   expected);\n+          notice (\"%s: %d: warning: found `%s' but expected `%s'\\n\",\n+\t\t  shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n+\t\t  identify_lineno (func_name_start),\n+\t\t  dupnstr (func_name_start, func_name_len),\n+\t\t  expected);\n           return 1;\n         }\n     }\n@@ -3503,8 +3524,8 @@ add_local_decl (def_dec_p, clean_text_p)\n   if (setjmp (source_confusion_recovery))\n     {\n       restore_pointers ();\n-      fprintf (stderr, \"%s: local declaration for function `%s' not inserted\\n\",\n-\t       pname, function_to_edit);\n+      notice (\"%s: local declaration for function `%s' not inserted\\n\",\n+\t      pname, function_to_edit);\n       return;\n     }\n \n@@ -3530,8 +3551,7 @@ add_local_decl (def_dec_p, clean_text_p)\n   if (*start_of_block != '{')\n     {\n       if (!quiet_flag)\n-        fprintf (stderr,\n-          \"\\n%s: %d: warning: can't add declaration of `%s' into macro call\\n\",\n+        notice (\"\\n%s: %d: warning: can't add declaration of `%s' into macro call\\n\",\n           def_dec_p->file->hash_entry->symbol, def_dec_p->line, \n           def_dec_p->hash_entry->symbol);\n       return;\n@@ -3605,8 +3625,8 @@ add_global_decls (file_p, clean_text_p)\n   if (setjmp (source_confusion_recovery))\n     {\n       restore_pointers ();\n-      fprintf (stderr, \"%s: global declarations for file `%s' not inserted\\n\",\n-\t       pname, shortpath (NULL, file_p->hash_entry->symbol));\n+      notice (\"%s: global declarations for file `%s' not inserted\\n\",\n+\t      pname, shortpath (NULL, file_p->hash_entry->symbol));\n       return;\n     }\n \n@@ -3696,8 +3716,8 @@ edit_fn_definition (def_dec_p, clean_text_p)\n   if (setjmp (source_confusion_recovery))\n     {\n       restore_pointers ();\n-      fprintf (stderr, \"%s: definition of function `%s' not converted\\n\",\n-\t       pname, function_to_edit);\n+      notice (\"%s: definition of function `%s' not converted\\n\",\n+\t      pname, function_to_edit);\n       return;\n     }\n \n@@ -3715,19 +3735,19 @@ edit_fn_definition (def_dec_p, clean_text_p)\n   if (other_variable_style_function (def_dec_p->ansi_decl))\n     {\n       if (!quiet_flag)\n-        fprintf (stderr, \"%s: %d: warning: definition of %s not converted\\n\",\n-\t\t shortpath (NULL, def_dec_p->file->hash_entry->symbol),\n-\t\t identify_lineno (end_formals), \n-\t\t other_var_style);\n+        notice (\"%s: %d: warning: definition of %s not converted\\n\",\n+\t\tshortpath (NULL, def_dec_p->file->hash_entry->symbol),\n+\t\tidentify_lineno (end_formals), \n+\t\tother_var_style);\n       output_up_to (end_formals);\n       return;\n     }\n \n   if (edit_formals_lists (end_formals, def_dec_p->f_list_count, def_dec_p))\n     {\n       restore_pointers ();\n-      fprintf (stderr, \"%s: definition of function `%s' not converted\\n\",\n-\t       pname, function_to_edit);\n+      notice (\"%s: definition of function `%s' not converted\\n\",\n+\t      pname, function_to_edit);\n       return;\n     }\n \n@@ -4045,11 +4065,11 @@ scan_for_missed_items (file_p)\n \t\t\tgoto not_missed;\n \n #if 0\n-\t\t    fprintf (stderr, \"%s: found definition of `%s' at %s(%d)\\n\",\n-\t\t\t     pname,\n-\t\t\t     func_name,\n-\t\t\t     shortpath (NULL, file_p->hash_entry->symbol),\n-\t\t\t     identify_lineno (id_start));\n+\t\t    notice (\"%s: found definition of `%s' at %s(%d)\\n\",\n+\t\t\t    pname,\n+\t\t\t    func_name,\n+\t\t\t    shortpath (NULL, file_p->hash_entry->symbol),\n+\t\t\t    identify_lineno (id_start));\n #endif\t\t\t\t/* 0 */\n \t\t    /* We really should check for a match of the function name\n \t\t       here also, but why bother.  */\n@@ -4061,11 +4081,11 @@ scan_for_missed_items (file_p)\n \t\t    /* If we make it here, then we did not know about this\n \t\t       function definition.  */\n \n-\t\t    fprintf (stderr, \"%s: %d: warning: `%s' excluded by preprocessing\\n\",\n-\t\t\t     shortpath (NULL, file_p->hash_entry->symbol),\n-\t\t\t     identify_lineno (id_start), func_name);\n-\t\t    fprintf (stderr, \"%s: function definition not converted\\n\",\n-\t\t\t     pname);\n+\t\t    notice (\"%s: %d: warning: `%s' excluded by preprocessing\\n\",\n+\t\t\t    shortpath (NULL, file_p->hash_entry->symbol),\n+\t\t\t    identify_lineno (id_start), func_name);\n+\t\t    notice (\"%s: function definition not converted\\n\",\n+\t\t\t    pname);\n \t\t  }\n \t\tnot_missed: ;\n                 }\n@@ -4123,19 +4143,19 @@ edit_file (hp)\n           && !in_system_include_dir (convert_filename)\n #endif /* defined (UNPROTOIZE) */\n           )\n-        fprintf (stderr, \"%s: `%s' not converted\\n\",\n-\t\t pname, shortpath (NULL, convert_filename));\n+        notice (\"%s: `%s' not converted\\n\",\n+\t\tpname, shortpath (NULL, convert_filename));\n       return;\n     }\n \n   /* Let the user know what we are up to.  */\n \n   if (nochange_flag)\n-    fprintf (stderr, \"%s: would convert file `%s'\\n\",\n-\t     pname, shortpath (NULL, convert_filename));\n+    notice (\"%s: would convert file `%s'\\n\",\n+\t    pname, shortpath (NULL, convert_filename));\n   else\n-    fprintf (stderr, \"%s: converting file `%s'\\n\",\n-\t     pname, shortpath (NULL, convert_filename));\n+    notice (\"%s: converting file `%s'\\n\",\n+\t    pname, shortpath (NULL, convert_filename));\n   fflush (stderr);\n \n   /* Find out the size (in bytes) of the original file.  */\n@@ -4144,9 +4164,9 @@ edit_file (hp)\n   if (my_stat ((char *)convert_filename, &stat_buf) == -1)\n     {\n       int errno_val = errno;\n-      fprintf (stderr, \"%s: can't get status for file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, convert_filename),\n-\t       xstrerror (errno_val));\n+      notice (\"%s: can't get status for file `%s': %s\\n\",\n+\t      pname, shortpath (NULL, convert_filename),\n+\t      xstrerror (errno_val));\n       return;\n     }\n   orig_size = stat_buf.st_size;\n@@ -4180,9 +4200,9 @@ edit_file (hp)\n     if ((input_file = my_open (convert_filename, O_RDONLY, 0444)) == -1)\n       {\n \tint errno_val = errno;\n-        fprintf (stderr, \"%s: can't open file `%s' for reading: %s\\n\",\n-\t\t pname, shortpath (NULL, convert_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"%s: can't open file `%s' for reading: %s\\n\",\n+\t\tpname, shortpath (NULL, convert_filename),\n+\t\txstrerror (errno_val));\n         return;\n       }\n \n@@ -4195,9 +4215,9 @@ edit_file (hp)\n       {\n \tint errno_val = errno;\n         close (input_file);\n-        fprintf (stderr, \"\\n%s: error reading input file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, convert_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"\\n%s: error reading input file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, convert_filename),\n+\t\txstrerror (errno_val));\n         return;\n       }\n \n@@ -4229,9 +4249,9 @@ edit_file (hp)\n     if ((clean_file = creat (clean_filename, 0666)) == -1)\n       {\n \tint errno_val = errno;\n-        fprintf (stderr, \"%s: can't create/open clean file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, clean_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"%s: can't create/open clean file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, clean_filename),\n+\t\txstrerror (errno_val));\n         return;\n       }\n   \n@@ -4330,18 +4350,18 @@ edit_file (hp)\n \t  if (errno_val == EEXIST)\n             {\n               if (!quiet_flag)\n-                fprintf (stderr, \"%s: warning: file `%s' already saved in `%s'\\n\",\n-\t\t\t pname,\n-\t\t\t shortpath (NULL, convert_filename),\n-\t\t\t shortpath (NULL, new_filename));\n+                notice (\"%s: warning: file `%s' already saved in `%s'\\n\",\n+\t\t\tpname,\n+\t\t\tshortpath (NULL, convert_filename),\n+\t\t\tshortpath (NULL, new_filename));\n             }\n           else\n             {\n-              fprintf (stderr, \"%s: can't link file `%s' to `%s': %s\\n\",\n-\t\t       pname,\n-\t\t       shortpath (NULL, convert_filename),\n-\t\t       shortpath (NULL, new_filename),\n-\t\t       xstrerror (errno_val));\n+              notice (\"%s: can't link file `%s' to `%s': %s\\n\",\n+\t\t      pname,\n+\t\t      shortpath (NULL, convert_filename),\n+\t\t      shortpath (NULL, new_filename),\n+\t\t      xstrerror (errno_val));\n               return;\n             }\n         }\n@@ -4350,9 +4370,9 @@ edit_file (hp)\n   if (my_unlink (convert_filename) == -1)\n     {\n       int errno_val = errno;\n-      fprintf (stderr, \"%s: can't delete file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, convert_filename),\n-\t       xstrerror (errno_val));\n+      notice (\"%s: can't delete file `%s': %s\\n\",\n+\t      pname, shortpath (NULL, convert_filename),\n+\t      xstrerror (errno_val));\n       return;\n     }\n \n@@ -4364,9 +4384,9 @@ edit_file (hp)\n     if ((output_file = creat (convert_filename, 0666)) == -1)\n       {\n \tint errno_val = errno;\n-        fprintf (stderr, \"%s: can't create/open output file `%s': %s\\n\",\n-\t\t pname, shortpath (NULL, convert_filename),\n-\t\t xstrerror (errno_val));\n+        notice (\"%s: can't create/open output file `%s': %s\\n\",\n+\t\tpname, shortpath (NULL, convert_filename),\n+\t\txstrerror (errno_val));\n         return;\n       }\n   \n@@ -4393,9 +4413,9 @@ edit_file (hp)\n   if (my_chmod ((char *)convert_filename, stat_buf.st_mode) == -1)\n     {\n       int errno_val = errno;\n-      fprintf (stderr, \"%s: can't change mode of file `%s': %s\\n\",\n-\t       pname, shortpath (NULL, convert_filename),\n-\t       xstrerror (errno_val));\n+      notice (\"%s: can't change mode of file `%s': %s\\n\",\n+\t      pname, shortpath (NULL, convert_filename),\n+\t      xstrerror (errno_val));\n     }\n \n   /* Note:  We would try to change the owner and group of the output file\n@@ -4535,11 +4555,15 @@ main (argc, argv)\n   pname = strrchr (argv[0], '/');\n   pname = pname ? pname+1 : argv[0];\n \n+  setlocale (LC_MESSAGES, \"\");\n+  bindtextdomain (PACKAGE, localedir);\n+  textdomain (PACKAGE);\n+\n   cwd_buffer = getpwd ();\n   if (!cwd_buffer)\n     {\n-      fprintf (stderr, \"%s: cannot get working directory: %s\\n\",\n-\t       pname, xstrerror(errno));\n+      notice (\"%s: cannot get working directory: %s\\n\",\n+\t      pname, xstrerror(errno));\n       exit (FATAL_EXIT_CODE);\n     }\n \n@@ -4636,8 +4660,8 @@ main (argc, argv)\n \tbase_source_filenames[n_base_source_files++] = path;\n       else\n \t{\n-\t  fprintf (stderr, \"%s: input file names must have .c suffixes: %s\\n\",\n-\t\t   pname, shortpath (NULL, path));\n+\t  notice (\"%s: input file names must have .c suffixes: %s\\n\",\n+\t\t  pname, shortpath (NULL, path));\n \t  errors++;\n \t}\n     }"}, {"sha": "631bee018074c6540d91004742f93b823d0b36a4", "filename": "gcc/real.c", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -5655,7 +5655,6 @@ eiremain (den, num)\n }\n \n /* Report an error condition CODE encountered in function NAME.\n-   CODE is one of the following:\n \n     Mnemonic        Value          Significance\n \n@@ -5672,19 +5671,6 @@ eiremain (den, num)\n    The order of appearance of the following messages is bound to the\n    error codes defined above.  */\n \n-#define NMSGS 8\n-static char *ermsg[NMSGS] =\n-{\n-  \"unknown\",\t\t\t/* error code 0 */\n-  \"domain error\",\t\t/* error code 1 */\n-  \"singularity\",\t\t/* et seq.      */\n-  \"overflow\",\n-  \"underflow\",\n-  \"total loss of precision\",\n-  \"partial loss of precision\",\n-  \"`not-a-number' produced\"\n-};\n-\n int merror = 0;\n extern int merror;\n \n@@ -5693,14 +5679,10 @@ mtherr (name, code)\n      char *name;\n      int code;\n {\n-  char errstr[80];\n-\n   /* The string passed by the calling program is supposed to be the\n      name of the function in which the error occurred.\n      The code argument selects which error message string will be printed.  */\n \n-  if ((code <= 0) || (code >= NMSGS))\n-    code = 0;\n   if (strcmp (name, \"esub\") == 0)\n     name = \"subtraction\";\n   else if (strcmp (name, \"ediv\") == 0)\n@@ -5717,9 +5699,21 @@ mtherr (name, code)\n     name = \"modulus\";\n   else if (strcmp (name, \"esqrt\") == 0)\n     name = \"square root\";\n-  sprintf (errstr, \"%s during real %s\", ermsg[code], name);\n   if (extra_warnings)\n-    warning (errstr);\n+    {\n+      switch (code)\n+\t{\n+\tcase DOMAIN:    warning (\"%s: argument domain error\"    , name); break;\n+\tcase SING:      warning (\"%s: function singularity\"     , name); break;\n+\tcase OVERFLOW:  warning (\"%s: overflow range error\"     , name); break;\n+\tcase UNDERFLOW: warning (\"%s: underflow range error\"    , name); break;\n+\tcase TLOSS:     warning (\"%s: total loss of precision\"  , name); break;\n+\tcase PLOSS:     warning (\"%s: partial loss of precision\", name); break;\n+\tcase INVALID:   warning (\"%s: NaN - producing operation\", name); break;\n+\tdefault:        abort ();\n+\t}\n+    }\n+\n   /* Set global error message word */\n   merror = code + 1;\n }"}, {"sha": "c8331e3f2571361fe432c1951f18a628c94ea5d0", "filename": "gcc/reload.c", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -869,9 +869,11 @@ push_reload (in, out, inloc, outloc, class,\n      the class whose registers cannot be referenced in a different size\n      and M1 is not the same size as M2.  If SUBREG_WORD is nonzero, we\n      cannot reload just the inside since we might end up with the wrong\n-     register class.  */\n+     register class.  But if it is inside a STRICT_LOW_PART, we have\n+     no choice, so we hope we do get the right register class there.  */\n \n-  if (in != 0 && GET_CODE (in) == SUBREG && SUBREG_WORD (in) == 0\n+  if (in != 0 && GET_CODE (in) == SUBREG\n+      && (SUBREG_WORD (in) == 0 || strict_low)\n #ifdef CLASS_CANNOT_CHANGE_SIZE\n       && class != CLASS_CANNOT_CHANGE_SIZE\n #endif\n@@ -988,7 +990,8 @@ push_reload (in, out, inloc, outloc, class,\n      storing in a subreg is entitled to clobber it all\n      (except in the case of STRICT_LOW_PART,\n      and in that case the constraint should label it input-output.)  */\n-  if (out != 0 && GET_CODE (out) == SUBREG && SUBREG_WORD (out) == 0\n+  if (out != 0 && GET_CODE (out) == SUBREG\n+      && (SUBREG_WORD (out) == 0 || strict_low)\n #ifdef CLASS_CANNOT_CHANGE_SIZE\n       && class != CLASS_CANNOT_CHANGE_SIZE\n #endif\n@@ -2602,12 +2605,12 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t}\n       else if (code == MEM)\n \t{\n-\t  if (find_reloads_address (GET_MODE (recog_operand[i]),\n+\t  address_reloaded[i]\n+\t    = find_reloads_address (GET_MODE (recog_operand[i]),\n \t\t\t\t    recog_operand_loc[i],\n \t\t\t\t    XEXP (recog_operand[i], 0),\n \t\t\t\t    &XEXP (recog_operand[i], 0),\n-\t\t\t\t    i, address_type[i], ind_levels, insn))\n-\t    address_reloaded[i] = 1;\n+\t\t\t\t    i, address_type[i], ind_levels, insn);\n \t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n \t}\n       else if (code == SUBREG)\n@@ -2683,6 +2686,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   && reg_alternate_class (REGNO (recog_operand[i])) == NO_REGS);\n     }\n \n+#ifdef HAVE_cc0\n+  /* If we made any reloads for addresses, see if they violate a\n+     \"no input reloads\" requirement for this insn.  */\n+  if (no_input_reloads)\n+    for (i = 0; i < n_reloads; i++)\n+      if (reload_in[i] != 0)\n+\tabort ();\n+#endif\n+\n   /* If this is simply a copy from operand 1 to operand 0, merge the\n      preferred classes for the operands.  */\n   if (set != 0 && noperands >= 2 && recog_operand[0] == SET_DEST (set)\n@@ -3020,24 +3032,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t     /* If IND_LEVELS, find_reloads_address won't reload a\n \t\t\tpseudo that didn't get a hard reg, so we have to\n \t\t\treject that case.  */\n-\t\t     && (ind_levels ? offsettable_memref_p (operand)\n-\t\t\t : offsettable_nonstrict_memref_p (operand)))\n-\t\t    /* A reloaded auto-increment address is offsettable,\n-\t\t       because it is now just a simple register indirect.  */\n-\t\t    || (GET_CODE (operand) == MEM\n-\t\t\t&& address_reloaded[i]\n-\t\t\t&& (GET_CODE (XEXP (operand, 0)) == PRE_INC\n-\t\t\t    || GET_CODE (XEXP (operand, 0)) == PRE_DEC\n-\t\t\t    || GET_CODE (XEXP (operand, 0)) == POST_INC\n-\t\t\t    || GET_CODE (XEXP (operand, 0)) == POST_DEC))\n-\t\t    /* Certain mem addresses will become offsettable\n-\t\t       after they themselves are reloaded.  This is important;\n-\t\t       we don't want our own handling of unoffsettables\n-\t\t       to override the handling of reg_equiv_address.  */\n-\t\t    || (GET_CODE (operand) == MEM\n-\t\t\t&& GET_CODE (XEXP (operand, 0)) == REG\n-\t\t\t&& (ind_levels == 0\n-\t\t\t    || reg_equiv_address[REGNO (XEXP (operand, 0))] != 0))\n+\t\t     && ((ind_levels ? offsettable_memref_p (operand)\n+\t\t\t  : offsettable_nonstrict_memref_p (operand))\n+\t\t\t /* A reloaded address is offsettable because it is now\n+\t\t\t    just a simple register indirect.  */\n+\t\t\t || address_reloaded[i]))\n \t\t    || (GET_CODE (operand) == REG\n \t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t&& reg_renumber[REGNO (operand)] < 0\n@@ -4552,6 +4551,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n      rtx insn;\n {\n   register int regno;\n+  int removed_and = 0;\n   rtx tem;\n \n   /* If the address is a register, see if it is a legitimate address and\n@@ -4566,7 +4566,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t  && strict_memory_address_p (mode, reg_equiv_constant[regno]))\n \t{\n \t  *loc = ad = reg_equiv_constant[regno];\n-\t  return 1;\n+\t  return 0;\n \t}\n \n       tem = reg_equiv_memory_loc[regno];\n@@ -4671,12 +4671,22 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n   while (0);\n #endif\n \n-  /* The address is not valid.  We have to figure out why.  One possibility\n-     is that it is itself a MEM.  This can happen when the frame pointer is\n-     being eliminated, a pseudo is not allocated to a hard register, and the\n-     offset between the frame and stack pointers is not its initial value.\n-     In that case the pseudo will have been replaced by a MEM referring to\n-     the stack pointer.  */\n+  /* The address is not valid.  We have to figure out why.  First see if\n+     we have an outer AND and remove it if so.  Then analyze what's inside.  */\n+\n+  if (GET_CODE (ad) == AND)\n+    {\n+      removed_and = 1;\n+      loc = &XEXP (ad, 0);\n+      ad = *loc;\n+    }\n+\n+  /* One possibility for why the address is invalid is that it is itself\n+     a MEM.  This can happen when the frame pointer is being eliminated, a\n+     pseudo is not allocated to a hard register, and the offset between the\n+     frame and stack pointers is not its initial value.  In that case the\n+     pseudo will have been replaced by a MEM referring to the\n+     stack pointer.  */\n   if (GET_CODE (ad) == MEM)\n     {\n       /* First ensure that the address in this MEM is valid.  Then, unless\n@@ -4693,6 +4703,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t  *memrefloc = copy_rtx (*memrefloc);\n \t  copy_replacements (tem, XEXP (*memrefloc, 0));\n \t  loc = &XEXP (*memrefloc, 0);\n+\t  if (removed_and)\n+\t    loc = &XEXP (*loc, 0);\n \t}\n \n       /* Check similar cases as for indirect addresses as above except\n@@ -4713,7 +4725,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t\t       BASE_REG_CLASS, GET_MODE (tem),\n \t\t       VOIDmode, 0,\n \t\t       0, opnum, type);\n-\t  return 1;\n+\t  return ! removed_and;\n \t}\n       else\n \treturn 0;\n@@ -4735,16 +4747,21 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t{\n \t  *memrefloc = copy_rtx (*memrefloc);\n \t  loc = &XEXP (*memrefloc, 0);\n+\t  if (removed_and)\n+\t    loc = &XEXP (*loc, 0);\n \t}\n+\n       if (double_reg_address_ok)\n \t{\n \t  /* Unshare the sum as well.  */\n \t  *loc = ad = copy_rtx (ad);\n+\n \t  /* Reload the displacement into an index reg.\n \t     We assume the frame pointer or arg pointer is a base reg.  */\n \t  find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),\n \t\t\t\t     INDEX_REG_CLASS, GET_MODE (ad), opnum,\n \t\t\t\t     type, ind_levels);\n+\t  return 0;\n \t}\n       else\n \t{\n@@ -4754,7 +4771,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t  find_reloads_address_part (ad, loc, BASE_REG_CLASS,\n \t\t\t\t     Pmode, opnum, type, ind_levels);\n \t}\n-      return 1;\n+      return ! removed_and;\n     }\n \n   /* If we have an indexed stack slot, there are three possible reasons why\n@@ -4807,7 +4824,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n       find_reloads_address_1 (mode, XEXP (ad, 1), 1, &XEXP (ad, 1), opnum,\n \t\t\t      type, 0, insn);\n \n-      return 1;\n+      return 0;\n     }\n \t\t\t   \n   else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n@@ -4831,7 +4848,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n       find_reloads_address_1 (mode, XEXP (ad, 0), 1, &XEXP (ad, 0), opnum,\n \t\t\t      type, 0, insn);\n \n-      return 1;\n+      return 0;\n     }\n \t\t\t   \n   /* See if address becomes valid when an eliminable register\n@@ -4868,11 +4885,13 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t{\n \t  *memrefloc = copy_rtx (*memrefloc);\n \t  loc = &XEXP (*memrefloc, 0);\n+\t  if (removed_and)\n+\t    loc = &XEXP (*loc, 0);\n \t}\n \n       find_reloads_address_part (ad, loc, BASE_REG_CLASS, Pmode, opnum, type,\n \t\t\t\t ind_levels);\n-      return 1;\n+      return ! removed_and;\n     }\n \n   return find_reloads_address_1 (mode, ad, 0, loc, opnum, type, ind_levels,"}, {"sha": "914009beb42468fca6fcdd8f9b5b1220121e79b2", "filename": "gcc/reload1.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1175,6 +1175,28 @@ reload (first, global, dumpfile)\n \twarning (\"frame size too large for reliable stack checking\");\n     }\n \n+  /* If we are doing stack checking, give a warning if this function's\n+     frame size is larger than we expect.  */\n+  if (flag_stack_check && ! STACK_CHECK_BUILTIN)\n+    {\n+      HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;\n+      static int verbose_warned = 0; \n+   \n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (regs_ever_live[i] && ! fixed_regs[i] && call_used_regs[i])\n+\t  size += UNITS_PER_WORD;\n+\n+      if (size > STACK_CHECK_MAX_FRAME_SIZE)\n+\t{ \n+\t  warning (\"frame size too large for reliable stack checking\");\n+\t  if (! verbose_warned)\n+\t    {\n+\t      warning (\"try reducing the number of local variables\");\n+\t      verbose_warned = 1;\n+\t    }\n+\t}\n+    }\n+\n   /* Indicate that we no longer have known memory locations or constants.  */\n   if (reg_equiv_constant)\n     free (reg_equiv_constant);"}, {"sha": "2e41e71e492918d8e3c72fd7be7f9048ae4e8593", "filename": "gcc/reorg.c", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -222,25 +222,26 @@ static int *uid_to_ruid;\n /* Highest valid index in `uid_to_ruid'.  */\n static int max_uid;\n \n-static void mark_referenced_resources PROTO((rtx, struct resources *, int));\n-static void mark_set_resources\tPROTO((rtx, struct resources *, int, int));\n-static int stop_search_p\tPROTO((rtx, int));\n-static int resource_conflicts_p\tPROTO((struct resources *,\n-\t\t\t\t       struct resources *));\n-static int insn_references_resource_p PROTO((rtx, struct resources *, int));\n-static int insn_sets_resource_p PROTO((rtx, struct resources *, int));\n-static rtx find_end_label\tPROTO((void));\n-static rtx emit_delay_sequence\tPROTO((rtx, rtx, int));\n-static rtx add_to_delay_list\tPROTO((rtx, rtx));\n-static rtx delete_from_delay_slot PROTO((rtx));\n-static void delete_scheduled_jump PROTO((rtx));\n-static void note_delay_statistics PROTO((int, int));\n-static rtx optimize_skip\tPROTO((rtx));\n-static int get_jump_flags PROTO((rtx, rtx));\n-static int rare_destination PROTO((rtx));\n-static int mostly_true_jump\tPROTO((rtx, rtx));\n-static rtx get_branch_condition\tPROTO((rtx, rtx));\n-static int condition_dominates_p PROTO((rtx, rtx));\n+static void mark_referenced_resources\tPROTO((rtx, struct resources *, int));\n+static void mark_set_resources\t\tPROTO((rtx, struct resources *,\n+\t\t\t\t\t       int, int));\n+static int stop_search_p\t\tPROTO((rtx, int));\n+static int resource_conflicts_p\t\tPROTO((struct resources *,\n+\t\t\t\t\t       struct resources *));\n+static int insn_references_resource_p\tPROTO((rtx, struct resources *, int));\n+static int insn_sets_resource_p\t\tPROTO((rtx, struct resources *, int));\n+static rtx find_end_label\t\tPROTO((void));\n+static rtx emit_delay_sequence\t\tPROTO((rtx, rtx, int));\n+static rtx add_to_delay_list\t\tPROTO((rtx, rtx));\n+static rtx delete_from_delay_slot\tPROTO((rtx));\n+static void delete_scheduled_jump\tPROTO((rtx));\n+static void note_delay_statistics\tPROTO((int, int));\n+static rtx optimize_skip\t\tPROTO((rtx));\n+static int get_jump_flags\t\tPROTO((rtx, rtx));\n+static int rare_destination\t\tPROTO((rtx));\n+static int mostly_true_jump\t\tPROTO((rtx, rtx));\n+static rtx get_branch_condition\t\tPROTO((rtx, rtx));\n+static int condition_dominates_p\tPROTO((rtx, rtx));\n static rtx steal_delay_list_from_target PROTO((rtx, rtx, rtx, rtx,\n \t\t\t\t\t       struct resources *,\n \t\t\t\t\t       struct resources *,\n@@ -251,29 +252,30 @@ static rtx steal_delay_list_from_fallthrough PROTO((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    int, int *, int *));\n-static void try_merge_delay_insns PROTO((rtx, rtx));\n-static rtx redundant_insn\tPROTO((rtx, rtx, rtx));\n-static int own_thread_p\t\tPROTO((rtx, rtx, int));\n-static int find_basic_block\tPROTO((rtx));\n-static void update_block\tPROTO((rtx, rtx));\n-static int reorg_redirect_jump PROTO((rtx, rtx));\n-static void update_reg_dead_notes PROTO((rtx, rtx));\n-static void fix_reg_dead_note PROTO((rtx, rtx));\n-static void update_reg_unused_notes PROTO((rtx, rtx));\n-static void update_live_status\tPROTO((rtx, rtx));\n-static rtx next_insn_no_annul\tPROTO((rtx));\n static rtx find_dead_or_set_registers PROTO ((rtx, struct resources *, rtx *,\n \t\t\t\t\t      int, struct resources,\n \t\t\t\t\t      struct resources));\n-static void mark_target_live_regs PROTO((rtx, struct resources *));\n-static void fill_simple_delay_slots PROTO((int));\n-static rtx fill_slots_from_thread PROTO((rtx, rtx, rtx, rtx, int, int,\n-\t\t\t\t\t int, int, int *, rtx));\n-static void fill_eager_delay_slots PROTO((void));\n-static void relax_delay_slots\tPROTO((rtx));\n-static void make_return_insns\tPROTO((rtx));\n+static void try_merge_delay_insns\tPROTO((rtx, rtx));\n+static rtx redundant_insn\t\tPROTO((rtx, rtx, rtx));\n+static int own_thread_p\t\t\tPROTO((rtx, rtx, int));\n+static int find_basic_block\t\tPROTO((rtx));\n+static void update_block\t\tPROTO((rtx, rtx));\n+static int reorg_redirect_jump\t\tPROTO((rtx, rtx));\n+static void update_reg_dead_notes\tPROTO((rtx, rtx));\n+static void fix_reg_dead_note\t\tPROTO((rtx, rtx));\n+static void update_reg_unused_notes\tPROTO((rtx, rtx));\n+static void update_live_status\t\tPROTO((rtx, rtx));\n+static rtx next_insn_no_annul\t\tPROTO((rtx));\n+static void mark_target_live_regs\tPROTO((rtx, struct resources *));\n+static void fill_simple_delay_slots\tPROTO((int));\n+static rtx fill_slots_from_thread\tPROTO((rtx, rtx, rtx, rtx, int, int,\n+\t\t\t\t\t       int, int, int *, rtx));\n+static void fill_eager_delay_slots\tPROTO((void));\n+static void relax_delay_slots\t\tPROTO((rtx));\n+static void make_return_insns\t\tPROTO((rtx));\n static int redirect_with_delay_slots_safe_p PROTO ((rtx, rtx, rtx));\n static int redirect_with_delay_list_safe_p PROTO ((rtx, rtx, rtx));\n+static int check_annul_list_true_false\tPROTO ((int, rtx));\n \f\n /* Given X, some rtl, and RES, a pointer to a `struct resource', mark\n    which resources are references by the insn.  If INCLUDE_DELAYED_EFFECTS\n@@ -1006,8 +1008,8 @@ add_to_delay_list (insn, delay_list)\n   return delay_list;\n }   \n \f\n-/* Delete INSN from the delay slot of the insn that it is in.  This may\n-   produce an insn without anything in its delay slots.  */\n+/* Delete INSN from the delay slot of the insn that it is in, which may\n+   produce an insn with no delay slots.  Return the new insn.  */\n \n static rtx\n delete_from_delay_slot (insn)\n@@ -1646,6 +1648,7 @@ check_annul_list_true_false (annul_true_p, delay_list)\n \t    return 0;\n         }\n     }\n+\n   return 1;\n }\n \n@@ -1689,8 +1692,8 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n   int total_slots_filled = *pslots_filled;\n   rtx new_delay_list = 0;\n   int must_annul = *pannul_p;\n-  int i;\n   int used_annul = 0;\n+  int i;\n   struct resources cc_set;\n \n   /* We can't do anything if there are more delay slots in SEQ than we"}, {"sha": "73c675e09b333134efc072262512b5d9a6f378c3", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -715,6 +715,7 @@ extern char *note_insn_name[];\n #define FUNCTION_FLAGS_USES_CONST_POOL 0200\n #define FUNCTION_FLAGS_CALLS_LONGJMP 0400\n #define FUNCTION_FLAGS_USES_PIC_OFFSET_TABLE 01000\n+#define FUNCTION_FLAGS_ADDRESSES_LABELS 02000\n \n /* Define a macro to look for REG_INC notes,\n    but save time on machines where they never exist.  */"}, {"sha": "7390974fa56b959eb91a7b38d6acc4179c52ddd0", "filename": "gcc/system.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -414,4 +414,15 @@ extern void abort ();\n /* Get libiberty declarations. */\n #include \"libiberty.h\"\n \n+#if defined (ANSI_PROTOTYPES)\n+# define PRINTF_PROTO(ARGS, m, n) PVPROTO (ARGS) ATTRIBUTE_PRINTF(m, n)\n+#else\n+# define PRINTF_PROTO(ARGS, m, n) () ATTRIBUTE_PRINTF(m, n)\n+#endif\n+#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n+#define PRINTF_PROTO_2(ARGS) PRINTF_PROTO(ARGS, 2, 3)\n+#define PRINTF_PROTO_3(ARGS) PRINTF_PROTO(ARGS, 3, 4)\n+#define PRINTF_PROTO_4(ARGS) PRINTF_PROTO(ARGS, 4, 5)\n+\n+\n #endif /* __GCC_SYSTEM_H__ */"}, {"sha": "2e2f688f7937b86ba33b160d4cd64b19321e5b5f", "filename": "gcc/tm.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -2639,7 +2639,8 @@ allocated for arguments even when their values are passed in\n registers.\n \n The value of this macro is the size, in bytes, of the area reserved for\n-arguments passed in registers for the function represented by @var{fndecl}.\n+arguments passed in registers for the function represented by @var{fndecl},\n+which can be zero if GNU CC is calling a library function.\n \n This space can be allocated by the caller, or be a part of the\n machine-dependent stack frame: @code{OUTGOING_REG_PARM_STACK_SPACE} says"}, {"sha": "bee1e8ec8946be46648455a0fde06e8943482ef4", "filename": "gcc/toplev.c", "status": "modified", "additions": 256, "deletions": 211, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -51,6 +51,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"expr.h\"\n+#include \"intl.h\"\n \n #ifdef DWARF_DEBUGGING_INFO\n #include \"dwarfout.h\"\n@@ -162,14 +163,28 @@ extern void print_rtl ();\n extern void print_rtl_with_bb ();\n \n void rest_of_decl_compilation ();\n+void error_with_file_and_line PVPROTO((const char *file,\n+\t\t\t\t       int line, const char *s, ...));\n+void error_with_decl PVPROTO((tree decl, const char *s, ...));\n+void error_for_asm PVPROTO((rtx insn, const char *s, ...));\n+void notice PVPROTO((const char *s, ...));\n+void error PVPROTO((const char *s, ...));\n+void fatal PVPROTO((const char *s, ...));\n+void warning_with_file_and_line PVPROTO((const char *file,\n+\t\t\t\t\t int line, const char *s, ...));\n+void warning_with_decl PVPROTO((tree decl, const char *s, ...));\n+void warning PVPROTO((const char *s, ...));\n+void pedwarn PVPROTO((const char *s, ...));\n+void pedwarn_with_decl PVPROTO((tree decl, const char *s, ...));\n+void pedwarn_with_file_and_line PVPROTO((const char *file,\n+\t\t\t\t\t int line, const char *s, ...));\n+void sorry PVPROTO((const char *s, ...));\n static void set_target_switch PROTO((const char *));\n static char *decl_name PROTO((tree, int));\n static void vmessage PROTO((const char *, const char *, va_list));\n-static void v_message_with_file_and_line PROTO((const char *, int,\n-\t\t\t\t\t\tconst char *, const char *,\n-\t\t\t\t\t\tva_list));\n-static void v_message_with_decl PROTO((tree, const char *,\n-\t\t\t\t       const char *, va_list));\n+static void v_message_with_file_and_line PROTO((const char *, int, int,\n+\t\t\t\t\t\tconst char *, va_list));\n+static void v_message_with_decl PROTO((tree, int, const char *, va_list));\n static void file_and_line_for_asm PROTO((rtx, char **, int *));\n static void v_error_with_file_and_line PROTO((const char *, int,\n \t\t\t\t\t      const char *, va_list));\n@@ -187,7 +202,6 @@ static void v_pedwarn_with_decl PROTO((tree, const char *, va_list));\n static void v_pedwarn_with_file_and_line PROTO((const char *, int,\n \t\t\t\t\t\tconst char *, va_list));\n static void vsorry PROTO((const char *, va_list));\n-static void v_really_sorry PROTO((const char *, va_list)) ATTRIBUTE_NORETURN;\n static void float_signal PROTO((int)) ATTRIBUTE_NORETURN;\n static void pipe_closed PROTO((int)) ATTRIBUTE_NORETURN;\n #ifdef ASM_IDENTIFY_LANGUAGE\n@@ -542,10 +556,14 @@ int flag_fast_math = 0;\n \n int flag_volatile;\n \n-/* Nonzero means treat all global and extern variables as global.  */\n+/* Nonzero means treat all global and extern variables as volatile.  */\n \n int flag_volatile_global;\n \n+/* Nonzero means treat all static variables as volatile.  */\n+\n+int flag_volatile_static;\n+\n /* Nonzero means just do syntax checking; don't output anything.  */\n \n int flag_syntax_only = 0;\n@@ -800,6 +818,8 @@ lang_independent_options f_options[] =\n    \"Consider all mem refs through pointers as volatile\"},\n   {\"volatile-global\", &flag_volatile_global, 1,\n    \"Consider all mem refs to global data to be volatile\" },\n+  {\"volatile-static\", &flag_volatile_static, 1,\n+   \"Consider all mem refs to static data to be volatile\" },\n   {\"defer-pop\", &flag_defer_pop, 1,\n    \"Defer popping functions args from stack until later\" },\n   {\"omit-frame-pointer\", &flag_omit_frame_pointer, 1,\n@@ -1343,7 +1363,7 @@ count_error (warningp)\n \n       if (warningp && !warning_message)\n \t{\n-\t  fprintf (stderr, \"%s: warnings being treated as errors\\n\", progname);\n+\t  notice (\"%s: warnings being treated as errors\\n\", progname);\n \t  warning_message = 1;\n \t}\n       errorcount++;\n@@ -1368,19 +1388,19 @@ void\n fatal_io_error (name)\n   const char *name;\n {\n-  fprintf (stderr, \"%s: %s: I/O error\\n\", progname, name);\n+  notice (\"%s: %s: I/O error\\n\", progname, name);\n   exit (FATAL_EXIT_CODE);\n }\n \n /* Called to give a better error message for a bad insn rather than\n    just calling abort().  */\n \n void\n-fatal_insn (message, insn)\n-     const char *message;\n+fatal_insn (msgid, insn)\n+     const char *msgid;\n      rtx insn;\n {\n-  error (message);\n+  error (msgid);\n   debug_rtx (insn);\n   if (asm_out_file)\n     fflush (asm_out_file);\n@@ -1455,21 +1475,16 @@ default_print_error_function (file)\n {\n   if (last_error_function != current_function_decl)\n     {\n-      const char *kind = \"function\";\n-      if (current_function_decl != 0\n-\t  && TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n-\tkind = \"method\";\n-\n       if (file)\n \tfprintf (stderr, \"%s: \", file);\n \n       if (current_function_decl == NULL)\n-\tfprintf (stderr, \"At top level:\\n\");\n+\tnotice (\"At top level:\\n\");\n       else\n-\t{\n-\t  char *name = (*decl_printable_name) (current_function_decl, 2);\n-\t  fprintf (stderr, \"In %s `%s':\\n\", kind, name);\n-\t}\n+\tnotice ((TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE\n+\t\t ? \"In method `%s':\\n\"\n+\t\t : \"In function `%s':\\n\"),\n+\t\t(*decl_printable_name) (current_function_decl, 2));\n \n       last_error_function = current_function_decl;\n     }\n@@ -1502,13 +1517,11 @@ report_error_function (file)\n       && input_file_stack_tick != last_error_tick\n       && file == input_filename)\n     {\n-      fprintf (stderr, \"In file included\");\n       for (p = input_file_stack->next; p; p = p->next)\n-\t{\n-\t  fprintf (stderr, \" from %s:%d\", p->name, p->line);\n-\t  if (p->next)\n-\t    fprintf (stderr, \",\\n                \");\n-\t}\n+\tnotice ((p == input_file_stack->next\n+\t\t ?    \"In file included from %s:%d\"\n+\t\t : \",\\n                 from %s:%d\"),\n+\t\tp->name, p->line);\n       fprintf (stderr, \":\\n\");\n       last_error_tick = input_file_stack_tick;\n     }\n@@ -1517,76 +1530,137 @@ report_error_function (file)\n /* Print a message.  */\n \n static void\n-vmessage (prefix, s, ap)\n+vnotice (file, msgid, ap)\n+     FILE *file;\n+     char *msgid;\n+     va_list ap;\n+{\n+  vfprintf (file, _(msgid), ap);\n+}\n+\n+void\n+notice VPROTO((const char *msgid, ...))\n+{\n+#ifndef __STDC__\n+  char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef __STDC__\n+  msgid = va_arg (ap, char *);\n+#endif\n+\n+  vnotice (stderr, msgid, ap);\n+  va_end (ap);\n+}\n+\n+void\n+fnotice VPROTO((FILE *file, char *msgid, ...))\n+{\n+#ifndef __STDC__\n+  FILE *file;\n+  char *msgid;\n+#endif\n+  va_list ap;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef __STDC__\n+  file = va_arg (ap, FILE *);\n+  msgid = va_arg (ap, char *);\n+#endif\n+\n+  vnotice (file, msgid, ap);\n+  va_end (ap);\n+}\n+\n+/* Report FILE and LINE (or program name), and optionally just WARN.  */\n+\n+static void\n+report_file_and_line (file, line, warn)\n+     char *file;\n+     int line;\n+     int warn;\n+{\n+  if (file)\n+    fprintf (stderr, \"%s:%d: \", file, line);\n+  else\n+    fprintf (stderr, \"%s: \", progname);\n+\n+  if (warn)\n+    notice (\"warning: \");\n+}\n+\n+/* Print a message.  */\n+\n+static void\n+vmessage (prefix, msgid, ap)\n      const char *prefix;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   if (prefix)\n     fprintf (stderr, \"%s: \", prefix);\n \n-  vfprintf (stderr, s, ap);\n+  vfprintf (stderr, msgid, ap);\n }\n \n /* Print a message relevant to line LINE of file FILE.  */\n \n static void\n-v_message_with_file_and_line (file, line, prefix, s, ap)\n+v_message_with_file_and_line (file, line, warn, msgid, ap)\n      const char *file;\n      int line;\n-     const char *prefix;\n-     const char *s;\n+     int warn;\n+     const char *msgid;\n      va_list ap;\n {\n-  if (file)\n-    fprintf (stderr, \"%s:%d: \", file, line);\n-  else\n-    fprintf (stderr, \"%s: \", progname);\n-\n-  vmessage (prefix, s, ap);\n+  report_file_and_line (file, line, warn);\n+  vnotice (stderr, msgid, ap);\n   fputc ('\\n', stderr);\n }\n \n /* Print a message relevant to the given DECL.  */\n \n static void\n-v_message_with_decl (decl, prefix, s, ap)\n+v_message_with_decl (decl, warn, msgid, ap)\n      tree decl;\n-     const char *prefix;\n-     const char *s;\n+     int warn;\n+     const char *msgid;\n      va_list ap;\n {\n   const char *p;\n \n-  fprintf (stderr, \"%s:%d: \",\n-\t   DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl));\n-\n-  if (prefix)\n-    fprintf (stderr, \"%s: \", prefix);\n+  report_file_and_line (DECL_SOURCE_FILE (decl),\n+\t\t\tDECL_SOURCE_LINE (decl), warn);\n \n   /* Do magic to get around lack of varargs support for insertion\n      of arguments into existing list.  We know that the decl is first;\n      we ass_u_me that it will be printed with \"%s\".  */\n \n-  for (p = s; *p; ++p)\n+  for (p = _(msgid); *p; ++p)\n     {\n       if (*p == '%')\n \t{\n \t  if (*(p + 1) == '%')\n \t    ++p;\n+\t  else if (*(p + 1) != 's')\n+\t    abort ();\n \t  else\n \t    break;\n \t}\n     }\n \n-  if (p > s)\t\t\t/* Print the left-hand substring.  */\n+  if (p > _(msgid))\t\t\t/* Print the left-hand substring.  */\n     {\n       char fmt[sizeof \"%.255s\"];\n-      long width = p - s;\n+      long width = p - _(msgid);\n              \n       if (width > 255L) width = 255L;\t/* arbitrary */\n       sprintf (fmt, \"%%.%lds\", width);\n-      fprintf (stderr, fmt, s);\n+      fprintf (stderr, fmt, _(msgid));\n     }\n \n   if (*p == '%')\t\t/* Print the name.  */\n@@ -1649,72 +1723,72 @@ file_and_line_for_asm (insn, pfile, pline)\n /* Report an error at line LINE of file FILE.  */\n \n static void\n-v_error_with_file_and_line (file, line, s, ap)\n+v_error_with_file_and_line (file, line, msgid, ap)\n      const char *file;\n      int line;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   count_error (0);\n   report_error_function (file);\n-  v_message_with_file_and_line (file, line, (char *)NULL, s, ap);\n+  v_message_with_file_and_line (file, line, 0, msgid, ap);\n }\n \n void\n error_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t const char *s, ...))\n+\t\t\t\t const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *file;\n   int line;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   file = va_arg (ap, const char *);\n   line = va_arg (ap, int);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_error_with_file_and_line (file, line, s, ap);\n+  v_error_with_file_and_line (file, line, msgid, ap);\n   va_end (ap);\n }\n \n /* Report an error at the declaration DECL.\n-   S is a format string which uses %s to substitute the declaration\n+   MSGID is a format string which uses %s to substitute the declaration\n    name; subsequent substitutions are a la printf.  */\n \n static void\n-v_error_with_decl (decl, s, ap)\n+v_error_with_decl (decl, msgid, ap)\n      tree decl;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   count_error (0);\n   report_error_function (DECL_SOURCE_FILE (decl));\n-  v_message_with_decl (decl, (char *)NULL, s, ap);\n+  v_message_with_decl (decl, 0, msgid, ap);\n }\n \n void\n-error_with_decl VPROTO((tree decl, const char *s, ...))\n+error_with_decl VPROTO((tree decl, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   decl = va_arg (ap, tree);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_error_with_decl (decl, s, ap);\n+  v_error_with_decl (decl, msgid, ap);\n   va_end (ap);\n }\n \n@@ -1723,9 +1797,9 @@ error_with_decl VPROTO((tree decl, const char *s, ...))\n    and each ASM_OPERANDS records its own source file and line.  */\n \n static void\n-v_error_for_asm (insn, s, ap)\n+v_error_for_asm (insn, msgid, ap)\n      rtx insn;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   char *file;\n@@ -1734,159 +1808,159 @@ v_error_for_asm (insn, s, ap)\n   count_error (0);\n   file_and_line_for_asm (insn, &file, &line);\n   report_error_function (file);\n-  v_message_with_file_and_line (file, line, (char *)NULL, s, ap);\n+  v_message_with_file_and_line (file, line, 0, msgid, ap);\n }\n \n void\n-error_for_asm VPROTO((rtx insn, const char *s, ...))\n+error_for_asm VPROTO((rtx insn, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx insn;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   insn = va_arg (ap, rtx);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_error_for_asm (insn, s, ap);\n+  v_error_for_asm (insn, msgid, ap);\n   va_end (ap);\n }\n \n /* Report an error at the current line number.  */\n \n static void\n-verror (s, ap)\n-     const char *s;\n+verror (msgid, ap)\n+     const char *msgid;\n      va_list ap;\n {\n-  v_error_with_file_and_line (input_filename, lineno, s, ap);\n+  v_error_with_file_and_line (input_filename, lineno, msgid, ap);\n }\n \n void\n-error VPROTO((const char *s, ...))\n+error VPROTO((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, const char *);\n+  msgic = va_arg (ap, const char *);\n #endif\n \n-  verror (s, ap);\n+  verror (msgid, ap);\n   va_end (ap);\n }\n \n /* Report a fatal error at the current line number.  */\n \n static void\n-vfatal (s, ap)\n-     const char *s;\n+vfatal (msgid, ap)\n+     const char *msgid;\n      va_list ap;\n {\n-  verror (s, ap);\n+  verror (msgid, ap);\n   exit (FATAL_EXIT_CODE);\n }\n \n void\n-fatal VPROTO((const char *s, ...))\n+fatal VPROTO((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  vfatal (s, ap);\n+  vfatal (msgid, ap);\n   va_end (ap);\n }\n \n /* Report a warning at line LINE of file FILE.  */\n \n static void\n-v_warning_with_file_and_line (file, line, s, ap)\n+v_warning_with_file_and_line (file, line, msgid, ap)\n      const char *file;\n      int line;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   if (count_error (1))\n     {\n       report_error_function (file);\n-      v_message_with_file_and_line (file, line, \"warning\", s, ap);\n+      v_message_with_file_and_line (file, line, 1, msgid, ap);\n     }\n }\n \n void\n warning_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t   const char *s, ...))\n+\t\t\t\t   const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *file;\n   int line;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   file = va_arg (ap, const char *);\n   line = va_arg (ap, int);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_warning_with_file_and_line (file, line, s, ap);\n+  v_warning_with_file_and_line (file, line, msgid, ap);\n   va_end (ap);\n }\n \n /* Report a warning at the declaration DECL.\n-   S is a format string which uses %s to substitute the declaration\n+   MSGID is a format string which uses %s to substitute the declaration\n    name; subsequent substitutions are a la printf.  */\n \n static void\n-v_warning_with_decl (decl, s, ap)\n+v_warning_with_decl (decl, msgid, ap)\n      tree decl;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   if (count_error (1))\n     {\n       report_error_function (DECL_SOURCE_FILE (decl));\n-      v_message_with_decl (decl, \"warning\", s, ap);\n+      v_message_with_decl (decl, 1, msgid, ap);\n     }\n }\n \n void\n-warning_with_decl VPROTO((tree decl, const char *s, ...))\n+warning_with_decl VPROTO((tree decl, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   decl = va_arg (ap, tree);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_warning_with_decl (decl, s, ap);\n+  v_warning_with_decl (decl, msgid, ap);\n   va_end (ap);\n }\n \n@@ -1895,9 +1969,9 @@ warning_with_decl VPROTO((tree decl, const char *s, ...))\n    and each ASM_OPERANDS records its own source file and line.  */\n \n static void\n-v_warning_for_asm (insn, s, ap)\n+v_warning_for_asm (insn, msgid, ap)\n      rtx insn;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   if (count_error (1))\n@@ -1907,94 +1981,94 @@ v_warning_for_asm (insn, s, ap)\n \n       file_and_line_for_asm (insn, &file, &line);\n       report_error_function (file);\n-      v_message_with_file_and_line (file, line, \"warning\", s, ap);\n+      v_message_with_file_and_line (file, line, 1, msgid, ap);\n     }\n }\n \n void\n-warning_for_asm VPROTO((rtx insn, const char *s, ...))\n+warning_for_asm VPROTO((rtx insn, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx insn;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   insn = va_arg (ap, rtx);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_warning_for_asm (insn, s, ap);\n+  v_warning_for_asm (insn, msgid, ap);\n   va_end (ap);\n }\n \n /* Report a warning at the current line number.  */\n \n static void\n-vwarning (s, ap)\n-     const char *s;\n+vwarning (msgid, ap)\n+     const char *msgid;\n      va_list ap;\n {\n-  v_warning_with_file_and_line (input_filename, lineno, s, ap);\n+  v_warning_with_file_and_line (input_filename, lineno, msgid, ap);\n }\n \n void\n-warning VPROTO((const char *s, ...))\n+warning VPROTO((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  vwarning (s, ap);\n+  vwarning (msgid, ap);\n   va_end (ap);\n }\n \n /* These functions issue either warnings or errors depending on\n    -pedantic-errors.  */\n \n static void\n-vpedwarn (s, ap)\n-     const char *s;\n+vpedwarn (msgid, ap)\n+     const char *msgid;\n      va_list ap;\n {\n   if (flag_pedantic_errors)\n-    verror (s, ap);\n+    verror (msgid, ap);\n   else\n-    vwarning (s, ap);\n+    vwarning (msgid, ap);\n }\n \n void\n-pedwarn VPROTO((const char *s, ...))\n+pedwarn VPROTO((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  vpedwarn (s, ap);\n+  vpedwarn (msgid, ap);\n   va_end (ap);\n }\n \n static void\n-v_pedwarn_with_decl (decl, s, ap)\n+v_pedwarn_with_decl (decl, msgid, ap)\n      tree decl;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   /* We don't want -pedantic-errors to cause the compilation to fail from\n@@ -2007,133 +2081,100 @@ v_pedwarn_with_decl (decl, s, ap)\n   if (! DECL_IN_SYSTEM_HEADER (decl))\n     {\n       if (flag_pedantic_errors)\n-\tv_error_with_decl (decl, s, ap);\n+\tv_error_with_decl (decl, msgid, ap);\n       else\n-\tv_warning_with_decl (decl, s, ap);\n+\tv_warning_with_decl (decl, msgid, ap);\n     }\n }\n \n void\n-pedwarn_with_decl VPROTO((tree decl, const char *s, ...))\n+pedwarn_with_decl VPROTO((tree decl, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   tree decl;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   decl = va_arg (ap, tree);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_pedwarn_with_decl (decl, s, ap);\n+  v_pedwarn_with_decl (decl, msgid, ap);\n   va_end (ap);\n }\n \n static void\n-v_pedwarn_with_file_and_line (file, line, s, ap)\n+v_pedwarn_with_file_and_line (file, line, msgid, ap)\n      const char *file;\n      int line;\n-     const char *s;\n+     const char *msgid;\n      va_list ap;\n {\n   if (flag_pedantic_errors)\n-    v_error_with_file_and_line (file, line, s, ap);\n+    v_error_with_file_and_line (file, line, msgid, ap);\n   else\n-    v_warning_with_file_and_line (file, line, s, ap);\n+    v_warning_with_file_and_line (file, line, msgid, ap);\n }\n \n void\n pedwarn_with_file_and_line VPROTO((const char *file, int line,\n-\t\t\t\t   const char *s, ...))\n+\t\t\t\t   const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *file;\n   int line;\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n   file = va_arg (ap, const char *);\n   line = va_arg (ap, int);\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  v_pedwarn_with_file_and_line (file, line, s, ap);\n+  v_pedwarn_with_file_and_line (file, line, msgid, ap);\n   va_end (ap);\n }\n \n /* Apologize for not implementing some feature.  */\n \n static void\n-vsorry (s, ap)\n-     const char *s;\n+vsorry (msgid, ap)\n+     const char *msgid;\n      va_list ap;\n {\n   sorrycount++;\n   if (input_filename)\n     fprintf (stderr, \"%s:%d: \", input_filename, lineno);\n   else\n     fprintf (stderr, \"%s: \", progname);\n-  vmessage (\"sorry, not implemented\", s, ap);\n+  notice (\"sorry, not implemented: \");\n+  vnotice (stderr, msgid, ap);\n   fputc ('\\n', stderr);\n }\n \n void\n-sorry VPROTO((const char *s, ...))\n+sorry VPROTO((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  const char *s;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n-  VA_START (ap, s);\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, const char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n-  vsorry (s, ap);\n-  va_end (ap);\n-}\n-\n-/* Apologize for not implementing some feature, then quit.  */\n-\n-static void\n-v_really_sorry (s, ap)\n-     const char *s;\n-     va_list ap;\n-{\n-  sorrycount++;\n-  if (input_filename)\n-    fprintf (stderr, \"%s:%d: \", input_filename, lineno);\n-  else\n-    fprintf (stderr, \"%s: \", progname);\n-  vmessage (\"sorry, not implemented\", s, ap);\n-  fatal (\" (fatal)\\n\");\n-}\n-\n-void\n-really_sorry VPROTO((const char *s, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  const char *s;\n-#endif\n-  va_list ap;\n-\n-  VA_START (ap, s);\n-\n-#ifndef ANSI_PROTOTYPES\n-  s = va_arg (ap, const char *);\n-#endif\n-\n-  v_really_sorry (s, ap);\n+  vsorry (msgid, ap);\n   va_end (ap);\n }\n \f\n@@ -2899,7 +2940,7 @@ compile_file (name)\n   if (yyparse () != 0)\n     {\n       if (errorcount == 0)\n-\tfprintf (stderr, \"Errors detected in input file (your bison.simple is out of date)\");\n+\tnotice (\"Errors detected in input file (your bison.simple is out of date)\\n\");\n \n       /* In case there were missing closebraces,\n \t get us back to the global binding level.  */\n@@ -4535,6 +4576,10 @@ main (argc, argv)\n   }\n #endif\n \n+  setlocale (LC_MESSAGES, \"\");\n+  bindtextdomain (PACKAGE, localedir);\n+  textdomain (PACKAGE);\n+\n   signal (SIGFPE, float_signal);\n \n #ifdef SIGPIPE\n@@ -5196,7 +5241,7 @@ main (argc, argv)\n     {\n       char *lim = (char *) sbrk (0);\n \n-      fprintf (stderr, \"Data size %ld.\\n\", (long)(lim - (char *) &environ));\n+      notice (\"Data size %ld.\\n\", (long) (lim - (char *) &environ));\n       fflush (stderr);\n \n #ifndef __MSDOS__\n@@ -5225,7 +5270,7 @@ set_target_switch (name)\n   const char *name;\n {\n   register size_t j;\n-  int valid = 0;\n+  int valid_target_option = 0;\n \n   for (j = 0; j < sizeof target_switches / sizeof target_switches[0]; j++)\n     if (!strcmp (target_switches[j].name, name))\n@@ -5234,23 +5279,23 @@ set_target_switch (name)\n \t  target_flags &= ~-target_switches[j].value;\n \telse\n \t  target_flags |= target_switches[j].value;\n-\tvalid = 1;\n+\tvalid_target_option = 1;\n       }\n \n #ifdef TARGET_OPTIONS\n-  if (!valid)\n+  if (!valid_target_option)\n     for (j = 0; j < sizeof target_options / sizeof target_options[0]; j++)\n       {\n \tint len = strlen (target_options[j].prefix);\n \tif (!strncmp (target_options[j].prefix, name, len))\n \t  {\n \t    *target_options[j].variable = name + len;\n-\t    valid = 1;\n+\t    valid_target_option = 1;\n \t  }\n       }\n #endif\n \n-  if (!valid)\n+  if (!valid_target_option)\n     error (\"Invalid option `%s'\", name);\n }\n \f\n@@ -5263,17 +5308,17 @@ print_version (file, indent)\n      FILE *file;\n      const char *indent;\n {\n-  fprintf (file, \"%s%s%s version %s\", indent, *indent != 0 ? \" \" : \"\",\n-\t   language_string, version_string);\n-  fprintf (file, \" (%s)\", TARGET_NAME);\n-#ifdef __GNUC__\n #ifndef __VERSION__\n-#define __VERSION__ \"[unknown]\"\n+#define __VERSION__ \"[?]\"\n #endif\n-  fprintf (file, \" compiled by GNU C version %s.\\n\", __VERSION__);\n+  fnotice (file,\n+#ifdef __GNUC__\n+\t   \"%s%s%s version %s (%s) compiled by GNU C version %s.\\n\"\n #else\n-  fprintf (file, \" compiled by CC.\\n\");\n+\t   \"%s%s%s version %s (%s) compiled by CC.\\n\"\n #endif\n+\t   , indent, *indent != 0 ? \" \" : \"\",\n+\t   language_string, version_string, TARGET_NAME, __VERSION__);\n }\n \n /* Print an option value and return the adjusted position in the line.\n@@ -5323,7 +5368,7 @@ print_switch_values (file, pos, max, indent, sep, term)\n   /* Print the options as passed.  */\n \n   pos = print_single_switch (file, pos, max, indent, *indent ? \" \" : \"\", term,\n-\t\t\t     \"options passed: \", \"\");\n+\t\t\t     _(\"options passed: \"), \"\");\n \n   for (p = &save_argv[1]; *p != NULL; p++)\n     if (**p == '-')\n@@ -5352,7 +5397,7 @@ print_switch_values (file, pos, max, indent, sep, term)\n      should suffice.  */\n \n   pos = print_single_switch (file, 0, max, indent, *indent ? \" \" : \"\", term,\n-\t\t\t     \"options enabled: \", \"\");\n+\t\t\t     _(\"options enabled: \"), \"\");\n \n   for (j = 0; j < sizeof f_options / sizeof f_options[0]; j++)\n     if (*f_options[j].variable == f_options[j].on_value)"}, {"sha": "5706ecee0d9dad92d635803ee9ae5f0930db9f30", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -3324,7 +3324,7 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n   tree decl ATTRIBUTE_UNUSED;\n   tree type ATTRIBUTE_UNUSED;\n {\n-  int valid = 0;\n+  int validated = 0;\n #ifdef VALID_MACHINE_DECL_ATTRIBUTE\n   tree decl_attr_list = decl != 0 ? DECL_MACHINE_ATTRIBUTES (decl) : 0;\n #endif\n@@ -3354,12 +3354,12 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \t  decl = build_decl_attribute_variant (decl, decl_attr_list);\n \t}\n \n-      valid = 1;\n+      validated = 1;\n     }\n #endif\n \n #ifdef VALID_MACHINE_TYPE_ATTRIBUTE\n-  if (valid)\n+  if (validated)\n     /* Don't apply the attribute to both the decl and the type.  */;\n   else if (VALID_MACHINE_TYPE_ATTRIBUTE (type, type_attr_list, attr_name,\n \t\t\t\t\t attr_args))\n@@ -3388,7 +3388,7 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \t}\n       if (decl != 0)\n \tTREE_TYPE (decl) = type;\n-      valid = 1;\n+      validated = 1;\n     }\n \n   /* Handle putting a type attribute on pointer-to-function-type by putting\n@@ -3415,11 +3415,11 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n       if (decl != 0)\n \tTREE_TYPE (decl) = build_pointer_type (inner_type);\n \n-      valid = 1;\n+      validated = 1;\n     }\n #endif\n \n-  return valid;\n+  return validated;\n }\n \n /* Return non-zero if IDENT is a valid name for attribute ATTR,"}, {"sha": "dc46c98899c3b004df62eba988fdf15b2f606bbd", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -769,6 +769,10 @@ make_decl_rtl (decl, asmspec, top_level)\n \t  if (flag_volatile_global && TREE_CODE (decl) == VAR_DECL\n \t      && TREE_PUBLIC (decl))\n \t    TREE_SIDE_EFFECTS (decl) = 1;\n+\t  else if (flag_volatile_static && TREE_CODE (decl) == VAR_DECL\n+\t       && (TREE_PUBLIC (decl) || TREE_STATIC (decl)))\n+\t    TREE_SIDE_EFFECTS (decl) = 1;\n+\n \t  if (TREE_SIDE_EFFECTS (decl))\n \t    MEM_VOLATILE_P (DECL_RTL (decl)) = 1;\n \n@@ -1314,6 +1318,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n #if ! defined (ASM_OUTPUT_BSS) && ! defined (ASM_OUTPUT_ALIGNED_BSS)\n       && DECL_COMMON (decl)\n #endif\n+      && DECL_SECTION_NAME (decl) == 0\n       && ! dont_output_data)\n     {\n       int size = TREE_INT_CST_LOW (size_tree);"}, {"sha": "40957b93541e4b8513b6c88d72024417729bb32a", "filename": "gcc/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fversion.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1 +1 @@\n-char *version_string = \"egcs-2.93.03 19990127 (gcc2 ss-980609 experimental)\";\n+char *version_string = \"egcs-2.93.03 19990127 (gcc2 ss-980929 experimental)\";"}, {"sha": "4da507979baa5ff2a0d82ca6f7c1624c692b50bd", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -177,7 +177,7 @@ xcoff_output_standard_types (syms)\n \n #define UNKNOWN_STAB(STR)\t\\\n    do { \\\n-     fprintf(stderr, \"Error, unknown stab %s: : 0x%x\\n\", STR, stab); \\\n+     error (\"Unknown stab %s: : 0x%x\\n\", STR, stab);\t\\\n      fflush (stderr);\t\\\n    } while (0)\n "}, {"sha": "d6a23a4cdcaea1e79193c3f4712745cfe32c73b6", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -1,3 +1,7 @@\n+Wed Jan 27 02:31:01 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Makefile.in (ALL_CFLAGS): Add -DIN_GCC.\n+\n Tue Jan  5 01:38:53 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* configure.in (thread_file): Correct and simplify code to find"}, {"sha": "cc56ae0b91d650ef04a36263db40f8913808ce90", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab87f8c8d19d6b0954516d7f1d8733f42076be81/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab87f8c8d19d6b0954516d7f1d8733f42076be81/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=ab87f8c8d19d6b0954516d7f1d8733f42076be81", "patch": "@@ -60,7 +60,7 @@ RANLIB = @RANLIB@\n \n CC = @CC@\n CFLAGS = @CFLAGS@\n-ALL_CFLAGS = -I. -I$(srcdir) $(CPPFLAGS) $(DEFS) $(CFLAGS)\n+ALL_CFLAGS = -I. -I$(srcdir) $(CPPFLAGS) $(DEFS) $(CFLAGS) -DIN_GCC\n \n INCLUDES = -I$(srcdir)/objc  -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n   -I$(srcdir)/$(MULTISRCTOP)../gcc/config -I$(MULTIBUILDTOP)../../gcc \\"}]}