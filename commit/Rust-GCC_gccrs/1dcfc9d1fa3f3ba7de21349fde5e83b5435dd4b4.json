{"sha": "1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRjZmM5ZDFmYTNmM2JhN2RlMjEzNDlmZGU1ZTgzYjU0MzVkZDRiNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-04-30T19:08:12Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-04-30T19:08:12Z"}, "message": "parse.y (make_plus_expression): New function.\n\n\t* parse.y (make_plus_expression): New function.\n\t(expression:): Use make_plus_expression for PLUS, MINUS,\n\tASSIGN and EQUALS.\n\t* tree1.c (treelang_decode_option): Don't fall through to\n\toptions that start with a different character when an option\n\twas not recognized.\n\nFrom-SVN: r66303", "tree": {"sha": "5eed3a0ac36520f5f61266349cf765c7bf2085de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eed3a0ac36520f5f61266349cf765c7bf2085de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4/comments", "author": null, "committer": null, "parents": [{"sha": "b7bfc1c0b5168ec25f7ac314bbb21d70fd802862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7bfc1c0b5168ec25f7ac314bbb21d70fd802862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7bfc1c0b5168ec25f7ac314bbb21d70fd802862"}], "stats": {"total": 190, "additions": 82, "deletions": 108}, "files": [{"sha": "58e473320e87d3691b37ded46ac3ffc74bf1f327", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4", "patch": "@@ -1,3 +1,12 @@\n+2003-04-30  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* parse.y (make_plus_expression): New function.\n+\t(expression production): Use make_plus_expression for PLUS,\n+\tMINUS, ASSIGN and EQUALS.\n+\t* tree1.c (treelang_decode_option): Don't fall through to\n+\toptions that start with a different character when an option\n+\twas not recognized.\n+\n 2003-04-30  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* Make-lang.in (parse.c): Reorder bison arguments for POSIXLY_CORRECT."}, {"sha": "fc6256ba912e04ca3968d8f85a835ec7d5f0ba0e", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 63, "deletions": 103, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4", "patch": "@@ -83,6 +83,9 @@ static void ensure_not_void (unsigned int type, struct prod_token_parm_item* nam\n static int check_type_match (int type_num, struct prod_token_parm_item *exp);\n static int get_common_type (struct prod_token_parm_item *type1, struct prod_token_parm_item *type2);\n static struct prod_token_parm_item *make_integer_constant (struct prod_token_parm_item* value);\n+static struct prod_token_parm_item *make_plus_expression\n+  (struct prod_token_parm_item* tok, struct prod_token_parm_item* op1,\n+   struct prod_token_parm_item* op2, int type_code, int prod_code);\n static void set_storage (struct prod_token_parm_item *prod);\n \n /* File global variables.  */\n@@ -569,118 +572,41 @@ INTEGER {\n   $$ = $1;\n }\n |expression tl_PLUS expression {\n-  struct prod_token_parm_item* tok;\n-  struct prod_token_parm_item *prod;\n-  struct prod_token_parm_item *op1;\n-  struct prod_token_parm_item *op2;\n-  tree type;\n-  \n-  op1 = $1;\n-  op2 = $3;\n-  tok = $2;\n-  ensure_not_void (NUMERIC_TYPE (op1), op1->tp.pro.main_token);\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n-  prod = make_production (PROD_PLUS_EXPRESSION, tok);\n-  NUMERIC_TYPE (prod) = get_common_type (op1, op2);\n-  if (!NUMERIC_TYPE (prod))\n+  struct prod_token_parm_item *tok = $2;\n+  struct prod_token_parm_item *op1 = $1;\n+  struct prod_token_parm_item *op2 = $3;\n+  int type_code = get_common_type (op1, op2);\n+  if (!type_code)\n     YYERROR;\n-  else \n-    {\n-      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n-      if (!type)\n-        abort ();\n-      OP1 (prod) = $1;\n-      OP2 (prod) = $3;\n-      \n-      prod->tp.pro.code = tree_code_get_expression\n-        (EXP_PLUS, type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n-    }\n-  $$ = prod;\n+  $$ = make_plus_expression\n+     (tok, op1, op2, type_code, EXP_PLUS);\n }\n |expression tl_MINUS expression %prec tl_PLUS {\n-  struct prod_token_parm_item* tok;\n-  struct prod_token_parm_item *prod;\n-  struct prod_token_parm_item *op1;\n-  struct prod_token_parm_item *op2;\n-  tree type;\n-  \n-  op1 = $1;\n-  op2 = $3;\n-  ensure_not_void (NUMERIC_TYPE (op1), op1->tp.pro.main_token);\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n-  tok = $2;\n-  prod = make_production (PROD_PLUS_EXPRESSION, tok);\n-  NUMERIC_TYPE (prod) = get_common_type (op1, op2);\n-  if (!NUMERIC_TYPE (prod))\n+  struct prod_token_parm_item *tok = $2;\n+  struct prod_token_parm_item *op1 = $1;\n+  struct prod_token_parm_item *op2 = $3;\n+  int type_code = get_common_type (op1, op2);\n+  if (!type_code)\n     YYERROR;\n-  else \n-    {\n-      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n-      if (!type)\n-        abort ();\n-      OP1 (prod) = $1;\n-      OP2 (prod) = $3;\n-      \n-      prod->tp.pro.code = tree_code_get_expression (EXP_MINUS, \n-                                          type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n-    }\n-  $$ = prod;\n+  $$ = make_plus_expression\n+     (tok, op1, op2, type_code, EXP_MINUS);\n }\n |expression EQUALS expression {\n-  struct prod_token_parm_item* tok;\n-  struct prod_token_parm_item *prod;\n-  struct prod_token_parm_item *op1;\n-  struct prod_token_parm_item *op2;\n-  tree type;\n-  \n-  op1 = $1;\n-  op2 = $3;\n-  ensure_not_void (NUMERIC_TYPE (op1), op1->tp.pro.main_token);\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n-  tok = $2;\n-  prod = make_production (PROD_PLUS_EXPRESSION, tok);\n-  NUMERIC_TYPE (prod) = SIGNED_INT;\n-  if (!NUMERIC_TYPE (prod))\n-    YYERROR;\n-  else \n-    {\n-      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n-      if (!type)\n-        abort ();\n-      OP1 (prod) = $1;\n-      OP2 (prod) = $3;\n-      \n-      prod->tp.pro.code = tree_code_get_expression (EXP_EQUALS, \n-                                          type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n-    }\n-  $$ = prod;\n+  struct prod_token_parm_item *tok = $2;\n+  struct prod_token_parm_item *op1 = $1;\n+  struct prod_token_parm_item *op2 = $3;\n+  $$ = make_plus_expression\n+     (tok, op1, op2, SIGNED_INT, EXP_EQUALS);\n }\n |variable_ref ASSIGN expression {\n-  struct prod_token_parm_item* tok;\n-  struct prod_token_parm_item *prod;\n-  struct prod_token_parm_item *op1;\n-  struct prod_token_parm_item *op2;\n-  tree type;\n-  \n-  op1 = $1;\n-  op2 = $3;\n-  tok = $2;\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n-  prod = make_production (PROD_ASSIGN_EXPRESSION, tok);\n-  NUMERIC_TYPE (prod) = NUMERIC_TYPE (op1);\n-  if (!NUMERIC_TYPE (prod))\n+  struct prod_token_parm_item *tok = $2;\n+  struct prod_token_parm_item *op1 = $1;\n+  struct prod_token_parm_item *op2 = $3;\n+  int type_code = NUMERIC_TYPE (op1);\n+  if (!type_code)\n     YYERROR;\n-  else \n-    {\n-      type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n-      if (!type)\n-        abort ();\n-      OP1 (prod) = $1;\n-      OP2 (prod) = $3;\n-      prod->tp.pro.code = tree_code_get_expression (EXP_ASSIGN, \n-                                          type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n-    }\n-  $$ = prod;\n+  $$ = make_plus_expression\n+     (tok, op1, op2, type_code, EXP_ASSIGN);\n }\n |function_invocation {\n   $$ = $1;\n@@ -973,6 +899,39 @@ make_integer_constant (struct prod_token_parm_item* value)\n   return prod;\n }\n \n+\n+/* Build a PROD_PLUS_EXPRESSION.  This is uses for PLUS, MINUS, ASSIGN\n+   and EQUALS expressions.  */\n+\n+static struct prod_token_parm_item *\n+make_plus_expression (struct prod_token_parm_item* tok,\n+\t\t      struct prod_token_parm_item* op1,\n+\t\t      struct prod_token_parm_item* op2,\n+\t\t      int type_code, int prod_code)\n+{\n+  struct prod_token_parm_item *prod;\n+  tree type;\n+\n+  ensure_not_void (NUMERIC_TYPE (op1), op1->tp.pro.main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n+\n+  prod = make_production (PROD_PLUS_EXPRESSION, tok);\n+\n+  NUMERIC_TYPE (prod) = type_code;\n+  type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n+  if (!type)\n+    abort ();\n+  OP1 (prod) = op1;\n+  OP2 (prod) = op2;\n+      \n+  prod->tp.pro.code = tree_code_get_expression\n+     (prod_code, type, op1->tp.pro.code,\n+      op2->tp.pro.code, NULL);\n+\n+  return prod;\n+}\n+\n+\n /* Set STORAGE_CLASS in PROD according to CLASS_TOKEN.  */\n \n static void\n@@ -1011,3 +970,4 @@ treelang_debug (void)\n   if (option_parser_trace)\n     yydebug = 1;\n }\n+"}, {"sha": "6333d0fc0abbcbcf90f434e01e76a0f5873d9c9d", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=1dcfc9d1fa3f3ba7de21349fde5e83b5435dd4b4", "patch": "@@ -121,6 +121,8 @@ treelang_decode_option (num_options_left, first_option_left)\n           fprintf (stdout, \"Usage: tree1 [switches] -o output input\\n\");\n           return 1;\n         }\n+      break;\n+\n     case 'v':\n       if (!strcmp (first_option_left[0],\"-v\"))\n         {\n@@ -133,13 +135,17 @@ treelang_decode_option (num_options_left, first_option_left)\n             }\n           return 1;\n         }\n+      break;\n+\n     case 'y':\n       if (!strcmp (first_option_left[0],\"-y\"))\n         {\n           option_lexer_trace = 1;\n           option_parser_trace = 1;\n           return 1;\n         }\n+      break;\n+\n     case 'f':\n       if (!strcmp (first_option_left[0],\"-fparser-trace\"))\n         {\n@@ -151,7 +157,7 @@ treelang_decode_option (num_options_left, first_option_left)\n           option_lexer_trace = 1;\n           return 1;\n         }\n-      return 0;\n+      break;\n \n     case 'w':\n       if (!strcmp (first_option_left[0],\"-w\"))\n@@ -160,21 +166,20 @@ treelang_decode_option (num_options_left, first_option_left)\n              all warnings.  */\n           return 1;\n         }\n-      return 0;\n+      break;\n \n     case 'W':\n       if (!strcmp (first_option_left[0],\"-Wall\"))\n         {\n           return 1;\n         }\n-      return 0;\n+      break;\n \n     default:\n-      return 0;\n+      break;\n     }\n \n   return 0;\n-\n }\n \n /* Language dependent parser setup.  */"}]}