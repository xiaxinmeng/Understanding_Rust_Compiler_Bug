{"sha": "aa4929209a17cc4070b900d9bd2947b50c6f83d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE0OTI5MjA5YTE3Y2M0MDcwYjkwMGQ5YmQyOTQ3YjUwYzZmODNkMQ==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-04-22T23:46:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-04-22T23:46:30Z"}, "message": "compiler: Use backend interface for initialization functions.\n\n\t* go-gcc.cc (Gcc_backend::temporary_variable): Push cfun around\n\tcall to create_tmp_var.  Require that function be non-NULL.\n\nFrom-SVN: r209665", "tree": {"sha": "4a57f96317acc5e134415f90f182cd3b815dc14b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a57f96317acc5e134415f90f182cd3b815dc14b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa4929209a17cc4070b900d9bd2947b50c6f83d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4929209a17cc4070b900d9bd2947b50c6f83d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa4929209a17cc4070b900d9bd2947b50c6f83d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa4929209a17cc4070b900d9bd2947b50c6f83d1/comments", "author": null, "committer": null, "parents": [{"sha": "2195867f1d6cdc9e8d36aeeefc3c0f000bccbda3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2195867f1d6cdc9e8d36aeeefc3c0f000bccbda3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2195867f1d6cdc9e8d36aeeefc3c0f000bccbda3"}], "stats": {"total": 200, "additions": 91, "deletions": 109}, "files": [{"sha": "966fd425d787dfeec9fac58377e001d465347c3d", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=aa4929209a17cc4070b900d9bd2947b50c6f83d1", "patch": "@@ -1,3 +1,8 @@\n+2014-04-22  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::temporary_variable): Push cfun around\n+\tcall to create_tmp_var.  Require that function be non-NULL.\n+\n 2014-04-17  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc (Gcc_backend::named_constant_expression): New"}, {"sha": "376e4dc5b49ec49ecd9b0e528a9bf58da6dd979f", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=aa4929209a17cc4070b900d9bd2947b50c6f83d1", "patch": "@@ -2214,10 +2214,21 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n       return this->error_variable();\n     }\n \n+  go_assert(function != NULL);\n+  tree decl = function->get_tree();\n+\n   tree var;\n   // We can only use create_tmp_var if the type is not addressable.\n   if (!TREE_ADDRESSABLE(type_tree))\n-    var = create_tmp_var(type_tree, \"GOTMP\");\n+    {\n+      if (DECL_STRUCT_FUNCTION(decl) == NULL)\n+      \tpush_struct_function(decl);\n+      else\n+      \tpush_cfun(DECL_STRUCT_FUNCTION(decl));\n+\n+      var = create_tmp_var(type_tree, \"GOTMP\");\n+      pop_cfun();\n+    }\n   else\n     {\n       gcc_assert(bblock != NULL);\n@@ -2227,16 +2238,7 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n       DECL_ARTIFICIAL(var) = 1;\n       DECL_IGNORED_P(var) = 1;\n       TREE_USED(var) = 1;\n-      // FIXME: Permitting function to be NULL here is a temporary\n-      // measure until we have a proper representation of the init\n-      // function.\n-      if (function != NULL)\n-\tDECL_CONTEXT(var) = function->get_tree();\n-      else\n-\t{\n-\t  gcc_assert(current_function_decl != NULL_TREE);\n-\t  DECL_CONTEXT(var) = current_function_decl;\n-\t}\n+      DECL_CONTEXT(var) = decl;\n \n       // We have to add this variable to the BLOCK and the BIND_EXPR.\n       tree bind_tree = bblock->get_tree();"}, {"sha": "c00e7d16011e54ea186c4f169f1441af5d3a5940", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 19, "deletions": 84, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=aa4929209a17cc4070b900d9bd2947b50c6f83d1", "patch": "@@ -236,32 +236,6 @@ Gogo::define_builtin_function_trees()\n \t\t false);\n }\n \n-// Get the name to use for the import control function.  If there is a\n-// global function or variable, then we know that that name must be\n-// unique in the link, and we use it as the basis for our name.\n-\n-const std::string&\n-Gogo::get_init_fn_name()\n-{\n-  if (this->init_fn_name_.empty())\n-    {\n-      go_assert(this->package_ != NULL);\n-      if (this->is_main_package())\n-\t{\n-\t  // Use a name which the runtime knows.\n-\t  this->init_fn_name_ = \"__go_init_main\";\n-\t}\n-      else\n-\t{\n-\t  std::string s = this->pkgpath_symbol();\n-\t  s.append(\"..import\");\n-\t  this->init_fn_name_ = s;\n-\t}\n-    }\n-\n-  return this->init_fn_name_;\n-}\n-\n // Add statements to INIT_STMT_LIST which run the initialization\n // functions for imported packages.  This is only used for the \"main\"\n // package.\n@@ -434,65 +408,31 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n     append_to_statement_list(call, init_stmt_list);\n }\n \n-// Build the decl for the initialization function.\n-\n-tree\n-Gogo::initialization_function_decl()\n-{\n-  // The tedious details of building your own function.  There doesn't\n-  // seem to be a helper function for this.\n-  std::string name = this->package_name() + \".init\";\n-  tree fndecl = build_decl(this->package_->location().gcc_location(),\n-\t\t\t   FUNCTION_DECL, get_identifier_from_string(name),\n-\t\t\t   build_function_type(void_type_node,\n-\t\t\t\t\t       void_list_node));\n-  const std::string& asm_name(this->get_init_fn_name());\n-  SET_DECL_ASSEMBLER_NAME(fndecl, get_identifier_from_string(asm_name));\n-\n-  tree resdecl = build_decl(this->package_->location().gcc_location(),\n-\t\t\t    RESULT_DECL, NULL_TREE, void_type_node);\n-  DECL_ARTIFICIAL(resdecl) = 1;\n-  DECL_CONTEXT(resdecl) = fndecl;\n-  DECL_RESULT(fndecl) = resdecl;\n-\n-  TREE_STATIC(fndecl) = 1;\n-  TREE_USED(fndecl) = 1;\n-  DECL_ARTIFICIAL(fndecl) = 1;\n-  TREE_PUBLIC(fndecl) = 1;\n-\n-  DECL_INITIAL(fndecl) = make_node(BLOCK);\n-  TREE_USED(DECL_INITIAL(fndecl)) = 1;\n-\n-  return fndecl;\n-}\n-\n // Create the magic initialization function.  INIT_STMT_LIST is the\n // code that it needs to run.\n \n void\n-Gogo::write_initialization_function(tree fndecl, tree init_stmt_list)\n+Gogo::write_initialization_function(Named_object* initfn, tree init_stmt_list)\n {\n   // Make sure that we thought we needed an initialization function,\n   // as otherwise we will not have reported it in the export data.\n   go_assert(this->is_main_package() || this->need_init_fn_);\n \n-  if (fndecl == NULL_TREE)\n-    fndecl = this->initialization_function_decl();\n+  if (initfn == NULL)\n+    initfn = this->initialization_function_decl();\n \n-  DECL_SAVED_TREE(fndecl) = init_stmt_list;\n-\n-  if (DECL_STRUCT_FUNCTION(fndecl) == NULL)\n-    push_struct_function(fndecl);\n-  else\n-    push_cfun(DECL_STRUCT_FUNCTION(fndecl));\n-  cfun->function_start_locus = this->package_->location().gcc_location();\n-  cfun->function_end_locus = cfun->function_start_locus;\n+  Bfunction* fndecl = initfn->func_value()->get_or_make_decl(this, initfn);\n+  Location loc = this->package_->location();\n+  std::vector<Bvariable*> vars;\n+  this->backend()->block(fndecl, NULL, vars, loc, loc);\n \n-  gimplify_function_tree(fndecl);\n-\n-  cgraph_add_new_function(fndecl, false);\n-\n-  pop_cfun();\n+  if (!this->backend()->function_set_body(fndecl, tree_to_stat(init_stmt_list)))\n+    {\n+      go_assert(saw_errors());\n+      return;\n+    }\n+  gimplify_function_tree(function_to_tree(fndecl));\n+  cgraph_add_new_function(function_to_tree(fndecl), false);\n }\n \n // Search for references to VAR in any statements or called functions.\n@@ -775,7 +715,7 @@ Gogo::write_globals()\n \n   tree* vec = new tree[count];\n \n-  tree init_fndecl = NULL_TREE;\n+  Named_object* init_fndecl = NULL;\n   tree init_stmt_list = NULL_TREE;\n \n   if (this->is_main_package())\n@@ -902,17 +842,12 @@ Gogo::write_globals()\n \t    {\n \t      // We are going to create temporary variables which\n \t      // means that we need an fndecl.\n-\t      if (init_fndecl == NULL_TREE)\n+\t      if (init_fndecl == NULL)\n \t\tinit_fndecl = this->initialization_function_decl();\n-\t      if (DECL_STRUCT_FUNCTION(init_fndecl) == NULL)\n-\t\tpush_struct_function(init_fndecl);\n-\t      else\n-\t\tpush_cfun(DECL_STRUCT_FUNCTION(init_fndecl));\n+\n \t      Bvariable* var_decl = is_sink ? NULL : var;\n               var_init_stmt =\n-                  no->var_value()->get_init_block(this, NULL, var_decl);\n-\n-\t      pop_cfun();\n+                  no->var_value()->get_init_block(this, init_fndecl, var_decl);\n \t    }\n \n \t  if (var_init_stmt != NULL)\n@@ -975,7 +910,7 @@ Gogo::write_globals()\n \n   // Set up a magic function to do all the initialization actions.\n   // This will be called if this package is imported.\n-  if (init_stmt_list != NULL_TREE\n+  if (init_stmt_list != NULL\n       || this->need_init_fn_\n       || this->is_main_package())\n     this->write_initialization_function(init_fndecl, init_stmt_list);"}, {"sha": "ac9510ed9a62dc7c9b7cb05f91472baec41a3f6b", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=aa4929209a17cc4070b900d9bd2947b50c6f83d1", "patch": "@@ -575,6 +575,45 @@ Gogo::current_bindings() const\n     return this->globals_;\n }\n \n+// Get the name to use for the import control function.  If there is a\n+// global function or variable, then we know that that name must be\n+// unique in the link, and we use it as the basis for our name.\n+\n+const std::string&\n+Gogo::get_init_fn_name()\n+{\n+  if (this->init_fn_name_.empty())\n+    {\n+      go_assert(this->package_ != NULL);\n+      if (this->is_main_package())\n+\t{\n+\t  // Use a name which the runtime knows.\n+\t  this->init_fn_name_ = \"__go_init_main\";\n+\t}\n+      else\n+\t{\n+\t  std::string s = this->pkgpath_symbol();\n+\t  s.append(\"..import\");\n+\t  this->init_fn_name_ = s;\n+\t}\n+    }\n+\n+  return this->init_fn_name_;\n+}\n+\n+// Build the decl for the initialization function.\n+\n+Named_object*\n+Gogo::initialization_function_decl()\n+{\n+  std::string name = this->get_init_fn_name();\n+  Location loc = this->package_->location();\n+\n+  Function_type* fntype = Type::make_function_type(NULL, NULL, NULL, loc);\n+  Function* initfn = new Function(fntype, NULL, NULL, loc);\n+  return Named_object::make_function(name, NULL, initfn);\n+}\n+\n // Return the current block.\n \n Block*\n@@ -4071,7 +4110,12 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n         ;\n       else if (Gogo::unpack_hidden_name(no->name()) == \"init\"\n                && !this->type_->is_method())\n-        ;\n+\t;\n+      else if (no->name() == gogo->get_init_fn_name())\n+\t{\n+\t  is_visible = true;\n+\t  asm_name = no->name();\n+\t}\n       else if (Gogo::unpack_hidden_name(no->name()) == \"main\"\n                && gogo->is_main_package())\n         is_visible = true;\n@@ -4647,13 +4691,9 @@ Block::get_backend(Translate_context* context)\n \tvars.push_back((*pv)->get_backend_variable(gogo, function));\n     }\n \n-  // FIXME: Permitting FUNCTION to be NULL here is a temporary measure\n-  // until we have a proper representation of the init function.\n-  Bfunction* bfunction;\n-  if (function == NULL)\n-    bfunction = NULL;\n-  else\n-    bfunction = tree_to_function(function->func_value()->get_decl());\n+  go_assert(function != NULL);\n+  Bfunction* bfunction =\n+    function->func_value()->get_or_make_decl(gogo, function);\n   Bblock* ret = context->backend()->block(bfunction, context->bblock(),\n \t\t\t\t\t  vars, this->start_location_,\n \t\t\t\t\t  this->end_location_);"}, {"sha": "dd43d269f409ed481c703d4097d89116e5bbbb57", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa4929209a17cc4070b900d9bd2947b50c6f83d1/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=aa4929209a17cc4070b900d9bd2947b50c6f83d1", "patch": "@@ -616,6 +616,10 @@ class Gogo\n   Expression*\n   allocate_memory(Type *type, Location);\n \n+  // Get the name of the magic initialization function.\n+  const std::string&\n+  get_init_fn_name();\n+\n  private:\n   // During parsing, we keep a stack of functions.  Each function on\n   // the stack is one that we are currently parsing.  For each\n@@ -642,17 +646,13 @@ class Gogo\n   const Bindings*\n   current_bindings() const;\n \n-  // Get the name of the magic initialization function.\n-  const std::string&\n-  get_init_fn_name();\n-\n   // Get the decl for the magic initialization function.\n-  tree\n+  Named_object*\n   initialization_function_decl();\n \n   // Write the magic initialization function.\n   void\n-  write_initialization_function(tree fndecl, tree init_stmt_list);\n+  write_initialization_function(Named_object* fndecl, tree init_stmt_list);\n \n   // Initialize imported packages.\n   void"}]}