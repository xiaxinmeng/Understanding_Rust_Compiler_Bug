{"sha": "2fbd3c37634c580500e15b55b08780a9db795b70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZiZDNjMzc2MzRjNTgwNTAwZTE1YjU1YjA4NzgwYTlkYjc5NWI3MA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2018-11-16T20:18:13Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-11-16T20:18:13Z"}, "message": "constraints.md (wF constraint): Remove power9 fusion documentation.\n\n[gcc]\n2018-11-16  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/constraints.md (wF constraint): Remove power9\n\tfusion documentation.  Just document wF's use for power8 fusion.\n\t* config/rs6000/predicates.md (p9_fusion_reg_operand): Delete.\n\t(fusion_gpr_addis): Delete power9 fusion support.  Change power8\n\tfusion support to require the upper 12 bits to be all 0's or all\n\t1's.\n\t(fusion_gpr_mem_load): Add comment.\n\t(fusion_addis_mem_combo_load): Remove power9 fusion support.\n\t(fusion_addis_mem_combo_store): Delete.\n\t(fusion_offsettable_mem_operand): Delete.\n\t* config/rs6000/rs6000-cpus.def (ISA_2_7_MASKS_SERVER): Do not set\n\tpower8 fusion here.\n\t(ISA_3_0_MASKS_SERVER): Delete power9 fusion.\n\t(POWERPC_MASKS): Delete power9 fusion.\n\t* config/rs6000/rs6000-protos.h (emit_fusion_load_store): Delete.\n\t(fusion_p9_p): Delete.\n\t(expand_fusion_p9_load): Delete.\n\t(expand_fusion_p9_store): Delete.\n\t(emit_fusion_p9_load): Delete.\n\t(emit_fusion_p9_store): Delete.\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Delete power9\n\tfusion support.\n\t(rs6000_option_override_internal): Set power8 fusion based on\n\twhether we are tuning for power8.  Delete power9 fusion support.\n\t(rs6000_opt_masks): Delete -mpower9-fusion switch.\n\t(emit_fusion_load): Rename emit_fusion_load_store to\n\temit_fusion_load, and drop fusion store support.  Update callers.\n\t(emit_fusion_load_store): Likewise.\n\t(emit_fusion_gpr_load): Likewise.\n\t(fusion_p9_p): Delete.\n\t(expand_fusion_p9_load): Delete.\n\t(expand_fusion_p9_store): Delete.\n\t(emit_fusion_p9_load): Delete.\n\t(emit_fusion_p9_store): Delete.\n\t* config/rs6000/rs6000.md (UNSPEC_FUSION_P9): Delete.\n\t(GPR_FUSION): Delete.\n\t(FPR_FUSION): Delete.\n\t(power9 fusion peephole2s): Delete.\n\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load): Delete.\n\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store): Delete.\n\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load): Delete.\n\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store): Delete.\n\t(fusion_p9_<mode>_constant): Delete.\n\t* config/rs6000/rs6000.opt (-mpower9-fusion): Delete undocumented\n\tpower9 fusion switch.\n\t* doc/md.texi (PowerPC constraints): Update wF constraint\n\tdocumentation for power8 fusion only.\n\n[gcc/testsuite]\n2018-11-16  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* gcc.target/powerpc/fusion3.c: Delete.\n\t* gcc.target/powerpc/fusion4.c: Delete.\n\nFrom-SVN: r266220", "tree": {"sha": "b7510a732341256ca5d623a545c98f38ec783d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7510a732341256ca5d623a545c98f38ec783d87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fbd3c37634c580500e15b55b08780a9db795b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbd3c37634c580500e15b55b08780a9db795b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbd3c37634c580500e15b55b08780a9db795b70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbd3c37634c580500e15b55b08780a9db795b70/comments", "author": null, "committer": null, "parents": [{"sha": "a09ad34709696a3d02ae588e7a595fd379b885b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09ad34709696a3d02ae588e7a595fd379b885b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a09ad34709696a3d02ae588e7a595fd379b885b0"}], "stats": {"total": 802, "additions": 83, "deletions": 719}, "files": [{"sha": "713f1c367fb03f5898901f51a09421c6de2bfe0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -1,3 +1,53 @@\n+2018-11-16  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/constraints.md (wF constraint): Remove power9\n+\tfusion documentation.  Just document wF's use for power8 fusion.\n+\t* config/rs6000/predicates.md (p9_fusion_reg_operand): Delete.\n+\t(fusion_gpr_addis): Delete power9 fusion support.  Change power8\n+\tfusion support to require the upper 12 bits to be all 0's or all\n+\t1's.\n+\t(fusion_gpr_mem_load): Add comment.\n+\t(fusion_addis_mem_combo_load): Remove power9 fusion support.\n+\t(fusion_addis_mem_combo_store): Delete.\n+\t(fusion_offsettable_mem_operand): Delete.\n+\t* config/rs6000/rs6000-cpus.def (ISA_2_7_MASKS_SERVER): Do not set\n+\tpower8 fusion here.\n+\t(ISA_3_0_MASKS_SERVER): Delete power9 fusion.\n+\t(POWERPC_MASKS): Delete power9 fusion.\n+\t* config/rs6000/rs6000-protos.h (emit_fusion_load_store): Delete.\n+\t(fusion_p9_p): Delete.\n+\t(expand_fusion_p9_load): Delete.\n+\t(expand_fusion_p9_store): Delete.\n+\t(emit_fusion_p9_load): Delete.\n+\t(emit_fusion_p9_store): Delete.\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Delete power9\n+\tfusion support.\n+\t(rs6000_option_override_internal): Set power8 fusion based on\n+\twhether we are tuning for power8.  Delete power9 fusion support.\n+\t(rs6000_opt_masks): Delete -mpower9-fusion switch.\n+\t(emit_fusion_load): Rename emit_fusion_load_store to\n+\temit_fusion_load, and drop fusion store support.  Update callers.\n+\t(emit_fusion_load_store): Likewise.\n+\t(emit_fusion_gpr_load): Likewise.\n+\t(fusion_p9_p): Delete.\n+\t(expand_fusion_p9_load): Delete.\n+\t(expand_fusion_p9_store): Delete.\n+\t(emit_fusion_p9_load): Delete.\n+\t(emit_fusion_p9_store): Delete.\n+\t* config/rs6000/rs6000.md (UNSPEC_FUSION_P9): Delete.\n+\t(GPR_FUSION): Delete.\n+\t(FPR_FUSION): Delete.\n+\t(power9 fusion peephole2s): Delete.\n+\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load): Delete.\n+\t(fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store): Delete.\n+\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load): Delete.\n+\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store): Delete.\n+\t(fusion_p9_<mode>_constant): Delete.\n+\t* config/rs6000/rs6000.opt (-mpower9-fusion): Delete undocumented\n+\tpower9 fusion switch.\n+\t* doc/md.texi (PowerPC constraints): Update wF constraint\n+\tdocumentation for power8 fusion only.\n+\n 2018-11-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/87475"}, {"sha": "90aba1e77d34e5943a8e3c921a99380a198667cd", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -154,7 +154,7 @@\n \n ;; Extended fusion store\n (define_memory_constraint \"wF\"\n-  \"Memory operand suitable for power9 fusion load/stores\"\n+  \"Memory operand suitable for power8 GPR load fusion\"\n   (match_operand 0 \"fusion_addis_mem_combo_load\"))\n \n (define_register_constraint \"wH\" \"rs6000_constraints[RS6000_CONSTRAINT_wH]\""}, {"sha": "5589ea19519eded746e185c6b290888a00996ad5", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 10, "deletions": 144, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -406,48 +406,6 @@\n   return FP_REGNO_P (r);\n })\n \n-;; Return true if this is a register that can has D-form addressing (GPR,\n-;; traditional FPR registers, and Altivec registers for scalars).  Unlike\n-;; power8 fusion, this fusion does not depend on putting the ADDIS instruction\n-;; into the GPR register being loaded.\n-(define_predicate \"p9_fusion_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  HOST_WIDE_INT r;\n-  bool gpr_p = (mode == QImode || mode == HImode || mode == SImode\n-\t\t|| mode == SFmode\n-\t\t|| (TARGET_POWERPC64 && (mode == DImode || mode == DFmode)));\n-  bool fpr_p = (TARGET_P9_FUSION\n-\t\t&& (mode == DFmode || mode == SFmode\n-\t\t    || (TARGET_POWERPC64 && mode == DImode)));\n-  bool vmx_p = (TARGET_P9_FUSION && TARGET_P9_VECTOR\n-\t\t&& (mode == DFmode || mode == SFmode));\n-\n-  if (!TARGET_P8_FUSION)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (!REG_P (op))\n-    return 0;\n-\n-  r = REGNO (op);\n-  if (r >= FIRST_PSEUDO_REGISTER)\n-    return (gpr_p || fpr_p || vmx_p);\n-\n-  if (INT_REGNO_P (r))\n-    return gpr_p;\n-\n-  if (FP_REGNO_P (r))\n-    return fpr_p;\n-\n-  if (ALTIVEC_REGNO_P (r))\n-    return vmx_p;\n-\n-  return 0;\n-})\n-\n ;; Return 1 if op is a HTM specific SPR register.\n (define_predicate \"htm_spr_reg_operand\"\n   (match_operand 0 \"register_operand\")\n@@ -1691,13 +1649,9 @@\n   if ((value & (HOST_WIDE_INT)0xffff0000) == 0)\n     return 0;\n \n-  /* Power8 currently will only do the fusion if the top 11 bits of the addis\n-     value are all 1's or 0's.  Ignore this restriction if we are testing\n-     advanced fusion.  */\n-  if (TARGET_P9_FUSION)\n-    return 1;\n-\n-  return (IN_RANGE (value >> 16, -32, 31));\n+  /* Power8 only does the fusion if the top 12 bits of the addis value are all\n+     1's or 0's.  */\n+  return (IN_RANGE (value >> 16, -16, 15));\n })\n \n ;; Match the second insn (lbz, lhz, lwz, ld) in fusing the combination of addis\n@@ -1730,6 +1684,8 @@\n \treturn 0;\n       break;\n \n+    /* Do not allow SF/DFmode in GPR fusion.  While the loads do occur, they\n+       are not common.  */\n     default:\n       return 0;\n     }\n@@ -1762,14 +1718,13 @@\n ;; Match a GPR load (lbz, lhz, lwz, ld) that uses a combined address in the\n ;; memory field with both the addis and the memory offset.  Sign extension\n ;; is not handled here, since lha and lwa are not fused.\n-;; With P9 fusion, also match a fpr/vector load and float_extend\n (define_predicate \"fusion_addis_mem_combo_load\"\n-  (match_code \"mem,zero_extend,float_extend\")\n+  (match_code \"mem,zero_extend\")\n {\n   rtx addr, base, offset;\n \n-  /* Handle zero/float extend.  */\n-  if (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == FLOAT_EXTEND)\n+  /* Handle zero extend.  */\n+  if (GET_CODE (op) == ZERO_EXTEND)\n     {\n       op = XEXP (op, 0);\n       mode = GET_MODE (op);\n@@ -1792,20 +1747,8 @@\n \treturn 0;\n       break;\n \n-    /* ISA 2.08/power8 only had fusion of GPR loads.  */\n-    case E_SFmode:\n-      if (!TARGET_P9_FUSION)\n-\treturn 0;\n-      break;\n-\n-    /* ISA 2.08/power8 only had fusion of GPR loads.  Do not allow 64-bit\n-       DFmode in 32-bit if -msoft-float since it splits into two separate\n-       instructions.  */\n-    case E_DFmode:\n-      if ((!TARGET_POWERPC64 && !TARGET_HARD_FLOAT) || !TARGET_P9_FUSION)\n-\treturn 0;\n-      break;\n-\n+    /* Do not allow SF/DFmode in GPR fusion.  While the loads do occur, they\n+       are not common.  */\n     default:\n       return 0;\n     }\n@@ -1833,80 +1776,3 @@\n \n   return 0;\n })\n-\n-;; Like fusion_addis_mem_combo_load, but for stores\n-(define_predicate \"fusion_addis_mem_combo_store\"\n-  (match_code \"mem\")\n-{\n-  rtx addr, base, offset;\n-\n-  if (!MEM_P (op) || !TARGET_P9_FUSION)\n-    return 0;\n-\n-  switch (mode)\n-    {\n-    case E_QImode:\n-    case E_HImode:\n-    case E_SImode:\n-    case E_SFmode:\n-      break;\n-\n-    /* Do not fuse 64-bit DImode in 32-bit since it splits into two\n-       separate instructions.  */\n-    case E_DImode:\n-      if (!TARGET_POWERPC64)\n-\treturn 0;\n-      break;\n-\n-    /* Do not allow 64-bit DFmode in 32-bit if -msoft-float since it splits\n-       into two separate instructions.  Do allow fusion if we have hardware\n-       floating point.  */\n-    case E_DFmode:\n-      if (!TARGET_POWERPC64 && !TARGET_HARD_FLOAT)\n-\treturn 0;\n-      break;\n-\n-    default:\n-      return 0;\n-    }\n-\n-  addr = XEXP (op, 0);\n-  if (GET_CODE (addr) != PLUS && GET_CODE (addr) != LO_SUM)\n-    return 0;\n-\n-  base = XEXP (addr, 0);\n-  if (!fusion_gpr_addis (base, GET_MODE (base)))\n-    return 0;\n-\n-  offset = XEXP (addr, 1);\n-  if (GET_CODE (addr) == PLUS)\n-    return satisfies_constraint_I (offset);\n-\n-  else if (GET_CODE (addr) == LO_SUM)\n-    {\n-      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n-\treturn small_toc_ref (offset, GET_MODE (offset));\n-\n-      else if (TARGET_ELF && !TARGET_POWERPC64)\n-\treturn CONSTANT_P (offset);\n-    }\n-\n-  return 0;\n-})\n-\n-;; Return true if the operand is a float_extend or zero extend of an\n-;; offsettable memory operand suitable for use in fusion\n-(define_predicate \"fusion_offsettable_mem_operand\"\n-  (match_code \"mem,zero_extend,float_extend\")\n-{\n-  if (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == FLOAT_EXTEND)\n-    {\n-      op = XEXP (op, 0);\n-      mode = GET_MODE (op);\n-    }\n-\n-  if (!memory_operand (op, mode))\n-    return 0;\n-\n-  return offsettable_nonstrict_memref_p (op);\n-})"}, {"sha": "b980ae4f445abf2e182f8f7f2e1fe1b61db02348", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -44,9 +44,10 @@\n \t\t\t\t | OPTION_MASK_ALTIVEC\t\t\t\\\n \t\t\t\t | OPTION_MASK_VSX)\n \n-/* For now, don't provide an embedded version of ISA 2.07.  */\n+/* For now, don't provide an embedded version of ISA 2.07.  Do not set power8\n+   fusion here, instead set it in rs6000.c if we are tuning for a power8\n+   system.  */\n #define ISA_2_7_MASKS_SERVER\t(ISA_2_6_MASKS_SERVER\t\t\t\\\n-\t\t\t\t | OPTION_MASK_P8_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_P8_VECTOR\t\t\\\n \t\t\t\t | OPTION_MASK_CRYPTO\t\t\t\\\n \t\t\t\t | OPTION_MASK_DIRECT_MOVE\t\t\\\n@@ -60,7 +61,6 @@\n #define ISA_3_0_MASKS_SERVER\t(ISA_2_7_MASKS_SERVER\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n \t\t\t\t | OPTION_MASK_MODULO\t\t\t\\\n-\t\t\t\t | OPTION_MASK_P9_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_P9_MINMAX\t\t\\\n \t\t\t\t | OPTION_MASK_P9_MISC\t\t\t\\\n \t\t\t\t | OPTION_MASK_P9_VECTOR)\n@@ -121,7 +121,6 @@\n \t\t\t\t | OPTION_MASK_NO_UPDATE\t\t\\\n \t\t\t\t | OPTION_MASK_P8_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_P8_VECTOR\t\t\\\n-\t\t\t\t | OPTION_MASK_P9_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_P9_MINMAX\t\t\\\n \t\t\t\t | OPTION_MASK_P9_MISC\t\t\t\\\n \t\t\t\t | OPTION_MASK_P9_VECTOR\t\t\\"}, {"sha": "6e58ce78d08d4b91edfd5b9ee570d586becf0f30", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -91,13 +91,7 @@ extern bool quad_load_store_p (rtx, rtx);\n extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx);\n extern void expand_fusion_gpr_load (rtx *);\n extern void emit_fusion_addis (rtx, rtx);\n-extern void emit_fusion_load_store (rtx, rtx, rtx, const char *);\n extern const char *emit_fusion_gpr_load (rtx, rtx);\n-extern bool fusion_p9_p (rtx, rtx, rtx, rtx);\n-extern void expand_fusion_p9_load (rtx *);\n-extern void expand_fusion_p9_store (rtx *);\n-extern const char *emit_fusion_p9_load (rtx, rtx, rtx);\n-extern const char *emit_fusion_p9_store (rtx, rtx, rtx);\n extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n \t\t\t\t\t\t\t    enum reg_class);\n extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,"}, {"sha": "276526381f1124ba07561aaf4bb977d46d26cd42", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 13, "deletions": 387, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -2787,7 +2787,7 @@ rs6000_debug_reg_global (void)\n     {\n       char options[80];\n \n-      strcpy (options, (TARGET_P9_FUSION) ? \"power9\" : \"power8\");\n+      strcpy (options, \"power8\");\n       if (TARGET_P8_FUSION_SIGN)\n \tstrcat (options, \", sign\");\n \n@@ -4163,10 +4163,15 @@ rs6000_option_override_internal (bool global_init_p)\n     rs6000_isa_flags |= OPTION_MASK_SAVE_TOC_INDIRECT;\n \n   /* Enable power8 fusion if we are tuning for power8, even if we aren't\n-     generating power8 instructions.  */\n+     generating power8 instructions.  Power9 does not optimize power8 fusion\n+     cases.  */\n   if (!(rs6000_isa_flags_explicit & OPTION_MASK_P8_FUSION))\n-    rs6000_isa_flags |= (processor_target_table[tune_index].target_enable\n-\t\t\t & OPTION_MASK_P8_FUSION);\n+    {\n+      if (processor_target_table[tune_index].processor == PROCESSOR_POWER8)\n+\trs6000_isa_flags |= OPTION_MASK_P8_FUSION;\n+      else\n+\trs6000_isa_flags &= ~OPTION_MASK_P8_FUSION;\n+    }\n \n   /* Setting additional fusion flags turns on base fusion.  */\n   if (!TARGET_P8_FUSION && TARGET_P8_FUSION_SIGN)\n@@ -4183,28 +4188,6 @@ rs6000_option_override_internal (bool global_init_p)\n \trs6000_isa_flags |= OPTION_MASK_P8_FUSION;\n     }\n \n-  /* Power9 fusion is a superset over power8 fusion.  */\n-  if (TARGET_P9_FUSION && !TARGET_P8_FUSION)\n-    {\n-      if (rs6000_isa_flags_explicit & OPTION_MASK_P8_FUSION)\n-\t{\n-\t  /* We prefer to not mention undocumented options in\n-\t     error messages.  However, if users have managed to select\n-\t     power9-fusion without selecting power8-fusion, they\n-\t     already know about undocumented flags.  */\n-\t  error (\"%qs requires %qs\", \"-mpower9-fusion\", \"-mpower8-fusion\");\n-\t  rs6000_isa_flags &= ~OPTION_MASK_P9_FUSION;\n-\t}\n-      else\n-\trs6000_isa_flags |= OPTION_MASK_P8_FUSION;\n-    }\n-\n-  /* Enable power9 fusion if we are tuning for power9, even if we aren't\n-     generating power9 instructions.  */\n-  if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_FUSION))\n-    rs6000_isa_flags |= (processor_target_table[tune_index].target_enable\n-\t\t\t & OPTION_MASK_P9_FUSION);\n-\n   /* Power8 does not fuse sign extended loads with the addis.  If we are\n      optimizing at high levels for speed, convert a sign extended load into a\n      zero extending load, and an explicit sign extension.  */\n@@ -36002,7 +35985,6 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"power8-fusion\",\t\tOPTION_MASK_P8_FUSION,\t\tfalse, true  },\n   { \"power8-fusion-sign\",\tOPTION_MASK_P8_FUSION_SIGN,\tfalse, true  },\n   { \"power8-vector\",\t\tOPTION_MASK_P8_VECTOR,\t\tfalse, true  },\n-  { \"power9-fusion\",\t\tOPTION_MASK_P9_FUSION,\t\tfalse, true  },\n   { \"power9-minmax\",\t\tOPTION_MASK_P9_MINMAX,\t\tfalse, true  },\n   { \"power9-misc\",\t\tOPTION_MASK_P9_MISC,\t\tfalse, true  },\n   { \"power9-vector\",\t\tOPTION_MASK_P9_VECTOR,\t\tfalse, true  },\n@@ -38106,14 +38088,13 @@ emit_fusion_addis (rtx target, rtx addis_value)\n /* Emit a D-form load or store instruction that is the second instruction\n    of a fusion sequence.  */\n \n-void\n-emit_fusion_load_store (rtx load_store_reg, rtx addis_reg, rtx offset,\n-\t\t\tconst char *insn_str)\n+static void\n+emit_fusion_load (rtx load_reg, rtx addis_reg, rtx offset, const char *insn_str)\n {\n   rtx fuse_ops[10];\n   char insn_template[80];\n \n-  fuse_ops[0] = load_store_reg;\n+  fuse_ops[0] = load_reg;\n   fuse_ops[1] = addis_reg;\n \n   if (CONST_INT_P (offset) && satisfies_constraint_I (offset))\n@@ -38251,367 +38232,12 @@ emit_fusion_gpr_load (rtx target, rtx mem)\n   emit_fusion_addis (target, addis_value);\n \n   /* Emit the D-form load instruction.  */\n-  emit_fusion_load_store (target, target, load_offset, load_str);\n+  emit_fusion_load (target, target, load_offset, load_str);\n \n   return \"\";\n }\n \f\n \n-/* Return true if the peephole2 can combine a load/store involving a\n-   combination of an addis instruction and the memory operation.  This was\n-   added to the ISA 3.0 (power9) hardware.  */\n-\n-bool\n-fusion_p9_p (rtx addis_reg,\t\t/* register set via addis.  */\n-\t     rtx addis_value,\t\t/* addis value.  */\n-\t     rtx dest,\t\t\t/* destination (memory or register). */\n-\t     rtx src)\t\t\t/* source (register or memory).  */\n-{\n-  rtx addr, mem, offset;\n-  machine_mode mode = GET_MODE (src);\n-\n-  /* Validate arguments.  */\n-  if (!base_reg_operand (addis_reg, GET_MODE (addis_reg)))\n-    return false;\n-\n-  if (!fusion_gpr_addis (addis_value, GET_MODE (addis_value)))\n-    return false;\n-\n-  /* Ignore extend operations that are part of the load.  */\n-  if (GET_CODE (src) == FLOAT_EXTEND || GET_CODE (src) == ZERO_EXTEND)\n-    src = XEXP (src, 0);\n-\n-  /* Test for memory<-register or register<-memory.  */\n-  if (fpr_reg_operand (src, mode) || int_reg_operand (src, mode))\n-    {\n-      if (!MEM_P (dest))\n-\treturn false;\n-\n-      mem = dest;\n-    }\n-\n-  else if (MEM_P (src))\n-    {\n-      if (!fpr_reg_operand (dest, mode) && !int_reg_operand (dest, mode))\n-\treturn false;\n-\n-      mem = src;\n-    }\n-\n-  else\n-    return false;\n-\n-  addr = XEXP (mem, 0);\t\t\t/* either PLUS or LO_SUM.  */\n-  if (GET_CODE (addr) == PLUS)\n-    {\n-      if (!rtx_equal_p (addis_reg, XEXP (addr, 0)))\n-\treturn false;\n-\n-      return satisfies_constraint_I (XEXP (addr, 1));\n-    }\n-\n-  else if (GET_CODE (addr) == LO_SUM)\n-    {\n-      if (!rtx_equal_p (addis_reg, XEXP (addr, 0)))\n-\treturn false;\n-\n-      offset = XEXP (addr, 1);\n-      if (TARGET_XCOFF || (TARGET_ELF && TARGET_POWERPC64))\n-\treturn small_toc_ref (offset, GET_MODE (offset));\n-\n-      else if (TARGET_ELF && !TARGET_POWERPC64)\n-\treturn CONSTANT_P (offset);\n-    }\n-\n-  return false;\n-}\n-\n-/* During the peephole2 pass, adjust and expand the insns for an extended fusion\n-   load sequence.\n-\n-   The operands are:\n-\toperands[0]\tregister set with addis\n-\toperands[1]\tvalue set via addis\n-\toperands[2]\ttarget register being loaded\n-\toperands[3]\tD-form memory reference using operands[0].\n-\n-  This is similar to the fusion introduced with power8, except it scales to\n-  both loads/stores and does not require the result register to be the same as\n-  the base register.  At the moment, we only do this if register set with addis\n-  is dead.  */\n-\n-void\n-expand_fusion_p9_load (rtx *operands)\n-{\n-  rtx tmp_reg = operands[0];\n-  rtx addis_value = operands[1];\n-  rtx target = operands[2];\n-  rtx orig_mem = operands[3];\n-  rtx  new_addr, new_mem, orig_addr, offset, set, clobber, insn;\n-  enum rtx_code plus_or_lo_sum;\n-  machine_mode target_mode = GET_MODE (target);\n-  machine_mode extend_mode = target_mode;\n-  machine_mode ptr_mode = Pmode;\n-  enum rtx_code extend = UNKNOWN;\n-\n-  if (GET_CODE (orig_mem) == FLOAT_EXTEND || GET_CODE (orig_mem) == ZERO_EXTEND)\n-    {\n-      extend = GET_CODE (orig_mem);\n-      orig_mem = XEXP (orig_mem, 0);\n-      target_mode = GET_MODE (orig_mem);\n-    }\n-\n-  gcc_assert (MEM_P (orig_mem));\n-\n-  orig_addr = XEXP (orig_mem, 0);\n-  plus_or_lo_sum = GET_CODE (orig_addr);\n-  gcc_assert (plus_or_lo_sum == PLUS || plus_or_lo_sum == LO_SUM);\n-\n-  offset = XEXP (orig_addr, 1);\n-  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_value, offset);\n-  new_mem = replace_equiv_address_nv (orig_mem, new_addr, false);\n-\n-  if (extend != UNKNOWN)\n-    new_mem = gen_rtx_fmt_e (extend, extend_mode, new_mem);\n-\n-  new_mem = gen_rtx_UNSPEC (extend_mode, gen_rtvec (1, new_mem),\n-\t\t\t    UNSPEC_FUSION_P9);\n-\n-  set = gen_rtx_SET (target, new_mem);\n-  clobber = gen_rtx_CLOBBER (VOIDmode, tmp_reg);\n-  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber));\n-  emit_insn (insn);\n-\n-  return;\n-}\n-\n-/* During the peephole2 pass, adjust and expand the insns for an extended fusion\n-   store sequence.\n-\n-   The operands are:\n-\toperands[0]\tregister set with addis\n-\toperands[1]\tvalue set via addis\n-\toperands[2]\ttarget D-form memory being stored to\n-\toperands[3]\tregister being stored\n-\n-  This is similar to the fusion introduced with power8, except it scales to\n-  both loads/stores and does not require the result register to be the same as\n-  the base register.  At the moment, we only do this if register set with addis\n-  is dead.  */\n-\n-void\n-expand_fusion_p9_store (rtx *operands)\n-{\n-  rtx tmp_reg = operands[0];\n-  rtx addis_value = operands[1];\n-  rtx orig_mem = operands[2];\n-  rtx src = operands[3];\n-  rtx  new_addr, new_mem, orig_addr, offset, set, clobber, insn, new_src;\n-  enum rtx_code plus_or_lo_sum;\n-  machine_mode target_mode = GET_MODE (orig_mem);\n-  machine_mode ptr_mode = Pmode;\n-\n-  gcc_assert (MEM_P (orig_mem));\n-\n-  orig_addr = XEXP (orig_mem, 0);\n-  plus_or_lo_sum = GET_CODE (orig_addr);\n-  gcc_assert (plus_or_lo_sum == PLUS || plus_or_lo_sum == LO_SUM);\n-\n-  offset = XEXP (orig_addr, 1);\n-  new_addr = gen_rtx_fmt_ee (plus_or_lo_sum, ptr_mode, addis_value, offset);\n-  new_mem = replace_equiv_address_nv (orig_mem, new_addr, false);\n-\n-  new_src = gen_rtx_UNSPEC (target_mode, gen_rtvec (1, src),\n-\t\t\t    UNSPEC_FUSION_P9);\n-\n-  set = gen_rtx_SET (new_mem, new_src);\n-  clobber = gen_rtx_CLOBBER (VOIDmode, tmp_reg);\n-  insn = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber));\n-  emit_insn (insn);\n-\n-  return;\n-}\n-\n-/* Return a string to fuse an addis instruction with a load using extended\n-   fusion.  The address that is used is the logical address that was formed\n-   during peephole2: (lo_sum (high) (low-part))\n-\n-   The code is complicated, so we call output_asm_insn directly, and just\n-   return \"\".  */\n-\n-const char *\n-emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n-{\n-  machine_mode mode = GET_MODE (reg);\n-  rtx hi;\n-  rtx lo;\n-  rtx addr;\n-  const char *load_string;\n-  int r;\n-\n-  if (GET_CODE (mem) == FLOAT_EXTEND || GET_CODE (mem) == ZERO_EXTEND)\n-    {\n-      mem = XEXP (mem, 0);\n-      mode = GET_MODE (mem);\n-    }\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    {\n-      gcc_assert (SUBREG_BYTE (reg) == 0);\n-      reg = SUBREG_REG (reg);\n-    }\n-\n-  if (!REG_P (reg))\n-    fatal_insn (\"emit_fusion_p9_load, bad reg #1\", reg);\n-\n-  r = REGNO (reg);\n-  if (FP_REGNO_P (r))\n-    {\n-      if (mode == SFmode)\n-\tload_string = \"lfs\";\n-      else if (mode == DFmode || mode == DImode)\n-\tload_string = \"lfd\";\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (ALTIVEC_REGNO_P (r) && TARGET_P9_VECTOR)\n-    {\n-      if (mode == SFmode)\n-\tload_string = \"lxssp\";\n-      else if (mode == DFmode || mode == DImode)\n-\tload_string = \"lxsd\";\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (INT_REGNO_P (r))\n-    {\n-      switch (mode)\n-\t{\n-\tcase E_QImode:\n-\t  load_string = \"lbz\";\n-\t  break;\n-\tcase E_HImode:\n-\t  load_string = \"lhz\";\n-\t  break;\n-\tcase E_SImode:\n-\tcase E_SFmode:\n-\t  load_string = \"lwz\";\n-\t  break;\n-\tcase E_DImode:\n-\tcase E_DFmode:\n-\t  if (!TARGET_POWERPC64)\n-\t    gcc_unreachable ();\n-\t  load_string = \"ld\";\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  else\n-    fatal_insn (\"emit_fusion_p9_load, bad reg #2\", reg);\n-\n-  if (!MEM_P (mem))\n-    fatal_insn (\"emit_fusion_p9_load not MEM\", mem);\n-\n-  addr = XEXP (mem, 0);\n-  fusion_split_address (addr, &hi, &lo);\n-\n-  /* Emit the addis instruction.  */\n-  emit_fusion_addis (tmp_reg, hi);\n-\n-  /* Emit the D-form load instruction.  */\n-  emit_fusion_load_store (reg, tmp_reg, lo, load_string);\n-\n-  return \"\";\n-}\n-\n-/* Return a string to fuse an addis instruction with a store using extended\n-   fusion.  The address that is used is the logical address that was formed\n-   during peephole2: (lo_sum (high) (low-part))\n-\n-   The code is complicated, so we call output_asm_insn directly, and just\n-   return \"\".  */\n-\n-const char *\n-emit_fusion_p9_store (rtx mem, rtx reg, rtx tmp_reg)\n-{\n-  machine_mode mode = GET_MODE (reg);\n-  rtx hi;\n-  rtx lo;\n-  rtx addr;\n-  const char *store_string;\n-  int r;\n-\n-  if (GET_CODE (reg) == SUBREG)\n-    {\n-      gcc_assert (SUBREG_BYTE (reg) == 0);\n-      reg = SUBREG_REG (reg);\n-    }\n-\n-  if (!REG_P (reg))\n-    fatal_insn (\"emit_fusion_p9_store, bad reg #1\", reg);\n-\n-  r = REGNO (reg);\n-  if (FP_REGNO_P (r))\n-    {\n-      if (mode == SFmode)\n-\tstore_string = \"stfs\";\n-      else if (mode == DFmode)\n-\tstore_string = \"stfd\";\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (ALTIVEC_REGNO_P (r) && TARGET_P9_VECTOR)\n-    {\n-      if (mode == SFmode)\n-\tstore_string = \"stxssp\";\n-      else if (mode == DFmode || mode == DImode)\n-\tstore_string = \"stxsd\";\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (INT_REGNO_P (r))\n-    {\n-      switch (mode)\n-\t{\n-\tcase E_QImode:\n-\t  store_string = \"stb\";\n-\t  break;\n-\tcase E_HImode:\n-\t  store_string = \"sth\";\n-\t  break;\n-\tcase E_SImode:\n-\tcase E_SFmode:\n-\t  store_string = \"stw\";\n-\t  break;\n-\tcase E_DImode:\n-\tcase E_DFmode:\n-\t  if (!TARGET_POWERPC64)\n-\t    gcc_unreachable ();\n-\t  store_string = \"std\";\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  else\n-    fatal_insn (\"emit_fusion_p9_store, bad reg #2\", reg);\n-\n-  if (!MEM_P (mem))\n-    fatal_insn (\"emit_fusion_p9_store not MEM\", mem);\n-\n-  addr = XEXP (mem, 0);\n-  fusion_split_address (addr, &hi, &lo);\n-\n-  /* Emit the addis instruction.  */\n-  emit_fusion_addis (tmp_reg, hi);\n-\n-  /* Emit the D-form load instruction.  */\n-  emit_fusion_load_store (reg, tmp_reg, lo, store_string);\n-\n-  return \"\";\n-}\n-\n #ifdef RS6000_GLIBC_ATOMIC_FENV\n /* Function declarations for rs6000_atomic_assign_expand_fenv.  */\n static tree atomic_hold_decl, atomic_clear_decl, atomic_update_decl;"}, {"sha": "f2b10afe35b5b292fbf9e210474298758b01c9b3", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -136,7 +136,6 @@\n    UNSPEC_LSQ\n    UNSPEC_FUSION_GPR\n    UNSPEC_STACK_CHECK\n-   UNSPEC_FUSION_P9\n    UNSPEC_ADD_ROUND_TO_ODD\n    UNSPEC_SUB_ROUND_TO_ODD\n    UNSPEC_MUL_ROUND_TO_ODD\n@@ -349,19 +348,6 @@\n ; SImode or DImode, even if DImode doesn't fit in GPRs.\n (define_mode_iterator SDI [SI DI])\n \n-; Types that can be fused with an ADDIS instruction to load or store a GPR\n-; register that has reg+offset addressing.\n-(define_mode_iterator GPR_FUSION [QI\n-\t\t\t\t  HI\n-\t\t\t\t  SI\n-\t\t\t\t  (DI\t\"TARGET_POWERPC64\")\n-\t\t\t\t  SF\n-\t\t\t\t  (DF\t\"TARGET_POWERPC64\")])\n-\n-; Types that can be fused with an ADDIS instruction to load or store a FPR\n-; register that has reg+offset addressing.\n-(define_mode_iterator FPR_FUSION [DI SF DF])\n-\n ; The size of a pointer.  Also, the size of the value that a record-condition\n ; (one with a '.') will compare; and the size used for arithmetic carries.\n (define_mode_iterator P [(SI \"TARGET_32BIT\") (DI \"TARGET_64BIT\")])\n@@ -13722,134 +13708,6 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n-\f\n-;; ISA 3.0 (power9) fusion support\n-;; Merge addis with floating load/store to FPRs (or GPRs).\n-(define_peephole2\n-  [(set (match_operand:P 0 \"base_reg_operand\")\n-\t(match_operand:P 1 \"fusion_gpr_addis\"))\n-   (set (match_operand:SFDF 2 \"p9_fusion_reg_operand\")\n-\t(match_operand:SFDF 3 \"fusion_offsettable_mem_operand\"))]\n-  \"TARGET_P9_FUSION && peep2_reg_dead_p (2, operands[0])\n-   && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\"\n-  [(const_int 0)]\n-{\n-  expand_fusion_p9_load (operands);\n-  DONE;\n-})\n-\n-(define_peephole2\n-  [(set (match_operand:P 0 \"base_reg_operand\")\n-\t(match_operand:P 1 \"fusion_gpr_addis\"))\n-   (set (match_operand:SFDF 2 \"offsettable_mem_operand\")\n-\t(match_operand:SFDF 3 \"p9_fusion_reg_operand\"))]\n-  \"TARGET_P9_FUSION && peep2_reg_dead_p (2, operands[0])\n-   && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\n-   && !rtx_equal_p (operands[0], operands[3])\"\n-  [(const_int 0)]\n-{\n-  expand_fusion_p9_store (operands);\n-  DONE;\n-})\n-\n-(define_peephole2\n-  [(set (match_operand:SDI 0 \"int_reg_operand\")\n-\t(match_operand:SDI 1 \"upper16_cint_operand\"))\n-   (set (match_dup 0)\n-\t(ior:SDI (match_dup 0)\n-\t\t (match_operand:SDI 2 \"u_short_cint_operand\")))]\n-  \"TARGET_P9_FUSION\"\n-  [(set (match_dup 0)\n-\t(unspec:SDI [(match_dup 1)\n-\t\t     (match_dup 2)] UNSPEC_FUSION_P9))])\n-\n-(define_peephole2\n-  [(set (match_operand:SDI 0 \"int_reg_operand\")\n-\t(match_operand:SDI 1 \"upper16_cint_operand\"))\n-   (set (match_operand:SDI 2 \"int_reg_operand\")\n-\t(ior:SDI (match_dup 0)\n-\t\t (match_operand:SDI 3 \"u_short_cint_operand\")))]\n-  \"TARGET_P9_FUSION\n-   && !rtx_equal_p (operands[0], operands[2])\n-   && peep2_reg_dead_p (2, operands[0])\"\n-  [(set (match_dup 2)\n-\t(unspec:SDI [(match_dup 1)\n-\t\t     (match_dup 3)] UNSPEC_FUSION_P9))])\n-\n-;; Fusion insns, created by the define_peephole2 above (and eventually by\n-;; reload).  Because we want to eventually have secondary_reload generate\n-;; these, they have to have a single alternative that gives the register\n-;; classes.  This means we need to have separate gpr/fpr/altivec versions.\n-(define_insn \"*fusion_gpr_<P:mode>_<GPR_FUSION:mode>_load\"\n-  [(set (match_operand:GPR_FUSION 0 \"int_reg_operand\" \"=r\")\n-\t(unspec:GPR_FUSION\n-\t [(match_operand:GPR_FUSION 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n-\t UNSPEC_FUSION_P9))\n-   (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n-  \"TARGET_P9_FUSION\"\n-{\n-  /* This insn is a secondary reload insn, which cannot have alternatives.\n-     If we are not loading up register 0, use the power8 fusion instead.  */\n-  if (base_reg_operand (operands[0], <GPR_FUSION:MODE>mode))\n-    return emit_fusion_gpr_load (operands[0], operands[1]);\n-\n-  return emit_fusion_p9_load (operands[0], operands[1], operands[2]);\n-}\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*fusion_gpr_<P:mode>_<GPR_FUSION:mode>_store\"\n-  [(set (match_operand:GPR_FUSION 0 \"fusion_addis_mem_combo_store\" \"=wF\")\n-\t(unspec:GPR_FUSION\n-\t [(match_operand:GPR_FUSION 1 \"int_reg_operand\" \"r\")]\n-\t UNSPEC_FUSION_P9))\n-   (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n-  \"TARGET_P9_FUSION\"\n-{\n-  return emit_fusion_p9_store (operands[0], operands[1], operands[2]);\n-}\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load\"\n-  [(set (match_operand:FPR_FUSION 0 \"vsx_register_operand\" \"=dwb\")\n-\t(unspec:FPR_FUSION\n-\t [(match_operand:FPR_FUSION 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n-\t UNSPEC_FUSION_P9))\n-   (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n-  \"TARGET_P9_FUSION\"\n-{\n-  return emit_fusion_p9_load (operands[0], operands[1], operands[2]);\n-}\n-  [(set_attr \"type\" \"fpload\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store\"\n-  [(set (match_operand:FPR_FUSION 0 \"fusion_addis_mem_combo_store\" \"=wF\")\n-\t(unspec:FPR_FUSION\n-\t [(match_operand:FPR_FUSION 1 \"vsx_register_operand\" \"dwb\")]\n-\t UNSPEC_FUSION_P9))\n-   (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n-  \"TARGET_P9_FUSION\"\n-{\n-  return emit_fusion_p9_store (operands[0], operands[1], operands[2]);\n-}\n-  [(set_attr \"type\" \"fpstore\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"*fusion_p9_<mode>_constant\"\n-  [(set (match_operand:SDI 0 \"int_reg_operand\" \"=r\")\n-\t(unspec:SDI [(match_operand:SDI 1 \"upper16_cint_operand\" \"L\")\n-\t\t     (match_operand:SDI 2 \"u_short_cint_operand\" \"K\")]\n-\t\t    UNSPEC_FUSION_P9))]\t\n-  \"TARGET_P9_FUSION\"\n-{\n-  emit_fusion_addis (operands[0], operands[1]);\n-  return \"ori %0,%0,%2\";\n-}\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n-\n \f\n ;; Optimize cases where we want to do a D-form load (register+offset) on\n ;; ISA 2.06/2.07 to an Altivec register, and the register allocator"}, {"sha": "70428599bb743da39b020072c86d92b05d2f40f8", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -498,10 +498,6 @@ moptimize-swaps\n Target Undocumented Var(rs6000_optimize_swaps) Init(1) Save\n Analyze and remove doubleword swaps from VSX computations.\n \n-mpower9-fusion\n-Target Undocumented Report Mask(P9_FUSION) Var(rs6000_isa_flags)\n-Fuse certain operations together for better performance on power9.\n-\n mpower9-misc\n Target Undocumented Report Mask(P9_MISC) Var(rs6000_isa_flags)\n Use certain scalar instructions added in ISA 3.0."}, {"sha": "295fc1f1143c60b31885281943ba9ed7fcaf3a14", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -3238,7 +3238,7 @@ Int constant that is the element number of the 64-bit scalar in a vector.\n Vector constant that can be loaded with the XXSPLTIB instruction.\n \n @item wF\n-Memory operand suitable for power9 fusion load/stores.\n+Memory operand suitable for power8 GPR load fusion\n \n @item wG\n Memory operand suitable for TOC fusion memory references."}, {"sha": "04349764c3e54de8c5fa5813d0a66ab717a020db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fbd3c37634c580500e15b55b08780a9db795b70/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2fbd3c37634c580500e15b55b08780a9db795b70", "patch": "@@ -1,3 +1,8 @@\n+2018-11-16  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* gcc.target/powerpc/fusion3.c: Delete.\n+\t* gcc.target/powerpc/fusion4.c: Delete.\n+\n 2018-11-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/87475"}, {"sha": "0d9f3182586c7809882c404f6f93fad143df45c9", "filename": "gcc/testsuite/gcc.target/powerpc/fusion3.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a09ad34709696a3d02ae588e7a595fd379b885b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a09ad34709696a3d02ae588e7a595fd379b885b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion3.c?ref=a09ad34709696a3d02ae588e7a595fd379b885b0", "patch": "@@ -1,18 +0,0 @@\n-/* { dg-do compile { target { powerpc*-*-* } } } */\n-/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n-/* { dg-require-effective-target powerpc_p9vector_ok } */\n-/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-mcpu=power7 -mtune=power9 -O3 -dp\" } */\n-\n-#define LARGE 0x12345\n-\n-int fusion_float_read (float *p){ return p[LARGE]; }\n-int fusion_double_read (double *p){ return p[LARGE]; }\n-\n-void fusion_float_write (float *p, float f){ p[LARGE] = f; }\n-void fusion_double_write (double *p, double d){ p[LARGE] = d; }\n-\n-/* { dg-final { scan-assembler {fusion_vsx_[sd]i_sf_load}  } } */\n-/* { dg-final { scan-assembler {fusion_vsx_[sd]i_df_load}  } } */\n-/* { dg-final { scan-assembler {fusion_vsx_[sd]i_sf_store}  } } */\n-/* { dg-final { scan-assembler {fusion_vsx_[sd]i_df_store}  } } */"}, {"sha": "703c06cbfa4d4afd22fc763267e7fe857ebcb9b7", "filename": "gcc/testsuite/gcc.target/powerpc/fusion4.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a09ad34709696a3d02ae588e7a595fd379b885b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a09ad34709696a3d02ae588e7a595fd379b885b0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion4.c?ref=a09ad34709696a3d02ae588e7a595fd379b885b0", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n-/* { dg-require-effective-target powerpc_p9vector_ok } */\n-/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-mcpu=power7 -mtune=power9 -O3 -msoft-float -dp\" } */\n-\n-#define LARGE 0x12345\n-\n-float fusion_float_read (float *p){ return p[LARGE]; }\n-\n-void fusion_float_write (float *p, float f){ p[LARGE] = f; }\n-\n-/* { dg-final { scan-assembler {fusion_gpr_[sd]i_sf_store}  } } */"}]}