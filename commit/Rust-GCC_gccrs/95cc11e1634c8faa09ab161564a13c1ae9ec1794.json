{"sha": "95cc11e1634c8faa09ab161564a13c1ae9ec1794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjYzExZTE2MzRjOGZhYTA5YWIxNjE1NjRhMTNjMWFlOWVjMTc5NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-11-13T11:44:26Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-11-13T11:44:26Z"}, "message": "tm.texi.in (SELECT_CC_MODE): Update example.\n\n\t* doc/tm.texi.in (SELECT_CC_MODE): Update example.\n\t(REVERSIBLE_CC_MODE): Fix example.\n\t(REVERSE_CONDITION): Fix typo.\n\t* doc/tm.texi: Regenerate.\n\nFrom-SVN: r217476", "tree": {"sha": "b67a9a798714bfddd396301579ee99f9e78e0b8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b67a9a798714bfddd396301579ee99f9e78e0b8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95cc11e1634c8faa09ab161564a13c1ae9ec1794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cc11e1634c8faa09ab161564a13c1ae9ec1794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95cc11e1634c8faa09ab161564a13c1ae9ec1794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cc11e1634c8faa09ab161564a13c1ae9ec1794/comments", "author": null, "committer": null, "parents": [{"sha": "187518942c654f1d144a76a262ba8a7b904f7b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187518942c654f1d144a76a262ba8a7b904f7b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187518942c654f1d144a76a262ba8a7b904f7b9d"}], "stats": {"total": 41, "additions": 26, "deletions": 15}, "files": [{"sha": "d418c82d724b6a1c1905ed96108a1d7bf987b7c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cc11e1634c8faa09ab161564a13c1ae9ec1794/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cc11e1634c8faa09ab161564a13c1ae9ec1794/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95cc11e1634c8faa09ab161564a13c1ae9ec1794", "patch": "@@ -1,3 +1,10 @@\n+2014-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/tm.texi.in (SELECT_CC_MODE): Update example.\n+\t(REVERSIBLE_CC_MODE): Fix example.\n+\t(REVERSE_CONDITION): Fix typo.\n+\t* doc/tm.texi: Regenerate.\n+\n 2014-11-13  Tom de Vries  <tom@codesourcery.com>\n \n \t* omp-low.c (pass_data_expand_omp): Set properties_provided to\n@@ -26,7 +33,7 @@\n \n 2014-11-14  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n-\t* gcc/lra-lives.c (struct bb_data): Rename to ...\n+\t* lra-lives.c (struct bb_data): Rename to ...\n \t(struct bb_data_pseudos): ... this.\n \t(initiate_live_solver): Update struct name.\n "}, {"sha": "8f708f6944cf8ee6b8f8ace9fe56e8c27e90c746", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cc11e1634c8faa09ab161564a13c1ae9ec1794/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cc11e1634c8faa09ab161564a13c1ae9ec1794/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=95cc11e1634c8faa09ab161564a13c1ae9ec1794", "patch": "@@ -5941,10 +5941,11 @@ for comparisons whose argument is a @code{plus}:\n \n @smallexample\n #define SELECT_CC_MODE(OP,X,Y) \\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT          \\\n-   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)    \\\n-   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS    \\\n-       || GET_CODE (X) == NEG) \\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT           \\\n+   ? ((OP == LT || OP == LE || OP == GT || OP == GE)     \\\n+      ? CCFPEmode : CCFPmode)                            \\\n+   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS     \\\n+       || GET_CODE (X) == NEG || GET_CODE (x) == ASHIFT) \\\n       ? CC_NOOVmode : CCmode))\n @end smallexample\n \n@@ -5987,10 +5988,11 @@ then @code{REVERSIBLE_CC_MODE (@var{mode})} must be zero.\n You need not define this macro if it would always returns zero or if the\n floating-point format is anything other than @code{IEEE_FLOAT_FORMAT}.\n For example, here is the definition used on the SPARC, where floating-point\n-inequality comparisons are always given @code{CCFPEmode}:\n+inequality comparisons are given either @code{CCFPEmode} or @code{CCFPmode}:\n \n @smallexample\n-#define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)\n+#define REVERSIBLE_CC_MODE(MODE) \\\n+   ((MODE) != CCFPEmode && (MODE) != CCFPmode)\n @end smallexample\n @end defmac\n \n@@ -6000,7 +6002,7 @@ comparison done in CC_MODE @var{mode}.  The macro is used only in case\n @code{REVERSIBLE_CC_MODE (@var{mode})} is nonzero.  Define this macro in case\n machine has some non-standard way how to reverse certain conditionals.  For\n instance in case all floating point conditions are non-trapping, compiler may\n-freely convert unordered compares to ordered one.  Then definition may look\n+freely convert unordered compares to ordered ones.  Then definition may look\n like:\n \n @smallexample"}, {"sha": "acd4cdcbc9d65247859d2ea41f91092e189d624c", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95cc11e1634c8faa09ab161564a13c1ae9ec1794/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95cc11e1634c8faa09ab161564a13c1ae9ec1794/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=95cc11e1634c8faa09ab161564a13c1ae9ec1794", "patch": "@@ -4441,10 +4441,11 @@ for comparisons whose argument is a @code{plus}:\n \n @smallexample\n #define SELECT_CC_MODE(OP,X,Y) \\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT          \\\n-   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)    \\\n-   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS    \\\n-       || GET_CODE (X) == NEG) \\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT           \\\n+   ? ((OP == LT || OP == LE || OP == GT || OP == GE)     \\\n+      ? CCFPEmode : CCFPmode)                            \\\n+   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS     \\\n+       || GET_CODE (X) == NEG || GET_CODE (x) == ASHIFT) \\\n       ? CC_NOOVmode : CCmode))\n @end smallexample\n \n@@ -4467,10 +4468,11 @@ then @code{REVERSIBLE_CC_MODE (@var{mode})} must be zero.\n You need not define this macro if it would always returns zero or if the\n floating-point format is anything other than @code{IEEE_FLOAT_FORMAT}.\n For example, here is the definition used on the SPARC, where floating-point\n-inequality comparisons are always given @code{CCFPEmode}:\n+inequality comparisons are given either @code{CCFPEmode} or @code{CCFPmode}:\n \n @smallexample\n-#define REVERSIBLE_CC_MODE(MODE)  ((MODE) != CCFPEmode)\n+#define REVERSIBLE_CC_MODE(MODE) \\\n+   ((MODE) != CCFPEmode && (MODE) != CCFPmode)\n @end smallexample\n @end defmac\n \n@@ -4480,7 +4482,7 @@ comparison done in CC_MODE @var{mode}.  The macro is used only in case\n @code{REVERSIBLE_CC_MODE (@var{mode})} is nonzero.  Define this macro in case\n machine has some non-standard way how to reverse certain conditionals.  For\n instance in case all floating point conditions are non-trapping, compiler may\n-freely convert unordered compares to ordered one.  Then definition may look\n+freely convert unordered compares to ordered ones.  Then definition may look\n like:\n \n @smallexample"}]}