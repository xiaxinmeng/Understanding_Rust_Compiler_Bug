{"sha": "ff7a7e12be85d18d68c1919346f267d5da7d0d61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY3YTdlMTJiZTg1ZDE4ZDY4YzE5MTkzNDZmMjY3ZDVkYTdkMGQ2MQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-10-13T16:34:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-13T16:34:01Z"}, "message": "gnat_rm.texi: Add documentation for pragmas Pre[_Class] Post[_Class].\n\n2013-10-13  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Add documentation for pragmas Pre[_Class]\n\tPost[_Class].\n\t* par-ch2.adb (Skip_Pragma_Semicolon): Handle extra semicolon nicely.\n\t* par-prag.adb: Add entries for pragmas Pre[_Class] and\n\tPost[_Class].\n\t* sem_prag.adb: Add handling of pragmas Pre[_Class] and\n\tPost[_Class].\n\t* sem_util.adb (Original_Aspect_Name): Moved here from\n\tSem_Prag.Original_Name, and modified to handle pragmas\n\tPre/Post/Pre_Class/Post_Class.\n\t* sem_util.ads (Original_Aspect_Name): Moved here from\n\tSem_Prag.Original_Name.\n\t* snames.ads-tmpl: Add entries for pragmas Pre[_Class] and\n\tPost[_Class].\n\n2013-10-13  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb, sem_ch6.adb: Minor reformatting.\n\nFrom-SVN: r203505", "tree": {"sha": "38d420a7a59178cd49c38febdfe3d723669585bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38d420a7a59178cd49c38febdfe3d723669585bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff7a7e12be85d18d68c1919346f267d5da7d0d61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7a7e12be85d18d68c1919346f267d5da7d0d61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7a7e12be85d18d68c1919346f267d5da7d0d61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7a7e12be85d18d68c1919346f267d5da7d0d61/comments", "author": null, "committer": null, "parents": [{"sha": "ab8843fac024b4f8e4147c084cb876649b2e66c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab8843fac024b4f8e4147c084cb876649b2e66c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab8843fac024b4f8e4147c084cb876649b2e66c5"}], "stats": {"total": 608, "additions": 496, "deletions": 112}, "files": [{"sha": "0b09903605fc9c47de1795f4395df40d56a49149", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -1,3 +1,24 @@\n+2013-10-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Add documentation for pragmas Pre[_Class]\n+\tPost[_Class].\n+\t* par-ch2.adb (Skip_Pragma_Semicolon): Handle extra semicolon nicely.\n+\t* par-prag.adb: Add entries for pragmas Pre[_Class] and\n+\tPost[_Class].\n+\t* sem_prag.adb: Add handling of pragmas Pre[_Class] and\n+\tPost[_Class].\n+\t* sem_util.adb (Original_Aspect_Name): Moved here from\n+\tSem_Prag.Original_Name, and modified to handle pragmas\n+\tPre/Post/Pre_Class/Post_Class.\n+\t* sem_util.ads (Original_Aspect_Name): Moved here from\n+\tSem_Prag.Original_Name.\n+\t* snames.ads-tmpl: Add entries for pragmas Pre[_Class] and\n+\tPost[_Class].\n+\n+2013-10-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb, sem_ch6.adb: Minor reformatting.\n+\n 2013-10-13  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* einfo.adb: Add node/list usage for Refined_State"}, {"sha": "fa0daa98ce6a7f51b22ca5fe58586ae45fe007e0", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -6292,16 +6292,18 @@ package body Einfo is\n    ----------------\n \n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id is\n-      Is_CDG       : constant Boolean :=\n-                       Id = Pragma_Depends\n-                         or else Id = Pragma_Global\n-                         or else Id = Pragma_Refined_Depends\n-                         or else Id = Pragma_Refined_Global;\n-      Is_CTC      : constant Boolean :=\n-                      Id = Pragma_Contract_Cases or else Id = Pragma_Test_Case;\n-      Is_PPC      : constant Boolean :=\n-                      Id = Pragma_Precondition\n-                        or else Id = Pragma_Postcondition;\n+      Is_CDG  : constant Boolean :=\n+                  Id = Pragma_Depends         or else\n+                  Id = Pragma_Global          or else\n+                  Id = Pragma_Refined_Depends or else\n+                  Id = Pragma_Refined_Global;\n+      Is_CTC : constant Boolean :=\n+                  Id = Pragma_Contract_Cases  or else\n+                  Id = Pragma_Test_Case;\n+      Is_PPC : constant Boolean :=\n+                  Id = Pragma_Precondition     or else\n+                  Id = Pragma_Postcondition;\n+\n       In_Contract : constant Boolean := Is_CDG or Is_CTC or Is_PPC;\n \n       Item   : Node_Id;"}, {"sha": "833922e46500718a4d4f11a6e3492552c926c06b", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 138, "deletions": 1, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -206,11 +206,15 @@ Implementation Defined Pragmas\n * Pragma Passive::\n * Pragma Persistent_BSS::\n * Pragma Polling::\n+* Pragma Post::\n * Pragma Postcondition::\n+* Pragma Post_Class::\n+* Pragma Pre::\n * Pragma Precondition::\n * Pragma Predicate::\n * Pragma Preelaborable_Initialization::\n * Pragma Preelaborate_05::\n+* Pragma Pre_Class::\n * Pragma Priority_Specific_Dispatching::\n * Pragma Profile::\n * Pragma Profile_Warnings::\n@@ -1022,11 +1026,15 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Passive::\n * Pragma Persistent_BSS::\n * Pragma Polling::\n+* Pragma Post::\n * Pragma Postcondition::\n+* Pragma Post_Class::\n+* Pragma Pre::\n * Pragma Precondition::\n * Pragma Predicate::\n * Pragma Preelaborable_Initialization::\n * Pragma Preelaborate_05::\n+* Pragma Pre_Class::\n * Pragma Priority_Specific_Dispatching::\n * Pragma Profile::\n * Pragma Profile_Warnings::\n@@ -1393,7 +1401,10 @@ are implementation defined additions recognized by the GNAT compiler.\n The pragma applies in both cases to pragmas and aspects with matching\n names, e.g. @code{Pre} applies to the Pre aspect, and @code{Precondition}\n applies to both the @code{Precondition} pragma\n-and the aspect @code{Precondition}.\n+and the aspect @code{Precondition}. Note that the identifiers for\n+pragmas Pre_Class and Post_Class are Pre'Class and Post'Class (not\n+Pre_Class and Post_Class), since these pragmas are intended to be\n+identical to the corresponding aspects).\n \n If the policy is @code{CHECK}, then assertions are enabled, i.e.\n the corresponding pragma or aspect is activated.\n@@ -5016,6 +5027,28 @@ Note that polling can also be enabled by use of the @option{-gnatP} switch.\n @xref{Switches for gcc,,, gnat_ugn, @value{EDITION} User's Guide}, for\n details.\n \n+@node Pragma Post\n+@unnumberedsec Pragma Post\n+@cindex Post\n+@cindex Checks, postconditions\n+@findex Postconditions\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Post (Boolean_Expression);\n+@end smallexample\n+\n+@noindent\n+The @code{Post} pragma is intended to be an exact replacement for\n+the language-defined\n+@code{Post} aspect, and shares its restrictions and semantics.\n+It must appear either immediately following the corresponding\n+subprogram declaration (only other pragmas may intervene), or\n+if there is no separate subprogram declaration, then it can\n+appear at the start of the declarations in a subprogram body\n+(preceded only by other pragmas).\n+\n @node Pragma Postcondition\n @unnumberedsec Pragma Postcondition\n @cindex Postcondition\n@@ -5173,6 +5206,69 @@ inlining (-gnatN option set) are accepted and legality-checked\n by the compiler, but are ignored at run-time even if postcondition\n checking is enabled.\n \n+Note that pragma @code{Postcondition} differs from the language-defined\n+@code{Post} aspect (and corresponding @code{Post} pragma) in allowing\n+multiple occurrences, allowing occurences in the body even if there\n+is a separate spec, and allowing a second string parameter, and the\n+use of the pragma identifier @code{Check}. Historically, pragma\n+@code{Postcondition} was implemented prior to the development of\n+Ada 2012, and has been retained in its original form for\n+compatibility purposes.\n+\n+@node Pragma Post_Class\n+@unnumberedsec Pragma Post_Class\n+@cindex Post\n+@cindex Checks, postconditions\n+@findex Postconditions\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Post_Class (Boolean_Expression);\n+@end smallexample\n+\n+@noindent\n+The @code{Post_Class} pragma is intended to be an exact replacement for\n+the language-defined\n+@code{Post'Class} aspect, and shares its restrictions and semantics.\n+It must appear either immediately following the corresponding\n+subprogram declaration (only other pragmas may intervene), or\n+if there is no separate subprogram declaration, then it can\n+appear at the start of the declarations in a subprogram body\n+(preceded only by other pragmas).\n+\n+Note: This pragma is called @code{Post_Class} rather than\n+@code{Post'Class} because the latter would not be strictly\n+conforming to the allowed syntax for pragmas. The motivation\n+for provinding pragmas equivalent to the aspects is to allow a program\n+to be written using the pragmas, and then compiled if necessary\n+using an Ada compiler that does not recognize the pragmas or\n+aspects, but is prepared to ignore the pragmas. The assertion\n+policy that controls this pragma is @code{Post'Class}, not\n+@code{Post_Class}.\n+\n+@node Pragma Pre\n+@unnumberedsec Pragma Pre\n+@cindex Pre\n+@cindex Checks, preconditions\n+@findex Preconditions\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Pre (Boolean_Expression);\n+@end smallexample\n+\n+@noindent\n+The @code{Pre} pragma is intended to be an exact replacement for\n+the language-defined\n+@code{Pre} aspect, and shares its restrictions and semantics.\n+It must appear either immediately following the corresponding\n+subprogram declaration (only other pragmas may intervene), or\n+if there is no separate subprogram declaration, then it can\n+appear at the start of the declarations in a subprogram body\n+(preceded only by other pragmas).\n+\n @node Pragma Precondition\n @unnumberedsec Pragma Precondition\n @cindex Preconditions\n@@ -5221,6 +5317,15 @@ inlining (-gnatN option set) are accepted and legality-checked\n by the compiler, but are ignored at run-time even if precondition\n checking is enabled.\n \n+Note that pragma @code{Precondition} differs from the language-defined\n+@code{Pre} aspect (and corresponding @code{Pre} pragma) in allowing\n+multiple occurrences, allowing occurences in the body even if there\n+is a separate spec, and allowing a second string parameter, and the\n+use of the pragma identifier @code{Check}. Historically, pragma\n+@code{Precondition} was implemented prior to the development of\n+Ada 2012, and has been retained in its original form for\n+compatibility purposes.\n+\n @node Pragma Predicate\n @unnumberedsec Pragma Predicate\n @findex Predicate\n@@ -5295,6 +5400,38 @@ equivalent to @code{pragma Prelaborate} when operating in later\n Ada versions. This is used to handle some cases where packages\n not previously preelaborable became so in Ada 2005.\n \n+@node Pragma Pre_Class\n+@unnumberedsec Pragma Pre_Class\n+@cindex Pre_Class\n+@cindex Checks, preconditions\n+@findex Preconditions\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Pre_Class (Boolean_Expression);\n+@end smallexample\n+\n+@noindent\n+The @code{Pre_Class} pragma is intended to be an exact replacement for\n+the language-defined\n+@code{Pre'Class} aspect, and shares its restrictions and semantics.\n+It must appear either immediately following the corresponding\n+subprogram declaration (only other pragmas may intervene), or\n+if there is no separate subprogram declaration, then it can\n+appear at the start of the declarations in a subprogram body\n+(preceded only by other pragmas).\n+\n+Note: This pragma is called @code{Pre_Class} rather than\n+@code{Pre'Class} because the latter would not be strictly\n+conforming to the allowed syntax for pragmas. The motivation\n+for providing pragmas equivalent to the aspects is to allow a program\n+to be written using the pragmas, and then compiled if necessary\n+using an Ada compiler that does not recognize the pragmas or\n+aspects, but is prepared to ignore the pragmas. The assertion\n+policy that controls this pragma is @code{Pre'Class}, not\n+@code{Pre_Class}.\n+\n @node Pragma Priority_Specific_Dispatching\n @unnumberedsec Pragma Priority_Specific_Dispatching\n @findex Priority_Specific_Dispatching"}, {"sha": "2218dacb17e90a82924c2b7358e3196747e7ebdc", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -250,23 +250,15 @@ package body Ch2 is\n \n       procedure Skip_Pragma_Semicolon is\n       begin\n-         if Token /= Tok_Semicolon then\n+         --  If skipping the pragma, ignore a missing semicolon\n \n-            --  If skipping the pragma, ignore a missing semicolon\n+         if Token /= Tok_Semicolon and then Skipping then\n+            null;\n \n-            if Skipping then\n-               null;\n-\n-            --  Otherwise demand a semicolon\n-\n-            else\n-               T_Semicolon;\n-            end if;\n-\n-         --  Scan past semicolon if present\n+         --  Otherwise demand a semicolon\n \n          else\n-            Scan;\n+            T_Semicolon;\n          end if;\n       end Skip_Pragma_Semicolon;\n "}, {"sha": "aed45f96982d3d4aaa78c584f398f2a98d30d90f", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -1234,11 +1234,15 @@ begin\n            Pragma_Preelaborable_Initialization   |\n            Pragma_Polling                        |\n            Pragma_Persistent_BSS                 |\n+           Pragma_Post                           |\n            Pragma_Postcondition                  |\n+           Pragma_Post_Class                     |\n+           Pragma_Pre                            |\n            Pragma_Precondition                   |\n            Pragma_Predicate                      |\n            Pragma_Preelaborate                   |\n            Pragma_Preelaborate_05                |\n+           Pragma_Pre_Class                      |\n            Pragma_Priority                       |\n            Pragma_Priority_Specific_Dispatching  |\n            Pragma_Profile                        |"}, {"sha": "acf1aeb812bdaf4aba6d8605505cc2f515ea8609", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -1995,7 +1995,6 @@ package body Sem_Ch6 is\n       while Present (Prag) loop\n          if Pragma_Name (Prag) = Name_Refined_Depends then\n             Analyze_Refined_Depends_In_Decl_Part (Prag);\n-\n          elsif Pragma_Name (Prag) = Name_Refined_Global then\n             Has_Refined_Global := True;\n             Analyze_Refined_Global_In_Decl_Part (Prag);"}, {"sha": "4fbbfd73cf92edef89c8ddd571493f5c48bd4be4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 188, "deletions": 80, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -236,16 +236,6 @@ package body Sem_Prag is\n    --  Get_SPARK_Mode_Id. Convert a name into a corresponding value of type\n    --  SPARK_Mode_Id.\n \n-   function Original_Name (N : Node_Id) return Name_Id;\n-   --  N is a pragma node or aspect specification node. This function returns\n-   --  the name of the pragma or aspect in original source form, taking into\n-   --  account possible rewrites, and also cases where a pragma comes from an\n-   --  aspect (in such cases, the name can be different from the pragma name,\n-   --  e.g. a Pre aspect generates a Precondition pragma). This also deals with\n-   --  the presence of 'Class, which results in one of the special names\n-   --  Name_uPre, Name_uPost, Name_uInvariant, or Name_uType_Invariant being\n-   --  returned to represent the corresponding aspects with x'Class names.\n-\n    procedure Preanalyze_CTC_Args (N, Arg_Req, Arg_Ens : Node_Id);\n    --  Preanalyze the boolean expressions in the Requires and Ensures arguments\n    --  of a Test_Case pragma if present (possibly Empty). We treat these as\n@@ -1979,6 +1969,13 @@ package body Sem_Prag is\n       --  In this version of the procedure, the identifier name is given as\n       --  a string with lower case letters.\n \n+      procedure Check_Pre_Post;\n+      --  Called to perform checks for Pre, Pre_Class, Post, Post_Class\n+      --  pragmas. These are processed by transformation to equivalent\n+      --  Precondition and Postcondition pragmas, but Pre and Post need an\n+      --  additional check that they are not used in a subprogram body when\n+      --  there is a separate spec present.\n+\n       procedure Check_Precondition_Postcondition (In_Body : out Boolean);\n       --  Called to process a precondition or postcondition pragma. There are\n       --  three cases:\n@@ -3392,6 +3389,97 @@ package body Sem_Prag is\n          Check_Optional_Identifier (Arg, Name_Find);\n       end Check_Optional_Identifier;\n \n+      --------------------\n+      -- Check_Pre_Post --\n+      --------------------\n+\n+      procedure Check_Pre_Post is\n+         P  : Node_Id;\n+         PO : Node_Id;\n+\n+      begin\n+         if not Is_List_Member (N) then\n+            Pragma_Misplaced;\n+         end if;\n+\n+         --  If we are within an inlined body, the legality of the pragma\n+         --  has been checked already.\n+\n+         if In_Inlined_Body then\n+            return;\n+         end if;\n+\n+         --  Search prior declarations\n+\n+         P := N;\n+         while Present (Prev (P)) loop\n+            P := Prev (P);\n+\n+            --  If the previous node is a generic subprogram, do not go to to\n+            --  the original node, which is the unanalyzed tree: we need to\n+            --  attach the pre/postconditions to the analyzed version at this\n+            --  point. They get propagated to the original tree when analyzing\n+            --  the corresponding body.\n+\n+            if Nkind (P) not in N_Generic_Declaration then\n+               PO := Original_Node (P);\n+            else\n+               PO := P;\n+            end if;\n+\n+            --  Skip past prior pragma\n+\n+            if Nkind (PO) = N_Pragma then\n+               null;\n+\n+            --  Skip stuff not coming from source\n+\n+            elsif not Comes_From_Source (PO) then\n+\n+               --  The condition may apply to a subprogram instantiation\n+\n+               if Nkind (PO) = N_Subprogram_Declaration\n+                 and then Present (Generic_Parent (Specification (PO)))\n+               then\n+                  return;\n+\n+               elsif Nkind (PO) = N_Subprogram_Declaration\n+                 and then In_Instance\n+               then\n+                  return;\n+\n+               --  For all other cases of non source code, do nothing\n+\n+               else\n+                  null;\n+               end if;\n+\n+            --  Only remaining possibility is subprogram declaration\n+\n+            else\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  If we fall through loop, pragma is at start of list, so see if it\n+         --  is at the start of declarations of a subprogram body.\n+\n+         PO := Parent (N);\n+\n+         if Nkind (PO) = N_Subprogram_Body\n+           and then List_Containing (N) = Declarations (PO)\n+         then\n+            --  This is only allowed if there is no separate specification\n+\n+            if Present (Corresponding_Spec (PO)) then\n+               Error_Pragma\n+                 (\"pragma% must apply to subprogram specification\");\n+            end if;\n+\n+            return;\n+         end if;\n+      end Check_Pre_Post;\n+\n       --------------------------------------\n       -- Check_Precondition_Postcondition --\n       --------------------------------------\n@@ -3431,7 +3519,7 @@ package body Sem_Prag is\n             --  compatibility with earlier uses of the Ada pragma, apply this\n             --  rule only to aspect specifications.\n \n-            --  The above discrpency needs documentation. Robert is dubious\n+            --  The above discrepency needs documentation. Robert is dubious\n             --  about whether it is a good idea ???\n \n             elsif Nkind (PO) = N_Subprogram_Declaration\n@@ -4286,7 +4374,7 @@ package body Sem_Prag is\n \n             --  Get name from corresponding aspect\n \n-            Error_Msg_Name_1 := Original_Name (N);\n+            Error_Msg_Name_1 := Original_Aspect_Name (N);\n          end if;\n       end Fix_Error;\n \n@@ -8180,7 +8268,7 @@ package body Sem_Prag is\n       --  Here to start processing for recognized pragma\n \n       Prag_Id := Get_Pragma_Id (Pname);\n-      Pname := Original_Name (N);\n+      Pname := Original_Aspect_Name (N);\n \n       --  Check applicable policy. We skip this if Is_Checked or Is_Ignored\n       --  is already set, indicating that we have already checked the policy\n@@ -15056,6 +15144,32 @@ package body Sem_Prag is\n             Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n             Polling_Required := (Chars (Get_Pragma_Arg (Arg1)) = Name_On);\n \n+         ------------------\n+         -- Post[_Class] --\n+         ------------------\n+\n+         --  pragma Post (Boolean_EXPRESSION);\n+         --  pragma Post_Class (Boolean_EXPRESSION);\n+\n+         when Pragma_Post | Pragma_Post_Class => Post : declare\n+            PC_Pragma : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments (1);\n+            Check_No_Identifiers;\n+            Check_Pre_Post;\n+\n+            Set_Class_Present (N, Prag_Id = Pragma_Pre_Class);\n+            PC_Pragma := New_Copy (N);\n+            Set_Pragma_Identifier\n+              (PC_Pragma, Make_Identifier (Loc, Name_Postcondition));\n+            Rewrite (N, PC_Pragma);\n+            Set_Analyzed (N, False);\n+            Analyze (N);\n+         end Post;\n+\n          -------------------\n          -- Postcondition --\n          -------------------\n@@ -15090,6 +15204,32 @@ package body Sem_Prag is\n             end if;\n          end Postcondition;\n \n+         -----------------\n+         -- Pre[_Class] --\n+         -----------------\n+\n+         --  pragma Pre (Boolean_EXPRESSION);\n+         --  pragma Pre_Class (Boolean_EXPRESSION);\n+\n+         when Pragma_Pre | Pragma_Pre_Class => Pre : declare\n+            PC_Pragma : Node_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments (1);\n+            Check_No_Identifiers;\n+            Check_Pre_Post;\n+\n+            Set_Class_Present (N, Prag_Id = Pragma_Pre_Class);\n+            PC_Pragma := New_Copy (N);\n+            Set_Pragma_Identifier\n+              (PC_Pragma, Make_Identifier (Loc, Name_Precondition));\n+            Rewrite (N, PC_Pragma);\n+            Set_Analyzed (N, False);\n+            Analyze (N);\n+         end Pre;\n+\n          ------------------\n          -- Precondition --\n          ------------------\n@@ -18405,6 +18545,7 @@ package body Sem_Prag is\n       Subp_Id : Entity_Id)\n    is\n       Arg1 : constant Node_Id := First (Pragma_Argument_Associations (Prag));\n+      Nam  : constant Name_Id := Original_Aspect_Name (Prag);\n       Expr : Node_Id;\n \n       Restore_Scope : Boolean := False;\n@@ -18540,14 +18681,37 @@ package body Sem_Prag is\n \n          begin\n             if not Present (T) then\n-               Error_Msg_Name_1 :=\n-                 Chars (Identifier (Corresponding_Aspect (Prag)));\n \n-               Error_Msg_Name_2 := Name_Class;\n+               --  Pre'Class/Post'Class aspect cases\n \n-               Error_Msg_N\n-                 (\"aspect `%''%` can only be specified for a primitive \"\n-                  & \"operation of a tagged type\", Corresponding_Aspect (Prag));\n+               if From_Aspect_Specification (Prag) then\n+                  if Nam = Name_uPre then\n+                     Error_Msg_Name_1 := Name_Pre;\n+                  else\n+                     Error_Msg_Name_1 := Name_Post;\n+                  end if;\n+\n+                  Error_Msg_Name_2 := Name_Class;\n+\n+                  Error_Msg_N\n+                    (\"aspect `%''%` can only be specified for a primitive \"\n+                     & \"operation of a tagged type\",\n+                     Corresponding_Aspect (Prag));\n+\n+               --  Pre_Class, Post_Class pragma cases\n+\n+               else\n+                  if Nam = Name_uPre then\n+                     Error_Msg_Name_1 := Name_Pre_Class;\n+                  else\n+                     Error_Msg_Name_1 := Name_Post_Class;\n+                  end if;\n+\n+                  Error_Msg_N\n+                    (\"pragma% can only be specified for a primitive \"\n+                     & \"operation of a tagged type\",\n+                     Corresponding_Aspect (Prag));\n+               end if;\n             end if;\n \n             Replace_Type (Get_Pragma_Arg (Arg1));\n@@ -20073,7 +20237,7 @@ package body Sem_Prag is\n       PP     : Node_Id;\n       Policy : Name_Id;\n \n-      Ename : constant Name_Id := Original_Name (N);\n+      Ename : constant Name_Id := Original_Aspect_Name (N);\n \n    begin\n       --  No effect if not valid assertion kind name\n@@ -20686,12 +20850,16 @@ package body Sem_Prag is\n       Pragma_Passive                        => -1,\n       Pragma_Persistent_BSS                 =>  0,\n       Pragma_Polling                        => -1,\n+      Pragma_Post                           => -1,\n       Pragma_Postcondition                  => -1,\n+      Pragma_Post_Class                     => -1,\n+      Pragma_Pre                            => -1,\n       Pragma_Precondition                   => -1,\n       Pragma_Predicate                      => -1,\n       Pragma_Preelaborable_Initialization   => -1,\n       Pragma_Preelaborate                   => -1,\n       Pragma_Preelaborate_05                => -1,\n+      Pragma_Pre_Class                      => -1,\n       Pragma_Priority                       => -1,\n       Pragma_Priority_Specific_Dispatching  => -1,\n       Pragma_Profile                        =>  0,\n@@ -21023,66 +21191,6 @@ package body Sem_Prag is\n       end if;\n    end Make_Aspect_For_PPC_In_Gen_Sub_Decl;\n \n-   -------------------\n-   -- Original_Name --\n-   -------------------\n-\n-   function Original_Name (N : Node_Id) return Name_Id is\n-      Pras : Node_Id;\n-      Name : Name_Id;\n-\n-   begin\n-      pragma Assert (Nkind_In (N, N_Aspect_Specification, N_Pragma));\n-      Pras := N;\n-\n-      if Is_Rewrite_Substitution (Pras)\n-        and then Nkind (Original_Node (Pras)) = N_Pragma\n-      then\n-         Pras := Original_Node (Pras);\n-      end if;\n-\n-      --  Case where we came from aspect specication\n-\n-      if Nkind (Pras) = N_Pragma and then From_Aspect_Specification (Pras) then\n-         Pras := Corresponding_Aspect (Pras);\n-      end if;\n-\n-      --  Get name from aspect or pragma\n-\n-      if Nkind (Pras) = N_Pragma then\n-         Name := Pragma_Name (Pras);\n-      else\n-         Name := Chars (Identifier (Pras));\n-      end if;\n-\n-      --  Deal with 'Class\n-\n-      if Class_Present (Pras) then\n-         case Name is\n-\n-         --  Names that need converting to special _xxx form\n-\n-            when Name_Pre             => Name := Name_uPre;\n-            when Name_Post            => Name := Name_uPost;\n-            when Name_Invariant       => Name := Name_uInvariant;\n-            when Name_Type_Invariant  => Name := Name_uType_Invariant;\n-\n-               --  Names already in special _xxx form (leave them alone)\n-\n-            when Name_uPre            => null;\n-            when Name_uPost           => null;\n-            when Name_uInvariant      => null;\n-            when Name_uType_Invariant => null;\n-\n-               --  Anything else is impossible with Class_Present set True\n-\n-            when others               => raise Program_Error;\n-         end case;\n-      end if;\n-\n-      return Name;\n-   end Original_Name;\n-\n    -------------------------\n    -- Preanalyze_CTC_Args --\n    -------------------------"}, {"sha": "80ba002a71179755c33e4c2514b60e52938f2385", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 109, "deletions": 5, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -215,6 +215,7 @@ package body Sem_Util is\n    procedure Add_Contract_Item (Prag : Node_Id; Subp_Id : Entity_Id) is\n       Items : constant Node_Id := Contract (Subp_Id);\n       Nam   : Name_Id;\n+      N     : Node_Id;\n \n    begin\n       --  The related subprogram [body] must have a contract and the item to be\n@@ -223,7 +224,7 @@ package body Sem_Util is\n       pragma Assert (Present (Items));\n       pragma Assert (Nkind (Prag) = N_Pragma);\n \n-      Nam := Pragma_Name (Prag);\n+      Nam := Original_Aspect_Name (Prag);\n \n       --  Contract items related to subprogram bodies\n \n@@ -241,7 +242,41 @@ package body Sem_Util is\n       --  Contract items related to subprogram declarations\n \n       else\n-         if Nam_In (Nam, Name_Precondition, Name_Postcondition) then\n+         if Nam_In (Nam, Name_Precondition,\n+                         Name_Postcondition,\n+                         Name_Pre,\n+                         Name_Post,\n+                         Name_uPre,\n+                         Name_uPost)\n+         then\n+            --  Before we add a precondition or postcondition to the list,\n+            --  make sure we do not have a disallowed duplicate, which can\n+            --  happen if we use a pragma for Pre{_Class] or Post[_Class]\n+            --  instead of the corresponding aspect.\n+\n+            if not From_Aspect_Specification (Prag)\n+              and then Nam_In (Nam, Name_Pre_Class,\n+                                    Name_Pre,\n+                                    Name_uPre,\n+                                    Name_Post_Class,\n+                                    Name_Post,\n+                                    Name_uPost)\n+            then\n+               N := Pre_Post_Conditions (Items);\n+               while Present (N) loop\n+                  if not Split_PPC (N)\n+                    and then Original_Aspect_Name (N) = Nam\n+                  then\n+                     Error_Msg_Sloc := Sloc (N);\n+                     Error_Msg_NE\n+                       (\"duplication of aspect for & given#\", Prag, Subp_Id);\n+                     return;\n+                  else\n+                     N := Next_Pragma (N);\n+                  end if;\n+               end loop;\n+            end if;\n+\n             Set_Next_Pragma (Prag, Pre_Post_Conditions (Items));\n             Set_Pre_Post_Conditions (Items, Prag);\n \n@@ -4411,7 +4446,6 @@ package body Sem_Util is\n \n    procedure Ensure_Freeze_Node (E : Entity_Id) is\n       FN : Node_Id;\n-\n    begin\n       if No (Freeze_Node (E)) then\n          FN := Make_Freeze_Entity (Sloc (E));\n@@ -4704,9 +4738,14 @@ package body Sem_Util is\n       --  Inherited discriminants and components in derived record types are\n       --  immediately visible. Itypes are not.\n \n+      --  Unless the Itype is for a record type with a corresponding remote\n+      --  type (what is that about, it was not commented ???)\n+\n       if Ekind_In (Def_Id, E_Discriminant, E_Component)\n-        or else (No (Corresponding_Remote_Type (Def_Id))\n-                 and then not Is_Itype (Def_Id))\n+        or else\n+          ((not Is_Record_Type (Def_Id)\n+             or else No (Corresponding_Remote_Type (Def_Id)))\n+            and then not Is_Itype (Def_Id))\n       then\n          Set_Is_Immediately_Visible (Def_Id);\n          Set_Current_Entity         (Def_Id);\n@@ -12833,6 +12872,71 @@ package body Sem_Util is\n       end if;\n    end Object_Access_Level;\n \n+   --------------------------\n+   -- Original_Aspect_Name --\n+   --------------------------\n+\n+   function Original_Aspect_Name (N : Node_Id) return Name_Id is\n+      Pras : Node_Id;\n+      Name : Name_Id;\n+\n+   begin\n+      pragma Assert (Nkind_In (N, N_Aspect_Specification, N_Pragma));\n+      Pras := N;\n+\n+      if Is_Rewrite_Substitution (Pras)\n+        and then Nkind (Original_Node (Pras)) = N_Pragma\n+      then\n+         Pras := Original_Node (Pras);\n+      end if;\n+\n+      --  Case where we came from aspect specication\n+\n+      if Nkind (Pras) = N_Pragma and then From_Aspect_Specification (Pras) then\n+         Pras := Corresponding_Aspect (Pras);\n+      end if;\n+\n+      --  Get name from aspect or pragma\n+\n+      if Nkind (Pras) = N_Pragma then\n+         Name := Pragma_Name (Pras);\n+      else\n+         Name := Chars (Identifier (Pras));\n+      end if;\n+\n+      --  Deal with 'Class\n+\n+      if Class_Present (Pras) then\n+         case Name is\n+\n+         --  Names that need converting to special _xxx form\n+\n+            when Name_Pre                  |\n+                 Name_Pre_Class            =>\n+               Name := Name_uPre;\n+\n+            when Name_Post                 |\n+                 Name_Post_Class           =>\n+               Name := Name_uPost;\n+\n+            when Name_Invariant            =>\n+               Name := Name_uInvariant;\n+\n+            when Name_Type_Invariant       |\n+                 Name_Type_Invariant_Class =>\n+               Name := Name_uType_Invariant;\n+\n+            --  Nothing to do for other cases (e.g. a Check that derived\n+            --  from Pre_Class and has the flag set). Also we do nothing\n+            --  if the name is already in special _xxx form.\n+\n+            when others                    =>\n+               null;\n+         end case;\n+      end if;\n+\n+      return Name;\n+   end Original_Aspect_Name;\n    --------------------------------------\n    -- Original_Corresponding_Operation --\n    --------------------------------------"}, {"sha": "13ee3b3dbe308aa55a70cdabd9b2efbdddcc2afa", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -1365,6 +1365,16 @@ package Sem_Util is\n    --  convenience, qualified expressions applied to object names are also\n    --  allowed as actuals for this function.\n \n+   function Original_Aspect_Name (N : Node_Id) return Name_Id;\n+   --  N is a pragma node or aspect specification node. This function returns\n+   --  the name of the pragma or aspect in original source form, taking into\n+   --  account possible rewrites, and also cases where a pragma comes from an\n+   --  aspect (in such cases, the name can be different from the pragma name,\n+   --  e.g. a Pre aspect generates a Precondition pragma). This also deals with\n+   --  the presence of 'Class, which results in one of the special names\n+   --  Name_uPre, Name_uPost, Name_uInvariant, or Name_uType_Invariant being\n+   --  returned to represent the corresponding aspects with x'Class names.\n+\n    function Primitive_Names_Match (E1, E2 : Entity_Id) return Boolean;\n    --  Returns True if the names of both entities correspond with matching\n    --  primitives. This routine includes support for the case in which one"}, {"sha": "aacaf8a505f017aefab944ad5570feaab7fdcc65", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7a7e12be85d18d68c1919346f267d5da7d0d61/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=ff7a7e12be85d18d68c1919346f267d5da7d0d61", "patch": "@@ -142,11 +142,10 @@ package Snames is\n    Name_Dimension                      : constant Name_Id := N + $;\n    Name_Dimension_System               : constant Name_Id := N + $;\n    Name_Dynamic_Predicate              : constant Name_Id := N + $;\n-   Name_Post                           : constant Name_Id := N + $;\n-   Name_Pre                            : constant Name_Id := N + $;\n    Name_Static_Predicate               : constant Name_Id := N + $;\n    Name_Synchronization                : constant Name_Id := N + $;\n    Name_Type_Invariant                 : constant Name_Id := N + $;\n+   Name_Type_Invariant_Class           : constant Name_Id := N + $;\n \n    --  Some special names used by the expander. Note that the lower case u's\n    --  at the start of these names get translated to extra underscores. These\n@@ -562,12 +561,16 @@ package Snames is\n    Name_Pack                           : constant Name_Id := N + $;\n    Name_Page                           : constant Name_Id := N + $;\n    Name_Passive                        : constant Name_Id := N + $; -- GNAT\n+   Name_Post                           : constant Name_Id := N + $; -- GNAT\n    Name_Postcondition                  : constant Name_Id := N + $; -- GNAT\n+   Name_Post_Class                     : constant Name_Id := N + $; -- GNAT\n+   Name_Pre                            : constant Name_Id := N + $; -- GNAT\n    Name_Precondition                   : constant Name_Id := N + $; -- GNAT\n    Name_Predicate                      : constant Name_Id := N + $; -- GNAT\n    Name_Preelaborable_Initialization   : constant Name_Id := N + $; -- Ada 05\n    Name_Preelaborate                   : constant Name_Id := N + $;\n    Name_Preelaborate_05                : constant Name_Id := N + $; -- GNAT\n+   Name_Pre_Class                      : constant Name_Id := N + $; -- GNAT\n \n    --  Note: Priority is not in this list because its name matches the name of\n    --  the corresponding attribute. However, it is included in the definition\n@@ -1860,12 +1863,16 @@ package Snames is\n       Pragma_Pack,\n       Pragma_Page,\n       Pragma_Passive,\n+      Pragma_Post,\n       Pragma_Postcondition,\n+      Pragma_Post_Class,\n+      Pragma_Pre,\n       Pragma_Precondition,\n       Pragma_Predicate,\n       Pragma_Preelaborable_Initialization,\n       Pragma_Preelaborate,\n       Pragma_Preelaborate_05,\n+      Pragma_Pre_Class,\n       Pragma_Psect_Object,\n       Pragma_Pure,\n       Pragma_Pure_05,"}]}