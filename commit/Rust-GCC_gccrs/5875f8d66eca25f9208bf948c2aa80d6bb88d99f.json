{"sha": "5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg3NWY4ZDY2ZWNhMjVmOTIwOGJmOTQ4YzJhYTgwZDZiYjg4ZDk5Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T13:32:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T13:32:14Z"}, "message": "[multiple changes]\n\n2010-06-14  Sergey Rybin  <rybin@adacore.com>\n\n\t* gnat_ugn.texi: Add description of '-cargs gcc_switches' to gnatstub\n\tand gnatppa.\n\n2010-06-14  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb (Expand_Short_Circuit_Operator): New subprogram,\n\tfactoring duplicated code between...\n\t(Expand_N_And_Than, Expand_N_Or_Else): Remove duplicated code.\n\t* a-envvar.ads: Minor reformatting\n\n2010-06-14  Arnaud Charlet  <charlet@adacore.com>\n\n\t* ali.adb, ali.ads, lib-xref.ads: Document new '+' letter for C/C++\n\tstatic entities.\n\t(Scan_ALI): Take into account new Visibility field.\n\t(Visibility_Kind): New type.\n\t(Xref_Entity_Record): Replace Lib field by Visibility.\n\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\n2010-06-14  Pascal Obry  <obry@adacore.com>\n\n\t* raise.h: Remove unused defintions.\n\n2010-06-14  Bob Duff  <duff@adacore.com>\n\n\t* par-ch10.adb (P_Subunit): If the next token after \"separate(X)\" is\n\tTok_Not or Tok_Overriding, call P_Subprogram. We had previously given\n\tthe incorrect error \"proper body expected\".\n\t* par-ch6.adb (P_Subprogram): Suppress \"overriding indicator not\n\tallowed here\" error in case of subunits, which was triggered by the\n\tabove change to P_Subunit.\n\nFrom-SVN: r160740", "tree": {"sha": "8cd5f637a3983c187a4335bba34225ba77a08a2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cd5f637a3983c187a4335bba34225ba77a08a2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/comments", "author": null, "committer": null, "parents": [{"sha": "395993ce178c5c7556fc584cdaacf9be77c816a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/395993ce178c5c7556fc584cdaacf9be77c816a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/395993ce178c5c7556fc584cdaacf9be77c816a3"}], "stats": {"total": 498, "additions": 250, "deletions": 248}, "files": [{"sha": "9f8ca7dfa910614f0f8338d210f56f471204a091", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -1,3 +1,38 @@\n+2010-06-14  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* gnat_ugn.texi: Add description of '-cargs gcc_switches' to gnatstub\n+\tand gnatppa.\n+\n+2010-06-14  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Short_Circuit_Operator): New subprogram,\n+\tfactoring duplicated code between...\n+\t(Expand_N_And_Than, Expand_N_Or_Else): Remove duplicated code.\n+\t* a-envvar.ads: Minor reformatting\n+\n+2010-06-14  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* ali.adb, ali.ads, lib-xref.ads: Document new '+' letter for C/C++\n+\tstatic entities.\n+\t(Scan_ALI): Take into account new Visibility field.\n+\t(Visibility_Kind): New type.\n+\t(Xref_Entity_Record): Replace Lib field by Visibility.\n+\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n+2010-06-14  Pascal Obry  <obry@adacore.com>\n+\n+\t* raise.h: Remove unused defintions.\n+\n+2010-06-14  Bob Duff  <duff@adacore.com>\n+\n+\t* par-ch10.adb (P_Subunit): If the next token after \"separate(X)\" is\n+\tTok_Not or Tok_Overriding, call P_Subprogram. We had previously given\n+\tthe incorrect error \"proper body expected\".\n+\t* par-ch6.adb (P_Subprogram): Suppress \"overriding indicator not\n+\tallowed here\" error in case of subunits, which was triggered by the\n+\tabove change to P_Subunit.\n+\n 2010-06-14  Sergey Rybin  <rybin@adacore.com>\n \n \t* gnat_ugn.texi, vms_data.ads: Update gnatelim doc."}, {"sha": "9769c9bb1ee4010f52db31154e17b362a6808176", "filename": "gcc/ada/a-envvar.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fa-envvar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fa-envvar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-envvar.ads?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -37,7 +37,7 @@ package Ada.Environment_Variables is\n    --  environment variable with the given name and value, then\n    --  Constraint_Error is propagated.\n    --  It is implementation defined whether there exist values for which the\n-   --  call Set(Name, Value) has the same effect as Clear (Name).\n+   --  call Set (Name, Value) has the same effect as Clear (Name).\n \n    procedure Clear (Name : String);\n    --  If the external execution environment supports environment variables,"}, {"sha": "9effd2201682eb3bb63483671bfbc805bb8d31b9", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -2190,10 +2190,19 @@ package body ALI is\n                --  Start of processing for Read_Refs_For_One_Entity\n \n                begin\n-                  XE.Line   := Get_Nat;\n-                  XE.Etype  := Getc;\n-                  XE.Col    := Get_Nat;\n-                  XE.Lib    := (Getc = '*');\n+                  XE.Line  := Get_Nat;\n+                  XE.Etype := Getc;\n+                  XE.Col   := Get_Nat;\n+\n+                  case Getc is\n+                     when '*' =>\n+                        XE.Visibility := Global;\n+                     when '+' =>\n+                        XE.Visibility := Static;\n+                     when others =>\n+                        XE.Visibility := Other;\n+                  end case;\n+\n                   XE.Entity := Get_Name;\n \n                   --  Handle the information about generic instantiations"}, {"sha": "74aeaed026dfba3a84422e0bf5afb1a96d61c8aa", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -811,6 +811,11 @@ package ALI is\n      Tref_Derived, --  Derived type typeref (points to parent type)\n      Tref_Type);   --  All other cases\n \n+   type Visibility_Kind is\n+     (Global, --  Library level entity\n+      Static, --  Static C/C++ entity\n+      Other); --  Local and other entity\n+\n    --  The following table records entities for which xrefs are recorded\n \n    type Xref_Entity_Record is record\n@@ -824,8 +829,8 @@ package ALI is\n       Col : Pos;\n       --  Column number of definition\n \n-      Lib : Boolean;\n-      --  True if entity is library level entity\n+      Visibility : Visibility_Kind;\n+      --  Visiblity of entity\n \n       Entity : Name_Id;\n       --  Name of entity"}, {"sha": "c08022051d66b38d9d073ecac49bfd67889412d0", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 146, "deletions": 205, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -127,6 +127,9 @@ package body Exp_Ch4 is\n    --  Common expansion processing for Boolean operators (And, Or, Xor) for the\n    --  case of array type arguments.\n \n+   procedure Expand_Short_Circuit_Operator (N : Node_Id);\n+   --  Common expansion processing for short-circuit boolean operators\n+\n    function Expand_Composite_Equality\n      (Nod    : Node_Id;\n       Typ    : Entity_Id;\n@@ -3900,113 +3903,8 @@ package body Exp_Ch4 is\n    -- Expand_N_And_Then --\n    -----------------------\n \n-   --  Expand into conditional expression if Actions present, and also deal\n-   --  with optimizing case of arguments being True or False.\n-\n-   procedure Expand_N_And_Then (N : Node_Id) is\n-      Loc     : constant Source_Ptr := Sloc (N);\n-      Typ     : constant Entity_Id  := Etype (N);\n-      Left    : constant Node_Id    := Left_Opnd (N);\n-      Right   : constant Node_Id    := Right_Opnd (N);\n-      Actlist : List_Id;\n-\n-   begin\n-      --  Deal with non-standard booleans\n-\n-      if Is_Boolean_Type (Typ) then\n-         Adjust_Condition (Left);\n-         Adjust_Condition (Right);\n-         Set_Etype (N, Standard_Boolean);\n-      end if;\n-\n-      --  Check for cases where left argument is known to be True or False\n-\n-      if Compile_Time_Known_Value (Left) then\n-\n-         --  If left argument is True, change (True and then Right) to Right.\n-         --  Any actions associated with Right will be executed unconditionally\n-         --  and can thus be inserted into the tree unconditionally.\n-\n-         if Expr_Value_E (Left) = Standard_True then\n-            if Present (Actions (N)) then\n-               Insert_Actions (N, Actions (N));\n-            end if;\n-\n-            Rewrite (N, Right);\n-\n-         --  If left argument is False, change (False and then Right) to False.\n-         --  In this case we can forget the actions associated with Right,\n-         --  since they will never be executed.\n-\n-         else pragma Assert (Expr_Value_E (Left) = Standard_False);\n-            Kill_Dead_Code (Right);\n-            Kill_Dead_Code (Actions (N));\n-            Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n-         end if;\n-\n-         Adjust_Result_Type (N, Typ);\n-         return;\n-      end if;\n-\n-      --  If Actions are present, we expand\n-\n-      --     left and then right\n-\n-      --  into\n-\n-      --     if left then right else false end\n-\n-      --  with the actions becoming the Then_Actions of the conditional\n-      --  expression. This conditional expression is then further expanded\n-      --  (and will eventually disappear)\n-\n-      if Present (Actions (N)) then\n-         Actlist := Actions (N);\n-         Rewrite (N,\n-            Make_Conditional_Expression (Loc,\n-              Expressions => New_List (\n-                Left,\n-                Right,\n-                New_Occurrence_Of (Standard_False, Loc))));\n-\n-         --  If the right part of the expression is a function call then it can\n-         --  be part of the expansion of the predefined equality operator of a\n-         --  tagged type and we may need to adjust its SCIL dispatching node.\n-\n-         if Generate_SCIL\n-           and then Nkind (Right) = N_Function_Call\n-         then\n-            Adjust_SCIL_Node (N, Right);\n-         end if;\n-\n-         Set_Then_Actions (N, Actlist);\n-         Analyze_And_Resolve (N, Standard_Boolean);\n-         Adjust_Result_Type (N, Typ);\n-         return;\n-      end if;\n-\n-      --  No actions present, check for cases of right argument True/False\n-\n-      if Compile_Time_Known_Value (Right) then\n-\n-         --  Change (Left and then True) to Left. Note that we know there are\n-         --  no actions associated with the True operand, since we just checked\n-         --  for this case above.\n-\n-         if Expr_Value_E (Right) = Standard_True then\n-            Rewrite (N, Left);\n-\n-         --  Change (Left and then False) to False, making sure to preserve any\n-         --  side effects associated with the Left operand.\n-\n-         else pragma Assert (Expr_Value_E (Right) = Standard_False);\n-            Remove_Side_Effects (Left);\n-            Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n-         end if;\n-      end if;\n-\n-      Adjust_Result_Type (N, Typ);\n-   end Expand_N_And_Then;\n+   procedure Expand_N_And_Then (N : Node_Id)\n+     renames Expand_Short_Circuit_Operator;\n \n    -------------------------------------\n    -- Expand_N_Conditional_Expression --\n@@ -7168,104 +7066,8 @@ package body Exp_Ch4 is\n    -- Expand_N_Or_Else --\n    ----------------------\n \n-   --  Expand into conditional expression if Actions present, and also\n-   --  deal with optimizing case of arguments being True or False.\n-\n-   procedure Expand_N_Or_Else (N : Node_Id) is\n-      Loc     : constant Source_Ptr := Sloc (N);\n-      Typ     : constant Entity_Id  := Etype (N);\n-      Left    : constant Node_Id    := Left_Opnd (N);\n-      Right   : constant Node_Id    := Right_Opnd (N);\n-      Actlist : List_Id;\n-\n-   begin\n-      --  Deal with non-standard booleans\n-\n-      if Is_Boolean_Type (Typ) then\n-         Adjust_Condition (Left);\n-         Adjust_Condition (Right);\n-         Set_Etype (N, Standard_Boolean);\n-      end if;\n-\n-      --  Check for cases where left argument is known to be True or False\n-\n-      if Compile_Time_Known_Value (Left) then\n-\n-         --  If left argument is False, change (False or else Right) to Right.\n-         --  Any actions associated with Right will be executed unconditionally\n-         --  and can thus be inserted into the tree unconditionally.\n-\n-         if Expr_Value_E (Left) = Standard_False then\n-            if Present (Actions (N)) then\n-               Insert_Actions (N, Actions (N));\n-            end if;\n-\n-            Rewrite (N, Right);\n-\n-         --  If left argument is True, change (True and then Right) to True. In\n-         --  this case we can forget the actions associated with Right, since\n-         --  they will never be executed.\n-\n-         else pragma Assert (Expr_Value_E (Left) = Standard_True);\n-            Kill_Dead_Code (Right);\n-            Kill_Dead_Code (Actions (N));\n-            Rewrite (N, New_Occurrence_Of (Standard_True, Loc));\n-         end if;\n-\n-         Adjust_Result_Type (N, Typ);\n-         return;\n-      end if;\n-\n-      --  If Actions are present, we expand\n-\n-      --     left or else right\n-\n-      --  into\n-\n-      --     if left then True else right end\n-\n-      --  with the actions becoming the Else_Actions of the conditional\n-      --  expression. This conditional expression is then further expanded\n-      --  (and will eventually disappear)\n-\n-      if Present (Actions (N)) then\n-         Actlist := Actions (N);\n-         Rewrite (N,\n-            Make_Conditional_Expression (Loc,\n-              Expressions => New_List (\n-                Left,\n-                New_Occurrence_Of (Standard_True, Loc),\n-                Right)));\n-\n-         Set_Else_Actions (N, Actlist);\n-         Analyze_And_Resolve (N, Standard_Boolean);\n-         Adjust_Result_Type (N, Typ);\n-         return;\n-      end if;\n-\n-      --  No actions present, check for cases of right argument True/False\n-\n-      if Compile_Time_Known_Value (Right) then\n-\n-         --  Change (Left or else False) to Left. Note that we know there are\n-         --  no actions associated with the True operand, since we just checked\n-         --  for this case above.\n-\n-         if Expr_Value_E (Right) = Standard_False then\n-            Rewrite (N, Left);\n-\n-         --  Change (Left or else True) to True, making sure to preserve any\n-         --  side effects associated with the Left operand.\n-\n-         else pragma Assert (Expr_Value_E (Right) = Standard_True);\n-            Remove_Side_Effects (Left);\n-            Rewrite\n-              (N, New_Occurrence_Of (Standard_True, Loc));\n-         end if;\n-      end if;\n-\n-      Adjust_Result_Type (N, Typ);\n-   end Expand_N_Or_Else;\n+   procedure Expand_N_Or_Else (N : Node_Id)\n+     renames Expand_Short_Circuit_Operator;\n \n    -----------------------------------\n    -- Expand_N_Qualified_Expression --\n@@ -8909,6 +8711,145 @@ package body Exp_Ch4 is\n       return Result;\n    end Expand_Record_Equality;\n \n+   -----------------------------------\n+   -- Expand_Short_Circuit_Operator --\n+   -----------------------------------\n+\n+   --  Expand into conditional expression if Actions present, and also deal\n+   --  with optimizing case of arguments being True or False.\n+\n+   procedure Expand_Short_Circuit_Operator (N : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Typ     : constant Entity_Id  := Etype (N);\n+      Kind    : constant Node_Kind  := Nkind (N);\n+      Left    : constant Node_Id    := Left_Opnd (N);\n+      Right   : constant Node_Id    := Right_Opnd (N);\n+      Actlist : List_Id;\n+\n+      Shortcut_Value : constant Boolean := Nkind (N) = N_Or_Else;\n+      Shortcut_Ent   : constant Entity_Id := Boolean_Literals (Shortcut_Value);\n+      --  If Left = Shortcut_Value then Right need not be evaluated\n+\n+      Expr_If_Left_True, Expr_If_Left_False : Node_Id;\n+\n+   begin\n+      --  Deal with non-standard booleans\n+\n+      if Is_Boolean_Type (Typ) then\n+         Adjust_Condition (Left);\n+         Adjust_Condition (Right);\n+         Set_Etype (N, Standard_Boolean);\n+      end if;\n+\n+      --  Check for cases where left argument is known to be True or False\n+\n+      if Compile_Time_Known_Value (Left) then\n+\n+         --  Rewrite True AND THEN Right / False OR ELSE Right to Right.\n+         --  Any actions associated with Right will be executed unconditionally\n+         --  and can thus be inserted into the tree unconditionally.\n+\n+         if Expr_Value_E (Left) /= Shortcut_Ent then\n+            if Present (Actions (N)) then\n+               Insert_Actions (N, Actions (N));\n+            end if;\n+\n+            Rewrite (N, Right);\n+\n+         --  Rewrite False AND THEN Right / True OR ELSE Right to Left.\n+         --  In this case we can forget the actions associated with Right,\n+         --  since they will never be executed.\n+\n+         else\n+            Kill_Dead_Code (Right);\n+            Kill_Dead_Code (Actions (N));\n+            Rewrite (N, New_Occurrence_Of (Shortcut_Ent, Loc));\n+         end if;\n+\n+         Adjust_Result_Type (N, Typ);\n+         return;\n+      end if;\n+\n+      --  If Actions are present, we expand\n+\n+      --     left AND THEN right\n+      --     left OR ELSE right\n+\n+      --  into\n+\n+      --     if left then right else false end\n+      --     if left then true else right end\n+\n+      --  with the actions for the right operand being transferred to the\n+      --  approriate actions list of the conditional expression. This\n+      --  conditional expression is then further expanded (and will eventually\n+      --  disappear).\n+\n+      if Present (Actions (N)) then\n+         Actlist := Actions (N);\n+\n+         if Kind = N_And_Then then\n+            Expr_If_Left_True  := Right;\n+            Expr_If_Left_False := New_Occurrence_Of (Standard_False, Loc);\n+\n+         else\n+            Expr_If_Left_True  := New_Occurrence_Of (Standard_True, Loc);\n+            Expr_If_Left_False := Right;\n+         end if;\n+\n+         Rewrite (N,\n+            Make_Conditional_Expression (Loc,\n+              Expressions => New_List (\n+                Left,\n+                Expr_If_Left_True,\n+                Expr_If_Left_False)));\n+\n+         --  If the right part of an AND THEN is a function call then it can\n+         --  be part of the expansion of the predefined equality operator of a\n+         --  tagged type and we may need to adjust its SCIL dispatching node.\n+\n+         if Generate_SCIL\n+           and then Kind = N_And_Then\n+           and then Nkind (Right) = N_Function_Call\n+         then\n+            Adjust_SCIL_Node (N, Right);\n+         end if;\n+\n+         if Kind = N_And_Then then\n+            Set_Then_Actions (N, Actlist);\n+         else\n+            Set_Else_Actions (N, Actlist);\n+         end if;\n+\n+         Analyze_And_Resolve (N, Standard_Boolean);\n+         Adjust_Result_Type (N, Typ);\n+         return;\n+      end if;\n+\n+      --  No actions present, check for cases of right argument True/False\n+\n+      if Compile_Time_Known_Value (Right) then\n+\n+         --  Change (Left and then True), (Left or else False) to Left.\n+         --  Note that we know there are no actions associated with the right\n+         --  operand, since we just checked for this case above.\n+\n+         if Expr_Value_E (Right) /= Shortcut_Ent then\n+            Rewrite (N, Left);\n+\n+         --  Change (Left and then False), (Left or else True) to Right,\n+         --  making sure to preserve any side effects associated with the Left\n+         --  operand.\n+\n+         else\n+            Remove_Side_Effects (Left);\n+            Rewrite (N, New_Occurrence_Of (Shortcut_Ent, Loc));\n+         end if;\n+      end if;\n+\n+      Adjust_Result_Type (N, Typ);\n+   end Expand_Short_Circuit_Operator;\n+\n    -------------------------------------\n    -- Fixup_Universal_Fixed_Operation --\n    -------------------------------------"}, {"sha": "9b6a308ae4349fba10926830ef14c0459cf1d7e1", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -2653,12 +2653,13 @@ ada/lib-load.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n ada/lib-util.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/hostparm.ads \\\n    ada/lib.ads ada/lib-util.ads ada/lib-util.adb ada/namet.ads ada/opt.ads \\\n-   ada/osint.ads ada/osint-c.ads ada/output.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/tree_io.ads ada/types.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads \n+   ada/osint.ads ada/osint-c.ads ada/output.ads ada/stringt.ads \\\n+   ada/stringt.adb ada/system.ads ada/s-carun8.ads ada/s-exctab.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tree_io.ads ada/types.ads ada/types.adb ada/uintp.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads \n \n ada/lib-writ.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/ali.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -2674,15 +2675,15 @@ ada/lib-writ.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sem_aux.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n    ada/sinput.adb ada/snames.ads ada/stand.ads ada/stringt.ads \\\n    ada/stringt.adb ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-casuti.ads ada/s-carun8.ads \\\n-   ada/s-crc32.ads ada/s-crc32.adb ada/s-exctab.ads ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n-   ada/types.ads ada/types.adb ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/stylesw.ads ada/system.ads ada/s-casuti.ads ada/s-crc32.ads \\\n+   ada/s-crc32.adb ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/types.ads \\\n+   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/lib-xref.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\"}, {"sha": "7ea24549e4662300908b8c94b07a742b33502451", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -10756,7 +10756,7 @@ Each @var{filename} is the name (including the extension) of a source\n file to process. ``Wildcards'' are allowed, and\n the file name may contain path information.\n \n-@samp{-cargs @var{gcc_switches}} is a list of switches for\n+@samp{@var{gcc_switches}} is a list of switches for\n @command{gcc}. They will be passed on to all compiler invocations made by\n @command{gnatelim} to generate the ASIS trees. Here you can provide\n @option{^-I^/INCLUDE_DIRS=^} switches to form the source search path,\n@@ -16164,7 +16164,7 @@ The @command{gnatpp} command has the form\n @smallexample\n @c $ gnatpp @ovar{switches} @var{filename}\n @c Expanding @ovar macro inline (explanation in macro def comments)\n-$ gnatpp @r{[}@var{switches}@r{]} @var{filename}\n+$ gnatpp @r{[}@var{switches}@r{]} @var{filename} @r{[}-cargs @var{gcc_switches}@r{]}\n @end smallexample\n \n @noindent\n@@ -16180,6 +16180,13 @@ output source file\n reformat; ``wildcards'' or several file names on the same gnatpp command are\n allowed.  The file name may contain path information; it does not have to\n follow the GNAT file naming rules\n+\n+@item\n+@samp{@var{gcc_switches}} is a list of switches for\n+@command{gcc}. They will be passed on to all compiler invocations made by\n+@command{gnatelim} to generate the ASIS trees. Here you can provide\n+@option{^-I^/INCLUDE_DIRS=^} switches to form the source search path,\n+use the @option{-gnatec} switch to set the configuration file etc.\n @end itemize\n \n @menu\n@@ -17289,7 +17296,7 @@ Including both a @option{-files} switch and one or more\n @var{filename} arguments is permitted.\n \n @item\n-@samp{-cargs @var{gcc_switches}} is a list of switches for\n+@samp{@var{gcc_switches}} is a list of switches for\n @command{gcc}. They will be passed on to all compiler invocations made by\n @command{gnatmetric} to generate the ASIS trees. Here you can provide\n @option{^-I^/INCLUDE_DIRS=^} switches to form the source search path,\n@@ -23206,7 +23213,7 @@ option @option{^--no-exception^/NO_EXCEPTION^} (see below).\n @smallexample\n @c $ gnatstub @ovar{switches} @var{filename} @ovar{directory}\n @c Expanding @ovar macro inline (explanation in macro def comments)\n-$ gnatstub @r{[}@var{switches}@r{]} @var{filename} @r{[}@var{directory}@r{]}\n+$ gnatstub @r{[}@var{switches}@r{]} @var{filename} @r{[}@var{directory}@r{]} @r{[}-cargs @var{gcc_switches}@r{]}\n @end smallexample\n \n @noindent\n@@ -23234,6 +23241,12 @@ indicates the directory in which the body stub is to be placed (the default\n is the\n current directory)\n \n+@item @samp{@var{gcc_switches}} is a list of switches for\n+@command{gcc}. They will be passed on to all compiler invocations made by\n+@command{gnatelim} to generate the ASIS trees. Here you can provide\n+@option{^-I^/INCLUDE_DIRS=^} switches to form the source search path,\n+use the @option{-gnatec} switch to set the configuration file etc.\n+\n @item switches\n is an optional sequence of switches as described in the next section\n @end table"}, {"sha": "86303d1627d14939cac906bd359050a0dcd74020", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -68,9 +68,10 @@ package Lib.Xref is\n    --        col is the column number of the referenced entity\n \n    --        level is a single character that separates the col and\n-   --        entity fields. It is an asterisk for a top level library\n+   --        entity fields. It is an asterisk (*) for a top level library\n    --        entity that is publicly visible, as well for an entity declared\n-   --        in the visible part of a generic package, and space otherwise.\n+   --        in the visible part of a generic package, the plus sign (+) for\n+   --        a C/C++ static entity, and space otherwise.\n \n    --        entity is the name of the referenced entity, with casing in\n    --        the canonical casing for the source file where it is defined."}, {"sha": "c97710e8ca4767d8b92e1c92814301c629e7e712", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -1028,7 +1028,11 @@ package body Ch10 is\n \n       Ignore (Tok_Semicolon);\n \n-      if Token = Tok_Function or else Token = Tok_Procedure then\n+      if Token = Tok_Function\n+        or else Token = Tok_Not\n+        or else Token = Tok_Overriding\n+        or else Token = Tok_Procedure\n+      then\n          Body_Node := P_Subprogram (Pf_Pbod);\n \n       elsif Token = Tok_Package then"}, {"sha": "2916f53d1623049c3c69944ba7e4f943ddfe267a", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -215,14 +215,17 @@ package body Ch6 is\n          --  already been given, so no need to give another message here.\n \n          --  An overriding indicator is allowed for subprogram declarations,\n-         --  bodies, renamings, stubs, and instantiations. The test against\n-         --  Pf_Decl_Pbod is added to account for the case of subprograms\n-         --  declared in a protected type, where only subprogram declarations\n-         --  and bodies can occur.\n+         --  bodies (including subunits), renamings, stubs, and\n+         --  instantiations. The test against Pf_Decl_Pbod is added to account\n+         --  for the case of subprograms declared in a protected type, where\n+         --  only subprogram declarations and bodies can occur. The Pf_Pbod\n+         --  case is for subunits.\n \n          if Pf_Flags /= Pf_Decl_Gins_Pbod_Rnam_Stub\n               and then\n             Pf_Flags /= Pf_Decl_Pbod\n+              and then\n+            Pf_Flags /= Pf_Pbod\n          then\n             Error_Msg_SC (\"overriding indicator not allowed here!\");\n "}, {"sha": "1ccc37bca01f494800029a8f92d13ec761140962", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5875f8d66eca25f9208bf948c2aa80d6bb88d99f/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=5875f8d66eca25f9208bf948c2aa80d6bb88d99f", "patch": "@@ -45,16 +45,6 @@ struct Exception_Data\n \n typedef struct Exception_Data *Exception_Id;\n \n-struct Exception_Occurrence\n-{\n-  int Max_Length;\n-  Exception_Id Id;\n-  int Msg_Length;\n-  char Msg[0];\n-};\n-\n-typedef struct Exception_Occurrence *Exception_Occurrence_Access;\n-\n extern void _gnat_builtin_longjmp\t(void *, int);\n extern void __gnat_unhandled_terminate\t(void);\n extern void *__gnat_malloc\t\t(__SIZE_TYPE__);"}]}