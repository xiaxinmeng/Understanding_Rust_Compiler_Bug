{"sha": "4a720a9547320699aceda7d2e0b08de5ab40132f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE3MjBhOTU0NzMyMDY5OWFjZWRhN2QyZTBiMDhkZTVhYjQwMTMyZg==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-04-02T21:23:13Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-16T16:52:23Z"}, "message": "rs6000: Add initial input files\n\nThis patch adds a tiny subset of the built-in and overload descriptions.\n\n2021-04-02  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-builtin-new.def: New.\n\t* config/rs6000/rs6000-overload.def: New.", "tree": {"sha": "290b60cfe36ba013039e6cf13efdb370957d2279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/290b60cfe36ba013039e6cf13efdb370957d2279"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a720a9547320699aceda7d2e0b08de5ab40132f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a720a9547320699aceda7d2e0b08de5ab40132f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a720a9547320699aceda7d2e0b08de5ab40132f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a720a9547320699aceda7d2e0b08de5ab40132f/comments", "author": null, "committer": null, "parents": [{"sha": "bd5b625228d545d5ecb35df24f9f094edc95e3fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5b625228d545d5ecb35df24f9f094edc95e3fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd5b625228d545d5ecb35df24f9f094edc95e3fa"}], "stats": {"total": 281, "additions": 281, "deletions": 0}, "files": [{"sha": "a84a3def2d5d265b601723b607b22814bc98c90e", "filename": "gcc/config/rs6000/rs6000-builtin-new.def", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a720a9547320699aceda7d2e0b08de5ab40132f/gcc%2Fconfig%2Frs6000%2Frs6000-builtin-new.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a720a9547320699aceda7d2e0b08de5ab40132f/gcc%2Fconfig%2Frs6000%2Frs6000-builtin-new.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin-new.def?ref=4a720a9547320699aceda7d2e0b08de5ab40132f", "patch": "@@ -0,0 +1,199 @@\n+; Built-in functions for PowerPC.\n+; Copyright (C) 2020-21 Free Software Foundation, Inc.\n+; Contributed by Bill Schmidt, IBM <wschmidt@linux.ibm.com>\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+\n+; Built-in functions in this file are organized into \"stanzas\", where\n+; all built-ins in a given stanza are enabled together.  Each stanza\n+; starts with a line identifying the circumstances in which the group of\n+; functions is permitted, with the gating predicate in square brackets.\n+; For example, this could be\n+;\n+;     [altivec]\n+;\n+;   or it could be\n+;\n+;     [power9]\n+;\n+; The bracketed gating predicate is the only information allowed on\n+; the stanza header line, other than whitespace.\n+;\n+; Following the stanza header are two lines for each function: the\n+; prototype line and the attributes line.  The prototype line has\n+; this format, where the square brackets indicate optional\n+; information and angle brackets indicate required information:\n+;\n+;   [kind] <return-type> <bif-name> (<argument-list>);\n+;\n+; Here [kind] can be one of \"const\", \"pure\", or \"fpmath\";\n+; <return-type> is a legal type for a built-in function result;\n+; <bif-name> is the name by which the function can be called;\n+; and <argument-list> is a comma-separated list of legal types\n+; for built-in function arguments.  The argument list may be\n+; empty, but the parentheses and semicolon are required.\n+;\n+; A legal type is of the form:\n+;\n+;   [const] [[signed|unsigned] <basetype> | <vectype>] [*]\n+;\n+; where \"const\" applies only to a <basetype> of \"int\".  Legal values\n+; of <basetype> are (for now):\n+;\n+;   char\n+;   short\n+;   int\n+;   long\n+;   long double\n+;   long long\n+;   float\n+;   double\n+;   __int128\n+;   _Float128\n+;   bool\n+;   string\n+;   _Decimal32\n+;   _Decimal64\n+;   _Decimal128\n+;   __ibm128\n+;\n+; Legal values of <vectype> are as follows, and are shorthand for\n+; the associated meaning:\n+;\n+;   vsc\t\tvector signed char\n+;   vuc\t\tvector unsigned char\n+;   vbc\t\tvector bool char\n+;   vss\t\tvector signed short\n+;   vus\t\tvector unsigned short\n+;   vbs\t\tvector bool short\n+;   vsi\t\tvector signed int\n+;   vui\t\tvector unsigned int\n+;   vbi\t\tvector bool int\n+;   vsll\tvector signed long long\n+;   vull\tvector unsigned long long\n+;   vbll\tvector bool long long\n+;   vsq\t\tvector signed __int128\n+;   vuq\t\tvector unsigned __int128\n+;   vbq\t\tvector bool __int128\n+;   vp\t\tvector pixel\n+;   vf\t\tvector float\n+;   vd\t\tvector double\n+;   v256\t__vector_pair\n+;   v512\t__vector_quad\n+;\n+; For simplicity, We don't support \"short int\" and \"long long int\".\n+; We don't currently support a <basetype> of \"_Float16\".  \"signed\"\n+; and \"unsigned\" only apply to integral base types.  The optional *\n+; indicates a pointer type.\n+;\n+; The attributes line looks like this:\n+;\n+;   <bif-id> <bif-pattern> {<attribute-list>}\n+;\n+; Here <bif-id> is a unique internal identifier for the built-in\n+; function that will be used as part of an enumeration of all\n+; built-in functions; <bif-pattern> is the define_expand or\n+; define_insn that will be invoked when the call is expanded;\n+; and <attribute-list> is a comma-separated list of special\n+; conditions that apply to the built-in function.  The attribute\n+; list may be empty, but the braces are required.\n+;\n+; Attributes are strings, and the allowed ones are listed below.\n+;\n+;   init     Process as a vec_init function\n+;   set      Process as a vec_set function\n+;   extract  Process as a vec_extract function\n+;   nosoft   Not valid with -msoft-float\n+;   ldvec    Needs special handling for vec_ld semantics\n+;   stvec    Needs special handling for vec_st semantics\n+;   reve     Needs special handling for element reversal\n+;   pred     Needs special handling for comparison predicates\n+;   htm      Needs special handling for transactional memory\n+;   htmspr   HTM function using an SPR\n+;   htmcr    HTM function using a CR\n+;   mma      Needs special handling for MMA\n+;   quad     MMA instruction using a register quad as an input operand\n+;   pair     MMA instruction using a register pair as an input operand\n+;   no32bit  Not valid for TARGET_32BIT\n+;   32bit    Requires different handling for TARGET_32BIT\n+;   cpu      This is a \"cpu_is\" or \"cpu_supports\" builtin\n+;   ldstmask Altivec mask for load or store\n+;   lxvrse   Needs special handling for load-rightmost, sign-extended\n+;   lxvrze   Needs special handling for load-rightmost, zero-extended\n+;   endian   Needs special handling for endianness\n+;\n+; Each attribute corresponds to extra processing required when\n+; the built-in is expanded.  All such special processing should\n+; be controlled by an attribute from now on.\n+;\n+; It is important to note that each entry's <bif-name> must be\n+; unique.  The code generated from this file will call def_builtin\n+; for each entry, and this can only happen once per name.\n+;\n+; The type signature for the builtin must match the modes of the RTL\n+; pattern <bif-pattern>.  When a builtin is used only as a basis for\n+; overloading, you can use an arbitrary type for each mode (for example,\n+; for V8HImode, you could use vp, vss, vus, or vbs).  The overloading\n+; machinery takes care of adding appropriate casts between vectors to\n+; satisfy impedance matching.  The overloaded prototypes are the ones\n+; that must match what users expect.  Thus you will often have a small\n+; number of entries in this file that correspond to a much greater\n+; number of entries in rs6000-overload.def.\n+;\n+; However, builtins in this file that are expected to be directly called\n+; by users must have one version for each expected type combination.\n+;\n+; Eventually we want to automatically generate built-in documentation\n+; from the entries in this file.  Documenting of built-ins with more\n+; than one acceptable prototype can be done by cross-referencing\n+; against rs6000-overload.def and picking up the allowable prototypes\n+; from there.\n+;\n+; Blank lines may be used as desired in this file between the lines as\n+; defined above; that is, you can introduce as many extra newlines as you\n+; like after a required newline, but nowhere else.  Lines beginning with\n+; a semicolon are also treated as blank lines.\n+;\n+; A const int argument may be restricted to certain values.  This is\n+; indicated by one of the following occurring after the \"int\" token:\n+;\n+;    <x>   restricts the constant to x bits, interpreted as unsigned\n+;    <x,y> restricts the constant to the inclusive range [x,y]\n+;    [x,y] restricts the constant to the inclusive range [x,y],\n+;\t   but only applies if the argument is constant.\n+;    {x,y} restricts the constant to one of two values, x or y.\n+;\n+; Here x and y are integer tokens.  Note that the \"const\" token is a\n+; lie when the restriction is [x,y], but this simplifies the parsing\n+; significantly and is hopefully forgivable.\n+\n+\n+\n+; AltiVec builtins.\n+[altivec]\n+  const vsc __builtin_altivec_abs_v16qi (vsc);\n+    ABS_V16QI absv16qi2 {}\n+\n+  const vf __builtin_altivec_abs_v4sf (vf);\n+    ABS_V4SF absv4sf2 {}\n+\n+  const vsi __builtin_altivec_abs_v4si (vsi);\n+    ABS_V4SI absv4si2 {}\n+\n+  const vss __builtin_altivec_abs_v8hi (vss);\n+    ABS_V8HI absv8hi2 {}"}, {"sha": "d8028c94470316b907c7b21f25eef48a9bc6a9aa", "filename": "gcc/config/rs6000/rs6000-overload.def", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a720a9547320699aceda7d2e0b08de5ab40132f/gcc%2Fconfig%2Frs6000%2Frs6000-overload.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a720a9547320699aceda7d2e0b08de5ab40132f/gcc%2Fconfig%2Frs6000%2Frs6000-overload.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-overload.def?ref=4a720a9547320699aceda7d2e0b08de5ab40132f", "patch": "@@ -0,0 +1,82 @@\n+; Overloaded built-in functions for PowerPC.\n+; Copyright (C) 2020-21 Free Software Foundation, Inc.\n+; Contributed by Bill Schmidt, IBM <wschmidt@linux.ibm.com>\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+\n+; Overloaded built-in functions in this file are organized into \"stanzas\",\n+; where all built-ins in a given stanza have the same overloaded function\n+; name:\n+;\n+;   [<overload-id>, <abi-name>, <builtin-name>[[, <ifdef>]] ]\n+;\n+; Here the single square brackets are part of the syntax; <overload-id>\n+; is a unique internal identifier for the overload that will be used as\n+; part of an enumeration of all overloaded functions; <abi-name> is the\n+; name that will appear as a #define in rs6000-vecdefines.h;\n+; <builtin-name> is the name that is overloaded in the back end; and\n+; <ifdef> is an optional token used to guard the #define with an #ifdef\n+; in rs6000-vecdefines.h.  If no #define is desired, the <abi-name> should\n+; be replaced with the token SKIP.\n+;\n+; Each function entry has two lines.  The first line is a prototype line.\n+; See rs6000-builtin-new.def for a description of the prototype line.\n+; A prototype line in this file differs in that it doesn't have an\n+; optional [kind] token:\n+;\n+;   <return-type> <internal-name> (<argument-list>);\n+;\n+; The second line contains the <bif-id> that this particular instance of\n+; the overloaded function maps to.  It must match a token that appears in\n+; rs6000-builtin-new.def.  Optionally, a second token may appear.  If only\n+; one token is on the line, it is also used to build the unique identifier\n+; for the overloaded function.  If a second token is present, the second\n+; token is used instead for this purpose.  This is necessary in cases\n+; where a built-in function accepts more than one type signature.  It is\n+; common to have a built-in function that, for example, specifies a\n+; \"vector signed char\" argument, but accepts \"vector unsigned char\" and\n+; \"vector bool char\" as well because only the mode matters.  Note that\n+; the overload resolution mechanism has always handled these cases by\n+; performing fold_convert on vector arguments to hide type mismatches,\n+; and it will continue to do so.\n+;\n+; As a concrete example, __builtin_altivec_mtvscr uses an opaque argument\n+; type for the source operand.  Its built-in function id is MTVSCR.  The\n+; overloaded function __builtin_vec_mtvscr takes a variety of specific\n+; types, but not all vector types.  Each of these maps to the same\n+; __builtin_altivec_mtvscr built-in function, but the overload ID must\n+; be unique, so we must specify the second token as shown here.\n+;\n+;[VEC_MTVSCR, vec_mtvscr, __builtin_vec_mtvscr]\n+;  void __builtin_vec_mtvscr (vbc);\n+;    MTVSCR  MTVSCR_VBC\n+;  void __builtin_vec_mtvscr (vsc);\n+;    MTVSCR  MTVSCR_VSC\n+;  ...\n+;\n+; Blank lines may be used as desired in this file between the lines as\n+; defined above; that is, you can introduce as many extra newlines as you\n+; like after a required newline, but nowhere else.  Lines beginning with\n+; a semicolon are also treated as blank lines.\n+\n+\n+[VEC_ABS, vec_abs, __builtin_vec_abs]\n+  vsc __builtin_vec_abs (vsc);\n+    ABS_V16QI\n+  vss __builtin_vec_abs (vss);\n+    ABS_V8HI"}]}