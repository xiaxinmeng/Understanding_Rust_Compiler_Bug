{"sha": "59e54267fc4d2eec894f1f4f4f8fc596cee68f3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTllNTQyNjdmYzRkMmVlYzg5NGYxZjRmNGY4ZmM1OTZjZWU2OGYzYQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-02-15T09:40:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:40:13Z"}, "message": "re PR ada/18819 (ACATS cdd2a02 fail at runtime)\n\n2006-02-13  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_util.ads, exp_util.adb (Find_Prim_Op,\n\tIs_Predefined_Primitive_Operation): When\n\tsearching for the predefined equality operator, verify that operands\n\thave the same type.\n\t(Is_Predefined_Dispatching_Operation): Remove the code that looks\n\tfor the last entity in the list of aliased subprograms. This code\n\twas wrong in case of renamings.\n\t(Set_Renamed_Subprogram): New procedure\n\t(Remove_Side_Effects): Replace calls to Etype (Exp) with use of the\n\tExp_Type constant computed when entering this subprogram.\n\t(Known_Null): New function\n\t(OK_To_Do_Constant_Replacement): New function\n\t(Known_Non_Null): Check scope before believing Is_Known_Non_Null flag\n\t(Side_Effect_Free): An attribute reference 'Input is not free of\n\tside effect, unlike other attributes that are functions. (from code\n\treading).\n\t(Remove_Side_Effects): Expressions that involve packed arrays or records\n\tare copied at the point of reference, and therefore must be marked as\n\trenamings of objects.\n\t(Is_Predefined_Dispatching_Operation): Return false if the operation is\n\tnot a dispatching operation.\n\n\tPR ada/18819\n\t(Remove_Side_Effects): Lift enclosing type conversion nodes for\n\telementary types in all cases.\n\nFrom-SVN: r111069", "tree": {"sha": "32c03273ec579732a66a0a65cd00ad690b168a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32c03273ec579732a66a0a65cd00ad690b168a81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f55cfa2e7ffb31f3afcd63d10308574bcc9cae4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f55cfa2e7ffb31f3afcd63d10308574bcc9cae4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f55cfa2e7ffb31f3afcd63d10308574bcc9cae4a"}], "stats": {"total": 567, "additions": 380, "deletions": 187}, "files": [{"sha": "732e0626475b83aa7d0dbd4d73d022cc5c57a0b8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 354, "deletions": 182, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=59e54267fc4d2eec894f1f4f4f8fc596cee68f3a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,6 +26,7 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -273,7 +274,7 @@ package body Exp_Util is\n       Ensure_Freeze_Node (T);\n       Fnode := Freeze_Node (T);\n \n-      if not Present (Actions (Fnode)) then\n+      if No (Actions (Fnode)) then\n          Set_Actions (Fnode, New_List);\n       end if;\n \n@@ -1541,14 +1542,14 @@ package body Exp_Util is\n       Found  : Boolean := False;\n       Typ    : Entity_Id := T;\n \n-      procedure Find_Tag (Typ : in Entity_Id);\n+      procedure Find_Tag (Typ : Entity_Id);\n       --  Internal subprogram used to recursively climb to the ancestors\n \n       --------------\n       -- Find_Tag --\n       --------------\n \n-      procedure Find_Tag (Typ : in Entity_Id) is\n+      procedure Find_Tag (Typ : Entity_Id) is\n          AI_Elmt : Elmt_Id;\n          AI      : Node_Id;\n \n@@ -1655,14 +1656,14 @@ package body Exp_Util is\n       Iface  : Entity_Id;\n       Typ    : Entity_Id := T;\n \n-      procedure Find_Iface (Typ : in Entity_Id);\n+      procedure Find_Iface (Typ : Entity_Id);\n       --  Internal subprogram used to recursively climb to the ancestors\n \n       ----------------\n       -- Find_Iface --\n       ----------------\n \n-      procedure Find_Iface (Typ : in Entity_Id) is\n+      procedure Find_Iface (Typ : Entity_Id) is\n          AI_Elmt : Elmt_Id;\n \n       begin\n@@ -1744,6 +1745,7 @@ package body Exp_Util is\n    function Find_Prim_Op (T : Entity_Id; Name : Name_Id) return Entity_Id is\n       Prim : Elmt_Id;\n       Typ  : Entity_Id := T;\n+      Op   : Entity_Id;\n \n    begin\n       if Is_Class_Wide_Type (Typ) then\n@@ -1752,8 +1754,22 @@ package body Exp_Util is\n \n       Typ := Underlying_Type (Typ);\n \n+      --  Loop through primitive operations\n+\n       Prim := First_Elmt (Primitive_Operations (Typ));\n-      while Chars (Node (Prim)) /= Name loop\n+      while Present (Prim) loop\n+         Op := Node (Prim);\n+\n+         --  We can retrieve primitive operations by name if it is an internal\n+         --  name. For equality we must check that both of its operands have\n+         --  the same type, to avoid confusion with user-defined equalities\n+         --  than may have a non-symmetric signature.\n+\n+         exit when Chars (Op) = Name\n+           and then\n+             (Name /= Name_Op_Eq\n+                or else Etype (First_Entity (Op)) = Etype (Last_Entity (Op)));\n+\n          Next_Elmt (Prim);\n          pragma Assert (Present (Prim));\n       end loop;\n@@ -1822,166 +1838,179 @@ package body Exp_Util is\n       Op  : out Node_Kind;\n       Val : out Node_Id)\n    is\n-      Loc  : constant Source_Ptr := Sloc (Var);\n-      CV   : constant Node_Id    := Current_Value (Entity (Var));\n-      Sens : Boolean;\n-      Stm  : Node_Id;\n-      Cond : Node_Id;\n+      Loc : constant Source_Ptr := Sloc (Var);\n+      Ent : constant Entity_Id  := Entity (Var);\n \n    begin\n       Op  := N_Empty;\n       Val := Empty;\n \n-      --  If statement. Condition is known true in THEN section, known False\n-      --  in any ELSIF or ELSE part, and unknown outside the IF statement.\n+      --  Immediate return, nothing doing, if this is not an object\n \n-      if Nkind (CV) = N_If_Statement then\n+      if Ekind (Ent) not in Object_Kind then\n+         return;\n+      end if;\n \n-         --  Before start of IF statement\n+      --  Otherwise examine current value\n \n-         if Loc < Sloc (CV) then\n-            return;\n+      declare\n+         CV   : constant Node_Id := Current_Value (Ent);\n+         Sens : Boolean;\n+         Stm  : Node_Id;\n+         Cond : Node_Id;\n \n-         --  After end of IF statement\n+      begin\n+         --  If statement. Condition is known true in THEN section, known False\n+         --  in any ELSIF or ELSE part, and unknown outside the IF statement.\n \n-         elsif Loc >= Sloc (CV) + Text_Ptr (UI_To_Int (End_Span (CV))) then\n-            return;\n-         end if;\n+         if Nkind (CV) = N_If_Statement then\n \n-         --  At this stage we know that we are within the IF statement, but\n-         --  unfortunately, the tree does not record the SLOC of the ELSE so\n-         --  we cannot use a simple SLOC comparison to distinguish between\n-         --  the then/else statements, so we have to climb the tree.\n+            --  Before start of IF statement\n \n-         declare\n-            N : Node_Id;\n+            if Loc < Sloc (CV) then\n+               return;\n \n-         begin\n-            N := Parent (Var);\n-            while Parent (N) /= CV loop\n-               N := Parent (N);\n+               --  After end of IF statement\n \n-               --  If we fall off the top of the tree, then that's odd, but\n-               --  perhaps it could occur in some error situation, and the\n-               --  safest response is simply to assume that the outcome of the\n-               --  condition is unknown. No point in bombing during an attempt\n-               --  to optimize things.\n+            elsif Loc >= Sloc (CV) + Text_Ptr (UI_To_Int (End_Span (CV))) then\n+               return;\n+            end if;\n \n-               if No (N) then\n-                  return;\n-               end if;\n-            end loop;\n+            --  At this stage we know that we are within the IF statement, but\n+            --  unfortunately, the tree does not record the SLOC of the ELSE so\n+            --  we cannot use a simple SLOC comparison to distinguish between\n+            --  the then/else statements, so we have to climb the tree.\n \n-            --  Now we have N pointing to a node whose parent is the IF\n-            --  statement in question, so now we can tell if we are within\n-            --  the THEN statements.\n+            declare\n+               N : Node_Id;\n \n-            if Is_List_Member (N)\n-              and then List_Containing (N) = Then_Statements (CV)\n-            then\n-               Sens := True;\n+            begin\n+               N := Parent (Var);\n+               while Parent (N) /= CV loop\n+                  N := Parent (N);\n \n-            --  Otherwise we must be in ELSIF or ELSE part\n+                  --  If we fall off the top of the tree, then that's odd, but\n+                  --  perhaps it could occur in some error situation, and the\n+                  --  safest response is simply to assume that the outcome of\n+                  --  the condition is unknown. No point in bombing during an\n+                  --  attempt to optimize things.\n \n-            else\n-               Sens := False;\n-            end if;\n-         end;\n+                  if No (N) then\n+                     return;\n+                  end if;\n+               end loop;\n \n-      --  ELSIF part. Condition is known true within the referenced ELSIF,\n-      --  known False in any subsequent ELSIF or ELSE part, and unknown before\n-      --  the ELSE part or after the IF statement.\n+               --  Now we have N pointing to a node whose parent is the IF\n+               --  statement in question, so now we can tell if we are within\n+               --  the THEN statements.\n \n-      elsif Nkind (CV) = N_Elsif_Part then\n-         Stm := Parent (CV);\n+               if Is_List_Member (N)\n+                 and then List_Containing (N) = Then_Statements (CV)\n+               then\n+                  Sens := True;\n \n-         --  Before start of ELSIF part\n+                  --  Otherwise we must be in ELSIF or ELSE part\n \n-         if Loc < Sloc (CV) then\n-            return;\n+               else\n+                  Sens := False;\n+               end if;\n+            end;\n \n-         --  After end of IF statement\n+            --  ELSIF part. Condition is known true within the referenced\n+            --  ELSIF, known False in any subsequent ELSIF or ELSE part, and\n+            --  unknown before the ELSE part or after the IF statement.\n \n-         elsif Loc >= Sloc (Stm) +\n-                        Text_Ptr (UI_To_Int (End_Span (Stm)))\n-         then\n-            return;\n-         end if;\n+         elsif Nkind (CV) = N_Elsif_Part then\n+            Stm := Parent (CV);\n \n-         --  Again we lack the SLOC of the ELSE, so we need to climb the tree\n-         --  to see if we are within the ELSIF part in question.\n+            --  Before start of ELSIF part\n \n-         declare\n-            N : Node_Id;\n+            if Loc < Sloc (CV) then\n+               return;\n \n-         begin\n-            N := Parent (Var);\n-            while Parent (N) /= Stm loop\n-               N := Parent (N);\n+               --  After end of IF statement\n \n-               --  If we fall off the top of the tree, then that's odd, but\n-               --  perhaps it could occur in some error situation, and the\n-               --  safest response is simply to assume that the outcome of the\n-               --  condition is unknown. No point in bombing during an attempt\n-               --  to optimize things.\n+            elsif Loc >= Sloc (Stm) +\n+              Text_Ptr (UI_To_Int (End_Span (Stm)))\n+            then\n+               return;\n+            end if;\n \n-               if No (N) then\n-                  return;\n-               end if;\n-            end loop;\n+            --  Again we lack the SLOC of the ELSE, so we need to climb the\n+            --  tree to see if we are within the ELSIF part in question.\n \n-            --  Now we have N pointing to a node whose parent is the IF\n-            --  statement in question, so see if is the ELSIF part we want.\n-            --  the THEN statements.\n+            declare\n+               N : Node_Id;\n \n-            if N = CV then\n-               Sens := True;\n+            begin\n+               N := Parent (Var);\n+               while Parent (N) /= Stm loop\n+                  N := Parent (N);\n \n-            --  Otherwise we must be in susbequent ELSIF or ELSE part\n+                  --  If we fall off the top of the tree, then that's odd, but\n+                  --  perhaps it could occur in some error situation, and the\n+                  --  safest response is simply to assume that the outcome of\n+                  --  the condition is unknown. No point in bombing during an\n+                  --  attempt to optimize things.\n \n-            else\n-               Sens := False;\n-            end if;\n-         end;\n+                  if No (N) then\n+                     return;\n+                  end if;\n+               end loop;\n \n-      --  All other cases of Current_Value settings\n+               --  Now we have N pointing to a node whose parent is the IF\n+               --  statement in question, so see if is the ELSIF part we want.\n+               --  the THEN statements.\n \n-      else\n-         return;\n-      end if;\n+               if N = CV then\n+                  Sens := True;\n \n-      --  If we fall through here, then we have a reportable condition, Sens is\n-      --  True if the condition is true and False if it needs inverting.\n+                  --  Otherwise we must be in susbequent ELSIF or ELSE part\n \n-      --  Deal with NOT operators, inverting sense\n+               else\n+                  Sens := False;\n+               end if;\n+            end;\n \n-      Cond := Condition (CV);\n-      while Nkind (Cond) = N_Op_Not loop\n-         Cond := Right_Opnd (Cond);\n-         Sens := not Sens;\n-      end loop;\n+            --  All other cases of Current_Value settings\n+\n+         else\n+            return;\n+         end if;\n \n-      --  Now we must have a relational operator\n+         --  If we fall through here, then we have a reportable condition, Sens\n+         --  is True if the condition is true and False if it needs inverting.\n \n-      pragma Assert (Entity (Var) = Entity (Left_Opnd (Cond)));\n-      Val := Right_Opnd (Cond);\n-      Op  := Nkind (Cond);\n+         --  Deal with NOT operators, inverting sense\n \n-      if Sens = False then\n-         case Op is\n+         Cond := Condition (CV);\n+         while Nkind (Cond) = N_Op_Not loop\n+            Cond := Right_Opnd (Cond);\n+            Sens := not Sens;\n+         end loop;\n+\n+         --  Now we must have a relational operator\n+\n+         pragma Assert (Entity (Var) = Entity (Left_Opnd (Cond)));\n+         Val := Right_Opnd (Cond);\n+         Op  := Nkind (Cond);\n+\n+         if Sens = False then\n+            case Op is\n             when N_Op_Eq => Op := N_Op_Ne;\n             when N_Op_Ne => Op := N_Op_Eq;\n             when N_Op_Lt => Op := N_Op_Ge;\n             when N_Op_Gt => Op := N_Op_Le;\n             when N_Op_Le => Op := N_Op_Gt;\n             when N_Op_Ge => Op := N_Op_Lt;\n \n-            --  No other entry should be possible\n+               --  No other entry should be possible\n \n             when others =>\n                raise Program_Error;\n-         end case;\n-      end if;\n+            end case;\n+         end if;\n+      end;\n    end Get_Current_Value_Condition;\n \n    --------------------\n@@ -2773,19 +2802,14 @@ package body Exp_Util is\n    -- Is_Predefined_Dispatching_Operation --\n    -----------------------------------------\n \n-   function Is_Predefined_Dispatching_Operation\n-     (Subp : Entity_Id) return Boolean\n+   function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean\n    is\n       TSS_Name : TSS_Name_Type;\n-      E        : Entity_Id := Subp;\n-   begin\n-      pragma Assert (Is_Dispatching_Operation (Subp));\n \n-      --  Handle overriden subprograms\n-\n-      while Present (Alias (E)) loop\n-         E := Alias (E);\n-      end loop;\n+   begin\n+      if not Is_Dispatching_Operation (E) then\n+         return False;\n+      end if;\n \n       Get_Name_String (Chars (E));\n \n@@ -2798,7 +2822,9 @@ package body Exp_Util is\n            or else TSS_Name  = TSS_Stream_Write\n            or else TSS_Name  = TSS_Stream_Input\n            or else TSS_Name  = TSS_Stream_Output\n-           or else Chars (E) = Name_Op_Eq\n+           or else\n+             (Chars (E) = Name_Op_Eq\n+                and then Etype (First_Entity (E)) = Etype (Last_Entity (E)))\n            or else Chars (E) = Name_uAssign\n            or else TSS_Name  = TSS_Deep_Adjust\n            or else TSS_Name  = TSS_Deep_Finalize\n@@ -3324,27 +3350,38 @@ package body Exp_Util is\n \n    function Known_Non_Null (N : Node_Id) return Boolean is\n    begin\n-      pragma Assert (Is_Access_Type (Underlying_Type (Etype (N))));\n+      --  Checks for case where N is an entity reference\n \n-      --  Case of entity for which Is_Known_Non_Null is True\n+      if Is_Entity_Name (N) and then Present (Entity (N)) then\n+         declare\n+            E   : constant Entity_Id := Entity (N);\n+            Op  : Node_Kind;\n+            Val : Node_Id;\n \n-      if Is_Entity_Name (N) and then Is_Known_Non_Null (Entity (N)) then\n+         begin\n+            --  First check if we are in decisive conditional\n \n-         --  If the entity is aliased or volatile, then we decide that\n-         --  we don't know it is really non-null even if the sequential\n-         --  flow indicates that it is, since such variables can be\n-         --  changed without us noticing.\n+            Get_Current_Value_Condition (N, Op, Val);\n \n-         if Is_Aliased (Entity (N))\n-           or else Treat_As_Volatile (Entity (N))\n-         then\n-            return False;\n+            if Nkind (Val) = N_Null then\n+               if Op = N_Op_Eq then\n+                  return False;\n+               elsif Op = N_Op_Ne then\n+                  return True;\n+               end if;\n+            end if;\n \n-         --  For all other cases, the flag is decisive\n+            --  If OK to do replacement, test Is_Known_Non_Null flag\n \n-         else\n-            return True;\n-         end if;\n+            if OK_To_Do_Constant_Replacement (E) then\n+               return Is_Known_Non_Null (E);\n+\n+            --  Otherwise if not safe to do replacement, then say so\n+\n+            else\n+               return False;\n+            end if;\n+         end;\n \n       --  True if access attribute\n \n@@ -3367,26 +3404,70 @@ package body Exp_Util is\n       elsif Nkind (N) = N_Type_Conversion then\n          return Known_Non_Null (Expression (N));\n \n-      --  One more case is when Current_Value references a condition\n-      --  that ensures a non-null value.\n+      --  Above are all cases where the value could be determined to be\n+      --  non-null. In all other cases, we don't know, so return False.\n \n-      elsif Is_Entity_Name (N) then\n+      else\n+         return False;\n+      end if;\n+   end Known_Non_Null;\n+\n+   ----------------\n+   -- Known_Null --\n+   ----------------\n+\n+   function Known_Null (N : Node_Id) return Boolean is\n+   begin\n+      --  Checks for case where N is an entity reference\n+\n+      if Is_Entity_Name (N) and then Present (Entity (N)) then\n          declare\n+            E   : constant Entity_Id := Entity (N);\n             Op  : Node_Kind;\n             Val : Node_Id;\n \n          begin\n+            --  First check if we are in decisive conditional\n+\n             Get_Current_Value_Condition (N, Op, Val);\n-            return Op = N_Op_Ne and then Nkind (Val) = N_Null;\n+\n+            if Nkind (Val) = N_Null then\n+               if Op = N_Op_Eq then\n+                  return True;\n+               elsif Op = N_Op_Ne then\n+                  return False;\n+               end if;\n+            end if;\n+\n+            --  If OK to do replacement, test Is_Known_Null flag\n+\n+            if OK_To_Do_Constant_Replacement (E) then\n+               return Is_Known_Null (E);\n+\n+            --  Otherwise if not safe to do replacement, then say so\n+\n+            else\n+               return False;\n+            end if;\n          end;\n \n-      --  Above are all cases where the value could be determined to be\n-      --  non-null. In all other cases, we don't know, so return False.\n+      --  True if explicit reference to null\n+\n+      elsif Nkind (N) = N_Null then\n+         return True;\n+\n+      --  For a conversion, true if expression is known null\n+\n+      elsif Nkind (N) = N_Type_Conversion then\n+         return Known_Null (Expression (N));\n+\n+      --  Above are all cases where the value could be determined to be null.\n+      --  In all other cases, we don't know, so return False.\n \n       else\n          return False;\n       end if;\n-   end Known_Non_Null;\n+   end Known_Null;\n \n    -----------------------------\n    -- Make_CW_Equivalent_Type --\n@@ -3774,6 +3855,67 @@ package body Exp_Util is\n       return (Res);\n    end New_Class_Wide_Subtype;\n \n+   -----------------------------------\n+   -- OK_To_Do_Constant_Replacement --\n+   -----------------------------------\n+\n+   function OK_To_Do_Constant_Replacement (E : Entity_Id) return Boolean is\n+      ES : constant Entity_Id := Scope (E);\n+      CS : Entity_Id;\n+\n+   begin\n+      --  Do not replace statically allocated objects, because they may be\n+      --  modified outside the current scope.\n+\n+      if Is_Statically_Allocated (E) then\n+         return False;\n+\n+      --  Do not replace aliased or volatile objects, since we don't know what\n+      --  else might change the value.\n+\n+      elsif Is_Aliased (E) or else Treat_As_Volatile (E) then\n+         return False;\n+\n+      --  Debug flag -gnatdM disconnects this optimization\n+\n+      elsif Debug_Flag_MM then\n+         return False;\n+\n+      --  Otherwise check scopes\n+\n+      else\n+\n+         CS := Current_Scope;\n+\n+         loop\n+            --  If we are in right scope, replacement is safe\n+\n+            if CS = ES then\n+               return True;\n+\n+            --  Packages do not affect the determination of safety\n+\n+            elsif Ekind (CS) = E_Package then\n+               CS := Scope (CS);\n+               exit when CS = Standard_Standard;\n+\n+            --  Blocks do not affect the determination of safety\n+\n+            elsif Ekind (CS) = E_Block then\n+               CS := Scope (CS);\n+\n+            --  Otherwise, the reference is dubious, and we cannot be sure that\n+            --  it is safe to do the replacement.\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end if;\n+   end OK_To_Do_Constant_Replacement;\n+\n    -------------------------\n    -- Remove_Side_Effects --\n    -------------------------\n@@ -3783,7 +3925,7 @@ package body Exp_Util is\n       Name_Req     : Boolean := False;\n       Variable_Ref : Boolean := False)\n    is\n-      Loc          : constant Source_Ptr := Sloc (Exp);\n+      Loc          : constant Source_Ptr     := Sloc (Exp);\n       Exp_Type     : constant Entity_Id      := Etype (Exp);\n       Svg_Suppress : constant Suppress_Array := Scope_Suppress;\n       Def_Id       : Entity_Id;\n@@ -3794,31 +3936,30 @@ package body Exp_Util is\n       E            : Node_Id;\n \n       function Side_Effect_Free (N : Node_Id) return Boolean;\n-      --  Determines if the tree N represents an expression that is known\n-      --  not to have side effects, and for which no processing is required.\n+      --  Determines if the tree N represents an expression that is known not\n+      --  to have side effects, and for which no processing is required.\n \n       function Side_Effect_Free (L : List_Id) return Boolean;\n       --  Determines if all elements of the list L are side effect free\n \n       function Safe_Prefixed_Reference (N : Node_Id) return Boolean;\n-      --  The argument N is a construct where the Prefix is dereferenced\n-      --  if it is a an access type and the result is a variable. The call\n-      --  returns True if the construct is side effect free (not considering\n-      --  side effects in other than the prefix which are to be tested by the\n-      --  caller).\n+      --  The argument N is a construct where the Prefix is dereferenced if it\n+      --  is an access type and the result is a variable. The call returns True\n+      --  if the construct is side effect free (not considering side effects in\n+      --  other than the prefix which are to be tested by the caller).\n \n       function Within_In_Parameter (N : Node_Id) return Boolean;\n-      --  Determines if N is a subcomponent of a composite in-parameter.\n-      --  If so, N is not side-effect free when the actual is global and\n-      --  modifiable indirectly from within a subprogram, because it may\n-      --  be passed by reference. The front-end must be conservative here\n-      --  and assume that this may happen with any array or record type.\n-      --  On the other hand, we cannot create temporaries for all expressions\n-      --  for which this condition is true, for various reasons that might\n-      --  require clearing up ??? For example, descriminant references that\n-      --  appear out of place, or spurious type errors with class-wide\n-      --  expressions. As a result, we limit the transformation to loop\n-      --  bounds, which is so far the only case that requires it.\n+      --  Determines if N is a subcomponent of a composite in-parameter. If so,\n+      --  N is not side-effect free when the actual is global and modifiable\n+      --  indirectly from within a subprogram, because it may be passed by\n+      --  reference. The front-end must be conservative here and assume that\n+      --  this may happen with any array or record type. On the other hand, we\n+      --  cannot create temporaries for all expressions for which this\n+      --  condition is true, for various reasons that might require clearing up\n+      --  ??? For example, descriminant references that appear out of place, or\n+      --  spurious type errors with class-wide expressions. As a result, we\n+      --  limit the transformation to loop bounds, which is so far the only\n+      --  case that requires it.\n \n       -----------------------------\n       -- Safe_Prefixed_Reference --\n@@ -3942,6 +4083,7 @@ package body Exp_Util is\n \n             when N_Attribute_Reference =>\n                return Side_Effect_Free (Expressions (N))\n+                 and then Attribute_Name (N) /= Name_Input\n                  and then (Is_Entity_Name (Prefix (N))\n                             or else Side_Effect_Free (Prefix (N)));\n \n@@ -4175,14 +4317,7 @@ package body Exp_Util is\n       --  is a view conversion to a smaller object, where gigi can end up\n       --  creating its own temporary of the wrong size.\n \n-      --  ??? this transformation is inhibited for elementary types that are\n-      --  not involved in a change of representation because it causes\n-      --  regressions that are not fully understood yet.\n-\n-      elsif Nkind (Exp) = N_Type_Conversion\n-        and then (not Is_Elementary_Type (Underlying_Type (Exp_Type))\n-                   or else Nkind (Parent (Exp)) = N_Assignment_Statement)\n-      then\n+      elsif Nkind (Exp) = N_Type_Conversion then\n          Remove_Side_Effects (Expression (Exp), Name_Req, Variable_Ref);\n          Scope_Suppress := Svg_Suppress;\n          return;\n@@ -4193,7 +4328,7 @@ package body Exp_Util is\n       elsif Nkind (Exp) = N_Unchecked_Type_Conversion\n         and then not Safe_Unchecked_Type_Conversion (Exp)\n       then\n-         if Controlled_Type (Etype (Exp)) then\n+         if Controlled_Type (Exp_Type) then\n \n             --  Use a renaming to capture the expression, rather than create\n             --  a controlled temporary.\n@@ -4237,7 +4372,7 @@ package body Exp_Util is\n \n          if Nkind (Exp) = N_Selected_Component\n            and then Nkind (Prefix (Exp)) = N_Function_Call\n-           and then Is_Array_Type (Etype (Exp))\n+           and then Is_Array_Type (Exp_Type)\n          then\n             --  Avoid generating a variable-sized temporary, by generating\n             --  the renaming declaration just for the function call. The\n@@ -4267,11 +4402,22 @@ package body Exp_Util is\n \n          end if;\n \n-         --  The temporary must be elaborated by gigi, and is of course\n-         --  not to be replaced in-line by the expression it renames,\n-         --  which would defeat the purpose of removing the side-effect.\n-\n-         Set_Is_Renaming_Of_Object (Def_Id, False);\n+         --  If this is a packed reference, or a selected component with a\n+         --  non-standard representation, a reference to the temporary will\n+         --  be replaced by a copy of the original expression (see\n+         --  exp_ch2.Expand_Renaming). Otherwise the temporary must be\n+         --  elaborated by gigi, and is of course not to be replaced in-line\n+         --  by the expression it renames, which would defeat the purpose of\n+         --  removing the side-effect.\n+\n+         if (Nkind (Exp) = N_Selected_Component\n+              or else Nkind (Exp) = N_Indexed_Component)\n+           and then Has_Non_Standard_Rep (Etype (Prefix (Exp)))\n+         then\n+            null;\n+         else\n+            Set_Is_Renaming_Of_Object (Def_Id, False);\n+         end if;\n \n       --  Otherwise we generate a reference to the value\n \n@@ -4588,6 +4734,32 @@ package body Exp_Util is\n       end if;\n    end Set_Elaboration_Flag;\n \n+   ----------------------------\n+   -- Set_Renamed_Subprogram --\n+   ----------------------------\n+\n+   procedure Set_Renamed_Subprogram (N : Node_Id; E : Entity_Id) is\n+   begin\n+      --  If input node is an identifier, we can just reset it\n+\n+      if Nkind (N) = N_Identifier then\n+         Set_Chars  (N, Chars (E));\n+         Set_Entity (N, E);\n+\n+         --  Otherwise we have to do a rewrite, preserving Comes_From_Source\n+\n+      else\n+         declare\n+            CS : constant Boolean := Comes_From_Source (N);\n+         begin\n+            Rewrite (N, Make_Identifier (Sloc (N), Chars => Chars (E)));\n+            Set_Entity (N, E);\n+            Set_Comes_From_Source (N, CS);\n+            Set_Analyzed (N, True);\n+         end;\n+      end if;\n+   end Set_Renamed_Subprogram;\n+\n    --------------------------\n    -- Target_Has_Fixed_Ops --\n    --------------------------"}, {"sha": "3a272fa7ec071feaf2d9ef01d726b3b39a1860d3", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59e54267fc4d2eec894f1f4f4f8fc596cee68f3a/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=59e54267fc4d2eec894f1f4f4f8fc596cee68f3a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -464,10 +464,8 @@ package Exp_Util is\n    --  False otherwise. True for an empty list. It is an error to call this\n    --  routine with No_List as the argument.\n \n-   function Is_Predefined_Dispatching_Operation\n-     (Subp : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-251): Determines if Subp is a predefined primitive\n-   --  operation.\n+   function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation.\n \n    function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a reference to a bit packed array, i.e.\n@@ -527,6 +525,12 @@ package Exp_Util is\n    --  be non-null and returns True if so. Returns False otherwise. It is\n    --  an error to call this function if N is not of an access type.\n \n+   function Known_Null (N : Node_Id) return Boolean;\n+   --  Given a node N for a subexpression of an access type, determines if this\n+   --  subexpression yields a value that is known at compile time to be null\n+   --  and returns True if so. Returns False otherwise. It is an error to call\n+   --  this function if N is not of an access type.\n+\n    function Make_Subtype_From_Expr\n      (E       : Node_Id;\n       Unc_Typ : Entity_Id) return Node_Id;\n@@ -544,6 +548,18 @@ package Exp_Util is\n    --  caller has to check whether stack checking is actually enabled in order\n    --  to guide the expansion (typically of a function call).\n \n+   function OK_To_Do_Constant_Replacement (E : Entity_Id) return Boolean;\n+   --  This function is used when testing whether or not to replace a reference\n+   --  to entity E by a known constant value. Such replacement must be done\n+   --  only in a scope known to be safe for such replacements. In particular,\n+   --  if we are within a subprogram and the entity E is declared outside the\n+   --  subprogram then we cannot do the replacement, since we do not attempt to\n+   --  trace subprogram call flow. It is also unsafe to replace statically\n+   --  allocated values (since they can be modified outside the scope), and we\n+   --  also inhibit replacement of Volatile or aliased objects since their\n+   --  address might be captured in a way we do not detect. A value of True is\n+   --  returned only if the replacement is safe.\n+\n    procedure Remove_Side_Effects\n      (Exp          : Node_Id;\n       Name_Req     : Boolean := False;\n@@ -583,6 +599,11 @@ package Exp_Util is\n    --  can detect cases where this is the only elaboration action that is\n    --  required.\n \n+   procedure Set_Renamed_Subprogram (N : Node_Id; E : Entity_Id);\n+   --  N is an node which is an entity name that represents the name of a\n+   --  renamed subprogram. The node is rewritten to be an identifier that\n+   --  refers directly to the renamed subprogram, given by entity E.\n+\n    function Target_Has_Fixed_Ops\n      (Left_Typ   : Entity_Id;\n       Right_Typ  : Entity_Id;"}]}