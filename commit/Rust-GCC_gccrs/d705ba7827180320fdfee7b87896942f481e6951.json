{"sha": "d705ba7827180320fdfee7b87896942f481e6951", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcwNWJhNzgyNzE4MDMyMGZkZmVlN2I4Nzg5Njk0MmY0ODFlNjk1MQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:54:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:54:05Z"}, "message": "exp_ch2.adb: Change Is_Lvalue to May_Be_Lvalue\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch2.adb: Change Is_Lvalue to May_Be_Lvalue\n\t(Expand_Entity_Reference): Correct error of not handling subprogram\n\tformals in current_value processing.\n\nFrom-SVN: r118255", "tree": {"sha": "b47410ea0b42b438ed8b2e9adad8dbdf13a7e102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b47410ea0b42b438ed8b2e9adad8dbdf13a7e102"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d705ba7827180320fdfee7b87896942f481e6951", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d705ba7827180320fdfee7b87896942f481e6951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d705ba7827180320fdfee7b87896942f481e6951", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d705ba7827180320fdfee7b87896942f481e6951/comments", "author": null, "committer": null, "parents": [{"sha": "7ce611e210e5f350cc9791c043478a4170df78d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ce611e210e5f350cc9791c043478a4170df78d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ce611e210e5f350cc9791c043478a4170df78d2"}], "stats": {"total": 57, "additions": 42, "deletions": 15}, "files": [{"sha": "291d172a42ea005edd407da8013cda8d3133f8a3", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d705ba7827180320fdfee7b87896942f481e6951/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d705ba7827180320fdfee7b87896942f481e6951/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=d705ba7827180320fdfee7b87896942f481e6951", "patch": "@@ -77,6 +77,7 @@ package body Exp_Ch2 is\n \n    procedure Expand_Entity_Reference (N : Node_Id);\n    --  Common processing for expansion of identifiers and expanded names\n+   --  Dispatches to specific expansion procedures.\n \n    procedure Expand_Entry_Index_Parameter (N : Node_Id);\n    --  A reference to the identifier in the entry index specification of\n@@ -93,19 +94,20 @@ package body Exp_Ch2 is\n \n    procedure Expand_Formal (N : Node_Id);\n    --  A reference to a formal parameter of a protected subprogram is expanded\n-   --  to the corresponding formal of the unprotected procedure used to\n-   --  represent the protected subprogram within the protected object.\n+   --  into the corresponding formal of the unprotected procedure used to\n+   --  represent the operation within the protected object. In other cases\n+   --  Expand_Formal is a noop.\n \n    procedure Expand_Protected_Private (N : Node_Id);\n-   --  A reference to a private object of a protected type is expanded to a\n+   --  A reference to a private component of a protected type is expanded to a\n    --  component selected from the record used to implement the protected\n    --  object. Such a record is passed to all operations on a protected object\n-   --  in a parameter named _object. Such an object is a constant within a\n-   --  function, and a variable otherwise.\n+   --  in a parameter named _object. This object is a constant in the body of a\n+   --  function, and a variable within a procedure or entry body.\n \n    procedure Expand_Renaming (N : Node_Id);\n    --  For renamings, just replace the identifier by the corresponding\n-   --  name expression. Note that this has been evaluated (see routine\n+   --  named expression. Note that this has been evaluated (see routine\n    --  Exp_Ch8.Expand_N_Object_Renaming.Evaluate_Name) so this gives\n    --  the correct renaming semantics.\n \n@@ -141,7 +143,7 @@ package body Exp_Ch2 is\n \n          --  Do not replace lvalues\n \n-         and then not Is_Lvalue (N)\n+         and then not May_Be_Lvalue (N)\n \n          --  Check that entity is suitable for replacement\n \n@@ -348,12 +350,15 @@ package body Exp_Ch2 is\n         and then Is_Shared_Passive (E)\n       then\n          Expand_Shared_Passive_Variable (N);\n+      end if;\n \n-      elsif (Ekind (E) = E_Variable\n-               or else\n-             Ekind (E) = E_In_Out_Parameter\n-               or else\n-             Ekind (E) = E_Out_Parameter)\n+      --  Interpret possible Current_Value for variable case\n+\n+      if (Ekind (E) = E_Variable\n+            or else\n+          Ekind (E) = E_In_Out_Parameter\n+            or else\n+          Ekind (E) = E_Out_Parameter)\n         and then Present (Current_Value (E))\n       then\n          Expand_Current_Value (N);\n@@ -364,6 +369,24 @@ package body Exp_Ch2 is\n          if Is_Boolean_Type (Etype (N)) then\n             Warn_On_Known_Condition (N);\n          end if;\n+\n+      --  Don't mess with Current_Value for compile time known values. Not\n+      --  only is it unnecessary, but we could disturb an indication of a\n+      --  static value, which could cause semantic trouble.\n+\n+      elsif Compile_Time_Known_Value (N) then\n+         null;\n+\n+      --  Interpret possible Current_Value for constant case\n+\n+      elsif (Ekind (E) = E_Constant\n+               or else\n+             Ekind (E) = E_In_Parameter\n+               or else\n+             Ekind (E) = E_Loop_Parameter)\n+        and then Present (Current_Value (E))\n+      then\n+         Expand_Current_Value (N);\n       end if;\n    end Expand_Entity_Reference;\n \n@@ -477,11 +500,15 @@ package body Exp_Ch2 is\n \n    procedure Expand_Formal (N : Node_Id) is\n       E    : constant Entity_Id  := Entity (N);\n-      Subp : constant Entity_Id  := Scope (E);\n+      Scop : constant Entity_Id  := Scope (E);\n \n    begin\n-      if Is_Protected_Type (Scope (Subp))\n-        and then not Is_Init_Proc (Subp)\n+      --  Check whether the subprogram of which this is a formal is\n+      --  a protected operation. The initialization procedure for\n+      --  the corresponding record type is not itself a protected operation.\n+\n+      if Is_Protected_Type (Scope (Scop))\n+        and then not Is_Init_Proc (Scop)\n         and then Present (Protected_Formal (E))\n       then\n          Set_Entity (N, Protected_Formal (E));"}]}