{"sha": "c2a49ce6276acab7961cc99b9692f77181721ecd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJhNDljZTYyNzZhY2FiNzk2MWNjOTliOTY5MmY3NzE4MTcyMWVjZA==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-06-06T10:49:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:49:20Z"}, "message": "a-dirval-vms.adb, [...] (Windows): New Boolean function.\n\n2007-04-20  Vincent Celier  <celier@adacore.com>\n\n\t* a-dirval-vms.adb, a-dirval.ads, a-dirval.adb (Windows): New Boolean\n\tfunction.\n\n\t* a-dirval-mingw.adb (Is_Valid_Path_Name): Forbid a path with a drive\n\tletter if it is not followed by a '/' or a '\\'.\n\t(Windows): New Boolean function\n\n\t* a-direct.ads, a-direct.adb: Remove unnecessary and misplaced pragma\n\tAda 2005.\n\t(Containing_Directory): On Windows, keep at least one '/' or '\\' after a\n\tdrive letter.\n\t(Containing_Directory): Raise Use_Error when the directory is a root\n\tdirectory.\n\t(Extension): When returning the result, use a conversion to Result_Type,\n\tnot a qualification.\n\nFrom-SVN: r125468", "tree": {"sha": "4e4642e3fdd77b04204a596480780a81c06decec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e4642e3fdd77b04204a596480780a81c06decec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2a49ce6276acab7961cc99b9692f77181721ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a49ce6276acab7961cc99b9692f77181721ecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a49ce6276acab7961cc99b9692f77181721ecd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a49ce6276acab7961cc99b9692f77181721ecd/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb65368d57a94a8b9b2e4a5c098cf3777f4d8dad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb65368d57a94a8b9b2e4a5c098cf3777f4d8dad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb65368d57a94a8b9b2e4a5c098cf3777f4d8dad"}], "stats": {"total": 480, "additions": 373, "deletions": 107}, "files": [{"sha": "1d7ea552be269e0d6e7fd9c21389b8fd19d1ecfe", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 326, "deletions": 97, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=c2a49ce6276acab7961cc99b9692f77181721ecd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,25 +34,48 @@\n with Ada.Calendar;               use Ada.Calendar;\n with Ada.Calendar.Formatting;    use Ada.Calendar.Formatting;\n with Ada.Directories.Validity;   use Ada.Directories.Validity;\n+with Ada.Strings.Maps;\n+with Ada.Strings.Fixed;\n with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;\n+with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n \n-with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n-with GNAT.OS_Lib;                use GNAT.OS_Lib;\n-with GNAT.Regexp;                use GNAT.Regexp;\n---  ??? Ada units should not depend on GNAT units\n+with System.CRTL;                use System.CRTL;\n+with System.OS_Lib;              use System.OS_Lib;\n+with System.Regexp;              use System.Regexp;\n \n with System;\n \n package body Ada.Directories is\n \n+   Filename_Max : constant Integer := 1024;\n+   --  1024 is the value of FILENAME_MAX in stdio.h\n+\n+   type Dir_Type_Value is new System.Address;\n+   --  This is the low-level address directory structure as returned by the C\n+   --  opendir routine.\n+\n+   No_Dir : constant Dir_Type_Value := Dir_Type_Value (System.Null_Address);\n+\n+   Dir_Separator : constant Character;\n+   pragma Import (C, Dir_Separator, \"__gnat_dir_separator\");\n+   --  Running system default directory separator\n+\n+   Dir_Seps : constant Ada.Strings.Maps.Character_Set :=\n+                Ada.Strings.Maps.To_Set (\"/\\\");\n+   --  UNIX and DOS style directory separators\n+\n+   Max_Path : Integer;\n+   pragma Import (C, Max_Path, \"__gnat_max_path_len\");\n+   --  The maximum length of a path\n+\n    type Search_Data is record\n       Is_Valid      : Boolean := False;\n       Name          : Ada.Strings.Unbounded.Unbounded_String;\n       Pattern       : Regexp;\n       Filter        : Filter_Type;\n-      Dir           : Dir_Type;\n+      Dir           : Dir_Type_Value := No_Dir;\n       Entry_Fetched : Boolean := False;\n       Dir_Entry     : Directory_Entry_Type;\n    end record;\n@@ -63,6 +86,8 @@ package body Ada.Directories is\n \n    procedure Free is new Ada.Unchecked_Deallocation (Search_Data, Search_Ptr);\n \n+   procedure Close (Dir : Dir_Type_Value);\n+\n    function File_Exists (Name : String) return Boolean;\n    --  Returns True if the named file exists\n \n@@ -99,6 +124,21 @@ package body Ada.Directories is\n       return Simple;\n    end Base_Name;\n \n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (Dir : Dir_Type_Value) is\n+      Discard : Integer;\n+      pragma Warnings (Off, Discard);\n+\n+      function closedir (directory : DIRs) return Integer;\n+      pragma Import (C, closedir, \"__gnat_closedir\");\n+\n+   begin\n+      Discard := closedir (DIRs (Dir));\n+   end Close;\n+\n    -------------\n    -- Compose --\n    -------------\n@@ -123,12 +163,12 @@ package body Ada.Directories is\n       then\n          raise Name_Error;\n \n-      elsif Extension'Length /= 0 and then\n-        (not Is_Valid_Simple_Name (Name & '.' & Extension))\n+      elsif Extension'Length /= 0\n+        and then not Is_Valid_Simple_Name (Name & '.' & Extension)\n       then\n          raise Name_Error;\n \n-         --  This is not an invalid case so build the path name\n+      --  This is not an invalid case so build the path name\n \n       else\n          Last := Containing_Directory'Length;\n@@ -172,31 +212,81 @@ package body Ada.Directories is\n          raise Name_Error;\n \n       else\n-         --  Get the directory name using GNAT.Directory_Operations.Dir_Name\n-\n          declare\n-            Value : constant String := Dir_Name (Path => Name);\n-            Result : String (1 .. Value'Length);\n-            Last : Natural := Result'Last;\n+            Norm    : constant String := Normalize_Pathname (Name);\n+            Last_DS : constant Natural :=\n+                        Strings.Fixed.Index\n+                          (Name, Dir_Seps, Going => Strings.Backward);\n \n          begin\n-            Result := Value;\n+            if Last_DS = 0 then\n+\n+               --  There is no directory separator, returns current working\n+               --  directory.\n+\n+               return Current_Directory;\n+\n+            --  If Name indicates a root directory, raise Use_Error, because\n+            --  it has no containing directory.\n+\n+            elsif Norm = \"/\"\n+              or else\n+                (Windows\n+                 and then\n+                   (Norm = \"\\\"\n+                    or else\n+                      (Norm'Length = 3\n+                        and then Norm (Norm'Last - 1 .. Norm'Last) = \":\\\"\n+                        and then (Norm (Norm'First) in 'a' .. 'z'\n+                                   or else Norm (Norm'First) in 'A' .. 'Z'))))\n+            then\n+               raise Use_Error;\n+\n+            else\n+               declare\n+                  Last   : Positive := Last_DS - Name'First + 1;\n+                  Result : String (1 .. Last);\n \n-            --  Remove any trailing directory separator, except as the first\n-            --  character.\n+               begin\n+                  Result := Name (Name'First .. Last_DS);\n \n-            while Last > 1 and then Result (Last) = Dir_Separator loop\n-               Last := Last - 1;\n-            end loop;\n+                  --  Remove any trailing directory separator, except as the\n+                  --  first character or the first character following a drive\n+                  --  number on Windows.\n \n-            --  Special case of current directory, identified by \".\"\n+                  while Last > 1 loop\n+                     exit when\n+                       Result (Last) /= '/'\n+                         and then\n+                       Result (Last) /= Directory_Separator;\n \n-            if Last = 1 and then Result (1) = '.' then\n-               return Get_Current_Dir;\n+                     exit when Windows\n+                       and then Last = 3\n+                       and then Result (2) = ':'\n+                       and then\n+                         (Result (1) in 'A' .. 'Z'\n+                           or else\n+                          Result (1) in 'a' .. 'z');\n \n-            else\n-               To_Lower_If_Case_Insensitive (Result (1 .. Last));\n-               return Result (1 .. Last);\n+                     Last := Last - 1;\n+                  end loop;\n+\n+                  --  Special case of current directory, identified by \".\"\n+\n+                  if Last = 1 and then Result (1) = '.' then\n+                     return Current_Directory;\n+\n+                  --  Special case of \"..\": the current directory may be a root\n+                  --  directory.\n+\n+                  elsif Last = 2 and then Result (1 .. 2) = \"..\" then\n+                     return Containing_Directory (Current_Directory);\n+\n+                  else\n+                     To_Lower_If_Case_Insensitive (Result (1 .. Last));\n+                     return Result (1 .. Last);\n+                  end if;\n+               end;\n             end if;\n          end;\n       end if;\n@@ -207,9 +297,9 @@ package body Ada.Directories is\n    ---------------\n \n    procedure Copy_File\n-     (Source_Name   : String;\n-      Target_Name   : String;\n-      Form          : String := \"\")\n+     (Source_Name : String;\n+      Target_Name : String;\n+      Form        : String := \"\")\n    is\n       pragma Unreferenced (Form);\n       Success : Boolean;\n@@ -227,11 +317,10 @@ package body Ada.Directories is\n          raise Use_Error;\n \n       else\n-         --  The implementation uses GNAT.OS_Lib.Copy_File, with parameters\n+         --  The implementation uses System.OS_Lib.Copy_File, with parameters\n          --  suitable for all platforms.\n \n-         Copy_File\n-           (Source_Name, Target_Name, Success, Overwrite, None);\n+         Copy_File (Source_Name, Target_Name, Success, Overwrite, None);\n \n          if not Success then\n             raise Use_Error;\n@@ -249,22 +338,21 @@ package body Ada.Directories is\n    is\n       pragma Unreferenced (Form);\n \n+      C_Dir_Name : constant String := New_Directory & ASCII.NUL;\n+\n+      function mkdir (Dir_Name : String) return Integer;\n+      pragma Import (C, mkdir, \"__gnat_mkdir\");\n+\n    begin\n       --  First, the invalid case\n \n       if not Is_Valid_Path_Name (New_Directory) then\n          raise Name_Error;\n \n       else\n-         --  The implementation uses GNAT.Directory_Operations.Make_Dir\n-\n-         begin\n-            Make_Dir (Dir_Name => New_Directory);\n-\n-         exception\n-            when Directory_Error =>\n-               raise Use_Error;\n-         end;\n+         if mkdir (C_Dir_Name) /= 0 then\n+            raise Use_Error;\n+         end if;\n       end if;\n    end Create_Directory;\n \n@@ -319,16 +407,7 @@ package body Ada.Directories is\n                   raise Use_Error;\n \n                else\n-                  --  The implementation uses\n-                  --  GNAT.Directory_Operations.Make_Dir.\n-\n-                  begin\n-                     Make_Dir (Dir_Name => New_Dir (1 .. Last));\n-\n-                  exception\n-                     when Directory_Error =>\n-                        raise Use_Error;\n-                  end;\n+                  Create_Directory (New_Directory => New_Dir (1 .. Last));\n                end if;\n             end if;\n          end loop;\n@@ -340,19 +419,29 @@ package body Ada.Directories is\n    -----------------------\n \n    function Current_Directory return String is\n+      Path_Len : Natural := Max_Path;\n+      Buffer   : String (1 .. 1 + Max_Path + 1);\n \n-      --  The implementation uses GNAT.Directory_Operations.Get_Current_Dir\n-\n-      Cur : String := Normalize_Pathname (Get_Current_Dir);\n+      procedure Local_Get_Current_Dir\n+        (Dir    : System.Address;\n+         Length : System.Address);\n+      pragma Import (C, Local_Get_Current_Dir, \"__gnat_get_current_dir\");\n \n    begin\n-      To_Lower_If_Case_Insensitive (Cur);\n+      Local_Get_Current_Dir (Buffer'Address, Path_Len'Address);\n \n-      if Cur'Length > 1 and then Cur (Cur'Last) = Dir_Separator then\n-         return Cur (1 .. Cur'Last - 1);\n-      else\n-         return Cur;\n-      end if;\n+      declare\n+         Cur : String := Normalize_Pathname (Buffer (1 .. Path_Len));\n+\n+      begin\n+         To_Lower_If_Case_Insensitive (Cur);\n+\n+         if Cur'Length > 1 and then Cur (Cur'Last) = Dir_Separator then\n+            return Cur (1 .. Cur'Last - 1);\n+         else\n+            return Cur;\n+         end if;\n+      end;\n    end Current_Directory;\n \n    ----------------------\n@@ -370,14 +459,14 @@ package body Ada.Directories is\n          raise Name_Error;\n \n       else\n-         --  The implementation uses GNAT.Directory_Operations.Remove_Dir\n-\n+         declare\n+            C_Dir_Name : constant String := Directory & ASCII.NUL;\n          begin\n-            Remove_Dir (Dir_Name => Directory, Recursive => False);\n+            rmdir (C_Dir_Name);\n \n-         exception\n-            when Directory_Error =>\n+            if System.OS_Lib.Is_Directory (Directory) then\n                raise Use_Error;\n+            end if;\n          end;\n       end if;\n    end Delete_Directory;\n@@ -399,7 +488,7 @@ package body Ada.Directories is\n          raise Name_Error;\n \n       else\n-         --  The implementation uses GNAT.OS_Lib.Delete_File\n+         --  The implementation uses System.OS_Lib.Delete_File\n \n          Delete_File (Name, Success);\n \n@@ -414,6 +503,9 @@ package body Ada.Directories is\n    -----------------\n \n    procedure Delete_Tree (Directory : String) is\n+      Current_Dir : constant String := Current_Directory;\n+      Search      : Search_Type;\n+      Dir_Ent     : Directory_Entry_Type;\n    begin\n       --  First, the invalid cases\n \n@@ -424,14 +516,39 @@ package body Ada.Directories is\n          raise Name_Error;\n \n       else\n-         --  The implementation uses GNAT.Directory_Operations.Remove_Dir\n+         Set_Directory (Directory);\n+         Start_Search (Search, Directory => \".\", Pattern => \"\");\n+\n+         while More_Entries (Search) loop\n+            Get_Next_Entry (Search, Dir_Ent);\n+\n+            declare\n+               File_Name : constant String := Simple_Name (Dir_Ent);\n+\n+            begin\n+               if System.OS_Lib.Is_Directory (File_Name) then\n+                  if File_Name /= \".\" and then File_Name /= \"..\" then\n+                     Delete_Tree (File_Name);\n+                  end if;\n+\n+               else\n+                  Delete_File (File_Name);\n+               end if;\n+            end;\n+         end loop;\n+\n+         Set_Directory (Current_Dir);\n+         End_Search (Search);\n+\n+         declare\n+            C_Dir_Name : constant String := Directory & ASCII.NUL;\n \n          begin\n-            Remove_Dir (Directory, Recursive => True);\n+            rmdir (C_Dir_Name);\n \n-         exception\n-            when Directory_Error =>\n+            if System.OS_Lib.Is_Directory (Directory) then\n                raise Use_Error;\n+            end if;\n          end;\n       end if;\n    end Delete_Tree;\n@@ -470,8 +587,8 @@ package body Ada.Directories is\n \n          for Pos in reverse Name'Range loop\n \n-            --  If a directory separator is found before a dot, there\n-            --  is no extension.\n+            --  If a directory separator is found before a dot, there is no\n+            --  extension.\n \n             if Name (Pos) = Dir_Separator then\n                return Empty_String;\n@@ -481,12 +598,9 @@ package body Ada.Directories is\n                --  We found a dot, build the return value with lower bound 1\n \n                declare\n-                  Result : String (1 .. Name'Last - Pos);\n+                  subtype Result_Type is String (1 .. Name'Last - Pos);\n                begin\n-                  Result := Name (Pos + 1 .. Name'Last);\n-                  return Result;\n-                  --  This should be done with a subtype conversion, avoiding\n-                  --  the unnecessary junk copy ???\n+                  return Result_Type (Name (Pos + 1 .. Name'Last));\n                end;\n             end if;\n          end loop;\n@@ -508,19 +622,55 @@ package body Ada.Directories is\n       Kind : File_Kind := Ordinary_File;\n       --  Initialized to avoid a compilation warning\n \n+      Filename_Addr : System.Address;\n+      Filename_Len  : aliased Integer;\n+\n+      Buffer : array (0 .. Filename_Max + 12) of Character;\n+      --  12 is the size of the dirent structure (see dirent.h), without the\n+      --  field for the filename.\n+\n+      function readdir_gnat\n+        (Directory : System.Address;\n+         Buffer    : System.Address;\n+         Last      : not null access Integer) return System.Address;\n+      pragma Import (C, readdir_gnat, \"__gnat_readdir\");\n+\n+      use System;\n+\n    begin\n       --  Search.Value.Is_Valid is always True when Fetch_Next_Entry is called\n \n       loop\n-         Read (Search.Value.Dir, Name, Last);\n+         Filename_Addr :=\n+           readdir_gnat\n+             (System.Address (Search.Value.Dir),\n+              Buffer'Address,\n+              Filename_Len'Access);\n \n          --  If no matching entry is found, set Is_Valid to False\n \n-         if Last = 0 then\n+         if Filename_Addr = System.Null_Address then\n             Search.Value.Is_Valid := False;\n             exit;\n          end if;\n \n+         declare\n+            subtype Path_String is String (1 .. Filename_Len);\n+            type    Path_String_Access is access Path_String;\n+\n+            function Address_To_Access is new\n+              Ada.Unchecked_Conversion\n+                (Source => Address,\n+                 Target => Path_String_Access);\n+\n+            Path_Access : constant Path_String_Access :=\n+                            Address_To_Access (Filename_Addr);\n+\n+         begin\n+            Last := Filename_Len;\n+            Name (1 .. Last) := Path_Access.all;\n+         end;\n+\n          --  Check if the entry matches the pattern\n \n          if Match (Name (1 .. Last), Search.Value.Pattern) then\n@@ -596,7 +746,7 @@ package body Ada.Directories is\n \n          --  Close the directory, if one is open\n \n-         if Is_Open (Search.Value.Dir) then\n+         if Search.Value.Dir /= No_Dir then\n             Close (Search.Value.Dir);\n          end if;\n \n@@ -618,7 +768,7 @@ package body Ada.Directories is\n       else\n          --  Build the return value with lower bound 1\n \n-         --  Use GNAT.OS_Lib.Normalize_Pathname\n+         --  Use System.OS_Lib.Normalize_Pathname\n \n          declare\n             Value : String := Normalize_Pathname (Name);\n@@ -823,7 +973,7 @@ package body Ada.Directories is\n          raise Use_Error;\n \n       else\n-         --  The implementation uses GNAT.OS_Lib.Rename_File\n+         --  The implementation uses System.OS_Lib.Rename_File\n \n          Rename_File (Old_Name, New_Name, Success);\n \n@@ -844,8 +994,9 @@ package body Ada.Directories is\n       Process   : not null access procedure\n                                     (Directory_Entry : Directory_Entry_Type))\n    is\n-      Srch : Search_Type;\n+      Srch            : Search_Type;\n       Directory_Entry : Directory_Entry_Type;\n+\n    begin\n       Start_Search (Srch, Directory, Pattern, Filter);\n \n@@ -862,21 +1013,86 @@ package body Ada.Directories is\n    -------------------\n \n    procedure Set_Directory (Directory : String) is\n-   begin\n-      --  The implementation uses GNAT.Directory_Operations.Change_Dir\n+      C_Dir_Name : constant String := Directory & ASCII.NUL;\n \n-      Change_Dir (Dir_Name => Directory);\n+      function chdir (Dir_Name : String) return Integer;\n+      pragma Import (C, chdir, \"chdir\");\n \n-   exception\n-      when Directory_Error =>\n+   begin\n+      if chdir (C_Dir_Name) /= 0 then\n          raise Name_Error;\n+      end if;\n    end Set_Directory;\n \n    -----------------\n    -- Simple_Name --\n    -----------------\n \n    function Simple_Name (Name : String) return String is\n+\n+      function Simple_Name_CI (Path : String) return String;\n+      --  This function does the job. The difference between Simple_Name_CI\n+      --  and Simple_Name (the parent function) is that the former is case\n+      --  sensitive, while the latter is not. Path and Suffix are adjusted\n+      --  appropriately before calling Simple_Name_CI under platforms where\n+      --  the file system is not case sensitive.\n+\n+      --------------------\n+      -- Simple_Name_CI --\n+      --------------------\n+\n+      function Simple_Name_CI (Path : String) return String is\n+         Cut_Start : Natural :=\n+                       Strings.Fixed.Index\n+                         (Path, Dir_Seps, Going => Strings.Backward);\n+         Cut_End   : Natural;\n+\n+      begin\n+         --  Cut_Start point to the first simple name character\n+\n+         if Cut_Start = 0 then\n+            Cut_Start := Path'First;\n+\n+         else\n+            Cut_Start := Cut_Start + 1;\n+         end if;\n+\n+         --  Cut_End point to the last simple name character\n+\n+         Cut_End := Path'Last;\n+\n+         Check_For_Standard_Dirs : declare\n+            Offset : constant Integer := Path'First - Name'First;\n+            BN     : constant String  :=\n+                       Name (Cut_Start - Offset .. Cut_End - Offset);\n+            --  Here we use Simple_Name.Name to keep the original casing\n+\n+            Has_Drive_Letter : constant Boolean :=\n+                                 System.OS_Lib.Path_Separator /= ':';\n+            --  If Path separator is not ':' then we are on a DOS based OS\n+            --  where this character is used as a drive letter separator.\n+\n+         begin\n+            if BN = \".\" or else BN = \"..\" then\n+               return \"\";\n+\n+            elsif Has_Drive_Letter\n+              and then BN'Length > 2\n+              and then Characters.Handling.Is_Letter (BN (BN'First))\n+              and then BN (BN'First + 1) = ':'\n+            then\n+               --  We have a DOS drive letter prefix, remove it\n+\n+               return BN (BN'First + 2 .. BN'Last);\n+\n+            else\n+               return BN;\n+            end if;\n+         end Check_For_Standard_Dirs;\n+      end Simple_Name_CI;\n+\n+   --  Start of processing for Simple_Name\n+\n    begin\n       --  First, the invalid case\n \n@@ -886,15 +1102,23 @@ package body Ada.Directories is\n       else\n          --  Build the value to return with lower bound 1\n \n-         --  The implementation uses GNAT.Directory_Operations.Base_Name\n+         if Is_Path_Name_Case_Sensitive then\n+            declare\n+               Value : constant String := Simple_Name_CI (Name);\n+               subtype Result is String (1 .. Value'Length);\n+            begin\n+               return Result (Value);\n+            end;\n \n-         declare\n-            Value  : String := GNAT.Directory_Operations.Base_Name (Name);\n-            subtype Result is String (1 .. Value'Length);\n-         begin\n-            To_Lower_If_Case_Insensitive (Value);\n-            return Result (Value);\n-         end;\n+         else\n+            declare\n+               Value : constant String :=\n+                         Simple_Name_CI (Characters.Handling.To_Lower (Name));\n+               subtype Result is String (1 .. Value'Length);\n+            begin\n+               return Result (Value);\n+            end;\n+         end if;\n       end if;\n    end Simple_Name;\n \n@@ -961,6 +1185,11 @@ package body Ada.Directories is\n       Pattern   : String;\n       Filter    : Filter_Type := (others => True))\n    is\n+      function opendir (file_name : String) return DIRs;\n+      pragma Import (C, opendir, \"__gnat_opendir\");\n+\n+      C_File_Name : constant String := Directory & ASCII.NUL;\n+\n    begin\n       --  First, the invalid case\n \n@@ -991,7 +1220,7 @@ package body Ada.Directories is\n \n       Search.Value.Filter := Filter;\n       Search.Value.Name := To_Unbounded_String (Full_Name (Directory));\n-      Open (Search.Value.Dir, Directory);\n+      Search.Value.Dir := Dir_Type_Value (opendir (C_File_Name));\n       Search.Value.Is_Valid := True;\n    end Start_Search;\n "}, {"sha": "8b918f638b8a6f5fd9f18fbf6ff84327720a4257", "filename": "gcc/ada/a-direct.ads", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-direct.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-direct.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.ads?ref=c2a49ce6276acab7961cc99b9692f77181721ecd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived for use with GNAT from AI-00248,  which is --\n -- expected to be a part of a future expected revised Ada Reference Manual. --\n@@ -77,9 +77,6 @@ with Ada.Strings.Unbounded;\n \n package Ada.Directories is\n \n-   pragma Ada_05;\n-   --  To be removed later ???\n-\n    -----------------------------------\n    -- Directory and File Operations --\n    -----------------------------------\n@@ -322,7 +319,7 @@ package Ada.Directories is\n    --  End_Search, the object Search will have no entries available. Note\n    --  that is is not necessary to call End_Search if the call to Start_Search\n    --  was unsuccessful and raised an exception (but it is harmless to make\n-   --  the call in this case)>\n+   --  the call in this case).\n \n    function More_Entries (Search : Search_Type) return Boolean;\n    --  Returns True if more entries are available to be returned by a call"}, {"sha": "8db8b6ad016491bc53e173f3ca67b12c28a5c71f", "filename": "gcc/ada/a-dirval-mingw.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval-mingw.adb?ref=c2a49ce6276acab7961cc99b9692f77181721ecd", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                            (Windows Version)                             --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -80,6 +80,16 @@ package body Ada.Directories.Validity is\n              Name (Start) in 'a' .. 'z')\n          then\n             Start := Start + 2;\n+\n+            --  A drive letter followed by a colon and followed by nothing or\n+            --  by a relative path is an ambiguous path name on Windows, so we\n+            --  don't accept it.\n+\n+            if Start > Name'Last\n+              or else (Name (Start) /= '/' and then Name (Start) /= '\\')\n+            then\n+               return False;\n+            end if;\n          end if;\n \n          loop\n@@ -162,4 +172,13 @@ package body Ada.Directories.Validity is\n       return False;\n    end OpenVMS;\n \n+   -------------\n+   -- Windows --\n+   -------------\n+\n+   function Windows return Boolean is\n+   begin\n+      return True;\n+   end Windows;\n+\n end Ada.Directories.Validity;"}, {"sha": "a9321f28b3b3f0f5601e48b22edb1c113d0299b1", "filename": "gcc/ada/a-dirval-vms.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval-vms.adb?ref=c2a49ce6276acab7961cc99b9692f77181721ecd", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                              (VMS Version)                               --\n --                                                                          --\n---          Copyright (C) 2004-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -98,7 +98,7 @@ package body Ada.Directories.Validity is\n                end if;\n             end loop;\n \n-            --  If name include a dot, it can only be \".\", \"..\" or a the last\n+            --  If name include a dot, it can only be \".\", \"..\" or the last\n             --  file name.\n \n             if Dot_Found then\n@@ -190,4 +190,13 @@ package body Ada.Directories.Validity is\n       return True;\n    end OpenVMS;\n \n+   -------------\n+   -- Windows --\n+   -------------\n+\n+   function Windows return Boolean is\n+   begin\n+      return False;\n+   end Windows;\n+\n end Ada.Directories.Validity;"}, {"sha": "b458264508280832d80dd7c7fd35e90f0e42d699", "filename": "gcc/ada/a-dirval.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval.adb?ref=c2a49ce6276acab7961cc99b9692f77181721ecd", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                             (POSIX Version)                              --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -103,4 +103,13 @@ package body Ada.Directories.Validity is\n       return False;\n    end OpenVMS;\n \n+   -------------\n+   -- Windows --\n+   -------------\n+\n+   function Windows return Boolean is\n+   begin\n+      return False;\n+   end Windows;\n+\n end Ada.Directories.Validity;"}, {"sha": "1fec3f2d3ef01322736b934659168fe3109cd9c2", "filename": "gcc/ada/a-dirval.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2a49ce6276acab7961cc99b9692f77181721ecd/gcc%2Fada%2Fa-dirval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval.ads?ref=c2a49ce6276acab7961cc99b9692f77181721ecd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -48,4 +48,7 @@ private package Ada.Directories.Validity is\n    function OpenVMS return Boolean;\n    --  Return True when OS is OpenVMS\n \n+   function Windows return Boolean;\n+   --  Return True when OS is Windows\n+\n end Ada.Directories.Validity;"}]}