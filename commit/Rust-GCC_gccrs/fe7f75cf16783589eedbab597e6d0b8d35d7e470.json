{"sha": "fe7f75cf16783589eedbab597e6d0b8d35d7e470", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU3Zjc1Y2YxNjc4MzU4OWVlZGJhYjU5N2U2ZDBiOGQzNWQ3ZTQ3MA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-12-14T20:30:00Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-12-14T20:30:00Z"}, "message": "Correct/improve maybe_emit_free_warning (PR middle-end/98166, PR c++/57111, PR middle-end/98160).\n\nResolves:\nPR middle-end/98166 - bogus -Wmismatched-dealloc on user-defined allocator and inlining\nPR c++/57111 - 57111 - Generalize -Wfree-nonheap-object to delete\nPR middle-end/98160 - ICE in default_tree_printer at gcc/tree-diagnostic.c:270\n\ngcc/ChangeLog:\n\n\tPR middle-end/98166\n\tPR c++/57111\n\tPR middle-end/98160\n\t* builtins.c (check_access): Call tree_inlined_location\n\tfndecl_alloc_p): Handle BUILT_IN_ALIGNED_ALLOC and\n\tBUILT_IN_GOMP_ALLOC.\n\tcall_dealloc_p): Remove unused function.\n\t(new_delete_mismatch_p): Call valid_new_delete_pair_p and rework.\n\t(matching_alloc_calls_p): Handle built-in deallocation functions.\n\t(warn_dealloc_offset): Corrct the handling of user-defined operators\n\tdelete.\n\t(maybe_emit_free_warning): Avoid assuming expression is a decl.\n\tSimplify.\n\t* doc/extend.texi (attribute malloc): Update.\n\t* tree-ssa-dce.c (valid_new_delete_pair_p): Factor code out into\n\tvalid_new_delete_pair_p in tree.c.\n\t* tree.c (tree_inlined_location): Define new function.\n\t(valid_new_delete_pair_p): Define.\n\t* tree.h (tree_inlined_location): Declare.\n\t(valid_new_delete_pair_p): Declare.\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/98166\n\tPR c++/57111\n\tPR middle-end/98160\n\t* c-attribs.c (maybe_add_noinline): New function.\n\t(handle_malloc_attribute): Call it.  Use ATTR_FLAG_INTERNAL.\n\tImplicitly add attribute noinline to functions not declared inline\n\tand warn on those.\n\nlibstdc++-v3/ChangeLog:\n\t* testsuite/ext/vstring/requirements/exception/basic.cc: Suppress\n\ta false positive warning.\n\t* testsuite/ext/vstring/requirements/exception/propagation_consistent.cc:\n\t  Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/98166\n\tPR c++/57111\n\tPR middle-end/98160\n\t* g++.dg/warn/Wmismatched-dealloc-2.C: Adjust test of expected warning.\n\t* g++.dg/warn/Wmismatched-new-delete.C: Same.\n\t* gcc.dg/Wmismatched-dealloc.c: Same.\n\t* c-c++-common/Wfree-nonheap-object-2.c: New test.\n\t* c-c++-common/Wfree-nonheap-object-3.c: New test.\n\t* c-c++-common/Wfree-nonheap-object.c: New test.\n\t* c-c++-common/Wmismatched-dealloc.c: New test.\n\t* g++.dg/warn/Wfree-nonheap-object-3.C: New test.\n\t* g++.dg/warn/Wfree-nonheap-object-4.C: New test.\n\t* g++.dg/warn/Wmismatched-dealloc-2.C: New test.\n\t* g++.dg/warn/Wmismatched-new-delete-2.C: New test.\n\t* g++.dg/warn/Wmismatched-new-delete.C: New test.\n\t* gcc.dg/Wmismatched-dealloc-2.c: New test.\n\t* gcc.dg/Wmismatched-dealloc-3.c: New test.\n\t* gcc.dg/Wmismatched-dealloc.c: New test.", "tree": {"sha": "7fec98daa8cd2d99d08d302f753fb7416f3e901c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fec98daa8cd2d99d08d302f753fb7416f3e901c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe7f75cf16783589eedbab597e6d0b8d35d7e470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe7f75cf16783589eedbab597e6d0b8d35d7e470", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe7f75cf16783589eedbab597e6d0b8d35d7e470", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe7f75cf16783589eedbab597e6d0b8d35d7e470/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e63ae8c083a3218400206b80d4eedd9950fc5d3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63ae8c083a3218400206b80d4eedd9950fc5d3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63ae8c083a3218400206b80d4eedd9950fc5d3f"}], "stats": {"total": 1907, "additions": 1657, "deletions": 250}, "files": [{"sha": "28e44445ab2a3057561d583691a14a2343878913", "filename": "gcc/builtins.c", "status": "modified", "additions": 315, "deletions": 73, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -4738,9 +4738,7 @@ check_access (tree exp, tree dstwrite,\n       && TREE_CODE (range[0]) == INTEGER_CST\n       && tree_int_cst_lt (maxobjsize, range[0]))\n     {\n-      location_t loc = tree_nonartificial_location (exp);\n-      loc = expansion_point_location_if_in_system_header (loc);\n-\n+      location_t loc = tree_inlined_location (exp);\n       maybe_warn_for_bound (OPT_Wstringop_overflow_, loc, exp, func, range,\n \t\t\t    NULL_TREE, pad);\n       return false;\n@@ -4766,9 +4764,7 @@ check_access (tree exp, tree dstwrite,\n \t      || (pad && pad->dst.ref && TREE_NO_WARNING (pad->dst.ref)))\n \t    return false;\n \n-\t  location_t loc = tree_nonartificial_location (exp);\n-\t  loc = expansion_point_location_if_in_system_header (loc);\n-\n+\t  location_t loc = tree_inlined_location (exp);\n \t  bool warned = false;\n \t  if (dstwrite == slen && at_least_one)\n \t    {\n@@ -4821,9 +4817,7 @@ check_access (tree exp, tree dstwrite,\n \t PAD is nonnull and BNDRNG is valid.  */\n       get_size_range (maxread, range, pad ? pad->src.bndrng : NULL);\n \n-      location_t loc = tree_nonartificial_location (exp);\n-      loc = expansion_point_location_if_in_system_header (loc);\n-\n+      location_t loc = tree_inlined_location (exp);\n       tree size = dstsize;\n       if (pad && pad->mode == access_read_only)\n \tsize = wide_int_to_tree (sizetype, pad->src.sizrng[1]);\n@@ -4882,9 +4876,7 @@ check_access (tree exp, tree dstwrite,\n \t  || (pad && pad->src.ref && TREE_NO_WARNING (pad->src.ref)))\n \treturn false;\n \n-      location_t loc = tree_nonartificial_location (exp);\n-      loc = expansion_point_location_if_in_system_header (loc);\n-\n+      location_t loc = tree_inlined_location (exp);\n       const bool read\n \t= mode == access_read_only || mode == access_read_write;\n       const bool maybe = pad && pad->dst.parmarray;\n@@ -6381,9 +6373,7 @@ check_strncat_sizes (tree exp, tree objsize)\n   if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (objsize)\n       && tree_int_cst_equal (objsize, maxread))\n     {\n-      location_t loc = tree_nonartificial_location (exp);\n-      loc = expansion_point_location_if_in_system_header (loc);\n-\n+      location_t loc = tree_inlined_location (exp);\n       warning_at (loc, OPT_Wstringop_overflow_,\n \t\t  \"%K%qD specified bound %E equals destination size\",\n \t\t  exp, get_callee_fndecl (exp), maxread);\n@@ -6456,9 +6446,7 @@ expand_builtin_strncat (tree exp, rtx)\n   if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (destsize)\n       && tree_int_cst_equal (destsize, maxread))\n     {\n-      location_t loc = tree_nonartificial_location (exp);\n-      loc = expansion_point_location_if_in_system_header (loc);\n-\n+      location_t loc = tree_inlined_location (exp);\n       warning_at (loc, OPT_Wstringop_overflow_,\n \t\t  \"%K%qD specified bound %E equals destination size\",\n \t\t  exp, get_callee_fndecl (exp), maxread);\n@@ -7040,9 +7028,7 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n       || !check_nul_terminated_array (exp, arg2, arg3))\n     return NULL_RTX;\n \n-  location_t loc = tree_nonartificial_location (exp);\n-  loc = expansion_point_location_if_in_system_header (loc);\n-\n+  location_t loc = tree_inlined_location (exp);\n   tree len1 = c_strlen (arg1, 1);\n   tree len2 = c_strlen (arg2, 1);\n \n@@ -12970,7 +12956,9 @@ fndecl_alloc_p (tree fndecl, bool all_alloc)\n \tcase BUILT_IN_ALLOCA:\n \tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n \t  return all_alloc;\n+\tcase BUILT_IN_ALIGNED_ALLOC:\n \tcase BUILT_IN_CALLOC:\n+\tcase BUILT_IN_GOMP_ALLOC:\n \tcase BUILT_IN_MALLOC:\n \tcase BUILT_IN_REALLOC:\n \tcase BUILT_IN_STRDUP:\n@@ -13065,12 +13053,119 @@ call_dealloc_argno (tree exp)\n   return UINT_MAX;\n }\n \n-/* Return true if STMT is a call to a deallocation function.  */\n+/* Return true if DELETE_DECL is an operator delete that's not suitable\n+   to call with a pointer returned fron NEW_DECL.  */\n \n-static inline bool\n-call_dealloc_p (tree exp)\n+static bool\n+new_delete_mismatch_p (tree new_decl, tree delete_decl)\n {\n-  return call_dealloc_argno (exp) != UINT_MAX;\n+  tree new_name = DECL_ASSEMBLER_NAME (new_decl);\n+  tree delete_name = DECL_ASSEMBLER_NAME (delete_decl);\n+\n+  /* valid_new_delete_pair_p() returns a conservative result.  A true\n+     result is reliable but a false result doesn't necessarily mean\n+     the operators don't match.  */\n+  if (valid_new_delete_pair_p (new_name, delete_name))\n+    return false;\n+\n+  const char *new_str = IDENTIFIER_POINTER (new_name);\n+  const char *del_str = IDENTIFIER_POINTER (delete_name);\n+\n+  if (*new_str != '_')\n+    return *new_str != *del_str;\n+\n+  ++del_str;\n+  if (*++new_str != 'Z')\n+    return *new_str != *del_str;\n+\n+  ++del_str;\n+  if (*++new_str == 'n')\n+    return *del_str != 'd';\n+\n+  if (*new_str != 'N')\n+    return *del_str != 'N';\n+\n+  /* Handle user-defined member operators below.  */\n+  ++new_str;\n+  ++del_str;\n+\n+  do\n+    {\n+      /* Determine if both operators are members of the same type.\n+\t If not, they don't match.  */\n+      char *new_end, *del_end;\n+      unsigned long nlen = strtoul (new_str, &new_end, 10);\n+      unsigned long dlen = strtoul (del_str, &del_end, 10);\n+      if (nlen != dlen)\n+\treturn true;\n+\n+      /* Skip past the name length.   */\n+      new_str = new_end;\n+      del_str = del_end;\n+\n+      /* Skip past the names making sure each has the expected length\n+\t (it would suggest some sort of a corruption if they didn't).  */\n+      while (nlen--)\n+\tif (!*++new_end)\n+\t  return true;\n+\n+      for (nlen = dlen; nlen--; )\n+\tif (!*++del_end)\n+\t  return true;\n+\n+      /* The names have the expected length.  Compare them.  */\n+      if (memcmp (new_str, del_str, dlen))\n+\treturn true;\n+\n+      new_str = new_end;\n+      del_str = del_end;\n+\n+      if (*new_str == 'I')\n+\t{\n+\t  /* Template instantiation.  */\n+\t  do\n+\t    {\n+\t      ++new_str;\n+\t      ++del_str;\n+\n+\t      if (*new_str == 'n')\n+\t\tbreak;\n+\t      if (*new_str != *del_str)\n+\t\treturn true;\n+\t    }\n+\t  while (*new_str);\n+\t}\n+\n+      if (*new_str == 'n')\n+\t{\n+\t  if (*del_str != 'd')\n+\t    return true;\n+\n+\t  ++del_str;\n+\t  if (*++new_str == 'w' && *del_str != 'l')\n+\t    return true;\n+\t  if (*new_str == 'a' && *del_str != 'a')\n+\t    return true;\n+\t  ++new_str;\n+\t  ++del_str;\n+\t  break;\n+\t}\n+    } while (true);\n+\n+  if (*new_str != 'E')\n+    return *del_str != *new_str;\n+\n+  ++new_str;\n+  ++del_str;\n+  if (*new_str != 'j' && *new_str != 'm' && *new_str != 'y')\n+    return true;\n+  if (*del_str != 'P' || *++del_str != 'v')\n+    return true;\n+\n+  /* Ignore any remaining arguments.  Since both operators are members\n+     of the same class, mismatches in those should be detectable and\n+     diagnosed by the front end.  */\n+  return false;\n }\n \n /* ALLOC_DECL and DEALLOC_DECL are pair of allocation and deallocation\n@@ -13080,18 +13175,17 @@ call_dealloc_p (tree exp)\n static bool\n matching_alloc_calls_p (tree alloc_decl, tree dealloc_decl)\n {\n+  /* Set to alloc_kind_t::builtin if ALLOC_DECL is associated with\n+     a built-in deallocator.  */\n+  enum class alloc_kind_t { none, builtin, user }\n+  alloc_dealloc_kind = alloc_kind_t::none;\n+\n   if (DECL_IS_OPERATOR_NEW_P (alloc_decl))\n     {\n       if (DECL_IS_OPERATOR_DELETE_P (dealloc_decl))\n-\t{\n-\t  /* Return true iff both functions are of the same array or\n-\t     singleton form and false otherwise.  */\n-\t  tree alloc_id = DECL_NAME (alloc_decl);\n-\t  tree dealloc_id = DECL_NAME (dealloc_decl);\n-\t  const char *alloc_fname = IDENTIFIER_POINTER (alloc_id);\n-\t  const char *dealloc_fname = IDENTIFIER_POINTER (dealloc_id);\n-\t  return !strchr (alloc_fname, '[') == !strchr (dealloc_fname, '[');\n-\t}\n+\t/* Return true iff both functions are of the same array or\n+\t   singleton form and false otherwise.  */\n+\treturn !new_delete_mismatch_p (alloc_decl, dealloc_decl);\n \n       /* Return false for deallocation functions that are known not\n \t to match.  */\n@@ -13110,7 +13204,9 @@ matching_alloc_calls_p (tree alloc_decl, tree dealloc_decl)\n \tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n \t  return false;\n \n+\tcase BUILT_IN_ALIGNED_ALLOC:\n \tcase BUILT_IN_CALLOC:\n+\tcase BUILT_IN_GOMP_ALLOC:\n \tcase BUILT_IN_MALLOC:\n \tcase BUILT_IN_REALLOC:\n \tcase BUILT_IN_STRDUP:\n@@ -13121,37 +13217,160 @@ matching_alloc_calls_p (tree alloc_decl, tree dealloc_decl)\n \t  if (fndecl_built_in_p (dealloc_decl, BUILT_IN_FREE)\n \t      || fndecl_built_in_p (dealloc_decl, BUILT_IN_REALLOC))\n \t    return true;\n+\n+\t  alloc_dealloc_kind = alloc_kind_t::builtin;\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n     }\n \n-  /* If DEALLOC_DECL has internal \"*dealloc\" attribute scan the list of\n-     its associated allocation functions for ALLOC_DECL.  If it's found\n-     they are a matching pair, otherwise they're not.  */\n-  tree attrs = DECL_ATTRIBUTES (dealloc_decl);\n-  if (!attrs)\n-    return false;\n+  /* Set if DEALLOC_DECL both allocates and deallocates.  */\n+  alloc_kind_t realloc_kind = alloc_kind_t::none;\n+\n+  if (fndecl_built_in_p (dealloc_decl, BUILT_IN_NORMAL))\n+    {\n+      built_in_function dealloc_code = DECL_FUNCTION_CODE (dealloc_decl);\n+      if (dealloc_code == BUILT_IN_REALLOC)\n+\trealloc_kind = alloc_kind_t::builtin;\n+\n+      for (tree amats = DECL_ATTRIBUTES (alloc_decl);\n+\t   (amats = lookup_attribute (\"malloc\", amats));\n+\t   amats = TREE_CHAIN (amats))\n+\t{\n+\t  tree args = TREE_VALUE (amats);\n+\t  if (!args)\n+\t    continue;\n+\n+\t  tree fndecl = TREE_VALUE (args);\n+\t  if (!fndecl || !DECL_P (fndecl))\n+\t    continue;\n+\n+\t  if (fndecl_built_in_p (fndecl, BUILT_IN_NORMAL)\n+\t      && dealloc_code == DECL_FUNCTION_CODE (fndecl))\n+\t    return true;\n+\t}\n+    }\n+\n+  const bool alloc_builtin = fndecl_built_in_p (alloc_decl, BUILT_IN_NORMAL);\n+  alloc_kind_t realloc_dealloc_kind = alloc_kind_t::none;\n \n-  for (tree funs = attrs;\n-       (funs = lookup_attribute (\"*dealloc\", funs));\n-       funs = TREE_CHAIN (funs))\n+  /* If DEALLOC_DECL has an internal \"*dealloc\" attribute scan the list\n+     of its associated allocation functions for ALLOC_DECL.\n+     If the corresponding ALLOC_DECL is found they're a matching pair,\n+     otherwise they're not.\n+     With DDATS set to the Deallocator's *Dealloc ATtributes...  */\n+  for (tree ddats = DECL_ATTRIBUTES (dealloc_decl);\n+       (ddats = lookup_attribute (\"*dealloc\", ddats));\n+       ddats = TREE_CHAIN (ddats))\n     {\n-      tree args = TREE_VALUE (funs);\n+      tree args = TREE_VALUE (ddats);\n       if (!args)\n \tcontinue;\n \n-      tree fname = TREE_VALUE (args);\n-      if (!fname)\n+      tree alloc = TREE_VALUE (args);\n+      if (!alloc)\n \tcontinue;\n \n-      if (fname == DECL_NAME (alloc_decl))\n+      if (alloc == DECL_NAME (dealloc_decl))\n+\trealloc_kind = alloc_kind_t::user;\n+\n+      if (DECL_P (alloc))\n+\t{\n+\t  gcc_checking_assert (fndecl_built_in_p (alloc, BUILT_IN_NORMAL));\n+\n+\t  switch (DECL_FUNCTION_CODE (alloc))\n+\t    {\n+\t    case BUILT_IN_ALIGNED_ALLOC:\n+\t    case BUILT_IN_CALLOC:\n+\t    case BUILT_IN_GOMP_ALLOC:\n+\t    case BUILT_IN_MALLOC:\n+\t    case BUILT_IN_REALLOC:\n+\t    case BUILT_IN_STRDUP:\n+\t    case BUILT_IN_STRNDUP:\n+\t      realloc_dealloc_kind = alloc_kind_t::builtin;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\n+\t  if (!alloc_builtin)\n+\t    continue;\n+\n+\t  if (DECL_FUNCTION_CODE (alloc) != DECL_FUNCTION_CODE (alloc_decl))\n+\t    continue;\n+\n+\t  return true;\n+\t}\n+\n+      if (alloc == DECL_NAME (alloc_decl))\n \treturn true;\n     }\n \n-  return false;\n+  if (realloc_kind == alloc_kind_t::none)\n+    return false;\n+\n+  hash_set<tree> common_deallocs;\n+  /* Special handling for deallocators.  Iterate over both the allocator's\n+     and the reallocator's associated deallocator functions looking for\n+     the first one in common.  If one is found, the de/reallocator is\n+     a match for the allocator even though the latter isn't directly\n+     associated with the former.  This simplifies declarations in system\n+     headers.\n+     With AMATS set to the Allocator's Malloc ATtributes,\n+     and  RMATS set to Reallocator's Malloc ATtributes...  */\n+  for (tree amats = DECL_ATTRIBUTES (alloc_decl),\n+\t rmats = DECL_ATTRIBUTES (dealloc_decl);\n+       (amats = lookup_attribute (\"malloc\", amats))\n+\t || (rmats = lookup_attribute (\"malloc\", rmats));\n+       amats = amats ? TREE_CHAIN (amats) : NULL_TREE,\n+\t rmats = rmats ? TREE_CHAIN (rmats) : NULL_TREE)\n+    {\n+      if (tree args = amats ? TREE_VALUE (amats) : NULL_TREE)\n+\tif (tree adealloc = TREE_VALUE (args))\n+\t  {\n+\t    if (DECL_P (adealloc)\n+\t\t&& fndecl_built_in_p (adealloc, BUILT_IN_NORMAL))\n+\t      {\n+\t\tbuilt_in_function fncode = DECL_FUNCTION_CODE (adealloc);\n+\t\tif (fncode == BUILT_IN_FREE || fncode == BUILT_IN_REALLOC)\n+\t\t  {\n+\t\t    if (realloc_kind == alloc_kind_t::builtin)\n+\t\t      return true;\n+\t\t    alloc_dealloc_kind = alloc_kind_t::builtin;\n+\t\t  }\n+\t\tcontinue;\n+\t      }\n+\n+\t    common_deallocs.add (adealloc);\n+\t  }\n+\n+      if (tree args = rmats ? TREE_VALUE (rmats) : NULL_TREE)\n+\tif (tree ddealloc = TREE_VALUE (args))\n+\t  {\n+\t    if (DECL_P (ddealloc)\n+\t\t&& fndecl_built_in_p (ddealloc, BUILT_IN_NORMAL))\n+\t      {\n+\t\tbuilt_in_function fncode = DECL_FUNCTION_CODE (ddealloc);\n+\t\tif (fncode == BUILT_IN_FREE || fncode == BUILT_IN_REALLOC)\n+\t\t  {\n+\t\t    if (alloc_dealloc_kind == alloc_kind_t::builtin)\n+\t\t      return true;\n+\t\t    realloc_dealloc_kind = alloc_kind_t::builtin;\n+\t\t  }\n+\t\tcontinue;\n+\t      }\n+\n+\t    if (common_deallocs.add (ddealloc))\n+\t      return true;\n+\t  }\n+    }\n+\n+  /* Succeed only if ALLOC_DECL and the reallocator DEALLOC_DECL share\n+     a built-in deallocator.  */\n+  return  (alloc_dealloc_kind == alloc_kind_t::builtin\n+\t   && realloc_dealloc_kind == alloc_kind_t::builtin);\n }\n \n /* Return true if DEALLOC_DECL is a function suitable to deallocate\n@@ -13167,15 +13386,36 @@ matching_alloc_calls_p (gimple *alloc, tree dealloc_decl)\n   return matching_alloc_calls_p (alloc_decl, dealloc_decl);\n }\n \n-/* Diagnose a call to FNDECL to deallocate a pointer referenced by\n-   AREF that includes a nonzero offset.  Such a pointer cannot refer\n-   to the beginning of an allocated object.  A negative offset may\n-   refer to it only if the target pointer is unknown.  */\n+/* Diagnose a call EXP to deallocate a pointer referenced by AREF if it\n+   includes a nonzero offset.  Such a pointer cannot refer to the beginning\n+   of an allocated object.  A negative offset may refer to it only if\n+   the target pointer is unknown.  */\n \n static bool\n-warn_dealloc_offset (location_t loc, tree exp, tree fndecl,\n-\t\t     const access_ref &aref)\n+warn_dealloc_offset (location_t loc, tree exp, const access_ref &aref)\n {\n+  if (aref.deref || aref.offrng[0] <= 0 || aref.offrng[1] <= 0)\n+    return false;\n+\n+  tree dealloc_decl = get_callee_fndecl (exp);\n+  if (DECL_IS_OPERATOR_DELETE_P (dealloc_decl)\n+      && !DECL_IS_REPLACEABLE_OPERATOR (dealloc_decl))\n+    {\n+      /* A call to a user-defined operator delete with a pointer plus offset\n+\t may be valid if it's returned from an unknown function (i.e., one\n+\t that's not operator new).  */\n+      if (TREE_CODE (aref.ref) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (aref.ref);\n+\t  if (is_gimple_call (def_stmt))\n+\t    {\n+\t      tree alloc_decl = gimple_call_fndecl (def_stmt);\n+\t      if (!DECL_IS_OPERATOR_NEW_P (alloc_decl))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n   char offstr[80];\n   offstr[0] = '\\0';\n   if (wi::fits_shwi_p (aref.offrng[0]))\n@@ -13192,7 +13432,7 @@ warn_dealloc_offset (location_t loc, tree exp, tree fndecl,\n \n   if (!warning_at (loc, OPT_Wfree_nonheap_object,\n \t\t   \"%K%qD called on pointer %qE with nonzero offset%s\",\n-\t\t   exp, fndecl, aref.ref, offstr))\n+\t\t   exp, dealloc_decl, aref.ref, offstr))\n     return false;\n \n   if (DECL_P (aref.ref))\n@@ -13202,9 +13442,16 @@ warn_dealloc_offset (location_t loc, tree exp, tree fndecl,\n       gimple *def_stmt = SSA_NAME_DEF_STMT (aref.ref);\n       if (is_gimple_call (def_stmt))\n \t{\n+\t  location_t def_loc = gimple_location (def_stmt);\n \t  tree alloc_decl = gimple_call_fndecl (def_stmt);\n-\t  inform (gimple_location (def_stmt),\n-\t\t  \"returned from a call to %qD\", alloc_decl);\n+\t  if (alloc_decl)\n+\t    inform (def_loc,\n+\t\t    \"returned from %qD\", alloc_decl);\n+\t  else if (tree alloc_fntype = gimple_call_fntype (def_stmt))\n+\t    inform (def_loc,\n+\t\t    \"returned from %qT\", alloc_fntype);\n+\t  else\n+\t    inform (def_loc,  \"obtained here\");\n \t}\n     }\n \n@@ -13240,8 +13487,7 @@ maybe_emit_free_warning (tree exp)\n     return;\n \n   tree dealloc_decl = get_callee_fndecl (exp);\n-  location_t loc = tree_nonartificial_location (exp);\n-  loc = expansion_point_location_if_in_system_header (loc);\n+  location_t loc = tree_inlined_location (exp);\n \n   if (DECL_P (ref) || EXPR_P (ref))\n     {\n@@ -13251,18 +13497,18 @@ maybe_emit_free_warning (tree exp)\n \t\t\t \"%K%qD called on unallocated object %qD\",\n \t\t\t exp, dealloc_decl, ref))\n \t{\n-\t  inform (DECL_SOURCE_LOCATION (ref),\n-\t\t  \"declared here\");\n+\t  loc = (DECL_P (ref)\n+\t\t ? DECL_SOURCE_LOCATION (ref)\n+\t\t : EXPR_LOCATION (ref));\n+\t  inform (loc, \"declared here\");\n \t  return;\n \t}\n \n       /* Diagnose freeing a pointer that includes a positive offset.\n \t Such a pointer cannot refer to the beginning of an allocated\n \t object.  A negative offset may refer to it.  */\n-      if (!aref.deref\n-\t  && aref.sizrng[0] != aref.sizrng[1]\n-\t  && aref.offrng[0] > 0 && aref.offrng[1] > 0\n-\t  && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+      if (aref.sizrng[0] != aref.sizrng[1]\n+\t  && warn_dealloc_offset (loc, exp, aref))\n \treturn;\n     }\n   else if (CONSTANT_CLASS_P (ref))\n@@ -13295,9 +13541,7 @@ maybe_emit_free_warning (tree exp)\n \t    {\n \t      if (matching_alloc_calls_p (def_stmt, dealloc_decl))\n \t\t{\n-\t\t  if (!aref.deref\n-\t\t      && aref.offrng[0] > 0 && aref.offrng[1] > 0\n-\t\t      && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+\t\t  if (warn_dealloc_offset (loc, exp, aref))\n \t\t    return;\n \t\t}\n \t      else\n@@ -13320,16 +13564,14 @@ maybe_emit_free_warning (tree exp)\n \t\t\t\t \"%K%qD called on pointer to \"\n \t\t\t\t \"an unallocated object\",\n \t\t\t\t exp, dealloc_decl);\n-\t  else if (!aref.deref\n-\t\t   && aref.offrng[0] > 0 && aref.offrng[1] > 0\n-\t\t   && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+\t  else if (warn_dealloc_offset (loc, exp, aref))\n \t    return;\n \n \t  if (warned)\n \t    {\n \t      tree fndecl = gimple_call_fndecl (def_stmt);\n \t      inform (gimple_location (def_stmt),\n-\t\t      \"returned from a call to %qD\", fndecl);\n+\t\t      \"returned from %qD\", fndecl);\n \t      return;\n \t    }\n \t}\n@@ -13341,7 +13583,7 @@ maybe_emit_free_warning (tree exp)\n \t      && !aref.deref\n \t      && aref.sizrng[0] != aref.sizrng[1]\n \t      && aref.offrng[0] > 0 && aref.offrng[1] > 0\n-\t      && warn_dealloc_offset (loc, exp, dealloc_decl, aref))\n+\t      && warn_dealloc_offset (loc, exp, aref))\n \t    return;\n \t}\n     }"}, {"sha": "29e2672830052d92b675aadbed72deb3b0b12a0d", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 103, "deletions": 22, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -3130,12 +3130,64 @@ handle_no_profile_instrument_function_attribute (tree *node, tree name, tree,\n   return NULL_TREE;\n }\n \n+/* If ALLOC_DECL and DEALLOC_DECL are a pair of user-defined functions,\n+   if they are declared inline issue warnings and return null.  Otherwise\n+   create attribute noinline, install it in ALLOC_DECL, and return it.\n+   Otherwise return null. */\n+\n+static tree\n+maybe_add_noinline (tree name, tree alloc_decl, tree dealloc_decl,\n+\t\t    bool *no_add_attrs)\n+{\n+  if (fndecl_built_in_p (alloc_decl) || fndecl_built_in_p (dealloc_decl))\n+    return NULL_TREE;\n+\n+  /* When inlining (or optimization) is enabled and the allocator and\n+     deallocator are not built-in functions, ignore the attribute on\n+     functions declared inline since it could lead to false positives\n+     when inlining one or the other call would wind up calling\n+     a mismatched allocator or  deallocator.  */\n+  if ((optimize && DECL_DECLARED_INLINE_P (alloc_decl))\n+      || lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (alloc_decl)))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%<%E (%E)%> attribute ignored on functions \"\n+\t       \"declared %qs\", name, DECL_NAME (dealloc_decl), \"inline\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  if ((optimize && DECL_DECLARED_INLINE_P (dealloc_decl))\n+      || lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (dealloc_decl)))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%<%E (%E)%> attribute ignored with deallocation \"\n+\t       \"functions declared %qs\",\n+\t       name, DECL_NAME (dealloc_decl), \"inline\");\n+      inform (DECL_SOURCE_LOCATION (dealloc_decl),\n+\t      \"deallocation function declared here\" );\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* Disable inlining for non-standard deallocators to avoid false\n+     positives due to mismatches between the inlined implementation\n+     of one and not the other pair of functions.  */\n+  tree attr = tree_cons (get_identifier (\"noinline\"), NULL_TREE, NULL_TREE);\n+  decl_attributes (&alloc_decl, attr, 0);\n+  return attr;\n+}\n+\n /* Handle the \"malloc\" attribute.  */\n \n static tree\n-handle_malloc_attribute (tree *node, tree name, tree args,\n-\t\t\t int ARG_UNUSED (flags), bool *no_add_attrs)\n+handle_malloc_attribute (tree *node, tree name, tree args, int flags,\n+\t\t\t bool *no_add_attrs)\n {\n+  if (flags & ATTR_FLAG_INTERNAL)\n+    /* Recursive call.  */\n+    return NULL_TREE;\n+\n   tree fndecl = *node;\n \n   if (TREE_CODE (*node) != FUNCTION_DECL)\n@@ -3174,11 +3226,21 @@ handle_malloc_attribute (tree *node, tree name, tree args,\n       return NULL_TREE;\n     }\n \n-  /* In C++ the argument may be wrapped in a cast to disambiguate one\n-     of a number of overloads (such as operator delete).  Strip it.  */\n   STRIP_NOPS (dealloc);\n   if (TREE_CODE (dealloc) == ADDR_EXPR)\n-    dealloc = TREE_OPERAND (dealloc, 0);\n+    {\n+      /* In C++ the argument may be wrapped in a cast to disambiguate\n+\t one of a number of overloads (such as operator delete).  To\n+\t make things interesting, the cast looks different between\n+\t different C++ versions.  Strip it and install the attribute\n+\t with the disambiguated function.  */\n+      dealloc = TREE_OPERAND (dealloc, 0);\n+\n+      *no_add_attrs = true;\n+      tree attr = tree_cons (NULL_TREE, dealloc, TREE_CHAIN (args));\n+      attr = build_tree_list (name, attr);\n+      return decl_attributes (node, attr, 0);\n+    }\n \n   if (TREE_CODE (dealloc) != FUNCTION_DECL)\n     {\n@@ -3233,10 +3295,21 @@ handle_malloc_attribute (tree *node, tree name, tree args,\n \t  return NULL_TREE;\n \t}\n \n-      *no_add_attrs = false;\n-      tree attr_free = build_tree_list (NULL_TREE, DECL_NAME (fndecl));\n-      attr_free = build_tree_list (get_identifier (\"*dealloc\"), attr_free);\n-      decl_attributes (&dealloc, attr_free, 0);\n+      /* Disable inlining for non-standard deallocators to avoid false\n+\t positives (or warn if either function is explicitly inline).  */\n+      tree at_noinline =\n+\tmaybe_add_noinline (name, fndecl, dealloc, no_add_attrs);\n+      if (*no_add_attrs)\n+\treturn NULL_TREE;\n+\n+      /* Add attribute *dealloc to the deallocator function associating\n+\t it with this one.  Ideally, the attribute would reference\n+\t the DECL of the deallocator but since that changes for each\n+\t redeclaration, use DECL_NAME instead.  (DECL_ASSEMBLER_NAME\n+\t need not be set set this point and setting it here is too early.  */\n+      tree attrs = build_tree_list (NULL_TREE, DECL_NAME (fndecl));\n+      attrs = tree_cons (get_identifier (\"*dealloc\"), attrs, at_noinline);\n+      decl_attributes (&dealloc, attrs, 0);\n       return NULL_TREE;\n     }\n \n@@ -3248,15 +3321,21 @@ handle_malloc_attribute (tree *node, tree name, tree args,\n       return NULL_TREE;\n     }\n \n+  /* As above, disable inlining for non-standard deallocators to avoid\n+     false positives (or warn).  */\n+  tree at_noinline =\n+    maybe_add_noinline (name, fndecl, dealloc, no_add_attrs);\n+  if (*no_add_attrs)\n+    return NULL_TREE;\n+\n   /* It's valid to declare the same function with multiple instances\n      of attribute malloc, each naming the same or different deallocator\n      functions, and each referencing either the same or a different\n      positional argument.  */\n-  *no_add_attrs = false;\n-  tree attr_free = tree_cons (NULL_TREE, argpos, NULL_TREE);\n-  attr_free = tree_cons (NULL_TREE, DECL_NAME (fndecl), attr_free);\n-  attr_free = build_tree_list (get_identifier (\"*dealloc\"), attr_free);\n-  decl_attributes (&dealloc, attr_free, 0);\n+  tree attrs = tree_cons (NULL_TREE, argpos, NULL_TREE);\n+  attrs = tree_cons (NULL_TREE, DECL_NAME (fndecl), attrs);\n+  attrs = tree_cons (get_identifier (\"*dealloc\"), attrs, at_noinline);\n+  decl_attributes (&dealloc, attrs, 0);\n   return NULL_TREE;\n }\n \n@@ -3274,11 +3353,13 @@ handle_dealloc_attribute (tree *node, tree name, tree args, int,\n   if (!attrs)\n     return NULL_TREE;\n \n-  tree arg_fname = TREE_VALUE (args);\n+  tree arg = TREE_VALUE (args);\n   args = TREE_CHAIN (args);\n-  tree arg_pos = args ? TREE_VALUE (args) : NULL_TREE;\n+  tree arg_pos = args ? TREE_VALUE (args) : integer_zero_node;\n \n-  gcc_checking_assert (TREE_CODE (arg_fname) == IDENTIFIER_NODE);\n+  gcc_checking_assert ((DECL_P (arg)\n+\t\t\t&& fndecl_built_in_p (arg, BUILT_IN_NORMAL))\n+\t\t       || TREE_CODE (arg) == IDENTIFIER_NODE);\n \n   const char* const namestr = IDENTIFIER_POINTER (name);\n   for (tree at = attrs; (at = lookup_attribute (namestr, at));\n@@ -3290,12 +3371,12 @@ handle_dealloc_attribute (tree *node, tree name, tree args, int,\n \n       tree pos = TREE_CHAIN (alloc);\n       alloc = TREE_VALUE (alloc);\n-      pos = pos ? TREE_VALUE (pos) : NULL_TREE;\n-      gcc_checking_assert (TREE_CODE (alloc) == IDENTIFIER_NODE);\n+      pos = pos ? TREE_VALUE (pos) : integer_zero_node;\n+      gcc_checking_assert ((DECL_P (alloc)\n+\t\t\t    && fndecl_built_in_p (alloc, BUILT_IN_NORMAL))\n+\t\t\t   || TREE_CODE (alloc) == IDENTIFIER_NODE);\n \n-      if (alloc == arg_fname\n-\t  && ((!pos && !arg_pos)\n-\t      || (pos && arg_pos && tree_int_cst_equal (pos, arg_pos))))\n+      if (alloc == arg && tree_int_cst_equal (pos, arg_pos))\n \t{\n \t  /* The function already has the attribute either without any\n \t     arguments or with the same arguments as the attribute that's"}, {"sha": "e73464a7f19b5d6abf89b70eaf1803ef892ad66f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -3257,37 +3257,37 @@ as they may return pointers to storage containing pointers to existing\n objects.\n \n Associating a function with a @var{deallocator} helps detect calls to\n-mismatched allocation and deallocation functions and diagnose them\n-under the control of options such as @option{-Wmismatched-dealloc}.\n-To indicate that an allocation function both satisifies the nonaliasing\n-property and has a deallocator associated with it, both the plain form\n-of the attribute and the one with the @var{deallocator} argument must\n-be used.\n+mismatched allocation and deallocation functions and diagnose them under\n+the control of options such as @option{-Wmismatched-dealloc}.  To indicate\n+that an allocation function both satisifies the nonaliasing property and\n+has a deallocator associated with it, both the plain form of the attribute\n+and the one with the @var{deallocator} argument must be used.  The same\n+function can be both an allocator and a deallocator.  Since inlining one\n+of the associated functions but not the other could result in apparent\n+mismatches, this form of attribute @code{malloc} is not accepted on inline\n+functions.  For the same reason, using the attribute prevents both\n+the allocation and deallocation functions from being expanded inline.\n \n For example, besides stating that the functions return pointers that do\n-not alias any others, the following declarations make the @code{fclose}\n-and @code{frepen} functions suitable deallocators for pointers returned\n-from all the functions that return them, and the @code{pclose} function\n-as the only other suitable deallocator besides @code{freopen} for pointers\n-returned from @code{popen}.  The deallocator functions must declared\n-before they can be referenced in the attribute.\n+not alias any others, the following declarations make @code{fclose}\n+a suitable deallocator for pointers returned from all functions except\n+@code{popen}, and @code{pclose} as the only suitable deallocator for\n+pointers returned from @code{popen}.  The deallocator functions must\n+declared before they can be referenced in the attribute.\n \n @smallexample\n-int   fclose (FILE*);\n-FILE* freopen (const char*, const char*, FILE*);\n-int   pclose (FILE*);\n+int fclose (FILE*);\n+int pclose (FILE*);\n \n-__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+__attribute__ ((malloc, malloc (fclose (1))))\n   FILE* fdopen (int);\n-__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+__attribute__ ((malloc, malloc (fclose (1))))\n   FILE* fopen (const char*, const char*);\n-__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+__attribute__ ((malloc, malloc (fclose (1))))\n   FILE* fmemopen(void *, size_t, const char *);\n-__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n-  FILE* freopen (const char*, const char*, FILE*);\n-__attribute__ ((malloc, malloc (pclose), malloc (freopen, 3)))\n+__attribute__ ((malloc, malloc (pclose (1))))\n   FILE* popen (const char*, const char*);\n-__attribute__ ((malloc, malloc (fclose), malloc (freopen, 3)))\n+__attribute__ ((malloc, malloc (fclose (1))))\n   FILE* tmpfile (void);\n @end smallexample\n "}, {"sha": "0aedf1babbc9b7bb6abfa687adcbd141fde68005", "filename": "gcc/testsuite/c-c++-common/Wfree-nonheap-object-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object-2.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,52 @@\n+/* PR middle-end/98166: bogus -Wmismatched-dealloc on user-defined allocator\n+   and inlining\n+   Verify that the allocator can be declared inline without a warning when\n+   it's associated with a standard deallocator.  Associating an inline\n+   deallocator with an allocator would cause false positives when the former\n+   calls a deallocation function the allocator isn't associated with, so\n+   that triggers a warning on declaration.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+__attribute__ ((malloc (__builtin_free)))\n+inline int*\n+alloc_int (int n)\n+{\n+  return (int*)__builtin_malloc (n + sizeof (int));\n+}\n+\n+void test_nowarn_int (int n)\n+{\n+  {\n+    int *p = alloc_int (n);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    int *p = alloc_int (n);\n+    __builtin_free (p + 1);   // { dg-warning \"\\\\\\[-Wfree-nonheap-object\" }\n+  }\n+}\n+\n+\n+inline void\n+dealloc_long (long *p)\n+{\n+  __builtin_free (p);         // { dg-warning \"'__builtin_free|void __builtin_free\\\\(void\\\\*\\\\)' called on pointer 'p|<unknown>' with nonzero offset\" }\n+}\n+\n+__attribute__ ((malloc (dealloc_long)))\n+long* alloc_long (int);       // { dg-warning \"'malloc \\\\\\(dealloc_long\\\\\\)' attribute ignored with deallocation functions declared 'inline'\" }\n+\n+void test_nowarn_long (int n)\n+{\n+  {\n+    long *p = alloc_long (n);\n+    dealloc_long (p);\n+  }\n+\n+  {\n+    long *p = alloc_long (n);\n+    dealloc_long (p + 1);\n+  }\n+}"}, {"sha": "41a5b50362eb2313ecd9b7ef1a3e020f713ace82", "filename": "gcc/testsuite/c-c++-common/Wfree-nonheap-object-3.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object-3.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,70 @@\n+/* PR middle-end/98166: bogus -Wmismatched-dealloc on user-defined allocator\n+   and inlining\n+   Verify that without inlining, both the allocator and the deallocator\n+   can be declared inline without a warning and that mismatched calls are\n+   detected, but that declaring them always_inline does trigger a warning.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+__attribute__ ((malloc (__builtin_free)))\n+inline int*\n+alloc_int (int n)\n+{\n+  return (int*)__builtin_malloc (n + sizeof (int));\n+}\n+\n+void test_nowarn_int (int n)\n+{\n+  {\n+    int *p = alloc_int (n);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    int *p = alloc_int (n);\n+    __builtin_free (p + 1);   // { dg-warning \"'__builtin_free|void __builtin_free\\\\(void\\\\*\\\\)' called on pointer 'p|<unknown>' with nonzero offset\" }\n+  }\n+}\n+\n+\n+inline void\n+dealloc_long (long *p) { __builtin_free (p); }\n+\n+__attribute__ ((malloc (dealloc_long)))\n+long* alloc_long (int);\n+\n+void test_nowarn_long (int n)\n+{\n+  {\n+    long *p = alloc_long (n);\n+    dealloc_long (p);\n+  }\n+\n+  {\n+    long *p = alloc_long (n);\n+    dealloc_long (p + 1);     // { dg-warning \"'dealloc_long' called on pointer 'p|<unknown>' with nonzero offset\" }\n+  }\n+}\n+\n+\n+inline __attribute__ ((always_inline)) void\n+dealloc_float (float *p)      // { dg-message \"deallocation function declared here\" }\n+{\n+  __builtin_free (p);         // { dg-warning \"'__builtin_free|void __builtin_free\\\\(void\\\\*\\\\)' called on pointer 'p|<unknown>' with nonzero offset\" }\n+}\n+\n+__attribute__ ((malloc (dealloc_float)))\n+float* alloc_float (int);     // { dg-warning \"'malloc \\\\(dealloc_float\\\\)' attribute ignored with deallocation functions declared 'inline'\" }\n+\n+void test_nowarn_float (int n)\n+{\n+  {\n+    float *p = alloc_float (n);\n+    dealloc_float (p);\n+  }\n+\n+  {\n+    float *p = alloc_float (n);\n+    dealloc_float (p + 2);\n+  }\n+}"}, {"sha": "dfbb296e9a765970f11f539dfeecd742dba6a2a7", "filename": "gcc/testsuite/c-c++-common/Wfree-nonheap-object.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWfree-nonheap-object.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,50 @@\n+/* Verify that built-in forms of functions can be used interchangeably\n+   with their ordinary (library) forms in attribute malloc.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+char* f (void) __attribute__ ((malloc (__builtin_free)));\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+void free (void*);\n+\n+#if __cplusplus\n+}\n+#endif\n+\n+char* g (void) __attribute__ ((malloc (free)));\n+\n+\n+void test_nowarm (void)\n+{\n+  char *p = f ();\n+  free (p);\n+\n+  p = g ();\n+  free (p);\n+\n+  p = f ();\n+  __builtin_free (p);\n+\n+  p = g ();\n+  __builtin_free (p);\n+}\n+\n+\n+void test_warn (void)\n+{\n+  char *p = f ();\n+  free (p + 1);               // { dg-warning \"'free|void free\\\\(void\\\\*\\\\)' called on pointer 'p|<unknown>' with nonzero offset\" }\n+\n+  p = g ();\n+  free (p + 2);               // { dg-warning \"'free|void free\\\\(void\\\\*\\\\)' called on pointer 'p|<unknown>' with nonzero offset\" }\n+\n+  p = f ();\n+  __builtin_free (p + 3);     // { dg-warning \"'__builtin_free|void __builtin_free\\\\(void\\\\*\\\\)' called on pointer 'p|<unknown>' with nonzero offset\" }\n+\n+  p = g ();\n+  __builtin_free (p + 4);     // { dg-warning \"'__builtin_free|void __builtin_free\\\\(void\\\\*\\\\)' called on pointer 'p|<unknown>' with nonzero offset\" }\n+}"}, {"sha": "27af2c2316b56590a7dcc264e589f41bd702aba1", "filename": "gcc/testsuite/c-c++-common/Wmismatched-dealloc.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmismatched-dealloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmismatched-dealloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmismatched-dealloc.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,67 @@\n+/* PR middle-end/98166: bogus -Wmismatched-dealloc on user-defined allocator\n+   and inlining\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+\n+void dealloc_shrt (short *p)\n+{\n+  /* A positive offset would be diagnosed but a negative one must\n+     not be.  */\n+  __builtin_free (p - 1);       // { dg-bogus \"-Wmismatched-dealloc\" }\n+}\n+\n+__attribute__ ((malloc (dealloc_shrt)))\n+short* alloc_shrt (int n) /* { return malloc (n) + 1; } */;\n+\n+void test_nowarn_shrt (int n)\n+{\n+  short *p = alloc_shrt (n);\n+  dealloc_shrt (p);\n+}\n+\n+\n+void dealloc_int (int *p) /* { free (p - 1); } */;\n+\n+__attribute__ ((malloc (dealloc_int, 1)))\n+int* alloc_int (int n)\n+{\n+  return (int*)__builtin_malloc (n) + 1;\n+}\n+\n+void test_nowarn_int (int n)\n+{\n+  int *p = alloc_int (n);\n+  dealloc_int (p);              // { dg-bogus \"-Wmismatched-dealloc\" }\n+}\n+\n+\n+void dealloc_long (int, long *p) /* { free (p - 2); } */;\n+\n+__attribute__ ((malloc (dealloc_long, 2)))\n+inline long*\n+alloc_long (int n) {            // { dg-warning \"'malloc \\\\(\\[^\\n\\r\\]*dealloc_long\\[^\\n\\r\\]*\\\\)' attribute ignored on functions declared 'inline'\" }\n+  return (long*)__builtin_malloc (n) + 2;\n+}\n+\n+void test_nowarn_long (int n)\n+{\n+  long *p = alloc_long (n);\n+  dealloc_long (0, p);          // { dg-bogus \"\\\\\\[-Wmismatched-dealloc\" }\n+}\n+\n+\n+inline void\n+dealloc_float (int, int, float *p)  // { dg-message \"deallocation function declared here\" }\n+{\n+  __builtin_free (p - 3);\n+}\n+\n+__attribute__ ((malloc (dealloc_float, 3)))\n+float* alloc_float (int n);     // { dg-warning \"'malloc \\\\(\\[^\\n\\r\\]*dealloc_float\\[^\\n\\r\\]*\\\\)' attribute ignored with deallocation functions declared 'inline'\" }\n+\n+void test_nowarn_float (int n)\n+{\n+  float *p = alloc_float (n);\n+  dealloc_float (0, 1, p);      // { dg-bogus \"\\\\\\[-Wmismatched-dealloc\" }\n+}"}, {"sha": "47f97dcb636a9b2b34ab4b0d6734abea9ee29c83", "filename": "gcc/testsuite/g++.dg/warn/Wfree-nonheap-object-3.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-3.C?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,38 @@\n+/* PR c++/57111 - Generalize -Wfree-nonheap-object to delete\n+   Verify that even without -Wsystem-headers the warning is issued\n+   for pairs of library functions defined in system headers.\n+   { dg-do compile { target c++11 } }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include <memory>\n+#include <string>\n+\n+void test_string ()\n+{\n+  std::string str (\"abc\");          // { dg-message \"declared here\" }\n+\n+  const char *s = str.c_str ();\n+  __builtin_printf (\"%s\\n\", s);\n+\n+  /* Because the delete call is made directly in the function this\n+     does not exercise the same thing as test_unique_ptr.  */\n+  delete s;                         // { dg-warning \"'void operator delete\\\\(void\\\\*\\[^\\\\)\\]*\\\\)' called on unallocated object 'str'\" }\n+}\n+\n+void test_unique_ptr ()\n+{\n+  int arr[]= { 1, 2 };              // { dg-message \"declared here\" }\n+\n+  std::unique_ptr<int[]> up (arr);\n+  __builtin_printf (\"%i %i\\n\", up[0], up[1]);\n+\n+  /* TO DO: verify that the warning is printed, including its inlining\n+     context (the directive below doesn't work):\n+     { Xdg-message \"In member function.*inlined from 'void test_unique_ptr\\\\(\\\\)'.*warning: 'void operator delete \\\\\\[]\\\\(void\\\\*\\\\)' called on unallocated object 'arr'\" \"\" { target *-*-* } 0 }  */\n+\n+  /* Here, the delete call is made indirectly from std::unique_ptr\n+     dtor.  */\n+}\n+\n+/* Prune out the warning from test_unique_ptr().\n+   { dg-prune-output \"-Wfree-nonheap-object\" } */"}, {"sha": "943ef0cd1abf6a10f2b81b38c32a9d41ea3826b8", "filename": "gcc/testsuite/g++.dg/warn/Wfree-nonheap-object-4.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-4.C?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,26 @@\n+/* PR middle-end/98160: bogus -Wfree-nonheap-object calling member delete\n+   on the result of inline member new plus offset\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+struct MemoryManager { void* allocate (); };\n+\n+struct XMemory\n+{\n+  void* operator new (__SIZE_TYPE__, MemoryManager *mgr)\n+  {\n+    void *p = mgr->allocate ();\n+    return (char*)p + sizeof(MemoryManager);\n+  }\n+\n+  void operator delete (void*, MemoryManager*);\n+};\n+\n+struct XMLMutex: XMemory {\n+  XMLMutex();\n+};\n+\n+void gValidatorMutex (MemoryManager *mgr)\n+{\n+  new (mgr) XMLMutex;   // { dg-bogus \"\\\\\\[-Wfree-nonheap-object\" }\n+}"}, {"sha": "3aea02fa63de86a5a24796c640338731995ceac9", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-dealloc-2.C", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-dealloc-2.C?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -59,13 +59,13 @@ void test_my_new ()\n \n   {\n     void *p = my_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     operator delete[] (p);\n     // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n   }\n   {\n     void *p = my_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     operator delete[] (p);\n     // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n@@ -89,23 +89,23 @@ void test_my_new ()\n \n   {\n     void *p = my_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     my_array_delete (\"3\", p);\n     // { dg-warning \"'void my_array_delete\\\\\\(const char\\\\\\*, void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n   }\n \n   {\n     void *p = my_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     free (p);\n     // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n   }\n \n   {\n     void *p = my_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     p = realloc (p, 123);\n     // { dg-warning \"'void\\\\\\* realloc\\\\\\(void\\\\\\*, size_t\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n@@ -132,13 +132,13 @@ void test_my_array_new ()\n \n   {\n     void *p = my_array_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     operator delete (p);\n     // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n   }\n   {\n     void *p = my_array_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     operator delete (p);\n     // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function \\\\\\[-Wmismatched-new-delete\" \"\" { target *-*-* } .-1 }\n@@ -161,23 +161,23 @@ void test_my_array_new ()\n   }\n   {\n     void *p = my_array_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     my_delete (\"3\", p);\n     // { dg-warning \"'void my_delete\\\\\\(const char\\\\\\*, void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n   }\n \n   {\n     void *p = my_array_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     free (p);\n     // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n   }\n \n   {\n     void *p = my_array_new (1);\n-    // { dg-message \"returned from a call to 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'int\\\\\\* my_array_new\\\\\\(size_t\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     p = realloc (p, 123);\n     // { dg-warning \"'void\\\\\\* realloc\\\\\\(void\\\\\\*, size_t\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }"}, {"sha": "d0d53b38b93891fa5bce59ead6de2d83be5c7642", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-new-delete-2.C", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete-2.C?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,249 @@\n+/* Verify that implicit and explicit calls to member operator new and delete\n+   are handled correctly.\n+   { dg-do compile }\n+   { dg-options \"-Wmismatched-new-delete\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+namespace std\n+{\n+#if __cplusplus >= 201703L\n+enum class align_val_t: size_t { };\n+#else\n+enum align_val_t { };\n+#endif\n+\n+struct nothrow_t { };\n+const nothrow_t nothrow = { };\n+}\n+\n+void sink (void*, ...);\n+\n+struct POD\n+{\n+  void* operator new (size_t);\n+  void operator delete (void*);\n+\n+  void* operator new[] (size_t);\n+  void operator delete[] (void*);\n+};\n+\n+POD* nowarn_pod ()\n+{\n+  POD *p = new POD;\n+  delete p;\n+  return new POD;\n+}\n+\n+void warn_pod_array_mismatch ()\n+{\n+  POD *p = new POD;\n+  delete[] p;                 // { dg-warning \"'static void POD::operator delete \\\\\\[]\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+  p = new POD[3];\n+  delete p;                   // { dg-warning \"'static void POD::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+}\n+\n+\n+struct X1\n+{\n+  X1 ();\n+\n+  void* operator new (size_t);\n+  void* operator new (size_t, std::align_val_t);\n+  void* operator new (size_t, std::nothrow_t) throw ();\n+  void* operator new (size_t, std::align_val_t, std::nothrow_t) throw ();\n+\n+  void* operator new[] (size_t);\n+  void* operator new[] (size_t, std::align_val_t);\n+  void* operator new[] (size_t, std::nothrow_t) throw ();\n+  void* operator new[] (size_t, std::align_val_t, std::nothrow_t) throw ();\n+\n+  void operator delete (void*);\n+  void operator delete (void*, size_t);\n+  void operator delete (void*, std::align_val_t);\n+  void operator delete (void*, size_t, std::align_val_t);\n+  void operator delete (void*, std::nothrow_t) throw ();\n+  void operator delete (void*, std::align_val_t, std::nothrow_t) throw ();\n+\n+  void operator delete[] (void*);\n+  void operator delete[] (void*, size_t);\n+  void operator delete[] (void*, std::align_val_t);\n+  void operator delete[] (void*, size_t, std::align_val_t);\n+  void operator delete[] (void*, std::nothrow_t) throw ();\n+  void operator delete[] (void*, std::align_val_t, std::nothrow_t) throw ();\n+};\n+\n+X1* nowarn_x1 ()\n+{\n+  return new X1;\n+}\n+\n+X1* nowarn_x1_array ()\n+{\n+  return new X1[2];\n+}\n+\n+X1* nowarn_align_val ()\n+{\n+  X1 *p = new (std::align_val_t (32)) X1;\n+  delete p;\n+  return new (std::align_val_t (64)) X1;\n+}\n+\n+X1* nowarn_align_val_array ()\n+{\n+  X1 *p = new (std::align_val_t (32)) X1[2];\n+  delete[] p;\n+  return new (std::align_val_t (64)) X1[2];\n+}\n+\n+X1* nowarn_x1_nothrow ()\n+{\n+  X1 *p = new (std::nothrow) X1;\n+  delete p;\n+  return new (std::nothrow) X1;\n+}\n+\n+X1* nowarn_x1_nothrow_array ()\n+{\n+  X1 *p = new (std::nothrow) X1[3];\n+  delete[] p;\n+  return new (std::nothrow) X1[3];\n+}\n+\n+X1* nowarn_align_val_nothrow ()\n+{\n+  X1 *p = new (std::align_val_t (32), std::nothrow) X1;\n+  delete p;\n+  return new (std::align_val_t (64), std::nothrow) X1;\n+}\n+\n+X1* nowarn_align_val_nothrow_array ()\n+{\n+  X1 *p = new (std::align_val_t (32), std::nothrow) X1[4];\n+  delete[] p;\n+  return new (std::align_val_t (64), std::nothrow) X1[4];\n+}\n+\n+void warn_x1_array_mismatch ()\n+{\n+  {\n+    X1 *p = new X1;\n+    delete[] p;               // { dg-warning \"'static void X1::operator delete \\\\\\[]\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+  }\n+  {\n+    X1 *p = new X1[2];\n+    delete p;                 // { dg-warning \"'static void X1::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+  }\n+  {\n+    X1 *p = new (std::align_val_t (32)) X1[2];\n+    delete p;                 // { dg-warning \"'static void X1::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+  }\n+  {\n+    // The following requires optimization (see warn_x1_array_mismatch()).\n+    X1 *p = new (std::nothrow) X1[3];\n+    delete p;                 // { dg-warning \"'static void X1::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" \"pr?????\" { xfail *-*-* } }\n+  }\n+}\n+\n+#pragma GCC push_options\n+#pragma GCC optimize \"1\"\n+\n+void warn_x1_nothrow_array_mismatch ()\n+{\n+  X1 *p = new (std::nothrow) X1[3];\n+  delete p;                   // { dg-warning \"'static void X1::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+}\n+\n+#pragma GCC pop_options\n+\n+\n+struct X2: X1\n+{\n+  X2 ();\n+\n+  void* operator new (size_t);\n+  void operator delete (void*);\n+};\n+\n+X2* nowarn_x2 ()\n+{\n+  X2 *p = new X2;\n+  sink (p);\n+  return new X2;\n+}\n+\n+void warn_x2 ()\n+{\n+  X1 *p = new X2;             // { dg-message \"returned from 'static void\\\\* X2::operator new\\\\(size_t\\\\)'\" \"note\" }\n+  sink (p);\n+  delete p;                   // { dg-warning \"'static void X1::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+}\n+\n+namespace N {\n+namespace NS {\n+namespace NmSpc {\n+namespace NameSpace {\n+\n+namespace dl {   // same name as operator delete\n+namespace nw {   // and as operator new\n+\n+struct X3: X2\n+{\n+  X3 ();\n+\n+  void* operator new (size_t);\n+  void operator delete (void*);\n+};\n+\n+X3* nowarn_x3 ()\n+{\n+  X3 *p = new X3;\n+  sink (p);\n+  return new X3;\n+}\n+\n+void warn_x3 ()\n+{\n+  X1 *p = new X3;             // { dg-message \"returned from 'static void\\\\* N::NS::NmSpc::NameSpace::dl::nw::X3::operator new\\\\(size_t\\\\)'\" \"note\" }\n+  sink (p);\n+  delete p;                   // { dg-warning \"'static void X1::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+}\n+\n+template <int N>\n+struct X4: X2\n+{\n+  X4 ();\n+\n+  void* operator new (size_t);\n+  void operator delete (void*);\n+};\n+\n+void* nowarn_x4 ()\n+{\n+  X4<0> *p = new X4<0>;\n+  sink (p);\n+  return new X4<1>;\n+}\n+\n+void warn_x4 ()\n+{\n+  X1 *p = new X4<1>;          // { dg-message \"returned from 'static void\\\\* N::NS::NmSpc::NameSpace::dl::nw::X4<N>::operator new\\\\(size_t\\\\) \\\\\\[with int N = 1]'\" \"note\" }\n+  sink (p);\n+  delete p;                   // { dg-warning \"'static void X1::operator delete\\\\(void\\\\*\\\\)' called on pointer returned from a mismatched allocation function\" }\n+}\n+\n+void warn_x4_inst_mismatch ()\n+{\n+  void *p = new X4<2>;        // { dg-message \"returned from 'static void\\\\* N::NS::NmSpc::NameSpace::dl::nw::X4<N>::operator new\\\\(size_t\\\\) \\\\\\[with int N = 2]'\" \"note\" }\n+  sink (p);\n+  X4<3> *q = (X4<3>*)p;\n+  delete q;                   // { dg-warning \"'static void N::NS::NmSpc::NameSpace::dl::nw::X4<N>::operator delete\\\\(void\\\\*\\\\) \\\\\\[with int N = 3]' called on pointer returned from a mismatched allocation function\" }\n+}\n+\n+}   // nw\n+}   // dl\n+}   // NameSpace\n+}   // NmSpc\n+}   // NS\n+}   // N"}, {"sha": "fc07149995de4bc6671310d204cc351013922926", "filename": "gcc/testsuite/g++.dg/warn/Wmismatched-new-delete.C", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWmismatched-new-delete.C?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -44,14 +44,14 @@ void warn_new_free (int n)\n {\n   {\n     void *p = operator new (n);\n-    // { dg-message \"returned from a call to 'void\\\\\\* operator new\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* operator new\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     free (p);\n     // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n   }\n   {\n     char *p = new char[n];\n-    // { dg-message \"returned from a call to 'void\\\\\\* operator new \\\\\\[\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* operator new \\\\\\[\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     free (p);\n     // { dg-warning \"'void free\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n@@ -66,15 +66,15 @@ void warn_new_realloc (int n)\n {\n   {\n     void *p = operator new (n);\n-    // { dg-message \"returned from a call to 'void\\\\\\* operator new\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* operator new\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     p = realloc (p, n * 2);\n     // { dg-warning \"'void\\\\\\* realloc\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n     sink (p);\n   }\n   {\n     void *p = new char[n];\n-    // { dg-message \"returned from a call to 'void\\\\\\* operator new \\\\\\[\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* operator new \\\\\\[\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     p = realloc (p, n * 2);\n     // { dg-warning \"'void\\\\\\* realloc\\\\\\(\\[^)\\]+\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n@@ -89,21 +89,21 @@ void warn_new_realloc (int n)\n void warn_malloc_op_delete (int n)\n {\n   char *p = (char *)malloc (n);\n-  // { dg-message \"returned from a call to 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+  // { dg-message \"returned from 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n   sink (p);\n   operator delete (p);\n   // { dg-warning \"'void operator delete\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n }\n \n \n /* Verify a warning for an invocation of either form of the delete\n-   expression with a pointer returned from a call to malloc().  */\n+   expression with a pointer returned from malloc().  */\n \n void warn_malloc_delete (int n)\n {\n   {\n     char *p = (char *)malloc (n);\n-    // { dg-message \"returned from a call to 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     /* C++98 calls operator delete (void*) but later versions call\n        operator delete (void*, size_t).  The difference doesn't matter\n@@ -114,7 +114,7 @@ void warn_malloc_delete (int n)\n \n   {\n     char *p = (char *)malloc (n);\n-    // { dg-message \"returned from a call to 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* malloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (p);\n     delete[] p;\n     // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n@@ -123,13 +123,13 @@ void warn_malloc_delete (int n)\n \n \n /* Verify a warning for an invocation of either form of the delete\n-   expression with a pointer returned from a call to realloc().  */\n+   expression with a pointer returned from realloc().  */\n \n void warn_realloc_delete (void *p1, void *p2, int n)\n {\n   {\n     char *q = (char *)realloc (p1, n);\n-    // { dg-message \"returned from a call to 'void\\\\\\* realloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* realloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (q);\n     /* C++98 calls operator delete (void*) but later versions call\n        operator delete (void*, size_t).  The difference doesn't matter\n@@ -140,7 +140,7 @@ void warn_realloc_delete (void *p1, void *p2, int n)\n \n   {\n     char *q = (char *)realloc (p2, n);\n-    // { dg-message \"returned from a call to 'void\\\\\\* realloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'void\\\\\\* realloc\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (q);\n     delete[] q;\n     // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n@@ -149,13 +149,13 @@ void warn_realloc_delete (void *p1, void *p2, int n)\n \n \n /* Verify a warning for an invocation of either form of the delete\n-   expression with a pointer returned from a call to strdup().  */\n+   expression with a pointer returned from strdup().  */\n \n void warn_strdup_delete (const char *s1, const char *s2)\n {\n   {\n     char *q = strdup (s1);\n-    // { dg-message \"returned from a call to 'char\\\\\\* strdup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'char\\\\\\* strdup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (q);\n     /* C++98 calls operator delete (void*) but later versions call\n        operator delete (void*, size_t).  The difference doesn't matter\n@@ -166,7 +166,7 @@ void warn_strdup_delete (const char *s1, const char *s2)\n \n   {\n     char *q = strdup (s2);\n-    // { dg-message \"returned from a call to 'char\\\\\\* strdup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'char\\\\\\* strdup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (q);\n     delete[] q;\n     // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }\n@@ -176,13 +176,13 @@ void warn_strdup_delete (const char *s1, const char *s2)\n \n \n /* Verify a warning for an invocation of either form of the delete\n-   expression with a pointer returned from a call to strndup().  */\n+   expression with a pointer returned from strndup().  */\n \n void warn_strdup_delete (const char *s1, const char *s2, size_t n)\n {\n   {\n     char *q = strndup (s1, n);\n-    // { dg-message \"returned from a call to 'char\\\\\\* strndup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'char\\\\\\* strndup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (q);\n     /* C++98 calls operator delete (void*) but later versions call\n        operator delete (void*, size_t).  The difference doesn't matter\n@@ -193,7 +193,7 @@ void warn_strdup_delete (const char *s1, const char *s2, size_t n)\n \n   {\n     char *q = strndup (s2, n);\n-    // { dg-message \"returned from a call to 'char\\\\\\* strndup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n+    // { dg-message \"returned from 'char\\\\\\* strndup\\\\\\(\" \"note\" { target *-*-* } .-1 }\n     sink (q);\n     delete[] q;\n     // { dg-warning \"'void operator delete \\\\\\[]\\\\\\(void\\\\\\*\\\\\\)' called on pointer returned from a mismatched allocation function\" \"\" { target *-*-* } .-1 }"}, {"sha": "21a5ea7c5dab3289d99d89e1074df532cbc7a681", "filename": "gcc/testsuite/gcc.dg/Wmismatched-dealloc-2.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-2.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,141 @@\n+/* PR middle-end/94527 - Add an attribute that marks a function as freeing\n+   an object\n+   Verify that attribute malloc with one or two arguments has the expected\n+   effect on diagnostics.\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" } */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__), noipa))\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef struct A A;\n+typedef struct B B;\n+\n+/* A pointer returned by any of the four functions must be deallocated\n+   either by dealloc() or by realloc_{A,B}().  */\n+A (__builtin_free) A* alloc_A (int);\n+A (__builtin_free) B* alloc_B (int);\n+A (__builtin_free) A* realloc_A (A *p, int n) { return p; }\n+A (__builtin_free) B* realloc_B (B *p, int n) { return p; }\n+\n+A (realloc_A) A* alloc_A (int);\n+A (realloc_B) B* alloc_B (int);\n+A (realloc_A) A* realloc_A (A*, int);\n+A (realloc_B) B* realloc_B (B*, int);\n+\n+void dealloc (void*);\n+A (dealloc) void* alloc (int);\n+\n+void sink (void*);\n+\n+void test_alloc_A (void)\n+{\n+  {\n+    void *p = alloc_A (1);\n+    p = realloc_A (p, 2);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    void *p = alloc_A (1);\n+    /* Verify that calling realloc doesn't trigger a warning even though\n+       alloc_A is not directly associated with it.  */\n+    p = __builtin_realloc (p, 2);\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = alloc_A (1);              // { dg-message \"returned from 'alloc_A'\" }\n+    dealloc (p);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    /* Because alloc_A() and realloc_B() share free() as a deallocator\n+       they must also be valid as each other's deallocators.  */\n+    void *p = alloc_A (1);\n+    p = realloc_B ((B*)p, 2);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    void *p = alloc_A (1);\n+    p = realloc_A (p, 2);\n+    p = __builtin_realloc (p, 3);\n+    __builtin_free (p);\n+  }\n+}\n+\n+\n+void test_realloc_A (void *ptr)\n+{\n+  {\n+    void *p = realloc_A (0, 1);\n+    p = realloc_A (p, 2);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    void *p = realloc_A (ptr, 2);\n+    p = realloc_A (p, 2);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    void *p = realloc_A (0, 3);\n+    p = __builtin_realloc (p, 2);\n+    sink (p);\n+  }\n+\n+  {\n+    void *p = realloc_A (0, 4);         // { dg-message \"returned from 'realloc_A'\" }\n+    dealloc (p);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    /* Because realloc_A() and realloc_B() share free() as a deallocator\n+       they must also be valid as each other's deallocators.  */\n+    void *p = realloc_A (0, 5);\n+    p = realloc_B ((B*)p, 2);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    void *p = realloc_A (0, 6);\n+    p = realloc_A ((A*)p, 2);\n+    p = __builtin_realloc (p, 3);\n+    __builtin_free (p);\n+  }\n+}\n+\n+\n+void test_realloc (void *ptr)\n+{\n+  extern void free (void*);\n+  extern void* realloc (void*, size_t);\n+\n+  {\n+    void *p = realloc (ptr, 1);\n+    p = realloc_A (p, 2);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    void *p = realloc (ptr, 2);\n+    p = realloc_A (p, 2);\n+    free (p);\n+  }\n+\n+  {\n+    void *p = realloc (ptr, 3);\n+    free (p);\n+  }\n+\n+  {\n+    void *p = realloc (ptr, 4);\n+    __builtin_free (p);\n+  }\n+\n+  {\n+    void *p = realloc (ptr, 5);         // { dg-message \"returned from 'realloc'\" }\n+    dealloc (p);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}"}, {"sha": "5afcea39b5e5ca0497432ba841935d3ae4726646", "filename": "gcc/testsuite/gcc.dg/Wmismatched-dealloc-3.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc-3.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -0,0 +1,265 @@\n+/* Verify that Glibc <stdlib.h> declarations are handled correctly\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__), noipa))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+/* All functions with the same standard deallocator are associated\n+   with each other.  */\n+void free (void*);\n+void* calloc (size_t, size_t);\n+void* malloc (size_t);\n+void* realloc (void*, size_t);\n+\n+A (__builtin_free) void* aligned_alloc (size_t, size_t);\n+\n+/* Like realloc(), reallocarray() is both an allocator and a deallocator.\n+   It must be associated with both free() and with itself, but nothing\n+   else.  */\n+A (__builtin_free) void* reallocarray (void*, size_t, size_t);\n+A (reallocarray) void* reallocarray (void*, size_t, size_t);\n+\n+A (__builtin_free) extern char *canonicalize_file_name (const char*);\n+\n+\n+void dealloc (void*);\n+A (dealloc) void* alloc (size_t);\n+\n+\n+void sink (void*);\n+void* source (void);\n+\n+\n+void test_builtin_aligned_alloc (void *p)\n+{\n+  {\n+    void *q = __builtin_aligned_alloc (1, 2);\n+    sink (q);\n+    __builtin_free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_aligned_alloc (1, 2);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_aligned_alloc (1, 2);\n+    q = __builtin_realloc (q, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_aligned_alloc (1, 2);\n+    q = realloc (q, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q;\n+    q = __builtin_aligned_alloc (1, 2); // { dg-message \"returned from '__builtin_aligned_alloc'\" }\n+    sink (q);\n+    dealloc (q);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void test_aligned_alloc (void *p)\n+{\n+  {\n+    void *q = aligned_alloc (1, 2);\n+    sink (q);\n+    __builtin_free (q);\n+  }\n+\n+  {\n+    void *q = aligned_alloc (1, 2);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = aligned_alloc (1, 2);\n+    q = __builtin_realloc (q, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = aligned_alloc (1, 2);\n+    q = realloc (q, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = aligned_alloc (1, 2);     // { dg-message \"returned from 'aligned_alloc'\" }\n+    sink (q);\n+    dealloc (q);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void test_reallocarray (void *p)\n+{\n+  {\n+    void *q = __builtin_aligned_alloc (1, 2);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = aligned_alloc (1, 2);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_calloc (1, 2);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = calloc (1, 2);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_malloc (1);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = malloc (1);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_realloc (p, 1);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = realloc (p, 1);\n+    q = reallocarray (q, 2, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_strdup (\"abc\");\n+    q = reallocarray (q, 3, 4);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = __builtin_strndup (\"abcd\", 3);\n+    q = reallocarray (q, 4, 5);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = source ();\n+    q = reallocarray (q, 5, 6);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = alloc (1);                // { dg-message \"returned from 'alloc'\" }\n+    q = reallocarray (q, 6, 7);         // { dg-warning \"'reallocarray' called on pointer returned from a mismatched allocation function\" }\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = reallocarray (p, 7, 8);\n+    q = __builtin_realloc (q, 9);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = reallocarray (p, 7, 8);\n+    q = realloc (q, 9);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = reallocarray (p, 8, 9);\n+    q = reallocarray (q, 3, 4);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = reallocarray (p, 9, 10);\n+    q = reallocarray (q, 3, 4);\n+    sink (q);\n+    dealloc (q);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void test_canonicalize_filename (void *p)\n+{\n+  {\n+    void *q = canonicalize_file_name (\"a\");\n+    sink (q);\n+    __builtin_free (q);\n+  }\n+\n+  {\n+    void *q = canonicalize_file_name (\"b\");\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = canonicalize_file_name (\"c\");\n+    q = __builtin_realloc (q, 2);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = canonicalize_file_name (\"d\");\n+    q = realloc (q, 3);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q = canonicalize_file_name (\"e\");\n+    q = reallocarray (q, 4, 5);\n+    sink (q);\n+    free (q);\n+  }\n+\n+  {\n+    void *q;\n+    q = canonicalize_file_name (\"f\");   // { dg-message \"returned from 'canonicalize_file_name'\" }\n+    sink (q);\n+    dealloc (q);                        // { dg-warning \"'dealloc' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}"}, {"sha": "6336efa559492403c20fb9d261a71588d4be3998", "filename": "gcc/testsuite/gcc.dg/Wmismatched-dealloc.c", "status": "modified", "additions": 119, "deletions": 44, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWmismatched-dealloc.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -13,28 +13,27 @@ void  free (void*);\n void* malloc (size_t);\n void* realloc (void*, size_t);\n \n-int   fclose (FILE*);\n-FILE* freopen (const char*, const char*, FILE*);\n-int   pclose (FILE*);\n-\n-A (fclose) A (freopen, 3)\n-  FILE* fdopen (int);\n-A (fclose) A (freopen, 3)\n-  FILE* fopen (const char*, const char*);\n-A (fclose) A (freopen, 3)\n-  FILE* fmemopen(void *, size_t, const char *);\n-A (fclose) A (freopen, 3)\n-  FILE* freopen (const char*, const char*, FILE*);\n-A (pclose) A (freopen, 3)\n-  FILE* popen (const char*, const char*);\n-A (fclose) A (freopen, 3)\n-  FILE* tmpfile (void);\n+/* Declare functions with the minimum attributes malloc how they're\n+   likely going to be declared in <stdio.h>.  */\n+               int   fclose (FILE*);\n+A (fclose)     FILE* fdopen (int);\n+A (fclose)     FILE* fopen (const char*, const char*);\n+A (fclose)     FILE* fmemopen(void *, size_t, const char *);\n+A (fclose)     FILE* freopen (const char*, const char*, FILE*);\n+A (freopen, 3) FILE* freopen (const char*, const char*, FILE*);\n+A (fclose)     FILE* tmpfile (void);\n \n-void sink (FILE*);\n+A (fclose)     FILE* open_memstream (char**, size_t*);\n+A (fclose)     FILE* open_wmemstream (char**, size_t*);\n+\n+               int   pclose (FILE*);\n+A (pclose)     FILE* popen (const char*, const char*);\n \n+               void  release (void*);\n+A (release)    FILE* acquire (void);\n+\n+void sink (FILE*);\n \n-            void  release (void*);\n-A (release) FILE* acquire (void);\n \n void nowarn_fdopen (void)\n {\n@@ -68,18 +67,18 @@ void nowarn_fdopen (void)\n void warn_fdopen (void)\n {\n   {\n-    FILE *q = fdopen (0);     // { dg-message \"returned from a call to 'fdopen'\" \"note\" }\n+    FILE *q = fdopen (0);     // { dg-message \"returned from 'fdopen'\" \"note\" }\n     sink (q);\n     release (q);              // { dg-warning \"'release' called on pointer returned from a mismatched allocation function\" }\n   }\n   {\n-    FILE *q = fdopen (0);     // { dg-message \"returned from a call to 'fdopen'\" \"note\" }\n+    FILE *q = fdopen (0);     // { dg-message \"returned from 'fdopen'\" \"note\" }\n     sink (q);\n     free (q);                 // { dg-warning \"'free' called on pointer returned from a mismatched allocation function\" }\n   }\n \n   {\n-    FILE *q = fdopen (0);     // { dg-message \"returned from a call to 'fdopen'\" \"note\" }\n+    FILE *q = fdopen (0);     // { dg-message \"returned from 'fdopen'\" \"note\" }\n     sink (q);\n     q = realloc (q, 7);       // { dg-warning \"'realloc' called on pointer returned from a mismatched allocation function\" }\n     sink (q);\n@@ -132,73 +131,149 @@ void warn_fopen (void)\n }\n \n \n-void test_popen (void)\n+void test_freopen (FILE *p[])\n {\n   {\n-    FILE *p = popen (\"1\", \"r\");\n+    FILE *q = freopen (\"1\", \"r\", p[0]);\n+    sink (q);\n+    fclose (q);\n+  }\n+  {\n+    FILE *q = freopen (\"2\", \"r\", p[1]);\n+    sink (q);\n+    q = freopen (\"3\", \"r\", q);\n+    sink (q);\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q;\n+    q = freopen (\"3\", \"r\", p[2]); // { dg-message \"returned from 'freopen'\" }\n+    sink (q);\n+    q = realloc (q, 7);       // { dg-warning \"'realloc' called on pointer returned from a mismatched allocation function\" }\n+    sink (q);\n+  }\n+}\n+\n+\n+void test_tmpfile (void)\n+{\n+  {\n+    FILE *p = tmpfile ();\n     sink (p);\n-    pclose (p);\n+    fclose (p);\n   }\n \n   {\n-    FILE *p;\n-    p = popen (\"2\", \"r\");     // { dg-message \"returned from a call to 'popen'\" \"note\" }\n+    FILE *p = tmpfile ();\n     sink (p);\n-    fclose (p);               // { dg-warning \"'fclose' called on pointer returned from a mismatched allocation function\" }\n+    p = freopen (\"1\", \"r\", p);\n+    sink (p);\n+    fclose (p);\n   }\n \n   {\n-    /* freopen() can close a stream open by popen() but pclose() can't\n-       close the stream returned from freopen().  */\n-    FILE *p = popen (\"2\", \"r\");\n+    FILE *p = tmpfile ();     // { dg-message \"returned from 'tmpfile'\" \"note\" }\n     sink (p);\n-    p = freopen (\"3\", \"r\", p);  // { dg-message \"returned from a call to 'freopen'\" \"note\" }\n+    pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void test_open_memstream (char **bufp, size_t *sizep)\n+{\n+  {\n+    FILE *p = open_memstream (bufp, sizep);\n+    sink (p);\n+    fclose (p);\n+  }\n+\n+  {\n+    FILE *p = open_memstream (bufp, sizep);\n+    sink (p);\n+    p = freopen (\"1\", \"r\", p);\n+    sink (p);\n+    fclose (p);\n+  }\n+\n+  {\n+    FILE *p;\n+    p = open_memstream (bufp, sizep);   // { dg-message \"returned from 'open_memstream'\" \"note\" }\n     sink (p);\n     pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n   }\n+\n+  {\n+    FILE *p;\n+    p = open_memstream (bufp, sizep);   // { dg-message \"returned from 'open_memstream'\" \"note\" }\n+    sink (p);\n+    free (p);                 // { dg-warning \"'free' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *p;\n+    p = open_memstream (bufp, sizep);   // { dg-message \"returned from 'open_memstream'\" \"note\" }\n+    sink (p);\n+    release (p);              // { dg-warning \"'release' called on pointer returned from a mismatched allocation function\" }\n+  }\n }\n \n \n-void test_tmpfile (void)\n+void test_open_wmemstream (char **bufp, size_t *sizep)\n {\n   {\n-    FILE *p = tmpfile ();\n+    FILE *p = open_wmemstream (bufp, sizep);\n     sink (p);\n     fclose (p);\n   }\n \n   {\n-    FILE *p = tmpfile ();\n+    FILE *p = open_wmemstream (bufp, sizep);\n     sink (p);\n     p = freopen (\"1\", \"r\", p);\n     sink (p);\n     fclose (p);\n   }\n \n   {\n-    FILE *p = tmpfile ();     // { dg-message \"returned from a call to 'tmpfile'\" \"note\" }\n+    FILE *p;\n+    p = open_wmemstream (bufp, sizep);  // { dg-message \"returned from 'open_wmemstream'\" \"note\" }\n     sink (p);\n     pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n   }\n+\n+  {\n+    FILE *p;\n+    p = open_wmemstream (bufp, sizep);  // { dg-message \"returned from 'open_wmemstream'\" \"note\" }\n+    sink (p);\n+    free (p);                 // { dg-warning \"'free' called on pointer returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *p;\n+    p = open_wmemstream (bufp, sizep);  // { dg-message \"returned from 'open_wmemstream'\" \"note\" }\n+    sink (p);\n+    release (p);              // { dg-warning \"'release' called on pointer returned from a mismatched allocation function\" }\n+  }\n }\n \n \n void warn_malloc (void)\n {\n   {\n-    FILE *p = malloc (100);   // { dg-message \"returned from a call to 'malloc'\" \"note\" }\n+    FILE *p = malloc (100);   // { dg-message \"returned from 'malloc'\" \"note\" }\n     sink (p);\n     fclose (p);               // { dg-warning \"'fclose' called on pointer returned from a mismatched allocation function\" }\n   }\n \n   {\n-    FILE *p = malloc (100);   // { dg-message \"returned from a call to 'malloc'\" \"note\" }\n+    FILE *p = malloc (100);   // { dg-message \"returned from 'malloc'\" \"note\" }\n     sink (p);\n     p = freopen (\"1\", \"r\", p);// { dg-warning \"'freopen' called on pointer returned from a mismatched allocation function\" }\n   }\n \n   {\n-    FILE *p = malloc (100);   // { dg-message \"returned from a call to 'malloc'\" \"note\" }\n+    FILE *p = malloc (100);   // { dg-message \"returned from 'malloc'\" \"note\" }\n     sink (p);\n     pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n   }\n@@ -219,32 +294,32 @@ void test_acquire (void)\n   }\n \n   {\n-    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    FILE *p = acquire ();     // { dg-message \"returned from 'acquire'\" \"note\" }\n     sink (p);\n     fclose (p);               // { dg-warning \"'fclose' called on pointer returned from a mismatched allocation function\" }\n   }\n \n   {\n-    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    FILE *p = acquire ();     // { dg-message \"returned from 'acquire'\" \"note\" }\n     sink (p);\n     pclose (p);               // { dg-warning \"'pclose' called on pointer returned from a mismatched allocation function\" }\n   }\n \n   {\n-    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    FILE *p = acquire ();     // { dg-message \"returned from 'acquire'\" \"note\" }\n     sink (p);\n     p = freopen (\"1\", \"r\", p);  // { dg-warning \"'freopen' called on pointer returned from a mismatched allocation function\" }\n     sink (p);\n   }\n \n   {\n-    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    FILE *p = acquire ();     // { dg-message \"returned from 'acquire'\" \"note\" }\n     sink (p);\n     free (p);               // { dg-warning \"'free' called on pointer returned from a mismatched allocation function\" }\n   }\n \n   {\n-    FILE *p = acquire ();     // { dg-message \"returned from a call to 'acquire'\" \"note\" }\n+    FILE *p = acquire ();     // { dg-message \"returned from 'acquire'\" \"note\" }\n     sink (p);\n     p = realloc (p, 123);     // { dg-warning \"'realloc' called on pointer returned from a mismatched allocation function\" }\n     sink (p);"}, {"sha": "5ec872967b7747524215403a9e9631be29e46808", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -656,67 +656,7 @@ valid_new_delete_pair_p (gimple *new_call, gimple *delete_call)\n {\n   tree new_asm = DECL_ASSEMBLER_NAME (gimple_call_fndecl (new_call));\n   tree delete_asm = DECL_ASSEMBLER_NAME (gimple_call_fndecl (delete_call));\n-  const char *new_name = IDENTIFIER_POINTER (new_asm);\n-  const char *delete_name = IDENTIFIER_POINTER (delete_asm);\n-  unsigned int new_len = IDENTIFIER_LENGTH (new_asm);\n-  unsigned int delete_len = IDENTIFIER_LENGTH (delete_asm);\n-\n-  if (new_len < 5 || delete_len < 6)\n-    return false;\n-  if (new_name[0] == '_')\n-    ++new_name, --new_len;\n-  if (new_name[0] == '_')\n-    ++new_name, --new_len;\n-  if (delete_name[0] == '_')\n-    ++delete_name, --delete_len;\n-  if (delete_name[0] == '_')\n-    ++delete_name, --delete_len;\n-  if (new_len < 4 || delete_len < 5)\n-    return false;\n-  /* *_len is now just the length after initial underscores.  */\n-  if (new_name[0] != 'Z' || new_name[1] != 'n')\n-    return false;\n-  if (delete_name[0] != 'Z' || delete_name[1] != 'd')\n-    return false;\n-  /* _Znw must match _Zdl, _Zna must match _Zda.  */\n-  if ((new_name[2] != 'w' || delete_name[2] != 'l')\n-      && (new_name[2] != 'a' || delete_name[2] != 'a'))\n-    return false;\n-  /* 'j', 'm' and 'y' correspond to size_t.  */\n-  if (new_name[3] != 'j' && new_name[3] != 'm' && new_name[3] != 'y')\n-    return false;\n-  if (delete_name[3] != 'P' || delete_name[4] != 'v')\n-    return false;\n-  if (new_len == 4\n-      || (new_len == 18 && !memcmp (new_name + 4, \"RKSt9nothrow_t\", 14)))\n-    {\n-      /* _ZnXY or _ZnXYRKSt9nothrow_t matches\n-\t _ZdXPv, _ZdXPvY and _ZdXPvRKSt9nothrow_t.  */\n-      if (delete_len == 5)\n-\treturn true;\n-      if (delete_len == 6 && delete_name[5] == new_name[3])\n-\treturn true;\n-      if (delete_len == 19 && !memcmp (delete_name + 5, \"RKSt9nothrow_t\", 14))\n-\treturn true;\n-    }\n-  else if ((new_len == 19 && !memcmp (new_name + 4, \"St11align_val_t\", 15))\n-\t   || (new_len == 33\n-\t       && !memcmp (new_name + 4, \"St11align_val_tRKSt9nothrow_t\", 29)))\n-    {\n-      /* _ZnXYSt11align_val_t or _ZnXYSt11align_val_tRKSt9nothrow_t matches\n-\t _ZdXPvSt11align_val_t or _ZdXPvYSt11align_val_t or  or\n-\t _ZdXPvSt11align_val_tRKSt9nothrow_t.  */\n-      if (delete_len == 20 && !memcmp (delete_name + 5, \"St11align_val_t\", 15))\n-\treturn true;\n-      if (delete_len == 21\n-\t  && delete_name[5] == new_name[3]\n-\t  && !memcmp (delete_name + 6, \"St11align_val_t\", 15))\n-\treturn true;\n-      if (delete_len == 34\n-\t  && !memcmp (delete_name + 5, \"St11align_val_tRKSt9nothrow_t\", 29))\n-\treturn true;\n-    }\n-  return false;\n+  return valid_new_delete_pair_p (new_asm, delete_asm);\n }\n \n /* Propagate necessity using the operands of necessary statements."}, {"sha": "5fd9da3ab966c7bae7739b59d28b55706a7463ec", "filename": "gcc/tree.c", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -12610,8 +12610,40 @@ tree_nonartificial_location (tree exp)\n     return EXPR_LOCATION (exp);\n }\n \n+/* Return the location into which EXP has been inlined.  Analogous\n+   to tree_nonartificial_location() above but not limited to artificial\n+   functions declared inline.  If SYSTEM_HEADER is true, return\n+   the macro expansion point of the location if it's in a system header */\n \n-/* These are the hash table functions for the hash table of OPTIMIZATION_NODEq\n+location_t\n+tree_inlined_location (tree exp, bool system_header /* = true */)\n+{\n+  location_t loc = UNKNOWN_LOCATION;\n+\n+  tree block = TREE_BLOCK (exp);\n+\n+  while (block && TREE_CODE (block) == BLOCK\n+\t && BLOCK_ABSTRACT_ORIGIN (block))\n+    {\n+      tree ao = BLOCK_ABSTRACT_ORIGIN (block);\n+      if (TREE_CODE (ao) == FUNCTION_DECL)\n+\tloc = BLOCK_SOURCE_LOCATION (block);\n+      else if (TREE_CODE (ao) != BLOCK)\n+\tbreak;\n+\n+      block = BLOCK_SUPERCONTEXT (block);\n+    }\n+\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = EXPR_LOCATION (exp);\n+\n+  if (system_header)\n+    return expansion_point_location_if_in_system_header (loc);\n+\n+  return loc;\n+}\n+\n+/* These are the hash table functions for the hash table of OPTIMIZATION_NODE\n    nodes.  */\n \n /* Return the hash code X, an OPTIMIZATION_NODE or TARGET_OPTION code.  */\n@@ -15386,6 +15418,75 @@ verify_type_context (location_t loc, type_context_kind context,\n \t  || targetm.verify_type_context (loc, context, type, silent_p));\n }\n \n+/* Return that NEW_ASM and DELETE_ASM name a valid pair of new and\n+   delete operators.  */\n+\n+bool\n+valid_new_delete_pair_p (tree new_asm, tree delete_asm)\n+{\n+  const char *new_name = IDENTIFIER_POINTER (new_asm);\n+  const char *delete_name = IDENTIFIER_POINTER (delete_asm);\n+  unsigned int new_len = IDENTIFIER_LENGTH (new_asm);\n+  unsigned int delete_len = IDENTIFIER_LENGTH (delete_asm);\n+\n+  if (new_len < 5 || delete_len < 6)\n+    return false;\n+  if (new_name[0] == '_')\n+    ++new_name, --new_len;\n+  if (new_name[0] == '_')\n+    ++new_name, --new_len;\n+  if (delete_name[0] == '_')\n+    ++delete_name, --delete_len;\n+  if (delete_name[0] == '_')\n+    ++delete_name, --delete_len;\n+  if (new_len < 4 || delete_len < 5)\n+    return false;\n+  /* *_len is now just the length after initial underscores.  */\n+  if (new_name[0] != 'Z' || new_name[1] != 'n')\n+    return false;\n+  if (delete_name[0] != 'Z' || delete_name[1] != 'd')\n+    return false;\n+  /* _Znw must match _Zdl, _Zna must match _Zda.  */\n+  if ((new_name[2] != 'w' || delete_name[2] != 'l')\n+      && (new_name[2] != 'a' || delete_name[2] != 'a'))\n+    return false;\n+  /* 'j', 'm' and 'y' correspond to size_t.  */\n+  if (new_name[3] != 'j' && new_name[3] != 'm' && new_name[3] != 'y')\n+    return false;\n+  if (delete_name[3] != 'P' || delete_name[4] != 'v')\n+    return false;\n+  if (new_len == 4\n+      || (new_len == 18 && !memcmp (new_name + 4, \"RKSt9nothrow_t\", 14)))\n+    {\n+      /* _ZnXY or _ZnXYRKSt9nothrow_t matches\n+\t _ZdXPv, _ZdXPvY and _ZdXPvRKSt9nothrow_t.  */\n+      if (delete_len == 5)\n+\treturn true;\n+      if (delete_len == 6 && delete_name[5] == new_name[3])\n+\treturn true;\n+      if (delete_len == 19 && !memcmp (delete_name + 5, \"RKSt9nothrow_t\", 14))\n+\treturn true;\n+    }\n+  else if ((new_len == 19 && !memcmp (new_name + 4, \"St11align_val_t\", 15))\n+\t   || (new_len == 33\n+\t       && !memcmp (new_name + 4, \"St11align_val_tRKSt9nothrow_t\", 29)))\n+    {\n+      /* _ZnXYSt11align_val_t or _ZnXYSt11align_val_tRKSt9nothrow_t matches\n+\t _ZdXPvSt11align_val_t or _ZdXPvYSt11align_val_t or  or\n+\t _ZdXPvSt11align_val_tRKSt9nothrow_t.  */\n+      if (delete_len == 20 && !memcmp (delete_name + 5, \"St11align_val_t\", 15))\n+\treturn true;\n+      if (delete_len == 21\n+\t  && delete_name[5] == new_name[3]\n+\t  && !memcmp (delete_name + 6, \"St11align_val_t\", 15))\n+\treturn true;\n+      if (delete_len == 34\n+\t  && !memcmp (delete_name + 5, \"St11align_val_tRKSt9nothrow_t\", 29))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "d366ffd8a5151ebece908d7562c62f8272de9716", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -5278,6 +5278,7 @@ extern tree tree_block (tree);\n extern void tree_set_block (tree, tree);\n extern location_t *block_nonartificial_location (tree);\n extern location_t tree_nonartificial_location (tree);\n+extern location_t tree_inlined_location (tree, bool = true);\n extern tree block_ultimate_origin (const_tree);\n extern tree get_binfo_at_offset (tree, poly_int64, tree);\n extern bool virtual_method_call_p (const_tree, bool = false);\n@@ -5355,6 +5356,7 @@ extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,\n extern bool type_with_interoperable_signedness (const_tree);\n extern bitmap get_nonnull_args (const_tree);\n extern int get_range_pos_neg (tree);\n+extern bool valid_new_delete_pair_p (tree, tree);\n \n /* Return simplified tree code of type that is used for canonical type\n    merging.  */"}, {"sha": "5036be507244aa228dcc91450ac5d300b984f2de", "filename": "libstdc++-v3/testsuite/ext/vstring/requirements/exception/basic.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Frequirements%2Fexception%2Fbasic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Frequirements%2Fexception%2Fbasic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Frequirements%2Fexception%2Fbasic.cc?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -48,3 +48,7 @@ int main()\n   value();\n   return 0;\n }\n+\n+// The __versa_string destructor triggers a bogus -Wfree-nonheap-object\n+// due to pr54202.\n+// { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" }"}, {"sha": "61e9aedb7e6083946e8ecaf724f15f2e83236419", "filename": "libstdc++-v3/testsuite/ext/vstring/requirements/exception/propagation_consistent.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe7f75cf16783589eedbab597e6d0b8d35d7e470/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Frequirements%2Fexception%2Fpropagation_consistent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe7f75cf16783589eedbab597e6d0b8d35d7e470/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Frequirements%2Fexception%2Fpropagation_consistent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fvstring%2Frequirements%2Fexception%2Fpropagation_consistent.cc?ref=fe7f75cf16783589eedbab597e6d0b8d35d7e470", "patch": "@@ -48,3 +48,7 @@ int main()\n   value();\n   return 0;\n }\n+\n+// The __versa_string destructor triggers a bogus -Wfree-nonheap-object\n+// due to pr54202.\n+// { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" }"}]}