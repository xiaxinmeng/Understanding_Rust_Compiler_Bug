{"sha": "9a1bdc314ba086904861838838bc2e0743476dcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWExYmRjMzE0YmEwODY5MDQ4NjE4Mzg4MzhiYzJlMDc0MzQ3NmRjZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-01-18T11:29:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-01-18T11:29:00Z"}, "message": "gigi.h (build_call_raise_column): Adjust prototype.\n\n\t* gcc-interface/gigi.h (build_call_raise_column): Adjust prototype.\n\t(build_call_raise_range): Likewise.\n\t(gnat_unsigned_type): Delete.\n\t(gnat_signed_type): Likewise.\n\t(gnat_signed_or_unsigned_type_for): New prototype.\n\t(gnat_unsigned_type_for): New inline function.\n\t(gnat_signed_type_for): Likewise.\n\t* gcc-interface/cuintp.c (build_cst_from_int): Call build_int_cst.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Likewise.\n\t(gnat_to_gnu_entity) <E_Array_Type>: Always translate the index types\n\tand compute their base type from that.\n\t<E_Array_Subtype>: Remove duplicate declaration.\n\t* gcc-interface/misc.c (get_array_bit_stride): Call build_int_cst.\n\t* gcc-interface/trans.c (get_type_length): Likewise.\n\t(Attribute_to_gnu): Likewise.\n\t(Loop_Statement_to_gnu): Likewise.\n\t(Call_to_gnu): Likewise.\n\t(gnat_to_gnu): Call build_real, build_int_cst, gnat_unsigned_type_for\n\tand gnat_signed_type_for.  Minor tweaks.\n\t(build_binary_op_trapv): Likewise.\n\t(emit_check): Likewise.\n\t(convert_with_check): Likewise.\n\t(Raise_Error_to_gnu): Adjust calls to the build_call_raise family of\n\tfunctions.  Minor tweaks.\n\t(Case_Statement_to_gnu): Remove dead code.\n\t(gnat_to_gnu): Call gnat_unsigned_type_for and gnat_signed_type_for.\n\t(init_code_table): Minor reordering.\n\t* gcc-interface/utils.c (gnat_unsigned_type): Delete.\n\t(gnat_signed_type): Likewise.\n\t(gnat_signed_or_unsigned_type_for): New function.\n\t(unchecked_convert): Use directly the size in the test for precision\n\tvs size adjustments.\n\t(install_builtin_elementary_types): Call gnat_signed_type_for.\n\t* gcc-interface/utils2.c (nonbinary_modular_operation): Call\n\tbuild_int_cst.\n\t(build_goto_raise): New function taken from...\n\t(build_call_raise): ...here.  Call it.\n\t(build_call_raise_column): Add KIND parameter and call it.\n\t(build_call_raise_range): Likewise.\n\nFrom-SVN: r232503", "tree": {"sha": "9b5a32fc16b8443b82e93e51c4c082d86cb64a11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b5a32fc16b8443b82e93e51c4c082d86cb64a11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a1bdc314ba086904861838838bc2e0743476dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1bdc314ba086904861838838bc2e0743476dcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a1bdc314ba086904861838838bc2e0743476dcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a1bdc314ba086904861838838bc2e0743476dcd/comments", "author": null, "committer": null, "parents": [{"sha": "f5460595a488ce9c131815016d0c89dc0d17ca14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5460595a488ce9c131815016d0c89dc0d17ca14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5460595a488ce9c131815016d0c89dc0d17ca14"}], "stats": {"total": 368, "additions": 207, "deletions": 161}, "files": [{"sha": "64e4c711145143a366f4c77043f0056b0f2ec301", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -1,3 +1,45 @@\n+2016-01-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (build_call_raise_column): Adjust prototype.\n+\t(build_call_raise_range): Likewise.\n+\t(gnat_unsigned_type): Delete.\n+\t(gnat_signed_type): Likewise.\n+\t(gnat_signed_or_unsigned_type_for): New prototype.\n+\t(gnat_unsigned_type_for): New inline function.\n+\t(gnat_signed_type_for): Likewise.\n+\t* gcc-interface/cuintp.c (build_cst_from_int): Call build_int_cst.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Likewise.\n+\t(gnat_to_gnu_entity) <E_Array_Type>: Always translate the index types\n+\tand compute their base type from that.\n+\t<E_Array_Subtype>: Remove duplicate declaration.\n+\t* gcc-interface/misc.c (get_array_bit_stride): Call build_int_cst.\n+\t* gcc-interface/trans.c (get_type_length): Likewise.\n+\t(Attribute_to_gnu): Likewise.\n+\t(Loop_Statement_to_gnu): Likewise.\n+\t(Call_to_gnu): Likewise.\n+\t(gnat_to_gnu): Call build_real, build_int_cst, gnat_unsigned_type_for\n+\tand gnat_signed_type_for.  Minor tweaks.\n+\t(build_binary_op_trapv): Likewise.\n+\t(emit_check): Likewise.\n+\t(convert_with_check): Likewise.\n+\t(Raise_Error_to_gnu): Adjust calls to the build_call_raise family of\n+\tfunctions.  Minor tweaks.\n+\t(Case_Statement_to_gnu): Remove dead code.\n+\t(gnat_to_gnu): Call gnat_unsigned_type_for and gnat_signed_type_for.\n+\t(init_code_table): Minor reordering.\n+\t* gcc-interface/utils.c (gnat_unsigned_type): Delete.\n+\t(gnat_signed_type): Likewise.\n+\t(gnat_signed_or_unsigned_type_for): New function.\n+\t(unchecked_convert): Use directly the size in the test for precision\n+\tvs size adjustments.\n+\t(install_builtin_elementary_types): Call gnat_signed_type_for.\n+\t* gcc-interface/utils2.c (nonbinary_modular_operation): Call\n+\tbuild_int_cst.\n+\t(build_goto_raise): New function taken from...\n+\t(build_call_raise): ...here.  Call it.\n+\t(build_call_raise_column): Add KIND parameter and call it.\n+\t(build_call_raise_range): Likewise.\n+\n 2016-01-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (TYPE_IMPLEMENTS_PACKED_ARRAY_P): Rename to"}, {"sha": "a22662e8af496089a017c01ab0c47571ebea0fe7", "filename": "gcc/ada/gcc-interface/cuintp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fcuintp.c?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -52,16 +52,16 @@\n    the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n    that a Uint value of Uint_Bias indexes the first element.\n \n-   First define a utility function that operates like build_int_cst_type for\n-   integral types and does a conversion for floating-point types.  */\n+   First define a utility function that is build_int_cst for integral types and\n+   does a conversion for floating-point types.  */\n \n static tree\n build_cst_from_int (tree type, HOST_WIDE_INT low)\n {\n   if (SCALAR_FLOAT_TYPE_P (type))\n     return convert (type, build_int_cst (gnat_type_for_size (32, 0), low));\n   else\n-    return build_int_cst_type (type, low);\n+    return build_int_cst (type, low);\n }\n \n /* Similar to UI_To_Int, but return a GCC INTEGER_CST or REAL_CST node,"}, {"sha": "556f079690d23e6bc66c76c0f7e6613118a20fc1", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -1716,7 +1716,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    TYPE_MODULAR_P (gnu_type) = 1;\n \t    SET_TYPE_MODULUS (gnu_type, gnu_modulus);\n \t    gnu_high = fold_build2 (MINUS_EXPR, gnu_type, gnu_modulus,\n-\t\t\t\t    convert (gnu_type, integer_one_node));\n+\t\t\t\t    build_int_cst (gnu_type, 1));\n \t  }\n \n \t/* If the upper bound is not maximal, make an extra subtype.  */\n@@ -2113,8 +2113,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     gnat_index = Next_Index (gnat_index))\n \t  {\n \t    char field_name[16];\n-\t    tree gnu_index_base_type\n-\t      = get_unpadded_type (Base_Type (Etype (gnat_index)));\n+\t    tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n+\t    tree gnu_index_base_type = get_base_type (gnu_index_type);\n \t    tree gnu_lb_field, gnu_hb_field, gnu_orig_min, gnu_orig_max;\n \t    tree gnu_min, gnu_max, gnu_high;\n \n@@ -2173,7 +2173,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Update the maximum size of the array in elements.  */\n \t    if (gnu_max_size)\n \t      {\n-\t\ttree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n \t\ttree gnu_min\n \t\t  = convert (sizetype, TYPE_MIN_VALUE (gnu_index_type));\n \t\ttree gnu_max\n@@ -2495,8 +2494,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t{\n \t\t  tree gnu_base_min = convert (sizetype, gnu_base_orig_min);\n \t\t  tree gnu_base_max = convert (sizetype, gnu_base_orig_max);\n-\t\t  tree gnu_base_index_base_type\n-\t\t    = get_base_type (gnu_base_index_type);\n \t\t  tree gnu_base_base_min\n \t\t    = convert (sizetype,\n \t\t\t       TYPE_MIN_VALUE (gnu_base_index_base_type));"}, {"sha": "cd3d5b6ed7c7fc77330d02f15af7338f1210be5a", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -538,11 +538,9 @@ extern tree gnat_type_for_mode (machine_mode mode, int unsignedp);\n /* Perform final processing on global declarations.  */\n extern void gnat_write_global_declarations (void);\n \n-/* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_unsigned_type (tree type_node);\n-\n-/* Return the signed version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_signed_type (tree type_node);\n+/* Return the signed or unsigned version of TYPE_NODE, a scalar type, the\n+   signedness being specified by UNSIGNEDP.  */\n+extern tree gnat_signed_or_unsigned_type_for (int unsignedp, tree type_node);\n \n /* Return 1 if the types T1 and T2 are compatible, i.e. if they can be\n    transparently converted to each other.  */\n@@ -898,11 +896,11 @@ extern tree build_call_raise (int msg, Node_Id gnat_node, char kind);\n \n /* Similar to build_call_raise, with extra information about the column\n    where the check failed.  */\n-extern tree build_call_raise_column (int msg, Node_Id gnat_node);\n+extern tree build_call_raise_column (int msg, Node_Id gnat_node, char kind);\n \n /* Similar to build_call_raise_column, for an index or range check exception ,\n    with extra information of the form \"INDEX out of range FIRST..LAST\".  */\n-extern tree build_call_raise_range (int msg, Node_Id gnat_node,\n+extern tree build_call_raise_range (int msg, Node_Id gnat_node, char kind,\n \t\t\t\t    tree index, tree first, tree last);\n \n /* Return a CONSTRUCTOR of TYPE whose elements are V.  This is not the\n@@ -1120,3 +1118,19 @@ return_type_with_variable_size_p (tree type)\n \n   return false;\n }\n+\n+/* Return the unsigned version of TYPE_NODE, a scalar type.  */\n+\n+static inline tree\n+gnat_unsigned_type_for (tree type_node)\n+{\n+  return gnat_signed_or_unsigned_type_for (1, type_node);\n+}\n+\n+/* Return the signed version of TYPE_NODE, a scalar type.  */\n+\n+static inline tree\n+gnat_signed_type_for (tree type_node)\n+{\n+  return gnat_signed_or_unsigned_type_for (0, type_node);\n+}"}, {"sha": "33839f32eaa152882f35c718e1bcb5720f1bec8d", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -1035,7 +1035,7 @@ get_array_bit_stride (tree comp_type)\n     {\n       stride = fold_convert (bitsizetype, stride);\n       stride = build_binary_op (MULT_EXPR, bitsizetype,\n-\t\t\t\tstride, build_int_cstu (bitsizetype, 8));\n+\t\t\t\tstride, build_int_cst (bitsizetype, 8));\n     }\n \n   for (int i = 0; i < info.ndimensions; ++i)\n@@ -1053,10 +1053,10 @@ get_array_bit_stride (tree comp_type)\n \t\t\t       fold_convert (sbitsizetype,\n \t\t\t\t\t     info.dimen[i].lower_bound)),\n       count = build_binary_op (PLUS_EXPR, sbitsizetype,\n-\t\t\t       count, build_int_cstu (sbitsizetype, 1));\n+\t\t\t       count, build_int_cst (sbitsizetype, 1));\n       count = build_binary_op (MAX_EXPR, sbitsizetype,\n \t\t\t       count,\n-\t\t\t       build_int_cstu (sbitsizetype, 0));\n+\t\t\t       build_int_cst (sbitsizetype, 0));\n       count = fold_convert (bitsizetype, count);\n       stride = build_binary_op (MULT_EXPR, bitsizetype, stride, count);\n     }"}, {"sha": "eacab82ca296a45746bdb77dd49b6aee28b27558", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -1555,12 +1555,12 @@ get_type_length (tree type, tree result_type)\n \t\t       build_binary_op (MINUS_EXPR, comp_type,\n \t\t\t\t\tconvert (comp_type, hb),\n \t\t\t\t\tconvert (comp_type, lb)),\n-\t\t       convert (comp_type, integer_one_node));\n+\t\t       build_int_cst (comp_type, 1));\n   length\n     = build_cond_expr (result_type,\n \t\t       build_binary_op (GE_EXPR, boolean_type_node, hb, lb),\n \t\t       convert (result_type, length),\n-\t\t       convert (result_type, integer_zero_node));\n+\t\t       build_int_cst (result_type, 0));\n   return length;\n }\n \n@@ -1637,7 +1637,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       gnu_result\n \t= build_binary_op (attribute == Attr_Pred ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t   gnu_result_type, gnu_expr,\n-\t\t\t   convert (gnu_result_type, integer_one_node));\n+\t\t\t   build_int_cst (gnu_result_type, 1));\n       break;\n \n     case Attr_Address:\n@@ -2508,22 +2508,6 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n   gnu_expr = gnat_to_gnu (Expression (gnat_node));\n   gnu_expr = convert (get_base_type (TREE_TYPE (gnu_expr)), gnu_expr);\n \n-  /*  The range of values in a case statement is determined by the rules in\n-      RM 5.4(7-9). In almost all cases, this range is represented by the Etype\n-      of the expression. One exception arises in the case of a simple name that\n-      is parenthesized. This still has the Etype of the name, but since it is\n-      not a name, para 7 does not apply, and we need to go to the base type.\n-      This is the only case where parenthesization affects the dynamic\n-      semantics (i.e. the range of possible values at run time that is covered\n-      by the others alternative).\n-\n-      Another exception is if the subtype of the expression is non-static.  In\n-      that case, we also have to use the base type.  */\n-  if (Paren_Count (Expression (gnat_node)) != 0\n-      || !Is_OK_Static_Subtype (Underlying_Type\n-\t\t\t\t(Etype (Expression (gnat_node)))))\n-    gnu_expr = convert (get_base_type (TREE_TYPE (gnu_expr)), gnu_expr);\n-\n   /* We build a SWITCH_EXPR that contains the code with interspersed\n      CASE_LABEL_EXPRs for each label.  */\n   if (!Sloc_to_locus (End_Location (gnat_node), &end_locus))\n@@ -2894,7 +2878,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       Entity_Id gnat_type = Etype (gnat_loop_var);\n       tree gnu_type = get_unpadded_type (gnat_type);\n       tree gnu_base_type = get_base_type (gnu_type);\n-      tree gnu_one_node = convert (gnu_base_type, integer_one_node);\n+      tree gnu_one_node = build_int_cst (gnu_base_type, 1);\n       tree gnu_loop_var, gnu_loop_iv, gnu_first, gnu_last, gnu_stmt;\n       enum tree_code update_code, test_code, shift_code;\n       bool reverse = Reverse_Present (gnat_loop_spec), use_iv = false;\n@@ -2990,7 +2974,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n \t      gnu_first = convert (gnu_base_type, gnu_first);\n \t      gnu_last = convert (gnu_base_type, gnu_last);\n-\t      gnu_one_node = convert (gnu_base_type, integer_one_node);\n+\t      gnu_one_node = build_int_cst (gnu_base_type, 1);\n \t      use_iv = true;\n \t    }\n \n@@ -4682,12 +4666,14 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      && (gnu_size = TYPE_SIZE (TREE_TYPE (gnu_actual)))\n \t      && TREE_CODE (gnu_size) == INTEGER_CST\n \t      && compare_tree_int (gnu_size, BITS_PER_WORD) <= 0)\n-\t    gnu_actual\n-\t      = unchecked_convert (DECL_ARG_TYPE (gnu_formal),\n-\t\t\t\t   convert (gnat_type_for_size\n-\t\t\t\t\t    (TREE_INT_CST_LOW (gnu_size), 1),\n-\t\t\t\t\t    integer_zero_node),\n-\t\t\t\t   false);\n+\t    {\n+\t      tree type_for_size\n+\t\t= gnat_type_for_size (TREE_INT_CST_LOW (gnu_size), 1);\n+\t      gnu_actual\n+\t\t= unchecked_convert (DECL_ARG_TYPE (gnu_formal),\n+\t\t\t\t     build_int_cst (type_for_size, 0),\n+\t\t\t\t     false);\n+\t    }\n \t  else\n \t    gnu_actual = convert (DECL_ARG_TYPE (gnu_formal), gnu_actual);\n \t}\n@@ -5497,10 +5483,9 @@ build_noreturn_cond (tree cond)\n   return build1 (NOP_EXPR, boolean_type_node, t);\n }\n \n-/* Subroutine of gnat_to_gnu to translate gnat_node, an N_Raise_xxx_Error,\n-   to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to where\n-   we should place the result type.  LABEL_P is true if there is a label to\n-   branch to for the exception.  */\n+/* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Raise_xxx_Error,\n+   to a GCC tree and return it.  GNU_RESULT_TYPE_P is a pointer to where\n+   we should place the result type.  */\n \n static tree\n Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n@@ -5514,13 +5499,13 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       && !get_exception_label (kind);\n   tree gnu_result = NULL_TREE, gnu_cond = NULL_TREE;\n \n-  *gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n-\n+  /* The following processing is not required for correctness.  Its purpose is\n+     to give more precise error messages and to record some information.  */\n   switch (reason)\n     {\n     case CE_Access_Check_Failed:\n       if (with_extra_info)\n-\tgnu_result = build_call_raise_column (reason, gnat_node);\n+\tgnu_result = build_call_raise_column (reason, gnat_node, kind);\n       break;\n \n     case CE_Index_Check_Failed:\n@@ -5566,7 +5551,7 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t      && Known_Esize (gnat_type)\n \t      && UI_To_Int (Esize (gnat_type)) <= 32)\n \t    gnu_result\n-\t      = build_call_raise_range (reason, gnat_node, gnu_index,\n+\t      = build_call_raise_range (reason, gnat_node, kind, gnu_index,\n \t\t\t\t\tgnu_low_bound, gnu_high_bound);\n \n \t  /* If optimization is enabled and we are inside a loop, we try to\n@@ -5636,11 +5621,14 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       break;\n     }\n \n+  /* The following processing does the common work.  */\n common:\n   if (!gnu_result)\n     gnu_result = build_call_raise (reason, gnat_node, kind);\n   set_expr_location_from_node (gnu_result, gnat_node);\n \n+  *gnu_result_type_p = get_unpadded_type (Etype (gnat_node));\n+\n   /* If the type is VOID, this is a statement, so we need to generate the code\n      for the call.  Handle a condition, if there is one.  */\n   if (VOID_TYPE_P (*gnu_result_type_p))\n@@ -5864,8 +5852,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_result = DECL_INITIAL (get_gnu_tree (Entity (gnat_node)));\n       else\n \tgnu_result\n-\t  = build_int_cst_type\n-\t      (gnu_result_type, UI_To_CC (Char_Literal_Value (gnat_node)));\n+\t  = build_int_cst (gnu_result_type,\n+\t\t\t   UI_To_CC (Char_Literal_Value (gnat_node)));\n       break;\n \n     case N_Real_Literal:\n@@ -5893,7 +5881,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t ur_realval, Round_Even, gnat_node);\n \n \t  if (UR_Is_Zero (ur_realval))\n-\t    gnu_result = convert (gnu_result_type, integer_zero_node);\n+\t    gnu_result = build_real (gnu_result_type, dconst0);\n \t  else\n \t    {\n \t      REAL_VALUE_TYPE tmp;\n@@ -6609,7 +6597,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t    gnu_result_type, gnu_lhs, gnu_rhs);\n       break;\n \n-    case N_Op_Or:    case N_Op_And:      case N_Op_Xor:\n+    case N_Op_And:\n+    case N_Op_Or:\n+    case N_Op_Xor:\n       /* These can either be operations on booleans or on modular types.\n \t Fall through for boolean types since that's the way GNU_CODES is\n \t set up.  */\n@@ -6630,16 +6620,24 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       /* ... fall through ... */\n \n-    case N_Op_Eq:    case N_Op_Ne:\t case N_Op_Lt:\n-    case N_Op_Le:    case N_Op_Gt:       case N_Op_Ge:\n-    case N_Op_Add:   case N_Op_Subtract: case N_Op_Multiply:\n-    case N_Op_Mod:   case N_Op_Rem:\n+    case N_Op_Eq:\n+    case N_Op_Ne:\n+    case N_Op_Lt:\n+    case N_Op_Le:\n+    case N_Op_Gt:\n+    case N_Op_Ge:\n+    case N_Op_Add:\n+    case N_Op_Subtract:\n+    case N_Op_Multiply:\n+    case N_Op_Mod:\n+    case N_Op_Rem:\n     case N_Op_Rotate_Left:\n     case N_Op_Rotate_Right:\n     case N_Op_Shift_Left:\n     case N_Op_Shift_Right:\n     case N_Op_Shift_Right_Arithmetic:\n-    case N_And_Then: case N_Or_Else:\n+    case N_And_Then:\n+    case N_Or_Else:\n       {\n \tenum tree_code code = gnu_codes[kind];\n \tbool ignore_lhs_overflow = false;\n@@ -6682,8 +6680,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   build_binary_op (MINUS_EXPR,\n \t\t\t\t    gnu_count_type,\n \t\t\t\t    gnu_max_shift,\n-\t\t\t\t    convert (gnu_count_type,\n-\t\t\t\t\t     integer_one_node)),\n+\t\t\t\t    build_int_cst (gnu_count_type, 1)),\n \t\t   gnu_rhs);\n \t  }\n \n@@ -6693,13 +6690,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   the way down and causes a CE to be explicitly raised.  */\n \tif (kind == N_Op_Shift_Right && !TYPE_UNSIGNED (gnu_type))\n \t  {\n-\t    gnu_type = gnat_unsigned_type (gnu_type);\n+\t    gnu_type = gnat_unsigned_type_for (gnu_type);\n \t    ignore_lhs_overflow = true;\n \t  }\n \telse if (kind == N_Op_Shift_Right_Arithmetic\n \t\t && TYPE_UNSIGNED (gnu_type))\n \t  {\n-\t    gnu_type = gnat_signed_type (gnu_type);\n+\t    gnu_type = gnat_signed_type_for (gnu_type);\n \t    ignore_lhs_overflow = true;\n \t  }\n \n@@ -6715,13 +6712,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* Instead of expanding overflow checks for addition, subtraction\n \t   and multiplication itself, the front end will leave this to\n \t   the back end when Backend_Overflow_Checks_On_Target is set.\n-\t   As the GCC back end itself does not know yet how to properly\n+\t   As the back end itself does not know yet how to properly\n \t   do overflow checking, do it here.  The goal is to push\n \t   the expansions further into the back end over time.  */\n-\tif (Do_Overflow_Check (gnat_node) && Backend_Overflow_Checks_On_Target\n-\t    && (kind == N_Op_Add\n-\t\t|| kind == N_Op_Subtract\n-\t\t|| kind == N_Op_Multiply)\n+\tif (Do_Overflow_Check (gnat_node)\n+\t    && Backend_Overflow_Checks_On_Target\n+\t    && (code == PLUS_EXPR || code == MINUS_EXPR || code == MULT_EXPR)\n \t    && !TYPE_UNSIGNED (gnu_type)\n \t    && !FLOAT_TYPE_P (gnu_type))\n \t  gnu_result = build_binary_op_trapv (code, gnu_type,\n@@ -6746,7 +6742,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\tgnu_rhs,\n \t\t\t\tconvert (TREE_TYPE (gnu_rhs),\n \t\t\t\t\t TYPE_SIZE (gnu_type))),\n-\t       convert (gnu_type, integer_zero_node),\n+\t       build_int_cst (gnu_type, 0),\n \t       gnu_result);\n       }\n       break;\n@@ -6784,7 +6780,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       /* ... fall through ... */\n \n-    case N_Op_Minus:  case N_Op_Abs:\n+    case N_Op_Minus:\n+    case N_Op_Abs:\n       gnu_expr = gnat_to_gnu (Right_Opnd (gnat_node));\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n@@ -7382,7 +7379,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t  true, true, NULL, gnat_node);\n \n       add_stmt (build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_incoming_exc_ptr,\n-\t\t\t\t convert (ptr_type_node, integer_zero_node)));\n+\t\t\t\t build_int_cst (ptr_type_node, 0)));\n       add_stmt (build_call_n_expr (reraise_zcx_decl, 1, gnu_expr));\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n@@ -8861,7 +8858,7 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n   tree rhs = gnat_protect_expr (right);\n   tree type_max = TYPE_MAX_VALUE (gnu_type);\n   tree type_min = TYPE_MIN_VALUE (gnu_type);\n-  tree zero = convert (gnu_type, integer_zero_node);\n+  tree zero = build_int_cst (gnu_type, 0);\n   tree gnu_expr, rhs_lt_zero, tmp1, tmp2;\n   tree check_pos, check_neg, check;\n \n@@ -9151,7 +9148,9 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason, Node_Id gnat_node)\n   return\n     fold_build3 (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n \t\t build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr), gnu_call,\n-\t\t\t convert (TREE_TYPE (gnu_expr), integer_zero_node)),\n+\t\t\t SCALAR_FLOAT_TYPE_P (TREE_TYPE (gnu_expr))\n+\t\t\t ? build_real (TREE_TYPE (gnu_expr), dconst0)\n+\t\t\t : build_int_cst (TREE_TYPE (gnu_expr), 0)),\n \t\t gnu_expr);\n }\n \f\n@@ -9207,17 +9206,21 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t comparing them properly.  Likewise, convert the upper bounds\n \t to unsigned types.  */\n       if (INTEGRAL_TYPE_P (gnu_in_basetype) && TYPE_UNSIGNED (gnu_in_basetype))\n-\tgnu_in_lb = convert (gnat_signed_type (gnu_in_basetype), gnu_in_lb);\n+\tgnu_in_lb\n+\t  = convert (gnat_signed_type_for (gnu_in_basetype), gnu_in_lb);\n \n       if (INTEGRAL_TYPE_P (gnu_in_basetype)\n \t  && !TYPE_UNSIGNED (gnu_in_basetype))\n-\tgnu_in_ub = convert (gnat_unsigned_type (gnu_in_basetype), gnu_in_ub);\n+\tgnu_in_ub\n+\t  = convert (gnat_unsigned_type_for (gnu_in_basetype), gnu_in_ub);\n \n       if (INTEGRAL_TYPE_P (gnu_base_type) && TYPE_UNSIGNED (gnu_base_type))\n-\tgnu_out_lb = convert (gnat_signed_type (gnu_base_type), gnu_out_lb);\n+\tgnu_out_lb\n+\t  = convert (gnat_signed_type_for (gnu_base_type), gnu_out_lb);\n \n       if (INTEGRAL_TYPE_P (gnu_base_type) && !TYPE_UNSIGNED (gnu_base_type))\n-\tgnu_out_ub = convert (gnat_unsigned_type (gnu_base_type), gnu_out_ub);\n+\tgnu_out_ub\n+\t  = convert (gnat_unsigned_type_for (gnu_base_type), gnu_out_ub);\n \n       /* Check each bound separately and only if the result bound\n \t is tighter than the bound on the input type.  Note that all the\n@@ -9301,7 +9304,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t to be scheduled in parallel with retrieval of the constant and\n \t conversion of the input to the calc_type (if necessary).  */\n \n-      gnu_zero = convert (gnu_in_basetype, integer_zero_node);\n+      gnu_zero = build_real (gnu_in_basetype, dconst0);\n       gnu_result = gnat_protect_expr (gnu_result);\n       gnu_conv = convert (calc_type, gnu_result);\n       gnu_comp\n@@ -10122,9 +10125,6 @@ get_elaboration_procedure (void)\n static void\n init_code_table (void)\n {\n-  gnu_codes[N_And_Then] = TRUTH_ANDIF_EXPR;\n-  gnu_codes[N_Or_Else] = TRUTH_ORIF_EXPR;\n-\n   gnu_codes[N_Op_And] = TRUTH_AND_EXPR;\n   gnu_codes[N_Op_Or] = TRUTH_OR_EXPR;\n   gnu_codes[N_Op_Xor] = TRUTH_XOR_EXPR;\n@@ -10147,6 +10147,8 @@ init_code_table (void)\n   gnu_codes[N_Op_Shift_Left] = LSHIFT_EXPR;\n   gnu_codes[N_Op_Shift_Right] = RSHIFT_EXPR;\n   gnu_codes[N_Op_Shift_Right_Arithmetic] = RSHIFT_EXPR;\n+  gnu_codes[N_And_Then] = TRUTH_ANDIF_EXPR;\n+  gnu_codes[N_Or_Else] = TRUTH_ORIF_EXPR;\n }\n \n #include \"gt-ada-trans.h\""}, {"sha": "95886f78d0bf5d8bf6b969fe77ce4c63d015c5c7", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 20, "deletions": 43, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -3354,35 +3354,13 @@ gnat_type_for_mode (machine_mode mode, int unsignedp)\n   return NULL_TREE;\n }\n \n-/* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n+/* Return the signed or unsigned version of TYPE_NODE, a scalar type, the\n+   signedness being specified by UNSIGNEDP.  */\n \n tree\n-gnat_unsigned_type (tree type_node)\n+gnat_signed_or_unsigned_type_for (int unsignedp, tree type_node)\n {\n-  tree type = gnat_type_for_size (TYPE_PRECISION (type_node), 1);\n-\n-  if (TREE_CODE (type_node) == INTEGER_TYPE && TYPE_MODULAR_P (type_node))\n-    {\n-      type = copy_node (type);\n-      TREE_TYPE (type) = type_node;\n-    }\n-  else if (TREE_TYPE (type_node)\n-\t   && TREE_CODE (TREE_TYPE (type_node)) == INTEGER_TYPE\n-\t   && TYPE_MODULAR_P (TREE_TYPE (type_node)))\n-    {\n-      type = copy_node (type);\n-      TREE_TYPE (type) = TREE_TYPE (type_node);\n-    }\n-\n-  return type;\n-}\n-\n-/* Return the signed version of a TYPE_NODE, a scalar type.  */\n-\n-tree\n-gnat_signed_type (tree type_node)\n-{\n-  tree type = gnat_type_for_size (TYPE_PRECISION (type_node), 0);\n+  tree type = gnat_type_for_size (TYPE_PRECISION (type_node), unsignedp);\n \n   if (TREE_CODE (type_node) == INTEGER_TYPE && TYPE_MODULAR_P (type_node))\n     {\n@@ -4936,8 +4914,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      are no considerations of precision or size involved.  */\n   else if (INTEGRAL_TYPE_P (type)\n \t   && TYPE_RM_SIZE (type)\n-\t   && (0 != compare_tree_int (TYPE_RM_SIZE (type),\n-\t\t\t\t      GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t   && (tree_int_cst_compare (TYPE_RM_SIZE (type),\n+\t\t\t\t     TYPE_SIZE (type)) < 0\n \t       || (AGGREGATE_TYPE_P (etype)\n \t\t   && TYPE_REVERSE_STORAGE_ORDER (etype))))\n     {\n@@ -4973,8 +4951,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      type with reverse storage order and we also proceed similarly.  */\n   else if (INTEGRAL_TYPE_P (etype)\n \t   && TYPE_RM_SIZE (etype)\n-\t   && (0 != compare_tree_int (TYPE_RM_SIZE (etype),\n-\t\t\t\t      GET_MODE_BITSIZE (TYPE_MODE (etype)))\n+\t   && (tree_int_cst_compare (TYPE_RM_SIZE (etype),\n+\t\t\t\t     TYPE_SIZE (etype)) < 0\n \t       || (AGGREGATE_TYPE_P (type)\n \t\t   && TYPE_REVERSE_STORAGE_ORDER (type))))\n     {\n@@ -5094,26 +5072,25 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n      is an integral type of the same precision and signedness or if the output\n      is a biased type or if both the input and output are unsigned.  */\n   if (!notrunc_p\n-      && INTEGRAL_TYPE_P (type) && TYPE_RM_SIZE (type)\n-      && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n-      && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n-\t\t\t\tGET_MODE_BITSIZE (TYPE_MODE (type)))\n+      && INTEGRAL_TYPE_P (type)\n+      && TYPE_RM_SIZE (type)\n+      && tree_int_cst_compare (TYPE_RM_SIZE (type), TYPE_SIZE (type)) < 0\n       && !(INTEGRAL_TYPE_P (etype)\n \t   && TYPE_UNSIGNED (type) == TYPE_UNSIGNED (etype)\n-\t   && operand_equal_p (TYPE_RM_SIZE (type),\n-\t\t\t       (TYPE_RM_SIZE (etype) != 0\n-\t\t\t\t? TYPE_RM_SIZE (etype) : TYPE_SIZE (etype)),\n-\t\t\t       0))\n+\t   && tree_int_cst_compare (TYPE_RM_SIZE (type),\n+\t\t\t\t    TYPE_RM_SIZE (etype)\n+\t\t\t\t    ? TYPE_RM_SIZE (etype)\n+\t\t\t\t    : TYPE_SIZE (etype)) == 0)\n+      && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))\n       && !(TYPE_UNSIGNED (type) && TYPE_UNSIGNED (etype)))\n     {\n       tree base_type\n-\t= gnat_type_for_mode (TYPE_MODE (type), TYPE_UNSIGNED (type));\n+\t= gnat_type_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),\n+\t\t\t      TYPE_UNSIGNED (type));\n       tree shift_expr\n \t= convert (base_type,\n \t\t   size_binop (MINUS_EXPR,\n-\t\t\t       bitsize_int\n-\t\t\t       (GET_MODE_BITSIZE (TYPE_MODE (type))),\n-\t\t\t       TYPE_RM_SIZE (type)));\n+\t\t\t       TYPE_SIZE (type), TYPE_RM_SIZE (type)));\n       expr\n \t= convert (type,\n \t\t   build_binary_op (RSHIFT_EXPR, base_type,\n@@ -5434,7 +5411,7 @@ builtin_type_for_size (int size, bool unsignedp)\n static void\n install_builtin_elementary_types (void)\n {\n-  signed_size_type_node = gnat_signed_type (size_type_node);\n+  signed_size_type_node = gnat_signed_type_for (size_type_node);\n   pid_type_node = integer_type_node;\n   void_list_node = build_void_list_node ();\n "}, {"sha": "efeb1473fdc5867671926d01d3da493c5e5f2339", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a1bdc314ba086904861838838bc2e0743476dcd/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=9a1bdc314ba086904861838838bc2e0743476dcd", "patch": "@@ -592,7 +592,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n       result = gnat_protect_expr (result);\n       result = fold_build3 (COND_EXPR, op_type,\n \t\t\t    fold_build2 (LT_EXPR, boolean_type_node, result,\n-\t\t\t\t\t convert (op_type, integer_zero_node)),\n+\t\t\t\t\t build_int_cst (op_type, 0)),\n \t\t\t    fold_build2 (PLUS_EXPR, op_type, result, modulus),\n \t\t\t    result);\n     }\n@@ -1601,8 +1601,8 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      {\n \t\tif (integer_pow2p (fold_build2 (PLUS_EXPR, operation_type,\n \t\t\t\t\t\tmodulus,\n-\t\t\t\t\t\tconvert (operation_type,\n-\t\t\t\t\t\t\t integer_one_node))))\n+\t\t\t\t\t\tbuild_int_cst (operation_type,\n+\t\t\t\t\t\t\t       1))))\n \t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n \t\t\t\t\toperand, modulus);\n \t\telse\n@@ -1613,9 +1613,8 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t\t\t\t      fold_build2 (NE_EXPR,\n \t\t\t\t\t\t   boolean_type_node,\n \t\t\t\t\t\t   operand,\n-\t\t\t\t\t\t   convert\n-\t\t\t\t\t\t     (operation_type,\n-\t\t\t\t\t\t      integer_zero_node)),\n+\t\t\t\t\t\t   build_int_cst\n+\t\t\t\t\t\t   (operation_type, 0)),\n \t\t\t\t      result, operand);\n \t      }\n \t    else\n@@ -1626,8 +1625,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t\t   that constant for nonbinary modulus.  */\n \n \t\ttree cnst = fold_build2 (MINUS_EXPR, operation_type, modulus,\n-\t\t\t\t\t convert (operation_type,\n-\t\t\t\t\t\t  integer_one_node));\n+\t\t\t\t\t build_int_cst (operation_type, 1));\n \n \t\tif (mod_pow2)\n \t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n@@ -1748,6 +1746,32 @@ build_call_n_expr (tree fndecl, int n, ...)\n   return fn;\n }\n \f\n+/* Build a goto to LABEL for a raise, with an optional call to Local_Raise.\n+   MSG gives the exception's identity for the call to Local_Raise, if any.  */\n+\n+static tree\n+build_goto_raise (tree label, int msg)\n+{\n+  tree gnu_result = build1 (GOTO_EXPR, void_type_node, label);\n+  Entity_Id local_raise = Get_Local_Raise_Call_Entity ();\n+\n+  /* If Local_Raise is present, build Local_Raise (Exception'Identity).  */\n+  if (Present (local_raise))\n+    {\n+      tree gnu_local_raise = gnat_to_gnu_entity (local_raise, NULL_TREE, 0);\n+      tree gnu_exception_entity\n+\t= gnat_to_gnu_entity (Get_RT_Exception_Entity (msg), NULL_TREE, 0);\n+      tree gnu_call\n+\t= build_call_n_expr (gnu_local_raise, 1,\n+\t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t     gnu_exception_entity));\n+      gnu_result\n+\t= build2 (COMPOUND_EXPR, void_type_node, gnu_call, gnu_result);\n+    }\n+\n+  return gnu_result;\n+}\n+\n /* Expand the SLOC of GNAT_NODE, if present, into tree location information\n    pointed to by FILENAME, LINE and COL.  Fall back to the current location\n    if GNAT_NODE is absent or has no SLOC.  */\n@@ -1803,27 +1827,7 @@ build_call_raise (int msg, Node_Id gnat_node, char kind)\n \n   /* If this is to be done as a goto, handle that case.  */\n   if (label)\n-    {\n-      Entity_Id local_raise = Get_Local_Raise_Call_Entity ();\n-      tree gnu_result = build1 (GOTO_EXPR, void_type_node, label);\n-\n-      /* If Local_Raise is present, build Local_Raise (Exception'Identity).  */\n-      if (Present (local_raise))\n-\t{\n-\t  tree gnu_local_raise\n-\t    = gnat_to_gnu_entity (local_raise, NULL_TREE, 0);\n-\t  tree gnu_exception_entity\n-\t    = gnat_to_gnu_entity (Get_RT_Exception_Entity (msg), NULL_TREE, 0);\n-\t  tree gnu_call\n-\t    = build_call_n_expr (gnu_local_raise, 1,\n-\t\t\t\t build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t\t gnu_exception_entity));\n-\t  gnu_result\n-\t    = build2 (COMPOUND_EXPR, void_type_node, gnu_call, gnu_result);\n-\t}\n-\n-      return gnu_result;\n-    }\n+    return build_goto_raise (label, msg);\n \n   expand_sloc (gnat_node, &filename, &line, NULL);\n \n@@ -1839,11 +1843,16 @@ build_call_raise (int msg, Node_Id gnat_node, char kind)\n    where the check failed.  */\n \n tree\n-build_call_raise_column (int msg, Node_Id gnat_node)\n+build_call_raise_column (int msg, Node_Id gnat_node, char kind)\n {\n   tree fndecl = gnat_raise_decls_ext[msg];\n+  tree label = get_exception_label (kind);\n   tree filename, line, col;\n \n+  /* If this is to be done as a goto, handle that case.  */\n+  if (label)\n+    return build_goto_raise (label, msg);\n+\n   expand_sloc (gnat_node, &filename, &line, &col);\n \n   return\n@@ -1858,12 +1867,17 @@ build_call_raise_column (int msg, Node_Id gnat_node)\n    with extra information of the form \"INDEX out of range FIRST..LAST\".  */\n \n tree\n-build_call_raise_range (int msg, Node_Id gnat_node,\n+build_call_raise_range (int msg, Node_Id gnat_node, char kind,\n \t\t\ttree index, tree first, tree last)\n {\n   tree fndecl = gnat_raise_decls_ext[msg];\n+  tree label = get_exception_label (kind);\n   tree filename, line, col;\n \n+  /* If this is to be done as a goto, handle that case.  */\n+  if (label)\n+    return build_goto_raise (label, msg);\n+\n   expand_sloc (gnat_node, &filename, &line, &col);\n \n   return"}]}