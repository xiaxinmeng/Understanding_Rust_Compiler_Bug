{"sha": "5fb54b91980565f03b96cadfc55dff8ddf5236ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZiNTRiOTE5ODA1NjVmMDNiOTZjYWRmYzU1ZGZmOGRkZjUyMzZjYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-04-24T15:28:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-04-24T15:28:21Z"}, "message": "libgcc2.h (AVOID_FP_TYPE_CONVERSION): Rename from IS_IBM_EXTENDED.\n\n        * libgcc2.h (AVOID_FP_TYPE_CONVERSION): Rename from \n        IS_IBM_EXTENDED.  Also define in terms of WIDEST_HARDWARE_FP_SIZE.\n        * libgcc2.c (__floatdisf): Avoid double-word arithmetic when\n        looking for non-zero bits shifted out.  Avoid a recursive call\n        when constructing the scalar.\n        (__floatundisf): Likewise.\n\nFrom-SVN: r124106", "tree": {"sha": "02de3c14605545c31467f9847eec2443b8c6117d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02de3c14605545c31467f9847eec2443b8c6117d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fb54b91980565f03b96cadfc55dff8ddf5236ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb54b91980565f03b96cadfc55dff8ddf5236ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fb54b91980565f03b96cadfc55dff8ddf5236ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb54b91980565f03b96cadfc55dff8ddf5236ca/comments", "author": null, "committer": null, "parents": [{"sha": "688518053c61ccb6d52aa647d6ba6b04fdc1b04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/688518053c61ccb6d52aa647d6ba6b04fdc1b04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/688518053c61ccb6d52aa647d6ba6b04fdc1b04c"}], "stats": {"total": 63, "additions": 43, "deletions": 20}, "files": [{"sha": "7cc6435ea0220e7d580e98b3a40c6397f17f0cc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb54b91980565f03b96cadfc55dff8ddf5236ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb54b91980565f03b96cadfc55dff8ddf5236ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fb54b91980565f03b96cadfc55dff8ddf5236ca", "patch": "@@ -1,3 +1,12 @@\n+2007-04-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* libgcc2.h (AVOID_FP_TYPE_CONVERSION): Rename from \n+\tIS_IBM_EXTENDED.  Also define in terms of WIDEST_HARDWARE_FP_SIZE.\n+\t* libgcc2.c (__floatdisf): Avoid double-word arithmetic when\n+\tlooking for non-zero bits shifted out.  Avoid a recursive call\n+\twhen constructing the scalar.\n+\t(__floatundisf): Likewise.\n+\n 2007-04-24  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* dwarf2out.c (field_byte_offset): Move the existing logic"}, {"sha": "a026fff4a870125456e48a7149f730b5f990afcb", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb54b91980565f03b96cadfc55dff8ddf5236ca/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb54b91980565f03b96cadfc55dff8ddf5236ca/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=5fb54b91980565f03b96cadfc55dff8ddf5236ca", "patch": "@@ -1420,11 +1420,7 @@ __floatunditf (UDWtype u)\n #define F_MODE_OK(SIZE) \\\n   (SIZE < DI_SIZE\t\t\t\t\t\t\t\\\n    && SIZE > (DI_SIZE - SIZE + FSSIZE)\t\t\t\t\t\\\n-   /* Don't use IBM Extended Double TFmode for TI->SF calculations.\t\\\n-      The conversion from long double to float suffers from double\t\\\n-      rounding, because we convert via double.  In any case, the\t\\\n-      fallback code is faster.  */\t\t\t\t\t\\\n-   && !IS_IBM_EXTENDED (SIZE))\n+   && !AVOID_FP_TYPE_CONVERSION(SIZE))\n #if defined(L_floatdisf)\n #define FUNC __floatdisf\n #define FSTYPE SFtype\n@@ -1515,13 +1511,21 @@ FUNC (DWtype u)\n   hi = u >> shift;\n \n   /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */\n-  if (u & (((DWtype)1 << shift) - 1))\n+  if ((UWtype)u << (W_TYPE_SIZE - shift))\n     hi |= 1;\n \n   /* Convert the one word of data, and rescale.  */\n-  FSTYPE f = hi;\n-  f *= (UDWtype)1 << shift;\n-  return f;\n+  FSTYPE f = hi, e;\n+  if (shift == W_TYPE_SIZE)\n+    e = Wtype_MAXp1_F;\n+  /* The following two cases could be merged if we knew that the target\n+     supported a native unsigned->float conversion.  More often, we only\n+     have a signed conversion, and have to add extra fixup code.  */\n+  else if (shift == W_TYPE_SIZE - 1)\n+    e = Wtype_MAXp1_F / 2;\n+  else\n+    e = (Wtype)1 << shift;\n+  return f * e;\n #endif\n }\n #endif\n@@ -1532,11 +1536,7 @@ FUNC (DWtype u)\n #define F_MODE_OK(SIZE) \\\n   (SIZE < DI_SIZE\t\t\t\t\t\t\t\\\n    && SIZE > (DI_SIZE - SIZE + FSSIZE)\t\t\t\t\t\\\n-   /* Don't use IBM Extended Double TFmode for TI->SF calculations.\t\\\n-      The conversion from long double to float suffers from double\t\\\n-      rounding, because we convert via double.  In any case, the\t\\\n-      fallback code is faster.  */\t\t\t\t\t\\\n-   && !IS_IBM_EXTENDED (SIZE))\n+   && !AVOID_FP_TYPE_CONVERSION(SIZE))\n #if defined(L_floatundisf)\n #define FUNC __floatundisf\n #define FSTYPE SFtype\n@@ -1620,13 +1620,21 @@ FUNC (UDWtype u)\n   hi = u >> shift;\n \n   /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */\n-  if (u & (((UDWtype)1 << shift) - 1))\n+  if ((UWtype)u << (W_TYPE_SIZE - shift))\n     hi |= 1;\n \n   /* Convert the one word of data, and rescale.  */\n-  FSTYPE f = hi;\n-  f *= (UDWtype)1 << shift;\n-  return f;\n+  FSTYPE f = hi, e;\n+  if (shift == W_TYPE_SIZE)\n+    e = Wtype_MAXp1_F;\n+  /* The following two cases could be merged if we knew that the target\n+     supported a native unsigned->float conversion.  More often, we only\n+     have a signed conversion, and have to add extra fixup code.  */\n+  else if (shift == W_TYPE_SIZE - 1)\n+    e = Wtype_MAXp1_F / 2;\n+  else\n+    e = (Wtype)1 << shift;\n+  return f * e;\n #endif\n }\n #endif"}, {"sha": "c6084dc00faac15387badf47023fdc920a0ebdab", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb54b91980565f03b96cadfc55dff8ddf5236ca/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb54b91980565f03b96cadfc55dff8ddf5236ca/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=5fb54b91980565f03b96cadfc55dff8ddf5236ca", "patch": "@@ -115,10 +115,16 @@ extern void __eprintf (const char *, const char *, unsigned int, const char *)\n \n /* FIXME: This #ifdef probably should be removed, ie. enable the test\n    for mips too.  */\n+/* Don't use IBM Extended Double TFmode for TI->SF calculations.\n+   The conversion from long double to float suffers from double\n+   rounding, because we convert via double.  In other cases, going\n+   through the software fp routines is much slower than the fallback.  */\n #ifdef __powerpc__\n-#define IS_IBM_EXTENDED(SIZE) (SIZE == 106)\n+#define AVOID_FP_TYPE_CONVERSION(SIZE) (SIZE == 106)\n+#elif defined(WIDEST_HARDWARE_FP_SIZE)\n+#define AVOID_FP_TYPE_CONVERSION(SIZE) (SIZE > WIDEST_HARDWARE_FP_SIZE)\n #else\n-#define IS_IBM_EXTENDED(SIZE) 0\n+#define AVOID_FP_TYPE_CONVERSION(SIZE) 0\n #endif\n \n /* In the first part of this file, we are interfacing to calls generated"}]}