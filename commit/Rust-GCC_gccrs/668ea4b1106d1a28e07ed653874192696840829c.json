{"sha": "668ea4b1106d1a28e07ed653874192696840829c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY4ZWE0YjExMDZkMWEyOGUwN2VkNjUzODc0MTkyNjk2ODQwODI5Yw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-10-14T20:09:41Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2010-10-14T20:09:41Z"}, "message": "add @property to ObjC*\n\tmerge from FSF apple 'trunk' branch. \n\t2006 Fariborz Jahanian <fjahanian@apple.com>\n\t\n\tRadars 4436866, 4505126, 4506903, 4517826\n\ngcc/c-family: \n\n\t* c-common.c (c_common_resword): Define @property and its attributes.\n\t* c-common.h: Define property attribute enum entries.\n\t(OBJC_IS_PATTR_KEYWORD): New.\n\t(objc_property_attribute_kind): New enum.\n\tDeclare objc_set_property_attr (), objc_add_property_variable (),\n\tobjc_build_getter_call () and objc_build_setter_call ().\n\t* stub-objc.c (objc_set_property_attr): New stub.\n\t(objc_add_property_variable): Likewise.\n\t(objc_build_getter_call): Likewise.\n\t(objc_build_setter_call) Likewise.\n\ngcc:\n\n\t* c-parser.c (c_parser, objc_property_attr_context) New flag.\n\t(c_lex_one_token): Handle property attributes.\n\t(c_parser_external_declaration): Handle @property.\n\t(c_parser_declaration_or_fndef): Warn on invalid attributes before\n\t@alias, @class, @end and @property objc keywords.\n\t(c_parser_objc_methodprotolist): Handle @property.\n\t(c_parser_objc_property_attrlist): New.\n\t(c_parser_objc_at_property): New.\n\t* c-typeck.c (build_component_ref): Handle CLASS.property syntax.\n\t(build_modify_expr): Likewise.\n\ngcc/cp:\n\n\t* typeck.c (finish_class_member_access_expr): Handle CLASS.property\n\tsyntax. \n\t(cp_build_modify_expr): Likewise.\n\t* parser.c (cp_parser_objc_method_prototype_list): Handle @property.\n\t(cp_parser_objc_method_definition_list): Likewise.\n\t(cp_parser_objc_property_decl): New.\n\t(cp_parser_objc_property_attrlist): New.\n\t(cp_parser_objc_at_property): New.\n\ngcc/objc:\n\n\t* objc-act.c (CALL_EXPR_OBJC_PROPERTY_GETTER): New.\n\tproperty_readonly, property_getter, property_setter, property_ivar,\n\tproperty_copies, in_objc_property_setter_name_context: New vars.\n\t(objc_set_property_attr): New.\n\t(objc_add_property_variable): New.\n\t(lookup_property_in_list): New.\n\t(lookup_property): New.\n\t(objc_build_getter_call): New.\n\t(objc_setter_func_call): New.\n\t(get_selector_from_reference): New.\n\t(objc_build_setter_call): New.\n\t(is_property): New.\n\t(build_property_reference): New.\n\t(objc_finish_message_expr): Detect readonly property and warn.\n\t(objc_build_property_ivar_name): New.\n\t(objc_build_property_setter_name): New.\n\t(objc_gen_one_property_datum): New.\n\t(objc_process_getter_setter): New.\n\t(objc_synthesize_getter): New.\n\t(objc_synthesize_setter): New.\n\t(objc_gen_property_data): New.\n\t(finish_class): Generate property data.\n\t(comp_proto_with_proto): Separated from ...\n\t(match_proto_with_proto): ... New.\n\t(objc_lookup_ivar): Handle properties.\n\t* objc-tree.def (PROPERTY_DECL): New tree code.\n\t* objc-act.h: CLASS_LANG_SLOT_ELTS, PROTOCOL_LANG_SLOT_ELTS update size.\n\t(METHOD_PROPERTY_CONTEXT): New.\n\t(PROPERTY_NAME): New.\n\t(PROPERTY_GETTER_NAME): New.\n\t(PROPERTY_SETTER_NAME): New.\n\t(PROPERTY_IVAR_NAME): New.\n\t(PROPERTY_READONLY): New.\n\t(PROPERTY_COPIES): New.\n\t(TOTAL_CLASS_RAW_IVARS): New.\n\t(CLASS_PROPERTY_DECL): New.\n\t(IMPL_PROPERTY_DECL): New.\n\t* objc-lang.c (objc_init_ts): Update fields for property_decl.\n\ngcc/objcp:\n\n\t* objcp-lang.c (objcxx_init_ts): Update for property_decl.\n\nFrom-SVN: r165479", "tree": {"sha": "2460cc4b29d1b167cadadbf17f50074e1a75ef92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2460cc4b29d1b167cadadbf17f50074e1a75ef92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/668ea4b1106d1a28e07ed653874192696840829c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668ea4b1106d1a28e07ed653874192696840829c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/668ea4b1106d1a28e07ed653874192696840829c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668ea4b1106d1a28e07ed653874192696840829c/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e05eee4908da6139ecdfe1be68af5b58418ceedf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e05eee4908da6139ecdfe1be68af5b58418ceedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e05eee4908da6139ecdfe1be68af5b58418ceedf"}], "stats": {"total": 1427, "additions": 1408, "deletions": 19}, "files": [{"sha": "262a377d108182ad15a263d79b0bb5d4ec93376c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -1,3 +1,20 @@\n+2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tmerge from FSF apple 'trunk' branch. \n+\t2006 Fariborz Jahanian <fjahanian@apple.com>\n+\t\n+\tRadars 4436866, 4505126, 4506903, 4517826\n+\t* c-parser.c (c_parser, objc_property_attr_context) New flag.\n+\t(c_lex_one_token): Handle property attributes.\n+\t(c_parser_external_declaration): Handle @property.\n+\t(c_parser_declaration_or_fndef): Warn on invalid attributes before\n+\t@alias, @class, @end and @property objc keywords.\n+\t(c_parser_objc_methodprotolist): Handle @property.\n+\t(c_parser_objc_property_attrlist): New.\n+\t(c_parser_objc_at_property): New.\n+\t* c-typeck.c (build_component_ref): Handle CLASS.property syntax.\n+\t(build_modify_expr): Likewise.\n+\n 2010-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/46008"}, {"sha": "5ba4659ba30707525af61af9b3565614cef2e163", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -1,3 +1,20 @@\n+2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tmerge from FSF apple 'trunk' branch. \n+\t2006 Fariborz Jahanian <fjahanian@apple.com>\n+\t\n+\tRadars 4436866, 4505126, 4506903, 4517826\n+\t* c-common.c (c_common_resword): Define @property and its attributes.\n+\t* c-common.h: Define property attribute enum entries.\n+\t(OBJC_IS_PATTR_KEYWORD): New.\n+\t(objc_property_attribute_kind): New enum.\n+\tDeclare objc_set_property_attr (), objc_add_property_variable (),\n+\tobjc_build_getter_call () and objc_build_setter_call ().\n+\t* stub-objc.c (objc_set_property_attr): New stub.\n+\t(objc_add_property_variable): Likewise.\n+\t(objc_build_getter_call): Likewise.\n+\t(objc_build_setter_call) Likewise.\n+\t\n 2010-10-13  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tmerge from FSF apple 'trunk' branch. "}, {"sha": "5203c0538ee36b28cd696fdf158b5bc8bfbe4b8b", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -543,6 +543,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"synchronized\",\tRID_AT_SYNCHRONIZED,\tD_OBJC },\n   { \"optional\",\t\tRID_AT_OPTIONAL,\tD_OBJC },\n   { \"required\",\t\tRID_AT_REQUIRED,\tD_OBJC },\n+  { \"property\",\t\tRID_AT_PROPERTY,\tD_OBJC },\n   /* These are recognized only in protocol-qualifier context\n      (see above) */\n   { \"bycopy\",\t\tRID_BYCOPY,\t\tD_OBJC },\n@@ -551,6 +552,12 @@ const struct c_common_resword c_common_reswords[] =\n   { \"inout\",\t\tRID_INOUT,\t\tD_OBJC },\n   { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC },\n   { \"out\",\t\tRID_OUT,\t\tD_OBJC },\n+  /* These are recognized inside a property attribute list */\n+  { \"readonly\",\t\tRID_READONLY,\t\tD_OBJC }, \n+  { \"copies\",\t\tRID_COPIES,\t\tD_OBJC },\n+  { \"getter\",\t\tRID_GETTER,\t\tD_OBJC }, \n+  { \"setter\",\t\tRID_SETTER,\t\tD_OBJC }, \n+  { \"ivar\",\t\tRID_IVAR,\t\tD_OBJC }, \n };\n \n const unsigned int num_c_common_reswords ="}, {"sha": "8c79d27d9dd0f744735784dc1ccd38c164900be6", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -80,6 +80,10 @@ enum rid\n      are keywords only in specific contexts)  */\n   RID_IN, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n \n+  /* ObjC (\"PATTR\" reserved words - they do not appear after a '@' \n+     and are keywords only as property attributes)  */\n+  RID_READONLY, RID_COPIES, RID_GETTER, RID_SETTER, RID_IVAR,\n+\n   /* C (reserved and imaginary types not implemented, so any use is a\n      syntax error) */\n   RID_IMAGINARY,\n@@ -143,7 +147,7 @@ enum rid\n   RID_AT_PROTOCOL, RID_AT_SELECTOR,\n   RID_AT_THROW,\t   RID_AT_TRY,       RID_AT_CATCH,\n   RID_AT_FINALLY,  RID_AT_SYNCHRONIZED, \n-  RID_AT_OPTIONAL, RID_AT_REQUIRED,\n+  RID_AT_OPTIONAL, RID_AT_REQUIRED, RID_AT_PROPERTY,\n   RID_AT_INTERFACE,\n   RID_AT_IMPLEMENTATION,\n \n@@ -181,7 +185,9 @@ enum rid\n   RID_FIRST_AT = RID_AT_ENCODE,\n   RID_LAST_AT = RID_AT_IMPLEMENTATION,\n   RID_FIRST_PQ = RID_IN,\n-  RID_LAST_PQ = RID_ONEWAY\n+  RID_LAST_PQ = RID_ONEWAY,\n+  RID_FIRST_PATTR = RID_READONLY,\n+  RID_LAST_PATTR = RID_IVAR\n };\n \n #define OBJC_IS_AT_KEYWORD(rid) \\\n@@ -192,6 +198,10 @@ enum rid\n   ((unsigned int) (rid) >= (unsigned int) RID_FIRST_PQ && \\\n    (unsigned int) (rid) <= (unsigned int) RID_LAST_PQ)\n \n+#define OBJC_IS_PATTR_KEYWORD(rid) \\\n+  ((unsigned int) (rid) >= (unsigned int) RID_FIRST_PATTR && \\\n+   (unsigned int) (rid) <= (unsigned int) RID_LAST_PATTR)\n+\n /* OBJC_IS_CXX_KEYWORD recognizes the 'CXX_OBJC' keywords (such as\n    'class') which are shared in a subtle way between Objective-C and\n    C++.  When the lexer is lexing in Objective-C/Objective-C++, if it\n@@ -420,6 +430,16 @@ extern c_language_kind c_language;\n #define c_dialect_cxx()\t\t((c_language & clk_cxx) != 0)\n #define c_dialect_objc()\t((c_language & clk_objc) != 0)\n \n+/* ObjC Property Attribute types.  */\n+typedef enum objc_property_attribute_kind {\n+  OBJC_PATTR_INIT\t= 0,\n+  OBJC_PATTR_READONLY\t= 1,\n+  OBJC_PATTR_GETTER\t= 2,\n+  OBJC_PATTR_SETTER\t= 3,\n+  OBJC_PATTR_IVAR\t= 4,\n+  OBJC_PATTR_COPIES\t= 5\n+} objc_property_attribute_kind;\n+\n /* The various name of operator that appears in error messages. */\n typedef enum ref_operator {\n   /* NULL */\n@@ -1009,7 +1029,12 @@ extern tree objc_generate_static_init_call (tree);\n extern tree objc_generate_write_barrier (tree, enum tree_code, tree);\n extern void objc_set_method_opt (bool);\n extern void objc_finish_foreach_loop (location_t, tree, tree, tree, tree, tree);\n+extern void objc_set_property_attr \n+  (location_t, objc_property_attribute_kind, tree);\n extern bool  objc_method_decl (enum tree_code);\n+extern void objc_add_property_variable (tree);\n+extern tree objc_build_getter_call (tree, tree);\n+extern tree objc_build_setter_call (tree, tree);\n \n /* The following are provided by the C and C++ front-ends, and called by\n    ObjC/ObjC++.  */"}, {"sha": "4a8a2b56b8e664659b49ee22c10366703556e373", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -314,6 +314,30 @@ objc_get_class_ivars (tree ARG_UNUSED (name))\n   return 0;\n }\n \n+void\n+objc_set_property_attr (location_t ARG_UNUSED (loc),\n+\t\t\tobjc_property_attribute_kind ARG_UNUSED (code),\n+\t\t\ttree ARG_UNUSED (identifier))\n+{\n+}\n+\n+void\n+objc_add_property_variable (tree ARG_UNUSED (prop))\n+{\n+}\n+\n+tree\n+objc_build_getter_call (tree ARG_UNUSED (datum), tree ARG_UNUSED (component))\n+{\n+  return 0;\n+}\n+\n+tree\n+objc_build_setter_call (tree ARG_UNUSED (lhs), tree ARG_UNUSED (rhs))\n+{\n+  return 0;\n+}\n+\n tree\n objc_build_throw_stmt (location_t ARG_UNUSED (loc), tree ARG_UNUSED (expr))\n {"}, {"sha": "36ed95131f14a6b55adb2b76ca70cad42f482ac8", "filename": "gcc/c-parser.c", "status": "modified", "additions": 167, "deletions": 1, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -195,6 +195,9 @@ typedef struct GTY(()) c_parser {\n      undesirable to bind an identifier to an Objective-C class, even\n      if a class with that name exists.  */\n   BOOL_BITFIELD objc_need_raw_identifier : 1;\n+  /* True if we are in a context where the Objective-C \"Property attribute\"\n+     keywords are valid.  */\n+  BOOL_BITFIELD objc_property_attr_context : 1;\n } c_parser;\n \n \n@@ -283,6 +286,20 @@ c_lex_one_token (c_parser *parser, c_token *token)\n \t\t   normal tokens.\n \t\t*/\n \t      }\n+\t    else if (c_dialect_objc () && OBJC_IS_PATTR_KEYWORD (rid_code))\n+\t      {\n+\t\t/* We found an Objective-C \"property attribute\" keyword \n+\t\t   (readonly, copies, getter, setter, ivar). These are \n+\t\t   only valid in the property context.  */\n+\t\tif (parser->objc_property_attr_context)\n+\t\t  {\n+\t\t    token->type = CPP_KEYWORD;\n+\t\t    token->keyword = rid_code;\n+\t\t    break;\n+\t\t  }\n+\t\t/* Else they are not special keywords.\n+\t\t*/\n+\t      }\n \t    else if (c_dialect_objc () \n \t\t     && (OBJC_IS_AT_KEYWORD (rid_code)\n \t\t\t || OBJC_IS_CXX_KEYWORD (rid_code)))\n@@ -573,6 +590,8 @@ c_token_starts_declaration (c_token *token)\n     return false;\n }\n \n+static c_token *c_parser_peek_2nd_token (c_parser *parser);\n+\n /* Return true if the next token from PARSER can start declaration\n    specifiers, false otherwise.  */\n static inline bool\n@@ -1062,7 +1081,8 @@ static tree c_parser_objc_selector_arg (c_parser *);\n static tree c_parser_objc_receiver (c_parser *);\n static tree c_parser_objc_message_args (c_parser *);\n static tree c_parser_objc_keywordexpr (c_parser *);\n-static bool c_parser_objc_diagnose_bad_element_prefix \n+static void c_parser_objc_at_property (c_parser *) ;\n+static bool c_parser_objc_diagnose_bad_element_prefix\n   (c_parser *, struct c_declspecs *);\n \n /* Parse a translation unit (C90 6.7, C99 6.9).\n@@ -1161,6 +1181,10 @@ c_parser_external_declaration (c_parser *parser)\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_objc_protocol_definition (parser, NULL_TREE);\n \t  break;\n+\tcase RID_AT_PROPERTY:\n+\t  gcc_assert (c_dialect_objc ());\n+\t  c_parser_objc_at_property (parser);\n+\t  break;\n \tcase RID_AT_END:\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_consume_token (parser);\n@@ -1378,6 +1402,17 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    return;\n \t  }\n \t  break;\n+\tcase RID_AT_ALIAS:\n+\tcase RID_AT_CLASS:\n+\tcase RID_AT_END:\n+\tcase RID_AT_PROPERTY:\n+\t  if (specs->attrs)\n+\t    {\n+\t      c_parser_error (parser, \n+\t      \t\t      \"attributes may not be specified before\" );\n+\t      specs->attrs = NULL;\n+\t    }\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n@@ -6942,6 +6977,8 @@ c_parser_objc_methodprotolist (c_parser *parser)\n \tdefault:\n \t  if (c_parser_next_token_is_keyword (parser, RID_AT_END))\n \t    return;\n+\t  else if (c_parser_next_token_is_keyword (parser, RID_AT_PROPERTY))\n+\t    c_parser_objc_at_property (parser);\n \t  else if (c_parser_next_token_is_keyword (parser, RID_AT_OPTIONAL))\n \t    {\n \t      objc_set_method_opt (true);\n@@ -7517,6 +7554,135 @@ c_parser_objc_diagnose_bad_element_prefix (c_parser *parser,\n     }\n   return false;\n }\n+\n+/* ObjC @property. */\n+\n+/* Parse a comma-separated list of property attributes.  */\n+\n+static void\n+c_parser_objc_property_attrlist (c_parser *parser)\n+{\n+  bool err = false;\n+  /* Initialize to an empty list.  */\n+  objc_set_property_attr (c_parser_peek_token (parser)->location,\n+\t\t\t  OBJC_PATTR_INIT, NULL_TREE);\n+\n+  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n+    return;\n+\n+  /* Eat the '(' */\n+  c_parser_consume_token (parser);\n+  \n+  /* Property attribute keywords are valid now.  */\n+  parser->objc_property_attr_context = true;\n+  while (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN)\n+\t && c_parser_next_token_is_not (parser, CPP_EOF)\n+\t && !err)\n+    {\n+      enum rid keywd;\n+      location_t loc;\n+      if (c_parser_peek_token (parser)->type != CPP_KEYWORD)\n+\t{\n+\t  c_parser_error (parser, \"expected a property attribute\");\n+\t  c_parser_consume_token (parser);\n+\t  err = true;\n+\t  break;\n+\t}\n+      keywd = c_parser_peek_token (parser)->keyword;\n+      /* Initially, make diagnostics point to the attribute.  */\n+      loc = c_parser_peek_token (parser)->location;\n+      switch (keywd)\n+\t{\n+\t  tree ident;\n+\t  objc_property_attribute_kind pkind;\n+\t  case RID_READONLY:\n+\t    objc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n+\t    break;\n+\t  case RID_GETTER:\n+\t  case RID_SETTER:\n+\t  case RID_IVAR:\n+\t    c_parser_consume_token (parser);\n+\t    if (c_parser_next_token_is_not (parser, CPP_EQ))\n+\t      {\n+\t\tc_parser_error (parser, \n+\t\t  \"getter/setter/ivar attribute must be followed by %<=%>\");\n+\t\terr = true;\n+\t\tbreak;\n+\t      }\n+\t    c_parser_consume_token (parser); /* eat the = */\n+\t    if (c_parser_next_token_is_not (parser, CPP_NAME))\n+\t      {\n+\t\tc_parser_error (parser, \"expected an identifier\");\n+\t\terr = true;\n+\t\tbreak;\n+\t      }\n+\t    ident = c_parser_peek_token (parser)->value;\n+\t    if (keywd == RID_SETTER)\n+\t      {\n+\t\tpkind = OBJC_PATTR_SETTER;\n+\t\t/* Eat the identifier, and look for the following : */\n+\t\tc_parser_consume_token (parser);\n+\t\tif (c_parser_next_token_is_not (parser, CPP_COLON))\n+\t\t  {\n+\t\t    c_parser_error (parser,\n+\t\t\t\t\"setter name must be followed by %<:%>\");\n+\t\t    err = true;\n+\t\t  }\n+\t      }\n+\t    else if (keywd == RID_GETTER)\n+\t      pkind = OBJC_PATTR_GETTER;\n+\t    else\n+\t      pkind = OBJC_PATTR_IVAR;\n+\t    \n+\t    objc_set_property_attr (loc, pkind, ident);\n+\t    break;\n+\t  case RID_COPIES:\n+\t    objc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n+\t    break;\n+\t  default:\n+\t    c_parser_error (parser, \"unknown property attribute\");\n+\t    err = true;\n+\t    break;\n+\t}\n+      /* Eat the attribute,identifier or colon that's been used.  */\n+      c_parser_consume_token (parser);\n+      if (err)\n+        break;\n+\n+      if (c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+      else if (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n+\twarning_at (c_parser_peek_token (parser)->location, 0, \n+\t\t    \"property attributes should be separated by a %<,%>\");\n+    }  \n+  parser->objc_property_attr_context = false;\n+  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+}\n+\n+/* Parse property attributes and then the definition.  */\n+\n+static void\n+c_parser_objc_at_property (c_parser *parser)\n+{\n+  tree props;\n+  /* We should only arrive here with the property keyword.  */\n+  c_parser_require_keyword (parser, RID_AT_PROPERTY, \"expected %<@property%>\");\n+\n+  /* Process the optional attribute list...  */\n+  c_parser_objc_property_attrlist (parser) ;\n+  /* ... and the property var decls.  */\n+  props = c_parser_struct_declaration (parser);\n+\n+  /* Comma-separated properties are chained together in\n+     reverse order; add them one by one.  */\n+  props = nreverse (props);\n+\n+  for (; props; props = TREE_CHAIN (props))\n+    objc_add_property_variable (copy_node (props));\n+\n+  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+}\n+\n \f\n /* Handle pragmas.  Some OpenMP pragmas are associated with, and therefore\n    should be considered, statements.  ALLOW_STMT is true if we're within"}, {"sha": "9a7cdc51c46736c20c7141884ef9c90cf93ab91e", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -2130,6 +2130,10 @@ build_component_ref (location_t loc, tree datum, tree component)\n   if (!objc_is_public (datum, component))\n     return error_mark_node;\n \n+  if (c_dialect_objc ()\n+      && (ref = objc_build_getter_call (datum, component)))\n+    return ref;\n+\n   /* See if there is a field or component with name COMPONENT.  */\n \n   if (code == RECORD_TYPE || code == UNION_TYPE)\n@@ -4837,7 +4841,8 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)\n     return error_mark_node;\n \n-  if (!lvalue_or_else (lhs, lv_assign))\n+  /* For ObjC, defer this check until we have assessed CLASS.property.   */\n+  if (!c_dialect_objc () && !lvalue_or_else (lhs, lv_assign))\n     return error_mark_node;\n \n   if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n@@ -4878,6 +4883,15 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n       rhs_origtype = NULL_TREE;\n     }\n \n+  if (c_dialect_objc ())\n+    {\n+      result = objc_build_setter_call (lhs, newrhs);\n+      if (result)\n+\treturn result;\n+      if (!lvalue_or_else (lhs, lv_assign))\n+\treturn error_mark_node;\n+    }\n+\n   /* Give an error for storing in something that is 'const'.  */\n \n   if (TYPE_READONLY (lhstype)"}, {"sha": "20ca6a6fef29ce0b0c9a58814c9120690cadd15a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -1,3 +1,18 @@\n+2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tmerge from FSF apple 'trunk' branch. \n+\t2006 Fariborz Jahanian <fjahanian@apple.com>\n+\t\n+\tRadars 4436866, 4505126, 4506903, 4517826\n+\t* typeck.c (finish_class_member_access_expr): Handle CLASS.property\n+\tsyntax. \n+\t(cp_build_modify_expr): Likewise.\n+\t* parser.c (cp_parser_objc_method_prototype_list): Handle @property.\n+\t(cp_parser_objc_method_definition_list): Likewise.\n+\t(cp_parser_objc_property_decl): New.\n+\t(cp_parser_objc_property_attrlist): New.\n+\t(cp_parser_objc_at_property): New.\n+\n 2010-10-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/44561"}, {"sha": "3e02cd500d2201ff663c8780ecceedaf7d3a3f03", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 149, "deletions": 1, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -2097,7 +2097,11 @@ static void cp_parser_objc_declaration\n static tree cp_parser_objc_statement\n   (cp_parser *);\n static bool cp_parser_objc_valid_prefix_attributes\n-  (cp_parser* parser, tree *attrib);\n+  (cp_parser *, tree *);\n+static void cp_parser_objc_at_property \n+  (cp_parser *) ;\n+static void cp_parser_objc_property_decl \n+  (cp_parser *) ;\n \n /* Utility Routines */\n \n@@ -21718,6 +21722,8 @@ cp_parser_objc_method_prototype_list (cp_parser* parser)\n \t  objc_add_method_declaration (sig, attributes);\n \t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n \t}\n+      else if (token->keyword == RID_AT_PROPERTY)\n+\tcp_parser_objc_at_property (parser);\n       else if (token->keyword == RID_ATTRIBUTE \n       \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n \twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n@@ -21779,6 +21785,8 @@ cp_parser_objc_method_definition_list (cp_parser* parser)\n \t      objc_finish_method_definition (meth);\n \t    }\n \t}\n+      else if (token->keyword == RID_AT_PROPERTY)\n+\tcp_parser_objc_at_property (parser);\n       else if (token->keyword == RID_ATTRIBUTE \n       \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n \twarning_at (token->location, OPT_Wattributes,\n@@ -22271,6 +22279,146 @@ cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)\n   cp_lexer_rollback_tokens (parser->lexer);\n   return false;  \n }\n+\n+/* This routine parses the propery declarations. */\n+\n+static void\n+cp_parser_objc_property_decl (cp_parser *parser)\n+{\n+  int declares_class_or_enum;\n+  cp_decl_specifier_seq declspecs;\n+\n+  cp_parser_decl_specifier_seq (parser,\n+                                CP_PARSER_FLAGS_NONE,\n+                                &declspecs,\n+                                &declares_class_or_enum);\n+  /* Keep going until we hit the `;' at the end of the declaration. */\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    {\n+      tree property;\n+      cp_token *token;\n+      cp_declarator *declarator\n+\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\tNULL, NULL, false);\n+      property = grokdeclarator (declarator, &declspecs, NORMAL,0, NULL);\n+      /* Recover from any kind of error in property declaration. */\n+      if (property == error_mark_node || property == NULL_TREE)\n+\treturn;\n+\n+      /* Add to property list. */\n+      objc_add_property_variable (copy_node (property));\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_COMMA)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+\t  continue;\n+\t}\n+      else if (token->type == CPP_EOF)\n+\tbreak;\n+    }\n+  /* Eat ';' if present, or issue an error.  */\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+}\n+\n+/* ObjC @property. */\n+/* Parse a comma-separated list of property attributes.  \n+   The lexer does not recognize */\n+\n+static void \n+cp_parser_objc_property_attrlist (cp_parser *parser)\n+{\n+  cp_token *token;\n+  /* Initialize to an empty list.  */\n+  objc_set_property_attr (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t  OBJC_PATTR_INIT, NULL_TREE);\n+\n+  /* The list is optional.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n+    return;\n+\n+  /* Eat the '('.  */\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  token = cp_lexer_peek_token (parser->lexer);\n+  while (token->type != CPP_CLOSE_PAREN && token->type != CPP_EOF)\n+    {\n+      location_t loc = token->location;\n+      tree node = cp_parser_identifier (parser);\n+      if (node == ridpointers [(int) RID_READONLY])\n+\tobjc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n+      else if (node == ridpointers [(int) RID_GETTER]\n+\t       || node == ridpointers [(int) RID_SETTER]\n+\t       || node == ridpointers [(int) RID_IVAR])\n+\t{\n+\t  /* Do the getter/setter/ivar attribute. */\n+\t  token = cp_lexer_consume_token (parser->lexer);\n+\t  if (token->type == CPP_EQ)\n+\t    {\n+\t      tree attr_ident = cp_parser_identifier (parser);\n+\t      objc_property_attribute_kind pkind;\n+\t      if (node == ridpointers [(int) RID_GETTER])\n+\t\tpkind = OBJC_PATTR_GETTER;\n+\t      else if (node == ridpointers [(int) RID_SETTER])\n+\t\t{\n+\t\t  pkind = OBJC_PATTR_SETTER;\n+\t\t  /* Consume the ':' which must always follow the setter name. */\n+\t\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+\t\t    cp_lexer_consume_token (parser->lexer); \n+\t\t  else\n+\t\t    {\n+\t\t      error_at (token->location,\n+\t\t\t\t\"setter name must be followed by %<:%>\");\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      else \n+\t\tpkind = OBJC_PATTR_IVAR;\n+\t      objc_set_property_attr (loc, pkind, attr_ident);\t  \n+\t    }\n+\t  else\n+\t    {\n+\t      error_at (token->location,\n+\t      \t\"getter/setter/ivar attribute must be followed by %<=%>\");\n+\t      break;\n+\t    }\n+\t}\n+      else if (node == ridpointers [(int) RID_COPIES])\n+\tobjc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n+      else\n+\t{\n+\t  error_at (token->location,\"unknown property attribute\");\n+\t  break;\n+\t}\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+\twarning_at (token->location, 0, \n+\t\t    \"property attributes should be separated by a %<,%>\");\n+      token = cp_lexer_peek_token (parser->lexer);\t  \n+    }\n+\n+  if (token->type != CPP_CLOSE_PAREN)\n+    error_at (token->location,\n+\t      \"syntax error in @property's attribute declaration\");\n+  else\n+    /* Consume ')' */\n+    cp_lexer_consume_token (parser->lexer);\n+}\n+\n+/* This function parses a @property declaration inside an objective class\n+   or its implementation. */\n+\n+static void \n+cp_parser_objc_at_property (cp_parser *parser)\n+{\n+  /* Consume @property */\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  /* Parse optional attributes list...  */\n+  cp_parser_objc_property_attrlist (parser);\n+  /* ... and the property declaration(s).  */\n+  cp_parser_objc_property_decl (parser);\n+}\n \f\n /* OpenMP 2.5 parsing routines.  */\n "}, {"sha": "ca832c66f6b0354c827875ae637a60ed57ecb41e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -2593,7 +2593,11 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \treturn build_min_nt (COMPONENT_REF, object, name, NULL_TREE);\n       object = build_non_dependent_expr (object);\n     }\n-\n+  else if (c_dialect_objc ()\n+\t   && TREE_CODE (name) == IDENTIFIER_NODE\n+\t   && (expr = objc_build_getter_call (object, name)))\n+    return expr;\n+    \n   /* [expr.ref]\n \n      The type of the first expression shall be \"class object\" (of a\n@@ -6758,6 +6762,13 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \n       if (modifycode == NOP_EXPR)\n \t{\n+\t  if (c_dialect_objc ())\n+\t    {\n+\t      result = objc_build_setter_call (lhs, rhs);\n+\t      if (result)\n+\t\treturn result;\n+\t    }\n+\n \t  /* `operator=' is not an inheritable operator.  */\n \t  if (! MAYBE_CLASS_TYPE_P (lhstype))\n \t    /* Do the default thing.  */;\n@@ -6796,6 +6807,12 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \n \t  /* Now it looks like a plain assignment.  */\n \t  modifycode = NOP_EXPR;\n+\t  if (c_dialect_objc ())\n+\t    {\n+\t      result = objc_build_setter_call (lhs, newrhs);\n+\t      if (result)\n+\t\treturn result;\n+\t    }\n \t}\n       gcc_assert (TREE_CODE (lhstype) != REFERENCE_TYPE);\n       gcc_assert (TREE_CODE (TREE_TYPE (newrhs)) != REFERENCE_TYPE);"}, {"sha": "1a51c1444ff93d0919d0327634473a08457035ef", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -1,3 +1,48 @@\n+2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tmerge from FSF apple 'trunk' branch. \n+\t2006 Fariborz Jahanian <fjahanian@apple.com>\n+\t\n+\tRadars 4436866, 4505126, 4506903, 4517826\n+\t* objc-act.c (CALL_EXPR_OBJC_PROPERTY_GETTER): New.\n+\tproperty_readonly, property_getter, property_setter, property_ivar,\n+\tproperty_copies, in_objc_property_setter_name_context: New vars.\n+\t(objc_set_property_attr): New.\n+\t(objc_add_property_variable): New.\n+\t(lookup_property_in_list): New.\n+\t(lookup_property): New.\n+\t(objc_build_getter_call): New.\n+\t(objc_setter_func_call): New.\n+\t(get_selector_from_reference): New.\n+\t(objc_build_setter_call): New.\n+\t(is_property): New.\n+\t(build_property_reference): New.\n+\t(objc_finish_message_expr): Detect readonly property and warn.\n+\t(objc_build_property_ivar_name): New.\n+\t(objc_build_property_setter_name): New.\n+\t(objc_gen_one_property_datum): New.\n+\t(objc_process_getter_setter): New.\n+\t(objc_synthesize_getter): New.\n+\t(objc_synthesize_setter): New.\n+\t(objc_gen_property_data): New.\n+\t(finish_class): Generate property data.\n+\t(comp_proto_with_proto): Separated from ...\n+\t(match_proto_with_proto): ... New.\n+\t(objc_lookup_ivar): Handle properties.\n+\t* objc-tree.def (PROPERTY_DECL): New tree code.\n+\t* objc-act.h: CLASS_LANG_SLOT_ELTS, PROTOCOL_LANG_SLOT_ELTS update size.\n+\t(METHOD_PROPERTY_CONTEXT): New.\n+\t(PROPERTY_NAME): New.\n+\t(PROPERTY_GETTER_NAME): New.\n+\t(PROPERTY_SETTER_NAME): New.\n+\t(PROPERTY_IVAR_NAME): New.\n+\t(PROPERTY_READONLY): New.\n+\t(PROPERTY_COPIES): New.\n+\t(TOTAL_CLASS_RAW_IVARS): New.\n+\t(CLASS_PROPERTY_DECL): New.\n+\t(IMPL_PROPERTY_DECL): New.\n+\t* objc-lang.c (objc_init_ts): Update fields for property_decl.\n+\n 2010-10-13  Richard Henderson  <rth@redhat.com>\n \n \t* objc-act.c (objc_eh_personality): Update call to"}, {"sha": "88f5d6c5a48bdee7ca80c95e7a14d545c6155319", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 871, "deletions": 11, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -163,6 +163,27 @@ static void build_next_objc_exception_stuff (void);\n static bool objc_derived_from_p (tree, tree);\n #define DERIVED_FROM_P(PARENT, CHILD) objc_derived_from_p (PARENT, CHILD)\n #endif\n+\n+/* Property.  */\n+static void objc_gen_one_property_datum (tree, tree, tree, bool*);\n+static void objc_gen_property_data (tree, tree);\n+static void objc_synthesize_getter (tree, tree, tree);\n+static void objc_process_getter_setter (tree, tree, bool);\n+static void objc_synthesize_setter (tree, tree, tree);\n+static char *objc_build_property_ivar_name (tree);\n+static char *objc_build_property_setter_name (tree, bool);\n+static int match_proto_with_proto (tree, tree, int);\n+static tree lookup_property (tree, tree);\n+static tree lookup_property_in_list (tree, tree);\n+static tree lookup_property_in_protocol_list (tree, tree);\n+static tree objc_setter_func_call (tree, tree, tree);\n+static tree build_property_reference (tree, tree);\n+static tree is_property (tree, tree);\n+/* Set on a CALL_EXPR if it is for call to a getter function represented by an\n+   objective-c property declaration. */\n+#define CALL_EXPR_OBJC_PROPERTY_GETTER(NODE) \\\n+  (CALL_EXPR_CHECK(NODE)->base.deprecated_flag)\n+\n static void objc_xref_basetypes (tree, tree);\n \n static void build_class_template (void);\n@@ -194,6 +215,10 @@ static hash hash_lookup (hash *, tree);\n static tree lookup_method (tree, tree);\n static tree lookup_method_static (tree, tree, int);\n \n+static tree add_class (tree, tree);\n+static void add_category (tree, tree);\n+static inline tree lookup_category (tree, tree);\n+\n enum string_section\n {\n   class_names,\t\t/* class, category, protocol, module names */\n@@ -369,6 +394,13 @@ static int method_slot = 0;\n    required.  */\n static bool objc_method_optional_flag = false;\n \n+static bool property_readonly;\n+static tree property_getter;\n+static tree property_setter;\n+static tree property_ivar;\n+static bool property_copies;\n+static bool in_objc_property_setter_name_context = false;\n+\n static int objc_collecting_ivars = 0;\n \n #define BUFSIZE\t\t1024\n@@ -807,6 +839,449 @@ objc_set_method_opt (bool optional)\n     }\n }\n \n+/* This routine gathers property attribute information from the attribute\n+   portion of a property declaration. */\n+\n+void\n+objc_set_property_attr (location_t loc, objc_property_attribute_kind attr,\n+\t\t\ttree ident)\n+{\n+  static char string[BUFSIZE];\n+  switch (attr)\n+    {\n+    case OBJC_PATTR_INIT: /* init */\n+\tproperty_readonly = property_copies = false;\n+\tproperty_setter = property_getter = property_ivar = NULL_TREE;\n+\tbreak;\n+    case OBJC_PATTR_READONLY: /* readonly */\n+\tproperty_readonly = true;\n+\tbreak;\n+    case OBJC_PATTR_GETTER: /* getter = ident */\n+\tif (property_getter != NULL_TREE)\n+\t  error_at (loc, \"the %<getter%> attribute may only be specified once\");\n+        property_getter = ident;\n+\tbreak;\n+    case OBJC_PATTR_SETTER: /* setter = ident */\n+\tif (property_setter != NULL_TREE)\n+\t  error_at (loc, \"the %<setter%> attribute may only be specified once\");\n+\t/* setters always have a trailing ':' in their name. In fact, this is the\n+\t   only syntax that parser recognizes for a setter name. Must add a trailing\n+\t   ':' here so name matches that of the declaration of user instance method\n+\t   for the setter. */\n+\tsprintf (string, \"%s:\", IDENTIFIER_POINTER (ident));\n+\tproperty_setter = get_identifier (string);;\n+\tbreak;\n+    case OBJC_PATTR_IVAR: /* ivar = ident */\n+\tif (property_ivar != NULL_TREE)\n+\t  error_at (loc, \"the %<ivar%> attribute may only be specified once\");\n+\telse if (objc_interface_context) \n+\t  {\n+\t    warning_at (loc, 0, \"the %<ivar%> attribute is ignored in an @interface\");\n+\t    property_ivar = NULL_TREE;\n+\t  }\n+\telse\n+\t  property_ivar = ident;\n+\tbreak;\n+    case OBJC_PATTR_COPIES: /* copies */\n+\tproperty_copies = true;\n+\tbreak;\n+    default:\n+\tbreak;\n+    }\n+}\n+\n+/* This routine builds a 'property_decl' tree node and adds it to the list\n+   of such properties in the current class. It also checks for duplicates.\n+*/\n+\n+void\n+objc_add_property_variable (tree decl)\n+{\n+  tree property_decl;\n+  tree x;\n+  tree interface = NULL_TREE;\n+\n+  if (objc_implementation_context)\n+    {\n+      interface = lookup_interface (CLASS_NAME (objc_implementation_context));\n+      if (!interface)\n+\t{\n+\t  error (\"no class property can be implemented without an interface\");\n+\t  return;\n+\t}\n+      if (TREE_CODE (objc_implementation_context) == CATEGORY_IMPLEMENTATION_TYPE)\n+        {\n+\t  interface = lookup_category (interface, \n+\t\t\t\t     CLASS_SUPER_NAME (objc_implementation_context));\t\n+\t  if (!interface)\n+\t    {\n+\t      error (\"no category property can be implemented without an interface\");\n+\t      return;\n+\t    }\n+        }\n+    }\n+  else if (!objc_interface_context)\n+    {\n+      fatal_error (\"property declaration not in @interface or @implementation context\");\n+      return;\n+    }\n+\n+  property_decl = make_node (PROPERTY_DECL);\n+  TREE_TYPE (property_decl) = TREE_TYPE (decl);\n+\n+  PROPERTY_NAME (property_decl) = DECL_NAME (decl);\n+  PROPERTY_GETTER_NAME (property_decl) = property_getter;\n+  PROPERTY_SETTER_NAME (property_decl) = property_setter;\n+  PROPERTY_IVAR_NAME (property_decl) = property_ivar;\n+  PROPERTY_READONLY (property_decl) = property_readonly \n+\t\t\t\t\t? boolean_true_node \n+\t\t\t\t\t: boolean_false_node;\n+  PROPERTY_COPIES (property_decl) = property_copies \n+\t\t\t\t\t? boolean_true_node \n+\t\t\t\t\t: boolean_false_node;\n+\n+  if (objc_interface_context)\n+    {\n+      /* Doing the property in interface declaration. */\n+\n+      /* Issue error if property and an ivar name match. */\n+      if (TREE_CODE (objc_interface_context) == CLASS_INTERFACE_TYPE\n+\t  && is_ivar (CLASS_IVARS (objc_interface_context), DECL_NAME (decl)))\n+\terror (\"property %qD may not have the same name as an ivar in the class\", decl);\n+      /* must check for duplicate property declarations. */\n+      for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n+\t{\n+\t  if (PROPERTY_NAME (x) == DECL_NAME (decl))\n+\t    {\n+\t      error (\"duplicate property declaration %qD\", decl);\n+\t      return;\n+\t    }\n+\t}\n+      TREE_CHAIN (property_decl) = CLASS_PROPERTY_DECL (objc_interface_context);\n+      CLASS_PROPERTY_DECL (objc_interface_context) = property_decl;\n+    }\n+  else\n+    {\n+      /* Doing the property in implementation context. */\n+      /* If property is not declared in the interface issue error. */\n+      for (x = CLASS_PROPERTY_DECL (interface); x; x = TREE_CHAIN (x))\n+\tif (PROPERTY_NAME (x) == DECL_NAME (decl))\n+\t  break;\n+      if (!x)\n+\t{\n+\t  error (\"no declaration of property %qD found in the interface\", decl);\n+\t  return;\n+\t}\n+      /* readonlys must also match. */\n+      if (PROPERTY_READONLY (x) != PROPERTY_READONLY (property_decl))\n+\t{\n+\t  error (\"property %qD %<readonly%> attribute conflicts with its\" \n+\t\t \" interface version\", decl);\n+\t}\n+      /* copies must also match. */\n+      if (PROPERTY_COPIES (x) != PROPERTY_COPIES (property_decl))\n+\t{\n+\t  error (\"property %qD %<copies%> attribute conflicts with its\" \n+\t\t \" interface version\", decl);\n+\t}\n+      /* Cannot have readonly and setter attribute for the same property. */\n+      if (PROPERTY_READONLY (property_decl) == boolean_true_node &&\n+\t  PROPERTY_SETTER_NAME (property_decl))\n+\t{\n+\t  warning (0, \"a %<readonly%> property cannot have a setter (ignored)\");\n+\t  PROPERTY_SETTER_NAME (property_decl) = NULL_TREE;\n+\t}\n+      /* Add the property to the list of properties for current implementation. */\n+      TREE_CHAIN (property_decl) = IMPL_PROPERTY_DECL (objc_implementation_context);\n+      IMPL_PROPERTY_DECL (objc_implementation_context) = property_decl;\n+    }\n+}\n+\n+/* This routine looks for a given PROPERTY in a list of CLASS, CATEGORY, or\n+   PROTOCOL.\n+*/\n+static tree\n+lookup_property_in_list (tree chain, tree property)\n+{\n+  tree x;\n+  for (x = CLASS_PROPERTY_DECL (chain); x; x = TREE_CHAIN (x))\n+    if (PROPERTY_NAME (x) == property)\n+      return x;\n+  return NULL_TREE;\n+}\n+\n+/* This routine looks for a given PROPERTY in the tree chain of RPROTO_LIST. */\n+\n+static tree lookup_property_in_protocol_list (tree rproto_list, tree property)\n+{\n+  tree rproto, x;\n+  for (rproto = rproto_list; rproto; rproto = TREE_CHAIN (rproto))\n+    {\n+      tree p = TREE_VALUE (rproto);\n+      if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n+\t{\n+\t  if ((x = lookup_property_in_list (p, property)))\n+\t    return x;\n+\t  if (PROTOCOL_LIST (p))\n+\t    return lookup_property_in_protocol_list (PROTOCOL_LIST (p), property);\n+\t}\n+      else\n+\t{\n+\t  ; /* An identifier...if we could not find a protocol.  */\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* This routine looks up the PROPERTY in current INTERFACE, its categories and up the\n+   chain of interface hierarchy.\n+*/\n+static tree\n+lookup_property (tree interface_type, tree property)\n+{\n+  tree inter = interface_type;\n+  while (inter)\n+    {\n+      tree x, category;\n+      if ((x = lookup_property_in_list (inter, property)))\n+\treturn x;\n+      /* Failing that, look for the property in each category of the class.  */\n+      category = inter;\n+      while ((category = CLASS_CATEGORY_LIST (category)))\n+\tif ((x = lookup_property_in_list (category, property)))\n+\t  return x;\n+\n+      /*  Failing to find in categories, look for property in protocol list. */\n+      if (CLASS_PROTOCOL_LIST (inter) \n+\t  && (x = lookup_property_in_protocol_list (\n+\t\t    CLASS_PROTOCOL_LIST (inter), property)))\n+\treturn x;\n+      \n+      /* Failing that, climb up the inheritance hierarchy.  */\n+      inter = lookup_interface (CLASS_SUPER_NAME (inter));\n+    }\n+  return inter;\n+}\n+\n+/* This routine recognizes a dot-notation for a propery reference and generates a call to\n+   the getter function for this property. In all other cases, it returns a NULL_TREE.\n+*/\n+\n+tree\n+objc_build_getter_call (tree receiver, tree component)\n+{\n+  tree x = NULL_TREE;\n+  tree rtype;\n+\n+  if (receiver == NULL_TREE \n+      || receiver == error_mark_node \n+      || (rtype = TREE_TYPE (receiver)) == NULL_TREE)\n+    return NULL_TREE;\n+\n+  if (component == NULL_TREE\n+      || component == error_mark_node\n+      || TREE_CODE (component) != IDENTIFIER_NODE)\n+    return NULL_TREE;\n+\n+  if (objc_is_id (rtype))\n+    {\n+      tree rprotos = (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype))\n+\t\t      ? TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype))\n+\t\t      : NULL_TREE);\n+      if (rprotos)\n+\tx = lookup_property_in_protocol_list (rprotos, component);\n+    }\n+  else\n+    {\n+      tree basetype = TYPE_MAIN_VARIANT (rtype);\n+\n+      if (basetype != NULL_TREE && TREE_CODE (basetype) == POINTER_TYPE)\n+\tbasetype = TREE_TYPE (basetype);\n+      else\n+\treturn NULL_TREE;\n+\n+      while (basetype != NULL_TREE\n+\t     && TREE_CODE (basetype) == RECORD_TYPE \n+\t     && OBJC_TYPE_NAME (basetype)\n+\t     && TREE_CODE (OBJC_TYPE_NAME (basetype)) == TYPE_DECL\n+\t     && DECL_ORIGINAL_TYPE (OBJC_TYPE_NAME (basetype)))\n+\tbasetype = DECL_ORIGINAL_TYPE (OBJC_TYPE_NAME (basetype));\n+\n+      if (basetype != NULL_TREE && TYPED_OBJECT (basetype))\n+\t{\n+\t  tree interface_type = TYPE_OBJC_INTERFACE (basetype);\n+\t  if (!interface_type)\n+\t    return NULL_TREE;\n+\t  x = lookup_property (interface_type, component);\n+\t}\n+    }\n+\n+  if (x)\n+    {\n+      tree call_exp, getter;\n+      /* Get the getter name. */\n+      gcc_assert (PROPERTY_NAME (x));\n+      getter = objc_finish_message_expr (receiver, PROPERTY_NAME (x), \n+\t\t\t\t\t NULL_TREE);\n+      call_exp = getter;\n+#ifdef OBJCPLUS\n+      /* In C++, a getter which returns an aggregate value results in a \n+\t target_expr which initializes a temporary to the call expression.  */\n+      if (TREE_CODE (getter) == TARGET_EXPR)\n+\t{\n+\t  gcc_assert (MAYBE_CLASS_TYPE_P (TREE_TYPE (getter)));\n+\t  gcc_assert (TREE_CODE (TREE_OPERAND (getter,0)) == VAR_DECL);\n+\t  call_exp = TREE_OPERAND (getter,1);\n+\t}\n+#endif\n+      gcc_assert (TREE_CODE (call_exp) == CALL_EXPR);\n+\n+      CALL_EXPR_OBJC_PROPERTY_GETTER (call_exp) = 1;\n+      return getter;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* This routine builds a call to property's 'setter' function.  RECEIVER is the\n+   receiving object for 'setter'.  PROPERTY_IDENT is name of the property and\n+   RHS is the argument passed to the 'setter' function.  */\n+\n+static tree\n+objc_setter_func_call (tree receiver, tree property_ident, tree rhs)\n+{\n+  tree setter_argument = build_tree_list (NULL_TREE, rhs);\n+  char *setter_name = objc_build_property_setter_name (property_ident, true);\n+  tree setter;\n+  in_objc_property_setter_name_context = true;\n+  setter = objc_finish_message_expr (receiver, get_identifier (setter_name),\n+\t\t\t\t     setter_argument);\n+  in_objc_property_setter_name_context = false;\n+  return setter;\n+}\n+\n+/* Find the selector identifier from a reference.  A somewhat tortuous way of\n+   obtaining  the information to allow a setter to be written, given an\n+   existing getter.  */\n+\n+static tree\n+get_selector_from_reference (tree selref)\n+{\n+  tree chain;\n+\n+  if (flag_next_runtime)\n+    {\n+      /* Run through the selectors until we find the one we're looking for.  */\n+      for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n+\tif (TREE_PURPOSE (chain) == selref)\n+\t  return TREE_VALUE (chain);\n+    }\n+  else\n+    {\n+      /* To find our way back to the selector for the GNU runtime is harder\n+         work, we need to decompose the representation of SELECTOR_TABLE[n]\n+         to find 'n'.  This representation is in several forms.  */\n+      if (TREE_CODE (selref) == POINTER_PLUS_EXPR) \n+\t{\n+\t  /* We need the element size to decode the array offset expression \n+\t     into an index.  */\n+\t  unsigned size = (unsigned) TREE_INT_CST_LOW  \n+\t\t\t      (TYPE_SIZE_UNIT \n+\t\t\t\t(TREE_TYPE \n+\t\t\t\t  (TREE_TYPE \n+\t\t\t\t    (TREE_OPERAND \n+\t\t\t\t      (TREE_OPERAND \n+\t\t\t\t\t(TREE_OPERAND (selref, 0), 0), 0)))));\n+\t  unsigned index = \n+\t  \t(unsigned) TREE_INT_CST_LOW (TREE_OPERAND (selref, 1)) \n+\t  \t\t   / size;\n+\t  for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n+\t    if (!index--)\n+\t      return TREE_VALUE (chain);\n+\t}\n+      else if (TREE_CODE (selref) == NOP_EXPR)\n+\t{\n+\t  /* Either we have a base an index, or we have just a base (when the \n+\t     index is 0.  */\n+\t  if (TREE_CODE (TREE_OPERAND (selref, 0)) == ADDR_EXPR\n+\t      && TREE_CODE \n+\t\t   (TREE_OPERAND \n+\t\t     (TREE_OPERAND (selref, 0), 0)) == ARRAY_REF)\n+\t    {\n+\t      /* The Nth.  */\n+\t      unsigned index = (unsigned) TREE_INT_CST_LOW\n+\t\t\t\t\t(TREE_OPERAND \n+\t\t\t\t\t  (TREE_OPERAND \n+\t\t\t\t\t    (TREE_OPERAND (selref, 0), 0), 1));\n+\t      for (chain = sel_ref_chain; chain; chain = TREE_CHAIN (chain))\n+\t\tif (!index--)\n+\t\t  return TREE_VALUE (chain);\n+\t    }\n+\t  else\n+\t    return TREE_VALUE (sel_ref_chain);\n+\t} /* Else we don't know how to figure this out - which will produce a\n+\t     parse error - saying that the LHS is not writeable.  */\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* This routine converts a previously synthesized 'getter' function call for\n+   a property and converts it to a 'setter' function call for the same\n+   property.  */\n+\n+tree\n+objc_build_setter_call (tree lhs, tree rhs)\n+{\n+  if (lhs \n+      && TREE_CODE (lhs) == CALL_EXPR\n+      && CALL_EXPR_OBJC_PROPERTY_GETTER (lhs))\n+    {\n+      tree selector;\n+      /* Get the Object.  */\n+      tree receiver = TREE_OPERAND (lhs, 3);\n+      /* Get the selector reference.  */\n+      tree selector_reference = TREE_OPERAND (lhs, 4);\n+      gcc_assert (receiver && selector_reference);\n+      /* The style of the selector reference is different for GNU & NeXT.  */\n+      selector = get_selector_from_reference (selector_reference);\n+      if (selector)\n+        return objc_setter_func_call (receiver, selector, rhs);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* This routine checks to see if ID is a property name. If so, it\n+   returns property declaration. */\n+\n+static tree \n+is_property (tree klass, tree id)\n+{\n+  tree x;\n+\n+  for (x = CLASS_PROPERTY_DECL (klass); x; x = TREE_CHAIN (x))\n+    if (PROPERTY_NAME (x) == id)\n+      return x;\n+  return NULL_TREE;\n+}\n+\n+/* This routine returns call to property's getter when a property is\n+   used stand-alone (without self. notation). */\n+\n+static tree\n+build_property_reference (tree property, tree id)\n+{\n+  tree getter;\n+  if (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL)\n+    {\n+      error (\"property %qs accessed in class method\",\n+               IDENTIFIER_POINTER (id));\n+      return error_mark_node;\n+    }\n+\n+  getter = objc_finish_message_expr (self_decl, PROPERTY_NAME (property), NULL_TREE);\n+  CALL_EXPR_OBJC_PROPERTY_GETTER (getter) = 1;\n+  return getter;\n+}\n+\n void\n objc_set_method_type (enum tree_code type)\n {\n@@ -6511,9 +6986,11 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t      || CONVERT_EXPR_P (rtype)\n \t      || TREE_CODE (rtype) == COMPONENT_REF)\n     rtype = TREE_OPERAND (rtype, 0);\n+\n   self = (rtype == self_decl);\n   super = (rtype == UOBJC_SUPER_decl);\n   rtype = TREE_TYPE (receiver);\n+\n   have_cast = (TREE_CODE (receiver) == NOP_EXPR\n \t       || (TREE_CODE (receiver) == COMPOUND_EXPR\n \t\t   && !IS_SUPER (rtype)));\n@@ -6663,7 +7140,9 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t  = lookup_method_in_hash_lists (sel_name, class_tree != NULL_TREE);\n     }\n \n-  if (!method_prototype)\n+  if (!method_prototype && in_objc_property_setter_name_context)\n+      error (\"readonly property can not be set\");\n+  else if (!method_prototype) \n     {\n       static bool warn_missing_methods = false;\n \n@@ -7968,6 +8447,309 @@ continue_class (tree klass)\n     return error_mark_node;\n }\n \n+/* This routine builds a property ivar name. */\n+\n+static char *\n+objc_build_property_ivar_name (tree property_decl)\n+{\n+  static char string[BUFSIZE];\n+  sprintf (string, \"_%s\", IDENTIFIER_POINTER (PROPERTY_NAME (property_decl)));\n+  return string;\n+}\n+\n+/* This routine builds name of the setter synthesized function. */\n+\n+static char *\n+objc_build_property_setter_name (tree ident, bool delimit_colon)\n+{\n+  static char string[BUFSIZE];\n+  if (delimit_colon)\n+    sprintf (string, \"set%s:\", IDENTIFIER_POINTER (ident));\n+  else\n+    sprintf (string, \"set%s\", IDENTIFIER_POINTER (ident));\n+  string[3] = TOUPPER (string[3]);\n+  return string;\n+}\n+\n+/* This routine does all the work for generating data and code per each \n+   property declared in current implementation. */\n+\n+static void\n+objc_gen_one_property_datum (tree klass, tree property, tree class_methods, bool *ivar_added)\n+{\n+  tree mth;\n+\n+  /* If getter, check that it is already declared in user code. */\n+  if (PROPERTY_GETTER_NAME (property))\n+    {\n+      mth = lookup_method (CLASS_NST_METHODS (class_methods), \n+\t\t\t   PROPERTY_GETTER_NAME (property));\n+      if (!mth)\n+\terror (\"property getter %qs not declared in class %qs\",  \n+\t\tIDENTIFIER_POINTER (PROPERTY_GETTER_NAME (property)), \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (class_methods)));\n+    }\n+  /* If setter, check that it is already declared in user code. */\n+  if (PROPERTY_SETTER_NAME (property))\n+    {\n+      mth = lookup_method (CLASS_NST_METHODS (class_methods), \n+\t\t\t   PROPERTY_SETTER_NAME (property));\n+      if (!mth)\n+\terror (\"property setter %qs not declared in class %qs\",  \n+\t\tIDENTIFIER_POINTER (PROPERTY_SETTER_NAME (property)), \n+\t\tIDENTIFIER_POINTER (CLASS_NAME (class_methods)));\n+    }\n+  /* If ivar attribute specified, check that it is already declared. */\n+  if (PROPERTY_IVAR_NAME (property))\n+    {\n+      if (!is_ivar (CLASS_IVARS (klass), \n+\t   PROPERTY_IVAR_NAME (property)))\n+\terror (\"ivar %qs in property declaration must be an existing ivar\", \n+   \t       IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (property)));\n+    }\n+  else if (!PROPERTY_GETTER_NAME (property) \n+\t   || (PROPERTY_READONLY (property) == boolean_false_node \n+\t       && !PROPERTY_SETTER_NAME (property)))\n+    {\n+      /* Setter and/or getter must be synthesize and there was no user-specified\n+\t ivar. Must create an ivar and add to to current class's ivar list. */\n+      tree record = CLASS_STATIC_TEMPLATE (klass);\n+      tree type = TREE_TYPE (property);\n+      tree field_decl, field;\n+      field_decl = create_field_decl (type, \n+\t\t\t\t      objc_build_property_ivar_name (property));\n+      DECL_CONTEXT (field_decl) = record;\n+      (void) add_instance_variable (klass, \n+\t\t\t\t    1, field_decl);\n+      /* Unfortunately, CLASS_IVARS is completed when interface is completed.\n+\t Must add the new ivar by hand to its list here. */\n+      \n+      CLASS_IVARS (klass) = \n+\t\t\tchainon (CLASS_IVARS (klass), \n+\t\t\t\t copy_node (field_decl));\n+      gcc_assert (record);\n+      /* Must also add this ivar to the end of list of fields for this class. */\n+      field = TYPE_FIELDS (record);\n+      if (field && field != CLASS_IVARS (klass))\n+        /* class has a hidden field, attach ivar list after the hiddent field. */\n+        TREE_CHAIN (field) = CLASS_IVARS (klass);\n+      else\n+        TYPE_FIELDS (record) = CLASS_IVARS (klass);\n+      *ivar_added = true;\n+    }\n+}\n+\n+/* This routine processes an existing getter or setter attribute.\n+   It aliases internal property getter or setter to the user implemented \n+   getter or setter.\n+*/\n+\n+static void \n+objc_process_getter_setter (tree klass, tree property, bool getter)\n+{\n+  tree prop_mth_decl;\n+  tree prop_getter_mth_decl;\n+  tree name_ident;\n+\n+  if (getter)\n+    /* getter name is same as property name. */\n+    name_ident = PROPERTY_NAME (property);\n+  else\n+    /* Must synthesize setter name from property name. */\n+    name_ident = get_identifier (objc_build_property_setter_name (\n+\t\t\t\t   PROPERTY_NAME (property), true));\n+\n+  /* Find declaration of instance method for the property in its class. */\n+  prop_mth_decl = lookup_method (CLASS_NST_METHODS (klass), name_ident);\n+\n+  if (!prop_mth_decl)\n+    return;\n+\n+  prop_getter_mth_decl = lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n+\t\t\t\t\tgetter ? PROPERTY_GETTER_NAME (property) \n+\t\t\t\t\t       : PROPERTY_SETTER_NAME (property));\n+\n+  if (!prop_getter_mth_decl)\n+    return;\n+\n+  if (!match_proto_with_proto (prop_getter_mth_decl, prop_mth_decl, 1))\n+    {\n+      error (\"User %s %qs does not match property %qs type\", \n+\t\tgetter ? \"getter\" : \"setter\",\n+\t\tIDENTIFIER_POINTER (DECL_NAME (prop_getter_mth_decl)), \n+\t\tIDENTIFIER_POINTER (PROPERTY_NAME (property)));\n+      return;\n+    }\n+  /* We alias internal property getter to the user implemented getter by copying relevant\n+     entries from user's implementation to the internal one. */\n+  prop_mth_decl = copy_node (prop_mth_decl);\n+  METHOD_ENCODING (prop_mth_decl) = METHOD_ENCODING (prop_getter_mth_decl);\n+  METHOD_DEFINITION (prop_mth_decl) = METHOD_DEFINITION (prop_getter_mth_decl);\n+  objc_add_method (objc_implementation_context, prop_mth_decl, 0, 0);\n+}\n+\n+/* This routine synthesizes a 'getter' method. */\n+\n+static void\n+objc_synthesize_getter (tree klass, tree class_method, tree property)\n+{\n+  tree fn, decl;\n+  tree body;\n+  tree ret_val;\n+  tree ivar_ident;\n+\n+  /* If user has implemented a getter with same name then do nothing. */\n+  if (lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n+\t\t     PROPERTY_NAME (property)))\n+    return;\n+\n+  /* Find declaration of the property in the interface. There must be one. */\n+  decl = lookup_method (CLASS_NST_METHODS (class_method),\n+                        PROPERTY_NAME (property));\n+\n+  /* If one not declared in the interface, this condition has already been reported\n+     as user error (because property was not declared in the interface). */\n+  if (!decl)\n+    return;\n+\n+  objc_inherit_code = INSTANCE_METHOD_DECL;\n+  /* For now no attributes.  */\n+  objc_start_method_definition (copy_node (decl), NULL_TREE);\n+\n+  body = c_begin_compound_stmt (true);\n+  /* return self->_property_name; */\n+  /* If user specified an ivar, use it in generation of the getter. */\n+  ivar_ident = PROPERTY_IVAR_NAME (property) \n+\t\t? PROPERTY_IVAR_NAME (property) \n+\t\t: get_identifier (objc_build_property_ivar_name (property));\n+\n+  /* objc_ivar_chain might not be up to date in the case that property 'ivar'\n+     is added *after* user ivar is parsed and objc_continue_implementation \n+     has already been called. */\n+  objc_ivar_chain = CLASS_IVARS (klass);\n+  ret_val = objc_lookup_ivar (NULL_TREE, ivar_ident);\n+  /* If ivar attribute is not a user declared attribute, this condition has\n+     already been repored as error. */\n+  gcc_assert (ret_val || PROPERTY_IVAR_NAME (property));\n+\n+  if (ret_val)\n+    {\n+#ifdef OBJCPLUS\n+      finish_return_stmt (ret_val);\n+#else\n+      (void)c_finish_return (input_location, ret_val, NULL);\n+#endif\n+    }\n+  add_stmt (c_end_compound_stmt (input_location, body, true));\n+  fn = current_function_decl;\n+#ifdef OBJCPLUS\n+  finish_function ();\n+#endif\n+  objc_finish_method_definition (fn);\n+}\n+\n+/* This routine synthesizes a 'setter' method.  */\n+\n+static void\n+objc_synthesize_setter (tree klass, tree class_method, tree property)\n+{\n+  tree fn, decl, ivar_ident, lhs, rhs;\n+  tree body;\n+  char *setter_name = objc_build_property_setter_name (\n+\t\t\tPROPERTY_NAME (property), true);\n+  tree setter_ident = get_identifier (setter_name);\n+\n+  /* If user has implemented a setter with same name then do nothing. */\n+  if (lookup_method (CLASS_NST_METHODS (objc_implementation_context),\n+\t\t     setter_ident))\n+    return;\n+\n+  /* Find declaration of the property in the interface. There must be one. */\n+  decl = lookup_method (CLASS_NST_METHODS (class_method), setter_ident);\n+\n+  /* If one not declared in the inerface, this condition has already been reported\n+     as user error (because property was not declared in the interface. */\n+  if (!decl)\n+    return;\n+\n+  objc_inherit_code = INSTANCE_METHOD_DECL;\n+  /* For now, no attributes.  */\n+  objc_start_method_definition (copy_node (decl), NULL_TREE);\n+\n+  body = c_begin_compound_stmt (true);\n+  /* _property_name = _value; */\n+  /* If user specified an ivar, use it in generation of the setter. */\n+  ivar_ident = PROPERTY_IVAR_NAME (property) \n+\t\t? PROPERTY_IVAR_NAME (property) \n+\t\t: get_identifier (objc_build_property_ivar_name (property));\n+\n+  /* objc_ivar_chain might not be up to date in the case that property 'ivar'\n+     is added *after* user ivar is parsed and objc_continue_implementation \n+     has already been called. */\n+  objc_ivar_chain = CLASS_IVARS (klass);\n+  lhs = objc_lookup_ivar (NULL_TREE, ivar_ident);\n+  /* If ivar attribute is not a user declared attribute, this condition has\n+     already been repored as error. */\n+  gcc_assert (lhs || PROPERTY_IVAR_NAME (property));\n+  if (lhs)\n+    {\n+      rhs = lookup_name (get_identifier (\"_value\"));\n+      gcc_assert (rhs);\n+      /* FIXME: NULL types to get compile.  */\n+      add_stmt (build_modify_expr (input_location, \n+      \t\t\t\t   lhs, NULL_TREE, NOP_EXPR, \n+      \t\t\t\t   input_location, rhs, NULL_TREE));\n+    }\n+  add_stmt (c_end_compound_stmt (input_location, body, true));\n+  fn = current_function_decl;\n+#ifdef OBJCPLUS\n+  finish_function ();\n+#endif\n+  objc_finish_method_definition (fn);\n+}\n+\n+/* Main routine to generate code/data for all the property information for \n+   current implementation (class or category). CLASS is the interface where\n+   ivars are declared.  CLASS_METHODS is where methods are found which\n+   could be a class or a category depending on whether we are implementing\n+   property of a class or a category.  */\n+\n+static void\n+objc_gen_property_data (tree klass, tree class_methods)\n+{\n+  tree x;\n+  bool  ivar_added = false;\n+  for (x = IMPL_PROPERTY_DECL (objc_implementation_context); x; x = TREE_CHAIN (x))\n+     objc_gen_one_property_datum (klass, x, class_methods, &ivar_added);\n+\n+  if (ivar_added)\n+    {\n+      tree record = CLASS_STATIC_TEMPLATE (klass);\n+      /* Ugh, must recalculate struct layout since at least one ivar was added. */\n+      TYPE_SIZE (record) = 0;\n+      layout_type (record);\n+    }\n+\n+  /* Synthesize all getters for properties. */\n+  for (x = IMPL_PROPERTY_DECL (objc_implementation_context); x; x = TREE_CHAIN (x))\n+    {\n+     /* Property has a getter attribute, no need to synthesize one. */\n+     if (PROPERTY_GETTER_NAME (x) == NULL_TREE)\n+       objc_synthesize_getter (klass, class_methods, x);\n+     else\n+       objc_process_getter_setter (class_methods, x, true);\n+\n+     if (PROPERTY_READONLY (x) == boolean_false_node)\n+       {\n+\t /* not a readonly property. */\n+\t if (PROPERTY_SETTER_NAME (x) == NULL_TREE)\n+\t   objc_synthesize_setter (klass, class_methods, x);\n+\t else\n+\t   objc_process_getter_setter (class_methods, x, false);\n+       }\n+    }\n+}\n+\n /* This is called once we see the \"@end\" in an interface/implementation.  */\n \n static void\n@@ -7977,6 +8759,9 @@ finish_class (tree klass)\n     {\n       /* All code generation is done in finish_objc.  */\n \n+      /* Generate what needed for property; setters, getters, etc. */\n+      objc_gen_property_data (implementation_template, implementation_template);\n+\n       if (implementation_template != objc_implementation_context)\n \t{\n \t  /* Ensure that all method listed in the interface contain bodies.  */\n@@ -7998,6 +8783,9 @@ finish_class (tree klass)\n \n       if (category)\n \t{\n+          /* Generate what needed for property; setters, getters, etc. */\n+          objc_gen_property_data (implementation_template, category);\n+\n \t  /* Ensure all method listed in the interface contain bodies.  */\n \t  check_methods (CLASS_CLS_METHODS (category),\n \t\t\t CLASS_CLS_METHODS (objc_implementation_context), '+');\n@@ -8010,6 +8798,60 @@ finish_class (tree klass)\n \t\t\t     CLASS_SUPER_NAME (objc_implementation_context));\n \t}\n     }\n+  else \n+    {\n+      /* Process properties of the class. */\n+      tree x;\n+      for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n+\t{\n+\t  tree type = TREE_TYPE (x);\n+\t  tree prop_name = PROPERTY_NAME (x);\n+\t  /* Build an instance method declaration: - (type) prop_name; */\n+\t  if (PROPERTY_GETTER_NAME (x) == NULL_TREE)\n+\t    {\n+\t      /* No getter attribute specified. Generate an instance method for the \n+\t\t getter. */\n+\t      tree rettype = build_tree_list (NULL_TREE, type);\n+\t      tree getter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t\t    rettype, prop_name, \n+\t\t\t\t\t\t    NULL_TREE, false);\n+\t      objc_add_method (objc_interface_context, getter_decl, false, false);\n+\t      METHOD_PROPERTY_CONTEXT (getter_decl) = x;\n+\t    }\n+\t  else\n+\t    warning (0, \"getter = %qs may not be specified in an interface\", \n+\t\t     IDENTIFIER_POINTER (PROPERTY_GETTER_NAME (x)));\n+\n+\t  /* Build an instance method declaration: - (void) setName: (type)value; */\n+\t  if (PROPERTY_SETTER_NAME (x) == NULL_TREE \n+\t      && PROPERTY_READONLY (x) == boolean_false_node)\n+\t    {\n+\t      /* Declare a setter instance method in the interface. */\n+\t      tree key_name, arg_type, arg_name;\n+\t      tree setter_decl, selector;\n+\t      tree ret_type = build_tree_list (NULL_TREE, void_type_node);\n+\t      /* setter name. */\n+\t      key_name = get_identifier (objc_build_property_setter_name (\n+\t\t\t\t\t  PROPERTY_NAME (x), false));\n+\t      arg_type = build_tree_list (NULL_TREE, type);\n+\t      arg_name = get_identifier (\"_value\");\n+\t      /* For now, no attributes.  */\n+\t      selector = objc_build_keyword_decl (key_name, arg_type, arg_name, NULL);\n+\t      setter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t       ret_type, selector, \n+\t\t\t\t\t       build_tree_list (NULL_TREE, NULL_TREE),\n+\t\t\t\t\t       false);\n+\t      objc_add_method (objc_interface_context, setter_decl, false, false);\n+\t      METHOD_PROPERTY_CONTEXT (setter_decl) = x;\n+\t    }\n+\t  else if (PROPERTY_SETTER_NAME (x))\n+\t    warning (0, \"setter = %qs may not be specified in an interface\", \n+\t\t     IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (x)));\n+\t  if (PROPERTY_IVAR_NAME (x))\n+\t    warning (0, \"ivar  = %qs attribute may not be specified in an interface\",\n+\t\t     IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (x)));\n+\t}\n+    }\n }\n \n static tree\n@@ -8988,13 +9830,19 @@ objc_types_share_size_and_alignment (tree type1, tree type2)\n static int\n comp_proto_with_proto (tree proto1, tree proto2, int strict)\n {\n-  tree type1, type2;\n-\n   /* The following test is needed in case there are hashing\n      collisions.  */\n   if (METHOD_SEL_NAME (proto1) != METHOD_SEL_NAME (proto2))\n     return 0;\n \n+  return match_proto_with_proto (proto1, proto2, strict);\n+}\n+\n+static int\n+match_proto_with_proto (tree proto1, tree proto2, int strict)\n+{\n+  tree type1, type2;\n+\n   /* Compare return types.  */\n   type1 = TREE_VALUE (TREE_TYPE (proto1));\n   type2 = TREE_VALUE (TREE_TYPE (proto2));\n@@ -9970,11 +10818,11 @@ generate_objc_image_info (void)\n \n /* Look up ID as an instance variable.  OTHER contains the result of\n    the C or C++ lookup, which we may want to use instead.  */\n-\n+/* Also handle use of property as setter/getter. */\n tree\n objc_lookup_ivar (tree other, tree id)\n {\n-  tree ivar;\n+  tree ivar, property;\n \n   /* If we are not inside of an ObjC method, ivar lookup makes no sense.  */\n   if (!objc_method_context)\n@@ -9990,11 +10838,18 @@ objc_lookup_ivar (tree other, tree id)\n       && other && other != error_mark_node)\n     return other;\n \n-  /* Look up the ivar, but do not use it if it is not accessible.  */\n-  ivar = is_ivar (objc_ivar_chain, id);\n+  property = NULL_TREE;\n+  if (objc_implementation_context)\n+    property = is_property (objc_implementation_context, id);\n \n-  if (!ivar || is_private (ivar))\n-    return other;\n+  if (!property)\n+    {\n+      /* Look up the ivar, but do not use it if it is not accessible.  */\n+      ivar = is_ivar (objc_ivar_chain, id);\n+\n+      if (!ivar || is_private (ivar))\n+\treturn other;\n+    }\n \n   /* In an instance method, a local variable (or parameter) may hide the\n      instance variable.  */\n@@ -10006,12 +10861,17 @@ objc_lookup_ivar (tree other, tree id)\n       && !DECL_FILE_SCOPE_P (other))\n #endif\n     {\n-      warning (0, \"local declaration of %qE hides instance variable\",\n-\t       id);\n+      if (property)\n+\twarning (0, \"local declaration of %qE hides property\", id);\n+      else\n+\twarning (0, \"local declaration of %qE hides instance variable\", id);\n \n       return other;\n     }\n \n+  if (property)\n+    return build_property_reference (property, id);\n+\n   /* At this point, we are either in an instance method with no obscuring\n      local definitions, or in a class method with no alternate definitions\n      at all.  */"}, {"sha": "1dd777c912f6f12e7412c5875da3653074eb54bb", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -37,8 +37,8 @@ tree objc_eh_personality (void);\n \n /* Objective-C structures */\n \n-#define CLASS_LANG_SLOT_ELTS\t\t5\n-#define PROTOCOL_LANG_SLOT_ELTS\t\t4\n+#define CLASS_LANG_SLOT_ELTS\t\t7\n+#define PROTOCOL_LANG_SLOT_ELTS\t\t7\n #define OBJC_INFO_SLOT_ELTS\t\t2\n \n /* KEYWORD_DECL */\n@@ -53,6 +53,14 @@ tree objc_eh_personality (void);\n #define METHOD_DEFINITION(DECL) ((DECL)->decl_common.initial)\n #define METHOD_ENCODING(DECL) ((DECL)->decl_minimal.context)\n #define METHOD_TYPE_ATTRIBUTES(DECL) ((DECL)->decl_common.abstract_origin)\n+#define METHOD_PROPERTY_CONTEXT(DECL) ((DECL)->decl_common.size_unit)\n+\n+#define PROPERTY_NAME(DECL) ((DECL)->decl_minimal.name)\n+#define PROPERTY_GETTER_NAME(DECL) ((DECL)->decl_non_common.arguments)\n+#define PROPERTY_SETTER_NAME(DECL) ((DECL)->decl_non_common.result)\n+#define PROPERTY_IVAR_NAME(DECL) ((DECL)->decl_common.initial)\n+#define PROPERTY_READONLY(DECL) ((DECL)->decl_minimal.context)\n+#define PROPERTY_COPIES(DECL) ((DECL)->decl_common.size_unit)\n \n /* CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,\n@@ -66,6 +74,8 @@ tree objc_eh_personality (void);\n #define CLASS_STATIC_TEMPLATE(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 2)\n #define CLASS_CATEGORY_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 3)\n #define CLASS_PROTOCOL_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 4)\n+#define TOTAL_CLASS_RAW_IVARS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 5)\n+\n #define PROTOCOL_NAME(CLASS) ((CLASS)->type.name)\n #define PROTOCOL_LIST(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 0)\n #define PROTOCOL_NST_METHODS(CLASS) ((CLASS)->type.minval)\n@@ -75,6 +85,11 @@ tree objc_eh_personality (void);\n #define PROTOCOL_OPTIONAL_CLS_METHODS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 2)\n #define PROTOCOL_OPTIONAL_NST_METHODS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 3)\n \n+/* For CATEGORY_INTERFACE_TYPE, CLASS_INTERFACE_TYPE or PROTOCOL_INTERFACE_TYPE */\n+#define CLASS_PROPERTY_DECL(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 6)\n+/* For CLASS_IMPLEMENTATION_TYPE or CATEGORY_IMPLEMENTATION_TYPE. */\n+#define IMPL_PROPERTY_DECL(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 6)\n+\n /* ObjC-specific information pertaining to RECORD_TYPEs are stored in\n    the LANG_SPECIFIC structures, which may itself need allocating first.  */\n "}, {"sha": "2469845b2c37ce22e4f5db593aec7ae1a41fb995", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -69,22 +69,27 @@ objc_init_ts (void)\n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_NON_COMMON] = 1;\n   \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_WITH_VIS] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_WITH_VIS] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_WITH_VIS] = 1;\n \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_WRTL] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_WRTL] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_WRTL] = 1;\n   \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_MINIMAL] = 1;\n   \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_COMMON] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_COMMON] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_COMMON] = 1;\n }\n \n void"}, {"sha": "b56734789d8894307cd111c70c18695f38120bc8", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -34,6 +34,7 @@ DEFTREECODE (PROTOCOL_INTERFACE_TYPE, \"protocol_interface_type\", tcc_type, 0)\n DEFTREECODE (KEYWORD_DECL, \"keyword_decl\", tcc_declaration, 0)\n DEFTREECODE (INSTANCE_METHOD_DECL, \"instance_method_decl\", tcc_declaration, 0)\n DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", tcc_declaration, 0)\n+DEFTREECODE (PROPERTY_DECL, \"property_decl\", tcc_declaration, 0)\n \n /* Objective-C expressions.  */\n DEFTREECODE (MESSAGE_SEND_EXPR, \"message_send_expr\", tcc_expression, 3)"}, {"sha": "c60766eaa922573fa9429f46fc626b89c5887d49", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -1,3 +1,11 @@\n+2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\tmerge from FSF apple 'trunk' branch. \n+\t2006 Fariborz Jahanian <fjahanian@apple.com>\n+\t\n+\tRadars 4436866, 4505126, 4506903, 4517826\n+\t* objcp-lang.c (objcxx_init_ts): Update for property_decl.\n+\n 2010-10-13  Richard Henderson  <rth@redhat.com>\n \n \t* objcp-lang.c (objcxx_eh_personality): Update call to"}, {"sha": "d03e7548ddf88001f0b300c23da257b3759b6007", "filename": "gcc/objcp/objcp-lang.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjcp%2Fobjcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/668ea4b1106d1a28e07ed653874192696840829c/gcc%2Fobjcp%2Fobjcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.c?ref=668ea4b1106d1a28e07ed653874192696840829c", "patch": "@@ -100,22 +100,27 @@ objcxx_init_ts (void)\n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_NON_COMMON] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_NON_COMMON] = 1;\n   \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_WITH_VIS] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_WITH_VIS] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_WITH_VIS] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_WITH_VIS] = 1;\n \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_WRTL] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_WRTL] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_WRTL] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_WRTL] = 1;\n   \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_MINIMAL] = 1;\n   \n   tree_contains_struct[CLASS_METHOD_DECL][TS_DECL_COMMON] = 1;\n   tree_contains_struct[INSTANCE_METHOD_DECL][TS_DECL_COMMON] = 1;\n   tree_contains_struct[KEYWORD_DECL][TS_DECL_COMMON] = 1;\n+  tree_contains_struct[PROPERTY_DECL][TS_DECL_COMMON] = 1;\n   \n   /* C++ decls */\n   tree_contains_struct[NAMESPACE_DECL][TS_DECL_NON_COMMON] = 1;"}]}