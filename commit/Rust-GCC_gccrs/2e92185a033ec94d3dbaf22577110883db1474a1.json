{"sha": "2e92185a033ec94d3dbaf22577110883db1474a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU5MjE4NWEwMzNlYzk0ZDNkYmFmMjI1NzcxMTA4ODNkYjE0NzRhMQ==", "commit": {"author": {"name": "Stafford Horne", "email": "shorne@gmail.com", "date": "2019-07-21T20:58:54Z"}, "committer": {"name": "Stafford Horne", "email": "shorne@gcc.gnu.org", "date": "2019-07-21T20:58:54Z"}, "message": "or1k: Fix code quality for volatile memory loads\n\nVolatile memory does not match the memory_operand predicate.  This\ncauses extra extend/mask instructions instructions when reading\nfrom volatile memory.  On OpenRISC loading volatile memory can be\ntreated the same as regular memory loads which supports combined\nsign/zero extends.  Fixing this eliminates the need for extra\nextend/mask instructions.\n\nThis also adds a test provided by Richard Selvaggi which uncovered the\nissue while we were looking into another issue.\n\ngcc/ChangeLog:\n\n\tPR target/90363\n\t* config/or1k/or1k.md (zero_extend<mode>si2): Update predicate.\n\t(extend<mode>si2): Update predicate.\n\t* gcc/config/or1k/predicates.md (volatile_mem_operand): New.\n\t(reg_or_mem_operand): New.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/90363\n\t* gcc.target/or1k/swap-1.c: New test.\n\t* gcc.target/or1k/swap-2.c: New test.\n\nFrom-SVN: r273647", "tree": {"sha": "fc6aa93cd23671359f287d9ce587e2737dba0552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc6aa93cd23671359f287d9ce587e2737dba0552"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e92185a033ec94d3dbaf22577110883db1474a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e92185a033ec94d3dbaf22577110883db1474a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e92185a033ec94d3dbaf22577110883db1474a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e92185a033ec94d3dbaf22577110883db1474a1/comments", "author": {"login": "stffrdhrn", "id": 2404255, "node_id": "MDQ6VXNlcjI0MDQyNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stffrdhrn", "html_url": "https://github.com/stffrdhrn", "followers_url": "https://api.github.com/users/stffrdhrn/followers", "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}", "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}", "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions", "organizations_url": "https://api.github.com/users/stffrdhrn/orgs", "repos_url": "https://api.github.com/users/stffrdhrn/repos", "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}", "received_events_url": "https://api.github.com/users/stffrdhrn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "48df93911ab1b71a533934419c320fe9102b5ec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48df93911ab1b71a533934419c320fe9102b5ec1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48df93911ab1b71a533934419c320fe9102b5ec1"}], "stats": {"total": 38, "additions": 35, "deletions": 3}, "files": [{"sha": "59e11bccfbd5c1b5fc105317790fe894d5d9e6d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e92185a033ec94d3dbaf22577110883db1474a1", "patch": "@@ -1,3 +1,11 @@\n+2019-07-22  Stafford Horne  <shorne@gmail.com>\n+\n+\tPR target/90363\n+\t* config/or1k/or1k.md (zero_extend<mode>si2): Update predicate.\n+\t(extend<mode>si2): Update predicate.\n+\t* gcc/config/or1k/predicates.md (volatile_mem_operand): New.\n+\t(reg_or_mem_operand): New.\n+\n 2019-07-21  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/rs6000/rs6000.c (TARGET_NO_PROTOTYPE): Move from here..."}, {"sha": "757d899c44239f93c173afa648d977792903a143", "filename": "gcc/config/or1k/or1k.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2Fconfig%2For1k%2For1k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2Fconfig%2For1k%2For1k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.md?ref=2e92185a033ec94d3dbaf22577110883db1474a1", "patch": "@@ -328,11 +328,11 @@\n ;; Sign Extending\n ;; -------------------------------------------------------------------------\n \n-;; Zero extension can always be done with AND and an extending load.\n+;; Zero extension can always be done with AND or an extending load.\n \n (define_insn \"zero_extend<mode>si2\"\n   [(set (match_operand:SI 0 \"register_operand\"                     \"=r,r\")\n-\t(zero_extend:SI (match_operand:I12 1 \"nonimmediate_operand\" \"r,m\")))]\n+\t(zero_extend:SI (match_operand:I12 1 \"reg_or_mem_operand\" \"r,m\")))]\n   \"\"\n   \"@\n    l.andi\\t%0, %1, <zext_andi>\n@@ -344,7 +344,7 @@\n \n (define_insn \"extend<mode>si2\"\n   [(set (match_operand:SI 0 \"register_operand\"                      \"=r,r\")\n-\t(sign_extend:SI (match_operand:I12 1 \"nonimmediate_operand\"  \"r,m\")))]\n+\t(sign_extend:SI (match_operand:I12 1 \"reg_or_mem_operand\"  \"r,m\")))]\n   \"TARGET_SEXT\"\n   \"@\n    l.ext<ldst>s\\t%0, %1"}, {"sha": "dad1c5d4be302cab3a7a70be3e8b17e5a85e5911", "filename": "gcc/config/or1k/predicates.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2Fconfig%2For1k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2Fconfig%2For1k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2Fpredicates.md?ref=2e92185a033ec94d3dbaf22577110883db1474a1", "patch": "@@ -82,3 +82,21 @@\n \n (define_predicate \"equality_comparison_operator\"\n   (match_code \"ne,eq\"))\n+\n+;; Borrowed from rs6000\n+;; Return true if the operand is in volatile memory.  Note that during the\n+;; RTL generation phase, memory_operand does not return TRUE for volatile\n+;; memory references.  So this function allows us to recognize volatile\n+;; references where it's safe.\n+(define_predicate \"volatile_mem_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"MEM_VOLATILE_P (op)\")\n+       (if_then_else (match_test \"reload_completed\")\n+\t (match_operand 0 \"memory_operand\")\n+\t (match_test \"memory_address_p (mode, XEXP (op, 0))\"))))\n+\n+;; Return true if the operand is a register or memory; including volatile\n+;; memory.\n+(define_predicate \"reg_or_mem_operand\"\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (match_operand 0 \"volatile_mem_operand\")))"}, {"sha": "95e73d9fa482fb8d25cbe1d050e24046a7a709bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e92185a033ec94d3dbaf22577110883db1474a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2e92185a033ec94d3dbaf22577110883db1474a1", "patch": "@@ -1,3 +1,9 @@\n+2019-07-22  Stafford Horne  <shorne@gmail.com>\n+\n+\tPR target/90363\n+\t* gcc.target/or1k/swap-1.c: New test.\n+\t* gcc.target/or1k/swap-2.c: New test.\n+\n 2019-07-20  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* gcc.target/powerpc/volatile-mem.c: New testcase."}]}