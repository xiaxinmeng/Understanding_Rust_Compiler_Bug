{"sha": "8145f0828c5c795620174ffd6deba9a5a6eb63f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE0NWYwODI4YzVjNzk1NjIwMTc0ZmZkNmRlYmE5YTVhNmViNjNmNg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@cygnus.com", "date": "1994-12-30T21:03:40Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-12-30T21:03:40Z"}, "message": "52th Cygnus<->FSF merge\n\nFrom-SVN: r8714", "tree": {"sha": "62f52de3e3e5cd9efd558e4adb41a23b685b37da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62f52de3e3e5cd9efd558e4adb41a23b685b37da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8145f0828c5c795620174ffd6deba9a5a6eb63f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8145f0828c5c795620174ffd6deba9a5a6eb63f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8145f0828c5c795620174ffd6deba9a5a6eb63f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8145f0828c5c795620174ffd6deba9a5a6eb63f6/comments", "author": null, "committer": null, "parents": [{"sha": "ad0ad21356c50f1509c5ebf6500cf79261f42467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad0ad21356c50f1509c5ebf6500cf79261f42467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad0ad21356c50f1509c5ebf6500cf79261f42467"}], "stats": {"total": 207, "additions": 169, "deletions": 38}, "files": [{"sha": "5fa2f83f2d7b9f26b5bc046e4a2a7d761e2de848", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -1,3 +1,61 @@\n+Fri Dec 30 12:22:29 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (n_incomplete): Bump n_incomplete up to int to match C\n+\tfront end.\n+\t(pushdecl): Also count decls pushed that are of a type being defined\n+\tas incomplete things.\n+\t* class.c (finish_struct): Move hack_incomplete_structures up to\n+\tjust after we set it as not being defined, so that the decls we\n+\tbuild for RTTI don't count as incomplete.\n+\n+Thu Dec 29 18:20:57 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* pt.c (tsubst): Fix problem with defining constructors in templated\n+\tclasses with virtual bases.\n+\n+Wed Dec 28 08:31:00 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (TYPEID): Strip top-level cv-qualifiers on typeid\n+\texpressions.\n+\t* gc.c (build_typeid): Ditto.\n+\n+Thu Dec 22 17:26:33 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Fix breakage introduced on Nov 29,\n+\tdon't assert on complex AGGR inits.\n+\n+Thu Dec 22 14:32:31 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* method.c (build_overload_value): Handle pointer to members as\n+\ttemplate arguments.\n+\n+Thu Dec 22 13:09:07 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (unary_complex_lvalue): Don't call sorry if we know how\n+\tto do take the address of a data member for a pointer to data\n+\tmember.\n+\n+Thu Dec 22 10:04:19 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Use the typedef name for linkage if the\n+\ttype doesn't otherwise have a name.\n+\n+\t* decl2.c (grokfield): Ditto.\n+\n+\t* class.c (finish_struct): Since we reuse the TYPE_DECL for the\n+\tDECL_NAME of enums, structs and classes, we have to avoid trying to\n+\tput it in the TYPE_FIELDS again.\n+\n+Wed Dec 21 11:07:05 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (check_classfn): Ignore this parameter on static functions\n+\twhen checking to see if we match.\n+\n+Tue Dec 20 17:47:02 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (unary_complex_lvalue): Handle address of non-left most\n+\tpointers to members by calling get_delta_difference.\n+\n Mon Dec 19 22:40:53 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* decl2.c (check_classfn): Don't use decls_match yet, as it modifies"}, {"sha": "b0e0cf8ff9736379c4056e98b3fdc86cfdd47a9f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -3982,12 +3982,15 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       last_x = tree_last (TYPE_FIELDS (t));\n       while (x)\n \t{\n-#if 0 /* What's wrong with using the decl the type already has? */\n-\t  tree tag = build_decl (TYPE_DECL, TREE_PURPOSE (x), TREE_VALUE (x));\n-\t  DECL_CONTEXT (tag) = t;\n-#else\n \t  tree tag = TYPE_NAME (TREE_VALUE (x));\n-#endif\n+\n+\t  /* Check to see if it is already there.  This will be the case if\n+\t     was do enum { red; } color; */\n+\t  if (chain_member (tag, TYPE_FIELDS (t)))\n+\t      {\n+\t\tx = TREE_CHAIN (x);\n+\t\tcontinue;\n+\t      }\n \n #ifdef DWARF_DEBUGGING_INFO\n \t  if (write_symbols == DWARF_DEBUG)\n@@ -4077,6 +4080,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n      the base types we marked.  */\n   finish_vtbls (TYPE_BINFO (t), 1, t);\n   TYPE_BEING_DEFINED (t) = 0;\n+  hack_incomplete_structures (t);\n \n   if (flag_rtti && TYPE_VIRTUAL_P (t) && CLASSTYPE_VTABLE_NEEDS_WRITING (t))\n     {\n@@ -4128,8 +4132,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   else\n     error (\"trying to finish struct, but kicked out due to previous parse errors.\");\n \n-  hack_incomplete_structures (t);\n-\n   resume_momentary (old);\n \n   if (flag_cadillac)"}, {"sha": "01d0a3d6386b68dffda29ad45171bf6926435c30", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -556,9 +556,6 @@ build_up_reference (type, arg, flags, checkconst)\n \t}\n       else\n \t{\n-\t  /* We should never get here for class objects, because they are\n-             always in memory.  */\n-\t  my_friendly_assert (! IS_AGGR_TYPE (argtype), 362);\n \t  temp = get_temp_name (argtype, 0);\n \t  if (global_bindings_p ())\n \t    {"}, {"sha": "f57399421e9bb80b1f821f126f014e5fa718ea47", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -552,7 +552,7 @@ struct binding_level\n \n     /* Number of decls in `names' that have incomplete \n        structure or union types.  */\n-    unsigned short n_incomplete;\n+    unsigned int n_incomplete;\n \n     /* 1 for the level that holds the parameters of a function.\n        2 for the level that holds a class declaration.\n@@ -2979,6 +2979,16 @@ pushdecl (x)\n \t  if (++b->n_incomplete == 0)\n \t    error (\"too many incomplete variables at this point\");\n \t}\n+\n+      /* Keep count of variables in this level with incomplete type.  */\n+      /* RTTI TD entries are created while defining the type_info.  */\n+      if (TREE_CODE (x) == VAR_DECL\n+\t  && TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n+\t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))\n+\t{\n+\t  if (++b->n_incomplete == 0)\n+\t    error (\"too many incomplete variables at this point\");\n+\t}\n     }\n \n   if (TREE_CODE (x) == TYPE_DECL && name != NULL_TREE)\n@@ -8603,6 +8613,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\t\t   declarator, type);\n \t    else\n \t      set_nested_typename (d, TYPE_NESTED_NAME (c), declarator, type);\n+\n+\t    DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n+\t    DECL_ASSEMBLER_NAME (d)\n+\t      = get_identifier (build_overload_name (type, 1, 1));\n \t  }\n \t}\n "}, {"sha": "df2b119683688194093e337b7b23f2aabf2abdd5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -1155,13 +1155,22 @@ check_classfn (ctype, cname, function)\n \t\t  if (decls_match (function, fndecl))\n \t\t    return;\n #else\n-\t\t  if (DECL_NAME (function) == DECL_NAME (fndecl)\n-\t\t      && comptypes (TREE_TYPE (TREE_TYPE (function)),\n-\t\t\t\t    TREE_TYPE (TREE_TYPE (fndecl)), 1)\n-\t\t      && compparms (TYPE_ARG_TYPES (TREE_TYPE (function)),\n-\t\t\t\t    TYPE_ARG_TYPES (TREE_TYPE (fndecl)),\n-\t\t\t\t    3))\n-\t\t    return;\n+\t\t  if (DECL_NAME (function) == DECL_NAME (fndecl))\n+\t\t    {\n+\t\t      tree p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n+\t\t      tree p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+\n+\t\t      /* Get rid of the this parameter on functions that become\n+\t\t\t static. */\n+\t\t      if (DECL_STATIC_FUNCTION_P (fndecl)\n+\t\t\t  && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n+\t\t\tp1 = TREE_CHAIN (p1);\n+\n+\t\t      if (comptypes (TREE_TYPE (TREE_TYPE (function)),\n+\t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)), 1)\n+\t\t\t  && compparms (p1, p2, 3))\n+\t\t\treturn;\n+\t\t    }\n #endif\n \t\t  fndecl = DECL_CHAIN (fndecl);\n \t\t}\n@@ -1253,6 +1262,16 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n       DECL_CLASS_CONTEXT (value) = current_class_type;\n       CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n       pushdecl_class_level (value);\n+\n+      /* If we declare a typedef name for something that has no name,\n+\t the typedef name is used for linkage.  See 7.1.3 p4 94/0158. */\n+      if (TYPE_NAME (TREE_TYPE (value))\n+\t  && TREE_CODE (TYPE_NAME (TREE_TYPE (value))) == TYPE_DECL\n+\t  && ANON_AGGRNAME_P (TYPE_IDENTIFIER (TREE_TYPE (value))))\n+\t{\n+\t  TYPE_NAME (TREE_TYPE (value)) = value;\n+\t  TYPE_STUB_DECL (TREE_TYPE (value)) = value;\n+\t}\n       return value;\n     }\n "}, {"sha": "92610ff072549534ecba930bc7aaf12c81b4cd61", "filename": "gcc/cp/method.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -362,6 +362,19 @@ build_overload_value (type, value)\n     value = TREE_OPERAND (value, 0);\n   my_friendly_assert (TREE_CODE (type) == PARM_DECL, 242);\n   type = TREE_TYPE (type);\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n+    {\n+      /* Handle a pointer to member as a template instantiation\n+\t parameter, boy, what fun!  */\n+      type = integer_type_node;\n+      if (TREE_CODE (value) != INTEGER_CST)\n+\t{\n+\t  sorry (\"unknown pointer to member constant\");\n+\t  return;\n+\t}\n+    }\n+\n   switch (TREE_CODE (type))\n     {\n     case INTEGER_TYPE:"}, {"sha": "49dc8329b6f9b50cbdb4844e8193115d2ad4df97", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -1484,7 +1484,7 @@ primary:\n \t\t{ $$ = build_typeid ($3); }\n \t| TYPEID '(' type_id ')'\n \t\t{ tree type = groktypename ($3);\n-\t\t  $$ = get_typeid (type); }\n+\t\t  $$ = get_typeid (TYPE_MAIN_VARIANT (type)); }\n \t| global_scope IDENTIFIER\n \t\t{\n \t\tdo_scoped_id:"}, {"sha": "e10acbe1c29aed2e99895ed2ac081328e0e8f05b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -1239,6 +1239,37 @@ tsubst (t, args, nargs, in_decl)\n \t\t&& TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (t))) == 't'\n \t\t&& constructor_name (DECL_CONTEXT (t)) == DECL_NAME (t))\n \t      name = constructor_name (ctx);\n+\n+\t    if (DECL_CONSTRUCTOR_P (t) && TYPE_USES_VIRTUAL_BASECLASSES (ctx))\n+\t      {\n+\t\t/* Since we didn't know that this class had virtual bases until after\n+\t\t   we instantiated it, we have to recreate the arguments to this\n+\t\t   constructor, as otherwise it would miss the __in_chrg parameter.  */\n+\t\ttree newtype, parm;\n+\t\ttree parms = TREE_CHAIN (TYPE_ARG_TYPES (type));\n+\t\tparms = hash_tree_chain (integer_type_node, parms);\n+\t\tnewtype = build_cplus_method_type (ctx,\n+\t\t\t\t\t\t   TREE_TYPE (type),\n+\t\t\t\t\t\t   parms);\n+\t\tnewtype = build_type_variant (newtype,\n+\t\t\t\t\t      TYPE_READONLY (type),\n+\t\t\t\t\t      TYPE_VOLATILE (type));\n+\t\ttype = newtype;\n+\n+\t\tfnargs = copy_node (DECL_ARGUMENTS (t));\n+\t\t/* In this case we need \"in-charge\" flag saying whether\n+\t\t   this constructor is responsible for initialization\n+\t\t   of virtual baseclasses or not.  */\n+\t\tparm = build_decl (PARM_DECL, in_charge_identifier, integer_type_node);\n+\t\t/* Mark the artificial `__in_chrg' parameter as \"artificial\".  */\n+\t\tSET_DECL_ARTIFICIAL (parm);\n+\t\tDECL_ARG_TYPE (parm) = integer_type_node;\n+\t\tDECL_REGISTER (parm) = 1;\n+\t\tTREE_CHAIN (parm) = TREE_CHAIN (fnargs);\n+\t\tTREE_CHAIN (fnargs) = parm;\n+\n+\t\tfnargs = tsubst (fnargs, args, nargs, t);\n+\t      }\n #if 0\n \t    fprintf (stderr, \"\\nfor function %s in class %s:\\n\",\n \t\t     IDENTIFIER_POINTER (name),"}, {"sha": "ae9f1935f90dfc107849fa06b657fde5173503f4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8145f0828c5c795620174ffd6deba9a5a6eb63f6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8145f0828c5c795620174ffd6deba9a5a6eb63f6", "patch": "@@ -47,6 +47,7 @@ static tree pointer_int_sum ();\n static tree pointer_diff ();\n static tree convert_sequence ();\n /* static */ tree unary_complex_lvalue ();\n+static tree get_delta_difference PROTO((tree, tree, int));\n \n extern rtx original_result_rtx;\n \n@@ -4290,29 +4291,25 @@ unary_complex_lvalue (code, arg)\n \treturn build_unary_op (ADDR_EXPR, t, 0);\n       else\n \t{\n-\t  /* Can't build a pointer to member if the member must\n-\t     go through virtual base classes.  */\n-\t  if (virtual_member (DECL_FIELD_CONTEXT (t),\n-\t\t\t      CLASSTYPE_VBASECLASSES (TREE_TYPE (TREE_OPERAND (arg, 0)))))\n-\t    {\n-\t      sorry (\"pointer to member via virtual baseclass\");\n-\t      return error_mark_node;\n-\t    }\n-\n \t  if (TREE_OPERAND (arg, 0)\n \t      && (TREE_CODE (TREE_OPERAND (arg, 0)) != NOP_EXPR\n \t\t  || TREE_OPERAND (TREE_OPERAND (arg, 0), 0) != error_mark_node))\n-\t    {\n-\t      /* Don't know if this should return address to just\n-\t\t _DECL, or actual address resolved in this expression.  */\n-\t      sorry (\"address of bound pointer-to-member expression\");\n-\t      return error_mark_node;\n-\t    }\n+\t    if (TREE_CODE (t) != FIELD_DECL)\n+\t      {\n+\t\t/* Don't know if this should return address to just\n+\t\t   _DECL, or actual address resolved in this expression.  */\n+\t\tsorry (\"address of bound pointer-to-member expression\");\n+\t\treturn error_mark_node;\n+\t      }\n \n-\t  return convert (build_pointer_type (TREE_TYPE (arg)),\n-\t\t\t  size_binop (EASY_DIV_EXPR, \n-\t\t\t\t      DECL_FIELD_BITPOS (t),\n-\t\t\t\t      size_int (BITS_PER_UNIT)));\n+\t  offset = get_delta_difference (DECL_FIELD_CONTEXT (t), \n+\t\t\t\t\t TREE_TYPE (TREE_OPERAND (arg, 0)),\n+\t\t\t\t\t 0);\n+\t  offset = size_binop (PLUS_EXPR, offset,\n+\t\t\t       size_binop (EASY_DIV_EXPR,\n+\t\t\t\t\t   DECL_FIELD_BITPOS (t),\n+\t\t\t\t\t   size_int (BITS_PER_UNIT)));\n+\t  return convert (build_pointer_type (TREE_TYPE (arg)), offset);\n \t}\n     }\n "}]}