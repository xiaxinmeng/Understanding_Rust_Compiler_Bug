{"sha": "6080348f0a75caa10df4208617d9247d56e85329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA4MDM0OGYwYTc1Y2FhMTBkZjQyMDg2MTdkOTI0N2Q1NmU4NTMyOQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-04-16T15:15:48Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2009-04-16T15:15:48Z"}, "message": "re PR rtl-optimization/39762 (IRA ICE with -msoft-float)\n\n2009-04-16  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/39762\n\t* ira-int.h (ira_register_move_cost, ira_may_move_in_cost,\n\tira_may_move_out_cost): Add comments about way of their usage.\n\t(ira_get_register_move_cost, ira_get_may_move_cost): New\n\tfunctions.\n\t\n\t* ira-conflicts.c (process_regs_for_copy): Use function\n\tira_get_register_move_cost instead of global\n\tira_register_move_cost.\n\n\t* ira-color.c (update_copy_costs, calculate_allocno_spill_cost,\n\tcolor_pass, move_spill_restore, update_curr_costs): Ditto.\n\n\t* ira-lives.c (process_single_reg_class_operands): Ditto.\n\n\t* ira-emit.c (emit_move_list): Ditto.\n\n\t* ira-costs.c (copy_cost): Don't call ira_init_register_move_cost.\n\t(record_reg_classes): Ditto.  Use functions\n\tira_get_register_move_cost and ira_get_may_move_cost instead of\n\tglobal vars ira_register_move_cost, ira_may_move_out_cost and\n\tira_may_move_in_cost.\n\t(record_address_regs): Don't call ira_init_register_move_cost.\n\tUse function ira_get_may_move_cost instead of global\n\tira_may_move_in_cost.\n\t(process_bb_node_for_hard_reg_moves): Use function\n\tira_get_register_move_cost instead of global\n\tira_register_move_cost.\n\t(ira_costs): Don't call ira_init_register_move_cost.\n\nFrom-SVN: r146198", "tree": {"sha": "cb80a649f68346c26aa9c7e3333e0ca57fbc0396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb80a649f68346c26aa9c7e3333e0ca57fbc0396"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6080348f0a75caa10df4208617d9247d56e85329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6080348f0a75caa10df4208617d9247d56e85329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6080348f0a75caa10df4208617d9247d56e85329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6080348f0a75caa10df4208617d9247d56e85329/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "646bea10e5f7be362618a8cdcf91d87ea9771fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646bea10e5f7be362618a8cdcf91d87ea9771fd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646bea10e5f7be362618a8cdcf91d87ea9771fd1"}], "stats": {"total": 166, "additions": 108, "deletions": 58}, "files": [{"sha": "e34def9b1630274654861f5090b6974b7ebd977e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6080348f0a75caa10df4208617d9247d56e85329/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6080348f0a75caa10df4208617d9247d56e85329/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6080348f0a75caa10df4208617d9247d56e85329", "patch": "@@ -1,3 +1,35 @@\n+2009-04-16  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/39762\n+\t* ira-int.h (ira_register_move_cost, ira_may_move_in_cost,\n+\tira_may_move_out_cost): Add comments about way of their usage.\n+\t(ira_get_register_move_cost, ira_get_may_move_cost): New\n+\tfunctions.\n+\t\n+\t* ira-conflicts.c (process_regs_for_copy): Use function\n+\tira_get_register_move_cost instead of global\n+\tira_register_move_cost.\n+\n+\t* ira-color.c (update_copy_costs, calculate_allocno_spill_cost,\n+\tcolor_pass, move_spill_restore, update_curr_costs): Ditto.\n+\n+\t* ira-lives.c (process_single_reg_class_operands): Ditto.\n+\n+\t* ira-emit.c (emit_move_list): Ditto.\n+\n+\t* ira-costs.c (copy_cost): Don't call ira_init_register_move_cost.\n+\t(record_reg_classes): Ditto.  Use functions\n+\tira_get_register_move_cost and ira_get_may_move_cost instead of\n+\tglobal vars ira_register_move_cost, ira_may_move_out_cost and\n+\tira_may_move_in_cost.\n+\t(record_address_regs): Don't call ira_init_register_move_cost.\n+\tUse function ira_get_may_move_cost instead of global\n+\tira_may_move_in_cost.\n+\t(process_bb_node_for_hard_reg_moves): Use function\n+\tira_get_register_move_cost instead of global\n+\tira_register_move_cost.\n+\t(ira_costs): Don't call ira_init_register_move_cost.\n+\t\n 2009-04-16  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-cfg.c (verify_gimple_assign_binary):"}, {"sha": "743ec3cd83566aca6299233bb122ea234f7f37df", "filename": "gcc/ira-color.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=6080348f0a75caa10df4208617d9247d56e85329", "patch": "@@ -285,8 +285,8 @@ update_copy_costs (ira_allocno_t allocno, bool decr_p)\n \t    continue;\n \n \t  cost = (cp->second == allocno\n-\t\t  ? ira_register_move_cost[mode][rclass][cover_class]\n-\t\t  : ira_register_move_cost[mode][cover_class][rclass]);\n+\t\t  ? ira_get_register_move_cost (mode, rclass, cover_class)\n+\t\t  : ira_get_register_move_cost (mode, cover_class, rclass));\n \t  if (decr_p)\n \t    cost = -cost;\n \n@@ -1071,7 +1071,7 @@ calculate_allocno_spill_cost (ira_allocno_t a)\n \t      * ira_loop_edge_freq (loop_node, regno, true)\n \t      + ira_memory_move_cost[mode][rclass][0]\n \t      * ira_loop_edge_freq (loop_node, regno, false))\n-\t     - (ira_register_move_cost[mode][rclass][rclass]\n+\t     - (ira_get_register_move_cost (mode, rclass, rclass)\n \t\t* (ira_loop_edge_freq (loop_node, regno, false)\n \t\t   + ira_loop_edge_freq (loop_node, regno, true))));\n   return cost;\n@@ -2039,7 +2039,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t  else\n \t    {\n \t      cover_class = ALLOCNO_COVER_CLASS (subloop_allocno);\n-\t      cost = (ira_register_move_cost[mode][rclass][rclass] \n+\t      cost = (ira_get_register_move_cost (mode, rclass, rclass)\n \t\t      * (exit_freq + enter_freq));\n \t      ira_allocate_and_set_or_copy_costs\n \t\t(&ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno), cover_class,\n@@ -2164,7 +2164,7 @@ move_spill_restore (void)\n \t\t    += (ira_memory_move_cost[mode][rclass][0] * exit_freq\n \t\t\t+ ira_memory_move_cost[mode][rclass][1] * enter_freq);\n \t\t  if (hard_regno2 != hard_regno)\n-\t\t    cost -= (ira_register_move_cost[mode][rclass][rclass]\n+\t\t    cost -= (ira_get_register_move_cost (mode, rclass, rclass)\n \t\t\t     * (exit_freq + enter_freq));\n \t\t}\n \t    }\n@@ -2183,7 +2183,7 @@ move_spill_restore (void)\n \t\t    += (ira_memory_move_cost[mode][rclass][1] * exit_freq\n \t\t\t+ ira_memory_move_cost[mode][rclass][0] * enter_freq);\n \t\t  if (hard_regno2 != hard_regno)\n-\t\t    cost -= (ira_register_move_cost[mode][rclass][rclass]\n+\t\t    cost -= (ira_get_register_move_cost (mode, rclass, rclass)\n \t\t\t     * (exit_freq + enter_freq));\n \t\t}\n \t    }\n@@ -2249,8 +2249,8 @@ update_curr_costs (ira_allocno_t a)\n       if (i < 0)\n \tcontinue;\n       cost = (cp->first == a\n-\t      ? ira_register_move_cost[mode][rclass][cover_class]\n-\t      : ira_register_move_cost[mode][cover_class][rclass]);\n+\t      ? ira_get_register_move_cost (mode, rclass, cover_class)\n+\t      : ira_get_register_move_cost (mode, cover_class, rclass));\n       ira_allocate_and_set_or_copy_costs\n \t(&ALLOCNO_UPDATED_HARD_REG_COSTS (a),\n \t cover_class, ALLOCNO_COVER_CLASS_COST (a),"}, {"sha": "399a28ae5cc9290fea817f2d989898b87a1fede7", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=6080348f0a75caa10df4208617d9247d56e85329", "patch": "@@ -411,9 +411,9 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n     /* Can not be tied.  It is not in the cover class.  */\n     return false;\n   if (HARD_REGISTER_P (reg1))\n-    cost = ira_register_move_cost[mode][cover_class][rclass] * freq;\n+    cost = ira_get_register_move_cost (mode, cover_class, rclass) * freq;\n   else\n-    cost = ira_register_move_cost[mode][rclass][cover_class] * freq;\n+    cost = ira_get_register_move_cost (mode, rclass, cover_class) * freq;\n   for (;;)\n     {\n       ira_allocate_and_set_costs"}, {"sha": "58700b75f14940d209fd4d4bcd8f1efd27ddb4d9", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=6080348f0a75caa10df4208617d9247d56e85329", "patch": "@@ -138,9 +138,6 @@ copy_cost (rtx x, enum machine_mode mode, enum reg_class rclass, bool to_p,\n   sri.extra_cost = 0;\n   secondary_class = targetm.secondary_reload (to_p, x, rclass, mode, &sri);\n \n-  if (ira_register_move_cost[mode] == NULL)\n-    ira_init_register_move_cost (mode);\n-\n   if (secondary_class != NO_REGS)\n     {\n       if (!move_cost[mode])\n@@ -294,19 +291,17 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     needs to do a copy, which is one insn.  */\n \t\t  struct costs *pp = this_op_costs[i];\n \n-\t\t  if (ira_register_move_cost[mode] == NULL)\n-\t\t    ira_init_register_move_cost (mode);\n-\n \t\t  for (k = 0; k < cost_classes_num; k++)\n \t\t    {\n \t\t      rclass = cost_classes[k];\n \t\t      pp->cost[k]\n-\t\t\t= ((recog_data.operand_type[i] != OP_OUT\n-\t\t\t    ? ira_may_move_in_cost[mode][rclass]\n-\t\t\t      [classes[i]] * frequency : 0)\n-\t\t\t   + (recog_data.operand_type[i] != OP_IN\n-\t\t\t      ? ira_may_move_out_cost[mode][classes[i]]\n-\t\t\t        [rclass] * frequency : 0));\n+\t\t\t= (((recog_data.operand_type[i] != OP_OUT\n+\t\t\t     ? ira_get_may_move_cost (mode, rclass,\n+\t\t\t\t\t\t      classes[i], true) : 0)\n+\t\t\t    + (recog_data.operand_type[i] != OP_IN\n+\t\t\t       ? ira_get_may_move_cost (mode, classes[i],\n+\t\t\t\t\t\t\trclass, false) : 0))\n+\t\t\t   * frequency);\n \t\t    }\n \n \t\t  /* If the alternative actually allows memory, make\n@@ -342,8 +337,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t\t : 0));\n \t\t      else if (ira_reg_class_intersect\n \t\t\t       [pref_class][classes[i]] == NO_REGS)\n-\t\t\talt_cost += (ira_register_move_cost\n-\t\t\t\t     [mode][pref_class][classes[i]]);\n+\t\t\talt_cost += ira_get_register_move_cost (mode,\n+\t\t\t\t\t\t\t\tpref_class,\n+\t\t\t\t\t\t\t\tclasses[i]);\n \t\t    }\n \t\t  if (REGNO (ops[i]) != REGNO (ops[j])\n \t\t      && ! find_reg_note (insn, REG_DEAD, op))\n@@ -540,19 +536,17 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t{\n \t\t  struct costs *pp = this_op_costs[i];\n \n-\t\t  if (ira_register_move_cost[mode] == NULL)\n-\t\t    ira_init_register_move_cost (mode);\n-\n \t\t  for (k = 0; k < cost_classes_num; k++)\n \t\t    {\n \t\t      rclass = cost_classes[k];\n \t\t      pp->cost[k]\n-\t\t\t= ((recog_data.operand_type[i] != OP_OUT\n-\t\t\t    ? ira_may_move_in_cost[mode][rclass]\n-\t\t\t      [classes[i]] * frequency : 0)\n-\t\t\t   + (recog_data.operand_type[i] != OP_IN\n-\t\t\t      ? ira_may_move_out_cost[mode][classes[i]]\n-\t\t\t        [rclass] * frequency : 0));\n+\t\t\t= (((recog_data.operand_type[i] != OP_OUT\n+\t\t\t     ? ira_get_may_move_cost (mode, rclass,\n+\t\t\t\t\t\t      classes[i], true) : 0)\n+\t\t\t    + (recog_data.operand_type[i] != OP_IN\n+\t\t\t       ? ira_get_may_move_cost (mode, classes[i],\n+\t\t\t\t\t\t\trclass, false) : 0))\n+\t\t\t   * frequency);\n \t\t    }\n \n \t\t  /* If the alternative actually allows memory, make\n@@ -587,8 +581,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t\t : 0));\n \t\t      else if (ira_reg_class_intersect[pref_class][classes[i]]\n \t\t\t       == NO_REGS)\n-\t\t\talt_cost += (ira_register_move_cost\n-\t\t\t\t     [mode][pref_class][classes[i]]);\n+\t\t\talt_cost += ira_get_register_move_cost (mode,\n+\t\t\t\t\t\t\t\tpref_class,\n+\t\t\t\t\t\t\t\tclasses[i]);\n \t\t    }\n \t\t}\n \t    }\n@@ -901,13 +896,11 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \t\t\t       ALLOCNO_NUM (ira_curr_regno_allocno_map\n \t\t\t\t\t    [REGNO (x)]));\n \tpp->mem_cost += (ira_memory_move_cost[Pmode][rclass][1] * scale) / 2;\n-\tif (ira_register_move_cost[Pmode] == NULL)\n-\t  ira_init_register_move_cost (Pmode);\n \tfor (k = 0; k < cost_classes_num; k++)\n \t  {\n \t    i = cost_classes[k];\n \t    pp->cost[k]\n-\t      += (ira_may_move_in_cost[Pmode][i][rclass] * scale) / 2;\n+\t      += (ira_get_may_move_cost (Pmode, i, rclass, true) * scale) / 2;\n \t  }\n       }\n       break;\n@@ -1425,8 +1418,9 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n \tcontinue;\n       mode = ALLOCNO_MODE (a);\n       hard_reg_class = REGNO_REG_CLASS (hard_regno);\n-      cost = (to_p ? ira_register_move_cost[mode][hard_reg_class][rclass]\n-\t      : ira_register_move_cost[mode][rclass][hard_reg_class]) * freq;\n+      cost\n+\t= (to_p ? ira_get_register_move_cost (mode, hard_reg_class, rclass)\n+\t   : ira_get_register_move_cost (mode, rclass, hard_reg_class)) * freq;\n       ira_allocate_and_set_costs (&ALLOCNO_HARD_REG_COSTS (a), rclass,\n \t\t\t\t  ALLOCNO_COVER_CLASS_COST (a));\n       ira_allocate_and_set_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),\n@@ -1579,9 +1573,6 @@ ira_finish_costs_once (void)\n void\n ira_costs (void)\n {\n-  ira_allocno_t a;\n-  ira_allocno_iterator ai;\n-\n   allocno_costs = (struct costs *) ira_allocate (max_struct_costs_size\n \t\t\t\t\t       * ira_allocnos_num);\n   total_costs = (struct costs *) ira_allocate (max_struct_costs_size\n@@ -1594,12 +1585,6 @@ ira_costs (void)\n \t\t\t\t       * max_reg_num ());\n   find_allocno_class_costs ();\n   setup_allocno_cover_class_and_costs ();\n-  /* Because we could process operands only as subregs, check mode of\n-     the registers themselves too.  */\n-  FOR_EACH_ALLOCNO (a, ai)\n-    if (ira_register_move_cost[ALLOCNO_MODE (a)] == NULL\n-\t&& have_regs_of_mode[ALLOCNO_MODE (a)])\n-      ira_init_register_move_cost (ALLOCNO_MODE (a));\n   ira_free (common_classes);\n   ira_free (allocno_pref_buffer);\n   ira_free (total_costs);"}, {"sha": "1d4d8ea224ff0fae85991cdb6d4ae04f86246e5d", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=6080348f0a75caa10df4208617d9247d56e85329", "patch": "@@ -812,7 +812,8 @@ emit_move_list (move_t list, int freq)\n \t}\n       else\n \t{\n-\t  cost = ira_register_move_cost[mode][cover_class][cover_class] * freq;\n+\t  cost = (ira_get_register_move_cost (mode, cover_class, cover_class)\n+\t\t  * freq);\n \t  ira_shuffle_cost += cost;\n \t}\n       ira_overall_cost += cost;"}, {"sha": "5b8c1ef0baec92b2d84f6da720b4eb05502b4cf7", "filename": "gcc/ira-int.h", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=6080348f0a75caa10df4208617d9247d56e85329", "patch": "@@ -730,21 +730,24 @@ ira_allocno_set_iter_next (ira_allocno_set_iterator *i)\n extern HARD_REG_SET ira_reg_mode_hard_regset\n                     [FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n \n-/* Arrays analogous to macros MEMORY_MOVE_COST and\n-   REGISTER_MOVE_COST.  */\n+/* Arrays analogous to macros MEMORY_MOVE_COST and REGISTER_MOVE_COST.\n+   Don't use ira_register_move_cost directly.  Use function of\n+   ira_get_may_move_cost instead.  */\n extern short ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n extern move_table *ira_register_move_cost[MAX_MACHINE_MODE];\n \n /* Similar to may_move_in_cost but it is calculated in IRA instead of\n    regclass.  Another difference we take only available hard registers\n    into account to figure out that one register class is a subset of\n-   the another one.  */\n+   the another one.  Don't use it directly.  Use function of\n+   ira_get_may_move_cost instead.  */\n extern move_table *ira_may_move_in_cost[MAX_MACHINE_MODE];\n \n /* Similar to may_move_out_cost but it is calculated in IRA instead of\n    regclass.  Another difference we take only available hard registers\n    into account to figure out that one register class is a subset of\n-   the another one.  */\n+   the another one.  Don't use it directly.  Use function of\n+   ira_get_may_move_cost instead.  */\n extern move_table *ira_may_move_out_cost[MAX_MACHINE_MODE];\n \n /* Register class subset relation: TRUE if the first class is a subset\n@@ -941,6 +944,34 @@ extern void ira_emit (bool);\n \n \f\n \n+/* Return cost of moving value of MODE from register of class FROM to\n+   register of class TO.  */\n+static inline int\n+ira_get_register_move_cost (enum machine_mode mode,\n+\t\t\t    enum reg_class from, enum reg_class to)\n+{\n+  if (ira_register_move_cost[mode] == NULL)\n+    ira_init_register_move_cost (mode);\n+  return ira_register_move_cost[mode][from][to];\n+}\n+\n+/* Return cost of moving value of MODE from register of class FROM to\n+   register of class TO.  Return zero if IN_P is true and FROM is\n+   subset of TO or if IN_P is false and FROM is superset of TO.  */\n+static inline int\n+ira_get_may_move_cost (enum machine_mode mode,\n+\t\t       enum reg_class from, enum reg_class to,\n+\t\t       bool in_p)\n+{\n+  if (ira_register_move_cost[mode] == NULL)\n+    ira_init_register_move_cost (mode);\n+  return (in_p\n+\t  ? ira_may_move_in_cost[mode][from][to]\n+\t  : ira_may_move_out_cost[mode][from][to]);\n+}\n+\n+\f\n+\n /* The iterator for all allocnos.  */\n typedef struct {\n   /* The number of the current element in IRA_ALLOCNOS.  */"}, {"sha": "4390c6fdb8c9bf2bcebafc49f9aaa9af3905fdc5", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6080348f0a75caa10df4208617d9247d56e85329/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=6080348f0a75caa10df4208617d9247d56e85329", "patch": "@@ -782,10 +782,11 @@ process_single_reg_class_operands (bool in_p, int freq)\n \t\t  [ira_class_hard_regs[cl][0]]) >= 0\n \t      && reg_class_size[cl] <= (unsigned) CLASS_MAX_NREGS (cl, mode))\n \t    {\n-\t      /* ??? FREQ */\n-\t      cost = freq * (in_p\n-\t\t\t     ? ira_register_move_cost[mode][cover_class][cl]\n-\t\t\t     : ira_register_move_cost[mode][cl][cover_class]);\n+\t      cost\n+\t\t= (freq\n+\t\t   * (in_p\n+\t\t      ? ira_get_register_move_cost (mode, cover_class, cl)\n+\t\t      : ira_get_register_move_cost (mode, cl, cover_class)));\n \t      ira_allocate_and_set_costs\n \t\t(&ALLOCNO_CONFLICT_HARD_REG_COSTS (operand_a), cover_class, 0);\n \t      ALLOCNO_CONFLICT_HARD_REG_COSTS (operand_a)"}]}