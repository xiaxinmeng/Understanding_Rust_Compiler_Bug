{"sha": "e32bac5bd603a3ff3b979fe010c26e40e9b72e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMyYmFjNWJkNjAzYTNmZjNiOTc5ZmUwMTBjMjZlNDBlOWI3MmU2NQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-06-10T18:55:17Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-06-10T18:55:17Z"}, "message": "arm-proto.h: Convert to ISO C90 prototypes.\n\n* arm-proto.h: Convert to ISO C90 prototypes.\n* arm.c: Likewise.\n\nFrom-SVN: r67721", "tree": {"sha": "34f31a5eadd20cae47e3e3f1df93bd6f568e2ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34f31a5eadd20cae47e3e3f1df93bd6f568e2ad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e32bac5bd603a3ff3b979fe010c26e40e9b72e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32bac5bd603a3ff3b979fe010c26e40e9b72e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e32bac5bd603a3ff3b979fe010c26e40e9b72e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32bac5bd603a3ff3b979fe010c26e40e9b72e65/comments", "author": null, "committer": null, "parents": [{"sha": "d192828ab610545ea373b5791fecbe6ba083c31d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d192828ab610545ea373b5791fecbe6ba083c31d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d192828ab610545ea373b5791fecbe6ba083c31d"}], "stats": {"total": 1405, "additions": 467, "deletions": 938}, "files": [{"sha": "1bba247f185f34c8a07c09bfcec503875264f947", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32bac5bd603a3ff3b979fe010c26e40e9b72e65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32bac5bd603a3ff3b979fe010c26e40e9b72e65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e32bac5bd603a3ff3b979fe010c26e40e9b72e65", "patch": "@@ -1,3 +1,8 @@\n+2003-06-10  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm-proto.h: Convert to ISO C90 prototypes.\n+\t* arm.c: Likewise.\n+\n 2003-06-10  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* sh.c (sh_output_mi_thunk): Call insn_locators_initialize."}, {"sha": "62674bc0a2db25c27bd41ee7d5af2955fbb2f31f", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 148, "deletions": 164, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32bac5bd603a3ff3b979fe010c26e40e9b72e65/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32bac5bd603a3ff3b979fe010c26e40e9b72e65/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=e32bac5bd603a3ff3b979fe010c26e40e9b72e65", "patch": "@@ -23,196 +23,180 @@\n #ifndef GCC_ARM_PROTOS_H\n #define GCC_ARM_PROTOS_H\n \n-extern void   arm_override_options\tPARAMS ((void));\n-extern int    use_return_insn\t\tPARAMS ((int));\n-extern int    arm_regno_class \t\tPARAMS ((int));\n-extern void   arm_finalize_pic\t\tPARAMS ((int));\n-extern int    arm_volatile_func\t\tPARAMS ((void));\n-extern const char * arm_output_epilogue\tPARAMS ((int));\n-extern void   arm_expand_prologue\tPARAMS ((void));\n-extern HOST_WIDE_INT arm_get_frame_size\tPARAMS ((void));\n-/* Used in arm.md, but defined in output.c.  */\n-extern void   assemble_align\t\tPARAMS ((int)); \n-extern const char * arm_strip_name_encoding\tPARAMS ((const char *));\n-extern void   arm_asm_output_labelref\tPARAMS ((FILE *, const char *));\n-extern unsigned long arm_current_func_type\tPARAMS ((void));\n-extern unsigned int  arm_compute_initial_elimination_offset PARAMS ((unsigned int, unsigned int));\n+extern void arm_override_options (void);\n+extern int use_return_insn (int);\n+extern int arm_regno_class (int);\n+extern void arm_finalize_pic (int);\n+extern int arm_volatile_func (void);\n+extern const char *arm_output_epilogue (int);\n+extern void arm_expand_prologue (void);\n+extern HOST_WIDE_INT arm_get_frame_size\t(void);\n+extern const char *arm_strip_name_encoding (const char *);\n+extern void arm_asm_output_labelref (FILE *, const char *);\n+extern unsigned long arm_current_func_type (void);\n+extern unsigned int arm_compute_initial_elimination_offset (unsigned int,\n+\t\t\t\t\t\t\t    unsigned int);\n \n #ifdef TREE_CODE\n-extern int    arm_return_in_memory\tPARAMS ((tree));\n-extern void   arm_encode_call_attribute\tPARAMS ((tree, int));\n+extern int arm_return_in_memory (tree);\n+extern void arm_encode_call_attribute (tree, int);\n #endif\n #ifdef RTX_CODE\n-extern int    arm_hard_regno_mode_ok\tPARAMS ((unsigned int,\n-\t\t\t\t\t\tenum machine_mode));\n-extern int    const_ok_for_arm\t\tPARAMS ((HOST_WIDE_INT));\n-extern int    arm_split_constant\tPARAMS ((RTX_CODE, enum machine_mode,\n-\t\t\t\t\t\tHOST_WIDE_INT, rtx, rtx, int));\n-extern RTX_CODE arm_canonicalize_comparison PARAMS ((RTX_CODE, rtx *));\n-extern int    legitimate_pic_operand_p\tPARAMS ((rtx));\n-extern rtx    legitimize_pic_address\tPARAMS ((rtx, enum machine_mode, rtx));\n-extern int    arm_legitimate_address_p  PARAMS ((enum machine_mode, rtx, int));\n-extern int    thumb_legitimate_address_p PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t  int));\n-extern int    thumb_legitimate_offset_p\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t HOST_WIDE_INT));\n-extern rtx    arm_legitimize_address\tPARAMS ((rtx, rtx, enum machine_mode));\n-extern int    const_double_rtx_ok_for_fpa\tPARAMS ((rtx));\n-extern int    neg_const_double_rtx_ok_for_fpa\tPARAMS ((rtx));\n+extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);\n+extern int const_ok_for_arm (HOST_WIDE_INT);\n+extern int arm_split_constant (RTX_CODE, enum machine_mode, HOST_WIDE_INT, rtx,\n+\t\t\t       rtx, int);\n+extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, rtx *);\n+extern int legitimate_pic_operand_p (rtx);\n+extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern int arm_legitimate_address_p  (enum machine_mode, rtx, int);\n+extern int thumb_legitimate_address_p (enum machine_mode, rtx, int);\n+extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);\n+extern rtx arm_legitimize_address (rtx, rtx, enum machine_mode);\n+extern int const_double_rtx_ok_for_fpa (rtx);\n+extern int neg_const_double_rtx_ok_for_fpa (rtx);\n \n /* Predicates.  */\n-extern int    s_register_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    arm_hard_register_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    f_register_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    reg_or_int_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    arm_reload_memory_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    arm_rhs_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    arm_rhsm_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    arm_add_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    arm_not_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    offsettable_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int    alignable_memory_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    bad_signed_byte_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    fpa_rhs_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    fpa_add_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    power_of_two_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    nonimmediate_di_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    di_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    nonimmediate_soft_df_operand PARAMS ((rtx, enum machine_mode));\n-extern int    soft_df_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    index_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    const_shift_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    arm_comparison_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int    shiftable_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int    shift_operator\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    equality_operator\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    minmax_operator\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    cc_register\t\tPARAMS ((rtx, enum machine_mode));\n-extern int    dominant_cc_register\tPARAMS ((rtx, enum machine_mode));\n-extern int    logical_binary_operator\tPARAMS ((rtx, enum machine_mode));\n-extern int    multi_register_push\tPARAMS ((rtx, enum machine_mode));\n-extern int    load_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n-extern int    store_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n-extern int    cirrus_fp_register\tPARAMS ((rtx, enum machine_mode));\n-extern int    cirrus_general_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    cirrus_register_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    cirrus_shift_const\tPARAMS ((rtx, enum machine_mode));\n-extern int    cirrus_memory_offset\tPARAMS ((rtx));\n-\n-extern int    symbol_mentioned_p\tPARAMS ((rtx));\n-extern int    label_mentioned_p\t\tPARAMS ((rtx));\n-extern RTX_CODE minmax_code\t\tPARAMS ((rtx));\n-extern int    adjacent_mem_locations\tPARAMS ((rtx, rtx));\n-extern int    load_multiple_sequence\tPARAMS ((rtx *, int, int *, int *,\n-\t\t\t\t\t\tHOST_WIDE_INT *));\n-extern const char * emit_ldm_seq\tPARAMS ((rtx *, int));\n-extern int    store_multiple_sequence\tPARAMS ((rtx *, int, int *, int *,\n-\t\t\t\t\t\tHOST_WIDE_INT *));\n-extern const char * emit_stm_seq\tPARAMS ((rtx *, int));\n-extern rtx    arm_gen_load_multiple\tPARAMS ((int, int, rtx, int, int, int,\n-\t\t\t\t\t\tint, int));\n-extern rtx    arm_gen_store_multiple\tPARAMS ((int, int, rtx, int, int, int,\n-\t\t\t\t\t\tint, int));\n-extern int    arm_gen_movstrqi\t\tPARAMS ((rtx *));\n-extern rtx    arm_gen_rotated_half_load\tPARAMS ((rtx));\n-extern enum machine_mode arm_select_cc_mode PARAMS ((RTX_CODE, rtx, rtx));\n-extern enum machine_mode arm_select_dominance_cc_mode PARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t       HOST_WIDE_INT));\n-extern rtx    arm_gen_compare_reg\tPARAMS ((RTX_CODE, rtx, rtx));\n-extern rtx    arm_gen_return_addr_mask\tPARAMS ((void));\n-extern void   arm_reload_in_hi\t\tPARAMS ((rtx *));\n-extern void   arm_reload_out_hi\t\tPARAMS ((rtx *));\n-extern const char * fp_immediate_constant PARAMS ((rtx));\n-extern const char * output_call\t\tPARAMS ((rtx *));\n-extern const char * output_call_mem\tPARAMS ((rtx *));\n-extern const char * output_mov_long_double_fpa_from_arm PARAMS ((rtx *));\n-extern const char * output_mov_long_double_arm_from_fpa PARAMS ((rtx *));\n-extern const char * output_mov_long_double_arm_from_arm PARAMS ((rtx *));\n-extern const char * output_mov_double_fpa_from_arm      PARAMS ((rtx *));\n-extern const char * output_mov_double_arm_from_fpa      PARAMS ((rtx *));\n-extern const char * output_move_double\tPARAMS ((rtx *));\n-extern const char * output_mov_immediate PARAMS ((rtx *));\n-extern const char * output_add_immediate PARAMS ((rtx *));\n-extern const char * arithmetic_instr\tPARAMS ((rtx, int));\n-extern void   output_ascii_pseudo_op\tPARAMS ((FILE *, const unsigned char *,\n-\t\t\t\t\t\tint));\n-extern const char * output_return_instruction PARAMS ((rtx, int, int));\n-extern void   arm_poke_function_name\tPARAMS ((FILE *, const char *));\n-extern void   arm_print_operand\t\tPARAMS ((FILE *, rtx, int));\n-extern void   arm_print_operand_address\tPARAMS ((FILE *, rtx));\n-extern void   arm_final_prescan_insn\tPARAMS ((rtx));\n-extern int    arm_go_if_legitimate_address PARAMS ((enum machine_mode, rtx));\n-extern int    arm_debugger_arg_offset\tPARAMS ((int, rtx));\n-extern int    arm_is_longcall_p \tPARAMS ((rtx, int, int));\n+extern int s_register_operand (rtx, enum machine_mode);\n+extern int arm_hard_register_operand (rtx, enum machine_mode);\n+extern int f_register_operand (rtx, enum machine_mode);\n+extern int reg_or_int_operand (rtx, enum machine_mode);\n+extern int arm_reload_memory_operand (rtx, enum machine_mode);\n+extern int arm_rhs_operand (rtx, enum machine_mode);\n+extern int arm_rhsm_operand (rtx, enum machine_mode);\n+extern int arm_add_operand (rtx, enum machine_mode);\n+extern int arm_not_operand (rtx, enum machine_mode);\n+extern int offsettable_memory_operand (rtx, enum machine_mode);\n+extern int alignable_memory_operand (rtx, enum machine_mode);\n+extern int bad_signed_byte_operand (rtx, enum machine_mode);\n+extern int fpa_rhs_operand (rtx, enum machine_mode);\n+extern int fpa_add_operand (rtx, enum machine_mode);\n+extern int power_of_two_operand (rtx, enum machine_mode);\n+extern int nonimmediate_di_operand (rtx, enum machine_mode);\n+extern int di_operand (rtx, enum machine_mode);\n+extern int nonimmediate_soft_df_operand (rtx, enum machine_mode);\n+extern int soft_df_operand (rtx, enum machine_mode);\n+extern int index_operand (rtx, enum machine_mode);\n+extern int const_shift_operand (rtx, enum machine_mode);\n+extern int arm_comparison_operator (rtx, enum machine_mode);\n+extern int shiftable_operator (rtx, enum machine_mode);\n+extern int shift_operator (rtx, enum machine_mode);\n+extern int equality_operator (rtx, enum machine_mode);\n+extern int minmax_operator (rtx, enum machine_mode);\n+extern int cc_register (rtx, enum machine_mode);\n+extern int dominant_cc_register (rtx, enum machine_mode);\n+extern int logical_binary_operator (rtx, enum machine_mode);\n+extern int multi_register_push (rtx, enum machine_mode);\n+extern int load_multiple_operation (rtx, enum machine_mode);\n+extern int store_multiple_operation (rtx, enum machine_mode);\n+extern int cirrus_fp_register (rtx, enum machine_mode);\n+extern int cirrus_general_operand (rtx, enum machine_mode);\n+extern int cirrus_register_operand (rtx, enum machine_mode);\n+extern int cirrus_shift_const (rtx, enum machine_mode);\n+extern int cirrus_memory_offset (rtx);\n+\n+extern int symbol_mentioned_p (rtx);\n+extern int label_mentioned_p (rtx);\n+extern RTX_CODE minmax_code (rtx);\n+extern int adjacent_mem_locations (rtx, rtx);\n+extern int load_multiple_sequence (rtx *, int, int *, int *, HOST_WIDE_INT *);\n+extern const char *emit_ldm_seq (rtx *, int);\n+extern int store_multiple_sequence (rtx *, int, int *, int *, HOST_WIDE_INT *);\n+extern const char * emit_stm_seq (rtx *, int);\n+extern rtx arm_gen_load_multiple (int, int, rtx, int, int, int, int, int);\n+extern rtx arm_gen_store_multiple (int, int, rtx, int, int, int, int, int);\n+extern int arm_gen_movstrqi (rtx *);\n+extern rtx arm_gen_rotated_half_load (rtx);\n+extern enum machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n+extern enum machine_mode arm_select_dominance_cc_mode (rtx, rtx,\n+\t\t\t\t\t\t       HOST_WIDE_INT);\n+extern rtx arm_gen_compare_reg (RTX_CODE, rtx, rtx);\n+extern rtx arm_gen_return_addr_mask (void);\n+extern void arm_reload_in_hi (rtx *);\n+extern void arm_reload_out_hi (rtx *);\n+extern const char *fp_immediate_constant (rtx);\n+extern const char *output_call (rtx *);\n+extern const char *output_call_mem (rtx *);\n+extern const char *output_mov_long_double_fpa_from_arm (rtx *);\n+extern const char *output_mov_long_double_arm_from_fpa (rtx *);\n+extern const char *output_mov_long_double_arm_from_arm (rtx *);\n+extern const char *output_mov_double_fpa_from_arm (rtx *);\n+extern const char *output_mov_double_arm_from_fpa (rtx *);\n+extern const char *output_move_double (rtx *);\n+extern const char *output_mov_immediate (rtx *);\n+extern const char *output_add_immediate (rtx *);\n+extern const char *arithmetic_instr (rtx, int);\n+extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);\n+extern const char *output_return_instruction (rtx, int, int);\n+extern void arm_poke_function_name (FILE *, const char *);\n+extern void arm_print_operand (FILE *, rtx, int);\n+extern void arm_print_operand_address (FILE *, rtx);\n+extern void arm_final_prescan_insn (rtx);\n+extern int arm_go_if_legitimate_address (enum machine_mode, rtx);\n+extern int arm_debugger_arg_offset (int, rtx);\n+extern int arm_is_longcall_p (rtx, int, int);\n \n #if defined TREE_CODE\n-extern rtx    arm_function_arg\t\tPARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\tenum machine_mode, tree, int));\n-extern void   arm_init_cumulative_args\tPARAMS ((CUMULATIVE_ARGS *, tree, rtx,\n-\t\t\t\t\t\ttree));\n-extern rtx    arm_va_arg                PARAMS ((tree, tree));\n-extern int    arm_function_arg_pass_by_reference PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t\t         tree, int));\n+extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n+extern rtx arm_va_arg (tree, tree);\n+extern int arm_function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n+\t\t\t\t\t       enum machine_mode, tree, int);\n #endif\n \n #if defined AOF_ASSEMBLER \n-extern rtx    aof_pic_entry\t\tPARAMS ((rtx));\n-extern char * aof_text_section\t\tPARAMS ((void));\n-extern char * aof_data_section\t\tPARAMS ((void));\n-extern void   aof_add_import\t\tPARAMS ((const char *));\n-extern void   aof_delete_import\t\tPARAMS ((const char *));\n-extern void   zero_init_section\t\tPARAMS ((void));\n-extern void   common_section\t\tPARAMS ((void));\n+extern rtx aof_pic_entry (rtx);\n+extern char *aof_text_section (void);\n+extern char *aof_data_section (void);\n+extern void aof_add_import (const char *);\n+extern void aof_delete_import (const char *);\n+extern void zero_init_section (void);\n+extern void common_section (void);\n #endif /* AOF_ASSEMBLER */\n \n #endif /* RTX_CODE */\n \n-extern int    arm_float_words_big_endian PARAMS ((void));\n+extern int arm_float_words_big_endian (void);\n \n /* Thumb functions.  */\n-extern void   arm_init_expanders\tPARAMS ((void));\n-extern int    thumb_far_jump_used_p\tPARAMS ((int));\n-extern const char * thumb_unexpanded_epilogue\tPARAMS ((void));\n-extern HOST_WIDE_INT thumb_get_frame_size PARAMS ((void));\n-extern void   thumb_expand_prologue\tPARAMS ((void));\n-extern void   thumb_expand_epilogue\tPARAMS ((void));\n+extern void arm_init_expanders (void);\n+extern int thumb_far_jump_used_p (int);\n+extern const char *thumb_unexpanded_epilogue (void);\n+extern HOST_WIDE_INT thumb_get_frame_size (void);\n+extern void thumb_expand_prologue (void);\n+extern void thumb_expand_epilogue (void);\n #ifdef TREE_CODE\n-extern int    is_called_in_ARM_mode\tPARAMS ((tree));\n+extern int is_called_in_ARM_mode (tree);\n #endif\n-extern int    thumb_shiftable_const\tPARAMS ((unsigned HOST_WIDE_INT));\n+extern int thumb_shiftable_const (unsigned HOST_WIDE_INT);\n #ifdef RTX_CODE\n-extern void   thumb_final_prescan_insn\tPARAMS ((rtx));\n-extern const char * thumb_load_double_from_address\n-\t\t\t\t\tPARAMS ((rtx *));\n-extern const char * thumb_output_move_mem_multiple\n-\t\t\t\t\tPARAMS ((int, rtx *));\n-extern void   thumb_expand_movstrqi\tPARAMS ((rtx *));\n-extern int    thumb_cmp_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern rtx *  thumb_legitimize_pic_address\n-\t\t\t\t\tPARAMS ((rtx, enum machine_mode, rtx));\n-extern int    thumb_go_if_legitimate_address\n-\t\t\t\t\tPARAMS ((enum machine_mode, rtx));\n-extern rtx    arm_return_addr\t\tPARAMS ((int, rtx));\n-extern void   thumb_reload_out_hi\tPARAMS ((rtx *));\n-extern void   thumb_reload_in_hi\tPARAMS ((rtx *));\n+extern void thumb_final_prescan_insn (rtx);\n+extern const char *thumb_load_double_from_address (rtx *);\n+extern const char *thumb_output_move_mem_multiple (int, rtx *);\n+extern void thumb_expand_movstrqi (rtx *);\n+extern int thumb_cmp_operand (rtx, enum machine_mode);\n+extern rtx *thumb_legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern int thumb_go_if_legitimate_address (enum machine_mode, rtx);\n+extern rtx arm_return_addr (int, rtx);\n+extern void thumb_reload_out_hi (rtx *);\n+extern void thumb_reload_in_hi (rtx *);\n #endif\n \n /* Defined in pe.c.  */\n-extern int  arm_dllexport_name_p \tPARAMS ((const char *));\n-extern int  arm_dllimport_name_p \tPARAMS ((const char *));\n+extern int arm_dllexport_name_p (const char *);\n+extern int arm_dllimport_name_p (const char *);\n \n #ifdef TREE_CODE\n-extern void arm_pe_unique_section \tPARAMS ((tree, int));\n-extern void arm_pe_encode_section_info \tPARAMS ((tree, rtx, int));\n-extern int  arm_dllexport_p \t\tPARAMS ((tree));\n-extern int  arm_dllimport_p \t\tPARAMS ((tree));\n-extern void arm_mark_dllexport \t\tPARAMS ((tree));\n-extern void arm_mark_dllimport \t\tPARAMS ((tree));\n+extern void arm_pe_unique_section (tree, int);\n+extern void arm_pe_encode_section_info (tree, rtx, int);\n+extern int arm_dllexport_p (tree);\n+extern int arm_dllimport_p (tree);\n+extern void arm_mark_dllexport (tree);\n+extern void arm_mark_dllimport (tree);\n #endif\n \n-extern void arm_pr_long_calls\t\tPARAMS ((struct cpp_reader *));\n-extern void arm_pr_no_long_calls\tPARAMS ((struct cpp_reader *));\n-extern void arm_pr_long_calls_off\tPARAMS ((struct cpp_reader *));\n+extern void arm_pr_long_calls (struct cpp_reader *);\n+extern void arm_pr_no_long_calls (struct cpp_reader *);\n+extern void arm_pr_long_calls_off (struct cpp_reader *);\n \n #endif /* ! GCC_ARM_PROTOS_H */"}, {"sha": "91235947e23ae87c9e6cd90c7557e144c4d8e701", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 314, "deletions": 774, "changes": 1088, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32bac5bd603a3ff3b979fe010c26e40e9b72e65/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32bac5bd603a3ff3b979fe010c26e40e9b72e65/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e32bac5bd603a3ff3b979fe010c26e40e9b72e65", "patch": "@@ -55,13 +55,6 @@\n typedef struct minipool_node    Mnode;\n typedef struct minipool_fixup   Mfix;\n \n-/* In order to improve the layout of the prototypes below\n-   some short type abbreviations are defined here.  */\n-#define Hint     HOST_WIDE_INT\n-#define Mmode    enum machine_mode\n-#define Ulong    unsigned long\n-#define Ccstar   const char *\n-\n const char extra_reg_names1[][16] =\n { \"mv0\", \"mv1\", \"mv2\",  \"mv3\",  \"mv4\",  \"mv5\",  \"mv6\",  \"mv7\",\n   \"mv8\", \"mv9\", \"mv10\", \"mv11\", \"mv12\", \"mv13\", \"mv14\", \"mv15\"\n@@ -71,91 +64,91 @@ const char extra_reg_names1[][16] =\n const struct attribute_spec arm_attribute_table[];\n \n /* Forward function declarations.  */\n-static void      arm_add_gc_roots \t\tPARAMS ((void));\n-static int       arm_gen_constant\t\tPARAMS ((enum rtx_code, Mmode, Hint, rtx, rtx, int, int));\n-static unsigned  bit_count \t\t\tPARAMS ((Ulong));\n-static int\t arm_address_register_rtx_p\tPARAMS ((rtx, int));\n-static int\t arm_legitimate_index_p\t\tPARAMS ((Mmode, rtx, int));\n-static int\t thumb_base_register_rtx_p\tPARAMS ((rtx, Mmode, int));\n-inline static int thumb_index_register_rtx_p\tPARAMS ((rtx, int));\n-static int       const_ok_for_op \t\tPARAMS ((Hint, enum rtx_code));\n-static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n-static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n-static rtx\t emit_sfm\t\t\tPARAMS ((int, int));\n+static void arm_add_gc_roots (void);\n+static int arm_gen_constant (enum rtx_code, enum machine_mode, HOST_WIDE_INT,\n+\t\t\t     rtx, rtx, int, int);\n+static unsigned bit_count (unsigned long);\n+static int arm_address_register_rtx_p (rtx, int);\n+static int arm_legitimate_index_p (enum machine_mode, rtx, int);\n+static int thumb_base_register_rtx_p (rtx, enum machine_mode, int);\n+inline static int thumb_index_register_rtx_p (rtx, int);\n+static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n+static int eliminate_lr2ip (rtx *);\n+static rtx emit_multi_reg_push (int);\n+static rtx emit_sfm (int, int);\n #ifndef AOF_ASSEMBLER\n-static bool\t arm_assemble_integer\t\tPARAMS ((rtx, unsigned int, int));\n+static bool arm_assemble_integer (rtx, unsigned int, int);\n #endif\n-static Ccstar    fp_const_from_val\t\tPARAMS ((REAL_VALUE_TYPE *));\n-static arm_cc    get_arm_condition_code\t\tPARAMS ((rtx));\n-static void      init_fpa_table\t\t\tPARAMS ((void));\n-static Hint      int_log2\t\t\tPARAMS ((Hint));\n-static rtx       is_jump_table \t\t\tPARAMS ((rtx));\n-static Ccstar    output_multi_immediate\t\tPARAMS ((rtx *, Ccstar, Ccstar, int, Hint));\n-static void      print_multi_reg\t\tPARAMS ((FILE *, Ccstar, int, int));\n-static Ccstar    shift_op\t\t\tPARAMS ((rtx, Hint *));\n-static struct machine_function * arm_init_machine_status PARAMS ((void));\n-static int       number_of_first_bit_set        PARAMS ((int));\n-static void      replace_symbols_in_block       PARAMS ((tree, rtx, rtx));\n-static void      thumb_exit                     PARAMS ((FILE *, int, rtx));\n-static void      thumb_pushpop                  PARAMS ((FILE *, int, int));\n-static Ccstar    thumb_condition_code           PARAMS ((rtx, int));\n-static rtx\t is_jump_table\t\t        PARAMS ((rtx));\n-static Hint\t get_jump_table_size\t        PARAMS ((rtx));\n-static Mnode *   move_minipool_fix_forward_ref  PARAMS ((Mnode *, Mnode *, Hint));\n-static Mnode *   add_minipool_forward_ref\tPARAMS ((Mfix *));\n-static Mnode *   move_minipool_fix_backward_ref PARAMS ((Mnode *, Mnode *, Hint));\n-static Mnode *   add_minipool_backward_ref      PARAMS ((Mfix *));\n-static void\t assign_minipool_offsets\tPARAMS ((Mfix *));\n-static void\t arm_print_value\t\tPARAMS ((FILE *, rtx));\n-static void\t dump_minipool\t\t        PARAMS ((rtx));\n-static int\t arm_barrier_cost\t\tPARAMS ((rtx));\n-static Mfix *    create_fix_barrier\t\tPARAMS ((Mfix *, Hint));\n-static void\t push_minipool_barrier\t        PARAMS ((rtx, Hint));\n-static void\t push_minipool_fix\t\tPARAMS ((rtx, Hint, rtx *, Mmode, rtx));\n-static void\t arm_reorg\t\t\tPARAMS ((void));\n-static bool\t note_invalid_constants\t        PARAMS ((rtx, Hint, int));\n-static int       current_file_function_operand\tPARAMS ((rtx));\n-static Ulong\t arm_compute_save_reg0_reg12_mask  PARAMS ((void));\n-static Ulong     arm_compute_save_reg_mask\tPARAMS ((void));\n-static Ulong     arm_isr_value \t\t\tPARAMS ((tree));\n-static Ulong     arm_compute_func_type\t\tPARAMS ((void));\n-static tree      arm_handle_fndecl_attribute    PARAMS ((tree *, tree, tree, int, bool *));\n-static tree      arm_handle_isr_attribute       PARAMS ((tree *, tree, tree, int, bool *));\n-static void\t arm_output_function_epilogue\tPARAMS ((FILE *, Hint));\n-static void\t arm_output_function_prologue\tPARAMS ((FILE *, Hint));\n-static void\t thumb_output_function_prologue PARAMS ((FILE *, Hint));\n-static int\t arm_comp_type_attributes\tPARAMS ((tree, tree));\n-static void\t arm_set_default_type_attributes PARAMS ((tree));\n-static int\t arm_adjust_cost\t\tPARAMS ((rtx, rtx, rtx, int));\n-static int\t arm_use_dfa_pipeline_interface PARAMS ((void));\n-static int\t count_insns_for_constant\tPARAMS ((Hint, int));\n-static int\t arm_get_strip_length\t\tPARAMS ((int));\n-static bool      arm_function_ok_for_sibcall    PARAMS ((tree, tree));\n-static void\t arm_internal_label\t\tPARAMS ((FILE *, Ccstar, Ulong));\n-static void      arm_output_mi_thunk\t\tPARAMS ((FILE *, tree, Hint, Hint, tree));\n-static int       arm_rtx_costs_1\t\tPARAMS ((rtx, enum rtx_code, enum rtx_code));\n-static bool      arm_rtx_costs\t\t\tPARAMS ((rtx, int, int, int *));\n-static int       arm_address_cost\t\tPARAMS ((rtx));\n-static bool \t arm_memory_load_p              PARAMS ((rtx));\n-static bool      arm_cirrus_insn_p              PARAMS ((rtx));\n-static void      cirrus_reorg                   PARAMS ((rtx));\n+static const char *fp_const_from_val (REAL_VALUE_TYPE *);\n+static arm_cc get_arm_condition_code (rtx);\n+static void init_fpa_table (void);\n+static HOST_WIDE_INT int_log2 (HOST_WIDE_INT);\n+static rtx is_jump_table (rtx);\n+static const char *output_multi_immediate (rtx *, const char *, const char *,\n+\t\t\t\t\t   int, HOST_WIDE_INT);\n+static void print_multi_reg (FILE *, const char *, int, int);\n+static const char *shift_op (rtx, HOST_WIDE_INT *);\n+static struct machine_function *arm_init_machine_status (void);\n+static int number_of_first_bit_set (int);\n+static void replace_symbols_in_block (tree, rtx, rtx);\n+static void thumb_exit (FILE *, int, rtx);\n+static void thumb_pushpop (FILE *, int, int);\n+static const char *thumb_condition_code (rtx, int);\n+static rtx is_jump_table (rtx);\n+static HOST_WIDE_INT get_jump_table_size (rtx);\n+static Mnode *move_minipool_fix_forward_ref (Mnode *, Mnode *, HOST_WIDE_INT);\n+static Mnode *add_minipool_forward_ref (Mfix *);\n+static Mnode *move_minipool_fix_backward_ref (Mnode *, Mnode *, HOST_WIDE_INT);\n+static Mnode *add_minipool_backward_ref (Mfix *);\n+static void assign_minipool_offsets (Mfix *);\n+static void arm_print_value (FILE *, rtx);\n+static void dump_minipool (rtx);\n+static int arm_barrier_cost (rtx);\n+static Mfix *create_fix_barrier (Mfix *, HOST_WIDE_INT);\n+static void push_minipool_barrier (rtx, HOST_WIDE_INT);\n+static void push_minipool_fix (rtx, HOST_WIDE_INT, rtx *, enum machine_mode,\n+\t\t\t       rtx);\n+static void arm_reorg (void);\n+static bool note_invalid_constants (rtx, HOST_WIDE_INT, int);\n+static int current_file_function_operand (rtx);\n+static unsigned long arm_compute_save_reg0_reg12_mask (void);\n+static unsigned long arm_compute_save_reg_mask (void);\n+static unsigned long arm_isr_value (tree);\n+static unsigned long arm_compute_func_type (void);\n+static tree arm_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n+static tree arm_handle_isr_attribute (tree *, tree, tree, int, bool *);\n+static void arm_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void arm_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void thumb_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static int arm_comp_type_attributes (tree, tree);\n+static void arm_set_default_type_attributes (tree);\n+static int arm_adjust_cost (rtx, rtx, rtx, int);\n+static int arm_use_dfa_pipeline_interface (void);\n+static int count_insns_for_constant (HOST_WIDE_INT, int);\n+static int arm_get_strip_length (int);\n+static bool arm_function_ok_for_sibcall (tree, tree);\n+static void arm_internal_label (FILE *, const char *, unsigned long);\n+static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t tree);\n+static int arm_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n+static bool arm_rtx_costs (rtx, int, int, int *);\n+static int arm_address_cost (rtx);\n+static bool arm_memory_load_p (rtx);\n+static bool arm_cirrus_insn_p (rtx);\n+static void cirrus_reorg (rtx);\n #ifdef OBJECT_FORMAT_ELF\n-static void\t arm_elf_asm_named_section\tPARAMS ((Ccstar, unsigned int));\n+static void arm_elf_asm_named_section (const char *, unsigned int);\n #endif\n #ifndef ARM_PE\n-static void\t arm_encode_section_info\tPARAMS ((tree, rtx, int));\n+static void arm_encode_section_info (tree, rtx, int);\n #endif\n #ifdef AOF_ASSEMBLER\n-static void\t aof_globalize_label\t\tPARAMS ((FILE *, Ccstar));\n-static void\t aof_dump_imports\t\tPARAMS ((FILE *));\n-static void\t aof_dump_pic_table\t\tPARAMS ((FILE *));\n-static void\t aof_file_end\t\t\tPARAMS ((void));\n+static void aof_globalize_label (FILE *, const char *);\n+static void aof_dump_imports (FILE *);\n+static void aof_dump_pic_table (FILE *);\n+static void aof_file_end (void);\n #endif\n \n-#undef Hint\n-#undef Mmode\n-#undef Ulong\n-#undef Ccstar\n \f\n /* Initialize the GCC target structure.  */\n #ifdef TARGET_DLLIMPORT_DECL_ATTRIBUTES\n@@ -458,8 +451,7 @@ struct arm_cpu_select arm_select[] =\n \n /* Return the number of bits set in VALUE.  */\n static unsigned\n-bit_count (value)\n-     unsigned long value;\n+bit_count (unsigned long value)\n {\n   unsigned long count = 0;\n   \n@@ -475,7 +467,7 @@ bit_count (value)\n /* Fix up any incompatible options that the user has specified.\n    This has now turned into a maze.  */\n void\n-arm_override_options ()\n+arm_override_options (void)\n {\n   unsigned i;\n   \n@@ -843,7 +835,7 @@ arm_override_options ()\n }\n \n static void\n-arm_add_gc_roots ()\n+arm_add_gc_roots (void)\n {\n   gcc_obstack_init(&minipool_obstack);\n   minipool_startobj = (char *) obstack_alloc (&minipool_obstack, 0);\n@@ -880,8 +872,7 @@ static const isr_attribute_arg isr_attribute_args [] =\n    function, or ARM_FT_UNKNOWN if the type cannot be determined.  */\n \n static unsigned long\n-arm_isr_value (argument)\n-     tree argument;\n+arm_isr_value (tree argument)\n {\n   const isr_attribute_arg * ptr;\n   const char *              arg;\n@@ -909,7 +900,7 @@ arm_isr_value (argument)\n /* Computes the type of the current function.  */\n \n static unsigned long\n-arm_compute_func_type ()\n+arm_compute_func_type (void)\n {\n   unsigned long type = ARM_FT_UNKNOWN;\n   tree a;\n@@ -956,7 +947,7 @@ arm_compute_func_type ()\n /* Returns the type of the current function.  */\n \n unsigned long\n-arm_current_func_type ()\n+arm_current_func_type (void)\n {\n   if (ARM_FUNC_TYPE (cfun->machine->func_type) == ARM_FT_UNKNOWN)\n     cfun->machine->func_type = arm_compute_func_type ();\n@@ -967,8 +958,7 @@ arm_current_func_type ()\n /* Return 1 if it is possible to return using a single instruction.  */\n \n int\n-use_return_insn (iscond)\n-     int iscond;\n+use_return_insn (int iscond)\n {\n   int regno;\n   unsigned int func_type;\n@@ -1037,8 +1027,7 @@ use_return_insn (iscond)\n /* Return TRUE if int I is a valid immediate ARM constant.  */\n \n int\n-const_ok_for_arm (i)\n-     HOST_WIDE_INT i;\n+const_ok_for_arm (HOST_WIDE_INT i)\n {\n   unsigned HOST_WIDE_INT mask = ~(unsigned HOST_WIDE_INT)0xFF;\n \n@@ -1069,9 +1058,7 @@ const_ok_for_arm (i)\n \n /* Return true if I is a valid constant for the operation CODE.  */\n static int\n-const_ok_for_op (i, code)\n-     HOST_WIDE_INT i;\n-     enum rtx_code code;\n+const_ok_for_op (HOST_WIDE_INT i, enum rtx_code code)\n {\n   if (const_ok_for_arm (i))\n     return 1;\n@@ -1105,13 +1092,8 @@ const_ok_for_op (i, code)\n    Return value is the number of insns emitted.  */\n \n int\n-arm_split_constant (code, mode, val, target, source, subtargets)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     HOST_WIDE_INT val;\n-     rtx target;\n-     rtx source;\n-     int subtargets;\n+arm_split_constant (enum rtx_code code, enum machine_mode mode,\n+\t\t    HOST_WIDE_INT val, rtx target, rtx source, int subtargets)\n {\n   if (subtargets || code == SET\n       || (GET_CODE (target) == REG && GET_CODE (source) == REG\n@@ -1159,9 +1141,7 @@ arm_split_constant (code, mode, val, target, source, subtargets)\n }\n \n static int\n-count_insns_for_constant (remainder, i)\n-     HOST_WIDE_INT remainder;\n-     int i;\n+count_insns_for_constant (HOST_WIDE_INT remainder, int i)\n {\n   HOST_WIDE_INT temp1;\n   int num_insns = 0;\n@@ -1191,14 +1171,9 @@ count_insns_for_constant (remainder, i)\n    RTL generation.  */\n \n static int\n-arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     HOST_WIDE_INT val;\n-     rtx target;\n-     rtx source;\n-     int subtargets;\n-     int generate;\n+arm_gen_constant (enum rtx_code code, enum machine_mode mode,\n+\t\t  HOST_WIDE_INT val, rtx target, rtx source, int subtargets,\n+\t\t  int generate)\n {\n   int can_invert = 0;\n   int can_negate = 0;\n@@ -1773,9 +1748,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n    immediate value easier to load.  */\n \n enum rtx_code\n-arm_canonicalize_comparison (code, op1)\n-     enum rtx_code code;\n-     rtx * op1;\n+arm_canonicalize_comparison (enum rtx_code code, rtx * op1)\n {\n   unsigned HOST_WIDE_INT i = INTVAL (*op1);\n \n@@ -1835,10 +1808,8 @@ arm_canonicalize_comparison (code, op1)\n /* Decide whether a type should be returned in memory (true)\n    or in a register (false).  This is called by the macro\n    RETURN_IN_MEMORY.  */\n-\n int\n-arm_return_in_memory (type)\n-     tree type;\n+arm_return_in_memory (tree type)\n {\n   HOST_WIDE_INT size;\n \n@@ -1943,7 +1914,7 @@ arm_return_in_memory (type)\n /* Indicate whether or not words of a double are in big-endian order. */\n \n int\n-arm_float_words_big_endian ()\n+arm_float_words_big_endian (void)\n {\n   if (TARGET_CIRRUS)\n     return 0;\n@@ -1967,11 +1938,9 @@ arm_float_words_big_endian ()\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is NULL.  */\n void\n-arm_init_cumulative_args (pcum, fntype, libname, fndecl)\n-     CUMULATIVE_ARGS * pcum;\n-     tree fntype;\n-     rtx libname  ATTRIBUTE_UNUSED;\n-     tree fndecl ATTRIBUTE_UNUSED;\n+arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype, \n+\t\t\t  rtx libname  ATTRIBUTE_UNUSED,\n+\t\t\t  tree fndecl ATTRIBUTE_UNUSED)\n {\n   /* On the ARM, the offset starts at 0.  */\n   pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype))) ? 1 : 0);\n@@ -2006,11 +1975,8 @@ arm_init_cumulative_args (pcum, fntype, libname, fndecl)\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n rtx\n-arm_function_arg (pcum, mode, type, named)\n-     CUMULATIVE_ARGS * pcum;\n-     enum machine_mode mode;\n-     tree type ATTRIBUTE_UNUSED;\n-     int named;\n+arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+\t\t  tree type ATTRIBUTE_UNUSED, int named)\n {\n   if (mode == VOIDmode)\n     /* Compute operand 2 of the call insn.  */\n@@ -2026,20 +1992,17 @@ arm_function_arg (pcum, mode, type, named)\n    extension to the ARM ABI.  */\n \n int\n-arm_function_arg_pass_by_reference (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+arm_function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n+\t\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n {\n   return type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST;\n }\n \n /* Implement va_arg.  */\n \n rtx\n-arm_va_arg (valist, type)\n-     tree valist, type;\n+arm_va_arg (tree valist, tree type)\n {\n   /* Variable sized types are passed by reference.  */\n   if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n@@ -2062,22 +2025,19 @@ typedef enum\n static arm_pragma_enum arm_pragma_long_calls = OFF;\n \n void\n-arm_pr_long_calls (pfile)\n-     struct cpp_reader * pfile ATTRIBUTE_UNUSED;\n+arm_pr_long_calls (struct cpp_reader * pfile ATTRIBUTE_UNUSED)\n {\n   arm_pragma_long_calls = LONG;\n }\n \n void\n-arm_pr_no_long_calls (pfile)\n-     struct cpp_reader * pfile ATTRIBUTE_UNUSED;\n+arm_pr_no_long_calls (struct cpp_reader * pfile ATTRIBUTE_UNUSED)\n {\n   arm_pragma_long_calls = SHORT;\n }\n \n void\n-arm_pr_long_calls_off (pfile)\n-     struct cpp_reader * pfile ATTRIBUTE_UNUSED;\n+arm_pr_long_calls_off (struct cpp_reader * pfile ATTRIBUTE_UNUSED)\n {\n   arm_pragma_long_calls = OFF;\n }\n@@ -2116,14 +2076,9 @@ const struct attribute_spec arm_attribute_table[] =\n \n /* Handle an attribute requiring a FUNCTION_DECL;\n    arguments as in struct attribute_spec.handler.  */\n-\n static tree\n-arm_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n-     tree * node;\n-     tree   name;\n-     tree   args ATTRIBUTE_UNUSED;\n-     int    flags ATTRIBUTE_UNUSED;\n-     bool * no_add_attrs;\n+arm_handle_fndecl_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n+\t\t\t     int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -2137,14 +2092,9 @@ arm_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)\n \n /* Handle an \"interrupt\" or \"isr\" attribute;\n    arguments as in struct attribute_spec.handler.  */\n-\n static tree\n-arm_handle_isr_attribute (node, name, args, flags, no_add_attrs)\n-     tree * node;\n-     tree   name;\n-     tree   args;\n-     int    flags;\n-     bool * no_add_attrs;\n+arm_handle_isr_attribute (tree *node, tree name, tree args, int flags,\n+\t\t\t  bool *no_add_attrs)\n {\n   if (DECL_P (*node))\n     {\n@@ -2202,11 +2152,8 @@ arm_handle_isr_attribute (node, name, args, flags, no_add_attrs)\n /* Return 0 if the attributes for two types are incompatible, 1 if they\n    are compatible, and 2 if they are nearly compatible (which causes a\n    warning to be generated).  */\n-\n static int\n-arm_comp_type_attributes (type1, type2)\n-     tree type1;\n-     tree type2;\n+arm_comp_type_attributes (tree type1, tree type2)\n {\n   int l1, l2, s1, s2;\n   \n@@ -2247,11 +2194,8 @@ arm_comp_type_attributes (type1, type2)\n \n /*  Encode long_call or short_call attribute by prefixing\n     symbol name in DECL with a special character FLAG.  */\n-\n void\n-arm_encode_call_attribute (decl, flag)\n-  tree decl;\n-  int flag;\n+arm_encode_call_attribute (tree decl, int flag)\n {\n   const char * str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n   int          len = strlen (str);\n@@ -2272,10 +2216,8 @@ arm_encode_call_attribute (decl, flag)\n /*  Assigns default attributes to newly defined type.  This is used to\n     set short_call/long_call attributes for function types of\n     functions defined inside corresponding #pragma scopes.  */\n-\n static void\n-arm_set_default_type_attributes (type)\n-  tree type;\n+arm_set_default_type_attributes (tree type)\n {\n   /* Add __attribute__ ((long_call)) to all functions, when\n      inside #pragma long_calls or __attribute__ ((short_call)),\n@@ -2300,10 +2242,8 @@ arm_set_default_type_attributes (type)\n /* Return 1 if the operand is a SYMBOL_REF for a function known to be\n    defined within the current compilation unit.  If this cannot be\n    determined, then 0 is returned.  */\n-\n static int\n-current_file_function_operand (sym_ref)\n-  rtx sym_ref;\n+current_file_function_operand (rtx sym_ref)\n {\n   /* This is a bit of a fib.  A function will have a short call flag\n      applied to its name if it has the short call attribute, or it has\n@@ -2343,12 +2283,8 @@ current_file_function_operand (sym_ref)\n    \"call_symbol\" and \"call_symbol_value\" patterns and to 0 in the \"call\"\n    and \"call_value\" patterns.  This is because of the difference in the\n    SYM_REFs passed by these patterns.  */\n-\n int\n-arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n-  rtx sym_ref;\n-  int call_cookie;\n-  int call_symbol;\n+arm_is_longcall_p (rtx sym_ref, int call_cookie, int call_symbol)\n {\n   if (!call_symbol)\n     {\n@@ -2376,11 +2312,8 @@ arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n }\n \n /* Return nonzero if it is ok to make a tail-call to DECL.  */\n-\n static bool\n-arm_function_ok_for_sibcall (decl, exp)\n-     tree decl;\n-     tree exp ATTRIBUTE_UNUSED;\n+arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   int call_type = TARGET_LONG_CALLS ? CALL_LONG : CALL_NORMAL;\n \n@@ -2421,8 +2354,7 @@ arm_function_ok_for_sibcall (decl, exp)\n /* Return non-zero if X is a legitimate immediate operand when compiling\n    for PIC.  */\n int\n-legitimate_pic_operand_p (x)\n-     rtx x;\n+legitimate_pic_operand_p (rtx x)\n {\n   if (CONSTANT_P (x)\n       && flag_pic\n@@ -2436,10 +2368,7 @@ legitimate_pic_operand_p (x)\n }\n \n rtx\n-legitimize_pic_address (orig, mode, reg)\n-     rtx orig;\n-     enum machine_mode mode;\n-     rtx reg;\n+legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n {\n   if (GET_CODE (orig) == SYMBOL_REF\n       || GET_CODE (orig) == LABEL_REF)\n@@ -2557,10 +2486,8 @@ legitimize_pic_address (orig, mode, reg)\n    generated insns at the start of the function);  false if called\n    by an exception receiver that needs the PIC register reloaded\n    (in which case the insns are just dumped at the current location).  */\n-\n void\n-arm_finalize_pic (prologue)\n-     int prologue ATTRIBUTE_UNUSED;\n+arm_finalize_pic (int prologue ATTRIBUTE_UNUSED)\n {\n #ifndef AOF_ASSEMBLER\n   rtx l1, pic_tmp, pic_tmp2, seq, pic_rtx;\n@@ -2613,9 +2540,7 @@ arm_finalize_pic (prologue)\n \n /* Return nonzero if X is valid as an ARM state addressing register.  */\n static int\n-arm_address_register_rtx_p (x, strict_p)\n-     rtx x;\n-     int strict_p;\n+arm_address_register_rtx_p (rtx x, int strict_p)\n {\n   int regno;\n \n@@ -2635,10 +2560,7 @@ arm_address_register_rtx_p (x, strict_p)\n \n /* Return nonzero if X is a valid ARM state address operand.  */\n int\n-arm_legitimate_address_p (mode, x, strict_p)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict_p;\n+arm_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n {\n   if (arm_address_register_rtx_p (x, strict_p))\n     return 1;\n@@ -2720,10 +2642,7 @@ arm_legitimate_address_p (mode, x, strict_p)\n /* Return nonzero if INDEX is valid for an address index operand in\n    ARM state.  */\n static int\n-arm_legitimate_index_p (mode, index, strict_p)\n-     enum machine_mode mode;\n-     rtx index;\n-     int strict_p;\n+arm_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n {\n   HOST_WIDE_INT range;\n   enum rtx_code code = GET_CODE (index);\n@@ -2783,10 +2702,7 @@ arm_legitimate_index_p (mode, index, strict_p)\n \n /* Return nonzero if X is valid as an ARM state addressing register.  */\n static int\n-thumb_base_register_rtx_p (x, mode, strict_p)\n-     rtx x;\n-     enum machine_mode mode;\n-     int strict_p;\n+thumb_base_register_rtx_p (rtx x, enum machine_mode mode, int strict_p)\n {\n   int regno;\n \n@@ -2810,9 +2726,7 @@ thumb_base_register_rtx_p (x, mode, strict_p)\n /* Return nonzero if x is a legitimate index register.  This is the case\n    for any base register that can access a QImode object.  */\n inline static int\n-thumb_index_register_rtx_p (x, strict_p)\n-     rtx x;\n-     int strict_p;\n+thumb_index_register_rtx_p (rtx x, int strict_p)\n {\n   return thumb_base_register_rtx_p (x, QImode, strict_p);\n }\n@@ -2835,10 +2749,7 @@ thumb_index_register_rtx_p (x, strict_p)\n    reload pass starts.  This is so that eliminating such addresses\n    into stack based ones won't produce impossible code.  */\n int\n-thumb_legitimate_address_p (mode, x, strict_p)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict_p;\n+thumb_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n {\n   /* ??? Not clear if this is right.  Experiment.  */\n   if (GET_MODE_SIZE (mode) < 4\n@@ -2931,9 +2842,7 @@ thumb_legitimate_address_p (mode, x, strict_p)\n /* Return nonzero if VAL can be used as an offset in a Thumb-state address\n    instruction of mode MODE.  */\n int\n-thumb_legitimate_offset_p (mode, val)\n-     enum machine_mode mode;\n-     HOST_WIDE_INT val;\n+thumb_legitimate_offset_p (enum machine_mode mode, HOST_WIDE_INT val)\n {\n   switch (GET_MODE_SIZE (mode))\n     {\n@@ -2952,12 +2861,8 @@ thumb_legitimate_offset_p (mode, val)\n \n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.  */\n-\n rtx\n-arm_legitimize_address (x, orig_x, mode)\n-     rtx x;\n-     rtx orig_x;\n-     enum machine_mode mode;\n+arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n {\n   if (GET_CODE (x) == PLUS)\n     {\n@@ -3047,12 +2952,9 @@ arm_legitimize_address (x, orig_x, mode)\n #ifndef COSTS_N_INSNS\n #define COSTS_N_INSNS(N) ((N) * 4 - 2)\n #endif\n-\n+/* Worker routine for arm_rtx_costs.  */\n static inline int\n-arm_rtx_costs_1 (x, code, outer)\n-     rtx x;\n-     enum rtx_code code;\n-     enum rtx_code outer;\n+arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n {\n   enum machine_mode mode = GET_MODE (x);\n   enum rtx_code subcode;\n@@ -3434,10 +3336,7 @@ arm_rtx_costs_1 (x, code, outer)\n }\n \n static bool\n-arm_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n+arm_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   *total = arm_rtx_costs_1 (x, code, outer_code);\n   return true;\n@@ -3447,10 +3346,8 @@ arm_rtx_costs (x, code, outer_code, total)\n    the same for practically all of them.  So we weight the different types\n    of address here in the order (most pref first):\n    PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL. */\n-\n static int\n-arm_address_cost (X)\n-    rtx X;\n+arm_address_cost (rtx x)\n {\n #define ARM_ADDRESS_COST(X)\t\t\t\t\t\t     \\\n   (10 - ((GET_CODE (X) == MEM || GET_CODE (X) == LABEL_REF\t\t     \\\n@@ -3474,21 +3371,17 @@ arm_address_cost (X)\n \t&& GET_CODE (XEXP (X, 1)) == CONST_INT))\t\t\\\n    ? 1 : 2)\n      \n-  return (TARGET_ARM ? ARM_ADDRESS_COST (X) : THUMB_ADDRESS_COST (X));\n+  return (TARGET_ARM ? ARM_ADDRESS_COST (x) : THUMB_ADDRESS_COST (x));\n }\n \n static int\n-arm_use_dfa_pipeline_interface ()\n+arm_use_dfa_pipeline_interface (void)\n {\n   return true;\n }\n \n static int\n-arm_adjust_cost (insn, link, dep, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep;\n-     int cost;\n+arm_adjust_cost (rtx insn, rtx link, rtx dep, int cost)\n {\n   rtx i_pat, d_pat;\n \n@@ -3564,8 +3457,6 @@ arm_adjust_cost (insn, link, dep, cost)\n   return cost;\n }\n \n-/* This code has been fixed for cross compilation.  */\n-\n static int fpa_consts_inited = 0;\n \n static const char * const strings_fpa[8] =\n@@ -3577,7 +3468,7 @@ static const char * const strings_fpa[8] =\n static REAL_VALUE_TYPE values_fpa[8];\n \n static void\n-init_fpa_table ()\n+init_fpa_table (void)\n {\n   int i;\n   REAL_VALUE_TYPE r;\n@@ -3592,10 +3483,8 @@ init_fpa_table ()\n }\n \n /* Return TRUE if rtx X is a valid immediate FPA constant.  */\n-\n int\n-const_double_rtx_ok_for_fpa (x)\n-     rtx x;\n+const_double_rtx_ok_for_fpa (rtx x)\n {\n   REAL_VALUE_TYPE r;\n   int i;\n@@ -3615,10 +3504,8 @@ const_double_rtx_ok_for_fpa (x)\n }\n \n /* Return TRUE if rtx X is a valid immediate FPA constant.  */\n-\n int\n-neg_const_double_rtx_ok_for_fpa (x)\n-     rtx x;\n+neg_const_double_rtx_ok_for_fpa (rtx x)\n {\n   REAL_VALUE_TYPE r;\n   int i;\n@@ -3647,11 +3534,8 @@ neg_const_double_rtx_ok_for_fpa (x)\n    code.  SUBREG(MEM) always needs a reload in the places where\n    s_register_operand is used, and this seemed to lead to excessive\n    reloading.  */\n-\n int\n-s_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+s_register_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return 0;\n@@ -3668,11 +3552,8 @@ s_register_operand (op, mode)\n }\n \n /* A hard register operand (even before reload.  */\n-\n int\n-arm_hard_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arm_hard_register_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return 0;\n@@ -3682,11 +3563,8 @@ arm_hard_register_operand (op, mode)\n }\n     \n /* Only accept reg, subreg(reg), const_int.  */\n-\n int\n-reg_or_int_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_int_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return 1;\n@@ -3705,11 +3583,8 @@ reg_or_int_operand (op, mode)\n }\n \n /* Return 1 if OP is an item in memory, given that we are in reload.  */\n-\n int\n-arm_reload_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+arm_reload_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int regno = true_regnum (op);\n \n@@ -3725,11 +3600,8 @@ arm_reload_memory_operand (op, mode)\n    emitting patterns.  In this latter case we cannot use memory_operand()\n    because it will fail on badly formed MEMs, which is precisely what we are\n    trying to catch.  */\n-\n int\n-bad_signed_byte_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+bad_signed_byte_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n #if 0\n   if ((mode == QImode && !memory_operand (op, mode)) || GET_CODE (op) != MEM)\n@@ -3758,23 +3630,17 @@ bad_signed_byte_operand (op, mode)\n }\n \n /* Return TRUE for valid operands for the rhs of an ARM instruction.  */\n-\n int\n-arm_rhs_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arm_rhs_operand (rtx op, enum machine_mode mode)\n {\n   return (s_register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op))));\n }\n \n /* Return TRUE for valid operands for the\n    rhs of an ARM instruction, or a load.  */\n-\n int\n-arm_rhsm_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arm_rhsm_operand (rtx op, enum machine_mode mode)\n {\n   return (s_register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op)))\n@@ -3783,11 +3649,8 @@ arm_rhsm_operand (op, mode)\n \n /* Return TRUE for valid operands for the rhs of an ARM instruction, or if a\n    constant that is valid when negated.  */\n-\n int\n-arm_add_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arm_add_operand (rtx op, enum machine_mode mode)\n {\n   if (TARGET_THUMB)\n     return thumb_cmp_operand (op, mode);\n@@ -3799,9 +3662,7 @@ arm_add_operand (op, mode)\n }\n \n int\n-arm_not_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arm_not_operand (rtx op, enum machine_mode mode)\n {\n   return (s_register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n@@ -3811,11 +3672,8 @@ arm_not_operand (op, mode)\n \n /* Return TRUE if the operand is a memory reference which contains an\n    offsettable address.  */\n-\n int\n-offsettable_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+offsettable_memory_operand (rtx op, enum machine_mode mode)\n {\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -3828,11 +3686,8 @@ offsettable_memory_operand (op, mode)\n \n /* Return TRUE if the operand is a memory reference which is, or can be\n    made word aligned by adjusting the offset.  */\n-\n int\n-alignable_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+alignable_memory_operand (rtx op, enum machine_mode mode)\n {\n   rtx reg;\n \n@@ -3857,11 +3712,8 @@ alignable_memory_operand (op, mode)\n \n /* Similar to s_register_operand, but does not allow hard integer \n    registers.  */\n-\n int\n-f_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+f_register_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return 0;\n@@ -3877,11 +3729,8 @@ f_register_operand (op, mode)\n }\n \n /* Return TRUE for valid operands for the rhs of an FPA instruction.  */\n-\n int\n-fpa_rhs_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fpa_rhs_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n@@ -3896,9 +3745,7 @@ fpa_rhs_operand (op, mode)\n }\n \n int\n-fpa_add_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fpa_add_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n@@ -3914,10 +3761,8 @@ fpa_add_operand (op, mode)\n }\n \n /* Return nonzero if OP is a valid Cirrus memory address pattern.  */\n-\n int\n-cirrus_memory_offset (op)\n-     rtx op;\n+cirrus_memory_offset (rtx op)\n {\n   /* Reject eliminable registers.  */\n   if (! (reload_in_progress || reload_completed)\n@@ -3953,11 +3798,8 @@ cirrus_memory_offset (op)\n }\n \n /* Return nonzero if OP is a Cirrus or general register.  */\n-\n int\n-cirrus_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cirrus_register_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n@@ -3971,11 +3813,8 @@ cirrus_register_operand (op, mode)\n }\n \n /* Return nonzero if OP is a cirrus FP register.  */\n-\n int\n-cirrus_fp_register (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cirrus_fp_register (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n@@ -3989,11 +3828,8 @@ cirrus_fp_register (op, mode)\n }\n \n /* Return nonzero if OP is a 6bit constant (0..63).  */\n-\n int\n-cirrus_shift_const (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+cirrus_shift_const (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && INTVAL (op) >= 0\n@@ -4003,10 +3839,8 @@ cirrus_shift_const (op, mode)\n /* Returns TRUE if INSN is an \"LDR REG, ADDR\" instruction.\n    Use by the Cirrus Maverick code which has to workaround\n    a hardware bug triggered by such instructions.  */\n-\n static bool\n-arm_memory_load_p (insn)\n-     rtx insn;\n+arm_memory_load_p (rtx insn)\n {\n   rtx body, lhs, rhs;;\n \n@@ -4038,10 +3872,8 @@ arm_memory_load_p (insn)\n }\n \n /* Return TRUE if INSN is a Cirrus instruction.  */\n-\n static bool\n-arm_cirrus_insn_p (insn)\n-     rtx insn;\n+arm_cirrus_insn_p (rtx insn)\n {\n   enum attr_cirrus attr;\n \n@@ -4058,10 +3890,8 @@ arm_cirrus_insn_p (insn)\n }\n \n /* Cirrus reorg for invalid instruction combinations.  */\n-\n static void\n-cirrus_reorg (first)\n-     rtx first;\n+cirrus_reorg (rtx first)\n {\n   enum attr_cirrus attr;\n   rtx body = PATTERN (first);\n@@ -4179,11 +4009,8 @@ cirrus_reorg (first)\n }\n \n /* Return nonzero if OP is a constant power of two.  */\n-\n int\n-power_of_two_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+power_of_two_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -4199,11 +4026,8 @@ power_of_two_operand (op, mode)\n    Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).\n    Note that this disallows MEM(REG+REG), but allows\n    MEM(PRE/POST_INC/DEC(REG)).  */\n-\n int\n-di_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+di_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n@@ -4229,11 +4053,8 @@ di_operand (op, mode)\n }\n \n /* Like di_operand, but don't accept constants.  */\n-\n int\n-nonimmediate_di_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+nonimmediate_di_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n@@ -4254,11 +4075,8 @@ nonimmediate_di_operand (op, mode)\n    Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).\n    Note that this disallows MEM(REG+REG), but allows\n    MEM(PRE/POST_INC/DEC(REG)).  */\n-\n int\n-soft_df_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+soft_df_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n@@ -4286,11 +4104,8 @@ soft_df_operand (op, mode)\n }\n \n /* Like soft_df_operand, but don't accept constants.  */\n-\n int\n-nonimmediate_soft_df_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+nonimmediate_soft_df_operand (rtx op, enum machine_mode mode)\n {\n   if (s_register_operand (op, mode))\n     return TRUE;\n@@ -4307,11 +4122,8 @@ nonimmediate_soft_df_operand (op, mode)\n }\n \n /* Return TRUE for valid index operands.  */\n-\n int\n-index_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+index_operand (rtx op, enum machine_mode mode)\n {\n   return (s_register_operand (op, mode)\n \t  || (immediate_operand (op, mode)\n@@ -4322,11 +4134,8 @@ index_operand (op, mode)\n /* Return TRUE for valid shifts by a constant. This also accepts any\n    power of two on the (somewhat overly relaxed) assumption that the\n    shift operator in this case was a mult.  */\n-\n int\n-const_shift_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+const_shift_operand (rtx op, enum machine_mode mode)\n {\n   return (power_of_two_operand (op, mode)\n \t  || (immediate_operand (op, mode)\n@@ -4336,11 +4145,8 @@ const_shift_operand (op, mode)\n \n /* Return TRUE for arithmetic operators which can be combined with a multiply\n    (shift).  */\n-\n int\n-shiftable_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+shiftable_operator (rtx x, enum machine_mode mode)\n {\n   enum rtx_code code;\n \n@@ -4354,11 +4160,8 @@ shiftable_operator (x, mode)\n }\n \n /* Return TRUE for binary logical operators.  */\n-\n int\n-logical_binary_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+logical_binary_operator (rtx x, enum machine_mode mode)\n {\n   enum rtx_code code;\n \n@@ -4371,11 +4174,8 @@ logical_binary_operator (x, mode)\n }\n \n /* Return TRUE for shift operators.  */\n-\n int\n-shift_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+shift_operator (rtx x,enum machine_mode mode)\n {\n   enum rtx_code code;\n \n@@ -4392,33 +4192,24 @@ shift_operator (x, mode)\n }\n \n /* Return TRUE if x is EQ or NE.  */\n-\n int\n-equality_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+equality_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return GET_CODE (x) == EQ || GET_CODE (x) == NE;\n }\n \n /* Return TRUE if x is a comparison operator other than LTGT or UNEQ.  */\n-\n int\n-arm_comparison_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+arm_comparison_operator (rtx x, enum machine_mode mode)\n {\n   return (comparison_operator (x, mode)\n \t  && GET_CODE (x) != LTGT\n \t  && GET_CODE (x) != UNEQ);\n }\n \n /* Return TRUE for SMIN SMAX UMIN UMAX operators.  */\n-\n int\n-minmax_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+minmax_operator (rtx x, enum machine_mode mode)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -4430,11 +4221,8 @@ minmax_operator (x, mode)\n \n /* Return TRUE if this is the condition code register, if we aren't given\n    a mode, accept any class CCmode register.  */\n-\n int\n-cc_register (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+cc_register (rtx x, enum machine_mode mode)\n {\n   if (mode == VOIDmode)\n     {\n@@ -4455,11 +4243,8 @@ cc_register (x, mode)\n /* Return TRUE if this is the condition code register, if we aren't given\n    a mode, accept any class CCmode register which indicates a dominance\n    expression.  */\n-\n int\n-dominant_cc_register (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+dominant_cc_register (rtx x, enum machine_mode mode)\n {\n   if (mode == VOIDmode)\n     {\n@@ -4469,7 +4254,7 @@ dominant_cc_register (x, mode)\n \treturn FALSE;\n     }\n \n-  if (   mode != CC_DNEmode && mode != CC_DEQmode\n+  if (mode != CC_DNEmode && mode != CC_DEQmode\n       && mode != CC_DLEmode && mode != CC_DLTmode\n       && mode != CC_DGEmode && mode != CC_DGTmode\n       && mode != CC_DLEUmode && mode != CC_DLTUmode\n@@ -4480,10 +4265,8 @@ dominant_cc_register (x, mode)\n }\n \n /* Return TRUE if X references a SYMBOL_REF.  */\n-\n int\n-symbol_mentioned_p (x)\n-     rtx x;\n+symbol_mentioned_p (rtx x)\n {\n   const char * fmt;\n   int i;\n@@ -4511,10 +4294,8 @@ symbol_mentioned_p (x)\n }\n \n /* Return TRUE if X references a LABEL_REF.  */\n-\n int\n-label_mentioned_p (x)\n-     rtx x;\n+label_mentioned_p (rtx x)\n {\n   const char * fmt;\n   int i;\n@@ -4541,8 +4322,7 @@ label_mentioned_p (x)\n }\n \n enum rtx_code\n-minmax_code (x)\n-     rtx x;\n+minmax_code (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n \n@@ -4559,10 +4339,8 @@ minmax_code (x)\n }\n \n /* Return 1 if memory locations are adjacent.  */\n-\n int\n-adjacent_mem_locations (a, b)\n-     rtx a, b;\n+adjacent_mem_locations (rtx a, rtx b)\n {\n   if ((GET_CODE (XEXP (a, 0)) == REG\n        || (GET_CODE (XEXP (a, 0)) == PLUS\n@@ -4590,9 +4368,9 @@ adjacent_mem_locations (a, b)\n       else\n \treg1 = REGNO (XEXP (b, 0));\n \n-      /* Don't accept any offset that will require multiple instructions to handle,\n-\t since this would cause the arith_adjacentmem pattern to output an overlong\n-\t sequence.  */\n+      /* Don't accept any offset that will require multiple\n+\t instructions to handle, since this would cause the\n+\t arith_adjacentmem pattern to output an overlong sequence.  */\n       if (!const_ok_for_op (PLUS, val0) || !const_ok_for_op (PLUS, val1))\n \treturn 0;\n       \n@@ -4603,11 +4381,8 @@ adjacent_mem_locations (a, b)\n \n /* Return 1 if OP is a load multiple operation.  It is known to be\n    parallel and the first section will be tested.  */\n-\n int\n-load_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT count = XVECLEN (op, 0);\n   int dest_regno;\n@@ -4666,11 +4441,8 @@ load_multiple_operation (op, mode)\n \n /* Return 1 if OP is a store multiple operation.  It is known to be\n    parallel and the first section will be tested.  */\n-\n int\n-store_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT count = XVECLEN (op, 0);\n   int src_regno;\n@@ -4728,12 +4500,8 @@ store_multiple_operation (op, mode)\n }\n \n int\n-load_multiple_sequence (operands, nops, regs, base, load_offset)\n-     rtx * operands;\n-     int nops;\n-     int * regs;\n-     int * base;\n-     HOST_WIDE_INT * load_offset;\n+load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n+\t\t\tHOST_WIDE_INT *load_offset)\n {\n   int unsorted_regs[4];\n   HOST_WIDE_INT unsorted_offsets[4];\n@@ -4903,9 +4671,7 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n }\n \n const char *\n-emit_ldm_seq (operands, nops)\n-     rtx * operands;\n-     int nops;\n+emit_ldm_seq (rtx *operands, int nops)\n {\n   int regs[4];\n   int base_reg;\n@@ -4963,12 +4729,8 @@ emit_ldm_seq (operands, nops)\n }\n \n int\n-store_multiple_sequence (operands, nops, regs, base, load_offset)\n-     rtx * operands;\n-     int nops;\n-     int * regs;\n-     int * base;\n-     HOST_WIDE_INT * load_offset;\n+store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n+\t\t\t HOST_WIDE_INT * load_offset)\n {\n   int unsorted_regs[4];\n   HOST_WIDE_INT unsorted_offsets[4];\n@@ -5100,9 +4862,7 @@ store_multiple_sequence (operands, nops, regs, base, load_offset)\n }\n \n const char *\n-emit_stm_seq (operands, nops)\n-     rtx * operands;\n-     int nops;\n+emit_stm_seq (rtx *operands, int nops)\n {\n   int regs[4];\n   int base_reg;\n@@ -5146,9 +4906,7 @@ emit_stm_seq (operands, nops)\n }\n \n int\n-multi_register_push (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+multi_register_push (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != PARALLEL\n       || (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n@@ -5162,16 +4920,9 @@ multi_register_push (op, mode)\n /* Routines for use in generating RTL.  */\n \n rtx\n-arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n-\t\t       in_struct_p, scalar_p)\n-     int base_regno;\n-     int count;\n-     rtx from;\n-     int up;\n-     int write_back;\n-     int unchanging_p;\n-     int in_struct_p;\n-     int scalar_p;\n+arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n+\t\t       int write_back, int unchanging_p, int in_struct_p,\n+\t\t       int scalar_p)\n {\n   int i = 0, j;\n   rtx result;\n@@ -5255,16 +5006,9 @@ arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n }\n \n rtx\n-arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n-\t\t\tin_struct_p, scalar_p)\n-     int base_regno;\n-     int count;\n-     rtx to;\n-     int up;\n-     int write_back;\n-     int unchanging_p;\n-     int in_struct_p;\n-     int scalar_p;\n+arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n+\t\t\tint write_back, int unchanging_p, int in_struct_p,\n+\t\t\tint scalar_p)\n {\n   int i = 0, j;\n   rtx result;\n@@ -5323,8 +5067,7 @@ arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n }\n \n int\n-arm_gen_movstrqi (operands)\n-     rtx * operands;\n+arm_gen_movstrqi (rtx *operands)\n {\n   HOST_WIDE_INT in_words_to_go, out_words_to_go, last_bytes;\n   int i;\n@@ -5507,8 +5250,7 @@ arm_gen_movstrqi (operands)\n    known to be alignable and of the form reg, or plus (reg, const).  */\n \n rtx\n-arm_gen_rotated_half_load (memref)\n-     rtx memref;\n+arm_gen_rotated_half_load (rtx memref)\n {\n   HOST_WIDE_INT offset = 0;\n   rtx base = XEXP (memref, 0);\n@@ -5541,12 +5283,8 @@ arm_gen_rotated_half_load (memref)\n    here.  If we are unable to support a dominance comparison we return \n    CC mode.  This will then fail to match for the RTL expressions that\n    generate this call.  */\n-\n enum machine_mode\n-arm_select_dominance_cc_mode (x, y, cond_or)\n-     rtx x;\n-     rtx y;\n-     HOST_WIDE_INT cond_or;\n+arm_select_dominance_cc_mode (rtx x, rtx y, HOST_WIDE_INT cond_or)\n {\n   enum rtx_code cond1, cond2;\n   int swapped = 0;\n@@ -5658,10 +5396,7 @@ arm_select_dominance_cc_mode (x, y, cond_or)\n }\n \n enum machine_mode\n-arm_select_cc_mode (op, x, y)\n-     enum rtx_code op;\n-     rtx x;\n-     rtx y;\n+arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n {\n   /* All floating point compares return CCFP if it is an equality\n      comparison, and CCFPE otherwise.  */\n@@ -5772,11 +5507,8 @@ arm_select_cc_mode (op, x, y)\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for register 0 in the proper mode.  FP means this is a\n    floating point compare: I don't think that it is needed on the arm.  */\n-\n rtx\n-arm_gen_compare_reg (code, x, y)\n-     enum rtx_code code;\n-     rtx x, y;\n+arm_gen_compare_reg (enum rtx_code code, rtx x, rtx y)\n {\n   enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n   rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n@@ -5790,9 +5522,8 @@ arm_gen_compare_reg (code, x, y)\n /* Generate a sequence of insns that will generate the correct return\n    address mask depending on the physical architecture that the program\n    is running on.  */\n-\n rtx\n-arm_gen_return_addr_mask ()\n+arm_gen_return_addr_mask (void)\n {\n   rtx reg = gen_reg_rtx (Pmode);\n \n@@ -5801,8 +5532,7 @@ arm_gen_return_addr_mask ()\n }\n \n void\n-arm_reload_in_hi (operands)\n-     rtx * operands;\n+arm_reload_in_hi (rtx *operands)\n {\n   rtx ref = operands[1];\n   rtx base, scratch;\n@@ -5919,10 +5649,8 @@ arm_reload_in_hi (operands)\n    scratch in operands[2] overlaps either the input value or output address\n    in some way, then that value must die in this insn (we absolutely need\n    two scratch registers for some corner cases).  */\n-\n void\n-arm_reload_out_hi (operands)\n-     rtx * operands;\n+arm_reload_out_hi (rtx *operands)\n {\n   rtx ref = operands[0];\n   rtx outval = operands[1];\n@@ -6080,11 +5808,8 @@ arm_reload_out_hi (operands)\n }\n \f\n /* Print a symbolic form of X to the debug file, F.  */\n-\n static void\n-arm_print_value (f, x)\n-     FILE * f;\n-     rtx x;\n+arm_print_value (FILE *f, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -6249,10 +5974,8 @@ Mfix *\t\tminipool_barrier;\n \n /* Determines if INSN is the start of a jump table.  Returns the end\n    of the TABLE or NULL_RTX.  */\n-\n static rtx\n-is_jump_table (insn)\n-     rtx insn;\n+is_jump_table (rtx insn)\n {\n   rtx table;\n   \n@@ -6274,8 +5997,7 @@ is_jump_table (insn)\n #endif\n \n static HOST_WIDE_INT\n-get_jump_table_size (insn)\n-     rtx insn;\n+get_jump_table_size (rtx insn)\n {\n   /* ADDR_VECs only take room if read-only data does into the text\n      section.  */\n@@ -6297,12 +6019,9 @@ get_jump_table_size (insn)\n /* Move a minipool fix MP from its current location to before MAX_MP.\n    If MAX_MP is NULL, then MP doesn't need moving, but the addressing\n    contrains may need updating.  */\n-\n static Mnode *\n-move_minipool_fix_forward_ref (mp, max_mp, max_address)\n-     Mnode *       mp;\n-     Mnode *       max_mp;\n-     HOST_WIDE_INT max_address;\n+move_minipool_fix_forward_ref (Mnode *mp, Mnode *max_mp,\n+\t\t\t       HOST_WIDE_INT max_address)\n {\n   /* This should never be true and the code below assumes these are\n      different.  */\n@@ -6357,10 +6076,8 @@ move_minipool_fix_forward_ref (mp, max_mp, max_address)\n \n /* Add a constant to the minipool for a forward reference.  Returns the\n    node added or NULL if the constant will not fit in this pool.  */\n-\n static Mnode *\n-add_minipool_forward_ref (fix)\n-     Mfix * fix;\n+add_minipool_forward_ref (Mfix *fix)\n {\n   /* If set, max_mp is the first pool_entry that has a lower\n      constraint than the one we are trying to add.  */\n@@ -6463,10 +6180,8 @@ add_minipool_forward_ref (fix)\n }\n \n static Mnode *\n-move_minipool_fix_backward_ref (mp, min_mp, min_address)\n-     Mnode *        mp;\n-     Mnode *        min_mp;\n-     HOST_WIDE_INT  min_address;\n+move_minipool_fix_backward_ref (Mnode *mp, Mnode *min_mp,\n+\t\t\t\tHOST_WIDE_INT  min_address)\n {\n   HOST_WIDE_INT offset;\n \n@@ -6526,17 +6241,15 @@ move_minipool_fix_backward_ref (mp, min_mp, min_address)\n    somewhat confusing because the calculated offsets for each fix do\n    not take into account the size of the pool (which is still under\n    construction.  */\n-\n static Mnode *\n-add_minipool_backward_ref (fix)\n-     Mfix * fix;\n+add_minipool_backward_ref (Mfix *fix)\n {\n   /* If set, min_mp is the last pool_entry that has a lower constraint\n      than the one we are trying to add.  */\n-  Mnode *        min_mp = NULL;\n+  Mnode *min_mp = NULL;\n   /* This can be negative, since it is only a constraint.  */\n   HOST_WIDE_INT  min_address = fix->address - fix->backwards;\n-  Mnode *        mp;\n+  Mnode *mp;\n \n   /* If we can't reach the current pool from this insn, or if we can't\n      insert this entry at the end of the pool without pushing other\n@@ -6653,11 +6366,10 @@ add_minipool_backward_ref (fix)\n }\n \n static void\n-assign_minipool_offsets (barrier)\n-     Mfix * barrier;\n+assign_minipool_offsets (Mfix *barrier)\n {\n   HOST_WIDE_INT offset = 0;\n-  Mnode * mp;\n+  Mnode *mp;\n \n   minipool_barrier = barrier;\n \n@@ -6672,11 +6384,10 @@ assign_minipool_offsets (barrier)\n \n /* Output the literal table */\n static void\n-dump_minipool (scan)\n-     rtx scan;\n+dump_minipool (rtx scan)\n {\n-  Mnode * mp;\n-  Mnode * nmp;\n+  Mnode *mp;\n+  Mnode *nmp;\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file,\n@@ -6743,10 +6454,8 @@ dump_minipool (scan)\n }\n \n /* Return the cost of forcibly inserting a barrier after INSN.  */\n-\n static int\n-arm_barrier_cost (insn)\n-     rtx insn;\n+arm_barrier_cost (rtx insn)\n {\n   /* Basing the location of the pool on the loop depth is preferable,\n      but at the moment, the basic block information seems to be\n@@ -6780,11 +6489,8 @@ arm_barrier_cost (insn)\n    (FIX->address,MAX_ADDRESS) to forcibly insert a minipool barrier.\n    Create the barrier by inserting a jump and add a new fix entry for\n    it.  */\n-\n static Mfix *\n-create_fix_barrier (fix, max_address)\n-     Mfix * fix;\n-     HOST_WIDE_INT max_address;\n+create_fix_barrier (Mfix *fix, HOST_WIDE_INT max_address)\n {\n   HOST_WIDE_INT count = 0;\n   rtx barrier;\n@@ -6866,9 +6572,7 @@ create_fix_barrier (fix, max_address)\n /* Record that there is a natural barrier in the insn stream at\n    ADDRESS.  */\n static void\n-push_minipool_barrier (insn, address)\n-     rtx insn;\n-     HOST_WIDE_INT address;\n+push_minipool_barrier (rtx insn, HOST_WIDE_INT address)\n {\n   Mfix * fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (* fix));\n \n@@ -6890,12 +6594,8 @@ push_minipool_barrier (insn, address)\n    fixing; VALUE is the constant that must be loaded, which is of type\n    MODE.  */\n static void\n-push_minipool_fix (insn, address, loc, mode, value)\n-     rtx insn;\n-     HOST_WIDE_INT address;\n-     rtx * loc;\n-     enum machine_mode mode;\n-     rtx value;\n+push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n+\t\t   enum machine_mode mode, rtx value)\n {\n   Mfix * fix = (Mfix *) obstack_alloc (&minipool_obstack, sizeof (* fix));\n \n@@ -6950,12 +6650,8 @@ push_minipool_fix (insn, address, loc, mode, value)\n    needed.  The function returns TRUE is any fixups were needed/pushed.\n    This is used by arm_memory_load_p() which needs to know about loads\n    of constants that will be converted into minipool loads.  */\n-\n static bool\n-note_invalid_constants (insn, address, do_pushes)\n-     rtx insn;\n-     HOST_WIDE_INT address;\n-     int do_pushes;\n+note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n {\n   bool result = false;\n   int opno;\n@@ -7010,9 +6706,8 @@ note_invalid_constants (insn, address, do_pushes)\n    load addresses a limited distance around the pc.  We do some\n    special munging to move the constant pool values to the correct\n    point in the code.  */\n-\n static void\n-arm_reorg ()\n+arm_reorg (void)\n {\n   rtx insn;\n   HOST_WIDE_INT address = 0;\n@@ -7175,10 +6870,8 @@ arm_reorg ()\n /* If the rtx is the correct value then return the string of the number.\n    In this way we can ensure that valid double constants are generated even\n    when cross compiling.  */\n-\n const char *\n-fp_immediate_constant (x)\n-     rtx x;\n+fp_immediate_constant (rtx x)\n {\n   REAL_VALUE_TYPE r;\n   int i;\n@@ -7195,10 +6888,8 @@ fp_immediate_constant (x)\n }\n \n /* As for fp_immediate_constant, but value is passed directly, not in rtx.  */\n-\n static const char *\n-fp_const_from_val (r)\n-     REAL_VALUE_TYPE * r;\n+fp_const_from_val (REAL_VALUE_TYPE *r)\n {\n   int i;\n \n@@ -7216,13 +6907,8 @@ fp_const_from_val (r)\n    MASK is the ARM register set mask of which only bits 0-15 are important.\n    REG is the base register, either the frame pointer or the stack pointer,\n    INSTR is the possibly suffixed load or store instruction.  */\n-\n static void\n-print_multi_reg (stream, instr, reg, mask)\n-     FILE * stream;\n-     const char * instr;\n-     int reg;\n-     int mask;\n+print_multi_reg (FILE *stream, const char *instr, int reg, int mask)\n {\n   int i;\n   int not_first = FALSE;\n@@ -7258,10 +6944,8 @@ print_multi_reg (stream, instr, reg, mask)\n }\n \n /* Output a 'call' insn.  */\n-\n const char *\n-output_call (operands)\n-     rtx * operands;\n+output_call (rtx *operands)\n {\n   /* Handle calls to lr using ip (which may be clobbered in subr anyway).  */\n \n@@ -7282,8 +6966,7 @@ output_call (operands)\n }\n \n static int\n-eliminate_lr2ip (x)\n-     rtx * x;\n+eliminate_lr2ip (rtx *x)\n {\n   int something_changed = 0;\n   rtx x0 = * x;\n@@ -7316,10 +6999,8 @@ eliminate_lr2ip (x)\n }\n   \n /* Output a 'call' insn that is a reference in memory.  */\n-\n const char *\n-output_call_mem (operands)\n-     rtx * operands;\n+output_call_mem (rtx *operands)\n {\n   operands[0] = copy_rtx (operands[0]); /* Be ultra careful.  */\n   /* Handle calls using lr by using ip (which may be clobbered in subr anyway).  */\n@@ -7345,10 +7026,8 @@ output_call_mem (operands)\n /* Output a move from arm registers to an fpa registers.\n    OPERANDS[0] is an fpa register.\n    OPERANDS[1] is the first registers of an arm register pair.  */\n-\n const char *\n-output_mov_long_double_fpa_from_arm (operands)\n-     rtx * operands;\n+output_mov_long_double_fpa_from_arm (rtx *operands)\n {\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[3];\n@@ -7369,10 +7048,8 @@ output_mov_long_double_fpa_from_arm (operands)\n /* Output a move from an fpa register to arm registers.\n    OPERANDS[0] is the first registers of an arm register pair.\n    OPERANDS[1] is an fpa register.  */\n-\n const char *\n-output_mov_long_double_arm_from_fpa (operands)\n-     rtx * operands;\n+output_mov_long_double_arm_from_fpa (rtx *operands)\n {\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[3];\n@@ -7392,10 +7069,8 @@ output_mov_long_double_arm_from_fpa (operands)\n /* Output a move from arm registers to arm registers of a long double\n    OPERANDS[0] is the destination.\n    OPERANDS[1] is the source.  */\n-\n const char *\n-output_mov_long_double_arm_from_arm (operands)\n-     rtx * operands;\n+output_mov_long_double_arm_from_arm (rtx *operands)\n {\n   /* We have to be careful here because the two might overlap.  */\n   int dest_start = REGNO (operands[0]);\n@@ -7429,10 +7104,8 @@ output_mov_long_double_arm_from_arm (operands)\n /* Output a move from arm registers to an fpa registers.\n    OPERANDS[0] is an fpa register.\n    OPERANDS[1] is the first registers of an arm register pair.  */\n-\n const char *\n-output_mov_double_fpa_from_arm (operands)\n-     rtx * operands;\n+output_mov_double_fpa_from_arm (rtx *operands)\n {\n   int arm_reg0 = REGNO (operands[1]);\n   rtx ops[2];\n@@ -7450,10 +7123,8 @@ output_mov_double_fpa_from_arm (operands)\n /* Output a move from an fpa register to arm registers.\n    OPERANDS[0] is the first registers of an arm register pair.\n    OPERANDS[1] is an fpa register.  */\n-\n const char *\n-output_mov_double_arm_from_fpa (operands)\n-     rtx * operands;\n+output_mov_double_arm_from_fpa (rtx *operands)\n {\n   int arm_reg0 = REGNO (operands[0]);\n   rtx ops[2];\n@@ -7471,10 +7142,8 @@ output_mov_double_arm_from_fpa (operands)\n /* Output a move between double words.\n    It must be REG<-REG, REG<-CONST_DOUBLE, REG<-CONST_INT, REG<-MEM\n    or MEM<-REG and all MEMs must be offsettable addresses.  */\n-\n const char *\n-output_move_double (operands)\n-     rtx * operands;\n+output_move_double (rtx *operands)\n {\n   enum rtx_code code0 = GET_CODE (operands[0]);\n   enum rtx_code code1 = GET_CODE (operands[1]);\n@@ -7707,10 +7376,8 @@ output_move_double (operands)\n \n /* Output an arbitrary MOV reg, #n.\n    OPERANDS[0] is a register.  OPERANDS[1] is a const_int.  */\n-\n const char *\n-output_mov_immediate (operands)\n-     rtx * operands;\n+output_mov_immediate (rtx *operands)\n {\n   HOST_WIDE_INT n = INTVAL (operands[1]);\n \n@@ -7745,10 +7412,8 @@ output_mov_immediate (operands)\n \n /* Output an ADD r, s, #n where n may be too big for one instruction.\n    If adding zero to one register, output nothing.  */\n-\n const char *\n-output_add_immediate (operands)\n-     rtx * operands;\n+output_add_immediate (rtx *operands)\n {\n   HOST_WIDE_INT n = INTVAL (operands[2]);\n \n@@ -7773,14 +7438,9 @@ output_add_immediate (operands)\n    INSTR2 is the output pattern to use for subsequent constants.\n    IMMED_OP is the index of the constant slot in OPERANDS.\n    N is the constant value.  */\n-\n static const char *\n-output_multi_immediate (operands, instr1, instr2, immed_op, n)\n-     rtx * operands;\n-     const char * instr1;\n-     const char * instr2;\n-     int immed_op;\n-     HOST_WIDE_INT n;\n+output_multi_immediate (rtx *operands, const char *instr1, const char *instr2,\n+\t\t\tint immed_op, HOST_WIDE_INT n)\n {\n #if HOST_BITS_PER_WIDE_INT > 32\n   n &= 0xffffffff;\n@@ -7817,11 +7477,8 @@ output_multi_immediate (operands, instr1, instr2, immed_op, n)\n    The returned result should not be overwritten.  OP is the rtx of the\n    operation.  SHIFT_FIRST_ARG is TRUE if the first argument of the operator\n    was shifted.  */\n-\n const char *\n-arithmetic_instr (op, shift_first_arg)\n-     rtx op;\n-     int shift_first_arg;\n+arithmetic_instr (rtx op, int shift_first_arg)\n {\n   switch (GET_CODE (op))\n     {\n@@ -7850,11 +7507,8 @@ arithmetic_instr (op, shift_first_arg)\n    OP is the rtx code of the shift.\n    On exit, *AMOUNTP will be -1 if the shift is by a register, or a constant\n    shift.  */\n-\n static const char *\n-shift_op (op, amountp)\n-     rtx op;\n-     HOST_WIDE_INT *amountp;\n+shift_op (rtx op, HOST_WIDE_INT *amountp)\n {\n   const char * mnem;\n   enum rtx_code code = GET_CODE (op);\n@@ -7927,16 +7581,15 @@ shift_op (op, amountp)\n /* Obtain the shift from the POWER of two.  */\n \n static HOST_WIDE_INT\n-int_log2 (power)\n-     HOST_WIDE_INT power;\n+int_log2 (HOST_WIDE_INT power)\n {\n   HOST_WIDE_INT shift = 0;\n \n   while ((((HOST_WIDE_INT) 1 << shift) & power) == 0)\n     {\n       if (shift > 31)\n \tabort ();\n-      shift ++;\n+      shift++;\n     }\n \n   return shift;\n@@ -7947,10 +7600,7 @@ int_log2 (power)\n #define MAX_ASCII_LEN 51\n \n void\n-output_ascii_pseudo_op (stream, p, len)\n-     FILE * stream;\n-     const unsigned char * p;\n-     int len;\n+output_ascii_pseudo_op (FILE *stream, const unsigned char *p, int len)\n {\n   int i;\n   int len_so_far = 0;\n@@ -8027,9 +7677,8 @@ output_ascii_pseudo_op (stream, p, len)\n /* Compute the register sabe mask for registers 0 through 12\n    inclusive.  This code is used by both arm_compute_save_reg_mask\n    and arm_compute_initial_elimination_offset.  */\n-\n static unsigned long\n-arm_compute_save_reg0_reg12_mask ()\n+arm_compute_save_reg0_reg12_mask (void)\n {\n   unsigned long func_type = arm_current_func_type ();\n   unsigned int save_reg_mask = 0;\n@@ -8089,7 +7738,7 @@ arm_compute_save_reg0_reg12_mask ()\n    saved on the stack for the current function.  */\n \n static unsigned long\n-arm_compute_save_reg_mask ()\n+arm_compute_save_reg_mask (void)\n {\n   unsigned int save_reg_mask = 0;\n   unsigned long func_type = arm_current_func_type ();\n@@ -8137,12 +7786,8 @@ arm_compute_save_reg_mask ()\n \n /* Generate a function exit sequence.  If REALLY_RETURN is true, then do\n    everything bar the final return instruction.  */\n-\n const char *\n-output_return_instruction (operand, really_return, reverse)\n-     rtx operand;\n-     int really_return;\n-     int reverse;\n+output_return_instruction (rtx operand, int really_return, int reverse)\n {\n   char conditional[10];\n   char instr[100];\n@@ -8355,11 +8000,8 @@ output_return_instruction (operand, really_return, reverse)\n    a leaf function.  These function types will not contain a stack\n    backtrace structure, therefore it is not possible to determine the\n    function name.  */\n-\n void\n-arm_poke_function_name (stream, name)\n-   FILE * stream;\n-   const char * name;\n+arm_poke_function_name (FILE *stream, const char *name)\n {\n   unsigned long alignlength;\n   unsigned long length;\n@@ -8376,11 +8018,8 @@ arm_poke_function_name (stream, name)\n \n /* Place some comments into the assembler stream\n    describing the current function.  */\n-\n static void\n-arm_output_function_prologue (f, frame_size)\n-     FILE * f;\n-     HOST_WIDE_INT frame_size;\n+arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n {\n   unsigned long func_type;\n \n@@ -8447,8 +8086,7 @@ arm_output_function_prologue (f, frame_size)\n }\n \n const char *\n-arm_output_epilogue (really_return)\n-     int really_return;\n+arm_output_epilogue (int really_return)\n {\n   int reg;\n   unsigned long saved_regs_mask;\n@@ -8726,9 +8364,8 @@ arm_output_epilogue (really_return)\n }\n \n static void\n-arm_output_function_epilogue (file, frame_size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT frame_size;\n+arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\t      HOST_WIDE_INT frame_size)\n {\n   if (TARGET_THUMB)\n     {\n@@ -8757,10 +8394,8 @@ arm_output_function_epilogue (file, frame_size)\n    Unfortunately, since this insn does not reflect very well the actual\n    semantics of the operation, we need to annotate the insn for the benefit\n    of DWARF2 frame unwind information.  */\n-\n static rtx\n-emit_multi_reg_push (mask)\n-     int mask;\n+emit_multi_reg_push (int mask)\n {\n   int num_regs = 0;\n   int num_dwarf_regs;\n@@ -8886,9 +8521,7 @@ emit_multi_reg_push (mask)\n }\n \n static rtx\n-emit_sfm (base_reg, count)\n-     int base_reg;\n-     int count;\n+emit_sfm (int base_reg, int count)\n {\n   rtx par;\n   rtx dwarf;\n@@ -8978,11 +8611,8 @@ emit_sfm (base_reg, count)\n   The sign of the number returned reflects the direction of stack\n   growth, so the values are positive for all eliminations except\n   from the soft frame pointer to the hard frame pointer.  */\n-\t\t\t    \n unsigned int\n-arm_compute_initial_elimination_offset (from, to)\n-     unsigned int from;\n-     unsigned int to;\n+arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n {\n   unsigned int local_vars    = arm_get_frame_size ();\n   unsigned int outgoing_args = current_function_outgoing_args_size;\n@@ -9111,9 +8741,8 @@ arm_compute_initial_elimination_offset (from, to)\n \n /* Calculate the size of the stack frame, taking into account any\n    padding that is required to ensure stack-alignment.  */\n-\n HOST_WIDE_INT\n-arm_get_frame_size ()\n+arm_get_frame_size (void)\n {\n   int regno;\n \n@@ -9183,9 +8812,8 @@ arm_get_frame_size ()\n }\n \n /* Generate the prologue instructions for entry into an ARM function.  */\n-\n void\n-arm_expand_prologue ()\n+arm_expand_prologue (void)\n {\n   int reg;\n   rtx amount;\n@@ -9473,12 +9101,8 @@ arm_expand_prologue ()\n    before output.\n    If CODE is 'B' then output a bitwise inverted value of X (a const int).\n    If X is a REG and CODE is `M', output a ldm/stm style multi-reg.  */\n-\n void\n-arm_print_operand (stream, x, code)\n-     FILE * stream;\n-     rtx x;\n-     int code;\n+arm_print_operand (FILE *stream, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -9717,12 +9341,8 @@ arm_print_operand (stream, x, code)\n #ifndef AOF_ASSEMBLER\n /* Target hook for assembling integer objects.  The ARM version needs to\n    handle word-sized values specially.  */\n-\n static bool\n-arm_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if (size == UNITS_PER_WORD && aligned_p)\n     {\n@@ -9785,10 +9405,8 @@ arm_assemble_integer (x, size, aligned_p)\n /* Returns the index of the ARM condition code string in\n    `arm_condition_codes'.  COMPARISON should be an rtx like\n    `(eq (...) (...))'.  */\n-\n static enum arm_cond_code\n-get_arm_condition_code (comparison)\n-     rtx comparison;\n+get_arm_condition_code (rtx comparison)\n {\n   enum machine_mode mode = GET_MODE (XEXP (comparison, 0));\n   int code;\n@@ -9908,10 +9526,8 @@ get_arm_condition_code (comparison)\n   abort ();\n }\n \n-\n void\n-arm_final_prescan_insn (insn)\n-     rtx insn;\n+arm_final_prescan_insn (rtx insn)\n {\n   /* BODY will hold the body of INSN.  */\n   rtx body = PATTERN (insn);\n@@ -10131,7 +9747,8 @@ arm_final_prescan_insn (insn)\n       \t      /* If this is an unconditional branch to the same label, succeed.\n \t\t If it is to another label, do nothing.  If it is conditional,\n \t\t fail.  */\n-\t      /* XXX Probably, the tests for SET and the PC are unnecessary.  */\n+\t      /* XXX Probably, the tests for SET and the PC are\n+\t\t unnecessary.  */\n \n \t      scanbody = PATTERN (this_insn);\n \t      if (GET_CODE (scanbody) == SET\n@@ -10260,11 +9877,8 @@ arm_final_prescan_insn (insn)\n \n /* Returns true if REGNO is a valid register\n    for holding a quantity of tyoe MODE.  */\n-\n int\n-arm_hard_regno_mode_ok (regno, mode)\n-     unsigned int regno;\n-     enum machine_mode mode;\n+arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n     return regno == CC_REGNUM;\n@@ -10302,8 +9916,7 @@ arm_hard_regno_mode_ok (regno, mode)\n }\n \n int\n-arm_regno_class (regno)\n-     int regno;\n+arm_regno_class (int regno)\n {\n   if (TARGET_THUMB)\n     {\n@@ -10332,11 +9945,8 @@ arm_regno_class (regno)\n \n /* Handle a special case when computing the offset\n    of an argument from the frame pointer.  */\n-\n int\n-arm_debugger_arg_offset (value, addr)\n-     int value;\n-     rtx addr;\n+arm_debugger_arg_offset (int value, rtx addr)\n {\n   rtx insn;\n \n@@ -10420,12 +10030,8 @@ arm_debugger_arg_offset (value, addr)\n    checking to see if any of the variables created in that\n    function match the RTX called 'orig'.  If they do then\n    replace them with the RTX called 'new'.  */\n-\n static void\n-replace_symbols_in_block (block, orig, new)\n-     tree block;\n-     rtx orig;\n-     rtx new;\n+replace_symbols_in_block (tree block, rtx orig, rtx new)\n {\n   for (; block; block = BLOCK_CHAIN (block))\n     {\n@@ -10454,12 +10060,8 @@ replace_symbols_in_block (block, orig, new)\n /* Return the number (counting from 0) of\n    the least significant set bit in MASK.  */\n \n-#ifdef __GNUC__\n-inline\n-#endif\n-static int\n-number_of_first_bit_set (mask)\n-     int mask;\n+inline static int\n+number_of_first_bit_set (int mask)\n {\n   int bit;\n \n@@ -10475,10 +10077,7 @@ number_of_first_bit_set (mask)\n    If 'reg_containing_return_addr' is -1, then the return address is\n    actually on the stack, at the stack pointer.  */\n static void\n-thumb_exit (f, reg_containing_return_addr, eh_ofs)\n-     FILE * f;\n-     int    reg_containing_return_addr;\n-     rtx    eh_ofs;\n+thumb_exit (FILE *f, int reg_containing_return_addr, rtx eh_ofs)\n {\n   unsigned regs_available_for_popping;\n   unsigned regs_to_pop;\n@@ -10765,12 +10364,8 @@ thumb_exit (f, reg_containing_return_addr, eh_ofs)\n }\n \n /* Emit code to push or pop registers to or from the stack.  */\n-\n static void\n-thumb_pushpop (f, mask, push)\n-     FILE * f;\n-     int mask;\n-     int push;\n+thumb_pushpop (FILE *f, int mask, int push)\n {\n   int regno;\n   int lo_mask = mask & 0xFF;\n@@ -10831,17 +10426,15 @@ thumb_pushpop (f, mask, push)\n }\n \f\n void\n-thumb_final_prescan_insn (insn)\n-     rtx insn;\n+thumb_final_prescan_insn (rtx insn)\n {\n   if (flag_print_asm_name)\n     asm_fprintf (asm_out_file, \"%@ 0x%04x\\n\",\n \t\t INSN_ADDRESSES (INSN_UID (insn)));\n }\n \n int\n-thumb_shiftable_const (val)\n-     unsigned HOST_WIDE_INT val;\n+thumb_shiftable_const (unsigned HOST_WIDE_INT val)\n {\n   unsigned HOST_WIDE_INT mask = 0xff;\n   int i;\n@@ -10858,10 +10451,8 @@ thumb_shiftable_const (val)\n \n /* Returns nonzero if the current function contains,\n    or might contain a far jump.  */\n-\n int\n-thumb_far_jump_used_p (in_prologue)\n-     int in_prologue;\n+thumb_far_jump_used_p (int in_prologue)\n {\n   rtx insn;\n \n@@ -10927,10 +10518,8 @@ thumb_far_jump_used_p (in_prologue)\n }\n \n /* Return nonzero if FUNC must be entered in ARM mode.  */\n-\n int\n-is_called_in_ARM_mode (func)\n-     tree func;\n+is_called_in_ARM_mode (tree func)\n {\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     abort ();\n@@ -10947,9 +10536,8 @@ is_called_in_ARM_mode (func)\n }\n \n /* The bits which aren't usefully expanded as rtl. */\n-\n const char *\n-thumb_unexpanded_epilogue ()\n+thumb_unexpanded_epilogue (void)\n {\n   int regno;\n   int live_regs_mask = 0;\n@@ -11117,9 +10705,8 @@ thumb_unexpanded_epilogue ()\n }\n \n /* Functions to save and restore machine-specific function data.  */\n-\n static struct machine_function *\n-arm_init_machine_status ()\n+arm_init_machine_status (void)\n {\n   struct machine_function *machine;\n   machine = (machine_function *) ggc_alloc_cleared (sizeof (machine_function));\n@@ -11132,11 +10719,8 @@ arm_init_machine_status ()\n \n /* Return an RTX indicating where the return address to the\n    calling function can be found.  */\n-\n rtx\n-arm_return_addr (count, frame)\n-     int count;\n-     rtx frame ATTRIBUTE_UNUSED;\n+arm_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n   if (count != 0)\n     return NULL_RTX;\n@@ -11152,16 +10736,15 @@ arm_return_addr (count, frame)\n }\n \n /* Do anything needed before RTL is emitted for each function.  */\n-\n void\n-arm_init_expanders ()\n+arm_init_expanders (void)\n {\n   /* Arrange to initialize and mark the machine per-function status.  */\n   init_machine_status = arm_init_machine_status;\n }\n \n HOST_WIDE_INT\n-thumb_get_frame_size ()\n+thumb_get_frame_size (void)\n {\n   int regno;\n \n@@ -11247,9 +10830,8 @@ thumb_get_frame_size ()\n }\n \n /* Generate the rest of a function's prologue.  */\n-\n void\n-thumb_expand_prologue ()\n+thumb_expand_prologue (void)\n {\n   HOST_WIDE_INT amount = (thumb_get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n@@ -11344,7 +10926,7 @@ thumb_expand_prologue ()\n }\n \n void\n-thumb_expand_epilogue ()\n+thumb_expand_epilogue (void)\n {\n   HOST_WIDE_INT amount = (thumb_get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n@@ -11381,9 +10963,7 @@ thumb_expand_epilogue ()\n }\n \n static void\n-thumb_output_function_prologue (f, size)\n-     FILE * f;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   int live_regs_mask = 0;\n   int high_regs_pushed = 0;\n@@ -11613,10 +11193,8 @@ thumb_output_function_prologue (f, size)\n /* Handle the case of a double word load into a low register from\n    a computed memory address.  The computed address may involve a\n    register which is overwritten by the load.  */\n-\n const char *\n-thumb_load_double_from_address (operands)\n-     rtx *operands;\n+thumb_load_double_from_address (rtx *operands)\n {\n   rtx addr;\n   rtx base;\n@@ -11735,11 +11313,8 @@ thumb_load_double_from_address (operands)\n   return \"\";\n }\n \n-\n const char *\n-thumb_output_move_mem_multiple (n, operands)\n-     int n;\n-     rtx * operands;\n+thumb_output_move_mem_multiple (int n, rtx *operands)\n {\n   rtx tmp;\n \n@@ -11788,10 +11363,8 @@ thumb_output_move_mem_multiple (n, operands)\n }\n \n /* Routines for generating rtl.  */\n-\n void\n-thumb_expand_movstrqi (operands)\n-     rtx * operands;\n+thumb_expand_movstrqi (rtx *operands)\n {\n   rtx out = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n   rtx in  = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n@@ -11841,19 +11414,15 @@ thumb_expand_movstrqi (operands)\n }\n \n int\n-thumb_cmp_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+thumb_cmp_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT\n \t   && (unsigned HOST_WIDE_INT) (INTVAL (op)) < 256)\n \t  || register_operand (op, mode));\n }\n \n static const char *\n-thumb_condition_code (x, invert)\n-     rtx x;\n-     int invert;\n+thumb_condition_code (rtx x, int invert)\n {\n   static const char * const conds[] =\n   {\n@@ -11882,29 +11451,23 @@ thumb_condition_code (x, invert)\n }\n \n /* Handle storing a half-word to memory during reload.  */ \n-\n void\n-thumb_reload_out_hi (operands)\n-     rtx * operands;\n+thumb_reload_out_hi (rtx *operands)\n {\n   emit_insn (gen_thumb_movhi_clobber (operands[0], operands[1], operands[2]));\n }\n \n-/* Handle storing a half-word to memory during reload.  */ \n-\n+/* Handle reading a half-word from memory during reload.  */ \n void\n-thumb_reload_in_hi (operands)\n-     rtx * operands ATTRIBUTE_UNUSED;\n+thumb_reload_in_hi (rtx *operands ATTRIBUTE_UNUSED)\n {\n   abort ();\n }\n \n /* Return the length of a function name prefix\n     that starts with the character 'c'.  */\n-\n static int\n-arm_get_strip_length (c)\n-     int c;\n+arm_get_strip_length (int c)\n {\n   switch (c)\n     {\n@@ -11915,10 +11478,8 @@ arm_get_strip_length (c)\n \n /* Return a pointer to a function's name with any\n    and all prefix encodings stripped from it.  */\n-\n const char *\n-arm_strip_name_encoding (name)\n-     const char * name;\n+arm_strip_name_encoding (const char *name)\n {\n   int skip;\n   \n@@ -11931,11 +11492,8 @@ arm_strip_name_encoding (name)\n /* If there is a '*' anywhere in the name's prefix, then\n    emit the stripped name verbatim, otherwise prepend an\n    underscore if leading underscores are being used.  */\n-\n void\n-arm_asm_output_labelref (stream, name)\n-     FILE * stream;\n-     const char * name;\n+arm_asm_output_labelref (FILE *stream, const char *name)\n {\n   int skip;\n   int verbatim = 0;\n@@ -11966,8 +11524,7 @@ struct pic_chain\n static struct pic_chain * aof_pic_chain = NULL;\n \n rtx\n-aof_pic_entry (x)\n-     rtx x;\n+aof_pic_entry (rtx x)\n {\n   struct pic_chain ** chainp;\n   int offset;\n@@ -11989,8 +11546,7 @@ aof_pic_entry (x)\n }\n \n void\n-aof_dump_pic_table (f)\n-     FILE * f;\n+aof_dump_pic_table (FILE *f)\n {\n   struct pic_chain * chain;\n \n@@ -12013,7 +11569,7 @@ aof_dump_pic_table (f)\n int arm_text_section_count = 1;\n \n char *\n-aof_text_section ()\n+aof_text_section (void )\n {\n   static char buf[100];\n   sprintf (buf, \"\\tAREA |C$$code%d|, CODE, READONLY\",\n@@ -12026,7 +11582,7 @@ aof_text_section ()\n static int arm_data_section_count = 1;\n \n char *\n-aof_data_section ()\n+aof_data_section (void)\n {\n   static char buf[100];\n   sprintf (buf, \"\\tAREA |C$$data%d|, DATA\", arm_data_section_count++);\n@@ -12052,8 +11608,7 @@ struct import\n static struct import * imports_list = NULL;\n \n void\n-aof_add_import (name)\n-     const char * name;\n+aof_add_import (const char *name)\n {\n   struct import * new;\n \n@@ -12068,8 +11623,7 @@ aof_add_import (name)\n }\n \n void\n-aof_delete_import (name)\n-     const char * name;\n+aof_delete_import (const char *name)\n {\n   struct import ** old;\n \n@@ -12086,8 +11640,7 @@ aof_delete_import (name)\n int arm_main_function = 0;\n \n static void\n-aof_dump_imports (f)\n-     FILE * f;\n+aof_dump_imports (FILE *f)\n {\n   /* The AOF assembler needs this to cause the startup code to be extracted\n      from the library.  Brining in __main causes the whole thing to work\n@@ -12110,17 +11663,15 @@ aof_dump_imports (f)\n }\n \n static void\n-aof_globalize_label (stream, name)\n-     FILE *stream;\n-     const char *name;\n+aof_globalize_label (FILE *stream, const char *name)\n {\n   default_globalize_label (stream, name);\n   if (! strcmp (name, \"main\"))\n     arm_main_function = 1;\n }\n \n static void\n-aof_file_end ()\n+aof_file_end (void)\n {\n   if (flag_pic)\n     aof_dump_pic_table (asm_out_file);\n@@ -12138,9 +11689,7 @@ aof_file_end ()\n    used before the section type.  */\n \n static void\n-arm_elf_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+arm_elf_asm_named_section (const char *name, unsigned int flags)\n {\n   char flagchars[10], *f = flagchars;\n \n@@ -12195,10 +11744,7 @@ arm_elf_asm_named_section (name, flags)\n    simplification.  */\n \n static void\n-arm_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+arm_encode_section_info (tree decl, rtx rtl, int first)\n {\n   /* This doesn't work with AOF syntax, since the string table may be in\n      a different AREA.  */\n@@ -12222,10 +11768,7 @@ arm_encode_section_info (decl, rtl, first)\n #endif /* !ARM_PE */\n \n static void\n-arm_internal_label (stream, prefix, labelno)\n-     FILE *stream;\n-     const char *prefix;\n-     unsigned long labelno;\n+arm_internal_label (FILE *stream, const char *prefix, unsigned long labelno)\n {\n   if (arm_ccfsm_state == 3 && (unsigned) arm_target_label == labelno\n       && !strcmp (prefix, \"L\"))\n@@ -12238,14 +11781,11 @@ arm_internal_label (stream, prefix, labelno)\n \n /* Output code to add DELTA to the first argument, and then jump\n    to FUNCTION.  Used for C++ multiple inheritance.  */\n-\n static void\n-arm_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree function;\n+arm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n+\t\t     HOST_WIDE_INT delta,\n+\t\t     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t     tree function)\n {\n   int mi_delta = delta;\n   const char *const mi_op = mi_delta < 0 ? \"sub\" : \"add\";"}]}