{"sha": "29d64660c735aa0c52a29452342b631a09c1266e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkNjQ2NjBjNzM1YWEwYzUyYTI5NDUyMzQyYjYzMWEwOWMxMjY2ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-05-30T22:20:07Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-05-30T22:20:07Z"}, "message": "c-tree.texi (Expressions): Document FLOOR_DIV_EXPR...\n\n\n\t* doc/c-tree.texi (Expressions): Document FLOOR_DIV_EXPR,\n\tCEIL_DIV_EXPR, ROUND_DIV_EXPR, FLOOR_MOD_EXPR, CEIL_MOD_EXPR,\n\tROUND_MOD_EXPR, EXACT_DIV_EXPR.  Improve documentation of\n\tTRUNC_DIV_EXPR, TRUNC_MOD_EXPR and comparison operations.\n\tAdd missing (but documented) tree nodes to the index.\n\nFrom-SVN: r82467", "tree": {"sha": "2455792f315c0c7ba5aad605ee6013b888dce76e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2455792f315c0c7ba5aad605ee6013b888dce76e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29d64660c735aa0c52a29452342b631a09c1266e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d64660c735aa0c52a29452342b631a09c1266e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29d64660c735aa0c52a29452342b631a09c1266e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29d64660c735aa0c52a29452342b631a09c1266e/comments", "author": null, "committer": null, "parents": [{"sha": "96b8a6154eee8298916907259e1543677c8910a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96b8a6154eee8298916907259e1543677c8910a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96b8a6154eee8298916907259e1543677c8910a5"}], "stats": {"total": 143, "additions": 97, "deletions": 46}, "files": [{"sha": "7ea891993b3610f3a5bbec53c5420294f46d87a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d64660c735aa0c52a29452342b631a09c1266e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d64660c735aa0c52a29452342b631a09c1266e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29d64660c735aa0c52a29452342b631a09c1266e", "patch": "@@ -1,3 +1,11 @@\n+2004-05-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* doc/c-tree.texi (Expressions): Document FLOOR_DIV_EXPR,\n+\tCEIL_DIV_EXPR, ROUND_DIV_EXPR, FLOOR_MOD_EXPR, CEIL_MOD_EXPR,\n+\tROUND_MOD_EXPR, EXACT_DIV_EXPR.  Improve documentation of\n+\tTRUNC_DIV_EXPR, TRUNC_MOD_EXPR and comparison operations.\n+\tAdd missing (but documented) tree nodes to the index.\n+\n 2004-05-30  Steven Bosscher  <stevenb@suse.de>\n \n \tPR tree-optimization/14819"}, {"sha": "60eba063922e5e5eea1759bc928c92b90de825d5", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 89, "deletions": 46, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29d64660c735aa0c52a29452342b631a09c1266e/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29d64660c735aa0c52a29452342b631a09c1266e/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=29d64660c735aa0c52a29452342b631a09c1266e", "patch": "@@ -1692,6 +1692,7 @@ This macro returns the attributes on the type @var{type}.\n @node Expression trees\n @section Expressions\n @cindex expression\n+@findex TREE_TYPE\n @findex TREE_OPERAND\n @tindex INTEGER_CST\n @findex TREE_INT_CST_HIGH\n@@ -1712,6 +1713,10 @@ This macro returns the attributes on the type @var{type}.\n @tindex ABS_EXPR\n @tindex BIT_NOT_EXPR\n @tindex TRUTH_NOT_EXPR\n+@tindex PREDECREMENT_EXPR\n+@tindex PREINCREMENT_EXPR\n+@tindex POSTDECREMENT_EXPR\n+@tindex POSTINCREMENT_EXPR\n @tindex ADDR_EXPR\n @tindex INDIRECT_REF\n @tindex FIX_TRUNC_EXPR\n@@ -1720,6 +1725,7 @@ This macro returns the attributes on the type @var{type}.\n @tindex CONJ_EXPR\n @tindex REALPART_EXPR\n @tindex IMAGPART_EXPR\n+@tindex NON_LVALUE_EXPR\n @tindex NOP_EXPR\n @tindex CONVERT_EXPR\n @tindex THROW_EXPR\n@@ -1736,35 +1742,48 @@ This macro returns the attributes on the type @var{type}.\n @tindex PLUS_EXPR\n @tindex MINUS_EXPR\n @tindex MULT_EXPR\n+@tindex RDIV_EXPR\n @tindex TRUNC_DIV_EXPR\n+@tindex FLOOR_DIV_EXPR\n+@tindex CEIL_DIV_EXPR\n+@tindex ROUND_DIV_EXPR\n @tindex TRUNC_MOD_EXPR\n-@tindex RDIV_EXPR\n+@tindex FLOOR_MOD_EXPR\n+@tindex CEIL_MOD_EXPR\n+@tindex ROUND_MOD_EXPR\n+@tindex EXACT_DIV_EXPR\n+@tindex ARRAY_REF\n+@tindex ARRAY_RANGE_REF\n @tindex LT_EXPR\n @tindex LE_EXPR\n @tindex GT_EXPR\n @tindex GE_EXPR\n @tindex EQ_EXPR\n @tindex NE_EXPR\n+@tindex ORDERED_EXPR\n+@tindex UNORDERED_EXPR\n @tindex UNLT_EXPR\n @tindex UNLE_EXPR\n @tindex UNGT_EXPR\n @tindex UNGE_EXPR\n @tindex UNEQ_EXPR\n @tindex LTGT_EXPR\n-@tindex INIT_EXPR\n @tindex MODIFY_EXPR\n+@tindex INIT_EXPR\n @tindex COMPONENT_REF\n @tindex COMPOUND_EXPR\n @tindex COND_EXPR\n @tindex CALL_EXPR\n-@tindex CONSTRUCTOR\n-@tindex COMPOUND_LITERAL_EXPR\n @tindex STMT_EXPR\n @tindex BIND_EXPR\n @tindex LOOP_EXPR\n @tindex EXIT_EXPR\n @tindex CLEANUP_POINT_EXPR\n-@tindex ARRAY_REF\n+@tindex CONSTRUCTOR\n+@tindex COMPOUND_LITERAL_EXPR\n+@tindex SAVE_EXPR\n+@tindex TARGET_EXPR\n+@tindex AGGR_INIT_EXPR\n @tindex VTABLE_REF\n @tindex VA_ARG_EXPR\n \n@@ -2063,25 +2082,50 @@ not matter.\n @itemx PLUS_EXPR\n @itemx MINUS_EXPR\n @itemx MULT_EXPR\n-@itemx TRUNC_DIV_EXPR\n-@itemx TRUNC_MOD_EXPR\n-@itemx RDIV_EXPR\n These nodes represent various binary arithmetic operations.\n Respectively, these operations are addition, subtraction (of the second\n-operand from the first), multiplication, integer division, integer\n-remainder, and floating-point division.  The operands to the first three\n-of these may have either integral or floating type, but there will never\n-be case in which one operand is of floating type and the other is of\n-integral type.\n-\n-The result of a @code{TRUNC_DIV_EXPR} is always rounded towards zero.\n-The @code{TRUNC_MOD_EXPR} of two operands @code{a} and @code{b} is\n-always @code{a - (a/b)*b} where the division is as if computed by a\n-@code{TRUNC_DIV_EXPR}.\n+operand from the first) and multiplication.  Their operands may have\n+either integral or floating type, but there will never be case in which\n+one operand is of floating type and the other is of integral type.\n \n The behavior of these operations on signed arithmetic overflow is\n controlled by the @code{flag_wrapv} and @code{flag_trapv} variables.\n \n+@item RDIV_EXPR\n+This node represents a floating point division operation.\n+\n+@item TRUNC_DIV_EXPR\n+@itemx FLOOR_DIV_EXPR\n+@itemx CEIL_DIV_EXPR\n+@itemx ROUND_DIV_EXPR\n+These nodes represent integer division operations that return an integer\n+result.  @code{TRUNC_DIV_EXPR} rounds towards zero, @code{FLOOR_DIV_EXPR}\n+rounds towards negative infinity, @code{CEIL_DIV_EXPR} rounds towards\n+positive infinity and @code{ROUND_DIV_EXPR} rounds to the closest integer.\n+Integer division in C and C++ is truncating, i.e@. @code{TRUNC_DIV_EXPR}.\n+\n+The behavior of these operations on signed arithmetic overflow, when\n+dividing the minimum signed integer by minus one, is controlled by the\n+@code{flag_wrapv} and @code{flag_trapv} variables.\n+\n+@item TRUNC_MOD_EXPR\n+@itemx FLOOR_MOD_EXPR\n+@itemx CEIL_MOD_EXPR\n+@itemx ROUND_MOD_EXPR\n+These nodes represent the integer remainder or modulus operation.\n+The integer modulus of two operands @code{a} and @code{b} is\n+defined as @code{a - (a/b)*b} where the division calculated using\n+the corresponding division operator.  Hence for @code{TRUNC_MOD_EXPR}\n+this definition assumes division using truncation towards zero, i.e@.\n+@code{TRUNC_DIV_EXPR}.  Integer remainder in C and C++ uses truncating\n+division, i.e@. @code{TRUNC_MOD_EXPR}.\n+\n+@item EXACT_DIV_EXPR\n+The @code{EXACT_DIV_EXPR} code is used to represent integer divisions where\n+the numerator is known to be an exact multiple of the denominator.  This\n+allows the backend to choose between the faster of @code{TRUNC_DIV_EXPR},\n+@code{CEIL_DIV_EXPR} and @code{FLOOR_DIV_EXPR} for the current target.\n+\n @item ARRAY_REF\n These nodes represent array accesses.  The first operand is the array;\n the second is the index.  To calculate the address of the memory\n@@ -2096,54 +2140,53 @@ meanings.  The type of these expressions must be an array whose component\n type is the same as that of the first operand.  The range of that array\n type determines the amount of data these expressions access.\n \n-@item EXACT_DIV_EXPR\n-Document.\n-\n @item LT_EXPR\n @itemx LE_EXPR\n @itemx GT_EXPR\n @itemx GE_EXPR\n @itemx EQ_EXPR\n @itemx NE_EXPR\n-\n These nodes represent the less than, less than or equal to, greater\n than, greater than or equal to, equal, and not equal comparison\n operators.  The first and second operand with either be both of integral\n type or both of floating type.  The result type of these expressions\n-will always be of integral or boolean type.\n+will always be of integral or boolean type.  These operations return\n+the result type's zero value for false, and the result type's one value\n+for true.\n \n-Floating-point comparison may have a fourth possible outcome for a\n-comparison, other than less, greater or equal: this is @dfn{unordered},\n-and two floating-point values are unordered if one of them is\n-a @dfn{not-a-number} (@dfn{NaN}) value.  In this case, all of these\n-nodes will be false but @code{NE_EXPR}, and the first four of these\n-nodes will also raise an invalid operation trap.\n+For floating point comparisons, if we honor IEEE NaNs and either operand\n+is NaN, then @code{NE_EXPR} always returns true and the remaining operators\n+always return false.  On some targets, comparisons against an IEEE NaN,\n+other than equality and inequality, may generate a floating point exception.\n \n @item ORDERED_EXPR\n @itemx UNORDERED_EXPR\n+These nodes represent non-trapping ordered and unordered comparison\n+operators.  These operations take two floating point operands and\n+determine whether they are ordered or unordered relative to each other.\n+If either operand is an IEEE NaN, their comparison is defined to be\n+unordered, otherwise the comparison is defined to be ordered.  The\n+result type of these expressions will always be of integral or boolean\n+type.  These operations return the result type's zero value for false,\n+and the result type's one value for true.\n+\n @item UNLT_EXPR\n @itemx UNLE_EXPR\n @itemx UNGT_EXPR\n @itemx UNGE_EXPR\n @itemx UNEQ_EXPR\n @itemx LTGT_EXPR\n-\n-These nodes represent other relational operations that are only used\n-with floating types.\n-\n-If the outcome of the comparison is unordered, all of these special\n-comparisons will be true but @code{ORDERED_EXPR} and @code{LTGT_EXPR}.\n-Only @code{LTGT_EXPR} is expected to generate an invalid floating-point\n-operation trap when the outcome is unordered.\n-\n-@code{ORDERED_EXPR} is true if neither of its operands is a NaN,\n-while its negation @code{UNORDERED_EXPR} is true if at least one of\n-its operands is a NaN.\n-\n-For floating operations, inverting one of the standard comparison nodes \n-will result in one of these nodes, with its name prefixed by\n-@code{UN}---the only exception is @code{NE_EXPR}, whose negation is\n-@code{LTGT_EXPR}.\n+These nodes represent the unordered comparison operators.\n+These operations take two floating point operands and determine whether\n+the operands are unordered or are less than, less than or equal to,\n+greater than, greater than or equal to, or equal respectively.  For\n+example, @code{UNLT_EXPR} returns true if either operand is an IEEE\n+NaN or the first operand is less than the second.  With the possible\n+exception of @code{LTGT_EXPR}, all of these operations are guaranteed\n+not to generate a floating point exception.  The result\n+type of these expressions will always be of integral or boolean type.\n+These operations return the result type's zero value for false,\n+and the result type's one value for true.\n \n @item MODIFY_EXPR\n These nodes represent assignment.  The left-hand side is the first"}]}