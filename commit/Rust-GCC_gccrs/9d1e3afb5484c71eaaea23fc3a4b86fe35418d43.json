{"sha": "9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQxZTNhZmI1NDg0YzcxZWFhZWEyM2ZjM2E0Yjg2ZmUzNTQxOGQ0Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2016-11-22T17:58:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-22T17:58:04Z"}, "message": "runtime: rewrite panic/defer code from C to Go\n    \n    The actual stack unwind code is still in C, but the rest of the code,\n    notably all the memory allocation, is now in Go.  The names are changed\n    to the names used in the Go 1.7 runtime, but the code is necessarily\n    somewhat different.\n    \n    The __go_makefunc_can_recover function is dropped, as the uses of it\n    were removed in https://golang.org/cl/198770044.\n    \n    Reviewed-on: https://go-review.googlesource.com/33414\n\nFrom-SVN: r242715", "tree": {"sha": "2110ef75ee2708c685482ea2ace4dfbf1461d4aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2110ef75ee2708c685482ea2ace4dfbf1461d4aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/comments", "author": null, "committer": null, "parents": [{"sha": "6c7509bc070b29293ca9874518b89227ce05361c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7509bc070b29293ca9874518b89227ce05361c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7509bc070b29293ca9874518b89227ce05361c"}], "stats": {"total": 1998, "additions": 941, "deletions": 1057}, "files": [{"sha": "825e4f06e4ed4454622f21ffb5d83b98518475c4", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -1,3 +1,8 @@\n+2016-11-22  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::Gcc_backend): Add builtin function\n+\t__builtin_frame_address.\n+\n 2016-10-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* go-lang.c (go_langhook_type_for_mode): Remove redundant cast"}, {"sha": "619499ec573aa1777e51017c230ddb807f7fbeb1", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -828,6 +828,15 @@ Gcc_backend::Gcc_backend()\n   this->define_builtin(BUILT_IN_FRAME_ADDRESS, \"__builtin_frame_address\",\n \t\t       NULL, t, false, false);\n \n+  // The runtime calls __builtin_extract_return_addr when recording\n+  // the address to which a function returns.\n+  this->define_builtin(BUILT_IN_EXTRACT_RETURN_ADDR,\n+\t\t       \"__builtin_extract_return_addr\", NULL,\n+\t\t       build_function_type_list(ptr_type_node,\n+\t\t\t\t\t\tptr_type_node,\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t       false, false);\n+\n   // The compiler uses __builtin_trap for some exception handling\n   // cases.\n   this->define_builtin(BUILT_IN_TRAP, \"__builtin_trap\", NULL,"}, {"sha": "212b9e9c7f575aed33a56471e1625a7e143b555d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -1,4 +1,4 @@\n-bf4762823c4543229867436399be3ae30b4d13bb\n+7593cc83a03999331c5e2dc65a9306c5fe57dfd0\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "dacfe486e5d214fb9f915cde5f94c88908f0a001", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -707,7 +707,7 @@ class Backend\n   // Create a statement that runs all deferred calls for FUNCTION.  This should\n   // be a statement that looks like this in C++:\n   //   finish:\n-  //     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n+  //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n   virtual Bstatement*\n   function_defer_statement(Bfunction* function, Bexpression* undefer,\n                            Bexpression* check_defer, Location) = 0;"}, {"sha": "6429a9a73d546c8259ef12d46fb6b12a8eb067e7", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -280,7 +280,7 @@ Node::op_format() const\n \t    {\n \t      switch (e->func_expression()->runtime_code())\n \t\t{\n-\t\tcase Runtime::PANIC:\n+\t\tcase Runtime::GOPANIC:\n \t\t  op << \"panic\";\n \t\t  break;\n \n@@ -300,11 +300,11 @@ Node::op_format() const\n \t\t  op << \"make\";\n \t\t  break;\n \n-\t\tcase Runtime::DEFER:\n+\t\tcase Runtime::DEFERPROC:\n \t\t  op << \"defer\";\n \t\t  break;\n \n-\t\tcase Runtime::RECOVER:\n+\t\tcase Runtime::GORECOVER:\n \t\t  op << \"recover\";\n \t\t  break;\n \n@@ -1189,7 +1189,7 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t  {\n \t    switch (fe->runtime_code())\n \t      {\n-\t      case Runtime::PANIC:\n+\t      case Runtime::GOPANIC:\n \t\t{\n \t\t  // Argument could leak through recover.\n \t\t  Node* panic_arg = Node::make_node(call->args()->front());"}, {"sha": "35c3e744dd207e1cd5f2b2cb2d65a3d38716a122", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -8951,7 +8951,7 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n         arg = Expression::convert_for_assignment(gogo, empty, arg, location);\n \n         Expression* panic =\n-            Runtime::make_call(Runtime::PANIC, location, 1, arg);\n+            Runtime::make_call(Runtime::GOPANIC, location, 1, arg);\n         return panic->get_backend(context);\n       }\n \n@@ -8972,8 +8972,8 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \t// because it changes whether it can recover a panic or not.\n \t// See test7 in test/recover1.go.\n         Expression* recover = Runtime::make_call((this->is_deferred()\n-                                                  ? Runtime::DEFERRED_RECOVER\n-                                                  : Runtime::RECOVER),\n+                                                  ? Runtime::DEFERREDRECOVER\n+                                                  : Runtime::GORECOVER),\n                                                  location, 0);\n         Expression* cond =\n             Expression::make_conditional(arg, recover, nil, location);"}, {"sha": "a9dd0a6f168597a094a179b35269aab3ac670669", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -4168,8 +4168,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n \n // Return the expression to pass for the .can_recover parameter to the\n // new function.  This indicates whether a call to recover may return\n-// non-nil.  The expression is\n-// __go_can_recover(__builtin_return_address()).\n+// non-nil.  The expression is runtime.canrecover(__builtin_return_address()).\n \n Expression*\n Build_recover_thunks::can_recover_arg(Location location)\n@@ -4191,10 +4190,10 @@ Build_recover_thunks::can_recover_arg(Location location)\n       results->push_back(Typed_identifier(\"\", boolean_type, bloc));\n       Function_type* fntype = Type::make_function_type(NULL, param_types,\n \t\t\t\t\t\t       results, bloc);\n-      can_recover = Named_object::make_function_declaration(\"__go_can_recover\",\n-\t\t\t\t\t\t\t    NULL, fntype,\n-\t\t\t\t\t\t\t    bloc);\n-      can_recover->func_declaration_value()->set_asm_name(\"__go_can_recover\");\n+      can_recover =\n+\tNamed_object::make_function_declaration(\"runtime_canrecover\",\n+\t\t\t\t\t\tNULL, fntype, bloc);\n+      can_recover->func_declaration_value()->set_asm_name(\"runtime.canrecover\");\n     }\n \n   Expression* fn = Expression::make_func_reference(builtin_return_address,\n@@ -4217,10 +4216,10 @@ Build_recover_thunks::can_recover_arg(Location location)\n // function with an extra parameter, which is whether a call to\n // recover can succeed.  We then move the body of this function to\n // that one.  We then turn this function into a thunk which calls the\n-// new one, passing the value of\n-// __go_can_recover(__builtin_return_address()).  The function will be\n-// marked as not splitting the stack.  This will cooperate with the\n-// implementation of defer to make recover do the right thing.\n+// new one, passing the value of runtime.canrecover(__builtin_return_address()).\n+// The function will be marked as not splitting the stack.  This will\n+// cooperate with the implementation of defer to make recover do the\n+// right thing.\n \n void\n Gogo::build_recover_thunks()\n@@ -5634,7 +5633,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n   // libgo/runtime/go-unwind.c.\n \n   std::vector<Bstatement*> stmts;\n-  Expression* call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n+  Expression* call = Runtime::make_call(Runtime::CHECKDEFER, end_loc, 1,\n \t\t\t\t\tthis->defer_stack(end_loc));\n   Translate_context context(gogo, named_function, NULL, NULL);\n   Bexpression* defer = call->get_backend(&context);\n@@ -5647,11 +5646,11 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n   go_assert(*except == NULL);\n   *except = gogo->backend()->statement_list(stmts);\n \n-  call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n+  call = Runtime::make_call(Runtime::CHECKDEFER, end_loc, 1,\n                             this->defer_stack(end_loc));\n   defer = call->get_backend(&context);\n \n-  call = Runtime::make_call(Runtime::UNDEFER, end_loc, 1,\n+  call = Runtime::make_call(Runtime::DEFERRETURN, end_loc, 1,\n         \t\t    this->defer_stack(end_loc));\n   Bexpression* undefer = call->get_backend(&context);\n   Bstatement* function_defer ="}, {"sha": "7027989810c27d9e400c5421e227886ff4923823", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -173,29 +173,26 @@ DEF_GO_RUNTIME(SELECTGO, \"runtime.selectgo\", P1(POINTER), R1(INT32))\n \n \n // Panic.\n-DEF_GO_RUNTIME(PANIC, \"__go_panic\", P1(EFACE), R0())\n+DEF_GO_RUNTIME(GOPANIC, \"runtime.gopanic\", P1(EFACE), R0())\n \n // Recover.\n-DEF_GO_RUNTIME(RECOVER, \"__go_recover\", P0(), R1(EFACE))\n+DEF_GO_RUNTIME(GORECOVER, \"runtime.gorecover\", P0(), R1(EFACE))\n \n // Recover when called directly from defer.\n-DEF_GO_RUNTIME(DEFERRED_RECOVER, \"__go_deferred_recover\", P0(), R1(EFACE))\n+DEF_GO_RUNTIME(DEFERREDRECOVER, \"runtime.deferredrecover\", P0(), R1(EFACE))\n \n // Decide whether this function can call recover.\n-DEF_GO_RUNTIME(CAN_RECOVER, \"__go_can_recover\", P1(POINTER), R1(BOOL))\n-\n-// Get the return address of the function.\n-DEF_GO_RUNTIME(RETURN_ADDRESS, \"__go_return_address\", P1(INT), R1(POINTER))\n+DEF_GO_RUNTIME(CANRECOVER, \"runtime.canrecover\", P1(POINTER), R1(BOOL))\n \n // Set the return address for defer in a defer thunk.\n-DEF_GO_RUNTIME(SET_DEFER_RETADDR, \"__go_set_defer_retaddr\", P1(POINTER),\n+DEF_GO_RUNTIME(SETDEFERRETADDR, \"runtime.setdeferretaddr\", P1(POINTER),\n \t       R1(BOOL))\n \n // Check for a deferred function in an exception handler.\n-DEF_GO_RUNTIME(CHECK_DEFER, \"__go_check_defer\", P1(BOOLPTR), R0())\n+DEF_GO_RUNTIME(CHECKDEFER, \"runtime.checkdefer\", P1(BOOLPTR), R0())\n \n // Run deferred functions.\n-DEF_GO_RUNTIME(UNDEFER, \"__go_undefer\", P1(BOOLPTR), R0())\n+DEF_GO_RUNTIME(DEFERRETURN, \"runtime.deferreturn\", P1(BOOLPTR), R0())\n \n // Panic with a runtime error.\n DEF_GO_RUNTIME(RUNTIME_ERROR, \"__go_runtime_error\", P1(INT32), R0())\n@@ -233,7 +230,8 @@ DEF_GO_RUNTIME(NEW, \"__go_new\", P2(TYPE, UINTPTR), R1(POINTER))\n DEF_GO_RUNTIME(GO, \"__go_go\", P2(FUNC_PTR, POINTER), R0())\n \n // Defer a function.\n-DEF_GO_RUNTIME(DEFER, \"__go_defer\", P3(BOOLPTR, FUNC_PTR, POINTER), R0())\n+DEF_GO_RUNTIME(DEFERPROC, \"runtime.deferproc\", P3(BOOLPTR, FUNC_PTR, POINTER),\n+\t       R0())\n \n \n // Convert an empty interface to an empty interface, returning ok."}, {"sha": "e25fd6b3bdff5950edf0e3b535813f98654aec45", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -2296,7 +2296,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n     {\n       retaddr_label = gogo->add_label_reference(\"retaddr\", location, false);\n       Expression* arg = Expression::make_label_addr(retaddr_label, location);\n-      Expression* call = Runtime::make_call(Runtime::SET_DEFER_RETADDR,\n+      Expression* call = Runtime::make_call(Runtime::SETDEFERRETADDR,\n \t\t\t\t\t    location, 1, arg);\n \n       // This is a hack to prevent the middle-end from deleting the\n@@ -2540,7 +2540,7 @@ Defer_statement::do_get_backend(Translate_context* context)\n   Location loc = this->location();\n   Expression* ds = context->function()->func_value()->defer_stack(loc);\n \n-  Expression* call = Runtime::make_call(Runtime::DEFER, loc, 3,\n+  Expression* call = Runtime::make_call(Runtime::DEFERPROC, loc, 3,\n \t\t\t\t\tds, fn, arg);\n   Bexpression* bcall = call->get_backend(context);\n   return context->backend()->expression_statement(bcall);"}, {"sha": "7165dfd3acf1f5f4be9c3bd28d126647725a6871", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -429,8 +429,6 @@ runtime_files = \\\n \truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n \truntime/go-construct-map.c \\\n-\truntime/go-defer.c \\\n-\truntime/go-deferred-recover.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n \truntime/go-matherr.c \\\n@@ -442,8 +440,6 @@ runtime_files = \\\n \truntime/go-now.c \\\n \truntime/go-new.c \\\n \truntime/go-nosys.c \\\n-\truntime/go-panic.c \\\n-\truntime/go-recover.c \\\n \truntime/go-reflect-call.c \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\"}, {"sha": "9b87db00982366e2eb3f4d990ff4983c5a9e16fa", "filename": "libgo/Makefile.in", "status": "modified", "additions": 3, "deletions": 40, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -191,10 +191,9 @@ libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n @LIBGO_IS_LINUX_TRUE@am__objects_4 = getncpu-linux.lo\n am__objects_5 = go-assert.lo go-breakpoint.lo go-caller.lo \\\n \tgo-callers.lo go-cdiv.lo go-cgo.lo go-construct-map.lo \\\n-\tgo-defer.lo go-deferred-recover.lo go-ffi.lo go-fieldtrack.lo \\\n-\tgo-matherr.lo go-memclr.lo go-memcmp.lo go-memequal.lo \\\n-\tgo-memmove.lo go-nanotime.lo go-now.lo go-new.lo go-nosys.lo \\\n-\tgo-panic.lo go-recover.lo go-reflect-call.lo \\\n+\tgo-ffi.lo go-fieldtrack.lo go-matherr.lo go-memclr.lo \\\n+\tgo-memcmp.lo go-memequal.lo go-memmove.lo go-nanotime.lo \\\n+\tgo-now.lo go-new.lo go-nosys.lo go-reflect-call.lo \\\n \tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strslice.lo \\\n \tgo-type-complex.lo go-type-float.lo go-type-identity.lo \\\n \tgo-type-string.lo go-typedesc-equal.lo go-unsafe-new.lo \\\n@@ -775,8 +774,6 @@ runtime_files = \\\n \truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n \truntime/go-construct-map.c \\\n-\truntime/go-defer.c \\\n-\truntime/go-deferred-recover.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n \truntime/go-matherr.c \\\n@@ -788,8 +785,6 @@ runtime_files = \\\n \truntime/go-now.c \\\n \truntime/go-new.c \\\n \truntime/go-nosys.c \\\n-\truntime/go-panic.c \\\n-\truntime/go-recover.c \\\n \truntime/go-reflect-call.c \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\\n@@ -1464,8 +1459,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cdiv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cgo.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-construct-map.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-defer.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-deferred-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-fieldtrack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-matherr.Plo@am__quote@\n@@ -1477,8 +1470,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-nosys.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-now.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-call.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-runtime-error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n@@ -1631,20 +1622,6 @@ go-construct-map.lo: runtime/go-construct-map.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-construct-map.lo `test -f 'runtime/go-construct-map.c' || echo '$(srcdir)/'`runtime/go-construct-map.c\n \n-go-defer.lo: runtime/go-defer.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-defer.lo -MD -MP -MF $(DEPDIR)/go-defer.Tpo -c -o go-defer.lo `test -f 'runtime/go-defer.c' || echo '$(srcdir)/'`runtime/go-defer.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-defer.Tpo $(DEPDIR)/go-defer.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-defer.c' object='go-defer.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-defer.lo `test -f 'runtime/go-defer.c' || echo '$(srcdir)/'`runtime/go-defer.c\n-\n-go-deferred-recover.lo: runtime/go-deferred-recover.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-deferred-recover.lo -MD -MP -MF $(DEPDIR)/go-deferred-recover.Tpo -c -o go-deferred-recover.lo `test -f 'runtime/go-deferred-recover.c' || echo '$(srcdir)/'`runtime/go-deferred-recover.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-deferred-recover.Tpo $(DEPDIR)/go-deferred-recover.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-deferred-recover.c' object='go-deferred-recover.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-deferred-recover.lo `test -f 'runtime/go-deferred-recover.c' || echo '$(srcdir)/'`runtime/go-deferred-recover.c\n-\n go-ffi.lo: runtime/go-ffi.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-ffi.lo -MD -MP -MF $(DEPDIR)/go-ffi.Tpo -c -o go-ffi.lo `test -f 'runtime/go-ffi.c' || echo '$(srcdir)/'`runtime/go-ffi.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-ffi.Tpo $(DEPDIR)/go-ffi.Plo\n@@ -1722,20 +1699,6 @@ go-nosys.lo: runtime/go-nosys.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-nosys.lo `test -f 'runtime/go-nosys.c' || echo '$(srcdir)/'`runtime/go-nosys.c\n \n-go-panic.lo: runtime/go-panic.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-panic.lo -MD -MP -MF $(DEPDIR)/go-panic.Tpo -c -o go-panic.lo `test -f 'runtime/go-panic.c' || echo '$(srcdir)/'`runtime/go-panic.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-panic.Tpo $(DEPDIR)/go-panic.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-panic.c' object='go-panic.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-panic.lo `test -f 'runtime/go-panic.c' || echo '$(srcdir)/'`runtime/go-panic.c\n-\n-go-recover.lo: runtime/go-recover.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-recover.lo -MD -MP -MF $(DEPDIR)/go-recover.Tpo -c -o go-recover.lo `test -f 'runtime/go-recover.c' || echo '$(srcdir)/'`runtime/go-recover.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-recover.Tpo $(DEPDIR)/go-recover.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-recover.c' object='go-recover.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-recover.lo `test -f 'runtime/go-recover.c' || echo '$(srcdir)/'`runtime/go-recover.c\n-\n go-reflect-call.lo: runtime/go-reflect-call.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-reflect-call.lo -MD -MP -MF $(DEPDIR)/go-reflect-call.Tpo -c -o go-reflect-call.lo `test -f 'runtime/go-reflect-call.c' || echo '$(srcdir)/'`runtime/go-reflect-call.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-reflect-call.Tpo $(DEPDIR)/go-reflect-call.Plo"}, {"sha": "ef5fb9f083f63500db60abad9435b827a85bcce7", "filename": "libgo/go/reflect/makefunc_ffi_c.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -4,7 +4,6 @@\n \n #include \"runtime.h\"\n #include \"go-type.h\"\n-#include \"go-panic.h\"\n \n #ifdef USE_LIBFFI\n \n@@ -27,9 +26,15 @@ void makeFuncFFI(void *cif, void *impl)\n    function ffiCall with the pointer to the arguments, the results area,\n    and the closure structure.  */\n \n-void FFICallbackGo(void *result, void **args, ffi_go_closure *closure)\n+extern void FFICallbackGo(void *result, void **args, ffi_go_closure *closure)\n   __asm__ (GOSYM_PREFIX \"reflect.FFICallbackGo\");\n \n+extern void makefuncfficanrecover(Slice)\n+  __asm__ (GOSYM_PREFIX \"runtime.makefuncfficanrecover\");\n+\n+extern void makefuncreturning(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.makefuncreturning\");\n+\n static void ffi_callback (ffi_cif *, void *, void **, void *)\n   __asm__ (\"reflect.ffi_callback\");\n \n@@ -59,12 +64,19 @@ ffi_callback (ffi_cif* cif __attribute__ ((unused)), void *results,\n \tbreak;\n     }\n   if (i < n)\n-    __go_makefunc_ffi_can_recover (locs + i, n - i);\n+    {\n+      Slice s;\n+\n+      s.__values = (void *) &locs[i];\n+      s.__count = n - i;\n+      s.__capacity = n - i;\n+      makefuncfficanrecover (s);\n+    }\n \n   FFICallbackGo(results, args, closure);\n \n   if (i < n)\n-    __go_makefunc_returning ();\n+    makefuncreturning ();\n }\n \n /* Allocate an FFI closure and arrange to call ffi_callback.  */"}, {"sha": "9cf2230ab3f935dbd475029f33852fbd37247de4", "filename": "libgo/go/runtime/error.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ferror.go?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -142,7 +142,7 @@ func typestring(x interface{}) string {\n // Prints an argument passed to panic.\n // There's room for arbitrary complexity here, but we keep it\n // simple and handle just a few important cases: int, string, and Stringer.\n-func Printany(i interface{}) {\n+func printany(i interface{}) {\n \tswitch v := i.(type) {\n \tcase nil:\n \t\tprint(\"nil\")"}, {"sha": "c221b1d81096380a18fa4978494ec59032c90e5a", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -163,15 +163,6 @@ import \"runtime/internal/sys\"\n // suspend the current goroutine, so execution resumes automatically.\n func Gosched()\n \n-// Goexit terminates the goroutine that calls it.  No other goroutine is affected.\n-// Goexit runs all deferred calls before terminating the goroutine.\n-//\n-// Calling Goexit from the main goroutine terminates that goroutine\n-// without func main returning. Since func main has not returned,\n-// the program continues execution of other goroutines.\n-// If all other goroutines exit, the program crashes.\n-func Goexit()\n-\n // Caller reports file and line number information about function invocations on\n // the calling goroutine's stack. The argument skip is the number of stack frames\n // to ascend, with 0 identifying the caller of Caller.  (For historical reasons the"}, {"sha": "29a2f021d9935175d7e160f5cd67121731cad1b9", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 758, "deletions": 0, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -4,6 +4,27 @@\n \n package runtime\n \n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname deferproc runtime.deferproc\n+//go:linkname deferreturn runtime.deferreturn\n+//go:linkname setdeferretaddr runtime.setdeferretaddr\n+//go:linkname checkdefer runtime.checkdefer\n+//go:linkname gopanic runtime.gopanic\n+//go:linkname canrecover runtime.canrecover\n+//go:linkname makefuncfficanrecover runtime.makefuncfficanrecover\n+//go:linkname makefuncreturning runtime.makefuncreturning\n+//go:linkname gorecover runtime.gorecover\n+//go:linkname deferredrecover runtime.deferredrecover\n+// Temporary for C code to call:\n+//go:linkname throw runtime.throw\n+\n // Calling panic with one of the errors below will call errorString.Error\n // which will call mallocgc to concatenate strings. That will fail if\n // malloc is locked, causing a confusing error message. Throw a better\n@@ -65,6 +86,743 @@ func throwinit() {\n \tthrow(\"recursive call during initialization - linker skew\")\n }\n \n+// deferproc creates a new deferred function.\n+// The compiler turns a defer statement into a call to this.\n+// frame points into the stack frame; it is used to determine which\n+// deferred functions are for the current stack frame, and whether we\n+// have already deferred functions for this frame.\n+// pfn is a C function pointer.\n+// arg is a value to pass to pfn.\n+func deferproc(frame *bool, pfn uintptr, arg unsafe.Pointer) {\n+\tn := newdefer()\n+\tn.frame = frame\n+\tn._panic = getg()._panic\n+\tn.pfn = pfn\n+\tn.arg = arg\n+\tn.retaddr = 0\n+\tn.makefunccanrecover = false\n+\tn.special = false\n+}\n+\n+// Allocate a Defer, usually using per-P pool.\n+// Each defer must be released with freedefer.\n+func newdefer() *_defer {\n+\tvar d *_defer\n+\tmp := acquirem()\n+\tpp := mp.p.ptr()\n+\tif len(pp.deferpool) == 0 && sched.deferpool != nil {\n+\t\tlock(&sched.deferlock)\n+\t\tfor len(pp.deferpool) < cap(pp.deferpool)/2 && sched.deferpool != nil {\n+\t\t\td := sched.deferpool\n+\t\t\tsched.deferpool = d.link\n+\t\t\td.link = nil\n+\t\t\tpp.deferpool = append(pp.deferpool, d)\n+\t\t}\n+\t\tunlock(&sched.deferlock)\n+\t}\n+\tif n := len(pp.deferpool); n > 0 {\n+\t\td = pp.deferpool[n-1]\n+\t\tpp.deferpool[n-1] = nil\n+\t\tpp.deferpool = pp.deferpool[:n-1]\n+\t}\n+\tif d == nil {\n+\t\td = new(_defer)\n+\t}\n+\tgp := mp.curg\n+\td.link = gp._defer\n+\tgp._defer = d\n+\treleasem(mp)\n+\treturn d\n+}\n+\n+// Free the given defer.\n+// The defer cannot be used after this call.\n+func freedefer(d *_defer) {\n+\tif d.special {\n+\t\treturn\n+\t}\n+\tmp := acquirem()\n+\tpp := mp.p.ptr()\n+\tif len(pp.deferpool) == cap(pp.deferpool) {\n+\t\t// Transfer half of local cache to the central cache.\n+\t\tvar first, last *_defer\n+\t\tfor len(pp.deferpool) > cap(pp.deferpool)/2 {\n+\t\t\tn := len(pp.deferpool)\n+\t\t\td := pp.deferpool[n-1]\n+\t\t\tpp.deferpool[n-1] = nil\n+\t\t\tpp.deferpool = pp.deferpool[:n-1]\n+\t\t\tif first == nil {\n+\t\t\t\tfirst = d\n+\t\t\t} else {\n+\t\t\t\tlast.link = d\n+\t\t\t}\n+\t\t\tlast = d\n+\t\t}\n+\t\tlock(&sched.deferlock)\n+\t\tlast.link = sched.deferpool\n+\t\tsched.deferpool = first\n+\t\tunlock(&sched.deferlock)\n+\t}\n+\t*d = _defer{}\n+\tpp.deferpool = append(pp.deferpool, d)\n+\treleasem(mp)\n+}\n+\n+// deferreturn is called to undefer the stack.\n+// The compiler inserts a call to this function as a finally clause\n+// wrapped around the body of any function that calls defer.\n+// The frame argument points to the stack frame of the function.\n+func deferreturn(frame *bool) {\n+\tgp := getg()\n+\tfor gp._defer != nil && gp._defer.frame == frame {\n+\t\td := gp._defer\n+\t\tpfn := d.pfn\n+\t\td.pfn = 0\n+\n+\t\tif pfn != 0 {\n+\t\t\t// This is rather awkward.\n+\t\t\t// The gc compiler does this using assembler\n+\t\t\t// code in jmpdefer.\n+\t\t\tvar fn func(unsafe.Pointer)\n+\t\t\t*(**uintptr)(unsafe.Pointer(&fn)) = &pfn\n+\t\t\tfn(d.arg)\n+\t\t}\n+\n+\t\tgp._defer = d.link\n+\n+\t\tfreedefer(d)\n+\n+\t\t// Since we are executing a defer function now, we\n+\t\t// know that we are returning from the calling\n+\t\t// function. If the calling function, or one of its\n+\t\t// callees, panicked, then the defer functions would\n+\t\t// be executed by panic.\n+\t\t*frame = true\n+\t}\n+}\n+\n+// __builtin_extract_return_addr is a GCC intrinsic that converts an\n+// address returned by __builtin_return_address(0) to a real address.\n+// On most architectures this is a nop.\n+//extern __builtin_extract_return_addr\n+func __builtin_extract_return_addr(uintptr) uintptr\n+\n+// setdeferretaddr records the address to which the deferred function\n+// returns.  This is check by canrecover.  The frontend relies on this\n+// function returning false.\n+func setdeferretaddr(retaddr uintptr) bool {\n+\tgp := getg()\n+\tif gp._defer != nil {\n+\t\tgp._defer.retaddr = __builtin_extract_return_addr(retaddr)\n+\t}\n+\treturn false\n+}\n+\n+// checkdefer is called by exception handlers used when unwinding the\n+// stack after a recovered panic. The exception handler is simply\n+//   checkdefer(frame)\n+//   return;\n+// If we have not yet reached the frame we are looking for, we\n+// continue unwinding.\n+func checkdefer(frame *bool) {\n+\tgp := getg()\n+\tif gp == nil {\n+\t\t// We should never wind up here. Even if some other\n+\t\t// language throws an exception, the cgo code\n+\t\t// should ensure that g is set.\n+\t\tthrow(\"no g in checkdefer\")\n+\t} else if gp.isforeign {\n+\t\t// Some other language has thrown an exception.\n+\t\t// We need to run the local defer handlers.\n+\t\t// If they call recover, we stop unwinding here.\n+\t\tvar p _panic\n+\t\tp.isforeign = true\n+\t\tp.link = gp._panic\n+\t\tgp._panic = &p\n+\t\tfor {\n+\t\t\td := gp._defer\n+\t\t\tif d == nil || d.frame != frame || d.pfn == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tpfn := d.pfn\n+\t\t\tgp._defer = d.link\n+\n+\t\t\tvar fn func(unsafe.Pointer)\n+\t\t\t*(**uintptr)(unsafe.Pointer(&fn)) = &pfn\n+\t\t\tfn(d.arg)\n+\n+\t\t\tfreedefer(d)\n+\n+\t\t\tif p.recovered {\n+\t\t\t\t// The recover function caught the panic\n+\t\t\t\t// thrown by some other language.\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\trecovered := p.recovered\n+\t\tgp._panic = p.link\n+\n+\t\tif recovered {\n+\t\t\t// Just return and continue executing Go code.\n+\t\t\t*frame = true\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// We are panicking through this function.\n+\t\t*frame = false\n+\t} else if gp._defer != nil && gp._defer.pfn == 0 && gp._defer.frame == frame {\n+\t\t// This is the defer function that called recover.\n+\t\t// Simply return to stop the stack unwind, and let the\n+\t\t// Go code continue to execute.\n+\t\td := gp._defer\n+\t\tgp._defer = d.link\n+\t\tfreedefer(d)\n+\n+\t\t// We are returning from this function.\n+\t\t*frame = true\n+\n+\t\treturn\n+\t}\n+\n+\t// This is some other defer function. It was already run by\n+\t// the call to panic, or just above. Rethrow the exception.\n+\trethrowException()\n+\tthrow(\"rethrowException returned\")\n+}\n+\n+// unwindStack starts unwinding the stack for a panic. We unwind\n+// function calls until we reach the one which used a defer function\n+// which called recover. Each function which uses a defer statement\n+// will have an exception handler, as shown above for checkdefer.\n+func unwindStack() {\n+\t// Allocate the exception type used by the unwind ABI.\n+\t// It would be nice to define it in runtime_sysinfo.go,\n+\t// but current definitions don't work because the required\n+\t// alignment is larger than can be represented in Go.\n+\t// The type never contains any Go pointers.\n+\tsize := unwindExceptionSize()\n+\tusize := uintptr(unsafe.Sizeof(uintptr(0)))\n+\tc := (size + usize - 1) / usize\n+\ts := make([]uintptr, c)\n+\tgetg().exception = unsafe.Pointer(&s[0])\n+\tthrowException()\n+}\n+\n+// Goexit terminates the goroutine that calls it. No other goroutine is affected.\n+// Goexit runs all deferred calls before terminating the goroutine. Because Goexit\n+// is not panic, however, any recover calls in those deferred functions will return nil.\n+//\n+// Calling Goexit from the main goroutine terminates that goroutine\n+// without func main returning. Since func main has not returned,\n+// the program continues execution of other goroutines.\n+// If all other goroutines exit, the program crashes.\n+func Goexit() {\n+\t// Run all deferred functions for the current goroutine.\n+\t// This code is similar to gopanic, see that implementation\n+\t// for detailed comments.\n+\tgp := getg()\n+\tfor {\n+\t\td := gp._defer\n+\t\tif d == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tgp._defer = d.link\n+\n+\t\tpfn := d.pfn\n+\t\td.pfn = 0\n+\n+\t\tif pfn != 0 {\n+\t\t\tvar fn func(unsafe.Pointer)\n+\t\t\t*(**uintptr)(unsafe.Pointer(&fn)) = &pfn\n+\t\t\tfn(d.arg)\n+\t\t}\n+\n+\t\tfreedefer(d)\n+\t\t// Note: we ignore recovers here because Goexit isn't a panic\n+\t}\n+\tgoexit1()\n+}\n+\n+// Call all Error and String methods before freezing the world.\n+// Used when crashing with panicking.\n+// This must match types handled by printany.\n+func preprintpanics(p *_panic) {\n+\tfor p != nil {\n+\t\tswitch v := p.arg.(type) {\n+\t\tcase error:\n+\t\t\tp.arg = v.Error()\n+\t\tcase stringer:\n+\t\t\tp.arg = v.String()\n+\t\t}\n+\t\tp = p.link\n+\t}\n+}\n+\n+// Print all currently active panics. Used when crashing.\n+func printpanics(p *_panic) {\n+\tif p.link != nil {\n+\t\tprintpanics(p.link)\n+\t\tprint(\"\\t\")\n+\t}\n+\tprint(\"panic: \")\n+\tprintany(p.arg)\n+\tif p.recovered {\n+\t\tprint(\" [recovered]\")\n+\t}\n+\tprint(\"\\n\")\n+}\n+\n+// The implementation of the predeclared function panic.\n+func gopanic(e interface{}) {\n+\tgp := getg()\n+\tif gp.m.curg != gp {\n+\t\tprint(\"panic: \")\n+\t\tprintany(e)\n+\t\tprint(\"\\n\")\n+\t\tthrow(\"panic on system stack\")\n+\t}\n+\n+\tif gp.m.mallocing != 0 {\n+\t\tprint(\"panic: \")\n+\t\tprintany(e)\n+\t\tprint(\"\\n\")\n+\t\tthrow(\"panic during malloc\")\n+\t}\n+\tif gp.m.preemptoff != \"\" {\n+\t\tprint(\"panic: \")\n+\t\tprintany(e)\n+\t\tprint(\"\\n\")\n+\t\tprint(\"preempt off reason: \")\n+\t\tprint(gp.m.preemptoff)\n+\t\tprint(\"\\n\")\n+\t\tthrow(\"panic during preemptoff\")\n+\t}\n+\tif gp.m.locks != 0 {\n+\t\tprint(\"panic: \")\n+\t\tprintany(e)\n+\t\tprint(\"\\n\")\n+\t\tthrow(\"panic holding locks\")\n+\t}\n+\n+\tvar p _panic\n+\tp.arg = e\n+\tp.link = gp._panic\n+\tgp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))\n+\n+\tfor {\n+\t\td := gp._defer\n+\t\tif d == nil {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tpfn := d.pfn\n+\t\td.pfn = 0\n+\n+\t\tif pfn != 0 {\n+\t\t\tvar fn func(unsafe.Pointer)\n+\t\t\t*(**uintptr)(unsafe.Pointer(&fn)) = &pfn\n+\t\t\tfn(d.arg)\n+\n+\t\t\tif p.recovered {\n+\t\t\t\t// Some deferred function called recover.\n+\t\t\t\t// Stop running this panic.\n+\t\t\t\tgp._panic = p.link\n+\n+\t\t\t\t// Unwind the stack by throwing an exception.\n+\t\t\t\t// The compiler has arranged to create\n+\t\t\t\t// exception handlers in each function\n+\t\t\t\t// that uses a defer statement.  These\n+\t\t\t\t// exception handlers will check whether\n+\t\t\t\t// the entry on the top of the defer stack\n+\t\t\t\t// is from the current function.  If it is,\n+\t\t\t\t// we have unwound the stack far enough.\n+\t\t\t\tunwindStack()\n+\n+\t\t\t\tthrow(\"unwindStack returned\")\n+\t\t\t}\n+\n+\t\t\t// Because we executed that defer function by a panic,\n+\t\t\t// and it did not call recover, we know that we are\n+\t\t\t// not returning from the calling function--we are\n+\t\t\t// panicking through it.\n+\t\t\t*d.frame = false\n+\t\t}\n+\n+\t\tgp._defer = d.link\n+\t\tfreedefer(d)\n+\t}\n+\n+\t// ran out of deferred calls - old-school panic now\n+\t// Because it is unsafe to call arbitrary user code after freezing\n+\t// the world, we call preprintpanics to invoke all necessary Error\n+\t// and String methods to prepare the panic strings before startpanic.\n+\tpreprintpanics(gp._panic)\n+\tstartpanic()\n+\tprintpanics(gp._panic)\n+\tdopanic(0)       // should not return\n+\t*(*int)(nil) = 0 // not reached\n+}\n+\n+// currentDefer returns the top of the defer stack if it can be recovered.\n+// Otherwise it returns nil.\n+func currentDefer() *_defer {\n+\tgp := getg()\n+\td := gp._defer\n+\tif d == nil {\n+\t\treturn nil\n+\t}\n+\n+\t// The panic that would be recovered is the one on the top of\n+\t// the panic stack. We do not want to recover it if that panic\n+\t// was on the top of the panic stack when this function was\n+\t// deferred.\n+\tif d._panic == gp._panic {\n+\t\treturn nil\n+\t}\n+\n+\t// The deferred thunk will call setdeferretaddr. If this has\n+\t// not happened, then we have not been called via defer, and\n+\t// we can not recover.\n+\tif d.retaddr == 0 {\n+\t\treturn nil\n+\t}\n+\n+\treturn d\n+}\n+\n+// canrecover is called by a thunk to see if the real function would\n+// be permitted to recover a panic value. Recovering a value is\n+// permitted if the thunk was called directly by defer. retaddr is the\n+// return address of the function that is calling canrecover--that is,\n+// the thunk.\n+func canrecover(retaddr uintptr) bool {\n+\td := currentDefer()\n+\tif d == nil {\n+\t\treturn false\n+\t}\n+\n+\tret := __builtin_extract_return_addr(retaddr)\n+\tdret := d.retaddr\n+\tif ret <= dret && ret+16 >= dret {\n+\t\treturn true\n+\t}\n+\n+\t// On some systems, in some cases, the return address does not\n+\t// work reliably. See http://gcc.gnu.org/PR60406. If we are\n+\t// permitted to call recover, the call stack will look like this:\n+\t//     runtime.gopanic, runtime.deferreturn, etc.\n+\t//     thunk to call deferred function (calls __go_set_defer_retaddr)\n+\t//     function that calls __go_can_recover (passing return address)\n+\t//     runtime.canrecover\n+\t// Calling callers will skip the thunks. So if our caller's\n+\t// caller starts with \"runtime.\", then we are permitted to\n+\t// call recover.\n+\tvar locs [16]location\n+\tif callers(2, locs[:2]) < 2 {\n+\t\treturn false\n+\t}\n+\n+\tname := locs[1].function\n+\tif hasprefix(name, \"runtime.\") {\n+\t\treturn true\n+\t}\n+\n+\t// If the function calling recover was created by reflect.MakeFunc,\n+\t// then makefuncfficanrecover will have set makefunccanrecover.\n+\tif !d.makefunccanrecover {\n+\t\treturn false\n+\t}\n+\n+\t// We look up the stack, ignoring libffi functions and\n+\t// functions in the reflect package, until we find\n+\t// reflect.makeFuncStub or reflect.ffi_callback called by FFI\n+\t// functions.  Then we check the caller of that function.\n+\n+\tn := callers(3, locs[:])\n+\tfoundFFICallback := false\n+\ti := 0\n+\tfor ; i < n; i++ {\n+\t\tname = locs[i].function\n+\t\tif name == \"\" {\n+\t\t\t// No function name means this caller isn't Go code.\n+\t\t\t// Assume that this is libffi.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Ignore function in libffi.\n+\t\tif hasprefix(name, \"ffi_\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif foundFFICallback {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tif name == \"reflect.ffi_callback\" {\n+\t\t\tfoundFFICallback = true\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Ignore other functions in the reflect package.\n+\t\tif hasprefix(name, \"reflect.\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We should now be looking at the real caller.\n+\t\tbreak\n+\t}\n+\n+\tif i < n {\n+\t\tname = locs[i].function\n+\t\tif hasprefix(name, \"runtime.\") {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n+// This function is called when code is about to enter a function\n+// created by the libffi version of reflect.MakeFunc. This function is\n+// passed the names of the callers of the libffi code that called the\n+// stub. It uses them to decide whether it is permitted to call\n+// recover, and sets d.makefunccanrecover so that gorecover can make\n+// the same decision.\n+func makefuncfficanrecover(loc []location) {\n+\td := currentDefer()\n+\tif d == nil {\n+\t\treturn\n+\t}\n+\n+\t// If we are already in a call stack of MakeFunc functions,\n+\t// there is nothing we can usefully check here.\n+\tif d.makefunccanrecover {\n+\t\treturn\n+\t}\n+\n+\t// loc starts with the caller of our caller. That will be a thunk.\n+\t// If its caller was a function function, then it was called\n+\t// directly by defer.\n+\tif len(loc) < 2 {\n+\t\treturn\n+\t}\n+\n+\tname := loc[1].function\n+\tif hasprefix(name, \"runtime.\") {\n+\t\td.makefunccanrecover = true\n+\t}\n+}\n+\n+// makefuncreturning is called when code is about to exit a function\n+// created by reflect.MakeFunc. It is called by the function stub used\n+// by reflect.MakeFunc. It clears the makefunccanrecover field. It's\n+// OK to always clear this field, because canrecover will only be\n+// called by a stub created for a function that calls recover. That\n+// stub will not call a function created by reflect.MakeFunc, so by\n+// the time we get here any caller higher up on the call stack no\n+// longer needs the information.\n+func makefuncreturning() {\n+\td := getg()._defer\n+\tif d != nil {\n+\t\td.makefunccanrecover = false\n+\t}\n+}\n+\n+// The implementation of the predeclared function recover.\n+func gorecover() interface{} {\n+\tgp := getg()\n+\tp := gp._panic\n+\tif p != nil && !p.recovered {\n+\t\tp.recovered = true\n+\t\treturn p.arg\n+\t}\n+\treturn nil\n+}\n+\n+// deferredrecover is called when a call to recover is deferred.  That\n+// is, something like\n+//   defer recover()\n+//\n+// We need to handle this specially.  In gc, the recover function\n+// looks up the stack frame. In particular, that means that a deferred\n+// recover will not recover a panic thrown in the same function that\n+// defers the recover. It will only recover a panic thrown in a\n+// function that defers the deferred call to recover.\n+//\n+// In other words:\n+//\n+// func f1() {\n+// \tdefer recover()\t// does not stop panic\n+// \tpanic(0)\n+// }\n+//\n+// func f2() {\n+// \tdefer func() {\n+// \t\tdefer recover()\t// stops panic(0)\n+// \t}()\n+// \tpanic(0)\n+// }\n+//\n+// func f3() {\n+// \tdefer func() {\n+// \t\tdefer recover()\t// does not stop panic\n+// \t\tpanic(0)\n+// \t}()\n+// \tpanic(1)\n+// }\n+//\n+// func f4() {\n+// \tdefer func() {\n+// \t\tdefer func() {\n+// \t\t\tdefer recover()\t// stops panic(0)\n+// \t\t}()\n+// \t\tpanic(0)\n+// \t}()\n+// \tpanic(1)\n+// }\n+//\n+// The interesting case here is f3. As can be seen from f2, the\n+// deferred recover could pick up panic(1). However, this does not\n+// happen because it is blocked by the panic(0).\n+//\n+// When a function calls recover, then when we invoke it we pass a\n+// hidden parameter indicating whether it should recover something.\n+// This parameter is set based on whether the function is being\n+// invoked directly from defer. The parameter winds up determining\n+// whether __go_recover or __go_deferred_recover is called at all.\n+//\n+// In the case of a deferred recover, the hidden parameter that\n+// controls the call is actually the one set up for the function that\n+// runs the defer recover() statement. That is the right thing in all\n+// the cases above except for f3. In f3 the function is permitted to\n+// call recover, but the deferred recover call is not. We address that\n+// here by checking for that specific case before calling recover. If\n+// this function was deferred when there is already a panic on the\n+// panic stack, then we can only recover that panic, not any other.\n+\n+// Note that we can get away with using a special function here\n+// because you are not permitted to take the address of a predeclared\n+// function like recover.\n+func deferredrecover() interface{} {\n+\tgp := getg()\n+\tif gp._defer == nil || gp._defer._panic != gp._panic {\n+\t\treturn nil\n+\t}\n+\treturn gorecover()\n+}\n+\n+//go:nosplit\n+func throw(s string) {\n+\tprint(\"fatal error: \", s, \"\\n\")\n+\tgp := getg()\n+\tif gp.m.throwing == 0 {\n+\t\tgp.m.throwing = 1\n+\t}\n+\tstartpanic()\n+\tdopanic(0)\n+\t*(*int)(nil) = 0 // not reached\n+}\n+\n+//uint32 runtime\u00b7panicking;\n+var paniclk mutex\n+\n+func startpanic() {\n+\t_g_ := getg()\n+\t// Uncomment when mheap_ is in Go.\n+\t// if mheap_.cachealloc.size == 0 { // very early\n+\t//\tprint(\"runtime: panic before malloc heap initialized\\n\")\n+\t//\t_g_.m.mallocing = 1 // tell rest of panic not to try to malloc\n+\t// } else\n+\tif _g_.m.mcache == nil { // can happen if called from signal handler or throw\n+\t\t_g_.m.mcache = allocmcache()\n+\t}\n+\n+\tswitch _g_.m.dying {\n+\tcase 0:\n+\t\t_g_.m.dying = 1\n+\t\t_g_.writebuf = nil\n+\t\tatomic.Xadd(&panicking, 1)\n+\t\tlock(&paniclk)\n+\t\tif debug.schedtrace > 0 || debug.scheddetail > 0 {\n+\t\t\tschedtrace(true)\n+\t\t}\n+\t\tfreezetheworld()\n+\t\treturn\n+\tcase 1:\n+\t\t// Something failed while panicing, probably the print of the\n+\t\t// argument to panic().  Just print a stack trace and exit.\n+\t\t_g_.m.dying = 2\n+\t\tprint(\"panic during panic\\n\")\n+\t\tdopanic(0)\n+\t\texit(3)\n+\t\tfallthrough\n+\tcase 2:\n+\t\t// This is a genuine bug in the runtime, we couldn't even\n+\t\t// print the stack trace successfully.\n+\t\t_g_.m.dying = 3\n+\t\tprint(\"stack trace unavailable\\n\")\n+\t\texit(4)\n+\t\tfallthrough\n+\tdefault:\n+\t\t// Can't even print!  Just exit.\n+\t\texit(5)\n+\t}\n+}\n+\n+var didothers bool\n+var deadlock mutex\n+\n+func dopanic(unused int) {\n+\tgp := getg()\n+\tif gp.sig != 0 {\n+\t\tsigname := signame(gp.sig)\n+\t\tif signame != \"\" {\n+\t\t\tprint(\"[signal \", signame)\n+\t\t} else {\n+\t\t\tprint(\"[signal \", hex(gp.sig))\n+\t\t}\n+\t\tprint(\" code=\", hex(gp.sigcode0), \" addr=\", hex(gp.sigcode1), \" pc=\", hex(gp.sigpc), \"]\\n\")\n+\t}\n+\n+\tlevel, all, docrash := gotraceback()\n+\t_g_ := getg()\n+\tif level > 0 {\n+\t\tif gp != gp.m.curg {\n+\t\t\tall = true\n+\t\t}\n+\t\tif gp != gp.m.g0 {\n+\t\t\tprint(\"\\n\")\n+\t\t\tgoroutineheader(gp)\n+\t\t\ttraceback(0)\n+\t\t} else if level >= 2 || _g_.m.throwing > 0 {\n+\t\t\tprint(\"\\nruntime stack:\\n\")\n+\t\t\ttraceback(0)\n+\t\t}\n+\t\tif !didothers && all {\n+\t\t\tdidothers = true\n+\t\t\ttracebackothers(gp)\n+\t\t}\n+\t}\n+\tunlock(&paniclk)\n+\n+\tif atomic.Xadd(&panicking, -1) != 0 {\n+\t\t// Some other m is panicking too.\n+\t\t// Let it print what it needs to print.\n+\t\t// Wait forever without chewing up cpu.\n+\t\t// It will exit when it's done.\n+\t\tlock(&deadlock)\n+\t\tlock(&deadlock)\n+\t}\n+\n+\tif docrash {\n+\t\tcrash()\n+\t}\n+\n+\texit(2)\n+}\n+\n //go:nosplit\n func canpanic(gp *g) bool {\n \t// Note that g is m->gsignal, different from gp."}, {"sha": "c8db7adde2281c6ec55d14b2c2d2b6b194a79099", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -494,10 +494,9 @@ type p struct {\n \tmcache      *mcache\n \t// Not for gccgo: racectx     uintptr\n \n-\t// Not for gccgo yet: deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)\n-\t// Not for gccgo yet: deferpoolbuf [5][32]*_defer\n-\t// Temporary gccgo type for deferpool field.\n-\tdeferpool *_defer\n+\t// gccgo has only one size of defer.\n+\tdeferpool    []*_defer\n+\tdeferpoolbuf [32]*_defer\n \n \t// Cache of goroutine ids, amortizes accesses to runtime\u00b7sched.goidgen.\n \tgoidcache    uint64\n@@ -696,7 +695,7 @@ func extendRandom(r []byte, n int) {\n // This is the gccgo version.\n type _defer struct {\n \t// The next entry in the stack.\n-\tnext *_defer\n+\tlink *_defer\n \n \t// The stack variable for the function which called this defer\n \t// statement.  This is set to true if we are returning from\n@@ -735,7 +734,7 @@ type _defer struct {\n // This is the gccgo version.\n type _panic struct {\n \t// The next entry in the stack.\n-\tnext *_panic\n+\tlink *_panic\n \n \t// The value associated with this panic.\n \targ interface{}\n@@ -763,9 +762,9 @@ var (\n \t//\tallm        *m\n \t//\tallp        [_MaxGomaxprocs + 1]*p\n \t//\tgomaxprocs  int32\n-\t//\tpanicking   uint32\n \n-\tncpu int32\n+\tpanicking uint32\n+\tncpu      int32\n \n \t//\tforcegc     forcegcstate\n "}, {"sha": "3bf8bb74bad9b0c629d460754a87dd970adbf56b", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -226,10 +226,6 @@ func osyield()\n //extern syscall\n func syscall(trap uintptr, a1, a2, a3, a4, a5, a6 uintptr) uintptr\n \n-// throw crashes the program.\n-// For gccgo unless and until we port panic.go.\n-func throw(string)\n-\n // newobject allocates a new object.\n // For gccgo unless and until we port malloc.go.\n func newobject(*_type) unsafe.Pointer\n@@ -502,6 +498,9 @@ func dropm()\n func sigprof()\n func mcount() int32\n func gcount() int32\n+func goexit1()\n+func schedtrace(bool)\n+func freezetheworld()\n \n // Signal trampoline, written in C.\n func sigtramp()\n@@ -518,11 +517,26 @@ func getSiginfo(*_siginfo_t, unsafe.Pointer) (sigaddr uintptr, sigpc uintptr)\n // Implemented in C for gccgo.\n func dumpregs(*_siginfo_t, unsafe.Pointer)\n \n-// Temporary for gccgo until we port panic.go.\n-func startpanic()\n-\n // Temporary for gccgo until we port proc.go.\n //go:linkname getsched runtime.getsched\n func getsched() *schedt {\n \treturn &sched\n }\n+\n+// Throw and rethrow an exception.\n+func throwException()\n+func rethrowException()\n+\n+// Fetch the size and required alignment of the _Unwind_Exception type\n+// used by the stack unwinder.\n+func unwindExceptionSize() uintptr\n+\n+// Temporary for gccgo until C code no longer needs it.\n+//go:nosplit\n+//go:linkname getPanicking runtime.getPanicking\n+func getPanicking() uint32 {\n+\treturn panicking\n+}\n+\n+// Temporary for gccgo until we port mcache.go.\n+func allocmcache() *mcache"}, {"sha": "75c180655b0591ced8457a1bbd8084d08b83ab2f", "filename": "libgo/runtime/go-cgo.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-cgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-cgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cgo.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -6,7 +6,6 @@\n \n #include \"runtime.h\"\n #include \"go-alloc.h\"\n-#include \"go-panic.h\"\n #include \"go-type.h\"\n \n extern void chanrecv1 (ChanType *, Hchan *, void *)\n@@ -191,7 +190,7 @@ _cgo_panic (const char *p)\n      handle this by calling runtime_entersyscall in the personality\n      function in go-unwind.c.  FIXME.  */\n \n-  __go_panic (e);\n+  runtime_panic (e);\n }\n \n /* Used for _cgo_wait_runtime_init_done.  This is based on code in"}, {"sha": "f3e14bd0b966e4695ee77b4aa9fab2e85dc615ef", "filename": "libgo/runtime/go-defer.c", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-defer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-defer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-defer.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -1,84 +0,0 @@\n-/* go-defer.c -- manage the defer stack.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-panic.h\"\n-\n-/* This function is called each time we need to defer a call.  */\n-\n-void\n-__go_defer (_Bool *frame, void (*pfn) (void *), void *arg)\n-{\n-  G *g;\n-  Defer *n;\n-\n-  g = runtime_g ();\n-  n = runtime_newdefer ();\n-  n->next = g->_defer;\n-  n->frame = frame;\n-  n->_panic = g->_panic;\n-  n->pfn = (uintptr) pfn;\n-  n->arg = arg;\n-  n->retaddr = 0;\n-  n->makefunccanrecover = 0;\n-  n->special = 0;\n-  g->_defer = n;\n-}\n-\n-/* This function is called when we want to undefer the stack.  */\n-\n-void\n-__go_undefer (_Bool *frame)\n-{\n-  G *g;\n-\n-  g = runtime_g ();\n-  while (g->_defer != NULL && g->_defer->frame == frame)\n-    {\n-      Defer *d;\n-      void (*pfn) (void *);\n-\n-      d = g->_defer;\n-      pfn = (void (*) (void *)) d->pfn;\n-      d->pfn = 0;\n-\n-      if (pfn != NULL)\n-\t(*pfn) (d->arg);\n-\n-      g->_defer = d->next;\n-\n-      /* This may be called by a cgo callback routine to defer the\n-\t call to syscall.CgocallBackDone, in which case we will not\n-\t have a memory context.  Don't try to free anything in that\n-\t case--the GC will release it later.  */\n-      if (runtime_m () != NULL)\n-\truntime_freedefer (d);\n-\n-      /* Since we are executing a defer function here, we know we are\n-\t returning from the calling function.  If the calling\n-\t function, or one of its callees, paniced, then the defer\n-\t functions would be executed by __go_panic.  */\n-      *frame = 1;\n-    }\n-}\n-\n-/* This function is called to record the address to which the deferred\n-   function returns.  This may in turn be checked by __go_can_recover.\n-   The frontend relies on this function returning false.  */\n-\n-_Bool\n-__go_set_defer_retaddr (void *retaddr)\n-{\n-  G *g;\n-\n-  g = runtime_g ();\n-  if (g->_defer != NULL)\n-    g->_defer->retaddr = (uintptr) __builtin_extract_return_addr (retaddr);\n-  return 0;\n-}"}, {"sha": "c89c1fb7652df39ddfa6fa9b415bfd5d2d80ae6d", "filename": "libgo/runtime/go-deferred-recover.c", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-deferred-recover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-deferred-recover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-deferred-recover.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -1,93 +0,0 @@\n-/* go-deferred-recover.c -- support for a deferred recover function.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"runtime.h\"\n-#include \"go-panic.h\"\n-\n-/* This is called when a call to recover is deferred.  That is,\n-   something like\n-     defer recover()\n-\n-   We need to handle this specially.  In 6g/8g, the recover function\n-   looks up the stack frame.  In particular, that means that a\n-   deferred recover will not recover a panic thrown in the same\n-   function that defers the recover.  It will only recover a panic\n-   thrown in a function that defers the deferred call to recover.\n-\n-   In other words:\n-\n-   func f1() {\n-\tdefer recover()\t// does not stop panic\n-\tpanic(0)\n-   }\n-\n-   func f2() {\n-\tdefer func() {\n-\t\tdefer recover()\t// stops panic(0)\n-\t}()\n-\tpanic(0)\n-   }\n-\n-   func f3() {\n-\tdefer func() {\n-\t\tdefer recover()\t// does not stop panic\n-\t\tpanic(0)\n-\t}()\n-\tpanic(1)\n-   }\n-\n-   func f4() {\n-\tdefer func() {\n-\t\tdefer func() {\n-\t\t\tdefer recover()\t// stops panic(0)\n-\t\t}()\n-\t\tpanic(0)\n-\t}()\n-\tpanic(1)\n-   }\n-\n-   The interesting case here is f3.  As can be seen from f2, the\n-   deferred recover could pick up panic(1).  However, this does not\n-   happen because it is blocked by the panic(0).\n-\n-   When a function calls recover, then when we invoke it we pass a\n-   hidden parameter indicating whether it should recover something.\n-   This parameter is set based on whether the function is being\n-   invoked directly from defer.  The parameter winds up determining\n-   whether __go_recover or __go_deferred_recover is called at all.\n-\n-   In the case of a deferred recover, the hidden parameter which\n-   controls the call is actually the one set up for the function which\n-   runs the defer recover() statement.  That is the right thing in all\n-   the cases above except for f3.  In f3 the function is permitted to\n-   call recover, but the deferred recover call is not.  We address\n-   that here by checking for that specific case before calling\n-   recover.  If this function was deferred when there is already a\n-   panic on the panic stack, then we can only recover that panic, not\n-   any other.\n-\n-   Note that we can get away with using a special function here\n-   because you are not permitted to take the address of a predeclared\n-   function like recover.  */\n-\n-Eface\n-__go_deferred_recover ()\n-{\n-  G *g;\n-\n-  g = runtime_g ();\n-  if (g->_defer == NULL || g->_defer->_panic != g->_panic)\n-    {\n-      Eface ret;\n-\n-      ret._type = NULL;\n-      ret.data = NULL;\n-      return ret;\n-    }\n-  return __go_recover ();\n-}"}, {"sha": "2fb65aa5782bffec304026dc87f6695031a8f285", "filename": "libgo/runtime/go-panic.c", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-panic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-panic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -1,110 +0,0 @@\n-/* go-panic.c -- support for the go panic function.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-#include \"go-alloc.h\"\n-#include \"go-panic.h\"\n-\n-/* Print the panic stack.  This is used when there is no recover.  */\n-\n-static void\n-__printpanics (Panic *p)\n-{\n-  if (p->next != NULL)\n-    {\n-      __printpanics (p->next);\n-      runtime_printf (\"\\t\");\n-    }\n-  runtime_printf (\"panic: \");\n-  runtime_printany (p->arg);\n-  if (p->recovered)\n-    runtime_printf (\" [recovered]\");\n-  runtime_printf (\"\\n\");\n-}\n-\n-/* This implements __go_panic which is used for the panic\n-   function.  */\n-\n-void\n-__go_panic (Eface arg)\n-{\n-  G *g;\n-  Panic *n;\n-\n-  g = runtime_g ();\n-\n-  n = (Panic *) __go_alloc (sizeof (Panic));\n-  n->arg = arg;\n-  n->next = g->_panic;\n-  g->_panic = n;\n-\n-  /* Run all the defer functions.  */\n-\n-  while (1)\n-    {\n-      Defer *d;\n-      void (*pfn) (void *);\n-\n-      d = g->_defer;\n-      if (d == NULL)\n-\tbreak;\n-\n-      pfn = (void (*) (void *)) d->pfn;\n-      d->pfn = 0;\n-\n-      if (pfn != NULL)\n-\t{\n-\t  (*pfn) (d->arg);\n-\n-\t  if (n->recovered)\n-\t    {\n-\t      /* Some defer function called recover.  That means that\n-\t\t we should stop running this panic.  */\n-\n-\t      g->_panic = n->next;\n-\t      __go_free (n);\n-\n-\t      /* Now unwind the stack by throwing an exception.  The\n-\t\t compiler has arranged to create exception handlers in\n-\t\t each function which uses a defer statement.  These\n-\t\t exception handlers will check whether the entry on\n-\t\t the top of the defer stack is from the current\n-\t\t function.  If it is, we have unwound the stack far\n-\t\t enough.  */\n-\t      __go_unwind_stack ();\n-\n-\t      /* __go_unwind_stack should not return.  */\n-\t      abort ();\n-\t    }\n-\n-\t  /* Because we executed that defer function by a panic, and\n-\t     it did not call recover, we know that we are not\n-\t     returning from the calling function--we are panicing\n-\t     through it.  */\n-\t  *d->frame = 0;\n-\t}\n-\n-      g->_defer = d->next;\n-\n-      /* This may be called by a cgo callback routine to defer the\n-\t call to syscall.CgocallBackDone, in which case we will not\n-\t have a memory context.  Don't try to free anything in that\n-\t case--the GC will release it later.  */\n-      if (runtime_m () != NULL)\n-\truntime_freedefer (d);\n-    }\n-\n-  /* The panic was not recovered.  */\n-\n-  runtime_startpanic ();\n-  __printpanics (g->_panic);\n-  runtime_dopanic (0);\n-}"}, {"sha": "83b529286949f1b48ad7648d9a09ffa1f76c5c7c", "filename": "libgo/runtime/go-panic.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-panic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-panic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.h?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -1,27 +0,0 @@\n-/* go-panic.h -- declare the go panic functions.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#ifndef LIBGO_GO_PANIC_H\n-#define LIBGO_GO_PANIC_H\n-\n-extern void __go_panic (Eface)\n-  __attribute__ ((noreturn));\n-\n-extern void __go_print_string (String);\n-\n-extern Eface __go_recover (void);\n-\n-extern _Bool __go_can_recover (void *);\n-\n-extern void __go_makefunc_can_recover (void *retaddr);\n-\n-extern void __go_makefunc_ffi_can_recover (Location*, int);\n-\n-extern void __go_makefunc_returning (void);\n-\n-extern void __go_unwind_stack (void);\n-\n-#endif /* !defined(LIBGO_GO_PANIC_H) */"}, {"sha": "97efdcdf8ac7d9055cc655d03ef6d966ee2cc7ec", "filename": "libgo/runtime/go-recover.c", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-recover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7509bc070b29293ca9874518b89227ce05361c/libgo%2Fruntime%2Fgo-recover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-recover.c?ref=6c7509bc070b29293ca9874518b89227ce05361c", "patch": "@@ -1,273 +0,0 @@\n-/* go-recover.c -- support for the go recover function.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-panic.h\"\n-\n-/* If the top of the defer stack can be recovered, then return it.\n-   Otherwise return NULL.  */\n-\n-static Defer *\n-current_defer ()\n-{\n-  G *g;\n-  Defer *d;\n-\n-  g = runtime_g ();\n-\n-  d = g->_defer;\n-  if (d == NULL)\n-    return NULL;\n-\n-  /* The panic which would be recovered is the one on the top of the\n-     panic stack.  We do not want to recover it if that panic was on\n-     the top of the panic stack when this function was deferred.  */\n-  if (d->_panic == g->_panic)\n-    return NULL;\n-\n-  /* The deferred thunk will call _go_set_defer_retaddr.  If this has\n-     not happened, then we have not been called via defer, and we can\n-     not recover.  */\n-  if (d->retaddr == 0)\n-    return NULL;\n-\n-  return d;\n-}\n-\n-/* This is called by a thunk to see if the real function should be\n-   permitted to recover a panic value.  Recovering a value is\n-   permitted if the thunk was called directly by defer.  RETADDR is\n-   the return address of the function which is calling\n-   __go_can_recover--this is, the thunk.  */\n-\n-_Bool\n-__go_can_recover (void *retaddr)\n-{\n-  Defer *d;\n-  const char* ret;\n-  const char* dret;\n-  Location locs[16];\n-  const byte *name;\n-  intgo len;\n-  int n;\n-  int i;\n-  _Bool found_ffi_callback;\n-\n-  d = current_defer ();\n-  if (d == NULL)\n-    return 0;\n-\n-  ret = (const char *) __builtin_extract_return_addr (retaddr);\n-\n-  dret = (const char *) (uintptr) d->retaddr;\n-  if (ret <= dret && ret + 16 >= dret)\n-    return 1;\n-\n-  /* On some systems, in some cases, the return address does not work\n-     reliably.  See http://gcc.gnu.org/PR60406.  If we are permitted\n-     to call recover, the call stack will look like this:\n-       __go_panic, __go_undefer, etc.\n-       thunk to call deferred function (calls __go_set_defer_retaddr)\n-       function that calls __go_can_recover (passing return address)\n-       __go_can_recover\n-     Calling runtime_callers will skip the thunks.  So if our caller's\n-     caller starts with __go, then we are permitted to call\n-     recover.  */\n-\n-  if (runtime_callers (1, &locs[0], 2, false) < 2)\n-    return 0;\n-\n-  name = locs[1].function.str;\n-  len = locs[1].function.len;\n-\n-  /* Although locs[1].function is a Go string, we know it is\n-     NUL-terminated.  */\n-  if (len > 4\n-      && __builtin_strchr ((const char *) name, '.') == NULL\n-      && __builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n-    return 1;\n-\n-  /* If we are called from __go_makefunc_can_recover, then we need to\n-     look one level higher.  */\n-  if (locs[0].function.len > 0\n-      && __builtin_strcmp ((const char *) locs[0].function.str,\n-\t\t\t   \"__go_makefunc_can_recover\") == 0)\n-    {\n-      if (runtime_callers (3, &locs[0], 1, false) < 1)\n-\treturn 0;\n-      name = locs[0].function.str;\n-      len = locs[0].function.len;\n-      if (len > 4\n-\t  && __builtin_strchr ((const char *) name, '.') == NULL\n-\t  && __builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n-\treturn 1;\n-    }\n-\n-  /* If the function calling recover was created by reflect.MakeFunc,\n-     then __go_makefunc_can_recover or __go_makefunc_ffi_can_recover\n-     will have set the __makefunc_can_recover field.  */\n-  if (!d->makefunccanrecover)\n-    return 0;\n-\n-  /* We look up the stack, ignoring libffi functions and functions in\n-     the reflect package, until we find reflect.makeFuncStub or\n-     reflect.ffi_callback called by FFI functions.  Then we check the\n-     caller of that function.  */\n-\n-  n = runtime_callers (2, &locs[0], sizeof locs / sizeof locs[0], false);\n-  found_ffi_callback = 0;\n-  for (i = 0; i < n; i++)\n-    {\n-      const byte *name;\n-\n-      if (locs[i].function.len == 0)\n-\t{\n-\t  /* No function name means this caller isn't Go code.  Assume\n-\t     that this is libffi.  */\n-\t  continue;\n-\t}\n-\n-      /* Ignore functions in libffi.  */\n-      name = locs[i].function.str;\n-      if (__builtin_strncmp ((const char *) name, \"ffi_\", 4) == 0)\n-\tcontinue;\n-\n-      if (found_ffi_callback)\n-\tbreak;\n-\n-      if (__builtin_strcmp ((const char *) name, \"reflect.ffi_callback\") == 0)\n-\t{\n-\t  found_ffi_callback = 1;\n-\t  continue;\n-\t}\n-\n-      if (__builtin_strcmp ((const char *) name, \"reflect.makeFuncStub\") == 0)\n-\t{\n-\t  i++;\n-\t  break;\n-\t}\n-\n-      /* Ignore other functions in the reflect package.  */\n-      if (__builtin_strncmp ((const char *) name, \"reflect.\", 8) == 0)\n-\tcontinue;\n-\n-      /* We should now be looking at the real caller.  */\n-      break;\n-    }\n-\n-  if (i < n && locs[i].function.len > 0)\n-    {\n-      name = locs[i].function.str;\n-      if (__builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* This function is called when code is about to enter a function\n-   created by reflect.MakeFunc.  It is called by the function stub\n-   used by MakeFunc.  If the stub is permitted to call recover, then a\n-   real MakeFunc function is permitted to call recover.  */\n-\n-void\n-__go_makefunc_can_recover (void *retaddr)\n-{\n-  Defer *d;\n-\n-  d = current_defer ();\n-  if (d == NULL)\n-    return;\n-\n-  /* If we are already in a call stack of MakeFunc functions, there is\n-     nothing we can usefully check here.  */\n-  if (d->makefunccanrecover)\n-    return;\n-\n-  if (__go_can_recover (retaddr))\n-    d->makefunccanrecover = 1;\n-}\n-\n-/* This function is called when code is about to enter a function\n-   created by the libffi version of reflect.MakeFunc.  This function\n-   is passed the names of the callers of the libffi code that called\n-   the stub.  It uses to decide whether it is permitted to call\n-   recover, and sets d->makefunccanrecover so that __go_recover can\n-   make the same decision.  */\n-\n-void\n-__go_makefunc_ffi_can_recover (Location *loc, int n)\n-{\n-  Defer *d;\n-  const byte *name;\n-  intgo len;\n-\n-  d = current_defer ();\n-  if (d == NULL)\n-    return;\n-\n-  /* If we are already in a call stack of MakeFunc functions, there is\n-     nothing we can usefully check here.  */\n-  if (d->makefunccanrecover)\n-    return;\n-\n-  /* LOC points to the caller of our caller.  That will be a thunk.\n-     If its caller was a runtime function, then it was called directly\n-     by defer.  */\n-\n-  if (n < 2)\n-    return;\n-\n-  name = (loc + 1)->function.str;\n-  len = (loc + 1)->function.len;\n-  if (len > 4\n-      && __builtin_strchr ((const char *) name, '.') == NULL\n-      && __builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n-    d->makefunccanrecover = 1;\n-}\n-\n-/* This function is called when code is about to exit a function\n-   created by reflect.MakeFunc.  It is called by the function stub\n-   used by MakeFunc.  It clears the makefunccanrecover field.  It's OK\n-   to always clear this field, because __go_can_recover will only be\n-   called by a stub created for a function that calls recover.  That\n-   stub will not call a function created by reflect.MakeFunc, so by\n-   the time we get here any caller higher up on the call stack no\n-   longer needs the information.  */\n-\n-void\n-__go_makefunc_returning (void)\n-{\n-  Defer *d;\n-\n-  d = runtime_g ()->_defer;\n-  if (d != NULL)\n-    d->makefunccanrecover = 0;\n-}\n-\n-/* This is only called when it is valid for the caller to recover the\n-   value on top of the panic stack, if there is one.  */\n-\n-Eface\n-__go_recover ()\n-{\n-  G *g;\n-  Panic *p;\n-\n-  g = runtime_g ();\n-\n-  if (g->_panic == NULL || g->_panic->recovered)\n-    {\n-      Eface ret;\n-\n-      ret._type = NULL;\n-      ret.data = NULL;\n-      return ret;\n-    }\n-  p = g->_panic;\n-  p->recovered = 1;\n-  return p->arg;\n-}"}, {"sha": "c1f1a52d20140778aa0bb98ed3864846b145136c", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -11,8 +11,6 @@\n #include <ucontext.h>\n \n #include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n \n #ifndef SA_RESTART\n   #define SA_RESTART 0"}, {"sha": "c9f196bc9c8309c683b38dc6be80eefb369cbdce", "filename": "libgo/runtime/go-strslice.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-strslice.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-strslice.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-strslice.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -5,9 +5,6 @@\n    license that can be found in the LICENSE file.  */\n \n #include \"runtime.h\"\n-#include \"go-panic.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n \n String\n __go_string_slice (String s, intgo start, intgo end)"}, {"sha": "9e85b4b81475ec012ae3a6cc779d6b4c6399522d", "filename": "libgo/runtime/go-unwind.c", "status": "modified", "additions": 36, "deletions": 106, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-unwind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fgo-unwind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unwind.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -15,7 +15,6 @@\n \n #include \"runtime.h\"\n #include \"go-alloc.h\"\n-#include \"go-panic.h\"\n \n /* The code for a Go exception.  */\n \n@@ -34,110 +33,16 @@ static const _Unwind_Exception_Class __go_exception_class =\n    << 8 | (_Unwind_Exception_Class) '\\0');\n #endif\n \n+/* Rethrow an exception.  */\n \n-/* This function is called by exception handlers used when unwinding\n-   the stack after a recovered panic.  The exception handler looks\n-   like this:\n-     __go_check_defer (frame);\n-     return;\n-   If we have not yet reached the frame we are looking for, we\n-   continue unwinding.  */\n+void rethrowException (void) __asm__(GOSYM_PREFIX \"runtime.rethrowException\");\n \n void\n-__go_check_defer (_Bool *frame)\n+rethrowException ()\n {\n-  G *g;\n   struct _Unwind_Exception *hdr;\n \n-  g = runtime_g ();\n-\n-  if (g == NULL)\n-    {\n-      /* Some other language has thrown an exception.  We know there\n-\t are no defer handlers, so there is nothing to do.  */\n-    }\n-  else if (g->isforeign)\n-    {\n-      Panic *n;\n-      _Bool recovered;\n-\n-      /* Some other language has thrown an exception.  We need to run\n-\t the local defer handlers.  If they call recover, we stop\n-\t unwinding the stack here.  */\n-\n-      n = (Panic *) __go_alloc (sizeof (Panic));\n-\n-      n->arg._type = NULL;\n-      n->arg.data = NULL;\n-      n->recovered = 0;\n-      n->isforeign = 1;\n-      n->next = g->_panic;\n-      g->_panic = n;\n-\n-      while (1)\n-\t{\n-\t  Defer *d;\n-\t  void (*pfn) (void *);\n-\n-\t  d = g->_defer;\n-\t  if (d == NULL || d->frame != frame || d->pfn == 0)\n-\t    break;\n-\n-\t  pfn = (void (*) (void *)) d->pfn;\n-\t  g->_defer = d->next;\n-\n-\t  (*pfn) (d->arg);\n-\n-\t  if (runtime_m () != NULL)\n-\t    runtime_freedefer (d);\n-\n-\t  if (n->recovered)\n-\t    {\n-\t      /* The recover function caught the panic thrown by some\n-\t\t other language.  */\n-\t      break;\n-\t    }\n-\t}\n-\n-      recovered = n->recovered;\n-      g->_panic = n->next;\n-      __go_free (n);\n-\n-      if (recovered)\n-\t{\n-\t  /* Just return and continue executing Go code.  */\n-\t  *frame = 1;\n-\t  return;\n-\t}\n-\n-      /* We are panicing through this function.  */\n-      *frame = 0;\n-    }\n-  else if (g->_defer != NULL\n-\t   && g->_defer->pfn == 0\n-\t   && g->_defer->frame == frame)\n-    {\n-      Defer *d;\n-\n-      /* This is the defer function which called recover.  Simply\n-\t return to stop the stack unwind, and let the Go code continue\n-\t to execute.  */\n-      d = g->_defer;\n-      g->_defer = d->next;\n-\n-      if (runtime_m () != NULL)\n-\truntime_freedefer (d);\n-\n-      /* We are returning from this function.  */\n-      *frame = 1;\n-\n-      return;\n-    }\n-\n-  /* This is some other defer function.  It was already run by the\n-     call to panic, or just above.  Rethrow the exception.  */\n-\n-  hdr = (struct _Unwind_Exception *) g->exception;\n+  hdr = (struct _Unwind_Exception *) runtime_g()->exception;\n \n #ifdef __USING_SJLJ_EXCEPTIONS__\n   _Unwind_SjLj_Resume_or_Rethrow (hdr);\n@@ -153,23 +58,48 @@ __go_check_defer (_Bool *frame)\n   abort();\n }\n \n-/* Unwind function calls until we reach the one which used a defer\n-   function which called recover.  Each function which uses a defer\n-   statement will have an exception handler, as shown above.  */\n+/* Return the size of the type that holds an exception header, so that\n+   it can be allocated by Go code.  */\n+\n+uintptr unwindExceptionSize(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.unwindExceptionSize\");\n+\n+uintptr\n+unwindExceptionSize ()\n+{\n+  uintptr ret, align;\n+\n+  ret = sizeof (struct _Unwind_Exception);\n+  /* Adjust the size fo make sure that we can get an aligned value.  */\n+  align = __alignof__ (struct _Unwind_Exception);\n+  if (align > __alignof__ (uintptr))\n+    ret += align - __alignof__ (uintptr);\n+  return ret;\n+}\n+\n+/* Throw an exception.  This is called with g->exception pointing to\n+   an uninitialized _Unwind_Exception instance.  */\n+\n+void throwException (void) __asm__(GOSYM_PREFIX \"runtime.throwException\");\n \n void\n-__go_unwind_stack ()\n+throwException ()\n {\n   struct _Unwind_Exception *hdr;\n+  uintptr align;\n+\n+  hdr = (struct _Unwind_Exception *)runtime_g ()->exception;\n \n+  /* Make sure the value is correctly aligned.  It will be large\n+     enough, because of unwindExceptionSize.  */\n+  align = __alignof__ (struct _Unwind_Exception);\n   hdr = ((struct _Unwind_Exception *)\n-\t __go_alloc (sizeof (struct _Unwind_Exception)));\n+\t (((uintptr) hdr + align - 1) &~ (align - 1)));\n+\n   __builtin_memcpy (&hdr->exception_class, &__go_exception_class,\n \t\t    sizeof hdr->exception_class);\n   hdr->exception_cleanup = NULL;\n \n-  runtime_g ()->exception = hdr;\n-\n #ifdef __USING_SJLJ_EXCEPTIONS__\n   _Unwind_SjLj_RaiseException (hdr);\n #else"}, {"sha": "80d2b7bf85006c2a78da57785e5be89a6fc018b9", "filename": "libgo/runtime/heapdump.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fheapdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fheapdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fheapdump.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -14,7 +14,6 @@\n #include \"malloc.h\"\n #include \"mgc0.h\"\n #include \"go-type.h\"\n-#include \"go-panic.h\"\n \n #define hash __hash\n #define KindNoPointers GO_NO_POINTERS\n@@ -284,24 +283,24 @@ dumpgoroutine(G *gp)\n \t// runtime_gentraceback(pc, sp, lr, gp, 0, nil, 0x7fffffff, dumpframe, &child, false);\n \n \t// dump defer & panic records\n-\tfor(d = gp->_defer; d != nil; d = d->next) {\n+\tfor(d = gp->_defer; d != nil; d = d->link) {\n \t\tdumpint(TagDefer);\n \t\tdumpint((uintptr)d);\n \t\tdumpint((uintptr)gp);\n \t\tdumpint((uintptr)d->arg);\n \t\tdumpint((uintptr)d->frame);\n \t\tdumpint((uintptr)d->pfn);\n \t\tdumpint((uintptr)0);\n-\t\tdumpint((uintptr)d->next);\n+\t\tdumpint((uintptr)d->link);\n \t}\n-\tfor (p = gp->_panic; p != nil; p = p->next) {\n+\tfor (p = gp->_panic; p != nil; p = p->link) {\n \t\tdumpint(TagPanic);\n \t\tdumpint((uintptr)p);\n \t\tdumpint((uintptr)gp);\n \t\tdumpint((uintptr)p->arg._type);\n \t\tdumpint((uintptr)p->arg.data);\n \t\tdumpint((uintptr)0);\n-\t\tdumpint((uintptr)p->next);\n+\t\tdumpint((uintptr)p->link);\n \t}\n }\n "}, {"sha": "7efad5e0ee431bafc110d1661b54a522509a9e64", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -124,6 +124,7 @@ clearpools(void)\n {\n \tP *p, **pp;\n \tMCache *c;\n+\tDefer *d, *dlink;\n \n \t// clear sync.Pool's\n \tif(poolcleanup != nil) {\n@@ -138,9 +139,17 @@ clearpools(void)\n \t\t\tc->tiny = nil;\n \t\t\tc->tinysize = 0;\n \t\t}\n-\t\t// clear defer pools\n-\t\tp->deferpool = nil;\n \t}\n+\n+\t// Clear central defer pools.\n+\t// Leave per-P pools alone, they have strictly bounded size.\n+\truntime_lock(&runtime_sched->deferlock);\n+\tfor(d = runtime_sched->deferpool; d != nil; d = dlink) {\n+\t\tdlink = d->link;\n+\t\td->link = nil;\n+\t}\n+\truntime_sched->deferpool = nil;\n+\truntime_unlock(&runtime_sched->deferlock);\n }\n \n typedef struct Workbuf Workbuf;\n@@ -2125,7 +2134,7 @@ runtime_gc(int32 force)\n \t// without a lock will do the gc instead.\n \tm = runtime_m();\n \tpmstats = mstats();\n-\tif(!pmstats->enablegc || runtime_g() == m->g0 || m->locks > 0 || runtime_panicking || m->preemptoff.len > 0)\n+\tif(!pmstats->enablegc || runtime_g() == m->g0 || m->locks > 0 || runtime_panicking() || m->preemptoff.len > 0)\n \t\treturn;\n \n \tif(gcpercent == GcpercentUnknown) {\t// first time through"}, {"sha": "493fde8932033abfb640da999e8539f11af4ded6", "filename": "libgo/runtime/panic.c", "status": "modified", "additions": 3, "deletions": 222, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fpanic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fpanic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fpanic.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -3,218 +3,14 @@\n // license that can be found in the LICENSE file.\n \n #include \"runtime.h\"\n-#include \"malloc.h\"\n-#include \"go-panic.h\"\n \n-// Code related to defer, panic and recover.\n-\n-uint32 runtime_panicking;\n-static Lock paniclk;\n-\n-// Allocate a Defer, usually using per-P pool.\n-// Each defer must be released with freedefer.\n-Defer*\n-runtime_newdefer()\n-{\n-\tDefer *d;\n-\tP *p;\n-\n-\td = nil;\n-\tp = (P*)runtime_m()->p;\n-\td = p->deferpool;\n-\tif(d)\n-\t\tp->deferpool = d->next;\n-\tif(d == nil) {\n-\t\t// deferpool is empty\n-\t\td = runtime_malloc(sizeof(Defer));\n-\t}\n-\treturn d;\n-}\n-\n-// Free the given defer.\n-// The defer cannot be used after this call.\n-void\n-runtime_freedefer(Defer *d)\n-{\n-\tP *p;\n-\n-\tif(d->special)\n-\t\treturn;\n-\tp = (P*)runtime_m()->p;\n-\td->next = p->deferpool;\n-\tp->deferpool = d;\n-\t// No need to wipe out pointers in argp/pc/fn/args,\n-\t// because we empty the pool before GC.\n-}\n-\n-// Run all deferred functions for the current goroutine.\n-// This is noinline for go_can_recover.\n-static void __go_rundefer (void) __attribute__ ((noinline));\n-static void\n-__go_rundefer(void)\n-{\n-\tG *g;\n-\tDefer *d;\n-\n-\tg = runtime_g();\n-\twhile((d = g->_defer) != nil) {\n-\t\tvoid (*pfn)(void*);\n-\n-\t\tg->_defer = d->next;\n-\t\tpfn = (void (*) (void *))d->pfn;\n-\t\td->pfn = 0;\n-\t\tif (pfn != nil)\n-\t\t\t(*pfn)(d->arg);\n-\t\truntime_freedefer(d);\n-\t}\n-}\n-\n-void\n-runtime_startpanic(void)\n-{\n-\tG *g;\n-\tM *m;\n-\n-\tg = runtime_g();\n-\tm = g->m;\n-\tif(runtime_mheap.cachealloc.size == 0) { // very early\n-\t\truntime_printf(\"runtime: panic before malloc heap initialized\\n\");\n-\t\tm->mallocing = 1; // tell rest of panic not to try to malloc\n-\t} else if(m->mcache == nil) // can happen if called from signal handler or throw\n-\t\tm->mcache = runtime_allocmcache();\n-\tswitch(m->dying) {\n-\tcase 0:\n-\t\tm->dying = 1;\n-\t\tg->writebuf.__values = nil;\n-\t\tg->writebuf.__count = 0;\n-\t\tg->writebuf.__capacity = 0;\n-\t\truntime_xadd(&runtime_panicking, 1);\n-\t\truntime_lock(&paniclk);\n-\t\tif(runtime_debug.schedtrace > 0 || runtime_debug.scheddetail > 0)\n-\t\t\truntime_schedtrace(true);\n-\t\truntime_freezetheworld();\n-\t\treturn;\n-\tcase 1:\n-\t\t// Something failed while panicing, probably the print of the\n-\t\t// argument to panic().  Just print a stack trace and exit.\n-\t\tm->dying = 2;\n-\t\truntime_printf(\"panic during panic\\n\");\n-\t\truntime_dopanic(0);\n-\t\truntime_exit(3);\n-\tcase 2:\n-\t\t// This is a genuine bug in the runtime, we couldn't even\n-\t\t// print the stack trace successfully.\n-\t\tm->dying = 3;\n-\t\truntime_printf(\"stack trace unavailable\\n\");\n-\t\truntime_exit(4);\n-\tdefault:\n-\t\t// Can't even print!  Just exit.\n-\t\truntime_exit(5);\n-\t}\n-}\n-\n-void\n-runtime_dopanic(int32 unused __attribute__ ((unused)))\n-{\n-\tG *g;\n-\tstatic bool didothers;\n-\tbool crash;\n-\tint32 t;\n-\n-\tg = runtime_g();\n-\tif(g->sig != 0) {\n-\t\truntime_printf(\"[signal %x code=%p addr=%p\",\n-\t\t\t       g->sig, (void*)g->sigcode0, (void*)g->sigcode1);\n-\t\tif (g->sigpc != 0)\n-\t\t\truntime_printf(\" pc=%p\", g->sigpc);\n-\t\truntime_printf(\"]\\n\");\n-\t}\n-\n-\tif((t = runtime_gotraceback(&crash)) > 0){\n-\t\tif(g != runtime_m()->g0) {\n-\t\t\truntime_printf(\"\\n\");\n-\t\t\truntime_goroutineheader(g);\n-\t\t\truntime_traceback(0);\n-\t\t\truntime_printcreatedby(g);\n-\t\t} else if(t >= 2 || runtime_m()->throwing > 0) {\n-\t\t\truntime_printf(\"\\nruntime stack:\\n\");\n-\t\t\truntime_traceback(0);\n-\t\t}\n-\t\tif(!didothers) {\n-\t\t\tdidothers = true;\n-\t\t\truntime_tracebackothers(g);\n-\t\t}\n-\t}\n-\truntime_unlock(&paniclk);\n-\tif(runtime_xadd(&runtime_panicking, -1) != 0) {\n-\t\t// Some other m is panicking too.\n-\t\t// Let it print what it needs to print.\n-\t\t// Wait forever without chewing up cpu.\n-\t\t// It will exit when it's done.\n-\t\tstatic Lock deadlock;\n-\t\truntime_lock(&deadlock);\n-\t\truntime_lock(&deadlock);\n-\t}\n-\t\n-\tif(crash)\n-\t\truntime_crash();\n-\n-\truntime_exit(2);\n-}\n-\n-bool\n-runtime_canpanic(G *gp)\n-{\n-\tM *m = runtime_m();\n-\tbyte g;\n-\n-\tUSED(&g);  // don't use global g, it points to gsignal\n-\n-\t// Is it okay for gp to panic instead of crashing the program?\n-\t// Yes, as long as it is running Go code, not runtime code,\n-\t// and not stuck in a system call.\n-\tif(gp == nil || gp != m->curg)\n-\t\treturn false;\n-\tif(m->locks-m->softfloat != 0 || m->mallocing != 0 || m->throwing != 0 || m->gcing != 0 || m->dying != 0)\n-\t\treturn false;\n-\tif(gp->atomicstatus != _Grunning)\n-\t\treturn false;\n-#ifdef GOOS_windows\n-\tif(m->libcallsp != 0)\n-\t\treturn false;\n-#endif\n-\treturn true;\n-}\n+extern void gothrow(String) __attribute__((noreturn));\n+extern void gothrow(String) __asm__(GOSYM_PREFIX \"runtime.throw\");\n \n void\n runtime_throw(const char *s)\n {\n-\tM *mp;\n-\n-\tmp = runtime_m();\n-\tif(mp->throwing == 0)\n-\t\tmp->throwing = 1;\n-\truntime_startpanic();\n-\truntime_printf(\"fatal error: %s\\n\", s);\n-\truntime_dopanic(0);\n-\t*(int32*)0 = 0;\t// not reached\n-\truntime_exit(1);\t// even more not reached\n-}\n-\n-void throw(String) __asm__ (GOSYM_PREFIX \"runtime.throw\");\n-void\n-throw(String s)\n-{\n-\tM *mp;\n-\n-\tmp = runtime_m();\n-\tif(mp->throwing == 0)\n-\t\tmp->throwing = 1;\n-\truntime_startpanic();\n-\truntime_printf(\"fatal error: %S\\n\", s);\n-\truntime_dopanic(0);\n-\t*(int32*)0 = 0;\t// not reached\n-\truntime_exit(1);\t// even more not reached\n+\tgothrow(runtime_gostringnocopy((const byte *)s));\n }\n \n void\n@@ -237,18 +33,3 @@ runtime_panicstring(const char *s)\n \truntime_newErrorCString(s, &err);\n \truntime_panic(err);\n }\n-\n-void runtime_Goexit (void) __asm__ (GOSYM_PREFIX \"runtime.Goexit\");\n-\n-void\n-runtime_Goexit(void)\n-{\n-\t__go_rundefer();\n-\truntime_goexit();\n-}\n-\n-void\n-runtime_panicdivide(void)\n-{\n-\truntime_panicstring(\"integer divide by zero\");\n-}"}, {"sha": "dd5562bb57668ece482d95c26abf66062b20d05a", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -255,7 +255,7 @@ kickoff(void)\n \tparam = g->param;\n \tg->param = nil;\n \tfn(param);\n-\truntime_goexit();\n+\truntime_goexit1();\n }\n \n // Switch context to a different goroutine.  This is like longjmp.\n@@ -351,8 +351,6 @@ runtime_mcall(void (*pfn)(G*))\n //\n // Design doc at http://golang.org/s/go11sched.\n \n-typedef struct schedt Sched;\n-\n enum\n {\n \t// Number of goroutine ids to grab from runtime_sched->goidgen to local per-P cache at once.\n@@ -362,7 +360,7 @@ enum\n \n extern Sched* runtime_getsched() __asm__ (GOSYM_PREFIX \"runtime.getsched\");\n \n-static Sched*\truntime_sched;\n+Sched*\truntime_sched;\n int32\truntime_gomaxprocs;\n uint32\truntime_needextram = 1;\n M\truntime_m0;\n@@ -581,7 +579,7 @@ runtime_main(void* dummy __attribute__((unused)))\n \t\n \t// Defer unlock so that runtime.Goexit during init does the unlock too.\n \td.pfn = (uintptr)(void*)initDone;\n-\td.next = g->_defer;\n+\td.link = g->_defer;\n \td.arg = (void*)-1;\n \td._panic = g->_panic;\n \td.retaddr = 0;\n@@ -604,7 +602,7 @@ runtime_main(void* dummy __attribute__((unused)))\n \n \tif(g->_defer != &d || (void*)d.pfn != initDone)\n \t\truntime_throw(\"runtime: bad defer entry after init\");\n-\tg->_defer = d.next;\n+\tg->_defer = d.link;\n \truntime_unlockOSThread();\n \n \t// For gccgo we have to wait until after main is initialized\n@@ -626,7 +624,7 @@ runtime_main(void* dummy __attribute__((unused)))\n \t// another goroutine at the same time as main returns,\n \t// let the other goroutine finish printing the panic trace.\n \t// Once it does, it will exit. See issue 3934.\n-\tif(runtime_panicking)\n+\tif(runtime_panicking())\n \t\truntime_park(nil, nil, \"panicwait\");\n \n \truntime_exit(0);\n@@ -1945,16 +1943,16 @@ runtime_gosched0(G *gp)\n // Need to mark it as nosplit, because it runs with sp > stackbase (as runtime_lessstack).\n // Since it does not return it does not matter.  But if it is preempted\n // at the split stack check, GC will complain about inconsistent sp.\n-void runtime_goexit(void) __attribute__ ((noinline));\n+void runtime_goexit1(void) __attribute__ ((noinline));\n void\n-runtime_goexit(void)\n+runtime_goexit1(void)\n {\n \tif(g->atomicstatus != _Grunning)\n \t\truntime_throw(\"bad g status\");\n \truntime_mcall(goexit0);\n }\n \n-// runtime_goexit continuation on g0.\n+// runtime_goexit1 continuation on g0.\n static void\n goexit0(G *gp)\n {\n@@ -2744,6 +2742,7 @@ procresize(int32 new)\n \tbool pempty;\n \tG *gp;\n \tP *p;\n+\tintgo j;\n \n \told = runtime_gomaxprocs;\n \tif(old < 0 || old > _MaxGomaxprocs || new <= 0 || new >_MaxGomaxprocs)\n@@ -2755,6 +2754,9 @@ procresize(int32 new)\n \t\t\tp = (P*)runtime_mallocgc(sizeof(*p), 0, FlagNoInvokeGC);\n \t\t\tp->id = i;\n \t\t\tp->status = _Pgcstop;\n+\t\t\tp->deferpool.__values = &p->deferpoolbuf[0];\n+\t\t\tp->deferpool.__count = 0;\n+\t\t\tp->deferpool.__capacity = nelem(p->deferpoolbuf);\n \t\t\truntime_atomicstorep(&runtime_allp[i], p);\n \t\t}\n \t\tif(p->mcache == nil) {\n@@ -2803,6 +2805,10 @@ procresize(int32 new)\n \t// free unused P's\n \tfor(i = new; i < old; i++) {\n \t\tp = runtime_allp[i];\n+\t\tfor(j = 0; j < p->deferpool.__count; j++) {\n+\t\t\t((struct _defer**)p->deferpool.__values)[j] = nil;\n+\t\t}\n+\t\tp->deferpool.__count = 0;\n \t\truntime_freemcache(p->mcache);\n \t\tp->mcache = nil;\n \t\tgfpurge(p);\n@@ -2902,7 +2908,7 @@ checkdead(void)\n \t// freezetheworld will cause all running threads to block.\n \t// And runtime will essentially enter into deadlock state,\n \t// except that there is a thread that will call runtime_exit soon.\n-\tif(runtime_panicking > 0)\n+\tif(runtime_panicking() > 0)\n \t\treturn;\n \tif(run < 0) {\n \t\truntime_printf(\"runtime: checkdead: nmidle=%d nmidlelocked=%d mcount=%d\\n\","}, {"sha": "34b5b444701c1b044b2a388576963c1cf87475ec", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e3afb5484c71eaaea23fc3a4b86fe35418d43/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=9d1e3afb5484c71eaaea23fc3a4b86fe35418d43", "patch": "@@ -73,6 +73,7 @@ typedef\tstruct\tParForThread\tParForThread;\n typedef\tstruct\tcgoMal\t\tCgoMal;\n typedef\tstruct\tPollDesc\tPollDesc;\n typedef\tstruct\tsudog\t\tSudoG;\n+typedef struct\tschedt\t\tSched;\n \n typedef\tstruct\t__go_open_array\t\tSlice;\n typedef\tstruct\tiface\t\t\tIface;\n@@ -241,9 +242,11 @@ extern\tuintptr runtime_allglen;\n extern\tG*\truntime_lastg;\n extern\tM*\truntime_allm;\n extern\tP**\truntime_allp;\n+extern\tSched*  runtime_sched;\n extern\tint32\truntime_gomaxprocs;\n extern\tuint32\truntime_needextram;\n-extern\tuint32\truntime_panicking;\n+extern\tuint32\truntime_panicking(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.getPanicking\");\n extern\tint8*\truntime_goos;\n extern\tint32\truntime_ncpu;\n extern \tvoid\t(*runtime_sysargs)(int32, uint8**);\n@@ -306,7 +309,8 @@ void\truntime_needm(void)\n void\truntime_dropm(void)\n   __asm__ (GOSYM_PREFIX \"runtime.dropm\");\n void\truntime_signalstack(byte*, int32);\n-MCache*\truntime_allocmcache(void);\n+MCache*\truntime_allocmcache(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.allocmcache\");\n void\truntime_freemcache(MCache*);\n void\truntime_mallocinit(void);\n void\truntime_mprofinit(void);\n@@ -348,12 +352,14 @@ void runtime_newextram(void);\n #define runtime_breakpoint() __builtin_trap()\n void\truntime_gosched(void);\n void\truntime_gosched0(G*);\n-void\truntime_schedtrace(bool);\n+void\truntime_schedtrace(bool)\n+  __asm__ (GOSYM_PREFIX \"runtime.schedtrace\");\n void\truntime_park(bool(*)(G*, void*), void*, const char*);\n void\truntime_parkunlock(Lock*, const char*);\n void\truntime_tsleep(int64, const char*);\n M*\truntime_newm(void);\n-void\truntime_goexit(void);\n+void\truntime_goexit1(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.goexit1\");\n void\truntime_entersyscall(int32)\n   __asm__ (GOSYM_PREFIX \"runtime.entersyscall\");\n void\truntime_entersyscallblock(int32)\n@@ -369,7 +375,8 @@ int64\truntime_unixnanotime(void) // real time, can skip\n void\truntime_dopanic(int32) __attribute__ ((noreturn));\n void\truntime_startpanic(void)\n   __asm__ (GOSYM_PREFIX \"runtime.startpanic\");\n-void\truntime_freezetheworld(void);\n+void\truntime_freezetheworld(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.freezetheworld\");\n void\truntime_unwindstack(G*, byte*);\n void\truntime_sigprof()\n   __asm__ (GOSYM_PREFIX \"runtime.sigprof\");\n@@ -494,13 +501,14 @@ void __wrap_rtems_task_variable_add(void **);\n void reflect_call(const struct __go_func_type *, FuncVal *, _Bool, _Bool,\n \t\t  void **, void **)\n   __asm__ (GOSYM_PREFIX \"reflect.call\");\n-#define runtime_panic __go_panic\n+void runtime_panic(Eface)\n+  __asm__ (GOSYM_PREFIX \"runtime.gopanic\");\n+void runtime_panic(Eface)\n+  __attribute__ ((noreturn));\n \n /*\n  * runtime c-called (but written in Go)\n  */\n-void\truntime_printany(Eface)\n-     __asm__ (GOSYM_PREFIX \"runtime.Printany\");\n void\truntime_newTypeAssertionError(const String*, const String*, const String*, const String*, Eface*)\n      __asm__ (GOSYM_PREFIX \"runtime.NewTypeAssertionError\");\n void\truntime_newErrorCString(const char*, Eface*)"}]}