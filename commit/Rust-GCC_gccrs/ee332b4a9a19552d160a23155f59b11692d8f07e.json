{"sha": "ee332b4a9a19552d160a23155f59b11692d8f07e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUzMzJiNGE5YTE5NTUyZDE2MGEyMzE1NWY1OWIxMTY5MmQ4ZjA3ZQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2019-02-22T10:51:05Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2019-02-22T10:51:05Z"}, "message": "[libgomp] Clarify difference between offload target, offload plugin, and OpenACC device type\n\n\tlibgomp/\n\t* plugin/configfrag.ac: Populate and AC_SUBST offload_plugins\n\tinstead of offload_targets, and AC_DEFINE_UNQUOTED OFFLOAD_PLUGINS\n\tinstead of OFFLOAD_TARGETS.\n\t* target.c (gomp_target_init): Adjust.\n\t* testsuite/libgomp-test-support.exp.in: Likewise.\n\t* testsuite/lib/libgomp.exp: Likewise.  Populate\n\topenacc_device_types_s instead of offload_targets_s_openacc.\n\t(check_effective_target_openacc_nvidia_accel_selected)\n\t(check_effective_target_openacc_host_selected): Adjust.\n\t* testsuite/libgomp.oacc-c++/c++.exp: Likewise.\n\t* testsuite/libgomp.oacc-c/c.exp: Likewise.\n\t* testsuite/libgomp.oacc-fortran/fortran.exp: Likewise.\n\t* Makefile.in: Regenerate.\n\t* config.h.in: Likewise.\n\t* configure: Likewise.\n\t* testsuite/Makefile.in: Likewise.\n\nFrom-SVN: r269107", "tree": {"sha": "58f40a753ad2430cc8982321e637e153ed80f5f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58f40a753ad2430cc8982321e637e153ed80f5f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee332b4a9a19552d160a23155f59b11692d8f07e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee332b4a9a19552d160a23155f59b11692d8f07e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee332b4a9a19552d160a23155f59b11692d8f07e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee332b4a9a19552d160a23155f59b11692d8f07e/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1241136c71bc1bf67b1df59f965ad5d50a613b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1241136c71bc1bf67b1df59f965ad5d50a613b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1241136c71bc1bf67b1df59f965ad5d50a613b4e"}], "stats": {"total": 212, "additions": 114, "deletions": 98}, "files": [{"sha": "344e83f082f4d265e5628746041e59f90e2dcb34", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -1,5 +1,22 @@\n 2019-02-22  Thomas Schwinge  <thomas@codesourcery.com>\n \n+\t* plugin/configfrag.ac: Populate and AC_SUBST offload_plugins\n+\tinstead of offload_targets, and AC_DEFINE_UNQUOTED OFFLOAD_PLUGINS\n+\tinstead of OFFLOAD_TARGETS.\n+\t* target.c (gomp_target_init): Adjust.\n+\t* testsuite/libgomp-test-support.exp.in: Likewise.\n+\t* testsuite/lib/libgomp.exp: Likewise.  Populate\n+\topenacc_device_types_s instead of offload_targets_s_openacc.\n+\t(check_effective_target_openacc_nvidia_accel_selected)\n+\t(check_effective_target_openacc_host_selected): Adjust.\n+\t* testsuite/libgomp.oacc-c++/c++.exp: Likewise.\n+\t* testsuite/libgomp.oacc-c/c.exp: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/fortran.exp: Likewise.\n+\t* Makefile.in: Regenerate.\n+\t* config.h.in: Likewise.\n+\t* configure: Likewise.\n+\t* testsuite/Makefile.in: Likewise.\n+\n \t* testsuite/lib/libgomp.exp: Error out for unknown offload target.\n \t* testsuite/libgomp.oacc-c++/c++.exp: Likewise.  Report if\n \t\"offloading: supported, but hardware not accessible\"."}, {"sha": "12ce8d05c19ffbb681259c5fbe4bfc1156792796", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -493,7 +493,7 @@ mkdir_p = @mkdir_p@\n multi_basedir = @multi_basedir@\n offload_additional_lib_paths = @offload_additional_lib_paths@\n offload_additional_options = @offload_additional_options@\n-offload_targets = @offload_targets@\n+offload_plugins = @offload_plugins@\n oldincludedir = @oldincludedir@\n pdfdir = @pdfdir@\n prefix = @prefix@"}, {"sha": "73f1b12805e33a00148e7ca535802b02abad56e7", "filename": "libgomp/config.h.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -146,8 +146,8 @@\n    */\n #undef LT_OBJDIR\n \n-/* Define to offload targets, separated by commas. */\n-#undef OFFLOAD_TARGETS\n+/* Define to offload plugins, separated by commas. */\n+#undef OFFLOAD_PLUGINS\n \n /* Name of package */\n #undef PACKAGE"}, {"sha": "1033ae4d988d0748161af92bc866c62ea0e4ff65", "filename": "libgomp/configure", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -667,6 +667,7 @@ PLUGIN_NVPTX_FALSE\n PLUGIN_NVPTX_TRUE\n offload_additional_lib_paths\n offload_additional_options\n+offload_plugins\n PLUGIN_HSA_LIBS\n PLUGIN_HSA_LDFLAGS\n PLUGIN_HSA_CPPFLAGS\n@@ -679,7 +680,6 @@ PLUGIN_NVPTX_CPPFLAGS\n PLUGIN_NVPTX\n CUDA_DRIVER_LIB\n CUDA_DRIVER_INCLUDE\n-offload_targets\n libtool_VERSION\n ac_ct_FC\n FCFLAGS\n@@ -15401,8 +15401,6 @@ fi\n # see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n # <http://www.gnu.org/licenses/>.\n \n-offload_targets=\n-\n plugin_support=yes\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for dlsym in -ldl\" >&5\n $as_echo_n \"checking for dlsym in -ldl... \" >&6; }\n@@ -15621,7 +15619,10 @@ PLUGIN_HSA_LIBS=\n \n \n \n-# Get offload targets and path to install tree of offloading compiler.\n+# Parse '--enable-offload-targets', figure out the corresponding libgomp\n+# plugins, and configure to find the corresponding offload compilers.\n+offload_plugins=\n+\n offload_additional_options=\n offload_additional_lib_paths=\n \n@@ -15630,13 +15631,13 @@ if test x\"$enable_offload_targets\" != x; then\n   for tgt in `echo $enable_offload_targets | sed -e 's#,# #g'`; do\n     tgt_dir=`echo $tgt | grep '=' | sed 's/.*=//'`\n     tgt=`echo $tgt | sed 's/=.*//'`\n-    tgt_name=\n+    tgt_plugin=\n     case $tgt in\n       *-intelmic-* | *-intelmicemul-*)\n-\ttgt_name=intelmic\n+\ttgt_plugin=intelmic\n \t;;\n       nvptx*)\n-        tgt_name=nvptx\n+\ttgt_plugin=nvptx\n \tPLUGIN_NVPTX=$tgt\n \tif test \"x$CUDA_DRIVER_LIB\" != xno \\\n \t   && test \"x$CUDA_DRIVER_LIB\" != xno; then\n@@ -15695,7 +15696,7 @@ rm -f core conftest.err conftest.$ac_objext \\\n \t        PLUGIN_HSA=0\n \t\t;;\n \t      *)\n-\t        tgt_name=hsa\n+\t\ttgt_plugin=hsa\n \t        PLUGIN_HSA=$tgt\n \t        PLUGIN_HSA_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS\n \t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS\"\n@@ -15713,7 +15714,7 @@ rm -f core conftest.err conftest.$ac_objext \\\n \t        LDFLAGS=$PLUGIN_HSA_save_LDFLAGS\n \t        LIBS=$PLUGIN_HSA_save_LIBS\n \t        case $PLUGIN_HSA in\n-\t          hsa*)\n+\t\t  hsa*)\n \t            HSA_PLUGIN=0\n \t            as_fn_error $? \"HSA run-time package required for HSA support\" \"$LINENO\" 5\n \t            ;;\n@@ -15730,16 +15731,17 @@ rm -f core conftest.err conftest.$ac_objext \\\n \tas_fn_error $? \"unknown offload target specified\" \"$LINENO\" 5\n \t;;\n     esac\n-    if test x\"$tgt_name\" = x; then\n-      # Don't configure libgomp for this offloading target if we don't build\n-      # the corresponding plugin.\n+    if test x\"$tgt_plugin\" = x; then\n+      # Not configuring libgomp for this offload target if we're not building\n+      # the corresponding offload plugin.\n       continue\n-    elif test x\"$offload_targets\" = x; then\n-      offload_targets=$tgt_name\n+    elif test x\"$offload_plugins\" = x; then\n+      offload_plugins=$tgt_plugin\n     else\n-      offload_targets=$offload_targets,$tgt_name\n+      offload_plugins=$offload_plugins,$tgt_plugin\n     fi\n-    if test \"$tgt_name\" = hsa; then\n+    # Configure additional search paths.\n+    if test \"$tgt_plugin\" = hsa; then\n       # Offloading compilation is all handled by the target compiler.\n       :\n     elif test x\"$tgt_dir\" != x; then\n@@ -15753,7 +15755,7 @@ rm -f core conftest.err conftest.$ac_objext \\\n fi\n \n cat >>confdefs.h <<_ACEOF\n-#define OFFLOAD_TARGETS \"$offload_targets\"\n+#define OFFLOAD_PLUGINS \"$offload_plugins\"\n _ACEOF\n \n  if test $PLUGIN_NVPTX = 1; then"}, {"sha": "c49d17991e6b8a542092fe86fb7eddceb0bb30db", "filename": "libgomp/plugin/configfrag.ac", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Fplugin%2Fconfigfrag.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Fplugin%2Fconfigfrag.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fconfigfrag.ac?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -26,8 +26,6 @@\n # see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n # <http://www.gnu.org/licenses/>.\n \n-offload_targets=\n-AC_SUBST(offload_targets)\n plugin_support=yes\n AC_CHECK_LIB(dl, dlsym, , [plugin_support=no])\n if test x\"$plugin_support\" = xyes; then\n@@ -139,7 +137,10 @@ AC_SUBST(PLUGIN_HSA_CPPFLAGS)\n AC_SUBST(PLUGIN_HSA_LDFLAGS)\n AC_SUBST(PLUGIN_HSA_LIBS)\n \n-# Get offload targets and path to install tree of offloading compiler.\n+# Parse '--enable-offload-targets', figure out the corresponding libgomp\n+# plugins, and configure to find the corresponding offload compilers.\n+offload_plugins=\n+AC_SUBST(offload_plugins)\n offload_additional_options=\n offload_additional_lib_paths=\n AC_SUBST(offload_additional_options)\n@@ -148,13 +149,13 @@ if test x\"$enable_offload_targets\" != x; then\n   for tgt in `echo $enable_offload_targets | sed -e 's#,# #g'`; do\n     tgt_dir=`echo $tgt | grep '=' | sed 's/.*=//'`\n     tgt=`echo $tgt | sed 's/=.*//'`\n-    tgt_name=\n+    tgt_plugin=\n     case $tgt in\n       *-intelmic-* | *-intelmicemul-*)\n-\ttgt_name=intelmic\n+\ttgt_plugin=intelmic\n \t;;\n       nvptx*)\n-        tgt_name=nvptx\n+\ttgt_plugin=nvptx\n \tPLUGIN_NVPTX=$tgt\n \tif test \"x$CUDA_DRIVER_LIB\" != xno \\\n \t   && test \"x$CUDA_DRIVER_LIB\" != xno; then\n@@ -202,7 +203,7 @@ if test x\"$enable_offload_targets\" != x; then\n \t        PLUGIN_HSA=0\n \t\t;;\n \t      *)\n-\t        tgt_name=hsa\n+\t\ttgt_plugin=hsa\n \t        PLUGIN_HSA=$tgt\n \t        PLUGIN_HSA_CPPFLAGS=$HSA_RUNTIME_CPPFLAGS\n \t        PLUGIN_HSA_LDFLAGS=\"$HSA_RUNTIME_LDFLAGS\"\n@@ -220,7 +221,7 @@ if test x\"$enable_offload_targets\" != x; then\n \t        LDFLAGS=$PLUGIN_HSA_save_LDFLAGS\n \t        LIBS=$PLUGIN_HSA_save_LIBS\n \t        case $PLUGIN_HSA in\n-\t          hsa*)\n+\t\t  hsa*)\n \t            HSA_PLUGIN=0\n \t            AC_MSG_ERROR([HSA run-time package required for HSA support])\n \t            ;;\n@@ -237,16 +238,17 @@ if test x\"$enable_offload_targets\" != x; then\n \tAC_MSG_ERROR([unknown offload target specified])\n \t;;\n     esac\n-    if test x\"$tgt_name\" = x; then\n-      # Don't configure libgomp for this offloading target if we don't build\n-      # the corresponding plugin.\n+    if test x\"$tgt_plugin\" = x; then\n+      # Not configuring libgomp for this offload target if we're not building\n+      # the corresponding offload plugin.\n       continue\n-    elif test x\"$offload_targets\" = x; then\n-      offload_targets=$tgt_name\n+    elif test x\"$offload_plugins\" = x; then\n+      offload_plugins=$tgt_plugin\n     else\n-      offload_targets=$offload_targets,$tgt_name\n+      offload_plugins=$offload_plugins,$tgt_plugin\n     fi\n-    if test \"$tgt_name\" = hsa; then\n+    # Configure additional search paths.\n+    if test \"$tgt_plugin\" = hsa; then\n       # Offloading compilation is all handled by the target compiler.\n       :\n     elif test x\"$tgt_dir\" != x; then\n@@ -258,8 +260,8 @@ if test x\"$enable_offload_targets\" != x; then\n     fi\n   done\n fi\n-AC_DEFINE_UNQUOTED(OFFLOAD_TARGETS, \"$offload_targets\",\n-  [Define to offload targets, separated by commas.])\n+AC_DEFINE_UNQUOTED(OFFLOAD_PLUGINS, \"$offload_plugins\",\n+  [Define to offload plugins, separated by commas.])\n AM_CONDITIONAL([PLUGIN_NVPTX], [test $PLUGIN_NVPTX = 1])\n AC_DEFINE_UNQUOTED([PLUGIN_NVPTX], [$PLUGIN_NVPTX],\n   [Define to 1 if the NVIDIA plugin is built, 0 if not.])"}, {"sha": "31148003d0a5d686ed00feb8299e52cb38eebb3a", "filename": "libgomp/target.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -2710,9 +2710,9 @@ gomp_target_fini (void)\n     }\n }\n \n-/* This function initializes the runtime needed for offloading.\n-   It parses the list of offload targets and tries to load the plugins for\n-   these targets.  On return, the variables NUM_DEVICES and NUM_DEVICES_OPENMP\n+/* This function initializes the runtime for offloading.\n+   It parses the list of offload plugins, and tries to load these.\n+   On return, the variables NUM_DEVICES and NUM_DEVICES_OPENMP\n    will be set, and the array DEVICES initialized, containing descriptors for\n    corresponding devices, first the GOMP_OFFLOAD_CAP_OPENMP_400 ones, follows\n    by the others.  */\n@@ -2729,7 +2729,7 @@ gomp_target_init (void)\n   num_devices = 0;\n   devices = NULL;\n \n-  cur = OFFLOAD_TARGETS;\n+  cur = OFFLOAD_PLUGINS;\n   if (*cur)\n     do\n       {"}, {"sha": "7e0e830b240698a665e434b6d714a47e59b09f78", "filename": "libgomp/testsuite/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.in?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -271,7 +271,7 @@ mkdir_p = @mkdir_p@\n multi_basedir = @multi_basedir@\n offload_additional_lib_paths = @offload_additional_lib_paths@\n offload_additional_options = @offload_additional_options@\n-offload_targets = @offload_targets@\n+offload_plugins = @offload_plugins@\n oldincludedir = @oldincludedir@\n pdfdir = @pdfdir@\n prefix = @prefix@"}, {"sha": "766e9ddd95b9691d8558e9f32052fd0bfd7369e9", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -41,19 +41,19 @@ load_gcc_lib fortran-modules.exp\n # Try to load a test support file, built during libgomp configuration.\n load_file libgomp-test-support.exp\n \n-# Populate offload_targets_s (offloading targets separated by a space), and\n-# offload_targets_s_openacc (the same, but with OpenACC names; OpenACC spells\n-# some of them a little differently).\n-set offload_targets_s [split $offload_targets \",\"]\n-set offload_targets_s_openacc {}\n-foreach offload_target_openacc $offload_targets_s {\n+# Populate offload_plugins_s (offload plugins, separated by a space), and\n+# openacc_device_types_s (OpenACC device type names for suitable offload\n+# plugins, separated by a space).\n+set offload_plugins_s [split $offload_plugins \",\"]\n+set openacc_device_types_s {}\n+foreach offload_plugin $offload_plugins_s {\n     # Translate to OpenACC names, or skip if not yet supported.\n-    switch $offload_target_openacc {\n+    switch $offload_plugin {\n \tintelmic {\n \t    continue\n \t}\n \tnvptx {\n-\t    set offload_target_openacc \"nvidia\"\n+\t    set offload_plugin \"nvidia\"\n \t}\n \thsa {\n \t    continue\n@@ -62,9 +62,9 @@ foreach offload_target_openacc $offload_targets_s {\n \t    error \"Unknown offload target: $offload_target_openacc\"\n \t}\n     }\n-    lappend offload_targets_s_openacc \"$offload_target_openacc\"\n+    lappend openacc_device_types_s \"$offload_plugin\"\n }\n-lappend offload_targets_s_openacc \"host\"\n+lappend openacc_device_types_s \"host\"\n \n set dg-do-what-default run\n \n@@ -143,9 +143,9 @@ proc libgomp_init { args } {\n     set always_ld_library_path \".:${blddir}/.libs\"\n \n     # Add liboffloadmic build directory in LD_LIBRARY_PATH to support\n-    # non-fallback testing for Intel MIC targets\n-    global offload_targets\n-    if { [string match \"*,intelmic,*\" \",$offload_targets,\"] } {\n+    # Intel MIC offloading testing.\n+    global offload_plugins\n+    if { [string match \"*,intelmic,*\" \",$offload_plugins,\"] } {\n \tappend always_ld_library_path \":${blddir}/../liboffloadmic/.libs\"\n \tappend always_ld_library_path \":${blddir}/../liboffloadmic/plugin/.libs\"\n \t# libstdc++ is required by liboffloadmic\n@@ -249,8 +249,7 @@ proc libgomp_init { args } {\n     # Disable color diagnostics\n     lappend ALWAYS_CFLAGS \"additional_flags=-fdiagnostics-color=never\"\n \n-    # Used for support non-fallback offloading.\n-    # Help GCC to find target mkoffload.\n+    # Help GCC to find offload compilers' 'mkoffload'.\n     global offload_additional_options\n     if { $offload_additional_options != \"\" } {\n \tlappend ALWAYS_CFLAGS \"additional_flags=${offload_additional_options}\"\n@@ -366,11 +365,11 @@ proc check_effective_target_offload_device_shared_as { } {\n     } ]\n }\n \n-# Return 1 if configured for nvptx offloading.\n+# Return 1 if configured for 'nvptx' offloading.\n \n proc check_effective_target_openacc_nvidia_accel_configured { } {\n-    global offload_targets\n-    if { ![string match \"*,nvptx,*\" \",$offload_targets,\"] } {\n+    global offload_plugins\n+    if { ![string match \"*,nvptx,*\" \",$offload_plugins,\"] } {\n         return 0\n     }\n     # PR libgomp/65099: Currently, we only support offloading in 64-bit\n@@ -389,29 +388,22 @@ proc check_effective_target_openacc_nvidia_accel_present { } {\n     } \"\" ]\n }\n \n-# Return 1 if at least one Nvidia GPU is accessible, and the nvidia device type\n-# is selected by default by means of setting the environment variable\n-# ACC_DEVICE_TYPE.\n+# Return 1 if at least one Nvidia GPU is accessible, and the OpenACC 'nvidia'\n+# device type is selected.\n \n proc check_effective_target_openacc_nvidia_accel_selected { } {\n     if { ![check_effective_target_openacc_nvidia_accel_present] } {\n \treturn 0;\n     }\n-    global offload_target_openacc\n-    if { $offload_target_openacc == \"nvidia\" } {\n-        return 1;\n-    }\n-    return 0;\n+    global openacc_device_type\n+    return [string match \"nvidia\" $openacc_device_type]\n }\n \n-# Return 1 if the host target is selected for offloaded\n+# Return 1 if the OpenACC 'host' device type is selected.\n \n proc check_effective_target_openacc_host_selected { } {\n-    global offload_target_openacc\n-    if { $offload_target_openacc == \"host\" } {\n-        return 1;\n-    }\n-    return 0;\n+    global openacc_device_type\n+    return [string match \"host\" $openacc_device_type]\n }\n \n # Return 1 if the selected OMP device is actually a HSA device"}, {"sha": "6cf31ae4bf9a786708322a17f3115820cae0c3e2", "filename": "libgomp/testsuite/libgomp-test-support.exp.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -2,4 +2,4 @@ set cuda_driver_include \"@CUDA_DRIVER_INCLUDE@\"\n set cuda_driver_lib \"@CUDA_DRIVER_LIB@\"\n set hsa_runtime_lib \"@HSA_RUNTIME_LIB@\"\n \n-set offload_targets \"@offload_targets@\"\n+set offload_plugins \"@offload_plugins@\""}, {"sha": "0854f60c8faaa2a0f9d4020a50522f1364ab4f8b", "filename": "libgomp/testsuite/libgomp.oacc-c++/c++.exp", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -77,18 +77,19 @@ if { $lang_test_file_found } {\n \tset libstdcxx_includes \"\"\n     }\n \n-    # Test OpenACC with available accelerators.\n-    foreach offload_target_openacc $offload_targets_s_openacc {\n-\tset tagopt \"-DACC_DEVICE_TYPE_$offload_target_openacc=1\"\n+    # Test with available OpenACC device types.\n+    global openacc_device_type\n+    foreach openacc_device_type $openacc_device_types_s {\n+\tset tagopt \"-DACC_DEVICE_TYPE_$openacc_device_type=1\"\n \n-\tswitch $offload_target_openacc {\n+\tswitch $openacc_device_type {\n \t    host {\n \t\tset acc_mem_shared 1\n \t    }\n \t    nvidia {\n \t\tif { ![check_effective_target_openacc_nvidia_accel_present] } {\n \t\t    # Don't bother; execution testing is going to FAIL.\n-\t\t    untested \"$subdir $offload_target_openacc offloading: supported, but hardware not accessible\"\n+\t\t    untested \"$subdir $openacc_device_type offloading: supported, but hardware not accessible\"\n \t\t    continue\n \t\t}\n \n@@ -101,12 +102,12 @@ if { $lang_test_file_found } {\n \t\tset acc_mem_shared 0\n \t    }\n \t    default {\n-\t\terror \"Unknown OpenACC device type: $offload_target_openacc\"\n+\t\terror \"Unknown OpenACC device type: $openacc_device_type\"\n \t    }\n \t}\n \tset tagopt \"$tagopt -DACC_MEM_SHARED=$acc_mem_shared\"\n \n-\tsetenv ACC_DEVICE_TYPE $offload_target_openacc\n+\tsetenv ACC_DEVICE_TYPE $openacc_device_type\n \n \t# To get better test coverage for device-specific code that is only\n \t# ever used in offloading configurations, we'd like more thorough\n@@ -115,7 +116,7 @@ if { $lang_test_file_found } {\n \t# -O0 and -O2 only, to avoid testing times exploding too much, under\n \t# the assumption that between -O0 and -O[something] there is the\n \t# biggest difference in the overall structure of the generated code.\n-\tswitch $offload_target_openacc {\n+\tswitch $openacc_device_type {\n \t    host {\n \t\tset-torture-options [list \\\n \t\t\t\t\t { -O2 } ]"}, {"sha": "2e0c050d6dec949fe4ae7dedac09c98bb0047699", "filename": "libgomp/testsuite/libgomp.oacc-c/c.exp", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2Fc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2Fc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2Fc.exp?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -38,20 +38,21 @@ set ld_library_path $always_ld_library_path\n append ld_library_path [gcc-set-multilib-library-path $GCC_UNDER_TEST]\n set_ld_library_path_env_vars\n \n-# Test OpenACC with available accelerators.\n+# Test with available OpenACC device types.\n set SAVE_ALWAYS_CFLAGS \"$ALWAYS_CFLAGS\"\n-foreach offload_target_openacc $offload_targets_s_openacc {\n+global openacc_device_type\n+foreach openacc_device_type $openacc_device_types_s {\n     set ALWAYS_CFLAGS \"$SAVE_ALWAYS_CFLAGS\"\n-    set tagopt \"-DACC_DEVICE_TYPE_$offload_target_openacc=1\"\n+    set tagopt \"-DACC_DEVICE_TYPE_$openacc_device_type=1\"\n \n-    switch $offload_target_openacc {\n+    switch $openacc_device_type {\n \thost {\n \t    set acc_mem_shared 1\n \t}\n \tnvidia {\n \t    if { ![check_effective_target_openacc_nvidia_accel_present] } {\n \t\t# Don't bother; execution testing is going to FAIL.\n-\t\tuntested \"$subdir $offload_target_openacc offloading: supported, but hardware not accessible\"\n+\t\tuntested \"$subdir $openacc_device_type offloading: supported, but hardware not accessible\"\n \t\tcontinue\n \t    }\n \n@@ -64,12 +65,12 @@ foreach offload_target_openacc $offload_targets_s_openacc {\n \t    set acc_mem_shared 0\n \t}\n \tdefault {\n-\t    error \"Unknown OpenACC device type: $offload_target_openacc\"\n+\t    error \"Unknown OpenACC device type: $openacc_device_type\"\n \t}\n     }\n     set tagopt \"$tagopt -DACC_MEM_SHARED=$acc_mem_shared\"\n \n-    setenv ACC_DEVICE_TYPE $offload_target_openacc\n+    setenv ACC_DEVICE_TYPE $openacc_device_type\n \n     # To get better test coverage for device-specific code that is only\n     # ever used in offloading configurations, we'd like more thorough\n@@ -78,7 +79,7 @@ foreach offload_target_openacc $offload_targets_s_openacc {\n     # -O0 and -O2 only, to avoid testing times exploding too much, under\n     # the assumption that between -O0 and -O[something] there is the\n     # biggest difference in the overall structure of the generated code.\n-    switch $offload_target_openacc {\n+    switch $openacc_device_type {\n \thost {\n \t    set-torture-options [list \\\n \t\t\t\t     { -O2 } ]"}, {"sha": "83f4f6b47d8adfe091f6a2401227f7c45d224abd", "filename": "libgomp/testsuite/libgomp.oacc-fortran/fortran.exp", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffortran.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee332b4a9a19552d160a23155f59b11692d8f07e/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffortran.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Ffortran.exp?ref=ee332b4a9a19552d160a23155f59b11692d8f07e", "patch": "@@ -65,30 +65,31 @@ if { $lang_test_file_found } {\n     append ld_library_path [gcc-set-multilib-library-path $GCC_UNDER_TEST]\n     set_ld_library_path_env_vars\n \n-    # Test OpenACC with available accelerators.\n-    foreach offload_target_openacc $offload_targets_s_openacc {\n-\tset tagopt \"-DACC_DEVICE_TYPE_$offload_target_openacc=1\"\n+    # Test with available OpenACC device types.\n+    global openacc_device_type\n+    foreach openacc_device_type $openacc_device_types_s {\n+\tset tagopt \"-DACC_DEVICE_TYPE_$openacc_device_type=1\"\n \n-\tswitch $offload_target_openacc {\n+\tswitch $openacc_device_type {\n \t    host {\n \t\tset acc_mem_shared 1\n \t    }\n \t    nvidia {\n \t\tif { ![check_effective_target_openacc_nvidia_accel_present] } {\n \t\t    # Don't bother; execution testing is going to FAIL.\n-\t\t    untested \"$subdir $offload_target_openacc offloading: supported, but hardware not accessible\"\n+\t\t    untested \"$subdir $openacc_device_type offloading: supported, but hardware not accessible\"\n \t\t    continue\n \t\t}\n \n \t\tset acc_mem_shared 0\n \t    }\n \t    default {\n-\t\terror \"Unknown OpenACC device type: $offload_target_openacc\"\n+\t\terror \"Unknown OpenACC device type: $openacc_device_type\"\n \t    }\n \t}\n \tset tagopt \"$tagopt -DACC_MEM_SHARED=$acc_mem_shared\"\n \n-\tsetenv ACC_DEVICE_TYPE $offload_target_openacc\n+\tsetenv ACC_DEVICE_TYPE $openacc_device_type\n \n \t# For Fortran we're doing torture testing, as Fortran has far more tests\n \t# with arrays etc. that testing just -O0 or -O2 is insufficient, that is"}]}