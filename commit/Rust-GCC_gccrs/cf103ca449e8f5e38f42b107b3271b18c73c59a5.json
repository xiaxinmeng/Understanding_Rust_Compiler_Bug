{"sha": "cf103ca449e8f5e38f42b107b3271b18c73c59a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YxMDNjYTQ0OWU4ZjVlMzhmNDJiMTA3YjMyNzFiMThjNzNjNTlhNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-04-07T21:11:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-04-07T21:11:51Z"}, "message": "basic-block.h (force_nonfallthru): Move to...\n\n\t* basic-block.h (force_nonfallthru): Move to...\n\t* cfghooks.h (struct cfg_hooks): Add force_nonfallthru hook.\n\t(force_nonfallthru): ...here.\n\t* cfghooks.c (force_nonfallthru): New function.\n\t* cfgrtl.c (force_nonfallthru): Rename into...\n\t(rtl_force_nonfallthru): ...this.\n\t(commit_one_edge_insertion): Do not set AUX field.\n\t(commit_edge_insertions): Do not discover new basic blocks.\n\t(rtl_cfg_hooks): Add rtl_force_nonfallthru.\n\t(cfg_layout_rtl_cfg_hooks): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Remove bogus\n\tATTRIBUTE_UNUSED.  Discover new basic blocks in the prologue insns.\n\t* tree-cfg.c (gimple_cfg_hooks): Add NULL for force_nonfallthru.\n\nFrom-SVN: r172128", "tree": {"sha": "145e2606d4e9bb3d9ec4665487247f62c68485dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/145e2606d4e9bb3d9ec4665487247f62c68485dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf103ca449e8f5e38f42b107b3271b18c73c59a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf103ca449e8f5e38f42b107b3271b18c73c59a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf103ca449e8f5e38f42b107b3271b18c73c59a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf103ca449e8f5e38f42b107b3271b18c73c59a5/comments", "author": null, "committer": null, "parents": [{"sha": "df9292840d1a59a7eee79d70fb38bafabd6049fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df9292840d1a59a7eee79d70fb38bafabd6049fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df9292840d1a59a7eee79d70fb38bafabd6049fa"}], "stats": {"total": 125, "additions": 78, "deletions": 47}, "files": [{"sha": "2c180856c1c3e32d96ae850cdf3db9910eb75308", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf103ca449e8f5e38f42b107b3271b18c73c59a5", "patch": "@@ -1,3 +1,19 @@\n+2011-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* basic-block.h (force_nonfallthru): Move to...\n+\t* cfghooks.h (struct cfg_hooks): Add force_nonfallthru hook.\n+\t(force_nonfallthru): ...here.\n+\t* cfghooks.c (force_nonfallthru): New function.\n+\t* cfgrtl.c (force_nonfallthru): Rename into...\n+\t(rtl_force_nonfallthru): ...this.\n+\t(commit_one_edge_insertion): Do not set AUX field.\n+\t(commit_edge_insertions): Do not discover new basic blocks.\n+\t(rtl_cfg_hooks): Add rtl_force_nonfallthru.\n+\t(cfg_layout_rtl_cfg_hooks): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Remove bogus\n+\tATTRIBUTE_UNUSED.  Discover new basic blocks in the prologue insns.\n+\t* tree-cfg.c (gimple_cfg_hooks): Add NULL for force_nonfallthru.\n+\n 2011-04-07  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/mips/mips.h (REG_MODE_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P):"}, {"sha": "946fe9d2ba1ff7c0bc56fba47b8164156b06fc44", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=cf103ca449e8f5e38f42b107b3271b18c73c59a5", "patch": "@@ -794,7 +794,6 @@ extern void flow_nodes_print (const char *, const_sbitmap, FILE *);\n extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n \n /* In cfgrtl.c  */\n-extern basic_block force_nonfallthru (edge);\n extern rtx block_label (basic_block);\n extern bool purge_all_dead_edges (void);\n extern bool purge_dead_edges (basic_block);"}, {"sha": "34685f4444adbf7ee45ca0081be93881c121852f", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=cf103ca449e8f5e38f42b107b3271b18c73c59a5", "patch": "@@ -398,8 +398,7 @@ redirect_edge_and_branch_force (edge e, basic_block dest)\n     rescan_loop_exit (e, false, true);\n \n   ret = cfg_hooks->redirect_edge_and_branch_force (e, dest);\n-  if (ret != NULL\n-      && dom_info_available_p (CDI_DOMINATORS))\n+  if (ret != NULL && dom_info_available_p (CDI_DOMINATORS))\n     set_immediate_dominator (CDI_DOMINATORS, ret, src);\n \n   if (current_loops != NULL)\n@@ -820,6 +819,8 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n   return fallthru;\n }\n \n+/* Try to make the edge fallthru.  */\n+\n void\n tidy_fallthru_edge (edge e)\n {\n@@ -874,6 +875,42 @@ tidy_fallthru_edges (void)\n     }\n }\n \n+/* Edge E is assumed to be fallthru edge.  Emit needed jump instruction\n+   (and possibly create new basic block) to make edge non-fallthru.\n+   Return newly created BB or NULL if none.  */\n+\n+basic_block\n+force_nonfallthru (edge e)\n+{\n+  basic_block ret, src = e->src, dest = e->dest;\n+  struct loop *loop;\n+\n+  if (!cfg_hooks->force_nonfallthru)\n+    internal_error (\"%s does not support force_nonfallthru\",\n+\t\t    cfg_hooks->name);\n+\n+  if (current_loops != NULL)\n+    rescan_loop_exit (e, false, true);\n+\n+  ret = cfg_hooks->force_nonfallthru (e);\n+  if (ret != NULL && dom_info_available_p (CDI_DOMINATORS))\n+    set_immediate_dominator (CDI_DOMINATORS, ret, src);\n+\n+  if (current_loops != NULL)\n+    {\n+      if (ret != NULL)\n+\t{\n+\t  loop = find_common_loop (single_pred (ret)->loop_father,\n+\t\t\t\t   single_succ (ret)->loop_father);\n+\t  add_bb_to_loop (ret, loop);\n+\t}\n+      else if (find_edge (src, dest) == e)\n+\trescan_loop_exit (e, true, false);\n+    }\n+\n+  return ret;\n+}\n+\n /* Returns true if we can duplicate basic block BB.  */\n \n bool"}, {"sha": "9fd81acb0d3f3021f7e2b163b198bcde830ba909", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=cf103ca449e8f5e38f42b107b3271b18c73c59a5", "patch": "@@ -85,9 +85,12 @@ struct cfg_hooks\n   basic_block (*split_edge) (edge);\n   void (*make_forwarder_block) (edge);\n \n-  /* Tries to make the edge fallthru.  */\n+  /* Try to make the edge fallthru.  */\n   void (*tidy_fallthru_edge) (edge);\n \n+  /* Make the edge non-fallthru.  */\n+  basic_block (*force_nonfallthru) (edge);\n+\n   /* Say whether a block ends with a call, possibly followed by some\n      other code that must stay with the call.  */\n   bool (*block_ends_with_call_p) (basic_block);\n@@ -156,6 +159,7 @@ extern bool can_merge_blocks_p (basic_block, basic_block);\n extern void merge_blocks (basic_block, basic_block);\n extern edge make_forwarder_block (basic_block, bool (*)(edge),\n \t\t\t\t  void (*) (basic_block));\n+extern basic_block force_nonfallthru (edge);\n extern void tidy_fallthru_edge (edge);\n extern void tidy_fallthru_edges (void);\n extern void predict_edge (edge e, enum br_predictor predictor, int probability);"}, {"sha": "c450ca005a0e0872d7fabf75b7f55c0144cc9fe7", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=cf103ca449e8f5e38f42b107b3271b18c73c59a5", "patch": "@@ -1279,8 +1279,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n    (and possibly create new basic block) to make edge non-fallthru.\n    Return newly created BB or NULL if none.  */\n \n-basic_block\n-force_nonfallthru (edge e)\n+static basic_block\n+rtl_force_nonfallthru (edge e)\n {\n   return force_nonfallthru_and_redirect (e, e->dest);\n }\n@@ -1566,10 +1566,6 @@ commit_one_edge_insertion (edge e)\n     }\n   else\n     gcc_assert (!JUMP_P (last));\n-\n-  /* Mark the basic block for find_many_sub_basic_blocks.  */\n-  if (current_ir_type () != IR_RTL_CFGLAYOUT)\n-    bb->aux = &bb->aux;\n }\n \n /* Update the CFG for all queued instructions.  */\n@@ -1578,8 +1574,6 @@ void\n commit_edge_insertions (void)\n {\n   basic_block bb;\n-  sbitmap blocks;\n-  bool changed = false;\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n@@ -1592,35 +1586,8 @@ commit_edge_insertions (void)\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->insns.r)\n-\t  {\n-\t    changed = true;\n-\t    commit_one_edge_insertion (e);\n-\t  }\n+\t  commit_one_edge_insertion (e);\n     }\n-\n-  if (!changed)\n-    return;\n-\n-  /* In the old rtl CFG API, it was OK to insert control flow on an\n-     edge, apparently?  In cfglayout mode, this will *not* work, and\n-     the caller is responsible for making sure that control flow is\n-     valid at all times.  */\n-  if (current_ir_type () == IR_RTL_CFGLAYOUT)\n-    return;\n-\n-  blocks = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (blocks);\n-  FOR_EACH_BB (bb)\n-    if (bb->aux)\n-      {\n-\tSET_BIT (blocks, bb->index);\n-\t/* Check for forgotten bb->aux values before commit_edge_insertions\n-\t   call.  */\n-\tgcc_assert (bb->aux == &bb->aux);\n-\tbb->aux = NULL;\n-      }\n-  find_many_sub_basic_blocks (blocks);\n-  sbitmap_free (blocks);\n }\n \f\n \n@@ -3233,6 +3200,7 @@ struct cfg_hooks rtl_cfg_hooks = {\n   rtl_split_edge,\n   rtl_make_forwarder_block,\n   rtl_tidy_fallthru_edge,\n+  rtl_force_nonfallthru,\n   rtl_block_ends_with_call_p,\n   rtl_block_ends_with_condjump_p,\n   rtl_flow_call_edges_add,\n@@ -3276,7 +3244,8 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   cfg_layout_duplicate_bb,\n   cfg_layout_split_edge,\n   rtl_make_forwarder_block,\n-  NULL,\n+  NULL, /* tidy_fallthru_edge */\n+  rtl_force_nonfallthru,\n   rtl_block_ends_with_call_p,\n   rtl_block_ends_with_condjump_p,\n   rtl_flow_call_edges_add,"}, {"sha": "14d21c97a42595d3041aa231a7973882feb37bb3", "filename": "gcc/function.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=cf103ca449e8f5e38f42b107b3271b18c73c59a5", "patch": "@@ -5295,8 +5295,7 @@ thread_prologue_and_epilogue_insns (void)\n {\n   bool inserted;\n   rtx seq ATTRIBUTE_UNUSED, epilogue_end ATTRIBUTE_UNUSED;\n-  edge entry_edge ATTRIBUTE_UNUSED;\n-  edge e;\n+  edge entry_edge, e;\n   edge_iterator ei;\n \n   rtl_profile_for_bb (ENTRY_BLOCK_PTR);\n@@ -5328,10 +5327,6 @@ thread_prologue_and_epilogue_insns (void)\n       record_insns (seq, NULL, &prologue_insn_hash);\n       set_insn_locators (seq, prologue_locator);\n \n-      /* This relies on the fact that committing the edge insertion\n-\t will look for basic blocks within the inserted instructions,\n-\t which in turn relies on the fact that we are not in CFG\n-\t layout mode here.  */\n       insert_insn_on_edge (seq, entry_edge);\n       inserted = true;\n #endif\n@@ -5566,13 +5561,23 @@ thread_prologue_and_epilogue_insns (void)\n \t  cur_bb->aux = cur_bb->next_bb;\n       cfg_layout_finalize ();\n     }\n+\n epilogue_done:\n   default_rtl_profile ();\n \n   if (inserted)\n     {\n+      sbitmap blocks;\n+\n       commit_edge_insertions ();\n \n+      /* Look for basic blocks within the prologue insns.  */\n+      blocks = sbitmap_alloc (last_basic_block);\n+      sbitmap_zero (blocks);\n+      SET_BIT (blocks, entry_edge->dest->index);\n+      find_many_sub_basic_blocks (blocks);\n+      sbitmap_free (blocks);\n+\n       /* The epilogue insns we inserted may cause the exit edge to no longer\n \t be fallthru.  */\n       FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)"}, {"sha": "e6dac6fa0e294ecc75afe528e30c5f147c5904be", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf103ca449e8f5e38f42b107b3271b18c73c59a5/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=cf103ca449e8f5e38f42b107b3271b18c73c59a5", "patch": "@@ -7135,6 +7135,7 @@ struct cfg_hooks gimple_cfg_hooks = {\n   gimple_split_edge,\t\t/* split_edge  */\n   gimple_make_forwarder_block,\t/* make_forward_block  */\n   NULL,\t\t\t\t/* tidy_fallthru_edge  */\n+  NULL,\t\t\t\t/* force_nonfallthru */\n   gimple_block_ends_with_call_p,/* block_ends_with_call_p */\n   gimple_block_ends_with_condjump_p, /* block_ends_with_condjump_p */\n   gimple_flow_call_edges_add,   /* flow_call_edges_add */"}]}