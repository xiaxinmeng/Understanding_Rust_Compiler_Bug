{"sha": "1a26b032d0adf5fc3e1f68c763eed4f304e1941f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEyNmIwMzJkMGFkZjVmYzNlMWY2OGM3NjNlZWQ0ZjMwNGUxOTQxZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:53:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:53:26Z"}, "message": "(try_combine): When removing REG_UNUSED note, update reg_n_deaths.\n\nLikewise, when making new REG_DEAD notes for distribute_notes.\n(remove_death, move_deaths): Update reg_n_deaths.\n(distribute_notes): When placing second REG_DEAD or REG_UNUSED note or\nignoring such a note, update reg_n_deaths.\n\n(simplify_comparison, case ASHIFT): Fix typo.\n\n(try_combine): The insns made by a DEFINE_SPLIT might contain a PARALLEL and\nthe call to recog_for_combine might add it.\n\n\n(combine_instructions): Clear significant_valid at end of combine pass for\na function.\n(find_split_point, case MEM): See if first operand of the PLUS that makes\nup an address is complex.\n(subst): Add missing arg to recursive calls when IF_THEN_ELSE is an arg\nof an operator.\n(subst, case IF_THEN_ELSE): Generalize code to propagate comparison result\ninto arms by using known_cond.\nIf an arm is the first operand of the comparison, make it the true arm.\nRemove unneeded comparison when arms are identical.\nTry to convert IF_THEN_ELSE to ABS, (neg (abs X)), [US]MIN, [US]MAX.\nConvert (if_then_else (ne A 0) (OP X C) X) to (OP X (mult A C)).\n(subst, case SET): If we don't have conditional moves, convert IF_THEN_ELSE\ninto logical operations.\n(subst, case AND): Always make conditional moves, even if we don't support\nthem on the machine.\n(known_cond, extended_count): New functions.\n(gen_binary): For commutative operations, put constant last.\n\nFrom-SVN: r2182", "tree": {"sha": "e9cc042a82f6417cdd76a21c3b3fffe3256c781c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9cc042a82f6417cdd76a21c3b3fffe3256c781c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a26b032d0adf5fc3e1f68c763eed4f304e1941f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a26b032d0adf5fc3e1f68c763eed4f304e1941f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a26b032d0adf5fc3e1f68c763eed4f304e1941f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a26b032d0adf5fc3e1f68c763eed4f304e1941f/comments", "author": null, "committer": null, "parents": [{"sha": "0e91429a56d8c737cd6b6f2e60c62a21de0a31d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6"}], "stats": {"total": 526, "additions": 466, "deletions": 60}, "files": [{"sha": "e082a1206bc7c77cbca1f1afd9e91b25ae5cdcb3", "filename": "gcc/combine.c", "status": "modified", "additions": 466, "deletions": 60, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a26b032d0adf5fc3e1f68c763eed4f304e1941f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a26b032d0adf5fc3e1f68c763eed4f304e1941f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=1a26b032d0adf5fc3e1f68c763eed4f304e1941f", "patch": "@@ -261,9 +261,9 @@ static enum machine_mode significant_mode;\n static char *reg_sign_bit_copies;\n \n /* Nonzero when reg_significant and reg_sign_bit_copies can be safely used.\n-   It is zero while computing them.  This prevents propagating values based\n-   on previously set values, which can be incorrect if a variable\n-   is modified in a loop.  */\n+   It is zero while computing them and after combine has completed.  This\n+   former test prevents propagating values based on previously set values,\n+   which can be incorrect if a variable is modified in a loop.  */\n \n static int significant_valid;\n \f\n@@ -355,6 +355,7 @@ static rtx expand_field_assignment ();\n static rtx make_extraction ();\n static int get_pos_from_mask ();\n static rtx force_to_mode ();\n+static rtx known_cond ();\n static rtx make_field_assignment ();\n static rtx make_compound_operation ();\n static rtx apply_distributive_law ();\n@@ -552,6 +553,8 @@ combine_instructions (f, nregs)\n   total_merges += combine_merges;\n   total_extras += combine_extras;\n   total_successes += combine_successes;\n+\n+  significant_valid = 0;\n }\n \f\n /* Called via note_stores.  If X is a pseudo that is used in more than\n@@ -1555,9 +1558,13 @@ try_combine (i3, i2, i1)\n \t      || ! use_crosses_set_p (PATTERN (XVECEXP (m_split, 0, 0)),\n \t\t\t\t      INSN_CUID (i2))))\n \t{\n+\t  rtx i2set, i3set;\n \t  rtx newi3pat = PATTERN (XVECEXP (m_split, 0, 1));\n \t  newi2pat = PATTERN (XVECEXP (m_split, 0, 0));\n \n+\t  i2set = single_set (newi2pat);\n+\t  i3set = single_set (newi3pat);\n+\n \t  /* In case we changed the mode of I2DEST, replace it in the\n \t     pseudo-register table here.  We can't do it above in case this\n \t     code doesn't get executed and we do a split the other way.  */\n@@ -1566,7 +1573,11 @@ try_combine (i3, i2, i1)\n \t    SUBST (regno_reg_rtx[REGNO (i2dest)], ni2dest);\n \n \t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n-\t  if (i2_code_number >= 0)\n+\n+\t  /* If I2 or I3 has multiple SETs, we won't know how to track\n+\t     register status, so don't use these insns.  */\n+\n+\t  if (i2_code_number >= 0 && i2set && i3set)\n \t    insn_code_number = recog_for_combine (&newi3pat, i3,\n \t\t\t\t\t\t  &new_i3_notes);\n \n@@ -1577,13 +1588,13 @@ try_combine (i3, i2, i1)\n \t     If so, we must show an extra use of it and update\n \t     reg_significant.  */\n \n-\t  if (insn_code_number >= 0 && GET_CODE (SET_DEST (newpat)) == REG\n-\t      && GET_CODE (SET_DEST (newi2pat)) == REG\n-\t      && REGNO (SET_DEST (newpat)) == REGNO (SET_DEST (newi2pat)))\n+\t  if (insn_code_number >= 0 && GET_CODE (SET_DEST (i3set)) == REG\n+\t      && GET_CODE (SET_DEST (i2set)) == REG\n+\t      && REGNO (SET_DEST (i3set)) == REGNO (SET_DEST (i2set)))\n \t    {\n-\t      reg_n_sets[REGNO (SET_DEST (newpat))]++;\n-\t      set_significant (SET_DEST (newi2pat), newi2pat);\n-\t      set_significant (SET_DEST (newpat), newpat);\n+\t      reg_n_sets[REGNO (SET_DEST (i2set))]++;\n+\t      set_significant (SET_DEST (i2set), i2set);\n+\t      set_significant (SET_DEST (i3set), i3set);\n \t    }\n \t}\n \n@@ -1794,9 +1805,18 @@ try_combine (i3, i2, i1)\n \n \t  if (REG_NOTE_KIND (note) == REG_UNUSED\n \t      && ! reg_set_p (XEXP (note, 0), PATTERN (undobuf.other_insn)))\n-\t    remove_note (undobuf.other_insn, note);\n+\t    {\n+\t      if (GET_CODE (XEXP (note, 0)) == REG)\n+\t\treg_n_deaths[REGNO (XEXP (note, 0))]--;\n+\n+\t      remove_note (undobuf.other_insn, note);\n+\t    }\n \t}\n \n+      for (note = new_other_notes; note; note = XEXP (note, 1))\n+\tif (GET_CODE (XEXP (note, 0)) == REG)\n+\t  reg_n_deaths[REGNO (XEXP (note, 0))]++;\n+\n       distribute_notes (new_other_notes, undobuf.other_insn,\n \t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX);\n     }\n@@ -1924,26 +1944,52 @@ try_combine (i3, i2, i1)\n \n     /* Distribute any notes added to I2 or I3 by recog_for_combine.  We\n        know these are REG_UNUSED and want them to go to the desired insn,\n-       so we always pass it as i3.  */\n+       so we always pass it as i3.  We have not counted the notes in \n+       reg_n_deaths yet, so we need to do so now.  */\n+\n     if (newi2pat && new_i2_notes)\n-      distribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n+      {\n+\tfor (temp = new_i2_notes; temp; temp = XEXP (temp, 1))\n+\t  if (GET_CODE (XEXP (temp, 0)) == REG)\n+\t    reg_n_deaths[REGNO (XEXP (temp, 0))]++;\n+\t\n+\tdistribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n+      }\n+\n     if (new_i3_notes)\n-      distribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n+      {\n+\tfor (temp = new_i3_notes; temp; temp = XEXP (temp, 1))\n+\t  if (GET_CODE (XEXP (temp, 0)) == REG)\n+\t    reg_n_deaths[REGNO (XEXP (temp, 0))]++;\n+\t\n+\tdistribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n+      }\n \n     /* If I3DEST was used in I3SRC, it really died in I3.  We may need to\n-       put a REG_DEAD note for it somewhere.  Similarly for I2 and I1.  */\n+       put a REG_DEAD note for it somewhere.  Similarly for I2 and I1.\n+       Show an additional death due to the REG_DEAD note we make here.  If\n+       we discard it in distribute_notes, we will decrement it again.  */\n \n     if (i3dest_killed)\n-      distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed, NULL_RTX),\n-\t\t\tNULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n-\t\t\tNULL_RTX, NULL_RTX);\n+      {\n+\tif (GET_CODE (i3dest_killed) == REG)\n+\t  reg_n_deaths[REGNO (i3dest_killed)]++;\n+\n+\tdistribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed,\n+\t\t\t\t   NULL_RTX),\n+\t\t\t  NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n+\t\t\t  NULL_RTX, NULL_RTX);\n+      }\n \n     /* For I2 and I1, we have to be careful.  If NEWI2PAT exists and sets\n        I2DEST or I1DEST, the death must be somewhere before I2, not I3.  If\n        we passed I3 in that case, it might delete I2.  */\n \n     if (i2dest_in_i2src)\n       {\n+\tif (GET_CODE (i2dest) == REG)\n+\t  reg_n_deaths[REGNO (i2dest)]++;\n+\n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n \t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i2dest, NULL_RTX),\n \t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n@@ -1955,6 +2001,9 @@ try_combine (i3, i2, i1)\n \n     if (i1dest_in_i1src)\n       {\n+\tif (GET_CODE (i1dest) == REG)\n+\t  reg_n_deaths[REGNO (i1dest)]++;\n+\n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n \t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i1dest, NULL_RTX),\n \t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n@@ -2156,6 +2205,17 @@ find_split_point (loc, insn)\n \t\t  return split;\n \t\t}\n \t    }\n+\t  \n+\t  /* If that didn't work, perhaps the first operand is complex and\n+\t     needs to be computed separately, so make a split point there.\n+\t     This will occur on machines that just support REG + CONST\n+\t     and have a constant moved through some previous computation.  */\n+\n+\t  else if (GET_RTX_CLASS (GET_CODE (XEXP (XEXP (x, 0), 0))) != 'o'\n+\t\t   && ! (GET_CODE (XEXP (XEXP (x, 0), 0)) == SUBREG\n+\t\t\t && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (XEXP (x, 0), 0))))\n+\t\t\t     == 'o')))\n+\t    return &XEXP (XEXP (x, 0), 0);\n \t}\n       break;\n \n@@ -2622,10 +2682,10 @@ subst (x, from, to, in_dest, unique_copy)\n       rtx cond = XEXP (XEXP (x, 0), 0);\n       rtx t_arm = subst (gen_binary (code, mode, XEXP (XEXP (x, 0), 1),\n \t\t\t\t     XEXP (x, 1)),\n-\t\t\t pc_rtx, pc_rtx, 0);\n+\t\t\t pc_rtx, pc_rtx, 0, 0);\n       rtx f_arm = subst (gen_binary (code, mode, XEXP (XEXP (x, 0), 2),\n \t\t\t\t     XEXP (x, 1)),\n-\t\t\t pc_rtx, pc_rtx, 0);\n+\t\t\t pc_rtx, pc_rtx, 0, 0);\n \n \n       x = gen_rtx (IF_THEN_ELSE, mode, cond, t_arm, f_arm);\n@@ -2638,9 +2698,9 @@ subst (x, from, to, in_dest, unique_copy)\n     {\n       rtx cond = XEXP (XEXP (x, 0), 0);\n       rtx t_arm = subst (gen_unary (code, mode, XEXP (XEXP (x, 0), 1)),\n-\t\t\t pc_rtx, pc_rtx, 0);\n+\t\t\t pc_rtx, pc_rtx, 0, 0);\n       rtx f_arm = subst (gen_unary (code, mode, XEXP (XEXP (x, 0), 2)),\n-\t\t\t pc_rtx, pc_rtx, 0);\n+\t\t\t pc_rtx, pc_rtx, 0, 0);\n \n       x = gen_rtx_combine (IF_THEN_ELSE, mode, cond, t_arm, f_arm);\n       goto restart;\n@@ -3306,56 +3366,73 @@ subst (x, from, to, in_dest, unique_copy)\n       break;\n \t  \n     case IF_THEN_ELSE:\n-      /* If we are testing a register for equality see if that register is\n-\t used in one of the arms.  If so, and we know something about its\n-\t value in that arm, try to simplify it.  */\n+      /* Sometimes we can simplify the arm of an IF_THEN_ELSE if a register\n+\t used in it is being compared against certain values.  Get the\n+\t true and false comparisons and see if that says anything about the\n+\t value of each arm.  */\n \n-      if ((GET_CODE (XEXP (x, 0)) == EQ || GET_CODE (XEXP (x, 0)) == NE)\n+      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t  && reversible_comparison_p (XEXP (x, 0))\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG)\n \t{\n-\t  /* Get the value being compared and the value it has on the equal\n-\t     branch.  */\n \t  HOST_WIDE_INT sig;\n \t  rtx from = XEXP (XEXP (x, 0), 0);\n-\t  rtx val_if_eq = XEXP (XEXP (x, 0), 1);\n-\t  rtx val_if_ne = from;\n-\t  int is_eq = (GET_CODE (XEXP (x, 0)) == EQ);\n+\t  enum rtx_code true_code = GET_CODE (XEXP (x, 0));\n+\t  enum rtx_code false_code = reverse_condition (true_code);\n+\t  rtx true_val = XEXP (XEXP (x, 0), 1);\n+\t  rtx false_val = true_val;\n+\t  rtx true_arm = XEXP (x, 1);\n+\t  rtx false_arm = XEXP (x, 2);\n+\t  int swapped = 0;\n+\n+\t  /* If FALSE_CODE is EQ, swap the codes and arms.  */\n+\n+\t  if (false_code == EQ)\n+\t    {\n+\t      swapped = 1, true_code = EQ, false_code = NE;\n+\t      true_arm = XEXP (x, 2), false_arm = XEXP (x, 1);\n+\t    }\n \n-\t  /* If we are comparing against zero and the expressiond being tested\n-\t     has only a single significant bit, that is it's value when it is \n-\t     not equal to zero.  Simplilarly if it is known to be -1 or 0.  */\n+\t  /* If we are comparing against zero and the expression being tested\n+\t     has only a single significant bit, that is its value when it is \n+\t     not equal to zero.  Similarly if it is known to be -1 or 0.  */\n \n-\t  if (val_if_eq == const0_rtx\n+\t  if (true_code == EQ && true_val == const0_rtx\n \t      && exact_log2 (sig = significant_bits (from,\n \t\t\t\t\t\t     GET_MODE (from))) >= 0)\n-\t    val_if_ne = GEN_INT (sig);\n-\t  else if (val_if_eq == const0_rtx\n+\t    false_code = EQ, false_val = GEN_INT (sig);\n+\t  else if (true_code == EQ && true_val == const0_rtx\n \t\t   && (num_sign_bit_copies (from, GET_MODE (from))\n \t\t       == GET_MODE_BITSIZE (GET_MODE (from))))\n-\t    val_if_ne = constm1_rtx;\n+\t    false_code = EQ, false_val = constm1_rtx;\n \n \t  /* Now simplify an arm if we know the value of the register\n \t     in the branch and it is used in the arm.  Be carefull due to\n \t     the potential of locally-shared RTL.  */\n \n-\t  if ((is_eq || val_if_ne != from)\n-\t      && reg_mentioned_p (from, XEXP (x, 1)))\n-\t    SUBST (XEXP (x, 1), subst (copy_rtx (XEXP (x, 1)), from,\n-\t\t\t\t       is_eq ? val_if_eq : val_if_ne, 0));\n-\n-\t  if ((! is_eq || val_if_ne != from)\n-\t      && reg_mentioned_p (from, XEXP (x, 2)))\n-\t    SUBST (XEXP (x, 2), subst (XEXP (x, 2), from,\n-\t\t\t\t       is_eq ? val_if_ne : val_if_eq, 0));\n+\t  if (reg_mentioned_p (from, true_arm))\n+\t    true_arm = subst (known_cond (copy_rtx (true_arm), true_code,\n+\t\t\t\t\t  from, true_val),\n+\t\t\t      pc_rtx, pc_rtx, 0, 0);\n+\t  if (reg_mentioned_p (from, false_arm))\n+\t    false_arm = subst (known_cond (copy_rtx (false_arm), false_code,\n+\t\t\t\t\t   from, false_val),\n+\t\t\t       pc_rtx, pc_rtx, 0, 0);\n+\n+\t  SUBST (XEXP (x, 1), swapped ? false_arm : true_arm);\n+\t  SUBST (XEXP (x, 2), swapped ? true_arm : false_arm);\n \t}\n       \n       /* If we have (if_then_else FOO (pc) (label_ref BAR)) and FOO can be\n \t reversed, do so to avoid needing two sets of patterns for\n \t subtract-and-branch insns.  Similarly if we have a constant in that\n-\t position.  */\n-      if ((XEXP (x, 1) == pc_rtx || GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0)))\n+\t position or if the third operand is the same as the first operand\n+\t of the comparison.  */\n+\n+      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t  && reversible_comparison_p (XEXP (x, 0))\n+\t  && (XEXP (x, 1) == pc_rtx || GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t      || rtx_equal_p (XEXP (x, 2), XEXP (XEXP (x, 0), 0))))\n \t{\n \t  SUBST (XEXP (x, 0),\n \t\t gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n@@ -3366,6 +3443,147 @@ subst (x, from, to, in_dest, unique_copy)\n \t  SUBST (XEXP (x, 1), XEXP (x, 2));\n \t  SUBST (XEXP (x, 2), temp);\n \t}\n+\n+      /* If the two arms are identical, we don't need the comparison.  */\n+\n+      if (rtx_equal_p (XEXP (x, 1), XEXP (x, 2))\n+\t  && ! side_effects_p (XEXP (x, 0)))\n+\treturn XEXP (x, 1);\n+\n+      /* Look for cases where we have (abs x) or (neg (abs X)).  */\n+\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_CODE (XEXP (x, 2)) == NEG\n+\t  && rtx_equal_p (XEXP (x, 1), XEXP (XEXP (x, 2), 0))\n+\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t  && rtx_equal_p (XEXP (x, 1), XEXP (XEXP (x, 0), 0))\n+\t  && ! side_effects_p (XEXP (x, 1)))\n+\tswitch (GET_CODE (XEXP (x, 0)))\n+\t  {\n+\t  case GT:\n+\t  case GE:\n+\t    x = gen_unary (ABS, mode, XEXP (x, 1));\n+\t    goto restart;\n+\t  case LT:\n+\t  case LE:\n+\t    x = gen_unary (NEG, mode, gen_unary (ABS, mode, XEXP (x, 1)));\n+\t    goto restart;\n+\t  }\n+\n+      /* Look for MIN or MAX.  */\n+\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n+\t  && rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n+\t  && rtx_equal_p (XEXP (XEXP (x, 0), 1), XEXP (x, 2))\n+\t  && ! side_effects_p (XEXP (x, 0)))\n+\tswitch (GET_CODE (XEXP (x, 0)))\n+\t  {\n+\t  case GE:\n+\t  case GT:\n+\t    x = gen_binary (SMAX, mode, XEXP (x, 1), XEXP (x, 2));\n+\t    goto restart;\n+\t  case LE:\n+\t  case LT:\n+\t    x = gen_binary (SMIN, mode, XEXP (x, 1), XEXP (x, 2));\n+\t    goto restart;\n+\t  case GEU:\n+\t  case GTU:\n+\t    x = gen_binary (UMAX, mode, XEXP (x, 1), XEXP (x, 2));\n+\t    goto restart;\n+\t  case LEU:\n+\t  case LTU:\n+\t    x = gen_binary (UMIN, mode, XEXP (x, 1), XEXP (x, 2));\n+\t    goto restart;\n+\t  }\n+\n+      /* If we have something like (if_then_else (ne A 0) (OP X C) X),\n+\t A is known to be either 0 or 1, and OP is an identity when its\n+\t second operand is zero, this can be done as (OP X (mult A C)).\n+\t Similarly if A is known to be 0 or -1 and also similarly if we have\n+\t a ZERO_EXTEND or SIGN_EXTEND as long as X is already extended (so\n+\t we don't destroy it).  */\n+\n+      if (mode != VOIDmode\n+\t  && (GET_CODE (XEXP (x, 0)) == EQ || GET_CODE (XEXP (x, 0)) == NE)\n+\t  && XEXP (XEXP (x, 0), 1) == const0_rtx\n+\t  && (significant_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n+\t      || (num_sign_bit_copies (XEXP (XEXP (x, 0), 0), mode)\n+\t\t  == GET_MODE_BITSIZE (mode))))\n+\t{\n+\t  rtx nz = make_compound_operation (GET_CODE (XEXP (x, 0)) == NE\n+\t\t\t\t\t    ? XEXP (x, 1) : XEXP (x, 2));\n+\t  rtx z = GET_CODE (XEXP (x, 0)) == NE ? XEXP (x, 2) : XEXP (x, 1);\n+\t  rtx dir = (significant_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n+\t\t     ? const1_rtx : constm1_rtx);\n+\t  rtx c = 0;\n+\t  enum machine_mode m = mode;\n+\t  enum rtx_code op, extend_op = NULL;\n+\n+\t  if ((GET_CODE (nz) == PLUS || GET_CODE (nz) == MINUS\n+\t       || GET_CODE (nz) == IOR || GET_CODE (nz) == XOR\n+\t       || GET_CODE (nz) == ASHIFT\n+\t       || GET_CODE (nz) == LSHIFTRT || GET_CODE (nz) == ASHIFTRT)\n+\t      && rtx_equal_p (XEXP (nz, 0), z))\n+\t    c = XEXP (nz, 1), op = GET_CODE (nz);\n+\t  else if (GET_CODE (nz) == SIGN_EXTEND\n+\t\t   && (GET_CODE (XEXP (nz, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (nz, 0)) == MINUS\n+\t\t       || GET_CODE (XEXP (nz, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (nz, 0)) == XOR\n+\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFT\n+\t\t       || GET_CODE (XEXP (nz, 0)) == LSHIFTRT\n+\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFTRT)\n+\t\t   && GET_CODE (XEXP (XEXP (nz, 0), 0)) == SUBREG\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (nz, 0), 0))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (nz, 0), 0)), z)\n+\t\t   && (num_sign_bit_copies (z, GET_MODE (z))\n+\t\t       >= (GET_MODE_BITSIZE (mode)\n+\t\t\t   - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (nz, 0), 0))))))\n+\t    {\n+\t      c = XEXP (XEXP (nz, 0), 1);\n+\t      op = GET_CODE (XEXP (nz, 0));\n+\t      extend_op = SIGN_EXTEND;\n+\t      m = GET_MODE (XEXP (nz, 0));\n+\t    }\n+\t  else if (GET_CODE (nz) == ZERO_EXTEND\n+\t\t   && (GET_CODE (XEXP (nz, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (nz, 0)) == MINUS\n+\t\t       || GET_CODE (XEXP (nz, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (nz, 0)) == XOR\n+\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFT\n+\t\t       || GET_CODE (XEXP (nz, 0)) == LSHIFTRT\n+\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFTRT)\n+\t\t   && GET_CODE (XEXP (XEXP (nz, 0), 0)) == SUBREG\n+\t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (nz, 0), 0))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (nz, 0), 0)), z)\n+\t\t   && ((significant_bits (z, GET_MODE (z))\n+\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (nz, 0), 0))))\n+\t\t       == 0))\n+\t    {\n+\t      c = XEXP (XEXP (nz, 0), 1);\n+\t      op = GET_CODE (XEXP (nz, 0));\n+\t      extend_op = ZERO_EXTEND;\n+\t      m = GET_MODE (XEXP (nz, 0));\n+\t    }\n+\n+\t  if (c && ! side_effects_p (c) && ! side_effects_p (z))\n+\t    {\n+\t      temp\n+\t\t= gen_binary (MULT, m,\n+\t\t\t      gen_lowpart_for_combine (m,\n+\t\t\t\t\t\t       XEXP (XEXP (x, 0), 0)),\n+\t\t\t      gen_binary (MULT, m, c, dir));\n+\n+\t      temp = gen_binary (op, m, gen_lowpart_for_combine (m, z), temp);\n+\n+\t      if (extend_op != NULL)\n+\t\ttemp = gen_unary (extend_op, mode, temp);\n+\n+\t      return temp;\n+\t    }\n+\t}\n       break;\n \t  \n     case ZERO_EXTRACT:\n@@ -3571,6 +3789,56 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t\t\t     XEXP (SET_SRC (x), 0)));\n #endif\n \n+#ifndef HAVE_conditional_move\n+\n+      /* If we don't have a conditional move, SET_SRC is an IF_THEN_ELSE,\n+\t and we are comparing an item known to be 0 or -1 against 0, use a\n+\t logical operation instead. Check for one of the arms being an IOR\n+\t of the other arm with some value.  We compute three terms to be\n+\t IOR'ed together.  In practice, at most two will be nonzero.  Then\n+\t we do the IOR's.  */\n+\n+      if (GET_CODE (SET_SRC (x)) == IF_THEN_ELSE\n+\t  && (GET_CODE (XEXP (SET_SRC (x), 0)) == EQ\n+\t      || GET_CODE (XEXP (SET_SRC (x), 0)) == NE)\n+\t  && XEXP (XEXP (SET_SRC (x), 0), 1) == const0_rtx\n+\t  && (num_sign_bit_copies (XEXP (XEXP (SET_SRC (x), 0), 0),\n+\t\t\t\t   GET_MODE (XEXP (XEXP (SET_SRC (x), 0), 0)))\n+\t      == GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (SET_SRC (x), 0), 0))))\n+\t  && ! side_effects_p (SET_SRC (x)))\n+\t{\n+\t  rtx true = (GET_CODE (XEXP (SET_SRC (x), 0)) == NE\n+\t\t      ? XEXP (SET_SRC (x), 1) : XEXP (SET_SRC (x), 2));\n+\t  rtx false = (GET_CODE (XEXP (SET_SRC (x), 0)) == NE\n+\t\t       ? XEXP (SET_SRC (x), 2) : XEXP (SET_SRC (x), 1));\n+\t  rtx term1 = const0_rtx, term2, term3;\n+\n+\t  if (GET_CODE (true) == IOR && rtx_equal_p (XEXP (true, 0), false))\n+\t    term1 = false, true = XEXP (true, 1), false = const0_rtx;\n+\t  else if (GET_CODE (true) == IOR\n+\t\t   && rtx_equal_p (XEXP (true, 1), false))\n+\t    term1 = false, true = XEXP (true, 0), false = const0_rtx;\n+\t  else if (GET_CODE (false) == IOR\n+\t\t   && rtx_equal_p (XEXP (false, 0), true))\n+\t    term1 = true, false = XEXP (false, 1), true = const0_rtx;\n+\t  else if (GET_CODE (false) == IOR\n+\t\t   && rtx_equal_p (XEXP (false, 1), true))\n+\t    term1 = true, false = XEXP (false, 0), true = const0_rtx;\n+\n+\t  term2 = gen_binary (AND, GET_MODE (SET_SRC (x)),\n+\t\t\t      XEXP (XEXP (SET_SRC (x), 0), 0), true);\n+\t  term3 = gen_binary (AND, GET_MODE (SET_SRC (x)),\n+\t\t\t      gen_unary (NOT, GET_MODE (SET_SRC (x)),\n+\t\t\t\t\t XEXP (XEXP (SET_SRC (x), 0), 0)),\n+\t\t\t      false);\n+\n+\t  SUBST (SET_SRC (x),\n+\t\t gen_binary (IOR, GET_MODE (SET_SRC (x)),\n+\t\t\t     gen_binary (IOR, GET_MODE (SET_SRC (x)),\n+\t\t\t\t\t term1, term2),\n+\t\t\t     term3));\n+\t}\n+#endif\n       break;\n \n     case AND:\n@@ -3646,13 +3914,15 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n \t}\n \n-#ifdef HAVE_conditional_move\n-\n       /* If we have (and A B) with A not an object but that is known to\n \t be -1 or 0, this is equivalent to the expression\n \t (if_then_else (ne A (const_int 0)) B (const_int 0))\n \t We make this conversion because it may allow further\n-\t simplifications and then allow use of conditional move insns.  */\n+\t simplifications and then allow use of conditional move insns.\n+\t If the machine doesn't have condition moves, code in case SET\n+\t will convert the IF_THEN_ELSE back to the logical operation.\n+\t We build the IF_THEN_ELSE here in case further simplification\n+\t is possible (e.g., we can convert it to ABS).  */\n \n       if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) != 'o'\n \t  && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n@@ -3670,7 +3940,6 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t\tXEXP (x, 1), const0_rtx);\n \t  goto restart;\n \t}\n-#endif\n \n       /* In the following group of tests (and those in case IOR below),\n \t we start with some combination of logical operations and apply\n@@ -4932,6 +5201,96 @@ force_to_mode (x, mode, bits, reg)\n   return gen_lowpart_for_combine (mode, x);\n }\n \f\n+/* Return the value of expression X given the fact that condition COND\n+   is known to be true when applied to REG as its first operand and VAL\n+   as its second.  X is known to not be shared and so can be modified in\n+   place.\n+\n+   We only handle the simplest cases, and specifically those cases that\n+   arise with IF_THEN_ELSE expressions.  */\n+\n+static rtx\n+known_cond (x, cond, reg, val)\n+     rtx x;\n+     enum rtx_code cond;\n+     rtx reg, val;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  rtx new, temp;\n+  char *fmt;\n+  int i, j;\n+\n+  if (side_effects_p (x))\n+    return x;\n+\n+  if (cond == EQ && rtx_equal_p (x, reg))\n+    return val;\n+\n+  /* If X is (abs REG) and we know something about REG's relationship\n+     with zero, we may be able to simplify this.  */\n+\n+  if (code == ABS && rtx_equal_p (XEXP (x, 0), reg) && val == const0_rtx)\n+    switch (cond)\n+      {\n+      case GE:  case GT:  case EQ:\n+\treturn XEXP (x, 0);\n+      case LT:  case LE:\n+\treturn gen_unary (NEG, GET_MODE (XEXP (x, 0)), XEXP (x, 0));\n+      }\n+\n+  /* The only other cases we handle are MIN, MAX, and comparisons if the\n+     operands are the same as REG and VAL.  */\n+\n+  else if (GET_RTX_CLASS (code) == '<' || GET_RTX_CLASS (code) == 'c')\n+    {\n+      if (rtx_equal_p (XEXP (x, 0), val))\n+\tcond = swap_condition (cond), temp = val, val = reg, reg = temp;\n+\n+      if (rtx_equal_p (XEXP (x, 0), reg) && rtx_equal_p (XEXP (x, 1), val))\n+\t{\n+\t  if (GET_RTX_CLASS (code) == '<')\n+\t    return (comparison_dominates_p (cond, code) ? const_true_rtx\n+\t\t    : (comparison_dominates_p (cond,\n+\t\t\t\t\t       reverse_condition (code))\n+\t\t       ? const0_rtx : x));\n+\n+\t  else if (code == SMAX || code == SMIN\n+\t\t   || code == UMIN || code == UMAX)\n+\t    {\n+\t      int unsignedp = (code == UMIN || code == UMAX);\n+\n+\t      if (code == SMAX || code == UMAX)\n+\t\tcond = reverse_condition (cond);\n+\n+\t      switch (cond)\n+\t\t{\n+\t\tcase GE:   case GT:\n+\t\t  return unsignedp ? x : XEXP (x, 1);\n+\t\tcase LE:   case LT:\n+\t\t  return unsignedp ? x : XEXP (x, 0);\n+\t\tcase GEU:  case GTU:\n+\t\t  return unsignedp ? XEXP (x, 1) : x;\n+\t\tcase LEU:  case LTU:\n+\t\t  return unsignedp ? XEXP (x, 0) : x;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tSUBST (XEXP (x, i), known_cond (XEXP (x, i), cond, reg, val));\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  SUBST (XVECEXP (x, i, j), known_cond (XVECEXP (x, i, j),\n+\t\t\t\t\t\tcond, reg, val));\n+    }\n+\n+  return x;\n+}\n+\f\n /* See if X, a SET operation, can be rewritten as a bit-field assignment.\n    Return that assignment if so.\n \n@@ -5984,6 +6343,32 @@ num_sign_bit_copies (x, mode)\n   return sig == GET_MODE_MASK (mode) ? 1 : bitwidth - floor_log2 (sig) - 1;\n }\n \f\n+/* Return the number of \"extended\" bits there are in X, when interpreted\n+   as a quantity in MODE whose signedness is indicated by UNSIGNEDP.  For\n+   unsigned quantities, this is the number of high-order zero bits.\n+   For signed quantities, this is the number of copies of the sign bit\n+   minus 1.  In both case, this function returns the number of \"spare\"\n+   bits.  For example, if two quantities for which this function returns\n+   at least 1 are added, the addition is known not to overflow.\n+\n+   This function will always return 0 unless called during combine, which\n+   implies that it must be called from a define_split.  */\n+\n+int\n+extended_count (x, mode, unsignedp)\n+     rtx x;\n+     enum machine_mode mode;\n+     int unsignedp;\n+{\n+  if (significant_valid == 0)\n+    return 0;\n+\n+  return (unsignedp\n+\t  ? (GET_MODE_BITSIZE (mode) - 1\n+\t     - floor_log2 (significant_bits (x, mode)))\n+\t  : num_sign_bit_copies (x, mode) - 1);\n+}\n+\f\n /* This function is called from `simplify_shift_const' to merge two\n    outer operations.  Specifically, we have already found that we need\n    to perform operation *POP0 with constant *PCONST0 at the outermost\n@@ -7047,6 +7432,12 @@ gen_binary (code, mode, op0, op1)\n      rtx op0, op1;\n {\n   rtx result;\n+  rtx tem;\n+\n+  if (GET_RTX_CLASS (code) == 'c'\n+      && (GET_CODE (op0) == CONST_INT\n+\t  || (CONSTANT_P (op0) && GET_CODE (op1) != CONST_INT)))\n+    tem = op0, op0 = op1, op1 = tem;\n \n   if (GET_RTX_CLASS (code) == '<') \n     {\n@@ -7804,8 +8195,7 @@ simplify_comparison (code, pop0, pop1)\n \t      && ((INTVAL (XEXP (op0, 1)) + ! equality_comparison_p)\n \t\t  < HOST_BITS_PER_WIDE_INT)\n \t      && ((const_op\n-\t\t   &  ~ (((HOST_WIDE_INT) 1\n-\t\t\t  << INTVAL (XEXP (op0, 1))) - 1)) == 0)\n+\t\t   &  ((HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1))) - 1) == 0)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && (significant_bits (XEXP (op0, 0), mode)\n \t\t  & ~ (mask >> (INTVAL (XEXP (op0, 1))\n@@ -8479,7 +8869,10 @@ remove_death (regno, insn)\n   register rtx note = find_regno_note (insn, REG_DEAD, regno);\n \n   if (note)\n-    remove_note (insn, note);\n+    {\n+      reg_n_deaths[regno]--;\n+      remove_note (insn, note);\n+    }\n \n   return note;\n }\n@@ -8524,6 +8917,8 @@ move_deaths (x, from_cuid, to_insn, pnotes)\n \t    }\n \t  else\n \t    *pnotes = gen_rtx (EXPR_LIST, REG_DEAD, x, *pnotes);\n+\n+\t  reg_n_deaths[regno]++;\n \t}\n \n       return;\n@@ -8960,10 +9355,21 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t  XEXP (note, 1) = REG_NOTES (place);\n \t  REG_NOTES (place) = note;\n \t}\n+      else if ((REG_NOTE_KIND (note) == REG_DEAD\n+\t\t|| REG_NOTE_KIND (note) == REG_UNUSED)\n+\t       && GET_CODE (XEXP (note, 0)) == REG)\n+\treg_n_deaths[REGNO (XEXP (note, 0))]--;\n \n       if (place2)\n-\tREG_NOTES (place2) = gen_rtx (GET_CODE (note), REG_NOTE_KIND (note),\n-\t\t\t\t      XEXP (note, 0), REG_NOTES (place2));\n+\t{\n+\t  if ((REG_NOTE_KIND (note) == REG_DEAD\n+\t       || REG_NOTE_KIND (note) == REG_UNUSED)\n+\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t    reg_n_deaths[REGNO (XEXP (note, 0))]++;\n+\n+\t  REG_NOTES (place2) = gen_rtx (GET_CODE (note), REG_NOTE_KIND (note),\n+\t\t\t\t\tXEXP (note, 0), REG_NOTES (place2));\n+\t}\n     }\n }\n \f"}]}