{"sha": "8ddb5a296eea999c6376f43a643b2baf79cf886a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRkYjVhMjk2ZWVhOTk5YzYzNzZmNDNhNjQzYjJiYWY3OWNmODg2YQ==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-04-08T17:39:10Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-04-08T17:39:10Z"}, "message": "First phase of unifying the computation of profile scale factors/probabilities and the actual scaling to use rounding divides...\n\nFirst phase of unifying the computation of profile scale factors/probabilities\nand the actual scaling to use rounding divides:\n- Add new macro GCOV_COMPUTE_SCALE to basic-block.h to compute the scale\nfactor/probability via a rounding divide.\n- Change all locations that already perform rounding divides (inline or via RDIV)\nto use the appropriate helper: GCOV_COMPUTE_SCALE, apply_probability or\ncombine_probabilities.\n- Change ipa-cp.c truncating divides to use rounding divides.\n- Add comments to all other locations (currently using truncating divides) to\nswitch them to one of the helpers so they use a rounding divide.\n\nNext phase will be to replace the locations using truncating divides, marked\nwith a comment here, into rounding divides via the helper methods.\n\n2013-04-08  Teresa Johnson  <tejohnson@google.com>\n\n\t* basic-block.h (GCOV_COMPUTE_SCALE): Define.\n\t* ipa-inline-analysis.c (param_change_prob): Use helper rounding divide\n        methods.\n\t(estimate_edge_size_and_time): Add comment to suggest using rounding\n\tmethods.\n\t(estimate_node_size_and_time): Ditto.\n\t(remap_edge_change_prob): Use helper rounding divide methods.\n\t* value-prof.c (gimple_divmod_fixed_value_transform): Ditto.\n\t(gimple_mod_pow2_value_transform): Ditto.\n\t(gimple_mod_subtract_transform): Ditto.\n\t(gimple_ic_transform): Ditto.\n\t(gimple_stringops_transform): Ditto.\n\t* stmt.c (conditional_probability): Ditto.\n\t(emit_case_dispatch_table): Ditto.\n\t* lto-cgraph.c (merge_profile_summaries): Ditto.\n\t* tree-optimize.c (execute_fixup_cfg): Ditto.\n\t* cfgcleanup.c (try_forward_edges): Ditto.\n\t* cfgloopmanip.c (scale_loop_profile): Ditto.\n\t(loopify): Ditto.\n\t(duplicate_loop_to_header_edge): Ditto.\n\t(lv_adjust_loop_entry_edge): Ditto.\n\t* tree-vect-loop.c (vect_transform_loop): Ditto.\n\t* profile.c (compute_branch_probabilities): Ditto.\n\t* cfgbuild.c (compute_outgoing_frequencies): Ditto.\n\t* lto-streamer-in.c (input_cfg): Ditto.\n\t* gimple-streamer-in.c (input_bb): Ditto.\n\t* ipa-cp.c (update_profiling_info): Ditto.\n\t(update_specialized_profile): Ditto.\n\t* tree-vect-loop-manip.c (slpeel_tree_peel_loop_to_edge): Ditto.\n\t* cfg.c (update_bb_profile_for_threading): Add comment to suggest using\n        rounding methods.\n\t* sched-rgn.c (compute_dom_prob_ps): Ditto.\n\t(compute_trg_info): Ditto.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): Ditto.\n\t(purge_dead_edges): Ditto.\n\t* loop-unswitch.c (unswitch_loop): Ditto.\n\t* cgraphclones.c (cgraph_clone_edge): Ditto.\n\t(cgraph_clone_node): Ditto.\n\t* tree-inline.c (copy_bb): Ditto.\n\t(copy_edges_for_bb): Ditto.\n\t(initialize_cfun): Ditto.\n\t(copy_cfg_body): Ditto.\n\t(expand_call_inline): Ditto.\n\nFrom-SVN: r197595", "tree": {"sha": "ffb943825496db918422c6ebe357dcdcc5207a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffb943825496db918422c6ebe357dcdcc5207a4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ddb5a296eea999c6376f43a643b2baf79cf886a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ddb5a296eea999c6376f43a643b2baf79cf886a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ddb5a296eea999c6376f43a643b2baf79cf886a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ddb5a296eea999c6376f43a643b2baf79cf886a/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6222d4ef011f80c08fb9619c29619b47daf4feb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6222d4ef011f80c08fb9619c29619b47daf4feb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6222d4ef011f80c08fb9619c29619b47daf4feb"}], "stats": {"total": 227, "additions": 147, "deletions": 80}, "files": [{"sha": "a7ca0455c5c522b0e0e223b5e7b17a0abbad46f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -1,3 +1,49 @@\n+2013-04-08  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* basic-block.h (GCOV_COMPUTE_SCALE): Define.\n+\t* ipa-inline-analysis.c (param_change_prob): Use helper rounding divide\n+        methods.\n+\t(estimate_edge_size_and_time): Add comment to suggest using rounding\n+\tmethods.\n+\t(estimate_node_size_and_time): Ditto.\n+\t(remap_edge_change_prob): Use helper rounding divide methods.\n+\t* value-prof.c (gimple_divmod_fixed_value_transform): Ditto.\n+\t(gimple_mod_pow2_value_transform): Ditto.\n+\t(gimple_mod_subtract_transform): Ditto.\n+\t(gimple_ic_transform): Ditto.\n+\t(gimple_stringops_transform): Ditto.\n+\t* stmt.c (conditional_probability): Ditto.\n+\t(emit_case_dispatch_table): Ditto.\n+\t* lto-cgraph.c (merge_profile_summaries): Ditto.\n+\t* tree-optimize.c (execute_fixup_cfg): Ditto.\n+\t* cfgcleanup.c (try_forward_edges): Ditto.\n+\t* cfgloopmanip.c (scale_loop_profile): Ditto.\n+\t(loopify): Ditto.\n+\t(duplicate_loop_to_header_edge): Ditto.\n+\t(lv_adjust_loop_entry_edge): Ditto.\n+\t* tree-vect-loop.c (vect_transform_loop): Ditto.\n+\t* profile.c (compute_branch_probabilities): Ditto.\n+\t* cfgbuild.c (compute_outgoing_frequencies): Ditto.\n+\t* lto-streamer-in.c (input_cfg): Ditto.\n+\t* gimple-streamer-in.c (input_bb): Ditto.\n+\t* ipa-cp.c (update_profiling_info): Ditto.\n+\t(update_specialized_profile): Ditto.\n+\t* tree-vect-loop-manip.c (slpeel_tree_peel_loop_to_edge): Ditto.\n+\t* cfg.c (update_bb_profile_for_threading): Add comment to suggest using\n+        rounding methods.\n+\t* sched-rgn.c (compute_dom_prob_ps): Ditto.\n+\t(compute_trg_info): Ditto.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): Ditto.\n+\t(purge_dead_edges): Ditto.\n+\t* loop-unswitch.c (unswitch_loop): Ditto.\n+\t* cgraphclones.c (cgraph_clone_edge): Ditto.\n+\t(cgraph_clone_node): Ditto.\n+\t* tree-inline.c (copy_bb): Ditto.\n+\t(copy_edges_for_bb): Ditto.\n+\t(initialize_cfun): Ditto.\n+\t(copy_cfg_body): Ditto.\n+\t(expand_call_inline): Ditto.\n+\n 2013-04-08  Kai Tietz  <ktietz@redhat.com>\n \n \t* config/i386/cygwin.h (EXTRA_OS_CPP_BUILTINS): Replaced"}, {"sha": "9b5192eb877be39317fb9bbd4013a5c07888895a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -499,6 +499,11 @@ struct edge_list\n #define EDGE_FREQUENCY(e)\t\tRDIV ((e)->src->frequency * (e)->probability, \\\n \t\t\t\t\t      REG_BR_PROB_BASE)\n \n+/* Compute a scale factor (or probability) suitable for scaling of\n+   gcov_type values via apply_probability().  */\n+#define GCOV_COMPUTE_SCALE(num,den) \\\n+  ((den) ? RDIV ((num) * REG_BR_PROB_BASE, (den)) : REG_BR_PROB_BASE)\n+\n /* Return nonzero if edge is critical.  */\n #define EDGE_CRITICAL_P(e)\t\t(EDGE_COUNT ((e)->src->succs) >= 2 \\\n \t\t\t\t\t && EDGE_COUNT ((e)->dest->preds) >= 2)"}, {"sha": "2bcd790d306a88e6524ef705e4f837425d3c12d7", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -848,6 +848,7 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n   /* Compute the probability of TAKEN_EDGE being reached via threaded edge.\n      Watch for overflows.  */\n   if (bb->frequency)\n+    /* Update to use GCOV_COMPUTE_SCALE.  */\n     prob = edge_frequency * REG_BR_PROB_BASE / bb->frequency;\n   else\n     prob = 0;"}, {"sha": "ac6aefb86dfbc329b738b75c47d93e85923a5a58", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -545,8 +545,7 @@ compute_outgoing_frequencies (basic_block b)\n \t  probability = INTVAL (XEXP (note, 0));\n \t  e = BRANCH_EDGE (b);\n \t  e->probability = probability;\n-\t  e->count = ((b->count * probability + REG_BR_PROB_BASE / 2)\n-\t\t      / REG_BR_PROB_BASE);\n+\t  e->count = apply_probability (b->count, probability);\n \t  f = FALLTHRU_EDGE (b);\n \t  f->probability = REG_BR_PROB_BASE - probability;\n \t  f->count = b->count - e->count;\n@@ -583,8 +582,7 @@ compute_outgoing_frequencies (basic_block b)\n \n   if (b->count)\n     FOR_EACH_EDGE (e, ei, b->succs)\n-      e->count = ((b->count * e->probability + REG_BR_PROB_BASE / 2)\n-\t\t  / REG_BR_PROB_BASE);\n+      e->count = apply_probability (b->count, e->probability);\n }\n \n /* Assume that some pass has inserted labels or control flow"}, {"sha": "2fcefc60b23403cd43394e960247fce6fd6e0137", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -595,9 +595,7 @@ try_forward_edges (int mode, basic_block b)\n \t  /* We successfully forwarded the edge.  Now update profile\n \t     data: for each edge we traversed in the chain, remove\n \t     the original edge's execution count.  */\n-\t  edge_frequency = ((edge_probability * b->frequency\n-\t\t\t     + REG_BR_PROB_BASE / 2)\n-\t\t\t    / REG_BR_PROB_BASE);\n+\t  edge_frequency = apply_probability (b->frequency, edge_probability);\n \n \t  do\n \t    {"}, {"sha": "13efb7515f905b177333e41dab8d758e9fd619f8", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -502,7 +502,7 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \n   /* See if loop is predicted to iterate too many times.  */\n   if (iteration_bound && iterations > 0\n-      && RDIV (iterations * scale, REG_BR_PROB_BASE) > iteration_bound)\n+      && apply_probability (iterations, scale) > iteration_bound)\n     {\n       /* Fixing loop profile for different trip count is not trivial; the exit\n \t probabilities has to be updated to match and frequencies propagated down\n@@ -563,7 +563,8 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \t      count_in += e->count;\n \n \t  if (count_in != 0)\n-\t    scale = RDIV (count_in * iteration_bound * REG_BR_PROB_BASE, loop->header->count);\n+\t    scale = GCOV_COMPUTE_SCALE (count_in * iteration_bound,\n+                                        loop->header->count);\n \t}\n       else if (loop->header->frequency)\n \t{\n@@ -574,7 +575,8 @@ scale_loop_profile (struct loop *loop, int scale, gcov_type iteration_bound)\n \t      freq_in += EDGE_FREQUENCY (e);\n \n \t  if (freq_in != 0)\n-\t    scale = RDIV (freq_in * iteration_bound * REG_BR_PROB_BASE, loop->header->frequency);\n+\t    scale = GCOV_COMPUTE_SCALE (freq_in * iteration_bound,\n+                                        loop->header->frequency);\n \t}\n       if (!scale)\n \tscale = 1;\n@@ -890,7 +892,7 @@ loopify (edge latch_edge, edge header_edge,\n       switch_bb->count = cnt;\n       FOR_EACH_EDGE (e, ei, switch_bb->succs)\n \t{\n-\t  e->count = RDIV (switch_bb->count * e->probability, REG_BR_PROB_BASE);\n+\t  e->count = apply_probability (switch_bb->count, e->probability);\n \t}\n     }\n   scale_loop_frequencies (loop, false_scale, REG_BR_PROB_BASE);\n@@ -1199,8 +1201,9 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t{\n \t  /* The blocks that are dominated by a removed exit edge ORIG have\n \t     frequencies scaled by this.  */\n-\t  scale_after_exit = RDIV (REG_BR_PROB_BASE * REG_BR_PROB_BASE,\n-\t\t\t\t   REG_BR_PROB_BASE - orig->probability);\n+\t  scale_after_exit\n+              = GCOV_COMPUTE_SCALE (REG_BR_PROB_BASE,\n+                                    REG_BR_PROB_BASE - orig->probability);\n \t  bbs_to_scale = BITMAP_ALLOC (NULL);\n \t  for (i = 0; i < n; i++)\n \t    {\n@@ -1231,12 +1234,12 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t     frequency should be reduced by prob_pass_wont_exit.  Caller\n \t     should've managed the flags so all except for original loop\n \t     has won't exist set.  */\n-\t  scale_act = RDIV (wanted_freq * REG_BR_PROB_BASE, freq_in);\n+\t  scale_act = GCOV_COMPUTE_SCALE (wanted_freq, freq_in);\n \t  /* Now simulate the duplication adjustments and compute header\n \t     frequency of the last copy.  */\n \t  for (i = 0; i < ndupl; i++)\n-\t    wanted_freq = RDIV (wanted_freq * scale_step[i], REG_BR_PROB_BASE);\n-\t  scale_main = RDIV (wanted_freq * REG_BR_PROB_BASE, freq_in);\n+\t    wanted_freq = combine_probabilities (wanted_freq, scale_step[i]);\n+\t  scale_main = GCOV_COMPUTE_SCALE (wanted_freq, freq_in);\n \t}\n       else if (is_latch)\n \t{\n@@ -1248,16 +1251,16 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t  for (i = 0; i < ndupl; i++)\n \t    {\n \t      scale_main += p;\n-\t      p = RDIV (p * scale_step[i], REG_BR_PROB_BASE);\n+\t      p = combine_probabilities (p, scale_step[i]);\n \t    }\n-\t  scale_main = RDIV (REG_BR_PROB_BASE * REG_BR_PROB_BASE, scale_main);\n-\t  scale_act = RDIV (scale_main * prob_pass_main, REG_BR_PROB_BASE);\n+\t  scale_main = GCOV_COMPUTE_SCALE (REG_BR_PROB_BASE, scale_main);\n+\t  scale_act = combine_probabilities (scale_main, prob_pass_main);\n \t}\n       else\n \t{\n \t  scale_main = REG_BR_PROB_BASE;\n \t  for (i = 0; i < ndupl; i++)\n-\t    scale_main = RDIV (scale_main * scale_step[i], REG_BR_PROB_BASE);\n+\t    scale_main = combine_probabilities (scale_main, scale_step[i]);\n \t  scale_act = REG_BR_PROB_BASE - prob_pass_thru;\n \t}\n       for (i = 0; i < ndupl; i++)\n@@ -1378,7 +1381,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       if (flags & DLTHE_FLAG_UPDATE_FREQ)\n \t{\n \t  scale_bbs_frequencies_int (new_bbs, n, scale_act, REG_BR_PROB_BASE);\n-\t  scale_act = RDIV (scale_act * scale_step[j], REG_BR_PROB_BASE);\n+\t  scale_act = combine_probabilities (scale_act, scale_step[j]);\n \t}\n     }\n   free (new_bbs);\n@@ -1638,8 +1641,8 @@ lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n \t\t  current_ir_type () == IR_GIMPLE ? EDGE_TRUE_VALUE : 0);\n   e1->probability = then_prob;\n   e->probability = REG_BR_PROB_BASE - then_prob;\n-  e1->count = RDIV (e->count * e1->probability, REG_BR_PROB_BASE);\n-  e->count = RDIV (e->count * e->probability, REG_BR_PROB_BASE);\n+  e1->count = apply_probability (e->count, e1->probability);\n+  e->count = apply_probability (e->count, e->probability);\n \n   set_immediate_dominator (CDI_DOMINATORS, first_head, new_head);\n   set_immediate_dominator (CDI_DOMINATORS, second_head, new_head);"}, {"sha": "6e8a31d95da21b8271d1f4d8d5faaefb5f019e4f", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -1362,6 +1362,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)\n \t  int prob = INTVAL (XEXP (note, 0));\n \n \t  b->probability = prob;\n+          /* Update this to use GCOV_COMPUTE_SCALE.  */\n \t  b->count = e->count * prob / REG_BR_PROB_BASE;\n \t  e->probability -= e->probability;\n \t  e->count -= b->count;\n@@ -2675,6 +2676,7 @@ purge_dead_edges (basic_block bb)\n \t  f = FALLTHRU_EDGE (bb);\n \t  b->probability = INTVAL (XEXP (note, 0));\n \t  f->probability = REG_BR_PROB_BASE - b->probability;\n+          /* Update these to use GCOV_COMPUTE_SCALE.  */\n \t  b->count = bb->count * b->probability / REG_BR_PROB_BASE;\n \t  f->count = bb->count * f->probability / REG_BR_PROB_BASE;\n \t}"}, {"sha": "fa6a9113a1e70da280989f7ea373229c6544e7fb", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -102,6 +102,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t\t   int freq_scale, bool update_original)\n {\n   struct cgraph_edge *new_edge;\n+  /* Update this to use GCOV_COMPUTE_SCALE.  */\n   gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n   gcov_type freq;\n \n@@ -204,6 +205,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n       if (new_node->count > n->count)\n         count_scale = REG_BR_PROB_BASE;\n       else\n+        /* Update to use GCOV_COMPUTE_SCALE.  */\n         count_scale = new_node->count * REG_BR_PROB_BASE / n->count;\n     }\n   else"}, {"sha": "a27f0d6d62fd3b983aa1f3694c5628b1ae2c070d", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -329,8 +329,8 @@ input_bb (struct lto_input_block *ib, enum LTO_tags tag,\n   index = streamer_read_uhwi (ib);\n   bb = BASIC_BLOCK_FOR_FUNCTION (fn, index);\n \n-  bb->count = (streamer_read_gcov_count (ib) * count_materialization_scale\n-\t       + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+  bb->count = apply_probability (streamer_read_gcov_count (ib),\n+                                 count_materialization_scale);\n   bb->frequency = streamer_read_hwi (ib);\n   bb->flags = streamer_read_hwi (ib);\n "}, {"sha": "0ca25d286f407751d06bdf2dd9c107d36add2df0", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -2572,14 +2572,16 @@ update_profiling_info (struct cgraph_node *orig_node,\n \n   for (cs = new_node->callees; cs ; cs = cs->next_callee)\n     if (cs->frequency)\n-      cs->count = cs->count * (new_sum * REG_BR_PROB_BASE\n-\t\t\t       / orig_node_count) / REG_BR_PROB_BASE;\n+      cs->count = apply_probability (cs->count,\n+                                     GCOV_COMPUTE_SCALE (new_sum,\n+                                                         orig_node_count));\n     else\n       cs->count = 0;\n \n   for (cs = orig_node->callees; cs ; cs = cs->next_callee)\n-    cs->count = cs->count * (remainder * REG_BR_PROB_BASE\n-\t\t\t     / orig_node_count) / REG_BR_PROB_BASE;\n+    cs->count = apply_probability (cs->count,\n+                                   GCOV_COMPUTE_SCALE (remainder,\n+                                                       orig_node_count));\n \n   if (dump_file)\n     dump_profile_updates (orig_node, new_node);\n@@ -2611,14 +2613,17 @@ update_specialized_profile (struct cgraph_node *new_node,\n \n   for (cs = new_node->callees; cs ; cs = cs->next_callee)\n     if (cs->frequency)\n-      cs->count += cs->count * redirected_sum / new_node_count;\n+      cs->count += apply_probability (cs->count,\n+                                      GCOV_COMPUTE_SCALE (redirected_sum,\n+                                                          new_node_count));\n     else\n       cs->count = 0;\n \n   for (cs = orig_node->callees; cs ; cs = cs->next_callee)\n     {\n-      gcov_type dec = cs->count * (redirected_sum * REG_BR_PROB_BASE\n-\t\t\t\t   / orig_node_count) / REG_BR_PROB_BASE;\n+      gcov_type dec = apply_probability (cs->count,\n+                                         GCOV_COMPUTE_SCALE (redirected_sum,\n+                                                             orig_node_count));\n       if (dec < cs->count)\n \tcs->count -= dec;\n       else"}, {"sha": "138433cdf1a2813c0b4edeb8beebc4fe9449b586", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -2093,8 +2093,7 @@ param_change_prob (gimple stmt, int i)\n       if (!init_freq)\n \tinit_freq = 1;\n       if (init_freq < bb->frequency)\n-\treturn MAX ((init_freq * REG_BR_PROB_BASE +\n-\t\t     bb->frequency / 2) / bb->frequency, 1);\n+\treturn MAX (GCOV_COMPUTE_SCALE (init_freq, bb->frequency), 1);\n       else\n \treturn REG_BR_PROB_BASE;\n     }\n@@ -2136,8 +2135,7 @@ param_change_prob (gimple stmt, int i)\n \n       BITMAP_FREE (info.bb_set);\n       if (max < bb->frequency)\n-\treturn MAX ((max * REG_BR_PROB_BASE +\n-\t\t     bb->frequency / 2) / bb->frequency, 1);\n+\treturn MAX (GCOV_COMPUTE_SCALE (max, bb->frequency), 1);\n       else\n \treturn REG_BR_PROB_BASE;\n     }\n@@ -2792,6 +2790,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n       && hints && cgraph_maybe_hot_edge_p (e))\n     *hints |= INLINE_HINT_indirect_call;\n   *size += call_size * INLINE_SIZE_SCALE;\n+  /* Update to use apply_probability().  */\n   *time += call_time * prob / REG_BR_PROB_BASE\n     * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n   if (*time > MAX_TIME * INLINE_TIME_SCALE)\n@@ -2902,6 +2901,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t\t      inline_param_summary);\n \t    gcc_checking_assert (prob >= 0);\n \t    gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n+            /* Update to use apply_probability().  */\n \t    time += ((gcov_type) e->time * prob) / REG_BR_PROB_BASE;\n \t  }\n \tif (time > MAX_TIME * INLINE_TIME_SCALE)\n@@ -3120,8 +3120,7 @@ remap_edge_change_prob (struct cgraph_edge *inlined_edge,\n \t      int jf_formal_id = ipa_get_jf_pass_through_formal_id (jfunc);\n \t      int prob1 = es->param[i].change_prob;\n \t      int prob2 = inlined_es->param[jf_formal_id].change_prob;\n-\t      int prob = ((prob1 * prob2 + REG_BR_PROB_BASE / 2)\n-\t\t\t  / REG_BR_PROB_BASE);\n+\t      int prob = combine_probabilities (prob1, prob2);\n \n \t      if (prob1 && prob2 && !prob)\n \t\tprob = 1;\n@@ -3312,6 +3311,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t  int prob = predicate_probability (callee_info->conds,\n \t\t\t\t\t    &e->predicate,\n \t\t\t\t\t    clause, es->param);\n+          /* Update to use apply_probability().  */\n \t  add_time = ((gcov_type) add_time * prob) / REG_BR_PROB_BASE;\n \t  if (add_time > MAX_TIME * INLINE_TIME_SCALE)\n \t    add_time = MAX_TIME * INLINE_TIME_SCALE;"}, {"sha": "e5f1bdc190b10e31d3d227e27279afddf245847e", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -436,9 +436,11 @@ unswitch_loop (struct loop *loop, basic_block unswitch_on, rtx cond, rtx cinsn)\n   emit_insn_after (seq, BB_END (switch_bb));\n   e = make_edge (switch_bb, true_edge->dest, 0);\n   e->probability = prob;\n+  /* Update to use apply_probability().  */\n   e->count = latch_edge->count * prob / REG_BR_PROB_BASE;\n   e = make_edge (switch_bb, FALLTHRU_EDGE (unswitch_on)->dest, EDGE_FALLTHRU);\n   e->probability = false_edge->probability;\n+  /* Update to use apply_probability().  */\n   e->count = latch_edge->count * (false_edge->probability) / REG_BR_PROB_BASE;\n \n   if (irred_flag)"}, {"sha": "69f5e3a659f42d0e8fc0f5d36d90f287c875eacd", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -1343,14 +1343,14 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n   for (j = 0; (file_data = file_data_vec[j]) != NULL; j++)\n     if (file_data->profile_info.runs)\n       {\n-\tint scale = RDIV (REG_BR_PROB_BASE * max_runs,\n-                          file_data->profile_info.runs);\n-\tlto_gcov_summary.sum_max = MAX (lto_gcov_summary.sum_max,\n-\t\t\t\t\tRDIV (file_data->profile_info.sum_max\n-                                              * scale, REG_BR_PROB_BASE));\n-\tlto_gcov_summary.sum_all = MAX (lto_gcov_summary.sum_all,\n-\t\t\t\t\tRDIV (file_data->profile_info.sum_all\n-                                              * scale, REG_BR_PROB_BASE));\n+\tint scale = GCOV_COMPUTE_SCALE (max_runs,\n+                                        file_data->profile_info.runs);\n+\tlto_gcov_summary.sum_max\n+            = MAX (lto_gcov_summary.sum_max,\n+                   apply_probability (file_data->profile_info.sum_max, scale));\n+\tlto_gcov_summary.sum_all\n+            = MAX (lto_gcov_summary.sum_all,\n+                   apply_probability (file_data->profile_info.sum_all, scale));\n         /* Save a pointer to the profile_info with the largest\n            scaled sum_all and the scale for use in merging the\n            histogram.  */\n@@ -1371,8 +1371,9 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n     {\n       /* Scale up the min value as we did the corresponding sum_all\n          above. Use that to find the new histogram index.  */\n-      gcov_type scaled_min = RDIV (saved_profile_info->histogram[h_ix].min_value\n-                                   * saved_scale, REG_BR_PROB_BASE);\n+      gcov_type scaled_min\n+          = apply_probability (saved_profile_info->histogram[h_ix].min_value,\n+                               saved_scale);\n       /* The new index may be shared with another scaled histogram entry,\n          so we need to account for a non-zero histogram entry at new_ix.  */\n       unsigned new_ix = gcov_histo_index (scaled_min);\n@@ -1385,8 +1386,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n          here and place the scaled cumulative counter value in the bucket\n          corresponding to the scaled minimum counter value.  */\n       lto_gcov_summary.histogram[new_ix].cum_value\n-          += RDIV (saved_profile_info->histogram[h_ix].cum_value\n-                   * saved_scale, REG_BR_PROB_BASE);\n+          += apply_probability (saved_profile_info->histogram[h_ix].cum_value,\n+                                saved_scale);\n       lto_gcov_summary.histogram[new_ix].num_counters\n           += saved_profile_info->histogram[h_ix].num_counters;\n     }\n@@ -1418,8 +1419,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n \tif (scale == REG_BR_PROB_BASE)\n \t  continue;\n \tfor (edge = node->callees; edge; edge = edge->next_callee)\n-\t  edge->count = RDIV (edge->count * scale, REG_BR_PROB_BASE);\n-\tnode->count = RDIV (node->count * scale, REG_BR_PROB_BASE);\n+\t  edge->count = apply_probability (edge->count, scale);\n+\tnode->count = apply_probability (node->count, scale);\n       }\n }\n "}, {"sha": "982d3574ee8de1d0cbb3300c951c5967dc515485", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -622,8 +622,8 @@ input_cfg (struct lto_input_block *ib, struct function *fn,\n \n \t  dest_index = streamer_read_uhwi (ib);\n \t  probability = (int) streamer_read_hwi (ib);\n-\t  count = ((gcov_type) streamer_read_gcov_count (ib) * count_materialization_scale\n-\t\t   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+\t  count = apply_probability ((gcov_type) streamer_read_gcov_count (ib),\n+                                     count_materialization_scale);\n \t  edge_flags = streamer_read_uhwi (ib);\n \n \t  dest = BASIC_BLOCK_FOR_FUNCTION (fn, dest_index);"}, {"sha": "6f05581711c99099e9c9f37456b49e6412a5ae2e", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -752,7 +752,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n       if (bb->count)\n \t{\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    e->probability = (e->count * REG_BR_PROB_BASE + bb->count / 2) / bb->count;\n+\t    e->probability = GCOV_COMPUTE_SCALE (e->count, bb->count);\n \t  if (bb->index >= NUM_FIXED_BLOCKS\n \t      && block_ends_with_condjump_p (bb)\n \t      && EDGE_COUNT (bb->succs) >= 2)"}, {"sha": "02a6705afc47d903bc97c4b529eb071c6e85c057", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -1441,6 +1441,7 @@ compute_dom_prob_ps (int bb)\n       FOR_EACH_EDGE (out_edge, out_ei, in_edge->src->succs)\n \tbitmap_set_bit (pot_split[bb], EDGE_TO_BIT (out_edge));\n \n+      /* Update to use apply_probability().  */\n       prob[bb] += ((prob[pred_bb] * in_edge->probability) / REG_BR_PROB_BASE);\n     }\n \n@@ -1514,6 +1515,7 @@ compute_trg_info (int trg)\n \t  int tf = prob[trg], cf = prob[i];\n \n \t  /* In CFGs with low probability edges TF can possibly be zero.  */\n+          /* Update to use GCOV_COMPUTE_SCALE.  */\n \t  sp->src_prob = (tf ? ((cf * REG_BR_PROB_BASE) / tf) : 0);\n \t  sp->is_valid = (sp->src_prob >= min_spec_prob);\n \t}"}, {"sha": "bada27cea0451e1d53eb627758d11d6b3e18619d", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -1890,7 +1890,7 @@ conditional_probability (int target_prob, int base_prob)\n     {\n       gcc_assert (target_prob >= 0);\n       gcc_assert (target_prob <= base_prob);\n-      return RDIV (target_prob * REG_BR_PROB_BASE, base_prob);\n+      return GCOV_COMPUTE_SCALE (target_prob, base_prob);\n     }\n   return -1;\n }\n@@ -2012,7 +2012,7 @@ emit_case_dispatch_table (tree index_expr, tree index_type,\n       edge e;\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, stmt_bb->succs)\n-        e->probability = RDIV (e->probability * REG_BR_PROB_BASE,  base);\n+        e->probability = GCOV_COMPUTE_SCALE (e->probability,  base);\n     }\n \n   if (try_with_tablejump)"}, {"sha": "978db6ea00635106bd256ec3f8bcb7b9ceb5fd58", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -1521,10 +1521,12 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n      basic_block_info automatically.  */\n   copy_basic_block = create_basic_block (NULL, (void *) 0,\n                                          (basic_block) prev->aux);\n+  /* Update to use apply_probability().  */\n   copy_basic_block->count = bb->count * count_scale / REG_BR_PROB_BASE;\n \n   /* We are going to rebuild frequencies from scratch.  These values\n      have just small importance to drive canonicalize_loop_headers.  */\n+  /* Update to use EDGE_FREQUENCY.  */\n   freq = ((gcov_type)bb->frequency * frequency_scale / REG_BR_PROB_BASE);\n \n   /* We recompute frequencies after inlining, so this is quite safe.  */\n@@ -1890,6 +1892,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR)\n \t  flags |= EDGE_FALLTHRU;\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n+        /* Update to use apply_probability().  */\n \tnew_edge->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n \tnew_edge->probability = old_edge->probability;\n       }\n@@ -2060,6 +2063,7 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n   gcov_type count_scale;\n \n+  /* Update to use GCOV_COMPUTE_SCALE.  */\n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n \t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n@@ -2207,6 +2211,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   int incoming_frequency = 0;\n   gcov_type incoming_count = 0;\n \n+  /* Update to use GCOV_COMPUTE_SCALE.  */\n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n     count_scale = (REG_BR_PROB_BASE * count\n \t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n@@ -2231,7 +2236,9 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t    incoming_frequency += EDGE_FREQUENCY (e);\n \t    incoming_count += e->count;\n \t  }\n+      /* Update to use apply_probability().  */\n       incoming_count = incoming_count * count_scale / REG_BR_PROB_BASE;\n+      /* Update to use EDGE_FREQUENCY.  */\n       incoming_frequency\n \t= incoming_frequency * frequency_scale / REG_BR_PROB_BASE;\n       ENTRY_BLOCK_PTR->count = incoming_count;\n@@ -4051,6 +4058,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      a self-referential call; if we're calling ourselves, we need to\n      duplicate our body before altering anything.  */\n   copy_body (id, bb->count,\n+             /* Update to use GCOV_COMPUTE_SCALE.  */\n   \t     cg_edge->frequency * REG_BR_PROB_BASE / CGRAPH_FREQ_BASE,\n \t     bb, return_block, NULL, NULL);\n "}, {"sha": "a72369eb59e57920d4d1ac4908c38693403d5a25", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -126,25 +126,20 @@ execute_fixup_cfg (void)\n   edge e;\n   edge_iterator ei;\n \n-  if (ENTRY_BLOCK_PTR->count)\n-    count_scale = ((cgraph_get_node (current_function_decl)->count\n-\t\t    * REG_BR_PROB_BASE + ENTRY_BLOCK_PTR->count / 2)\n-\t\t   / ENTRY_BLOCK_PTR->count);\n-  else\n-    count_scale = REG_BR_PROB_BASE;\n+  count_scale\n+      = GCOV_COMPUTE_SCALE (cgraph_get_node (current_function_decl)->count,\n+                            ENTRY_BLOCK_PTR->count);\n \n   ENTRY_BLOCK_PTR->count = cgraph_get_node (current_function_decl)->count;\n-  EXIT_BLOCK_PTR->count = (EXIT_BLOCK_PTR->count * count_scale\n-  \t\t\t   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+  EXIT_BLOCK_PTR->count = apply_probability (EXIT_BLOCK_PTR->count,\n+                                             count_scale);\n \n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n-    e->count = (e->count * count_scale\n-       + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+    e->count = apply_probability (e->count, count_scale);\n \n   FOR_EACH_BB (bb)\n     {\n-      bb->count = (bb->count * count_scale\n-\t\t   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+      bb->count = apply_probability (bb->count, count_scale);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n@@ -177,8 +172,7 @@ execute_fixup_cfg (void)\n \t}\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n-        e->count = (e->count * count_scale\n-\t\t    + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;\n+        e->count = apply_probability (e->count, count_scale);\n \n       /* If we have a basic block with no successors that does not\n \t end with a control statement or a noreturn call end it with"}, {"sha": "bff5c22130ea6e66489055378bfadfb518234935", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -1236,8 +1236,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n      same frequencies.  Loop exit probablities are however easy to get wrong.\n      It is safer to copy value from original loop entry.  */\n   bb_before_second_loop->frequency\n-     = apply_probability (bb_before_first_loop->frequency,\n-\t\t\t  probability_of_second_loop);\n+     = combine_probabilities (bb_before_first_loop->frequency,\n+                              probability_of_second_loop);\n   bb_before_second_loop->count\n      = apply_probability (bb_before_first_loop->count,\n \t\t\t  probability_of_second_loop);"}, {"sha": "2fc20f38cfbedefc38409ede217e42cc7ddf58e3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -5761,7 +5761,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   slpeel_make_loop_iterate_ntimes (loop, ratio);\n \n   /* Reduce loop iterations by the vectorization factor.  */\n-  scale_loop_profile (loop, RDIV (REG_BR_PROB_BASE , vectorization_factor),\n+  scale_loop_profile (loop, GCOV_COMPUTE_SCALE (1, vectorization_factor),\n \t\t      expected_iterations / vectorization_factor);\n   loop->nb_iterations_upper_bound\n     = loop->nb_iterations_upper_bound.udiv (double_int::from_uhwi (vectorization_factor),"}, {"sha": "3348d7f58c82534b621553f4973f6ea8f6749bfa", "filename": "gcc/value-prof.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddb5a296eea999c6376f43a643b2baf79cf886a/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=8ddb5a296eea999c6376f43a643b2baf79cf886a", "patch": "@@ -802,7 +802,7 @@ gimple_divmod_fixed_value_transform (gimple_stmt_iterator *si)\n \n   /* Compute probability of taking the optimal path.  */\n   if (all > 0)\n-    prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+    prob = GCOV_COMPUTE_SCALE (count, all);\n   else\n     prob = 0;\n \n@@ -962,7 +962,7 @@ gimple_mod_pow2_value_transform (gimple_stmt_iterator *si)\n     return false;\n \n   if (all > 0)\n-    prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+    prob = GCOV_COMPUTE_SCALE (count, all);\n   else\n     prob = 0;\n \n@@ -1156,8 +1156,8 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   /* Compute probability of taking the optimal path(s).  */\n   if (all > 0)\n     {\n-      prob1 = (count1 * REG_BR_PROB_BASE + all / 2) / all;\n-      prob2 = (count2 * REG_BR_PROB_BASE + all / 2) / all;\n+      prob1 = GCOV_COMPUTE_SCALE (count1, all);\n+      prob2 = GCOV_COMPUTE_SCALE (count2, all);\n     }\n   else\n     {\n@@ -1430,7 +1430,7 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n     return false;\n \n   if (all > 0)\n-    prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+    prob = GCOV_COMPUTE_SCALE (count, all);\n   else\n     prob = 0;\n   direct_call = find_func_by_funcdef_no ((int)val);\n@@ -1636,7 +1636,7 @@ gimple_stringops_transform (gimple_stmt_iterator *gsi)\n   if (check_counter (stmt, \"value\", &count, &all, gimple_bb (stmt)->count))\n     return false;\n   if (all > 0)\n-    prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+    prob = GCOV_COMPUTE_SCALE (count, all);\n   else\n     prob = 0;\n   dest = gimple_call_arg (stmt, 0);"}]}