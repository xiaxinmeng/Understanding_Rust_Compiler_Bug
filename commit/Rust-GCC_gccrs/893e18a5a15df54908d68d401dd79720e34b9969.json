{"sha": "893e18a5a15df54908d68d401dd79720e34b9969", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzZTE4YTVhMTVkZjU0OTA4ZDY4ZDQwMWRkNzk3MjBlMzRiOTk2OQ==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-11-13T13:25:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-11-13T13:25:09Z"}, "message": "re PR target/18230 (SPARC VIS instructions are not generated by GCC)\n\n\tPR target/18230\n\t* config/sparc/sparc.c (sparc_rtx_costs): Handle the NAND vector\n\tpatterns.\n\t* config/sparc/sparc.md (V64I): New macro for 64-bit modes.\n\t(V32I): New macro for 32-bit modes.\n\t(anddi3, anddi_sp32, anddi_sp64, and_not_di_sp32, and_not_di_sp64,\n\tiordi3, iordi3_sp32, iordi_sp64, or_not_di_sp32, or_not_di_sp64,\n\txordi3, xordi3_sp32, xordi3_sp64, {AND, IOR, XOR} DI splitter,\n\txor_not_di_sp32, xordi_not_di_sp64, one_cmpldi2, one_cmpldi_sp32,\n\tone_cmpldi_sp64): Use V64I instead of DI.\n\t(andsi3, andsi_sp32, andsi_sp64, and_not_si, iorsi3, or_not_si,\n\txorsi3, xor_not_si, one_cmplsi2): Use V32I instead of SI.\n\t(addv2si3, addv4hi3, addv2hi3): Remove % modifier.\n\t(nandv64i_vis, nandv32i_vis): New patterns.\n\nCo-Authored-By: Eric Botcazou <ebotcazou@libertysurf.fr>\n\nFrom-SVN: r90578", "tree": {"sha": "a8a16dc9bcef08e8adcbcecd5caf0f41f0e7d0dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8a16dc9bcef08e8adcbcecd5caf0f41f0e7d0dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/893e18a5a15df54908d68d401dd79720e34b9969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893e18a5a15df54908d68d401dd79720e34b9969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/893e18a5a15df54908d68d401dd79720e34b9969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893e18a5a15df54908d68d401dd79720e34b9969/comments", "author": null, "committer": null, "parents": [{"sha": "9d65c5cb5765b9b45447850e37dcfa6d67d079f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d65c5cb5765b9b45447850e37dcfa6d67d079f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d65c5cb5765b9b45447850e37dcfa6d67d079f6"}], "stats": {"total": 1194, "additions": 1039, "deletions": 155}, "files": [{"sha": "7fe8ac684adb43a2de94eb837db13a60144a0e33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -1,3 +1,21 @@\n+2004-11-13  James A. Morrison  <phython@gcc.gnu.org>\n+            Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/18230\n+\t* config/sparc/sparc.c (sparc_rtx_costs): Handle the NAND vector\n+\tpatterns.\n+\t* config/sparc/sparc.md (V64I): New macro for 64-bit modes.\n+\t(V32I): New macro for 32-bit modes.\n+\t(anddi3, anddi_sp32, anddi_sp64, and_not_di_sp32, and_not_di_sp64,\n+\tiordi3, iordi3_sp32, iordi_sp64, or_not_di_sp32, or_not_di_sp64,\n+\txordi3, xordi3_sp32, xordi3_sp64, {AND, IOR, XOR} DI splitter,\n+\txor_not_di_sp32, xordi_not_di_sp64, one_cmpldi2, one_cmpldi_sp32,\n+\tone_cmpldi_sp64): Use V64I instead of DI.\n+\t(andsi3, andsi_sp32, andsi_sp64, and_not_si, iorsi3, or_not_si,\n+\txorsi3, xor_not_si, one_cmplsi2): Use V32I instead of SI.\n+\t(addv2si3, addv4hi3, addv2hi3): Remove % modifier.\n+\t(nandv64i_vis, nandv32i_vis): New patterns.\n+\n 2004-11-12  Mike Stump  <mrs@apple.com>\n \n \t* Makefile.in: Add html support."}, {"sha": "69c3bc593a027c6a0fd88258eeca5405625783dc", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -8688,6 +8688,18 @@ sparc_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t*total = sparc_costs->int_cmove;\n       return false;\n \n+    case IOR:\n+      /* Handle the NAND vector patterns.  */\n+      if (sparc_vector_mode_supported_p (GET_MODE (x))\n+\t  && GET_CODE (XEXP (x, 0)) == NOT\n+\t  && GET_CODE (XEXP (x, 1)) == NOT)\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      else\n+        return false;\n+\n     default:\n       return false;\n     }"}, {"sha": "fea0f91e5f48b09acd28afba55f31497c8ad706e", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 188, "deletions": 155, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -2208,7 +2208,7 @@\n    (set_attr \"fptype\" \"*,*,*,*,*,double,*,*\")])\n \n ;; We don't define V1SI because SI should work just fine.\n-(define_mode_macro V64 [DF V4HI V8QI V2SI])\n+(define_mode_macro V64 [DF V2SI V4HI V8QI])\n (define_mode_macro V32 [SF V2HI V4QI])\n \n (define_insn \"*movdi_insn_sp64_vis\"\n@@ -5929,45 +5929,49 @@\n ;; We define DImode `and' so with DImode `not' we can get\n ;; DImode `andn'.  Other combinations are possible.\n \n-(define_expand \"anddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+(define_mode_macro V64I [DI V2SI V4HI V8QI])\n+(define_mode_macro V32I [SI V2HI V4QI])\n+\n+(define_expand \"and<V64I:mode>3\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n+\t(and:V64I (match_operand:V64I 1 \"arith_double_operand\" \"\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*anddi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*and<V64I:mode>3_sp32\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(and:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"! TARGET_ARCH64\"\n   \"@\n   #\n   fand\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*anddi3_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*and<V64I:mode>3_sp64\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(and:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    and\\t%1, %2, %0\n    fand\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(and:SI (match_operand:SI 1 \"arith_operand\" \"%r,d\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"and<V32I:mode>3\"\n+  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n+\t(and:V32I (match_operand:V32I 1 \"arith_operand\" \"%r,d\")\n+\t\t(match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n   \"@\n    and\\t%1, %2, %0\n    fands\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")])\n+  [(set_attr \"type\" \"*,fga\")\n+   (set_attr \"fptype\" \"*,single\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -5983,44 +5987,10 @@\n   operands[4] = GEN_INT (~INTVAL (operands[2]));\n })\n \n-;; Split DImode logical operations requiring two instructions.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operator:DI 1 \"cc_arithop\"\t; AND, IOR, XOR\n-\t\t\t   [(match_operand:DI 2 \"register_operand\" \"\")\n-\t\t\t    (match_operand:DI 3 \"arith_double_operand\" \"\")]))]\n-  \"! TARGET_ARCH64\n-   && reload_completed\n-   && ((GET_CODE (operands[0]) == REG\n-        && REGNO (operands[0]) < 32)\n-       || (GET_CODE (operands[0]) == SUBREG\n-           && GET_CODE (SUBREG_REG (operands[0])) == REG\n-           && REGNO (SUBREG_REG (operands[0])) < 32))\"\n-  [(set (match_dup 4) (match_op_dup:SI 1 [(match_dup 6) (match_dup 8)]))\n-   (set (match_dup 5) (match_op_dup:SI 1 [(match_dup 7) (match_dup 9)]))]\n-{\n-  operands[4] = gen_highpart (SImode, operands[0]);\n-  operands[5] = gen_lowpart (SImode, operands[0]);\n-  operands[6] = gen_highpart (SImode, operands[2]);\n-  operands[7] = gen_lowpart (SImode, operands[2]);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-  if (GET_CODE (operands[3]) == CONST_INT)\n-    {\n-      if (INTVAL (operands[3]) < 0)\n-\toperands[8] = constm1_rtx;\n-      else\n-\toperands[8] = const0_rtx;\n-    }\n-  else\n-#endif\n-    operands[8] = gen_highpart_mode (SImode, DImode, operands[3]);\n-  operands[9] = gen_lowpart (SImode, operands[3]);\n-})\n-\n-(define_insn_and_split \"*and_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,b\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r,b\")))]\n+(define_insn_and_split \"*and_not_<V64I:mode>_sp32\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(and:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"%r,b\"))\n+\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n   \"! TARGET_ARCH64\"\n   \"@\n    #\n@@ -6041,68 +6011,70 @@\n    operands[8] = gen_lowpart (SImode, operands[2]);\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*and_not_di_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,b\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r,b\")))]\n+(define_insn \"*and_not_<V64I:mode>_sp64\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(and:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"%r,b\"))\n+\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    andn\\t%2, %1, %0\n    fandnot1\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*and_not_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r,d\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"r,d\")))]\n+(define_insn \"*and_not_<V32I:mode>\"\n+  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n+\t(and:V32I (not:V32I (match_operand:V32I 1 \"register_operand\" \"%r,d\"))\n+\t\t  (match_operand:V32I 2 \"register_operand\" \"r,d\")))]\n   \"\"\n   \"@\n    andn\\t%2, %1, %0\n    fandnot1s\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")])\n+  [(set_attr \"type\" \"*,fga\")\n+   (set_attr \"fptype\" \"*,single\")])\n \n-(define_expand \"iordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+(define_expand \"ior<V64I:mode>3\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n+\t(ior:V64I (match_operand:V64I 1 \"arith_double_operand\" \"\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*iordi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*ior<V64I:mode>3_sp32\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(ior:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"! TARGET_ARCH64\"\n   \"@\n   #\n   for\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*iordi3_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*ior<V64I:mode>3_sp64\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(ior:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n   or\\t%1, %2, %0\n   for\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"%r,d\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"ior<V32I:mode>3\"\n+  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n+\t(ior:V32I (match_operand:V32I 1 \"arith_operand\" \"%r,d\")\n+\t\t  (match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n   \"@\n    or\\t%1, %2, %0\n    fors\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")])\n+  [(set_attr \"type\" \"*,fga\")\n+   (set_attr \"fptype\" \"*,single\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -6118,10 +6090,10 @@\n   operands[4] = GEN_INT (~INTVAL (operands[2]));\n })\n \n-(define_insn_and_split \"*or_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,b\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r,b\")))]\n+(define_insn_and_split \"*or_not_<V64I:mode>_sp32\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(ior:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\"))\n+\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n   \"! TARGET_ARCH64\"\n   \"@\n    #\n@@ -6142,58 +6114,59 @@\n    operands[8] = gen_lowpart (SImode, operands[2]);\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*or_not_di_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,b\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r,b\")))]\n+(define_insn \"*or_not_<V64I:mode>_sp64\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(ior:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\"))\n+\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n   orn\\t%2, %1, %0\n   fornot1\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*or_not_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r,d\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"r,d\")))]\n+(define_insn \"*or_not_<V32I:mode>\"\n+  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n+\t(ior:V32I (not:V32I (match_operand:V32I 1 \"register_operand\" \"r,d\"))\n+\t\t  (match_operand:V32I 2 \"register_operand\" \"r,d\")))]\n   \"\"\n   \"@\n    orn\\t%2, %1, %0\n    fornot1s\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")])\n+  [(set_attr \"type\" \"*,fga\")\n+   (set_attr \"fptype\" \"*,single\")])\n \n-(define_expand \"xordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n+(define_expand \"xor<V64I:mode>3\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n+\t(xor:V64I (match_operand:V64I 1 \"arith_double_operand\" \"\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*xordi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*xor<V64I:mode>3_sp32\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(xor:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"! TARGET_ARCH64\"\n   \"@\n   #\n   fxor\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*xordi3_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%rJ,b\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*xor<V64I:mode>3_sp64\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(xor:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%rJ,b\")\n+\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n   xor\\t%r1, %2, %0\n   fxor\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n (define_insn \"*xordi3_sp64_dbl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -6203,15 +6176,16 @@\n     && HOST_BITS_PER_WIDE_INT != 64)\"\n   \"xor\\t%1, %2, %0\")\n \n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"%rJ,d\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"xor<V32I:mode>3\"\n+  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n+\t(xor:V32I (match_operand:V32I 1 \"arith_operand\" \"%rJ,d\")\n+\t\t  (match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n   \"@\n    xor\\t%r1, %2, %0\n    fxors\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")])\n+  [(set_attr \"type\" \"*,fga\")\n+   (set_attr \"fptype\" \"*,single\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -6241,12 +6215,46 @@\n   operands[4] = GEN_INT (~INTVAL (operands[2]));\n })\n \n+;; Split DImode logical operations requiring two instructions.\n+(define_split\n+  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n+\t(match_operator:V64I 1 \"cc_arithop\"\t; AND, IOR, XOR\n+\t\t\t   [(match_operand:V64I 2 \"register_operand\" \"\")\n+\t\t\t    (match_operand:V64I 3 \"arith_double_operand\" \"\")]))]\n+  \"! TARGET_ARCH64\n+   && reload_completed\n+   && ((GET_CODE (operands[0]) == REG\n+        && REGNO (operands[0]) < 32)\n+       || (GET_CODE (operands[0]) == SUBREG\n+           && GET_CODE (SUBREG_REG (operands[0])) == REG\n+           && REGNO (SUBREG_REG (operands[0])) < 32))\"\n+  [(set (match_dup 4) (match_op_dup:SI 1 [(match_dup 6) (match_dup 8)]))\n+   (set (match_dup 5) (match_op_dup:SI 1 [(match_dup 7) (match_dup 9)]))]\n+{\n+  operands[4] = gen_highpart (SImode, operands[0]);\n+  operands[5] = gen_lowpart (SImode, operands[0]);\n+  operands[6] = gen_highpart (SImode, operands[2]);\n+  operands[7] = gen_lowpart (SImode, operands[2]);\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  if (GET_CODE (operands[3]) == CONST_INT && <V64I:MODE>mode == DImode)\n+    {\n+      if (INTVAL (operands[3]) < 0)\n+\toperands[8] = constm1_rtx;\n+      else\n+\toperands[8] = const0_rtx;\n+    }\n+  else\n+#endif\n+    operands[8] = gen_highpart_mode (SImode, <V64I:MODE>mode, operands[3]);\n+  operands[9] = gen_lowpart (SImode, operands[3]);\n+})\n+\n ;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b).\n ;; Combine now canonicalizes to the rightmost expression.\n-(define_insn_and_split \"*xor_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"r,b\")\n-\t\t\t(match_operand:DI 2 \"register_operand\" \"r,b\"))))]\n+(define_insn_and_split \"*xor_not_<V64I:mode>_sp32\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(not:V64I (xor:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\")\n+\t\t\t    (match_operand:V64I 2 \"register_operand\" \"r,b\"))))]\n   \"! TARGET_ARCH64\"\n   \"@\n    #\n@@ -6267,28 +6275,29 @@\n    operands[8] = gen_lowpart (SImode, operands[2]);\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*xor_not_di_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(not:DI (xor:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ,b\")\n-\t\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\"))))]\n+(define_insn \"*xor_not_<V64I:mode>_sp64\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(not:V64I (xor:V64I (match_operand:V64I 1 \"reg_or_0_operand\" \"rJ,b\")\n+\t\t\t    (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\"))))]\n   \"TARGET_ARCH64\"\n   \"@\n   xnor\\t%r1, %2, %0\n   fxnor\\t%1, %2, %0\"\n   [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*xor_not_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(not:SI (xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ,d\")\n-\t\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\"))))]\n+(define_insn \"*xor_not_<V32I:mode>\"\n+  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n+\t(not:V32I (xor:V32I (match_operand:V32I 1 \"reg_or_0_operand\" \"rJ,d\")\n+\t\t\t    (match_operand:V32I 2 \"arith_operand\" \"rI,d\"))))]\n   \"\"\n   \"@\n    xnor\\t%r1, %2, %0\n    fxnors\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")])\n+  [(set_attr \"type\" \"*,fga\")\n+   (set_attr \"fptype\" \"*,single\")])\n \n ;; These correspond to the above in the case where we also (or only)\n ;; want to set the condition code.  \n@@ -6526,15 +6535,15 @@\n \n ;; We cannot use the \"not\" pseudo insn because the Sun assembler\n ;; does not know how to make it work for constants.\n-(define_expand \"one_cmpldi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(not:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n+(define_expand \"one_cmpl<V64I:mode>2\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n+\t(not:V64I (match_operand:V64I 1 \"register_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn_and_split \"*one_cmpldi2_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(not:DI (match_operand:DI 1 \"register_operand\" \"r,b\")))]\n+(define_insn_and_split \"*one_cmpl<V64I:mode>2_sp32\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(not:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\")))]\n   \"! TARGET_ARCH64\"\n   \"@\n    #\n@@ -6553,26 +6562,27 @@\n    operands[5] = gen_lowpart (SImode, operands[1]);\"\n   [(set_attr \"type\" \"*,fga\")\n    (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"*one_cmpldi2_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n-\t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*one_cmpl<V64I:mode>2_sp64\"\n+  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n+\t(not:V64I (match_operand:V64I 1 \"arith_double_operand\" \"rHI,b\")))]\n   \"TARGET_ARCH64\"\n   \"@\n    xnor\\t%%g0, %1, %0\n    fnot1\\t%1, %0\"\n   [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"*,double\")])\n \n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(not:SI (match_operand:SI 1 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"one_cmpl<V32I:mode>2\"\n+  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n+\t(not:V32I (match_operand:V32I 1 \"arith_operand\" \"rI,d\")))]\n   \"\"\n   \"@\n   xnor\\t%%g0, %1, %0\n   fnot1s\\t%1, %0\"\n-  [(set_attr \"type\" \"*,fga\")])\n+  [(set_attr \"type\" \"*,fga\")\n+   (set_attr \"fptype\" \"*,single\")])\n \n (define_insn \"*cmp_cc_not\"\n   [(set (reg:CC 100)\n@@ -8873,7 +8883,7 @@\n \n (define_insn \"addv2si3\"\n   [(set (match_operand:V2SI 0 \"register_operand\" \"=e\")\n-\t(plus:V2SI (match_operand:V2SI 1 \"register_operand\" \"%e\")\n+\t(plus:V2SI (match_operand:V2SI 1 \"register_operand\" \"e\")\n \t\t   (match_operand:V2SI 2 \"register_operand\" \"e\")))]\n   \"TARGET_VIS\"\n   \"fpadd32\\t%1, %2, %0\"\n@@ -8882,7 +8892,7 @@\n \n (define_insn \"addv4hi3\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"=e\")\n-\t (plus:V4HI (match_operand:V4HI 1 \"register_operand\" \"%e\")\n+\t (plus:V4HI (match_operand:V4HI 1 \"register_operand\" \"e\")\n \t\t    (match_operand:V4HI 2 \"register_operand\" \"e\")))]\n   \"TARGET_VIS\"\n   \"fpadd16\\t%1, %2, %0\"\n@@ -8893,7 +8903,7 @@\n \n (define_insn \"addv2hi3\"\n   [(set (match_operand:V2HI 0 \"register_operand\" \"=f\")\n-\t(plus:V2HI (match_operand:V2HI 1 \"register_operand\" \"%f\")\n+\t(plus:V2HI (match_operand:V2HI 1 \"register_operand\" \"f\")\n \t\t   (match_operand:V2HI 2 \"register_operand\" \"f\")))]\n   \"TARGET_VIS\"\n   \"fpadd16s\\t%1, %2, %0\"\n@@ -8928,3 +8938,26 @@\n   \"fpsub16s\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n    (set_attr \"fptype\" \"single\")])\n+\n+;; All other logical instructions have integer equivalents so they\n+;; are defined together.\n+\n+;; (ior (not (op1)) (not (op2))) is the canonical form of NAND.\n+\n+(define_insn \"*nand<V64mode>_vis\"\n+  [(set (match_operand:V64 0 \"register_operand\" \"=e\")\n+\t(ior:V64 (not:V64 (match_operand:V64 1 \"register_operand\" \"e\"))\n+\t\t (not:V64 (match_operand:V64 2 \"register_operand\" \"e\"))))]\n+  \"TARGET_VIS\"\n+  \"fnand\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"fptype\" \"double\")])\n+\n+(define_insn \"*nand<V32mode>_vis\"\n+  [(set (match_operand:V32 0 \"register_operand\" \"=f\")\n+\t (ior:V32 (not:V32 (match_operand:V32 1 \"register_operand\" \"f\"))\n+\t\t  (not:V32 (match_operand:V32 2 \"register_operand\" \"f\"))))]\n+  \"TARGET_VIS\"\n+  \"fnands\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"fptype\" \"single\")])"}, {"sha": "851443fb57b24b86dcb291eac2638012b0fa6550", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -1,3 +1,15 @@\n+2004-11-13  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* gcc.target/sparc/fand.c, gcc.target/sparc/fands,\n+\tgcc.target/sparc/fnand.c, gcc.target/sparc/fnands.c,\n+\tgcc.target/sparc/fxor.c, gcc.target/sparc/fxors.c,\n+\tgcc.target/sparc/fxnor.c, gcc.target/sparc/fxnors.c,\n+\tgcc.target/sparc/fandnot.c, gcc.target/sparc/fandnots.c,\n+\tgcc.target/sparc/fornot.c, gcc.target/sparc/fornots.c,\n+\tgcc.target/sparc/fnot.c, gcc.target/sparc/fnots.c,\n+\tgcc.target/sparc/for.c, gcc.target/sparc/fors.c,\n+\tgcc.target/sparc/combined-1.c: New tests.\n+\n 2004-11-12  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc.dg/const-str-8.m, objc.dg/const-str-9.m:"}, {"sha": "5f19db3b0b4915bdf3b0c25205773363cba26cdb", "filename": "gcc/testsuite/gcc.target/sparc/combined-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcombined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcombined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcombined-1.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int vec32 __attribute__((vector_size(8)));\n+\n+vec16 fun16(vec16 a, vec16 b)\n+{\n+  return (~a & b) + (b | a) - (a ^ b);\n+}\n+\n+vec32 fun32(vec32 a, vec32 b)\n+{\n+  return (~a & b) + (b | a) - (a ^ b);\n+}\n+\n+/* This should be transformed into ~b & a.  */\n+vec16 fun16b(vec16 a, vec16 b)\n+{\n+  return (a & ~b) + (b | a) - (a ^ b);\n+}\n+\n+vec32 fun32b(vec32 a, vec32 b)\n+{\n+  return (a & ~b) + (b | a) - (a ^ b);\n+}\n+\n+/* { dg-final { scan-assembler-times \"fandnot1\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"for\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fpadd\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fxor\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"fpsub\" 4 } } */"}, {"sha": "3194c921ccdc19614dea48d63f779ed8a21cedb0", "filename": "gcc/testsuite/gcc.target/sparc/fand.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffand.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return foo1_8 () & foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2(vec8 a, vec8 b)\n+{\n+  return a & b;\n+}\n+#endif\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return foo1_16 () & foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2(vec16 a, vec16 b)\n+{\n+  return a & b;\n+}\n+#endif\n+\n+extern vec32 foo1_32(void);\n+extern vec32 foo2_32(void);\n+\n+vec32 fun32(void)\n+{\n+  return foo1_32 () & foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2(vec32 a, vec32 b)\n+{\n+  return a & b;\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"fand\\t%\" 3 } } */"}, {"sha": "41db849c239237721288796ea1d66287676acf80", "filename": "gcc/testsuite/gcc.target/sparc/fandnot.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnot.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~foo1_8 () & foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2(vec8 a, vec8 b)\n+{\n+  return ~a & b;\n+}\n+#endif\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~foo1_16 () & foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2(vec16 a, vec16 b)\n+{\n+  return ~a & b;\n+}\n+#endif\n+\n+extern vec32 foo1_32(void);\n+extern vec32 foo2_32(void);\n+\n+vec32 fun32(void)\n+{\n+  return ~foo1_32 () & foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2(vec32 a, vec32 b)\n+{\n+  return ~a & b;\n+}\n+#endif\n+\n+\n+/* This should be transformed into ~b & a.  */\n+vec8 fun8b(void)\n+{\n+  return foo1_8 () & ~foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2b(vec8 a, vec8 b)\n+{\n+  return a & ~b;\n+}\n+#endif\n+\n+vec16 fun16b(void)\n+{\n+  return foo1_16 () & ~foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2b(vec16 a, vec16 b)\n+{\n+  return a & ~b;\n+}\n+#endif\n+\n+vec32 fun32b(void)\n+{\n+  return foo1_32 () & ~foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2b(vec32 a, vec32 b)\n+{\n+  return a & ~b;\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"fandnot1\\t%\" 6 } } */"}, {"sha": "7a5ed24148c3f7824d529b4bacec3486d3e1d544", "filename": "gcc/testsuite/gcc.target/sparc/fandnots.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnots.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnots.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnots.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~foo1_8 () & foo2_8 ();\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~foo1_16 () & foo1_16 ();\n+}\n+\n+\n+/* This should be transformed into ~b & a.  */\n+vec8 fun8b(void)\n+{\n+  return foo1_8 () & ~foo2_8 ();\n+}\n+\n+vec16 fun16b(void)\n+{\n+  return foo1_16 () & ~foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fandnot1s\\t%\" 4 } } */"}, {"sha": "f924f4531de5c2c3048d4cbafa9e04da9d4bebb3", "filename": "gcc/testsuite/gcc.target/sparc/fands.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffands.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return foo1_8 () & foo2_8 ();\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return foo1_16 () & foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fands\\t%\" 2 } } */"}, {"sha": "89fe8694df35f3683d12146bc517d5a5f7012b59", "filename": "gcc/testsuite/gcc.target/sparc/fnand.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnand.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~(foo1_8 () & foo2_8 ());\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~(foo1_16 () & foo2_16 ());\n+}\n+\n+extern vec32 foo1_32(void);\n+extern vec32 foo2_32(void);\n+\n+vec32 fun32(void)\n+{\n+  return ~(foo1_32 () & foo2_32 ());\n+}\n+\n+\n+/* DeMorgan's Law's at work.  */\n+vec8 fun8b(void)\n+{\n+  return ~foo1_8 () | ~foo2_8 ();\n+}\n+\n+vec16 fun16b(void)\n+{\n+  return ~foo1_16 () | ~foo2_16 ();\n+}\n+\n+vec32 fun32b(void)\n+{\n+  return ~foo1_32 () | ~foo2_32 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fnand\\t%\" 6 } } */"}, {"sha": "05d6c4733cda3a5ae6a22df1cbf68820dfab236c", "filename": "gcc/testsuite/gcc.target/sparc/fnands.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnands.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~(foo1_8 () & foo2_8 ());\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~(foo1_16 () & foo1_16 ());\n+}\n+\n+/* DeMorgan's Law's at work.  */\n+vec8 fun8b(void)\n+{\n+  return ~foo1_8 () | ~foo2_8 ();\n+}\n+\n+vec16 fun16b(void)\n+{\n+  return ~foo1_16 () | ~foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fnands\\t%\" 4 } } */"}, {"sha": "e6f98d412a6b90eaf4c612e206ec45dbe0124b70", "filename": "gcc/testsuite/gcc.target/sparc/fnot.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnot.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern void foo2_8(vec8);\n+\n+vec8 fun8(void)\n+{\n+  return ~foo1_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2(vec8 a)\n+{\n+  foo2_8 (~a);\n+}\n+#endif\n+\n+extern vec16 foo1_16(void);\n+extern void foo2_16(vec8);\n+\n+\n+vec16 fun16(void)\n+{\n+  return ~foo1_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2(vec16 a)\n+{\n+  foo2_16 (~a);\n+}\n+#endif\n+\n+extern vec32 foo1_32(void);\n+extern void foo2_32(vec8);\n+\n+vec32 fun32(void)\n+{\n+  return ~foo1_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2(vec32 a)\n+{\n+  foo2_32 (~a);\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"fnot1\\t%\" 3 } } */"}, {"sha": "f50eb0b3a6bf92dc70d3b0428b1b5795597eef70", "filename": "gcc/testsuite/gcc.target/sparc/fnots.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnots.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnots.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnots.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~foo1_8 ();\n+}\n+\n+extern vec16 foo1_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fnot1s\\t%\" 2 } } */"}, {"sha": "7348dce20356de0b73fc692601b42376df7c3c9b", "filename": "gcc/testsuite/gcc.target/sparc/for.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffor.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return foo1_8 () | foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2(vec8 a, vec8 b)\n+{\n+  return a | b;\n+}\n+#endif\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return foo1_16 () | foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2(vec16 a, vec16 b)\n+{\n+  return a | b;\n+}\n+#endif\n+\n+extern vec32 foo1_32(void);\n+extern vec32 foo2_32(void);\n+\n+vec32 fun32(void)\n+{\n+  return foo1_32 () | foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2(vec32 a, vec32 b)\n+{\n+  return a | b;\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"for\\t%\" 3 } } */"}, {"sha": "09fdb4f98f3426a38c8f4ae5bdd32d760694ebf2", "filename": "gcc/testsuite/gcc.target/sparc/fornot.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornot.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~foo1_8 () | foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2(vec8 a, vec8 b)\n+{\n+  return ~a | b;\n+}\n+#endif\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~foo1_16 () | foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2(vec16 a, vec16 b)\n+{\n+  return ~a | b;\n+}\n+#endif\n+\n+extern vec32 foo1_32(void);\n+extern vec32 foo2_32(void);\n+\n+vec32 fun32(void)\n+{\n+  return ~foo1_32 () | foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2(vec32 a, vec32 b)\n+{\n+  return ~a | b;\n+}\n+#endif\n+\n+\n+/* This should be transformed into ~b | a.  */\n+vec8 fun8b(void)\n+{\n+  return foo1_8 () | ~foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2b(vec8 a, vec8 b)\n+{\n+  return a | ~b;\n+}\n+#endif\n+\n+vec16 fun16b(void)\n+{\n+  return foo1_16 () | ~foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2b(vec16 a, vec16 b)\n+{\n+  return a | ~b;\n+}\n+#endif\n+\n+vec32 fun32b(void)\n+{\n+  return foo1_32 () | ~foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2b(vec32 a, vec32 b)\n+{\n+  return a | ~b;\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"fornot1\\t%\" 6 } } */"}, {"sha": "db29a992636e4a69e3ff227aced252c6cd68309d", "filename": "gcc/testsuite/gcc.target/sparc/fornots.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornots.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornots.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornots.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~foo1_8 () | foo2_8 ();\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~foo1_16 () | foo1_16 ();\n+}\n+\n+\n+/* This should be transformed into ~b | a.  */\n+vec8 fun8b(void)\n+{\n+  return foo1_8 () | ~foo2_8 ();\n+}\n+\n+vec16 fun16b(void)\n+{\n+  return foo1_16 () | ~foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fornot1s\\t%\" 4 } } */"}, {"sha": "0afdd4bbc65e2e8dd6335ba71d7cd6ab170b4f6c", "filename": "gcc/testsuite/gcc.target/sparc/fors.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffors.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return foo1_8 () | foo2_8 ();\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return foo1_16 () | foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fors\\t%\" 2 } } */"}, {"sha": "a685e08e04c289eae3bd8942d19cd93544ec7a82", "filename": "gcc/testsuite/gcc.target/sparc/fxnor.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnor.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~(foo1_8 () ^ foo2_8 ());\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2(vec8 a, vec8 b)\n+{\n+  return ~(a ^ b);\n+}\n+#endif\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~(foo1_16 () ^ foo2_16 ());\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2(vec16 a, vec16 b)\n+{\n+  return ~(a ^ b);\n+}\n+#endif\n+\n+extern vec32 foo1_32(void);\n+extern vec32 foo2_32(void);\n+\n+vec32 fun32(void)\n+{\n+  return ~(foo1_32 () ^ foo2_32 ());\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2(vec32 a, vec32 b)\n+{\n+  return ~(a ^ b);\n+}\n+#endif\n+\n+\n+/* This should be transformed into ~(b ^ a).  */\n+vec8 fun8b(void)\n+{\n+  return foo1_8 () ^ ~foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2b(vec8 a, vec8 b)\n+{\n+  return a ^ ~b;\n+}\n+#endif\n+\n+vec16 fun16b(void)\n+{\n+  return foo1_16 () ^ ~foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2b(vec16 a, vec16 b)\n+{\n+  return a ^ ~b;\n+}\n+#endif\n+\n+vec32 fun32b(void)\n+{\n+  return foo1_32 () ^ ~foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2b(vec32 a, vec32 b)\n+{\n+  return a ^ ~b;\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"fxnor\\t%\" 6 } } */"}, {"sha": "29775cffe3f505c15193f51472c8e776a3e50fd9", "filename": "gcc/testsuite/gcc.target/sparc/fxnors.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnors.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return ~(foo1_8 () ^ foo2_8 ());\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return ~(foo1_16 () ^ foo1_16 ());\n+}\n+\n+\n+/* This should be transformed into ~(b ^ a).  */\n+vec8 fun8b(void)\n+{\n+  return foo1_8 () ^ ~foo2_8 ();\n+}\n+\n+vec16 fun16b(void)\n+{\n+  return foo1_16 () ^ ~foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fxnors\\t%\" 4 } } */"}, {"sha": "581b37b54fb8e90fb7fd7b94026d6d35f48028ca", "filename": "gcc/testsuite/gcc.target/sparc/fxor.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxor.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char  vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int   vec32 __attribute__((vector_size(8)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return foo1_8 () ^ foo2_8 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec8 fun8_2(vec8 a, vec8 b)\n+{\n+  return a ^ b;\n+}\n+#endif\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return foo1_16 () ^ foo2_16 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec16 fun16_2(vec16 a, vec16 b)\n+{\n+  return a ^ b;\n+}\n+#endif\n+\n+extern vec32 foo1_32(void);\n+extern vec32 foo2_32(void);\n+\n+vec32 fun32(void)\n+{\n+  return foo1_32 () ^ foo2_32 ();\n+}\n+\n+#ifndef __LP64__\n+/* Test the 32-bit splitter. */\n+vec32 fun32_2(vec32 a, vec32 b)\n+{\n+  return a ^ b;\n+}\n+#endif\n+\n+/* { dg-final { scan-assembler-times \"fxor\\t%\" 3 } } */"}, {"sha": "5da017a28feb170f39042f848ede4f1c97b2f967", "filename": "gcc/testsuite/gcc.target/sparc/fxors.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893e18a5a15df54908d68d401dd79720e34b9969/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxors.c?ref=893e18a5a15df54908d68d401dd79720e34b9969", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n+typedef char vec8 __attribute__((vector_size(4)));\n+typedef short vec16 __attribute__((vector_size(4)));\n+\n+extern vec8 foo1_8(void);\n+extern vec8 foo2_8(void);\n+\n+vec8 fun8(void)\n+{\n+  return foo1_8 () ^ foo2_8 ();\n+}\n+\n+extern vec16 foo1_16(void);\n+extern vec16 foo2_16(void);\n+\n+vec16 fun16(void)\n+{\n+  return foo1_16 () ^ foo1_16 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"fxors\\t%\" 2 } } */"}]}