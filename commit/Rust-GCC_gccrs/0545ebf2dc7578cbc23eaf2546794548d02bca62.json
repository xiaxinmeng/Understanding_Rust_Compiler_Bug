{"sha": "0545ebf2dc7578cbc23eaf2546794548d02bca62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU0NWViZjJkYzc1NzhjYmMyM2VhZjI1NDY3OTQ1NDhkMDJiY2E2Mg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-05-11T19:21:31Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-05-11T19:21:31Z"}, "message": "re PR libstdc++/53263 (priority_queue is very slow if -D_GLIBCXX_DEBUG is used)\n\n2012-05-11  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/53263\n\t* include/debug/safe_iterator.h (__gnu_debug::__base): Move...\n\t* include/debug/functions.h: ... Here. Add debug function\n\toverloads to perform checks on normal iterators when possible.\n\t* include/debug/macros.h (__glibcxx_check_heap)\n\t(__glibcxx_check_heap_pred): Use __gnu_debug::__base on iterator range.\n\nFrom-SVN: r187414", "tree": {"sha": "c3a1f6beee1db89e2e98320de952fc89e37b7a6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3a1f6beee1db89e2e98320de952fc89e37b7a6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0545ebf2dc7578cbc23eaf2546794548d02bca62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0545ebf2dc7578cbc23eaf2546794548d02bca62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0545ebf2dc7578cbc23eaf2546794548d02bca62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0545ebf2dc7578cbc23eaf2546794548d02bca62/comments", "author": null, "committer": null, "parents": [{"sha": "06118b14d6a75fc6d6c949ef66c6696430d7724d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06118b14d6a75fc6d6c949ef66c6696430d7724d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06118b14d6a75fc6d6c949ef66c6696430d7724d"}], "stats": {"total": 227, "additions": 168, "deletions": 59}, "files": [{"sha": "f1dab1ab1f642a173be4a9ce18b67e55b23093ba", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0545ebf2dc7578cbc23eaf2546794548d02bca62", "patch": "@@ -1,3 +1,12 @@\n+2012-05-11  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/53263\n+\t* include/debug/safe_iterator.h (__gnu_debug::__base): Move...\n+\t* include/debug/functions.h: ... Here. Add debug function\n+\toverloads to perform checks on normal iterators when possible.\n+\t* include/debug/macros.h (__glibcxx_check_heap)\n+\t(__glibcxx_check_heap_pred): Use __gnu_debug::__base on iterator range.\n+\n 2012-05-10  DJ Delorie  <dj@redhat.com>\n \n \t* include/bits/random.tcc (seed_seq::generate): Cast max()"}, {"sha": "b2817d5ef1c7abc6be7d35759f7b3d19adbd8479", "filename": "libstdc++-v3/include/debug/functions.h", "status": "modified", "additions": 154, "deletions": 25, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h?ref=0545ebf2dc7578cbc23eaf2546794548d02bca62", "patch": "@@ -31,7 +31,8 @@\n #define _GLIBCXX_DEBUG_FUNCTIONS_H 1\n \n #include <bits/c++config.h>\n-#include <bits/stl_iterator_base_types.h> // for iterator_traits, categories\n+#include <bits/stl_iterator_base_types.h> // for iterator_traits, categories and\n+\t\t\t\t\t  // _Iter_base\n #include <bits/cpp_type_traits.h>         // for __is_integer\n #include <debug/formatter.h>\n \n@@ -118,11 +119,8 @@ namespace __gnu_debug\n     inline bool\n     __valid_range_aux(const _InputIterator& __first,\n \t\t      const _InputIterator& __last, std::__false_type)\n-  {\n-    typedef typename std::iterator_traits<_InputIterator>::iterator_category\n-      _Category;\n-    return __valid_range_aux2(__first, __last, _Category());\n-  }\n+  { return __valid_range_aux2(__first, __last,\n+\t\t\t      std::__iterator_category(__first)); }\n \n   /** Don't know what these iterators are, or if they are even\n    *  iterators (we may get an integral type for InputIterator), so\n@@ -214,6 +212,15 @@ namespace __gnu_debug\n       return true;\n     }\n \n+  // For performance reason, as the iterator range has been validated, check on\n+  // random access safe iterators is done using the base iterator.\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    __check_sorted_aux(const _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t       const _Safe_iterator<_Iterator, _Sequence>& __last,\n+\t\t       std::random_access_iterator_tag __tag)\n+  { return __check_sorted_aux(__first.base(), __last.base(), __tag); }\n+\n   // Can't check if an input iterator sequence is sorted, because we can't step\n   // through the sequence.\n   template<typename _InputIterator, typename _Predicate>\n@@ -240,34 +247,41 @@ namespace __gnu_debug\n       return true;\n     }\n \n+  // For performance reason, as the iterator range has been validated, check on\n+  // random access safe iterators is done using the base iterator.\n+  template<typename _Iterator, typename _Sequence,\n+\t   typename _Predicate>\n+    inline bool\n+    __check_sorted_aux(const _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t       const _Safe_iterator<_Iterator, _Sequence>& __last,\n+\t\t       _Predicate __pred,\n+\t\t       std::random_access_iterator_tag __tag)\n+  { return __check_sorted_aux(__first.base(), __last.base(), __pred, __tag); }\n+\n   // Determine if a sequence is sorted.\n   template<typename _InputIterator>\n     inline bool\n     __check_sorted(const _InputIterator& __first, const _InputIterator& __last)\n     {\n-      typedef typename std::iterator_traits<_InputIterator>::iterator_category\n-        _Category;\n-\n       // Verify that the < operator for elements in the sequence is a\n       // StrictWeakOrdering by checking that it is irreflexive.\n       __glibcxx_assert(__first == __last || !(*__first < *__first));\n \n-      return __check_sorted_aux(__first, __last, _Category());\n+      return __check_sorted_aux(__first, __last,\n+\t\t\t\tstd::__iterator_category(__first));\n     }\n \n   template<typename _InputIterator, typename _Predicate>\n     inline bool\n     __check_sorted(const _InputIterator& __first, const _InputIterator& __last,\n                    _Predicate __pred)\n     {\n-      typedef typename std::iterator_traits<_InputIterator>::iterator_category\n-        _Category;\n-\n       // Verify that the predicate is StrictWeakOrdering by checking that it\n       // is irreflexive.\n       __glibcxx_assert(__first == __last || !__pred(*__first, *__first));\n \n-      return __check_sorted_aux(__first, __last, __pred, _Category());\n+      return __check_sorted_aux(__first, __last, __pred,\n+\t\t\t\tstd::__iterator_category(__first));\n     }\n \n   template<typename _InputIterator>\n@@ -332,13 +346,11 @@ namespace __gnu_debug\n       return __check_sorted_set_aux(__first, __last, __pred, _SameType());\n    }\n \n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 270. Binary search requirements overly strict\n-  // Determine if a sequence is partitioned w.r.t. this element.\n   template<typename _ForwardIterator, typename _Tp>\n     inline bool\n-    __check_partitioned_lower(_ForwardIterator __first,\n-\t\t\t      _ForwardIterator __last, const _Tp& __value)\n+  __check_partitioned_lower_aux(_ForwardIterator __first,\n+\t\t\t\t_ForwardIterator __last, const _Tp& __value,\n+\t\t\t\tstd::forward_iterator_tag)\n     {\n       while (__first != __last && *__first < __value)\n \t++__first;\n@@ -347,10 +359,33 @@ namespace __gnu_debug\n       return __first == __last;\n     }\n \n+  // For performance reason, as the iterator range has been validated, check on\n+  // random access safe iterators is done using the base iterator.\n+  template<typename _Iterator, typename _Sequence, typename _Tp>\n+    inline bool\n+    __check_partitioned_lower_aux(\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __last,\n+\t\t\tconst _Tp& __value,\n+\t\t\tstd::random_access_iterator_tag __tag)\n+    { return __check_partitioned_lower_aux(__first.base(), __last.base(),\n+\t\t\t\t\t   __value, __tag); }\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 270. Binary search requirements overly strict\n+  // Determine if a sequence is partitioned w.r.t. this element.\n   template<typename _ForwardIterator, typename _Tp>\n     inline bool\n-    __check_partitioned_upper(_ForwardIterator __first,\n+    __check_partitioned_lower(_ForwardIterator __first,\n \t\t\t      _ForwardIterator __last, const _Tp& __value)\n+    { return __check_partitioned_lower_aux(__first, __last, __value,\n+\t\t\t\t\t   std::__iterator_category(__first)); }\n+\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline bool\n+    __check_partitioned_upper_aux(_ForwardIterator __first,\n+\t\t\t\t  _ForwardIterator __last, const _Tp& __value,\n+\t\t\t\t  std::forward_iterator_tag)\n     {\n       while (__first != __last && !(__value < *__first))\n \t++__first;\n@@ -359,12 +394,31 @@ namespace __gnu_debug\n       return __first == __last;\n     }\n \n-  // Determine if a sequence is partitioned w.r.t. this element.\n+  // For performance reason, as the iterator range has been validated, check on\n+  // random access safe iterators is done using the base iterator.\n+  template<typename _Iterator, typename _Sequence, typename _Tp>\n+    inline bool\n+    __check_partitioned_upper_aux(\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __last,\n+\t\t\tconst _Tp& __value,\n+\t\t\tstd::random_access_iterator_tag __tag)\n+    { return __check_partitioned_upper_aux(__first.base(), __last.base(),\n+\t\t\t\t\t   __value, __tag); }\n+\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline bool\n+    __check_partitioned_upper(_ForwardIterator __first,\n+\t\t\t      _ForwardIterator __last, const _Tp& __value)\n+    { return __check_partitioned_upper_aux(__first, __last, __value,\n+\t\t\t\t\t   std::__iterator_category(__first)); }\n+\n   template<typename _ForwardIterator, typename _Tp, typename _Pred>\n     inline bool\n-    __check_partitioned_lower(_ForwardIterator __first,\n-\t\t\t      _ForwardIterator __last, const _Tp& __value,\n-\t\t\t      _Pred __pred)\n+    __check_partitioned_lower_aux(_ForwardIterator __first,\n+\t\t\t\t  _ForwardIterator __last, const _Tp& __value,\n+\t\t\t\t  _Pred __pred,\n+\t\t\t\t  std::forward_iterator_tag)\n     {\n       while (__first != __last && bool(__pred(*__first, __value)))\n \t++__first;\n@@ -373,18 +427,93 @@ namespace __gnu_debug\n       return __first == __last;\n     }\n \n+  // For performance reason, as the iterator range has been validated, check on\n+  // random access safe iterators is done using the base iterator.\n+  template<typename _Iterator, typename _Sequence,\n+\t   typename _Tp, typename _Pred>\n+    inline bool\n+    __check_partitioned_lower_aux(\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __last,\n+\t\t\tconst _Tp& __value, _Pred __pred,\n+\t\t\tstd::random_access_iterator_tag __tag)\n+    { return __check_partitioned_lower_aux(__first.base(), __last.base(),\n+\t\t\t\t\t   __value, __pred, __tag); }\n+\n+  // Determine if a sequence is partitioned w.r.t. this element.\n   template<typename _ForwardIterator, typename _Tp, typename _Pred>\n     inline bool\n-    __check_partitioned_upper(_ForwardIterator __first,\n+    __check_partitioned_lower(_ForwardIterator __first,\n \t\t\t      _ForwardIterator __last, const _Tp& __value,\n \t\t\t      _Pred __pred)\n+    { return __check_partitioned_lower_aux(__first, __last, __value, __pred,\n+\t\t\t\t\t   std::__iterator_category(__first)); }\n+\n+  template<typename _ForwardIterator, typename _Tp, typename _Pred>\n+    inline bool\n+    __check_partitioned_upper_aux(_ForwardIterator __first,\n+\t\t\t\t  _ForwardIterator __last, const _Tp& __value,\n+\t\t\t\t  _Pred __pred,\n+\t\t\t\t  std::forward_iterator_tag)\n     {\n       while (__first != __last && !bool(__pred(__value, *__first)))\n \t++__first;\n       while (__first != __last && bool(__pred(__value, *__first)))\n \t++__first;\n       return __first == __last;\n     }\n+\n+  // For performance reason, as the iterator range has been validated, check on\n+  // random access safe iterators is done using the base iterator.\n+  template<typename _Iterator, typename _Sequence,\n+\t   typename _Tp, typename _Pred>\n+    inline bool\n+    __check_partitioned_upper_aux(\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t\tconst _Safe_iterator<_Iterator, _Sequence>& __last,\n+\t\t\tconst _Tp& __value, _Pred __pred,\n+\t\t\tstd::random_access_iterator_tag __tag)\n+    { return __check_partitioned_upper_aux(__first.base(), __last.base(),\n+\t\t\t\t\t   __value, __pred, __tag); }\n+\n+  template<typename _ForwardIterator, typename _Tp, typename _Pred>\n+    inline bool\n+    __check_partitioned_upper(_ForwardIterator __first,\n+\t\t\t      _ForwardIterator __last, const _Tp& __value,\n+\t\t\t      _Pred __pred)\n+    { return __check_partitioned_upper_aux(__first, __last, __value, __pred,\n+\t\t\t\t\t   std::__iterator_category(__first)); }\n+\n+  // Helper struct to detect random access safe iterators.\n+  template<typename _Iterator>\n+    struct __is_safe_random_iterator\n+    {\n+      enum { __value = 0 };\n+      typedef std::__false_type __type;\n+    };\n+\n+  template<typename _Iterator, typename _Sequence>\n+    struct __is_safe_random_iterator<_Safe_iterator<_Iterator, _Sequence> >\n+    : std::__are_same<std::random_access_iterator_tag,\n+                      typename std::iterator_traits<_Iterator>::\n+\t\t      iterator_category>\n+    { };\n+\n+  template<typename _Iterator>\n+    struct _Siter_base\n+    : std::_Iter_base<_Iterator, __is_safe_random_iterator<_Iterator>::__value>\n+    { };\n+\n+  /** Helper function to extract base iterator of random access safe iterator\n+      in order to reduce performance impact of debug mode.  Limited to random\n+      access iterator because it is the only category for which it is possible\n+      to check for correct iterators order in the __valid_range function\n+      thanks to the < operator.\n+  */\n+  template<typename _Iterator>\n+    inline typename _Siter_base<_Iterator>::iterator_type\n+    __base(_Iterator __it)\n+    { return _Siter_base<_Iterator>::_S_base(__it); }\n } // namespace __gnu_debug\n \n #endif"}, {"sha": "1b7871957ee2ff9fa7837de71c5568d5b9754230", "filename": "libstdc++-v3/include/debug/macros.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h?ref=0545ebf2dc7578cbc23eaf2546794548d02bca62", "patch": "@@ -296,15 +296,18 @@ _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__check_partitioned_upper(_First, _Last, \\\n \n // Verify that the iterator range [_First, _Last) is a heap\n #define __glibcxx_check_heap(_First,_Last)\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(std::__is_heap(_First, _Last),\t\t        \\\n+  _GLIBCXX_DEBUG_VERIFY(std::__is_heap(__gnu_debug::__base(_First),\t\\\n+\t\t\t\t       __gnu_debug::__base(_Last)),\t\\\n \t\t      _M_message(__gnu_debug::__msg_not_heap)\t        \\\n \t\t      ._M_iterator(_First, #_First)\t\t\t\\\n \t\t      ._M_iterator(_Last, #_Last))\n \n /** Verify that the iterator range [_First, _Last) is a heap\n     w.r.t. the predicate _Pred. */\n #define __glibcxx_check_heap_pred(_First,_Last,_Pred)\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(std::__is_heap(_First, _Last, _Pred),\t\t\\\n+  _GLIBCXX_DEBUG_VERIFY(std::__is_heap(__gnu_debug::__base(_First),\t\\\n+\t\t\t\t       __gnu_debug::__base(_Last),\t\\\n+\t\t\t\t       _Pred),\t\t\t\t\\\n \t\t      _M_message(__gnu_debug::__msg_not_heap_pred)      \\\n                       ._M_iterator(_First, #_First)\t\t\t\\\n \t\t      ._M_iterator(_Last, #_Last)\t\t\t\\"}, {"sha": "68f55cd974e4fc8cf2854a023b3ce6cefbeba53b", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0545ebf2dc7578cbc23eaf2546794548d02bca62/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=0545ebf2dc7578cbc23eaf2546794548d02bca62", "patch": "@@ -35,7 +35,6 @@\n #include <debug/functions.h>\n #include <debug/safe_base.h>\n #include <bits/stl_pair.h>\n-#include <bits/stl_iterator_base_types.h> // for _Iter_base\n #include <ext/type_traits.h>\n \n namespace __gnu_debug\n@@ -714,37 +713,6 @@ namespace __gnu_debug\n     operator+(typename _Safe_iterator<_Iterator,_Sequence>::difference_type __n,\n \t      const _Safe_iterator<_Iterator, _Sequence>& __i)\n     { return __i + __n; }\n-\n-  // Helper struct to detect random access safe iterators.\n-  template<typename _Iterator>\n-    struct __is_safe_random_iterator\n-    {\n-      enum { __value = 0 };\n-      typedef std::__false_type __type;\n-    };\n-\n-  template<typename _Iterator, typename _Sequence>\n-    struct __is_safe_random_iterator<_Safe_iterator<_Iterator, _Sequence> >\n-    : std::__are_same<std::random_access_iterator_tag,\n-                      typename std::iterator_traits<_Iterator>::\n-\t\t      iterator_category>\n-    { };\n-\n-  template<typename _Iterator>\n-    struct _Siter_base\n-    : std::_Iter_base<_Iterator, __is_safe_random_iterator<_Iterator>::__value>\n-    { };\n-\n-  /** Helper function to extract base iterator of random access safe iterator\n-      in order to reduce performance impact of debug mode.  Limited to random\n-      access iterator because it is the only category for which it is possible\n-      to check for correct iterators order in the __valid_range function\n-      thanks to the < operator.\n-  */\n-  template<typename _Iterator>\n-    inline typename _Siter_base<_Iterator>::iterator_type\n-    __base(_Iterator __it)\n-    { return _Siter_base<_Iterator>::_S_base(__it); }\n } // namespace __gnu_debug\n \n #include <debug/safe_iterator.tcc>"}]}