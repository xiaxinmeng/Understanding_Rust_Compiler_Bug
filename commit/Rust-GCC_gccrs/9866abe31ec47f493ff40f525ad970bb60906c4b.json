{"sha": "9866abe31ec47f493ff40f525ad970bb60906c4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg2NmFiZTMxZWM0N2Y0OTNmZjQwZjUyNWFkOTcwYmI2MDkwNmM0Yg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-17T16:03:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-02-17T17:09:18Z"}, "message": "libstdc++ P1956R1 On the names of low-level bit manipulation functions\n\nImplement this change for C++20 that was just approved in Prague.\n\n\tP1956R1 On the names of low-level bit manipulation functions\n\t* include/bits/hashtable_policy.h: Update comment.\n\t* include/std/bit (__ispow2, __ceil2, __floor2, __log2p1): Rename.\n\t(ispow2, ceil2, floor2, log2p1): Likewise.\n\t(__cpp_lib_int_pow2): Add feature test macro.\n\t* include/std/charconv (__to_chars_len_2): Adjust use of __log2p1.\n\t* include/std/memory (assume_aligned): Adjust use of ispow2.\n\t* include/std/version (__cpp_lib_int_pow2): Add.\n\t* libsupc++/new_opa.cc: Adjust use of __ispow2.\n\t* src/c++17/memory_resource.cc: Likewise, and for __ceil2 and __log2p1.\n\t* testsuite/17_intro/freestanding.cc: Adjust use of ispow2.\n\t* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: Rename to ...\n\t* testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc: ... here.\n\t* testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc: Rename to ...\n\t* testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc: ... here.\n\t* testsuite/26_numerics/bit/bit.pow.two/floor2.cc: Rename to ...\n\t* testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc: ... here.\n\t* testsuite/26_numerics/bit/bit.pow.two/log2p1.cc: Rename to ...\n\t* testsuite/26_numerics/bit/bit.pow.two/bit_width.cc: ... here.\n\t* testsuite/26_numerics/bit/bit.pow.two/ispow2.cc: Rename to ...\n\t* testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc: ... here.", "tree": {"sha": "99c716639b6082dfc556c43e9d3ce03121fb1034", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99c716639b6082dfc556c43e9d3ce03121fb1034"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9866abe31ec47f493ff40f525ad970bb60906c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9866abe31ec47f493ff40f525ad970bb60906c4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9866abe31ec47f493ff40f525ad970bb60906c4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9866abe31ec47f493ff40f525ad970bb60906c4b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd23cdb1743b41baed0b937c4b359b9422490ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd23cdb1743b41baed0b937c4b359b9422490ca7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd23cdb1743b41baed0b937c4b359b9422490ca7"}], "stats": {"total": 661, "additions": 343, "deletions": 318}, "files": [{"sha": "999c35fb9bc14777244b7d0f569425c094925723", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -1,5 +1,27 @@\n 2020-02-17  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tP1956R1 On the names of low-level bit manipulation functions\n+\t* include/bits/hashtable_policy.h: Update comment.\n+\t* include/std/bit (__ispow2, __ceil2, __floor2, __log2p1): Rename.\n+\t(ispow2, ceil2, floor2, log2p1): Likewise.\n+\t(__cpp_lib_int_pow2): Add feature test macro.\n+\t* include/std/charconv (__to_chars_len_2): Adjust use of __log2p1.\n+\t* include/std/memory (assume_aligned): Adjust use of ispow2.\n+\t* include/std/version (__cpp_lib_int_pow2): Add.\n+\t* libsupc++/new_opa.cc: Adjust use of __ispow2.\n+\t* src/c++17/memory_resource.cc: Likewise, and for __ceil2 and __log2p1.\n+\t* testsuite/17_intro/freestanding.cc: Adjust use of ispow2.\n+\t* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: Rename to ...\n+\t* testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc: ... here.\n+\t* testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc: Rename to ...\n+\t* testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc: ... here.\n+\t* testsuite/26_numerics/bit/bit.pow.two/floor2.cc: Rename to ...\n+\t* testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc: ... here.\n+\t* testsuite/26_numerics/bit/bit.pow.two/log2p1.cc: Rename to ...\n+\t* testsuite/26_numerics/bit/bit.pow.two/bit_width.cc: ... here.\n+\t* testsuite/26_numerics/bit/bit.pow.two/ispow2.cc: Rename to ...\n+\t* testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc: ... here.\n+\n \t* include/std/charconv: Add comment.\n \n \tPR libstdc++/92546 (partial)"}, {"sha": "22bc4472e320905ba762f44a2fdbc0b8e1c9974f", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -508,7 +508,7 @@ namespace __detail\n   inline std::size_t\n   __clp2(std::size_t __n) noexcept\n   {\n-    // Equivalent to return __n ? std::ceil2(__n) : 0;\n+    // Equivalent to return __n ? std::bit_ceil(__n) : 0;\n     if (__n < 2)\n       return __n;\n     const unsigned __lz = sizeof(size_t) > sizeof(long)"}, {"sha": "69e955458f3ab518729cce4335d149814235243a", "filename": "libstdc++-v3/include/std/bit", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -211,12 +211,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     constexpr bool\n-    __ispow2(_Tp __x) noexcept\n+    __has_single_bit(_Tp __x) noexcept\n     { return std::__popcount(__x) == 1; }\n \n   template<typename _Tp>\n     constexpr _Tp\n-    __ceil2(_Tp __x) noexcept\n+    __bit_ceil(_Tp __x) noexcept\n     {\n       using std::__detail::__int_limits;\n       constexpr auto _Nd = __int_limits<_Tp>::digits;\n@@ -249,7 +249,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     constexpr _Tp\n-    __floor2(_Tp __x) noexcept\n+    __bit_floor(_Tp __x) noexcept\n     {\n       constexpr auto _Nd = __detail::__int_limits<_Tp>::digits;\n       if (__x == 0)\n@@ -259,7 +259,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     constexpr _Tp\n-    __log2p1(_Tp __x) noexcept\n+    __bit_width(_Tp __x) noexcept\n     {\n       constexpr auto _Nd = __detail::__int_limits<_Tp>::digits;\n       return _Nd - std::__countl_zero(__x);\n@@ -325,29 +325,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // [bit.pow.two], integral powers of 2\n \n+#define __cpp_lib_int_pow2 202002L\n+\n   /// True if `x` is a power of two, false otherwise.\n   template<typename _Tp>\n     constexpr _If_is_unsigned_integer<_Tp, bool>\n-    ispow2(_Tp __x) noexcept\n-    { return std::__ispow2(__x); }\n+    has_single_bit(_Tp __x) noexcept\n+    { return std::__has_single_bit(__x); }\n \n   /// The smallest power-of-two not less than `x`.\n   template<typename _Tp>\n     constexpr _If_is_unsigned_integer<_Tp>\n-    ceil2(_Tp __x) noexcept\n-    { return std::__ceil2(__x); }\n+    bit_ceil(_Tp __x) noexcept\n+    { return std::__bit_ceil(__x); }\n \n   /// The largest power-of-two not greater than `x`.\n   template<typename _Tp>\n     constexpr _If_is_unsigned_integer<_Tp>\n-    floor2(_Tp __x) noexcept\n-    { return std::__floor2(__x); }\n+    bit_floor(_Tp __x) noexcept\n+    { return std::__bit_floor(__x); }\n \n   /// The smallest integer greater than the base-2 logarithm of `x`.\n   template<typename _Tp>\n     constexpr _If_is_unsigned_integer<_Tp>\n-    log2p1(_Tp __x) noexcept\n-    { return std::__log2p1(__x); }\n+    bit_width(_Tp __x) noexcept\n+    { return std::__bit_width(__x); }\n \n #define __cpp_lib_endian 201907L\n "}, {"sha": "35f8efc7e359dac763895f8fdb0e778a38241271", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -38,7 +38,7 @@\n #if __cplusplus >= 201402L\n \n #include <type_traits>\n-#include <bit>\t\t\t// for __log2p1\n+#include <bit>\t\t\t// for __bit_width\n #include <cctype>\t\t// for isdigit\n #include <bits/charconv.h>\t// for __to_chars_len, __to_chars_10_impl\n #include <bits/error_constants.h> // for std::errc\n@@ -101,7 +101,7 @@ namespace __detail\n   template<typename _Tp>\n     constexpr unsigned\n     __to_chars_len_2(_Tp __value) noexcept\n-    { return std::__log2p1(__value); }\n+    { return std::__bit_width(__value); }\n \n   // Generic implementation for arbitrary bases.\n   template<typename _Tp>"}, {"sha": "14aedb70dacda09172da39c70db62f5bcbbeb9f0", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -93,7 +93,7 @@\n #if __cplusplus >= 201103L\n #include <cstdint>\n #if __cplusplus > 201703L\n-# include <bit>\t\t\t// for ispow2\n+# include <bit>\t\t\t// for has_single_bit\n # include <new>\t\t\t// for placement operator new\n # include <tuple>\t\t// for tuple, make_tuple, make_from_tuple\n #endif\n@@ -191,7 +191,7 @@ get_pointer_safety() noexcept { return pointer_safety::relaxed; }\n     [[nodiscard,__gnu__::__always_inline__]]\n     constexpr _Tp* assume_aligned(_Tp* __ptr)\n     {\n-      static_assert(std::ispow2(_Align));\n+      static_assert(std::has_single_bit(_Align));\n       _GLIBCXX_DEBUG_ASSERT((std::uintptr_t)__ptr % _Align == 0);\n       return static_cast<_Tp*>(__builtin_assume_aligned(__ptr, _Align));\n     }"}, {"sha": "f9877ef04ca8d3c70f58a5c5b799f687cc6cea02", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -174,6 +174,7 @@\n # define __cpp_lib_destroying_delete 201806L\n #endif\n #define __cpp_lib_endian 201907L\n+#define __cpp_lib_int_pow2 202002L\n #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED\n # define __cpp_lib_is_constant_evaluated 201811L\n #endif"}, {"sha": "b935936e19a6820b207b7c42d8434dbd4021028b", "filename": "libstdc++-v3/libsupc++/new_opa.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -115,7 +115,7 @@ operator new (std::size_t sz, std::align_val_t al)\n \n   /* Alignment must be a power of two.  */\n   /* XXX This should be checked by the compiler (PR 86878).  */\n-  if (__builtin_expect (!std::__ispow2(align), false))\n+  if (__builtin_expect (!std::__has_single_bit(align), false))\n     _GLIBCXX_THROW_OR_ABORT(bad_alloc());\n \n   /* malloc (0) is unpredictable; avoid it.  */"}, {"sha": "56a87844da034b0aa51603291200c0557332ba06", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -25,7 +25,7 @@\n #include <memory_resource>\n #include <algorithm>\t\t\t// lower_bound, rotate\n #include <atomic>\n-#include <bit>\t\t\t\t// __ceil2, __log2p1\n+#include <bit>\t\t\t\t// has_single_bit, bit_ceil, bit_width\n #include <new>\n #if ATOMIC_POINTER_LOCK_FREE != 2\n # include <bits/std_mutex.h>\t// std::mutex, std::lock_guard\n@@ -189,7 +189,7 @@ namespace pmr\n     allocate(memory_resource* __r, size_t __size, size_t __align,\n \t     _Chunk*& __head)\n     {\n-      __size = std::__ceil2(__size + sizeof(_Chunk));\n+      __size = std::__bit_ceil(__size + sizeof(_Chunk));\n \n       if constexpr (alignof(_Chunk) > 1)\n \t{\n@@ -237,8 +237,8 @@ namespace pmr\n \n   private:\n     _Chunk(size_t __size, size_t __align, _Chunk* __next) noexcept\n-    : _M_size(std::__log2p1(__size) - 1),\n-      _M_align(std::__log2p1(__align) - 1)\n+    : _M_size(std::__bit_width(__size) - 1),\n+      _M_align(std::__bit_width(__align) - 1)\n     {\n       __builtin_memcpy(_M_next, &__next, sizeof(__next));\n       _M_canary = _M_size | _M_align;\n@@ -430,7 +430,7 @@ namespace pmr\n   private:\n     static constexpr unsigned _S_size_digits\n       = (numeric_limits<size_type>::digits\n-\t  + std::__log2p1(bits_per_word) - 1) / 2;\n+\t  + std::__bit_width(bits_per_word) - 1) / 2;\n \n     word* _M_words = nullptr;\n     // Number of blocks represented by the bitset:\n@@ -553,7 +553,7 @@ namespace pmr\n     // Alignment must be a power-of-two so we only need to use enough bits\n     // to store the power, not the actual value:\n     static constexpr unsigned _S_alignbits\n-      = std::__log2p1((unsigned)numeric_limits<size_t>::digits - 1);\n+      = std::__bit_width((unsigned)numeric_limits<size_t>::digits - 1);\n     // Use the remaining bits to store the size:\n     static constexpr unsigned _S_sizebits\n       = numeric_limits<size_t>::digits - _S_alignbits;\n@@ -564,7 +564,7 @@ namespace pmr\n \n     big_block(size_t bytes, size_t alignment)\n     : _M_size(alloc_size(bytes) >> _S_alignbits),\n-      _M_align_exp(std::__log2p1(alignment) - 1u)\n+      _M_align_exp(std::__bit_width(alignment) - 1u)\n     { }\n \n     void* pointer = nullptr;\n@@ -686,7 +686,7 @@ namespace pmr\n       const size_t __words = (__blocks + __bits - 1) / __bits;\n       const size_t __block_size = block_size();\n       size_t __bytes = __blocks * __block_size + __words * sizeof(word);\n-      size_t __alignment = std::__ceil2(__block_size);\n+      size_t __alignment = std::__bit_ceil(__block_size);\n       void* __p = __r->allocate(__bytes, __alignment);\n       __try\n \t{\n@@ -713,7 +713,7 @@ namespace pmr\n \n     void release(memory_resource* __r)\n     {\n-      const size_t __alignment = std::__ceil2(block_size());\n+      const size_t __alignment = std::__bit_ceil(block_size());\n       for (auto& __c : _M_chunks)\n \tif (__c._M_p)\n \t  __r->deallocate(__c._M_p, __c._M_bytes, __alignment);\n@@ -894,7 +894,7 @@ namespace pmr\n     else\n       {\n \t// Round to preferred granularity\n-\tstatic_assert(std::__ispow2(pool_sizes[0]));\n+\tstatic_assert(std::__has_single_bit(pool_sizes[0]));\n \tconstexpr size_t mask = pool_sizes[0] - 1;\n \topts.largest_required_pool_block += mask;\n \topts.largest_required_pool_block &= ~mask;"}, {"sha": "8dac1810b8cea5db9cc3491aec0f63a90b2c164b", "filename": "libstdc++-v3/testsuite/17_intro/freestanding.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Ffreestanding.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Ffreestanding.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Ffreestanding.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -52,7 +52,7 @@ int main()\n   std::initializer_list<int> ilisti __attribute__((unused));\n \n #if __cplusplus > 201703L\n-  static_assert( std::ispow2(256u) );\n+  static_assert( std::has_single_bit(256u) );\n   static_assert( __cpp_lib_void_t >= 201411L );\n #endif\n "}, {"sha": "0f6aaa12e387f3975170c58211ce6651b937d3a2", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil.cc", "status": "renamed", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_ceil.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_ceil.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_ceil.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -27,62 +27,62 @@ template<typename T>\n template<typename T>\n   constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);\n \n-// Detect whether std::ceil2(N) is a constant expression.\n+// Detect whether std::bit_ceil(N) is a constant expression.\n template<auto N, typename = void>\n-  struct ceil2_valid\n+  struct bit_ceil_valid\n   : std::false_type { };\n \n template<auto N>\n-  struct ceil2_valid<N, std::void_t<char[(std::ceil2(N), 1)]>>\n+  struct bit_ceil_valid<N, std::void_t<char[(std::bit_ceil(N), 1)]>>\n   : std::true_type { };\n \n template<typename UInt>\n constexpr auto\n test(UInt x)\n--> decltype(std::ceil2(x))\n+-> decltype(std::bit_ceil(x))\n {\n-  static_assert( noexcept(std::ceil2(x)) );\n+  static_assert( noexcept(std::bit_ceil(x)) );\n \n-  static_assert( std::ceil2(UInt(0)) == 1 );\n-  static_assert( std::ceil2(UInt(1)) == 1 );\n-  static_assert( std::ceil2(UInt(2)) == 2 );\n-  static_assert( std::ceil2(UInt(3)) == 4 );\n-  static_assert( std::ceil2(UInt(4)) == 4 );\n-  static_assert( std::ceil2(UInt(0x11)) == 0x20 );\n-  static_assert( std::ceil2(UInt(0x20)) == 0x20 );\n+  static_assert( std::bit_ceil(UInt(0)) == 1 );\n+  static_assert( std::bit_ceil(UInt(1)) == 1 );\n+  static_assert( std::bit_ceil(UInt(2)) == 2 );\n+  static_assert( std::bit_ceil(UInt(3)) == 4 );\n+  static_assert( std::bit_ceil(UInt(4)) == 4 );\n+  static_assert( std::bit_ceil(UInt(0x11)) == 0x20 );\n+  static_assert( std::bit_ceil(UInt(0x20)) == 0x20 );\n \n   if constexpr (std::numeric_limits<UInt>::digits > 8)\n   {\n-    static_assert( std::ceil2(UInt(0x201)) == 0x400 );\n-    static_assert( std::ceil2(UInt(0x8ff)) == 0x1000 );\n-    static_assert( std::ceil2(UInt(0x1000)) == 0x1000 );\n+    static_assert( std::bit_ceil(UInt(0x201)) == 0x400 );\n+    static_assert( std::bit_ceil(UInt(0x8ff)) == 0x1000 );\n+    static_assert( std::bit_ceil(UInt(0x1000)) == 0x1000 );\n   }\n \n   if constexpr (std::numeric_limits<UInt>::digits > 32)\n   {\n-    static_assert( std::ceil2(UInt(0xabcdef)) == 0x1000000 );\n-    static_assert( std::ceil2(UInt(0x1000000)) == 0x1000000 );\n-    static_assert( std::ceil2(UInt(0x1000001)) == 0x2000000 );\n+    static_assert( std::bit_ceil(UInt(0xabcdef)) == 0x1000000 );\n+    static_assert( std::bit_ceil(UInt(0x1000000)) == 0x1000000 );\n+    static_assert( std::bit_ceil(UInt(0x1000001)) == 0x2000000 );\n   }\n \n   if constexpr (std::numeric_limits<UInt>::digits > 64)\n   {\n-    static_assert( std::ceil2(UInt(1) << 64) == (UInt(1) << 64) );\n-    static_assert( std::ceil2(UInt(3) << 64) == (UInt(4) << 64) );\n+    static_assert( std::bit_ceil(UInt(1) << 64) == (UInt(1) << 64) );\n+    static_assert( std::bit_ceil(UInt(3) << 64) == (UInt(4) << 64) );\n   }\n \n   constexpr UInt msb = maxpow2<UInt>;\n-  static_assert( ceil2_valid<msb>() );\n-  static_assert( std::ceil2( msb ) == msb );\n-  static_assert( std::ceil2( UInt(msb - 1) ) == msb );\n-  static_assert( std::ceil2( UInt(msb - 2) ) == msb );\n-  static_assert( std::ceil2( UInt(msb - 3) ) == msb );\n+  static_assert( bit_ceil_valid<msb>() );\n+  static_assert( std::bit_ceil( msb ) == msb );\n+  static_assert( std::bit_ceil( UInt(msb - 1) ) == msb );\n+  static_assert( std::bit_ceil( UInt(msb - 2) ) == msb );\n+  static_assert( std::bit_ceil( UInt(msb - 3) ) == msb );\n \n   // P1355R2: not a constant expression if the result is not representable\n-  static_assert( !ceil2_valid<UInt(msb + 1)>() );\n-  static_assert( !ceil2_valid<max<UInt>>() );\n-  static_assert( !ceil2_valid<UInt(max<UInt> - 1)>() );\n-  static_assert( !ceil2_valid<UInt(max<UInt> - 2)>() );\n+  static_assert( !bit_ceil_valid<UInt(msb + 1)>() );\n+  static_assert( !bit_ceil_valid<max<UInt>>() );\n+  static_assert( !bit_ceil_valid<UInt(max<UInt> - 1)>() );\n+  static_assert( !bit_ceil_valid<UInt(max<UInt> - 2)>() );\n \n   return true;\n }\n@@ -93,7 +93,7 @@ static_assert( test( (unsigned int)0 ) );\n static_assert( test( (unsigned long)0 ) );\n static_assert( test( (unsigned long long)0 ) );\n \n-// std::ceil2(T) shall not participate in overload resolution\n+// std::bit_ceil(T) shall not participate in overload resolution\n // unless T is an unsigned integer type.\n struct X { constexpr bool did_not_match() { return true; } };\n constexpr X test(...) { return X{}; }", "previous_filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2.cc"}, {"sha": "96cd08a201769a2dd17f6c1e73f7040f6cba0d79", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_ceil_neg.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_ceil_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_ceil_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_ceil_neg.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -0,0 +1,75 @@\n+// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a -D_GLIBCXX_ASSERTIONS\" }\n+// { dg-do run { target c++2a } }\n+// { dg-xfail-run-if \"__glibcxx_assert in bit_ceil should fail\" { *-*-* } }\n+\n+#include <bit>\n+#include <limits>\n+\n+// P1355R2: not a constant expression if the result is not representable\n+\n+template<auto N, typename = void>\n+  struct bit_ceil_valid\n+  : std::false_type { };\n+\n+template<auto N>\n+  struct bit_ceil_valid<N, std::void_t<char[(std::bit_ceil(N), 1)]>>\n+  : std::true_type { };\n+\n+template<typename T>\n+  constexpr T max = std::numeric_limits<T>::max();\n+template<typename T>\n+  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);\n+\n+static_assert( bit_ceil_valid<maxpow2<unsigned char>>() );\n+static_assert( !bit_ceil_valid<maxpow2<unsigned char> + (unsigned char)1>() );\n+\n+static_assert( !bit_ceil_valid<max<unsigned char>>() );\n+static_assert( !bit_ceil_valid<max<unsigned char> - (unsigned char)1>() );\n+\n+static_assert( bit_ceil_valid<maxpow2<unsigned short>>() );\n+static_assert( !bit_ceil_valid<maxpow2<unsigned short> + (unsigned short)1>() );\n+static_assert( !bit_ceil_valid<max<unsigned short>>() );\n+static_assert( !bit_ceil_valid<max<unsigned short> - (unsigned short)1>() );\n+\n+static_assert( bit_ceil_valid<maxpow2<unsigned int>>() );\n+static_assert( !bit_ceil_valid<maxpow2<unsigned int> + 1u>() );\n+static_assert( !bit_ceil_valid<max<unsigned int>>() );\n+static_assert( !bit_ceil_valid<max<unsigned int> - 1u>() );\n+\n+static_assert( bit_ceil_valid<maxpow2<unsigned long>>() );\n+static_assert( !bit_ceil_valid<maxpow2<unsigned long> + 1ul>() );\n+static_assert( !bit_ceil_valid<max<unsigned long>>() );\n+static_assert( !bit_ceil_valid<max<unsigned long> - 1ul>() );\n+\n+static_assert( bit_ceil_valid<maxpow2<unsigned long long>>() );\n+static_assert( !bit_ceil_valid<maxpow2<unsigned long long> + 1ull>() );\n+static_assert( !bit_ceil_valid<max<unsigned long long>>() );\n+static_assert( !bit_ceil_valid<max<unsigned long long> - 1ull>() );\n+\n+void\n+test01()\n+{\n+  std::bit_ceil( maxpow2<unsigned> + 1u ); // should fail __glibcxx_assert\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "d818d87454957254abb9ff6d67ea981a919e82d7", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_floor.cc", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_floor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_floor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_floor.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -24,36 +24,36 @@\n template<typename UInt>\n constexpr auto\n test(UInt x)\n--> decltype(std::floor2(x))\n+-> decltype(std::bit_floor(x))\n {\n-  static_assert( noexcept(std::floor2(x)) );\n+  static_assert( noexcept(std::bit_floor(x)) );\n \n-  static_assert( std::floor2(UInt(0)) == 0 );\n-  static_assert( std::floor2(UInt(1)) == 1 );\n-  static_assert( std::floor2(UInt(2)) == 2 );\n-  static_assert( std::floor2(UInt(3)) == 2 );\n-  static_assert( std::floor2(UInt(4)) == 4 );\n-  static_assert( std::floor2(UInt(0x11)) == 0x10 );\n-  static_assert( std::floor2(UInt(0x20)) == 0x20 );\n+  static_assert( std::bit_floor(UInt(0)) == 0 );\n+  static_assert( std::bit_floor(UInt(1)) == 1 );\n+  static_assert( std::bit_floor(UInt(2)) == 2 );\n+  static_assert( std::bit_floor(UInt(3)) == 2 );\n+  static_assert( std::bit_floor(UInt(4)) == 4 );\n+  static_assert( std::bit_floor(UInt(0x11)) == 0x10 );\n+  static_assert( std::bit_floor(UInt(0x20)) == 0x20 );\n \n   if constexpr (std::numeric_limits<UInt>::digits > 8)\n   {\n-    static_assert( std::floor2(UInt(0x201)) == 0x200 );\n-    static_assert( std::floor2(UInt(0x8ff)) == 0x800 );\n-    static_assert( std::floor2(UInt(0x1000)) == 0x1000 );\n+    static_assert( std::bit_floor(UInt(0x201)) == 0x200 );\n+    static_assert( std::bit_floor(UInt(0x8ff)) == 0x800 );\n+    static_assert( std::bit_floor(UInt(0x1000)) == 0x1000 );\n   }\n \n   if constexpr (std::numeric_limits<UInt>::digits > 32)\n   {\n-    static_assert( std::floor2(UInt(0xabcdef)) == 0x800000 );\n-    static_assert( std::floor2(UInt(0x1000000)) == 0x1000000 );\n-    static_assert( std::floor2(UInt(0x1000001)) == 0x1000000 );\n+    static_assert( std::bit_floor(UInt(0xabcdef)) == 0x800000 );\n+    static_assert( std::bit_floor(UInt(0x1000000)) == 0x1000000 );\n+    static_assert( std::bit_floor(UInt(0x1000001)) == 0x1000000 );\n   }\n \n   if constexpr (std::numeric_limits<UInt>::digits > 64)\n   {\n-    static_assert( std::floor2(UInt(1) << 64) == (UInt(1) << 64) );\n-    static_assert( std::floor2(UInt(3) << 64) == (UInt(2) << 64) );\n+    static_assert( std::bit_floor(UInt(1) << 64) == (UInt(1) << 64) );\n+    static_assert( std::bit_floor(UInt(3) << 64) == (UInt(2) << 64) );\n   }\n \n   return true;\n@@ -65,7 +65,7 @@ static_assert( test( (unsigned int)0 ) );\n static_assert( test( (unsigned long)0 ) );\n static_assert( test( (unsigned long long)0 ) );\n \n-// std::floor2(T) shall not participate in overload resolution\n+// std::bit_floor(T) shall not participate in overload resolution\n // unless T is an unsigned integer type.\n struct X { constexpr bool did_not_match() { return true; } };\n constexpr X test(...) { return X{}; }", "previous_filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/floor2.cc"}, {"sha": "b5716228ce3d3a71c32dfe0519af5fa5d4f6291f", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/bit_width.cc", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_width.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_width.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fbit_width.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -24,36 +24,36 @@\n template<typename UInt>\n constexpr auto\n test(UInt x)\n--> decltype(std::log2p1(x))\n+-> decltype(std::bit_width(x))\n {\n-  static_assert( noexcept(std::log2p1(x)) );\n+  static_assert( noexcept(std::bit_width(x)) );\n \n-  static_assert( std::log2p1(UInt(0)) == 0 );\n-  static_assert( std::log2p1(UInt(1)) == 1 );\n-  static_assert( std::log2p1(UInt(2)) == 2 );\n-  static_assert( std::log2p1(UInt(3)) == 2 );\n-  static_assert( std::log2p1(UInt(4)) == 3 );\n-  static_assert( std::log2p1(UInt(0x11)) == 5 );\n-  static_assert( std::log2p1(UInt(0x20)) == 6 );\n+  static_assert( std::bit_width(UInt(0)) == 0 );\n+  static_assert( std::bit_width(UInt(1)) == 1 );\n+  static_assert( std::bit_width(UInt(2)) == 2 );\n+  static_assert( std::bit_width(UInt(3)) == 2 );\n+  static_assert( std::bit_width(UInt(4)) == 3 );\n+  static_assert( std::bit_width(UInt(0x11)) == 5 );\n+  static_assert( std::bit_width(UInt(0x20)) == 6 );\n \n   if constexpr (std::numeric_limits<UInt>::digits > 8)\n   {\n-    static_assert( std::log2p1(UInt(0x201)) == 10 );\n-    static_assert( std::log2p1(UInt(0x8ff)) == 12 );\n-    static_assert( std::log2p1(UInt(0x1000)) == 13 );\n+    static_assert( std::bit_width(UInt(0x201)) == 10 );\n+    static_assert( std::bit_width(UInt(0x8ff)) == 12 );\n+    static_assert( std::bit_width(UInt(0x1000)) == 13 );\n   }\n \n   if constexpr (std::numeric_limits<UInt>::digits > 32)\n   {\n-    static_assert( std::log2p1(UInt(0xabcdef)) == 24 );\n-    static_assert( std::log2p1(UInt(0x1000000)) == 25 );\n-    static_assert( std::log2p1(UInt(0x1000001)) == 25 );\n+    static_assert( std::bit_width(UInt(0xabcdef)) == 24 );\n+    static_assert( std::bit_width(UInt(0x1000000)) == 25 );\n+    static_assert( std::bit_width(UInt(0x1000001)) == 25 );\n   }\n \n   if constexpr (std::numeric_limits<UInt>::digits > 64)\n   {\n-    static_assert( std::log2p1(UInt(1) << 64) == 65 );\n-    static_assert( std::log2p1(UInt(3) << 64) == 66 );\n+    static_assert( std::bit_width(UInt(1) << 64) == 65 );\n+    static_assert( std::bit_width(UInt(3) << 64) == 66 );\n   }\n \n   return true;\n@@ -65,7 +65,7 @@ static_assert( test( (unsigned int)0 ) );\n static_assert( test( (unsigned long)0 ) );\n static_assert( test( (unsigned long long)0 ) );\n \n-// std::log2p1(T) shall not participate in overload resolution\n+// std::bit_width(T) shall not participate in overload resolution\n // unless T is an unsigned integer type.\n struct X { constexpr bool did_not_match() { return true; } };\n constexpr X test(...) { return X{}; }", "previous_filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/log2p1.cc"}, {"sha": "b5391936e3deaded1722cef662cf5e8a0527df13", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2_neg.cc", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd23cdb1743b41baed0b937c4b359b9422490ca7/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd23cdb1743b41baed0b937c4b359b9422490ca7/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2_neg.cc?ref=cd23cdb1743b41baed0b937c4b359b9422490ca7", "patch": "@@ -1,75 +0,0 @@\n-// Copyright (C) 2019-2020 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// { dg-options \"-std=gnu++2a -D_GLIBCXX_ASSERTIONS\" }\n-// { dg-do run { target c++2a } }\n-// { dg-xfail-run-if \"__glibcxx_assert in ceil2 should fail\" { *-*-* } }\n-\n-#include <bit>\n-#include <limits>\n-\n-// P1355R2: not a constant expression if the result is not representable\n-\n-template<auto N, typename = void>\n-  struct ceil2_valid\n-  : std::false_type { };\n-\n-template<auto N>\n-  struct ceil2_valid<N, std::void_t<char[(std::ceil2(N), 1)]>>\n-  : std::true_type { };\n-\n-template<typename T>\n-  constexpr T max = std::numeric_limits<T>::max();\n-template<typename T>\n-  constexpr T maxpow2 = T(1) << (std::numeric_limits<T>::digits - 1);\n-\n-static_assert( ceil2_valid<maxpow2<unsigned char>>() );\n-static_assert( !ceil2_valid<maxpow2<unsigned char> + (unsigned char)1>() );\n-\n-static_assert( !ceil2_valid<max<unsigned char>>() );\n-static_assert( !ceil2_valid<max<unsigned char> - (unsigned char)1>() );\n-\n-static_assert( ceil2_valid<maxpow2<unsigned short>>() );\n-static_assert( !ceil2_valid<maxpow2<unsigned short> + (unsigned short)1>() );\n-static_assert( !ceil2_valid<max<unsigned short>>() );\n-static_assert( !ceil2_valid<max<unsigned short> - (unsigned short)1>() );\n-\n-static_assert( ceil2_valid<maxpow2<unsigned int>>() );\n-static_assert( !ceil2_valid<maxpow2<unsigned int> + 1u>() );\n-static_assert( !ceil2_valid<max<unsigned int>>() );\n-static_assert( !ceil2_valid<max<unsigned int> - 1u>() );\n-\n-static_assert( ceil2_valid<maxpow2<unsigned long>>() );\n-static_assert( !ceil2_valid<maxpow2<unsigned long> + 1ul>() );\n-static_assert( !ceil2_valid<max<unsigned long>>() );\n-static_assert( !ceil2_valid<max<unsigned long> - 1ul>() );\n-\n-static_assert( ceil2_valid<maxpow2<unsigned long long>>() );\n-static_assert( !ceil2_valid<maxpow2<unsigned long long> + 1ull>() );\n-static_assert( !ceil2_valid<max<unsigned long long>>() );\n-static_assert( !ceil2_valid<max<unsigned long long> - 1ull>() );\n-\n-void\n-test01()\n-{\n-  std::ceil2( maxpow2<unsigned> + 1u ); // should fail __glibcxx_assert\n-}\n-\n-int main()\n-{\n-  test01();\n-}"}, {"sha": "ac115ef4c5e84ec79ff11e36708f02850b7706db", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/has_single_bit.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fhas_single_bit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9866abe31ec47f493ff40f525ad970bb60906c4b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fhas_single_bit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fhas_single_bit.cc?ref=9866abe31ec47f493ff40f525ad970bb60906c4b", "patch": "@@ -0,0 +1,148 @@\n+// Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+#include <limits>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::has_single_bit(x))\n+{\n+  static_assert( noexcept(std::has_single_bit(x)) );\n+\n+  static_assert( ! std::has_single_bit( (UInt)0 ) );\n+  static_assert( ! std::has_single_bit( (UInt)-1 ) );\n+  static_assert( ! std::has_single_bit( (UInt)3 ) );\n+  static_assert( ! std::has_single_bit( (UInt)0x0f ) );\n+  static_assert( ! std::has_single_bit( (UInt)0xff ) );\n+  static_assert( ! std::has_single_bit( (UInt)0x0a ) );\n+  static_assert( ! std::has_single_bit( (UInt)0xa0 ) );\n+\n+  constexpr UInt one = 1;\n+  static_assert( std::has_single_bit( (UInt)(one << 0) ) );\n+\n+  static_assert( std::has_single_bit( (UInt)(one << 1) ) );\n+  static_assert( std::has_single_bit( (UInt)(one << 2) ) );\n+  static_assert( std::has_single_bit( (UInt)(one << 3) ) );\n+  static_assert( std::has_single_bit( (UInt)(one << 4) ) );\n+  static_assert( std::has_single_bit( (UInt)(one << 5) ) );\n+  static_assert( std::has_single_bit( (UInt)(one << 6) ) );\n+  static_assert( std::has_single_bit( (UInt)(one << 7) ) );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::has_single_bit( (UInt)(one << 8) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 9) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 10) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 11) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 12) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 13) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 14) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 15) ) );\n+\n+    static_assert( ! std::has_single_bit( (UInt)0xf000 ) );\n+    static_assert( ! std::has_single_bit( (UInt)0xff00 ) );\n+    static_assert( ! std::has_single_bit( (UInt)0xf0f0 ) );\n+    static_assert( ! std::has_single_bit( (UInt)0xf00f ) );\n+    static_assert( ! std::has_single_bit( (UInt)0x0f0f ) );\n+    static_assert( ! std::has_single_bit( (UInt)0x00ff ) );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 16)\n+  {\n+    static_assert( std::has_single_bit( (UInt)(one << 16) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 17) ) );\n+    static_assert( ! std::has_single_bit( (UInt)((one << 16) + 1) ) );\n+    static_assert( ! std::has_single_bit( (UInt)((one << 16) + 0x10) ) );\n+  }\n+\n+  // msp340 target has 20-bit __GLIBCXX_TYPE_INT_N_0 type\n+  if constexpr (std::numeric_limits<UInt>::digits > 20)\n+  {\n+    static_assert( std::has_single_bit( (UInt)(one << 20) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 21) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 24) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 28) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 31) ) );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 32)\n+  {\n+    static_assert( std::has_single_bit( (UInt)(one << 32) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 33) ) );\n+    static_assert( std::has_single_bit( (UInt)(one << 41) ) );\n+\n+    static_assert( ! std::has_single_bit( (UInt)((one << 32) + 1) ) );\n+    static_assert( ! std::has_single_bit( (UInt)((one << 32) + (one << 31)) ) );\n+    static_assert( ! std::has_single_bit( (UInt)((one << 33) + 1) ) );\n+    static_assert( ! std::has_single_bit( (UInt)((one << 33) + (one << 32)) ) );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits == 64)\n+  {\n+    static_assert( std::has_single_bit( (UInt)(one << 63) ) );\n+\n+    static_assert( ! std::has_single_bit( (UInt)((one << 63) + 1) ) );\n+    static_assert( ! std::has_single_bit( (UInt)((one << 63) + (one << 8)) ) );\n+    static_assert( ! std::has_single_bit( (UInt)((one << 63) + (one << 32)) ) );\n+  }\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::has_single_bit(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif\n+\n+#include <cstddef>\n+static_assert( test( (std::byte)0 ).did_not_match() );"}, {"sha": "a0a4d89a54f575540337828e47df5217b1eee1e1", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ispow2.cc", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd23cdb1743b41baed0b937c4b359b9422490ca7/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fispow2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd23cdb1743b41baed0b937c4b359b9422490ca7/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fispow2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fispow2.cc?ref=cd23cdb1743b41baed0b937c4b359b9422490ca7", "patch": "@@ -1,148 +0,0 @@\n-// Copyright (C) 2018-2020 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-// { dg-options \"-std=gnu++2a\" }\n-// { dg-do compile { target c++2a } }\n-\n-#include <bit>\n-#include <limits>\n-\n-template<typename UInt>\n-constexpr auto\n-test(UInt x)\n--> decltype(std::ispow2(x))\n-{\n-  static_assert( noexcept(std::ispow2(x)) );\n-\n-  static_assert( ! std::ispow2( (UInt)0 ) );\n-  static_assert( ! std::ispow2( (UInt)-1 ) );\n-  static_assert( ! std::ispow2( (UInt)3 ) );\n-  static_assert( ! std::ispow2( (UInt)0x0f ) );\n-  static_assert( ! std::ispow2( (UInt)0xff ) );\n-  static_assert( ! std::ispow2( (UInt)0x0a ) );\n-  static_assert( ! std::ispow2( (UInt)0xa0 ) );\n-\n-  constexpr UInt one = 1;\n-  static_assert( std::ispow2( (UInt)(one << 0) ) );\n-\n-  static_assert( std::ispow2( (UInt)(one << 1) ) );\n-  static_assert( std::ispow2( (UInt)(one << 2) ) );\n-  static_assert( std::ispow2( (UInt)(one << 3) ) );\n-  static_assert( std::ispow2( (UInt)(one << 4) ) );\n-  static_assert( std::ispow2( (UInt)(one << 5) ) );\n-  static_assert( std::ispow2( (UInt)(one << 6) ) );\n-  static_assert( std::ispow2( (UInt)(one << 7) ) );\n-\n-  if constexpr (std::numeric_limits<UInt>::digits > 8)\n-  {\n-    static_assert( std::ispow2( (UInt)(one << 8) ) );\n-    static_assert( std::ispow2( (UInt)(one << 9) ) );\n-    static_assert( std::ispow2( (UInt)(one << 10) ) );\n-    static_assert( std::ispow2( (UInt)(one << 11) ) );\n-    static_assert( std::ispow2( (UInt)(one << 12) ) );\n-    static_assert( std::ispow2( (UInt)(one << 13) ) );\n-    static_assert( std::ispow2( (UInt)(one << 14) ) );\n-    static_assert( std::ispow2( (UInt)(one << 15) ) );\n-\n-    static_assert( ! std::ispow2( (UInt)0xf000 ) );\n-    static_assert( ! std::ispow2( (UInt)0xff00 ) );\n-    static_assert( ! std::ispow2( (UInt)0xf0f0 ) );\n-    static_assert( ! std::ispow2( (UInt)0xf00f ) );\n-    static_assert( ! std::ispow2( (UInt)0x0f0f ) );\n-    static_assert( ! std::ispow2( (UInt)0x00ff ) );\n-  }\n-\n-  if constexpr (std::numeric_limits<UInt>::digits > 16)\n-  {\n-    static_assert( std::ispow2( (UInt)(one << 16) ) );\n-    static_assert( std::ispow2( (UInt)(one << 17) ) );\n-    static_assert( ! std::ispow2( (UInt)((one << 16) + 1) ) );\n-    static_assert( ! std::ispow2( (UInt)((one << 16) + 0x10) ) );\n-  }\n-\n-  // msp340 target has 20-bit __GLIBCXX_TYPE_INT_N_0 type\n-  if constexpr (std::numeric_limits<UInt>::digits > 20)\n-  {\n-    static_assert( std::ispow2( (UInt)(one << 20) ) );\n-    static_assert( std::ispow2( (UInt)(one << 21) ) );\n-    static_assert( std::ispow2( (UInt)(one << 24) ) );\n-    static_assert( std::ispow2( (UInt)(one << 28) ) );\n-    static_assert( std::ispow2( (UInt)(one << 31) ) );\n-  }\n-\n-  if constexpr (std::numeric_limits<UInt>::digits > 32)\n-  {\n-    static_assert( std::ispow2( (UInt)(one << 32) ) );\n-    static_assert( std::ispow2( (UInt)(one << 33) ) );\n-    static_assert( std::ispow2( (UInt)(one << 41) ) );\n-\n-    static_assert( ! std::ispow2( (UInt)((one << 32) + 1) ) );\n-    static_assert( ! std::ispow2( (UInt)((one << 32) + (one << 31)) ) );\n-    static_assert( ! std::ispow2( (UInt)((one << 33) + 1) ) );\n-    static_assert( ! std::ispow2( (UInt)((one << 33) + (one << 32)) ) );\n-  }\n-\n-  if constexpr (std::numeric_limits<UInt>::digits == 64)\n-  {\n-    static_assert( std::ispow2( (UInt)(one << 63) ) );\n-\n-    static_assert( ! std::ispow2( (UInt)((one << 63) + 1) ) );\n-    static_assert( ! std::ispow2( (UInt)((one << 63) + (one << 8)) ) );\n-    static_assert( ! std::ispow2( (UInt)((one << 63) + (one << 32)) ) );\n-  }\n-  return true;\n-}\n-\n-static_assert( test( (unsigned char)0 ) );\n-static_assert( test( (unsigned short)0 ) );\n-static_assert( test( (unsigned int)0 ) );\n-static_assert( test( (unsigned long)0 ) );\n-static_assert( test( (unsigned long long)0 ) );\n-\n-// std::ispow2(T) shall not participate in overload resolution\n-// unless T is an unsigned integer type.\n-struct X { constexpr bool did_not_match() { return true; } };\n-constexpr X test(...) { return X{}; }\n-static_assert( test( (bool)0 ).did_not_match() );\n-static_assert( test( (char)0 ).did_not_match() );\n-static_assert( test( (int)0 ).did_not_match() );\n-static_assert( test( (char16_t)0 ).did_not_match() );\n-static_assert( test( (float)0 ).did_not_match() );\n-static_assert( test( (void*)0 ).did_not_match() );\n-static_assert( test( X{} ).did_not_match() );\n-enum E : unsigned { e };\n-static_assert( test( e ).did_not_match() );\n-\n-#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n-static_assert( test( (unsigned __int128)0 ) );\n-static_assert( test( (__int128)0 ).did_not_match() );\n-#endif\n-#if defined(__GLIBCXX_TYPE_INT_N_0)\n-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n-static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n-#endif\n-#if defined(__GLIBCXX_TYPE_INT_N_1)\n-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n-static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n-#endif\n-#if defined(__GLIBCXX_TYPE_INT_N_2)\n-static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n-static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n-#endif\n-\n-#include <cstddef>\n-static_assert( test( (std::byte)0 ).did_not_match() );"}]}