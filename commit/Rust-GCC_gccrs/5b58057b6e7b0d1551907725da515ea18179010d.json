{"sha": "5b58057b6e7b0d1551907725da515ea18179010d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI1ODA1N2I2ZTdiMGQxNTUxOTA3NzI1ZGE1MTVlYTE4MTc5MDEwZA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-27T15:31:20Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-27T22:55:14Z"}, "message": "rs6000: Write output to the builtins init file, part 3 of 3\n\n2021-07-27  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c (typemap): New struct.\n\t(TYPE_MAP_SIZE): New macro.\n\t(type_map): New initialized variable.\n\t(typemap_cmp): New function.\n\t(write_type_node): Likewise.\n\t(write_fntype_init): Implement.", "tree": {"sha": "a240cf261fef267e432351c81d7159b2066e3324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a240cf261fef267e432351c81d7159b2066e3324"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b58057b6e7b0d1551907725da515ea18179010d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b58057b6e7b0d1551907725da515ea18179010d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b58057b6e7b0d1551907725da515ea18179010d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b58057b6e7b0d1551907725da515ea18179010d/comments", "author": null, "committer": null, "parents": [{"sha": "6aacd901b800ee8a2a03123669b299a08aad0504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aacd901b800ee8a2a03123669b299a08aad0504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aacd901b800ee8a2a03123669b299a08aad0504"}], "stats": {"total": 163, "additions": 163, "deletions": 0}, "files": [{"sha": "59b0632bfebcb69de81e30a8a43d4c62dc4807d1", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b58057b6e7b0d1551907725da515ea18179010d/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b58057b6e7b0d1551907725da515ea18179010d/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=5b58057b6e7b0d1551907725da515ea18179010d", "patch": "@@ -464,6 +464,108 @@ static rbt_strings fntype_rbt;\n    identifiers to the order in which they were encountered.  */\n static rbt_strings bifo_rbt;\n \n+/* Mapping from type tokens to type node names.  */\n+struct typemap\n+{\n+  const char *key;\n+  const char *value;\n+};\n+\n+/* This table must be kept in alphabetical order, as we use binary\n+   search for table lookups in map_token_to_type_node.  The table\n+   maps tokens from a fntype string to a tree type.  For example,\n+   in \"si_ftype_hi\" we would map \"si\" to \"intSI_type_node\" and\n+   map \"hi\" to \"intHI_type_node\".  */\n+#define TYPE_MAP_SIZE 86\n+static typemap type_map[TYPE_MAP_SIZE] =\n+  {\n+    { \"bi\",\t\t\"bool_int\" },\n+    { \"bv16qi\",\t\t\"bool_V16QI\" },\n+    { \"bv1ti\",\t\t\"bool_V1TI\" },\n+    { \"bv2di\",\t\t\"bool_V2DI\" },\n+    { \"bv4si\",\t\t\"bool_V4SI\" },\n+    { \"bv8hi\",\t\t\"bool_V8HI\" },\n+    { \"ci\",\t\t\"integer\" },\n+    { \"dd\",\t\t\"dfloat64\" },\n+    { \"df\",\t\t\"double\" },\n+    { \"di\",\t\t\"long_long_integer\" },\n+    { \"hi\",\t\t\"intHI\" },\n+    { \"if\",\t\t\"ibm128_float\" },\n+    { \"ld\",\t\t\"long_double\" },\n+    { \"lg\",\t\t\"long_integer\" },\n+    { \"pbv16qi\",\t\"ptr_bool_V16QI\" },\n+    { \"pbv1ti\",\t\t\"ptr_bool_V1TI\" },\n+    { \"pbv2di\",\t\t\"ptr_bool_V2DI\" },\n+    { \"pbv4si\",\t\t\"ptr_bool_V4SI\" },\n+    { \"pbv8hi\",\t\t\"ptr_bool_V8HI\" },\n+    { \"pcvoid\",\t\t\"pcvoid\" },\n+    { \"pdd\",\t\t\"ptr_dfloat64\" },\n+    { \"pdf\",\t\t\"ptr_double\" },\n+    { \"pdi\",\t\t\"ptr_long_long_integer\" },\n+    { \"phi\",\t\t\"ptr_intHI\" },\n+    { \"pif\",\t\t\"ptr_ibm128_float\" },\n+    { \"pld\",\t\t\"ptr_long_double\" },\n+    { \"plg\",\t\t\"ptr_long_integer\" },\n+    { \"pqi\",\t\t\"ptr_intQI\" },\n+    { \"psf\",\t\t\"ptr_float\" },\n+    { \"psi\",\t\t\"ptr_intSI\" },\n+    { \"ptd\",\t\t\"ptr_dfloat128\" },\n+    { \"ptf\",\t\t\"ptr_float128\" },\n+    { \"pti\",\t\t\"ptr_intTI\" },\n+    { \"pudi\",\t\t\"ptr_long_long_unsigned\" },\n+    { \"puhi\",\t\t\"ptr_uintHI\" },\n+    { \"pulg\",\t\t\"ptr_long_unsigned\" },\n+    { \"puqi\",\t\t\"ptr_uintQI\" },\n+    { \"pusi\",\t\t\"ptr_uintSI\" },\n+    { \"puti\",\t\t\"ptr_uintTI\" },\n+    { \"puv16qi\",\t\"ptr_unsigned_V16QI\" },\n+    { \"puv1ti\",\t\t\"ptr_unsigned_V1TI\" },\n+    { \"puv2di\",\t\t\"ptr_unsigned_V2DI\" },\n+    { \"puv4si\",\t\t\"ptr_unsigned_V4SI\" },\n+    { \"puv8hi\",\t\t\"ptr_unsigned_V8HI\" },\n+    { \"pv\",\t\t\"ptr\" },\n+    { \"pv16qi\",\t\t\"ptr_V16QI\" },\n+    { \"pv1poi\",\t\t\"ptr_vector_pair\" },\n+    { \"pv1pxi\",\t\t\"ptr_vector_quad\" },\n+    { \"pv1ti\",\t\t\"ptr_V1TI\" },\n+    { \"pv2df\",\t\t\"ptr_V2DF\" },\n+    { \"pv2di\",\t\t\"ptr_V2DI\" },\n+    { \"pv4sf\",\t\t\"ptr_V4SF\" },\n+    { \"pv4si\",\t\t\"ptr_V4SI\" },\n+    { \"pv8hi\",\t\t\"ptr_V8HI\" },\n+    { \"pvp8hi\",\t\t\"ptr_pixel_V8HI\" },\n+    { \"qi\",\t\t\"intQI\" },\n+    { \"sd\",\t\t\"dfloat32\" },\n+    { \"sf\",\t\t\"float\" },\n+    { \"si\",\t\t\"intSI\" },\n+    { \"st\",\t\t\"const_str\" },\n+    { \"td\",\t\t\"dfloat128\" },\n+    { \"tf\",\t\t\"float128\" },\n+    { \"ti\",\t\t\"intTI\" },\n+    { \"udi\",\t\t\"long_long_unsigned\" },\n+    { \"uhi\",\t\t\"unsigned_intHI\" },\n+    { \"ulg\",\t\t\"long_unsigned\" },\n+    { \"uqi\",\t\t\"unsigned_intQI\" },\n+    { \"usi\",\t\t\"unsigned_intSI\" },\n+    { \"uti\",\t\t\"unsigned_intTI\" },\n+    { \"uv16qi\",\t\t\"unsigned_V16QI\" },\n+    { \"uv1ti\",\t\t\"unsigned_V1TI\" },\n+    { \"uv2di\",\t\t\"unsigned_V2DI\" },\n+    { \"uv4si\",\t\t\"unsigned_V4SI\" },\n+    { \"uv8hi\",\t\t\"unsigned_V8HI\" },\n+    { \"v\",\t\t\"void\" },\n+    { \"v16qi\",\t\t\"V16QI\" },\n+    { \"v1poi\",\t\t\"vector_pair\" },\n+    { \"v1pxi\",\t\t\"vector_quad\" },\n+    { \"v1ti\",\t\t\"V1TI\" },\n+    { \"v2df\",\t\t\"V2DF\" },\n+    { \"v2di\",\t\t\"V2DI\" },\n+    { \"v4sf\",\t\t\"V4SF\" },\n+    { \"v4si\",\t\t\"V4SI\" },\n+    { \"v8hi\",\t\t\"V8HI\" },\n+    { \"vp8hi\",\t\t\"pixel_V8HI\" },\n+  };\n+\n /* Pointer to a diagnostic function.  */\n static void (*diag) (const char *, ...)\n   __attribute__ ((format (printf, 1, 2)));\n@@ -2219,10 +2321,71 @@ write_fntype (char *str)\n   fprintf (init_file, \"tree %s;\\n\", str);\n }\n \n+/* Comparator for bsearch on the type map.  */\n+int\n+typemap_cmp (const void *key, const void *entry)\n+{\n+  return strcmp ((const char *)key, ((const typemap *)entry)->key);\n+}\n+\n+/* Write the type node corresponding to TOK.  */\n+static void\n+write_type_node (char *tok, bool indent)\n+{\n+  if (indent)\n+    fprintf (init_file, \"  \");\n+  typemap *entry = (typemap *) bsearch (tok, type_map, TYPE_MAP_SIZE,\n+\t\t\t\t\tsizeof (typemap), typemap_cmp);\n+  if (!entry)\n+    fatal (\"Type map is inconsistent.\");\n+  fprintf (init_file, \"%s_type_node\", entry->value);\n+}\n+\n /* Write an initializer for a function type identified by STR.  */\n void\n write_fntype_init (char *str)\n {\n+  char *tok;\n+\n+  /* Check whether we have a \"tf\" token in this string, representing\n+     a float128_type_node.  It's possible that float128_type_node is\n+     undefined (occurs for -maltivec -mno-vsx, for example), so we\n+     must guard against that.  */\n+  int tf_found = strstr (str, \"tf\") != NULL;\n+\n+  /* Similarly, look for decimal float tokens.  */\n+  int dfp_found = (strstr (str, \"dd\") != NULL\n+\t\t   || strstr (str, \"td\") != NULL\n+\t\t   || strstr (str, \"sd\") != NULL);\n+\n+  /* Avoid side effects of strtok on the original string by using a copy.  */\n+  char *buf = strdup (str);\n+\n+  if (tf_found)\n+    fprintf (init_file, \"  if (float128_type_node)\\n  \");\n+  else if (dfp_found)\n+    fprintf (init_file, \"  if (dfloat64_type_node)\\n  \");\n+\n+  fprintf (init_file, \"  %s\\n    = build_function_type_list (\", buf);\n+  tok = strtok (buf, \"_\");\n+  write_type_node (tok, tf_found || dfp_found);\n+  tok = strtok (0, \"_\");\n+  assert (tok);\n+  assert (!strcmp (tok, \"ftype\"));\n+\n+  tok = strtok (0, \"_\");\n+  if (tok)\n+    fprintf (init_file, \",\\n\\t\\t\\t\\t\");\n+\n+  /* Note:  A function with no arguments ends with '_ftype_v'.  */\n+  while (tok && strcmp (tok, \"v\"))\n+    {\n+      write_type_node (tok, tf_found || dfp_found);\n+      tok = strtok (0, \"_\");\n+      fprintf (init_file, \",\\n\\t\\t\\t\\t\");\n+    }\n+  fprintf (init_file, \"NULL_TREE);\\n\");\n+  free (buf);\n }\n \n /* Write everything to the header file (rs6000-builtins.h).  Return"}]}