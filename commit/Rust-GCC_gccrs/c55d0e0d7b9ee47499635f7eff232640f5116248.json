{"sha": "c55d0e0d7b9ee47499635f7eff232640f5116248", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU1ZDBlMGQ3YjllZTQ3NDk5NjM1ZjdlZmYyMzI2NDBmNTExNjI0OA==", "commit": {"author": {"name": "Magnus Fromreide", "email": "magfr@lysator.liu.se", "date": "2000-12-04T17:03:27Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-12-04T17:03:27Z"}, "message": "* sstream: Backport libstdc++-V3 sstream to V2.\n\nFrom-SVN: r38000", "tree": {"sha": "ae026a468208cc5cf7cdd5e1f7f080714c2fbea1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae026a468208cc5cf7cdd5e1f7f080714c2fbea1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c55d0e0d7b9ee47499635f7eff232640f5116248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c55d0e0d7b9ee47499635f7eff232640f5116248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c55d0e0d7b9ee47499635f7eff232640f5116248", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c55d0e0d7b9ee47499635f7eff232640f5116248/comments", "author": {"login": "magfr", "id": 38747965, "node_id": "MDQ6VXNlcjM4NzQ3OTY1", "avatar_url": "https://avatars.githubusercontent.com/u/38747965?v=4", "gravatar_id": "", "url": "https://api.github.com/users/magfr", "html_url": "https://github.com/magfr", "followers_url": "https://api.github.com/users/magfr/followers", "following_url": "https://api.github.com/users/magfr/following{/other_user}", "gists_url": "https://api.github.com/users/magfr/gists{/gist_id}", "starred_url": "https://api.github.com/users/magfr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/magfr/subscriptions", "organizations_url": "https://api.github.com/users/magfr/orgs", "repos_url": "https://api.github.com/users/magfr/repos", "events_url": "https://api.github.com/users/magfr/events{/privacy}", "received_events_url": "https://api.github.com/users/magfr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c00996a3ea28127b7392876352ad0dd32e00e1ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00996a3ea28127b7392876352ad0dd32e00e1ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c00996a3ea28127b7392876352ad0dd32e00e1ca"}], "stats": {"total": 572, "additions": 347, "deletions": 225}, "files": [{"sha": "1323c65ace5d181a8ea1f10207e2f1f9400b0632", "filename": "libstdc++/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c55d0e0d7b9ee47499635f7eff232640f5116248/libstdc%2B%2B%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c55d0e0d7b9ee47499635f7eff232640f5116248/libstdc%2B%2B%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2FChangeLog?ref=c55d0e0d7b9ee47499635f7eff232640f5116248", "patch": "@@ -1,3 +1,7 @@\n+2000-11-24  Magnus Fromreide <magfr@lysator.liu.se>\n+\n+\t* sstream: Backport libstdc++-V3 sstream to V2.\n+\n 2000-10-23  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* std/std_valarray.h (valarray::valarray): Use __valarray_copy,"}, {"sha": "45393b14761ebc8030263a7709aa13ad151a0be9", "filename": "libstdc++/sstream", "status": "modified", "additions": 343, "deletions": 225, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c55d0e0d7b9ee47499635f7eff232640f5116248/libstdc%2B%2B%2Fsstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c55d0e0d7b9ee47499635f7eff232640f5116248/libstdc%2B%2B%2Fsstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fsstream?ref=c55d0e0d7b9ee47499635f7eff232640f5116248", "patch": "@@ -1,225 +1,343 @@\n-/* This is part of libio/iostream, providing -*- C++ -*- input/output.\r\n-Copyright (C) 2000 Free Software Foundation\r\n-\r\n-This file is part of the GNU IO Library.  This library is free\r\n-software; you can redistribute it and/or modify it under the\r\n-terms of the GNU General Public License as published by the\r\n-Free Software Foundation; either version 2, or (at your option)\r\n-any later version.\r\n-\r\n-This library is distributed in the hope that it will be useful,\r\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n-GNU General Public License for more details.\r\n-\r\n-You should have received a copy of the GNU General Public License\r\n-along with this library; see the file COPYING.  If not, write to the Free\r\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\r\n-\r\n-As a special exception, if you link this library with files\r\n-compiled with a GNU compiler to produce an executable, this does not cause\r\n-the resulting executable to be covered by the GNU General Public License.\r\n-This exception does not however invalidate any other reasons why\r\n-the executable file might be covered by the GNU General Public License. */\r\n-\r\n-/* Written by Magnus Fromreide (magfr@lysator.liu.se). */\r\n-\r\n-#ifndef __SSTREAM__\r\n-#define __SSTREAM__\r\n-\r\n-#include <string>\r\n-#include <iostream.h>\r\n-#include <streambuf.h>\r\n-\r\n-namespace std\r\n-{\r\n-  class stringbuf : public streambuf\r\n-  {\r\n-  public:\r\n-    typedef char\tchar_type;\r\n-    typedef int\t\tint_type;\r\n-    typedef streampos\tpos_type;\r\n-    typedef streamoff\toff_type;\r\n-\r\n-    explicit stringbuf(int which=ios::in|ios::out) :\r\n-      streambuf(which), buf(), mode(static_cast<ios::open_mode>(which)),\r\n-      rpos(0), bufsize(1)\r\n-    { }\r\n-\t\r\n-    explicit stringbuf(const std::string &s, int which=ios::in|ios::out) :\r\n-      streambuf(which), buf(s), mode(static_cast<ios::open_mode>(which)),\r\n-      bufsize(1)\r\n-    {\r\n-      if(mode & ios::in)\r\n-\t{\r\n-\t  setg(&defbuf, &defbuf + bufsize, &defbuf + bufsize);\r\n-\t}\r\n-      if(mode & ios::out)\r\n-\t{\r\n-\t  setp(&defbuf, &defbuf + bufsize);\r\n-\t}\r\n-      rpos = (mode & ios::ate ? s.size() : 0);\r\n-    }\r\n-\t\r\n-    std::string str() const\r\n-    {\r\n-      const_cast<stringbuf*>(this)->sync();  // Sigh, really ugly hack\r\n-      return buf;\r\n-    };\r\n-\r\n-    void str(const std::string& s)\r\n-    {\r\n-      buf = s;\r\n-      if(mode & ios::in)\r\n-\t{\r\n-\t  gbump(egptr() - gptr());\r\n-\t}\r\n-      if(mode & ios::out)\r\n-\t{\r\n-\t  pbump(pbase() - pptr());\r\n-\t}\r\n-      rpos = (mode & ios::ate ? s.size() : 0);\r\n-    }\r\n-\r\n-  protected:\r\n-    inline virtual int sync();\r\n-    inline virtual int overflow(int = EOF);\r\n-    inline virtual int underflow();\r\n-  private:\r\n-    std::string\t\t\tbuf;\r\n-    ios::open_mode\t\tmode;\r\n-    std::string::size_type\trpos;\r\n-    streamsize\t\t\tbufsize;\r\n-    char\t\t\tdefbuf;\r\n-  };\r\n-\r\n-  class stringstreambase : virtual public ios {\r\n-  protected:\r\n-    stringbuf __my_sb;\r\n-  public:\r\n-    std::string str() const\r\n-    {\r\n-      return dynamic_cast<stringbuf*>(_strbuf)->str();\r\n-    }\r\n-    void str(const std::string& s)\r\n-    {\r\n-      clear();\r\n-      dynamic_cast<stringbuf*>(_strbuf)->str(s);\r\n-    }\r\n-\t\r\n-    stringbuf* rdbuf()\r\n-    {\r\n-      return &__my_sb;\r\n-    }\r\n-  protected:\r\n-    stringstreambase(int which) :\r\n-      __my_sb(which)\r\n-    {\r\n-      init (&__my_sb);\r\n-    }\r\n-\t\r\n-    stringstreambase(const std::string& s, int which) :\r\n-      __my_sb(s, which)\r\n-    {\r\n-      init (&__my_sb);\r\n-    }\r\n-  };\r\n-    \r\n-  class istringstream : public stringstreambase, public istream {\r\n-  public:\r\n-    istringstream(int which=ios::in) :\r\n-      stringstreambase(which)\r\n-    { }\r\n-\t\r\n-    istringstream(const std::string& s, int which=ios::in) :\r\n-      stringstreambase(s, which)\r\n-    { }\r\n-  };\r\n-    \r\n-  class ostringstream : public stringstreambase, public ostream {\r\n-  public:\r\n-    ostringstream(int which=ios::out) :\r\n-      stringstreambase(which)\r\n-    { }\r\n-\t\r\n-    ostringstream(const std::string& s, int which=ios::out) :\r\n-      stringstreambase(s, which)\r\n-    { }\r\n-  };\r\n-    \r\n-  class stringstream : public stringstreambase, public iostream {\r\n-  public:\r\n-    stringstream(int which=ios::in|ios::out) :\r\n-      stringstreambase(which)\r\n-    { }\r\n-    \r\n-    stringstream(const std::string &s, int which=ios::in|ios::out) :\r\n-      stringstreambase(s, which)\r\n-    { }\r\n-  };\r\n-}\r\n-\r\n-inline int std::stringbuf::sync()\r\n-{\r\n-  if((mode & ios::out) == 0)\r\n-    return EOF;\r\n-\r\n-  streamsize n = pptr() - pbase();\r\n-  if(n)\r\n-    {\r\n-      buf.replace(rpos, std::string::npos, pbase(), n);\r\n-      if(buf.size() - rpos != n)\r\n-\treturn EOF;\r\n-      rpos += n;\r\n-      pbump(-n);\r\n-      gbump(egptr() - gptr());\r\n-    }\r\n-  return 0;\r\n-}\r\n-\r\n-inline int std::stringbuf::overflow(int ch)\r\n-{\r\n-  if((mode & ios::out) == 0)\r\n-    return EOF;\r\n-\r\n-  streamsize n = pptr() - pbase();\r\n-\r\n-  if(n && sync())\r\n-    return EOF;\r\n-\r\n-  if(ch != EOF)\r\n-    {\r\n-      std::string::size_type oldSize = buf.size();\r\n-      \r\n-      buf.replace(rpos, std::string::npos, ch);\r\n-      if(buf.size() - oldSize != 1)\r\n-\treturn EOF;\r\n-      ++rpos;\r\n-    }\r\n-  return 0;\r\n-}\r\n-\r\n-inline int std::stringbuf::underflow()\r\n-{\r\n-  sync();\r\n-  if((mode & ios::in) == 0)\r\n-    {\r\n-      return EOF;\r\n-    }\r\n-  if(rpos >= buf.size())\r\n-    {\r\n-      return EOF;\r\n-    }\r\n-  \r\n-  std::string::size_type n = egptr() - eback();\r\n-  std::string::size_type s;\r\n-\r\n-  s = buf.copy(eback(), n, rpos);\r\n-  pbump(pbase() - pptr());\r\n-  gbump(eback() - gptr());\r\n-  int res = (0377 & buf[rpos]);\r\n-  rpos += s;\r\n-  return res;\r\n-}\r\n-\r\n-#endif /* not __STRSTREAM__ */\r\n+/* This is part of libio/iostream, providing -*- C++ -*- input/output.\n+Copyright (C) 2000 Free Software Foundation\n+\n+This file is part of the GNU IO Library.  This library is free\n+software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This library is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this library; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n+\n+As a special exception, if you link this library with files\n+compiled with a GNU compiler to produce an executable, this does not cause\n+the resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why\n+the executable file might be covered by the GNU General Public License. */\n+\n+/* Written by Magnus Fromreide (magfr@lysator.liu.se). */\n+/* seekoff and ideas for overflow is largely borrowed from libstdc++-v3 */\n+\n+#ifndef __SSTREAM__\n+#define __SSTREAM__\n+\n+#include <iostream.h>\n+#include <streambuf.h>\n+#include <string>\n+\n+namespace std\n+{\n+  class stringbuf : public streambuf\n+  {\n+  public:\n+    typedef char\tchar_type;\n+    typedef int\t\tint_type;\n+    typedef streampos\tpos_type;\n+    typedef streamoff\toff_type;\n+\n+    explicit\n+    stringbuf(int which=ios::in|ios::out)\n+      : streambuf(), mode(static_cast<ios::open_mode>(which)),\n+\tstream(NULL), stream_len(0)\n+    {\n+      stringbuf_init();\n+    }\n+\n+    explicit\n+    stringbuf(const string &str, int which=ios::in|ios::out)\n+      : streambuf(), mode(static_cast<ios::open_mode>(which)),\n+\tstream(NULL), stream_len(0)\n+    {\n+      if (mode & (ios::in|ios::out))\n+\t{\n+\t  stream_len = str.size();\n+\t  stream = new char_type[stream_len];\n+\t  str.copy(stream, stream_len);\n+\t}\n+      stringbuf_init();\n+    }\n+\n+    virtual\n+    ~stringbuf()\n+    {\n+      delete[] stream;\n+    }\n+\n+    string\n+    str() const\n+    {\n+      if (pbase() != 0)\n+\treturn string(stream, pptr()-pbase());\n+      else\n+\treturn string();\n+    }\n+\n+    void\n+    str(const string& str)\n+    {\n+      delete[] stream;\n+      stream_len = str.size();\n+      stream = new char_type[stream_len];\n+      str.copy(stream, stream_len);\n+      stringbuf_init();\n+    }\n+\n+  protected:\n+    // The buffer is already in gptr, so if it ends then it is out of data.\n+    virtual int\n+    underflow()\n+    {\n+      return EOF;\n+    }\n+\n+    virtual int\n+    overflow(int c = EOF)\n+    {\n+      int res;\n+      if (mode & ios::out)\n+\t{\n+\t  if (c != EOF)\n+\t    {\n+\t      streamsize old_stream_len = stream_len;\n+\t      stream_len += 1;\n+\t      char_type* new_stream = new char_type[stream_len];\n+\t      memcpy(new_stream, stream, old_stream_len);\n+\t      delete[] stream;\n+\t      stream = new_stream;\n+\t      stringbuf_sync(gptr()-eback(), pptr()-pbase());\n+\t      sputc(c);\n+\t      res = c;\n+\t    }\n+\t  else\n+\t    res = EOF;\n+\t}\n+      else\n+\tres = 0;\n+      return res;\n+    }\n+\n+    virtual streambuf*\n+    setbuf(char_type* s, streamsize n)\n+    {\n+      if (n != 0)\n+\t{\n+\t  delete[] stream;\n+\t  stream = new char_type[n];\n+\t  memcpy(stream, s, n);\n+\t  stream_len = n;\n+\t  stringbuf_sync(0, 0);\n+\t}\n+      return this;\n+    }\n+\n+    virtual pos_type\n+    seekoff(off_type off, ios::seek_dir way, int which = ios::in | ios::out)\n+    {\n+      pos_type ret =  pos_type(off_type(-1));\n+      bool testin = which & ios::in && mode & ios::in;\n+      bool testout = which & ios::out && mode & ios::out;\n+      bool testboth = testin && testout && way != ios::cur;\n+\n+      if (stream_len && ((testin != testout) || testboth))\n+\t{\n+\t  char_type* beg = stream;\n+\t  char_type* curi = NULL;\n+\t  char_type* curo = NULL;\n+\t  char_type* endi = NULL;\n+\t  char_type* endo = NULL;\n+\n+\t  if (testin)\n+\t    {\n+\t      curi = gptr();\n+\t      endi = egptr();\n+\t    }\n+\t  if (testout)\n+\t    {\n+\t      curo = pptr();\n+\t      endo = epptr();\n+\t    }\n+\n+\t  off_type newoffi = 0;\n+\t  off_type newoffo = 0;\n+\t  if (way == ios::beg)\n+\t    {\n+\t      newoffi = beg - curi;\n+\t      newoffo = beg - curo;\n+\t    }\n+\t  else if (way == ios::end)\n+\t    {\n+\t      newoffi = endi - curi;\n+\t      newoffo = endo - curo;\n+\t    }\n+\n+\t  if (testin && newoffi + off + curi - beg >= 0 &&\n+\t      endi - beg >= newoffi + off + curi - beg)\n+\t    {\n+\t      gbump(newoffi + off);\n+\t      ret = pos_type(newoffi + off + curi);\n+\t    }\n+\t  if (testout && newoffo + off + curo - beg >= 0 &&\n+\t      endo - beg >= newoffo + off + curo - beg)\n+\t    {\n+\t      pbump(newoffo + off);\n+\t      ret = pos_type(newoffo + off + curo);\n+\t    }\n+\t}\n+      return ret;\n+    }\n+\n+    virtual pos_type\n+    seekpos(pos_type sp, int which = ios::in | ios::out)\n+    {\n+      pos_type ret = seekoff(sp, ios::beg, which);\n+      return ret;\n+    }\n+\n+  private:\n+    void\n+    stringbuf_sync(streamsize i, streamsize o)\n+    {\n+      if (mode & ios::in)\n+\tsetg(stream, stream + i, stream + stream_len);\n+      if (mode & ios::out)\n+\t{\n+\t  setp(stream, stream + stream_len);\n+\t  pbump(o);\n+\t}\n+    }\n+    void\n+    stringbuf_init()\n+    {\n+      if (mode & ios::ate)\n+\tstringbuf_sync(0, stream_len);\n+      else\n+\tstringbuf_sync(0, 0);\n+    }\n+\n+  private:\n+    ios::open_mode\tmode;\n+    char_type*\t\tstream;\n+    streamsize\t\tstream_len;\n+  };\n+\f\n+  class istringstream : public istream {\n+  public:\n+    typedef char\tchar_type;\n+    typedef int\t\tint_type;\n+    typedef streampos\tpos_type;\n+    typedef streamoff\toff_type;\n+\n+    explicit\n+    istringstream(int which=ios::in)\n+      : istream(&sb), sb(which | ios::in)\n+    { }\n+\n+    explicit\n+    istringstream(const string& str, int which=ios::in)\n+      : istream(&sb), sb(str, which | ios::in)\n+    { }\n+\n+    stringbuf*\n+    rdbuf() const\n+    {\n+      return const_cast<stringbuf*>(&sb);\n+    }\n+\n+    string\n+    str() const\n+    {\n+      return rdbuf()->str();\n+    }\n+    void\n+    str(const string& s)\n+    {\n+      rdbuf()->str(s);\n+    }\n+  private:\n+    stringbuf sb;\n+  };\n+\f\n+  class ostringstream : public ostream {\n+  public:\n+    typedef char\tchar_type;\n+    typedef int\t\tint_type;\n+    typedef streampos\tpos_type;\n+    typedef streamoff\toff_type;\n+\n+    explicit\n+    ostringstream(int which=ios::out)\n+      : ostream(&sb), sb(which | ios::out)\n+    { }\n+\n+    explicit\n+    ostringstream(const string& str, int which=ios::out)\n+      : ostream(&sb), sb(str, which | ios::out)\n+    { }\n+\n+    stringbuf*\n+    rdbuf() const\n+    {\n+      return const_cast<stringbuf*>(&sb);\n+    }\n+\n+    string\n+    str() const\n+    {\n+      return rdbuf()->str();\n+    }\n+\n+    void str(const string& s)\n+    {\n+      rdbuf()->str(s);\n+    }\n+  private:\n+    stringbuf sb;\n+  };\n+\f\n+  class stringstream : public iostream {\n+  public:\n+    typedef char\tchar_type;\n+    typedef int\t\tint_type;\n+    typedef streampos\tpos_type;\n+    typedef streamoff\toff_type;\n+\n+    explicit\n+    stringstream(int which=ios::out|ios::in)\n+      : iostream(&sb), sb(which)\n+    { }\n+\n+    explicit\n+    stringstream(const string& str, int which=ios::out|ios::in)\n+      : iostream(&sb), sb(str, which)\n+    { }\n+\n+    stringbuf*\n+    rdbuf() const\n+    {\n+      return const_cast<stringbuf*>(&sb);\n+    }\n+\n+    string\n+    str() const\n+    {\n+      return rdbuf()->str();\n+    }\n+\n+    void\n+    str(const string& s)\n+    {\n+      rdbuf()->str(s);\n+    }\n+  private:\n+    stringbuf sb;\n+  };\n+};\n+\n+#endif /* not __STRSTREAM__ */"}]}