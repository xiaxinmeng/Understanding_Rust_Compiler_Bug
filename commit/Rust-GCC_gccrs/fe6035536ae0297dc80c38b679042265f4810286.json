{"sha": "fe6035536ae0297dc80c38b679042265f4810286", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU2MDM1NTM2YWUwMjk3ZGM4MGMzOGI2NzkwNDIyNjVmNDgxMDI4Ng==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2013-01-20T14:40:16Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2013-01-20T14:40:16Z"}, "message": "pa.md (atomic_loaddi, [...]): New patterns.\n\n\t* config/pa/pa.md (atomic_loaddi, atomic_loaddi_1, atomic_storedi,\n\tatomic_storedi_1): New patterns.\n\nFrom-SVN: r195320", "tree": {"sha": "b68b3e9ea6848ec5193e26cb97d2024f9a489718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b68b3e9ea6848ec5193e26cb97d2024f9a489718"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe6035536ae0297dc80c38b679042265f4810286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6035536ae0297dc80c38b679042265f4810286", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe6035536ae0297dc80c38b679042265f4810286", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe6035536ae0297dc80c38b679042265f4810286/comments", "author": null, "committer": null, "parents": [{"sha": "0128489557a1d96656f0049a3f0cd3ca4f6f1dc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0128489557a1d96656f0049a3f0cd3ca4f6f1dc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0128489557a1d96656f0049a3f0cd3ca4f6f1dc9"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "dbc0cc1a3ba4f78733b4e4efd38c9867b74d5968", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6035536ae0297dc80c38b679042265f4810286/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6035536ae0297dc80c38b679042265f4810286/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe6035536ae0297dc80c38b679042265f4810286", "patch": "@@ -1,3 +1,8 @@\n+2013-01-20  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* config/pa/pa.md (atomic_loaddi, atomic_loaddi_1, atomic_storedi,\n+\tatomic_storedi_1): New patterns.\n+\n 2013-01-20  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n \n \tbtver2 pipeline descriptions."}, {"sha": "de2eb3aa8d132744b7c8d4953cb3cf53491ac653", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe6035536ae0297dc80c38b679042265f4810286/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe6035536ae0297dc80c38b679042265f4810286/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=fe6035536ae0297dc80c38b679042265f4810286", "patch": "@@ -699,6 +699,67 @@\n (include \"predicates.md\")\n (include \"constraints.md\")\n \f\n+;; Atomic instructions\n+\n+;; All memory loads and stores access storage atomically except\n+;; for one exception.  The STORE BYTES, STORE DOUBLE BYTES, and\n+;; doubleword loads and stores are not guaranteed to be atomic\n+;; when referencing the I/O address space.\n+\n+;; Implement atomic DImode load using 64-bit floating point load and copy.\n+\n+(define_expand \"atomic_loaddi\"\n+  [(match_operand:DI 0 \"register_operand\")              ;; val out\n+   (match_operand:DI 1 \"memory_operand\")                ;; memory\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n+  operands[2] = gen_reg_rtx (DImode);\n+  expand_mem_thread_fence (model);\n+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1], operands[2]));\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n+    expand_mem_thread_fence (model);\n+  DONE;\n+})\n+\n+(define_insn \"atomic_loaddi_1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (mem:DI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=&f\"))]\n+  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n+  \"{fldds|fldd} 0(%1),%2\\;{fstds|fstd} %2,-16(%%sp)\\;{ldws|ldw} -16(%%sp),%0\\;{ldws|ldw} -12(%%sp),%R0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"16\")])\n+\n+;; Implement atomic DImode store using copy and 64-bit floating point store.\n+\n+(define_expand \"atomic_storedi\"\n+  [(match_operand:DI 0 \"memory_operand\")                ;; memory\n+   (match_operand:DI 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n+  operands[2] = gen_reg_rtx (DImode);\n+  expand_mem_thread_fence (model);\n+  emit_insn (gen_atomic_storedi_1 (operands[0], operands[1], operands[2]));\n+  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n+    expand_mem_thread_fence (model);\n+  DONE;\n+})\n+\n+(define_insn \"atomic_storedi_1\"\n+  [(set (mem:DI (match_operand:SI 0 \"register_operand\" \"r\"))\n+        (match_operand:DI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=&f\"))]\n+  \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n+  \"{stws|stw} %1,-16(%%sp)\\;{stws|stw} %R1,-12(%%sp)\\;{fldds|fldd} -16(%%sp),%2\\;{fstds|fstd} %2,0(%0)\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"16\")])\n+\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n "}]}