{"sha": "64ee94908dee791e0f1ee24f740a9fc734fc7002", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRlZTk0OTA4ZGVlNzkxZTBmMWVlMjRmNzQwYTlmYzczNGZjNzAwMg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@apple.com", "date": "2006-09-19T23:56:17Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-09-19T23:56:17Z"}, "message": "tm.texi (OBJC_JBLEN): Describe.\n\n2006-09-19  Eric Christopher  <echristo@apple.com>\n\n        * doc/tm.texi (OBJC_JBLEN): Describe.\n        * config/i386/darwin.h (OBJC_JBLEN): Define.\n        * config/rs6000/darwin.h: Ditto.\n\n2006-09-19  Eric Christopher  <echristo@apple.com>\n\n        * objc-act.c (JBLEN): Rename to OBJC_JBLEN,\n        default to something innocuous.\n        (build_next_objc_exception_stuff): Rename JBLEN.\n\nFrom-SVN: r117066", "tree": {"sha": "c69f5f84d38935b21c920b0de96f5b6100d6adea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c69f5f84d38935b21c920b0de96f5b6100d6adea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64ee94908dee791e0f1ee24f740a9fc734fc7002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ee94908dee791e0f1ee24f740a9fc734fc7002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64ee94908dee791e0f1ee24f740a9fc734fc7002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ee94908dee791e0f1ee24f740a9fc734fc7002/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "83a4f4f746dd8db00bbec21f9e31f72b160bc24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a4f4f746dd8db00bbec21f9e31f72b160bc24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a4f4f746dd8db00bbec21f9e31f72b160bc24c"}], "stats": {"total": 188, "additions": 104, "deletions": 84}, "files": [{"sha": "a961b5cfd279290d9d1a543cd2d450f820128cbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64ee94908dee791e0f1ee24f740a9fc734fc7002", "patch": "@@ -1,3 +1,9 @@\n+2006-09-19  Eric Christopher  <echristo@apple.com>\n+\n+\t* doc/tm.texi (OBJC_JBLEN): Describe.\n+\t* config/i386/darwin.h (OBJC_JBLEN): Define.\n+\t* config/rs6000/darwin.h: Ditto.\n+\n 2006-09-19  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR rtl-optimization/21299"}, {"sha": "51259dbdc4389f7d7c4725ce5f193bc21ccdd40b", "filename": "gcc/config/i386/darwin.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fconfig%2Fi386%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fconfig%2Fi386%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdarwin.h?ref=64ee94908dee791e0f1ee24f740a9fc734fc7002", "patch": "@@ -37,6 +37,9 @@ Boston, MA 02110-1301, USA.  */\n #endif\n #endif\n \n+/* Size of the Obj-C jump buffer.  */\n+#define OBJC_JBLEN ((TARGET_64BIT) ? ((9 * 2) + 3 + 16) : (18))\n+\n #undef TARGET_FPMATH_DEFAULT\n #define TARGET_FPMATH_DEFAULT (TARGET_SSE ? FPMATH_SSE : FPMATH_387)\n "}, {"sha": "1b3f71714e281dc5ffaeb22fbb1bef506efad9bf", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=64ee94908dee791e0f1ee24f740a9fc734fc7002", "patch": "@@ -40,6 +40,9 @@\n \n #define TARGET_OBJECT_FORMAT OBJECT_MACHO\n \n+/* Size of the Obj-C jump buffer.  */\n+#define OBJC_JBLEN ((TARGET_64BIT) ? (26*2 + 18*2 + 129 + 1) : (26 + 18*2 + 129 + 1))\n+\n /* We're not ever going to do TOCs.  */\n \n #define TARGET_TOC 0"}, {"sha": "44f1aaa59cd862974245aeb93277c0536bc962ff", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=64ee94908dee791e0f1ee24f740a9fc734fc7002", "patch": "@@ -4198,7 +4198,7 @@ the caller.\n If @var{incoming} is nonzero and the address is to be found on the\n stack, return a @code{mem} which refers to the frame pointer. If\n @var{incoming} is @code{2}, the result is being used to fetch the\n-structure value address at the beginning of a function.  If you need \n+structure value address at the beginning of a function.  If you need\n to emit adjusting code, you should do it at this point.\n @end deftypefn\n \n@@ -6038,12 +6038,12 @@ per instruction data structures.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_SPECULATE_INSN (rtx @var{insn}, int @var{request}, rtx *@var{new_pat})\n-This hook is called by the insn scheduler when @var{insn} has only \n-speculative dependencies and therefore can be scheduled speculatively.  \n-The hook is used to check if the pattern of @var{insn} has a speculative \n-version and, in case of successful check, to generate that speculative \n-pattern.  The hook should return 1, if the instruction has a speculative form, \n-or -1, if it doesn't.  @var{request} describes the type of requested \n+This hook is called by the insn scheduler when @var{insn} has only\n+speculative dependencies and therefore can be scheduled speculatively.\n+The hook is used to check if the pattern of @var{insn} has a speculative\n+version and, in case of successful check, to generate that speculative\n+pattern.  The hook should return 1, if the instruction has a speculative form,\n+or -1, if it doesn't.  @var{request} describes the type of requested\n speculation.  If the return value equals 1 then @var{new_pat} is assigned\n the generated speculative pattern.\n @end deftypefn\n@@ -6056,12 +6056,12 @@ instruction should branch to recovery code, or zero otherwise.\n \n @deftypefn {Target Hook} rtx TARGET_SCHED_GEN_CHECK (rtx @var{insn}, rtx @var{label}, int @var{mutate_p})\n This hook is called by the insn scheduler to generate a pattern for recovery\n-check instruction.  If @var{mutate_p} is zero, then @var{insn} is a \n-speculative instruction for which the check should be generated.  \n-@var{label} is either a label of a basic block, where recovery code should \n-be emitted, or a null pointer, when requested check doesn't branch to \n-recovery code (a simple check).  If @var{mutate_p} is nonzero, then \n-a pattern for a branchy check corresponding to a simple check denoted by \n+check instruction.  If @var{mutate_p} is zero, then @var{insn} is a\n+speculative instruction for which the check should be generated.\n+@var{label} is either a label of a basic block, where recovery code should\n+be emitted, or a null pointer, when requested check doesn't branch to\n+recovery code (a simple check).  If @var{mutate_p} is nonzero, then\n+a pattern for a branchy check corresponding to a simple check denoted by\n @var{insn} should be generated.  In this case @var{label} can't be null.\n @end deftypefn\n \n@@ -6070,20 +6070,20 @@ This hook is used as a workaround for\n @samp{TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD} not being\n called on the first instruction of the ready list.  The hook is used to\n discard speculative instruction that stand first in the ready list from\n-being scheduled on the current cycle.  For non-speculative instructions, \n+being scheduled on the current cycle.  For non-speculative instructions,\n the hook should always return nonzero.  For example, in the ia64 backend\n the hook is used to cancel data speculative insns when the ALAT table\n is nearly full.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_SCHED_SET_SCHED_FLAGS (unsigned int *@var{flags}, spec_info_t @var{spec_info})\n-This hook is used by the insn scheduler to find out what features should be \n+This hook is used by the insn scheduler to find out what features should be\n enabled/used.  @var{flags} initially may have either the SCHED_RGN or SCHED_EBB\n-bit set.  This denotes the scheduler pass for which the data should be \n+bit set.  This denotes the scheduler pass for which the data should be\n provided.  The target backend should modify @var{flags} by modifying\n the bits corresponding to the following features: USE_DEPS_LIST, USE_GLAT,\n-DETACH_LIFE_INFO, and DO_SPECULATION.  For the DO_SPECULATION feature \n-an additional structure @var{spec_info} should be filled by the target.  \n+DETACH_LIFE_INFO, and DO_SPECULATION.  For the DO_SPECULATION feature\n+an additional structure @var{spec_info} should be filled by the target.\n The structure describes speculation types that can be used in the scheduler.\n @end deftypefn\n \n@@ -9915,3 +9915,8 @@ This macro determines whether to use the JCR section to register Java\n classes. By default, TARGET_USE_JCR_SECTION is defined to 1 if both\n SUPPORTS_WEAK and TARGET_HAVE_NAMED_SECTIONS are true, else 0.\n @end defmac\n+\n+@defmac OBJC_JBLEN\n+This macro determines the size of the objective C jump buffer for the\n+NeXT runtime. By default, OBJC_JBLEN is defined to an innocuous value.\n+@end defmac"}, {"sha": "ec777a64ac064c5f5012d5d72d639f78a99c85e8", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=64ee94908dee791e0f1ee24f740a9fc734fc7002", "patch": "@@ -1,3 +1,9 @@\n+2006-09-19  Eric Christopher  <echristo@apple.com>\n+\n+\t* objc-act.c (JBLEN): Rename to OBJC_JBLEN,\n+\tdefault to something innocuous.\n+\t(build_next_objc_exception_stuff): Rename JBLEN.\n+\n 2006-07-28  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* Make-lang.in: Use $(HEADER_H) instead of header.h in dependencies."}, {"sha": "7ac785f53909828a77251ef9429f926423645166", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 63, "deletions": 66, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ee94908dee791e0f1ee24f740a9fc734fc7002/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=64ee94908dee791e0f1ee24f740a9fc734fc7002", "patch": "@@ -820,7 +820,7 @@ objc_build_struct (tree class, tree fields, tree super_name)\n \t in the class.  */\n       DECL_SIZE (base)\n \t= (field && TREE_CODE (field) == FIELD_DECL\n-\t   ? size_binop (PLUS_EXPR, \n+\t   ? size_binop (PLUS_EXPR,\n \t\t\t size_binop (PLUS_EXPR,\n \t\t\t\t     size_binop\n \t\t\t\t     (MULT_EXPR,\n@@ -911,7 +911,7 @@ objc_build_volatilized_type (tree type)\n      a new one.  */\n   t = build_variant_type_copy (type);\n   TYPE_VOLATILE (t) = 1;\n-  \n+\n   return t;\n }\n \n@@ -1539,7 +1539,7 @@ synth_module_prologue (void)\n \n   objc_object_reference = xref_tag (RECORD_TYPE, objc_object_id);\n   objc_class_reference = xref_tag (RECORD_TYPE, objc_class_id);\n-  \n+\n   objc_object_type = build_pointer_type (objc_object_reference);\n   objc_class_type = build_pointer_type (objc_class_reference);\n \n@@ -1644,8 +1644,8 @@ synth_module_prologue (void)\n \t\t\t\t\t type, 0, NOT_BUILT_IN,\n \t\t\t\t\t NULL, NULL_TREE);\n       TREE_NOTHROW (umsg_fast_decl) = 0;\n-      DECL_ATTRIBUTES (umsg_fast_decl) \n-\t= tree_cons (get_identifier (\"hard_coded_address\"), \n+      DECL_ATTRIBUTES (umsg_fast_decl)\n+\t= tree_cons (get_identifier (\"hard_coded_address\"),\n \t\t     build_int_cst (NULL_TREE, OFFS_MSGSEND_FAST),\n \t\t     NULL_TREE);\n #else\n@@ -1676,10 +1676,10 @@ synth_module_prologue (void)\n       /* typedef id (*IMP)(id, SEL, ...); */\n       tree IMP_type\n \t= build_pointer_type\n-\t  (build_function_type (objc_object_type,      \n-\t\t\t\ttree_cons (NULL_TREE, objc_object_type,      \n-\t\t\t\t\t   tree_cons (NULL_TREE, objc_selector_type,      \n-\t\t\t\t\t\t      NULL_TREE))));      \n+\t  (build_function_type (objc_object_type,\n+\t\t\t\ttree_cons (NULL_TREE, objc_object_type,\n+\t\t\t\t\t   tree_cons (NULL_TREE, objc_selector_type,\n+\t\t\t\t\t\t      NULL_TREE))));\n \n       /* IMP objc_msg_lookup (id, SEL); */\n       type\n@@ -2323,7 +2323,7 @@ build_module_descriptor (void)\n \n    static void __objc_gnu_init (void) {\n      __objc_exec_class (&L_OBJC_MODULES);\n-   }  */ \n+   }  */\n \n static void\n build_module_initializer_routine (void)\n@@ -2332,7 +2332,7 @@ build_module_initializer_routine (void)\n \n #ifdef OBJCPLUS\n   push_lang_context (lang_name_c); /* extern \"C\" */\n-#endif                                     \n+#endif\n \n   objc_push_parm (build_decl (PARM_DECL, NULL_TREE, void_type_node));\n   objc_start_function (get_identifier (TAG_GNUINIT),\n@@ -2577,7 +2577,7 @@ build_selector_translation_table (void)\n \t\t\t       tree_cons (NULL_TREE,\n \t\t\t\t\t  build_int_cst (NULL_TREE, 0),\n \t\t\t\t\t  tree_cons (NULL_TREE,\n-\t\t\t\t\t\t     build_int_cst (NULL_TREE, 0), \n+\t\t\t\t\t\t     build_int_cst (NULL_TREE, 0),\n \t\t\t\t\t\t     NULL_TREE)))\n \t\t\t    : build_int_cst (NULL_TREE, 0), initlist);\n       initlist = objc_build_constructor (TREE_TYPE (UOBJC_SELECTOR_TABLE_decl),\n@@ -2804,11 +2804,11 @@ add_objc_string (tree ident, enum string_section section)\n     }\n \n   decl = build_objc_string_decl (section);\n-  \n+\n   type = build_array_type\n \t (char_type_node,\n \t  build_index_type\n-\t  (build_int_cst (NULL_TREE, \n+\t  (build_int_cst (NULL_TREE,\n \t\t\t  IDENTIFIER_LENGTH (ident))));\n   decl = start_var_decl (type, IDENTIFIER_POINTER (DECL_NAME (decl)));\n   string_expr = my_build_string (IDENTIFIER_LENGTH (ident) + 1,\n@@ -2848,7 +2848,7 @@ build_objc_string_decl (enum string_section section)\n   DECL_ARTIFICIAL (decl) = 1;\n #ifdef OBJCPLUS\n   DECL_THIS_STATIC (decl) = 1; /* squash redeclaration errors */\n-#endif  \n+#endif\n \n   make_decl_rtl (decl);\n   pushdecl_top_level (decl);\n@@ -2985,7 +2985,7 @@ objc_is_id (tree type)\n   return (objc_object_type && type\n \t  && (IS_ID (type) || IS_CLASS (type) || IS_SUPER (type))\n \t  ? type\n-\t  : NULL_TREE); \n+\t  : NULL_TREE);\n }\n \n /* Check whether TYPE is either 'id', 'Class', or a pointer to an ObjC\n@@ -3011,7 +3011,7 @@ objc_is_object_ptr (tree type)\n static int\n objc_is_gcable_type (tree type, int or_strong_p)\n {\n-  tree name; \n+  tree name;\n \n   if (!TYPE_P (type))\n     return 0;\n@@ -3074,7 +3074,7 @@ objc_build_ivar_assignment (tree outervar, tree lhs, tree rhs)\n \n   offs = convert (integer_type_node, build_unary_op (ADDR_EXPR, offs, 0));\n   offs = fold (offs);\n-  func_params = tree_cons (NULL_TREE, \n+  func_params = tree_cons (NULL_TREE,\n \tconvert (objc_object_type, rhs),\n \t    tree_cons (NULL_TREE, convert (objc_object_type, outervar),\n \t\ttree_cons (NULL_TREE, offs,\n@@ -3103,7 +3103,7 @@ objc_build_strong_cast_assignment (tree lhs, tree rhs)\n   tree func_params = tree_cons (NULL_TREE,\n \tconvert (objc_object_type, rhs),\n \t    tree_cons (NULL_TREE, convert (build_pointer_type (objc_object_type),\n-\t\t      build_unary_op (ADDR_EXPR, lhs, 0)), \n+\t\t      build_unary_op (ADDR_EXPR, lhs, 0)),\n \t\t    NULL_TREE));\n \n   assemble_external (objc_assign_strong_cast_decl);\n@@ -3215,7 +3215,7 @@ objc_generate_write_barrier (tree lhs, enum tree_code modifycode, tree rhs)\n     }\n \n   outer_gc_p = objc_is_gcable_p (outer);\n-  \n+\n   /* Handle ivar assignments. */\n   if (objc_is_ivar_reference_p (lhs))\n     {\n@@ -3249,7 +3249,7 @@ objc_generate_write_barrier (tree lhs, enum tree_code modifycode, tree rhs)\n     }\n \n   /* Likewise, intercept assignment to global/static variables if their type is\n-     GC-marked.  */    \n+     GC-marked.  */\n   if (objc_is_global_reference_p (outer))\n     {\n       if (indirect_p)\n@@ -3375,7 +3375,7 @@ static tree\n objc_create_temporary_var (tree type)\n {\n   tree decl;\n- \n+\n   decl = build_decl (VAR_DECL, NULL_TREE, type);\n   TREE_USED (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n@@ -3542,7 +3542,7 @@ next_sjlj_build_enter_and_setjmp (void)\n /* Build:\n \n    DECL = objc_exception_extract(&_stack);  */\n-   \n+\n static tree\n next_sjlj_build_exc_extract (tree decl)\n {\n@@ -3762,10 +3762,10 @@ objc_begin_try_stmt (location_t try_locus, tree body)\n     objc_mark_locals_volatile (NULL);\n }\n \n-/* Called just after parsing \"@catch (parm)\".  Open a binding level, \n+/* Called just after parsing \"@catch (parm)\".  Open a binding level,\n    enter DECL into the binding level, and initialize it.  Leave the\n    binding level open while the body of the compound statement is parsed.  */\n-   \n+\n void\n objc_begin_catch_clause (tree decl)\n {\n@@ -3953,19 +3953,16 @@ objc_build_synchronized (location_t start_locus, tree mutex, tree body)\n \n    struct _objc_exception_data\n    {\n-     int buf[JBLEN];\n+     int buf[OBJC_JBLEN];\n      void *pointers[4];\n    }; */\n \n /* The following yuckiness should prevent users from having to #include\n    <setjmp.h> in their code... */\n \n-#ifdef TARGET_POWERPC\n-/* snarfed from /usr/include/ppc/setjmp.h */\n-#define JBLEN (26 + 36 + 129 + 1)\n-#else\n-/* snarfed from /usr/include/i386/{setjmp,signal}.h */\n-#define JBLEN 18\n+/* Define to a harmless positive value so the below code doesn't die.  */\n+#ifndef OBJC_JBLEN\n+#define OBJC_JBLEN 18\n #endif\n \n static void\n@@ -3976,9 +3973,9 @@ build_next_objc_exception_stuff (void)\n   objc_exception_data_template\n     = start_struct (RECORD_TYPE, get_identifier (UTAG_EXCDATA));\n \n-  /* int buf[JBLEN]; */\n+  /* int buf[OBJC_JBLEN]; */\n \n-  index = build_index_type (build_int_cst (NULL_TREE, JBLEN - 1));\n+  index = build_index_type (build_int_cst (NULL_TREE, OBJC_JBLEN - 1));\n   field_decl = create_field_decl (build_array_type (integer_type_node, index),\n \t\t\t\t  \"buf\");\n   field_decl_chain = field_decl;\n@@ -4020,7 +4017,7 @@ build_next_objc_exception_stuff (void)\n     = builtin_function (TAG_EXCEPTIONTRYEXIT, temp_type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n \n   /* int objc_exception_match(id, id); */\n-  temp_type \n+  temp_type\n     = build_function_type (integer_type_node,\n \t\t\t   tree_cons (NULL_TREE, objc_object_type,\n \t\t\t\t      tree_cons (NULL_TREE, objc_object_type,\n@@ -4046,8 +4043,8 @@ build_next_objc_exception_stuff (void)\n   objc_assign_ivar_fast_decl\n     = builtin_function (TAG_ASSIGNIVAR_FAST, temp_type, 0,\n \t\t\tNOT_BUILT_IN, NULL, NULL_TREE);\n-  DECL_ATTRIBUTES (objc_assign_ivar_fast_decl) \n-    = tree_cons (get_identifier (\"hard_coded_address\"), \n+  DECL_ATTRIBUTES (objc_assign_ivar_fast_decl)\n+    = tree_cons (get_identifier (\"hard_coded_address\"),\n \t\t build_int_cst (NULL_TREE, OFFS_ASSIGNIVAR_FAST),\n \t\t NULL_TREE);\n #else\n@@ -5278,7 +5275,7 @@ build_dispatch_table_initializer (tree type, tree entries)\n \n       elemlist\n \t= tree_cons (NULL_TREE,\n-\t\t     convert (ptr_type_node, \n+\t\t     convert (ptr_type_node,\n \t\t\t      build_unary_op (ADDR_EXPR,\n \t\t\t\t\t      METHOD_DEFINITION (entries), 1)),\n \t\t     elemlist);\n@@ -5524,7 +5521,7 @@ build_category_initializer (tree type, tree cat_name, tree class_name,\n   else\n     {\n       expr = convert (build_pointer_type\n-\t\t      (build_pointer_type \n+\t\t      (build_pointer_type\n \t\t       (objc_protocol_template)),\n \t\t      build_unary_op (ADDR_EXPR, protocol_list, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n@@ -5626,7 +5623,7 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n   else\n     {\n       expr = convert (build_pointer_type\n-\t\t      (build_pointer_type \n+\t\t      (build_pointer_type\n \t\t       (objc_protocol_template)),\n \t\t      build_unary_op (ADDR_EXPR, protocol_list, 0));\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n@@ -6072,12 +6069,12 @@ check_duplicates (hash hsh, int methods, int is_class)\n \t  warn_with_method (methods ? \"using\" : \"found\",\n \t\t\t    ((TREE_CODE (meth) == INSTANCE_METHOD_DECL)\n \t\t\t     ? '-'\n-\t\t\t     : '+'), \n+\t\t\t     : '+'),\n \t\t\t    meth);\n \t  for (loop = hsh->list; loop; loop = loop->next)\n \t    warn_with_method (\"also found\",\n \t\t\t      ((TREE_CODE (loop->value) == INSTANCE_METHOD_DECL)\n-\t\t\t       ? '-' \n+\t\t\t       ? '-'\n \t\t\t       : '+'),\n \t\t\t      loop->value);\n         }\n@@ -6234,7 +6231,7 @@ lookup_method_in_hash_lists (tree sel_name, int is_class)\n   if (!is_class)\n     method_prototype = hash_lookup (nst_method_hash_list,\n \t\t\t\t    sel_name);\n-\t\t\t\t\t\n+\n   if (!method_prototype)\n     {\n       method_prototype = hash_lookup (cls_method_hash_list,\n@@ -6373,7 +6370,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t     exist locally as part of the @implementation.  */\n \t  if (!method_prototype && objc_implementation_context\n \t     && CLASS_NAME (objc_implementation_context)\n-\t\t== OBJC_TYPE_NAME (rtype))\t\t\t\n+\t\t== OBJC_TYPE_NAME (rtype))\n \t    method_prototype\n \t      = lookup_method\n \t\t((class_tree\n@@ -6396,7 +6393,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t     lookup as if we were messaging 'id'.  */\n \t  rtype = rprotos = NULL_TREE;\n \t}\n-    }\t\n+    }\n \n \n   /* For 'id' or 'Class' receivers, search in the global hash table\n@@ -6496,7 +6493,7 @@ build_objc_method_call (int super_flag, tree method_prototype,\n   tree method, t;\n \n   lookup_object = build_c_cast (rcv_p, lookup_object);\n-    \n+\n   /* Use SAVE_EXPR to avoid evaluating the receiver twice.  */\n   lookup_object = save_expr (lookup_object);\n \n@@ -6526,7 +6523,7 @@ build_objc_method_call (int super_flag, tree method_prototype,\n \n       /* First, call the lookup function to get a pointer to the method,\n \t then cast the pointer, then call it with the method arguments.  */\n-      \n+\n       object = (super_flag ? self_decl : lookup_object);\n \n       t = tree_cons (NULL_TREE, selector, NULL_TREE);\n@@ -6820,13 +6817,13 @@ lookup_method (tree mchain, tree method)\n /* Look up a class (if OBJC_LOOKUP_CLASS is set in FLAGS) or instance method\n    in INTERFACE, along with any categories and protocols attached thereto.\n    If method is not found, and the OBJC_LOOKUP_NO_SUPER is _not_ set in FLAGS,\n-   recursively examine the INTERFACE's superclass.  If OBJC_LOOKUP_CLASS is \n+   recursively examine the INTERFACE's superclass.  If OBJC_LOOKUP_CLASS is\n    set, OBJC_LOOKUP_NO_SUPER is cleared, and no suitable class method could\n    be found in INTERFACE or any of its superclasses, look for an _instance_\n    method of the same name in the root class as a last resort.\n \n    If a suitable method cannot be found, return NULL_TREE.  */\n-   \n+\n static tree\n lookup_method_static (tree interface, tree ident, int flags)\n {\n@@ -6944,7 +6941,7 @@ objc_add_method (tree class, tree method, int is_class)\n \t   || TREE_CODE (class) == CATEGORY_INTERFACE_TYPE)\n \t  && !comp_proto_with_proto (method, mth, 1))\n \terror (\"duplicate declaration of method %<%c%s%>\",\n-\t\tis_class ? '+' : '-', \n+\t\tis_class ? '+' : '-',\n \t\tIDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n     }\n \n@@ -7228,7 +7225,7 @@ objc_is_public (tree expr, tree identifier)\n \t\t\t TREE_PRIVATE (decl) ? \"@private\" : \"@protected\");\n \t\treturn 1;\n \t      }\n-\t\t\n+\n \t      error (\"instance variable %qs is declared %s\",\n \t\t     IDENTIFIER_POINTER (identifier),\n \t\t     TREE_PRIVATE (decl) ? \"private\" : \"protected\");\n@@ -7552,7 +7549,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \terror (\"duplicate interface declaration for class %qs\",\n #else\n \twarning (0, \"duplicate interface declaration for class %qs\",\n-#endif\t\n+#endif\n         IDENTIFIER_POINTER (class_name));\n       else\n         add_class (class, class_name);\n@@ -7927,7 +7924,7 @@ encode_array (tree type, int curtype, int format)\n \n   if (TREE_INT_CST_LOW (TYPE_SIZE (array_of)) == 0)\n    sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)0);\n-  else \n+  else\n     sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC,\n \t     TREE_INT_CST_LOW (an_int_cst)\n \t      / TREE_INT_CST_LOW (TYPE_SIZE (array_of)));\n@@ -7953,7 +7950,7 @@ encode_aggregate_fields (tree type, int pointed_to, int curtype, int format)\n #endif\n \n       /* Recursively encode fields of embedded base classes.  */\n-      if (DECL_ARTIFICIAL (field) && !DECL_NAME (field) \n+      if (DECL_ARTIFICIAL (field) && !DECL_NAME (field)\n \t  && TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n \t{\n \t  encode_aggregate_fields (TREE_TYPE (field),\n@@ -7998,7 +7995,7 @@ encode_aggregate_within (tree type, int curtype, int format, int left,\n      original struct and its tag name (if any).  */\n   type = TYPE_MAIN_VARIANT (type);\n   name = OBJC_TYPE_NAME (type);\n-  /* Open parenth/bracket.  */  \t\t\t\n+  /* Open parenth/bracket.  */\n   obstack_1grow (&util_obstack, left);\n \n   /* Encode the struct/union tag name, or '?' if a tag was\n@@ -8022,7 +8019,7 @@ encode_aggregate_within (tree type, int curtype, int format, int left,\n       obstack_1grow (&util_obstack, '=');\n       encode_aggregate_fields (type, pointed_to, curtype, format);\n     }\n-  /* Close parenth/bracket.  */  \t\t\t\n+  /* Close parenth/bracket.  */\n   obstack_1grow (&util_obstack, right);\n }\n \n@@ -8080,7 +8077,7 @@ encode_type (tree type, int curtype, int format)\n \t{\n \tcase 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n \tcase 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;\n-\tcase 32: \n+\tcase 32:\n \t  if (type == long_unsigned_type_node\n \t      || type == long_integer_type_node)\n \t         c = TYPE_UNSIGNED (type) ? 'L' : 'l';\n@@ -8124,7 +8121,7 @@ encode_type (tree type, int curtype, int format)\n \n   else if (code == FUNCTION_TYPE) /* '?' */\n     obstack_1grow (&util_obstack, '?');\n-    \n+\n   else if (code == COMPLEX_TYPE)\n     {\n       obstack_1grow (&util_obstack, 'j');\n@@ -8240,7 +8237,7 @@ objc_push_parm (tree parm)\n   ((TYPE_READONLY (TREE_TYPE (parm)) ? TYPE_QUAL_CONST : 0)\n    | (TYPE_RESTRICT (TREE_TYPE (parm)) ? TYPE_QUAL_RESTRICT : 0)\n    | (TYPE_VOLATILE (TREE_TYPE (parm)) ? TYPE_QUAL_VOLATILE : 0), parm);\n-  \n+\n   objc_parmlist = chainon (objc_parmlist, parm);\n }\n \n@@ -8271,7 +8268,7 @@ objc_get_parm_info (int have_ellipsis)\n     {\n       tree next = TREE_CHAIN (parm_info);\n \n-      TREE_CHAIN (parm_info) = NULL_TREE; \n+      TREE_CHAIN (parm_info) = NULL_TREE;\n       parm_info = pushdecl (parm_info);\n       finish_decl (parm_info, NULL_TREE, NULL_TREE);\n       parm_info = next;\n@@ -8353,7 +8350,7 @@ start_method_def (tree method)\n     {\n       tree akey;\n \n-      for (akey = TREE_CHAIN (METHOD_ADD_ARGS (method)); \n+      for (akey = TREE_CHAIN (METHOD_ADD_ARGS (method));\n \t   akey; akey = TREE_CHAIN (akey))\n \t{\n \t  objc_push_parm (TREE_VALUE (akey));\n@@ -8835,7 +8832,7 @@ gen_declaration (tree decl)\n \tsprintf (errbuf + strlen (errbuf), \": \" HOST_WIDE_INT_PRINT_DEC,\n \t\t TREE_INT_CST_LOW (DECL_INITIAL (decl)));\n     }\n-  \n+\n   return errbuf;\n }\n \n@@ -8857,7 +8854,7 @@ gen_type_name_0 (tree type)\n \tinner = TREE_TYPE (inner);\n \n       gen_type_name_0 (inner);\n-      \n+\n       if (!POINTER_TYPE_P (inner))\n \tstrcat (errbuf, \" \");\n \n@@ -8873,7 +8870,7 @@ gen_type_name_0 (tree type)\n \t\tchar sz[20];\n \n \t\tsprintf (sz, HOST_WIDE_INT_PRINT_DEC,\n-\t\t\t (TREE_INT_CST_LOW \n+\t\t\t (TREE_INT_CST_LOW\n \t\t\t  (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) + 1));\n \t\tstrcat (errbuf, sz);\n \t      }\n@@ -8895,15 +8892,15 @@ gen_type_name_0 (tree type)\n   /* For 'id' and 'Class', adopted protocols are stored in the pointee.  */\n   if (objc_is_id (orig))\n     orig = TREE_TYPE (orig);\n-  \n+\n   proto = TYPE_HAS_OBJC_INFO (orig) ? TYPE_OBJC_PROTOCOL_LIST (orig) : NULL_TREE;\n \n   if (proto)\n     {\n       strcat (errbuf, \" <\");\n \n       while (proto) {\n-\tstrcat (errbuf, \n+\tstrcat (errbuf,\n \t\tIDENTIFIER_POINTER (PROTOCOL_NAME (TREE_VALUE (proto))));\n \tproto = TREE_CHAIN (proto);\n \tstrcat (errbuf, proto ? \", \" : \">\");"}]}