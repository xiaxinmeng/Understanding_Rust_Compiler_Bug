{"sha": "2f07b722ed0302ded58710b6d8485d85d785b4ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYwN2I3MjJlZDAzMDJkZWQ1ODcxMGI2ZDg0ODVkODVkNzg1YjRlZQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-06-02T10:19:18Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-06-02T10:19:18Z"}, "message": "re PR tree-optimization/48052 (loop not vectorized if index is \"unsigned int\")\n\n\n\tPR tree-optimization/48052\n\t* cfgloop.h (struct control_iv): New.\n\t(struct loop): New field control_ivs.\n\t* tree-ssa-loop-niter.c : Include \"stor-layout.h\".\n\t(number_of_iterations_lt): Set no_overflow information.\n\t(number_of_iterations_exit): Init control iv in niter struct.\n\t(record_control_iv): New.\n\t(estimate_numbers_of_iterations_loop): Call record_control_iv.\n\t(loop_exits_before_overflow): New.  Interface factored out of\n\tscev_probably_wraps_p.\n\t(scev_probably_wraps_p): Factor loop niter related code into\n\tloop_exits_before_overflow.\n\t(free_numbers_of_iterations_estimates_loop): Free control ivs.\n\t* tree-ssa-loop-niter.h (free_loop_control_ivs): New.\n\n\tgcc/testsuite/ChangeLog\n\tPR tree-optimization/48052\n\t* gcc.dg/tree-ssa/scev-8.c: New.\n\t* gcc.dg/tree-ssa/scev-9.c: New.\n\t* gcc.dg/tree-ssa/scev-10.c: New.\n\t* gcc.dg/vect/pr48052.c: New.\n\nFrom-SVN: r224020", "tree": {"sha": "5afe55006761ff005599d44216fad2d86d243e58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5afe55006761ff005599d44216fad2d86d243e58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f07b722ed0302ded58710b6d8485d85d785b4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f07b722ed0302ded58710b6d8485d85d785b4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f07b722ed0302ded58710b6d8485d85d785b4ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f07b722ed0302ded58710b6d8485d85d785b4ee/comments", "author": null, "committer": null, "parents": [{"sha": "b47717225bfbffb2e06c0f2a7e72b458ba40fc17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47717225bfbffb2e06c0f2a7e72b458ba40fc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47717225bfbffb2e06c0f2a7e72b458ba40fc17"}], "stats": {"total": 458, "additions": 397, "deletions": 61}, "files": [{"sha": "9f3ec684279a9e899ab0c5db40a48df5154369d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -1,3 +1,20 @@\n+2015-06-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/48052\n+\t* cfgloop.h (struct control_iv): New.\n+\t(struct loop): New field control_ivs.\n+\t* tree-ssa-loop-niter.c : Include \"stor-layout.h\".\n+\t(number_of_iterations_lt): Set no_overflow information.\n+\t(number_of_iterations_exit): Init control iv in niter struct.\n+\t(record_control_iv): New.\n+\t(estimate_numbers_of_iterations_loop): Call record_control_iv.\n+\t(loop_exits_before_overflow): New.  Interface factored out of\n+\tscev_probably_wraps_p.\n+\t(scev_probably_wraps_p): Factor loop niter related code into\n+\tloop_exits_before_overflow.\n+\t(free_numbers_of_iterations_estimates_loop): Free control ivs.\n+\t* tree-ssa-loop-niter.h (free_loop_control_ivs): New.\n+\n 2015-06-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gimplify.c (gimplify_modify_expr): Do not create a DECL_DEBUG_EXPR if"}, {"sha": "b0116786d49c0c9f3458fa39aafd2681be97e835", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -116,6 +116,14 @@ enum loop_estimation\n   EST_LAST\n };\n \n+/* The structure describing non-overflow control induction variable for\n+   loop's exit edge.  */\n+struct GTY ((chain_next (\"%h.next\"))) control_iv {\n+  tree base;\n+  tree step;\n+  struct control_iv *next;\n+};\n+\n /* Structure to hold information for each natural loop.  */\n struct GTY ((chain_next (\"%h.next\"))) loop {\n   /* Index into loops array.  */\n@@ -203,6 +211,9 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n \n+  /* Non-overflow control ivs of a loop.  */\n+  struct control_iv *control_ivs;\n+\n   /* Head of the cyclic list of the exits of the loop.  */\n   struct loop_exit *exits;\n "}, {"sha": "39617815ba6e20571c1efbb6d9eaac70a84d9285", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -1,3 +1,11 @@\n+2015-06-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/48052\n+\t* gcc.dg/tree-ssa/scev-8.c: New.\n+\t* gcc.dg/tree-ssa/scev-9.c: New.\n+\t* gcc.dg/tree-ssa/scev-10.c: New.\n+\t* gcc.dg/vect/pr48052.c: New.\n+\n 2015-06-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/vect/vec-scal-opt.c: Adjust regexp."}, {"sha": "fd815b2fe08eaa943e9e4a7945f107557bee24c7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-10.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (signed char s, signed char l)\n+{\n+  signed char i;\n+  int sum = 0;\n+\n+  for (i = s; i < l; i++)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Address of array reference is scev.  */\n+/* { dg-final { scan-tree-dump-times \"use \\[0-9\\]\\n  address\" 1 \"ivopts\" } } */\n+\n+"}, {"sha": "766f674d55be90ad782ed34af21ff65e7ffede4e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-8.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-8.c?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo1 (long long s, long long l)\n+{\n+  long long i;\n+\n+  for (i = s; i < l; i++)\n+    {\n+      a[(short)i] = 0;\n+    }\n+  return 0;\n+}\n+\n+int\n+foo2 (unsigned char s, unsigned char l, unsigned char c)\n+{\n+  unsigned char i, step = 1;\n+  int sum = 0;\n+\n+  for (i = s; i < l; i++)\n+    {\n+      sum += a[c];\n+      c += step;\n+    }\n+\n+  return sum;\n+}\n+\n+int\n+foo3 (unsigned char s, unsigned char l, unsigned char c)\n+{\n+  unsigned char i;\n+  int sum = 0;\n+\n+  for (i = s; i != l; i += c)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+int\n+foo4 (unsigned char s, unsigned char l)\n+{\n+  unsigned char i;\n+  int sum = 0;\n+\n+  for (i = s; i != l; i++)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Address of array references are not scevs.  */\n+/* { dg-final { scan-tree-dump-not \"use \\[0-9\\]\\n  address\" \"ivopts\" } } */"}, {"sha": "22e96c00d485440fca41b927a6cc5b69029f5a92", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-9.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (unsigned char s, unsigned char l)\n+{\n+  unsigned char i;\n+  int sum = 0;\n+\n+  for (i = s; i < l; i += 1)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Address of array reference is scev.  */\n+/* { dg-final { scan-tree-dump-times \"use \\[0-9\\]\\n  address\" 1 \"ivopts\" } } */\n+"}, {"sha": "7e99c5508fdbd552176a6c9a01708163a7799a15", "filename": "gcc/testsuite/gcc.dg/vect/pr48052.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr48052.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr48052.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr48052.c?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+int foo(int* A, int* B,  unsigned start, unsigned BS)\n+{\n+  int s;\n+  for (unsigned k = start;  k < start + BS; k++)\n+    {\n+      s += A[k] * B[k];\n+    }\n+\n+  return s;\n+}\n+\n+int bar(int* A, int* B, unsigned BS)\n+{\n+  int s;\n+  for (unsigned k = 0;  k < BS; k++)\n+    {\n+      s += A[k] * B[k];\n+    }\n+\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */"}, {"sha": "3f6bebe63dc9d3aa1d3090f9005441a157248f97", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 227, "deletions": 61, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"wide-int.h\"\n #include \"inchash.h\"\n #include \"tree.h\"\n+#include \"stor-layout.h\"\n #include \"fold-const.h\"\n #include \"calls.h\"\n #include \"hashtab.h\"\n@@ -1184,6 +1185,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n       niter->niter = delta;\n       niter->max = widest_int::from (wi::from_mpz (niter_type, bnds->up, false),\n \t\t\t\t     TYPE_SIGN (niter_type));\n+      niter->control.no_overflow = true;\n       return true;\n     }\n \n@@ -1965,6 +1967,9 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n     return false;\n \n   niter->assumptions = boolean_false_node;\n+  niter->control.base = NULL_TREE;\n+  niter->control.step = NULL_TREE;\n+  niter->control.no_overflow = false;\n   last = last_stmt (exit->src);\n   if (!last)\n     return false;\n@@ -2744,6 +2749,29 @@ record_estimate (struct loop *loop, tree bound, const widest_int &i_bound,\n   record_niter_bound (loop, new_i_bound, realistic, upper);\n }\n \n+/* Records the control iv analyzed in NITER for LOOP if the iv is valid\n+   and doesn't overflow.  */\n+\n+static void\n+record_control_iv (struct loop *loop, struct tree_niter_desc *niter)\n+{\n+  struct control_iv *iv;\n+\n+  if (!niter->control.base || !niter->control.step)\n+    return;\n+\n+  if (!integer_onep (niter->assumptions) || !niter->control.no_overflow)\n+    return;\n+\n+  iv = ggc_alloc<control_iv> ();\n+  iv->base = niter->control.base;\n+  iv->step = niter->control.step;\n+  iv->next = loop->control_ivs;\n+  loop->control_ivs = iv;\n+\n+  return;\n+}\n+\n /* Record the estimate on number of iterations of LOOP based on the fact that\n    the induction variable BASE + STEP * i evaluated in STMT does not wrap and\n    its values belong to the range <LOW, HIGH>.  REALISTIC is true if the\n@@ -3467,6 +3495,7 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n       record_estimate (loop, niter, niter_desc.max,\n \t\t       last_stmt (ex->src),\n \t\t       true, ex == likely_exit, true);\n+      record_control_iv (loop, &niter_desc);\n     }\n   exits.release ();\n \n@@ -3773,6 +3802,189 @@ nowrap_type_p (tree type)\n   return false;\n }\n \n+/* Return true if we can prove LOOP is exited before evolution of induction\n+   variabled {BASE, STEP} overflows with respect to its type bound.  */\n+\n+static bool\n+loop_exits_before_overflow (tree base, tree step,\n+\t\t\t    gimple at_stmt, struct loop *loop)\n+{\n+  widest_int niter;\n+  struct control_iv *civ;\n+  struct nb_iter_bound *bound;\n+  tree e, delta, step_abs, unsigned_base;\n+  tree type = TREE_TYPE (step);\n+  tree unsigned_type, valid_niter;\n+\n+  /* Don't issue signed overflow warnings.  */\n+  fold_defer_overflow_warnings ();\n+\n+  /* Compute the number of iterations before we reach the bound of the\n+     type, and verify that the loop is exited before this occurs.  */\n+  unsigned_type = unsigned_type_for (type);\n+  unsigned_base = fold_convert (unsigned_type, base);\n+\n+  if (tree_int_cst_sign_bit (step))\n+    {\n+      tree extreme = fold_convert (unsigned_type,\n+\t\t\t\t   lower_bound_in_type (type, type));\n+      delta = fold_build2 (MINUS_EXPR, unsigned_type, unsigned_base, extreme);\n+      step_abs = fold_build1 (NEGATE_EXPR, unsigned_type,\n+\t\t\t      fold_convert (unsigned_type, step));\n+    }\n+  else\n+    {\n+      tree extreme = fold_convert (unsigned_type,\n+\t\t\t\t   upper_bound_in_type (type, type));\n+      delta = fold_build2 (MINUS_EXPR, unsigned_type, extreme, unsigned_base);\n+      step_abs = fold_convert (unsigned_type, step);\n+    }\n+\n+  valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);\n+\n+  estimate_numbers_of_iterations_loop (loop);\n+\n+  if (max_loop_iterations (loop, &niter)\n+      && wi::fits_to_tree_p (niter, TREE_TYPE (valid_niter))\n+      && (e = fold_binary (GT_EXPR, boolean_type_node, valid_niter,\n+\t\t\t   wide_int_to_tree (TREE_TYPE (valid_niter),\n+\t\t\t\t\t     niter))) != NULL\n+      && integer_nonzerop (e))\n+    {\n+      fold_undefer_and_ignore_overflow_warnings ();\n+      return true;\n+    }\n+  if (at_stmt)\n+    for (bound = loop->bounds; bound; bound = bound->next)\n+      {\n+\tif (n_of_executions_at_most (at_stmt, bound, valid_niter))\n+\t  {\n+\t    fold_undefer_and_ignore_overflow_warnings ();\n+\t    return true;\n+\t  }\n+      }\n+  fold_undefer_and_ignore_overflow_warnings ();\n+\n+  /* Try to prove loop is exited before {base, step} overflows with the\n+     help of analyzed loop control IV.  This is done only for IVs with\n+     constant step because otherwise we don't have the information.  */\n+  if (TREE_CODE (step) == INTEGER_CST)\n+    for (civ = loop->control_ivs; civ; civ = civ->next)\n+      {\n+\tenum tree_code code;\n+\ttree stepped, extreme, civ_type = TREE_TYPE (civ->step);\n+\n+\t/* Have to consider type difference because operand_equal_p ignores\n+\t   that for constants.  */\n+\tif (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (civ_type)\n+\t    || element_precision (type) != element_precision (civ_type))\n+\t  continue;\n+\n+\t/* Only consider control IV with same step.  */\n+\tif (!operand_equal_p (step, civ->step, 0))\n+\t  continue;\n+\n+\t/* Done proving if this is a no-overflow control IV.  */\n+\tif (operand_equal_p (base, civ->base, 0))\n+\t  return true;\n+\n+\t/* If this is a before stepping control IV, in other words, we have\n+\n+\t     {civ_base, step} = {base + step, step}\n+\n+\t   Because civ {base + step, step} doesn't overflow during loop\n+\t   iterations, {base, step} will not overflow if we can prove the\n+\t   operation \"base + step\" does not overflow.  Specifically, we try\n+\t   to prove below conditions are satisfied:\n+\n+\t     base <= UPPER_BOUND (type) - step  ;;step > 0\n+\t     base >= LOWER_BOUND (type) - step  ;;step < 0\n+\n+\t   by proving the reverse conditions are false using loop's initial\n+\t   condition.  */\n+\tstepped = fold_build2 (PLUS_EXPR, TREE_TYPE (base), base, step);\n+\tif (operand_equal_p (stepped, civ->base, 0))\n+\t  {\n+\t    if (tree_int_cst_sign_bit (step))\n+\t      {\n+\t\tcode = LT_EXPR;\n+\t\textreme = lower_bound_in_type (type, type);\n+\t      }\n+\t    else\n+\t      {\n+\t\tcode = GT_EXPR;\n+\t\textreme = upper_bound_in_type (type, type);\n+\t      }\n+\t    extreme = fold_build2 (MINUS_EXPR, type, extreme, step);\n+\t    e = fold_build2 (code, boolean_type_node, base, extreme);\n+\t    e = simplify_using_initial_conditions (loop, e);\n+\t    if (integer_zerop (e))\n+\t      return true;\n+\n+\t    continue;\n+\t  }\n+\n+\t/* Similar to above, only in this case we have:\n+\n+\t     {civ_base, step} = {(signed T)((unsigned T)base + step), step}\n+\t     && TREE_TYPE (civ_base) = signed T.\n+\n+\t   We prove that below condition is satisfied:\n+\n+\t     (signed T)((unsigned T)base + step)\n+\t       == (signed T)(unsigned T)base + step\n+\t       == base + step\n+\n+\t   because of exact the same reason as above.  This also proves\n+\t   there is no overflow in the operation \"base + step\", thus the\n+\t   induction variable {base, step} during loop iterations.\n+\n+\t   This is necessary to handle cases as below:\n+\n+\t     int foo (int *a, signed char s, signed char l)\n+\t       {\n+\t\t signed char i;\n+\t\t for (i = s; i < l; i++)\n+\t\t   a[i] = 0;\n+\t\t return 0;\n+\t       }\n+\n+\t   The variable I is firstly converted to type unsigned char,\n+\t   incremented, then converted back to type signed char.  */\n+\tif (!CONVERT_EXPR_P (civ->base) || TREE_TYPE (civ->base) != type)\n+\t  continue;\n+\te = TREE_OPERAND (civ->base, 0);\n+\tif (TREE_CODE (e) != PLUS_EXPR\n+\t    || TREE_CODE (TREE_OPERAND (e, 1)) != INTEGER_CST\n+\t    || !operand_equal_p (step,\n+\t\t\t\t fold_convert (type,\n+\t\t\t\t\t       TREE_OPERAND (e, 1)), 0))\n+\t  continue;\n+\te = TREE_OPERAND (e, 0);\n+\tif (!CONVERT_EXPR_P (e) || !operand_equal_p (e, unsigned_base, 0))\n+\t  continue;\n+\te = TREE_OPERAND (e, 0);\n+\tgcc_assert (operand_equal_p (e, base, 0));\n+\tif (tree_int_cst_sign_bit (step))\n+\t  {\n+\t    code = LT_EXPR;\n+\t    extreme = lower_bound_in_type (type, type);\n+\t  }\n+\telse\n+\t  {\n+\t    code = GT_EXPR;\n+\t    extreme = upper_bound_in_type (type, type);\n+\t  }\n+\textreme = fold_build2 (MINUS_EXPR, type, extreme, step);\n+\te = fold_build2 (code, boolean_type_node, base, extreme);\n+\te = simplify_using_initial_conditions (loop, e);\n+\tif (integer_zerop (e))\n+\t  return true;\n+      }\n+\n+  return false;\n+}\n+\n /* Return false only when the induction variable BASE + STEP * I is\n    known to not overflow: i.e. when the number of iterations is small\n    enough with respect to the step and initial condition in order to\n@@ -3788,13 +4000,6 @@ scev_probably_wraps_p (tree base, tree step,\n \t\t       gimple at_stmt, struct loop *loop,\n \t\t       bool use_overflow_semantics)\n {\n-  tree delta, step_abs;\n-  tree unsigned_type, valid_niter;\n-  tree type = TREE_TYPE (step);\n-  tree e;\n-  widest_int niter;\n-  struct nb_iter_bound *bound;\n-\n   /* FIXME: We really need something like\n      http://gcc.gnu.org/ml/gcc-patches/2005-06/msg02025.html.\n \n@@ -3828,56 +4033,8 @@ scev_probably_wraps_p (tree base, tree step,\n   if (TREE_CODE (step) != INTEGER_CST)\n     return true;\n \n-  /* Don't issue signed overflow warnings.  */\n-  fold_defer_overflow_warnings ();\n-\n-  /* Otherwise, compute the number of iterations before we reach the\n-     bound of the type, and verify that the loop is exited before this\n-     occurs.  */\n-  unsigned_type = unsigned_type_for (type);\n-  base = fold_convert (unsigned_type, base);\n-\n-  if (tree_int_cst_sign_bit (step))\n-    {\n-      tree extreme = fold_convert (unsigned_type,\n-\t\t\t\t   lower_bound_in_type (type, type));\n-      delta = fold_build2 (MINUS_EXPR, unsigned_type, base, extreme);\n-      step_abs = fold_build1 (NEGATE_EXPR, unsigned_type,\n-\t\t\t      fold_convert (unsigned_type, step));\n-    }\n-  else\n-    {\n-      tree extreme = fold_convert (unsigned_type,\n-\t\t\t\t   upper_bound_in_type (type, type));\n-      delta = fold_build2 (MINUS_EXPR, unsigned_type, extreme, base);\n-      step_abs = fold_convert (unsigned_type, step);\n-    }\n-\n-  valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);\n-\n-  estimate_numbers_of_iterations_loop (loop);\n-\n-  if (max_loop_iterations (loop, &niter)\n-      && wi::fits_to_tree_p (niter, TREE_TYPE (valid_niter))\n-      && (e = fold_binary (GT_EXPR, boolean_type_node, valid_niter,\n-\t\t\t   wide_int_to_tree (TREE_TYPE (valid_niter),\n-\t\t\t\t\t     niter))) != NULL\n-      && integer_nonzerop (e))\n-    {\n-      fold_undefer_and_ignore_overflow_warnings ();\n-      return false;\n-    }\n-  if (at_stmt)\n-    for (bound = loop->bounds; bound; bound = bound->next)\n-      {\n-\tif (n_of_executions_at_most (at_stmt, bound, valid_niter))\n-\t  {\n-\t    fold_undefer_and_ignore_overflow_warnings ();\n-\t    return false;\n-\t  }\n-      }\n-\n-  fold_undefer_and_ignore_overflow_warnings ();\n+  if (loop_exits_before_overflow (base, step, at_stmt, loop))\n+    return false;\n \n   /* At this point we still don't have a proof that the iv does not\n      overflow: give up.  */\n@@ -3889,17 +4046,26 @@ scev_probably_wraps_p (tree base, tree step,\n void\n free_numbers_of_iterations_estimates_loop (struct loop *loop)\n {\n-  struct nb_iter_bound *bound, *next;\n+  struct control_iv *civ;\n+  struct nb_iter_bound *bound;\n \n   loop->nb_iterations = NULL;\n   loop->estimate_state = EST_NOT_COMPUTED;\n-  for (bound = loop->bounds; bound; bound = next)\n+  for (bound = loop->bounds; bound;)\n     {\n-      next = bound->next;\n+      struct nb_iter_bound *next = bound->next;\n       ggc_free (bound);\n+      bound = next;\n     }\n-\n   loop->bounds = NULL;\n+\n+  for (civ = loop->control_ivs; civ;)\n+    {\n+      struct control_iv *next = civ->next;\n+      ggc_free (civ);\n+      civ = next;\n+    }\n+  loop->control_ivs = NULL;\n }\n \n /* Frees the information on upper bounds on numbers of iterations of loops.  */"}, {"sha": "8d4f799c090fd50900ec203a09c61bef8922f352", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f07b722ed0302ded58710b6d8485d85d785b4ee/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=2f07b722ed0302ded58710b6d8485d85d785b4ee", "patch": "@@ -41,6 +41,7 @@ extern void estimate_numbers_of_iterations (void);\n extern bool stmt_dominates_stmt_p (gimple, gimple);\n extern bool nowrap_type_p (tree);\n extern bool scev_probably_wraps_p (tree, tree, gimple, struct loop *, bool);\n+extern void free_loop_control_ivs (struct loop *);\n extern void free_numbers_of_iterations_estimates_loop (struct loop *);\n extern void free_numbers_of_iterations_estimates (void);\n extern void substitute_in_loop_info (struct loop *, tree, tree);"}]}