{"sha": "33338e7289288404de79cb57dd1003a7552fb3d4", "node_id": "C_kwDOANBUbNoAKDMzMzM4ZTcyODkyODg0MDRkZTc5Y2I1N2RkMTAwM2E3NTUyZmIzZDQ", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-06-30T00:21:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-12T12:24:14Z"}, "message": "[Ada] Use right implementation type for nonbinary-modulus ops\n\nIf the flag Opt.Expand_Nonbinary_Modular_Ops is set (which occurs if\n-gnateg is specified) then we implement predefined operations for a\nmodular type whose modulus is not a power of two by converting the\noperands to some other type (either a signed integer type or a modular\ntype with a power-of-two modulus), doing the operation in that\nrepresentation, and converting back.  If the bounds of the chosen type\nare too narrow, then problems with intermediate overflow can result. But\nthere are performance advantages to choosing narrower bounds (and to\nprefering an unsigned choice over a signed choice of the same size) when\nmultiple safe choices are available.\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_Nonbinary_Modular_Op.Expand_Modular_Op):\n\tReimplement choice of which predefined type to use for the\n\timplementation of a predefined operation of a modular type with\n\ta non-power-of-two modulus.", "tree": {"sha": "35881d6a00ecfce6720838f858d12d38e6a64b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35881d6a00ecfce6720838f858d12d38e6a64b01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33338e7289288404de79cb57dd1003a7552fb3d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33338e7289288404de79cb57dd1003a7552fb3d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33338e7289288404de79cb57dd1003a7552fb3d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33338e7289288404de79cb57dd1003a7552fb3d4/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "729d2e2a80768b6df008ea98979dbe34b7e4ab9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729d2e2a80768b6df008ea98979dbe34b7e4ab9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729d2e2a80768b6df008ea98979dbe34b7e4ab9a"}], "stats": {"total": 101, "additions": 70, "deletions": 31}, "files": [{"sha": "911bdf31b7871bbad01e41677eb74745ce0beffe", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 70, "deletions": 31, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33338e7289288404de79cb57dd1003a7552fb3d4/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33338e7289288404de79cb57dd1003a7552fb3d4/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=33338e7289288404de79cb57dd1003a7552fb3d4", "patch": "@@ -4177,43 +4177,82 @@ package body Exp_Ch4 is\n       -----------------------\n \n       procedure Expand_Modular_Op is\n+         --   We will convert to another type (not a nonbinary-modulus modular\n+         --   type), evaluate the op in that representation, reduce the result,\n+         --   and convert back to the original type. This means that the\n+         --   backend does not have to deal with nonbinary-modulus ops.\n+\n          Op_Expr  : constant Node_Id := New_Op_Node (Nkind (N), Loc);\n          Mod_Expr : constant Node_Id := New_Op_Node (N_Op_Mod, Loc);\n \n-         Target_Type   : Entity_Id;\n-\n+         Target_Type : Entity_Id;\n       begin\n-         --  Convert nonbinary modular type operands into integer values. Thus\n-         --  we avoid never-ending loops expanding them, and we also ensure\n-         --  the back end never receives nonbinary modular type expressions.\n-\n-         if Nkind (N) in N_Op_And | N_Op_Or | N_Op_Xor then\n-            Set_Left_Opnd (Op_Expr,\n-              Unchecked_Convert_To (Standard_Unsigned,\n-                New_Copy_Tree (Left_Opnd (N))));\n-            Set_Right_Opnd (Op_Expr,\n-              Unchecked_Convert_To (Standard_Unsigned,\n-                New_Copy_Tree (Right_Opnd (N))));\n-            Set_Left_Opnd (Mod_Expr,\n-              Unchecked_Convert_To (Standard_Integer, Op_Expr));\n-\n-         else\n-            --  If the modulus of the type is larger than Integer'Last use a\n-            --  larger type for the operands, to prevent spurious constraint\n-            --  errors on large legal literals of the type.\n+         --  Select a target type that is large enough to avoid spurious\n+         --  intermediate overflow on pre-reduction computation (for\n+         --  correctness) but is no larger than is needed (for performance).\n \n-            if Modulus (Etype (N)) > Int (Integer'Last) then\n-               Target_Type := Standard_Long_Long_Integer;\n+         declare\n+            Required_Size : Uint := RM_Size (Etype (N));\n+            Use_Unsigned  : Boolean := True;\n+         begin\n+            case Nkind (N) is\n+               when N_Op_Add =>\n+                  --  For example, if modulus is 255 then RM_Size will be 8\n+                  --  and the range of possible values (before reduction) will\n+                  --  be 0 .. 508; that range requires 9 bits.\n+                  Required_Size := Required_Size + 1;\n+\n+               when N_Op_Subtract =>\n+                  --  For example, if modulus is 255 then RM_Size will be 8\n+                  --  and the range of possible values (before reduction) will\n+                  --  be -254 .. 254; that range requires 9 bits, signed.\n+                  Use_Unsigned := False;\n+                  Required_Size := Required_Size + 1;\n+\n+               when N_Op_Multiply =>\n+                  --  For example, if modulus is 255 then RM_Size will be 8\n+                  --  and the range of possible values (before reduction) will\n+                  --  be 0 .. 64,516; that range requires 16 bits.\n+                  Required_Size := Required_Size * 2;\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n+            if Use_Unsigned then\n+               if Required_Size <= Standard_Short_Short_Integer_Size then\n+                  Target_Type := Standard_Short_Short_Unsigned;\n+               elsif Required_Size <= Standard_Short_Integer_Size then\n+                  Target_Type := Standard_Short_Unsigned;\n+               elsif Required_Size <= Standard_Integer_Size then\n+                  Target_Type := Standard_Unsigned;\n+               else\n+                  pragma Assert (Required_Size <= 64);\n+                  Target_Type := Standard_Unsigned_64;\n+               end if;\n+            elsif Required_Size <= 8 then\n+               Target_Type := Standard_Integer_8;\n+            elsif Required_Size <= 16 then\n+               Target_Type := Standard_Integer_16;\n+            elsif Required_Size <= 32 then\n+               Target_Type := Standard_Integer_32;\n             else\n-               Target_Type := Standard_Integer;\n+               pragma Assert (Required_Size <= 64);\n+               Target_Type := Standard_Integer_64;\n             end if;\n \n-            Set_Left_Opnd (Op_Expr,\n-              Unchecked_Convert_To (Target_Type,\n-                New_Copy_Tree (Left_Opnd (N))));\n-            Set_Right_Opnd (Op_Expr,\n-              Unchecked_Convert_To (Target_Type,\n-                New_Copy_Tree (Right_Opnd (N))));\n+            pragma Assert (Present (Target_Type));\n+         end;\n+\n+         Set_Left_Opnd (Op_Expr,\n+           Unchecked_Convert_To (Target_Type,\n+             New_Copy_Tree (Left_Opnd (N))));\n+         Set_Right_Opnd (Op_Expr,\n+           Unchecked_Convert_To (Target_Type,\n+             New_Copy_Tree (Right_Opnd (N))));\n+\n+         --  ??? Why do this stuff for some ops and not others?\n+         if Nkind (N) not in N_Op_And | N_Op_Or | N_Op_Xor then\n \n             --  Link this node to the tree to analyze it\n \n@@ -4237,10 +4276,10 @@ package body Exp_Ch4 is\n             --  several times.\n \n             Force_Evaluation (Op_Expr, Mode => Strict);\n-\n-            Set_Left_Opnd (Mod_Expr, Op_Expr);\n          end if;\n \n+         Set_Left_Opnd (Mod_Expr, Op_Expr);\n+\n          Set_Right_Opnd (Mod_Expr,\n            Make_Integer_Literal (Loc, Modulus (Typ)));\n "}]}