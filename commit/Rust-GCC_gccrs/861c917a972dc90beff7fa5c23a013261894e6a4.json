{"sha": "861c917a972dc90beff7fa5c23a013261894e6a4", "node_id": "C_kwDOANBUbNoAKDg2MWM5MTdhOTcyZGM5MGJlZmY3ZmE1YzIzYTAxMzI2MTg5NGU2YTQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-06T18:26:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-12-06T18:26:56Z"}, "message": "analyzer: split out more stuff from region-model-impl-calls.cc\n\ngcc/ChangeLog:\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/call-details.o,\n\tanalyzer/kf-analyzer.o, and kf-lang-cp.o.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (register_known_analyzer_functions): New decl.\n\t(register_known_functions_lang_cp): New decl.\n\t* call-details.cc: New file, split out from\n\tregion-model-impl-calls.cc.\n\t* call-details.h: New file, split out from region-model.h.\n\t* call-info.cc: Include \"analyzer/call-details.h\".\n\t* call-summary.h: Likewise.\n\t* kf-analyzer.cc: New file, split out from\n\tregion-model-impl-calls.cc.\n\t* kf-lang-cp.cc: Likewise.\n\t* known-function-manager.cc: Include \"analyzer/call-details.h\".\n\t* region-model-impl-calls.cc: Move definitions of call_details's\n\tmember functions to call-details.cc.  Move class kf_analyzer_* to\n\tkf-analyzer.cc.  Move kf_operator_new and kf_operator_delete to\n\tkf-lang-cp.cc.  Refresh #includes accordingly.\n\t(register_known_functions): Replace registration of __analyzer_*\n\tfunctions with a call to register_known_analyzer_functions.\n\tReplace registration of C++ support functions with a call to\n\tregister_known_functions_lang_cp.\n\t* region-model.h (class call_details): Move to new call-details.h.\n\t* sm-fd.cc: Include \"analyzer/call-details.h\".\n\t* sm-file.cc: Likewise.\n\t* sm-malloc.cc: Likewise.\n\t* varargs.cc: Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/analyzer_kernel_plugin.c: Include\n\t\"analyzer/call-details.h\".\n\t* gcc.dg/plugin/analyzer_known_fns_plugin.c: Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "3b38c877d395f7106a0ceec21d7e549dfdcedf7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b38c877d395f7106a0ceec21d7e549dfdcedf7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/861c917a972dc90beff7fa5c23a013261894e6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861c917a972dc90beff7fa5c23a013261894e6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861c917a972dc90beff7fa5c23a013261894e6a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861c917a972dc90beff7fa5c23a013261894e6a4/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81476bc4f4a20bcf3af7ac2548c2322d48499402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81476bc4f4a20bcf3af7ac2548c2322d48499402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81476bc4f4a20bcf3af7ac2548c2322d48499402"}], "stats": {"total": 1489, "additions": 827, "deletions": 662}, "files": [{"sha": "7bcc5e501de8437f97abe3e455ace3f3dad6aee0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -1256,6 +1256,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/analyzer-selftests.o \\\n \tanalyzer/bar-chart.o \\\n \tanalyzer/bounds-checking.o \\\n+\tanalyzer/call-details.o \\\n \tanalyzer/call-info.o \\\n \tanalyzer/call-string.o \\\n \tanalyzer/call-summary.o \\\n@@ -1268,6 +1269,8 @@ ANALYZER_OBJS = \\\n \tanalyzer/feasible-graph.o \\\n \tanalyzer/function-set.o \\\n \tanalyzer/infinite-recursion.o \\\n+\tanalyzer/kf-analyzer.o \\\n+\tanalyzer/kf-lang-cp.o \\\n \tanalyzer/known-function-manager.o \\\n \tanalyzer/pending-diagnostic.o \\\n \tanalyzer/program-point.o \\"}, {"sha": "418d4210755270d4ec60833c47e8d08d42545614", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -259,8 +259,10 @@ class internal_known_function : public known_function\n };\n \n extern void register_known_functions (known_function_manager &mgr);\n+extern void register_known_analyzer_functions (known_function_manager &kfm);\n extern void register_known_fd_functions (known_function_manager &kfm);\n extern void register_known_file_functions (known_function_manager &kfm);\n+extern void register_known_functions_lang_cp (known_function_manager &kfm);\n extern void register_varargs_builtins (known_function_manager &kfm);\n \n /* Passed by pointer to PLUGIN_ANALYZER_INIT callbacks.  */"}, {"sha": "b63b8a38d8852116c167378dd215524c9a47a36f", "filename": "gcc/analyzer/call-details.cc", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-details.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-details.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-details.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -0,0 +1,231 @@\n+/* Helper class for handling a call with specific arguments.\n+   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_MEMORY\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"diagnostic-core.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\" /* for default_tree_printer.  */\n+#include \"gimple-pretty-print.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class call_details.  */\n+\n+/* call_details's ctor.  */\n+\n+call_details::call_details (const gcall *call, region_model *model,\n+\t\t\t    region_model_context *ctxt)\n+: m_call (call), m_model (model), m_ctxt (ctxt),\n+  m_lhs_type (NULL_TREE), m_lhs_region (NULL)\n+{\n+  m_lhs_type = NULL_TREE;\n+  if (tree lhs = gimple_call_lhs (call))\n+    {\n+      m_lhs_region = model->get_lvalue (lhs, ctxt);\n+      m_lhs_type = TREE_TYPE (lhs);\n+    }\n+}\n+\n+/* Get the manager from m_model.  */\n+\n+region_model_manager *\n+call_details::get_manager () const\n+{\n+  return m_model->get_manager ();\n+}\n+\n+/* Get any logger associated with this object.  */\n+\n+logger *\n+call_details::get_logger () const\n+{\n+  if (m_ctxt)\n+    return m_ctxt->get_logger ();\n+  else\n+    return NULL;\n+}\n+\n+/* Get any uncertainty_t associated with the region_model_context.  */\n+\n+uncertainty_t *\n+call_details::get_uncertainty () const\n+{\n+  if (m_ctxt)\n+    return m_ctxt->get_uncertainty ();\n+  else\n+    return NULL;\n+}\n+\n+/* If the callsite has a left-hand-side region, set it to RESULT\n+   and return true.\n+   Otherwise do nothing and return false.  */\n+\n+bool\n+call_details::maybe_set_lhs (const svalue *result) const\n+{\n+  gcc_assert (result);\n+  if (m_lhs_region)\n+    {\n+      m_model->set_value (m_lhs_region, result, m_ctxt);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Return the number of arguments used by the call statement.  */\n+\n+unsigned\n+call_details::num_args () const\n+{\n+  return gimple_call_num_args (m_call);\n+}\n+\n+/* Return true if argument IDX is a size_t (or compatible with it).  */\n+\n+bool\n+call_details::arg_is_size_p (unsigned idx) const\n+{\n+  return types_compatible_p (get_arg_type (idx), size_type_node);\n+}\n+\n+/* Get the location of the call statement.  */\n+\n+location_t\n+call_details::get_location () const\n+{\n+  return m_call->location;\n+}\n+\n+/* Get argument IDX at the callsite as a tree.  */\n+\n+tree\n+call_details::get_arg_tree (unsigned idx) const\n+{\n+  return gimple_call_arg (m_call, idx);\n+}\n+\n+/* Get the type of argument IDX.  */\n+\n+tree\n+call_details::get_arg_type (unsigned idx) const\n+{\n+  return TREE_TYPE (gimple_call_arg (m_call, idx));\n+}\n+\n+/* Get argument IDX at the callsite as an svalue.  */\n+\n+const svalue *\n+call_details::get_arg_svalue (unsigned idx) const\n+{\n+  tree arg = get_arg_tree (idx);\n+  return m_model->get_rvalue (arg, m_ctxt);\n+}\n+\n+/* Attempt to get the string literal for argument IDX, or return NULL\n+   otherwise.\n+   For use when implementing \"__analyzer_*\" functions that take\n+   string literals.  */\n+\n+const char *\n+call_details::get_arg_string_literal (unsigned idx) const\n+{\n+  const svalue *str_arg = get_arg_svalue (idx);\n+  if (const region *pointee = str_arg->maybe_get_region ())\n+    if (const string_region *string_reg = pointee->dyn_cast_string_region ())\n+      {\n+\ttree string_cst = string_reg->get_string_cst ();\n+\treturn TREE_STRING_POINTER (string_cst);\n+      }\n+  return NULL;\n+}\n+\n+/* Attempt to get the fndecl used at this call, if known, or NULL_TREE\n+   otherwise.  */\n+\n+tree\n+call_details::get_fndecl_for_call () const\n+{\n+  return m_model->get_fndecl_for_call (m_call, m_ctxt);\n+}\n+\n+/* Dump a multiline representation of this call to PP.  */\n+\n+void\n+call_details::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  pp_string (pp, \"gcall: \");\n+  pp_gimple_stmt_1 (pp, m_call, 0 /* spc */, TDF_NONE /* flags */);\n+  pp_newline (pp);\n+  pp_string (pp, \"return region: \");\n+  if (m_lhs_region)\n+    m_lhs_region->dump_to_pp (pp, simple);\n+  else\n+    pp_string (pp, \"NULL\");\n+  pp_newline (pp);\n+  for (unsigned i = 0; i < gimple_call_num_args (m_call); i++)\n+    {\n+      const svalue *arg_sval = get_arg_svalue (i);\n+      pp_printf (pp, \"arg %i: \", i);\n+      arg_sval->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+    }\n+}\n+\n+/* Dump a multiline representation of this call to stderr.  */\n+\n+DEBUG_FUNCTION void\n+call_details::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple);\n+  pp_flush (&pp);\n+}\n+\n+/* Get a conjured_svalue for this call for REG,\n+   and purge any state already relating to that conjured_svalue.  */\n+\n+const svalue *\n+call_details::get_or_create_conjured_svalue (const region *reg) const\n+{\n+  region_model_manager *mgr = m_model->get_manager ();\n+  return mgr->get_or_create_conjured_svalue (reg->get_type (), m_call, reg,\n+\t\t\t\t\t     conjured_purge (m_model, m_ctxt));\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "144ca0ce868994c92c219443d03c370b0b197dbb", "filename": "gcc/analyzer/call-details.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-details.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-details.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-details.h?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -0,0 +1,77 @@\n+/* Helper class for handling a call with specific arguments.\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CALL_DETAILS_H\n+#define GCC_ANALYZER_CALL_DETAILS_H\n+\n+namespace ana {\n+\n+/* Helper class for handling calls to functions with known behavior.  */\n+\n+class call_details\n+{\n+public:\n+  call_details (const gcall *call, region_model *model,\n+\t\tregion_model_context *ctxt);\n+\n+  region_model *get_model () const { return m_model; }\n+  region_model_manager *get_manager () const;\n+  region_model_context *get_ctxt () const { return m_ctxt; }\n+  logger *get_logger () const;\n+\n+  uncertainty_t *get_uncertainty () const;\n+  tree get_lhs_type () const { return m_lhs_type; }\n+  const region *get_lhs_region () const { return m_lhs_region; }\n+\n+  bool maybe_set_lhs (const svalue *result) const;\n+\n+  unsigned num_args () const;\n+  bool arg_is_pointer_p (unsigned idx) const\n+  {\n+    return POINTER_TYPE_P (get_arg_type (idx));\n+  }\n+  bool arg_is_size_p (unsigned idx) const;\n+\n+  const gcall *get_call_stmt () const { return m_call; }\n+  location_t get_location () const;\n+\n+  tree get_arg_tree (unsigned idx) const;\n+  tree get_arg_type (unsigned idx) const;\n+  const svalue *get_arg_svalue (unsigned idx) const;\n+  const char *get_arg_string_literal (unsigned idx) const;\n+\n+  tree get_fndecl_for_call () const;\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const;\n+  void dump (bool simple) const;\n+\n+  const svalue *get_or_create_conjured_svalue (const region *) const;\n+\n+private:\n+  const gcall *m_call;\n+  region_model *m_model;\n+  region_model_context *m_ctxt;\n+  tree m_lhs_type;\n+  const region *m_lhs_region;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_CALL_DETAILS_H */"}, {"sha": "cbd21f7472b57f11d22bd800031e5b1a37f447fb", "filename": "gcc/analyzer/call-info.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-info.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/checker-path.h\"\n #include \"analyzer/diagnostic-manager.h\"\n #include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/call-details.h\"\n #include \"analyzer/call-info.h\"\n #include \"make-unique.h\"\n "}, {"sha": "73f21ac72826cf8db0d7a30c3729fcc00ab73390", "filename": "gcc/analyzer/call-summary.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fcall-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-summary.h?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_CALL_SUMMARY_H\n #define GCC_ANALYZER_CALL_SUMMARY_H\n \n+#include \"call-details.h\"\n+\n namespace ana {\n \n /* A class summarizing one particular outcome of a function that"}, {"sha": "b233418beb7c58fdc8870f0c79c4fca6bf99b056", "filename": "gcc/analyzer/kf-analyzer.cc", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fkf-analyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fkf-analyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fkf-analyzer.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -0,0 +1,386 @@\n+/* Handling for the various __analyzer_* known functions.\n+   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_MEMORY\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"diagnostic-core.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\" /* for default_tree_printer.  */\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/call-details.h\"\n+#include \"make-unique.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Handle calls to \"__analyzer_break\" by triggering a breakpoint within\n+   the analyzer.  */\n+\n+class kf_analyzer_break : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &) const final override\n+  {\n+    /* TODO: is there a good cross-platform way to do this?  */\n+    raise (SIGINT);\n+  }\n+};\n+\n+/* Handler for calls to \"__analyzer_describe\".\n+\n+   Emit a warning describing the 2nd argument (which can be of any\n+   type), at the given verbosity level.  This is for use when\n+   debugging, and may be of use in DejaGnu tests.  */\n+\n+class kf_analyzer_describe : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 2;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    if (!cd.get_ctxt ())\n+      return;\n+    tree t_verbosity = cd.get_arg_tree (0);\n+    const svalue *sval = cd.get_arg_svalue (1);\n+    bool simple = zerop (t_verbosity);\n+    label_text desc = sval->get_desc (simple);\n+    warning_at (cd.get_location (), 0, \"svalue: %qs\", desc.get ());\n+  }\n+};\n+\n+/* Handler for calls to \"__analyzer_dump_capacity\".\n+\n+   Emit a warning describing the capacity of the base region of\n+   the region pointed to by the 1st argument.\n+   This is for use when debugging, and may be of use in DejaGnu tests.  */\n+\n+class kf_analyzer_dump_capacity : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return (cd.num_args () == 1\n+\t    && cd.arg_is_pointer_p (0));\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n+    tree t_ptr = cd.get_arg_tree (0);\n+    const svalue *sval_ptr = model->get_rvalue (t_ptr, ctxt);\n+    const region *reg = model->deref_rvalue (sval_ptr, t_ptr, ctxt);\n+    const region *base_reg = reg->get_base_region ();\n+    const svalue *capacity = model->get_capacity (base_reg);\n+    label_text desc = capacity->get_desc (true);\n+    warning_at (cd.get_call_stmt ()->location, 0,\n+\t\t\"capacity: %qs\", desc.get ());\n+  }\n+};\n+\n+/* Compare D1 and D2 using their names, and then IDs to order them.  */\n+\n+static int\n+cmp_decls (tree d1, tree d2)\n+{\n+  gcc_assert (DECL_P (d1));\n+  gcc_assert (DECL_P (d2));\n+  if (DECL_NAME (d1) && DECL_NAME (d2))\n+    if (int cmp = strcmp (IDENTIFIER_POINTER (DECL_NAME (d1)),\n+\t\t\t  IDENTIFIER_POINTER (DECL_NAME (d2))))\n+      return cmp;\n+  return (int)DECL_UID (d1) - (int)DECL_UID (d2);\n+}\n+\n+/* Comparator for use by vec<tree>::qsort,\n+   using their names, and then IDs to order them.  */\n+\n+static int\n+cmp_decls_ptr_ptr (const void *p1, const void *p2)\n+{\n+  tree const *d1 = (tree const *)p1;\n+  tree const *d2 = (tree const *)p2;\n+\n+  return cmp_decls (*d1, *d2);\n+}\n+\n+/* Handler for calls to \"__analyzer_dump_escaped\".\n+\n+   Emit a warning giving the number of decls that have escaped, followed\n+   by a comma-separated list of their names, in alphabetical order.\n+\n+   This is for use when debugging, and may be of use in DejaGnu tests.  */\n+\n+class kf_analyzer_dump_escaped : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n+\n+    auto_vec<tree> escaped_decls;\n+    for (auto iter : *model->get_store ())\n+      {\n+\tconst binding_cluster *c = iter.second;\n+\tif (!c->escaped_p ())\n+\t  continue;\n+\tif (tree decl = c->get_base_region ()->maybe_get_decl ())\n+\t  escaped_decls.safe_push (decl);\n+      }\n+\n+    /* Sort them into deterministic order; alphabetical is\n+       probably most user-friendly.  */\n+    escaped_decls.qsort (cmp_decls_ptr_ptr);\n+\n+    pretty_printer pp;\n+    pp_format_decoder (&pp) = default_tree_printer;\n+    pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+    bool first = true;\n+    for (auto iter : escaped_decls)\n+      {\n+\tif (first)\n+\t  first = false;\n+\telse\n+\t  pp_string (&pp, \", \");\n+\tpp_printf (&pp, \"%qD\", iter);\n+      }\n+    /* Print the number to make it easier to write DejaGnu tests for\n+       the \"nothing has escaped\" case.  */\n+    warning_at (cd.get_location (), 0, \"escaped: %i: %s\",\n+\t\tescaped_decls.length (),\n+\t\tpp_formatted_text (&pp));\n+  }\n+};\n+\n+/* Placeholder handler for calls to \"__analyzer_dump_exploded_nodes\".\n+   This is a no-op; the real implementation happens when the\n+   exploded_graph is postprocessed.  */\n+\n+class kf_analyzer_dump_exploded_nodes : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+};\n+\n+/* Handler for calls to \"__analyzer_dump_named_constant\".\n+\n+   Look up the given name, and emit a warning describing the\n+   state of the corresponding stashed value.\n+\n+   This is for use when debugging, and for DejaGnu tests.  */\n+\n+class kf_analyzer_dump_named_constant : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+\n+    const char *name = cd.get_arg_string_literal (0);\n+    if (!name)\n+      {\n+\terror_at (cd.get_location (), \"cannot determine name\");\n+\treturn;\n+      }\n+    tree value = get_stashed_constant_by_name (name);\n+    if (value)\n+      warning_at (cd.get_location (), 0, \"named constant %qs has value %qE\",\n+\t\t  name, value);\n+    else\n+      warning_at (cd.get_location (), 0, \"named constant %qs has unknown value\",\n+\t\t  name);\n+  }\n+};\n+\n+/* A pending_diagnostic subclass for implementing \"__analyzer_dump_path\".  */\n+\n+class dump_path_diagnostic\n+  : public pending_diagnostic_subclass<dump_path_diagnostic>\n+{\n+public:\n+  int get_controlling_option () const final override\n+  {\n+    return 0;\n+  }\n+\n+  bool emit (rich_location *richloc) final override\n+  {\n+    inform (richloc, \"path\");\n+    return true;\n+  }\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"dump_path_diagnostic\";\n+  }\n+\n+  bool operator== (const dump_path_diagnostic &) const\n+  {\n+    return true;\n+  }\n+};\n+\n+/* Handle calls to \"__analyzer_dump_path\" by queuing a diagnostic at this\n+   exploded_node.  */\n+\n+class kf_analyzer_dump_path : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    ctxt->warn (make_unique<dump_path_diagnostic> ());\n+  }\n+};\n+\n+/* Handle calls to \"__analyzer_dump_region_model\" by dumping\n+   the region model's state to stderr.  */\n+\n+class kf_analyzer_dump_region_model : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n+    model->dump (false);\n+  }\n+};\n+\n+/* Handle a call to \"__analyzer_eval\" by evaluating the input\n+   and dumping as a dummy warning, so that test cases can use\n+   dg-warning to validate the result (and so unexpected warnings will\n+   lead to DejaGnu failures).\n+   Broken out as a subroutine to make it easier to put a breakpoint on it\n+   - though typically this doesn't help, as we have an SSA name as the arg,\n+   and what's more interesting is usually the def stmt for that name.  */\n+\n+class kf_analyzer_eval : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_context *ctxt = cd.get_ctxt ();\n+    if (!ctxt)\n+      return;\n+    region_model *model = cd.get_model ();\n+\n+    tree t_arg = cd.get_arg_tree (0);\n+    tristate t = model->eval_condition (t_arg, NE_EXPR, integer_zero_node,\n+\t\t\t\t\tctxt);\n+    warning_at (cd.get_location (), 0, \"%s\", t.as_string ());\n+  }\n+};\n+\n+/* Handler for \"__analyzer_get_unknown_ptr\".  */\n+\n+class kf_analyzer_get_unknown_ptr : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 0;\n+  }\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_manager *mgr = cd.get_manager ();\n+    const svalue *ptr_sval\n+      = mgr->get_or_create_unknown_svalue (cd.get_lhs_type ());\n+    cd.maybe_set_lhs (ptr_sval);\n+  }\n+};\n+\n+/* Populate KFM with instances of known functions used for debugging the\n+   analyzer and for writing DejaGnu tests, all with a \"__analyzer_\" prefix.  */\n+\n+void\n+register_known_analyzer_functions (known_function_manager &kfm)\n+{\n+  kfm.add (\"__analyzer_break\", make_unique<kf_analyzer_break> ());\n+  kfm.add (\"__analyzer_describe\", make_unique<kf_analyzer_describe> ());\n+  kfm.add (\"__analyzer_dump_capacity\",\n+\t   make_unique<kf_analyzer_dump_capacity> ());\n+  kfm.add (\"__analyzer_dump_escaped\", make_unique<kf_analyzer_dump_escaped> ());\n+  kfm.add (\"__analyzer_dump_exploded_nodes\",\n+\t   make_unique<kf_analyzer_dump_exploded_nodes> ());\n+  kfm.add (\"__analyzer_dump_named_constant\",\n+\t   make_unique<kf_analyzer_dump_named_constant> ());\n+  kfm.add (\"__analyzer_dump_path\", make_unique<kf_analyzer_dump_path> ());\n+  kfm.add (\"__analyzer_dump_region_model\",\n+\t   make_unique<kf_analyzer_dump_region_model> ());\n+  kfm.add (\"__analyzer_eval\", make_unique<kf_analyzer_eval> ());\n+  kfm.add (\"__analyzer_get_unknown_ptr\",\n+\t   make_unique<kf_analyzer_get_unknown_ptr> ());\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "9dca36699944c0e5d01f56fc64d32043da020b05", "filename": "gcc/analyzer/kf-lang-cp.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fkf-lang-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fkf-lang-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fkf-lang-cp.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -0,0 +1,111 @@\n+/* Handling for the known behavior of various functions specific to C++.\n+   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_MEMORY\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"diagnostic.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n+#include \"make-unique.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Implementations of specific functions.  */\n+\n+/* Handler for \"operator new\" and \"operator new []\".  */\n+\n+class kf_operator_new : public known_function\n+{\n+public:\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == 1;\n+  }\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model *model = cd.get_model ();\n+    region_model_manager *mgr = cd.get_manager ();\n+    const svalue *size_sval = cd.get_arg_svalue (0);\n+    const region *new_reg\n+      = model->get_or_create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n+    if (cd.get_lhs_type ())\n+      {\n+\tconst svalue *ptr_sval\n+\t  = mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+\tcd.maybe_set_lhs (ptr_sval);\n+      }\n+  }\n+};\n+\n+/* Handler for \"operator delete\", both the sized and unsized variants\n+   (2 arguments and 1 argument respectively), and for \"operator delete []\"  */\n+\n+class kf_operator_delete : public known_function\n+{\n+public:\n+  kf_operator_delete (unsigned num_args) : m_num_args (num_args) {}\n+\n+  bool matches_call_types_p (const call_details &cd) const final override\n+  {\n+    return cd.num_args () == m_num_args;\n+  }\n+\n+  void impl_call_post (const call_details &cd) const final override\n+  {\n+    region_model *model = cd.get_model ();\n+    const svalue *ptr_sval = cd.get_arg_svalue (0);\n+    if (const region *freed_reg = ptr_sval->maybe_get_region ())\n+      {\n+\t/* If the ptr points to an underlying heap region, delete it,\n+\t   poisoning pointers.  */\n+\tmodel->unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n+      }\n+  }\n+\n+private:\n+  unsigned m_num_args;\n+};\n+\n+/* Populate KFM with instances of known functions relating to C++.  */\n+\n+void\n+register_known_functions_lang_cp (known_function_manager &kfm)\n+{\n+  kfm.add (\"operator new\", make_unique<kf_operator_new> ());\n+  kfm.add (\"operator new []\", make_unique<kf_operator_new> ());\n+  kfm.add (\"operator delete\", make_unique<kf_operator_delete> (1));\n+  kfm.add (\"operator delete\", make_unique<kf_operator_delete> (2));\n+  kfm.add (\"operator delete []\", make_unique<kf_operator_delete> (1));\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "dc514a7fe57715fe2e7a9b71fc693a66d21a7450", "filename": "gcc/analyzer/known-function-manager.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fknown-function-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fknown-function-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"analyzer/known-function-manager.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n \n #if ENABLE_ANALYZER\n "}, {"sha": "6aeb9281bffabb77fbeaa9b1cb4f2fa3f142a64d", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 7, "deletions": 612, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -26,228 +26,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"basic-block.h\"\n #include \"gimple.h\"\n-#include \"gimple-iterator.h\"\n #include \"diagnostic-core.h\"\n-#include \"graphviz.h\"\n-#include \"options.h\"\n-#include \"cgraph.h\"\n-#include \"tree-dfa.h\"\n-#include \"stringpool.h\"\n-#include \"convert.h\"\n-#include \"target.h\"\n-#include \"fold-const.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"diagnostic-color.h\"\n #include \"diagnostic-metadata.h\"\n-#include \"bitmap.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n-#include \"ordered-hash-map.h\"\n-#include \"options.h\"\n-#include \"analyzer/supergraph.h\"\n-#include \"sbitmap.h\"\n-#include \"analyzer/call-string.h\"\n-#include \"analyzer/program-point.h\"\n-#include \"analyzer/store.h\"\n+#include \"diagnostic.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n #include \"analyzer/call-info.h\"\n-#include \"analyzer/sm.h\"\n-#include \"diagnostic-path.h\"\n-#include \"analyzer/pending-diagnostic.h\"\n-#include \"gimple-pretty-print.h\"\n #include \"make-unique.h\"\n \n #if ENABLE_ANALYZER\n \n namespace ana {\n \n-/* class call_details.  */\n-\n-/* call_details's ctor.  */\n-\n-call_details::call_details (const gcall *call, region_model *model,\n-\t\t\t    region_model_context *ctxt)\n-: m_call (call), m_model (model), m_ctxt (ctxt),\n-  m_lhs_type (NULL_TREE), m_lhs_region (NULL)\n-{\n-  m_lhs_type = NULL_TREE;\n-  if (tree lhs = gimple_call_lhs (call))\n-    {\n-      m_lhs_region = model->get_lvalue (lhs, ctxt);\n-      m_lhs_type = TREE_TYPE (lhs);\n-    }\n-}\n-\n-/* Get the manager from m_model.  */\n-\n-region_model_manager *\n-call_details::get_manager () const\n-{\n-  return m_model->get_manager ();\n-}\n-\n-/* Get any logger associated with this object.  */\n-\n-logger *\n-call_details::get_logger () const\n-{\n-  if (m_ctxt)\n-    return m_ctxt->get_logger ();\n-  else\n-    return NULL;\n-}\n-\n-/* Get any uncertainty_t associated with the region_model_context.  */\n-\n-uncertainty_t *\n-call_details::get_uncertainty () const\n-{\n-  if (m_ctxt)\n-    return m_ctxt->get_uncertainty ();\n-  else\n-    return NULL;\n-}\n-\n-/* If the callsite has a left-hand-side region, set it to RESULT\n-   and return true.\n-   Otherwise do nothing and return false.  */\n-\n-bool\n-call_details::maybe_set_lhs (const svalue *result) const\n-{\n-  gcc_assert (result);\n-  if (m_lhs_region)\n-    {\n-      m_model->set_value (m_lhs_region, result, m_ctxt);\n-      return true;\n-    }\n-  else\n-    return false;\n-}\n-\n-/* Return the number of arguments used by the call statement.  */\n-\n-unsigned\n-call_details::num_args () const\n-{\n-  return gimple_call_num_args (m_call);\n-}\n-\n-/* Return true if argument IDX is a size_t (or compatible with it).  */\n-\n-bool\n-call_details::arg_is_size_p (unsigned idx) const\n-{\n-  return types_compatible_p (get_arg_type (idx), size_type_node);\n-}\n-\n-/* Get the location of the call statement.  */\n-\n-location_t\n-call_details::get_location () const\n-{\n-  return m_call->location;\n-}\n-\n-/* Get argument IDX at the callsite as a tree.  */\n-\n-tree\n-call_details::get_arg_tree (unsigned idx) const\n-{\n-  return gimple_call_arg (m_call, idx);\n-}\n-\n-/* Get the type of argument IDX.  */\n-\n-tree\n-call_details::get_arg_type (unsigned idx) const\n-{\n-  return TREE_TYPE (gimple_call_arg (m_call, idx));\n-}\n-\n-/* Get argument IDX at the callsite as an svalue.  */\n-\n-const svalue *\n-call_details::get_arg_svalue (unsigned idx) const\n-{\n-  tree arg = get_arg_tree (idx);\n-  return m_model->get_rvalue (arg, m_ctxt);\n-}\n-\n-/* Attempt to get the string literal for argument IDX, or return NULL\n-   otherwise.\n-   For use when implementing \"__analyzer_*\" functions that take\n-   string literals.  */\n-\n-const char *\n-call_details::get_arg_string_literal (unsigned idx) const\n-{\n-  const svalue *str_arg = get_arg_svalue (idx);\n-  if (const region *pointee = str_arg->maybe_get_region ())\n-    if (const string_region *string_reg = pointee->dyn_cast_string_region ())\n-      {\n-\ttree string_cst = string_reg->get_string_cst ();\n-\treturn TREE_STRING_POINTER (string_cst);\n-      }\n-  return NULL;\n-}\n-\n-/* Attempt to get the fndecl used at this call, if known, or NULL_TREE\n-   otherwise.  */\n-\n-tree\n-call_details::get_fndecl_for_call () const\n-{\n-  return m_model->get_fndecl_for_call (m_call, m_ctxt);\n-}\n-\n-/* Dump a multiline representation of this call to PP.  */\n-\n-void\n-call_details::dump_to_pp (pretty_printer *pp, bool simple) const\n-{\n-  pp_string (pp, \"gcall: \");\n-  pp_gimple_stmt_1 (pp, m_call, 0 /* spc */, TDF_NONE /* flags */);\n-  pp_newline (pp);\n-  pp_string (pp, \"return region: \");\n-  if (m_lhs_region)\n-    m_lhs_region->dump_to_pp (pp, simple);\n-  else\n-    pp_string (pp, \"NULL\");\n-  pp_newline (pp);\n-  for (unsigned i = 0; i < gimple_call_num_args (m_call); i++)\n-    {\n-      const svalue *arg_sval = get_arg_svalue (i);\n-      pp_printf (pp, \"arg %i: \", i);\n-      arg_sval->dump_to_pp (pp, simple);\n-      pp_newline (pp);\n-    }\n-}\n-\n-/* Dump a multiline representation of this call to stderr.  */\n-\n-DEBUG_FUNCTION void\n-call_details::dump (bool simple) const\n-{\n-  pretty_printer pp;\n-  pp_format_decoder (&pp) = default_tree_printer;\n-  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n-  pp.buffer->stream = stderr;\n-  dump_to_pp (&pp, simple);\n-  pp_flush (&pp);\n-}\n-\n-/* Get a conjured_svalue for this call for REG,\n-   and purge any state already relating to that conjured_svalue.  */\n-\n-const svalue *\n-call_details::get_or_create_conjured_svalue (const region *reg) const\n-{\n-  region_model_manager *mgr = m_model->get_manager ();\n-  return mgr->get_or_create_conjured_svalue (reg->get_type (), m_call, reg,\n-\t\t\t\t\t     conjured_purge (m_model, m_ctxt));\n-}\n-\n /* Implementations of specific functions.  */\n \n /* Handler for \"alloca\".  */\n@@ -277,324 +69,6 @@ kf_alloca::impl_call_pre (const call_details &cd) const\n   cd.maybe_set_lhs (ptr_sval);\n }\n \n-/* Handle calls to \"__analyzer_break\" by triggering a breakpoint within\n-   the analyzer.  */\n-\n-class kf_analyzer_break : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 0;\n-  }\n-  void impl_call_pre (const call_details &) const final override\n-  {\n-    /* TODO: is there a good cross-platform way to do this?  */\n-    raise (SIGINT);\n-  }\n-};\n-\n-/* Handler for calls to \"__analyzer_describe\".\n-\n-   Emit a warning describing the 2nd argument (which can be of any\n-   type), at the given verbosity level.  This is for use when\n-   debugging, and may be of use in DejaGnu tests.  */\n-\n-class kf_analyzer_describe : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 2;\n-  }\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    if (!cd.get_ctxt ())\n-      return;\n-    tree t_verbosity = cd.get_arg_tree (0);\n-    const svalue *sval = cd.get_arg_svalue (1);\n-    bool simple = zerop (t_verbosity);\n-    label_text desc = sval->get_desc (simple);\n-    warning_at (cd.get_location (), 0, \"svalue: %qs\", desc.get ());\n-  }\n-};\n-\n-/* Handler for calls to \"__analyzer_dump_capacity\".\n-\n-   Emit a warning describing the capacity of the base region of\n-   the region pointed to by the 1st argument.\n-   This is for use when debugging, and may be of use in DejaGnu tests.  */\n-\n-class kf_analyzer_dump_capacity : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return (cd.num_args () == 1\n-\t    && cd.arg_is_pointer_p (0));\n-  }\n-\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model_context *ctxt = cd.get_ctxt ();\n-    if (!ctxt)\n-      return;\n-    region_model *model = cd.get_model ();\n-    tree t_ptr = cd.get_arg_tree (0);\n-    const svalue *sval_ptr = model->get_rvalue (t_ptr, ctxt);\n-    const region *reg = model->deref_rvalue (sval_ptr, t_ptr, ctxt);\n-    const region *base_reg = reg->get_base_region ();\n-    const svalue *capacity = model->get_capacity (base_reg);\n-    label_text desc = capacity->get_desc (true);\n-    warning_at (cd.get_call_stmt ()->location, 0,\n-\t\t\"capacity: %qs\", desc.get ());\n-  }\n-};\n-\n-/* Compare D1 and D2 using their names, and then IDs to order them.  */\n-\n-static int\n-cmp_decls (tree d1, tree d2)\n-{\n-  gcc_assert (DECL_P (d1));\n-  gcc_assert (DECL_P (d2));\n-  if (DECL_NAME (d1) && DECL_NAME (d2))\n-    if (int cmp = strcmp (IDENTIFIER_POINTER (DECL_NAME (d1)),\n-\t\t\t  IDENTIFIER_POINTER (DECL_NAME (d2))))\n-      return cmp;\n-  return (int)DECL_UID (d1) - (int)DECL_UID (d2);\n-}\n-\n-/* Comparator for use by vec<tree>::qsort,\n-   using their names, and then IDs to order them.  */\n-\n-static int\n-cmp_decls_ptr_ptr (const void *p1, const void *p2)\n-{\n-  tree const *d1 = (tree const *)p1;\n-  tree const *d2 = (tree const *)p2;\n-\n-  return cmp_decls (*d1, *d2);\n-}\n-\n-/* Handler for calls to \"__analyzer_dump_escaped\".\n-\n-   Emit a warning giving the number of decls that have escaped, followed\n-   by a comma-separated list of their names, in alphabetical order.\n-\n-   This is for use when debugging, and may be of use in DejaGnu tests.  */\n-\n-class kf_analyzer_dump_escaped : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 0;\n-  }\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model_context *ctxt = cd.get_ctxt ();\n-    if (!ctxt)\n-      return;\n-    region_model *model = cd.get_model ();\n-\n-    auto_vec<tree> escaped_decls;\n-    for (auto iter : *model->get_store ())\n-      {\n-\tconst binding_cluster *c = iter.second;\n-\tif (!c->escaped_p ())\n-\t  continue;\n-\tif (tree decl = c->get_base_region ()->maybe_get_decl ())\n-\t  escaped_decls.safe_push (decl);\n-      }\n-\n-    /* Sort them into deterministic order; alphabetical is\n-       probably most user-friendly.  */\n-    escaped_decls.qsort (cmp_decls_ptr_ptr);\n-\n-    pretty_printer pp;\n-    pp_format_decoder (&pp) = default_tree_printer;\n-    pp_show_color (&pp) = pp_show_color (global_dc->printer);\n-    bool first = true;\n-    for (auto iter : escaped_decls)\n-      {\n-\tif (first)\n-\t  first = false;\n-\telse\n-\t  pp_string (&pp, \", \");\n-\tpp_printf (&pp, \"%qD\", iter);\n-      }\n-    /* Print the number to make it easier to write DejaGnu tests for\n-       the \"nothing has escaped\" case.  */\n-    warning_at (cd.get_location (), 0, \"escaped: %i: %s\",\n-\t\tescaped_decls.length (),\n-\t\tpp_formatted_text (&pp));\n-  }\n-};\n-\n-/* Placeholder handler for calls to \"__analyzer_dump_exploded_nodes\".\n-   This is a no-op; the real implementation happens when the\n-   exploded_graph is postprocessed.  */\n-\n-class kf_analyzer_dump_exploded_nodes : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 1;\n-  }\n-};\n-\n-/* Handler for calls to \"__analyzer_dump_named_constant\".\n-\n-   Look up the given name, and emit a warning describing the\n-   state of the corresponding stashed value.\n-\n-   This is for use when debugging, and for DejaGnu tests.  */\n-\n-class kf_analyzer_dump_named_constant : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 1;\n-  }\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model_context *ctxt = cd.get_ctxt ();\n-    if (!ctxt)\n-      return;\n-\n-    const char *name = cd.get_arg_string_literal (0);\n-    if (!name)\n-      {\n-\terror_at (cd.get_location (), \"cannot determine name\");\n-\treturn;\n-      }\n-    tree value = get_stashed_constant_by_name (name);\n-    if (value)\n-      warning_at (cd.get_location (), 0, \"named constant %qs has value %qE\",\n-\t\t  name, value);\n-    else\n-      warning_at (cd.get_location (), 0, \"named constant %qs has unknown value\",\n-\t\t  name);\n-  }\n-};\n-\n-/* A pending_diagnostic subclass for implementing \"__analyzer_dump_path\".  */\n-\n-class dump_path_diagnostic\n-  : public pending_diagnostic_subclass<dump_path_diagnostic>\n-{\n-public:\n-  int get_controlling_option () const final override\n-  {\n-    return 0;\n-  }\n-\n-  bool emit (rich_location *richloc) final override\n-  {\n-    inform (richloc, \"path\");\n-    return true;\n-  }\n-\n-  const char *get_kind () const final override\n-  {\n-    return \"dump_path_diagnostic\";\n-  }\n-\n-  bool operator== (const dump_path_diagnostic &) const\n-  {\n-    return true;\n-  }\n-};\n-\n-/* Handle calls to \"__analyzer_dump_path\" by queuing a diagnostic at this\n-   exploded_node.  */\n-\n-class kf_analyzer_dump_path : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 0;\n-  }\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model_context *ctxt = cd.get_ctxt ();\n-    if (!ctxt)\n-      return;\n-    ctxt->warn (make_unique<dump_path_diagnostic> ());\n-  }\n-};\n-\n-/* Handle calls to \"__analyzer_dump_region_model\" by dumping\n-   the region model's state to stderr.  */\n-\n-class kf_analyzer_dump_region_model : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 0;\n-  }\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model_context *ctxt = cd.get_ctxt ();\n-    if (!ctxt)\n-      return;\n-    region_model *model = cd.get_model ();\n-    model->dump (false);\n-  }\n-};\n-\n-/* Handle a call to \"__analyzer_eval\" by evaluating the input\n-   and dumping as a dummy warning, so that test cases can use\n-   dg-warning to validate the result (and so unexpected warnings will\n-   lead to DejaGnu failures).\n-   Broken out as a subroutine to make it easier to put a breakpoint on it\n-   - though typically this doesn't help, as we have an SSA name as the arg,\n-   and what's more interesting is usually the def stmt for that name.  */\n-\n-class kf_analyzer_eval : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 1;\n-  }\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model_context *ctxt = cd.get_ctxt ();\n-    if (!ctxt)\n-      return;\n-    region_model *model = cd.get_model ();\n-\n-    tree t_arg = cd.get_arg_tree (0);\n-    tristate t = model->eval_condition (t_arg, NE_EXPR, integer_zero_node,\n-\t\t\t\t\tctxt);\n-    warning_at (cd.get_location (), 0, \"%s\", t.as_string ());\n-  }\n-};\n-\n-/* Handler for \"__analyzer_get_unknown_ptr\".  */\n-\n-class kf_analyzer_get_unknown_ptr : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 0;\n-  }\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model_manager *mgr = cd.get_manager ();\n-    const svalue *ptr_sval\n-      = mgr->get_or_create_unknown_svalue (cd.get_lhs_type ());\n-    cd.maybe_set_lhs (ptr_sval);\n-  }\n-};\n-\n /* Handler for \"__builtin_expect\" etc.  */\n \n class kf_expect : public internal_known_function\n@@ -977,61 +451,6 @@ class kf_putenv : public known_function\n   }\n };\n \n-/* Handler for \"operator new\" and \"operator new []\".  */\n-\n-class kf_operator_new : public known_function\n-{\n-public:\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == 1;\n-  }\n-\n-  void impl_call_pre (const call_details &cd) const final override\n-  {\n-    region_model *model = cd.get_model ();\n-    region_model_manager *mgr = cd.get_manager ();\n-    const svalue *size_sval = cd.get_arg_svalue (0);\n-    const region *new_reg\n-      = model->get_or_create_region_for_heap_alloc (size_sval, cd.get_ctxt ());\n-    if (cd.get_lhs_type ())\n-      {\n-\tconst svalue *ptr_sval\n-\t  = mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n-\tcd.maybe_set_lhs (ptr_sval);\n-      }\n-  }\n-};\n-\n-/* Handler for \"operator delete\", both the sized and unsized variants\n-   (2 arguments and 1 argument respectively), and for \"operator delete []\"  */\n-\n-class kf_operator_delete : public known_function\n-{\n-public:\n-  kf_operator_delete (unsigned num_args) : m_num_args (num_args) {}\n-\n-  bool matches_call_types_p (const call_details &cd) const final override\n-  {\n-    return cd.num_args () == m_num_args;\n-  }\n-\n-  void impl_call_post (const call_details &cd) const final override\n-  {\n-    region_model *model = cd.get_model ();\n-    const svalue *ptr_sval = cd.get_arg_svalue (0);\n-    if (const region *freed_reg = ptr_sval->maybe_get_region ())\n-      {\n-\t/* If the ptr points to an underlying heap region, delete it,\n-\t   poisoning pointers.  */\n-\tmodel->unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n-      }\n-  }\n-\n-private:\n-  unsigned m_num_args;\n-};\n-\n /* Handler for \"realloc\":\n \n      void *realloc(void *ptr, size_t size);\n@@ -1490,6 +909,9 @@ region_model::impl_deallocation_call (const call_details &cd)\n void\n register_known_functions (known_function_manager &kfm)\n {\n+  /* Debugging/test support functions, all  with a \"__analyzer_\" prefix.  */\n+  register_known_analyzer_functions (kfm);\n+\n   /* Internal fns the analyzer has known_functions for.  */\n   {\n     kfm.add (IFN_BUILTIN_EXPECT, make_unique<kf_expect> ());\n@@ -1520,27 +942,6 @@ register_known_functions (known_function_manager &kfm)\n     register_varargs_builtins (kfm);\n   }\n \n-  /* Debugging/test support functions, all  with a \"__analyzer_\" prefix.  */\n-  {\n-    kfm.add (\"__analyzer_break\", make_unique<kf_analyzer_break> ());\n-    kfm.add (\"__analyzer_describe\", make_unique<kf_analyzer_describe> ());\n-    kfm.add (\"__analyzer_dump_capacity\",\n-\t     make_unique<kf_analyzer_dump_capacity> ());\n-    kfm.add (\"__analyzer_dump_escaped\",\n-\t     make_unique<kf_analyzer_dump_escaped> ());\n-    kfm.add (\"__analyzer_dump_exploded_nodes\",\n-\t     make_unique<kf_analyzer_dump_exploded_nodes> ());\n-    kfm.add (\"__analyzer_dump_named_constant\",\n-\t     make_unique<kf_analyzer_dump_named_constant> ());\n-    kfm.add (\"__analyzer_dump_path\", make_unique<kf_analyzer_dump_path> ());\n-    kfm.add (\"__analyzer_dump_region_model\",\n-\t     make_unique<kf_analyzer_dump_region_model> ());\n-    kfm.add (\"__analyzer_eval\",\n-\t     make_unique<kf_analyzer_eval> ());\n-    kfm.add (\"__analyzer_get_unknown_ptr\",\n-\t     make_unique<kf_analyzer_get_unknown_ptr> ());\n-  }\n-\n   /* Known builtins and C standard library functions.  */\n   {\n     kfm.add (\"memset\", make_unique<kf_memset> ());\n@@ -1575,14 +976,8 @@ register_known_functions (known_function_manager &kfm)\n     kfm.add (\"__error\", make_unique<kf_errno_location> ());\n   }\n \n-  /* C++ support functions.  */\n-  {\n-    kfm.add (\"operator new\", make_unique<kf_operator_new> ());\n-    kfm.add (\"operator new []\", make_unique<kf_operator_new> ());\n-    kfm.add (\"operator delete\", make_unique<kf_operator_delete> (1));\n-    kfm.add (\"operator delete\", make_unique<kf_operator_delete> (2));\n-    kfm.add (\"operator delete []\", make_unique<kf_operator_delete> (1));\n-  }\n+  /* Language-specific support functions.  */\n+  register_known_functions_lang_cp (kfm);\n }\n \n } // namespace ana"}, {"sha": "3b93d3e16b83240d685d2ef12461f74502c32bf2", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -236,56 +236,6 @@ class visitor\n \n struct append_regions_cb_data;\n \n-/* Helper class for handling calls to functions with known behavior.\n-   Implemented in region-model-impl-calls.c.  */\n-\n-class call_details\n-{\n-public:\n-  call_details (const gcall *call, region_model *model,\n-\t\tregion_model_context *ctxt);\n-\n-  region_model *get_model () const { return m_model; }\n-  region_model_manager *get_manager () const;\n-  region_model_context *get_ctxt () const { return m_ctxt; }\n-  logger *get_logger () const;\n-\n-  uncertainty_t *get_uncertainty () const;\n-  tree get_lhs_type () const { return m_lhs_type; }\n-  const region *get_lhs_region () const { return m_lhs_region; }\n-\n-  bool maybe_set_lhs (const svalue *result) const;\n-\n-  unsigned num_args () const;\n-  bool arg_is_pointer_p (unsigned idx) const\n-  {\n-    return POINTER_TYPE_P (get_arg_type (idx));\n-  }\n-  bool arg_is_size_p (unsigned idx) const;\n-\n-  const gcall *get_call_stmt () const { return m_call; }\n-  location_t get_location () const;\n-\n-  tree get_arg_tree (unsigned idx) const;\n-  tree get_arg_type (unsigned idx) const;\n-  const svalue *get_arg_svalue (unsigned idx) const;\n-  const char *get_arg_string_literal (unsigned idx) const;\n-\n-  tree get_fndecl_for_call () const;\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const;\n-  void dump (bool simple) const;\n-\n-  const svalue *get_or_create_conjured_svalue (const region *) const;\n-\n-private:\n-  const gcall *m_call;\n-  region_model *m_model;\n-  region_model_context *m_ctxt;\n-  tree m_lhs_type;\n-  const region *m_lhs_region;\n-};\n-\n /* A region_model encapsulates a representation of the state of memory, with\n    a tree of regions, along with their associated values.\n    The representation is graph-like because values can be pointers to"}, {"sha": "50e1313f85b1457de6fd75fa9acafe8c2f1e09da", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-state.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/analyzer-language.h\"\n+#include \"analyzer/call-details.h\"\n #include \"analyzer/call-info.h\"\n \n #if ENABLE_ANALYZER"}, {"sha": "1bd594b1263c89a189914072408ee62c0bf2224c", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n \n #if ENABLE_ANALYZER\n "}, {"sha": "b520c9b5566d054ffcf7a6b2a8dd61b5b4e7beae", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"analyzer/function-set.h\""}, {"sha": "1a3bddee4b29dddbbf535a8353bbb3fc3d849e22", "filename": "gcc/analyzer/varargs.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/diagnostic-manager.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"diagnostic-metadata.h\"\n+#include \"analyzer/call-details.h\"\n \n #if ENABLE_ANALYZER\n "}, {"sha": "57bccf4f2eb5964ecae7b5bff4eadb5c634bfb51", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_kernel_plugin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -41,6 +41,7 @@\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n #include \"analyzer/call-info.h\"\n #include \"make-unique.h\"\n "}, {"sha": "de887dbad8379ac05800ede2b5301d3cea47e11c", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_known_fns_plugin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861c917a972dc90beff7fa5c23a013261894e6a4/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_known_fns_plugin.c?ref=861c917a972dc90beff7fa5c23a013261894e6a4", "patch": "@@ -41,6 +41,7 @@\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-details.h\"\n #include \"analyzer/call-info.h\"\n #include \"make-unique.h\"\n "}]}