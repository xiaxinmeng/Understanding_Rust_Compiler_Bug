{"sha": "d3867483044ae00bac6daaeac6274e95254fb991", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM4Njc0ODMwNDRhZTAwYmFjNmRhYWVhYzYyNzRlOTUyNTRmYjk5MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:27:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:27:24Z"}, "message": "Use vec_perm_builder::series_p in shift_amt_for_vec_perm_mask\n\nThis patch makes shift_amt_for_vec_perm_mask use series_p to check\nfor the simple case of a natural linear series before falling back\nto testing each element individually.  The series_p test works with\nvariable-length vectors but testing every individual element doesn't.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* optabs.c (shift_amt_for_vec_perm_mask): Try using series_p\n\tbefore testing each element individually.\n\t* tree-vect-generic.c (lower_vec_perm): Likewise.\n\nFrom-SVN: r256099", "tree": {"sha": "f88513d11adda2c227b64b6e7453d3b2d8b40afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f88513d11adda2c227b64b6e7453d3b2d8b40afc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3867483044ae00bac6daaeac6274e95254fb991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3867483044ae00bac6daaeac6274e95254fb991", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3867483044ae00bac6daaeac6274e95254fb991", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3867483044ae00bac6daaeac6274e95254fb991/comments", "author": null, "committer": null, "parents": [{"sha": "1a1c441dbe5933ebf9180831236aa5be7d70a434", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1c441dbe5933ebf9180831236aa5be7d70a434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a1c441dbe5933ebf9180831236aa5be7d70a434"}], "stats": {"total": 47, "additions": 29, "deletions": 18}, "files": [{"sha": "1dfb6839d10bbc050faf9dd26c4f93b2959a071a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3867483044ae00bac6daaeac6274e95254fb991/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3867483044ae00bac6daaeac6274e95254fb991/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3867483044ae00bac6daaeac6274e95254fb991", "patch": "@@ -1,3 +1,9 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* optabs.c (shift_amt_for_vec_perm_mask): Try using series_p\n+\tbefore testing each element individually.\n+\t* tree-vect-generic.c (lower_vec_perm): Likewise.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* selftest.h (selftest::vec_perm_indices_c_tests): Declare."}, {"sha": "dcd94cd5a301b783720353d2f21b39db14a9c624", "filename": "gcc/optabs.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3867483044ae00bac6daaeac6274e95254fb991/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3867483044ae00bac6daaeac6274e95254fb991/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d3867483044ae00bac6daaeac6274e95254fb991", "patch": "@@ -5395,20 +5395,20 @@ vector_compare_rtx (machine_mode cmp_mode, enum tree_code tcode,\n static rtx\n shift_amt_for_vec_perm_mask (machine_mode mode, const vec_perm_indices &sel)\n {\n-  unsigned int i, first, nelt = GET_MODE_NUNITS (mode);\n+  unsigned int nelt = GET_MODE_NUNITS (mode);\n   unsigned int bitsize = GET_MODE_UNIT_BITSIZE (mode);\n-\n-  first = sel[0];\n+  unsigned int first = sel[0];\n   if (first >= nelt)\n     return NULL_RTX;\n-  for (i = 1; i < nelt; i++)\n-    {\n-      int idx = sel[i];\n-      unsigned int expected = i + first;\n-      /* Indices into the second vector are all equivalent.  */\n-      if (idx < 0 || (MIN (nelt, (unsigned) idx) != MIN (nelt, expected)))\n-\treturn NULL_RTX;\n-    }\n+\n+  if (!sel.series_p (0, 1, first, 1))\n+    for (unsigned int i = 1; i < nelt; i++)\n+      {\n+\tunsigned int expected = i + first;\n+\t/* Indices into the second vector are all equivalent.  */\n+\tif (MIN (nelt, sel[i]) != MIN (nelt, expected))\n+\t  return NULL_RTX;\n+      }\n \n   return gen_int_shift_amount (mode, first * bitsize);\n }"}, {"sha": "602cea3775541ac889f6ba0fdb05dfe911216f4b", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3867483044ae00bac6daaeac6274e95254fb991/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3867483044ae00bac6daaeac6274e95254fb991/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=d3867483044ae00bac6daaeac6274e95254fb991", "patch": "@@ -1320,15 +1320,20 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \t  && indices[0]\n \t  && indices[0] < elements)\n \t{\n-\t  for (i = 1; i < elements; ++i)\n+\t  bool ok_p = indices.series_p (0, 1, indices[0], 1);\n+\t  if (!ok_p)\n \t    {\n-\t      unsigned int expected = i + indices[0];\n-\t      /* Indices into the second vector are all equivalent.  */\n-\t      if (MIN (elements, (unsigned) indices[i])\n-\t\t  != MIN (elements, expected))\n- \t\tbreak;\n+\t      for (i = 1; i < elements; ++i)\n+\t\t{\n+\t\t  unsigned int expected = i + indices[0];\n+\t\t  /* Indices into the second vector are all equivalent.  */\n+\t\t  if (MIN (elements, (unsigned) indices[i])\n+\t\t      != MIN (elements, expected))\n+\t\t    break;\n+\t\t}\n+\t      ok_p = i == elements;\n \t    }\n-\t  if (i == elements)\n+\t  if (ok_p)\n \t    {\n \t      gimple_assign_set_rhs3 (stmt, mask);\n \t      update_stmt (stmt);"}]}