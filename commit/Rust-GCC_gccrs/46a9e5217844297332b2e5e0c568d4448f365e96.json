{"sha": "46a9e5217844297332b2e5e0c568d4448f365e96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZhOWU1MjE3ODQ0Mjk3MzMyYjJlNWUwYzU2OGQ0NDQ4ZjM2NWU5Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2007-06-01T00:44:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2007-06-01T00:44:36Z"}, "message": "decl.c (get_atexit_fn_ptr_type): New function.\n\n\t* decl.c (get_atexit_fn_ptr_type): New function.\n\t(get_atexit_node): Use it.\n\t(start_cleanup_fn): Likewise.\n\t(register_dtor_fn): Use the object's destructor, instead of a\n\tseparate cleanup function, where possible.\n\t* cp-tree.h (CPTI_ATEXIT_FN_PTR_TYPE): New enumerator.\n\t(atexit_fn_ptr_type_node): New macro.\n\t* decl2.c (build_cleanup): Use build_address.\n\t* g++.dg/init/cleanup3.C: New test.\n\nFrom-SVN: r125253", "tree": {"sha": "420cff63564965826ce919df9219fa10d126d563", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/420cff63564965826ce919df9219fa10d126d563"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46a9e5217844297332b2e5e0c568d4448f365e96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a9e5217844297332b2e5e0c568d4448f365e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a9e5217844297332b2e5e0c568d4448f365e96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a9e5217844297332b2e5e0c568d4448f365e96/comments", "author": null, "committer": null, "parents": [{"sha": "fa2185f0c8be353357878e67a0bb610ab7a9a704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa2185f0c8be353357878e67a0bb610ab7a9a704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa2185f0c8be353357878e67a0bb610ab7a9a704"}], "stats": {"total": 191, "additions": 145, "deletions": 46}, "files": [{"sha": "ec1492818c956906cc9bb027dd7c0ec14cb4e6bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=46a9e5217844297332b2e5e0c568d4448f365e96", "patch": "@@ -1,3 +1,14 @@\n+2007-05-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (get_atexit_fn_ptr_type): New function.\n+\t(get_atexit_node): Use it.\n+\t(start_cleanup_fn): Likewise.\n+\t(register_dtor_fn): Use the object's destructor, instead of a\n+\tseparate cleanup function, where possible.\n+\t* cp-tree.h (CPTI_ATEXIT_FN_PTR_TYPE): New enumerator.\n+\t(atexit_fn_ptr_type_node): New macro.\n+\t* decl2.c (build_cleanup): Use build_address.\n+\n 2007-05-31  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* typeck.c (build_binary_op): Include types in error."}, {"sha": "7afc68b06ba45165f1526fa875841f0a07045f70", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=46a9e5217844297332b2e5e0c568d4448f365e96", "patch": "@@ -615,6 +615,7 @@ enum cp_tree_index\n     CPTI_JCLASS,\n     CPTI_TERMINATE,\n     CPTI_CALL_UNEXPECTED,\n+    CPTI_ATEXIT_FN_PTR_TYPE,\n     CPTI_ATEXIT,\n     CPTI_DSO_HANDLE,\n     CPTI_DCAST,\n@@ -704,6 +705,10 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n /* The declaration for \"__cxa_call_unexpected\".  */\n #define call_unexpected_node\t\tcp_global_trees[CPTI_CALL_UNEXPECTED]\n \n+/* The type of the function-pointer argument to \"__cxa_atexit\" (or\n+   \"std::atexit\", if \"__cxa_atexit\" is not being used).  */\n+#define atexit_fn_ptr_type_node         cp_global_trees[CPTI_ATEXIT_FN_PTR_TYPE]\n+\n /* A pointer to `std::atexit'.  */\n #define atexit_node\t\t\tcp_global_trees[CPTI_ATEXIT]\n "}, {"sha": "407e5db8d650f1d19c618c7b67566407c2d35fce", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 102, "deletions": 42, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=46a9e5217844297332b2e5e0c568d4448f365e96", "patch": "@@ -5424,6 +5424,33 @@ declare_global_var (tree name, tree type)\n   return decl;\n }\n \n+/* Returns the type for the argument to \"__cxa_atexit\" (or \"atexit\",\n+   if \"__cxa_atexit\" is not being used) corresponding to the function\n+   to be called when the program exits.  */\n+\n+static tree\n+get_atexit_fn_ptr_type (void)\n+{\n+  tree arg_types;\n+  tree fn_type;\n+\n+  if (!atexit_fn_ptr_type_node)\n+    {\n+      if (flag_use_cxa_atexit \n+\t  && !targetm.cxx.use_atexit_for_cxa_atexit ())\n+\t/* The parameter to \"__cxa_atexit\" is \"void (*)(void *)\".  */\n+\targ_types = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+      else\n+\t/* The parameter to \"atexit\" is \"void (*)(void)\".  */\n+\targ_types = void_list_node;\n+      \n+      fn_type = build_function_type (void_type_node, arg_types);\n+      atexit_fn_ptr_type_node = build_pointer_type (fn_type);\n+    }\n+\n+  return atexit_fn_ptr_type_node;\n+}\n+\n /* Returns a pointer to the `atexit' function.  Note that if\n    FLAG_USE_CXA_ATEXIT is nonzero, then this will actually be the new\n    `__cxa_atexit' function specified in the IA64 C++ ABI.  */\n@@ -5453,9 +5480,7 @@ get_atexit_node (void)\n       use_aeabi_atexit = targetm.cxx.use_aeabi_atexit ();\n       /* First, build the pointer-to-function type for the first\n \t argument.  */\n-      arg_types = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n-      fn_type = build_function_type (void_type_node, arg_types);\n-      fn_ptr_type = build_pointer_type (fn_type);\n+      fn_ptr_type = get_atexit_fn_ptr_type ();\n       /* Then, build the rest of the argument types.  */\n       arg_types = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n       if (use_aeabi_atexit)\n@@ -5484,8 +5509,7 @@ get_atexit_node (void)\n \n \t We build up the argument types and then then function type\n \t itself.  */\n-      fn_type = build_function_type (void_type_node, void_list_node);\n-      fn_ptr_type = build_pointer_type (fn_type);\n+      fn_ptr_type = get_atexit_fn_ptr_type ();\n       arg_types = tree_cons (NULL_TREE, fn_ptr_type, void_list_node);\n       /* Build the final atexit type.  */\n       fn_type = build_function_type (integer_type_node, arg_types);\n@@ -5526,7 +5550,6 @@ static tree\n start_cleanup_fn (void)\n {\n   char name[32];\n-  tree parmtypes;\n   tree fntype;\n   tree fndecl;\n   bool use_cxa_atexit = flag_use_cxa_atexit\n@@ -5537,19 +5560,10 @@ start_cleanup_fn (void)\n   /* No need to mangle this.  */\n   push_lang_context (lang_name_c);\n \n-  /* Build the parameter-types.  */\n-  parmtypes = void_list_node;\n-  /* Functions passed to __cxa_atexit take an additional parameter.\n-     We'll just ignore it.  After we implement the new calling\n-     convention for destructors, we can eliminate the use of\n-     additional cleanup functions entirely in the -fnew-abi case.  */\n-  if (use_cxa_atexit)\n-    parmtypes = tree_cons (NULL_TREE, ptr_type_node, parmtypes);\n-  /* Build the function type itself.  */\n-  fntype = build_function_type (void_type_node, parmtypes);\n   /* Build the name of the function.  */\n   sprintf (name, \"__tcf_%d\", start_cleanup_cnt++);\n   /* Build the function declaration.  */\n+  fntype = TREE_TYPE (get_atexit_fn_ptr_type ());\n   fndecl = build_lang_decl (FUNCTION_DECL, get_identifier (name), fntype);\n   /* It's a function with internal linkage, generated by the\n      compiler.  */\n@@ -5601,50 +5615,96 @@ register_dtor_fn (tree decl)\n   tree compound_stmt;\n   tree args;\n   tree fcall;\n+  tree type;\n+  bool use_dtor;\n \n-  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n+  type = TREE_TYPE (decl);\n+  if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     return void_zero_node;\n \n-  /* Call build_cleanup before we enter the anonymous function so that\n-     any access checks will be done relative to the current scope,\n-     rather than the scope of the anonymous function.  */\n-  build_cleanup (decl);\n-\n-  /* Now start the function.  */\n-  cleanup = start_cleanup_fn ();\n-\n-  /* Now, recompute the cleanup.  It may contain SAVE_EXPRs that refer\n-     to the original function, rather than the anonymous one.  That\n-     will make the back end think that nested functions are in use,\n-     which causes confusion.  */\n-\n-  push_deferring_access_checks (dk_no_check);\n-  fcall = build_cleanup (decl);\n-  pop_deferring_access_checks ();\n+  /* If we're using \"__cxa_atexit\" (or \"__aeabi_atexit\"), and DECL is\n+     a class object, we can just pass the destructor to\n+     \"__cxa_atexit\"; we don't have to build a temporary function to do\n+     the cleanup.  */\n+  use_dtor = (flag_use_cxa_atexit \n+\t      && !targetm.cxx.use_atexit_for_cxa_atexit ()\n+\t      && CLASS_TYPE_P (type));\n+  if (use_dtor)\n+    {\n+      int idx;\n \n-  /* Create the body of the anonymous function.  */\n-  compound_stmt = begin_compound_stmt (BCS_FN_BODY);\n-  finish_expr_stmt (fcall);\n-  finish_compound_stmt (compound_stmt);\n-  end_cleanup_fn ();\n+      /* Find the destructor.  */\n+      idx = lookup_fnfields_1 (type, complete_dtor_identifier);\n+      gcc_assert (idx >= 0);\n+      cleanup = VEC_index (tree, CLASSTYPE_METHOD_VEC (type), idx);\n+      /* Make sure it is accessible.  */\n+      perform_or_defer_access_check (TYPE_BINFO (type), cleanup, cleanup);\n+    }\n+  else\n+    {\n+      /* Call build_cleanup before we enter the anonymous function so\n+\t that any access checks will be done relative to the current\n+\t scope, rather than the scope of the anonymous function.  */\n+      build_cleanup (decl);\n+  \n+      /* Now start the function.  */\n+      cleanup = start_cleanup_fn ();\n+      \n+      /* Now, recompute the cleanup.  It may contain SAVE_EXPRs that refer\n+\t to the original function, rather than the anonymous one.  That\n+\t will make the back end think that nested functions are in use,\n+\t which causes confusion.  */\n+      push_deferring_access_checks (dk_no_check);\n+      fcall = build_cleanup (decl);\n+      pop_deferring_access_checks ();\n+      \n+      /* Create the body of the anonymous function.  */\n+      compound_stmt = begin_compound_stmt (BCS_FN_BODY);\n+      finish_expr_stmt (fcall);\n+      finish_compound_stmt (compound_stmt);\n+      end_cleanup_fn ();\n+    }\n \n   /* Call atexit with the cleanup function.  */\n-  cxx_mark_addressable (cleanup);\n   mark_used (cleanup);\n-  cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n+  cleanup = build_address (cleanup);\n   if (flag_use_cxa_atexit && !targetm.cxx.use_atexit_for_cxa_atexit ())\n     {\n+      tree addr;\n+\n+      if (use_dtor)\n+\t{\n+\t  /* We must convert CLEANUP to the type that \"__cxa_atexit\"\n+\t     expects.  */\n+\t  cleanup = build_nop (get_atexit_fn_ptr_type (), cleanup);\n+\t  /* \"__cxa_atexit\" will pass the address of DECL to the\n+\t     cleanup function.  */\n+\t  mark_used (decl);\n+\t  addr = build_address (decl);\n+\t  /* The declared type of the parameter to \"__cxa_atexit\" is\n+\t     \"void *\".  For plain \"T*\", we could just let the\n+\t     machinery in build_function_call convert it -- but if the\n+\t     type is \"cv-qualified T *\", then we need to convert it\n+\t     before passing it in, to avoid spurious errors.  */\n+\t  addr = build_nop (ptr_type_node, addr);\n+\t}\n+      else\n+\t/* Since the cleanup functions we build ignore the address\n+\t   they're given, there's no reason to pass the actual address\n+\t   in, and, in general, it's cheaper to pass NULL than any\n+\t   other value.  */\n+\taddr = null_pointer_node;\n       args = tree_cons (NULL_TREE,\n \t\t\tbuild_unary_op (ADDR_EXPR, get_dso_handle_node (), 0),\n \t\t\tNULL_TREE);\n       if (targetm.cxx.use_aeabi_atexit ())\n \t{\n \t  args = tree_cons (NULL_TREE, cleanup, args);\n-\t  args = tree_cons (NULL_TREE, null_pointer_node, args);\n+\t  args = tree_cons (NULL_TREE, addr, args);\n \t}\n       else\n \t{\n-\t  args = tree_cons (NULL_TREE, null_pointer_node, args);\n+\t  args = tree_cons (NULL_TREE, addr, args);\n \t  args = tree_cons (NULL_TREE, cleanup, args);\n \t}\n     }"}, {"sha": "3e18c4a4c19ba3bf5a37f1a763610ef6bf6ec092", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=46a9e5217844297332b2e5e0c568d4448f365e96", "patch": "@@ -2190,10 +2190,7 @@ build_cleanup (tree decl)\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     temp = decl;\n   else\n-    {\n-      cxx_mark_addressable (decl);\n-      temp = build1 (ADDR_EXPR, build_pointer_type (type), decl);\n-    }\n+    temp = build_address (decl);\n   temp = build_delete (TREE_TYPE (temp), temp,\n \t\t       sfk_complete_destructor,\n \t\t       LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);"}, {"sha": "51d65e75896eace1f3b39397ca11174bd8d0593e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46a9e5217844297332b2e5e0c568d4448f365e96", "patch": "@@ -1,3 +1,7 @@\n+2007-05-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/init/cleanup3.C: New test.\n+\n 2007-05-31  Rask Ingemann Lambertsen  <rask@sygehus.dk>\n \n \t* gcc.c-torture/compile/limits-caselabels.c: Fix for targets where"}, {"sha": "da7e411aba4ae1de5103a82ece859169a51b8733", "filename": "gcc/testsuite/g++.dg/init/cleanup3.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcleanup3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46a9e5217844297332b2e5e0c568d4448f365e96/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcleanup3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcleanup3.C?ref=46a9e5217844297332b2e5e0c568d4448f365e96", "patch": "@@ -0,0 +1,22 @@\n+// Check that on targets with \"__cxa_atexit\" we use destructors,\n+// rather than cleanup functions, to destroy objects with static\n+// storage duration.\n+\n+// { dg-require-effective-target \"cxa_atexit\" }\n+// Cleanup functions generated by G++ have the \"_tcf\" prefix.\n+// { dg-final { scan-assembler-not \"_tcf\" } }\n+\n+struct S { \n+  ~S();\n+};\n+\n+struct T { \n+  S s;\n+};\n+\n+S s;\n+T t;\n+\n+void f() {\n+  static S s;\n+}"}]}