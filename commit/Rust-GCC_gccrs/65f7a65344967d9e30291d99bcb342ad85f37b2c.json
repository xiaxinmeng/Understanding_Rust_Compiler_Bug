{"sha": "65f7a65344967d9e30291d99bcb342ad85f37b2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVmN2E2NTM0NDk2N2Q5ZTMwMjkxZDk5YmNiMzQyYWQ4NWYzN2IyYw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-28T22:38:07Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-28T22:38:07Z"}, "message": "* libgcc2.c (__bb_exit_func): Support gcov style output.\n\nFrom-SVN: r13818", "tree": {"sha": "80fd07937a6cc99421933f379a19c8022aa29bb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80fd07937a6cc99421933f379a19c8022aa29bb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65f7a65344967d9e30291d99bcb342ad85f37b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f7a65344967d9e30291d99bcb342ad85f37b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f7a65344967d9e30291d99bcb342ad85f37b2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f7a65344967d9e30291d99bcb342ad85f37b2c/comments", "author": null, "committer": null, "parents": [{"sha": "f6a6a1b37dc269a44ebd1b97d9cd7bcc8da4afa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a6a1b37dc269a44ebd1b97d9cd7bcc8da4afa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6a6a1b37dc269a44ebd1b97d9cd7bcc8da4afa3"}], "stats": {"total": 133, "additions": 127, "deletions": 6}, "files": [{"sha": "23a5535dd3afacda7fc472bc0d26e1339f5b0ee4", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 127, "deletions": 6, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f7a65344967d9e30291d99bcb342ad85f37b2c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f7a65344967d9e30291d99bcb342ad85f37b2c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=65f7a65344967d9e30291d99bcb342ad85f37b2c", "patch": "@@ -1438,6 +1438,7 @@ BLOCK_PROFILER_CODE\n char *ctime ();\n \n #include \"gbl-ctors.h\"\n+#include \"gcov-io.h\"\n \n static struct bb *bb_head;\n \n@@ -1461,8 +1462,118 @@ static struct bb *bb_head;\n void\n __bb_exit_func (void)\n {\n-  FILE *file = fopen (\"bb.out\", \"a\");\n+  FILE *da_file, *file;\n   long time_value;\n+  int i;\n+\n+  if (bb_head == 0)\n+    return;\n+\n+  i = strlen (bb_head->filename) - 3;\n+\n+  if (!strcmp (bb_head->filename+i, \".da\"))\n+    {\n+      /* Must be -fprofile-arcs not -a.\n+\t Dump data in a form that gcov expects.  */\n+\n+      struct bb *ptr;\n+\n+      for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n+\t{\n+\t  /* If the file exists, and the number of counts in it is the same,\n+\t     then merge them in.  */\n+\t     \n+\t  if ((da_file = fopen (ptr->filename, \"r\")) != NULL)\n+\t    {\n+\t      long n_counts = 0;\n+\t      unsigned char tmp;\n+\t      int i;\n+\t      int ret = 0;\n+\n+\t      \n+\t      if (__read_long (&n_counts, da_file, 8) != 0)\n+\t\t{\n+\t\t  fprintf (stderr, \"arc profiling: Can't read output file %s.\\n\",\n+\t\t\t   ptr->filename);\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (n_counts == ptr->ncounts)\n+\t\t{\n+\t\t  int i;\n+\n+\t\t  for (i = 0; i < n_counts; i++)\n+\t\t    {\n+\t\t      long v = 0;\n+\t\t      unsigned char tmp;\n+\t\t      int j;\n+\t\t      int ret = 0;\n+\n+\t\t      if (__read_long (&v, da_file, 8) != 0)\n+\t\t\t{\n+\t\t\t  fprintf (stderr, \"arc profiling: Can't read output file %s.\\n\",\n+\t\t\t\t   ptr->filename);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      ptr->counts[i] += v;\n+\t\t    }\n+\t\t}\n+\n+\t      if (fclose (da_file) == EOF)\n+\t\tfprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n+\t\t\t ptr->filename);\n+\t    }\n+\t  if ((da_file = fopen (ptr->filename, \"w\")) < 0)\n+\t    {\n+\t      fprintf (stderr, \"arc profiling: Can't open output file %s.\\n\",\n+\t\t       ptr->filename);\n+\t      continue;\n+\t    }\n+\n+\t  /* ??? Should first write a header to the file.  Perferably, a 4 byte\n+\t     magic number, 4 bytes containing the time the program was\n+\t     compiled, 4 bytes containing the last modification time of the\n+\t     source file, and 4 bytes indicating the compiler options used.\n+\n+\t     That way we can easily verify that the proper source/executable/\n+\t     data file combination is being used from gcov.  */\n+\n+\t  if (__write_long (ptr->ncounts, da_file, 8) != 0)\n+\t    {\n+\t      \n+\t      fprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n+\t\t       ptr->filename);\n+\t    }\n+\t  else\n+\t    {\n+\t      int j;\n+\t      long *count_ptr = ptr->counts;\n+\t      int ret = 0;\n+\t      for (j = ptr->ncounts; j > 0; j--)\n+\t\t{\n+\t\t  if (__write_long (*count_ptr, da_file, 8) != 0)\n+\t\t    {\n+\t\t      ret=1;\n+\t\t      break;\n+\t\t    }\n+\t\t  count_ptr++;\n+\t\t}\n+\t      if (ret)\n+\t\tfprintf (stderr, \"arc profiling: Error writing output file %s.\\n\",\n+\t\t\t ptr->filename);\n+\t    }\n+\t  \n+\t  if (fclose (da_file) == EOF)\n+\t    fprintf (stderr, \"arc profiling: Error closing output file %s.\\n\",\n+\t\t     ptr->filename);\n+\t}\n+\n+      return;\n+    }\n+\n+  /* Must be basic block profiling.  Emit a human readable output file.  */\n+\n+  file = fopen (\"bb.out\", \"a\");\n \n   if (!file)\n     perror (\"bb.out\");\n@@ -1486,9 +1597,12 @@ __bb_exit_func (void)\n       for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n \t{\n \t  int i;\n-\t  int func_p\t= (ptr->nwords >= sizeof (struct bb) && ptr->nwords <= 1000);\n+\t  int func_p\t= (ptr->nwords >= sizeof (struct bb)\n+\t\t\t   && ptr->nwords <= 1000\n+\t\t\t   && ptr->functions);\n \t  int line_p\t= (func_p && ptr->line_nums);\n \t  int file_p\t= (func_p && ptr->filenames);\n+\t  int addr_p\t= (ptr->addresses != 0);\n \t  long ncounts\t= ptr->ncounts;\n \t  long cnt_max  = 0;\n \t  long line_max = 0;\n@@ -1512,7 +1626,7 @@ __bb_exit_func (void)\n \t      if (cnt_max < ptr->counts[i])\n \t\tcnt_max = ptr->counts[i];\n \n-\t      if (addr_max < ptr->addresses[i])\n+\t      if (addr_p && addr_max < ptr->addresses[i])\n \t\taddr_max = ptr->addresses[i];\n \n \t      if (line_p && line_max < ptr->line_nums[i])\n@@ -1543,10 +1657,13 @@ __bb_exit_func (void)\n \t  for (i = 0; i < ncounts; i++)\n \t    {\n \t      fprintf (file,\n-\t\t       \"    Block #%*d: executed %*ld time(s) address= 0x%.*lx\",\n+\t\t       \"    Block #%*d: executed %*ld time(s)\",\n \t\t       blk_len, i+1,\n-\t\t       cnt_len, ptr->counts[i],\n-\t\t       addr_len, ptr->addresses[i]);\n+\t\t       cnt_len, ptr->counts[i]);\n+\n+\t      if (addr_p)\n+\t\tfprintf (file, \" address= 0x%.*lx\", addr_len,\n+\t\t\t ptr->addresses[i]);\n \n \t      if (func_p)\n \t\tfprintf (file, \" function= %-*s\", func_len,\n@@ -2937,6 +3054,7 @@ int atexit (func_ptr func)\n    have to define our own exit routine which will get this to happen.  */\n \n extern void __do_global_dtors ();\n+extern void __bb_exit_func ();\n extern void _cleanup ();\n extern void _exit () __attribute__ ((noreturn));\n \n@@ -2959,6 +3077,9 @@ exit (int status)\n   __do_global_dtors ();\n #endif /* No NEED_ATEXIT */\n #endif\n+#ifndef inhibit_libc\n+  __bb_exit_func ();\n+#endif\n #ifdef EXIT_BODY\n   EXIT_BODY;\n #else"}]}