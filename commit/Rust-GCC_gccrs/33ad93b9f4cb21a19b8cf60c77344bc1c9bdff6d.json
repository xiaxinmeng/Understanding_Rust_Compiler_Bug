{"sha": "33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNhZDkzYjlmNGNiMjFhMTliOGNmNjBjNzczNDRiYzFjOWJkZmY2ZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-07-02T11:43:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-07-02T11:43:46Z"}, "message": "cloog.m4: Set up to work against ISL only.\n\n2012-07-02  Richard Guenther  <rguenther@suse.de>\n\tMichael Matz  <matz@suse.de>\n\tTobias Grosser <tobias@grosser.es>\n\tSebastian Pop <sebpop@gmail.com>\n\n\tconfig/\n\t* cloog.m4: Set up to work against ISL only.\n\t* isl.m4: New file.\n\n\t* Makefile.def: Add ISL host module, remove PPL host module.\n\tAdjust ClooG host module to use the proper ISL.\n\t* Makefile.tpl: Pass ISL include flags instead of PPL ones.\n\t* configure.ac: Include config/isl.m4.  Add ISL host library,\n\tremove PPL.  Remove PPL configury, add ISL configury, adjust\n\tClooG configury.\n\t* Makefile.in: Regenerated.\n\t* configure: Likewise.\n\n\tgcc/\n\t* Makefile.in: Remove PPL flags in favor of ISL ones.\n\t(BACKENDLIBS): Remove PPL libs.\n\t(INCLUDES): Remove PPL includes in favor of ISL ones.\n\t(graphite-clast-to-gimple.o): Remove graphite-dependences.h and\n\tgraphite-cloog-compat.h dependencies.\n\t(graphite-dependences.o): Likewise.\n\t(graphite-poly.o): Likewise.\n\t* configure.ac: Declare ISL vars instead of PPL ones.\n\t* configure: Regenerated.\n\t* doc/install.texi: Replace PPL requirement documentation\n\twith ISL one.\n\t* graphite-blocking.c: Remove PPL code, add ISL equivalent.\n\t* graphite-clast-to-gimple.c: Likewise.\n\t* graphite-dependences.c: Likewise.\n\t* graphite-interchange.c: Likewise.\n\t* graphite-poly.h: Likewise.\n\t* graphite-poly.c: Likewise.\n\t* graphite-sese-to-poly.c: Likewise.\n\t* graphite.c: Likewise.\n\t* graphite-scop-detection.c: Re-arrange includes.\n\t* graphite-cloog-util.c: Remove.\n\t* graphite-cloog-util.h: Likewise.\n\t* graphite-ppl.h: Likewise.\n\t* graphite-ppl.c: Likewise.\n\t* graphite-dependences.h: Likewise.\n\n\tlibgomp/\n\t* testsuite/libgomp.graphite/force-parallel-4.c: Adjust.\n\t* testsuite/libgomp.graphite/force-parallel-5.c: Likewise.\n\t* testsuite/libgomp.graphite/force-parallel-7.c: Likewise.\n\t* testsuite/libgomp.graphite/force-parallel-8.c: Likewise.\n\nCo-Authored-By: Michael Matz <matz@suse.de>\nCo-Authored-By: Sebastian Pop <sebpop@gmail.com>\nCo-Authored-By: Tobias Grosser <tobias@grosser.es>\n\nFrom-SVN: r189156", "tree": {"sha": "7571e73ba6cb3202642afdc4b34430a313e9a3a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7571e73ba6cb3202642afdc4b34430a313e9a3a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6886e4444f193c399b96cb1f64a24b9673cf3149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6886e4444f193c399b96cb1f64a24b9673cf3149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6886e4444f193c399b96cb1f64a24b9673cf3149"}], "stats": {"total": 7836, "additions": 2681, "deletions": 5155}, "files": [{"sha": "f32899f37bec70eb0bd94ec2b5e91c031324a7b0", "filename": "ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,3 +1,17 @@\n+2012-07-02  Richard Guenther  <rguenther@suse.de>\n+\tMichael Matz  <matz@suse.de>\n+\tTobias Grosser <tobias@grosser.es>\n+\tSebastian Pop <sebpop@gmail.com>\n+\n+\t* Makefile.def: Add ISL host module, remove PPL host module.\n+\tAdjust ClooG host module to use the proper ISL.\n+\t* Makefile.tpl: Pass ISL include flags instead of PPL ones.\n+\t* configure.ac: Include config/isl.m4.  Add ISL host library,\n+\tremove PPL.  Remove PPL configury, add ISL configury, adjust\n+\tClooG configury.\n+\t* Makefile.in: Regenerated.\n+\t* configure: Likewise.\n+\n 2012-07-02  Richard Guenther  <rguenther@suse.de>\n \n \tMerge from graphite branch"}, {"sha": "3969bf6a4d27a3458bd313d227dbd0c4977dc59d", "filename": "Makefile.def", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -61,13 +61,15 @@ host_modules= { module= mpfr; lib_path=.libs; bootstrap=true;\n host_modules= { module= mpc; lib_path=.libs; bootstrap=true;\n \t\textra_configure_flags='--disable-shared @extra_mpc_gmp_configure_flags@ @extra_mpc_mpfr_configure_flags@';\n \t\tno_install= true; };\n-host_modules= { module= ppl; lib_path=src/.libs; bootstrap=true;\n-\t\textra_configure_flags='--disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/';\n+host_modules= { module= isl; lib_path=.libs; bootstrap=true;\n+\t\textra_configure_flags='--disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp';\n+\t\textra_exports='CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS; ';\n+\t\textra_make_flags='CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"';\n \t\tno_install= true; };\n host_modules= { module= cloog; lib_path=.libs; bootstrap=true;\n-\t\textra_configure_flags='--disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl';\n-\t\textra_exports='CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS; ';\n-\t\textra_make_flags='CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"';\n+\t\textra_configure_flags='--disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system';\n+\t\textra_exports='CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS; ';\n+\t\textra_make_flags='CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"';\n \t\tno_install= true; };\n host_modules= { module= libelf; lib_path=.libs; bootstrap=true;\n \t\textra_configure_flags='--disable-shared';\n@@ -295,7 +297,6 @@ dependencies = { module=all-gcc; on=all-gmp; };\n dependencies = { module=all-gcc; on=all-intl; };\n dependencies = { module=all-gcc; on=all-mpfr; };\n dependencies = { module=all-gcc; on=all-mpc; };\n-dependencies = { module=all-gcc; on=all-ppl; };\n dependencies = { module=all-gcc; on=all-cloog; };\n dependencies = { module=all-gcc; on=all-build-texinfo; };\n dependencies = { module=all-gcc; on=all-build-bison; };\n@@ -332,9 +333,9 @@ dependencies = { module=all-utils; on=all-libiberty; };\n \n dependencies = { module=configure-mpfr; on=all-gmp; };\n dependencies = { module=configure-mpc; on=all-mpfr; };\n-dependencies = { module=configure-ppl; on=all-gmp; };\n-dependencies = { module=configure-ppl; on=all-mpfr; };\n-dependencies = { module=configure-cloog; on=all-ppl; };\n+dependencies = { module=configure-isl; on=all-gmp; };\n+dependencies = { module=configure-cloog; on=all-isl; };\n+dependencies = { module=configure-cloog; on=all-gmp; };\n \n // Host modules specific to gdb.\n dependencies = { module=configure-gdb; on=all-intl; };"}, {"sha": "0be7e479a78b15b9faa42d2fa0bbf43a595f929a", "filename": "Makefile.in", "status": "modified", "additions": 592, "deletions": 602, "changes": 1194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -219,8 +219,7 @@ HOST_EXPORTS = \\\n \tHOST_LIBS=\"$(STAGE1_LIBS)\"; export HOST_LIBS; \\\n \tGMPLIBS=\"$(HOST_GMPLIBS)\"; export GMPLIBS; \\\n \tGMPINC=\"$(HOST_GMPINC)\"; export GMPINC; \\\n-\tPPLLIBS=\"$(HOST_PPLLIBS)\"; export PPLLIBS; \\\n-\tPPLINC=\"$(HOST_PPLINC)\"; export PPLINC; \\\n+\tISLINC=\"$(HOST_ISLINC)\"; export ISLINC; \\\n \tCLOOGLIBS=\"$(HOST_CLOOGLIBS)\"; export CLOOGLIBS; \\\n \tCLOOGINC=\"$(HOST_CLOOGINC)\"; export CLOOGINC; \\\n \tLIBELFLIBS=\"$(HOST_LIBELFLIBS)\" ; export LIBELFLIBS; \\\n@@ -310,9 +309,8 @@ NORMAL_TARGET_EXPORTS = \\\n HOST_GMPLIBS = @gmplibs@\n HOST_GMPINC = @gmpinc@\n \n-# Where to find PPL\n-HOST_PPLLIBS = @ppllibs@\n-HOST_PPLINC = @pplinc@\n+# Where to find ISL\n+HOST_ISLINC = @islinc@\n \n # Where to find CLOOG\n HOST_CLOOGLIBS = @clooglibs@\n@@ -629,7 +627,7 @@ TARGET_LIB_PATH_libatomic = $$r/$(TARGET_SUBDIR)/libatomic/.libs:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the host machine work.\n-HOST_LIB_PATH = $(HOST_LIB_PATH_bfd)$(HOST_LIB_PATH_opcodes)$(HOST_LIB_PATH_gmp)$(HOST_LIB_PATH_mpfr)$(HOST_LIB_PATH_mpc)$(HOST_LIB_PATH_ppl)$(HOST_LIB_PATH_cloog)$(HOST_LIB_PATH_libelf)\n+HOST_LIB_PATH = $(HOST_LIB_PATH_bfd)$(HOST_LIB_PATH_opcodes)$(HOST_LIB_PATH_gmp)$(HOST_LIB_PATH_mpfr)$(HOST_LIB_PATH_mpc)$(HOST_LIB_PATH_isl)$(HOST_LIB_PATH_cloog)$(HOST_LIB_PATH_libelf)\n \n # Define HOST_LIB_PATH_gcc here, for the sake of TARGET_LIB_PATH, ouch\n @if gcc\n@@ -662,10 +660,10 @@ HOST_LIB_PATH_mpc = \\\n   $$r/$(HOST_SUBDIR)/mpc/.libs:$$r/$(HOST_SUBDIR)/prev-mpc/.libs:\n @endif mpc\n \n-@if ppl\n-HOST_LIB_PATH_ppl = \\\n-  $$r/$(HOST_SUBDIR)/ppl/src/.libs:$$r/$(HOST_SUBDIR)/prev-ppl/src/.libs:\n-@endif ppl\n+@if isl\n+HOST_LIB_PATH_isl = \\\n+  $$r/$(HOST_SUBDIR)/isl/.libs:$$r/$(HOST_SUBDIR)/prev-isl/.libs:\n+@endif isl\n \n @if cloog\n HOST_LIB_PATH_cloog = \\\n@@ -915,7 +913,7 @@ configure-host:  \\\n     maybe-configure-gmp \\\n     maybe-configure-mpfr \\\n     maybe-configure-mpc \\\n-    maybe-configure-ppl \\\n+    maybe-configure-isl \\\n     maybe-configure-cloog \\\n     maybe-configure-libelf \\\n     maybe-configure-gold \\\n@@ -1034,9 +1032,9 @@ all-host: maybe-all-mpfr\n @if mpc-no-bootstrap\n all-host: maybe-all-mpc\n @endif mpc-no-bootstrap\n-@if ppl-no-bootstrap\n-all-host: maybe-all-ppl\n-@endif ppl-no-bootstrap\n+@if isl-no-bootstrap\n+all-host: maybe-all-isl\n+@endif isl-no-bootstrap\n @if cloog-no-bootstrap\n all-host: maybe-all-cloog\n @endif cloog-no-bootstrap\n@@ -1146,7 +1144,7 @@ info-host: maybe-info-gcc\n info-host: maybe-info-gmp\n info-host: maybe-info-mpfr\n info-host: maybe-info-mpc\n-info-host: maybe-info-ppl\n+info-host: maybe-info-isl\n info-host: maybe-info-cloog\n info-host: maybe-info-libelf\n info-host: maybe-info-gold\n@@ -1225,7 +1223,7 @@ dvi-host: maybe-dvi-gcc\n dvi-host: maybe-dvi-gmp\n dvi-host: maybe-dvi-mpfr\n dvi-host: maybe-dvi-mpc\n-dvi-host: maybe-dvi-ppl\n+dvi-host: maybe-dvi-isl\n dvi-host: maybe-dvi-cloog\n dvi-host: maybe-dvi-libelf\n dvi-host: maybe-dvi-gold\n@@ -1304,7 +1302,7 @@ pdf-host: maybe-pdf-gcc\n pdf-host: maybe-pdf-gmp\n pdf-host: maybe-pdf-mpfr\n pdf-host: maybe-pdf-mpc\n-pdf-host: maybe-pdf-ppl\n+pdf-host: maybe-pdf-isl\n pdf-host: maybe-pdf-cloog\n pdf-host: maybe-pdf-libelf\n pdf-host: maybe-pdf-gold\n@@ -1383,7 +1381,7 @@ html-host: maybe-html-gcc\n html-host: maybe-html-gmp\n html-host: maybe-html-mpfr\n html-host: maybe-html-mpc\n-html-host: maybe-html-ppl\n+html-host: maybe-html-isl\n html-host: maybe-html-cloog\n html-host: maybe-html-libelf\n html-host: maybe-html-gold\n@@ -1462,7 +1460,7 @@ TAGS-host: maybe-TAGS-gcc\n TAGS-host: maybe-TAGS-gmp\n TAGS-host: maybe-TAGS-mpfr\n TAGS-host: maybe-TAGS-mpc\n-TAGS-host: maybe-TAGS-ppl\n+TAGS-host: maybe-TAGS-isl\n TAGS-host: maybe-TAGS-cloog\n TAGS-host: maybe-TAGS-libelf\n TAGS-host: maybe-TAGS-gold\n@@ -1541,7 +1539,7 @@ install-info-host: maybe-install-info-gcc\n install-info-host: maybe-install-info-gmp\n install-info-host: maybe-install-info-mpfr\n install-info-host: maybe-install-info-mpc\n-install-info-host: maybe-install-info-ppl\n+install-info-host: maybe-install-info-isl\n install-info-host: maybe-install-info-cloog\n install-info-host: maybe-install-info-libelf\n install-info-host: maybe-install-info-gold\n@@ -1620,7 +1618,7 @@ install-pdf-host: maybe-install-pdf-gcc\n install-pdf-host: maybe-install-pdf-gmp\n install-pdf-host: maybe-install-pdf-mpfr\n install-pdf-host: maybe-install-pdf-mpc\n-install-pdf-host: maybe-install-pdf-ppl\n+install-pdf-host: maybe-install-pdf-isl\n install-pdf-host: maybe-install-pdf-cloog\n install-pdf-host: maybe-install-pdf-libelf\n install-pdf-host: maybe-install-pdf-gold\n@@ -1699,7 +1697,7 @@ install-html-host: maybe-install-html-gcc\n install-html-host: maybe-install-html-gmp\n install-html-host: maybe-install-html-mpfr\n install-html-host: maybe-install-html-mpc\n-install-html-host: maybe-install-html-ppl\n+install-html-host: maybe-install-html-isl\n install-html-host: maybe-install-html-cloog\n install-html-host: maybe-install-html-libelf\n install-html-host: maybe-install-html-gold\n@@ -1778,7 +1776,7 @@ installcheck-host: maybe-installcheck-gcc\n installcheck-host: maybe-installcheck-gmp\n installcheck-host: maybe-installcheck-mpfr\n installcheck-host: maybe-installcheck-mpc\n-installcheck-host: maybe-installcheck-ppl\n+installcheck-host: maybe-installcheck-isl\n installcheck-host: maybe-installcheck-cloog\n installcheck-host: maybe-installcheck-libelf\n installcheck-host: maybe-installcheck-gold\n@@ -1857,7 +1855,7 @@ mostlyclean-host: maybe-mostlyclean-gcc\n mostlyclean-host: maybe-mostlyclean-gmp\n mostlyclean-host: maybe-mostlyclean-mpfr\n mostlyclean-host: maybe-mostlyclean-mpc\n-mostlyclean-host: maybe-mostlyclean-ppl\n+mostlyclean-host: maybe-mostlyclean-isl\n mostlyclean-host: maybe-mostlyclean-cloog\n mostlyclean-host: maybe-mostlyclean-libelf\n mostlyclean-host: maybe-mostlyclean-gold\n@@ -1936,7 +1934,7 @@ clean-host: maybe-clean-gcc\n clean-host: maybe-clean-gmp\n clean-host: maybe-clean-mpfr\n clean-host: maybe-clean-mpc\n-clean-host: maybe-clean-ppl\n+clean-host: maybe-clean-isl\n clean-host: maybe-clean-cloog\n clean-host: maybe-clean-libelf\n clean-host: maybe-clean-gold\n@@ -2015,7 +2013,7 @@ distclean-host: maybe-distclean-gcc\n distclean-host: maybe-distclean-gmp\n distclean-host: maybe-distclean-mpfr\n distclean-host: maybe-distclean-mpc\n-distclean-host: maybe-distclean-ppl\n+distclean-host: maybe-distclean-isl\n distclean-host: maybe-distclean-cloog\n distclean-host: maybe-distclean-libelf\n distclean-host: maybe-distclean-gold\n@@ -2094,7 +2092,7 @@ maintainer-clean-host: maybe-maintainer-clean-gcc\n maintainer-clean-host: maybe-maintainer-clean-gmp\n maintainer-clean-host: maybe-maintainer-clean-mpfr\n maintainer-clean-host: maybe-maintainer-clean-mpc\n-maintainer-clean-host: maybe-maintainer-clean-ppl\n+maintainer-clean-host: maybe-maintainer-clean-isl\n maintainer-clean-host: maybe-maintainer-clean-cloog\n maintainer-clean-host: maybe-maintainer-clean-libelf\n maintainer-clean-host: maybe-maintainer-clean-gold\n@@ -2228,7 +2226,7 @@ check-host:  \\\n     maybe-check-gmp \\\n     maybe-check-mpfr \\\n     maybe-check-mpc \\\n-    maybe-check-ppl \\\n+    maybe-check-isl \\\n     maybe-check-cloog \\\n     maybe-check-libelf \\\n     maybe-check-gold \\\n@@ -2333,7 +2331,7 @@ install-host-nogcc:  \\\n     maybe-install-gmp \\\n     maybe-install-mpfr \\\n     maybe-install-mpc \\\n-    maybe-install-ppl \\\n+    maybe-install-isl \\\n     maybe-install-cloog \\\n     maybe-install-libelf \\\n     maybe-install-gold \\\n@@ -2379,7 +2377,7 @@ install-host:  \\\n     maybe-install-gmp \\\n     maybe-install-mpfr \\\n     maybe-install-mpc \\\n-    maybe-install-ppl \\\n+    maybe-install-isl \\\n     maybe-install-cloog \\\n     maybe-install-libelf \\\n     maybe-install-gold \\\n@@ -2478,7 +2476,7 @@ install-strip-host:  \\\n     maybe-install-strip-gmp \\\n     maybe-install-strip-mpfr \\\n     maybe-install-strip-mpc \\\n-    maybe-install-strip-ppl \\\n+    maybe-install-strip-isl \\\n     maybe-install-strip-cloog \\\n     maybe-install-strip-libelf \\\n     maybe-install-strip-gold \\\n@@ -13019,878 +13017,878 @@ maintainer-clean-mpc:\n \n \n \n-.PHONY: configure-ppl maybe-configure-ppl\n-maybe-configure-ppl:\n+.PHONY: configure-isl maybe-configure-isl\n+maybe-configure-isl:\n @if gcc-bootstrap\n-configure-ppl: stage_current\n+configure-isl: stage_current\n @endif gcc-bootstrap\n-@if ppl\n-maybe-configure-ppl: configure-ppl\n-configure-ppl: \n+@if isl\n+maybe-configure-isl: configure-isl\n+configure-isl: \n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\ttest ! -f $(HOST_SUBDIR)/ppl/Makefile || exit 0; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl ; \\\n-\t$(HOST_EXPORTS)  \\\n-\techo Configuring in $(HOST_SUBDIR)/ppl; \\\n-\tcd \"$(HOST_SUBDIR)/ppl\" || exit 1; \\\n+\ttest ! -f $(HOST_SUBDIR)/isl/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl ; \\\n+\t$(HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\techo Configuring in $(HOST_SUBDIR)/isl; \\\n+\tcd \"$(HOST_SUBDIR)/isl\" || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(HOST_SUBDIR)/ppl/ | \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/isl/ | \\\n \t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n \tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/ppl\"; \\\n-\tlibsrcdir=\"$$s/ppl\"; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/isl\"; \\\n+\tlibsrcdir=\"$$s/isl\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n-\t  --target=${target_alias} $${srcdiroption} --disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/ \\\n+\t  --target=${target_alias} $${srcdiroption} --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp \\\n \t  || exit 1\n-@endif ppl\n+@endif isl\n \n \n \n-.PHONY: configure-stage1-ppl maybe-configure-stage1-ppl\n-maybe-configure-stage1-ppl:\n-@if ppl-bootstrap\n-maybe-configure-stage1-ppl: configure-stage1-ppl\n-configure-stage1-ppl:\n+.PHONY: configure-stage1-isl maybe-configure-stage1-isl\n+maybe-configure-stage1-isl:\n+@if isl-bootstrap\n+maybe-configure-stage1-isl: configure-stage1-isl\n+configure-stage1-isl:\n \t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n-\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n-\ttest ! -f $(HOST_SUBDIR)/ppl/Makefile || exit 0; \\\n+\ttest ! -f $(HOST_SUBDIR)/isl/Makefile || exit 0; \\\n \t$(HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE1_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE1_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(LIBCFLAGS)\"; export LIBCFLAGS;  \\\n-\techo Configuring stage 1 in $(HOST_SUBDIR)/ppl ; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl ; \\\n-\tcd $(HOST_SUBDIR)/ppl || exit 1; \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\techo Configuring stage 1 in $(HOST_SUBDIR)/isl ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl ; \\\n+\tcd $(HOST_SUBDIR)/isl || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(HOST_SUBDIR)/ppl/ | \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/isl/ | \\\n \t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n \tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/ppl\"; \\\n-\tlibsrcdir=\"$$s/ppl\"; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/isl\"; \\\n+\tlibsrcdir=\"$$s/isl\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  $(STAGE1_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/\n-@endif ppl-bootstrap\n-\n-.PHONY: configure-stage2-ppl maybe-configure-stage2-ppl\n-maybe-configure-stage2-ppl:\n-@if ppl-bootstrap\n-maybe-configure-stage2-ppl: configure-stage2-ppl\n-configure-stage2-ppl:\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp\n+@endif isl-bootstrap\n+\n+.PHONY: configure-stage2-isl maybe-configure-stage2-isl\n+maybe-configure-stage2-isl:\n+@if isl-bootstrap\n+maybe-configure-stage2-isl: configure-stage2-isl\n+configure-stage2-isl:\n \t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n-\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n-\ttest ! -f $(HOST_SUBDIR)/ppl/Makefile || exit 0; \\\n+\ttest ! -f $(HOST_SUBDIR)/isl/Makefile || exit 0; \\\n \t$(HOST_EXPORTS) \\\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE2_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE2_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\"; export LIBCFLAGS;  \\\n-\techo Configuring stage 2 in $(HOST_SUBDIR)/ppl ; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl ; \\\n-\tcd $(HOST_SUBDIR)/ppl || exit 1; \\\n+\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\techo Configuring stage 2 in $(HOST_SUBDIR)/isl ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl ; \\\n+\tcd $(HOST_SUBDIR)/isl || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(HOST_SUBDIR)/ppl/ | \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/isl/ | \\\n \t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n \tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/ppl\"; \\\n-\tlibsrcdir=\"$$s/ppl\"; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/isl\"; \\\n+\tlibsrcdir=\"$$s/isl\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGE2_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/\n-@endif ppl-bootstrap\n-\n-.PHONY: configure-stage3-ppl maybe-configure-stage3-ppl\n-maybe-configure-stage3-ppl:\n-@if ppl-bootstrap\n-maybe-configure-stage3-ppl: configure-stage3-ppl\n-configure-stage3-ppl:\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp\n+@endif isl-bootstrap\n+\n+.PHONY: configure-stage3-isl maybe-configure-stage3-isl\n+maybe-configure-stage3-isl:\n+@if isl-bootstrap\n+maybe-configure-stage3-isl: configure-stage3-isl\n+configure-stage3-isl:\n \t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n-\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n-\ttest ! -f $(HOST_SUBDIR)/ppl/Makefile || exit 0; \\\n+\ttest ! -f $(HOST_SUBDIR)/isl/Makefile || exit 0; \\\n \t$(HOST_EXPORTS) \\\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE3_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE3_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\"; export LIBCFLAGS;  \\\n-\techo Configuring stage 3 in $(HOST_SUBDIR)/ppl ; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl ; \\\n-\tcd $(HOST_SUBDIR)/ppl || exit 1; \\\n+\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\techo Configuring stage 3 in $(HOST_SUBDIR)/isl ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl ; \\\n+\tcd $(HOST_SUBDIR)/isl || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(HOST_SUBDIR)/ppl/ | \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/isl/ | \\\n \t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n \tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/ppl\"; \\\n-\tlibsrcdir=\"$$s/ppl\"; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/isl\"; \\\n+\tlibsrcdir=\"$$s/isl\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGE3_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/\n-@endif ppl-bootstrap\n-\n-.PHONY: configure-stage4-ppl maybe-configure-stage4-ppl\n-maybe-configure-stage4-ppl:\n-@if ppl-bootstrap\n-maybe-configure-stage4-ppl: configure-stage4-ppl\n-configure-stage4-ppl:\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp\n+@endif isl-bootstrap\n+\n+.PHONY: configure-stage4-isl maybe-configure-stage4-isl\n+maybe-configure-stage4-isl:\n+@if isl-bootstrap\n+maybe-configure-stage4-isl: configure-stage4-isl\n+configure-stage4-isl:\n \t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n-\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n-\ttest ! -f $(HOST_SUBDIR)/ppl/Makefile || exit 0; \\\n+\ttest ! -f $(HOST_SUBDIR)/isl/Makefile || exit 0; \\\n \t$(HOST_EXPORTS) \\\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE4_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE4_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\"; export LIBCFLAGS;  \\\n-\techo Configuring stage 4 in $(HOST_SUBDIR)/ppl ; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl ; \\\n-\tcd $(HOST_SUBDIR)/ppl || exit 1; \\\n+\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\techo Configuring stage 4 in $(HOST_SUBDIR)/isl ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl ; \\\n+\tcd $(HOST_SUBDIR)/isl || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(HOST_SUBDIR)/ppl/ | \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/isl/ | \\\n \t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n \tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/ppl\"; \\\n-\tlibsrcdir=\"$$s/ppl\"; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/isl\"; \\\n+\tlibsrcdir=\"$$s/isl\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGE4_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/\n-@endif ppl-bootstrap\n-\n-.PHONY: configure-stageprofile-ppl maybe-configure-stageprofile-ppl\n-maybe-configure-stageprofile-ppl:\n-@if ppl-bootstrap\n-maybe-configure-stageprofile-ppl: configure-stageprofile-ppl\n-configure-stageprofile-ppl:\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp\n+@endif isl-bootstrap\n+\n+.PHONY: configure-stageprofile-isl maybe-configure-stageprofile-isl\n+maybe-configure-stageprofile-isl:\n+@if isl-bootstrap\n+maybe-configure-stageprofile-isl: configure-stageprofile-isl\n+configure-stageprofile-isl:\n \t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n-\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n-\ttest ! -f $(HOST_SUBDIR)/ppl/Makefile || exit 0; \\\n+\ttest ! -f $(HOST_SUBDIR)/isl/Makefile || exit 0; \\\n \t$(HOST_EXPORTS) \\\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGEprofile_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export LIBCFLAGS;  \\\n-\techo Configuring stage profile in $(HOST_SUBDIR)/ppl ; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl ; \\\n-\tcd $(HOST_SUBDIR)/ppl || exit 1; \\\n+\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\techo Configuring stage profile in $(HOST_SUBDIR)/isl ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl ; \\\n+\tcd $(HOST_SUBDIR)/isl || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(HOST_SUBDIR)/ppl/ | \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/isl/ | \\\n \t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n \tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/ppl\"; \\\n-\tlibsrcdir=\"$$s/ppl\"; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/isl\"; \\\n+\tlibsrcdir=\"$$s/isl\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGEprofile_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/\n-@endif ppl-bootstrap\n-\n-.PHONY: configure-stagefeedback-ppl maybe-configure-stagefeedback-ppl\n-maybe-configure-stagefeedback-ppl:\n-@if ppl-bootstrap\n-maybe-configure-stagefeedback-ppl: configure-stagefeedback-ppl\n-configure-stagefeedback-ppl:\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp\n+@endif isl-bootstrap\n+\n+.PHONY: configure-stagefeedback-isl maybe-configure-stagefeedback-isl\n+maybe-configure-stagefeedback-isl:\n+@if isl-bootstrap\n+maybe-configure-stagefeedback-isl: configure-stagefeedback-isl\n+configure-stagefeedback-isl:\n \t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n-\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl\n+\t@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n-\ttest ! -f $(HOST_SUBDIR)/ppl/Makefile || exit 0; \\\n+\ttest ! -f $(HOST_SUBDIR)/isl/Makefile || exit 0; \\\n \t$(HOST_EXPORTS) \\\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGEfeedback_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export LIBCFLAGS;  \\\n-\techo Configuring stage feedback in $(HOST_SUBDIR)/ppl ; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/ppl ; \\\n-\tcd $(HOST_SUBDIR)/ppl || exit 1; \\\n+\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\techo Configuring stage feedback in $(HOST_SUBDIR)/isl ; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/isl ; \\\n+\tcd $(HOST_SUBDIR)/isl || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(HOST_SUBDIR)/ppl/ | \\\n+\t  *) topdir=`echo $(HOST_SUBDIR)/isl/ | \\\n \t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n \tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/ppl\"; \\\n-\tlibsrcdir=\"$$s/ppl\"; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/isl\"; \\\n+\tlibsrcdir=\"$$s/isl\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGEfeedback_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-libgmp-prefix=$$r/$(HOST_SUBDIR)/gmp/ --with-libgmpxx-prefix=$$r/$(HOST_SUBDIR)/gmp/\n-@endif ppl-bootstrap\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp\n+@endif isl-bootstrap\n \n \n \n \n \n-.PHONY: all-ppl maybe-all-ppl\n-maybe-all-ppl:\n+.PHONY: all-isl maybe-all-isl\n+maybe-all-isl:\n @if gcc-bootstrap\n-all-ppl: stage_current\n+all-isl: stage_current\n @endif gcc-bootstrap\n-@if ppl\n-TARGET-ppl=all\n-maybe-all-ppl: all-ppl\n-all-ppl: configure-ppl\n+@if isl\n+TARGET-isl=all\n+maybe-all-isl: all-isl\n+all-isl: configure-isl\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(HOST_EXPORTS)  \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS)  \\\n-\t\t$(TARGET-ppl))\n-@endif ppl\n+\t$(HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t\t$(TARGET-isl))\n+@endif isl\n \n \n \n-.PHONY: all-stage1-ppl maybe-all-stage1-ppl\n-.PHONY: clean-stage1-ppl maybe-clean-stage1-ppl\n-maybe-all-stage1-ppl:\n-maybe-clean-stage1-ppl:\n-@if ppl-bootstrap\n-maybe-all-stage1-ppl: all-stage1-ppl\n-all-stage1: all-stage1-ppl\n-TARGET-stage1-ppl = $(TARGET-ppl)\n-all-stage1-ppl: configure-stage1-ppl\n+.PHONY: all-stage1-isl maybe-all-stage1-isl\n+.PHONY: clean-stage1-isl maybe-clean-stage1-isl\n+maybe-all-stage1-isl:\n+maybe-clean-stage1-isl:\n+@if isl-bootstrap\n+maybe-all-stage1-isl: all-stage1-isl\n+all-stage1: all-stage1-isl\n+TARGET-stage1-isl = $(TARGET-isl)\n+all-stage1-isl: configure-stage1-isl\n \t@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n-\t$(HOST_EXPORTS)  \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\t$(HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE1_CFLAGS)\" \\\n \t\tCXXFLAGS=\"$(STAGE1_CXXFLAGS)\" \\\n \t\tLIBCFLAGS=\"$(LIBCFLAGS)\" \\\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS)   \\\n+\t\t$(EXTRA_HOST_FLAGS)  CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE1_TFLAGS)\" \\\n-\t\t$(TARGET-stage1-ppl)\n+\t\t$(TARGET-stage1-isl)\n \n-maybe-clean-stage1-ppl: clean-stage1-ppl\n-clean-stage1: clean-stage1-ppl\n-clean-stage1-ppl:\n+maybe-clean-stage1-isl: clean-stage1-isl\n+clean-stage1: clean-stage1-isl\n+clean-stage1-isl:\n \t@if [ $(current_stage) = stage1 ]; then \\\n-\t  [ -f $(HOST_SUBDIR)/ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/isl/Makefile ] || exit 0; \\\n \telse \\\n-\t  [ -f $(HOST_SUBDIR)/stage1-ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/stage1-isl/Makefile ] || exit 0; \\\n \t  $(MAKE) stage1-start; \\\n \tfi; \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n-\t\t clean\n-@endif ppl-bootstrap\n-\n-\n-.PHONY: all-stage2-ppl maybe-all-stage2-ppl\n-.PHONY: clean-stage2-ppl maybe-clean-stage2-ppl\n-maybe-all-stage2-ppl:\n-maybe-clean-stage2-ppl:\n-@if ppl-bootstrap\n-maybe-all-stage2-ppl: all-stage2-ppl\n-all-stage2: all-stage2-ppl\n-TARGET-stage2-ppl = $(TARGET-ppl)\n-all-stage2-ppl: configure-stage2-ppl\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n+@endif isl-bootstrap\n+\n+\n+.PHONY: all-stage2-isl maybe-all-stage2-isl\n+.PHONY: clean-stage2-isl maybe-clean-stage2-isl\n+maybe-all-stage2-isl:\n+maybe-clean-stage2-isl:\n+@if isl-bootstrap\n+maybe-all-stage2-isl: all-stage2-isl\n+all-stage2: all-stage2-isl\n+TARGET-stage2-isl = $(TARGET-isl)\n+all-stage2-isl: configure-stage2-isl\n \t@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE2_CFLAGS)\" \\\n \t\tCXXFLAGS=\"$(STAGE2_CXXFLAGS)\" \\\n \t\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\" \\\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE2_TFLAGS)\" \\\n-\t\t$(TARGET-stage2-ppl)\n+\t\t$(TARGET-stage2-isl)\n \n-maybe-clean-stage2-ppl: clean-stage2-ppl\n-clean-stage2: clean-stage2-ppl\n-clean-stage2-ppl:\n+maybe-clean-stage2-isl: clean-stage2-isl\n+clean-stage2: clean-stage2-isl\n+clean-stage2-isl:\n \t@if [ $(current_stage) = stage2 ]; then \\\n-\t  [ -f $(HOST_SUBDIR)/ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/isl/Makefile ] || exit 0; \\\n \telse \\\n-\t  [ -f $(HOST_SUBDIR)/stage2-ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/stage2-isl/Makefile ] || exit 0; \\\n \t  $(MAKE) stage2-start; \\\n \tfi; \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t clean\n-@endif ppl-bootstrap\n-\n-\n-.PHONY: all-stage3-ppl maybe-all-stage3-ppl\n-.PHONY: clean-stage3-ppl maybe-clean-stage3-ppl\n-maybe-all-stage3-ppl:\n-maybe-clean-stage3-ppl:\n-@if ppl-bootstrap\n-maybe-all-stage3-ppl: all-stage3-ppl\n-all-stage3: all-stage3-ppl\n-TARGET-stage3-ppl = $(TARGET-ppl)\n-all-stage3-ppl: configure-stage3-ppl\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n+@endif isl-bootstrap\n+\n+\n+.PHONY: all-stage3-isl maybe-all-stage3-isl\n+.PHONY: clean-stage3-isl maybe-clean-stage3-isl\n+maybe-all-stage3-isl:\n+maybe-clean-stage3-isl:\n+@if isl-bootstrap\n+maybe-all-stage3-isl: all-stage3-isl\n+all-stage3: all-stage3-isl\n+TARGET-stage3-isl = $(TARGET-isl)\n+all-stage3-isl: configure-stage3-isl\n \t@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE3_CFLAGS)\" \\\n \t\tCXXFLAGS=\"$(STAGE3_CXXFLAGS)\" \\\n \t\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\" \\\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE3_TFLAGS)\" \\\n-\t\t$(TARGET-stage3-ppl)\n+\t\t$(TARGET-stage3-isl)\n \n-maybe-clean-stage3-ppl: clean-stage3-ppl\n-clean-stage3: clean-stage3-ppl\n-clean-stage3-ppl:\n+maybe-clean-stage3-isl: clean-stage3-isl\n+clean-stage3: clean-stage3-isl\n+clean-stage3-isl:\n \t@if [ $(current_stage) = stage3 ]; then \\\n-\t  [ -f $(HOST_SUBDIR)/ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/isl/Makefile ] || exit 0; \\\n \telse \\\n-\t  [ -f $(HOST_SUBDIR)/stage3-ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/stage3-isl/Makefile ] || exit 0; \\\n \t  $(MAKE) stage3-start; \\\n \tfi; \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t clean\n-@endif ppl-bootstrap\n-\n-\n-.PHONY: all-stage4-ppl maybe-all-stage4-ppl\n-.PHONY: clean-stage4-ppl maybe-clean-stage4-ppl\n-maybe-all-stage4-ppl:\n-maybe-clean-stage4-ppl:\n-@if ppl-bootstrap\n-maybe-all-stage4-ppl: all-stage4-ppl\n-all-stage4: all-stage4-ppl\n-TARGET-stage4-ppl = $(TARGET-ppl)\n-all-stage4-ppl: configure-stage4-ppl\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n+@endif isl-bootstrap\n+\n+\n+.PHONY: all-stage4-isl maybe-all-stage4-isl\n+.PHONY: clean-stage4-isl maybe-clean-stage4-isl\n+maybe-all-stage4-isl:\n+maybe-clean-stage4-isl:\n+@if isl-bootstrap\n+maybe-all-stage4-isl: all-stage4-isl\n+all-stage4: all-stage4-isl\n+TARGET-stage4-isl = $(TARGET-isl)\n+all-stage4-isl: configure-stage4-isl\n \t@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE4_CFLAGS)\" \\\n \t\tCXXFLAGS=\"$(STAGE4_CXXFLAGS)\" \\\n \t\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\" \\\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE4_TFLAGS)\" \\\n-\t\t$(TARGET-stage4-ppl)\n+\t\t$(TARGET-stage4-isl)\n \n-maybe-clean-stage4-ppl: clean-stage4-ppl\n-clean-stage4: clean-stage4-ppl\n-clean-stage4-ppl:\n+maybe-clean-stage4-isl: clean-stage4-isl\n+clean-stage4: clean-stage4-isl\n+clean-stage4-isl:\n \t@if [ $(current_stage) = stage4 ]; then \\\n-\t  [ -f $(HOST_SUBDIR)/ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/isl/Makefile ] || exit 0; \\\n \telse \\\n-\t  [ -f $(HOST_SUBDIR)/stage4-ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/stage4-isl/Makefile ] || exit 0; \\\n \t  $(MAKE) stage4-start; \\\n \tfi; \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t clean\n-@endif ppl-bootstrap\n-\n-\n-.PHONY: all-stageprofile-ppl maybe-all-stageprofile-ppl\n-.PHONY: clean-stageprofile-ppl maybe-clean-stageprofile-ppl\n-maybe-all-stageprofile-ppl:\n-maybe-clean-stageprofile-ppl:\n-@if ppl-bootstrap\n-maybe-all-stageprofile-ppl: all-stageprofile-ppl\n-all-stageprofile: all-stageprofile-ppl\n-TARGET-stageprofile-ppl = $(TARGET-ppl)\n-all-stageprofile-ppl: configure-stageprofile-ppl\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n+@endif isl-bootstrap\n+\n+\n+.PHONY: all-stageprofile-isl maybe-all-stageprofile-isl\n+.PHONY: clean-stageprofile-isl maybe-clean-stageprofile-isl\n+maybe-all-stageprofile-isl:\n+maybe-clean-stageprofile-isl:\n+@if isl-bootstrap\n+maybe-all-stageprofile-isl: all-stageprofile-isl\n+all-stageprofile: all-stageprofile-isl\n+TARGET-stageprofile-isl = $(TARGET-isl)\n+all-stageprofile-isl: configure-stageprofile-isl\n \t@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n \t\tCXXFLAGS=\"$(STAGEprofile_CXXFLAGS)\" \\\n \t\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGEprofile_TFLAGS)\" \\\n-\t\t$(TARGET-stageprofile-ppl)\n+\t\t$(TARGET-stageprofile-isl)\n \n-maybe-clean-stageprofile-ppl: clean-stageprofile-ppl\n-clean-stageprofile: clean-stageprofile-ppl\n-clean-stageprofile-ppl:\n+maybe-clean-stageprofile-isl: clean-stageprofile-isl\n+clean-stageprofile: clean-stageprofile-isl\n+clean-stageprofile-isl:\n \t@if [ $(current_stage) = stageprofile ]; then \\\n-\t  [ -f $(HOST_SUBDIR)/ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/isl/Makefile ] || exit 0; \\\n \telse \\\n-\t  [ -f $(HOST_SUBDIR)/stageprofile-ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/stageprofile-isl/Makefile ] || exit 0; \\\n \t  $(MAKE) stageprofile-start; \\\n \tfi; \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t clean\n-@endif ppl-bootstrap\n-\n-\n-.PHONY: all-stagefeedback-ppl maybe-all-stagefeedback-ppl\n-.PHONY: clean-stagefeedback-ppl maybe-clean-stagefeedback-ppl\n-maybe-all-stagefeedback-ppl:\n-maybe-clean-stagefeedback-ppl:\n-@if ppl-bootstrap\n-maybe-all-stagefeedback-ppl: all-stagefeedback-ppl\n-all-stagefeedback: all-stagefeedback-ppl\n-TARGET-stagefeedback-ppl = $(TARGET-ppl)\n-all-stagefeedback-ppl: configure-stagefeedback-ppl\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n+@endif isl-bootstrap\n+\n+\n+.PHONY: all-stagefeedback-isl maybe-all-stagefeedback-isl\n+.PHONY: clean-stagefeedback-isl maybe-clean-stagefeedback-isl\n+maybe-all-stagefeedback-isl:\n+maybe-clean-stagefeedback-isl:\n+@if isl-bootstrap\n+maybe-all-stagefeedback-isl: all-stagefeedback-isl\n+all-stagefeedback: all-stagefeedback-isl\n+TARGET-stagefeedback-isl = $(TARGET-isl)\n+all-stagefeedback-isl: configure-stagefeedback-isl\n \t@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS)  \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS\"; export LDFLAGS;  \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n \t\tCXXFLAGS=\"$(STAGEfeedback_CXXFLAGS)\" \\\n \t\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\" \\\n-\t\t$(TARGET-stagefeedback-ppl)\n+\t\t$(TARGET-stagefeedback-isl)\n \n-maybe-clean-stagefeedback-ppl: clean-stagefeedback-ppl\n-clean-stagefeedback: clean-stagefeedback-ppl\n-clean-stagefeedback-ppl:\n+maybe-clean-stagefeedback-isl: clean-stagefeedback-isl\n+clean-stagefeedback: clean-stagefeedback-isl\n+clean-stagefeedback-isl:\n \t@if [ $(current_stage) = stagefeedback ]; then \\\n-\t  [ -f $(HOST_SUBDIR)/ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/isl/Makefile ] || exit 0; \\\n \telse \\\n-\t  [ -f $(HOST_SUBDIR)/stagefeedback-ppl/Makefile ] || exit 0; \\\n+\t  [ -f $(HOST_SUBDIR)/stagefeedback-isl/Makefile ] || exit 0; \\\n \t  $(MAKE) stagefeedback-start; \\\n \tfi; \\\n-\tcd $(HOST_SUBDIR)/ppl && \\\n+\tcd $(HOST_SUBDIR)/isl && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\t clean\n-@endif ppl-bootstrap\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n+@endif isl-bootstrap\n \n \n \n \n \n-.PHONY: check-ppl maybe-check-ppl\n-maybe-check-ppl:\n-@if ppl\n-maybe-check-ppl: check-ppl\n+.PHONY: check-isl maybe-check-isl\n+maybe-check-isl:\n+@if isl\n+maybe-check-isl: check-isl\n \n-check-ppl:\n+check-isl:\n \t@: $(MAKE); $(unstage)\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n-\t  $(MAKE) $(FLAGS_TO_PASS)  check)\n+\t(cd $(HOST_SUBDIR)/isl && \\\n+\t  $(MAKE) $(FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" check)\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: install-ppl maybe-install-ppl\n-maybe-install-ppl:\n-@if ppl\n-maybe-install-ppl: install-ppl\n+.PHONY: install-isl maybe-install-isl\n+maybe-install-isl:\n+@if isl\n+maybe-install-isl: install-isl\n \n-install-ppl:\n+install-isl:\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: install-strip-ppl maybe-install-strip-ppl\n-maybe-install-strip-ppl:\n-@if ppl\n-maybe-install-strip-ppl: install-strip-ppl\n+.PHONY: install-strip-isl maybe-install-strip-isl\n+maybe-install-strip-isl:\n+@if isl\n+maybe-install-strip-isl: install-strip-isl\n \n-install-strip-ppl:\n+install-strip-isl:\n \n-@endif ppl\n+@endif isl\n \n # Other targets (info, dvi, pdf, etc.)\n \n-.PHONY: maybe-info-ppl info-ppl\n-maybe-info-ppl:\n-@if ppl\n-maybe-info-ppl: info-ppl\n+.PHONY: maybe-info-isl info-isl\n+maybe-info-isl:\n+@if isl\n+maybe-info-isl: info-isl\n \n-info-ppl: \\\n-    configure-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+info-isl: \\\n+    configure-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing info in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing info in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          info) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-dvi-ppl dvi-ppl\n-maybe-dvi-ppl:\n-@if ppl\n-maybe-dvi-ppl: dvi-ppl\n+.PHONY: maybe-dvi-isl dvi-isl\n+maybe-dvi-isl:\n+@if isl\n+maybe-dvi-isl: dvi-isl\n \n-dvi-ppl: \\\n-    configure-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+dvi-isl: \\\n+    configure-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing dvi in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing dvi in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          dvi) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-pdf-ppl pdf-ppl\n-maybe-pdf-ppl:\n-@if ppl\n-maybe-pdf-ppl: pdf-ppl\n+.PHONY: maybe-pdf-isl pdf-isl\n+maybe-pdf-isl:\n+@if isl\n+maybe-pdf-isl: pdf-isl\n \n-pdf-ppl: \\\n-    configure-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+pdf-isl: \\\n+    configure-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing pdf in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing pdf in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          pdf) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-html-ppl html-ppl\n-maybe-html-ppl:\n-@if ppl\n-maybe-html-ppl: html-ppl\n+.PHONY: maybe-html-isl html-isl\n+maybe-html-isl:\n+@if isl\n+maybe-html-isl: html-isl\n \n-html-ppl: \\\n-    configure-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+html-isl: \\\n+    configure-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing html in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing html in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          html) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-TAGS-ppl TAGS-ppl\n-maybe-TAGS-ppl:\n-@if ppl\n-maybe-TAGS-ppl: TAGS-ppl\n+.PHONY: maybe-TAGS-isl TAGS-isl\n+maybe-TAGS-isl:\n+@if isl\n+maybe-TAGS-isl: TAGS-isl\n \n-TAGS-ppl: \\\n-    configure-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+TAGS-isl: \\\n+    configure-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing TAGS in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing TAGS in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          TAGS) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-install-info-ppl install-info-ppl\n-maybe-install-info-ppl:\n-@if ppl\n-maybe-install-info-ppl: install-info-ppl\n+.PHONY: maybe-install-info-isl install-info-isl\n+maybe-install-info-isl:\n+@if isl\n+maybe-install-info-isl: install-info-isl\n \n-install-info-ppl: \\\n-    configure-ppl \\\n-    info-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+install-info-isl: \\\n+    configure-isl \\\n+    info-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing install-info in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing install-info in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          install-info) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-install-pdf-ppl install-pdf-ppl\n-maybe-install-pdf-ppl:\n-@if ppl\n-maybe-install-pdf-ppl: install-pdf-ppl\n+.PHONY: maybe-install-pdf-isl install-pdf-isl\n+maybe-install-pdf-isl:\n+@if isl\n+maybe-install-pdf-isl: install-pdf-isl\n \n-install-pdf-ppl: \\\n-    configure-ppl \\\n-    pdf-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+install-pdf-isl: \\\n+    configure-isl \\\n+    pdf-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing install-pdf in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing install-pdf in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          install-pdf) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-install-html-ppl install-html-ppl\n-maybe-install-html-ppl:\n-@if ppl\n-maybe-install-html-ppl: install-html-ppl\n+.PHONY: maybe-install-html-isl install-html-isl\n+maybe-install-html-isl:\n+@if isl\n+maybe-install-html-isl: install-html-isl\n \n-install-html-ppl: \\\n-    configure-ppl \\\n-    html-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+install-html-isl: \\\n+    configure-isl \\\n+    html-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing install-html in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing install-html in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          install-html) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-installcheck-ppl installcheck-ppl\n-maybe-installcheck-ppl:\n-@if ppl\n-maybe-installcheck-ppl: installcheck-ppl\n+.PHONY: maybe-installcheck-isl installcheck-isl\n+maybe-installcheck-isl:\n+@if isl\n+maybe-installcheck-isl: installcheck-isl\n \n-installcheck-ppl: \\\n-    configure-ppl \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+installcheck-isl: \\\n+    configure-isl \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing installcheck in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing installcheck in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          installcheck) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-mostlyclean-ppl mostlyclean-ppl\n-maybe-mostlyclean-ppl:\n-@if ppl\n-maybe-mostlyclean-ppl: mostlyclean-ppl\n+.PHONY: maybe-mostlyclean-isl mostlyclean-isl\n+maybe-mostlyclean-isl:\n+@if isl\n+maybe-mostlyclean-isl: mostlyclean-isl\n \n-mostlyclean-ppl: \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+mostlyclean-isl: \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing mostlyclean in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing mostlyclean in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          mostlyclean) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-clean-ppl clean-ppl\n-maybe-clean-ppl:\n-@if ppl\n-maybe-clean-ppl: clean-ppl\n+.PHONY: maybe-clean-isl clean-isl\n+maybe-clean-isl:\n+@if isl\n+maybe-clean-isl: clean-isl\n \n-clean-ppl: \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+clean-isl: \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing clean in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing clean in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          clean) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-distclean-ppl distclean-ppl\n-maybe-distclean-ppl:\n-@if ppl\n-maybe-distclean-ppl: distclean-ppl\n+.PHONY: maybe-distclean-isl distclean-isl\n+maybe-distclean-isl:\n+@if isl\n+maybe-distclean-isl: distclean-isl\n \n-distclean-ppl: \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+distclean-isl: \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing distclean in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing distclean in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          distclean) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n-.PHONY: maybe-maintainer-clean-ppl maintainer-clean-ppl\n-maybe-maintainer-clean-ppl:\n-@if ppl\n-maybe-maintainer-clean-ppl: maintainer-clean-ppl\n+.PHONY: maybe-maintainer-clean-isl maintainer-clean-isl\n+maybe-maintainer-clean-isl:\n+@if isl\n+maybe-maintainer-clean-isl: maintainer-clean-isl\n \n-maintainer-clean-ppl: \n-\t@[ -f ./ppl/Makefile ] || exit 0; \\\n+maintainer-clean-isl: \n+\t@[ -f ./isl/Makefile ] || exit 0; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) ; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n-\techo \"Doing maintainer-clean in ppl\" ; \\\n-\t(cd $(HOST_SUBDIR)/ppl && \\\n+\techo \"Doing maintainer-clean in isl\" ; \\\n+\t(cd $(HOST_SUBDIR)/isl && \\\n \t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n \t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n \t          \"RANLIB=$${RANLIB}\" \\\n \t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n \t          maintainer-clean) \\\n \t  || exit 1\n \n-@endif ppl\n+@endif isl\n \n \n \n@@ -13906,7 +13904,7 @@ configure-cloog:\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \ttest ! -f $(HOST_SUBDIR)/cloog/Makefile || exit 0; \\\n \t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/cloog ; \\\n-\t$(HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \techo Configuring in $(HOST_SUBDIR)/cloog; \\\n \tcd \"$(HOST_SUBDIR)/cloog\" || exit 1; \\\n \tcase $(srcdir) in \\\n@@ -13918,7 +13916,7 @@ configure-cloog:\n \tlibsrcdir=\"$$s/cloog\"; \\\n \t$(SHELL) $${libsrcdir}/configure \\\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n-\t  --target=${target_alias} $${srcdiroption} --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl \\\n+\t  --target=${target_alias} $${srcdiroption} --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system \\\n \t  || exit 1\n @endif cloog\n \n@@ -13938,7 +13936,7 @@ configure-stage1-cloog:\n \t$(HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE1_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE1_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(LIBCFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\tLIBCFLAGS=\"$(LIBCFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \techo Configuring stage 1 in $(HOST_SUBDIR)/cloog ; \\\n \t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/cloog ; \\\n \tcd $(HOST_SUBDIR)/cloog || exit 1; \\\n@@ -13953,7 +13951,7 @@ configure-stage1-cloog:\n \t  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \\\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  $(STAGE1_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system\n @endif cloog-bootstrap\n \n .PHONY: configure-stage2-cloog maybe-configure-stage2-cloog\n@@ -13971,7 +13969,7 @@ configure-stage2-cloog:\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE2_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE2_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\tLIBCFLAGS=\"$(STAGE2_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \techo Configuring stage 2 in $(HOST_SUBDIR)/cloog ; \\\n \t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/cloog ; \\\n \tcd $(HOST_SUBDIR)/cloog || exit 1; \\\n@@ -13987,7 +13985,7 @@ configure-stage2-cloog:\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGE2_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system\n @endif cloog-bootstrap\n \n .PHONY: configure-stage3-cloog maybe-configure-stage3-cloog\n@@ -14005,7 +14003,7 @@ configure-stage3-cloog:\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE3_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE3_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\tLIBCFLAGS=\"$(STAGE3_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \techo Configuring stage 3 in $(HOST_SUBDIR)/cloog ; \\\n \t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/cloog ; \\\n \tcd $(HOST_SUBDIR)/cloog || exit 1; \\\n@@ -14021,7 +14019,7 @@ configure-stage3-cloog:\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGE3_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system\n @endif cloog-bootstrap\n \n .PHONY: configure-stage4-cloog maybe-configure-stage4-cloog\n@@ -14039,7 +14037,7 @@ configure-stage4-cloog:\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGE4_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGE4_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\tLIBCFLAGS=\"$(STAGE4_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \techo Configuring stage 4 in $(HOST_SUBDIR)/cloog ; \\\n \t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/cloog ; \\\n \tcd $(HOST_SUBDIR)/cloog || exit 1; \\\n@@ -14055,7 +14053,7 @@ configure-stage4-cloog:\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGE4_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system\n @endif cloog-bootstrap\n \n .PHONY: configure-stageprofile-cloog maybe-configure-stageprofile-cloog\n@@ -14073,7 +14071,7 @@ configure-stageprofile-cloog:\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGEprofile_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\tLIBCFLAGS=\"$(STAGEprofile_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \techo Configuring stage profile in $(HOST_SUBDIR)/cloog ; \\\n \t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/cloog ; \\\n \tcd $(HOST_SUBDIR)/cloog || exit 1; \\\n@@ -14089,7 +14087,7 @@ configure-stageprofile-cloog:\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGEprofile_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system\n @endif cloog-bootstrap\n \n .PHONY: configure-stagefeedback-cloog maybe-configure-stagefeedback-cloog\n@@ -14107,7 +14105,7 @@ configure-stagefeedback-cloog:\n \t$(POSTSTAGE1_HOST_EXPORTS) \\\n \tCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export CFLAGS; \\\n \tCXXFLAGS=\"$(STAGEfeedback_CXXFLAGS)\"; export CXXFLAGS; \\\n-\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\tLIBCFLAGS=\"$(STAGEfeedback_CFLAGS)\"; export LIBCFLAGS; CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \techo Configuring stage feedback in $(HOST_SUBDIR)/cloog ; \\\n \t$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/cloog ; \\\n \tcd $(HOST_SUBDIR)/cloog || exit 1; \\\n@@ -14123,7 +14121,7 @@ configure-stagefeedback-cloog:\n \t  --target=${target_alias} $${srcdiroption} \\\n \t  --with-build-libsubdir=$(HOST_SUBDIR) \\\n \t  $(STAGEfeedback_CONFIGURE_FLAGS) \\\n-\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-ppl\n+\t  --disable-shared --with-gmp-library=$$r/$(HOST_SUBDIR)/gmp/.libs --with-gmp-include=$$r/$(HOST_SUBDIR)/gmp --with-bits=gmp --with-isl=system\n @endif cloog-bootstrap\n \n \n@@ -14141,9 +14139,9 @@ maybe-all-cloog: all-cloog\n all-cloog: configure-cloog\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \t(cd $(HOST_SUBDIR)/cloog && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\t$(TARGET-cloog))\n @endif cloog\n \n@@ -14162,7 +14160,7 @@ all-stage1-cloog: configure-stage1-cloog\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE1_TFLAGS)\"; \\\n-\t$(HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE1_CFLAGS)\" \\\n@@ -14171,7 +14169,7 @@ all-stage1-cloog: configure-stage1-cloog\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS)  CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t\t$(EXTRA_HOST_FLAGS)  CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE1_TFLAGS)\" \\\n \t\t$(TARGET-stage1-cloog)\n \n@@ -14186,7 +14184,7 @@ clean-stage1-cloog:\n \tfi; \\\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n-\t\tCPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" clean\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n @endif cloog-bootstrap\n \n \n@@ -14204,7 +14202,7 @@ all-stage2-cloog: configure-stage2-cloog\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE2_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE2_CFLAGS)\" \\\n@@ -14213,7 +14211,7 @@ all-stage2-cloog: configure-stage2-cloog\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE2_TFLAGS)\" \\\n \t\t$(TARGET-stage2-cloog)\n \n@@ -14229,7 +14227,7 @@ clean-stage2-cloog:\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" clean\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n @endif cloog-bootstrap\n \n \n@@ -14247,7 +14245,7 @@ all-stage3-cloog: configure-stage3-cloog\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE3_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE3_CFLAGS)\" \\\n@@ -14256,7 +14254,7 @@ all-stage3-cloog: configure-stage3-cloog\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE3_TFLAGS)\" \\\n \t\t$(TARGET-stage3-cloog)\n \n@@ -14272,7 +14270,7 @@ clean-stage3-cloog:\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" clean\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n @endif cloog-bootstrap\n \n \n@@ -14290,7 +14288,7 @@ all-stage4-cloog: configure-stage4-cloog\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGE4_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGE4_CFLAGS)\" \\\n@@ -14299,7 +14297,7 @@ all-stage4-cloog: configure-stage4-cloog\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGE4_TFLAGS)\" \\\n \t\t$(TARGET-stage4-cloog)\n \n@@ -14315,7 +14313,7 @@ clean-stage4-cloog:\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" clean\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n @endif cloog-bootstrap\n \n \n@@ -14333,7 +14331,7 @@ all-stageprofile-cloog: configure-stageprofile-cloog\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGEprofile_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGEprofile_CFLAGS)\" \\\n@@ -14342,7 +14340,7 @@ all-stageprofile-cloog: configure-stageprofile-cloog\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGEprofile_TFLAGS)\" \\\n \t\t$(TARGET-stageprofile-cloog)\n \n@@ -14358,7 +14356,7 @@ clean-stageprofile-cloog:\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" clean\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n @endif cloog-bootstrap\n \n \n@@ -14376,7 +14374,7 @@ all-stagefeedback-cloog: configure-stagefeedback-cloog\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \tTFLAGS=\"$(STAGEfeedback_TFLAGS)\"; \\\n \t$(HOST_EXPORTS) \\\n-\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\"; export CPPFLAGS; LDFLAGS=\"$$LDFLAGS ${HOST_PPLLIBS}\"; export LDFLAGS;  \\\n+\t$(POSTSTAGE1_HOST_EXPORTS) CPPFLAGS=\"-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include ${CPPFLAGS}\"; export CPPFLAGS; LDFLAGS=\"-L$$r/$(HOST_SUBDIR)/isl/.libs $$LDFLAGS\"; export LDFLAGS;  \\\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(BASE_FLAGS_TO_PASS) \\\n \t\tCFLAGS=\"$(STAGEfeedback_CFLAGS)\" \\\n@@ -14385,7 +14383,7 @@ all-stagefeedback-cloog: configure-stagefeedback-cloog\n \t\tCFLAGS_FOR_TARGET=\"$(CFLAGS_FOR_TARGET)\" \\\n \t\tCXXFLAGS_FOR_TARGET=\"$(CXXFLAGS_FOR_TARGET)\" \\\n \t\tLIBCFLAGS_FOR_TARGET=\"$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" \\\n+\t\t$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" \\\n \t\tTFLAGS=\"$(STAGEfeedback_TFLAGS)\" \\\n \t\t$(TARGET-stagefeedback-cloog)\n \n@@ -14401,7 +14399,7 @@ clean-stagefeedback-cloog:\n \tcd $(HOST_SUBDIR)/cloog && \\\n \t$(MAKE) $(EXTRA_HOST_FLAGS)  \\\n \t\t$(POSTSTAGE1_FLAGS_TO_PASS)  \\\n-\t\tCPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" clean\n+\t\tCPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" clean\n @endif cloog-bootstrap\n \n \n@@ -14419,7 +14417,7 @@ check-cloog:\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n \t(cd $(HOST_SUBDIR)/cloog && \\\n-\t  $(MAKE) $(FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\" check)\n+\t  $(MAKE) $(FLAGS_TO_PASS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\" check)\n \n @endif cloog\n \n@@ -14454,7 +14452,7 @@ info-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing info in cloog\" ; \\\n@@ -14479,7 +14477,7 @@ dvi-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing dvi in cloog\" ; \\\n@@ -14504,7 +14502,7 @@ pdf-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing pdf in cloog\" ; \\\n@@ -14529,7 +14527,7 @@ html-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing html in cloog\" ; \\\n@@ -14554,7 +14552,7 @@ TAGS-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing TAGS in cloog\" ; \\\n@@ -14580,7 +14578,7 @@ install-info-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing install-info in cloog\" ; \\\n@@ -14606,7 +14604,7 @@ install-pdf-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing install-pdf in cloog\" ; \\\n@@ -14632,7 +14630,7 @@ install-html-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing install-html in cloog\" ; \\\n@@ -14657,7 +14655,7 @@ installcheck-cloog: \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing installcheck in cloog\" ; \\\n@@ -14681,7 +14679,7 @@ mostlyclean-cloog:\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing mostlyclean in cloog\" ; \\\n@@ -14705,7 +14703,7 @@ clean-cloog:\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing clean in cloog\" ; \\\n@@ -14729,7 +14727,7 @@ distclean-cloog:\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing distclean in cloog\" ; \\\n@@ -14753,7 +14751,7 @@ maintainer-clean-cloog:\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n-\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS} ${HOST_PPLINC}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n+\tfor flag in $(EXTRA_HOST_FLAGS) CPPFLAGS=\"${CPPFLAGS}\" LDFLAGS=\"$$LDFLAGS\"; do \\\n \t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n \tdone; \\\n \techo \"Doing maintainer-clean in cloog\" ; \\\n@@ -41326,11 +41324,11 @@ stage1-start::\n \t  mkdir stage1-mpc; \\\n \tmv stage1-mpc mpc \n @endif mpc\n-@if ppl\n-\t@cd $(HOST_SUBDIR); [ -d stage1-ppl ] || \\\n-\t  mkdir stage1-ppl; \\\n-\tmv stage1-ppl ppl \n-@endif ppl\n+@if isl\n+\t@cd $(HOST_SUBDIR); [ -d stage1-isl ] || \\\n+\t  mkdir stage1-isl; \\\n+\tmv stage1-isl isl \n+@endif isl\n @if cloog\n \t@cd $(HOST_SUBDIR); [ -d stage1-cloog ] || \\\n \t  mkdir stage1-cloog; \\\n@@ -41426,11 +41424,11 @@ stage1-end::\n \t  cd $(HOST_SUBDIR); mv mpc stage1-mpc  ; \\\n \tfi\n @endif mpc\n-@if ppl\n-\t@if test -d $(HOST_SUBDIR)/ppl ; then \\\n-\t  cd $(HOST_SUBDIR); mv ppl stage1-ppl  ; \\\n+@if isl\n+\t@if test -d $(HOST_SUBDIR)/isl ; then \\\n+\t  cd $(HOST_SUBDIR); mv isl stage1-isl  ; \\\n \tfi\n-@endif ppl\n+@endif isl\n @if cloog\n \t@if test -d $(HOST_SUBDIR)/cloog ; then \\\n \t  cd $(HOST_SUBDIR); mv cloog stage1-cloog  ; \\\n@@ -41577,12 +41575,12 @@ stage2-start::\n \tmv stage2-mpc mpc  ; \\\n \tmv stage1-mpc prev-mpc || test -f stage1-lean \n @endif mpc\n-@if ppl\n-\t@cd $(HOST_SUBDIR); [ -d stage2-ppl ] || \\\n-\t  mkdir stage2-ppl; \\\n-\tmv stage2-ppl ppl  ; \\\n-\tmv stage1-ppl prev-ppl || test -f stage1-lean \n-@endif ppl\n+@if isl\n+\t@cd $(HOST_SUBDIR); [ -d stage2-isl ] || \\\n+\t  mkdir stage2-isl; \\\n+\tmv stage2-isl isl  ; \\\n+\tmv stage1-isl prev-isl || test -f stage1-lean \n+@endif isl\n @if cloog\n \t@cd $(HOST_SUBDIR); [ -d stage2-cloog ] || \\\n \t  mkdir stage2-cloog; \\\n@@ -41697,12 +41695,12 @@ stage2-end::\n \t  mv prev-mpc stage1-mpc ; :  ; \\\n \tfi\n @endif mpc\n-@if ppl\n-\t@if test -d $(HOST_SUBDIR)/ppl ; then \\\n-\t  cd $(HOST_SUBDIR); mv ppl stage2-ppl ; \\\n-\t  mv prev-ppl stage1-ppl ; :  ; \\\n+@if isl\n+\t@if test -d $(HOST_SUBDIR)/isl ; then \\\n+\t  cd $(HOST_SUBDIR); mv isl stage2-isl ; \\\n+\t  mv prev-isl stage1-isl ; :  ; \\\n \tfi\n-@endif ppl\n+@endif isl\n @if cloog\n \t@if test -d $(HOST_SUBDIR)/cloog ; then \\\n \t  cd $(HOST_SUBDIR); mv cloog stage2-cloog ; \\\n@@ -41883,12 +41881,12 @@ stage3-start::\n \tmv stage3-mpc mpc  ; \\\n \tmv stage2-mpc prev-mpc || test -f stage2-lean \n @endif mpc\n-@if ppl\n-\t@cd $(HOST_SUBDIR); [ -d stage3-ppl ] || \\\n-\t  mkdir stage3-ppl; \\\n-\tmv stage3-ppl ppl  ; \\\n-\tmv stage2-ppl prev-ppl || test -f stage2-lean \n-@endif ppl\n+@if isl\n+\t@cd $(HOST_SUBDIR); [ -d stage3-isl ] || \\\n+\t  mkdir stage3-isl; \\\n+\tmv stage3-isl isl  ; \\\n+\tmv stage2-isl prev-isl || test -f stage2-lean \n+@endif isl\n @if cloog\n \t@cd $(HOST_SUBDIR); [ -d stage3-cloog ] || \\\n \t  mkdir stage3-cloog; \\\n@@ -42003,12 +42001,12 @@ stage3-end::\n \t  mv prev-mpc stage2-mpc ; :  ; \\\n \tfi\n @endif mpc\n-@if ppl\n-\t@if test -d $(HOST_SUBDIR)/ppl ; then \\\n-\t  cd $(HOST_SUBDIR); mv ppl stage3-ppl ; \\\n-\t  mv prev-ppl stage2-ppl ; :  ; \\\n+@if isl\n+\t@if test -d $(HOST_SUBDIR)/isl ; then \\\n+\t  cd $(HOST_SUBDIR); mv isl stage3-isl ; \\\n+\t  mv prev-isl stage2-isl ; :  ; \\\n \tfi\n-@endif ppl\n+@endif isl\n @if cloog\n \t@if test -d $(HOST_SUBDIR)/cloog ; then \\\n \t  cd $(HOST_SUBDIR); mv cloog stage3-cloog ; \\\n@@ -42245,12 +42243,12 @@ stage4-start::\n \tmv stage4-mpc mpc  ; \\\n \tmv stage3-mpc prev-mpc || test -f stage3-lean \n @endif mpc\n-@if ppl\n-\t@cd $(HOST_SUBDIR); [ -d stage4-ppl ] || \\\n-\t  mkdir stage4-ppl; \\\n-\tmv stage4-ppl ppl  ; \\\n-\tmv stage3-ppl prev-ppl || test -f stage3-lean \n-@endif ppl\n+@if isl\n+\t@cd $(HOST_SUBDIR); [ -d stage4-isl ] || \\\n+\t  mkdir stage4-isl; \\\n+\tmv stage4-isl isl  ; \\\n+\tmv stage3-isl prev-isl || test -f stage3-lean \n+@endif isl\n @if cloog\n \t@cd $(HOST_SUBDIR); [ -d stage4-cloog ] || \\\n \t  mkdir stage4-cloog; \\\n@@ -42365,12 +42363,12 @@ stage4-end::\n \t  mv prev-mpc stage3-mpc ; :  ; \\\n \tfi\n @endif mpc\n-@if ppl\n-\t@if test -d $(HOST_SUBDIR)/ppl ; then \\\n-\t  cd $(HOST_SUBDIR); mv ppl stage4-ppl ; \\\n-\t  mv prev-ppl stage3-ppl ; :  ; \\\n+@if isl\n+\t@if test -d $(HOST_SUBDIR)/isl ; then \\\n+\t  cd $(HOST_SUBDIR); mv isl stage4-isl ; \\\n+\t  mv prev-isl stage3-isl ; :  ; \\\n \tfi\n-@endif ppl\n+@endif isl\n @if cloog\n \t@if test -d $(HOST_SUBDIR)/cloog ; then \\\n \t  cd $(HOST_SUBDIR); mv cloog stage4-cloog ; \\\n@@ -42595,12 +42593,12 @@ stageprofile-start::\n \tmv stageprofile-mpc mpc  ; \\\n \tmv stage1-mpc prev-mpc || test -f stage1-lean \n @endif mpc\n-@if ppl\n-\t@cd $(HOST_SUBDIR); [ -d stageprofile-ppl ] || \\\n-\t  mkdir stageprofile-ppl; \\\n-\tmv stageprofile-ppl ppl  ; \\\n-\tmv stage1-ppl prev-ppl || test -f stage1-lean \n-@endif ppl\n+@if isl\n+\t@cd $(HOST_SUBDIR); [ -d stageprofile-isl ] || \\\n+\t  mkdir stageprofile-isl; \\\n+\tmv stageprofile-isl isl  ; \\\n+\tmv stage1-isl prev-isl || test -f stage1-lean \n+@endif isl\n @if cloog\n \t@cd $(HOST_SUBDIR); [ -d stageprofile-cloog ] || \\\n \t  mkdir stageprofile-cloog; \\\n@@ -42715,12 +42713,12 @@ stageprofile-end::\n \t  mv prev-mpc stage1-mpc ; :  ; \\\n \tfi\n @endif mpc\n-@if ppl\n-\t@if test -d $(HOST_SUBDIR)/ppl ; then \\\n-\t  cd $(HOST_SUBDIR); mv ppl stageprofile-ppl ; \\\n-\t  mv prev-ppl stage1-ppl ; :  ; \\\n+@if isl\n+\t@if test -d $(HOST_SUBDIR)/isl ; then \\\n+\t  cd $(HOST_SUBDIR); mv isl stageprofile-isl ; \\\n+\t  mv prev-isl stage1-isl ; :  ; \\\n \tfi\n-@endif ppl\n+@endif isl\n @if cloog\n \t@if test -d $(HOST_SUBDIR)/cloog ; then \\\n \t  cd $(HOST_SUBDIR); mv cloog stageprofile-cloog ; \\\n@@ -42878,12 +42876,12 @@ stagefeedback-start::\n \tmv stagefeedback-mpc mpc  ; \\\n \tmv stageprofile-mpc prev-mpc || test -f stageprofile-lean \n @endif mpc\n-@if ppl\n-\t@cd $(HOST_SUBDIR); [ -d stagefeedback-ppl ] || \\\n-\t  mkdir stagefeedback-ppl; \\\n-\tmv stagefeedback-ppl ppl  ; \\\n-\tmv stageprofile-ppl prev-ppl || test -f stageprofile-lean \n-@endif ppl\n+@if isl\n+\t@cd $(HOST_SUBDIR); [ -d stagefeedback-isl ] || \\\n+\t  mkdir stagefeedback-isl; \\\n+\tmv stagefeedback-isl isl  ; \\\n+\tmv stageprofile-isl prev-isl || test -f stageprofile-lean \n+@endif isl\n @if cloog\n \t@cd $(HOST_SUBDIR); [ -d stagefeedback-cloog ] || \\\n \t  mkdir stagefeedback-cloog; \\\n@@ -42998,12 +42996,12 @@ stagefeedback-end::\n \t  mv prev-mpc stageprofile-mpc ; :  ; \\\n \tfi\n @endif mpc\n-@if ppl\n-\t@if test -d $(HOST_SUBDIR)/ppl ; then \\\n-\t  cd $(HOST_SUBDIR); mv ppl stagefeedback-ppl ; \\\n-\t  mv prev-ppl stageprofile-ppl ; :  ; \\\n+@if isl\n+\t@if test -d $(HOST_SUBDIR)/isl ; then \\\n+\t  cd $(HOST_SUBDIR); mv isl stagefeedback-isl ; \\\n+\t  mv prev-isl stageprofile-isl ; :  ; \\\n \tfi\n-@endif ppl\n+@endif isl\n @if cloog\n \t@if test -d $(HOST_SUBDIR)/cloog ; then \\\n \t  cd $(HOST_SUBDIR); mv cloog stagefeedback-cloog ; \\\n@@ -43354,14 +43352,6 @@ all-stage3-gcc: maybe-all-stage3-mpc\n all-stage4-gcc: maybe-all-stage4-mpc\n all-stageprofile-gcc: maybe-all-stageprofile-mpc\n all-stagefeedback-gcc: maybe-all-stagefeedback-mpc\n-all-gcc: maybe-all-ppl\n-\n-all-stage1-gcc: maybe-all-stage1-ppl\n-all-stage2-gcc: maybe-all-stage2-ppl\n-all-stage3-gcc: maybe-all-stage3-ppl\n-all-stage4-gcc: maybe-all-stage4-ppl\n-all-stageprofile-gcc: maybe-all-stageprofile-ppl\n-all-stagefeedback-gcc: maybe-all-stagefeedback-ppl\n all-gcc: maybe-all-cloog\n \n all-stage1-gcc: maybe-all-stage1-cloog\n@@ -43546,30 +43536,30 @@ configure-stage3-mpc: maybe-all-stage3-mpfr\n configure-stage4-mpc: maybe-all-stage4-mpfr\n configure-stageprofile-mpc: maybe-all-stageprofile-mpfr\n configure-stagefeedback-mpc: maybe-all-stagefeedback-mpfr\n-configure-ppl: maybe-all-gmp\n-\n-configure-stage1-ppl: maybe-all-stage1-gmp\n-configure-stage2-ppl: maybe-all-stage2-gmp\n-configure-stage3-ppl: maybe-all-stage3-gmp\n-configure-stage4-ppl: maybe-all-stage4-gmp\n-configure-stageprofile-ppl: maybe-all-stageprofile-gmp\n-configure-stagefeedback-ppl: maybe-all-stagefeedback-gmp\n-configure-ppl: maybe-all-mpfr\n-\n-configure-stage1-ppl: maybe-all-stage1-mpfr\n-configure-stage2-ppl: maybe-all-stage2-mpfr\n-configure-stage3-ppl: maybe-all-stage3-mpfr\n-configure-stage4-ppl: maybe-all-stage4-mpfr\n-configure-stageprofile-ppl: maybe-all-stageprofile-mpfr\n-configure-stagefeedback-ppl: maybe-all-stagefeedback-mpfr\n-configure-cloog: maybe-all-ppl\n-\n-configure-stage1-cloog: maybe-all-stage1-ppl\n-configure-stage2-cloog: maybe-all-stage2-ppl\n-configure-stage3-cloog: maybe-all-stage3-ppl\n-configure-stage4-cloog: maybe-all-stage4-ppl\n-configure-stageprofile-cloog: maybe-all-stageprofile-ppl\n-configure-stagefeedback-cloog: maybe-all-stagefeedback-ppl\n+configure-isl: maybe-all-gmp\n+\n+configure-stage1-isl: maybe-all-stage1-gmp\n+configure-stage2-isl: maybe-all-stage2-gmp\n+configure-stage3-isl: maybe-all-stage3-gmp\n+configure-stage4-isl: maybe-all-stage4-gmp\n+configure-stageprofile-isl: maybe-all-stageprofile-gmp\n+configure-stagefeedback-isl: maybe-all-stagefeedback-gmp\n+configure-cloog: maybe-all-isl\n+\n+configure-stage1-cloog: maybe-all-stage1-isl\n+configure-stage2-cloog: maybe-all-stage2-isl\n+configure-stage3-cloog: maybe-all-stage3-isl\n+configure-stage4-cloog: maybe-all-stage4-isl\n+configure-stageprofile-cloog: maybe-all-stageprofile-isl\n+configure-stagefeedback-cloog: maybe-all-stagefeedback-isl\n+configure-cloog: maybe-all-gmp\n+\n+configure-stage1-cloog: maybe-all-stage1-gmp\n+configure-stage2-cloog: maybe-all-stage2-gmp\n+configure-stage3-cloog: maybe-all-stage3-gmp\n+configure-stage4-cloog: maybe-all-stage4-gmp\n+configure-stageprofile-cloog: maybe-all-stageprofile-gmp\n+configure-stagefeedback-cloog: maybe-all-stagefeedback-gmp\n configure-gdb: maybe-all-intl\n configure-gdb: maybe-configure-sim\n configure-gdb: maybe-all-bfd"}, {"sha": "2573eee8f6a1639216632db4c99bbf1b0ba224f9", "filename": "Makefile.tpl", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -222,8 +222,7 @@ HOST_EXPORTS = \\\n \tHOST_LIBS=\"$(STAGE1_LIBS)\"; export HOST_LIBS; \\\n \tGMPLIBS=\"$(HOST_GMPLIBS)\"; export GMPLIBS; \\\n \tGMPINC=\"$(HOST_GMPINC)\"; export GMPINC; \\\n-\tPPLLIBS=\"$(HOST_PPLLIBS)\"; export PPLLIBS; \\\n-\tPPLINC=\"$(HOST_PPLINC)\"; export PPLINC; \\\n+\tISLINC=\"$(HOST_ISLINC)\"; export ISLINC; \\\n \tCLOOGLIBS=\"$(HOST_CLOOGLIBS)\"; export CLOOGLIBS; \\\n \tCLOOGINC=\"$(HOST_CLOOGINC)\"; export CLOOGINC; \\\n \tLIBELFLIBS=\"$(HOST_LIBELFLIBS)\" ; export LIBELFLIBS; \\\n@@ -313,9 +312,8 @@ NORMAL_TARGET_EXPORTS = \\\n HOST_GMPLIBS = @gmplibs@\n HOST_GMPINC = @gmpinc@\n \n-# Where to find PPL\n-HOST_PPLLIBS = @ppllibs@\n-HOST_PPLINC = @pplinc@\n+# Where to find ISL\n+HOST_ISLINC = @islinc@\n \n # Where to find CLOOG\n HOST_CLOOGLIBS = @clooglibs@"}, {"sha": "b0b6690cf9d7c93ede25ae41a9086f98883a8516", "filename": "config/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,3 +1,11 @@\n+2012-07-02  Richard Guenther  <rguenther@suse.de>\n+\tMichael Matz  <matz@suse.de>\n+\tTobias Grosser <tobias@grosser.es>\n+\tSebastian Pop <sebpop@gmail.com>\n+\n+\t* cloog.m4: Set up to work against ISL only.\n+\t* isl.m4: New file.\n+\n 2012-05-29  Joseph Myers  <joseph@codesourcery.com>\n \n \t* mt-sde: Fix typos."}, {"sha": "603df6bcfaf7c0a46a5ca68ff8075e150184c408", "filename": "config/cloog.m4", "status": "modified", "additions": 15, "deletions": 56, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/config%2Fcloog.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/config%2Fcloog.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fcloog.m4?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -63,6 +63,17 @@ AC_DEFUN([CLOOG_INIT_FLAGS],\n   if test \"x${with_cloog_lib}\" != x; then\n     clooglibs=\"-L$with_cloog_lib\"\n   fi\n+  dnl If no --with-cloog flag was specified and there is in-tree ClooG\n+  dnl source, set up flags to use that.\n+  if test \"x${clooginc}\" == x && test \"x${clooglibs}\" == x \\\n+     && test -d ${srcdir}/cloog; then\n+     echo FooBar\n+     clooglibs='-L$$r/$(HOST_SUBDIR)/cloog/'\"$lt_cv_objdir\"' '\n+     clooginc='-I$$r/$(HOST_SUBDIR)/cloog/include -I$$s/cloog/include -I'${srcdir}'/cloog/include '\n+  fi\n+\n+  clooginc=\"-DCLOOG_INT_GMP ${clooginc}\"\n+  clooglibs=\"${clooglibs} -lcloog-isl ${isllibs}\"\n \n   dnl Flags needed for CLOOG\n   AC_SUBST(clooglibs)\n@@ -89,63 +100,11 @@ AC_DEFUN([CLOOG_REQUESTED],\n ]\n )\n \n-# _CLOOG_ORG_PROG_ISL ()\n-# ------------------\n-# Helper for detecting CLooG.org's ISL backend.\n-m4_define([_CLOOG_ORG_PROG_ISL],[AC_LANG_PROGRAM(\n-  [#include \"cloog/cloog.h\" ],\n-  [cloog_version ()])])\n-\n-# CLOOG_FIND_FLAGS ()\n-# ------------------\n-# Detect the used CLooG-backend and set clooginc/clooglibs/cloog_org.\n-# Only look for the CLooG backend type specified in --enable-cloog-backend\n-AC_DEFUN([CLOOG_FIND_FLAGS],\n-[\n-  AC_REQUIRE([CLOOG_INIT_FLAGS])\n-\n-  _cloog_saved_CFLAGS=$CFLAGS\n-  _cloog_saved_CPPFLAGS=$CPPFLAGS\n-  _cloog_saved_LDFLAGS=$LDFLAGS\n-  _cloog_saved_LIBS=$LIBS\n-\n-  _cloogorginc=\"-DCLOOG_INT_GMP\"\n- \n-  dnl clooglibs & clooginc may have been initialized by CLOOG_INIT_FLAGS.\n-  CFLAGS=\"${CFLAGS} ${clooginc} ${gmpinc}\"\n-  CPPFLAGS=\"${CPPFLAGS} ${_cloogorginc}\"\n-  LDFLAGS=\"${LDFLAGS} ${clooglibs}\"\n-\n-  AC_CACHE_CHECK([for installed CLooG ISL], [gcc_cv_cloog_type],\n-    [LIBS=\"-lcloog-isl ${_cloog_saved_LIBS}\"\n-    AC_LINK_IFELSE([_CLOOG_ORG_PROG_ISL], [gcc_cv_cloog_type=\"ISL\"],\n-\t\t   [gcc_cv_cloog_type=no])])\n-\n-  case $gcc_cv_cloog_type in\n-    \"ISL\")\n-      clooginc=\"${clooginc} ${_cloogorginc}\"\n-      clooglibs=\"${clooglibs} -lcloog-isl -lisl\"\n-      cloog_org=yes\n-      ;;\n-    *)\n-      clooglibs=\n-      clooginc=\n-      cloog_org=\n-      ;;\n-  esac\n-\n-  LIBS=$_cloog_saved_LIBS\n-  CFLAGS=$_cloog_saved_CFLAGS\n-  CPPFLAGS=$_cloog_saved_CPPFLAGS\n-  LDFLAGS=$_cloog_saved_LDFLAGS\n-]\n-)\n-\n # _CLOOG_CHECK_CT_PROG(MAJOR, MINOR, REVISION)\n # --------------------------------------------\n # Helper for verifying CLooG's compile time version.\n m4_define([_CLOOG_CHECK_CT_PROG],[AC_LANG_PROGRAM(\n-  [#include \"cloog/cloog.h\"],\n+  [#include \"cloog/version.h\"],\n   [#if CLOOG_VERSION_MAJOR != $1 \\\n     || CLOOG_VERSION_MINOR != $2 \\\n     || CLOOG_VERSION_REVISION < $3\n@@ -158,14 +117,14 @@ m4_define([_CLOOG_CHECK_CT_PROG],[AC_LANG_PROGRAM(\n # REVISION.\n AC_DEFUN([CLOOG_CHECK_VERSION],\n [\n-  AC_REQUIRE([CLOOG_FIND_FLAGS])\n+  AC_REQUIRE([CLOOG_INIT_FLAGS])\n \n   if test \"${ENABLE_CLOOG_CHECK}\" = yes ; then\n     _cloog_saved_CFLAGS=$CFLAGS\n     _cloog_saved_LDFLAGS=$LDFLAGS\n \n-    CFLAGS=\"${_cloog_saved_CFLAGS} ${clooginc} ${pplinc} ${gmpinc}\"\n-    LDFLAGS=\"${_cloog_saved_LDFLAGS} ${clooglibs} ${ppllibs}\"\n+    CFLAGS=\"${_cloog_saved_CFLAGS} ${clooginc} ${islinc} ${gmpinc}\"\n+    LDFLAGS=\"${_cloog_saved_LDFLAGS} ${clooglibs} ${isllibs} ${gmplib}\"\n \n     AC_CACHE_CHECK([for version $1.$2.$3 of CLooG],\n       [gcc_cv_cloog],"}, {"sha": "b157a7219896661c9df1b302c9b480de418d6901", "filename": "configure", "status": "modified", "additions": 173, "deletions": 213, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -646,8 +646,8 @@ stage1_languages\n extra_host_libiberty_configure_flags\n clooginc\n clooglibs\n-pplinc\n-ppllibs\n+islinc\n+isllibs\n poststage1_ldflags\n poststage1_libs\n stage1_libs\n@@ -770,10 +770,10 @@ with_stage1_ldflags\n with_stage1_libs\n with_boot_libs\n with_boot_ldflags\n-with_ppl\n-with_ppl_include\n-with_ppl_lib\n-enable_ppl_version_check\n+with_isl\n+with_isl_include\n+with_isl_lib\n+enable_isl_version_check\n with_cloog\n with_cloog_include\n with_cloog_lib\n@@ -1473,8 +1473,8 @@ Optional Features:\n   --enable-build-with-cxx build with C++ compiler instead of C compiler\n   --enable-build-poststage1-with-cxx\n                           build stages 2 and 3 with C++, not C\n-  --disable-ppl-version-check\n-                          disable check for PPL version\n+  --disable-isl-version-check\n+                          disable check for ISL version\n   --disable-cloog-version-check\n                           disable check for CLooG version\n   --enable-lto            enable link time optimization support\n@@ -1526,12 +1526,12 @@ Optional Packages:\n   --with-boot-libs=LIBS   libraries for stage2 and later\n   --with-boot-ldflags=FLAGS\n                           linker flags for stage2 and later\n-  --with-ppl=PATH         specify prefix directory for the installed PPL\n+  --with-isl=PATH         Specify prefix directory for the installed ISL\n                           package. Equivalent to\n-                          --with-ppl-include=PATH/include plus\n-                          --with-ppl-lib=PATH/lib\n-  --with-ppl-include=PATH specify directory for installed PPL include files\n-  --with-ppl-lib=PATH     specify directory for the installed PPL library\n+                          --with-isl-include=PATH/include plus\n+                          --with-isl-lib=PATH/lib\n+  --with-isl-include=PATH Specify directory for installed ISL include files\n+  --with-isl-lib=PATH     Specify the directory for the installed ISL library\n   --with-cloog=PATH       Specify prefix directory for the installed CLooG-PPL\n                           package. Equivalent to\n                           --with-cloog-include=PATH/include plus\n@@ -1816,6 +1816,48 @@ fi\n   return $ac_retval\n \n } # ac_fn_c_try_link\n+\n+# ac_fn_c_try_run LINENO\n+# ----------------------\n+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes\n+# that executables *can* be run.\n+ac_fn_c_try_run ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  if { { ac_try=\"$ac_link\"\n+case \"(($ac_try\" in\n+  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n+  *) ac_try_echo=$ac_try;;\n+esac\n+eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n+$as_echo \"$ac_try_echo\"; } >&5\n+  (eval \"$ac_link\") 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'\n+  { { case \"(($ac_try\" in\n+  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n+  *) ac_try_echo=$ac_try;;\n+esac\n+eval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n+$as_echo \"$ac_try_echo\"; } >&5\n+  (eval \"$ac_try\") 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }; then :\n+  ac_retval=0\n+else\n+  $as_echo \"$as_me: program exited with status $ac_status\" >&5\n+       $as_echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+       ac_retval=$ac_status\n+fi\n+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n+  eval $as_lineno_stack; test \"x$as_lineno_stack\" = x && { as_lineno=; unset as_lineno;}\n+  return $ac_retval\n+\n+} # ac_fn_c_try_run\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n@@ -2662,7 +2704,7 @@ build_tools=\"build-texinfo build-flex build-bison build-m4 build-fixincludes\"\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr mpc ppl cloog libelf libiconv\"\n+host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr mpc isl cloog libelf libiconv\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -5581,158 +5623,156 @@ fi\n \n \n \n-# Check for PPL\n-ppllibs=\n-pplinc=\n-pwllib=\n+# Check for ISL\n \n \n-# Check whether --with-ppl was given.\n-if test \"${with_ppl+set}\" = set; then :\n-  withval=$with_ppl;\n+# Check whether --with-isl was given.\n+if test \"${with_isl+set}\" = set; then :\n+  withval=$with_isl;\n fi\n \n \n-# Check whether --with-ppl-include was given.\n-if test \"${with_ppl_include+set}\" = set; then :\n-  withval=$with_ppl_include;\n+# Check whether --with-isl-include was given.\n+if test \"${with_isl_include+set}\" = set; then :\n+  withval=$with_isl_include;\n fi\n \n \n-# Check whether --with-ppl-lib was given.\n-if test \"${with_ppl_lib+set}\" = set; then :\n-  withval=$with_ppl_lib;\n+# Check whether --with-isl-lib was given.\n+if test \"${with_isl_lib+set}\" = set; then :\n+  withval=$with_isl_lib;\n fi\n \n \n-# Check whether --enable-ppl-version-check was given.\n-if test \"${enable_ppl_version_check+set}\" = set; then :\n-  enableval=$enable_ppl_version_check;\n+  # Check whether --enable-isl-version-check was given.\n+if test \"${enable_isl_version_check+set}\" = set; then :\n+  enableval=$enable_isl_version_check; ENABLE_ISL_CHECK=$enableval\n+else\n+  ENABLE_ISL_CHECK=yes\n fi\n \n \n-case $with_ppl in\n-  yes | no | \"\")\n-    ;;\n-  *)\n-    ppllibs=\"-L$with_ppl/lib\"\n-    pplinc=\"-I$with_ppl/include $pplinc\"\n-    if test -d \"$with_ppl/lib\" && test -d \"$with_ppl/include\"; then\n-      with_ppl=yes\n-    else\n-      as_fn_error \"cannot find directories \\\"$with_ppl/lib\\\" or \\\"$with_ppl/include\\\"\" \"$LINENO\" 5\n-    fi\n-    ;;\n-esac\n+  # Initialize isllibs and islinc.\n+  case $with_isl in\n+    no)\n+      isllibs=\n+      islinc=\n+      ;;\n+    \"\" | yes)\n+      ;;\n+    *)\n+      isllibs=\"-L$with_isl/lib\"\n+      islinc=\"-I$with_isl/include\"\n+      ;;\n+  esac\n+  if test \"x${with_isl_include}\" != x ; then\n+    islinc=\"-I$with_isl_include\"\n+  fi\n+  if test \"x${with_isl_lib}\" != x; then\n+    isllibs=\"-L$with_isl_lib\"\n+  fi\n+        if test \"x${islinc}\" = x && test \"x${isllibs}\" = x \\\n+     && test -d ${srcdir}/isl; then\n+    isllibs='-L$$r/$(HOST_SUBDIR)/isl/'\"$lt_cv_objdir\"' '\n+    islinc='-I$$r/$(HOST_SUBDIR)/isl/include -I$$s/isl/include'\n+    ENABLE_ISL_CHECK=no\n+  fi\n \n-if test x\"$with_ppl_include\" != x; then\n-  pplinc=\"-I$with_ppl_include $pplinc\"\n-  with_ppl=yes\n-fi\n+  isllibs=\"${isllibs} -lisl\"\n \n-if test \"x$with_ppl_lib\" != x; then\n-  ppllibs=\"-L$with_ppl_lib\"\n-  with_ppl=yes\n-fi\n \n-if test x\"$with_ppl$with_ppl_include$with_ppl_lib\" = x && test -d ${srcdir}/ppl; then\n-  if test x\"$enable_watchdog\" = xyes; then\n-    pwllib=\"-lpwl\"\n-  fi\n-  ppllibs='-L$$r/$(HOST_SUBDIR)/ppl/interfaces/C/'\"$lt_cv_objdir\"' -L$$r/$(HOST_SUBDIR)/ppl/src/'\"$lt_cv_objdir\"\n-  pplinc='-I$$r/$(HOST_SUBDIR)/ppl/src -I$$r/$(HOST_SUBDIR)/ppl/interfaces/C '\n-  enable_ppl_version_check=no\n-  with_ppl=yes\n-fi\n \n-if test \"x$with_ppl\" != xno; then\n-  if test \"x$pwllib\" = x; then\n-    saved_LIBS=\"$LIBS\"\n-    LIBS=\"$LIBS $ppllibs -lstdc++ -lm\"\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for PWL_handle_timeout in -lpwl\" >&5\n-$as_echo_n \"checking for PWL_handle_timeout in -lpwl... \" >&6; }\n-if test \"${ac_cv_lib_pwl_PWL_handle_timeout+set}\" = set; then :\n+\n+\n+if test \"x$with_isl\" != \"xno\"; then\n+\n+  if test \"${ENABLE_ISL_CHECK}\" = yes ; then\n+    _isl_saved_CFLAGS=$CFLAGS\n+    _isl_saved_LDFLAGS=$LDFLAGS\n+\n+    CFLAGS=\"${_isl_saved_CFLAGS} ${islinc} ${gmpinc}\"\n+    LDFLAGS=\"${_isl_saved_LDFLAGS} ${isllibs} -lisl\"\n+    echo $CFLAGS\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for version 0.10 of ISL\" >&5\n+$as_echo_n \"checking for version 0.10 of ISL... \" >&6; }\n+if test \"${gcc_cv_isl+set}\" = set; then :\n   $as_echo_n \"(cached) \" >&6\n else\n-  ac_check_lib_save_LIBS=$LIBS\n-LIBS=\"-lpwl  $LIBS\"\n-cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+  if test \"$cross_compiling\" = yes; then :\n+  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error \"cannot run test program while cross compiling\n+See \\`config.log' for more details.\" \"$LINENO\" 5; }\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n-\n-/* Override any GCC internal prototype to avoid an error.\n-   Use char because int might match the return type of a GCC\n-   builtin and then its argument prototype would still apply.  */\n-#ifdef __cplusplus\n-extern \"C\"\n-#endif\n-char PWL_handle_timeout ();\n+#include <isl/version.h>\n+   #include <string.h>\n int\n main ()\n {\n-return PWL_handle_timeout ();\n+int main()\n+   {\n+     if (strncmp (isl_version (), \"isl-0.10\", strlen (\"isl-0.10\")) != 0)\n+       return 1;\n+     return 0;\n+   }\n   ;\n   return 0;\n }\n _ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  ac_cv_lib_pwl_PWL_handle_timeout=yes\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  gcc_cv_isl=yes\n else\n-  ac_cv_lib_pwl_PWL_handle_timeout=no\n+  gcc_cv_isl=no\n fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-LIBS=$ac_check_lib_save_LIBS\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pwl_PWL_handle_timeout\" >&5\n-$as_echo \"$ac_cv_lib_pwl_PWL_handle_timeout\" >&6; }\n-if test \"x$ac_cv_lib_pwl_PWL_handle_timeout\" = x\"\"yes; then :\n-  pwllib=\"-lpwl\"\n+\n fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_isl\" >&5\n+$as_echo \"$gcc_cv_isl\" >&6; }\n \n-    LIBS=\"$saved_LIBS\"\n+    CFLAGS=$_isl_saved_CFLAGS\n+    LDFLAGS=$_isl_saved_LDFLAGS\n   fi\n \n-  ppllibs=\"$ppllibs -lppl_c -lppl $pwllib -lgmpxx\"\n \n-  if test \"$enable_ppl_version_check\" != no; then\n-    saved_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$CFLAGS $pplinc $gmpinc\"\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for version 0.11 (revision 0 or later) of PPL\" >&5\n-$as_echo_n \"checking for version 0.11 (revision 0 or later) of PPL... \" >&6; }\n-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include \"ppl_c.h\"\n-int\n-main ()\n-{\n \n-    #if PPL_VERSION_MAJOR != 0 || PPL_VERSION_MINOR < 11\n-    choke me\n-    #endif\n \n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_compile \"$LINENO\"; then :\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n-$as_echo \"yes\" >&6; }\n-else\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n-$as_echo \"no\" >&6; }; ppllibs= ; pplinc= ; with_ppl=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-    CFLAGS=\"$saved_CFLAGS\"\n+\n+\n+\n+  if test \"x${with_isl}\" = xno; then\n+    graphite_requested=no\n+  elif test \"x${with_isl}\" != x \\\n+    || test \"x${with_isl_include}\" != x \\\n+    || test \"x${with_isl_lib}\" != x ; then\n+    graphite_requested=yes\n+  else\n+    graphite_requested=no\n   fi\n-fi\n \n-# Flags needed for PPL\n \n \n+  if test \"${gcc_cv_isl}\" = no ; then\n+    isllibs=\n+    islinc=\n+  fi\n+\n+  if test \"${graphite_requested}\" = yes \\\n+    && test \"x${isllibs}\" = x \\\n+    && test \"x${islinc}\" = x ; then\n \n+    as_fn_error \"Unable to find a usable ISL.  See config.log for details.\" \"$LINENO\" 5\n+  fi\n \n-# Check for CLOOG\n \n+fi\n+\n+# Check for CLOOG\n \n \n # Check whether --with-cloog was given.\n@@ -5780,107 +5820,30 @@ fi\n   if test \"x${with_cloog_lib}\" != x; then\n     clooglibs=\"-L$with_cloog_lib\"\n   fi\n-\n-\n-\n-\n-\n-if test \"x$with_ppl\" = \"xno\"; then\n-\n-\n-\n-  if test \"x${with_cloog}\" = xno; then\n-    graphite_requested=no\n-  elif test \"x${with_cloog}\" != x \\\n-    || test \"x${with_cloog_include}\" != x \\\n-    || test \"x${with_cloog_lib}\" != x ; then\n-    graphite_requested=yes\n-  else\n-    graphite_requested=no\n-  fi\n-\n-\n-  if test \"${graphite_requested}\" = yes; then\n-    as_fn_error \"Unable to find a usable PPL.  See config.log for details.\" \"$LINENO\" 5\n+      if test \"x${clooginc}\" == x && test \"x${clooglibs}\" == x \\\n+     && test -d ${srcdir}/cloog; then\n+     echo FooBar\n+     clooglibs='-L$$r/$(HOST_SUBDIR)/cloog/'\"$lt_cv_objdir\"' '\n+     clooginc='-I$$r/$(HOST_SUBDIR)/cloog/include -I$$s/cloog/include -I'${srcdir}'/cloog/include '\n   fi\n-  with_cloog=no\n-fi\n-if test \"x${with_cloog}\" = x && test \"x${with_cloog_include}\" = x \\\n-  && test \"x${with_cloog_lib}\" = x && test -d ${srcdir}/cloog; then\n-  clooglibs='-L$$r/$(HOST_SUBDIR)/cloog/'\"$lt_cv_objdir\"' '\n-  clooginc='-I$$r/$(HOST_SUBDIR)/cloog/include -I$$s/cloog/include '\n-fi\n-if test \"x$with_cloog\" != \"xno\"; then\n \n+  clooginc=\"-DCLOOG_INT_GMP ${clooginc}\"\n+  clooglibs=\"${clooglibs} -lcloog-isl ${isllibs}\"\n \n \n-  _cloog_saved_CFLAGS=$CFLAGS\n-  _cloog_saved_CPPFLAGS=$CPPFLAGS\n-  _cloog_saved_LDFLAGS=$LDFLAGS\n-  _cloog_saved_LIBS=$LIBS\n \n-  _cloogorginc=\"-DCLOOG_INT_GMP\"\n-\n-    CFLAGS=\"${CFLAGS} ${clooginc} ${gmpinc}\"\n-  CPPFLAGS=\"${CPPFLAGS} ${_cloogorginc}\"\n-  LDFLAGS=\"${LDFLAGS} ${clooglibs}\"\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for installed CLooG ISL\" >&5\n-$as_echo_n \"checking for installed CLooG ISL... \" >&6; }\n-if test \"${gcc_cv_cloog_type+set}\" = set; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  LIBS=\"-lcloog-isl ${_cloog_saved_LIBS}\"\n-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include \"cloog/cloog.h\"\n-int\n-main ()\n-{\n-cloog_version ()\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  gcc_cv_cloog_type=\"ISL\"\n-else\n-  gcc_cv_cloog_type=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_cloog_type\" >&5\n-$as_echo \"$gcc_cv_cloog_type\" >&6; }\n-\n-  case $gcc_cv_cloog_type in\n-    \"ISL\")\n-      clooginc=\"${clooginc} ${_cloogorginc}\"\n-      clooglibs=\"${clooglibs} -lcloog-isl -lisl\"\n-      cloog_org=yes\n-      ;;\n-    *)\n-      clooglibs=\n-      clooginc=\n-      cloog_org=\n-      ;;\n-  esac\n-\n-  LIBS=$_cloog_saved_LIBS\n-  CFLAGS=$_cloog_saved_CFLAGS\n-  CPPFLAGS=$_cloog_saved_CPPFLAGS\n-  LDFLAGS=$_cloog_saved_LDFLAGS\n \n \n+if test \"x$with_cloog\" != \"xno\"; then\n \n \n \n   if test \"${ENABLE_CLOOG_CHECK}\" = yes ; then\n     _cloog_saved_CFLAGS=$CFLAGS\n     _cloog_saved_LDFLAGS=$LDFLAGS\n \n-    CFLAGS=\"${_cloog_saved_CFLAGS} ${clooginc} ${pplinc} ${gmpinc}\"\n-    LDFLAGS=\"${_cloog_saved_LDFLAGS} ${clooglibs} ${ppllibs}\"\n+    CFLAGS=\"${_cloog_saved_CFLAGS} ${clooginc} ${islinc} ${gmpinc}\"\n+    LDFLAGS=\"${_cloog_saved_LDFLAGS} ${clooglibs} ${isllibs} ${gmplib}\"\n \n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for version 0.17.0 of CLooG\" >&5\n $as_echo_n \"checking for version 0.17.0 of CLooG... \" >&6; }\n@@ -5889,7 +5852,7 @@ if test \"${gcc_cv_cloog+set}\" = set; then :\n else\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n-#include \"cloog/cloog.h\"\n+#include \"cloog/version.h\"\n int\n main ()\n {\n@@ -7081,7 +7044,7 @@ do\n \n \n     case $lib in\n-    mpc | mpfr | gmp | ppl | cloog)\n+    mpc | mpfr | gmp | cloog)\n       # If we're processing --with-$lib, --with-$lib-include or\n       # --with-$lib-lib, for one of the libs above, and target is\n       # different from host, don't pass the current argument to any\n@@ -14331,9 +14294,6 @@ case \"$target\" in\n   hppa*64*-*-hpux*) ;;\n   hppa*-*-hpux*) compare_exclusions=\"gcc/cc*-checksum\\$(objext) | */libgcc/lib2funcs* | gcc/ada/*tools/*\" ;;\n esac\n-case \" $configdirs \" in\n-*\" ppl \"*) compare_exclusions=\"$compare_exclusions | ppl/src/ppl-config.o\" ;;\n-esac\n \n \n ac_config_files=\"$ac_config_files Makefile\""}, {"sha": "12b9c550726a35c96c5d2c7f0d288d29ff78403e", "filename": "configure.ac", "status": "modified", "additions": 13, "deletions": 99, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -28,6 +28,7 @@ m4_include([ltoptions.m4])\n m4_include([ltsugar.m4])\n m4_include([ltversion.m4])\n m4_include([lt~obsolete.m4])\n+m4_include([config/isl.m4])\n m4_include([config/cloog.m4])\n \n AC_INIT(move-if-change)\n@@ -132,7 +133,7 @@ build_tools=\"build-texinfo build-flex build-bison build-m4 build-fixincludes\"\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr mpc ppl cloog libelf libiconv\"\n+host_libs=\"intl libiberty opcodes bfd readline tcl tk itcl libgui zlib libcpp libdecnumber gmp mpfr mpc isl cloog libelf libiconv\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -1517,107 +1518,23 @@ AC_ARG_WITH(boot-ldflags,\n  fi])\n AC_SUBST(poststage1_ldflags)\n \n-# Check for PPL\n-ppllibs=\n-pplinc=\n-pwllib=\n-\n-AC_ARG_WITH(ppl,\n-[AS_HELP_STRING([--with-ppl=PATH],\n-\t\t[specify prefix directory for the installed PPL package.\n-\t\t Equivalent to --with-ppl-include=PATH/include\n-\t\t plus --with-ppl-lib=PATH/lib])])\n-AC_ARG_WITH(ppl-include,\n-[AS_HELP_STRING([--with-ppl-include=PATH],\n-\t\t[specify directory for installed PPL include files])])\n-AC_ARG_WITH(ppl-lib,\n-[AS_HELP_STRING([--with-ppl-lib=PATH],\n-\t\t[specify directory for the installed PPL library])])\n-\n-AC_ARG_ENABLE(ppl-version-check,\n-[AS_HELP_STRING([--disable-ppl-version-check],\n-\t\t[disable check for PPL version])])\n-\n-case $with_ppl in\n-  yes | no | \"\")\n-    ;;\n-  *)\n-    ppllibs=\"-L$with_ppl/lib\"\n-    pplinc=\"-I$with_ppl/include $pplinc\"\n-    if test -d \"$with_ppl/lib\" && test -d \"$with_ppl/include\"; then\n-      with_ppl=yes\n-    else\n-      AC_MSG_ERROR([cannot find directories \"$with_ppl/lib\" or \"$with_ppl/include\"])\n-    fi\n-    ;;\n-esac\n-\n-if test x\"$with_ppl_include\" != x; then\n-  pplinc=\"-I$with_ppl_include $pplinc\"\n-  with_ppl=yes\n-fi\n-\n-if test \"x$with_ppl_lib\" != x; then\n-  ppllibs=\"-L$with_ppl_lib\"\n-  with_ppl=yes\n-fi\n-\n-if test x\"$with_ppl$with_ppl_include$with_ppl_lib\" = x && test -d ${srcdir}/ppl; then\n-  if test x\"$enable_watchdog\" = xyes; then\n-    pwllib=\"-lpwl\"\n-  fi\n-  ppllibs='-L$$r/$(HOST_SUBDIR)/ppl/interfaces/C/'\"$lt_cv_objdir\"' -L$$r/$(HOST_SUBDIR)/ppl/src/'\"$lt_cv_objdir\"\n-  pplinc='-I$$r/$(HOST_SUBDIR)/ppl/src -I$$r/$(HOST_SUBDIR)/ppl/interfaces/C '\n-  enable_ppl_version_check=no\n-  with_ppl=yes\n-fi\n-\n-if test \"x$with_ppl\" != xno; then\n-  if test \"x$pwllib\" = x; then\n-    saved_LIBS=\"$LIBS\"\n-    LIBS=\"$LIBS $ppllibs -lstdc++ -lm\"\n-    AC_CHECK_LIB(pwl, PWL_handle_timeout, [pwllib=\"-lpwl\"])\n-    LIBS=\"$saved_LIBS\"\n-  fi\n-\n-  ppllibs=\"$ppllibs -lppl_c -lppl $pwllib -lgmpxx\"\n+# Check for ISL\n+dnl Provide configure switches and initialize islinc & isllibs\n+dnl with user input.\n+ISL_INIT_FLAGS\n+if test \"x$with_isl\" != \"xno\"; then\n+  dnl The minimal version of ISL required for Graphite.\n+  ISL_CHECK_VERSION(0,10)\n \n-  if test \"$enable_ppl_version_check\" != no; then\n-    saved_CFLAGS=\"$CFLAGS\"\n-    CFLAGS=\"$CFLAGS $pplinc $gmpinc\"\n-    AC_MSG_CHECKING([for version 0.11 (revision 0 or later) of PPL])\n-    AC_TRY_COMPILE([#include \"ppl_c.h\"],[\n-    #if PPL_VERSION_MAJOR != 0 || PPL_VERSION_MINOR < 11\n-    choke me\n-    #endif\n-    ], [AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no]); ppllibs= ; pplinc= ; with_ppl=no ])\n-    CFLAGS=\"$saved_CFLAGS\"\n-  fi\n+  dnl Only execute fail-action, if ISL has been requested.\n+  ISL_IF_FAILED([\n+    AC_MSG_ERROR([Unable to find a usable ISL.  See config.log for details.])])\n fi\n \n-# Flags needed for PPL\n-AC_SUBST(ppllibs)\n-AC_SUBST(pplinc)\n-\n-\n # Check for CLOOG\n-\n dnl Provide configure switches and initialize clooginc & clooglibs\n dnl with user input.\n CLOOG_INIT_FLAGS\n-if test \"x$with_ppl\" = \"xno\"; then\n-  dnl Only execute fail-action, if CLooG has been requested.\n-  CLOOG_REQUESTED([graphite_requested=yes], [graphite_requested=no])\n-  if test \"${graphite_requested}\" = yes; then\n-    AC_MSG_ERROR([Unable to find a usable PPL.  See config.log for details.])\n-  fi\n-  with_cloog=no\n-fi\n-if test \"x${with_cloog}\" = x && test \"x${with_cloog_include}\" = x \\\n-  && test \"x${with_cloog_lib}\" = x && test -d ${srcdir}/cloog; then\n-  clooglibs='-L$$r/$(HOST_SUBDIR)/cloog/'\"$lt_cv_objdir\"' '\n-  clooginc='-I$$r/$(HOST_SUBDIR)/cloog/include -I$$s/cloog/include '\n-fi\n if test \"x$with_cloog\" != \"xno\"; then\n   dnl The minimal version of CLooG required for Graphite.\n   dnl\n@@ -2684,7 +2601,7 @@ changequote(,)\n changequote([,])\n \n     case $lib in\n-    mpc | mpfr | gmp | ppl | cloog)\n+    mpc | mpfr | gmp | cloog)\n       # If we're processing --with-$lib, --with-$lib-include or\n       # --with-$lib-lib, for one of the libs above, and target is\n       # different from host, don't pass the current argument to any\n@@ -3266,9 +3183,6 @@ case \"$target\" in\n   hppa*64*-*-hpux*) ;;\n   hppa*-*-hpux*) compare_exclusions=\"gcc/cc*-checksum\\$(objext) | */libgcc/lib2funcs* | gcc/ada/*tools/*\" ;;\n esac\n-case \" $configdirs \" in\n-*\" ppl \"*) compare_exclusions=\"$compare_exclusions | ppl/src/ppl-config.o\" ;;\n-esac\n AC_SUBST(compare_exclusions)\n \n AC_CONFIG_FILES([Makefile],"}, {"sha": "c02b77b4cbe2ff8465d62a7dae59f3b2341ca580", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,3 +1,34 @@\n+2012-07-02  Richard Guenther  <rguenther@suse.de>\n+\tMichael Matz  <matz@suse.de>\n+\tTobias Grosser <tobias@grosser.es>\n+\tSebastian Pop <sebpop@gmail.com>\n+\n+\t* Makefile.in: Remove PPL flags in favor of ISL ones.\n+\t(BACKENDLIBS): Remove PPL libs.\n+\t(INCLUDES): Remove PPL includes in favor of ISL ones.\n+\t(graphite-clast-to-gimple.o): Remove graphite-dependences.h and\n+\tgraphite-cloog-compat.h dependencies.\n+\t(graphite-dependences.o): Likewise.\n+\t(graphite-poly.o): Likewise.\n+\t* configure.ac: Declare ISL vars instead of PPL ones.\n+\t* configure: Regenerated.\n+\t* doc/install.texi: Replace PPL requirement documentation\n+\twith ISL one.\n+\t* graphite-blocking.c: Remove PPL code, add ISL equivalent.\n+\t* graphite-clast-to-gimple.c: Likewise.\n+\t* graphite-dependences.c: Likewise.\n+\t* graphite-interchange.c: Likewise.\n+\t* graphite-poly.h: Likewise.\n+\t* graphite-poly.c: Likewise.\n+\t* graphite-sese-to-poly.c: Likewise.\n+\t* graphite.c: Likewise.\n+\t* graphite-scop-detection.c: Re-arrange includes.\n+\t* graphite-cloog-util.c: Remove.\n+\t* graphite-cloog-util.h: Likewise.\n+\t* graphite-ppl.h: Likewise.\n+\t* graphite-ppl.c: Likewise.\n+\t* graphite-dependences.h: Likewise.\n+\n 2012-07-02  Richard Guenther  <rguenther@suse.de>\n \n \tMerge from graphite branch"}, {"sha": "ec39e2eeaaa45069974f76e1bf2f29ce6517edd8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -325,9 +325,8 @@ ZLIBINC = @zlibinc@\n GMPLIBS = @GMPLIBS@\n GMPINC = @GMPINC@\n \n-# How to find PPL\n-PPLLIBS = @PPLLIBS@\n-PPLINC = @PPLINC@\n+# How to find ISL\n+ISLINC = @ISLINC@\n \n # How to find CLOOG\n CLOOGLIBS = @CLOOGLIBS@\n@@ -954,7 +953,6 @@ REAL_H = real.h $(MACHMODE_H)\n IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h\n DBGCNT_H = dbgcnt.h dbgcnt.def\n EBITMAP_H = ebitmap.h sbitmap.h\n-GRAPHITE_PPL_H = graphite-ppl.h $(TREE_H)\n LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n \t\t$(CGRAPH_H) $(VEC_H) vecprim.h $(TREE_H) $(GIMPLE_H) \\\n \t\t$(GCOV_IO_H) $(DIAGNOSTIC_H) alloc-pool.h\n@@ -1027,7 +1025,7 @@ BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n # and the system's installed libraries.\n LIBS = @LIBS@ libcommon.a $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) \\\n \t$(LIBDECNUMBER) $(HOST_LIBS)\n-BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \\\n+BACKENDLIBS = $(CLOOGLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \\\n \t$(ZLIB)\n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n@@ -1059,7 +1057,7 @@ BUILD_ERRORS = build/errors.o\n INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \\\n \t   -I$(srcdir)/../include @INCINTL@ \\\n \t   $(CPPINC) $(GMPINC) $(DECNUMINC) \\\n-\t   $(PPLINC) $(CLOOGINC)\n+\t   $(CLOOGINC) $(ISLINC)\n \n .c.o:\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)\n@@ -1248,11 +1246,9 @@ OBJS = \\\n \tgraphite.o \\\n \tgraphite-blocking.o \\\n \tgraphite-clast-to-gimple.o \\\n-\tgraphite-cloog-util.o \\\n \tgraphite-dependences.o \\\n \tgraphite-interchange.o \\\n \tgraphite-poly.o \\\n-\tgraphite-ppl.o \\\n \tgraphite-scop-detection.o \\\n \tgraphite-sese-to-poly.o \\\n \tgtype-desc.o \\\n@@ -2539,37 +2535,30 @@ sese.o : sese.c sese.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_PRETTY_PRINT_H\n    $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H) value-prof.h\n graphite.o : graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h \\\n-   $(DBGCNT_H) $(GRAPHITE_PPL_H) graphite-poly.h graphite-scop-detection.h \\\n+   $(DBGCNT_H) graphite-poly.h graphite-scop-detection.h \\\n    graphite-clast-to-gimple.h graphite-sese-to-poly.h\n graphite-blocking.o : graphite-blocking.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n-   sese.h $(GRAPHITE_PPL_H) graphite-poly.h\n+   sese.h graphite-poly.h\n graphite-clast-to-gimple.o : graphite-clast-to-gimple.c $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\\n-   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h graphite-cloog-util.h \\\n-   $(GRAPHITE_PPL_H) graphite-poly.h graphite-clast-to-gimple.h \\\n-   graphite-dependences.h\n-graphite-cloog-util.o : graphite-cloog-util.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h graphite-cloog-util.h\n+   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h \\\n+   graphite-poly.h graphite-clast-to-gimple.h\n graphite-dependences.o : graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n-   sese.h $(GRAPHITE_PPL_H) graphite-poly.h graphite-dependences.h \\\n-   graphite-cloog-util.h\n+   sese.h graphite-poly.h\n graphite-interchange.o : graphite-interchange.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n-   sese.h $(GRAPHITE_PPL_H) graphite-poly.h\n+   sese.h graphite-poly.h\n graphite-poly.o : graphite-poly.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(GIMPLE_PRETTY_PRINT_H) \\\n-   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h $(GRAPHITE_PPL_H) graphite-poly.h \\\n-   graphite-dependences.h graphite-cloog-util.h\n-graphite-ppl.o : graphite-ppl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   graphite-cloog-util.h $(GRAPHITE_PPL_H)\n+   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h graphite-poly.h\n graphite-scop-detection.o : graphite-scop-detection.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H) \\\n-   sese.h $(GRAPHITE_PPL_H) graphite-poly.h graphite-scop-detection.h\n+   sese.h graphite-poly.h graphite-scop-detection.h\n graphite-sese-to-poly.o : graphite-sese-to-poly.c $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) \\\n-   $(TREE_DATA_REF_H) domwalk.h sese.h $(GRAPHITE_PPL_H) graphite-poly.h \\\n+   $(TREE_DATA_REF_H) domwalk.h sese.h graphite-poly.h \\\n    graphite-sese-to-poly.h\n tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\"}, {"sha": "fd3be5231b80ee52aee3c83953d030b7b5bf14ca", "filename": "gcc/configure", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -604,8 +604,8 @@ enable_plugin\n pluginlibs\n CLOOGINC\n CLOOGLIBS\n-PPLINC\n-PPLLIBS\n+ISLINC\n+ISLLIBS\n GMPINC\n GMPLIBS\n target_cpu_default\n@@ -934,8 +934,8 @@ CPP\n CXXCPP\n GMPLIBS\n GMPINC\n-PPLLIBS\n-PPLINC\n+ISLLIBS\n+ISLINC\n CLOOGLIBS\n CLOOGINC'\n \n@@ -1687,8 +1687,8 @@ Some influential environment variables:\n   CXXCPP      C++ preprocessor\n   GMPLIBS     How to link GMP\n   GMPINC      How to find GMP include files\n-  PPLLIBS     How to link PPL\n-  PPLINC      How to find PPL include files\n+  ISLLIBS     How to link ISL\n+  ISLINC      How to find ISL include files\n   CLOOGLIBS   How to link CLOOG\n   CLOOGINC    How to find CLOOG include files\n "}, {"sha": "89644e2dd96256f31051b0e23ed43ff71247459b", "filename": "gcc/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -4987,8 +4987,8 @@ fi\n AC_ARG_VAR(GMPLIBS,[How to link GMP])\n AC_ARG_VAR(GMPINC,[How to find GMP include files])\n \n-AC_ARG_VAR(PPLLIBS,[How to link PPL])\n-AC_ARG_VAR(PPLINC,[How to find PPL include files])\n+AC_ARG_VAR(ISLLIBS,[How to link ISL])\n+AC_ARG_VAR(ISLINC,[How to find ISL include files])\n \n AC_ARG_VAR(CLOOGLIBS,[How to link CLOOG])\n AC_ARG_VAR(CLOOGINC,[How to find CLOOG include files])"}, {"sha": "436f6567d5395b5379904b900a0dc3a0b4511c69", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -362,12 +362,12 @@ installed but it is not in your default library search path, the\n @option{--with-mpc} configure option should be used.  See also\n @option{--with-mpc-lib} and @option{--with-mpc-include}.\n \n-@item Parma Polyhedra Library (PPL) version 0.11\n+@item ISL Library version 0.10\n \n Necessary to build GCC with the Graphite loop optimizations.\n-It can be downloaded from @uref{http://www.cs.unipr.it/ppl/Download/}.\n+It can be downloaded from @uref{ftp://gcc.gnu.org/pub/gcc/infrastructure/}.\n \n-The @option{--with-ppl} configure option should be used if PPL is not\n+The @option{--with-isl} configure option should be used if ISL is not\n installed in your default library search path.\n \n @item CLooG 0.17.0\n@@ -1630,14 +1630,14 @@ a cross compiler, they will not be used to configure target libraries.\n @itemx --with-cloog=@var{pathname}\n @itemx --with-cloog-include=@var{pathname}\n @itemx --with-cloog-lib=@var{pathname}\n-If you do not have PPL (the Parma Polyhedra Library) and the CLooG\n+If you do not have ISL and the CLooG\n libraries installed in a standard location and you want to build GCC,\n you can explicitly specify the directory where they are installed\n-(@samp{--with-ppl=@/@var{pplinstalldir}},\n+(@samp{--with-isl=@/@var{islinstalldir}},\n @samp{--with-cloog=@/@var{clooginstalldir}}). The\n-@option{--with-ppl=@/@var{pplinstalldir}} option is shorthand for\n-@option{--with-ppl-lib=@/@var{pplinstalldir}/lib} and\n-@option{--with-ppl-include=@/@var{pplinstalldir}/include}.  Likewise the\n+@option{--with-isl=@/@var{islinstalldir}} option is shorthand for\n+@option{--with-isl-lib=@/@var{islinstalldir}/lib} and\n+@option{--with-isl-include=@/@var{islinstalldir}/include}.  Likewise the\n @option{--with-cloog=@/@var{clooginstalldir}} option is shorthand for\n @option{--with-cloog-lib=@/@var{clooginstalldir}/lib} and\n @option{--with-cloog-include=@/@var{clooginstalldir}/include}.  If these"}, {"sha": "b4ac522850a7e770dda730306e5e057ca04693e3", "filename": "gcc/graphite-blocking.c", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-blocking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-blocking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-blocking.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,7 +1,7 @@\n /* Heuristics and transform for loop blocking and strip mining on\n    polyhedral representation.\n \n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n    Pranav Garg  <pranav.garg2107@gmail.com>.\n \n@@ -20,7 +20,18 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n+\n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <isl/constraint.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree-flow.h\"\n@@ -31,8 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sese.h\"\n \n #ifdef HAVE_cloog\n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n \n \n@@ -92,65 +101,39 @@ along with GCC; see the file COPYING3.  If not see\n static void\n pbb_strip_mine_time_depth (poly_bb_p pbb, int time_depth, int stride)\n {\n-  ppl_dimension_type iter, dim, strip;\n-  ppl_Polyhedron_t res = PBB_TRANSFORMED_SCATTERING (pbb);\n+  isl_space *d;\n+  isl_constraint *c;\n+  int iter, strip;\n   /* STRIP is the dimension that iterates with stride STRIDE.  */\n   /* ITER is the dimension that enumerates single iterations inside\n      one strip that has at most STRIDE iterations.  */\n   strip = time_depth;\n   iter = strip + 2;\n \n-  psct_add_scattering_dimension (pbb, strip);\n-  psct_add_scattering_dimension (pbb, strip + 1);\n-\n-  ppl_Polyhedron_space_dimension (res, &dim);\n+  pbb->transformed = isl_map_insert_dims (pbb->transformed, isl_dim_out,\n+\t\t\t\t\t  strip, 2);\n \n   /* Lower bound of the striped loop.  */\n-  {\n-    ppl_Constraint_t new_cstr;\n-    ppl_Linear_Expression_t expr;\n-\n-    ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-    ppl_set_coef (expr, strip, -1 * stride);\n-    ppl_set_coef (expr, iter, 1);\n-\n-    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-    ppl_delete_Linear_Expression (expr);\n-    ppl_Polyhedron_add_constraint (res, new_cstr);\n-    ppl_delete_Constraint (new_cstr);\n-  }\n+  d = isl_map_get_space (pbb->transformed);\n+  c = isl_inequality_alloc (isl_local_space_from_space (d));\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, strip, -stride);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, iter, 1);\n+  pbb->transformed = isl_map_add_constraint (pbb->transformed, c);\n \n   /* Upper bound of the striped loop.  */\n-  {\n-    ppl_Constraint_t new_cstr;\n-    ppl_Linear_Expression_t expr;\n-\n-    ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-    ppl_set_coef (expr, strip, stride);\n-    ppl_set_coef (expr, iter, -1);\n-    ppl_set_inhomogeneous (expr, stride - 1);\n-\n-    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-    ppl_delete_Linear_Expression (expr);\n-    ppl_Polyhedron_add_constraint (res, new_cstr);\n-    ppl_delete_Constraint (new_cstr);\n-  }\n+  d = isl_map_get_space (pbb->transformed);\n+  c = isl_inequality_alloc (isl_local_space_from_space (d));\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, strip, stride);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, iter, -1);\n+  c = isl_constraint_set_constant_si (c, stride - 1);\n+  pbb->transformed = isl_map_add_constraint (pbb->transformed, c);\n \n   /* Static scheduling for ITER level.\n      This is mandatory to keep the 2d + 1 canonical scheduling format.  */\n-  {\n-    ppl_Constraint_t new_cstr;\n-    ppl_Linear_Expression_t expr;\n-\n-    ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-    ppl_set_coef (expr, strip + 1, 1);\n-    ppl_set_inhomogeneous (expr, 0);\n-\n-    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n-    ppl_delete_Linear_Expression (expr);\n-    ppl_Polyhedron_add_constraint (res, new_cstr);\n-    ppl_delete_Constraint (new_cstr);\n-  }\n+  d = isl_map_get_space (pbb->transformed);\n+  c = isl_equality_alloc (isl_local_space_from_space (d));\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, strip + 1, 1);\n+  pbb->transformed = isl_map_add_constraint (pbb->transformed, c);\n }\n \n /* Returns true when strip mining with STRIDE of the loop LST is"}, {"sha": "0219afeea80c9cca952390395f0d6e5a53d42a6a", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 235, "deletions": 144, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -19,6 +19,19 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <isl/list.h>\n+#include <isl/constraint.h>\n+#include <isl/ilp.h>\n+#include <isl/aff.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"diagnostic-core.h\"\n@@ -32,19 +45,56 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef HAVE_cloog\n #include \"cloog/cloog.h\"\n-#include \"ppl_c.h\"\n-#include \"graphite-cloog-util.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n #include \"graphite-clast-to-gimple.h\"\n-#include \"graphite-dependences.h\"\n \n typedef const struct clast_expr *clast_name_p;\n \n #ifndef CLOOG_LANGUAGE_C\n #define CLOOG_LANGUAGE_C LANGUAGE_C\n #endif\n \n+\n+/* Converts a GMP constant VAL to a tree and returns it.  */\n+\n+static tree\n+gmp_cst_to_tree (tree type, mpz_t val)\n+{\n+  tree t = type ? type : integer_type_node;\n+  mpz_t tmp;\n+  double_int di;\n+\n+  mpz_init (tmp);\n+  mpz_set (tmp, val);\n+  di = mpz_get_double_int (t, tmp, true);\n+  mpz_clear (tmp);\n+\n+  return double_int_to_tree (t, di);\n+}\n+\n+/* Sets RES to the min of V1 and V2.  */\n+\n+static void\n+value_min (mpz_t res, mpz_t v1, mpz_t v2)\n+{\n+  if (mpz_cmp (v1, v2) < 0)\n+    mpz_set (res, v1);\n+  else\n+    mpz_set (res, v2);\n+}\n+\n+/* Sets RES to the max of V1 and V2.  */\n+\n+static void\n+value_max (mpz_t res, mpz_t v1, mpz_t v2)\n+{\n+  if (mpz_cmp (v1, v2) < 0)\n+    mpz_set (res, v2);\n+  else\n+    mpz_set (res, v1);\n+}\n+\n+\n /* This flag is set when an error occurred during the translation of\n    CLAST to Gimple.  */\n static bool gloog_error;\n@@ -695,23 +745,18 @@ type_for_clast_expr (struct clast_expr *e, ivs_params_p ip, mpz_t bound_one,\n   return NULL_TREE;\n }\n \n-/* Returns the type for the equation CLEQ.  */\n+/* Returns true if the clast expression E is a constant with VALUE.  */\n \n-static tree\n-type_for_clast_eq (struct clast_equation *cleq, ivs_params_p ip)\n+static bool\n+clast_expr_const_value_p (struct clast_expr *e, int value)\n {\n-  mpz_t bound_one, bound_two;\n-  tree l, r;\n-\n-  mpz_init (bound_one);\n-  mpz_init (bound_two);\n-\n-  l = type_for_clast_expr (cleq->LHS, ip, bound_one, bound_two);\n-  r = type_for_clast_expr (cleq->RHS, ip, bound_one, bound_two);\n-\n-  mpz_clear (bound_one);\n-  mpz_clear (bound_two);\n-  return max_precision_type (l, r);\n+  struct clast_term *t;\n+  if (e->type != clast_expr_term)\n+    return false;\n+  t = (struct clast_term *)e;\n+  if (t->var)\n+    return false;\n+  return 0 == mpz_cmp_si (t->val, value);\n }\n \n /* Translates a clast equation CLEQ to a tree.  */\n@@ -721,19 +766,49 @@ graphite_translate_clast_equation (struct clast_equation *cleq,\n \t\t\t\t   ivs_params_p ip)\n {\n   enum tree_code comp;\n-  tree type = type_for_clast_eq (cleq, ip);\n-  tree lhs = clast_to_gcc_expression (type, cleq->LHS, ip);\n-  tree rhs = clast_to_gcc_expression (type, cleq->RHS, ip);\n+  tree type, lhs, rhs, ltype, rtype;\n+  mpz_t bound_one, bound_two;\n+  struct clast_expr *clhs, *crhs;\n \n+  clhs = cleq->LHS;\n+  crhs = cleq->RHS;\n   if (cleq->sign == 0)\n     comp = EQ_EXPR;\n-\n   else if (cleq->sign > 0)\n     comp = GE_EXPR;\n-\n   else\n     comp = LE_EXPR;\n \n+  /* Special cases to reduce range of arguments to hopefully\n+     don't need types with larger precision than the input.  */\n+  if (crhs->type == clast_expr_red\n+      && comp != EQ_EXPR)\n+    {\n+      struct clast_reduction *r = (struct clast_reduction *) crhs;\n+      /* X >= A+1 --> X > A and\n+         X <= A-1 --> X < A  */\n+      if (r->n == 2\n+\t  && r->type == clast_red_sum\n+\t  && clast_expr_const_value_p (r->elts[1], comp == GE_EXPR ? 1 : -1))\n+\t{\n+\t  crhs = r->elts[0];\n+\t  comp = comp == GE_EXPR ? GT_EXPR : LT_EXPR;\n+\t}\n+    }\n+\n+  mpz_init (bound_one);\n+  mpz_init (bound_two);\n+\n+  ltype = type_for_clast_expr (clhs, ip, bound_one, bound_two);\n+  rtype = type_for_clast_expr (crhs, ip, bound_one, bound_two);\n+\n+  mpz_clear (bound_one);\n+  mpz_clear (bound_two);\n+  type = max_precision_type (ltype, rtype);\n+\n+  lhs = clast_to_gcc_expression (type, clhs, ip);\n+  rhs = clast_to_gcc_expression (type, crhs, ip);\n+\n   return fold_build2 (comp, boolean_type_node, lhs, rhs);\n }\n \n@@ -776,87 +851,59 @@ graphite_create_new_guard (edge entry_edge, struct clast_guard *stmt,\n static void\n compute_bounds_for_param (scop_p scop, int param, mpz_t low, mpz_t up)\n {\n-  ppl_Linear_Expression_t le;\n-\n-  /* Prepare the linear expression corresponding to the parameter that\n-     we want to maximize/minimize.  */\n-  ppl_new_Linear_Expression_with_dimension (&le, scop_nb_params (scop));\n-  ppl_set_coef (le, param, 1);\n-\n-  ppl_max_for_le_pointset (SCOP_CONTEXT (scop), le, up);\n-  ppl_min_for_le_pointset (SCOP_CONTEXT (scop), le, low);\n-  ppl_delete_Linear_Expression (le);\n+  isl_int v;\n+  isl_aff *aff = isl_aff_zero_on_domain\n+    (isl_local_space_from_space (isl_set_get_space (scop->context)));\n+\n+  aff = isl_aff_add_coefficient_si (aff, isl_dim_param, param, 1);\n+\n+  isl_int_init (v);\n+  isl_set_min (scop->context, aff, &v);\n+  isl_int_get_gmp (v, low);\n+  isl_set_max (scop->context, aff, &v);\n+  isl_int_get_gmp (v, up);\n+  isl_int_clear (v);\n+  isl_aff_free (aff);\n }\n \n /* Compute the lower bound LOW and upper bound UP for the induction\n-   variable at LEVEL for the statement PBB, based on the transformed\n-   scattering of PBB: T|I|G|Cst, with T the scattering transform, I\n-   the iteration domain, and G the context parameters.  */\n+   variable of loop LOOP.\n \n-static void\n-compute_bounds_for_level (poly_bb_p pbb, int level, mpz_t low, mpz_t up)\n-{\n-  ppl_Pointset_Powerset_C_Polyhedron_t ps;\n-  ppl_Linear_Expression_t le;\n-\n-  combine_context_id_scat (&ps, pbb, false);\n-\n-  /* Prepare the linear expression corresponding to the level that we\n-     want to maximize/minimize.  */\n-  {\n-    ppl_dimension_type dim = pbb_nb_scattering_transform (pbb)\n-      + pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb);\n-\n-    ppl_new_Linear_Expression_with_dimension (&le, dim);\n-    ppl_set_coef (le, psct_dynamic_dim (pbb, level), 1);\n-  }\n-\n-  ppl_max_for_le_pointset (ps, le, up);\n-  ppl_min_for_le_pointset (ps, le, low);\n-  ppl_delete_Linear_Expression (le);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (ps);\n-}\n-\n-/* Walks a CLAST and returns the first statement in the body of a\n-   loop.\n-\n-   FIXME: This function should not be used to get a PBB in the STMT\n-   loop in order to find out the iteration domain of the loop: the\n-   counter example from Tobias is:\n-\n-   | for (i = 0; i < 100; i++)\n-   |   {\n-   |     if (i == 0)\n-   |       S1;\n-   |     S2;\n-   |   }\n+   FIXME: This one is not entirely correct, as min/max expressions in the\n+\t  calculation can yield to incorrect results. To be completely\n+\t  correct, we need to evaluate each subexpression generated by\n+          CLooG. CLooG does not yet support this, so this is as good as\n+\t  it can be. */\n \n-   This function would return S1 whose iteration domain contains only\n-   one point \"i = 0\", whereas the iteration domain of S2 has 100 points.\n-\n-   This should be implemented using some functionality existing in\n-   CLooG-ISL.  */\n-\n-static struct clast_user_stmt *\n-clast_get_body_of_loop (struct clast_stmt *stmt)\n+static void\n+compute_bounds_for_loop (struct clast_for *loop, mpz_t low, mpz_t up)\n {\n-  if (!stmt\n-      || CLAST_STMT_IS_A (stmt, stmt_user))\n-    return (struct clast_user_stmt *) stmt;\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_for))\n-    return clast_get_body_of_loop (((struct clast_for *) stmt)->body);\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n-    return clast_get_body_of_loop (((struct clast_guard *) stmt)->then);\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_block))\n-    return clast_get_body_of_loop (((struct clast_block *) stmt)->body);\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_ass))\n-    return clast_get_body_of_loop (stmt->next);\n-\n-  gcc_unreachable ();\n+  isl_set *domain;\n+  isl_aff *dimension;\n+  isl_local_space *local_space;\n+  isl_int isl_value;\n+  enum isl_lp_result lp_result;\n+\n+  domain = isl_set_copy (isl_set_from_cloog_domain (loop->domain));\n+  local_space = isl_local_space_from_space (isl_set_get_space (domain));\n+  dimension = isl_aff_zero_on_domain (local_space);\n+  dimension = isl_aff_add_coefficient_si (dimension, isl_dim_in,\n+\t\t\t\t\t  isl_set_dim (domain, isl_dim_set) - 1,\n+\t\t\t\t\t  1);\n+\n+  isl_int_init (isl_value);\n+\n+  lp_result = isl_set_min (domain, dimension, &isl_value);\n+  assert (lp_result == isl_lp_ok);\n+  isl_int_get_gmp (isl_value, low);\n+\n+  lp_result = isl_set_max (domain, dimension, &isl_value);\n+  assert (lp_result == isl_lp_ok);\n+  isl_int_get_gmp (isl_value, up);\n+\n+  isl_int_clear (isl_value);\n+  isl_set_free (domain);\n+  isl_aff_free (dimension);\n }\n \n /* Returns the type for the induction variable for the loop translated\n@@ -895,10 +942,6 @@ graphite_create_new_loop (edge entry_edge, struct clast_for *stmt,\n {\n   mpz_t low, up;\n \n-  struct clast_user_stmt *body\n-    = clast_get_body_of_loop ((struct clast_stmt *) stmt);\n-  poly_bb_p pbb = (poly_bb_p) body->statement->usr;\n-\n   tree stride = gmp_cst_to_tree (type, stmt->stride);\n   tree ivvar = create_tmp_var (type, \"graphite_IV\");\n   tree iv, iv_after_increment;\n@@ -910,7 +953,7 @@ graphite_create_new_loop (edge entry_edge, struct clast_for *stmt,\n \n   mpz_init (low);\n   mpz_init (up);\n-  compute_bounds_for_level (pbb, level, low, up);\n+  compute_bounds_for_loop (stmt, low, up);\n   save_clast_name_index (ip->newivs_index, stmt->iterator,\n \t\t\t VEC_length (tree, *(ip->newivs)), level, low, up);\n   mpz_clear (low);\n@@ -982,7 +1025,7 @@ mark_bb_with_pbb (poly_bb_p pbb, basic_block bb, htab_t bb_pbb_mapping)\n \n /* Find BB's related poly_bb_p in hash table BB_PBB_MAPPING.  */\n \n-static poly_bb_p\n+poly_bb_p\n find_pbb_via_hash (htab_t bb_pbb_mapping, basic_block bb)\n {\n   bb_pbb_def tmp;\n@@ -997,41 +1040,32 @@ find_pbb_via_hash (htab_t bb_pbb_mapping, basic_block bb)\n   return NULL;\n }\n \n-/* Check data dependency in LOOP at level LEVEL.\n-   BB_PBB_MAPPING is a basic_block and it's related poly_bb_p\n-   mapping.  */\n+/* Return the scop of the loop and initialize PBBS the set of\n+   poly_bb_p that belong to the LOOP.  BB_PBB_MAPPING is a map created\n+   by the CLAST code generator between a generated basic_block and its\n+   related poly_bb_p.  */\n \n-static bool\n-dependency_in_loop_p (loop_p loop, htab_t bb_pbb_mapping, int level)\n+scop_p\n+get_loop_body_pbbs (loop_p loop, htab_t bb_pbb_mapping,\n+\t\t    VEC (poly_bb_p, heap) **pbbs)\n {\n-  unsigned i,j;\n+  unsigned i;\n   basic_block *bbs = get_loop_body_in_dom_order (loop);\n+  scop_p scop = NULL;\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n-      poly_bb_p pbb1 = find_pbb_via_hash (bb_pbb_mapping, bbs[i]);\n+      poly_bb_p pbb = find_pbb_via_hash (bb_pbb_mapping, bbs[i]);\n \n-      if (pbb1 == NULL)\n-       continue;\n-\n-      for (j = 0; j < loop->num_nodes; j++)\n-       {\n-\t poly_bb_p pbb2 = find_pbb_via_hash (bb_pbb_mapping, bbs[j]);\n-\n-\t if (pbb2 == NULL)\n-\t   continue;\n+      if (pbb == NULL)\n+\tcontinue;\n \n-\t if (dependency_between_pbbs_p (pbb1, pbb2, level))\n-\t   {\n-\t     free (bbs);\n-\t     return true;\n-\t   }\n-       }\n+      scop = PBB_SCOP (pbb);\n+      VEC_safe_push (poly_bb_p, heap, *pbbs, pbb);\n     }\n \n   free (bbs);\n-\n-  return false;\n+  return scop;\n }\n \n /* Translates a clast user statement STMT to gimple.\n@@ -1138,7 +1172,7 @@ translate_clast_for_loop (loop_p context_loop, struct clast_for *stmt,\n   set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n \n   if (flag_loop_parallelize_all\n-      && !dependency_in_loop_p (loop, bb_pbb_mapping, level))\n+      && loop_is_parallel_p (loop, bb_pbb_mapping, level))\n     loop->can_be_parallel = true;\n \n   return last_e;\n@@ -1358,14 +1392,52 @@ init_cloog_input_file (int scop_number)\n   return graphite_out_file;\n }\n \n+/* Extend the scattering to NEW_DIMS scattering dimensions.  */\n+\n+static\n+isl_map *extend_scattering(isl_map *scattering, int new_dims)\n+{\n+  int old_dims, i;\n+  isl_space *space;\n+  isl_basic_map *change_scattering;\n+  isl_map *change_scattering_map;\n+\n+  old_dims = isl_map_dim (scattering, isl_dim_out);\n+\n+  space = isl_space_alloc (isl_map_get_ctx (scattering), 0, old_dims, new_dims);\n+  change_scattering = isl_basic_map_universe (isl_space_copy (space));\n+\n+  for (i = 0; i < old_dims; i++)\n+    {\n+      isl_constraint *c;\n+      c = isl_equality_alloc\n+\t(isl_local_space_from_space (isl_space_copy (space)));\n+      isl_constraint_set_coefficient_si (c, isl_dim_in, i, 1);\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, i, -1);\n+      change_scattering = isl_basic_map_add_constraint (change_scattering, c);\n+    }\n+\n+  for (i = old_dims; i < new_dims; i++)\n+    {\n+      isl_constraint *c;\n+      c = isl_equality_alloc\n+\t(isl_local_space_from_space (isl_space_copy (space)));\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n+      change_scattering = isl_basic_map_add_constraint (change_scattering, c);\n+    }\n+\n+  change_scattering_map = isl_map_from_basic_map (change_scattering);\n+  change_scattering_map = isl_map_align_params (change_scattering_map, space);\n+  return isl_map_apply_range (scattering, change_scattering_map);\n+}\n+\n /* Build cloog union domain for SCoP.  */\n \n static CloogUnionDomain *\n-build_cloog_union_domain (scop_p scop)\n+build_cloog_union_domain (scop_p scop, int nb_scattering_dims)\n {\n   int i;\n   poly_bb_p pbb;\n-\n   CloogUnionDomain *union_domain =\n     cloog_union_domain_alloc (scop_nb_params (scop));\n \n@@ -1376,16 +1448,12 @@ build_cloog_union_domain (scop_p scop)\n \n       /* Dead code elimination: when the domain of a PBB is empty,\n \t don't generate code for the PBB.  */\n-      if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (PBB_DOMAIN (pbb)))\n+      if (isl_set_is_empty(pbb->domain))\n \tcontinue;\n \n-      domain = new_Cloog_Domain_from_ppl_Pointset_Powerset (PBB_DOMAIN (pbb),\n-\t\t\t\t\t\t\t    scop_nb_params (scop),\n-\t\t\t\t\t\t\t    cloog_state);\n-\n-      scattering = new_Cloog_Scattering_from_ppl_Polyhedron\n-\t(PBB_TRANSFORMED_SCATTERING (pbb), scop_nb_params (scop),\n-\t pbb_nb_scattering_transform (pbb), cloog_state);\n+      domain = cloog_domain_from_isl_set(isl_set_copy(pbb->domain));\n+      scattering = cloog_scattering_from_isl_map(extend_scattering(isl_map_copy(pbb->transformed),\n+\t\t\t\t\t\t nb_scattering_dims));\n \n       union_domain = cloog_union_domain_add_domain (union_domain, \"\", domain,\n \t\t\t\t\t\t    scattering, pbb);\n@@ -1422,6 +1490,11 @@ set_cloog_options (void)\n        A  */\n   options->strides = 1;\n \n+  /* We want the clast to provide the iteration domains of the executed loops.\n+     This allows us to derive minimal/maximal values for the induction\n+     variables.  */\n+  options->save_domains = 1;\n+\n   /* Disable optimizations and make cloog generate source code closer to the\n      input.  This is useful for debugging,  but later we want the optimized\n      code.\n@@ -1456,20 +1529,38 @@ debug_clast_stmt (struct clast_stmt *stmt)\n   print_clast_stmt (stderr, stmt);\n }\n \n+/* Get the maximal number of scattering dimensions in the scop SCOP.  */\n+\n+static\n+int get_max_scattering_dimensions (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  int scattering_dims = 0;\n+\n+  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n+    {\n+      int pbb_scatt_dims = isl_map_dim (pbb->transformed, isl_dim_out);\n+      if (pbb_scatt_dims > scattering_dims)\n+\tscattering_dims = pbb_scatt_dims;\n+    }\n+\n+  return scattering_dims;\n+}\n+\n static CloogInput *\n generate_cloog_input (scop_p scop, htab_t params_index)\n {\n   CloogUnionDomain *union_domain;\n   CloogInput *cloog_input;\n   CloogDomain *context;\n+  int nb_scattering_dims = get_max_scattering_dimensions (scop);\n \n-  int nb_scattering_dims = unify_scattering_dimensions (scop);\n-  union_domain = build_cloog_union_domain (scop);\n+  union_domain = build_cloog_union_domain (scop, nb_scattering_dims);\n   union_domain = add_names_to_union_domain (scop, union_domain,\n \t\t\t\t\t    nb_scattering_dims,\n \t\t\t\t\t    params_index);\n-  context = new_Cloog_Domain_from_ppl_Pointset_Powerset\n-    (SCOP_CONTEXT (scop), scop_nb_params (scop), cloog_state);\n+  context = cloog_domain_from_isl_set (isl_set_copy (scop->context));\n \n   cloog_input = cloog_input_alloc (context, union_domain);\n "}, {"sha": "8fdee90856bd1f48b7838ec74c9c9b1ea9fff1b8", "filename": "gcc/graphite-clast-to-gimple.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-clast-to-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-clast-to-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.h?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -21,8 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GRAPHITE_CLAST_TO_GIMPLE_H\n #define GCC_GRAPHITE_CLAST_TO_GIMPLE_H\n \n-#include \"graphite-cloog-util.h\"\n-\n extern CloogState *cloog_state;\n \n /* Data structure for CLooG program representation.  */"}, {"sha": "83cfb54eb1efd161408bca864411b331c65ddfc6", "filename": "gcc/graphite-cloog-util.c", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-cloog-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-cloog-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-cloog-util.c?ref=6886e4444f193c399b96cb1f64a24b9673cf3149", "patch": "@@ -1,409 +0,0 @@\n-/* Gimple Represented as Polyhedra.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n-   and Tobias Grosser <grosser@fim.uni-passau.de>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-\n-#ifdef HAVE_cloog\n-\n-#include \"ppl_c.h\"\n-#include \"cloog/cloog.h\"\n-#include \"graphite-cloog-util.h\"\n-\n-/* Counts the number of constraints in PCS.  */\n-\n-static int\n-ppl_Constrain_System_number_of_constraints (ppl_const_Constraint_System_t pcs)\n-{\n-  ppl_Constraint_System_const_iterator_t cit, end;\n-  int num = 0;\n-\n-  ppl_new_Constraint_System_const_iterator (&cit);\n-  ppl_new_Constraint_System_const_iterator (&end);\n-\n-  for (ppl_Constraint_System_begin (pcs, cit),\n-       ppl_Constraint_System_end (pcs, end);\n-       !ppl_Constraint_System_const_iterator_equal_test (cit, end);\n-       ppl_Constraint_System_const_iterator_increment (cit))\n-    num++;\n-\n-  ppl_delete_Constraint_System_const_iterator (cit);\n-  ppl_delete_Constraint_System_const_iterator (end);\n-  return num;\n-}\n-\n-static void\n-oppose_constraint (CloogMatrix *m, int row)\n-{\n-  int k;\n-\n-  /* Do not oppose the first column: it is the eq/ineq one.  */\n-  /* Cast needed to remove warning that is generated as CLooG isl\n-     is using an unsigned int for NbColumns and CLooG PPL is\n-     using a signed int for NBColumns.  */\n-  for (k = 1; k < (int)m->NbColumns; k++)\n-    mpz_neg (m->p[row][k], m->p[row][k]);\n-}\n-\n-/* Inserts constraint CSTR at row ROW of matrix M.  */\n-\n-static void\n-insert_constraint_into_matrix (CloogMatrix *m, int row,\n-\t\t\t       ppl_const_Constraint_t cstr)\n-{\n-  ppl_Coefficient_t c;\n-  ppl_dimension_type i, dim, nb_cols = m->NbColumns;\n-\n-  ppl_Constraint_space_dimension (cstr, &dim);\n-  ppl_new_Coefficient (&c);\n-\n-  for (i = 0; i < dim; i++)\n-    {\n-      ppl_Constraint_coefficient (cstr, i, c);\n-      ppl_Coefficient_to_mpz_t (c, m->p[row][i + 1]);\n-    }\n-\n-  for (i = dim; i < nb_cols - 1; i++)\n-    mpz_set_si (m->p[row][i + 1], 0);\n-\n-  ppl_Constraint_inhomogeneous_term  (cstr, c);\n-  ppl_Coefficient_to_mpz_t (c, m->p[row][nb_cols - 1]);\n-  mpz_set_si (m->p[row][0], 1);\n-\n-  switch (ppl_Constraint_type (cstr))\n-    {\n-    case PPL_CONSTRAINT_TYPE_LESS_THAN:\n-      oppose_constraint (m, row);\n-    case PPL_CONSTRAINT_TYPE_GREATER_THAN:\n-      mpz_sub_ui (m->p[row][nb_cols - 1],\n-\t\t     m->p[row][nb_cols - 1], 1);\n-      break;\n-\n-    case PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL:\n-      oppose_constraint (m, row);\n-    case PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL:\n-      break;\n-\n-    case PPL_CONSTRAINT_TYPE_EQUAL:\n-      mpz_set_si (m->p[row][0], 0);\n-      break;\n-\n-    default:\n-      /* Not yet implemented.  */\n-      gcc_unreachable();\n-    }\n-\n-  ppl_delete_Coefficient (c);\n-}\n-\n-/* Creates a CloogMatrix from constraint system PCS.  */\n-\n-static CloogMatrix *\n-new_Cloog_Matrix_from_ppl_Constraint_System (ppl_const_Constraint_System_t pcs)\n-{\n-  CloogMatrix *matrix;\n-  ppl_Constraint_System_const_iterator_t cit, end;\n-  ppl_dimension_type dim;\n-  int rows;\n-  int row = 0;\n-\n-  rows = ppl_Constrain_System_number_of_constraints (pcs);\n-  ppl_Constraint_System_space_dimension (pcs, &dim);\n-  matrix = cloog_matrix_alloc (rows, dim + 2);\n-  ppl_new_Constraint_System_const_iterator (&cit);\n-  ppl_new_Constraint_System_const_iterator (&end);\n-\n-  for (ppl_Constraint_System_begin (pcs, cit),\n-       ppl_Constraint_System_end (pcs, end);\n-       !ppl_Constraint_System_const_iterator_equal_test (cit, end);\n-       ppl_Constraint_System_const_iterator_increment (cit))\n-    {\n-      ppl_const_Constraint_t c;\n-      ppl_Constraint_System_const_iterator_dereference (cit, &c);\n-      insert_constraint_into_matrix (matrix, row, c);\n-      row++;\n-    }\n-\n-  ppl_delete_Constraint_System_const_iterator (cit);\n-  ppl_delete_Constraint_System_const_iterator (end);\n-\n-  return matrix;\n-}\n-\n-/* Creates a CloogMatrix from polyhedron PH.  */\n-\n-CloogMatrix *\n-new_Cloog_Matrix_from_ppl_Polyhedron (ppl_const_Polyhedron_t ph)\n-{\n-  ppl_const_Constraint_System_t pcs;\n-  CloogMatrix *res;\n-\n-  ppl_Polyhedron_get_constraints (ph, &pcs);\n-  res = new_Cloog_Matrix_from_ppl_Constraint_System (pcs);\n-\n-  return res;\n-}\n-\n-/* Translates row ROW of the CloogMatrix MATRIX to a PPL Constraint.  */\n-\n-static ppl_Constraint_t\n-cloog_matrix_to_ppl_constraint (CloogMatrix *matrix, int row)\n-{\n-  int j;\n-  ppl_Constraint_t cstr;\n-  ppl_Coefficient_t coef;\n-  ppl_Linear_Expression_t expr;\n-  ppl_dimension_type dim = matrix->NbColumns - 2;\n-\n-  ppl_new_Coefficient (&coef);\n-  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-\n-  /* Cast needed to remove warning that is generated as CLooG isl\n-     is using an unsigned int for NbColumns and CLooG PPL is\n-     using a signed int for NBColumns.  */\n-  for (j = 1; j < (int)matrix->NbColumns - 1; j++)\n-    {\n-      ppl_assign_Coefficient_from_mpz_t (coef, matrix->p[row][j]);\n-      ppl_Linear_Expression_add_to_coefficient (expr, j - 1, coef);\n-    }\n-\n-  ppl_assign_Coefficient_from_mpz_t (coef,\n-\t\t\t\t     matrix->p[row][matrix->NbColumns - 1]);\n-  ppl_Linear_Expression_add_to_inhomogeneous (expr, coef);\n-  ppl_delete_Coefficient (coef);\n-\n-  if (mpz_sgn (matrix->p[row][0]) == 0)\n-    ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n-  else\n-    ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-\n-  ppl_delete_Linear_Expression (expr);\n-  return cstr;\n-}\n-\n-/* Creates a PPL constraint system from MATRIX.  */\n-\n-static void\n-new_Constraint_System_from_Cloog_Matrix (ppl_Constraint_System_t *pcs,\n-\t\t\t\t\t CloogMatrix *matrix)\n-{\n-  int i;\n-\n-  ppl_new_Constraint_System (pcs);\n-\n-  /* Cast needed to remove warning that is generated as CLooG isl\n-     is using an unsigned int for NbColumns and CLooG PPL is\n-     using a signed int for NBColumns.  */\n-  for (i = 0; i < (int)matrix->NbRows; i++)\n-    {\n-      ppl_Constraint_t c = cloog_matrix_to_ppl_constraint (matrix, i);\n-      ppl_Constraint_System_insert_Constraint (*pcs, c);\n-      ppl_delete_Constraint (c);\n-    }\n-}\n-\n-/* Creates a PPL Polyhedron from MATRIX.  */\n-\n-void\n-new_C_Polyhedron_from_Cloog_Matrix (ppl_Polyhedron_t *ph,\n-\t\t\t\t      CloogMatrix *matrix)\n-{\n-  ppl_Constraint_System_t cs;\n-  new_Constraint_System_from_Cloog_Matrix (&cs, matrix);\n-  ppl_new_C_Polyhedron_recycle_Constraint_System (ph, cs);\n-}\n-\n-/* Creates a CloogDomain from polyhedron PH.  */\n-\n-CloogDomain *\n-new_Cloog_Domain_from_ppl_Polyhedron (ppl_const_Polyhedron_t ph, int nb_params,\n-                                      CloogState *state)\n-{\n-  CloogMatrix *mat = new_Cloog_Matrix_from_ppl_Polyhedron (ph);\n-  CloogDomain *res = cloog_domain_from_cloog_matrix (state, mat, nb_params);\n-  cloog_matrix_free (mat);\n-  return res;\n-}\n-\n-/* Create a CloogScattering from polyhedron PH.  */\n-\n-CloogScattering *\n-new_Cloog_Scattering_from_ppl_Polyhedron (ppl_const_Polyhedron_t ph,\n-                                          int nb_params,\n-                                          int nb_scatt,\n-                                          CloogState *state)\n-{\n-  CloogMatrix *mat = new_Cloog_Matrix_from_ppl_Polyhedron (ph);\n-  CloogScattering *res = cloog_scattering_from_cloog_matrix (state, mat,\n-                                                             nb_scatt,\n-                                                             nb_params);\n-\n-  cloog_matrix_free (mat);\n-  return res;\n-}\n-\n-/* Creates a CloogDomain from a pointset powerset PS.  */\n-\n-CloogDomain *\n-new_Cloog_Domain_from_ppl_Pointset_Powerset\n-  (ppl_Pointset_Powerset_C_Polyhedron_t ps, int nb_params,\n-   CloogState *state)\n-{\n-  CloogDomain *res = NULL;\n-  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n-\n-  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (ps, it),\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (ps, end);\n-       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n-    {\n-      ppl_const_Polyhedron_t ph;\n-      CloogDomain *tmp;\n-\n-      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n-      tmp = new_Cloog_Domain_from_ppl_Polyhedron (ph, nb_params, state);\n-\n-      if (res == NULL)\n-\tres = tmp;\n-      else\n-\tres = cloog_domain_union (res, tmp);\n-    }\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n-\n-  gcc_assert (res != NULL);\n-\n-  return res;\n-}\n-\n-/* Print to FILE the matrix MAT in OpenScop format.  OUTPUT is the number\n-   of output dimensions, INPUT is the number of input dimensions, LOCALS\n-   is the number of existentially quantified variables and PARAMS is the\n-   number of parameters.  */\n-\n-static void\n-openscop_print_cloog_matrix (FILE *file, CloogMatrix *mat,\n-\t\t\t     int output, int input, int locals,\n-\t\t\t     int params)\n-{\n-  unsigned i, j;\n-\n-  fprintf (file, \"%d %d %d %d %d %d \\n\", mat->NbRows,\n-\t   mat->NbColumns, output, input, locals, params);\n-\n-  for (i = 0; i < mat->NbRows; i++)\n-    {\n-      for (j = 0; j < mat->NbColumns; j++)\n-        if (j == 0)\n-\t  fprintf (file, \"%ld \", mpz_get_si (mat->p[i][j]));\n-        else\n-\t  fprintf (file, \"%6ld \", mpz_get_si (mat->p[i][j]));\n-\n-      fprintf (file, \"\\n\");\n-    }\n-}\n-\n-/* Print to FILE the polyhedron PH in OpenScop format.  OUTPUT is the number\n-   of output dimensions, INPUT is the number of input dimensions, LOCALS is\n-   the number of existentially quantified variables and PARAMS is the number\n-   of parameters.  */\n-\n-void\n-openscop_print_polyhedron_matrix (FILE *file, ppl_const_Polyhedron_t ph,\n-\t\t\t\t  int output, int input, int locals,\n-\t\t\t\t  int params)\n-{\n-  CloogMatrix *mat = new_Cloog_Matrix_from_ppl_Polyhedron (ph);\n-  openscop_print_cloog_matrix (file, mat, output, input, locals, params);\n-  cloog_matrix_free (mat);\n-}\n-\n-/* Read from FILE a matrix in OpenScop format.  OUTPUT is the number of\n-   output dimensions, INPUT is the number of input dimensions, LOCALS\n-   is the number of existentially quantified variables and PARAMS is the\n-   number of parameters.  */\n-\n-static CloogMatrix *\n-openscop_read_cloog_matrix (FILE *file, int *output, int *input, int *locals,\n-\t\t\t    int *params)\n-{\n-  int nb_rows, nb_cols, i, j;\n-  CloogMatrix *mat;\n-  int *openscop_matrix_header, *matrix_line;\n-\n-  openscop_matrix_header = openscop_read_N_int (file, 6);\n-\n-  nb_rows = openscop_matrix_header[0];\n-  nb_cols = openscop_matrix_header[1];\n-  *output = openscop_matrix_header[2];\n-  *input = openscop_matrix_header[3];\n-  *locals = openscop_matrix_header[4];\n-  *params = openscop_matrix_header[5];\n-\n-  free (openscop_matrix_header);\n-\n-  if (nb_rows == 0 || nb_cols == 0)\n-    return NULL;\n-\n-  mat = cloog_matrix_alloc (nb_rows, nb_cols);\n-  mat->NbRows = nb_rows;\n-  mat->NbColumns = nb_cols;\n-\n-  for (i = 0; i < nb_rows; i++)\n-    {\n-      matrix_line = openscop_read_N_int (file, nb_cols);\n-\n-      for (j = 0; j < nb_cols; j++)\n-        mpz_set_si (mat->p[i][j], matrix_line[j]);\n-    }\n-\n-  return mat;\n-}\n-\n-/* Read from FILE the polyhedron PH in OpenScop format.  OUTPUT is the number\n-   of output dimensions, INPUT is the number of input dimensions, LOCALS is\n-   the number of existentially quantified variables and PARAMS is the number\n-   of parameters.  */\n-\n-void\n-openscop_read_polyhedron_matrix (FILE *file, ppl_Polyhedron_t *ph,\n-\t\t\t\t int *output, int *input, int *locals,\n-\t\t\t\t int *params)\n-{\n-  CloogMatrix *mat;\n-\n-  mat = openscop_read_cloog_matrix (file, output, input, locals, params);\n-\n-  if (!mat)\n-    *ph = NULL;\n-  else\n-    {\n-      new_C_Polyhedron_from_Cloog_Matrix (ph, mat);\n-      cloog_matrix_free (mat);\n-    }\n-}\n-\n-#endif"}, {"sha": "da26ee9f1fc2b237263153013f9fb25c0426d9b2", "filename": "gcc/graphite-cloog-util.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-cloog-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-cloog-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-cloog-util.h?ref=6886e4444f193c399b96cb1f64a24b9673cf3149", "patch": "@@ -1,41 +0,0 @@\n-/* Gimple Represented as Polyhedra.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n-   and Tobias Grosser <grosser@fim.uni-passau.de>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-#ifndef GRAPHITE_CLOOG_UTIL_H\n-#define GRAPHITE_CLOOG_UTIL_H\n-\n-#include \"cloog/cloog.h\"\n-\n-CloogMatrix *new_Cloog_Matrix_from_ppl_Polyhedron (ppl_const_Polyhedron_t);\n-CloogDomain *new_Cloog_Domain_from_ppl_Polyhedron (ppl_const_Polyhedron_t,\n-\t\t\t\t\t\t   int, CloogState *);\n-CloogScattering *new_Cloog_Scattering_from_ppl_Polyhedron\n-  (ppl_const_Polyhedron_t, int, int, CloogState *);\n-CloogDomain * new_Cloog_Domain_from_ppl_Pointset_Powerset\n-  (ppl_Pointset_Powerset_C_Polyhedron_t, int, CloogState *);\n-void new_C_Polyhedron_from_Cloog_Matrix (ppl_Polyhedron_t *, CloogMatrix *);\n-void openscop_print_polyhedron_matrix (FILE *, ppl_const_Polyhedron_t, int,\n-\t\t\t\t       int, int, int);\n-void openscop_read_polyhedron_matrix (FILE *, ppl_Polyhedron_t *, int *, int *,\n-\t       \t\t\t     int *, int *);\n-\n-extern int *openscop_read_N_int (FILE *, int);\n-\n-#endif /* GRAPHITE_CLOOG_UTIL_H */"}, {"sha": "0c10e60e6409731dade4b13790090a57b7911a3b", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 435, "deletions": 772, "changes": 1207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,5 +1,5 @@\n /* Data dependence analysis for Graphite.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n    Konrad Trifunovic <konrad.trifunovic@inria.fr>.\n \n@@ -20,6 +20,17 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <isl/flow.h>\n+#include <isl/constraint.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree-flow.h\"\n@@ -31,904 +42,556 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sese.h\"\n \n #ifdef HAVE_cloog\n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n-#include \"graphite-dependences.h\"\n-#include \"graphite-cloog-util.h\"\n-\n-/* Comparison function for poly_ddr hash table.  */\n-\n-int\n-eq_poly_ddr_p (const void *pddr1, const void *pddr2)\n-{\n-  const struct poly_ddr *p1 = (const struct poly_ddr *) pddr1;\n-  const struct poly_ddr *p2 = (const struct poly_ddr *) pddr2;\n-\n-  return (PDDR_SOURCE (p1) == PDDR_SOURCE (p2)\n-          && PDDR_SINK (p1) == PDDR_SINK (p2));\n-}\n-\n-/* Hash function for poly_ddr hashtable.  */\n-\n-hashval_t\n-hash_poly_ddr_p (const void *pddr)\n-{\n-  const struct poly_ddr *p = (const struct poly_ddr *) pddr;\n-\n-  return (hashval_t) ((long) PDDR_SOURCE (p) + (long) PDDR_SINK (p));\n-}\n \n-/* Returns true when PDDR has no dependence.  */\n+/* Add the constraints from the set S to the domain of MAP.  */\n \n-static bool\n-pddr_is_empty (poly_ddr_p pddr)\n+static isl_map *\n+constrain_domain (isl_map *map, isl_set *s)\n {\n-  if (!pddr)\n-    return true;\n-\n-  gcc_assert (PDDR_KIND (pddr) != unknown_dependence);\n+  isl_space *d = isl_map_get_space (map);\n+  isl_id *id = isl_space_get_tuple_id (d, isl_dim_in);\n \n-  return PDDR_KIND (pddr) == no_dependence ? true : false;\n+  s = isl_set_set_tuple_id (s, id);\n+  isl_space_free (d);\n+  return isl_map_intersect_domain (map, s);\n }\n \n-/* Prints to FILE the layout of the dependence polyhedron of PDDR:\n+/* Constrain pdr->accesses with pdr->extent and pbb->domain.  */\n \n-   T1|I1|T2|I2|S1|S2|G\n-\n-   with\n-   | T1 and T2 the scattering dimensions for PDDR_SOURCE and PDDR_SINK\n-   | I1 and I2 the iteration domains\n-   | S1 and S2 the subscripts\n-   | G the global parameters.  */\n-\n-static void\n-print_dependence_polyhedron_layout (FILE *file, poly_ddr_p pddr)\n+static isl_map *\n+add_pdr_constraints (poly_dr_p pdr, poly_bb_p pbb)\n {\n-  poly_dr_p pdr1 = PDDR_SOURCE (pddr);\n-  poly_dr_p pdr2 = PDDR_SINK (pddr);\n-  poly_bb_p pbb1 = PDR_PBB (pdr1);\n-  poly_bb_p pbb2 = PDR_PBB (pdr2);\n-\n-  graphite_dim_t i;\n-  graphite_dim_t tdim1 = PDDR_ORIGINAL_SCATTERING_P (pddr) ?\n-    pbb_nb_scattering_orig (pbb1) : pbb_nb_scattering_transform (pbb1);\n-  graphite_dim_t tdim2 = PDDR_ORIGINAL_SCATTERING_P (pddr) ?\n-    pbb_nb_scattering_orig (pbb2) : pbb_nb_scattering_transform (pbb2);\n-  graphite_dim_t idim1 = pbb_dim_iter_domain (pbb1);\n-  graphite_dim_t idim2 = pbb_dim_iter_domain (pbb2);\n-  graphite_dim_t sdim1 = PDR_NB_SUBSCRIPTS (pdr1) + 1;\n-  graphite_dim_t sdim2 = PDR_NB_SUBSCRIPTS (pdr2) + 1;\n-  graphite_dim_t gdim = scop_nb_params (PBB_SCOP (pbb1));\n-\n-  fprintf (file, \"#  eq\");\n-\n-  for (i = 0; i < tdim1; i++)\n-    fprintf (file, \"   t1_%d\", (int) i);\n-  for (i = 0; i < idim1; i++)\n-    fprintf (file, \"   i1_%d\", (int) i);\n-  for (i = 0; i < tdim2; i++)\n-    fprintf (file, \"   t2_%d\", (int) i);\n-  for (i = 0; i < idim2; i++)\n-    fprintf (file, \"   i2_%d\", (int) i);\n-  for (i = 0; i < sdim1; i++)\n-    fprintf (file, \"   s1_%d\", (int) i);\n-  for (i = 0; i < sdim2; i++)\n-    fprintf (file, \"   s2_%d\", (int) i);\n-  for (i = 0; i < gdim; i++)\n-    fprintf (file, \"    g_%d\", (int) i);\n-\n-  fprintf (file, \"    cst\\n\");\n+  isl_map *x = isl_map_intersect_range (isl_map_copy (pdr->accesses),\n+\t\t\t\t\tisl_set_copy (pdr->extent));\n+  x = constrain_domain (x, isl_set_copy (pbb->domain));\n+  return x;\n }\n \n-/* Prints to FILE the poly_ddr_p PDDR.  */\n+/* Returns all the memory reads in SCOP.  */\n \n-void\n-print_pddr (FILE *file, poly_ddr_p pddr)\n+static isl_union_map *\n+scop_get_reads (scop_p scop, VEC (poly_bb_p, heap) *pbbs)\n {\n-  fprintf (file, \"pddr (kind: \");\n-\n-  if (PDDR_KIND (pddr) == unknown_dependence)\n-    fprintf (file, \"unknown_dependence\");\n-  else if (PDDR_KIND (pddr) == no_dependence)\n-    fprintf (file, \"no_dependence\");\n-  else if (PDDR_KIND (pddr) == has_dependence)\n-    fprintf (file, \"has_dependence\");\n-\n-  fprintf (file, \"\\n  source \");\n-  print_pdr (file, PDDR_SOURCE (pddr), 2);\n-\n-  fprintf (file, \"\\n  sink \");\n-  print_pdr (file, PDDR_SINK (pddr), 2);\n+  int i, j;\n+  poly_bb_p pbb;\n+  poly_dr_p pdr;\n+  isl_space *space = isl_set_get_space (scop->context);\n+  isl_union_map *res = isl_union_map_empty (space);\n \n-  if (PDDR_KIND (pddr) == has_dependence)\n+  FOR_EACH_VEC_ELT (poly_bb_p, pbbs, i, pbb)\n     {\n-      fprintf (file, \"\\n  dependence polyhedron (\\n\");\n-      print_dependence_polyhedron_layout (file, pddr);\n-      ppl_print_powerset_matrix (file, PDDR_DDP (pddr));\n-      ppl_io_fprint_Pointset_Powerset_C_Polyhedron (file, PDDR_DDP (pddr));\n-      fprintf (file, \")\\n\");\n+      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), j, pdr)\n+\tif (pdr_read_p (pdr))\n+\t  res = isl_union_map_add_map (res, add_pdr_constraints (pdr, pbb));\n     }\n \n-  fprintf (file, \")\\n\");\n-}\n-\n-/* Prints to STDERR the poly_ddr_p PDDR.  */\n-\n-DEBUG_FUNCTION void\n-debug_pddr (poly_ddr_p pddr)\n-{\n-  print_pddr (stderr, pddr);\n-}\n-\n-\n-/* Remove all the dimensions except alias information at dimension\n-   ALIAS_DIM.  */\n-\n-static void\n-build_alias_set_powerset (ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset,\n-\t\t\t  ppl_dimension_type alias_dim)\n-{\n-  ppl_dimension_type *ds;\n-  ppl_dimension_type access_dim;\n-  unsigned i, pos;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (alias_powerset,\n-\t\t\t\t\t\t      &access_dim);\n-  ds = XNEWVEC (ppl_dimension_type, access_dim - 1);\n-  gcc_assert (alias_dim < access_dim);\n-\n-  for (pos = 0, i = 0; i < access_dim; i++)\n-    if (i != alias_dim)\n-      ds[pos++] = i;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_remove_space_dimensions (alias_powerset,\n-\t\t\t\t\t\t\t      ds,\n-\t\t\t\t\t\t\t      access_dim - 1);\n-  free (ds);\n-}\n-\n-/* Return true when PDR1 and PDR2 may alias.  */\n-\n-static bool\n-poly_drs_may_alias_p (poly_dr_p pdr1, poly_dr_p pdr2)\n-{\n-  ppl_Pointset_Powerset_C_Polyhedron_t alias_powerset1, alias_powerset2;\n-  ppl_Pointset_Powerset_C_Polyhedron_t accesses1 = PDR_ACCESSES (pdr1);\n-  ppl_Pointset_Powerset_C_Polyhedron_t accesses2 = PDR_ACCESSES (pdr2);\n-  ppl_dimension_type alias_dim1 = pdr_alias_set_dim (pdr1);\n-  ppl_dimension_type alias_dim2 = pdr_alias_set_dim (pdr2);\n-  int empty_p;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&alias_powerset1, accesses1);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&alias_powerset2, accesses2);\n-\n-  build_alias_set_powerset (alias_powerset1, alias_dim1);\n-  build_alias_set_powerset (alias_powerset2, alias_dim2);\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign\n-    (alias_powerset1, alias_powerset2);\n-\n-  empty_p = ppl_Pointset_Powerset_C_Polyhedron_is_empty (alias_powerset1);\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset1);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (alias_powerset2);\n-\n-  return !empty_p;\n-}\n-\n-/* Swap [cut0, ..., cut1] to the end of DR: \"a CUT0 b CUT1 c\" is\n-   transformed into \"a CUT0 c CUT1' b\"\n-\n-   Add NB0 zeros before \"a\":  \"00...0 a CUT0 c CUT1' b\"\n-   Add NB1 zeros between \"a\" and \"c\":  \"00...0 a 00...0 c CUT1' b\"\n-   Add DIM - NB0 - NB1 - PDIM zeros between \"c\" and \"b\":\n-   \"00...0 a 00...0 c 00...0 b\".  */\n-\n-static ppl_Pointset_Powerset_C_Polyhedron_t\n-map_dr_into_dep_poly (graphite_dim_t dim,\n-\t\t      ppl_Pointset_Powerset_C_Polyhedron_t dr,\n-\t\t      graphite_dim_t cut0, graphite_dim_t cut1,\n-\t\t      graphite_dim_t nb0, graphite_dim_t nb1)\n-{\n-  ppl_dimension_type pdim;\n-  ppl_dimension_type *map;\n-  ppl_Pointset_Powerset_C_Polyhedron_t res;\n-  ppl_dimension_type i;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&res, dr);\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (res, &pdim);\n-\n-  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, pdim);\n-\n-  /* First mapping: move 'g' vector to right position.  */\n-  for (i = 0; i < cut0; i++)\n-    map[i] = i;\n-\n-  for (i = cut0; i < cut1; i++)\n-    map[i] = pdim - cut1 + i;\n-\n-  for (i = cut1; i < pdim; i++)\n-    map[i] = cut0 + i - cut1;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (res, map, pdim);\n-  free (map);\n-\n-  /* After swapping 's' and 'g' vectors, we have to update a new cut.  */\n-  cut1 = pdim - cut1 + cut0;\n-\n-  ppl_insert_dimensions_pointset (res, 0, nb0);\n-  ppl_insert_dimensions_pointset (res, nb0 + cut0, nb1);\n-  ppl_insert_dimensions_pointset (res, nb0 + nb1 + cut1,\n-\t\t\t\t  dim - nb0 - nb1 - pdim);\n-\n   return res;\n }\n \n-/* Builds subscript equality constraints.  */\n+/* Returns all the memory must writes in SCOP.  */\n \n-static ppl_Pointset_Powerset_C_Polyhedron_t\n-dr_equality_constraints (graphite_dim_t dim,\n-\t\t         graphite_dim_t pos, graphite_dim_t nb_subscripts)\n+static isl_union_map *\n+scop_get_must_writes (scop_p scop, VEC (poly_bb_p, heap) *pbbs)\n {\n-  ppl_Polyhedron_t eqs;\n-  ppl_Pointset_Powerset_C_Polyhedron_t res;\n-  graphite_dim_t i;\n-\n-  ppl_new_C_Polyhedron_from_space_dimension (&eqs, dim, 0);\n+  int i, j;\n+  poly_bb_p pbb;\n+  poly_dr_p pdr;\n+  isl_space *space = isl_set_get_space (scop->context);\n+  isl_union_map *res = isl_union_map_empty (space);\n \n-  for (i = 0; i < nb_subscripts; i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, pbbs, i, pbb)\n     {\n-      ppl_Constraint_t cstr\n-\t= ppl_build_relation (dim, pos + i, pos + i + nb_subscripts,\n-\t\t\t      0, PPL_CONSTRAINT_TYPE_EQUAL);\n-      ppl_Polyhedron_add_constraint (eqs, cstr);\n-      ppl_delete_Constraint (cstr);\n+      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), j, pdr)\n+\tif (pdr_write_p (pdr))\n+\t  res = isl_union_map_add_map (res, add_pdr_constraints (pdr, pbb));\n     }\n \n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&res, eqs);\n-  ppl_delete_Polyhedron (eqs);\n   return res;\n }\n \n-/* Builds scheduling inequality constraints: when DIRECTION is\n-   1 builds a GE constraint,\n-   0 builds an EQ constraint,\n-   -1 builds a LE constraint.\n-   DIM is the dimension of the scheduling space.\n-   POS and POS + OFFSET are the dimensions that are related.  */\n-\n-static ppl_Pointset_Powerset_C_Polyhedron_t\n-build_pairwise_scheduling (graphite_dim_t dim,\n-\t\t\t   graphite_dim_t pos,\n-\t\t\t   graphite_dim_t offset,\n-\t\t\t   int direction)\n-{\n-  ppl_Pointset_Powerset_C_Polyhedron_t res;\n-  ppl_Polyhedron_t equalities;\n-  ppl_Constraint_t cstr;\n-  graphite_dim_t a = pos;\n-  graphite_dim_t b = pos + offset;\n+/* Returns all the memory may writes in SCOP.  */\n \n-  ppl_new_C_Polyhedron_from_space_dimension (&equalities, dim, 0);\n+static isl_union_map *\n+scop_get_may_writes (scop_p scop, VEC (poly_bb_p, heap) *pbbs)\n+{\n+  int i, j;\n+  poly_bb_p pbb;\n+  poly_dr_p pdr;\n+  isl_space *space = isl_set_get_space (scop->context);\n+  isl_union_map *res = isl_union_map_empty (space);\n \n-  switch (direction)\n+  FOR_EACH_VEC_ELT (poly_bb_p, pbbs, i, pbb)\n     {\n-    case 1:\n-      /* Builds \"a + 1 <= b.  */\n-      cstr = ppl_build_relation (dim, a, b, 1,\n-\t\t\t\t PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL);\n-      break;\n-\n-    case 0:\n-      /* Builds \"a = b.  */\n-      cstr = ppl_build_relation (dim, a, b, 0,\n-\t\t\t\t PPL_CONSTRAINT_TYPE_EQUAL);\n-      break;\n-\n-    case -1:\n-      /* Builds \"a >= b + 1.  */\n-      cstr = ppl_build_relation (dim, a, b, -1,\n-\t\t\t\t PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n+      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), j, pdr)\n+\tif (pdr_may_write_p (pdr))\n+\t  res = isl_union_map_add_map (res, add_pdr_constraints (pdr, pbb));\n     }\n \n-  ppl_Polyhedron_add_constraint (equalities, cstr);\n-  ppl_delete_Constraint (cstr);\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&res, equalities);\n-  ppl_delete_Polyhedron (equalities);\n   return res;\n }\n \n-/* Add to a non empty polyhedron BAG the precedence constraints for\n-   the lexicographical comparison of time vectors in BAG following the\n-   lexicographical order.  DIM is the dimension of the polyhedron BAG.\n-   TDIM is the number of loops common to the two statements that are\n-   compared lexicographically, i.e. the number of loops containing\n-   both statements.  OFFSET is the number of dimensions needed to\n-   represent the first statement, i.e. dimT1 + dimI1 in the layout of\n-   the BAG polyhedron: T1|I1|T2|I2|S1|S2|G.  When DIRECTION is set to\n-   1, compute the direct dependence from PDR1 to PDR2, and when\n-   DIRECTION is -1, compute the reversed dependence relation, from\n-   PDR2 to PDR1.  */\n-\n-static ppl_Pointset_Powerset_C_Polyhedron_t\n-build_lexicographical_constraint (ppl_Pointset_Powerset_C_Polyhedron_t bag,\n-\t\t\t\t  graphite_dim_t dim,\n-\t\t\t\t  graphite_dim_t tdim,\n-\t\t\t\t  graphite_dim_t offset,\n-\t\t\t\t  int direction)\n-{\n-  graphite_dim_t i;\n-  ppl_Pointset_Powerset_C_Polyhedron_t res, lex;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (&res, dim, 1);\n-\n-  lex = build_pairwise_scheduling (dim, 0, offset, direction);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (lex, bag);\n-\n-  if (!ppl_powerset_is_empty (lex))\n-    ppl_Pointset_Powerset_C_Polyhedron_upper_bound_assign (res, lex);\n+/* Returns all the original schedules in SCOP.  */\n \n-  ppl_delete_Pointset_Powerset_C_Polyhedron (lex);\n+static isl_union_map *\n+scop_get_original_schedule (scop_p scop, VEC (poly_bb_p, heap) *pbbs)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  isl_space *space = isl_set_get_space (scop->context);\n+  isl_union_map *res = isl_union_map_empty (space);\n \n-  for (i = 0; i < tdim - 1; i++)\n+  FOR_EACH_VEC_ELT (poly_bb_p, pbbs, i, pbb)\n     {\n-      ppl_Pointset_Powerset_C_Polyhedron_t sceq;\n-\n-      sceq = build_pairwise_scheduling (dim, i, offset, 0);\n-      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (bag, sceq);\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (sceq);\n-\n-      if (ppl_powerset_is_empty (bag))\n-\tbreak;\n-\n-      lex = build_pairwise_scheduling (dim, i + 1, offset, direction);\n-      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (lex, bag);\n-\n-      if (!ppl_powerset_is_empty (lex))\n-\tppl_Pointset_Powerset_C_Polyhedron_upper_bound_assign (res, lex);\n-\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (lex);\n+      res = isl_union_map_add_map\n+\t(res, constrain_domain (isl_map_copy (pbb->schedule),\n+\t\t\t\tisl_set_copy (pbb->domain)));\n     }\n \n   return res;\n }\n \n-/* Build the dependence polyhedron for data references PDR1 and PDR2.\n-   The layout of the dependence polyhedron is:\n-\n-   T1|I1|T2|I2|S1|S2|G\n-\n-   with\n-   | T1 and T2 the scattering dimensions for PDR1 and PDR2\n-   | I1 and I2 the iteration domains\n-   | S1 and S2 the subscripts\n-   | G the global parameters.\n-\n-   When DIRECTION is set to 1, compute the direct dependence from PDR1\n-   to PDR2, and when DIRECTION is -1, compute the reversed dependence\n-   relation, from PDR2 to PDR1.  */\n-\n-static ppl_Pointset_Powerset_C_Polyhedron_t\n-dependence_polyhedron (poly_dr_p pdr1, poly_dr_p pdr2,\n-\t\t       int direction, bool original_scattering_p)\n-{\n-  poly_bb_p pbb1 = PDR_PBB (pdr1);\n-  poly_bb_p pbb2 = PDR_PBB (pdr2);\n-  scop_p scop = PBB_SCOP (pbb1);\n-  graphite_dim_t tdim1 = original_scattering_p ?\n-    pbb_nb_scattering_orig (pbb1) : pbb_nb_scattering_transform (pbb1);\n-  graphite_dim_t tdim2 = original_scattering_p ?\n-    pbb_nb_scattering_orig (pbb2) : pbb_nb_scattering_transform (pbb2);\n-  graphite_dim_t ddim1 = pbb_dim_iter_domain (pbb1);\n-  graphite_dim_t ddim2 = pbb_dim_iter_domain (pbb2);\n-  graphite_dim_t sdim1 = PDR_NB_SUBSCRIPTS (pdr1) + 1;\n-  graphite_dim_t sdim2 = PDR_NB_SUBSCRIPTS (pdr2) + 1;\n-  graphite_dim_t gdim = scop_nb_params (scop);\n-  graphite_dim_t dim1 = pdr_dim (pdr1);\n-  graphite_dim_t dim2 = pdr_dim (pdr2);\n-  graphite_dim_t dim = tdim1 + tdim2 + dim1 + dim2 - gdim;\n-  ppl_Pointset_Powerset_C_Polyhedron_t res;\n-  ppl_Pointset_Powerset_C_Polyhedron_t idr1, idr2;\n-  ppl_Pointset_Powerset_C_Polyhedron_t sc1, sc2, dreq;\n-  ppl_Pointset_Powerset_C_Polyhedron_t lex;\n-\n-  gcc_assert (PBB_SCOP (pbb1) == PBB_SCOP (pbb2));\n-\n-  combine_context_id_scat (&sc1, pbb1, original_scattering_p);\n-  combine_context_id_scat (&sc2, pbb2, original_scattering_p);\n-\n-  ppl_insert_dimensions_pointset (sc1, tdim1 + ddim1,\n-\t\t\t\t  tdim2 + ddim2 + sdim1 + sdim2);\n-\n-  ppl_insert_dimensions_pointset (sc2, 0, tdim1 + ddim1);\n-  ppl_insert_dimensions_pointset (sc2, tdim1 + ddim1 + tdim2 + ddim2,\n-\t\t\t\t  sdim1 + sdim2);\n-\n-  idr1 = map_dr_into_dep_poly (dim, PDR_ACCESSES (pdr1), ddim1, ddim1 + gdim,\n-\t\t\t       tdim1, tdim2 + ddim2);\n-  idr2 = map_dr_into_dep_poly (dim, PDR_ACCESSES (pdr2), ddim2, ddim2 + gdim,\n-\t\t\t       tdim1 + ddim1 + tdim2, sdim1);\n-\n-  /* Now add the subscript equalities.  */\n-  dreq = dr_equality_constraints (dim, tdim1 + ddim1 + tdim2 + ddim2, sdim1);\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (&res, dim, 0);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, sc1);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, sc2);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, idr1);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, idr2);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (res, dreq);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (sc1);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (sc2);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (idr1);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (idr2);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (dreq);\n-\n-  if (ppl_powerset_is_empty (res))\n-    return NULL;\n-\n-  lex = build_lexicographical_constraint (res, dim, MIN (tdim1, tdim2),\n-\t\t\t\t\t  tdim1 + ddim1, direction);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (res);\n-\n-  return lex;\n-}\n-\n-/* Build the dependence polyhedron for data references PDR1 and PDR2.\n-   If possible use already cached information.\n-\n-   When DIRECTION is set to 1, compute the direct dependence from PDR1\n-   to PDR2, and when DIRECTION is -1, compute the reversed dependence\n-   relation, from PDR2 to PDR1.  */\n+/* Returns all the transformed schedules in SCOP.  */\n \n-static poly_ddr_p\n-new_poly_ddr (poly_dr_p pdr1, poly_dr_p pdr2,\n-\t      int direction, bool original_scattering_p)\n+static isl_union_map *\n+scop_get_transformed_schedule (scop_p scop, VEC (poly_bb_p, heap) *pbbs)\n {\n-  PTR *x = NULL;\n-  poly_ddr_p res;\n-  bool may_alias;\n-\n-  /* Return the PDDR from the cache if it already has been computed.  */\n-  if (original_scattering_p)\n-    {\n-      struct poly_ddr tmp;\n-      scop_p scop = PBB_SCOP (PDR_PBB (pdr1));\n-\n-      tmp.source = pdr1;\n-      tmp.sink = pdr2;\n-      x = htab_find_slot (SCOP_ORIGINAL_PDDRS (scop),\n-                          &tmp, INSERT);\n-\n-      if (x && *x)\n-\treturn (poly_ddr_p) *x;\n-    }\n-\n-  res = XNEW (struct poly_ddr);\n-  PDDR_SOURCE (res) = pdr1;\n-  PDDR_SINK (res) = pdr2;\n-  PDDR_DDP (res) = NULL;\n-  PDDR_ORIGINAL_SCATTERING_P (res) = original_scattering_p;\n-  PDDR_KIND (res) = unknown_dependence;\n-\n-  may_alias = poly_drs_may_alias_p (pdr1, pdr2);\n-\n-  if (!(pdr_read_p (pdr1) && pdr_read_p (pdr2))\n-      && PDR_BASE_OBJECT_SET (pdr1) != PDR_BASE_OBJECT_SET (pdr2)\n-      && may_alias)\n-    PDDR_KIND (res) = unknown_dependence;\n+  int i;\n+  poly_bb_p pbb;\n+  isl_space *space = isl_set_get_space (scop->context);\n+  isl_union_map *res = isl_union_map_empty (space);\n \n-  else if (!(pdr_read_p (pdr1) && pdr_read_p (pdr2))\n-\t   && same_pdr_p (pdr1, pdr2)\n-\t   && may_alias)\n+  FOR_EACH_VEC_ELT (poly_bb_p, pbbs, i, pbb)\n     {\n-      PDDR_DDP (res) = dependence_polyhedron (pdr1, pdr2, direction,\n-\t\t\t\t\t      original_scattering_p);\n-      if (PDDR_DDP (res))\n-\tPDDR_KIND (res) = has_dependence;\n-      else\n-\tPDDR_KIND (res) = no_dependence;\n+      res = isl_union_map_add_map\n+\t(res, constrain_domain (isl_map_copy (pbb->transformed),\n+\t\t\t\tisl_set_copy (pbb->domain)));\n     }\n-  else\n-    PDDR_KIND (res) = no_dependence;\n-\n-  if (original_scattering_p)\n-    *x = res;\n \n   return res;\n }\n \n-/* Free the data dependence relation poly_ddr_p P.  */\n-\n-void\n-free_poly_ddr (void *p)\n-{\n-  poly_ddr_p pddr = (poly_ddr_p) p;\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (PDDR_DDP (pddr));\n-  free (pddr);\n-}\n-\n-/* Return true when the data dependence relation between the data\n-   references PDR1 belonging to PBB1 and PDR2 is part of a\n-   reduction.  */\n+/* Helper function used on each MAP of a isl_union_map.  Computes the\n+   maximal output dimension.  */\n \n-static inline bool\n-reduction_dr_1 (poly_bb_p pbb1, poly_dr_p pdr1, poly_dr_p pdr2)\n+static int\n+max_number_of_out_dimensions (__isl_take isl_map *map, void *user)\n {\n-  int i;\n-  poly_dr_p pdr;\n+  int global_max = *((int *) user);\n+  isl_space *space = isl_map_get_space (map);\n+  int nb_out = isl_space_dim (space, isl_dim_out);\n \n-  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), i, pdr)\n-    if (PDR_TYPE (pdr) == PDR_WRITE\n-\t&& same_pdr_p (pdr, pdr1) && same_pdr_p (pdr, pdr2))\n-      return true;\n+  if (global_max < nb_out)\n+    *((int *) user) = nb_out;\n \n-  return false;\n+  isl_map_free (map);\n+  isl_space_free (space);\n+  return 0;\n }\n \n-/* Return true when the data dependence relation between the data\n-   references PDR1 belonging to PBB1 and PDR2 belonging to PBB2 is\n-   part of a reduction.  */\n+/* Extends the output dimension of MAP to MAX dimensions.  */\n \n-static inline bool\n-reduction_dr_p (poly_dr_p pdr1, poly_dr_p pdr2)\n+static __isl_give isl_map *\n+extend_map (__isl_take isl_map *map, int max)\n {\n-  poly_bb_p pbb1 = PDR_PBB (pdr1);\n-  poly_bb_p pbb2 = PDR_PBB (pdr2);\n+  isl_space *space = isl_map_get_space (map);\n+  int n = isl_space_dim (space, isl_dim_out);\n \n-  if (PBB_IS_REDUCTION (pbb1))\n-    return reduction_dr_1 (pbb1, pdr1, pdr2);\n-\n-  if (PBB_IS_REDUCTION (pbb2))\n-    return reduction_dr_1 (pbb2, pdr2, pdr1);\n-\n-  return false;\n+  isl_space_free (space);\n+  return isl_map_add_dims (map, isl_dim_out, max - n);\n }\n \n-/* Returns true when the PBB_TRANSFORMED_SCATTERING functions of PBB1\n-   and PBB2 respect the data dependences of PBB_ORIGINAL_SCATTERING\n-   functions.  */\n-\n-static bool\n-graphite_legal_transform_dr (poly_dr_p pdr1, poly_dr_p pdr2)\n-{\n-  ppl_Pointset_Powerset_C_Polyhedron_t po, pt;\n-  graphite_dim_t ddim1, otdim1, otdim2, ttdim1, ttdim2;\n-  ppl_Pointset_Powerset_C_Polyhedron_t po_temp;\n-  ppl_dimension_type pdim;\n-  bool is_empty_p;\n-  poly_ddr_p opddr, tpddr;\n-  poly_bb_p pbb1, pbb2;\n-\n-  if (reduction_dr_p (pdr1, pdr2))\n-    return true;\n-\n-  /* We build the reverse dependence relation for the transformed\n-     scattering, such that when we intersect it with the original PO,\n-     we get an empty intersection when the transform is legal:\n-     i.e. the transform should reverse no dependences, and so PT, the\n-     reversed transformed PDDR, should have no constraint from PO.  */\n-  opddr = new_poly_ddr (pdr1, pdr2, 1, true);\n-\n-  if (PDDR_KIND (opddr) == unknown_dependence)\n-    return false;\n-\n-    /* There are no dependences between PDR1 and PDR2 in the original\n-       version of the program, or after the transform, so the\n-       transform is legal.  */\n-  if (pddr_is_empty (opddr))\n-    return true;\n-\n-  tpddr = new_poly_ddr (pdr1, pdr2, -1, false);\n-\n-  if (PDDR_KIND (tpddr) == unknown_dependence)\n-    {\n-      free_poly_ddr (tpddr);\n-      return false;\n-    }\n-\n-  if (pddr_is_empty (tpddr))\n-    {\n-      free_poly_ddr (tpddr);\n-      return true;\n-    }\n+/* Structure used to pass parameters to extend_schedule_1.  */\n \n-  po = PDDR_DDP (opddr);\n-  pt = PDDR_DDP (tpddr);\n-\n-  /* Copy PO into PO_TEMP, such that PO is not destroyed.  PO is\n-     stored in a cache and should not be modified or freed.  */\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (po, &pdim);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (&po_temp,\n-\t\t\t\t\t\t\t       pdim, 0);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (po_temp, po);\n-\n-  /* Extend PO and PT to have the same dimensions.  */\n-  pbb1 = PDR_PBB (pdr1);\n-  pbb2 = PDR_PBB (pdr2);\n-  ddim1 = pbb_dim_iter_domain (pbb1);\n-  otdim1 = pbb_nb_scattering_orig (pbb1);\n-  otdim2 = pbb_nb_scattering_orig (pbb2);\n-  ttdim1 = pbb_nb_scattering_transform (pbb1);\n-  ttdim2 = pbb_nb_scattering_transform (pbb2);\n-  ppl_insert_dimensions_pointset (po_temp, otdim1, ttdim1);\n-  ppl_insert_dimensions_pointset (po_temp, otdim1 + ttdim1 + ddim1 + otdim2,\n-\t\t\t\t  ttdim2);\n-  ppl_insert_dimensions_pointset (pt, 0, otdim1);\n-  ppl_insert_dimensions_pointset (pt, otdim1 + ttdim1 + ddim1, otdim2);\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (po_temp, pt);\n-  is_empty_p = ppl_powerset_is_empty (po_temp);\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (po_temp);\n-  free_poly_ddr (tpddr);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nloop carries dependency.\\n\");\n-\n-  return is_empty_p;\n-}\n+struct extend_schedule_str {\n+  int max;\n+  isl_union_map *umap;\n+};\n \n-/* Return true when the data dependence relation for PBB1 and PBB2 is\n-   part of a reduction.  */\n+/* Helper function for extend_schedule.  */\n \n-static inline bool\n-reduction_ddr_p (poly_bb_p pbb1, poly_bb_p pbb2)\n+static int\n+extend_schedule_1 (__isl_take isl_map *map, void *user)\n {\n-  return pbb1 == pbb2 && PBB_IS_REDUCTION (pbb1);\n+  struct extend_schedule_str *str = (struct extend_schedule_str *) user;\n+  str->umap = isl_union_map_add_map (str->umap, extend_map (map, str->max));\n+  return 0;\n }\n \n-/* Iterates over the data references of PBB1 and PBB2 and detect\n-   whether the transformed schedule is correct.  */\n+/* Return a relation that has uniform output dimensions.  */\n \n-static bool\n-graphite_legal_transform_bb (poly_bb_p pbb1, poly_bb_p pbb2)\n+__isl_give isl_union_map *\n+extend_schedule (__isl_take isl_union_map *x)\n {\n-  int i, j;\n-  poly_dr_p pdr1, pdr2;\n+  int max = 0;\n+  int res;\n+  struct extend_schedule_str str;\n \n-  if (!PBB_PDR_DUPLICATES_REMOVED (pbb1))\n-    pbb_remove_duplicate_pdrs (pbb1);\n+  res = isl_union_map_foreach_map (x, max_number_of_out_dimensions, (void *) &max);\n+  gcc_assert (res == 0);\n \n-  if (!PBB_PDR_DUPLICATES_REMOVED (pbb2))\n-    pbb_remove_duplicate_pdrs (pbb2);\n+  str.max = max;\n+  str.umap = isl_union_map_empty (isl_union_map_get_space (x));\n+  res = isl_union_map_foreach_map (x, extend_schedule_1, (void *) &str);\n+  gcc_assert (res == 0);\n \n-  if (reduction_ddr_p (pbb1, pbb2))\n-    return true;\n-\n-  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), i, pdr1)\n-    FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), j, pdr2)\n-      if (!graphite_legal_transform_dr (pdr1, pdr2))\n-\treturn false;\n-\n-  return true;\n+  isl_union_map_free (x);\n+  return str.umap;\n }\n \n-/* Iterates over the SCOP and detect whether the transformed schedule\n-   is correct.  */\n+/* Applies SCHEDULE to the in and out dimensions of the dependences\n+   DEPS and return the resulting relation.  */\n \n-bool\n-graphite_legal_transform (scop_p scop)\n+static isl_map *\n+apply_schedule_on_deps (__isl_keep isl_union_map *schedule,\n+\t\t\t__isl_keep isl_union_map *deps)\n {\n-  int i, j;\n-  poly_bb_p pbb1, pbb2;\n+  isl_map *x;\n+  isl_union_map *ux, *trans;\n \n-  timevar_push (TV_GRAPHITE_DATA_DEPS);\n-\n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n-    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n-      if (!graphite_legal_transform_bb (pbb1, pbb2))\n-\t{\n-\t  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n-\t  return false;\n-\t}\n+  trans = isl_union_map_copy (schedule);\n+  trans = extend_schedule (trans);\n+  ux = isl_union_map_copy (deps);\n+  ux = isl_union_map_apply_domain (ux, isl_union_map_copy (trans));\n+  ux = isl_union_map_apply_range (ux, trans);\n+  x = isl_map_from_union_map (ux);\n \n-  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n-  return true;\n+  return x;\n }\n \n-/* Returns TRUE when the dependence polyhedron between PDR1 and\n-   PDR2 represents a loop carried dependence at level LEVEL.  */\n+/* Return true when SCHEDULE does not violate the data DEPS: that is\n+   when the intersection of LEX with the DEPS transformed by SCHEDULE\n+   is empty.  LEX is the relation in which the outputs occur before\n+   the inputs.  */\n \n static bool\n-graphite_carried_dependence_level_k (poly_dr_p pdr1, poly_dr_p pdr2,\n-\t\t\t\t     int level)\n+no_violations (__isl_keep isl_union_map *schedule,\n+\t       __isl_keep isl_union_map *deps)\n {\n-  ppl_Pointset_Powerset_C_Polyhedron_t po;\n-  ppl_Pointset_Powerset_C_Polyhedron_t eqpp;\n-  poly_bb_p pbb = PDR_PBB (pdr1);\n-  graphite_dim_t tdim1 = pbb_nb_scattering_transform (pbb);\n-  graphite_dim_t ddim1 = pbb_dim_iter_domain (pbb);\n-  ppl_dimension_type dim;\n-  bool empty_p;\n-  poly_ddr_p pddr = new_poly_ddr (pdr1, pdr2, 1, false);\n-  graphite_dim_t pos;\n-\n-  if (PDDR_KIND (pddr) == unknown_dependence)\n-    {\n-      free_poly_ddr (pddr);\n-      return true;\n-    }\n+  bool res;\n+  isl_space *space;\n+  isl_map *lex, *x;\n \n-  if (pddr_is_empty (pddr))\n-    {\n-      free_poly_ddr (pddr);\n-      return false;\n-    }\n-\n-  po = PDDR_DDP (pddr);\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (po, &dim);\n-  pos = psct_dynamic_dim (pbb, level);\n-  eqpp = build_pairwise_scheduling (dim, pos, tdim1 + ddim1, 1);\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (eqpp, po);\n-  empty_p = ppl_powerset_is_empty (eqpp);\n+  if (isl_union_map_is_empty (deps))\n+    return true;\n \n-  ppl_delete_Pointset_Powerset_C_Polyhedron (eqpp);\n-  free_poly_ddr (pddr);\n+  x = apply_schedule_on_deps (schedule, deps);\n+  space = isl_map_get_space (x);\n+  space = isl_space_range (space);\n+  lex = isl_map_lex_ge (space);\n+  x = isl_map_intersect (x, lex);\n+  res = isl_map_is_empty (x);\n \n-  return !empty_p;\n+  isl_map_free (x);\n+  return res;\n }\n \n-/* Check data dependency between PBB1 and PBB2 at level LEVEL.  */\n+/* Return true when DEPS is non empty and the intersection of LEX with\n+   the DEPS transformed by SCHEDULE is non empty.  LEX is the relation\n+   in which all the inputs before DEPTH occur at the same time as the\n+   output, and the input at DEPTH occurs before output.  */\n \n-bool\n-dependency_between_pbbs_p (poly_bb_p pbb1, poly_bb_p pbb2, int level)\n+static bool\n+carries_deps (__isl_keep isl_union_map *schedule,\n+\t      __isl_keep isl_union_map *deps,\n+\t      int depth)\n {\n-  int i, j;\n-  poly_dr_p pdr1, pdr2;\n+  bool res;\n+  int idx, i;\n+  isl_space *space;\n+  isl_map *lex, *x;\n+  isl_constraint *ineq;\n \n-  timevar_push (TV_GRAPHITE_DATA_DEPS);\n-\n-  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), i, pdr1)\n-    FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), j, pdr2)\n-      if (graphite_carried_dependence_level_k (pdr1, pdr2, level))\n-\t{\n-\t  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n-\t  return true;\n-\t}\n+  if (isl_union_map_is_empty (deps))\n+    return false;\n \n-  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n-  return false;\n+  x = apply_schedule_on_deps (schedule, deps);\n+  space = isl_map_get_space (x);\n+  space = isl_space_range (space);\n+  lex = isl_map_lex_le (space);\n+  space = isl_map_get_space (x);\n+  ineq = isl_inequality_alloc (isl_local_space_from_space (space));\n+\n+  idx = 2 * depth + 1;\n+  for (i = 0; i < idx; i++)\n+    lex = isl_map_equate (lex, isl_dim_in, i, isl_dim_out, i);\n+\n+  /* in + 1 <= out  */\n+  ineq = isl_constraint_set_coefficient_si (ineq, isl_dim_out, idx, 1);\n+  ineq = isl_constraint_set_coefficient_si (ineq, isl_dim_in, idx, -1);\n+  ineq = isl_constraint_set_constant_si (ineq, -1);\n+  lex = isl_map_add_constraint (lex, ineq);\n+  x = isl_map_intersect (x, lex);\n+  res = !isl_map_is_empty (x);\n+\n+  isl_map_free (x);\n+  return res;\n }\n \n-/* When ORIG is true, pretty print to FILE all the original data\n-   dependences of SCoP in DOT format, otherwise print the transformed\n-   data deps.  */\n+/* Subtract from the RAW, WAR, and WAW dependences those relations\n+   that have been marked as belonging to an associative commutative\n+   reduction.  */\n \n static void\n-dot_deps_stmt_2 (FILE *file, scop_p scop, bool orig)\n+subtract_commutative_associative_deps (scop_p scop,\n+\t\t\t\t       VEC (poly_bb_p, heap) *pbbs,\n+\t\t\t\t       isl_union_map *original,\n+\t\t\t\t       isl_union_map **must_raw,\n+\t\t\t\t       isl_union_map **may_raw,\n+\t\t\t\t       isl_union_map **must_raw_no_source,\n+\t\t\t\t       isl_union_map **may_raw_no_source,\n+\t\t\t\t       isl_union_map **must_war,\n+\t\t\t\t       isl_union_map **may_war,\n+\t\t\t\t       isl_union_map **must_war_no_source,\n+\t\t\t\t       isl_union_map **may_war_no_source,\n+\t\t\t\t       isl_union_map **must_waw,\n+\t\t\t\t       isl_union_map **may_waw,\n+\t\t\t\t       isl_union_map **must_waw_no_source,\n+\t\t\t\t       isl_union_map **may_waw_no_source)\n {\n-  int i, j, k, l;\n-  poly_bb_p pbb1, pbb2;\n-  poly_dr_p pdr1, pdr2;\n+  int i, j;\n+  poly_bb_p pbb;\n+  poly_dr_p pdr;\n+  isl_space *space = isl_set_get_space (scop->context);\n \n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n-    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n+  FOR_EACH_VEC_ELT (poly_bb_p, pbbs, i, pbb)\n+    if (PBB_IS_REDUCTION (pbb))\n       {\n-\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n-\t  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n-\t    {\n-\t      poly_ddr_p pddr = new_poly_ddr (pdr1, pdr2, 1, orig);\n-\n-\t      if (!pddr_is_empty (pddr))\n-\t\t{\n-\t\t  fprintf (file, orig ? \"OS%d -> OS%d\\n\" : \"TS%d -> TS%d\\n\",\n-\t\t\t   pbb_index (pbb1), pbb_index (pbb2));\n-\n-\t\t  free_poly_ddr (pddr);\n-\t\t  goto done;\n-\t\t}\n-\n-\t      free_poly_ddr (pddr);\n-\t    }\n-      done:;\n+\tint res;\n+\tisl_union_map *r = isl_union_map_empty (isl_space_copy (space));\n+\tisl_union_map *must_w = isl_union_map_empty (isl_space_copy (space));\n+\tisl_union_map *may_w = isl_union_map_empty (isl_space_copy (space));\n+\tisl_union_map *all_w;\n+\tisl_union_map *empty;\n+\tisl_union_map *x_must_raw;\n+\tisl_union_map *x_may_raw;\n+\tisl_union_map *x_must_raw_no_source;\n+\tisl_union_map *x_may_raw_no_source;\n+\tisl_union_map *x_must_war;\n+\tisl_union_map *x_may_war;\n+\tisl_union_map *x_must_war_no_source;\n+\tisl_union_map *x_may_war_no_source;\n+\tisl_union_map *x_must_waw;\n+\tisl_union_map *x_may_waw;\n+\tisl_union_map *x_must_waw_no_source;\n+\tisl_union_map *x_may_waw_no_source;\n+\n+\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), j, pdr)\n+\t  if (pdr_read_p (pdr))\n+\t    r = isl_union_map_add_map (r, add_pdr_constraints (pdr, pbb));\n+\n+\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), j, pdr)\n+\t  if (pdr_write_p (pdr))\n+\t    must_w = isl_union_map_add_map (must_w,\n+\t\t\t\t\t    add_pdr_constraints (pdr, pbb));\n+\n+\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), j, pdr)\n+\t  if (pdr_may_write_p (pdr))\n+\t    may_w = isl_union_map_add_map (may_w,\n+\t\t\t\t\t   add_pdr_constraints (pdr, pbb));\n+\n+\tall_w = isl_union_map_union\n+\t  (isl_union_map_copy (must_w), isl_union_map_copy (may_w));\n+\tempty = isl_union_map_empty (isl_union_map_get_space (all_w));\n+\n+\tres = isl_union_map_compute_flow (isl_union_map_copy (r),\n+\t\t\t\t\t  isl_union_map_copy (must_w),\n+\t\t\t\t\t  isl_union_map_copy (may_w),\n+\t\t\t\t\t  isl_union_map_copy (original),\n+\t\t\t\t\t  &x_must_raw, &x_may_raw,\n+\t\t\t\t\t  &x_must_raw_no_source,\n+\t\t\t\t\t  &x_may_raw_no_source);\n+\tgcc_assert (res == 0);\n+\tres = isl_union_map_compute_flow (isl_union_map_copy (all_w),\n+\t\t\t\t\t  r, empty,\n+\t\t\t\t\t  isl_union_map_copy (original),\n+\t\t\t\t\t  &x_must_war, &x_may_war,\n+\t\t\t\t\t  &x_must_war_no_source,\n+\t\t\t\t\t  &x_may_war_no_source);\n+\tgcc_assert (res == 0);\n+\tres = isl_union_map_compute_flow (all_w, must_w, may_w,\n+\t\t\t\t\t  isl_union_map_copy (original),\n+\t\t\t\t\t  &x_must_waw, &x_may_waw,\n+\t\t\t\t\t  &x_must_waw_no_source,\n+\t\t\t\t\t  &x_may_waw_no_source);\n+\tgcc_assert (res == 0);\n+\n+\t*must_raw = isl_union_map_subtract (*must_raw, x_must_raw);\n+\t*may_raw = isl_union_map_subtract (*may_raw, x_may_raw);\n+\t*must_raw_no_source = isl_union_map_subtract (*must_raw_no_source,\n+\t\t\t\t\t\t      x_must_raw_no_source);\n+\t*may_raw_no_source = isl_union_map_subtract (*may_raw_no_source,\n+\t\t\t\t\t\t     x_may_raw_no_source);\n+\t*must_war = isl_union_map_subtract (*must_war, x_must_war);\n+\t*may_war = isl_union_map_subtract (*may_war, x_may_war);\n+\t*must_war_no_source = isl_union_map_subtract (*must_war_no_source,\n+\t\t\t\t\t\t      x_must_war_no_source);\n+\t*may_war_no_source = isl_union_map_subtract (*may_war_no_source,\n+\t\t\t\t\t\t     x_may_war_no_source);\n+\t*must_waw = isl_union_map_subtract (*must_waw, x_must_waw);\n+\t*may_waw = isl_union_map_subtract (*may_waw, x_may_waw);\n+\t*must_waw_no_source = isl_union_map_subtract (*must_waw_no_source,\n+\t\t\t\t\t\t      x_must_waw_no_source);\n+\t*may_waw_no_source = isl_union_map_subtract (*may_waw_no_source,\n+\t\t\t\t\t\t     x_may_waw_no_source);\n       }\n+\n+  isl_union_map_free (original);\n+  isl_space_free (space);\n }\n \n-/* Pretty print to FILE all the data dependences of SCoP in DOT\n-   format.  */\n+/* Compute the original data dependences in SCOP for all the reads and\n+   writes in PBBS.  */\n \n static void\n-dot_deps_stmt_1 (FILE *file, scop_p scop)\n+compute_deps (scop_p scop, VEC (poly_bb_p, heap) *pbbs,\n+\t      isl_union_map **must_raw,\n+\t      isl_union_map **may_raw,\n+\t      isl_union_map **must_raw_no_source,\n+\t      isl_union_map **may_raw_no_source,\n+\t      isl_union_map **must_war,\n+\t      isl_union_map **may_war,\n+\t      isl_union_map **must_war_no_source,\n+\t      isl_union_map **may_war_no_source,\n+\t      isl_union_map **must_waw,\n+\t      isl_union_map **may_waw,\n+\t      isl_union_map **must_waw_no_source,\n+\t      isl_union_map **may_waw_no_source)\n {\n-  fputs (\"digraph all {\\n\", file);\n-\n-  dot_deps_stmt_2 (file, scop, true);\n-  dot_deps_stmt_2 (file, scop, false);\n-\n-  fputs (\"}\\n\\n\", file);\n+  isl_union_map *reads = scop_get_reads (scop, pbbs);\n+  isl_union_map *must_writes = scop_get_must_writes (scop, pbbs);\n+  isl_union_map *may_writes = scop_get_may_writes (scop, pbbs);\n+  isl_union_map *all_writes = isl_union_map_union\n+    (isl_union_map_copy (must_writes), isl_union_map_copy (may_writes));\n+  isl_space *space = isl_union_map_get_space (all_writes);\n+  isl_union_map *empty = isl_union_map_empty (space);\n+  isl_union_map *original = scop_get_original_schedule (scop, pbbs);\n+  int res;\n+\n+  res = isl_union_map_compute_flow (isl_union_map_copy (reads),\n+\t\t\t\t    isl_union_map_copy (must_writes),\n+\t\t\t\t    isl_union_map_copy (may_writes),\n+\t\t\t\t    isl_union_map_copy (original),\n+\t\t\t\t    must_raw, may_raw, must_raw_no_source,\n+\t\t\t\t    may_raw_no_source);\n+  gcc_assert (res == 0);\n+  res = isl_union_map_compute_flow (isl_union_map_copy (all_writes),\n+\t\t\t\t    reads, empty,\n+\t\t\t\t    isl_union_map_copy (original),\n+\t\t\t\t    must_war, may_war, must_war_no_source,\n+\t\t\t\t    may_war_no_source);\n+  gcc_assert (res == 0);\n+  res = isl_union_map_compute_flow (all_writes, must_writes, may_writes,\n+\t\t\t\t    isl_union_map_copy (original),\n+\t\t\t\t    must_waw, may_waw, must_waw_no_source,\n+\t\t\t\t    may_waw_no_source);\n+  gcc_assert (res == 0);\n+\n+  subtract_commutative_associative_deps\n+    (scop, pbbs, original,\n+     must_raw, may_raw, must_raw_no_source, may_raw_no_source,\n+     must_war, may_war, must_war_no_source, may_war_no_source,\n+     must_waw, may_waw, must_waw_no_source, may_waw_no_source);\n }\n \n-/* When ORIG is true, pretty print to FILE all the original data\n-   dependences of SCoP in DOT format, otherwise print the transformed\n-   data deps.  */\n+/* Given a TRANSFORM, check whether it respects the original\n+   dependences in SCOP.  Returns true when TRANSFORM is a safe\n+   transformation.  */\n \n-static void\n-dot_deps_2 (FILE *file, scop_p scop, bool orig)\n+static bool\n+transform_is_safe (scop_p scop, isl_union_map *transform)\n {\n-  int i, j, k, l;\n-  poly_bb_p pbb1, pbb2;\n-  poly_dr_p pdr1, pdr2;\n-\n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb1)\n-    FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), j, pbb2)\n-      FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb1), k, pdr1)\n-\tFOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb2), l, pdr2)\n-          {\n-\t    poly_ddr_p pddr = new_poly_ddr (pdr1, pdr2, 1, orig);\n-\n-\t    if (!pddr_is_empty (pddr))\n-\t      fprintf (file, orig\n-\t\t       ? \"OS%d_D%d -> OS%d_D%d\\n\" : \"TS%d_D%d -> TS%d_D%d\\n\",\n-\t\t       pbb_index (pbb1), PDR_ID (pdr1),\n-\t\t       pbb_index (pbb2), PDR_ID (pdr2));\n-\n-\t    free_poly_ddr (pddr);\n-\t  }\n+  bool res;\n+\n+  if (!scop->must_raw)\n+    compute_deps (scop, SCOP_BBS (scop),\n+\t\t  &scop->must_raw, &scop->may_raw,\n+\t\t  &scop->must_raw_no_source, &scop->may_raw_no_source,\n+\t\t  &scop->must_war, &scop->may_war,\n+\t\t  &scop->must_war_no_source, &scop->may_war_no_source,\n+\t\t  &scop->must_waw, &scop->may_waw,\n+\t\t  &scop->must_waw_no_source, &scop->may_waw_no_source);\n+\n+  res = (no_violations (transform, scop->must_raw)\n+\t && no_violations (transform, scop->may_raw)\n+\t && no_violations (transform, scop->must_war)\n+\t && no_violations (transform, scop->may_war)\n+\t && no_violations (transform, scop->must_waw)\n+\t && no_violations (transform, scop->may_waw));\n+\n+  isl_union_map_free (transform);\n+  return res;\n }\n \n-/* Pretty print to FILE all the data dependences of SCoP in DOT\n-   format.  */\n+/* Return true when the SCOP transformed schedule is correct.  */\n \n-static void\n-dot_deps_1 (FILE *file, scop_p scop)\n+bool\n+graphite_legal_transform (scop_p scop)\n {\n-  fputs (\"digraph all {\\n\", file);\n+  int res;\n+  isl_union_map *transform;\n \n-  dot_deps_2 (file, scop, true);\n-  dot_deps_2 (file, scop, false);\n+  timevar_push (TV_GRAPHITE_DATA_DEPS);\n+  transform = scop_get_transformed_schedule (scop, SCOP_BBS (scop));\n+  res = transform_is_safe (scop, transform);\n+  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n \n-  fputs (\"}\\n\\n\", file);\n+  return res;\n }\n \n-/* Display all the data dependences in SCoP using dotty.  */\n+/* Return true when the loop at DEPTH carries dependences.  BODY is\n+   the body of the loop.  */\n \n-DEBUG_FUNCTION void\n-dot_deps (scop_p scop)\n+static bool\n+loop_level_carries_dependences (scop_p scop, VEC (poly_bb_p, heap) *body,\n+\t\t\t\tint depth)\n {\n-  /* When debugging, enable the following code.  This cannot be used\n-     in production compilers because it calls \"system\".  */\n-#if 0\n-  FILE *stream = fopen (\"/tmp/scopdeps.dot\", \"w\");\n-  gcc_assert (stream);\n-\n-  dot_deps_1 (stream, scop);\n-  fclose (stream);\n-\n-  system (\"dotty /tmp/scopdeps.dot &\");\n-#else\n-  dot_deps_1 (stderr, scop);\n-#endif\n+  isl_union_map *transform = scop_get_transformed_schedule (scop, body);\n+  isl_union_map *must_raw, *may_raw;\n+  isl_union_map *must_war, *may_war;\n+  isl_union_map *must_waw, *may_waw;\n+  int res;\n+\n+  compute_deps (scop, body,\n+\t\t&must_raw, &may_raw, NULL, NULL,\n+\t\t&must_war, &may_war, NULL, NULL,\n+\t\t&must_waw, &may_waw, NULL, NULL);\n+\n+  res = (carries_deps (transform, must_raw, depth)\n+\t || carries_deps (transform, may_raw, depth)\n+\t || carries_deps (transform, must_war, depth)\n+\t || carries_deps (transform, may_war, depth)\n+\t || carries_deps (transform, must_waw, depth)\n+\t || carries_deps (transform, may_waw, depth));\n+\n+  isl_union_map_free (transform);\n+  isl_union_map_free (must_raw);\n+  isl_union_map_free (may_raw);\n+  isl_union_map_free (must_war);\n+  isl_union_map_free (may_war);\n+  isl_union_map_free (must_waw);\n+  isl_union_map_free (may_waw);\n+  return res;\n }\n \n-/* Display all the statement dependences in SCoP using dotty.  */\n+/* Returns true when the loop L at level DEPTH is parallel.\n+   BB_PBB_MAPPING is a map between a basic_block and its related\n+   poly_bb_p.  */\n \n-DEBUG_FUNCTION void\n-dot_deps_stmt (scop_p scop)\n+bool\n+loop_is_parallel_p (loop_p loop, htab_t bb_pbb_mapping, int depth)\n {\n-  /* When debugging, enable the following code.  This cannot be used\n-     in production compilers because it calls \"system\".  */\n-#if 0\n-  FILE *stream = fopen (\"/tmp/scopdeps.dot\", \"w\");\n-  gcc_assert (stream);\n-\n-  dot_deps_stmt_1 (stream, scop);\n-  fclose (stream);\n-\n-  system (\"dotty /tmp/scopdeps.dot &\");\n-#else\n-  dot_deps_stmt_1 (stderr, scop);\n-#endif\n+  bool dependences;\n+  scop_p scop;\n+  VEC (poly_bb_p, heap) *body = VEC_alloc (poly_bb_p, heap, 3);\n+\n+  timevar_push (TV_GRAPHITE_DATA_DEPS);\n+  scop = get_loop_body_pbbs (loop, bb_pbb_mapping, &body);\n+  dependences = loop_level_carries_dependences (scop, body, depth);\n+  VEC_free (poly_bb_p, heap, body);\n+  timevar_pop (TV_GRAPHITE_DATA_DEPS);\n+\n+  return !dependences;\n }\n \n #endif"}, {"sha": "5f2a4a03acc75be8b1a5cd98e0506fd85ad58781", "filename": "gcc/graphite-dependences.h", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-dependences.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-dependences.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.h?ref=6886e4444f193c399b96cb1f64a24b9673cf3149", "patch": "@@ -1,64 +0,0 @@\n-/* Graphite polyhedral representation.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Konrad Trifunovic <konrad.trifunovic@gmail.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_GRAPHITE_DEPENDENCES_H\n-#define GCC_GRAPHITE_DEPENDENCES_H\n-\n-extern bool graphite_legal_transform (scop_p);\n-extern bool dependency_between_pbbs_p (poly_bb_p, poly_bb_p, int);\n-\n-enum poly_dependence_kind {\n-  unknown_dependence,\n-  no_dependence,\n-  has_dependence\n-};\n-\n-/* Represents a Polyhedral Data Dependence Relation.  */\n-\n-typedef struct poly_ddr\n-{\n-  /* Source and sink data references of the dependence.  */\n-  poly_dr_p source, sink;\n-\n-  /* Data dependence polyhedron.  */\n-  ppl_Pointset_Powerset_C_Polyhedron_t ddp;\n-\n-  enum poly_dependence_kind kind;\n-\n-  /* True when the dependence relation is for the original scattering.  */\n-  bool original_scattering_p;\n-\n-} *poly_ddr_p;\n-\n-#define PDDR_SOURCE(PDDR) (PDDR->source)\n-#define PDDR_SINK(PDDR) (PDDR->sink)\n-#define PDDR_DDP(PDDR) (PDDR->ddp)\n-#define PDDR_KIND(PDDR) (PDDR->kind)\n-#define PDDR_ORIGINAL_SCATTERING_P(PDDR) (PDDR->original_scattering_p)\n-\n-extern int eq_poly_ddr_p (const void *, const void *);\n-extern hashval_t hash_poly_ddr_p (const void *);\n-extern void free_poly_ddr (void *);\n-extern void dot_deps (scop_p);\n-extern void dot_deps_stmt (scop_p);\n-extern void print_pddr (FILE *, poly_ddr_p);\n-extern void debug_pddr (poly_ddr_p);\n-\n-#endif"}, {"sha": "dbef03a042225b66105ef8853658dc386cfefe61", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 168, "deletions": 235, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,7 +1,7 @@\n /* Interchange heuristics and transform for loop interchange on\n    polyhedral representation.\n \n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n    Harsha Jagasia <harsha.jagasia@amd.com>.\n \n@@ -20,7 +20,19 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n+\n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/aff.h>\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <isl/ilp.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree-flow.h\"\n@@ -32,10 +44,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sese.h\"\n \n #ifdef HAVE_cloog\n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n \n+/* XXX isl rewrite following comment */\n /* Builds a linear expression, of dimension DIM, representing PDR's\n    memory access:\n \n@@ -53,87 +64,90 @@ along with GCC; see the file COPYING3.  If not see\n    where the expression itself is:\n    c_0 * s_0 + c_1 * s_1 + ... c_n * s_n.  */\n \n-static ppl_Linear_Expression_t\n-build_linearized_memory_access (ppl_dimension_type offset, poly_dr_p pdr)\n+static isl_constraint *\n+build_linearized_memory_access (isl_map *map, poly_dr_p pdr)\n {\n-  ppl_Linear_Expression_t res;\n-  ppl_Linear_Expression_t le;\n-  ppl_dimension_type i;\n-  ppl_dimension_type first = pdr_subscript_dim (pdr, 0);\n-  ppl_dimension_type last = pdr_subscript_dim (pdr, PDR_NB_SUBSCRIPTS (pdr));\n-  mpz_t size, sub_size;\n-  graphite_dim_t dim = offset + pdr_dim (pdr);\n-\n-  ppl_new_Linear_Expression_with_dimension (&res, dim);\n-\n-  mpz_init (size);\n-  mpz_set_si (size, 1);\n-  mpz_init (sub_size);\n-  mpz_set_si (sub_size, 1);\n-\n-  for (i = last - 1; i >= first; i--)\n+  isl_constraint *res;\n+  isl_local_space *ls = isl_local_space_from_space (isl_map_get_space (map));\n+  unsigned offset, nsubs;\n+  int i;\n+  isl_int size, subsize;\n+\n+  res = isl_equality_alloc (ls);\n+  isl_int_init (size);\n+  isl_int_set_ui (size, 1);\n+  isl_int_init (subsize);\n+  isl_int_set_ui (subsize, 1);\n+\n+  nsubs = isl_set_dim (pdr->extent, isl_dim_set);\n+  /* -1 for the already included L dimension.  */\n+  offset = isl_map_dim (map, isl_dim_out) - 1 - nsubs;\n+  res = isl_constraint_set_coefficient_si (res, isl_dim_out, offset + nsubs, -1);\n+  /* Go through all subscripts from last to first.  First dimension\n+     is the alias set, ignore it.  */\n+  for (i = nsubs - 1; i >= 1; i--)\n     {\n-      ppl_set_coef_gmp (res, i + offset, size);\n+      isl_space *dc;\n+      isl_aff *aff;\n \n-      ppl_new_Linear_Expression_with_dimension (&le, dim - offset);\n-      ppl_set_coef (le, i, 1);\n-      ppl_max_for_le_pointset (PDR_ACCESSES (pdr), le, sub_size);\n-      mpz_mul (size, size, sub_size);\n-      ppl_delete_Linear_Expression (le);\n+      res = isl_constraint_set_coefficient (res, isl_dim_out, offset + i, size);\n+\n+      dc = isl_set_get_space (pdr->extent);\n+      aff = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n+      aff = isl_aff_set_coefficient_si (aff, isl_dim_in, i, 1);\n+      isl_set_max (pdr->extent, aff, &subsize);\n+      isl_aff_free (aff);\n+      isl_int_mul (size, size, subsize);\n     }\n \n-  mpz_clear (sub_size);\n-  mpz_clear (size);\n+  isl_int_clear (subsize);\n+  isl_int_clear (size);\n+\n   return res;\n }\n \n-/* Builds a partial difference equations and inserts them\n-   into pointset powerset polyhedron P.  Polyhedron is assumed\n-   to have the format: T|I|T'|I'|G|S|S'|l1|l2.\n-\n-   TIME_DEPTH is the time dimension w.r.t. which we are\n-   differentiating.\n-   OFFSET represents the number of dimensions between\n-   columns t_{time_depth} and t'_{time_depth}.\n-   DIM_SCTR is the number of scattering dimensions.  It is\n-   essentially the dimensionality of the T vector.\n-\n-   The following equations are inserted into the polyhedron P:\n-    | t_1 = t_1'\n-    | ...\n-    | t_{time_depth-1} = t'_{time_depth-1}\n-    | t_{time_depth} = t'_{time_depth} + 1\n-    | t_{time_depth+1} = t'_{time_depth + 1}\n-    | ...\n-    | t_{dim_sctr} = t'_{dim_sctr}.  */\n+/* Set STRIDE to the stride of PDR in memory by advancing by one in\n+   the loop at DEPTH.  */\n \n static void\n-build_partial_difference (ppl_Pointset_Powerset_C_Polyhedron_t *p,\n-                          ppl_dimension_type time_depth,\n-                          ppl_dimension_type offset,\n-                          ppl_dimension_type dim_sctr)\n+pdr_stride_in_loop (mpz_t stride, graphite_dim_t depth, poly_dr_p pdr)\n {\n-  ppl_Constraint_t new_cstr;\n-  ppl_Linear_Expression_t le;\n-  ppl_dimension_type i;\n-  ppl_dimension_type dim;\n-  ppl_Pointset_Powerset_C_Polyhedron_t temp;\n+  poly_bb_p pbb = PDR_PBB (pdr);\n+  isl_map *map;\n+  isl_set *set;\n+  isl_aff *aff;\n+  isl_space *dc;\n+  isl_constraint *lma, *c;\n+  isl_int islstride;\n+  graphite_dim_t time_depth;\n+  unsigned offset, nt;\n+  unsigned i;\n+  /* XXX isl rewrite following comments.  */\n+  /* Builds a partial difference equations and inserts them\n+     into pointset powerset polyhedron P.  Polyhedron is assumed\n+     to have the format: T|I|T'|I'|G|S|S'|l1|l2.\n+\n+     TIME_DEPTH is the time dimension w.r.t. which we are\n+     differentiating.\n+     OFFSET represents the number of dimensions between\n+     columns t_{time_depth} and t'_{time_depth}.\n+     DIM_SCTR is the number of scattering dimensions.  It is\n+     essentially the dimensionality of the T vector.\n+\n+     The following equations are inserted into the polyhedron P:\n+     | t_1 = t_1'\n+     | ...\n+     | t_{time_depth-1} = t'_{time_depth-1}\n+     | t_{time_depth} = t'_{time_depth} + 1\n+     | t_{time_depth+1} = t'_{time_depth + 1}\n+     | ...\n+     | t_{dim_sctr} = t'_{dim_sctr}.  */\n \n   /* Add the equality: t_{time_depth} = t'_{time_depth} + 1.\n      This is the core part of this alogrithm, since this\n      constraint asks for the memory access stride (difference)\n      between two consecutive points in time dimensions.  */\n \n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (*p, &dim);\n-  ppl_new_Linear_Expression_with_dimension (&le, dim);\n-  ppl_set_coef (le, time_depth, 1);\n-  ppl_set_coef (le, time_depth + offset, -1);\n-  ppl_set_inhomogeneous (le, 1);\n-  ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n-  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (*p, new_cstr);\n-  ppl_delete_Linear_Expression (le);\n-  ppl_delete_Constraint (new_cstr);\n-\n   /* Add equalities:\n      | t1 = t1'\n      | ...\n@@ -149,156 +163,80 @@ build_partial_difference (ppl_Pointset_Powerset_C_Polyhedron_t *p,\n      is stripmined dimension, and the other dimension corresponds\n      to the point loop inside stripmined dimension.  */\n \n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron (&temp, *p);\n-\n-  for (i = 0; i < dim_sctr; i++)\n+  /* pdr->accesses:    [P1..nb_param,I1..nb_domain]->[a,S1..nb_subscript]\n+          ??? [P] not used for PDRs?\n+     pdr->extent:      [a,S1..nb_subscript]\n+     pbb->domain:      [P1..nb_param,I1..nb_domain]\n+     pbb->transformed: [P1..nb_param,I1..nb_domain]->[T1..Tnb_sctr]\n+          [T] includes local vars (currently unused)\n+     \n+     First we create [P,I] -> [T,a,S].  */\n+  \n+  map = isl_map_flat_range_product (isl_map_copy (pbb->transformed),\n+\t\t\t\t    isl_map_copy (pdr->accesses));\n+  /* Add a dimension for L: [P,I] -> [T,a,S,L].*/\n+  map = isl_map_add_dims (map, isl_dim_out, 1);\n+  /* Build a constraint for \"lma[S] - L == 0\", effectively calculating\n+     L in terms of subscripts.  */\n+  lma = build_linearized_memory_access (map, pdr);\n+  /* And add it to the map, so we now have:\n+     [P,I] -> [T,a,S,L] : lma([S]) == L.  */\n+  map = isl_map_add_constraint (map, lma);\n+\n+  /* Then we create  [P,I,P',I'] -> [T,a,S,L,T',a',S',L'].  */\n+  map = isl_map_flat_product (map, isl_map_copy (map));\n+\n+  /* Now add the equality T[time_depth] == T'[time_depth]+1.  This will\n+     force L' to be the linear address at T[time_depth] + 1. */\n+  time_depth = psct_dynamic_dim (pbb, depth);\n+  /* Length of [a,S] plus [L] ...  */\n+  offset = 1 + isl_map_dim (pdr->accesses, isl_dim_out);\n+  /* ... plus [T].  */\n+  offset += isl_map_dim (pbb->transformed, isl_dim_out);\n+\n+  c = isl_equality_alloc (isl_local_space_from_space (isl_map_get_space (map)));\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, time_depth, 1);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out,\n+\t\t\t\t\t offset + time_depth, -1);\n+  c = isl_constraint_set_constant_si (c, 1);\n+  map = isl_map_add_constraint (map, c);\n+\n+  /* Now we equate most of the T/T' elements (making PITaSL nearly\n+     the same is (PITaSL)', except for one dimension, namely for 'depth'\n+     (an index into [I]), after translating to index into [T].  Take care\n+     to not produce an empty map, which indicates we wanted to equate\n+     two dimensions that are already coupled via the above time_depth\n+     dimension.  Happens with strip mining where several scatter dimension\n+     are interdependend.  */\n+  /* Length of [T].  */\n+  nt = pbb_nb_scattering_transform (pbb) + pbb_nb_local_vars (pbb);\n+  for (i = 0; i < nt; i++)\n     if (i != time_depth)\n       {\n-        ppl_new_Linear_Expression_with_dimension (&le, dim);\n-        ppl_set_coef (le, i, 1);\n-        ppl_set_coef (le, i + offset, -1);\n-        ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n-        ppl_Pointset_Powerset_C_Polyhedron_add_constraint (temp, new_cstr);\n-\n-        if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (temp))\n-          {\n-            ppl_delete_Pointset_Powerset_C_Polyhedron (temp);\n-            ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron (&temp, *p);\n-          }\n-        else\n-          ppl_Pointset_Powerset_C_Polyhedron_add_constraint (*p, new_cstr);\n-        ppl_delete_Linear_Expression (le);\n-        ppl_delete_Constraint (new_cstr);\n+\tisl_map *temp = isl_map_equate (isl_map_copy (map),\n+\t\t\t\t\tisl_dim_out, i,\n+\t\t\t\t\tisl_dim_out, offset + i);\n+\tif (isl_map_is_empty (temp))\n+\t  isl_map_free (temp);\n+\telse\n+\t  {\n+\t    isl_map_free (map);\n+\t    map = temp;\n+\t  }\n       }\n \n-  ppl_delete_Pointset_Powerset_C_Polyhedron (temp);\n-}\n-\n-\n-/* Set STRIDE to the stride of PDR in memory by advancing by one in\n-   the loop at DEPTH.  */\n-\n-static void\n-pdr_stride_in_loop (mpz_t stride, graphite_dim_t depth, poly_dr_p pdr)\n-{\n-  ppl_dimension_type time_depth;\n-  ppl_Linear_Expression_t le, lma;\n-  ppl_Constraint_t new_cstr;\n-  ppl_dimension_type i, *map;\n-  ppl_Pointset_Powerset_C_Polyhedron_t p1, p2, sctr;\n-  graphite_dim_t nb_subscripts = PDR_NB_SUBSCRIPTS (pdr) + 1;\n-  poly_bb_p pbb = PDR_PBB (pdr);\n-  ppl_dimension_type offset = pbb_nb_scattering_transform (pbb)\n-                              + pbb_nb_local_vars (pbb)\n-                              + pbb_dim_iter_domain (pbb);\n-  ppl_dimension_type offsetg = offset + pbb_nb_params (pbb);\n-  ppl_dimension_type dim_sctr = pbb_nb_scattering_transform (pbb)\n-                                + pbb_nb_local_vars (pbb);\n-  ppl_dimension_type dim_L1 = offset + offsetg + 2 * nb_subscripts;\n-  ppl_dimension_type dim_L2 = offset + offsetg + 2 * nb_subscripts + 1;\n-  ppl_dimension_type new_dim = offset + offsetg + 2 * nb_subscripts + 2;\n-\n-  /* The resulting polyhedron should have the following format:\n-     T|I|T'|I'|G|S|S'|l1|l2\n-     where:\n-     | T = t_1..t_{dim_sctr}\n-     | I = i_1..i_{dim_iter_domain}\n-     | T'= t'_1..t'_{dim_sctr}\n-     | I'= i'_1..i'_{dim_iter_domain}\n-     | G = g_1..g_{nb_params}\n-     | S = s_1..s_{nb_subscripts}\n-     | S'= s'_1..s'_{nb_subscripts}\n-     | l1 and l2 are scalars.\n-\n-     Some invariants:\n-     offset = dim_sctr + dim_iter_domain + nb_local_vars\n-     offsetg = dim_sctr + dim_iter_domain + nb_local_vars + nb_params.  */\n-\n-  /* Construct the T|I|0|0|G|0|0|0|0 part.  */\n-  {\n-    ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-      (&sctr, PBB_TRANSFORMED_SCATTERING (pbb));\n-    ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed\n-      (sctr, 2 * nb_subscripts + 2);\n-    ppl_insert_dimensions_pointset (sctr, offset, offset);\n-  }\n-\n-  /* Construct the 0|I|0|0|G|S|0|0|0 part.  */\n-  {\n-    ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-      (&p1, PDR_ACCESSES (pdr));\n-    ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed\n-      (p1, nb_subscripts + 2);\n-    ppl_insert_dimensions_pointset (p1, 0, dim_sctr);\n-    ppl_insert_dimensions_pointset (p1, offset, offset);\n-  }\n-\n-  /* Construct the 0|0|0|0|0|S|0|l1|0 part.  */\n-  {\n-    lma = build_linearized_memory_access (offset + dim_sctr, pdr);\n-    ppl_set_coef (lma, dim_L1, -1);\n-    ppl_new_Constraint (&new_cstr, lma, PPL_CONSTRAINT_TYPE_EQUAL);\n-    ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p1, new_cstr);\n-    ppl_delete_Linear_Expression (lma);\n-    ppl_delete_Constraint (new_cstr);\n-  }\n-\n-  /* Now intersect all the parts to get the polyhedron P1:\n-     T|I|0|0|G|0|0|0 |0\n-     0|I|0|0|G|S|0|0 |0\n-     0|0|0|0|0|S|0|l1|0\n-     ------------------\n-     T|I|0|0|G|S|0|l1|0.  */\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (p1, sctr);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (sctr);\n-\n-  /* Build P2, which would have the following form:\n-     0|0|T'|I'|G|0|S'|0|l2\n-\n-     P2 is built, by remapping the P1 polyhedron:\n-     T|I|0|0|G|S|0|l1|0\n-\n-     using the following mapping:\n-     T->T'\n-     I->I'\n-     S->S'\n-     l1->l2.  */\n-  {\n-    ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-      (&p2, p1);\n-\n-    map = ppl_new_id_map (new_dim);\n-\n-    /* TI -> T'I'.  */\n-    for (i = 0; i < offset; i++)\n-      ppl_interchange (map, i, i + offset);\n-\n-    /* l1 -> l2.  */\n-    ppl_interchange (map, dim_L1, dim_L2);\n-\n-    /* S -> S'.  */\n-    for (i = 0; i < nb_subscripts; i++)\n-      ppl_interchange (map, offset + offsetg + i,\n-\t\t       offset + offsetg + nb_subscripts + i);\n-\n-    ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (p2, map, new_dim);\n-    free (map);\n-  }\n-\n-  time_depth = psct_dynamic_dim (pbb, depth);\n-\n-  /* P1 = P1 inter P2.  */\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (p1, p2);\n-  build_partial_difference (&p1, time_depth, offset, dim_sctr);\n-\n-  /* Maximise the expression L2 - L1.  */\n-  {\n-    ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n-    ppl_set_coef (le, dim_L2, 1);\n-    ppl_set_coef (le, dim_L1, -1);\n-    ppl_max_for_le_pointset (p1, le, stride);\n-  }\n+  /* Now maximize the expression L' - L.  */\n+  set = isl_map_range (map);\n+  dc = isl_set_get_space (set);\n+  aff = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n+  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, offset - 1, -1);\n+  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, offset + offset - 1, 1);\n+  isl_int_init (islstride);\n+  isl_set_max (set, aff, &islstride);\n+  isl_int_get_gmp (islstride, stride);\n+  isl_int_clear (islstride);\n+  isl_aff_free (aff);\n+  isl_set_free (set);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -312,13 +250,8 @@ pdr_stride_in_loop (mpz_t stride, graphite_dim_t depth, poly_dr_p pdr)\n       mp_get_memory_functions (NULL, NULL, &gmp_free);\n       (*gmp_free) (str, strlen (str) + 1);\n     }\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (p1);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (p2);\n-  ppl_delete_Linear_Expression (le);\n }\n \n-\n /* Sets STRIDES to the sum of all the strides of the data references\n    accessed in LOOP at DEPTH.  */\n \n@@ -475,23 +408,23 @@ static void\n pbb_interchange_loop_depths (graphite_dim_t depth1, graphite_dim_t depth2,\n \t\t\t     poly_bb_p pbb)\n {\n-  ppl_dimension_type i, dim;\n-  ppl_dimension_type *map;\n-  ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n-  ppl_dimension_type dim1 = psct_dynamic_dim (pbb, depth1);\n-  ppl_dimension_type dim2 = psct_dynamic_dim (pbb, depth2);\n-\n-  ppl_Polyhedron_space_dimension (poly, &dim);\n-  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim);\n-\n-  for (i = 0; i < dim; i++)\n-    map[i] = i;\n-\n-  map[dim1] = dim2;\n-  map[dim2] = dim1;\n-\n-  ppl_Polyhedron_map_space_dimensions (poly, map, dim);\n-  free (map);\n+  unsigned i;\n+  unsigned dim1 = psct_dynamic_dim (pbb, depth1);\n+  unsigned dim2 = psct_dynamic_dim (pbb, depth2);\n+  isl_space *d = isl_map_get_space (pbb->transformed);\n+  isl_space *d1 = isl_space_range (d);\n+  unsigned n = isl_space_dim (d1, isl_dim_out);\n+  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);\n+  isl_map *x = isl_map_universe (d2);\n+\n+  x = isl_map_equate (x, isl_dim_in, dim1, isl_dim_out, dim2);\n+  x = isl_map_equate (x, isl_dim_in, dim2, isl_dim_out, dim1);\n+\n+  for (i = 0; i < n; i++)\n+    if (i != dim1 && i != dim2)\n+      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);\n+\n+  pbb->transformed = isl_map_apply_range (pbb->transformed, x);\n }\n \n /* Apply the interchange of loops at depths DEPTH1 and DEPTH2 to all"}, {"sha": "e3563a21a3fb59bc936f4537c1d5a4ec2d6219ab", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 196, "deletions": 837, "changes": 1033, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,5 +1,5 @@\n /* Graphite polyhedral representation.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n    Tobias Grosser <grosser@fim.uni-passau.de>.\n \n@@ -18,7 +18,20 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n+\n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <isl/constraint.h>\n+#include <isl/ilp.h>\n+#include <isl/aff.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"diagnostic-core.h\"\n@@ -32,14 +45,24 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sese.h\"\n \n #ifdef HAVE_cloog\n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n-#include \"graphite-dependences.h\"\n-#include \"graphite-cloog-util.h\"\n \n #define OPENSCOP_MAX_STRING 256\n \n+\n+/* Print to STDERR the GMP value VAL.  */\n+\n+DEBUG_FUNCTION void\n+debug_gmp_value (mpz_t val)\n+{\n+  char *str = mpz_get_str (0, 10, val);\n+  void (*gmp_free) (void *, size_t);\n+\n+  fprintf (stderr, \"%s\", str);\n+  mp_get_memory_functions (NULL, NULL, &gmp_free);\n+  (*gmp_free) (str, strlen (str) + 1);\n+}\n+\n /* Return the maximal loop depth in SCOP.  */\n \n int\n@@ -59,223 +82,6 @@ scop_max_loop_depth (scop_p scop)\n   return max_nb_loops;\n }\n \n-/* Extend the scattering matrix of PBB to MAX_SCATTERING scattering\n-   dimensions.  */\n-\n-static void\n-extend_scattering (poly_bb_p pbb, int max_scattering)\n-{\n-  ppl_dimension_type nb_old_dims, nb_new_dims;\n-  int nb_added_dims, i;\n-  ppl_Coefficient_t coef;\n-  mpz_t one;\n-\n-  nb_added_dims = max_scattering - pbb_nb_scattering_transform (pbb);\n-  mpz_init (one);\n-  mpz_set_si (one, 1);\n-  ppl_new_Coefficient (&coef);\n-  ppl_assign_Coefficient_from_mpz_t (coef, one);\n-\n-  gcc_assert (nb_added_dims >= 0);\n-\n-  nb_old_dims = pbb_nb_scattering_transform (pbb) + pbb_dim_iter_domain (pbb)\n-    + scop_nb_params (PBB_SCOP (pbb));\n-  nb_new_dims = nb_old_dims + nb_added_dims;\n-\n-  ppl_insert_dimensions (PBB_TRANSFORMED_SCATTERING (pbb),\n-\t\t\t pbb_nb_scattering_transform (pbb), nb_added_dims);\n-  PBB_NB_SCATTERING_TRANSFORM (pbb) += nb_added_dims;\n-\n-  /* Add identity matrix for the added dimensions.  */\n-  for (i = max_scattering - nb_added_dims; i < max_scattering; i++)\n-    {\n-      ppl_Constraint_t cstr;\n-      ppl_Linear_Expression_t expr;\n-\n-      ppl_new_Linear_Expression_with_dimension (&expr, nb_new_dims);\n-      ppl_Linear_Expression_add_to_coefficient (expr, i, coef);\n-      ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n-      ppl_Polyhedron_add_constraint (PBB_TRANSFORMED_SCATTERING (pbb), cstr);\n-      ppl_delete_Constraint (cstr);\n-      ppl_delete_Linear_Expression (expr);\n-    }\n-\n-  ppl_delete_Coefficient (coef);\n-  mpz_clear (one);\n-}\n-\n-/* All scattering matrices in SCOP will have the same number of scattering\n-   dimensions.  */\n-\n-int\n-unify_scattering_dimensions (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  graphite_dim_t max_scattering = 0;\n-\n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n-    max_scattering = MAX (pbb_nb_scattering_transform (pbb), max_scattering);\n-\n-  FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n-    extend_scattering (pbb, max_scattering);\n-\n-  return max_scattering;\n-}\n-\n-/* Print to FILE the pdr PH in OpenScop format.  NB_SUBSCRIPTS is the number\n-   of subscripts in PH, ALIAS_SET_DIM is the dimension of the alias set and\n-   NB_PARAMS is the number of parameters in PH.  */\n-\n-static void\n-openscop_print_pdr_polyhedron (FILE *file, ppl_const_Polyhedron_t ph,\n-\t\t\t       int nb_subscripts, int alias_set_dimension,\n-\t\t\t       int nb_params)\n-{\n-  int input, locals, output;\n-  ppl_dimension_type alias_set_dim = (ppl_dimension_type) alias_set_dimension;\n-  ppl_dimension_type sub_dim_last = alias_set_dim + nb_subscripts;\n-  ppl_dimension_type *map, i, ph_space_dim = sub_dim_last + 1;\n-  ppl_Polyhedron_t pph;\n-\n-  ppl_new_C_Polyhedron_from_C_Polyhedron (&pph, ph);\n-\n-  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, ph_space_dim);\n-\n-  for (i = 0; i < alias_set_dim - 1; i++)\n-    map[i] = nb_subscripts + 1 + i;\n-\n-  for (i = alias_set_dim - 1; i < sub_dim_last; i++)\n-    map[i] = i - alias_set_dim + 1;\n-\n-  ppl_Polyhedron_map_space_dimensions (pph, map, ph_space_dim - 1);\n-\n-  locals = 0;\n-  input = alias_set_dim - nb_params - 1;\n-\n-  /* According to OpenScop specification, the alias set column is a part of\n-     the output columns.  */\n-  output = nb_subscripts + 1;\n-\n-  openscop_print_polyhedron_matrix (file, pph, output, input, locals, nb_params);\n-}\n-\n-/* Print to FILE the powerset PDR.  NB_SUBSCRIPTS is the number of subscripts\n-   in PDR, ALIAS_SET_DIM is the dimension of the alias set in PDR and\n-   NB_PARAMS is the number of parameters in PDR.  */\n-\n-static void\n-openscop_print_pdr_powerset (FILE *file,\n-\t\t\t     ppl_Pointset_Powerset_C_Polyhedron_t ps,\n-\t\t\t     int nb_subscripts,\n-\t\t\t     int alias_set_dim,\n-\t\t\t     int nb_params)\n-{\n-  size_t nb_disjuncts;\n-  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_size (ps, &nb_disjuncts);\n-  fprintf (file, \"%d\\n\", (int) nb_disjuncts);\n-\n-  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (ps, it),\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (ps, end);\n-       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n-    {\n-      ppl_const_Polyhedron_t ph;\n-\n-      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n-      openscop_print_pdr_polyhedron (file, ph, nb_subscripts, alias_set_dim,\n-\t\t\t\t     nb_params);\n-    }\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n-}\n-\n-/* Print to FILE the powerset PS in its OpenScop matrix form.  */\n-\n-static void\n-openscop_print_powerset_matrix (FILE *file,\n-\t\t\t\tppl_Pointset_Powerset_C_Polyhedron_t ps,\n-\t\t\t\tint output, int input, int locals,\n-\t\t\t\tint params)\n-{\n-  size_t nb_disjuncts;\n-  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_size (ps, &nb_disjuncts);\n-  fprintf (file, \"%d\\n\", (int) nb_disjuncts);\n-\n-  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (ps, it),\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (ps, end);\n-       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n-    {\n-      ppl_const_Polyhedron_t ph;\n-\n-      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n-      openscop_print_polyhedron_matrix (file, ph, output, input, locals,\n-\t\t\t\t        params);\n-    }\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n-}\n-\n-/* Prints to FILE the scattering function of PBB in OpenScop format, at some\n-   VERBOSITY level.  */\n-\n-static void\n-openscop_print_scattering_function_1 (FILE *file, poly_bb_p pbb, int verbosity)\n-{\n-  graphite_dim_t i;\n-  ppl_const_Polyhedron_t ph;\n-\n-  if (verbosity > 0)\n-    {\n-      fprintf (file, \"# scattering bb_%d (\\n\", pbb_index (pbb));\n-      fprintf (file, \"#eq\");\n-\n-      for (i = 0; i < pbb_nb_scattering_transform (pbb); i++)\n-\tfprintf (file, \"     s%d\", (int) i);\n-\n-      for (i = 0; i < pbb_nb_local_vars (pbb); i++)\n-\tfprintf (file, \"    lv%d\", (int) i);\n-\n-      for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n-\tfprintf (file, \"     i%d\", (int) i);\n-\n-      for (i = 0; i < pbb_nb_params (pbb); i++)\n-\tfprintf (file, \"     p%d\", (int) i);\n-\n-      fprintf (file, \"    cst\\n\");\n-    }\n-\n-  /* Number of disjunct components.  Remove this when\n-     PBB_TRANSFORMED_SCATTERING will be a pointset_powerset.  */\n-  fprintf (file, \"1\\n\");\n-\n-  ph = PBB_TRANSFORMED_SCATTERING (pbb)\n-    ? PBB_TRANSFORMED_SCATTERING (pbb)\n-    : PBB_ORIGINAL_SCATTERING (pbb);\n-\n-  openscop_print_polyhedron_matrix (file, ph,\n-\t\t\t\t    pbb_nb_scattering_transform (pbb),\n-\t\t\t\t    pbb_dim_iter_domain (pbb),\n-\t\t\t\t    pbb_nb_local_vars (pbb),\n-\t\t\t\t    pbb_nb_params (pbb));\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"#)\\n\");\n-}\n-\n /* Prints to FILE the scattering function of PBB, at some VERBOSITY\n    level.  */\n \n@@ -304,12 +110,8 @@ print_scattering_function_1 (FILE *file, poly_bb_p pbb, int verbosity)\n       fprintf (file, \"    cst\\n\");\n     }\n \n-  /* Number of disjunct components.  Remove this when\n-     PBB_TRANSFORMED_SCATTERING will be a pointset_powerset.  */\n-  fprintf (file, \"1\\n\");\n-  ppl_print_polyhedron_matrix (file, PBB_TRANSFORMED_SCATTERING (pbb)\n-\t\t\t       ? PBB_TRANSFORMED_SCATTERING (pbb)\n-\t\t\t       : PBB_ORIGINAL_SCATTERING (pbb));\n+  fprintf (file, \"isl\\n\");\n+  print_isl_map (file, pbb->transformed ? pbb->transformed : pbb->schedule);\n \n   if (verbosity > 0)\n     fprintf (file, \"#)\\n\");\n@@ -324,8 +126,7 @@ print_scattering_function (FILE *file, poly_bb_p pbb, int verbosity)\n   if (!PBB_TRANSFORMED (pbb))\n     return;\n \n-  if (PBB_TRANSFORMED_SCATTERING (pbb)\n-      || PBB_ORIGINAL_SCATTERING (pbb))\n+  if (pbb->schedule || pbb->transformed)\n     {\n       if (verbosity > 0)\n \tfprintf (file, \"# Scattering function is provided\\n\");\n@@ -341,7 +142,7 @@ print_scattering_function (FILE *file, poly_bb_p pbb, int verbosity)\n       return;\n     }\n \n-  openscop_print_scattering_function_1 (file, pbb, verbosity);\n+  print_scattering_function_1 (file, pbb, verbosity);\n \n   if (verbosity > 0)\n     fprintf (file, \"# Scattering names are not provided\\n\");\n@@ -420,334 +221,12 @@ debug_iteration_domains (scop_p scop, int verbosity)\n   print_iteration_domains (stderr, scop, verbosity);\n }\n \n-/* Read N integer from FILE.  */\n-\n-int *\n-openscop_read_N_int (FILE *file, int N)\n-{\n-  char s[OPENSCOP_MAX_STRING];\n-  char *str;\n-  int i, *res = (int *) xmalloc (OPENSCOP_MAX_STRING * sizeof (int));\n-\n-  /* Skip blank and commented lines.  */\n-  while (fgets (s, sizeof s, file) == (char *) 0\n-\t || s[0] == '#'\n-\t || ISSPACE (s[0]))\n-    ;\n-\n-  str = s;\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      sscanf (str, \"%d\", &res[i]);\n-\n-      /* Jump the integer that was read.  */\n-      while ((*str) && !ISSPACE (*str) && (*str != '#'))\n-\tstr++;\n-\n-      /* Jump spaces.  */\n-      while ((*str) && ISSPACE (*str) && (*str != '#'))\n-\tstr++;\n-    }\n-\n-  return res;\n-}\n-\n-/* Read one integer from FILE.  */\n-\n-static int\n-openscop_read_one_int (FILE *file)\n-{\n-  int *x = openscop_read_N_int (file, 1);\n-  int res = *x;\n-\n-  free (x);\n-  return res;\n-}\n-\n-/* Read N string from FILE.  */\n-\n-static char *\n-openscop_read_N_string (FILE *file, int N)\n-{\n-  int count, i;\n-  char str[OPENSCOP_MAX_STRING];\n-  char *tmp = (char *) xmalloc (sizeof (char) * OPENSCOP_MAX_STRING);\n-  char *s = NULL;\n-\n-  /* Skip blank and commented lines.  */\n-  while (fgets (str, sizeof str, file) == (char *) 0\n-\t || str[0] == '#'\n-\t || ISSPACE (str[0]))\n-    ;\n-\n-  s = str;\n-  count = 0;\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      /* Read the first word.  */\n-      for (; (*s) && (!ISSPACE (*s)) && (*s != '#'); ++count)\n-        tmp[count] = *(s++);\n-\n-      tmp[count] = ' ';\n-      count++;\n-\n-      /* Jump spaces.  */\n-      while ((*s) && ISSPACE (*s) && (*s != '#'))\n-\ts++;\n-    }\n-\n-  tmp[count-1] = '\\0';\n-\n-  return tmp;\n-}\n-\n-/* Read one string from FILE.  */\n-\n-static char *\n-openscop_read_one_string (FILE *file)\n-{\n-  return openscop_read_N_string (file, 1);\n-}\n-\n-/* Read from FILE the powerset PS in its OpenScop matrix form.  OUTPUT is the\n-   number of output dimensions, INPUT is the number of input dimensions,\n-   LOCALS is the number of existentially quantified variables and PARAMS is\n-   the number of parameters.  */\n-\n-static void\n-openscop_read_powerset_matrix (FILE *file,\n-\t\t\t       ppl_Pointset_Powerset_C_Polyhedron_t *ps,\n-\t\t\t       int *output, int *input, int *locals,\n-\t\t\t       int *params)\n-{\n-  int nb_disjuncts, i;\n-\n-  nb_disjuncts = openscop_read_one_int (file);\n-\n-  for (i = 0; i < nb_disjuncts; i++)\n-    {\n-      ppl_Polyhedron_t ph;\n-\n-      openscop_read_polyhedron_matrix (file, &ph, output, input, locals,\n-\t\t\t\t       params);\n-      if (!ph)\n-        *ps = NULL;\n-      else if (i == 0)\n-        ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (ps, ph);\n-      else\n-        ppl_Pointset_Powerset_C_Polyhedron_add_disjunct (*ps, ph);\n-    }\n-}\n-\n-/* Read a scattering function from FILE and save it to PBB.  Return whether\n-   the scattering function was provided or not.  */\n-\n-static bool\n-graphite_read_scatt (FILE *file, poly_bb_p pbb)\n-{\n-  bool scattering_provided = false;\n-  int output, input, locals, params;\n-  ppl_Polyhedron_t newp;\n-\n-  if (openscop_read_one_int (file) > 0)\n-    {\n-      /* Read number of disjunct components.  */\n-      openscop_read_one_int (file);\n-\n-      /* Read scattering function.  */\n-      openscop_read_polyhedron_matrix (file, &newp, &output, &input,\n-\t\t\t\t       &locals, &params);\n-      store_scattering (PBB_SCOP (pbb));\n-      PBB_TRANSFORMED (pbb) = poly_scattering_new ();\n-      PBB_TRANSFORMED_SCATTERING (pbb) = newp;\n-      PBB_NB_LOCAL_VARIABLES (pbb) = locals;\n-\n-      /* New scattering dimension.  */\n-      PBB_NB_SCATTERING_TRANSFORM (pbb) = output;\n-\n-      scattering_provided = true;\n-    }\n-\n-  return scattering_provided;\n-}\n-\n-/* Read a scop file.  Return true if the scop is transformed.  */\n-\n-static bool\n-graphite_read_scop_file (FILE *file, scop_p scop)\n-{\n-  char *tmp, *language;\n-  size_t i, j, nb_statements, nbr, nbw;\n-  int input, output, locals, params;\n-  ppl_Pointset_Powerset_C_Polyhedron_t ps;\n-  poly_bb_p pbb;\n-  bool transform_done = false;\n-\n-  /* Ensure that the file is in OpenScop format.  */\n-  tmp = openscop_read_N_string (file, 2);\n-\n-  if (strcmp (tmp, \"SCoP 1\"))\n-    {\n-      error (\"the file is not in OpenScop format\");\n-      return false;\n-    }\n-\n-  free (tmp);\n-\n-  /* Read the language.  */\n-  language = openscop_read_one_string (file);\n-\n-  if (strcmp (language, \"Gimple\"))\n-    {\n-      error (\"the language is not recognized\");\n-      return false;\n-    }\n-\n-  free (language);\n-\n-  /* Read the context but do not use it.  */\n-  openscop_read_powerset_matrix (file, &ps, &input, &output, &locals, &params);\n-\n-  if ((size_t) params != scop->nb_params)\n-    {\n-      error (\"parameters number in the scop file is different from the\"\n-\t     \" internal scop parameter number\");\n-      return false;\n-    }\n-\n-  /* Read parameter names if provided.  */\n-  if (openscop_read_one_int (file))\n-    openscop_read_N_string (file, scop->nb_params);\n-\n-  nb_statements = openscop_read_one_int (file);\n-\n-  if (nb_statements != VEC_length (poly_bb_p, SCOP_BBS (scop)))\n-    {\n-      error (\"number of statements in the OpenScop file does not match\"\n-\t     \" the graphite internal statements number\");\n-      return false;\n-    }\n-\n-  for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)\n-    {\n-      /* Read iteration domain.  */\n-      openscop_read_powerset_matrix (file, &ps, &input, &output, &locals,\n-\t\t\t\t     &params);\n-\n-      /* Read scattering.  */\n-      transform_done = graphite_read_scatt (file, pbb);\n-\n-      /* Scattering names.  */\n-      openscop_read_one_int (file);\n-\n-      /* Read access functions.  */\n-      if (openscop_read_one_int (file) > 0)\n-\t{\n-\t  nbr = openscop_read_one_int (file);\n-\n-\t  /* Read access functions.  */\n-\t  for (j = 0; j < nbr; j++)\n-\t    openscop_read_powerset_matrix (file, &ps, &input, &output, &locals,\n-\t\t\t\t\t   &params);\n-\n-\t  nbw = openscop_read_one_int (file);\n-\n-\t  /* Write access functions.  */\n-\t  for (j = 0; j < nbw; j++)\n-\t    openscop_read_powerset_matrix (file, &ps, &input, &output, &locals,\n-\t\t\t\t\t   &params);\n-\t}\n-\n-      /* Statement body.  */\n-      openscop_read_one_int (file);\n-    }\n-\n-  return transform_done;\n-}\n-\n-/* Initialize and return a file that will be used to write a scop.  SCOP_NUMBER\n-   is a sequential number (identifier) used to differentiate scop files.\n-   Examples of the generated file names: dump_base_name.0.graphite,\n-   dump_base_name.1.graphite, dump_base_name.2.graphite, etc.  */\n-\n-static FILE *\n-init_graphite_out_file (int scop_number)\n-{\n-  FILE *graphite_out_file;\n-  int len = strlen (dump_base_name);\n-  char *dumpname = XNEWVEC (char, len + 25);\n-  char *s_scop_number = XNEWVEC (char, 15);\n-\n-  memcpy (dumpname, dump_base_name, len + 1);\n-  strip_off_ending (dumpname, len);\n-  sprintf (s_scop_number, \".%d\", scop_number);\n-  strcat (dumpname, s_scop_number);\n-  strcat (dumpname, \".graphite\");\n-  graphite_out_file = fopen (dumpname, \"w+b\");\n-\n-  if (graphite_out_file == 0)\n-    fatal_error (\"can%'t open %s for writing: %m\", dumpname);\n-\n-  free (dumpname);\n-\n-  return graphite_out_file;\n-}\n-\n-/* Open and return a file used for scop reading.  SCOP_NUMBER is a sequential\n-   number (identifier) used to differentiate scop files.  Examples of the\n-   generated file names: dump_base_name.0.graphite, dump_base_name.1.graphite,\n-   dump_base_name.2.graphite, etc.  */\n-\n-static FILE *\n-init_graphite_in_file (int scop_number)\n-{\n-  FILE *graphite_in_file;\n-  int len = strlen (dump_base_name);\n-  char *dumpname = XNEWVEC (char, len + 25);\n-  char *s_scop_number = XNEWVEC (char, 15);\n-\n-  memcpy (dumpname, dump_base_name, len + 1);\n-  strip_off_ending (dumpname, len);\n-  sprintf (s_scop_number, \".%d\", scop_number);\n-  strcat (dumpname, s_scop_number);\n-  strcat (dumpname, \".graphite\");\n-  graphite_in_file = fopen (dumpname, \"r+b\");\n-\n-  if (graphite_in_file == 0)\n-    fatal_error (\"can%'t open %s for reading: %m\", dumpname);\n-\n-  free (dumpname);\n-\n-  return graphite_in_file;\n-}\n-\n /* Apply graphite transformations to all the basic blocks of SCOP.  */\n \n bool\n apply_poly_transforms (scop_p scop)\n {\n   bool transform_done = false;\n-  FILE *graphite_file;\n-  static size_t file_scop_number = 0;\n-\n-  /* This feature is only enabled in the Graphite branch.  */\n-  if (0)\n-    {\n-      graphite_file = init_graphite_in_file (file_scop_number);\n-      transform_done |= graphite_read_scop_file (graphite_file, scop);\n-\n-      /* We cannot check for the legality of the transform here: there\n-\t are cases where graphite_legal_transform cannot determine the\n-\t dependence at compile time.  For an example, see the\n-\t explanation of why http://gcc.gnu.org/PR45450 is invalid.  */\n-      if (0 && !graphite_legal_transform (scop))\n-\tfatal_error (\"the graphite file read for scop %d does not contain a legal transform\",\n-\t\t     (int) file_scop_number);\n-\n-      file_scop_number++;\n-    }\n \n   /* Generate code even if we did not apply any real transformation.\n      This also allows to check the performance for the identity\n@@ -771,70 +250,17 @@ apply_poly_transforms (scop_p scop)\n \ttransform_done |= scop_do_interchange (scop);\n     }\n \n-  /* This feature is only enabled in the Graphite branch.  */\n-  if (0)\n-    {\n-      graphite_file = init_graphite_out_file (file_scop_number);\n-      print_scop (graphite_file, scop, 1);\n-      file_scop_number++;\n-    }\n-\n   return transform_done;\n }\n \n-/* Returns true when it PDR1 is a duplicate of PDR2: same PBB, and\n-   their ACCESSES, TYPE, and NB_SUBSCRIPTS are the same.  */\n-\n-static inline bool\n-can_collapse_pdrs (poly_dr_p pdr1, poly_dr_p pdr2)\n-{\n-  bool res;\n-  ppl_Pointset_Powerset_C_Polyhedron_t af1, af2, diff;\n-\n-  if (PDR_PBB (pdr1) != PDR_PBB (pdr2)\n-      || PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2)\n-      || PDR_TYPE (pdr1) != PDR_TYPE (pdr2))\n-    return false;\n-\n-  af1 = PDR_ACCESSES (pdr1);\n-  af2 = PDR_ACCESSES (pdr2);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&diff, af1);\n-  ppl_Pointset_Powerset_C_Polyhedron_difference_assign (diff, af2);\n-\n-  res = ppl_Pointset_Powerset_C_Polyhedron_is_empty (diff);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (diff);\n-  return res;\n-}\n-\n-/* Removes duplicated data references in PBB.  */\n-\n-void\n-pbb_remove_duplicate_pdrs (poly_bb_p pbb)\n-{\n-  int i, j;\n-  poly_dr_p pdr1, pdr2;\n-\n-  FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), i, pdr1)\n-    for (j = i + 1; VEC_iterate (poly_dr_p, PBB_DRS (pbb), j, pdr2); j++)\n-      if (can_collapse_pdrs (pdr1, pdr2))\n-\t{\n-\t  PDR_NB_REFS (pdr1) += PDR_NB_REFS (pdr2);\n-\t  free_poly_dr (pdr2);\n-\t  VEC_ordered_remove (poly_dr_p, PBB_DRS (pbb), j);\n-\t}\n-\n-  PBB_PDR_DUPLICATES_REMOVED (pbb) = true;\n-}\n-\n /* Create a new polyhedral data reference and add it to PBB.  It is\n    defined by its ACCESSES, its TYPE, and the number of subscripts\n    NB_SUBSCRIPTS.  */\n \n void\n new_poly_dr (poly_bb_p pbb, int dr_base_object_set,\n-\t     ppl_Pointset_Powerset_C_Polyhedron_t accesses,\n-\t     enum poly_dr_type type, void *cdr, graphite_dim_t nb_subscripts)\n+\t     enum poly_dr_type type, void *cdr, graphite_dim_t nb_subscripts,\n+\t     isl_map *acc, isl_set *extent)\n {\n   static int id = 0;\n   poly_dr_p pdr = XNEW (struct poly_dr);\n@@ -843,7 +269,8 @@ new_poly_dr (poly_bb_p pbb, int dr_base_object_set,\n   PDR_BASE_OBJECT_SET (pdr) = dr_base_object_set;\n   PDR_NB_REFS (pdr) = 1;\n   PDR_PBB (pdr) = pbb;\n-  PDR_ACCESSES (pdr) = accesses;\n+  pdr->accesses = acc;\n+  pdr->extent = extent;\n   PDR_TYPE (pdr) = type;\n   PDR_CDR (pdr) = cdr;\n   PDR_NB_SUBSCRIPTS (pdr) = nb_subscripts;\n@@ -855,7 +282,8 @@ new_poly_dr (poly_bb_p pbb, int dr_base_object_set,\n void\n free_poly_dr (poly_dr_p pdr)\n {\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (PDR_ACCESSES (pdr));\n+  isl_map_free (pdr->accesses);\n+  isl_set_free (pdr->extent);\n   XDELETE (pdr);\n }\n \n@@ -866,15 +294,17 @@ new_poly_bb (scop_p scop, void *black_box)\n {\n   poly_bb_p pbb = XNEW (struct poly_bb);\n \n-  PBB_DOMAIN (pbb) = NULL;\n+  pbb->domain = NULL;\n+  pbb->schedule = NULL;\n+  pbb->transformed = NULL;\n+  pbb->saved = NULL;\n   PBB_SCOP (pbb) = scop;\n   pbb_set_black_box (pbb, black_box);\n   PBB_TRANSFORMED (pbb) = NULL;\n   PBB_SAVED (pbb) = NULL;\n   PBB_ORIGINAL (pbb) = NULL;\n   PBB_DRS (pbb) = VEC_alloc (poly_dr_p, heap, 3);\n   PBB_IS_REDUCTION (pbb) = false;\n-  PBB_PDR_DUPLICATES_REMOVED (pbb) = false;\n   GBB_PBB ((gimple_bb_p) black_box) = pbb;\n \n   return pbb;\n@@ -888,16 +318,10 @@ free_poly_bb (poly_bb_p pbb)\n   int i;\n   poly_dr_p pdr;\n \n-  ppl_delete_Pointset_Powerset_C_Polyhedron (PBB_DOMAIN (pbb));\n-\n-  if (PBB_TRANSFORMED (pbb))\n-    poly_scattering_free (PBB_TRANSFORMED (pbb));\n-\n-  if (PBB_SAVED (pbb))\n-    poly_scattering_free (PBB_SAVED (pbb));\n-\n-  if (PBB_ORIGINAL (pbb))\n-    poly_scattering_free (PBB_ORIGINAL (pbb));\n+  isl_set_free (pbb->domain);\n+  isl_map_free (pbb->schedule);\n+  isl_map_free (pbb->transformed);\n+  isl_map_free (pbb->saved);\n \n   if (PBB_DRS (pbb))\n     FOR_EACH_VEC_ELT (poly_dr_p, PBB_DRS (pbb), i, pdr)\n@@ -934,8 +358,6 @@ print_pdr_access_layout (FILE *file, poly_bb_p pbb, poly_dr_p pdr)\n void\n print_pdr (FILE *file, poly_dr_p pdr, int verbosity)\n {\n-  int alias_set_dim;\n-\n   if (verbosity > 1)\n     {\n       fprintf (file, \"# pdr_%d (\", PDR_ID (pdr));\n@@ -967,13 +389,7 @@ print_pdr (FILE *file, poly_dr_p pdr, int verbosity)\n       print_pdr_access_layout (file, PDR_PBB (pdr), pdr);\n     }\n \n-  alias_set_dim = pdr_alias_set_dim (pdr) + 1;\n-\n-  openscop_print_pdr_powerset (file,\n-\t\t\t       PDR_ACCESSES (pdr),\n-\t\t\t       PDR_NB_SUBSCRIPTS (pdr),\n-\t\t\t       alias_set_dim,\n-\t\t\t       pbb_nb_params (PDR_PBB (pdr)));\n+  /* XXX isl dump accesses/subscripts */\n \n   if (verbosity > 0)\n     fprintf (file, \"#)\\n\");\n@@ -998,11 +414,21 @@ new_scop (void *region)\n {\n   scop_p scop = XNEW (struct scop);\n \n-  SCOP_CONTEXT (scop) = NULL;\n+  scop->context = NULL;\n+  scop->must_raw = NULL;\n+  scop->may_raw = NULL;\n+  scop->must_raw_no_source = NULL;\n+  scop->may_raw_no_source = NULL;\n+  scop->must_war = NULL;\n+  scop->may_war = NULL;\n+  scop->must_war_no_source = NULL;\n+  scop->may_war_no_source = NULL;\n+  scop->must_waw = NULL;\n+  scop->may_waw = NULL;\n+  scop->must_waw_no_source = NULL;\n+  scop->may_waw_no_source = NULL;\n   scop_set_region (scop, region);\n   SCOP_BBS (scop) = VEC_alloc (poly_bb_p, heap, 3);\n-  SCOP_ORIGINAL_PDDRS (scop) = htab_create (10, hash_poly_ddr_p,\n-\t\t\t\t\t    eq_poly_ddr_p, free_poly_ddr);\n   SCOP_ORIGINAL_SCHEDULE (scop) = NULL;\n   SCOP_TRANSFORMED_SCHEDULE (scop) = NULL;\n   SCOP_SAVED_SCHEDULE (scop) = NULL;\n@@ -1024,10 +450,19 @@ free_scop (scop_p scop)\n \n   VEC_free (poly_bb_p, heap, SCOP_BBS (scop));\n \n-  if (SCOP_CONTEXT (scop))\n-    ppl_delete_Pointset_Powerset_C_Polyhedron (SCOP_CONTEXT (scop));\n-\n-  htab_delete (SCOP_ORIGINAL_PDDRS (scop));\n+  isl_set_free (scop->context);\n+  isl_union_map_free (scop->must_raw);\n+  isl_union_map_free (scop->may_raw);\n+  isl_union_map_free (scop->must_raw_no_source);\n+  isl_union_map_free (scop->may_raw_no_source);\n+  isl_union_map_free (scop->must_war);\n+  isl_union_map_free (scop->may_war);\n+  isl_union_map_free (scop->must_war_no_source);\n+  isl_union_map_free (scop->may_war_no_source);\n+  isl_union_map_free (scop->must_waw);\n+  isl_union_map_free (scop->may_waw);\n+  isl_union_map_free (scop->must_waw_no_source);\n+  isl_union_map_free (scop->may_waw_no_source);\n   free_lst (SCOP_ORIGINAL_SCHEDULE (scop));\n   free_lst (SCOP_TRANSFORMED_SCHEDULE (scop));\n   free_lst (SCOP_SAVED_SCHEDULE (scop));\n@@ -1043,7 +478,7 @@ openscop_print_pbb_domain (FILE *file, poly_bb_p pbb, int verbosity)\n   graphite_dim_t i;\n   gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n \n-  if (!PBB_DOMAIN (pbb))\n+  if (!pbb->domain)\n     return;\n \n   if (verbosity > 0)\n@@ -1060,14 +495,7 @@ openscop_print_pbb_domain (FILE *file, poly_bb_p pbb, int verbosity)\n       fprintf (file, \"    cst\\n\");\n     }\n \n-  if (PBB_DOMAIN (pbb))\n-    openscop_print_powerset_matrix (file, PBB_DOMAIN (pbb),\n-\t\t\t\t    pbb_dim_iter_domain (pbb),\n-\t\t\t\t    0,\n-\t\t\t\t    0,\n-\t\t\t\t    pbb_nb_params (pbb));\n-  else\n-    fprintf (file, \"0\\n\");\n+  fprintf (file, \"XXX isl\\n\");\n \n   if (verbosity > 0)\n     fprintf (file, \"#)\\n\");\n@@ -1076,35 +504,9 @@ openscop_print_pbb_domain (FILE *file, poly_bb_p pbb, int verbosity)\n /* Print to FILE the domain of PBB, at some VERBOSITY level.  */\n \n void\n-print_pbb_domain (FILE *file, poly_bb_p pbb, int verbosity)\n+print_pbb_domain (FILE *file, poly_bb_p pbb, int verbosity ATTRIBUTE_UNUSED)\n {\n-  graphite_dim_t i;\n-  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-\n-  if (!PBB_DOMAIN (pbb))\n-    return;\n-\n-  if (verbosity > 0)\n-    {\n-      fprintf (file, \"# Iteration domain of bb_%d (\\n\", GBB_BB (gbb)->index);\n-      fprintf (file, \"#  eq\");\n-\n-      for (i = 0; i < pbb_dim_iter_domain (pbb); i++)\n-\tfprintf (file, \"     i%d\", (int) i);\n-\n-      for (i = 0; i < pbb_nb_params (pbb); i++)\n-\tfprintf (file, \"     p%d\", (int) i);\n-\n-      fprintf (file, \"    cst\\n\");\n-    }\n-\n-  if (PBB_DOMAIN (pbb))\n-    ppl_print_powerset_matrix (file, PBB_DOMAIN (pbb));\n-  else\n-    fprintf (file, \"0\\n\");\n-\n-  if (verbosity > 0)\n-    fprintf (file, \"#)\\n\");\n+  print_isl_set (file, pbb->domain);\n }\n \n /* Dump the cases of a graphite basic block GBB on FILE.  */\n@@ -1354,9 +756,9 @@ openscop_print_scop_context (FILE *file, scop_p scop, int verbosity)\n       fprintf (file, \"    cst\\n\");\n     }\n \n-  if (SCOP_CONTEXT (scop))\n-    openscop_print_powerset_matrix (file, SCOP_CONTEXT (scop), 0, 0, 0,\n-\t\t\t\t    scop_nb_params (scop));\n+  if (scop->context)\n+    /* XXX isl print context */\n+    fprintf (file, \"XXX isl\\n\");\n   else\n     fprintf (file, \"0 %d 0 0 0 %d\\n\", (int) scop_nb_params (scop) + 2,\n \t     (int) scop_nb_params (scop));\n@@ -1383,10 +785,10 @@ print_scop_context (FILE *file, scop_p scop, int verbosity)\n       fprintf (file, \"    cst\\n\");\n     }\n \n-  if (SCOP_CONTEXT (scop))\n-    ppl_print_powerset_matrix (file, SCOP_CONTEXT (scop));\n+  if (scop->context)\n+    print_isl_set (file, scop->context);\n   else\n-    fprintf (file, \"0 %d\\n\", (int) scop_nb_params (scop) + 2);\n+    fprintf (file, \"no isl context %d\\n\", (int) scop_nb_params (scop) + 2);\n \n   if (verbosity > 0)\n     fprintf (file, \"# )\\n\");\n@@ -1476,13 +878,10 @@ print_cloog (FILE *file, scop_p scop, int verbosity)\n     fprintf (file, \"# Number of scattering functions\\n\");\n \n   fprintf (file, \"%d\\n\", VEC_length (poly_bb_p, SCOP_BBS (scop)));\n-  unify_scattering_dimensions (scop);\n \n   FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     {\n-      if (!PBB_TRANSFORMED (pbb)\n-\t  || !(PBB_TRANSFORMED_SCATTERING (pbb)\n-\t       || PBB_ORIGINAL_SCATTERING (pbb)))\n+      if (!(pbb->transformed || pbb->schedule))\n \tcontinue;\n \n       if (verbosity > 1)\n@@ -1554,66 +953,61 @@ debug_scop_params (scop_p scop, int verbosity)\n   print_scop_params (stderr, scop, verbosity);\n }\n \n-\n-/* The dimension in the transformed scattering polyhedron of PBB\n-   containing the scattering iterator for the loop at depth LOOP_DEPTH.  */\n-\n-ppl_dimension_type\n-psct_scattering_dim_for_loop_depth (poly_bb_p pbb, graphite_dim_t loop_depth)\n+extern isl_ctx *the_isl_ctx;\n+void\n+print_isl_set (FILE *f, isl_set *set)\n {\n-  ppl_const_Constraint_System_t pcs;\n-  ppl_Constraint_System_const_iterator_t cit, cend;\n-  ppl_const_Constraint_t cstr;\n-  ppl_Polyhedron_t ph = PBB_TRANSFORMED_SCATTERING (pbb);\n-  ppl_dimension_type iter = psct_iterator_dim (pbb, loop_depth);\n-  ppl_Linear_Expression_t expr;\n-  ppl_Coefficient_t coef;\n-  mpz_t val;\n-  graphite_dim_t i;\n-\n-  mpz_init (val);\n-  ppl_new_Coefficient (&coef);\n-  ppl_Polyhedron_get_constraints (ph, &pcs);\n-  ppl_new_Constraint_System_const_iterator (&cit);\n-  ppl_new_Constraint_System_const_iterator (&cend);\n+  isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+  p = isl_printer_print_set (p, set);\n+  isl_printer_free (p);\n+}\n \n-  for (ppl_Constraint_System_begin (pcs, cit),\n-\t ppl_Constraint_System_end (pcs, cend);\n-       !ppl_Constraint_System_const_iterator_equal_test (cit, cend);\n-       ppl_Constraint_System_const_iterator_increment (cit))\n-    {\n-      ppl_Constraint_System_const_iterator_dereference (cit, &cstr);\n-      ppl_new_Linear_Expression_from_Constraint (&expr, cstr);\n-      ppl_Linear_Expression_coefficient (expr, iter, coef);\n-      ppl_Coefficient_to_mpz_t (coef, val);\n+DEBUG_FUNCTION void\n+debug_isl_set (isl_set *set)\n+{\n+  print_isl_set (stderr, set);\n+}\n \n-      if (mpz_sgn (val) == 0)\n-\t{\n-\t  ppl_delete_Linear_Expression (expr);\n-\t  continue;\n-\t}\n+void\n+print_isl_map (FILE *f, isl_map *map)\n+{\n+  isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+  p = isl_printer_print_map (p, map);\n+  isl_printer_free (p);\n+}\n \n-      for (i = 0; i < pbb_nb_scattering_transform (pbb); i++)\n-\t{\n-\t  ppl_dimension_type scatter = psct_scattering_dim (pbb, i);\n+DEBUG_FUNCTION void\n+debug_isl_map (isl_map *map)\n+{\n+  print_isl_map (stderr, map);\n+}\n \n-\t  ppl_Linear_Expression_coefficient (expr, scatter, coef);\n-\t  ppl_Coefficient_to_mpz_t (coef, val);\n+void\n+print_isl_aff (FILE *f, isl_aff *aff)\n+{\n+  isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+  p = isl_printer_print_aff (p, aff);\n+  isl_printer_free (p);\n+}\n \n-\t  if (mpz_sgn (val) != 0)\n-\t    {\n-\t      mpz_clear (val);\n-\t      ppl_delete_Linear_Expression (expr);\n-\t      ppl_delete_Coefficient (coef);\n-\t      ppl_delete_Constraint_System_const_iterator (cit);\n-\t      ppl_delete_Constraint_System_const_iterator (cend);\n+DEBUG_FUNCTION void\n+debug_isl_aff (isl_aff *aff)\n+{\n+  print_isl_aff (stderr, aff);\n+}\n \n-\t      return scatter;\n-\t    }\n-\t}\n-    }\n+void\n+print_isl_constraint (FILE *f, isl_constraint *c)\n+{\n+  isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n+  p = isl_printer_print_constraint (p, c);\n+  isl_printer_free (p);\n+}\n \n-  gcc_unreachable ();\n+DEBUG_FUNCTION void\n+debug_isl_constraint (isl_constraint *c)\n+{\n+  print_isl_constraint (stderr, c);\n }\n \n /* Returns the number of iterations RES of the loop around PBB at\n@@ -1624,112 +1018,37 @@ pbb_number_of_iterations_at_time (poly_bb_p pbb,\n \t\t\t\t  graphite_dim_t time_depth,\n \t\t\t\t  mpz_t res)\n {\n-  ppl_Pointset_Powerset_C_Polyhedron_t domain, sctr_lb, sctr_ub;\n-  ppl_dimension_type domain_dim, sctr_dim;\n-  graphite_dim_t dim_iter_domain = pbb_dim_iter_domain (pbb);\n-  ppl_Linear_Expression_t le;\n-  mpz_t lb, ub, diff, one;\n-  int i;\n+  isl_set *transdomain;\n+  isl_space *dc;\n+  isl_aff *aff;\n+  isl_int isllb, islub;\n \n-  ppl_Polyhedron_space_dimension (PBB_TRANSFORMED_SCATTERING (pbb), &sctr_dim);\n+  isl_int_init (isllb);\n+  isl_int_init (islub);\n \n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&domain, PBB_DOMAIN (pbb));\n+  /* Map the iteration domain through the current scatter, and work\n+     on the resulting set.  */\n+  transdomain = isl_set_apply (isl_set_copy (pbb->domain),\n+\t\t\t       isl_map_copy (pbb->transformed));\n \n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (domain, &domain_dim);\n+  /* Select the time_depth' dimension via an affine expression.  */\n+  dc = isl_set_get_space (transdomain);\n+  aff = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n+  aff = isl_aff_set_coefficient_si (aff, isl_dim_in, time_depth, 1);\n \n-  mpz_init (diff);\n-  mpz_init (lb);\n-  mpz_init (ub);\n-  mpz_init (one);\n-  mpz_set_si (one, 1);\n-\n-  /* Compute the upper bound on the original iteration domain and add\n-     that upper bound to the scattering.  */\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-    (&sctr_ub, PBB_TRANSFORMED_SCATTERING (pbb));\n-  for (i = 0; i < (int) dim_iter_domain; i++)\n-    {\n-      ppl_Linear_Expression_t eq;\n-      ppl_Constraint_t pc;\n-      ppl_Constraint_System_t cs;\n-      ppl_Polyhedron_t ph;\n-      ppl_Pointset_Powerset_C_Polyhedron_t pph;\n-\n-      ppl_new_Linear_Expression_with_dimension (&le, domain_dim);\n-      ppl_set_coef (le, i, 1);\n-      ppl_min_for_le_pointset (domain, le, lb);\n-      ppl_max_for_le_pointset (domain, le, ub);\n-      mpz_sub (diff, ub, lb);\n-      mpz_add (diff, diff, one);\n-\n-      ppl_new_Linear_Expression_with_dimension (&eq, sctr_dim);\n-      ppl_set_coef (eq, psct_iterator_dim (pbb, i), -1);\n-      ppl_set_inhomogeneous_gmp (eq, diff);\n-\n-      ppl_new_Constraint (&pc, eq, PPL_CONSTRAINT_TYPE_EQUAL);\n-      ppl_new_Constraint_System_from_Constraint (&cs, pc);\n-      ppl_new_C_Polyhedron_from_Constraint_System (&ph, cs);\n-      ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&pph, ph);\n-      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (sctr_ub, pph);\n-\n-      ppl_delete_Linear_Expression (le);\n-      ppl_delete_Linear_Expression (eq);\n-      ppl_delete_Polyhedron (ph);\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (pph);\n-      ppl_delete_Constraint (pc);\n-      ppl_delete_Constraint_System (cs);\n-    }\n+  /* And find the min/max for that function.  */\n+  /* XXX isl check results?  */\n+  isl_set_min (transdomain, aff, &isllb);\n+  isl_set_max (transdomain, aff, &islub);\n \n-  /* Compute the lower bound on the original iteration domain and add\n-     it to the scattering.  */\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-    (&sctr_lb, PBB_TRANSFORMED_SCATTERING (pbb));\n-  for (i = 0; i < (int) dim_iter_domain; i++)\n-    {\n-      ppl_Linear_Expression_t eq;\n-      ppl_Constraint_t pc;\n-      ppl_Constraint_System_t cs;\n-      ppl_Polyhedron_t ph;\n-      ppl_Pointset_Powerset_C_Polyhedron_t pph;\n-\n-      ppl_new_Linear_Expression_with_dimension (&le, domain_dim);\n-      ppl_set_coef (le, i, 1);\n-      ppl_min_for_le_pointset (domain, le, lb);\n-\n-      ppl_new_Linear_Expression_with_dimension (&eq, sctr_dim);\n-      ppl_set_coef (eq, psct_iterator_dim (pbb, i), -1);\n-      ppl_set_inhomogeneous_gmp (eq, lb);\n-\n-      ppl_new_Constraint (&pc, eq, PPL_CONSTRAINT_TYPE_EQUAL);\n-      ppl_new_Constraint_System_from_Constraint (&cs, pc);\n-      ppl_new_C_Polyhedron_from_Constraint_System (&ph, cs);\n-      ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&pph, ph);\n-      ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (sctr_lb, pph);\n-\n-      ppl_delete_Linear_Expression (le);\n-      ppl_delete_Linear_Expression (eq);\n-      ppl_delete_Polyhedron (ph);\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (pph);\n-      ppl_delete_Constraint (pc);\n-      ppl_delete_Constraint_System (cs);\n-    }\n+  isl_int_sub (islub, islub, isllb);\n+  isl_int_add_ui (islub, islub, 1);\n+  isl_int_get_gmp (islub, res);\n \n-  /* Extract the number of iterations.  */\n-  ppl_new_Linear_Expression_with_dimension (&le, sctr_dim);\n-  ppl_set_coef (le, time_depth, 1);\n-  ppl_min_for_le_pointset (sctr_lb, le, lb);\n-  ppl_max_for_le_pointset (sctr_ub, le, ub);\n-  mpz_sub (res, ub, lb);\n-\n-  mpz_clear (one);\n-  mpz_clear (diff);\n-  mpz_clear (lb);\n-  mpz_clear (ub);\n-  ppl_delete_Linear_Expression (le);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (sctr_ub);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (sctr_lb);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (domain);\n+  isl_int_clear (isllb);\n+  isl_int_clear (islub);\n+  isl_aff_free (aff);\n+  isl_set_free (transdomain);\n }\n \n /* Translates LOOP to LST.  */\n@@ -1927,5 +1246,45 @@ cloog_checksum (scop_p scop ATTRIBUTE_UNUSED)\n #endif\n }\n \n+/* Reverse the loop around PBB at level DEPTH.  */\n+\n+isl_map *\n+reverse_loop_at_level (poly_bb_p pbb, int depth)\n+{\n+  unsigned i, depth_dim = psct_dynamic_dim (pbb, depth);\n+  isl_space *d = isl_map_get_space (pbb->transformed);\n+  isl_space *d1 = isl_space_range (d);\n+  unsigned n = isl_space_dim (d1, isl_dim_out);\n+  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);\n+  isl_map *x = isl_map_universe (isl_space_copy (d2));\n+  isl_constraint *c = isl_equality_alloc (isl_local_space_from_space (d2));\n+\n+  for (i = 0; i < n; i++)\n+    if (i != depth_dim)\n+      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);\n+\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_in, depth_dim, 1);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, depth_dim, 1);\n+  x = isl_map_add_constraint (x, c);\n+  return x;\n+}\n+\n+/* Reverse the loop at level DEPTH for all the PBBS.  */\n+\n+isl_union_map *\n+reverse_loop_for_pbbs (scop_p scop, VEC (poly_bb_p, heap) *pbbs, int depth)\n+{\n+  poly_bb_p pbb;\n+  int i;\n+  isl_space *space = isl_space_from_domain (isl_set_get_space (scop->context));\n+  isl_union_map *res = isl_union_map_empty (space);\n+\n+  for (i = 0; VEC_iterate (poly_bb_p, pbbs, i, pbb); i++)\n+    res = isl_union_map_add_map (res, reverse_loop_at_level (pbb, depth));\n+\n+  return res;\n+}\n+\n+\n #endif\n "}, {"sha": "0b95662932d800198db9554265526e58313fdfed", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 93, "deletions": 158, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,5 +1,5 @@\n /* Graphite polyhedral representation.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n    Tobias Grosser <grosser@fim.uni-passau.de>.\n \n@@ -34,7 +34,7 @@ typedef struct scop *scop_p;\n DEF_VEC_P(scop_p);\n DEF_VEC_ALLOC_P (scop_p, heap);\n \n-typedef ppl_dimension_type graphite_dim_t;\n+typedef unsigned graphite_dim_t;\n \n static inline graphite_dim_t pbb_dim_iter_domain (const struct poly_bb *);\n static inline graphite_dim_t pbb_nb_params (const struct poly_bb *);\n@@ -180,7 +180,8 @@ struct poly_dr\n      - P: Number of parameters.\n \n      In the example, the vector \"R C O I L P\" is \"7 7 3 2 0 1\".  */\n-  ppl_Pointset_Powerset_C_Polyhedron_t accesses;\n+  isl_map *accesses;\n+  isl_set *extent;\n \n   /* Data reference's base object set number, we must assure 2 pdrs are in the\n      same base object set before dependency checking.  */\n@@ -195,47 +196,36 @@ struct poly_dr\n #define PDR_CDR(PDR) (PDR->compiler_dr)\n #define PDR_PBB(PDR) (PDR->pbb)\n #define PDR_TYPE(PDR) (PDR->type)\n-#define PDR_ACCESSES(PDR) (PDR->accesses)\n+#define PDR_ACCESSES(PDR) (NULL)\n #define PDR_BASE_OBJECT_SET(PDR) (PDR->dr_base_object_set)\n #define PDR_NB_SUBSCRIPTS(PDR) (PDR->nb_subscripts)\n \n-void new_poly_dr (poly_bb_p, int, ppl_Pointset_Powerset_C_Polyhedron_t,\n-\t\t  enum poly_dr_type, void *, graphite_dim_t);\n+void new_poly_dr (poly_bb_p, int, enum poly_dr_type, void *,\n+\t\t  graphite_dim_t, isl_map *, isl_set *);\n void free_poly_dr (poly_dr_p);\n void debug_pdr (poly_dr_p, int);\n void print_pdr (FILE *, poly_dr_p, int);\n static inline scop_p pdr_scop (poly_dr_p pdr);\n \n-/* The dimension of the PDR_ACCESSES polyhedron of PDR.  */\n-\n-static inline ppl_dimension_type\n-pdr_dim (poly_dr_p pdr)\n-{\n-  ppl_dimension_type dim;\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PDR_ACCESSES (pdr),\n-\t\t\t\t\t\t      &dim);\n-  return dim;\n-}\n-\n /* The dimension of the iteration domain of the scop of PDR.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pdr_dim_iter_domain (poly_dr_p pdr)\n {\n   return pbb_dim_iter_domain (PDR_PBB (pdr));\n }\n \n /* The number of parameters of the scop of PDR.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pdr_nb_params (poly_dr_p pdr)\n {\n   return scop_nb_params (pdr_scop (pdr));\n }\n \n /* The dimension of the alias set in PDR.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pdr_alias_set_dim (poly_dr_p pdr)\n {\n   poly_bb_p pbb = PDR_PBB (pdr);\n@@ -245,7 +235,7 @@ pdr_alias_set_dim (poly_dr_p pdr)\n \n /* The dimension in PDR containing subscript S.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pdr_subscript_dim (poly_dr_p pdr, graphite_dim_t s)\n {\n   poly_bb_p pbb = PDR_PBB (pdr);\n@@ -255,15 +245,15 @@ pdr_subscript_dim (poly_dr_p pdr, graphite_dim_t s)\n \n /* The dimension in PDR containing the loop iterator ITER.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pdr_iterator_dim (poly_dr_p pdr ATTRIBUTE_UNUSED, graphite_dim_t iter)\n {\n   return iter;\n }\n \n /* The dimension in PDR containing parameter PARAM.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pdr_parameter_dim (poly_dr_p pdr, graphite_dim_t param)\n {\n   poly_bb_p pbb = PDR_PBB (pdr);\n@@ -309,11 +299,6 @@ typedef struct poly_scattering *poly_scattering_p;\n \n struct poly_scattering\n {\n-  /* The scattering function containing the transformations: the\n-     layout of this polyhedron is: T|I|G with T the transform\n-     scattering, I the iteration domain, G the context parameters.  */\n-  ppl_Polyhedron_t scattering;\n-\n   /* The number of local variables.  */\n   int nb_local_variables;\n \n@@ -353,39 +338,41 @@ struct poly_bb\n \n      The number of variables in the DOMAIN may change and is not\n      related to the number of loops in the original code.  */\n-  ppl_Pointset_Powerset_C_Polyhedron_t domain;\n+  isl_set *domain;\n \n   /* The data references we access.  */\n   VEC (poly_dr_p, heap) *drs;\n \n   /* The original scattering.  */\n-  poly_scattering_p original;\n+  poly_scattering_p _original;\n+  isl_map *schedule;\n \n   /* The transformed scattering.  */\n-  poly_scattering_p transformed;\n+  poly_scattering_p _transformed;\n+  isl_map *transformed;\n \n   /* A copy of the transformed scattering.  */\n-  poly_scattering_p saved;\n-\n-  /* True when the PDR duplicates have already been removed.  */\n-  bool pdr_duplicates_removed;\n+  poly_scattering_p _saved;\n+  isl_map *saved;\n \n   /* True when this PBB contains only a reduction statement.  */\n   bool is_reduction;\n };\n \n #define PBB_BLACK_BOX(PBB) ((gimple_bb_p) PBB->black_box)\n #define PBB_SCOP(PBB) (PBB->scop)\n-#define PBB_DOMAIN(PBB) (PBB->domain)\n+#define PBB_DOMAIN(PBB) (NULL)\n #define PBB_DRS(PBB) (PBB->drs)\n-#define PBB_ORIGINAL(PBB) (PBB->original)\n-#define PBB_ORIGINAL_SCATTERING(PBB) (PBB->original->scattering)\n-#define PBB_TRANSFORMED(PBB) (PBB->transformed)\n-#define PBB_TRANSFORMED_SCATTERING(PBB) (PBB->transformed->scattering)\n-#define PBB_SAVED(PBB) (PBB->saved)\n-#define PBB_NB_LOCAL_VARIABLES(PBB) (PBB->transformed->nb_local_variables)\n-#define PBB_NB_SCATTERING_TRANSFORM(PBB) (PBB->transformed->nb_scattering)\n-#define PBB_PDR_DUPLICATES_REMOVED(PBB) (PBB->pdr_duplicates_removed)\n+#define PBB_ORIGINAL(PBB) (PBB->_original)\n+#define PBB_ORIGINAL_SCATTERING(PBB) (NULL)\n+#define PBB_TRANSFORMED(PBB) (PBB->_transformed)\n+#define PBB_TRANSFORMED_SCATTERING(PBB) (NULL)\n+#define PBB_SAVED(PBB) (PBB->_saved)\n+/* XXX isl if we ever need local vars in the scatter, we can't use the\n+   out dimension of transformed to count the scatterting transform dimension.\n+   */\n+#define PBB_NB_LOCAL_VARIABLES(PBB) (0)\n+#define PBB_NB_SCATTERING_TRANSFORM(PBB) (isl_map_n_out (PBB->transformed))\n #define PBB_IS_REDUCTION(PBB) (PBB->is_reduction)\n \n extern poly_bb_p new_poly_bb (scop_p, void *);\n@@ -410,12 +397,20 @@ extern void print_iteration_domain (FILE *, poly_bb_p, int);\n extern void print_iteration_domains (FILE *, scop_p, int);\n extern void debug_iteration_domain (poly_bb_p, int);\n extern void debug_iteration_domains (scop_p, int);\n+extern void print_isl_set (FILE *, isl_set *);\n+extern void print_isl_map (FILE *, isl_map *);\n+extern void print_isl_aff (FILE *, isl_aff *);\n+extern void print_isl_constraint (FILE *, isl_constraint *);\n+extern void debug_isl_set (isl_set *);\n+extern void debug_isl_map (isl_map *);\n+extern void debug_isl_aff (isl_aff *);\n+extern void debug_isl_constraint (isl_constraint *);\n extern int scop_do_interchange (scop_p);\n extern int scop_do_strip_mine (scop_p, int);\n extern bool scop_do_block (scop_p);\n extern bool flatten_all_loops (scop_p);\n extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);\n-extern void pbb_remove_duplicate_pdrs (poly_bb_p);\n+extern void debug_gmp_value (mpz_t);\n \n /* Return the number of write data references in PBB.  */\n \n@@ -495,11 +490,7 @@ pbb_set_black_box (poly_bb_p pbb, void *black_box)\n static inline graphite_dim_t\n pbb_dim_iter_domain (const struct poly_bb *pbb)\n {\n-  scop_p scop = PBB_SCOP (pbb);\n-  ppl_dimension_type dim;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PBB_DOMAIN (pbb), &dim);\n-  return dim - scop_nb_params (scop);\n+  return isl_set_dim (pbb->domain, isl_dim_set);\n }\n \n /* The number of params defined in PBB.  */\n@@ -544,7 +535,7 @@ pbb_nb_dynamic_scattering_transform (const struct poly_bb *pbb)\n    scattering polyhedron of PBB.  */\n \n static inline graphite_dim_t\n-pbb_nb_local_vars (const struct poly_bb *pbb)\n+pbb_nb_local_vars (const struct poly_bb *pbb ATTRIBUTE_UNUSED)\n {\n   /* For now we do not have any local variables, as we do not do strip\n      mining for example.  */\n@@ -553,15 +544,15 @@ pbb_nb_local_vars (const struct poly_bb *pbb)\n \n /* The dimension in the domain of PBB containing the iterator ITER.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pbb_iterator_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t iter)\n {\n   return iter;\n }\n \n /* The dimension in the domain of PBB containing the iterator ITER.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n pbb_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n {\n   return param\n@@ -571,7 +562,7 @@ pbb_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n /* The dimension in the original scattering polyhedron of PBB\n    containing the scattering iterator SCATTER.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psco_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)\n {\n   gcc_assert (scatter < pbb_nb_scattering_orig (pbb));\n@@ -581,20 +572,17 @@ psco_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)\n /* The dimension in the transformed scattering polyhedron of PBB\n    containing the scattering iterator SCATTER.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psct_scattering_dim (poly_bb_p pbb ATTRIBUTE_UNUSED, graphite_dim_t scatter)\n {\n   gcc_assert (scatter <= pbb_nb_scattering_transform (pbb));\n   return scatter;\n }\n \n-ppl_dimension_type psct_scattering_dim_for_loop_depth (poly_bb_p,\n-\t\t\t\t\t\t       graphite_dim_t);\n-\n /* The dimension in the transformed scattering polyhedron of PBB of\n    the local variable LV.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psct_local_var_dim (poly_bb_p pbb, graphite_dim_t lv)\n {\n   gcc_assert (lv <= pbb_nb_local_vars (pbb));\n@@ -604,7 +592,7 @@ psct_local_var_dim (poly_bb_p pbb, graphite_dim_t lv)\n /* The dimension in the original scattering polyhedron of PBB\n    containing the loop iterator ITER.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psco_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n {\n   gcc_assert (iter < pbb_dim_iter_domain (pbb));\n@@ -614,7 +602,7 @@ psco_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n /* The dimension in the transformed scattering polyhedron of PBB\n    containing the loop iterator ITER.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psct_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n {\n   gcc_assert (iter < pbb_dim_iter_domain (pbb));\n@@ -626,7 +614,7 @@ psct_iterator_dim (poly_bb_p pbb, graphite_dim_t iter)\n /* The dimension in the original scattering polyhedron of PBB\n    containing parameter PARAM.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psco_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n {\n   gcc_assert (param < pbb_nb_params (pbb));\n@@ -638,7 +626,7 @@ psco_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n /* The dimension in the transformed scattering polyhedron of PBB\n    containing parameter PARAM.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psct_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n {\n   gcc_assert (param < pbb_nb_params (pbb));\n@@ -651,7 +639,7 @@ psct_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n /* The scattering dimension of PBB corresponding to the dynamic level\n    LEVEL.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psct_dynamic_dim (poly_bb_p pbb, graphite_dim_t level)\n {\n   graphite_dim_t result = 1 + 2 * level;\n@@ -663,7 +651,7 @@ psct_dynamic_dim (poly_bb_p pbb, graphite_dim_t level)\n /* The scattering dimension of PBB corresponding to the static\n    sequence of the loop level LEVEL.  */\n \n-static inline ppl_dimension_type\n+static inline graphite_dim_t\n psct_static_dim (poly_bb_p pbb, graphite_dim_t level)\n {\n   graphite_dim_t result = 2 * level;\n@@ -676,25 +664,10 @@ psct_static_dim (poly_bb_p pbb, graphite_dim_t level)\n    variable and returns its index.  */\n \n static inline graphite_dim_t\n-psct_add_local_variable (poly_bb_p pbb)\n+psct_add_local_variable (poly_bb_p pbb ATTRIBUTE_UNUSED)\n {\n-  graphite_dim_t nlv = pbb_nb_local_vars (pbb);\n-  ppl_dimension_type lv_column = psct_local_var_dim (pbb, nlv);\n-  ppl_insert_dimensions (PBB_TRANSFORMED_SCATTERING (pbb), lv_column, 1);\n-  PBB_NB_LOCAL_VARIABLES (pbb) += 1;\n-  return nlv;\n-}\n-\n-/* Adds a dimension to the transformed scattering polyhedron of PBB at\n-   INDEX.  */\n-\n-static inline void\n-psct_add_scattering_dimension (poly_bb_p pbb, ppl_dimension_type index)\n-{\n-  gcc_assert (index < pbb_nb_scattering_transform (pbb));\n-\n-  ppl_insert_dimensions (PBB_TRANSFORMED_SCATTERING (pbb), index, 1);\n-  PBB_NB_SCATTERING_TRANSFORM (pbb) += 1;\n+  gcc_unreachable ();\n+  return 0;\n }\n \n typedef struct lst *lst_p;\n@@ -1116,25 +1089,20 @@ lst_niter_for_loop (lst_p lst, mpz_t niter)\n static inline void\n pbb_update_scattering (poly_bb_p pbb, graphite_dim_t level, int dewey)\n {\n-  ppl_Polyhedron_t ph = PBB_TRANSFORMED_SCATTERING (pbb);\n-  ppl_dimension_type sched = psct_static_dim (pbb, level);\n-  ppl_dimension_type ds[1];\n-  ppl_Constraint_t new_cstr;\n-  ppl_Linear_Expression_t expr;\n-  ppl_dimension_type dim;\n+  graphite_dim_t sched = psct_static_dim (pbb, level);\n+  isl_space *d = isl_map_get_space (pbb->transformed);\n+  isl_space *d1 = isl_space_range (d);\n+  unsigned i, n = isl_space_dim (d1, isl_dim_out);\n+  isl_space *d2 = isl_space_add_dims (d1, isl_dim_in, n);\n+  isl_map *x = isl_map_universe (d2);\n+\n+  x = isl_map_fix_si (x, isl_dim_out, sched, dewey);\n \n-  ppl_Polyhedron_space_dimension (ph, &dim);\n-  ds[0] = sched;\n-  ppl_Polyhedron_remove_space_dimensions (ph, ds, 1);\n-  ppl_insert_dimensions (ph, sched, 1);\n+  for (i = 0; i < n; i++)\n+    if (i != sched)\n+      x = isl_map_equate (x, isl_dim_in, i, isl_dim_out, i);\n \n-  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-  ppl_set_coef (expr, sched, -1);\n-  ppl_set_inhomogeneous (expr, dewey);\n-  ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n-  ppl_delete_Linear_Expression (expr);\n-  ppl_Polyhedron_add_constraint (ph, new_cstr);\n-  ppl_delete_Constraint (new_cstr);\n+  pbb->transformed = isl_map_apply_range (pbb->transformed, x);\n }\n \n /* Updates the scattering of all the PBBs under LST to be at the DEWEY\n@@ -1401,7 +1369,18 @@ struct scop\n   -128 >= a >= 127\n      0 >= b >= 65,535\n      c = 2a + b  */\n-  ppl_Pointset_Powerset_C_Polyhedron_t context;\n+  isl_set *context;\n+\n+  /* The context used internally by ISL.  */\n+  isl_ctx *ctx;\n+\n+  /* The original dependence relations:\n+     RAW are read after write dependences,\n+     WAR are write after read dependences,\n+     WAW are write after write dependences.  */\n+  isl_union_map *must_raw, *may_raw, *must_raw_no_source, *may_raw_no_source,\n+    *must_war, *may_war, *must_war_no_source, *may_war_no_source,\n+    *must_waw, *may_waw, *must_waw_no_source, *may_waw_no_source;\n \n   /* A hashtable of the data dependence relations for the original\n      scattering.  */\n@@ -1414,7 +1393,7 @@ struct scop\n \n #define SCOP_BBS(S) (S->bbs)\n #define SCOP_REGION(S) ((sese) S->region)\n-#define SCOP_CONTEXT(S) (S->context)\n+#define SCOP_CONTEXT(S) (NULL)\n #define SCOP_ORIGINAL_PDDRS(S) (S->original_pddrs)\n #define SCOP_ORIGINAL_SCHEDULE(S) (S->original_schedule)\n #define SCOP_TRANSFORMED_SCHEDULE(S) (S->transformed_schedule)\n@@ -1467,7 +1446,6 @@ poly_scattering_new (void)\n {\n   poly_scattering_p res = XNEW (struct poly_scattering);\n \n-  res->scattering = NULL;\n   res->nb_local_variables = 0;\n   res->nb_scattering = 0;\n   return res;\n@@ -1478,7 +1456,6 @@ poly_scattering_new (void)\n static inline void\n poly_scattering_free (poly_scattering_p s)\n {\n-  ppl_delete_Polyhedron (s->scattering);\n   free (s);\n }\n \n@@ -1489,7 +1466,6 @@ poly_scattering_copy (poly_scattering_p s)\n {\n   poly_scattering_p res = poly_scattering_new ();\n \n-  ppl_new_C_Polyhedron_from_C_Polyhedron (&(res->scattering), s->scattering);\n   res->nb_local_variables = s->nb_local_variables;\n   res->nb_scattering = s->nb_scattering;\n   return res;\n@@ -1500,12 +1476,8 @@ poly_scattering_copy (poly_scattering_p s)\n static inline void\n store_scattering_pbb (poly_bb_p pbb)\n {\n-  gcc_assert (PBB_TRANSFORMED (pbb));\n-\n-  if (PBB_SAVED (pbb))\n-    poly_scattering_free (PBB_SAVED (pbb));\n-\n-  PBB_SAVED (pbb) = poly_scattering_copy (PBB_TRANSFORMED (pbb));\n+  isl_map_free (pbb->saved);\n+  pbb->saved = isl_map_copy (pbb->transformed);\n }\n \n /* Stores the SCOP_TRANSFORMED_SCHEDULE to SCOP_SAVED_SCHEDULE.  */\n@@ -1549,10 +1521,10 @@ store_scattering (scop_p scop)\n static inline void\n restore_scattering_pbb (poly_bb_p pbb)\n {\n-  gcc_assert (PBB_SAVED (pbb));\n+  gcc_assert (pbb->saved);\n \n-  poly_scattering_free (PBB_TRANSFORMED (pbb));\n-  PBB_TRANSFORMED (pbb) = poly_scattering_copy (PBB_SAVED (pbb));\n+  isl_map_free (pbb->transformed);\n+  pbb->transformed = isl_map_copy (pbb->saved);\n }\n \n /* Restores the scattering for all the pbbs in the SCOP.  */\n@@ -1569,49 +1541,12 @@ restore_scattering (scop_p scop)\n   restore_lst_schedule (scop);\n }\n \n-/* For a given PBB, add to RES the scop context, the iteration domain,\n-   the original scattering when ORIGINAL_P is true, otherwise add the\n-   transformed scattering.  */\n-\n-static inline void\n-combine_context_id_scat (ppl_Pointset_Powerset_C_Polyhedron_t *res,\n-\t\t\t poly_bb_p pbb, bool original_p)\n-{\n-  ppl_Pointset_Powerset_C_Polyhedron_t context;\n-  ppl_Pointset_Powerset_C_Polyhedron_t id;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-    (res, original_p ?\n-     PBB_ORIGINAL_SCATTERING (pbb) : PBB_TRANSFORMED_SCATTERING (pbb));\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&context, SCOP_CONTEXT (PBB_SCOP (pbb)));\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&id, PBB_DOMAIN (pbb));\n-\n-  /* Extend the context and the iteration domain to the dimension of\n-     the scattering: T|I|G.  */\n-  {\n-    ppl_dimension_type gdim, tdim, idim;\n-\n-    ppl_Pointset_Powerset_C_Polyhedron_space_dimension (*res, &tdim);\n-    ppl_Pointset_Powerset_C_Polyhedron_space_dimension (context, &gdim);\n-    ppl_Pointset_Powerset_C_Polyhedron_space_dimension (id, &idim);\n-\n-    if (tdim > gdim)\n-      ppl_insert_dimensions_pointset (context, 0, tdim - gdim);\n-\n-    if (tdim > idim)\n-      ppl_insert_dimensions_pointset (id, 0, tdim - idim);\n-  }\n-\n-  /* Add the context and the iteration domain to the result.  */\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*res, context);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*res, id);\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (context);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (id);\n-}\n+bool graphite_legal_transform (scop_p);\n+poly_bb_p find_pbb_via_hash (htab_t, basic_block);\n+bool loop_is_parallel_p (loop_p, htab_t, int);\n+scop_p get_loop_body_pbbs (loop_p, htab_t, VEC (poly_bb_p, heap) **);\n+isl_map *reverse_loop_at_level (poly_bb_p, int);\n+isl_union_map *reverse_loop_for_pbbs (scop_p, VEC (poly_bb_p, heap) *, int);\n+__isl_give isl_union_map *extend_schedule (__isl_take isl_union_map *);\n \n #endif"}, {"sha": "9762ca46770bbc8b39f7135999d23d64ac89d50d", "filename": "gcc/graphite-ppl.c", "status": "removed", "additions": 0, "deletions": 566, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-ppl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-ppl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-ppl.c?ref=6886e4444f193c399b96cb1f64a24b9673cf3149", "patch": "@@ -1,566 +0,0 @@\n-/* Gimple Represented as Polyhedra.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com>\n-   and Tobias Grosser <grosser@fim.uni-passau.de>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-\n-#ifdef HAVE_cloog\n-\n-#include \"ppl_c.h\"\n-#include \"graphite-cloog-util.h\"\n-#include \"graphite-ppl.h\"\n-\n-/* Set the inhomogeneous term of E to X.  */\n-\n-void\n-ppl_set_inhomogeneous_gmp (ppl_Linear_Expression_t e, mpz_t x)\n-{\n-  mpz_t v0, v1;\n-  ppl_Coefficient_t c;\n-\n-  mpz_init (v0);\n-  mpz_init (v1);\n-  ppl_new_Coefficient (&c);\n-\n-  ppl_Linear_Expression_inhomogeneous_term (e, c);\n-  ppl_Coefficient_to_mpz_t (c, v1);\n-  mpz_neg (v1, v1);\n-  mpz_set (v0, x);\n-  mpz_add (v0, v0, v1);\n-  ppl_assign_Coefficient_from_mpz_t (c, v0);\n-  ppl_Linear_Expression_add_to_inhomogeneous (e, c);\n-\n-  mpz_clear (v0);\n-  mpz_clear (v1);\n-  ppl_delete_Coefficient (c);\n-}\n-\n-/* Set E[I] to X.  */\n-\n-void\n-ppl_set_coef_gmp (ppl_Linear_Expression_t e, ppl_dimension_type i, mpz_t x)\n-{\n-  mpz_t v0, v1;\n-  ppl_Coefficient_t c;\n-\n-  mpz_init (v0);\n-  mpz_init (v1);\n-  ppl_new_Coefficient (&c);\n-\n-  ppl_Linear_Expression_coefficient (e, i, c);\n-  ppl_Coefficient_to_mpz_t (c, v1);\n-  mpz_neg (v1, v1);\n-  mpz_set (v0, x);\n-  mpz_add (v0, v0, v1);\n-  ppl_assign_Coefficient_from_mpz_t (c, v0);\n-  ppl_Linear_Expression_add_to_coefficient (e, i, c);\n-\n-  mpz_clear (v0);\n-  mpz_clear (v1);\n-  ppl_delete_Coefficient (c);\n-}\n-\n-/* Insert after X NB_NEW_DIMS empty dimensions into PH.\n-\n-   With x = 3 and nb_new_dims = 4\n-\n-   |  d0 d1 d2 d3 d4\n-\n-   is transformed to\n-\n-   |  d0 d1 d2 x0 x1 x2 x3 d3 d4\n-\n-   | map = {0, 1, 2, 7, 8, 3, 4, 5, 6}\n-*/\n-\n-void\n-ppl_insert_dimensions_pointset (ppl_Pointset_Powerset_C_Polyhedron_t ph, int x,\n-\t\t\t\tint nb_new_dims)\n-{\n-  ppl_dimension_type i, dim;\n-  ppl_dimension_type *map;\n-  ppl_dimension_type x_ppl, nb_new_dims_ppl;\n-\n-  x_ppl = (ppl_dimension_type) x;\n-  nb_new_dims_ppl = (ppl_dimension_type) nb_new_dims;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (ph, &dim);\n-  ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed (ph, nb_new_dims);\n-\n-  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim + nb_new_dims);\n-\n-  for (i = 0; i < x_ppl; i++)\n-    map[i] = i;\n-\n-  for (i = x_ppl; i < x_ppl + nb_new_dims_ppl; i++)\n-    map[dim + i - x_ppl] = i;\n-\n-  for (i = x_ppl + nb_new_dims_ppl; i < dim + nb_new_dims_ppl; i++)\n-    map[i - nb_new_dims_ppl] = i;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (ph, map, dim + nb_new_dims);\n-  free (map);\n-}\n-\n-/* Insert after X NB_NEW_DIMS empty dimensions into PH.\n-\n-   With x = 3 and nb_new_dims = 4\n-\n-   |  d0 d1 d2 d3 d4\n-\n-   is transformed to\n-\n-   |  d0 d1 d2 x0 x1 x2 x3 d3 d4\n-\n-   | map = {0, 1, 2, 7, 8, 3, 4, 5, 6}\n-*/\n-\n-void\n-ppl_insert_dimensions (ppl_Polyhedron_t ph, int x,\n-\t\t       int nb_new_dims)\n-{\n-  ppl_dimension_type i, dim;\n-  ppl_dimension_type *map;\n-  ppl_dimension_type x_ppl, nb_new_dims_ppl;\n-\n-  x_ppl = (ppl_dimension_type) x;\n-  nb_new_dims_ppl = (ppl_dimension_type) nb_new_dims;\n-\n-  ppl_Polyhedron_space_dimension (ph, &dim);\n-  ppl_Polyhedron_add_space_dimensions_and_embed (ph, nb_new_dims);\n-\n-  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim + nb_new_dims);\n-\n-  for (i = 0; i < x_ppl; i++)\n-    map[i] = i;\n-\n-  for (i = x_ppl; i < x_ppl + nb_new_dims_ppl; i++)\n-    map[dim + i - x_ppl] = i;\n-\n-  for (i = x_ppl + nb_new_dims_ppl; i < dim + nb_new_dims_ppl; i++)\n-    map[i - nb_new_dims_ppl] = i;\n-\n-  ppl_Polyhedron_map_space_dimensions (ph, map, dim + nb_new_dims);\n-  free (map);\n-}\n-\n-/* Based on the original polyhedron PH, returns a new polyhedron with\n-   an extra dimension placed at position LOOP + 1 that slices the\n-   dimension LOOP into strips of size STRIDE.  */\n-\n-ppl_Polyhedron_t\n-ppl_strip_loop (ppl_Polyhedron_t ph, ppl_dimension_type loop, int stride)\n-{\n-  ppl_const_Constraint_System_t pcs;\n-  ppl_Constraint_System_const_iterator_t cit, end;\n-  ppl_const_Constraint_t cstr;\n-  ppl_Linear_Expression_t expr;\n-  int v;\n-  ppl_dimension_type dim;\n-  ppl_Polyhedron_t res;\n-  ppl_Coefficient_t c;\n-  mpz_t val;\n-\n-  mpz_init (val);\n-  ppl_new_Coefficient (&c);\n-\n-  ppl_Polyhedron_space_dimension (ph, &dim);\n-  ppl_Polyhedron_get_constraints (ph, &pcs);\n-\n-  /* Start from a copy of the constraints.  */\n-  ppl_new_C_Polyhedron_from_space_dimension (&res, dim + 1, 0);\n-  ppl_Polyhedron_add_constraints (res, pcs);\n-\n-  /* Add an empty dimension for the strip loop.  */\n-  ppl_insert_dimensions (res, loop, 1);\n-\n-  /* Identify the constraints that define the lower and upper bounds\n-     of the strip-mined loop, and add them to the strip loop.  */\n-  {\n-    ppl_Polyhedron_t tmp;\n-\n-    ppl_new_C_Polyhedron_from_space_dimension (&tmp, dim + 1, 0);\n-    ppl_new_Constraint_System_const_iterator (&cit);\n-    ppl_new_Constraint_System_const_iterator (&end);\n-\n-    for (ppl_Constraint_System_begin (pcs, cit),\n-\t   ppl_Constraint_System_end (pcs, end);\n-\t !ppl_Constraint_System_const_iterator_equal_test (cit, end);\n-\t ppl_Constraint_System_const_iterator_increment (cit))\n-      {\n-\tppl_Constraint_System_const_iterator_dereference (cit, &cstr);\n-\tppl_new_Linear_Expression_from_Constraint (&expr, cstr);\n-\tppl_Linear_Expression_coefficient (expr, loop, c);\n-\tppl_delete_Linear_Expression (expr);\n-\tppl_Coefficient_to_mpz_t (c, val);\n-\tv = mpz_get_si (val);\n-\n-\tif (0 < v || v < 0)\n-\t  ppl_Polyhedron_add_constraint (tmp, cstr);\n-      }\n-    ppl_delete_Constraint_System_const_iterator (cit);\n-    ppl_delete_Constraint_System_const_iterator (end);\n-\n-    ppl_insert_dimensions (tmp, loop + 1, 1);\n-    ppl_Polyhedron_get_constraints (tmp, &pcs);\n-    ppl_Polyhedron_add_constraints (res, pcs);\n-    ppl_delete_Polyhedron (tmp);\n-  }\n-\n-  /* Lower bound of a tile starts at \"stride * outer_iv\".  */\n-  {\n-    ppl_Constraint_t new_cstr;\n-    ppl_new_Linear_Expression_with_dimension (&expr, dim + 1);\n-\n-    ppl_set_coef (expr, loop + 1, 1);\n-    ppl_set_coef (expr, loop, -1 * stride);\n-\n-    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-    ppl_delete_Linear_Expression (expr);\n-    ppl_Polyhedron_add_constraint (res, new_cstr);\n-    ppl_delete_Constraint (new_cstr);\n-  }\n-\n-  /* Upper bound of a tile stops at \"stride * outer_iv + stride - 1\",\n-     or at the old upper bound that is not modified.  */\n-  {\n-    ppl_Constraint_t new_cstr;\n-    ppl_new_Linear_Expression_with_dimension (&expr, dim + 1);\n-\n-    ppl_set_coef (expr, loop + 1, -1);\n-    ppl_set_coef (expr, loop, stride);\n-    ppl_set_inhomogeneous (expr, stride - 1);\n-\n-    ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-    ppl_delete_Linear_Expression (expr);\n-    ppl_Polyhedron_add_constraint (res, new_cstr);\n-    ppl_delete_Constraint (new_cstr);\n-  }\n-\n-  mpz_clear (val);\n-  ppl_delete_Coefficient (c);\n-  return res;\n-}\n-\n-/* Lexicographically compares two linear expressions A and B and\n-   returns negative when A < B, 0 when A == B and positive when A > B.  */\n-\n-int\n-ppl_lexico_compare_linear_expressions (ppl_Linear_Expression_t a,\n-\t\t\t\t       ppl_Linear_Expression_t b)\n-{\n-  ppl_dimension_type min_length, length1, length2;\n-  ppl_dimension_type i;\n-  ppl_Coefficient_t c;\n-  int res;\n-  mpz_t va, vb;\n-\n-  ppl_Linear_Expression_space_dimension (a, &length1);\n-  ppl_Linear_Expression_space_dimension (b, &length2);\n-  ppl_new_Coefficient (&c);\n-  mpz_init (va);\n-  mpz_init (vb);\n-\n-  if (length1 < length2)\n-    min_length = length1;\n-  else\n-    min_length = length2;\n-\n-  for (i = 0; i < min_length; i++)\n-    {\n-      ppl_Linear_Expression_coefficient (a, i, c);\n-      ppl_Coefficient_to_mpz_t (c, va);\n-      ppl_Linear_Expression_coefficient (b, i, c);\n-      ppl_Coefficient_to_mpz_t (c, vb);\n-      res = mpz_cmp (va, vb);\n-\n-      if (res == 0)\n-\tcontinue;\n-\n-      mpz_clear (va);\n-      mpz_clear (vb);\n-      ppl_delete_Coefficient (c);\n-      return res;\n-    }\n-\n-  mpz_clear (va);\n-  mpz_clear (vb);\n-  ppl_delete_Coefficient (c);\n-  return length1 - length2;\n-}\n-\n-/* Print to FILE the polyhedron PH under its PolyLib matrix form.  */\n-\n-void\n-ppl_print_polyhedron_matrix (FILE *file, ppl_const_Polyhedron_t ph)\n-{\n-  CloogMatrix *mat = new_Cloog_Matrix_from_ppl_Polyhedron (ph);\n-  cloog_matrix_print (file, mat);\n-  cloog_matrix_free (mat);\n-}\n-\n-/* Print to FILE the linear expression LE.  */\n-\n-void\n-ppl_print_linear_expr (FILE *file, ppl_Linear_Expression_t le)\n-{\n-  ppl_Constraint_t c;\n-  ppl_Polyhedron_t pol;\n-  ppl_dimension_type dim;\n-\n-  ppl_Linear_Expression_space_dimension (le, &dim);\n-  ppl_new_C_Polyhedron_from_space_dimension (&pol, dim, 0);\n-  ppl_new_Constraint (&c, le, PPL_CONSTRAINT_TYPE_EQUAL);\n-  ppl_Polyhedron_add_constraint (pol, c);\n-  ppl_print_polyhedron_matrix (file, pol);\n-}\n-\n-/* Print to STDERR the linear expression LE.  */\n-\n-DEBUG_FUNCTION void\n-debug_ppl_linear_expr (ppl_Linear_Expression_t le)\n-{\n-  ppl_print_linear_expr (stderr, le);\n-}\n-\n-/* Print to FILE the powerset PS in its PolyLib matrix form.  */\n-\n-void\n-ppl_print_powerset_matrix (FILE *file,\n-\t\t\t   ppl_Pointset_Powerset_C_Polyhedron_t ps)\n-{\n-  size_t nb_disjuncts;\n-  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_size (ps, &nb_disjuncts);\n-  fprintf (file, \"%d\\n\", (int) nb_disjuncts);\n-\n-  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (ps, it),\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (ps, end);\n-       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n-    {\n-      ppl_const_Polyhedron_t ph;\n-\n-      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n-      ppl_print_polyhedron_matrix (file, ph);\n-    }\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n-}\n-\n-/* Print to STDERR the polyhedron PH under its PolyLib matrix form.  */\n-\n-DEBUG_FUNCTION void\n-debug_ppl_polyhedron_matrix (ppl_Polyhedron_t ph)\n-{\n-  ppl_print_polyhedron_matrix (stderr, ph);\n-}\n-\n-/* Print to STDERR the powerset PS in its PolyLib matrix form.  */\n-\n-DEBUG_FUNCTION void\n-debug_ppl_powerset_matrix (ppl_Pointset_Powerset_C_Polyhedron_t ps)\n-{\n-  ppl_print_powerset_matrix (stderr, ps);\n-}\n-\n-/* Read from FILE a polyhedron under PolyLib matrix form and return a\n-   PPL polyhedron object.  */\n-\n-void\n-ppl_read_polyhedron_matrix (ppl_Polyhedron_t *ph, FILE *file)\n-{\n-  CloogMatrix *mat = cloog_matrix_read (file);\n-  new_C_Polyhedron_from_Cloog_Matrix (ph, mat);\n-  cloog_matrix_free (mat);\n-}\n-\n-/* Return in RES the maximum of the linear expression LE on the\n-   pointset powerset of polyhedra PS.  */\n-\n-void\n-ppl_max_for_le_pointset (ppl_Pointset_Powerset_C_Polyhedron_t ps,\n-                         ppl_Linear_Expression_t le, mpz_t res)\n-{\n-  ppl_Coefficient_t num, denom;\n-  mpz_t dv, nv;\n-  int maximum, err;\n-\n-  mpz_init (nv);\n-  mpz_init (dv);\n-  ppl_new_Coefficient (&num);\n-  ppl_new_Coefficient (&denom);\n-  err = ppl_Pointset_Powerset_C_Polyhedron_maximize (ps, le, num, denom, &maximum);\n-\n-  if (err > 0)\n-    {\n-      ppl_Coefficient_to_mpz_t (num, nv);\n-      ppl_Coefficient_to_mpz_t (denom, dv);\n-      gcc_assert (mpz_sgn (dv) != 0);\n-      mpz_tdiv_q (res, nv, dv);\n-    }\n-\n-  mpz_clear (nv);\n-  mpz_clear (dv);\n-  ppl_delete_Coefficient (num);\n-  ppl_delete_Coefficient (denom);\n-}\n-\n-/* Return in RES the maximum of the linear expression LE on the\n-   polyhedron POL.  */\n-\n-void\n-ppl_min_for_le_pointset (ppl_Pointset_Powerset_C_Polyhedron_t ps,\n-\t\t\t ppl_Linear_Expression_t le, mpz_t res)\n-{\n-  ppl_Coefficient_t num, denom;\n-  mpz_t dv, nv;\n-  int minimum, err;\n-\n-  mpz_init (nv);\n-  mpz_init (dv);\n-  ppl_new_Coefficient (&num);\n-  ppl_new_Coefficient (&denom);\n-  err = ppl_Pointset_Powerset_C_Polyhedron_minimize (ps, le, num, denom, &minimum);\n-\n-  if (err > 0)\n-    {\n-      ppl_Coefficient_to_mpz_t (num, nv);\n-      ppl_Coefficient_to_mpz_t (denom, dv);\n-      gcc_assert (mpz_sgn (dv) != 0);\n-      mpz_tdiv_q (res, nv, dv);\n-    }\n-\n-  mpz_clear (nv);\n-  mpz_clear (dv);\n-  ppl_delete_Coefficient (num);\n-  ppl_delete_Coefficient (denom);\n-}\n-\n-/* Builds a constraint in dimension DIM relating dimensions POS1 to\n-   POS2 as \"POS1 - POS2 + C CSTR_TYPE 0\" */\n-\n-ppl_Constraint_t\n-ppl_build_relation (int dim, int pos1, int pos2, int c,\n-\t\t    enum ppl_enum_Constraint_Type cstr_type)\n-{\n-  ppl_Linear_Expression_t expr;\n-  ppl_Constraint_t cstr;\n-  ppl_Coefficient_t coef;\n-  mpz_t v, v_op, v_c;\n-\n-  mpz_init (v);\n-  mpz_init (v_op);\n-  mpz_init (v_c);\n-\n-  mpz_set_si (v, 1);\n-  mpz_set_si (v_op, -1);\n-  mpz_set_si (v_c, c);\n-\n-  ppl_new_Coefficient (&coef);\n-  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-\n-  ppl_assign_Coefficient_from_mpz_t (coef, v);\n-  ppl_Linear_Expression_add_to_coefficient (expr, pos1, coef);\n-  ppl_assign_Coefficient_from_mpz_t (coef, v_op);\n-  ppl_Linear_Expression_add_to_coefficient (expr, pos2, coef);\n-  ppl_assign_Coefficient_from_mpz_t (coef, v_c);\n-  ppl_Linear_Expression_add_to_inhomogeneous (expr, coef);\n-\n-  ppl_new_Constraint (&cstr, expr, cstr_type);\n-\n-  ppl_delete_Linear_Expression (expr);\n-  ppl_delete_Coefficient (coef);\n-  mpz_clear (v);\n-  mpz_clear (v_op);\n-  mpz_clear (v_c);\n-\n-  return cstr;\n-}\n-\n-/* Print to STDERR the GMP value VAL.  */\n-\n-DEBUG_FUNCTION void\n-debug_gmp_value (mpz_t val)\n-{\n-  char *str = mpz_get_str (0, 10, val);\n-  void (*gmp_free) (void *, size_t);\n-\n-  fprintf (stderr, \"%s\", str);\n-  mp_get_memory_functions (NULL, NULL, &gmp_free);\n-  (*gmp_free) (str, strlen (str) + 1);\n-}\n-\n-/* Checks for integer feasibility: returns true when the powerset\n-   polyhedron PS has no integer solutions.  */\n-\n-bool\n-ppl_powerset_is_empty (ppl_Pointset_Powerset_C_Polyhedron_t ps)\n-{\n-  ppl_PIP_Problem_t pip;\n-  ppl_dimension_type d;\n-  ppl_const_Constraint_System_t pcs;\n-  ppl_Constraint_System_const_iterator_t first, last;\n-  ppl_Pointset_Powerset_C_Polyhedron_iterator_t it, end;\n-  bool has_integer_solutions = false;\n-\n-  if (ppl_Pointset_Powerset_C_Polyhedron_is_empty (ps))\n-    return true;\n-\n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (ps, &d);\n-  ppl_new_Constraint_System_const_iterator (&first);\n-  ppl_new_Constraint_System_const_iterator (&last);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&it);\n-  ppl_new_Pointset_Powerset_C_Polyhedron_iterator (&end);\n-\n-  for (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (ps, it),\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_end (ps, end);\n-       !ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (it, end);\n-       ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (it))\n-    {\n-      ppl_const_Polyhedron_t ph;\n-      ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (it, &ph);\n-\n-      ppl_Polyhedron_get_constraints (ph, &pcs);\n-      ppl_Constraint_System_begin (pcs, first);\n-      ppl_Constraint_System_end (pcs, last);\n-\n-      ppl_new_PIP_Problem_from_constraints (&pip, d, first, last, 0, NULL);\n-      has_integer_solutions |= ppl_PIP_Problem_is_satisfiable (pip);\n-\n-      ppl_delete_PIP_Problem (pip);\n-    }\n-\n-  ppl_delete_Constraint_System_const_iterator (first);\n-  ppl_delete_Constraint_System_const_iterator (last);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (it);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (end);\n-\n-  return !has_integer_solutions;\n-}\n-\n-#endif"}, {"sha": "5820e19927dc024b492eb10f08d49eccae61bdc0", "filename": "gcc/graphite-ppl.h", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-ppl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6886e4444f193c399b96cb1f64a24b9673cf3149/gcc%2Fgraphite-ppl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-ppl.h?ref=6886e4444f193c399b96cb1f64a24b9673cf3149", "patch": "@@ -1,176 +0,0 @@\n-/* Gimple Represented as Polyhedra.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@inria.fr>\n-   and Tobias Grosser <grosser@fim.uni-passau.de>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-#ifndef GCC_GRAPHITE_PPL_H\n-#define GCC_GRAPHITE_PPL_H\n-\n-#include \"double-int.h\"\n-#include \"tree.h\"\n-\n-ppl_Polyhedron_t ppl_strip_loop (ppl_Polyhedron_t, ppl_dimension_type, int);\n-int ppl_lexico_compare_linear_expressions (ppl_Linear_Expression_t,\n-\t\t\t\t\t   ppl_Linear_Expression_t);\n-\n-void ppl_print_polyhedron_matrix (FILE *, ppl_const_Polyhedron_t);\n-void ppl_print_powerset_matrix (FILE *, ppl_Pointset_Powerset_C_Polyhedron_t);\n-void debug_ppl_polyhedron_matrix (ppl_Polyhedron_t);\n-void debug_ppl_powerset_matrix (ppl_Pointset_Powerset_C_Polyhedron_t);\n-void ppl_print_linear_expr (FILE *, ppl_Linear_Expression_t);\n-void debug_ppl_linear_expr (ppl_Linear_Expression_t);\n-void ppl_read_polyhedron_matrix (ppl_Polyhedron_t *, FILE *);\n-void ppl_insert_dimensions (ppl_Polyhedron_t, int, int);\n-void ppl_insert_dimensions_pointset (ppl_Pointset_Powerset_C_Polyhedron_t, int,\n-\t\t\t\t     int);\n-void ppl_set_inhomogeneous_gmp (ppl_Linear_Expression_t, mpz_t);\n-void ppl_set_coef_gmp (ppl_Linear_Expression_t, ppl_dimension_type, mpz_t);\n-void ppl_max_for_le_pointset (ppl_Pointset_Powerset_C_Polyhedron_t,\n-                              ppl_Linear_Expression_t, mpz_t);\n-void ppl_min_for_le_pointset (ppl_Pointset_Powerset_C_Polyhedron_t,\n-\t\t\t      ppl_Linear_Expression_t, mpz_t);\n-ppl_Constraint_t ppl_build_relation (int, int, int, int,\n-\t\t\t\t     enum ppl_enum_Constraint_Type);\n-void debug_gmp_value (mpz_t);\n-bool ppl_powerset_is_empty (ppl_Pointset_Powerset_C_Polyhedron_t);\n-\n-\n-/* Assigns to RES the value of the INTEGER_CST T.  */\n-\n-static inline void\n-tree_int_to_gmp (tree t, mpz_t res)\n-{\n-  double_int di = tree_to_double_int (t);\n-  mpz_set_double_int (res, di, TYPE_UNSIGNED (TREE_TYPE (t)));\n-}\n-\n-/* Converts a GMP constant VAL to a tree and returns it.  */\n-\n-static inline tree\n-gmp_cst_to_tree (tree type, mpz_t val)\n-{\n-  tree t = type ? type : integer_type_node;\n-  mpz_t tmp;\n-  double_int di;\n-\n-  mpz_init (tmp);\n-  mpz_set (tmp, val);\n-  di = mpz_get_double_int (t, tmp, true);\n-  mpz_clear (tmp);\n-\n-  return double_int_to_tree (t, di);\n-}\n-\n-/* Set the inhomogeneous term of E to the integer X.  */\n-\n-static inline void\n-ppl_set_inhomogeneous (ppl_Linear_Expression_t e, int x)\n-{\n-  mpz_t v;\n-  mpz_init (v);\n-  mpz_set_si (v, x);\n-  ppl_set_inhomogeneous_gmp (e, v);\n-  mpz_clear (v);\n-}\n-\n-/* Set the inhomogeneous term of E to the tree X.  */\n-\n-static inline void\n-ppl_set_inhomogeneous_tree (ppl_Linear_Expression_t e, tree x)\n-{\n-  mpz_t v;\n-  mpz_init (v);\n-  tree_int_to_gmp (x, v);\n-  ppl_set_inhomogeneous_gmp (e, v);\n-  mpz_clear (v);\n-}\n-\n-/* Set E[I] to integer X.  */\n-\n-static inline void\n-ppl_set_coef (ppl_Linear_Expression_t e, ppl_dimension_type i, int x)\n-{\n-  mpz_t v;\n-  mpz_init (v);\n-  mpz_set_si (v, x);\n-  ppl_set_coef_gmp (e, i, v);\n-  mpz_clear (v);\n-}\n-\n-/* Set E[I] to tree X.  */\n-\n-static inline void\n-ppl_set_coef_tree (ppl_Linear_Expression_t e, ppl_dimension_type i, tree x)\n-{\n-  mpz_t v;\n-  mpz_init (v);\n-  tree_int_to_gmp (x, v);\n-  ppl_set_coef_gmp (e, i, v);\n-  mpz_clear (v);\n-}\n-\n-/* Sets RES to the min of V1 and V2.  */\n-\n-static inline void\n-value_min (mpz_t res, mpz_t v1, mpz_t v2)\n-{\n-  if (mpz_cmp (v1, v2) < 0)\n-    mpz_set (res, v1);\n-  else\n-    mpz_set (res, v2);\n-}\n-\n-/* Sets RES to the max of V1 and V2.  */\n-\n-static inline void\n-value_max (mpz_t res, mpz_t v1, mpz_t v2)\n-{\n-  if (mpz_cmp (v1, v2) < 0)\n-    mpz_set (res, v2);\n-  else\n-    mpz_set (res, v1);\n-}\n-\n-/* Builds a new identity map for dimension DIM.  */\n-\n-static inline ppl_dimension_type *\n-ppl_new_id_map (ppl_dimension_type dim)\n-{\n-  ppl_dimension_type *map, i;\n-\n-  map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim);\n-\n-  for (i = 0; i < dim; i++)\n-    map[i] = i;\n-\n-  return map;\n-}\n-\n-/* Builds an interchange of dimensions A and B in MAP.  */\n-\n-static inline void\n-ppl_interchange (ppl_dimension_type *map,\n-\t\t ppl_dimension_type a,\n-\t\t ppl_dimension_type b)\n-{\n-  map[a] = b;\n-  map[b] = a;\n-}\n-\n-#endif\n-"}, {"sha": "cfa06ab60c5b9929abf1ff5d5e5951b61fba37c0", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,5 +1,5 @@\n /* Detection of Static Control Parts (SCoP) for Graphite.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@amd.com> and\n    Tobias Grosser <grosser@fim.uni-passau.de>.\n \n@@ -20,6 +20,15 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree-flow.h\"\n@@ -31,8 +40,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sese.h\"\n \n #ifdef HAVE_cloog\n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n #include \"graphite-scop-detection.h\"\n "}, {"sha": "eacfcf1b6e67bc4a3b231f31a6b985392230267e", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 561, "deletions": 650, "changes": 1211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -19,6 +19,18 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/union_map.h>\n+#include <isl/constraint.h>\n+#include <isl/aff.h>\n+#include <cloog/cloog.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree-flow.h\"\n@@ -31,11 +43,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sese.h\"\n \n #ifdef HAVE_cloog\n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n #include \"graphite-sese-to-poly.h\"\n \n+\n+/* Assigns to RES the value of the INTEGER_CST T.  */\n+\n+static inline void\n+tree_int_to_gmp (tree t, mpz_t res)\n+{\n+  double_int di = tree_to_double_int (t);\n+  mpz_set_double_int (res, di, TYPE_UNSIGNED (TREE_TYPE (t)));\n+}\n+\n /* Returns the index of the PHI argument defined in the outermost\n    loop.  */\n \n@@ -390,6 +410,16 @@ build_scop_bbs (scop_p scop)\n   sbitmap_free (visited);\n }\n \n+/* Return an ISL identifier for the polyhedral basic block PBB.  */\n+\n+static isl_id *\n+isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n+{\n+  char name[50];\n+  snprintf (name, sizeof (name), \"S_%d\", pbb_index (pbb));\n+  return isl_id_alloc (s->ctx, name, pbb);\n+}\n+\n /* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.\n    We generate SCATTERING_DIMENSIONS scattering dimensions.\n \n@@ -424,69 +454,54 @@ build_scop_bbs (scop_p scop)\n    | 0   0   1   0   0   0   0   0  -5  = 0  */\n \n static void\n-build_pbb_scattering_polyhedrons (ppl_Linear_Expression_t static_schedule,\n+build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n \t\t\t\t  poly_bb_p pbb, int scattering_dimensions)\n {\n   int i;\n-  scop_p scop = PBB_SCOP (pbb);\n   int nb_iterators = pbb_dim_iter_domain (pbb);\n   int used_scattering_dimensions = nb_iterators * 2 + 1;\n-  int nb_params = scop_nb_params (scop);\n-  ppl_Coefficient_t c;\n-  ppl_dimension_type dim = scattering_dimensions + nb_iterators + nb_params;\n-  mpz_t v;\n+  isl_int val;\n+  isl_space *dc, *dm;\n \n   gcc_assert (scattering_dimensions >= used_scattering_dimensions);\n \n-  mpz_init (v);\n-  ppl_new_Coefficient (&c);\n-  PBB_TRANSFORMED (pbb) = poly_scattering_new ();\n-  ppl_new_C_Polyhedron_from_space_dimension\n-    (&PBB_TRANSFORMED_SCATTERING (pbb), dim, 0);\n+  isl_int_init (val);\n \n-  PBB_NB_SCATTERING_TRANSFORM (pbb) = scattering_dimensions;\n+  dc = isl_set_get_space (pbb->domain);\n+  dm = isl_space_add_dims (isl_space_from_domain (dc),\n+\t\t\t   isl_dim_out, scattering_dimensions);\n+  pbb->schedule = isl_map_universe (dm);\n \n   for (i = 0; i < scattering_dimensions; i++)\n     {\n-      ppl_Constraint_t cstr;\n-      ppl_Linear_Expression_t expr;\n-\n-      ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-      mpz_set_si (v, 1);\n-      ppl_assign_Coefficient_from_mpz_t (c, v);\n-      ppl_Linear_Expression_add_to_coefficient (expr, i, c);\n-\n       /* Textual order inside this loop.  */\n       if ((i % 2) == 0)\n \t{\n-\t  ppl_Linear_Expression_coefficient (static_schedule, i / 2, c);\n-\t  ppl_Coefficient_to_mpz_t (c, v);\n-\t  mpz_neg (v, v);\n-\t  ppl_assign_Coefficient_from_mpz_t (c, v);\n-\t  ppl_Linear_Expression_add_to_inhomogeneous (expr, c);\n+\t  isl_constraint *c = isl_equality_alloc\n+\t      (isl_local_space_from_space (isl_map_get_space (pbb->schedule)));\n+\n+\t  if (0 != isl_aff_get_coefficient (static_sched, isl_dim_in,\n+\t\t\t\t\t    i / 2, &val))\n+\t    gcc_unreachable ();\n+\n+\t  isl_int_neg (val, val);\n+\t  c = isl_constraint_set_constant (c, val);\n+\t  c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n+\t  pbb->schedule = isl_map_add_constraint (pbb->schedule, c);\n \t}\n \n       /* Iterations of this loop.  */\n       else /* if ((i % 2) == 1) */\n \t{\n \t  int loop = (i - 1) / 2;\n-\n-\t  mpz_set_si (v, -1);\n-\t  ppl_assign_Coefficient_from_mpz_t (c, v);\n-\t  ppl_Linear_Expression_add_to_coefficient\n-\t    (expr, scattering_dimensions + loop, c);\n+\t  pbb->schedule = isl_map_equate (pbb->schedule, isl_dim_in, loop,\n+\t\t\t\t\t  isl_dim_out, i);\n \t}\n-\n-      ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n-      ppl_Polyhedron_add_constraint (PBB_TRANSFORMED_SCATTERING (pbb), cstr);\n-      ppl_delete_Linear_Expression (expr);\n-      ppl_delete_Constraint (cstr);\n     }\n \n-  mpz_clear (v);\n-  ppl_delete_Coefficient (c);\n+  isl_int_clear (val);\n \n-  PBB_ORIGINAL (pbb) = poly_scattering_copy (PBB_TRANSFORMED (pbb));\n+  pbb->transformed = isl_map_copy (pbb->schedule);\n }\n \n /* Build for BB the static schedule.\n@@ -531,26 +546,21 @@ build_scop_scattering (scop_p scop)\n   int i;\n   poly_bb_p pbb;\n   gimple_bb_p previous_gbb = NULL;\n-  ppl_Linear_Expression_t static_schedule;\n-  ppl_Coefficient_t c;\n-  mpz_t v;\n+  isl_space *dc = isl_set_get_space (scop->context);\n+  isl_aff *static_sched;\n \n-  mpz_init (v);\n-  ppl_new_Coefficient (&c);\n-  ppl_new_Linear_Expression (&static_schedule);\n+  dc = isl_space_add_dims (dc, isl_dim_set, number_of_loops());\n+  static_sched = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n \n   /* We have to start schedules at 0 on the first component and\n      because we cannot compare_prefix_loops against a previous loop,\n      prefix will be equal to zero, and that index will be\n      incremented before copying.  */\n-  mpz_set_si (v, -1);\n-  ppl_assign_Coefficient_from_mpz_t (c, v);\n-  ppl_Linear_Expression_add_to_coefficient (static_schedule, 0, c);\n+  static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in, 0, -1);\n \n   FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     {\n       gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-      ppl_Linear_Expression_t common;\n       int prefix;\n       int nb_scat_dims = pbb_dim_iter_domain (pbb) * 2 + 1;\n \n@@ -560,102 +570,158 @@ build_scop_scattering (scop_p scop)\n \tprefix = 0;\n \n       previous_gbb = gbb;\n-      ppl_new_Linear_Expression_with_dimension (&common, prefix + 1);\n-      ppl_assign_Linear_Expression_from_Linear_Expression (common,\n-\t\t\t\t\t\t\t   static_schedule);\n \n-      mpz_set_si (v, 1);\n-      ppl_assign_Coefficient_from_mpz_t (c, v);\n-      ppl_Linear_Expression_add_to_coefficient (common, prefix, c);\n-      ppl_assign_Linear_Expression_from_Linear_Expression (static_schedule,\n-\t\t\t\t\t\t\t   common);\n+      static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in,\n+\t\t\t\t\t\t prefix, 1);\n+      build_pbb_scattering_polyhedrons (static_sched, pbb, nb_scat_dims);\n+    }\n+\n+  isl_aff_free (static_sched);\n+}\n+\n+static isl_pw_aff *extract_affine (scop_p, tree, __isl_take isl_space *space);\n+\n+/* Extract an affine expression from the chain of recurrence E.  */\n+\n+static isl_pw_aff *\n+extract_affine_chrec (scop_p s, tree e, __isl_take isl_space *space)\n+{\n+  isl_pw_aff *lhs = extract_affine (s, CHREC_LEFT (e), isl_space_copy (space));\n+  isl_pw_aff *rhs = extract_affine (s, CHREC_RIGHT (e), isl_space_copy (space));\n+  isl_local_space *ls = isl_local_space_from_space (space);\n+  unsigned pos = sese_loop_depth ((sese) s->region,\n+\t\t\t\t  get_loop (CHREC_VARIABLE (e))) - 1;\n+  isl_aff *loop = isl_aff_set_coefficient_si\n+    (isl_aff_zero_on_domain (ls), isl_dim_in, pos, 1);\n+  isl_pw_aff *l = isl_pw_aff_from_aff (loop);\n+\n+  /* Before multiplying, make sure that the result is affine.  */\n+  gcc_assert (isl_pw_aff_is_cst (rhs)\n+\t      || isl_pw_aff_is_cst (l));\n+\n+  return isl_pw_aff_add (lhs, isl_pw_aff_mul (rhs, l));\n+}\n+\n+/* Extract an affine expression from the mult_expr E.  */\n+\n+static isl_pw_aff *\n+extract_affine_mul (scop_p s, tree e, __isl_take isl_space *space)\n+{\n+  isl_pw_aff *lhs = extract_affine (s, TREE_OPERAND (e, 0),\n+\t\t\t\t    isl_space_copy (space));\n+  isl_pw_aff *rhs = extract_affine (s, TREE_OPERAND (e, 1), space);\n+\n+  if (!isl_pw_aff_is_cst (lhs)\n+      && !isl_pw_aff_is_cst (rhs))\n+    {\n+      isl_pw_aff_free (lhs);\n+      isl_pw_aff_free (rhs);\n+      return NULL;\n+    }\n \n-      build_pbb_scattering_polyhedrons (common, pbb, nb_scat_dims);\n+  return isl_pw_aff_mul (lhs, rhs);\n+}\n \n-      ppl_delete_Linear_Expression (common);\n+/* Return an ISL identifier from the name of the ssa_name E.  */\n+\n+static isl_id *\n+isl_id_for_ssa_name (scop_p s, tree e)\n+{\n+  const char *name = get_name (e);\n+  isl_id *id;\n+\n+  if (name)\n+    id = isl_id_alloc (s->ctx, name, e);\n+  else\n+    {\n+      char name1[50];\n+      snprintf (name1, sizeof (name1), \"P_%d\", SSA_NAME_VERSION (e));\n+      id = isl_id_alloc (s->ctx, name1, e);\n     }\n \n-  mpz_clear (v);\n-  ppl_delete_Coefficient (c);\n-  ppl_delete_Linear_Expression (static_schedule);\n+  return id;\n }\n \n-/* Add the value K to the dimension D of the linear expression EXPR.  */\n+/* Return an ISL identifier for the data reference DR.  */\n \n-static void\n-add_value_to_dim (ppl_dimension_type d, ppl_Linear_Expression_t expr,\n-\t\t  mpz_t k)\n+static isl_id *\n+isl_id_for_dr (scop_p s, data_reference_p dr ATTRIBUTE_UNUSED)\n {\n-  mpz_t val;\n-  ppl_Coefficient_t coef;\n+  /* Data references all get the same isl_id.  They need to be comparable\n+     and are distinguished through the first dimension, which contains the\n+     alias set number.  */\n+  return isl_id_alloc (s->ctx, \"\", 0);\n+}\n \n-  ppl_new_Coefficient (&coef);\n-  ppl_Linear_Expression_coefficient (expr, d, coef);\n-  mpz_init (val);\n-  ppl_Coefficient_to_mpz_t (coef, val);\n+/* Extract an affine expression from the ssa_name E.  */\n \n-  mpz_add (val, val, k);\n+static isl_pw_aff *\n+extract_affine_name (scop_p s, tree e, __isl_take isl_space *space)\n+{\n+  isl_aff *aff;\n+  isl_set *dom;\n+  isl_id *id;\n+  int dimension;\n \n-  ppl_assign_Coefficient_from_mpz_t (coef, val);\n-  ppl_Linear_Expression_add_to_coefficient (expr, d, coef);\n-  mpz_clear (val);\n-  ppl_delete_Coefficient (coef);\n+  id = isl_id_for_ssa_name (s, e);\n+  dimension = isl_space_find_dim_by_id (space, isl_dim_param, id);\n+  isl_id_free(id);\n+  dom = isl_set_universe (isl_space_copy (space));\n+  aff = isl_aff_zero_on_domain (isl_local_space_from_space (space));\n+  aff = isl_aff_add_coefficient_si (aff, isl_dim_param, dimension, 1);\n+  return isl_pw_aff_alloc (dom, aff);\n }\n \n-/* In the context of scop S, scan E, the right hand side of a scalar\n-   evolution function in loop VAR, and translate it to a linear\n-   expression EXPR.  */\n+/* Extract an affine expression from the gmp constant G.  */\n \n-static void\n-scan_tree_for_params_right_scev (sese s, tree e, int var,\n-\t\t\t\t ppl_Linear_Expression_t expr)\n+static isl_pw_aff *\n+extract_affine_gmp (mpz_t g, __isl_take isl_space *space)\n {\n-  if (expr)\n-    {\n-      loop_p loop = get_loop (var);\n-      ppl_dimension_type l = sese_loop_depth (s, loop) - 1;\n-      mpz_t val;\n+  isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n+  isl_aff *aff = isl_aff_zero_on_domain (ls);\n+  isl_set *dom = isl_set_universe (space);\n+  isl_int v;\n \n-      /* Scalar evolutions should happen in the sese region.  */\n-      gcc_assert (sese_loop_depth (s, loop) > 0);\n+  isl_int_init (v);\n+  isl_int_set_gmp (v, g);\n+  aff = isl_aff_add_constant (aff, v);\n+  isl_int_clear (v);\n \n-      /* We can not deal with parametric strides like:\n+  return isl_pw_aff_alloc (dom, aff);\n+}\n \n-      | p = parameter;\n-      |\n-      | for i:\n-      |   a [i * p] = ...   */\n-      gcc_assert (TREE_CODE (e) == INTEGER_CST);\n+/* Extract an affine expression from the integer_cst E.  */\n \n-      mpz_init (val);\n-      tree_int_to_gmp (e, val);\n-      add_value_to_dim (l, expr, val);\n-      mpz_clear (val);\n-    }\n+static isl_pw_aff *\n+extract_affine_int (tree e, __isl_take isl_space *space)\n+{\n+  isl_pw_aff *res;\n+  mpz_t g;\n+\n+  mpz_init (g);\n+  tree_int_to_gmp (e, g);\n+  res = extract_affine_gmp (g, space);\n+  mpz_clear (g);\n+\n+  return res;\n }\n \n-/* Scan the integer constant CST, and add it to the inhomogeneous part of the\n-   linear expression EXPR.  K is the multiplier of the constant.  */\n+/* Compute pwaff mod 2^width.  */\n \n-static void\n-scan_tree_for_params_int (tree cst, ppl_Linear_Expression_t expr, mpz_t k)\n+static isl_pw_aff *\n+wrap (isl_pw_aff *pwaff, unsigned width)\n {\n-  mpz_t val;\n-  ppl_Coefficient_t coef;\n-  tree type = TREE_TYPE (cst);\n+  isl_int mod;\n+\n+  isl_int_init (mod);\n+  isl_int_set_si (mod, 1);\n+  isl_int_mul_2exp (mod, mod, width);\n \n-  mpz_init (val);\n+  pwaff = isl_pw_aff_mod (pwaff, mod);\n \n-  /* Necessary to not get \"-1 = 2^n - 1\". */\n-  mpz_set_double_int (val, double_int_sext (tree_to_double_int (cst),\n-\t\t\t\t\t    TYPE_PRECISION (type)), false);\n+  isl_int_clear (mod);\n \n-  mpz_mul (val, val, k);\n-  ppl_new_Coefficient (&coef);\n-  ppl_assign_Coefficient_from_mpz_t (coef, val);\n-  ppl_Linear_Expression_add_to_inhomogeneous (expr, coef);\n-  mpz_clear (val);\n-  ppl_delete_Coefficient (coef);\n+  return pwaff;\n }\n \n /* When parameter NAME is in REGION, returns its index in SESE_PARAMS.\n@@ -698,168 +764,119 @@ parameter_index_in_region (tree name, sese region)\n   return i;\n }\n \n-/* In the context of sese S, scan the expression E and translate it to\n-   a linear expression C.  When parsing a symbolic multiplication, K\n-   represents the constant multiplier of an expression containing\n-   parameters.  */\n+/* Extract an affine expression from the tree E in the scop S.  */\n \n-static void\n-scan_tree_for_params (sese s, tree e, ppl_Linear_Expression_t c,\n-\t\t      mpz_t k)\n+static isl_pw_aff *\n+extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n {\n-  if (e == chrec_dont_know)\n-    return;\n+  isl_pw_aff *lhs, *rhs, *res;\n+  tree type;\n+\n+  if (e == chrec_dont_know) {\n+    isl_space_free (space);\n+    return NULL;\n+  }\n \n   switch (TREE_CODE (e))\n     {\n     case POLYNOMIAL_CHREC:\n-      scan_tree_for_params_right_scev (s, CHREC_RIGHT (e),\n-\t\t\t\t       CHREC_VARIABLE (e), c);\n-      scan_tree_for_params (s, CHREC_LEFT (e), c, k);\n+      res = extract_affine_chrec (s, e, space);\n       break;\n \n     case MULT_EXPR:\n-      if (chrec_contains_symbols (TREE_OPERAND (e, 0)))\n-\t{\n-\t  if (c)\n-\t    {\n-\t      mpz_t val;\n-\t      gcc_assert (host_integerp (TREE_OPERAND (e, 1), 0));\n-\t      mpz_init (val);\n-\t      tree_int_to_gmp (TREE_OPERAND (e, 1), val);\n-\t      mpz_mul (val, val, k);\n-\t      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, val);\n-\t      mpz_clear (val);\n-\t    }\n-\t  else\n-\t    scan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n-\t}\n-      else\n-\t{\n-\t  if (c)\n-\t    {\n-\t      mpz_t val;\n-\t      gcc_assert (host_integerp (TREE_OPERAND (e, 0), 0));\n-\t      mpz_init (val);\n-\t      tree_int_to_gmp (TREE_OPERAND (e, 0), val);\n-\t      mpz_mul (val, val, k);\n-\t      scan_tree_for_params (s, TREE_OPERAND (e, 1), c, val);\n-\t      mpz_clear (val);\n-\t    }\n-\t  else\n-\t    scan_tree_for_params (s, TREE_OPERAND (e, 1), c, k);\n-\t}\n+      res = extract_affine_mul (s, e, space);\n       break;\n \n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n-      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n-      scan_tree_for_params (s, TREE_OPERAND (e, 1), c, k);\n+      lhs = extract_affine (s, TREE_OPERAND (e, 0), isl_space_copy (space));\n+      rhs = extract_affine (s, TREE_OPERAND (e, 1), space);\n+      res = isl_pw_aff_add (lhs, rhs);\n       break;\n \n     case MINUS_EXPR:\n-      {\n-\tppl_Linear_Expression_t tmp_expr = NULL;\n-\n-        if (c)\n-\t  {\n-\t    ppl_dimension_type dim;\n-\t    ppl_Linear_Expression_space_dimension (c, &dim);\n-\t    ppl_new_Linear_Expression_with_dimension (&tmp_expr, dim);\n-\t  }\n-\n-\tscan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n-\tscan_tree_for_params (s, TREE_OPERAND (e, 1), tmp_expr, k);\n-\n-\tif (c)\n-\t  {\n-\t    ppl_subtract_Linear_Expression_from_Linear_Expression (c,\n-\t\t\t\t\t\t\t\t   tmp_expr);\n-\t    ppl_delete_Linear_Expression (tmp_expr);\n-\t  }\n-\n-\tbreak;\n-      }\n+      lhs = extract_affine (s, TREE_OPERAND (e, 0), isl_space_copy (space));\n+      rhs = extract_affine (s, TREE_OPERAND (e, 1), space);\n+      res = isl_pw_aff_sub (lhs, rhs);\n+      break;\n \n     case NEGATE_EXPR:\n-      {\n-\tppl_Linear_Expression_t tmp_expr = NULL;\n-\n-\tif (c)\n-\t  {\n-\t    ppl_dimension_type dim;\n-\t    ppl_Linear_Expression_space_dimension (c, &dim);\n-\t    ppl_new_Linear_Expression_with_dimension (&tmp_expr, dim);\n-\t  }\n+    case BIT_NOT_EXPR:\n+      lhs = extract_affine (s, TREE_OPERAND (e, 0), isl_space_copy (space));\n+      rhs = extract_affine (s, integer_minus_one_node, space);\n+      res = isl_pw_aff_mul (lhs, rhs);\n+      break;\n \n-\tscan_tree_for_params (s, TREE_OPERAND (e, 0), tmp_expr, k);\n+    case SSA_NAME:\n+      gcc_assert (-1 != parameter_index_in_region_1 (e, SCOP_REGION (s)));\n+      res = extract_affine_name (s, e, space);\n+      break;\n \n-\tif (c)\n-\t  {\n-\t    ppl_subtract_Linear_Expression_from_Linear_Expression (c,\n-\t\t\t\t\t\t\t\t   tmp_expr);\n-\t    ppl_delete_Linear_Expression (tmp_expr);\n-\t  }\n+    case INTEGER_CST:\n+      res = extract_affine_int (e, space);\n+      /* No need to wrap a single integer.  */\n+      return res;\n \n-\tbreak;\n-      }\n+    CASE_CONVERT:\n+    case NON_LVALUE_EXPR:\n+      res = extract_affine (s, TREE_OPERAND (e, 0), space);\n+      break;\n \n-    case BIT_NOT_EXPR:\n-      {\n-\tppl_Linear_Expression_t tmp_expr = NULL;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n \n-\tif (c)\n-\t  {\n-\t    ppl_dimension_type dim;\n-\t    ppl_Linear_Expression_space_dimension (c, &dim);\n-\t    ppl_new_Linear_Expression_with_dimension (&tmp_expr, dim);\n-\t  }\n+  type = TREE_TYPE (e);\n+  if (TYPE_UNSIGNED (type))\n+    res = wrap (res, TYPE_PRECISION (type));\n \n-\tscan_tree_for_params (s, TREE_OPERAND (e, 0), tmp_expr, k);\n+  return res;\n+}\n \n-\tif (c)\n-\t  {\n-\t    ppl_Coefficient_t coef;\n-\t    mpz_t minus_one;\n-\n-\t    ppl_subtract_Linear_Expression_from_Linear_Expression (c,\n-\t\t\t\t\t\t\t\t   tmp_expr);\n-\t    ppl_delete_Linear_Expression (tmp_expr);\n-\t    mpz_init (minus_one);\n-\t    mpz_set_si (minus_one, -1);\n-\t    ppl_new_Coefficient_from_mpz_t (&coef, minus_one);\n-\t    ppl_Linear_Expression_add_to_inhomogeneous (c, coef);\n-\t    mpz_clear (minus_one);\n-\t    ppl_delete_Coefficient (coef);\n-\t  }\n+/* In the context of sese S, scan the expression E and translate it to\n+   a linear expression C.  When parsing a symbolic multiplication, K\n+   represents the constant multiplier of an expression containing\n+   parameters.  */\n \n-\tbreak;\n-      }\n+static void\n+scan_tree_for_params (sese s, tree e)\n+{\n+  if (e == chrec_dont_know)\n+    return;\n \n-    case SSA_NAME:\n-      {\n-\tppl_dimension_type p = parameter_index_in_region (e, s);\n+  switch (TREE_CODE (e))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      scan_tree_for_params (s, CHREC_LEFT (e));\n+      break;\n \n-\tif (c)\n-\t  {\n-\t    ppl_dimension_type dim;\n-\t    ppl_Linear_Expression_space_dimension (c, &dim);\n-\t    p += dim - sese_nb_params (s);\n-\t    add_value_to_dim (p, c, k);\n-\t  }\n-\tbreak;\n-      }\n+    case MULT_EXPR:\n+      if (chrec_contains_symbols (TREE_OPERAND (e, 0)))\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 0));\n+      else\n+\tscan_tree_for_params (s, TREE_OPERAND (e, 1));\n+      break;\n \n-    case INTEGER_CST:\n-      if (c)\n-\tscan_tree_for_params_int (e, c, k);\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case MINUS_EXPR:\n+      scan_tree_for_params (s, TREE_OPERAND (e, 0));\n+      scan_tree_for_params (s, TREE_OPERAND (e, 1));\n       break;\n \n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n     CASE_CONVERT:\n     case NON_LVALUE_EXPR:\n-      scan_tree_for_params (s, TREE_OPERAND (e, 0), c, k);\n+      scan_tree_for_params (s, TREE_OPERAND (e, 0));\n       break;\n \n+    case SSA_NAME:\n+      parameter_index_in_region (e, s);\n+      break;\n+\n+    case INTEGER_CST:\n     case ADDR_EXPR:\n       break;\n \n@@ -880,15 +897,11 @@ find_params_in_bb (sese region, gimple_bb_p gbb)\n   data_reference_p dr;\n   gimple stmt;\n   loop_p loop = GBB_BB (gbb)->loop_father;\n-  mpz_t one;\n-\n-  mpz_init (one);\n-  mpz_set_si (one, 1);\n \n   /* Find parameters in the access functions of data references.  */\n   FOR_EACH_VEC_ELT (data_reference_p, GBB_DATA_REFS (gbb), i, dr)\n     for (j = 0; j < DR_NUM_DIMENSIONS (dr); j++)\n-      scan_tree_for_params (region, DR_ACCESS_FN (dr, j), NULL, one);\n+      scan_tree_for_params (region, DR_ACCESS_FN (dr, j));\n \n   /* Find parameters in conditional statements.  */\n   FOR_EACH_VEC_ELT (gimple, GBB_CONDITIONS (gbb), i, stmt)\n@@ -898,11 +911,9 @@ find_params_in_bb (sese region, gimple_bb_p gbb)\n       tree rhs = scalar_evolution_in_region (region, loop,\n \t\t\t\t\t     gimple_cond_rhs (stmt));\n \n-      scan_tree_for_params (region, lhs, NULL, one);\n-      scan_tree_for_params (region, rhs, NULL, one);\n+      scan_tree_for_params (region, lhs);\n+      scan_tree_for_params (region, rhs);\n     }\n-\n-  mpz_clear (one);\n }\n \n /* Record the parameters used in the SCOP.  A variable is a parameter\n@@ -915,10 +926,7 @@ find_scop_parameters (scop_p scop)\n   unsigned i;\n   sese region = SCOP_REGION (scop);\n   struct loop *loop;\n-  mpz_t one;\n-\n-  mpz_init (one);\n-  mpz_set_si (one, 1);\n+  int nbp;\n \n   /* Find the parameters used in the loop bounds.  */\n   FOR_EACH_VEC_ELT (loop_p, SESE_LOOP_NEST (region), i, loop)\n@@ -929,320 +937,207 @@ find_scop_parameters (scop_p scop)\n \tcontinue;\n \n       nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n-      scan_tree_for_params (region, nb_iters, NULL, one);\n+      scan_tree_for_params (region, nb_iters);\n     }\n \n-  mpz_clear (one);\n-\n   /* Find the parameters used in data accesses.  */\n   FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n     find_params_in_bb (region, PBB_BLACK_BOX (pbb));\n \n-  scop_set_nb_params (scop, sese_nb_params (region));\n+  nbp = sese_nb_params (region);\n+  scop_set_nb_params (scop, nbp);\n   SESE_ADD_PARAMS (region) = false;\n \n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension\n-    (&SCOP_CONTEXT (scop), scop_nb_params (scop), 0);\n-}\n-\n-/* Insert in the SCOP context constraints from the estimation of the\n-   number of iterations.  UB_EXPR is a linear expression describing\n-   the number of iterations in a loop.  This expression is bounded by\n-   the estimation NIT.  */\n-\n-static void\n-add_upper_bounds_from_estimated_nit (scop_p scop, double_int nit,\n-\t\t\t\t     ppl_dimension_type dim,\n-\t\t\t\t     ppl_Linear_Expression_t ub_expr)\n-{\n-  mpz_t val;\n-  ppl_Linear_Expression_t nb_iters_le;\n-  ppl_Polyhedron_t pol;\n-  ppl_Coefficient_t coef;\n-  ppl_Constraint_t ub;\n-\n-  ppl_new_C_Polyhedron_from_space_dimension (&pol, dim, 0);\n-  ppl_new_Linear_Expression_from_Linear_Expression (&nb_iters_le,\n-\t\t\t\t\t\t    ub_expr);\n-\n-  /* Construct the negated number of last iteration in VAL.  */\n-  mpz_init (val);\n-  mpz_set_double_int (val, nit, false);\n-  mpz_sub_ui (val, val, 1);\n-  mpz_neg (val, val);\n-\n-  /* NB_ITERS_LE holds the number of last iteration in\n-     parametrical form.  Subtract estimated number of last\n-     iteration and assert that result is not positive.  */\n-  ppl_new_Coefficient_from_mpz_t (&coef, val);\n-  ppl_Linear_Expression_add_to_inhomogeneous (nb_iters_le, coef);\n-  ppl_delete_Coefficient (coef);\n-  ppl_new_Constraint (&ub, nb_iters_le,\n-\t\t      PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL);\n-  ppl_Polyhedron_add_constraint (pol, ub);\n-\n-  /* Remove all but last GDIM dimensions from POL to obtain\n-     only the constraints on the parameters.  */\n   {\n-    graphite_dim_t gdim = scop_nb_params (scop);\n-    ppl_dimension_type *dims = XNEWVEC (ppl_dimension_type, dim - gdim);\n-    graphite_dim_t i;\n-\n-    for (i = 0; i < dim - gdim; i++)\n-      dims[i] = i;\n-\n-    ppl_Polyhedron_remove_space_dimensions (pol, dims, dim - gdim);\n-    XDELETEVEC (dims);\n-  }\n+    tree e;\n+    isl_space *space = isl_space_set_alloc (scop->ctx, nbp, 0);\n \n-  /* Add the constraints on the parameters to the SCoP context.  */\n-  {\n-    ppl_Pointset_Powerset_C_Polyhedron_t constraints_ps;\n+    FOR_EACH_VEC_ELT (tree, SESE_PARAMS (region), i, e)\n+      space = isl_space_set_dim_id (space, isl_dim_param, i,\n+\t\t\t\t    isl_id_for_ssa_name (scop, e));\n \n-    ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-      (&constraints_ps, pol);\n-    ppl_Pointset_Powerset_C_Polyhedron_intersection_assign\n-      (SCOP_CONTEXT (scop), constraints_ps);\n-    ppl_delete_Pointset_Powerset_C_Polyhedron (constraints_ps);\n+    scop->context = isl_set_universe (space);\n   }\n-\n-  ppl_delete_Polyhedron (pol);\n-  ppl_delete_Linear_Expression (nb_iters_le);\n-  ppl_delete_Constraint (ub);\n-  mpz_clear (val);\n }\n \n /* Builds the constraint polyhedra for LOOP in SCOP.  OUTER_PH gives\n    the constraints for the surrounding loops.  */\n \n static void\n build_loop_iteration_domains (scop_p scop, struct loop *loop,\n-                              ppl_Polyhedron_t outer_ph, int nb,\n-\t\t\t      ppl_Pointset_Powerset_C_Polyhedron_t *domains)\n+                              int nb,\n+\t\t\t      isl_set *outer, isl_set **doms)\n {\n-  int i;\n-  ppl_Polyhedron_t ph;\n   tree nb_iters = number_of_latch_executions (loop);\n-  ppl_dimension_type dim = nb + 1 + scop_nb_params (scop);\n   sese region = SCOP_REGION (scop);\n \n-  {\n-    ppl_const_Constraint_System_t pcs;\n-    ppl_dimension_type *map\n-      = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim);\n-\n-    ppl_new_C_Polyhedron_from_space_dimension (&ph, dim, 0);\n-    ppl_Polyhedron_get_constraints (outer_ph, &pcs);\n-    ppl_Polyhedron_add_constraints (ph, pcs);\n-\n-    for (i = 0; i < (int) nb; i++)\n-      map[i] = i;\n-    for (i = (int) nb; i < (int) dim - 1; i++)\n-      map[i] = i + 1;\n-    map[dim - 1] = nb;\n-\n-    ppl_Polyhedron_map_space_dimensions (ph, map, dim);\n-    free (map);\n-  }\n+  isl_set *inner = isl_set_copy (outer);\n+  isl_space *space;\n+  isl_constraint *c;\n+  int pos = isl_set_dim (outer, isl_dim_set);\n+  isl_int v;\n+  mpz_t g;\n+\n+  mpz_init (g);\n+  isl_int_init (v);\n+\n+  inner = isl_set_add_dims (inner, isl_dim_set, 1);\n+  space = isl_set_get_space (inner);\n \n   /* 0 <= loop_i */\n-  {\n-    ppl_Constraint_t lb;\n-    ppl_Linear_Expression_t lb_expr;\n-\n-    ppl_new_Linear_Expression_with_dimension (&lb_expr, dim);\n-    ppl_set_coef (lb_expr, nb, 1);\n-    ppl_new_Constraint (&lb, lb_expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-    ppl_delete_Linear_Expression (lb_expr);\n-    ppl_Polyhedron_add_constraint (ph, lb);\n-    ppl_delete_Constraint (lb);\n-  }\n+  c = isl_inequality_alloc\n+      (isl_local_space_from_space (isl_space_copy (space)));\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, 1);\n+  inner = isl_set_add_constraint (inner, c);\n \n+  /* loop_i <= cst_nb_iters */\n   if (TREE_CODE (nb_iters) == INTEGER_CST)\n     {\n-      ppl_Constraint_t ub;\n-      ppl_Linear_Expression_t ub_expr;\n-\n-      ppl_new_Linear_Expression_with_dimension (&ub_expr, dim);\n-\n-      /* loop_i <= cst_nb_iters */\n-      ppl_set_coef (ub_expr, nb, -1);\n-      ppl_set_inhomogeneous_tree (ub_expr, nb_iters);\n-      ppl_new_Constraint (&ub, ub_expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-      ppl_Polyhedron_add_constraint (ph, ub);\n-      ppl_delete_Linear_Expression (ub_expr);\n-      ppl_delete_Constraint (ub);\n+      c = isl_inequality_alloc\n+\t  (isl_local_space_from_space(isl_space_copy (space)));\n+      c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n+      tree_int_to_gmp (nb_iters, g);\n+      isl_int_set_gmp (v, g);\n+      c = isl_constraint_set_constant (c, v);\n+      inner = isl_set_add_constraint (inner, c);\n     }\n+\n+  /* loop_i <= expr_nb_iters */\n   else if (!chrec_contains_undetermined (nb_iters))\n     {\n-      mpz_t one;\n-      ppl_Constraint_t ub;\n-      ppl_Linear_Expression_t ub_expr;\n       double_int nit;\n+      isl_pw_aff *aff;\n+      isl_set *valid;\n+      isl_local_space *ls;\n+      isl_aff *al;\n+      isl_set *le;\n \n-      mpz_init (one);\n-      mpz_set_si (one, 1);\n-      ppl_new_Linear_Expression_with_dimension (&ub_expr, dim);\n       nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n-      scan_tree_for_params (SCOP_REGION (scop), nb_iters, ub_expr, one);\n-      mpz_clear (one);\n+\n+      aff = extract_affine (scop, nb_iters, isl_set_get_space (inner));\n+      valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (aff));\n+      valid = isl_set_project_out (valid, isl_dim_set, 0,\n+\t\t\t\t   isl_set_dim (valid, isl_dim_set));\n+      scop->context = isl_set_intersect (scop->context, valid);\n+\n+      ls = isl_local_space_from_space (isl_space_copy (space));\n+      al = isl_aff_set_coefficient_si (isl_aff_zero_on_domain (ls),\n+\t\t\t\t       isl_dim_in, pos, 1);\n+      le = isl_pw_aff_le_set (isl_pw_aff_from_aff (al),\n+\t\t\t      isl_pw_aff_copy (aff));\n+      inner = isl_set_intersect (inner, le);\n \n       if (max_stmt_executions (loop, &nit))\n-\tadd_upper_bounds_from_estimated_nit (scop, nit, dim, ub_expr);\n-\n-      /* loop_i <= expr_nb_iters */\n-      ppl_set_coef (ub_expr, nb, -1);\n-      ppl_new_Constraint (&ub, ub_expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-      ppl_Polyhedron_add_constraint (ph, ub);\n-      ppl_delete_Linear_Expression (ub_expr);\n-      ppl_delete_Constraint (ub);\n+\t{\n+\t  /* Insert in the context the constraints from the\n+\t     estimation of the number of iterations NIT and the\n+\t     symbolic number of iterations (involving parameter\n+\t     names) NB_ITERS.  First, build the affine expression\n+\t     \"NIT - NB_ITERS\" and then say that it is positive,\n+\t     i.e., NIT approximates NB_ITERS: \"NIT >= NB_ITERS\".  */\n+\t  isl_pw_aff *approx;\n+\t  mpz_t g;\n+\t  isl_set *x;\n+\t  isl_constraint *c;\n+\n+\t  mpz_init (g);\n+\t  mpz_set_double_int (g, nit, false);\n+\t  mpz_sub_ui (g, g, 1);\n+\t  approx = extract_affine_gmp (g, isl_set_get_space (inner));\n+\t  x = isl_pw_aff_ge_set (approx, aff);\n+\t  x = isl_set_project_out (x, isl_dim_set, 0,\n+\t\t\t\t   isl_set_dim (x, isl_dim_set));\n+\t  scop->context = isl_set_intersect (scop->context, x);\n+\n+\t  c = isl_inequality_alloc\n+\t      (isl_local_space_from_space (isl_space_copy (space)));\n+\t  c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n+\t  isl_int_set_gmp (v, g);\n+\t  mpz_clear (g);\n+\t  c = isl_constraint_set_constant (c, v);\n+\t  inner = isl_set_add_constraint (inner, c);\n+\t}\n     }\n   else\n     gcc_unreachable ();\n \n   if (loop->inner && loop_in_sese_p (loop->inner, region))\n-    build_loop_iteration_domains (scop, loop->inner, ph, nb + 1, domains);\n+    build_loop_iteration_domains (scop, loop->inner, nb + 1,\n+\t\t\t\t  isl_set_copy (inner), doms);\n \n   if (nb != 0\n       && loop->next\n       && loop_in_sese_p (loop->next, region))\n-    build_loop_iteration_domains (scop, loop->next, outer_ph, nb, domains);\n+    build_loop_iteration_domains (scop, loop->next, nb,\n+\t\t\t\t  isl_set_copy (outer), doms);\n \n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-    (&domains[loop->num], ph);\n+  doms[loop->num] = inner;\n \n-  ppl_delete_Polyhedron (ph);\n+  isl_set_free (outer);\n+  isl_space_free (space);\n+  isl_int_clear (v);\n+  mpz_clear (g);\n }\n \n /* Returns a linear expression for tree T evaluated in PBB.  */\n \n-static ppl_Linear_Expression_t\n-create_linear_expr_from_tree (poly_bb_p pbb, tree t)\n+static isl_pw_aff *\n+create_pw_aff_from_tree (poly_bb_p pbb, tree t)\n {\n-  mpz_t one;\n-  ppl_Linear_Expression_t res;\n-  ppl_dimension_type dim;\n-  sese region = SCOP_REGION (PBB_SCOP (pbb));\n-  loop_p loop = pbb_loop (pbb);\n-\n-  dim = pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb);\n-  ppl_new_Linear_Expression_with_dimension (&res, dim);\n+  scop_p scop = PBB_SCOP (pbb);\n \n-  t = scalar_evolution_in_region (region, loop, t);\n+  t = scalar_evolution_in_region (SCOP_REGION (scop), pbb_loop (pbb), t);\n   gcc_assert (!automatically_generated_chrec_p (t));\n \n-  mpz_init (one);\n-  mpz_set_si (one, 1);\n-  scan_tree_for_params (region, t, res, one);\n-  mpz_clear (one);\n-\n-  return res;\n-}\n-\n-/* Returns the ppl constraint type from the gimple tree code CODE.  */\n-\n-static enum ppl_enum_Constraint_Type\n-ppl_constraint_type_from_tree_code (enum tree_code code)\n-{\n-  switch (code)\n-    {\n-    /* We do not support LT and GT to be able to work with C_Polyhedron.\n-       As we work on integer polyhedron \"a < b\" can be expressed by\n-       \"a + 1 <= b\".  */\n-    case LT_EXPR:\n-    case GT_EXPR:\n-      gcc_unreachable ();\n-\n-    case LE_EXPR:\n-      return PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL;\n-\n-    case GE_EXPR:\n-      return PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL;\n-\n-    case EQ_EXPR:\n-      return PPL_CONSTRAINT_TYPE_EQUAL;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  return extract_affine (scop, t, isl_set_get_space (pbb->domain));\n }\n \n-/* Add conditional statement STMT to PS.  It is evaluated in PBB and\n-   CODE is used as the comparison operator.  This allows us to invert the\n-   condition or to handle inequalities.  */\n+/* Add conditional statement STMT to pbb.  CODE is used as the comparison\n+   operator.  This allows us to invert the condition or to handle\n+   inequalities.  */\n \n static void\n-add_condition_to_domain (ppl_Pointset_Powerset_C_Polyhedron_t ps, gimple stmt,\n-\t\t\t poly_bb_p pbb, enum tree_code code)\n+add_condition_to_pbb (poly_bb_p pbb, gimple stmt, enum tree_code code)\n {\n-  mpz_t v;\n-  ppl_Coefficient_t c;\n-  ppl_Linear_Expression_t left, right;\n-  ppl_Constraint_t cstr;\n-  enum ppl_enum_Constraint_Type type;\n-\n-  left = create_linear_expr_from_tree (pbb, gimple_cond_lhs (stmt));\n-  right = create_linear_expr_from_tree (pbb, gimple_cond_rhs (stmt));\n+  isl_pw_aff *lhs = create_pw_aff_from_tree (pbb, gimple_cond_lhs (stmt));\n+  isl_pw_aff *rhs = create_pw_aff_from_tree (pbb, gimple_cond_rhs (stmt));\n+  isl_set *cond;\n \n-  /* If we have < or > expressions convert them to <= or >= by adding 1 to\n-     the left or the right side of the expression. */\n-  if (code == LT_EXPR)\n-    {\n-      mpz_init (v);\n-      mpz_set_si (v, 1);\n-      ppl_new_Coefficient (&c);\n-      ppl_assign_Coefficient_from_mpz_t (c, v);\n-      ppl_Linear_Expression_add_to_inhomogeneous (left, c);\n-      ppl_delete_Coefficient (c);\n-      mpz_clear (v);\n-\n-      code = LE_EXPR;\n-    }\n-  else if (code == GT_EXPR)\n+  switch (code)\n     {\n-      mpz_init (v);\n-      mpz_set_si (v, 1);\n-      ppl_new_Coefficient (&c);\n-      ppl_assign_Coefficient_from_mpz_t (c, v);\n-      ppl_Linear_Expression_add_to_inhomogeneous (right, c);\n-      ppl_delete_Coefficient (c);\n-      mpz_clear (v);\n-\n-      code = GE_EXPR;\n-    }\n+      case LT_EXPR:\n+\tcond = isl_pw_aff_lt_set (lhs, rhs);\n+\tbreak;\n \n-  type = ppl_constraint_type_from_tree_code (code);\n+      case GT_EXPR:\n+\tcond = isl_pw_aff_gt_set (lhs, rhs);\n+\tbreak;\n \n-  ppl_subtract_Linear_Expression_from_Linear_Expression (left, right);\n+      case LE_EXPR:\n+\tcond = isl_pw_aff_le_set (lhs, rhs);\n+\tbreak;\n \n-  ppl_new_Constraint (&cstr, left, type);\n-  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (ps, cstr);\n+      case GE_EXPR:\n+\tcond = isl_pw_aff_ge_set (lhs, rhs);\n+\tbreak;\n \n-  ppl_delete_Constraint (cstr);\n-  ppl_delete_Linear_Expression (left);\n-  ppl_delete_Linear_Expression (right);\n-}\n+      case EQ_EXPR:\n+\tcond = isl_pw_aff_eq_set (lhs, rhs);\n+\tbreak;\n \n-/* Add conditional statement STMT to pbb.  CODE is used as the comparison\n-   operator.  This allows us to invert the condition or to handle\n-   inequalities.  */\n+      case NE_EXPR:\n+\tcond = isl_pw_aff_ne_set (lhs, rhs);\n+\tbreak;\n \n-static void\n-add_condition_to_pbb (poly_bb_p pbb, gimple stmt, enum tree_code code)\n-{\n-  if (code == NE_EXPR)\n-    {\n-      ppl_Pointset_Powerset_C_Polyhedron_t left = PBB_DOMAIN (pbb);\n-      ppl_Pointset_Powerset_C_Polyhedron_t right;\n-      ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-\t(&right, left);\n-      add_condition_to_domain (left, stmt, pbb, LT_EXPR);\n-      add_condition_to_domain (right, stmt, pbb, GT_EXPR);\n-      ppl_Pointset_Powerset_C_Polyhedron_upper_bound_assign (left, right);\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (right);\n+      default:\n+\tisl_pw_aff_free(lhs);\n+\tisl_pw_aff_free(rhs);\n+\treturn;\n     }\n-  else\n-    add_condition_to_domain (PBB_DOMAIN (pbb), stmt, pbb, code);\n+\n+  cond = isl_set_coalesce (cond);\n+  cond = isl_set_set_tuple_id (cond, isl_set_get_tuple_id (pbb->domain));\n+  pbb->domain = isl_set_intersect (pbb->domain, cond);\n }\n \n /* Add conditions to the domain of PBB.  */\n@@ -1273,7 +1168,7 @@ add_conditions_to_domain (poly_bb_p pbb)\n \t  }\n \n       case GIMPLE_SWITCH:\n-\t/* Switch statements are not supported right now - fall throught.  */\n+\t/* Switch statements are not supported right now - fall through.  */\n \n       default:\n \tgcc_unreachable ();\n@@ -1420,10 +1315,8 @@ build_sese_conditions (sese region)\n    of P.  */\n \n static void\n-add_param_constraints (scop_p scop, ppl_Polyhedron_t context, graphite_dim_t p)\n+add_param_constraints (scop_p scop, graphite_dim_t p)\n {\n-  ppl_Constraint_t cstr;\n-  ppl_Linear_Expression_t le;\n   tree parameter = VEC_index (tree, SESE_PARAMS (SCOP_REGION (scop)), p);\n   tree type = TREE_TYPE (parameter);\n   tree lb = NULL_TREE;\n@@ -1441,24 +1334,44 @@ add_param_constraints (scop_p scop, ppl_Polyhedron_t context, graphite_dim_t p)\n \n   if (lb)\n     {\n-      ppl_new_Linear_Expression_with_dimension (&le, scop_nb_params (scop));\n-      ppl_set_coef (le, p, -1);\n-      ppl_set_inhomogeneous_tree (le, lb);\n-      ppl_new_Constraint (&cstr, le, PPL_CONSTRAINT_TYPE_LESS_OR_EQUAL);\n-      ppl_Polyhedron_add_constraint (context, cstr);\n-      ppl_delete_Linear_Expression (le);\n-      ppl_delete_Constraint (cstr);\n+      isl_space *space = isl_set_get_space (scop->context);\n+      isl_constraint *c;\n+      mpz_t g;\n+      isl_int v;\n+\n+      c = isl_inequality_alloc (isl_local_space_from_space (space));\n+      mpz_init (g);\n+      isl_int_init (v);\n+      tree_int_to_gmp (lb, g);\n+      isl_int_set_gmp (v, g);\n+      isl_int_neg (v, v);\n+      mpz_clear (g);\n+      c = isl_constraint_set_constant (c, v);\n+      isl_int_clear (v);\n+      c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, 1);\n+\n+      scop->context = isl_set_add_constraint (scop->context, c);\n     }\n \n   if (ub)\n     {\n-      ppl_new_Linear_Expression_with_dimension (&le, scop_nb_params (scop));\n-      ppl_set_coef (le, p, -1);\n-      ppl_set_inhomogeneous_tree (le, ub);\n-      ppl_new_Constraint (&cstr, le, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-      ppl_Polyhedron_add_constraint (context, cstr);\n-      ppl_delete_Linear_Expression (le);\n-      ppl_delete_Constraint (cstr);\n+      isl_space *space = isl_set_get_space (scop->context);\n+      isl_constraint *c;\n+      mpz_t g;\n+      isl_int v;\n+\n+      c = isl_inequality_alloc (isl_local_space_from_space (space));\n+\n+      mpz_init (g);\n+      isl_int_init (v);\n+      tree_int_to_gmp (ub, g);\n+      isl_int_set_gmp (v, g);\n+      mpz_clear (g);\n+      c = isl_constraint_set_constant (c, v);\n+      isl_int_clear (v);\n+      c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, -1);\n+\n+      scop->context = isl_set_add_constraint (scop->context, c);\n     }\n }\n \n@@ -1469,22 +1382,10 @@ add_param_constraints (scop_p scop, ppl_Polyhedron_t context, graphite_dim_t p)\n static void\n build_scop_context (scop_p scop)\n {\n-  ppl_Polyhedron_t context;\n-  ppl_Pointset_Powerset_C_Polyhedron_t ps;\n   graphite_dim_t p, n = scop_nb_params (scop);\n \n-  ppl_new_C_Polyhedron_from_space_dimension (&context, n, 0);\n-\n   for (p = 0; p < n; p++)\n-    add_param_constraints (scop, context, p);\n-\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-    (&ps, context);\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign\n-    (SCOP_CONTEXT (scop), ps);\n-\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (ps);\n-  ppl_delete_Polyhedron (context);\n+    add_param_constraints (scop, p);\n }\n \n /* Build the iteration domains: the loops belonging to the current\n@@ -1497,206 +1398,218 @@ build_scop_iteration_domain (scop_p scop)\n   struct loop *loop;\n   sese region = SCOP_REGION (scop);\n   int i;\n-  ppl_Polyhedron_t ph;\n   poly_bb_p pbb;\n   int nb_loops = number_of_loops ();\n-  ppl_Pointset_Powerset_C_Polyhedron_t *domains\n-    = XNEWVEC (ppl_Pointset_Powerset_C_Polyhedron_t, nb_loops);\n-\n-  for (i = 0; i < nb_loops; i++)\n-    domains[i] = NULL;\n-\n-  ppl_new_C_Polyhedron_from_space_dimension (&ph, scop_nb_params (scop), 0);\n+  isl_set **doms = XCNEWVEC (isl_set *, nb_loops);\n \n   FOR_EACH_VEC_ELT (loop_p, SESE_LOOP_NEST (region), i, loop)\n     if (!loop_in_sese_p (loop_outer (loop), region))\n-      build_loop_iteration_domains (scop, loop, ph, 0, domains);\n+      build_loop_iteration_domains (scop, loop, 0,\n+\t\t\t\t    isl_set_copy (scop->context), doms);\n \n   FOR_EACH_VEC_ELT (poly_bb_p, SCOP_BBS (scop), i, pbb)\n-    if (domains[gbb_loop (PBB_BLACK_BOX (pbb))->num])\n-      ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-\t(&PBB_DOMAIN (pbb), (ppl_const_Pointset_Powerset_C_Polyhedron_t)\n-\t domains[gbb_loop (PBB_BLACK_BOX (pbb))->num]);\n-    else\n-      ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n-\t(&PBB_DOMAIN (pbb), ph);\n+    {\n+      loop = pbb_loop (pbb);\n+\n+      if (doms[loop->num])\n+\tpbb->domain = isl_set_copy (doms[loop->num]);\n+      else\n+\tpbb->domain = isl_set_copy (scop->context);\n+\n+      pbb->domain = isl_set_set_tuple_id (pbb->domain,\n+\t\t\t\t\t  isl_id_for_pbb (scop, pbb));\n+    }\n \n   for (i = 0; i < nb_loops; i++)\n-    if (domains[i])\n-      ppl_delete_Pointset_Powerset_C_Polyhedron (domains[i]);\n+    if (doms[i])\n+      isl_set_free (doms[i]);\n \n-  ppl_delete_Polyhedron (ph);\n-  free (domains);\n+  free (doms);\n }\n \n /* Add a constrain to the ACCESSES polyhedron for the alias set of\n    data reference DR.  ACCESSP_NB_DIMS is the dimension of the\n    ACCESSES polyhedron, DOM_NB_DIMS is the dimension of the iteration\n    domain.  */\n \n-static void\n-pdr_add_alias_set (ppl_Polyhedron_t accesses, data_reference_p dr,\n-\t\t   ppl_dimension_type accessp_nb_dims,\n-\t\t   ppl_dimension_type dom_nb_dims)\n+static isl_map *\n+pdr_add_alias_set (isl_map *acc, data_reference_p dr)\n {\n-  ppl_Linear_Expression_t alias;\n-  ppl_Constraint_t cstr;\n+  isl_constraint *c;\n   int alias_set_num = 0;\n   base_alias_pair *bap = (base_alias_pair *)(dr->aux);\n \n   if (bap && bap->alias_set)\n     alias_set_num = *(bap->alias_set);\n \n-  ppl_new_Linear_Expression_with_dimension (&alias, accessp_nb_dims);\n+  c = isl_equality_alloc\n+      (isl_local_space_from_space (isl_map_get_space (acc)));\n+  c = isl_constraint_set_constant_si (c, -alias_set_num);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, 0, 1);\n+\n+  return isl_map_add_constraint (acc, c);\n+}\n+\n+/* Assign the affine expression INDEX to the output dimension POS of\n+   MAP and return the result.  */\n+\n+static isl_map *\n+set_index (isl_map *map, int pos, isl_pw_aff *index)\n+{\n+  isl_map *index_map;\n+  int len = isl_map_dim (map, isl_dim_out);\n+  isl_id *id;\n+\n+  index_map = isl_map_from_pw_aff (index);\n+  index_map = isl_map_insert_dims (index_map, isl_dim_out, 0, pos);\n+  index_map = isl_map_add_dims (index_map, isl_dim_out, len - pos - 1);\n \n-  ppl_set_coef (alias, dom_nb_dims, 1);\n-  ppl_set_inhomogeneous (alias, -alias_set_num);\n-  ppl_new_Constraint (&cstr, alias, PPL_CONSTRAINT_TYPE_EQUAL);\n-  ppl_Polyhedron_add_constraint (accesses, cstr);\n+  id = isl_map_get_tuple_id (map, isl_dim_out);\n+  index_map = isl_map_set_tuple_id (index_map, isl_dim_out, id);\n+  id = isl_map_get_tuple_id (map, isl_dim_in);\n+  index_map = isl_map_set_tuple_id (index_map, isl_dim_in, id);\n \n-  ppl_delete_Linear_Expression (alias);\n-  ppl_delete_Constraint (cstr);\n+  return isl_map_intersect (map, index_map);\n }\n \n /* Add to ACCESSES polyhedron equalities defining the access functions\n    to the memory.  ACCESSP_NB_DIMS is the dimension of the ACCESSES\n    polyhedron, DOM_NB_DIMS is the dimension of the iteration domain.\n    PBB is the poly_bb_p that contains the data reference DR.  */\n \n-static void\n-pdr_add_memory_accesses (ppl_Polyhedron_t accesses, data_reference_p dr,\n-\t\t\t ppl_dimension_type accessp_nb_dims,\n-\t\t\t ppl_dimension_type dom_nb_dims,\n-\t\t\t poly_bb_p pbb)\n+static isl_map *\n+pdr_add_memory_accesses (isl_map *acc, data_reference_p dr, poly_bb_p pbb)\n {\n   int i, nb_subscripts = DR_NUM_DIMENSIONS (dr);\n-  mpz_t v;\n   scop_p scop = PBB_SCOP (pbb);\n-  sese region = SCOP_REGION (scop);\n-\n-  mpz_init (v);\n \n   for (i = 0; i < nb_subscripts; i++)\n     {\n-      ppl_Linear_Expression_t fn, access;\n-      ppl_Constraint_t cstr;\n-      ppl_dimension_type subscript = dom_nb_dims + 1 + i;\n+      isl_pw_aff *aff;\n       tree afn = DR_ACCESS_FN (dr, nb_subscripts - 1 - i);\n \n-      ppl_new_Linear_Expression_with_dimension (&fn, dom_nb_dims);\n-      ppl_new_Linear_Expression_with_dimension (&access, accessp_nb_dims);\n-\n-      mpz_set_si (v, 1);\n-      scan_tree_for_params (region, afn, fn, v);\n-      ppl_assign_Linear_Expression_from_Linear_Expression (access, fn);\n-\n-      ppl_set_coef (access, subscript, -1);\n-      ppl_new_Constraint (&cstr, access, PPL_CONSTRAINT_TYPE_EQUAL);\n-      ppl_Polyhedron_add_constraint (accesses, cstr);\n-\n-      ppl_delete_Linear_Expression (fn);\n-      ppl_delete_Linear_Expression (access);\n-      ppl_delete_Constraint (cstr);\n+      aff = extract_affine (scop, afn,\n+\t\t\t    isl_space_domain (isl_map_get_space (acc)));\n+      acc = set_index (acc, i + 1, aff);\n     }\n \n-  mpz_clear (v);\n+  return acc;\n }\n \n /* Add constrains representing the size of the accessed data to the\n    ACCESSES polyhedron.  ACCESSP_NB_DIMS is the dimension of the\n    ACCESSES polyhedron, DOM_NB_DIMS is the dimension of the iteration\n    domain.  */\n \n-static void\n-pdr_add_data_dimensions (ppl_Polyhedron_t accesses, data_reference_p dr,\n-\t\t\t ppl_dimension_type accessp_nb_dims,\n-\t\t\t ppl_dimension_type dom_nb_dims)\n+static isl_set *\n+pdr_add_data_dimensions (isl_set *extent, scop_p scop, data_reference_p dr)\n {\n   tree ref = DR_REF (dr);\n   int i, nb_subscripts = DR_NUM_DIMENSIONS (dr);\n \n   for (i = nb_subscripts - 1; i >= 0; i--, ref = TREE_OPERAND (ref, 0))\n     {\n-      ppl_Linear_Expression_t expr;\n-      ppl_Constraint_t cstr;\n-      ppl_dimension_type subscript = dom_nb_dims + 1 + i;\n       tree low, high;\n \n       if (TREE_CODE (ref) != ARRAY_REF)\n \tbreak;\n \n       low = array_ref_low_bound (ref);\n-\n-      /* subscript - low >= 0 */\n-      if (host_integerp (low, 0))\n-\t{\n-\t  tree minus_low;\n-\n-\t  ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);\n-\t  ppl_set_coef (expr, subscript, 1);\n-\n-\t  minus_low = fold_build1 (NEGATE_EXPR, TREE_TYPE (low), low);\n-\t  ppl_set_inhomogeneous_tree (expr, minus_low);\n-\n-\t  ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-\t  ppl_Polyhedron_add_constraint (accesses, cstr);\n-\t  ppl_delete_Linear_Expression (expr);\n-\t  ppl_delete_Constraint (cstr);\n-\t}\n-\n       high = array_ref_up_bound (ref);\n \n-      /* high - subscript >= 0 */\n-      if (high && host_integerp (high, 0)\n+      /* XXX The PPL code dealt separately with\n+         subscript - low >= 0 and high - subscript >= 0 in case one of\n+\t the two bounds isn't known.  Do the same here?  */\n+\n+      if (host_integerp (low, 0)\n+\t  && high\n+\t  && host_integerp (high, 0)\n \t  /* 1-element arrays at end of structures may extend over\n \t     their declared size.  */\n \t  && !(array_at_struct_end_p (ref)\n \t       && operand_equal_p (low, high, 0)))\n \t{\n-\t  ppl_new_Linear_Expression_with_dimension (&expr, accessp_nb_dims);\n-\t  ppl_set_coef (expr, subscript, -1);\n-\n-\t  ppl_set_inhomogeneous_tree (expr, high);\n-\n-\t  ppl_new_Constraint (&cstr, expr, PPL_CONSTRAINT_TYPE_GREATER_OR_EQUAL);\n-\t  ppl_Polyhedron_add_constraint (accesses, cstr);\n-\t  ppl_delete_Linear_Expression (expr);\n-\t  ppl_delete_Constraint (cstr);\n+\t  isl_id *id;\n+\t  isl_aff *aff;\n+\t  isl_set *univ, *lbs, *ubs;\n+\t  isl_pw_aff *index;\n+\t  isl_space *space;\n+\t  isl_set *valid;\n+\t  isl_pw_aff *lb = extract_affine_int (low, isl_set_get_space (extent));\n+\t  isl_pw_aff *ub = extract_affine_int (high, isl_set_get_space (extent));\n+\n+\t  /* high >= 0 */\n+\t  valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (ub));\n+\t  valid = isl_set_project_out (valid, isl_dim_set, 0,\n+\t\t\t\t       isl_set_dim (valid, isl_dim_set));\n+\t  scop->context = isl_set_intersect (scop->context, valid);\n+\n+\t  space = isl_set_get_space (extent);\n+\t  aff = isl_aff_zero_on_domain (isl_local_space_from_space (space));\n+\t  aff = isl_aff_add_coefficient_si (aff, isl_dim_in, i + 1, 1);\n+\t  univ = isl_set_universe (isl_space_domain (isl_aff_get_space (aff)));\n+\t  index = isl_pw_aff_alloc (univ, aff);\n+\n+\t  id = isl_set_get_tuple_id (extent);\n+\t  lb = isl_pw_aff_set_tuple_id (lb, isl_dim_in, isl_id_copy (id));\n+\t  ub = isl_pw_aff_set_tuple_id (ub, isl_dim_in, id);\n+\n+\t  /* low <= sub_i <= high */\n+\t  lbs = isl_pw_aff_ge_set (isl_pw_aff_copy (index), lb);\n+\t  ubs = isl_pw_aff_le_set (index, ub);\n+\t  extent = isl_set_intersect (extent, lbs);\n+\t  extent = isl_set_intersect (extent, ubs);\n \t}\n     }\n+\n+  return extent;\n }\n \n /* Build data accesses for DR in PBB.  */\n \n static void\n build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n {\n-  ppl_Polyhedron_t accesses;\n-  ppl_Pointset_Powerset_C_Polyhedron_t accesses_ps;\n-  ppl_dimension_type dom_nb_dims;\n-  ppl_dimension_type accessp_nb_dims;\n   int dr_base_object_set;\n+  isl_map *acc;\n+  isl_set *extent;\n+  scop_p scop = PBB_SCOP (pbb);\n \n-  ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PBB_DOMAIN (pbb),\n-\t\t\t\t\t\t      &dom_nb_dims);\n-  accessp_nb_dims = dom_nb_dims + 1 + DR_NUM_DIMENSIONS (dr);\n+  {\n+    isl_space *dc = isl_set_get_space (pbb->domain);\n+    int nb_out = 1 + DR_NUM_DIMENSIONS (dr);\n+    isl_space *space = isl_space_add_dims (isl_space_from_domain (dc),\n+\t\t\t\t\t   isl_dim_out, nb_out);\n \n-  ppl_new_C_Polyhedron_from_space_dimension (&accesses, accessp_nb_dims, 0);\n+    acc = isl_map_universe (space);\n+    acc = isl_map_set_tuple_id (acc, isl_dim_out, isl_id_for_dr (scop, dr));\n+  }\n \n-  pdr_add_alias_set (accesses, dr, accessp_nb_dims, dom_nb_dims);\n-  pdr_add_memory_accesses (accesses, dr, accessp_nb_dims, dom_nb_dims, pbb);\n-  pdr_add_data_dimensions (accesses, dr, accessp_nb_dims, dom_nb_dims);\n+  acc = pdr_add_alias_set (acc, dr);\n+  acc = pdr_add_memory_accesses (acc, dr, pbb);\n \n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&accesses_ps,\n-\t\t\t\t\t\t\t    accesses);\n-  ppl_delete_Polyhedron (accesses);\n+  {\n+    isl_id *id = isl_id_for_dr (scop, dr);\n+    int nb = 1 + DR_NUM_DIMENSIONS (dr);\n+    isl_space *space = isl_space_set_alloc (scop->ctx, 0, nb);\n+    int alias_set_num = 0;\n+    base_alias_pair *bap = (base_alias_pair *)(dr->aux);\n+\n+    if (bap && bap->alias_set)\n+      alias_set_num = *(bap->alias_set);\n+\n+    space = isl_space_set_tuple_id (space, isl_dim_set, id);\n+    extent = isl_set_nat_universe (space);\n+    extent = isl_set_fix_si (extent, isl_dim_set, 0, alias_set_num);\n+    extent = pdr_add_data_dimensions (extent, scop, dr);\n+  }\n \n   gcc_assert (dr->aux);\n   dr_base_object_set = ((base_alias_pair *)(dr->aux))->base_obj_set;\n \n-  new_poly_dr (pbb, dr_base_object_set, accesses_ps,\n+  new_poly_dr (pbb, dr_base_object_set,\n \t       DR_IS_READ (dr) ? PDR_READ : PDR_WRITE,\n-\t       dr, DR_NUM_DIMENSIONS (dr));\n+\t       dr, DR_NUM_DIMENSIONS (dr), acc, extent);\n }\n \n /* Write to FILE the alias graph of data references in DIMACS format.  */\n@@ -2139,9 +2052,7 @@ new_pbb_from_pbb (scop_p scop, poly_bb_p pbb, basic_block bb)\n     if (VEC_index (poly_bb_p, SCOP_BBS (scop), index) == pbb)\n       break;\n \n-  if (PBB_DOMAIN (pbb))\n-    ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-      (&PBB_DOMAIN (pbb1), PBB_DOMAIN (pbb));\n+  pbb1->domain = isl_set_copy (pbb->domain);\n \n   GBB_PBB (gbb1) = pbb1;\n   GBB_CONDITIONS (gbb1) = VEC_copy (gimple, heap, GBB_CONDITIONS (gbb));"}, {"sha": "04e1da29118ec03a490ef6706fc133d8c2a96664", "filename": "gcc/graphite.c", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,5 +1,6 @@\n /* Gimple Represented as Polyhedra.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <sebastian.pop@inria.fr>.\n \n This file is part of GCC.\n@@ -33,6 +34,17 @@ along with GCC; see the file COPYING3.  If not see\n    the functions that are used for transforming the code.  */\n \n #include \"config.h\"\n+\n+#ifdef HAVE_cloog\n+#include <isl/set.h>\n+#include <isl/map.h>\n+#include <isl/options.h>\n+#include <isl/union_map.h>\n+#include <cloog/cloog.h>\n+#include <cloog/isl/domain.h>\n+#include <cloog/isl/cloog.h>\n+#endif\n+\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"diagnostic-core.h\"\n@@ -47,8 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef HAVE_cloog\n \n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n #include \"graphite-poly.h\"\n #include \"graphite-scop-detection.h\"\n #include \"graphite-clast-to-gimple.h\"\n@@ -186,10 +196,8 @@ print_graphite_statistics (FILE* file, VEC (scop_p, heap) *scops)\n /* Initialize graphite: when there are no loops returns false.  */\n \n static bool\n-graphite_initialize (void)\n+graphite_initialize (isl_ctx *ctx)\n {\n-  int ppl_initialized;\n-\n   if (number_of_loops () <= 1\n       /* FIXME: This limit on the number of basic blocks of a function\n \t should be removed when the SCOP detection is faster.  */\n@@ -198,17 +206,15 @@ graphite_initialize (void)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tprint_global_statistics (dump_file);\n \n+      isl_ctx_free (ctx);\n       return false;\n     }\n \n   scev_reset ();\n   recompute_all_dominators ();\n   initialize_original_copy_tables ();\n \n-  ppl_initialized = ppl_initialize ();\n-  gcc_assert (ppl_initialized == 0);\n-\n-  cloog_state = cloog_state_malloc ();\n+  cloog_state = cloog_isl_state_malloc (ctx);\n \n   if (dump_file && dump_flags)\n     dump_function_to_file (current_function_decl, dump_file, dump_flags);\n@@ -232,13 +238,14 @@ graphite_finalize (bool need_cfg_cleanup_p)\n     }\n \n   cloog_state_free (cloog_state);\n-  ppl_finalize ();\n   free_original_copy_tables ();\n \n   if (dump_file && dump_flags)\n     print_loops (dump_file, 3);\n }\n \n+isl_ctx *the_isl_ctx;\n+\n /* Perform a set of linear transforms on the loops of the current\n    function.  */\n \n@@ -250,15 +257,19 @@ graphite_transform_loops (void)\n   bool need_cfg_cleanup_p = false;\n   VEC (scop_p, heap) *scops = NULL;\n   htab_t bb_pbb_mapping;\n+  isl_ctx *ctx;\n \n   /* If a function is parallel it was most probably already run through graphite\n      once. No need to run again.  */\n   if (parallelized_function_p (cfun->decl))\n     return;\n \n-  if (!graphite_initialize ())\n+  ctx = isl_ctx_alloc ();\n+  isl_options_set_on_error(ctx, ISL_ON_ERROR_ABORT);\n+  if (!graphite_initialize (ctx))\n     return;\n \n+  the_isl_ctx = ctx;\n   build_scops (&scops);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -272,6 +283,7 @@ graphite_transform_loops (void)\n   FOR_EACH_VEC_ELT (scop_p, scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       {\n+\tscop->ctx = ctx;\n \tbuild_poly_scop (scop);\n \n \tif (POLY_SCOP_P (scop)\n@@ -283,6 +295,8 @@ graphite_transform_loops (void)\n   htab_delete (bb_pbb_mapping);\n   free_scops (scops);\n   graphite_finalize (need_cfg_cleanup_p);\n+  the_isl_ctx = NULL;\n+  isl_ctx_free (ctx);\n }\n \n #else /* If Cloog is not available: #ifndef HAVE_cloog.  */"}, {"sha": "ace010430e7822a8a480608b654945eed0a8d3e2", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -1,3 +1,13 @@\n+2012-07-02  Richard Guenther  <rguenther@suse.de>\n+\tMichael Matz  <matz@suse.de>\n+\tTobias Grosser <tobias@grosser.es>\n+\tSebastian Pop <sebpop@gmail.com>\n+\n+\t* testsuite/libgomp.graphite/force-parallel-4.c: Adjust.\n+\t* testsuite/libgomp.graphite/force-parallel-5.c: Likewise.\n+\t* testsuite/libgomp.graphite/force-parallel-7.c: Likewise.\n+\t* testsuite/libgomp.graphite/force-parallel-8.c: Likewise.\n+\n 2012-06-28  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* libgomp.texi: Include gpl_v3.texi instead of gpl.texi."}, {"sha": "825bda5c439e76f9caef3d61a8003e3c944861a8", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-4.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-4.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -47,6 +47,7 @@ int main(void)\n }\n \n /* Check that parallel code generation part make the right answer.  */\n+/* { dg-final { scan-tree-dump-times \"1 loops carried no dependency\" 1 \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"2 loops carried no dependency\" 1 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn.0\" 5 \"optimized\" } } */"}, {"sha": "5c944dcee619befaa504eb427604bf3d6e313fdf", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-5.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -31,7 +31,7 @@ int main(void)\n }\n \n /* Check that parallel code generation part make the right answer.  */\n-/* { dg-final { scan-tree-dump-times \"2 loops carried no dependency\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"1 loops carried no dependency\" 1 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn.0\" 5 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn.1\" 5 \"optimized\" } } */"}, {"sha": "2fbe10a4e5c590d732a048025f25f028e2187c1e", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-7.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-7.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -2,29 +2,30 @@\n \n int A[N+5][N+5][N+5];\n \n-int foo(void)\n+void abort (void);\n+\n+int foo (void)\n {\n   int i, j, k;\n \n+  for (i = 0; i < N + 5; i++)\n+    for (j = 0; j < N + 5; j++)\n+      for (k = 0; k < N + 5; k++)\n+\tA[i][j][k] = i + j + k;\n+\n   /* Loop i: carried no dependency.  */\n   for (i = 0; i < N; i++)\n     for (j = 0; j < N; j++)\n       for (k = 0; k < N; k++)\n \tA[k+1][j+2][i+1] = A[k][j][i+1];\n \n-  for (i = 0; i < N; i++)\n-    /* Loop j: carried no dependency.  */\n-    for (j = 0; j < N; j++)\n-      /* Loop k: carreid no dependency.  */\n-      for (k = 0; k < N; k++)\n-\tA[i+1][j][k] = A[i][j][k+1];\n-\n   return A[1][5][2];\n }\n \n-int main(void)\n+int main (void)\n {\n-  foo();\n+  if (5 != foo ())\n+    abort ();\n \n   return 0;\n }"}, {"sha": "f9ce9686fefd153e16fa01d6cf54cb761fdc443d", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-8.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-8.c?ref=33ad93b9f4cb21a19b8cf60c77344bc1c9bdff6d", "patch": "@@ -2,10 +2,19 @@\n \n int x[N][N], y[N];\n \n+void abort (void);\n+\n int foo(void)\n {\n   int i, j;\n \n+  for (i = 0; i < N; i++)\n+    y[i] = i;\n+\n+  for (i = 0; i < N; i++)\n+    for (j = 0; j < N; j++)\n+      x[i][j] = i + j;\n+\n   for (i = 0; i < N; i++)\n     {\n       y[i] = i;\n@@ -27,13 +36,16 @@ int foo(void)\n \n int main(void)\n {\n-  foo();\n+  if (168 != foo())\n+    abort ();\n \n   return 0;\n }\n \n /* Check that parallel code generation part make the right answer.  */\n-/* { dg-final { scan-tree-dump-times \"2 loops carried no dependency\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"1 loops carried no dependency\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"3 loops carried no dependency\" 1 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"5 loops carried no dependency\" 1 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn.0\" 5 \"optimized\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn.1\" 5 \"optimized\" } } */"}]}