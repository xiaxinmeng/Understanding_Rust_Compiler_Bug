{"sha": "ba0c6e4769cb6e81289ea4a0c536260e859fc795", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEwYzZlNDc2OWNiNmU4MTI4OWVhNGEwYzUzNjI2MGU4NTlmYzc5NQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2014-07-31T13:48:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:48:33Z"}, "message": "cstand.adb, [...]: Remove obsolete VMS-specific code.\n\n2014-07-31  Robert Dewar  <dewar@adacore.com>\n\n\t* cstand.adb, einfo.adb, einfo.ads, errout.adb, exp_attr.adb,\n\texp_prag.adb, frontend.adb, interfac.ads,\n\tpar-prag.adb, s-auxdec.ads, s-filofl.ads, s-fishfl.ads, s-fvadfl.ads,\n\ts-fvaffl.ads, s-fvagfl.ads, s-vaflop.ads, sem_attr.adb, sem_attr.ads,\n\tsem_ch13.adb, sem_ch3.adb, sem_ch8.adb, sem_prag.adb, snames.adb-tmpl,\n\tsnames.ads-tmpl: Remove obsolete VMS-specific code.\n\nFrom-SVN: r213369", "tree": {"sha": "4d402263be4cc3bb252bd582efca70aa12a62bb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d402263be4cc3bb252bd582efca70aa12a62bb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba0c6e4769cb6e81289ea4a0c536260e859fc795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba0c6e4769cb6e81289ea4a0c536260e859fc795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba0c6e4769cb6e81289ea4a0c536260e859fc795", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba0c6e4769cb6e81289ea4a0c536260e859fc795/comments", "author": null, "committer": null, "parents": [{"sha": "f9648959b41d5c443702c809676056f1f39c56de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9648959b41d5c443702c809676056f1f39c56de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9648959b41d5c443702c809676056f1f39c56de"}], "stats": {"total": 1469, "additions": 124, "deletions": 1345}, "files": [{"sha": "e6c4cb8bf69f7219eca85b5aac898f13e8f8a732", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -1,3 +1,12 @@\n+2014-07-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* cstand.adb, einfo.adb, einfo.ads, errout.adb, exp_attr.adb,\n+\texp_prag.adb, frontend.adb, interfac.ads,\n+\tpar-prag.adb, s-auxdec.ads, s-filofl.ads, s-fishfl.ads, s-fvadfl.ads,\n+\ts-fvaffl.ads, s-fvagfl.ads, s-vaflop.ads, sem_attr.adb, sem_attr.ads,\n+\tsem_ch13.adb, sem_ch3.adb, sem_ch8.adb, sem_prag.adb, snames.adb-tmpl,\n+\tsnames.ads-tmpl: Remove obsolete VMS-specific code.\n+\n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sem_ch13.adb: Minor reformatting."}, {"sha": "8261a41b6a1e471fa5c3a2acd9e024720908acc3", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -2125,11 +2125,6 @@ package body CStand is\n       Exponent    : constant Uint := Emax - Mantissa;\n \n    begin\n-      --  Note: for the call from Cstand to initially create the types in\n-      --  Standard, Float_Rep will never be VAX_Native. Circuitry in Sem_Vfpt\n-      --  will adjust these types appropriately VAX_Native if a pragma\n-      --  Float_Representation (VAX_Float) is used.\n-\n       H := Make_Float_Literal (Stloc, Radix, Significand, Exponent);\n       L := Make_Float_Literal (Stloc, Radix, -Significand, Exponent);\n "}, {"sha": "664d24bcc9beaff80d6fb6d380e23b73ec1bf134", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -7367,13 +7367,6 @@ package body Einfo is\n                when others => return No_Uint;\n             end case;\n \n-         when VAX_Native =>\n-            case Digs is\n-               when  1 ..  9 => return 2**7 - 1;\n-               when 10 .. 15 => return 2**10 - 1;\n-               when others => return No_Uint;\n-            end case;\n-\n          when AAMP =>\n             return Uint_2 ** Uint_7 - Uint_1;\n       end case;\n@@ -7387,7 +7380,6 @@ package body Einfo is\n    begin\n       case Float_Rep (Id) is\n          when IEEE_Binary => return Uint_3 - Machine_Emax_Value (Id);\n-         when VAX_Native  => return -Machine_Emax_Value (Id);\n          when AAMP        => return -Machine_Emax_Value (Id);\n       end case;\n    end Machine_Emin_Value;\n@@ -7410,14 +7402,6 @@ package body Einfo is\n                when others => return No_Uint;\n             end case;\n \n-         when VAX_Native =>\n-            case Digs is\n-               when  1 ..  6 => return Uint_24;\n-               when  7 ..  9 => return UI_From_Int (56);\n-               when 10 .. 15 => return UI_From_Int (53);\n-               when others => return No_Uint;\n-            end case;\n-\n          when AAMP =>\n             case Digs is\n                when  1 ..  6 => return Uint_24;\n@@ -7434,7 +7418,7 @@ package body Einfo is\n    function Machine_Radix_Value (Id : E) return U is\n    begin\n       case Float_Rep (Id) is\n-         when IEEE_Binary | VAX_Native | AAMP =>\n+         when IEEE_Binary | AAMP =>\n             return Uint_2;\n       end case;\n    end Machine_Radix_Value;\n@@ -8209,7 +8193,7 @@ package body Einfo is\n \n    function Vax_Float (Id : E) return B is\n    begin\n-      return Is_Floating_Point_Type (Id) and then Float_Rep (Id) = VAX_Native;\n+      return False;\n    end Vax_Float;\n \n    ------------------------"}, {"sha": "b29821bee6fb3725c138aa2ac43a8fe3aa7d5269", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -2068,13 +2068,11 @@ package Einfo is\n --       access to subprograms (JGNAT only). Set to Empty unless an export,\n --       import, or interface name pragma has explicitly specified an external\n --       name, in which case it references an N_String_Literal node for the\n---       specified external name. In the case of exceptions, the field is set\n---       by Import_Exception/Export_Exception (which can be used in OpenVMS\n---       versions only). Note that if this field is Empty, and Is_Imported\n---       or Is_Exported is set, then the default interface name is the name\n---       of the entity, cased in a manner that is appropriate to the system\n---       in use. Note that Interface_Name is ignored if an address clause\n---       is present (since it is meaningless in this case).\n+--       specified external name. Note that if this field is Empty, and\n+--       Is_Imported or Is_Exported is set, then the default interface name\n+--       is the name of the entity, cased in a manner that is appropriate to\n+--       the system in use. Note that Interface_Name is ignored if an address\n+--       clause is present (since it is meaningless in this case).\n --\n --       An additional special case usage of this field is in JGNAT for\n --       E_Component and E_Discriminant. JGNAT allows these entities to be\n@@ -6252,8 +6250,7 @@ package Einfo is\n    -----------------------------------\n \n    type Float_Rep_Kind is (\n-      IEEE_Binary,  -- IEEE 754p conform binary format\n-      VAX_Native,   -- VAX D, F, G or H format\n+      IEEE_Binary,  -- IEEE 754p conforming binary format\n       AAMP);        -- AAMP format\n \n    ---------------"}, {"sha": "cae81b152bf743ea7e5db3bc9f3332cd59e58884", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 1, "deletions": 68, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -37,7 +37,6 @@ with Einfo;    use Einfo;\n with Erroutc;  use Erroutc;\n with Fname;    use Fname;\n with Gnatvsn;  use Gnatvsn;\n-with Hostparm; use Hostparm;\n with Lib;      use Lib;\n with Opt;      use Opt;\n with Nlists;   use Nlists;\n@@ -190,14 +189,6 @@ package body Errout is\n    --  should have 'Class appended to its name (see Add_Class procedure), and\n    --  is otherwise unchanged.\n \n-   procedure VMS_Convert;\n-   --  This procedure has no effect if called when the host is not OpenVMS. If\n-   --  the host is indeed OpenVMS, then the error message stored in Msg_Buffer\n-   --  is scanned for appearances of switch names which need converting to\n-   --  corresponding VMS qualifier names. See Gnames/Vnames table in Errout\n-   --  spec for precise definition of the conversion that is performed by this\n-   --  routine in OpenVMS mode.\n-\n    function Warn_Insertion return String;\n    --  This is called for warning messages only (so Warning_Msg_Char is set)\n    --  and returns a corresponding string to use at the beginning of generated\n@@ -1678,11 +1669,6 @@ package body Errout is\n          --  error to make sure that *something* appears on standard error in\n          --  an error situation.\n \n-         --  Formerly, only the \"# errors\" suffix was sent to stderr, whereas\n-         --  \"# lines:\" appeared on stdout. This caused problems on VMS when\n-         --  the stdout buffer was flushed, giving an extra line feed after\n-         --  the prefix.\n-\n          if Total_Errors_Detected + Warnings_Detected /= 0\n            and then not Brief_Output\n            and then (Verbose_Mode or Full_List)\n@@ -2331,9 +2317,7 @@ package body Errout is\n       --  Loop through file names to find matching one. This is a bit slow, but\n       --  we only do it in error situations so it is not so terrible. Note that\n       --  if the loop does not exit, then the desired case will be left set to\n-      --  Mixed_Case, this can happen if the name was not in canonical form,\n-      --  and gets canonicalized on VMS. Possibly we could fix this by\n-      --  unconditionally canonicalizing these names ???\n+      --  Mixed_Case, this can happen if the name was not in canonical form.\n \n       for J in 1 .. Last_Source_File loop\n          Get_Name_String (Full_Debug_Name (J));\n@@ -2980,8 +2964,6 @@ package body Errout is\n                Set_Msg_Char (C);\n          end case;\n       end loop;\n-\n-      VMS_Convert;\n    end Set_Msg_Text;\n \n    ----------------\n@@ -3292,55 +3274,6 @@ package body Errout is\n       end if;\n    end Unwind_Internal_Type;\n \n-   -----------------\n-   -- VMS_Convert --\n-   -----------------\n-\n-   procedure VMS_Convert is\n-      P : Natural;\n-      L : Natural;\n-      N : Natural;\n-\n-   begin\n-      if not OpenVMS then\n-         return;\n-      end if;\n-\n-      P := Msg_Buffer'First;\n-      loop\n-         if P >= Msglen then\n-            return;\n-         end if;\n-\n-         if Msg_Buffer (P) = '-' then\n-            for G in Gnames'Range loop\n-               L := Gnames (G)'Length;\n-\n-               --  See if we have \"-ggg switch\", where ggg is Gnames entry\n-\n-               if P + L + 7 <= Msglen\n-                 and then Msg_Buffer (P + 1 .. P + L) = Gnames (G).all\n-                 and then Msg_Buffer (P + L + 1 .. P + L + 7) = \" switch\"\n-               then\n-                  --  Replace by \"/vvv qualifier\", where vvv is Vnames entry\n-\n-                  N := Vnames (G)'Length;\n-                  Msg_Buffer (P + N + 11 .. Msglen + N - L + 3) :=\n-                    Msg_Buffer (P + L + 8 .. Msglen);\n-                  Msg_Buffer (P) := '/';\n-                  Msg_Buffer (P + 1 .. P + N) := Vnames (G).all;\n-                  Msg_Buffer (P + N + 1 .. P + N + 10) := \" qualifier\";\n-                  P := P + N + 10;\n-                  Msglen := Msglen + N - L + 3;\n-                  exit;\n-               end if;\n-            end loop;\n-         end if;\n-\n-         P := P + 1;\n-      end loop;\n-   end VMS_Convert;\n-\n    --------------------\n    -- Warn_Insertion --\n    --------------------"}, {"sha": "e2ec15d8a20aec57ec0a5c850d3cb2831d4390bb", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -2255,70 +2255,6 @@ package body Exp_Attr is\n          end if;\n       end Alignment;\n \n-      ---------------\n-      -- AST_Entry --\n-      ---------------\n-\n-      when Attribute_AST_Entry => AST_Entry : declare\n-         Ttyp : Entity_Id;\n-         T_Id : Node_Id;\n-         Eent : Entity_Id;\n-\n-         Entry_Ref : Node_Id;\n-         --  The reference to the entry or entry family\n-\n-         Index : Node_Id;\n-         --  The index expression for an entry family reference, or\n-         --  the Empty if Entry_Ref references a simple entry.\n-\n-      begin\n-         if Nkind (Pref) = N_Indexed_Component then\n-            Entry_Ref := Prefix (Pref);\n-            Index := First (Expressions (Pref));\n-         else\n-            Entry_Ref := Pref;\n-            Index := Empty;\n-         end if;\n-\n-         --  Get expression for Task_Id and the entry entity\n-\n-         if Nkind (Entry_Ref) = N_Selected_Component then\n-            T_Id :=\n-              Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_Identity,\n-                Prefix         => Prefix (Entry_Ref));\n-\n-            Ttyp := Etype (Prefix (Entry_Ref));\n-            Eent := Entity (Selector_Name (Entry_Ref));\n-\n-         else\n-            T_Id :=\n-              Make_Function_Call (Loc,\n-                Name => New_Occurrence_Of (RTE (RE_Current_Task), Loc));\n-\n-            Eent  := Entity (Entry_Ref);\n-\n-            --  We have to find the enclosing task to get the task type\n-            --  There must be one, since we already validated this earlier\n-\n-            Ttyp := Current_Scope;\n-            while not Is_Task_Type (Ttyp) loop\n-               Ttyp := Scope (Ttyp);\n-            end loop;\n-         end if;\n-\n-         --  Now rewrite the attribute with a call to Create_AST_Handler\n-\n-         Rewrite (N,\n-           Make_Function_Call (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Create_AST_Handler), Loc),\n-             Parameter_Associations => New_List (\n-               T_Id,\n-               Entry_Index_Expression (Loc, Eent, Index, Ttyp))));\n-\n-         Analyze_And_Resolve (N, RTE (RE_AST_Handler));\n-      end AST_Entry;\n-\n       ---------\n       -- Bit --\n       ---------"}, {"sha": "181629429075f23b11193c129af4ac1bb8f6e2ca", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -41,14 +41,12 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Stand;    use Stand;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n@@ -68,7 +66,6 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Check                   (N : Node_Id);\n    procedure Expand_Pragma_Common_Object           (N : Node_Id);\n    procedure Expand_Pragma_Import_Or_Interface     (N : Node_Id);\n-   procedure Expand_Pragma_Import_Export_Exception (N : Node_Id);\n    procedure Expand_Pragma_Inspection_Point        (N : Node_Id);\n    procedure Expand_Pragma_Interrupt_Priority      (N : Node_Id);\n    procedure Expand_Pragma_Loop_Variant            (N : Node_Id);\n@@ -818,15 +815,9 @@ package body Exp_Prag is\n             when Pragma_Common_Object =>\n                Expand_Pragma_Common_Object (N);\n \n-            when Pragma_Export_Exception =>\n-               Expand_Pragma_Import_Export_Exception (N);\n-\n             when Pragma_Import =>\n                Expand_Pragma_Import_Or_Interface (N);\n \n-            when Pragma_Import_Exception =>\n-               Expand_Pragma_Import_Export_Exception (N);\n-\n             when Pragma_Inspection_Point =>\n                Expand_Pragma_Inspection_Point (N);\n \n@@ -1292,176 +1283,6 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Import_Or_Interface;\n \n-   -------------------------------------------\n-   -- Expand_Pragma_Import_Export_Exception --\n-   -------------------------------------------\n-\n-   --  For a VMS exception fix up the language field with \"VMS\" instead of\n-   --  \"Ada\" (gigi needs this), create a constant that will be the value of\n-   --  the VMS condition code and stuff the Interface_Name field with the\n-   --  unexpanded name of the exception (if not already set). For a Ada\n-   --  exception, just stuff the Interface_Name field with the unexpanded\n-   --  name of the exception (if not already set).\n-\n-   procedure Expand_Pragma_Import_Export_Exception (N : Node_Id) is\n-   begin\n-      --  This pragma is only effective on OpenVMS systems, it was ignored on\n-      --  non-VMS systems, and we need to ignore it here as well.\n-\n-      if not OpenVMS_On_Target then\n-         return;\n-      end if;\n-\n-      declare\n-         Id     : constant Entity_Id := Entity (Arg1 (N));\n-         Call   : constant Node_Id := Register_Exception_Call (Id);\n-         Loc    : constant Source_Ptr := Sloc (N);\n-\n-      begin\n-         if Present (Call) then\n-            declare\n-               Excep_Internal : constant Node_Id := Make_Temporary (Loc, 'V');\n-               Export_Pragma  : Node_Id;\n-               Excep_Alias    : Node_Id;\n-               Excep_Object   : Node_Id;\n-               Excep_Image    : String_Id;\n-               Exdata         : List_Id;\n-               Lang_Char      : Node_Id;\n-               Code           : Node_Id;\n-\n-            begin\n-               --  Compute the symbol for the code of the condition\n-\n-               if Present (Interface_Name (Id)) then\n-                  Excep_Image := Strval (Interface_Name (Id));\n-               else\n-                  Get_Name_String (Chars (Id));\n-                  Set_All_Upper_Case;\n-                  Excep_Image := String_From_Name_Buffer;\n-               end if;\n-\n-               Exdata := Component_Associations (Expression (Parent (Id)));\n-\n-               if Is_VMS_Exception (Id) then\n-                  Lang_Char := Next (First (Exdata));\n-\n-                  --  Change the one-character language designator to 'V'\n-\n-                  Rewrite (Expression (Lang_Char),\n-                    Make_Character_Literal (Loc,\n-                      Chars => Name_uV,\n-                      Char_Literal_Value =>\n-                        UI_From_Int (Character'Pos ('V'))));\n-                  Analyze (Expression (Lang_Char));\n-\n-                  if Exception_Code (Id) /= No_Uint then\n-\n-                     --  The code for the exception is present. Create a linker\n-                     --  alias to define the symbol.\n-\n-                     Code :=\n-                       Unchecked_Convert_To (RTE (RE_Address),\n-                         Make_Integer_Literal (Loc,\n-                           Intval => Exception_Code (Id)));\n-\n-                     --  Declare a dummy object\n-\n-                     Excep_Object :=\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => Excep_Internal,\n-                         Object_Definition   =>\n-                           New_Occurrence_Of (RTE (RE_Address), Loc));\n-\n-                     Insert_Action (N, Excep_Object);\n-                     Analyze (Excep_Object);\n-\n-                     --  Clear severity bits\n-\n-                     Start_String;\n-                     Store_String_Int\n-                       (UI_To_Int (Exception_Code (Id)) / 8 * 8);\n-\n-                     --  Insert a pragma Linker_Alias to set the value of the\n-                     --  dummy object symbol.\n-\n-                     Excep_Alias :=\n-                       Make_Pragma (Loc,\n-                         Chars                        => Name_Linker_Alias,\n-                         Pragma_Argument_Associations => New_List (\n-                           Make_Pragma_Argument_Association (Loc,\n-                             Expression =>\n-                               New_Occurrence_Of (Excep_Internal, Loc)),\n-\n-                           Make_Pragma_Argument_Association (Loc,\n-                             Expression =>\n-                               Make_String_Literal (Loc, End_String))));\n-\n-                     Insert_Action (N, Excep_Alias);\n-                     Analyze (Excep_Alias);\n-\n-                     --  Insert a pragma Export to give a Linker_Name to the\n-                     --  dummy object.\n-\n-                     Export_Pragma :=\n-                       Make_Pragma (Loc,\n-                         Chars                        => Name_Export,\n-                         Pragma_Argument_Associations => New_List (\n-                           Make_Pragma_Argument_Association (Loc,\n-                             Expression => Make_Identifier (Loc, Name_C)),\n-\n-                           Make_Pragma_Argument_Association (Loc,\n-                             Expression =>\n-                               New_Occurrence_Of (Excep_Internal, Loc)),\n-\n-                           Make_Pragma_Argument_Association (Loc,\n-                             Expression =>\n-                               Make_String_Literal (Loc, Excep_Image)),\n-\n-                           Make_Pragma_Argument_Association (Loc,\n-                             Expression =>\n-                               Make_String_Literal (Loc, Excep_Image))));\n-\n-                     Insert_Action (N, Export_Pragma);\n-                     Analyze (Export_Pragma);\n-\n-                  else\n-                     Code :=\n-                        Make_Function_Call (Loc,\n-                          Name                   =>\n-                            New_Occurrence_Of (RTE (RE_Import_Address), Loc),\n-                          Parameter_Associations => New_List\n-                            (Make_String_Literal (Loc,\n-                              Strval => Excep_Image)));\n-                  end if;\n-\n-                  --  Generate the call to Register_VMS_Exception\n-\n-                  Rewrite (Call,\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name => New_Occurrence_Of\n-                                (RTE (RE_Register_VMS_Exception), Loc),\n-                      Parameter_Associations => New_List (\n-                        Code,\n-                        Unchecked_Convert_To (RTE (RE_Exception_Data_Ptr),\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         => New_Occurrence_Of (Id, Loc),\n-                            Attribute_Name => Name_Unrestricted_Access)))));\n-\n-                  Analyze_And_Resolve (Code, RTE (RE_Address));\n-                  Analyze (Call);\n-               end if;\n-\n-               if No (Interface_Name (Id)) then\n-                  Set_Interface_Name (Id,\n-                     Make_String_Literal\n-                       (Sloc => Loc,\n-                        Strval => Excep_Image));\n-               end if;\n-            end;\n-         end if;\n-      end;\n-   end Expand_Pragma_Import_Export_Exception;\n-\n    ------------------------------------\n    -- Expand_Pragma_Inspection_Point --\n    ------------------------------------"}, {"sha": "5cea4dbba6a5671324794972e4706b94d0c09e95", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -57,7 +57,6 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_SCIL;\n with Sem_Elab; use Sem_Elab;\n with Sem_Prag; use Sem_Prag;\n-with Sem_VFpt; use Sem_VFpt;\n with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -191,21 +190,6 @@ begin\n          Config_Pragmas := Empty_List;\n       end if;\n \n-      --  Check for VAX Float\n-\n-      if Targparm.VAX_Float_On_Target then\n-\n-         --  pragma Float_Representation (VAX_Float);\n-\n-         Opt.Float_Format := 'V';\n-\n-         --  pragma Long_Float (G_Float);\n-\n-         Opt.Float_Format_Long := 'G';\n-\n-         Set_Standard_Fpt_Formats;\n-      end if;\n-\n       --  Now deal with specified config pragmas files if there are any\n \n       if Opt.Config_File_Names /= null then"}, {"sha": "1c88a507d7d511eea573d2cd09646819c6df8c44", "filename": "gcc/ada/interfac.ads", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Finterfac.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Finterfac.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finterfac.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2002-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -152,19 +152,12 @@ package Interfaces is\n    pragma Import (Intrinsic, Rotate_Left);\n    pragma Import (Intrinsic, Rotate_Right);\n \n-   --  IEEE Floating point types. Note that the form of these definitions\n-   --  ensures that the work on VMS, even if the standard library is compiled\n-   --  using a Float_Representation pragma for Vax_Float.\n-\n-   pragma Warnings (Off);\n-   --  Turn off warnings for targets not providing IEEE floating-point types\n+   --  IEEE Floating point types\n \n    type IEEE_Float_32 is digits 6;\n-   pragma Float_Representation (IEEE_Float, IEEE_Float_32);\n    for IEEE_Float_32'Size use 32;\n \n    type IEEE_Float_64 is digits 15;\n-   pragma Float_Representation (IEEE_Float, IEEE_Float_64);\n    for IEEE_Float_64'Size use 64;\n \n    --  If there is an IEEE extended float available on the machine, we assume"}, {"sha": "ea770fdc1c5f19f5ec699a7dd43c4af5f484916c", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -1151,7 +1151,6 @@ begin\n            Pragma_Assertion_Policy               |\n            Pragma_Assume                         |\n            Pragma_Assume_No_Invalid_Values       |\n-           Pragma_AST_Entry                      |\n            Pragma_All_Calls_Remote               |\n            Pragma_Allow_Integer_Address          |\n            Pragma_Annotate                       |\n@@ -1201,7 +1200,6 @@ begin\n            Pragma_Elaboration_Checks             |\n            Pragma_Enable_Atomic_Synchronization  |\n            Pragma_Export                         |\n-           Pragma_Export_Exception               |\n            Pragma_Export_Function                |\n            Pragma_Export_Object                  |\n            Pragma_Export_Procedure               |\n@@ -1213,14 +1211,12 @@ begin\n            Pragma_Favor_Top_Level                |\n            Pragma_Fast_Math                      |\n            Pragma_Finalize_Storage_Only          |\n-           Pragma_Float_Representation           |\n            Pragma_Global                         |\n            Pragma_Ident                          |\n            Pragma_Implementation_Defined         |\n            Pragma_Implemented                    |\n            Pragma_Implicit_Packing               |\n            Pragma_Import                         |\n-           Pragma_Import_Exception               |\n            Pragma_Import_Function                |\n            Pragma_Import_Object                  |\n            Pragma_Import_Procedure               |\n@@ -1252,7 +1248,6 @@ begin\n            Pragma_Linker_Section                 |\n            Pragma_Lock_Free                      |\n            Pragma_Locking_Policy                 |\n-           Pragma_Long_Float                     |\n            Pragma_Loop_Invariant                 |\n            Pragma_Loop_Optimize                  |\n            Pragma_Loop_Variant                   |"}, {"sha": "6c585ccd92f6ed46f03007c109d5c9c61a5f5a6a", "filename": "gcc/ada/s-auxdec.ads", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-auxdec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-auxdec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -109,27 +109,15 @@ package System.Aux_DEC is\n \n    --  Floating point type declarations for VAX floating point data types\n \n-   pragma Warnings (Off);\n-   --  ??? needs comment\n-\n    type F_Float is digits 6;\n-   pragma Float_Representation (VAX_Float, F_Float);\n-\n    type D_Float is digits 9;\n-   pragma Float_Representation (Vax_Float, D_Float);\n-\n    type G_Float is digits 15;\n-   pragma Float_Representation (Vax_Float, G_Float);\n+   --  We provide the type names, but these will be IEEE, not VMS format\n \n    --  Floating point type declarations for IEEE floating point data types\n \n    type IEEE_Single_Float is digits 6;\n-   pragma Float_Representation (IEEE_Float, IEEE_Single_Float);\n-\n    type IEEE_Double_Float is digits 15;\n-   pragma Float_Representation (IEEE_Float, IEEE_Double_Float);\n-\n-   pragma Warnings (On);\n \n    Non_Ada_Error : exception;\n "}, {"sha": "3f40af8996db025b4d4f9013505dc35f28d6bad9", "filename": "gcc/ada/s-filofl.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-filofl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-filofl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-filofl.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,13 +34,14 @@\n --  we can't just use Long_Float, since this may have been mapped to Vax_Float\n --  using a Float_Representation configuration pragma.\n \n+--  TO BE RMOVED ???\n+\n with System.Fat_Gen;\n \n package System.Fat_IEEE_Long_Float is\n    pragma Pure;\n \n    type Fat_IEEE_Long is digits 15;\n-   pragma Float_Representation (IEEE_Float, Fat_IEEE_Long);\n \n    --  Note the only entity from this package that is accessed by Rtsfind\n    --  is the name of the package instantiation. Entities within this package"}, {"sha": "c5f1bac3a7fea0b423b3f1c30de3cbb3b44090e0", "filename": "gcc/ada/s-fishfl.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fishfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fishfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fishfl.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005,2009 Free Software Foundation, Inc.     --\n+--           Copyright (C) 1992-2014, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,13 +34,14 @@\n --  we can't just use Float, since this may have been mapped to Vax_Float\n --  using a Float_Representation configuration pragma.\n \n+--  TO BE REMOVED ???\n+\n with System.Fat_Gen;\n \n package System.Fat_IEEE_Short_Float is\n    pragma Pure;\n \n    type Fat_IEEE_Short is digits 6;\n-   pragma Float_Representation (IEEE_Float, Fat_IEEE_Short);\n \n    --  Note the only entity from this package that is accessed by Rtsfind\n    --  is the name of the package instantiation. Entities within this package"}, {"sha": "c5fedafb37c462b419684394577ab222c5202cb9", "filename": "gcc/ada/s-fvadfl.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fvadfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fvadfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fvadfl.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005,2009 Free Software Foundation, Inc.     --\n+--            Copyright (C) 1992-2014, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,17 +32,14 @@\n --  This package contains an instantiation of the floating-point attribute\n --  runtime routines for VAX D-float for use on VMS targets.\n \n+--  TO BE REMOVED ???\n+\n with System.Fat_Gen;\n \n package System.Fat_VAX_D_Float is\n    pragma Pure;\n \n-   pragma Warnings (Off);\n-   --  This unit is normally used only for VMS, but we compile it for other\n-   --  targets for the convenience of testing vms code using -gnatdm.\n-\n    type Fat_VAX_D is digits 9;\n-   pragma Float_Representation (VAX_Float, Fat_VAX_D);\n \n    --  Note the only entity from this package that is accessed by Rtsfind\n    --  is the name of the package instantiation. Entities within this package"}, {"sha": "fddcb6429536acf9acd897dda052c775e55a7a52", "filename": "gcc/ada/s-fvaffl.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fvaffl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fvaffl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fvaffl.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005,2009 Free Software Foundation, Inc.     --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,17 +32,14 @@\n --  This package contains an instantiation of the floating-point attribute\n --  runtime routines for VAX F-float for use on VMS targets.\n \n+--  TO BE REMOVED ???\n+\n with System.Fat_Gen;\n \n package System.Fat_VAX_F_Float is\n    pragma Pure;\n \n-   pragma Warnings (Off);\n-   --  This unit is normally used only for VMS, but we compile it for other\n-   --  targets for the convenience of testing vms code using -gnatdm.\n-\n    type Fat_VAX_F is digits 6;\n-   pragma Float_Representation (VAX_Float, Fat_VAX_F);\n \n    --  Note the only entity from this package that is accessed by Rtsfind\n    --  is the name of the package instantiation. Entities within this package"}, {"sha": "15bbc56f3b0c657b1586351c90fcc15b21c8ba3e", "filename": "gcc/ada/s-fvagfl.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fvagfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-fvagfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fvagfl.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005,2009 Free Software Foundation, Inc.     --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,17 +32,14 @@\n --  This package contains an instantiation of the floating-point attribute\n --  runtime routines for VAX F-float for use on VMS targets.\n \n+--  TO BE REMOVED ???\n+\n with System.Fat_Gen;\n \n package System.Fat_VAX_G_Float is\n    pragma Pure;\n \n-   pragma Warnings (Off);\n-   --  This unit is normally used only for VMS, but we compile it for other\n-   --  targets for the convenience of testing vms code using -gnatdm.\n-\n    type Fat_VAX_G is digits 15;\n-   pragma Float_Representation (VAX_Float, Fat_VAX_G);\n \n    --  Note the only entity from this package that is accessed by Rtsfind\n    --  is the name of the package instantiation. Entities within this package"}, {"sha": "1cb077e2b49017a9614e42674eac87e6a317ecde", "filename": "gcc/ada/s-vaflop.ads", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-vaflop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fs-vaflop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vaflop.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,34 +30,17 @@\n ------------------------------------------------------------------------------\n \n --  This package contains runtime routines for handling the non-IEEE\n---  floating-point formats used on the Vax and the Alpha.\n+--  floating-point formats used on the Vax.\n \n-package System.Vax_Float_Operations is\n+--  TO BE REMOVED ???\n \n-   pragma Warnings (Off);\n-   --  Suppress warnings if not on Alpha/VAX\n+package System.Vax_Float_Operations is\n \n    type D is digits 9;\n-   pragma Float_Representation (VAX_Float, D);\n-   --  D Float type on Vax\n-\n    type G is digits 15;\n-   pragma Float_Representation (VAX_Float, G);\n-   --  G Float type on Vax\n-\n    type F is digits 6;\n-   pragma Float_Representation (VAX_Float, F);\n-   --  F Float type on Vax\n-\n    type S is digits 6;\n-   pragma Float_Representation (IEEE_Float, S);\n-   --  IEEE short\n-\n    type T is digits 15;\n-   pragma Float_Representation (IEEE_Float, T);\n-   --  IEEE long\n-\n-   pragma Warnings (On);\n \n    type Q is range -2 ** 63 .. +(2 ** 63 - 1);\n    --  64-bit signed integer"}, {"sha": "bff45393eebf4fb940e2ad6e6fb371c58d78cbec", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 4, "deletions": 163, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -536,18 +536,6 @@ package body Sem_Attr is\n                end if;\n             end;\n \n-         --  Allow Address if the prefix is a reference to the AST_Entry\n-         --  attribute. If expansion is active, the attribute will be\n-         --  replaced by a function call, and address will work fine and\n-         --  get the proper value, but if expansion is not active, then\n-         --  the check here allows proper semantic analysis of the reference.\n-\n-         elsif Nkind (P) = N_Attribute_Reference\n-           and then Attribute_Name (P) = Name_AST_Entry\n-         then\n-            Rewrite (N,\n-                     New_Occurrence_Of (RTE (RE_Null_Address), Sloc (N)));\n-\n          --  Object is OK\n \n          elsif Is_Object_Reference (P) then\n@@ -2514,18 +2502,18 @@ package body Sem_Attr is\n          --  parameterless call. Entry attributes are handled specially below.\n \n          if Is_Entity_Name (P)\n-           and then not Nam_In (Aname, Name_Count, Name_Caller, Name_AST_Entry)\n+           and then not Nam_In (Aname, Name_Count, Name_Caller)\n          then\n             Check_Parameterless_Call (P);\n          end if;\n \n          if Is_Overloaded (P) then\n \n             --  Ada 2005 (AI-345): Since protected and task types have\n-            --  primitive entry wrappers, the attributes Count, Caller and\n-            --  AST_Entry require a context check\n+            --  primitive entry wrappers, the attributes Count, and Caller\n+            --  require a context check\n \n-            if Nam_In (Aname, Name_Count, Name_Caller, Name_AST_Entry) then\n+            if Nam_In (Aname, Name_Count, Name_Caller) then\n                declare\n                   Count : Natural := 0;\n                   I     : Interp_Index;\n@@ -2697,129 +2685,6 @@ package body Sem_Attr is\n \n          Set_Etype (N, RTE (RE_Asm_Output_Operand));\n \n-      ---------------\n-      -- AST_Entry --\n-      ---------------\n-\n-      when Attribute_AST_Entry => AST_Entry : declare\n-         Ent  : Entity_Id;\n-         Pref : Node_Id;\n-         Ptyp : Entity_Id;\n-\n-         Indexed : Boolean;\n-         --  Indicates if entry family index is present. Note the coding\n-         --  here handles the entry family case, but in fact it cannot be\n-         --  executed currently, because pragma AST_Entry does not permit\n-         --  the specification of an entry family.\n-\n-         procedure Bad_AST_Entry;\n-         --  Signal a bad AST_Entry pragma\n-\n-         function OK_Entry (E : Entity_Id) return Boolean;\n-         --  Checks that E is of an appropriate entity kind for an entry\n-         --  (i.e. E_Entry if Index is False, or E_Entry_Family if Index\n-         --  is set True for the entry family case). In the True case,\n-         --  makes sure that Is_AST_Entry is set on the entry.\n-\n-         -------------------\n-         -- Bad_AST_Entry --\n-         -------------------\n-\n-         procedure Bad_AST_Entry is\n-         begin\n-            Error_Attr_P (\"prefix for % attribute must be task entry\");\n-         end Bad_AST_Entry;\n-\n-         --------------\n-         -- OK_Entry --\n-         --------------\n-\n-         function OK_Entry (E : Entity_Id) return Boolean is\n-            Result : Boolean;\n-\n-         begin\n-            if Indexed then\n-               Result := (Ekind (E) = E_Entry_Family);\n-            else\n-               Result := (Ekind (E) = E_Entry);\n-            end if;\n-\n-            if Result then\n-               if not Is_AST_Entry (E) then\n-                  Error_Msg_Name_2 := Aname;\n-                  Error_Attr (\"% attribute requires previous % pragma\", P);\n-               end if;\n-            end if;\n-\n-            return Result;\n-         end OK_Entry;\n-\n-      --  Start of processing for AST_Entry\n-\n-      begin\n-         Check_VMS (N);\n-         Check_E0;\n-\n-         --  Deal with entry family case\n-\n-         if Nkind (P) = N_Indexed_Component then\n-            Pref := Prefix (P);\n-            Indexed := True;\n-         else\n-            Pref := P;\n-            Indexed := False;\n-         end if;\n-\n-         Ptyp := Etype (Pref);\n-\n-         if Ptyp = Any_Type or else Error_Posted (Pref) then\n-            return;\n-         end if;\n-\n-         --  If the prefix is a selected component whose prefix is of an\n-         --  access type, then introduce an explicit dereference.\n-         --  ??? Could we reuse Check_Dereference here?\n-\n-         if Nkind (Pref) = N_Selected_Component\n-           and then Is_Access_Type (Ptyp)\n-         then\n-            Rewrite (Pref,\n-              Make_Explicit_Dereference (Sloc (Pref),\n-                Relocate_Node (Pref)));\n-            Analyze_And_Resolve (Pref, Designated_Type (Ptyp));\n-         end if;\n-\n-         --  Prefix can be of the form a.b, where a is a task object\n-         --  and b is one of the entries of the corresponding task type.\n-\n-         if Nkind (Pref) = N_Selected_Component\n-           and then OK_Entry (Entity (Selector_Name (Pref)))\n-           and then Is_Object_Reference (Prefix (Pref))\n-           and then Is_Task_Type (Etype (Prefix (Pref)))\n-         then\n-            null;\n-\n-         --  Otherwise the prefix must be an entry of a containing task,\n-         --  or of a variable of the enclosing task type.\n-\n-         else\n-            if Nkind_In (Pref, N_Identifier, N_Expanded_Name) then\n-               Ent := Entity (Pref);\n-\n-               if not OK_Entry (Ent)\n-                 or else not In_Open_Scopes (Scope (Ent))\n-               then\n-                  Bad_AST_Entry;\n-               end if;\n-\n-            else\n-               Bad_AST_Entry;\n-            end if;\n-         end if;\n-\n-         Set_Etype (N, RTE (RE_AST_Handler));\n-      end AST_Entry;\n-\n       -----------------------------\n       -- Atomic_Always_Lock_Free --\n       -----------------------------\n@@ -7858,20 +7723,6 @@ package body Sem_Attr is\n          end if;\n       end Alignment_Block;\n \n-      ---------------\n-      -- AST_Entry --\n-      ---------------\n-\n-      --  Can only be folded in No_Ast_Handler case\n-\n-      when Attribute_AST_Entry =>\n-         if not Is_AST_Entry (P_Entity) then\n-            Rewrite (N,\n-              New_Occurrence_Of (RTE (RE_No_AST_Handler), Loc));\n-         else\n-            null;\n-         end if;\n-\n       -----------------------------\n       -- Atomic_Always_Lock_Free --\n       -----------------------------\n@@ -10837,16 +10688,6 @@ package body Sem_Attr is\n             end if;\n          end Address_Attribute;\n \n-         ---------------\n-         -- AST_Entry --\n-         ---------------\n-\n-         --  Prefix of the AST_Entry attribute is an entry name which must\n-         --  not be resolved, since this is definitely not an entry call.\n-\n-         when Attribute_AST_Entry =>\n-            null;\n-\n          ------------------\n          -- Body_Version --\n          ------------------"}, {"sha": "c70eb06d762f663d1c925ee0d16d46725ad6db87", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -89,23 +89,6 @@ package Sem_Attr is\n       --  Machine_Code to construct machine instructions. See documentation\n       --  in package Machine_Code in file s-maccod.ads.\n \n-      ---------------\n-      -- AST_Entry --\n-      ---------------\n-\n-      Attribute_AST_Entry => True,\n-      --  E'Ast_Entry, where E is a task entry, yields a value of the\n-      --  predefined type System.DEC.AST_Handler, that enables the given\n-      --  entry to be called when an AST occurs. If the name to which the\n-      --  attribute applies has not been specified with the pragma AST_Entry,\n-      --  the attribute returns the value No_Ast_Handler, and no AST occurs.\n-      --  If the entry is for a task that is not callable (T'Callable False),\n-      --  the exception program error is raised. If an AST occurs for an\n-      --  entry of a task that is terminated, the program is erroneous.\n-      --\n-      --  The attribute AST_Entry is supported only in OpenVMS versions\n-      --  of GNAT. It will be rejected as illegal in other GNAT versions.\n-\n       ---------\n       -- Bit --\n       ---------"}, {"sha": "bf720be6f1bf7116a1ca42dbe108005262ec001d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -10875,19 +10875,10 @@ package body Sem_Ch13 is\n       then\n          return 0;\n \n-         --  Access types. Normally an access type cannot have a size smaller\n-         --  than the size of System.Address. The exception is on VMS, where\n-         --  we have short and long addresses, and it is possible for an access\n-         --  type to have a short address size (and thus be less than the size\n-         --  of System.Address itself). We simply skip the check for VMS, and\n-         --  leave it to the back end to do the check.\n+         --  Access types (cannot have size smaller than System.Address)\n \n       elsif Is_Access_Type (T) then\n-         if OpenVMS_On_Target then\n-            return 0;\n-         else\n-            return System_Address_Size;\n-         end if;\n+         return System_Address_Size;\n \n       --  Floating-point types\n \n@@ -12588,13 +12579,10 @@ package body Sem_Ch13 is\n         and then Convention (Target) /= Convention (Source)\n         and then Warn_On_Unchecked_Conversion\n       then\n-         --  Give warnings for subprogram pointers only on most targets. The\n-         --  exception is VMS, where data pointers can have different lengths\n-         --  depending on the pointer convention.\n+         --  Give warnings for subprogram pointers only on most targets\n \n          if Is_Access_Subprogram_Type (Target)\n            or else Is_Access_Subprogram_Type (Source)\n-           or else OpenVMS_On_Target\n          then\n             Error_Msg_N\n               (\"?z?conversion between pointers with different conventions!\","}, {"sha": "cfda6596607a18ceb47e718cd9d75b9df4bc9531", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -16004,15 +16004,6 @@ package body Sem_Ch3 is\n             return False;\n          end if;\n \n-         --  Avoid types not matching pragma Float_Representation, if present\n-\n-         if (Opt.Float_Format = 'I' and then Float_Rep (E) /= IEEE_Binary)\n-              or else\n-            (Opt.Float_Format = 'V' and then Float_Rep (E) /= VAX_Native)\n-         then\n-            return False;\n-         end if;\n-\n          --  Check for matching range, if specified\n \n          if Present (Spec) then"}, {"sha": "cb0facadf60cdb6d2ccc7676d7fd8d945d14d4cf", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -3388,12 +3388,11 @@ package body Sem_Ch8 is\n \n       --  This procedure is called in the context of subprogram renaming, and\n       --  thus the attribute must be one that is a subprogram. All of those\n-      --  have at least one formal parameter, with the exceptions of AST_Entry\n-      --  (which is a real oddity, it is odd that this can be renamed at all)\n-      --  and the GNAT attribute 'Img, which GNAT treats as renameable.\n+      --  have at least one formal parameter, with the exceptions of the GNAT\n+      --  attribute 'Img, which GNAT treats as renameable.\n \n       if not Is_Non_Empty_List (Parameter_Specifications (Spec)) then\n-         if Aname /= Name_AST_Entry and then Aname /= Name_Img then\n+         if Aname /= Name_Img then\n             Error_Msg_N\n               (\"subprogram renaming an attribute must have formals\", N);\n             return;\n@@ -3463,46 +3462,18 @@ package body Sem_Ch8 is\n          end if;\n       end if;\n \n-      --  AST_Entry is an odd case. It doesn't really make much sense to allow\n-      --  it to be renamed, but that's the DEC rule, so we have to do it right.\n-      --  The point is that the AST_Entry call should be made now, and what the\n-      --  function will return is the returned value.\n+      --  Rewrite attribute node to have a list of expressions corresponding to\n+      --  the subprogram formals. A renaming declaration is not a freeze point,\n+      --  and the analysis of the attribute reference should not freeze the\n+      --  type of the prefix. We use the original node in the renaming so that\n+      --  its source location is preserved, and checks on stream attributes are\n+      --  properly applied.\n \n-      --  Note that there is no Expr_List in this case anyway\n+      Attr_Node := Relocate_Node (Nam);\n+      Set_Expressions (Attr_Node, Expr_List);\n \n-      if Aname = Name_AST_Entry then\n-         declare\n-            Ent  : constant Entity_Id := Make_Temporary (Loc, 'R', Nam);\n-            Decl : Node_Id;\n-\n-         begin\n-            Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Ent,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (RTE (RE_AST_Handler), Loc),\n-                Expression          => Nam,\n-                Constant_Present    => True);\n-\n-            Set_Assignment_OK (Decl, True);\n-            Insert_Action (N, Decl);\n-            Attr_Node := Make_Identifier (Loc, Chars (Ent));\n-         end;\n-\n-      --  For all other attributes, we rewrite the attribute node to have\n-      --  a list of expressions corresponding to the subprogram formals.\n-      --  A renaming declaration is not a freeze point, and the analysis of\n-      --  the attribute reference should not freeze the type of the prefix.\n-      --  We use the original node in the renaming so that its source location\n-      --  is preserved, and checks on stream attributes are properly applied.\n-\n-      else\n-         Attr_Node := Relocate_Node (Nam);\n-         Set_Expressions (Attr_Node, Expr_List);\n-\n-         Set_Must_Not_Freeze (Attr_Node);\n-         Set_Must_Not_Freeze (Prefix (Nam));\n-      end if;\n+      Set_Must_Not_Freeze (Attr_Node);\n+      Set_Must_Not_Freeze (Prefix (Nam));\n \n       --  Case of renaming a function\n \n@@ -3547,7 +3518,7 @@ package body Sem_Ch8 is\n       --  In case of tagged types we add the body of the generated function to\n       --  the freezing actions of the type (because in the general case such\n       --  type is still not frozen). We exclude from this processing generic\n-      --  formal subprograms found in instantiations and AST_Entry renamings.\n+      --  formal subprograms found in instantiations.\n \n       --  We must exclude VM targets and restricted run-time libraries because\n       --  entity AST_Handler is defined in package System.Aux_Dec which is not"}, {"sha": "ac5d494719aa6e1f010e35c7429cdcdea0563b56", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 30, "deletions": 613, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -68,7 +68,6 @@ with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n-with Sem_VFpt; use Sem_VFpt;\n with Sem_Warn; use Sem_Warn;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n@@ -125,8 +124,7 @@ package body Sem_Prag is\n    --  If the External parameter is given as an identifier (or there is no\n    --  External parameter, so that the Internal identifier is used), then\n    --  the external name is the characters of the identifier, translated\n-   --  to all upper case letters for OpenVMS versions of GNAT, and to all\n-   --  lower case letters for all other versions\n+   --  to all lower case letters.\n \n    --  Note: the external name specified or implied by any of these special\n    --  Import_xxx or Export_xxx pragmas override an external or link name\n@@ -3227,16 +3225,6 @@ package body Sem_Prag is\n       --  Common processing for Disable/Enable_Atomic_Synchronization. Nam is\n       --  Name_Suppress for Disable and Name_Unsuppress for Enable.\n \n-      procedure Process_Extended_Import_Export_Exception_Pragma\n-        (Arg_Internal : Node_Id;\n-         Arg_External : Node_Id;\n-         Arg_Form     : Node_Id;\n-         Arg_Code     : Node_Id);\n-      --  Common processing for the pragmas Import/Export_Exception. The three\n-      --  arguments correspond to the three named parameters of the pragma. An\n-      --  argument is empty if the corresponding parameter is not present in\n-      --  the pragma.\n-\n       procedure Process_Extended_Import_Export_Object_Pragma\n         (Arg_Internal : Node_Id;\n          Arg_External : Node_Id;\n@@ -6880,14 +6868,10 @@ package body Sem_Prag is\n          elsif Is_Convention_Name (Cname) then\n             C := Get_Convention_Id (Chars (Get_Pragma_Arg (Arg1)));\n \n-         --  In DEC VMS, it seems that there is an undocumented feature that\n-         --  any unrecognized convention is treated as the default, which for\n-         --  us is convention C. It does not seem so terrible to do this\n-         --  unconditionally, silently in the VMS case, and with a warning\n-         --  in the non-VMS case.\n+         --  Otherwise warn on unrecognized convention\n \n          else\n-            if Warn_On_Export_Import and not OpenVMS_On_Target then\n+            if Warn_On_Export_Import then\n                Error_Msg_N\n                  (\"??unrecognized convention name, C assumed\",\n                   Get_Pragma_Arg (Arg1));\n@@ -7168,69 +7152,6 @@ package body Sem_Prag is\n          Analyze (N);\n       end Process_Disable_Enable_Atomic_Sync;\n \n-      -----------------------------------------------------\n-      -- Process_Extended_Import_Export_Exception_Pragma --\n-      -----------------------------------------------------\n-\n-      procedure Process_Extended_Import_Export_Exception_Pragma\n-        (Arg_Internal : Node_Id;\n-         Arg_External : Node_Id;\n-         Arg_Form     : Node_Id;\n-         Arg_Code     : Node_Id)\n-      is\n-         Def_Id   : Entity_Id;\n-         Code_Val : Uint;\n-\n-      begin\n-         if not OpenVMS_On_Target then\n-            Error_Pragma\n-              (\"??pragma% ignored (applies only to Open'V'M'S)\");\n-         end if;\n-\n-         Process_Extended_Import_Export_Internal_Arg (Arg_Internal);\n-         Def_Id := Entity (Arg_Internal);\n-\n-         if Ekind (Def_Id) /= E_Exception then\n-            Error_Pragma_Arg\n-              (\"pragma% must refer to declared exception\", Arg_Internal);\n-         end if;\n-\n-         Set_Extended_Import_Export_External_Name (Def_Id, Arg_External);\n-\n-         if Present (Arg_Form) then\n-            Check_Arg_Is_One_Of (Arg_Form, Name_Ada, Name_VMS);\n-         end if;\n-\n-         if Present (Arg_Form)\n-           and then Chars (Arg_Form) = Name_Ada\n-         then\n-            null;\n-         else\n-            Set_Is_VMS_Exception (Def_Id);\n-            Set_Exception_Code (Def_Id, No_Uint);\n-         end if;\n-\n-         if Present (Arg_Code) then\n-            if not Is_VMS_Exception (Def_Id) then\n-               Error_Pragma_Arg\n-                 (\"Code option for pragma% not allowed for Ada case\",\n-                  Arg_Code);\n-            end if;\n-\n-            Check_Arg_Is_OK_Static_Expression (Arg_Code, Any_Integer);\n-            Code_Val := Expr_Value (Arg_Code);\n-\n-            if not UI_Is_In_Int_Range (Code_Val) then\n-               Error_Pragma_Arg\n-                 (\"Code option for pragma% must be in 32-bit range\",\n-                  Arg_Code);\n-\n-            else\n-               Set_Exception_Code (Def_Id, Code_Val);\n-            end if;\n-         end if;\n-      end Process_Extended_Import_Export_Exception_Pragma;\n-\n       -------------------------------------------------\n       -- Process_Extended_Import_Export_Internal_Arg --\n       -------------------------------------------------\n@@ -9445,13 +9366,15 @@ package body Sem_Prag is\n                Set_Is_Public (E);\n                Set_Is_Statically_Allocated (E);\n \n-               --  Warn if the corresponding W flag is set and the pragma comes\n-               --  from source. The latter may not be true e.g. on VMS where we\n-               --  expand export pragmas for exception codes associated with\n-               --  imported or exported exceptions. We do not want to generate\n-               --  a warning for something that the user did not write.\n+               --  Warn if the corresponding W flag is set\n \n                if Warn_On_Export_Import\n+\n+                 --  Only do this for something that was in the source. Not\n+                 --  clear if this can be False now (there used for sure to\n+                 --  be cases on VMS where it was False), but anyway the test\n+                 --  is harmless if not needed, so it is retained.\n+\n                  and then Comes_From_Source (Arg)\n                then\n                   Error_Msg_NE\n@@ -9645,27 +9568,10 @@ package body Sem_Prag is\n       --  form created by the parser.\n \n       procedure Set_Mechanism_Value (Ent : Entity_Id; Mech_Name : Node_Id) is\n-         Class        : Node_Id;\n-         Param        : Node_Id;\n-         Mech_Name_Id : Name_Id;\n-\n-         procedure Bad_Class;\n-         pragma No_Return (Bad_Class);\n-         --  Signal bad descriptor class name\n-\n          procedure Bad_Mechanism;\n          pragma No_Return (Bad_Mechanism);\n          --  Signal bad mechanism name\n \n-         ---------------\n-         -- Bad_Class --\n-         ---------------\n-\n-         procedure Bad_Class is\n-         begin\n-            Error_Pragma_Arg (\"unrecognized descriptor class name\", Class);\n-         end Bad_Class;\n-\n          -------------------------\n          -- Bad_Mechanism_Value --\n          -------------------------\n@@ -9683,8 +9589,7 @@ package body Sem_Prag is\n               (\"mechanism for & has already been set\", Mech_Name, Ent);\n          end if;\n \n-         --  MECHANISM_NAME ::= value | reference | descriptor |\n-         --                     short_descriptor\n+         --  MECHANISM_NAME ::= value | reference\n \n          if Nkind (Mech_Name) = N_Identifier then\n             if Chars (Mech_Name) = Name_Value then\n@@ -9695,24 +9600,6 @@ package body Sem_Prag is\n                Set_Mechanism (Ent, By_Reference);\n                return;\n \n-            elsif Chars (Mech_Name) = Name_Descriptor then\n-               Check_VMS (Mech_Name);\n-\n-               --  Descriptor => Short_Descriptor if pragma was given\n-\n-               if Short_Descriptors then\n-                  Set_Mechanism (Ent, By_Short_Descriptor);\n-               else\n-                  Set_Mechanism (Ent, By_Descriptor);\n-               end if;\n-\n-               return;\n-\n-            elsif Chars (Mech_Name) = Name_Short_Descriptor then\n-               Check_VMS (Mech_Name);\n-               Set_Mechanism (Ent, By_Short_Descriptor);\n-               return;\n-\n             elsif Chars (Mech_Name) = Name_Copy then\n                Error_Pragma_Arg\n                  (\"bad mechanism name, Value assumed\", Mech_Name);\n@@ -9721,141 +9608,9 @@ package body Sem_Prag is\n                Bad_Mechanism;\n             end if;\n \n-         --  MECHANISM_NAME ::= descriptor (CLASS_NAME) |\n-         --                     short_descriptor (CLASS_NAME)\n-         --  CLASS_NAME     ::= ubs | ubsb | uba | s | sb | a | nca\n-\n-         --  Note: this form is parsed as an indexed component\n-\n-         elsif Nkind (Mech_Name) = N_Indexed_Component then\n-            Class := First (Expressions (Mech_Name));\n-\n-            if Nkind (Prefix (Mech_Name)) /= N_Identifier\n-              or else\n-                not Nam_In (Chars (Prefix (Mech_Name)), Name_Descriptor,\n-                                                        Name_Short_Descriptor)\n-              or else Present (Next (Class))\n-            then\n-               Bad_Mechanism;\n-            else\n-               Mech_Name_Id := Chars (Prefix (Mech_Name));\n-\n-               --  Change Descriptor => Short_Descriptor if pragma was given\n-\n-               if Mech_Name_Id = Name_Descriptor\n-                 and then Short_Descriptors\n-               then\n-                  Mech_Name_Id := Name_Short_Descriptor;\n-               end if;\n-            end if;\n-\n-         --  MECHANISM_NAME ::= descriptor (Class => CLASS_NAME) |\n-         --                     short_descriptor (Class => CLASS_NAME)\n-         --  CLASS_NAME     ::= ubs | ubsb | uba | s | sb | a | nca\n-\n-         --  Note: this form is parsed as a function call\n-\n-         elsif Nkind (Mech_Name) = N_Function_Call then\n-            Param := First (Parameter_Associations (Mech_Name));\n-\n-            if Nkind (Name (Mech_Name)) /= N_Identifier\n-              or else\n-                not Nam_In (Chars (Name (Mech_Name)), Name_Descriptor,\n-                                                      Name_Short_Descriptor)\n-              or else Present (Next (Param))\n-              or else No (Selector_Name (Param))\n-              or else Chars (Selector_Name (Param)) /= Name_Class\n-            then\n-               Bad_Mechanism;\n-            else\n-               Class := Explicit_Actual_Parameter (Param);\n-               Mech_Name_Id := Chars (Name (Mech_Name));\n-            end if;\n-\n          else\n             Bad_Mechanism;\n          end if;\n-\n-         --  Fall through here with Class set to descriptor class name\n-\n-         Check_VMS (Mech_Name);\n-\n-         if Nkind (Class) /= N_Identifier then\n-            Bad_Class;\n-\n-         elsif Mech_Name_Id = Name_Descriptor\n-           and then Chars (Class) = Name_UBS\n-         then\n-            Set_Mechanism (Ent, By_Descriptor_UBS);\n-\n-         elsif Mech_Name_Id = Name_Descriptor\n-           and then Chars (Class) = Name_UBSB\n-         then\n-            Set_Mechanism (Ent, By_Descriptor_UBSB);\n-\n-         elsif Mech_Name_Id = Name_Descriptor\n-           and then Chars (Class) = Name_UBA\n-         then\n-            Set_Mechanism (Ent, By_Descriptor_UBA);\n-\n-         elsif Mech_Name_Id = Name_Descriptor\n-           and then Chars (Class) = Name_S\n-         then\n-            Set_Mechanism (Ent, By_Descriptor_S);\n-\n-         elsif Mech_Name_Id = Name_Descriptor\n-           and then Chars (Class) = Name_SB\n-         then\n-            Set_Mechanism (Ent, By_Descriptor_SB);\n-\n-         elsif Mech_Name_Id = Name_Descriptor\n-           and then Chars (Class) = Name_A\n-         then\n-            Set_Mechanism (Ent, By_Descriptor_A);\n-\n-         elsif Mech_Name_Id = Name_Descriptor\n-           and then Chars (Class) = Name_NCA\n-         then\n-            Set_Mechanism (Ent, By_Descriptor_NCA);\n-\n-         elsif Mech_Name_Id = Name_Short_Descriptor\n-           and then Chars (Class) = Name_UBS\n-         then\n-            Set_Mechanism (Ent, By_Short_Descriptor_UBS);\n-\n-         elsif Mech_Name_Id = Name_Short_Descriptor\n-           and then Chars (Class) = Name_UBSB\n-         then\n-            Set_Mechanism (Ent, By_Short_Descriptor_UBSB);\n-\n-         elsif Mech_Name_Id = Name_Short_Descriptor\n-           and then Chars (Class) = Name_UBA\n-         then\n-            Set_Mechanism (Ent, By_Short_Descriptor_UBA);\n-\n-         elsif Mech_Name_Id = Name_Short_Descriptor\n-           and then Chars (Class) = Name_S\n-         then\n-            Set_Mechanism (Ent, By_Short_Descriptor_S);\n-\n-         elsif Mech_Name_Id = Name_Short_Descriptor\n-           and then Chars (Class) = Name_SB\n-         then\n-            Set_Mechanism (Ent, By_Short_Descriptor_SB);\n-\n-         elsif Mech_Name_Id = Name_Short_Descriptor\n-           and then Chars (Class) = Name_A\n-         then\n-            Set_Mechanism (Ent, By_Short_Descriptor_A);\n-\n-         elsif Mech_Name_Id = Name_Short_Descriptor\n-           and then Chars (Class) = Name_NCA\n-         then\n-            Set_Mechanism (Ent, By_Short_Descriptor_NCA);\n-\n-         else\n-            Bad_Class;\n-         end if;\n       end Set_Mechanism_Value;\n \n       --------------------------\n@@ -11092,9 +10847,10 @@ package body Sem_Prag is\n             Check_Arg_Count (0);\n \n             --  If Address is a private type, then set the flag to allow\n-            --  integer address values. If Address is not private (e.g. on\n-            --  VMS, where it is an integer type), then this pragma has no\n-            --  purpose, so it is simply ignored.\n+            --  integer address values. If Address is not private, then\n+            --  this pragma has no purpose, so it is simply ignored. Not\n+            --  clear if there are any such targets now (VMS used to be\n+            --  one such, but leave test in for the future anyway).\n \n             if Opt.Address_Is_Private then\n                Opt.Allow_Integer_Address := True;\n@@ -11566,63 +11322,6 @@ package body Sem_Prag is\n             Analyze (N);\n          end Attribute_Definition;\n \n-         ---------------\n-         -- AST_Entry --\n-         ---------------\n-\n-         --  pragma AST_Entry (entry_IDENTIFIER);\n-\n-         when Pragma_AST_Entry => AST_Entry : declare\n-            Ent : Node_Id;\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_VMS (N);\n-            Check_Arg_Count (1);\n-            Check_No_Identifiers;\n-            Check_Arg_Is_Local_Name (Arg1);\n-            Ent := Entity (Get_Pragma_Arg (Arg1));\n-\n-            --  Note: the implementation of the AST_Entry pragma could handle\n-            --  the entry family case fine, but for now we are consistent with\n-            --  the DEC rules, and do not allow the pragma, which of course\n-            --  has the effect of also forbidding the attribute.\n-\n-            if Ekind (Ent) /= E_Entry then\n-               Error_Pragma_Arg\n-                 (\"pragma% argument must be simple entry name\", Arg1);\n-\n-            elsif Is_AST_Entry (Ent) then\n-               Error_Pragma_Arg\n-                 (\"duplicate % pragma for entry\", Arg1);\n-\n-            elsif Has_Homonym (Ent) then\n-               Error_Pragma_Arg\n-                 (\"pragma% argument cannot specify overloaded entry\", Arg1);\n-\n-            else\n-               declare\n-                  FF : constant Entity_Id := First_Formal (Ent);\n-\n-               begin\n-                  if Present (FF) then\n-                     if Present (Next_Formal (FF)) then\n-                        Error_Pragma_Arg\n-                          (\"entry for pragma% can have only one argument\",\n-                           Arg1);\n-\n-                     elsif Parameter_Mode (FF) /= E_In_Parameter then\n-                        Error_Pragma_Arg\n-                          (\"entry parameter for pragma% must have mode IN\",\n-                           Arg1);\n-                     end if;\n-                  end if;\n-               end;\n-\n-               Set_Is_AST_Entry (Ent);\n-            end if;\n-         end AST_Entry;\n-\n          ------------------------------------------------------------------\n          -- Async_Readers/Async_Writers/Effective_Reads/Effective_Writes --\n          ------------------------------------------------------------------\n@@ -13857,48 +13556,6 @@ package body Sem_Prag is\n             end if;\n          end Export;\n \n-         ----------------------\n-         -- Export_Exception --\n-         ----------------------\n-\n-         --  pragma Export_Exception (\n-         --        [Internal         =>] LOCAL_NAME\n-         --     [, [External         =>] EXTERNAL_SYMBOL]\n-         --     [, [Form     =>] Ada | VMS]\n-         --     [, [Code     =>] static_integer_EXPRESSION]);\n-\n-         when Pragma_Export_Exception => Export_Exception : declare\n-            Args  : Args_List (1 .. 4);\n-            Names : constant Name_List (1 .. 4) := (\n-                      Name_Internal,\n-                      Name_External,\n-                      Name_Form,\n-                      Name_Code);\n-\n-            Internal : Node_Id renames Args (1);\n-            External : Node_Id renames Args (2);\n-            Form     : Node_Id renames Args (3);\n-            Code     : Node_Id renames Args (4);\n-\n-         begin\n-            GNAT_Pragma;\n-\n-            if Inside_A_Generic then\n-               Error_Pragma (\"pragma% cannot be used for generic entities\");\n-            end if;\n-\n-            Gather_Associations (Names, Args);\n-            Process_Extended_Import_Export_Exception_Pragma (\n-              Arg_Internal => Internal,\n-              Arg_External => External,\n-              Arg_Form     => Form,\n-              Arg_Code     => Code);\n-\n-            if not Is_VMS_Exception (Entity (Internal)) then\n-               Set_Exported (Entity (Internal), Internal);\n-            end if;\n-         end Export_Exception;\n-\n          ---------------------\n          -- Export_Function --\n          ---------------------\n@@ -14388,106 +14045,6 @@ package body Sem_Prag is\n             end if;\n          end Finalize_Storage;\n \n-         --------------------------\n-         -- Float_Representation --\n-         --------------------------\n-\n-         --  pragma Float_Representation (FLOAT_REP[, float_type_LOCAL_NAME]);\n-\n-         --  FLOAT_REP ::= VAX_Float | IEEE_Float\n-\n-         when Pragma_Float_Representation => Float_Representation : declare\n-            Argx : Node_Id;\n-            Digs : Nat;\n-            Ent  : Entity_Id;\n-\n-         begin\n-            GNAT_Pragma;\n-\n-            if Arg_Count = 1 then\n-               Check_Valid_Configuration_Pragma;\n-            else\n-               Check_Arg_Count (2);\n-               Check_Optional_Identifier (Arg2, Name_Entity);\n-               Check_Arg_Is_Local_Name (Arg2);\n-            end if;\n-\n-            Check_No_Identifier (Arg1);\n-            Check_Arg_Is_One_Of (Arg1, Name_VAX_Float, Name_IEEE_Float);\n-\n-            if not OpenVMS_On_Target then\n-               if Chars (Get_Pragma_Arg (Arg1)) = Name_VAX_Float then\n-                  Error_Pragma\n-                    (\"??pragma% ignored (applies only to Open'V'M'S)\");\n-               end if;\n-\n-               return;\n-            end if;\n-\n-            --  One argument case\n-\n-            if Arg_Count = 1 then\n-               if Chars (Get_Pragma_Arg (Arg1)) = Name_VAX_Float then\n-                  if Opt.Float_Format = 'I' then\n-                     Error_Pragma (\"'I'E'E'E format previously specified\");\n-                  end if;\n-\n-                  Opt.Float_Format := 'V';\n-\n-               else\n-                  if Opt.Float_Format = 'V' then\n-                     Error_Pragma (\"'V'A'X format previously specified\");\n-                  end if;\n-\n-                  Opt.Float_Format := 'I';\n-               end if;\n-\n-               Set_Standard_Fpt_Formats;\n-\n-            --  Two argument case\n-\n-            else\n-               Argx := Get_Pragma_Arg (Arg2);\n-\n-               if not Is_Entity_Name (Argx)\n-                 or else not Is_Floating_Point_Type (Entity (Argx))\n-               then\n-                  Error_Pragma_Arg\n-                    (\"second argument of% pragma must be floating-point type\",\n-                     Arg2);\n-               end if;\n-\n-               Ent  := Entity (Argx);\n-               Digs := UI_To_Int (Digits_Value (Ent));\n-\n-               --  Two arguments, VAX_Float case\n-\n-               if Chars (Get_Pragma_Arg (Arg1)) = Name_VAX_Float then\n-                  case Digs is\n-                     when  6 => Set_F_Float (Ent);\n-                     when  9 => Set_D_Float (Ent);\n-                     when 15 => Set_G_Float (Ent);\n-\n-                     when others =>\n-                        Error_Pragma_Arg\n-                          (\"wrong digits value, must be 6,9 or 15\", Arg2);\n-                  end case;\n-\n-               --  Two arguments, IEEE_Float case\n-\n-               else\n-                  case Digs is\n-                     when  6 => Set_IEEE_Short (Ent);\n-                     when 15 => Set_IEEE_Long  (Ent);\n-\n-                     when others =>\n-                        Error_Pragma_Arg\n-                          (\"wrong digits value, must be 6 or 15\", Arg2);\n-                  end case;\n-               end if;\n-            end if;\n-         end Float_Representation;\n-\n          ------------\n          -- Global --\n          ------------\n@@ -14630,25 +14187,6 @@ package body Sem_Prag is\n                      end if;\n \n                   else\n-                     --  In VMS, the effect of IDENT is achieved by passing\n-                     --  --identification=name as a --for-linker switch.\n-\n-                     if OpenVMS_On_Target then\n-                        Start_String;\n-                        Store_String_Chars\n-                          (\"--for-linker=--identification=\");\n-                        String_To_Name_Buffer (Strval (Str));\n-                        Store_String_Chars (Name_Buffer (1 .. Name_Len));\n-\n-                        --  Only the last processed IDENT is saved. The main\n-                        --  purpose is so an IDENT associated with a main\n-                        --  procedure will be used in preference to an IDENT\n-                        --  associated with a with'd package.\n-\n-                        Replace_Linker_Option_String\n-                          (End_String, \"--for-linker=--identification=\");\n-                     end if;\n-\n                      Set_Ident_String (Current_Sem_Unit, Str);\n                   end if;\n \n@@ -14845,49 +14383,6 @@ package body Sem_Prag is\n             Check_At_Most_N_Arguments  (4);\n             Process_Import_Or_Interface;\n \n-         ----------------------\n-         -- Import_Exception --\n-         ----------------------\n-\n-         --  pragma Import_Exception (\n-         --        [Internal         =>] LOCAL_NAME\n-         --     [, [External         =>] EXTERNAL_SYMBOL]\n-         --     [, [Form     =>] Ada | VMS]\n-         --     [, [Code     =>] static_integer_EXPRESSION]);\n-\n-         when Pragma_Import_Exception => Import_Exception : declare\n-            Args  : Args_List (1 .. 4);\n-            Names : constant Name_List (1 .. 4) := (\n-                      Name_Internal,\n-                      Name_External,\n-                      Name_Form,\n-                      Name_Code);\n-\n-            Internal : Node_Id renames Args (1);\n-            External : Node_Id renames Args (2);\n-            Form     : Node_Id renames Args (3);\n-            Code     : Node_Id renames Args (4);\n-\n-         begin\n-            GNAT_Pragma;\n-            Gather_Associations (Names, Args);\n-\n-            if Present (External) and then Present (Code) then\n-               Error_Pragma\n-                 (\"cannot give both External and Code options for pragma%\");\n-            end if;\n-\n-            Process_Extended_Import_Export_Exception_Pragma (\n-              Arg_Internal => Internal,\n-              Arg_External => External,\n-              Arg_Form     => Form,\n-              Arg_Code     => Code);\n-\n-            if not Is_VMS_Exception (Entity (Internal)) then\n-               Set_Imported (Entity (Internal));\n-            end if;\n-         end Import_Exception;\n-\n          ---------------------\n          -- Import_Function --\n          ---------------------\n@@ -16692,65 +16187,6 @@ package body Sem_Prag is\n             end if;\n          end;\n \n-         ----------------\n-         -- Long_Float --\n-         ----------------\n-\n-         --  pragma Long_Float (D_Float | G_Float);\n-\n-         when Pragma_Long_Float => Long_Float : declare\n-         begin\n-            GNAT_Pragma;\n-            Check_Valid_Configuration_Pragma;\n-            Check_Arg_Count (1);\n-            Check_No_Identifier (Arg1);\n-            Check_Arg_Is_One_Of (Arg1, Name_D_Float, Name_G_Float);\n-\n-            if not OpenVMS_On_Target then\n-               Error_Pragma (\"??pragma% ignored (applies only to Open'V'M'S)\");\n-            end if;\n-\n-            --  D_Float case\n-\n-            if Chars (Get_Pragma_Arg (Arg1)) = Name_D_Float then\n-               if Opt.Float_Format_Long = 'G' then\n-                  Error_Pragma_Arg\n-                    (\"G_Float previously specified\", Arg1);\n-\n-               elsif Current_Sem_Unit /= Main_Unit\n-                 and then Opt.Float_Format_Long /= 'D'\n-               then\n-                  Error_Pragma_Arg\n-                    (\"main unit not compiled with pragma Long_Float (D_Float)\",\n-                     \"\\pragma% must be used consistently for whole partition\",\n-                     Arg1);\n-\n-               else\n-                  Opt.Float_Format_Long := 'D';\n-               end if;\n-\n-            --  G_Float case (this is the default, does not need overriding)\n-\n-            else\n-               if Opt.Float_Format_Long = 'D' then\n-                  Error_Pragma (\"D_Float previously specified\");\n-\n-               elsif Current_Sem_Unit /= Main_Unit\n-                 and then Opt.Float_Format_Long /= 'G'\n-               then\n-                  Error_Pragma_Arg\n-                    (\"main unit not compiled with pragma Long_Float (G_Float)\",\n-                     \"\\pragma% must be used consistently for whole partition\",\n-                     Arg1);\n-\n-               else\n-                  Opt.Float_Format_Long := 'G';\n-               end if;\n-            end if;\n-\n-            Set_Standard_Fpt_Formats;\n-         end Long_Float;\n-\n          -------------------\n          -- Loop_Optimize --\n          -------------------\n@@ -18807,37 +18243,24 @@ package body Sem_Prag is\n \n             Def_Id : Entity_Id;\n \n-            procedure Check_Too_Long (Arg : Node_Id);\n-            --  Posts message if the argument is an identifier with more\n-            --  than 31 characters, or a string literal with more than\n-            --  31 characters, and we are operating under VMS\n-\n-            --------------------\n-            -- Check_Too_Long --\n-            --------------------\n+            procedure Check_Arg (Arg : Node_Id);\n+            --  Checks that argument is either a string literal or an\n+            --  identifier, and posts error message if not.\n \n-            procedure Check_Too_Long (Arg : Node_Id) is\n-               X : constant Node_Id := Original_Node (Arg);\n+            ---------------\n+            -- Check_Arg --\n+            ---------------\n \n+            procedure Check_Arg (Arg : Node_Id) is\n             begin\n-               if not Nkind_In (X, N_String_Literal, N_Identifier) then\n+               if not Nkind_In (Original_Node (Arg),\n+                                N_String_Literal,\n+                                N_Identifier)\n+               then\n                   Error_Pragma_Arg\n                     (\"inappropriate argument for pragma %\", Arg);\n                end if;\n-\n-               if OpenVMS_On_Target then\n-                  if (Nkind (X) = N_String_Literal\n-                       and then String_Length (Strval (X)) > 31)\n-                    or else\n-                     (Nkind (X) = N_Identifier\n-                       and then Length_Of_Name (Chars (X)) > 31)\n-                  then\n-                     Error_Pragma_Arg\n-                       (\"argument for pragma % is longer than 31 characters\",\n-                        Arg);\n-                  end if;\n-               end if;\n-            end Check_Too_Long;\n+            end Check_Arg;\n \n          --  Start of processing for Common_Object/Psect_Object\n \n@@ -18853,7 +18276,7 @@ package body Sem_Prag is\n                  (\"pragma% must designate an object\", Internal);\n             end if;\n \n-            Check_Too_Long (Internal);\n+            Check_Arg (Internal);\n \n             if Is_Imported (Def_Id) or else Is_Exported (Def_Id) then\n                Error_Pragma_Arg\n@@ -18906,12 +18329,11 @@ package body Sem_Prag is\n             end if;\n \n             if Present (Size) then\n-               Check_Too_Long (Size);\n+               Check_Arg (Size);\n             end if;\n \n             if Present (External) then\n                Check_Arg_Is_External_Name (External);\n-               Check_Too_Long (External);\n             end if;\n \n             --  If all error tests pass, link pragma on to the rep item chain\n@@ -25350,8 +24772,7 @@ package body Sem_Prag is\n    --  99  special processing required (e.g. for pragma Check)\n \n    Sig_Flags : constant array (Pragma_Id) of Int :=\n-     (Pragma_AST_Entry                      => -1,\n-      Pragma_Abort_Defer                    => -1,\n+     (Pragma_Abort_Defer                    => -1,\n       Pragma_Abstract_State                 => -1,\n       Pragma_Ada_83                         => -1,\n       Pragma_Ada_95                         => -1,\n@@ -25416,7 +24837,6 @@ package body Sem_Prag is\n       Pragma_Eliminate                      => -1,\n       Pragma_Enable_Atomic_Synchronization  => -1,\n       Pragma_Export                         => -1,\n-      Pragma_Export_Exception               => -1,\n       Pragma_Export_Function                => -1,\n       Pragma_Export_Object                  => -1,\n       Pragma_Export_Procedure               => -1,\n@@ -25429,14 +24849,12 @@ package body Sem_Prag is\n       Pragma_External_Name_Casing           => -1,\n       Pragma_Fast_Math                      => -1,\n       Pragma_Finalize_Storage_Only          =>  0,\n-      Pragma_Float_Representation           =>  0,\n       Pragma_Global                         => -1,\n       Pragma_Ident                          => -1,\n       Pragma_Implementation_Defined         => -1,\n       Pragma_Implemented                    => -1,\n       Pragma_Implicit_Packing               =>  0,\n       Pragma_Import                         => +2,\n-      Pragma_Import_Exception               =>  0,\n       Pragma_Import_Function                =>  0,\n       Pragma_Import_Object                  =>  0,\n       Pragma_Import_Procedure               =>  0,\n@@ -25469,7 +24887,6 @@ package body Sem_Prag is\n       Pragma_List                           => -1,\n       Pragma_Lock_Free                      => -1,\n       Pragma_Locking_Policy                 => -1,\n-      Pragma_Long_Float                     => -1,\n       Pragma_Loop_Invariant                 => -1,\n       Pragma_Loop_Optimize                  => -1,\n       Pragma_Loop_Variant                   => -1,"}, {"sha": "aafa07200c00aab028a646782fd9e12c343fee4b", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -217,33 +217,30 @@ package body Snames is\n \n    function Get_Pragma_Id (N : Name_Id) return Pragma_Id is\n    begin\n-      if N = Name_AST_Entry then\n-         return Pragma_AST_Entry;\n-      elsif N = Name_CPU then\n-         return Pragma_CPU;\n-      elsif N = Name_Dispatching_Domain then\n-         return Pragma_Dispatching_Domain;\n-      elsif N = Name_Fast_Math then\n-         return Pragma_Fast_Math;\n-      elsif N = Name_Interface then\n-         return Pragma_Interface;\n-      elsif N = Name_Interrupt_Priority then\n-         return Pragma_Interrupt_Priority;\n-      elsif N = Name_Lock_Free then\n-         return Pragma_Lock_Free;\n-      elsif N = Name_Priority then\n-         return Pragma_Priority;\n-      elsif N = Name_Relative_Deadline then\n-         return Pragma_Relative_Deadline;\n-      elsif N = Name_Storage_Size then\n-         return Pragma_Storage_Size;\n-      elsif N = Name_Storage_Unit then\n-         return Pragma_Storage_Unit;\n-      elsif N not in First_Pragma_Name .. Last_Pragma_Name then\n-         return Unknown_Pragma;\n-      else\n-         return Pragma_Id'Val (N - First_Pragma_Name);\n-      end if;\n+      case N is\n+         when Name_CPU                              =>\n+            return Pragma_CPU;\n+         when Name_Dispatching_Domain               =>\n+            return Pragma_Dispatching_Domain;\n+         when Name_Fast_Math                        =>\n+            return Pragma_Fast_Math;\n+         when Name_Interface                        =>\n+            return Pragma_Interface;\n+         when Name_Interrupt_Priority               =>\n+            return Pragma_Interrupt_Priority;\n+         when Name_Lock_Free                        =>\n+            return Pragma_Lock_Free;\n+         when Name_Priority                         =>\n+            return Pragma_Priority;\n+         when Name_Storage_Size                     =>\n+            return Pragma_Storage_Size;\n+         when Name_Storage_Unit                     =>\n+            return Pragma_Storage_Unit;\n+         when First_Pragma_Name .. Last_Pragma_Name =>\n+            return Pragma_Id'Val (N - First_Pragma_Name);\n+         when others                                =>\n+            return Unknown_Pragma;\n+      end case;\n    end Get_Pragma_Id;\n \n    ---------------------------\n@@ -449,7 +446,6 @@ package body Snames is\n    function Is_Pragma_Name (N : Name_Id) return Boolean is\n    begin\n       return N in First_Pragma_Name .. Last_Pragma_Name\n-        or else N = Name_AST_Entry\n         or else N = Name_CPU\n         or else N = Name_Dispatching_Domain\n         or else N = Name_Fast_Math"}, {"sha": "1488ce56d13844cf0dcc85c0e72cd54a9ff16f89", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba0c6e4769cb6e81289ea4a0c536260e859fc795/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=ba0c6e4769cb6e81289ea4a0c536260e859fc795", "patch": "@@ -405,13 +405,11 @@ package Snames is\n    --  Fast_Math.\n \n    Name_Favor_Top_Level                : constant Name_Id := N + $; -- GNAT\n-   Name_Float_Representation           : constant Name_Id := N + $; -- GNAT\n    Name_Implicit_Packing               : constant Name_Id := N + $; -- GNAT\n    Name_Initialize_Scalars             : constant Name_Id := N + $; -- GNAT\n    Name_Interrupt_State                : constant Name_Id := N + $; -- GNAT\n    Name_License                        : constant Name_Id := N + $; -- GNAT\n    Name_Locking_Policy                 : constant Name_Id := N + $;\n-   Name_Long_Float                     : constant Name_Id := N + $; -- VMS\n    Name_Loop_Optimize                  : constant Name_Id := N + $; -- GNAT\n    Name_No_Run_Time                    : constant Name_Id := N + $; -- GNAT\n    Name_No_Strict_Aliasing             : constant Name_Id := N + $; -- GNAT\n@@ -457,12 +455,6 @@ package Snames is\n    Name_Abort_Defer                    : constant Name_Id := N + $; -- GNAT\n    Name_Abstract_State                 : constant Name_Id := N + $; -- GNAT\n    Name_All_Calls_Remote               : constant Name_Id := N + $;\n-\n-   --  Note: AST_Entry is not in this list because its name matches the name of\n-   --  the corresponding attribute. However, it is included in the definition\n-   --  of the type Pragma_Id, and the functions Get_Pragma_Id and Is_Pragma_Id\n-   --  correctly recognize and process Name_AST_Entry.\n-\n    Name_Assert                         : constant Name_Id := N + $; -- Ada 05\n    Name_Assert_And_Cut                 : constant Name_Id := N + $; -- GNAT\n    Name_Async_Readers                  : constant Name_Id := N + $; -- GNAT\n@@ -499,7 +491,6 @@ package Snames is\n    Name_Elaborate_All                  : constant Name_Id := N + $;\n    Name_Elaborate_Body                 : constant Name_Id := N + $;\n    Name_Export                         : constant Name_Id := N + $;\n-   Name_Export_Exception               : constant Name_Id := N + $; -- VMS\n    Name_Export_Function                : constant Name_Id := N + $; -- GNAT\n    Name_Export_Object                  : constant Name_Id := N + $; -- GNAT\n    Name_Export_Procedure               : constant Name_Id := N + $; -- GNAT\n@@ -512,7 +503,6 @@ package Snames is\n    Name_Implementation_Defined         : constant Name_Id := N + $; -- GNAT\n    Name_Implemented                    : constant Name_Id := N + $; -- Ada 12\n    Name_Import                         : constant Name_Id := N + $;\n-   Name_Import_Exception               : constant Name_Id := N + $; -- VMS\n    Name_Import_Function                : constant Name_Id := N + $; -- GNAT\n    Name_Import_Object                  : constant Name_Id := N + $; -- GNAT\n    Name_Import_Procedure               : constant Name_Id := N + $; -- GNAT\n@@ -838,7 +828,6 @@ package Snames is\n    Name_Alignment                      : constant Name_Id := N + $;\n    Name_Asm_Input                      : constant Name_Id := N + $; -- GNAT\n    Name_Asm_Output                     : constant Name_Id := N + $; -- GNAT\n-   Name_AST_Entry                      : constant Name_Id := N + $; -- VMS\n    Name_Atomic_Always_Lock_Free        : constant Name_Id := N + $; -- GNAT\n    Name_Bit                            : constant Name_Id := N + $; -- GNAT\n    Name_Bit_Order                      : constant Name_Id := N + $;\n@@ -1468,7 +1457,6 @@ package Snames is\n       Attribute_Alignment,\n       Attribute_Asm_Input,\n       Attribute_Asm_Output,\n-      Attribute_AST_Entry,\n       Attribute_Atomic_Always_Lock_Free,\n       Attribute_Bit,\n       Attribute_Bit_Order,\n@@ -1761,13 +1749,11 @@ package Snames is\n       Pragma_Extensions_Allowed,\n       Pragma_External_Name_Casing,\n       Pragma_Favor_Top_Level,\n-      Pragma_Float_Representation,\n       Pragma_Implicit_Packing,\n       Pragma_Initialize_Scalars,\n       Pragma_Interrupt_State,\n       Pragma_License,\n       Pragma_Locking_Policy,\n-      Pragma_Long_Float,\n       Pragma_Loop_Optimize,\n       Pragma_No_Run_Time,\n       Pragma_No_Strict_Aliasing,\n@@ -1841,7 +1827,6 @@ package Snames is\n       Pragma_Elaborate_All,\n       Pragma_Elaborate_Body,\n       Pragma_Export,\n-      Pragma_Export_Exception,\n       Pragma_Export_Function,\n       Pragma_Export_Object,\n       Pragma_Export_Procedure,\n@@ -1854,7 +1839,6 @@ package Snames is\n       Pragma_Implementation_Defined,\n       Pragma_Implemented,\n       Pragma_Import,\n-      Pragma_Import_Exception,\n       Pragma_Import_Function,\n       Pragma_Import_Object,\n       Pragma_Import_Procedure,\n@@ -1953,7 +1937,6 @@ package Snames is\n       --  special processing required to deal with the fact that their names\n       --  match existing attribute names.\n \n-      Pragma_AST_Entry,\n       Pragma_CPU,\n       Pragma_Dispatching_Domain,\n       Pragma_Fast_Math,\n@@ -2046,12 +2029,12 @@ package Snames is\n    --  Test to see if the name N is the name of an operator symbol\n \n    function Is_Pragma_Name (N : Name_Id) return Boolean;\n-   --  Test to see if the name N is the name of a recognized pragma. Note that\n-   --  pragmas AST_Entry, CPU, Dispatching_Domain, Fast_Math,\n-   --  Interrupt_Priority, Lock_Free, Priority, Storage_Size, and Storage_Unit\n-   --  are recognized as pragmas by this function even though their names are\n-   --  separate from the other pragma names. For this reason, clients should\n-   --  always use this function, rather than do range tests on Name_Id values.\n+   --  Test to see if the name N is the name of a recognized pragma. Note\n+   --  that pragmas CPU, Dispatching_Domain, Fast_Math, Interrupt_Priority,\n+   --  Lock_Free, Priority, Storage_Size, and Storage_Unit are recognized\n+   --  as pragmas by this function even though their names are separate from\n+   --  the other pragma names. For this reason, clients should always use\n+   --  this function, rather than do range tests on Name_Id values.\n \n    function Is_Configuration_Pragma_Name (N : Name_Id) return Boolean;\n    --  Test to see if the name N is the name of a recognized configuration\n@@ -2091,10 +2074,8 @@ package Snames is\n    --  Returns Id of pragma corresponding to given name. Returns Unknown_Pragma\n    --  if N is not a name of a known (Ada defined or GNAT-specific) pragma.\n    --  Note that the function also works correctly for names of pragmas that\n-   --  are not included in the main list of pragma Names (AST_Entry, CPU,\n-   --  Dispatching_Domain, Interrupt_Priority, Lock_Free, Priority,\n-   --  Storage_Size, and Storage_Unit (e.g. Name_Storage_Size returns\n-   --  Pragma_Storage_Size).\n+   --  are not included in the main list of pragma Names (e.g. Name_CPU returns\n+   --  Pragma_CPU).\n \n    function Get_Queuing_Policy_Id (N : Name_Id) return Queuing_Policy_Id;\n    --  Returns Id of queuing policy corresponding to given name. It is an error"}]}