{"sha": "31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFiZTYzYWI4YzRkZWY3NzVjOWVjZTBiNmZhOGQwZmVkYzExYmFlNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-01-21T21:23:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-01-21T21:23:04Z"}, "message": "re PR c/63307 (Cilk+ breaks -fcompare-debug bootstrap)\n\n\tPR c/63307\n\t* cilk.c (fill_decls_vec): Only put decls into vector v.                                                                                   \n\t(compare_decls): Fix up formatting.\n\n\t* c-c++-common/cilk-plus/CK/pr63307.c: New test.\n\n2015-01-21  Igor Zamyatin  <igor.zamyatin@intel.com>\n\n\tPR c/63307\n\t* cilk.c: Include vec.h.\n\t(struct cilk_decls): New structure.\n\t(wrapper_parm_cb): Split this function to...\n\t(fill_decls_vec): ...this...\n\t(create_parm_list): ...and this.\n\t(compare_decls): New function.\n\t(for_local_cb): Remove.\n\t(wrapper_local_cb): Ditto.\n\t(build_wrapper_type): For now first traverse and fill vector of\n\tdeclarations then sort it and then deal with sorted vector.\n\t(cilk_outline): Ditto.\n\t(declare_one_free_variable): Ditto.\n\nFrom-SVN: r219969", "tree": {"sha": "651a51d4177f4f06007a6abcc4aa6459dfa11eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/651a51d4177f4f06007a6abcc4aa6459dfa11eb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/comments", "author": null, "committer": null, "parents": [{"sha": "8b08ef255bd6e37c4f29e99d45a156bd5c007aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b08ef255bd6e37c4f29e99d45a156bd5c007aa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b08ef255bd6e37c4f29e99d45a156bd5c007aa6"}], "stats": {"total": 145, "additions": 104, "deletions": 41}, "files": [{"sha": "62b8c3403f941a4ca888cdb525a9d2f6915d4b5c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "patch": "@@ -1,3 +1,25 @@\n+2015-01-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/63307\n+\t* cilk.c (fill_decls_vec): Only put decls into vector v.                                                                                   \n+\t(compare_decls): Fix up formatting.\n+\n+2015-01-21  Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tPR c/63307\n+\t* cilk.c: Include vec.h.\n+\t(struct cilk_decls): New structure.\n+\t(wrapper_parm_cb): Split this function to...\n+\t(fill_decls_vec): ...this...\n+\t(create_parm_list): ...and this.\n+\t(compare_decls): New function.\n+\t(for_local_cb): Remove.\n+\t(wrapper_local_cb): Ditto.\n+\t(build_wrapper_type): For now first traverse and fill vector of\n+\tdeclarations then sort it and then deal with sorted vector.\n+\t(cilk_outline): Ditto.\n+\t(declare_one_free_variable): Ditto.\n+\n 2015-01-21  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/64629"}, {"sha": "fc694be459e1dd8c4c2d65e0512da0629d3c6989", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 73, "deletions": 41, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-ref.h\"\n #include \"cgraph.h\"\n #include \"diagnostic.h\"\n+#include \"vec.h\"\n #include \"cilk.h\"\n \n enum add_variable_type {\n@@ -355,17 +356,39 @@ create_cilk_helper_decl (struct wrapper_data *wd)\n   return fndecl;\n }\n \n-/* A function used by walk tree to find wrapper parms.  */\n+struct cilk_decls\n+{\n+  tree key;\n+  tree *val;\n+};\n+\n+/* A function used by traversal to fill vector of decls for further work.  */\n \n bool\n-wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n+fill_decls_vec (tree const &key0, tree *val0, auto_vec<struct cilk_decls> *v)\n+{\n+  tree t1 = key0;\n+  struct cilk_decls dp;\n+\n+  if (DECL_P (t1))\n+    {\n+      dp.key = t1;\n+      dp.val = val0;\n+      v->safe_push (dp);\n+    }\n+  return true;\n+}\n+\n+/* Function that actually creates necessary parm lists.  */\n+\n+static void\n+create_parm_list (struct wrapper_data *wd, tree *val0, tree arg)\n {\n-  tree arg = key0;\n   tree val = *val0;\n   tree parm;\n \n   if (val == error_mark_node || val == arg)\n-    return true;\n+    return;\n \n   if (TREE_CODE (val) == PAREN_EXPR)\n     {\n@@ -383,7 +406,7 @@ wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n \t}\n       else\n \targ = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg)), arg);\n-\t\n+\n       val = TREE_OPERAND (val, 0);\n       *val0 = val;\n       gcc_assert (TREE_CODE (val) == INDIRECT_REF);\n@@ -394,22 +417,44 @@ wrapper_parm_cb (tree const &key0, tree *val0, wrapper_data *wd)\n     parm = val;\n   TREE_CHAIN (parm) = wd->parms;\n   wd->parms = parm;\n-  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes); \n-  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist); \n-  return true;\n+  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes);\n+  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist);\n+}\n+\n+/* Sorting decls in a vector.  */\n+\n+static int\n+compare_decls (const void *a, const void *b)\n+{\n+  const struct cilk_decls *t1 = (const struct cilk_decls *) a;\n+  const struct cilk_decls *t2 = (const struct cilk_decls *) b;\n+\n+  if (DECL_UID (t1->key) > DECL_UID (t2->key))\n+    return 1;\n+  else if (DECL_UID (t1->key) < DECL_UID (t2->key))\n+    return -1;\n+  else\n+    return 0;\n }\n \n /* This function is used to build a wrapper of a certain type.  */\n \n static void\n build_wrapper_type (struct wrapper_data *wd)\n {\n+  unsigned int j;\n+  struct cilk_decls * c;\n+  auto_vec<struct cilk_decls> vd;\n   wd->arglist = NULL_TREE;\n   wd->parms = NULL_TREE;\n   wd->argtypes = void_list_node;\n \n-  wd->decl_map->traverse<wrapper_data *, wrapper_parm_cb> (wd);\n   gcc_assert (wd->type != CILK_BLOCK_FOR);\n+  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n+  vd.qsort (compare_decls);\n+\n+  FOR_EACH_VEC_ELT (vd, j, c)\n+   create_parm_list (wd, c->val, c->key);\n \n   /* Now build a function.\n      Its return type is void (all side effects are via explicit parameters).\n@@ -471,41 +516,19 @@ copy_decl_for_cilk (tree decl, copy_body_data *id)\n     }\n }\n \n-/* Copy all local variables.  */\n-\n-bool\n-for_local_cb (tree const &k, tree *vp, copy_body_data *id)\n-{\n-  tree v = *vp;\n-\n-  if (v == error_mark_node)\n-    *vp = copy_decl_no_change (k, id);\n-  return true;\n-}\n-\n-/* Copy all local declarations from a _Cilk_spawned function's body.  */\n-\n-bool\n-wrapper_local_cb (tree const &key, tree *vp, copy_body_data *id)\n-{\n-  tree val = *vp;\n-\n-  if (val == error_mark_node)\n-    *vp = copy_decl_for_cilk (key, id);\n-\n-  return true;\n-}\n-\n /* Alter a tree STMT from OUTER_FN to form the body of INNER_FN.  */\n \n void\n cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n {\n   struct wrapper_data *wd = (struct wrapper_data *) w;\n-  const tree outer_fn = wd->context;\t      \n+  const tree outer_fn = wd->context;\n   const bool nested = (wd->type == CILK_BLOCK_FOR);\n   copy_body_data id;\n   bool throws;\n+  auto_vec<struct cilk_decls> vd;\n+  unsigned int j;\n+  struct cilk_decls * c;\n \n   DECL_STATIC_CHAIN (outer_fn) = 1;\n \n@@ -531,11 +554,13 @@ cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n \n   insert_decl_map (&id, wd->block, DECL_INITIAL (inner_fn));\n \n+  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n+  vd.qsort (compare_decls);\n   /* We don't want the private variables any more.  */\n-  if (nested)\n-    wd->decl_map->traverse<copy_body_data *, for_local_cb> (&id);\n-  else\n-    wd->decl_map->traverse<copy_body_data *, wrapper_local_cb> (&id);\n+  FOR_EACH_VEC_ELT (vd, j, c)\n+   if (*(c->val) == error_mark_node)\n+     *(c->val) = nested ? copy_decl_no_change (c->key, &id)\n+\t\t\t: copy_decl_for_cilk (c->key, &id);\n \n   walk_tree (stmt_p, copy_tree_body_r, (void *) &id, NULL);\n \n@@ -640,7 +665,7 @@ free_wd (struct wrapper_data *wd)\n */\n \n bool\n-declare_one_free_variable (tree const &var0, tree *map0, wrapper_data &)\n+declare_one_free_variable (tree var0, tree *map0)\n {\n   const_tree var = var0;\n   tree map = *map0;\n@@ -713,6 +738,9 @@ create_cilk_wrapper (tree exp, tree *args_out)\n {\n   struct wrapper_data wd;\n   tree fndecl;\n+  unsigned int j;\n+  struct cilk_decls * c;\n+  auto_vec<struct cilk_decls> vd;\n \n   init_wd (&wd, CILK_BLOCK_SPAWN);\n \n@@ -733,7 +761,11 @@ create_cilk_wrapper (tree exp, tree *args_out)\n     }\n   else\n     extract_free_variables (exp, &wd, ADD_READ);\n-  wd.decl_map->traverse<wrapper_data &, declare_one_free_variable> (wd);\n+  wd.decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n+  vd.qsort (compare_decls);\n+  FOR_EACH_VEC_ELT (vd, j, c)\n+   declare_one_free_variable (c->key, c->val);\n+\n   wd.block = TREE_BLOCK (exp);\n   if (!wd.block)\n     wd.block = DECL_INITIAL (current_function_decl);"}, {"sha": "784ce467f862edafe3d55239ba61ecf625daff93", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "patch": "@@ -1,3 +1,8 @@\n+2015-01-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c/63307\n+\t* c-c++-common/cilk-plus/CK/pr63307.c: New test.\n+\n 2015-01-21  Thomas Koenig  <tkoenig@netcologne.de>\n \n \tPR fortran/57023"}, {"sha": "d476c45471235fddce26a800f537074155ccad08", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr63307.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr63307.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31be63ab8c4def775c9ece0b6fa8d0fedc11bae4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr63307.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr63307.c?ref=31be63ab8c4def775c9ece0b6fa8d0fedc11bae4", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-options \"-fcilkplus -fcompare-debug\" } */\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+\n+#include \"fib_no_return.c\""}]}