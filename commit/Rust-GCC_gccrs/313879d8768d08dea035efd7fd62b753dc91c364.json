{"sha": "313879d8768d08dea035efd7fd62b753dc91c364", "node_id": "C_kwDOANBUbNoAKDMxMzg3OWQ4NzY4ZDA4ZGVhMDM1ZWZkN2ZkNjJiNzUzZGM5MWMzNjQ", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-07T21:45:07Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-18T19:53:19Z"}, "message": "OpenMP: Push attaches to end of clause list in \"target\" regions\n\nThis patch moves GOMP_MAP_ATTACH{_ZERO_LENGTH_ARRAY_SECTION} nodes to\nthe end of the clause list, for offload regions.  This ensures that when\nwe do the attach operation, both the \"attachment point\" and the target\nregion have both already been mapped on the target.  This avoids a\npathological case that can otherwise happen with struct sibling-list\nhandling.\n\nThis version of the patch moves the attach-node motion to\ngimplify_adjust_omp_clauses.\n\n2022-09-15  Julian Brown  <julian@codesourcery.com>\n\ngcc/\n\t* gimplify.cc (omp_segregate_mapping_groups): Update comment.\n\t(gimplify_adjust_omp_clauses): Move ATTACH and\n\tATTACH_ZERO_LENGTH_ARRAY_SECTION nodes to the end of the clause list\n\tfor offloaded OpenMP regions.\n\ngcc/testsuite/\n\t* g++.dg/gomp/target-lambda-1.C: Adjust expected scan output.", "tree": {"sha": "f9df85fd73efabccf504cae13c05c944bb09f8c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9df85fd73efabccf504cae13c05c944bb09f8c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/313879d8768d08dea035efd7fd62b753dc91c364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313879d8768d08dea035efd7fd62b753dc91c364", "html_url": "https://github.com/Rust-GCC/gccrs/commit/313879d8768d08dea035efd7fd62b753dc91c364", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313879d8768d08dea035efd7fd62b753dc91c364/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d458f806afe07d1e06bdf275e94d05a716f41bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d458f806afe07d1e06bdf275e94d05a716f41bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d458f806afe07d1e06bdf275e94d05a716f41bf6"}], "stats": {"total": 39, "additions": 37, "deletions": 2}, "files": [{"sha": "4d032c6bf06372d07b27dfae740776417087ef79", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313879d8768d08dea035efd7fd62b753dc91c364/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313879d8768d08dea035efd7fd62b753dc91c364/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=313879d8768d08dea035efd7fd62b753dc91c364", "patch": "@@ -9639,7 +9639,9 @@ omp_tsort_mapping_groups (vec<omp_mapping_group> *groups,\n /* Split INLIST into two parts, moving groups corresponding to\n    ALLOC/RELEASE/DELETE mappings to one list, and other mappings to another.\n    The former list is then appended to the latter.  Each sub-list retains the\n-   order of the original list.  */\n+   order of the original list.\n+   Note that ATTACH nodes are later moved to the end of the list in\n+   gimplify_adjust_omp_clauses, for target regions.  */\n \n static omp_mapping_group *\n omp_segregate_mapping_groups (omp_mapping_group *inlist)\n@@ -12411,10 +12413,15 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t    *list_p = c2;\n \t  }\n     }\n+\n+  tree attach_list = NULL_TREE;\n+  tree *attach_tail = &attach_list;\n+\n   while ((c = *list_p) != NULL)\n     {\n       splay_tree_node n;\n       bool remove = false;\n+      bool move_attach = false;\n \n       switch (OMP_CLAUSE_CODE (c))\n \t{\n@@ -12576,6 +12583,19 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t      remove = true;\n \t      break;\n \t    }\n+\t  /* If we have a target region, we can push all the attaches to the\n+\t     end of the list (we may have standalone \"attach\" operations\n+\t     synthesized for GOMP_MAP_STRUCT nodes that must be processed after\n+\t     the attachment point AND the pointed-to block have been mapped).\n+\t     If we have something else, e.g. \"enter data\", we need to keep\n+\t     \"attach\" nodes together with the previous node they attach to so\n+\t     that separate \"exit data\" operations work properly (see\n+\t     libgomp/target.c).  */\n+\t  if ((ctx->region_type & ORT_TARGET) != 0\n+\t      && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH\n+\t\t  || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t      == GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION)))\n+\t    move_attach = true;\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  /* Data clauses associated with reductions must be\n \t     compatible with present_or_copy.  Warn and adjust the clause\n@@ -12890,10 +12910,25 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \n       if (remove)\n \t*list_p = OMP_CLAUSE_CHAIN (c);\n+      else if (move_attach)\n+\t{\n+\t  /* Remove attach node from here, separate out into its own list.  */\n+\t  *attach_tail = c;\n+\t  *list_p = OMP_CLAUSE_CHAIN (c);\n+\t  OMP_CLAUSE_CHAIN (c) = NULL_TREE;\n+\t  attach_tail = &OMP_CLAUSE_CHAIN (c);\n+\t}\n       else\n \tlist_p = &OMP_CLAUSE_CHAIN (c);\n     }\n \n+  /* Splice attach nodes at the end of the list.  */\n+  if (attach_list)\n+    {\n+      *list_p = attach_list;\n+      list_p = attach_tail;\n+    }\n+\n   /* Add in any implicit data sharing.  */\n   struct gimplify_adjust_omp_clauses_data data;\n   if ((gimplify_omp_ctxp->region_type & ORT_ACC) == 0)"}, {"sha": "5ce8ceadb194d14320ad0ea2201afe8459d04bcf", "filename": "gcc/testsuite/g++.dg/gomp/target-lambda-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313879d8768d08dea035efd7fd62b753dc91c364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313879d8768d08dea035efd7fd62b753dc91c364/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C?ref=313879d8768d08dea035efd7fd62b753dc91c364", "patch": "@@ -87,7 +87,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(b\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:iptr \\[pointer assign, bias: 0\\]\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:__closure->__iptr \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(b\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:iptr \\[pointer assign, bias: 0\\]\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:__closure->__iptr \\[bias: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\)} \"gimple\" } } */\n \n /* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:loop\\.__data1 \\[bias: 0\\]\\)} \"gimple\" } } */\n "}]}