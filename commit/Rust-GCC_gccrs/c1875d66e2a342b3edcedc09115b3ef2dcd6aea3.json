{"sha": "c1875d66e2a342b3edcedc09115b3ef2dcd6aea3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE4NzVkNjZlMmEzNDJiM2VkY2VkYzA5MTE1YjNlZjJkY2Q2YWVhMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-28T07:44:08Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-28T07:44:08Z"}, "message": "(find_reloads_address): Be selective about what inner\naddresses to allow in an indirect mem ref.\n\nFrom-SVN: r4783", "tree": {"sha": "fb3842df11f0e4fe554c80488cbfe76c53d6fd9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb3842df11f0e4fe554c80488cbfe76c53d6fd9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1875d66e2a342b3edcedc09115b3ef2dcd6aea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1875d66e2a342b3edcedc09115b3ef2dcd6aea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1875d66e2a342b3edcedc09115b3ef2dcd6aea3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1875d66e2a342b3edcedc09115b3ef2dcd6aea3/comments", "author": null, "committer": null, "parents": [{"sha": "8b3d02513eb1b096d82d116d8db80c7374c814b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3d02513eb1b096d82d116d8db80c7374c814b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b3d02513eb1b096d82d116d8db80c7374c814b7"}], "stats": {"total": 10, "additions": 8, "deletions": 2}, "files": [{"sha": "35fe843db2fea1c4001aad123e892206272c4897", "filename": "gcc/reload.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1875d66e2a342b3edcedc09115b3ef2dcd6aea3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1875d66e2a342b3edcedc09115b3ef2dcd6aea3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c1875d66e2a342b3edcedc09115b3ef2dcd6aea3", "patch": "@@ -3888,10 +3888,16 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t}\n \n       /* We can avoid a reload if the register's equivalent memory expression\n-\t is valid as an indirect memory address. */\n+\t is valid as an indirect memory address.\n+\t But not all addresses are valid in a mem used as an indirect address:\n+\t only reg or reg+constant.  */\n \n       else if (reg_equiv_mem[regno] != 0 && ind_levels > 0\n-\t       && strict_memory_address_p (mode, reg_equiv_mem[regno]))\n+\t       && strict_memory_address_p (mode, reg_equiv_mem[regno])\n+\t       && (GET_CODE (XEXP (reg_equiv_mem[regno], 0)) == REG\n+\t\t   || (GET_CODE (XEXP (reg_equiv_mem[regno], 0)) == PLUS\n+\t\t       && GET_CODE (XEXP (XEXP (reg_equiv_mem[regno], 0), 0)) == REG\n+\t\t       && CONSTANT_P (XEXP (XEXP (reg_equiv_mem[regno], 0), 0)))))\n \treturn 0;\n \n       /* The only remaining case where we can avoid a reload is if this is a"}]}