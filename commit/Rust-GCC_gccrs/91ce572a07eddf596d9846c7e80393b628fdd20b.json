{"sha": "91ce572a07eddf596d9846c7e80393b628fdd20b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFjZTU3MmEwN2VkZGY1OTZkOTg0NmM3ZTgwMzkzYjYyOGZkZDIwYg==", "commit": {"author": {"name": "Chandrakala Chavva", "email": "cchavva@redhat.com", "date": "2000-10-18T21:33:41Z"}, "committer": {"name": "Chandra Chavva", "email": "cchavva@gcc.gnu.org", "date": "2000-10-18T21:33:41Z"}, "message": "Adding new option -ftrapv.\n\nFrom-SVN: r36942", "tree": {"sha": "23acf9f52d85ebec426a6674cb36c94dab1cabb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23acf9f52d85ebec426a6674cb36c94dab1cabb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91ce572a07eddf596d9846c7e80393b628fdd20b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ce572a07eddf596d9846c7e80393b628fdd20b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ce572a07eddf596d9846c7e80393b628fdd20b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ce572a07eddf596d9846c7e80393b628fdd20b/comments", "author": null, "committer": null, "parents": [{"sha": "4c2c5712af14f6d1b8f1c6da6ba7813ac7705563", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2c5712af14f6d1b8f1c6da6ba7813ac7705563", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2c5712af14f6d1b8f1c6da6ba7813ac7705563"}], "stats": {"total": 551, "additions": 461, "deletions": 90}, "files": [{"sha": "61cd3aed827ddf9d6031fe8e1058161c87d2cf0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -1,3 +1,47 @@\n+2000-10-18  Chandrakala Chavva  <cchavva@redhat.com>\n+\n+        * expmed.c (expand_mult): Don't do synth_mult optimization for -ftrapv.\n+        Use smulv_optab for -ftrapv.\n+        (expand_mult_highpart): Use unsigned multiply.\n+        (expand_divmod): Special-case division by -1.\n+        For EXACT_DIV_EXPR, do right shift first, then the multiply.\n+        For complex divide, use abs with unsigned result.\n+        * expr.c (force_operand): Use unsigned multiply.\n+        (expand_expr): Use overflow-trapping optabs for signed types if\n+        flag_trapv.\n+        If flag_trapv, don't generate a recursive call with EXPAND_SUM\n+        if the type is signed and the original call wasn't EXPAND_SUM or\n+        EXPAND_INITIALIZER.\n+        * expr.h (addv_optab, subv_optab, smulv_optab, sdivv_optab): Declare.\n+        (negv_optab, absv_optab): Declare.\n+        * flags.h (flag_trapv): Declare.\n+        * genopinit.c (optabs): Add entries for addv_optab, subv_optab,\n+        smulv_optab, sdivv_optab, negv_optab and absv_optab.\n+\t(gen_insn): Interpret '$P' as requiring an integer mode,\n+        including partial integer modes.\n+        * loop.c (emit_iv_add_mult): Use unsigned expand_mult_add.\n+        (product_cheap_p): Use unsigned expand_mult.\n+        * optabs.c (addv_optab, subv_optab, smulv_optab, sdivv_optab): Define.\n+        (negv_optab, absv_optab): Define.\n+        (expand_binop): Use overflow-trapping optabs for signed types if\n+        flag_trapv.\n+        Handle negv_optab libe neg_optab.\n+        (expand_abs): Take result_unsignedp argument instead of unsignedp one.\n+        Use overflow-trapping optabs for signed result if flag_trapv.\n+        (expand_complex_abs): Use overflow-trapping optabs for signed types if\n+        flag_trapv.\n+        Don't open-code complex absolute-value operation for flag_trapv.\n+        (init_optabs): Initialize addv_optab, subv_optab, smulv_optab,\n+        sdivv_optab, negv_optab and absv_optab.\n+        * toplev.c (flag_trapv): Define.\n+        (lang_independent_options f_options): Include flag_trapv.\n+        * tree.h (TYPE_TRAP_SIGNED): Define.\n+        * libgcc2.c (__addvsi3, __addvdi3, __subvsi3,__subvsi3, __subvdi3,\n+        __mulvsi3, __negvsi2, __negvdi2, __absvsi2, __absvdi2, __mulvdi3):\n+        New functions.\n+        * Makefile.in: add _absvsi2 _absvdi2 _addvsi3 _addvdi3 _subvsi3\n+        _subvdi3 _mulvsi3 _mulvdi3 _negvsi2 _negvdi2.\n+\n 2000-10-18  Geoffrey Keating  <geoffk@cygnus.com>\n \t    David V. Henkel-Wallace  <gumby@cygnus.com>\n "}, {"sha": "595c62ef24747902c0b0c1ebed437b72cf7d9a21", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -754,6 +754,8 @@ LIB2FUNCS = _muldi3 _divdi3 _moddi3 _udivdi3 _umoddi3 _negdi2 \\\n     _fixtfdi _fixunstfdi _floatditf \\\n     __gcc_bcmp _varargs __dummy _eprintf \\\n     _bb _shtab _clear_cache _trampoline __main _exit \\\n+    _absvsi2 _absvdi2 _addvsi3 _addvdi3 _subvsi3 _subvdi3 \\\n+    _mulvsi3 _mulvdi3 _negvsi2 _negvdi2 \\\n     _ctors\n \n LIB2FUNCS_EH = _eh"}, {"sha": "bdd9fa703c4901aac1374530e4574cebb7467b6e", "filename": "gcc/expmed.c", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -2358,7 +2358,8 @@ expand_mult (mode, op0, op1, target, unsignedp)\n      But this causes such a terrible slowdown sometimes\n      that it seems better to use synth_mult always.  */\n \n-  if (const_op1 && GET_CODE (const_op1) == CONST_INT)\n+  if (const_op1 && GET_CODE (const_op1) == CONST_INT\n+      && (unsignedp || ! flag_trapv))\n     {\n       struct algorithm alg;\n       struct algorithm alg2;\n@@ -2531,7 +2532,10 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \n   /* This used to use umul_optab if unsigned, but for non-widening multiply\n      there is no difference between signed and unsigned.  */\n-  op0 = expand_binop (mode, smul_optab,\n+  op0 = expand_binop (mode, \n+\t\t      ! unsignedp\n+                       && flag_trapv && (GET_MODE_CLASS(mode) == MODE_INT)\n+                       ? smulv_optab : smul_optab,\n \t\t      op0, op1, target, unsignedp, OPTAB_LIB_WIDEN);\n   if (op0 == 0)\n     abort ();\n@@ -2775,7 +2779,9 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n \t multiply.  Maybe change expand_binop to handle widening multiply?  */\n       op0 = convert_to_mode (wider_mode, op0, unsignedp);\n \n-      tem = expand_mult (wider_mode, op0, wide_op1, NULL_RTX, unsignedp);\n+      /* We know that this can't have signed overflow, so pretend this is\n+         an unsigned multiply.  */\n+      tem = expand_mult (wider_mode, op0, wide_op1, NULL_RTX, 0);\n       tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n \t\t\t  build_int_2 (size, 0), NULL_RTX, 1);\n       return convert_modes (mode, wider_mode, tem, unsignedp);\n@@ -2968,6 +2974,16 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   if (op1 == const1_rtx)\n     return rem_flag ? const0_rtx : op0;\n \n+    /* When dividing by -1, we could get an overflow.\n+     negv_optab can handle overflows.  */\n+  if (! unsignedp && op1 == constm1_rtx)\n+    {\n+      if (rem_flag)\n+        return const0_rtx;\n+      return expand_unop (mode, flag_trapv && GET_MODE_CLASS(mode) == MODE_INT\n+                        ? negv_optab : neg_optab, op0, target, 0);\n+    }\n+\n   if (target\n       /* Don't use the function value register as a target\n \t since we have to read it as well as write it,\n@@ -3764,16 +3780,15 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  {\n \t    HOST_WIDE_INT d = INTVAL (op1);\n \t    unsigned HOST_WIDE_INT ml;\n-\t    int post_shift;\n+\t    int pre_shift;\n \t    rtx t1;\n \n-\t    post_shift = floor_log2 (d & -d);\n-\t    ml = invert_mod2n (d >> post_shift, size);\n-\t    t1 = expand_mult (compute_mode, op0, GEN_INT (ml), NULL_RTX,\n-\t\t\t      unsignedp);\n-\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n-\t\t\t\t     build_int_2 (post_shift, 0),\n-\t\t\t\t     NULL_RTX, unsignedp);\n+\t    pre_shift = floor_log2 (d & -d);\n+\t    ml = invert_mod2n (d >> pre_shift, size);\n+\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t       build_int_2 (pre_shift, 0), NULL_RTX, unsignedp);\n+\t    quotient = expand_mult (compute_mode, t1, GEN_INT (ml), NULL_RTX,\n+\t\t\t      \t    0);\n \n \t    insn = get_last_insn ();\n \t    set_unique_reg_note (insn,\n@@ -3826,8 +3841,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\tremainder = expand_binop (compute_mode, sub_optab, op0, tem,\n \t\t\t\t\t  remainder, 0, OPTAB_LIB_WIDEN);\n \t      }\n-\t    abs_rem = expand_abs (compute_mode, remainder, NULL_RTX, 0);\n-\t    abs_op1 = expand_abs (compute_mode, op1, NULL_RTX, 0);\n+\t    abs_rem = expand_abs (compute_mode, remainder, NULL_RTX, 1, 0);\n+\t    abs_op1 = expand_abs (compute_mode, op1, NULL_RTX, 1, 0);\n \t    tem = expand_shift (LSHIFT_EXPR, compute_mode, abs_rem,\n \t\t\t\tbuild_int_2 (1, 0), NULL_RTX, 1);\n \t    do_cmp_and_jump (tem, abs_op1, LTU, compute_mode, label);\n@@ -4477,6 +4492,11 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n \t we can use zero-extension to the wider mode (an unsigned conversion)\n \t as the operation.  */\n \n+      /* CYGNUS LOCAL - amylaar/-ftrapv:  Note that ABS doesn't yield a\n+         positive number for INT_MIN, but that is compensated by the\n+         subsequent overflow when subtracting one / negating.\n+         END CYGNUS LOCAL */\n+\n       if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \ttem = expand_unop (mode, abs_optab, op0, subtarget, 1);\n       else if (ffs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)"}, {"sha": "84e574d915b6a2df0c7f96f118d50d322033e36d", "filename": "gcc/expr.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -5307,7 +5307,7 @@ force_operand (value, target)\n       tmp = force_operand (XEXP (value, 0), subtarget);\n       return expand_mult (GET_MODE (value), tmp,\n \t\t\t  force_operand (op2, NULL_RTX),\n-\t\t\t  target, 0);\n+\t\t\t  target, 1);\n     }\n \n   if (binoptab)\n@@ -7248,7 +7248,9 @@ expand_expr (exp, target, tmode, modifier)\n       /* We come here from MINUS_EXPR when the second operand is a\n          constant.  */\n     plus_expr:\n-      this_optab = add_optab;\n+      this_optab = ! unsignedp && flag_trapv\n+                   && (GET_MODE_CLASS(mode) == MODE_INT)\n+                   ? addv_optab : add_optab;\n \n       /* If we are adding a constant, an RTL_EXPR that is sp, fp, or ap, and\n \t something else, make sure we add the register to the constant and\n@@ -7283,7 +7285,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t If this is an EXPAND_SUM call, always return the sum.  */\n       if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n-\t  || mode == ptr_mode)\n+          || (mode == ptr_mode && (unsignedp || ! flag_trapv)))\n \t{\n \t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n@@ -7441,7 +7443,9 @@ expand_expr (exp, target, tmode, modifier)\n \t      goto plus_expr;\n \t    }\n \t}\n-      this_optab = sub_optab;\n+      this_optab = ! unsignedp && flag_trapv\n+                   && (GET_MODE_CLASS(mode) == MODE_INT)\n+                   ? subv_optab : sub_optab;\n       goto binop;\n \n     case MULT_EXPR:\n@@ -7624,7 +7628,10 @@ expand_expr (exp, target, tmode, modifier)\n \n     case NEGATE_EXPR:\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-      temp = expand_unop (mode, neg_optab, op0, target, 0);\n+      temp = expand_unop (mode,\n+                          ! unsignedp && flag_trapv\n+                          && (GET_MODE_CLASS(mode) == MODE_INT)\n+                          ? negv_optab : neg_optab, op0, target, 0);\n       if (temp == 0)\n \tabort ();\n       return temp;\n@@ -7642,7 +7649,7 @@ expand_expr (exp, target, tmode, modifier)\n       if (TREE_UNSIGNED (type))\n \treturn op0;\n \n-      return expand_abs (mode, op0, target,\n+      return expand_abs (mode, op0, target, unsignedp,\n \t\t\t safe_from_p (target, TREE_OPERAND (exp, 0), 1));\n \n     case MAX_EXPR:\n@@ -7964,10 +7971,14 @@ expand_expr (exp, target, tmode, modifier)\n \t    && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<')\n \t  {\n \t    rtx result;\n-\t    optab boptab = (TREE_CODE (binary_op) == PLUS_EXPR ? add_optab\n-\t\t\t    : TREE_CODE (binary_op) == MINUS_EXPR ? sub_optab\n-\t\t\t    : TREE_CODE (binary_op) == BIT_IOR_EXPR ? ior_optab\n-\t\t\t    : xor_optab);\n+\t    optab boptab = (TREE_CODE (binary_op) == PLUS_EXPR\n+                            ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n+                               ? addv_optab : add_optab)\n+                            : TREE_CODE (binary_op) == MINUS_EXPR\n+                              ? (TYPE_TRAP_SIGNED (TREE_TYPE (binary_op))\n+                                 ? subv_optab : sub_optab)\n+                            : TREE_CODE (binary_op) == BIT_IOR_EXPR ? ior_optab\n+                            : xor_optab);\n \n \t    /* If we had X ? A : A + 1, do this as A + (X == 0).\n \n@@ -8491,7 +8502,10 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\tgen_realpart (partmode, op0));\n \n \timag_t = gen_imagpart (partmode, target);\n-\ttemp = expand_unop (partmode, neg_optab,\n+\ttemp = expand_unop (partmode,\n+                            ! unsignedp && flag_trapv\n+                            && (GET_MODE_CLASS(partmode) == MODE_INT)\n+                            ? negv_optab : neg_optab,\n \t\t\t    gen_imagpart (partmode, op0), imag_t, 0);\n \tif (temp != imag_t)\n \t  emit_move_insn (imag_t, temp);\n@@ -9045,6 +9059,9 @@ expand_increment (exp, post, ignore)\n       this_optab = add_optab;\n     }\n \n+  if (TYPE_TRAP_SIGNED (TREE_TYPE (exp)))\n+     this_optab = this_optab == add_optab ? addv_optab : subv_optab;\n+\n   /* For a preincrement, see if we can do this with a single instruction.  */\n   if (!post)\n     {"}, {"sha": "8cb283610381283b41eede2d8f20e316db633e31", "filename": "gcc/expr.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -298,10 +298,13 @@ typedef struct optab\n enum optab_index\n {\n   OTI_add,\n+  OTI_addv,\n   OTI_sub,\n+  OTI_subv,\n \n   /* Signed and fp multiply */\n   OTI_smul,\n+  OTI_smulv,\n   /* Signed multiply, return high word */\n   OTI_smul_highpart,\n   OTI_umul_highpart,\n@@ -311,6 +314,7 @@ enum optab_index\n \n   /* Signed divide */\n   OTI_sdiv,\n+  OTI_sdivv,\n   /* Signed divide-and-remainder in one */\n   OTI_sdivmod,\n   OTI_udiv,\n@@ -357,8 +361,10 @@ enum optab_index\n   /* Unary operations */\n   /* Negation */\n   OTI_neg,\n+  OTI_negv,\n   /* Abs value */\n   OTI_abs,\n+  OTI_absv,\n   /* Bitwise not */\n   OTI_one_cmpl,\n   /* Find first bit set */\n@@ -393,11 +399,15 @@ extern optab optab_table[OTI_MAX];\n #define add_optab (optab_table[OTI_add])\n #define sub_optab (optab_table[OTI_sub])\n #define smul_optab (optab_table[OTI_smul])\n+#define addv_optab (optab_table[OTI_addv])\n+#define subv_optab (optab_table[OTI_subv])\n #define smul_highpart_optab (optab_table[OTI_smul_highpart])\n #define umul_highpart_optab (optab_table[OTI_umul_highpart])\n #define smul_widen_optab (optab_table[OTI_smul_widen])\n #define umul_widen_optab (optab_table[OTI_umul_widen])\n #define sdiv_optab (optab_table[OTI_sdiv])\n+#define smulv_optab (optab_table[OTI_smulv])\n+#define sdivv_optab (optab_table[OTI_sdivv])\n #define sdivmod_optab (optab_table[OTI_sdivmod])\n #define udiv_optab (optab_table[OTI_udiv])\n #define udivmod_optab (optab_table[OTI_udivmod])\n@@ -422,7 +432,9 @@ extern optab optab_table[OTI_MAX];\n #define movstrict_optab (optab_table[OTI_movstrict])\n \n #define neg_optab (optab_table[OTI_neg])\n+#define negv_optab (optab_table[OTI_negv])\n #define abs_optab (optab_table[OTI_abs])\n+#define absv_optab (optab_table[OTI_absv])\n #define one_cmpl_optab (optab_table[OTI_one_cmpl])\n #define ffs_optab (optab_table[OTI_ffs])\n #define sqrt_optab (optab_table[OTI_sqrt])\n@@ -769,7 +781,7 @@ extern int expand_twoval_binop PARAMS ((optab, rtx, rtx, rtx, rtx, int));\n extern rtx expand_unop PARAMS ((enum machine_mode, optab, rtx, rtx, int));\n \n /* Expand the absolute value operation.  */\n-extern rtx expand_abs PARAMS ((enum machine_mode, rtx, rtx, int));\n+extern rtx expand_abs PARAMS ((enum machine_mode, rtx, rtx, int, int));\n \n /* Expand the complex absolute value operation.  */\n extern rtx expand_complex_abs PARAMS ((enum machine_mode, rtx, rtx, int));"}, {"sha": "dec686dfe38f8da36a474e3720d86ee60fee8df2", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -555,6 +555,10 @@ extern int frame_pointer_needed;\n \n extern int flag_check_memory_usage;\n \n+/* Nonzero if the generated code should trap on signed overflow\n+   for PLUS / SUB / MULT.  */\n+extern int flag_trapv;\n+\n /* Nonzero if GCC must prefix function names (used with\n    flag_check_memory_usage).  */\n "}, {"sha": "9aeaee7baac916727bacde97b609e8f64d714088", "filename": "gcc/genopinit.c", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -46,8 +46,11 @@ Boston, MA 02111-1307, USA.  */\n \n    If $N is present in the pattern, it means the two modes must be consecutive\n    widths in the same mode class (e.g, QImode and HImode).  $I means that\n-   only integer modes should be considered for the next mode, and $F means\n-   that only float modes should be considered.\n+   only full integer modes should be considered for the next mode, and $F\n+   means that only float modes should be considered.\n+   $P means that both full and partial integer modes should be considered.\n+\n+   $V means to emit 'v' if the first mode is a MODE_FLOAT mode.\n \n    For some optabs, we store the operation by RTL codes.  These are only\n    used for comparisons.  In that case, $c and $C are the lower-case and\n@@ -62,14 +65,24 @@ const char * const optabs[] =\n   \"fixtrunctab[$A][$B][1] = CODE_FOR_$(fixuns_trunc$F$a$I$b2$)\",\n   \"floattab[$B][$A][0] = CODE_FOR_$(float$I$a$F$b2$)\",\n   \"floattab[$B][$A][1] = CODE_FOR_$(floatuns$I$a$F$b2$)\",\n-  \"add_optab->handlers[$A].insn_code = CODE_FOR_$(add$a3$)\",\n-  \"sub_optab->handlers[$A].insn_code = CODE_FOR_$(sub$a3$)\",\n-  \"smul_optab->handlers[$A].insn_code = CODE_FOR_$(mul$a3$)\",\n+  \"add_optab->handlers[$A].insn_code = CODE_FOR_$(add$P$a3$)\",\n+  \"addv_optab->handlers[(int) $A].insn_code =\\n\\\n+    add_optab->handlers[(int) $A].insn_code = CODE_FOR_$(add$F$a3$)\",\n+  \"addv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(addv$I$a3$)\",\n+  \"sub_optab->handlers[$A].insn_code = CODE_FOR_$(sub$P$a3$)\",\n+  \"subv_optab->handlers[(int) $A].insn_code =\\n\\\n+    sub_optab->handlers[(int) $A].insn_code = CODE_FOR_$(sub$F$a3$)\",\n+  \"subv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(subv$I$a3$)\",\n+  \"smul_optab->handlers[$A].insn_code = CODE_FOR_$(mul$P$a3$)\",\n+  \"smulv_optab->handlers[(int) $A].insn_code =\\n\\\n+    smul_optab->handlers[(int) $A].insn_code = CODE_FOR_$(mul$F$a3$)\",\n+  \"smulv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(mulv$I$a3$)\",\n   \"umul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(umul$a3_highpart$)\",\n   \"smul_highpart_optab->handlers[$A].insn_code = CODE_FOR_$(smul$a3_highpart$)\",\n   \"smul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(mul$a$b3$)$N\",\n   \"umul_widen_optab->handlers[$B].insn_code = CODE_FOR_$(umul$a$b3$)$N\",\n   \"sdiv_optab->handlers[$A].insn_code = CODE_FOR_$(div$I$a3$)\",\n+  \"sdivv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(div$V$I$a3$)\",\n   \"udiv_optab->handlers[$A].insn_code = CODE_FOR_$(udiv$I$a3$)\",\n   \"sdivmod_optab->handlers[$A].insn_code = CODE_FOR_$(divmod$a4$)\",\n   \"udivmod_optab->handlers[$A].insn_code = CODE_FOR_$(udivmod$a4$)\",\n@@ -91,8 +104,14 @@ const char * const optabs[] =\n   \"smax_optab->handlers[$A].insn_code = CODE_FOR_$(max$F$a3$)\",\n   \"umin_optab->handlers[$A].insn_code = CODE_FOR_$(umin$I$a3$)\",\n   \"umax_optab->handlers[$A].insn_code = CODE_FOR_$(umax$I$a3$)\",\n-  \"neg_optab->handlers[$A].insn_code = CODE_FOR_$(neg$a2$)\",\n-  \"abs_optab->handlers[$A].insn_code = CODE_FOR_$(abs$a2$)\",\n+  \"neg_optab->handlers[$A].insn_code = CODE_FOR_$(neg$P$a2$)\",\n+  \"negv_optab->handlers[(int) $A].insn_code =\\n\\\n+    neg_optab->handlers[(int) $A].insn_code = CODE_FOR_$(neg$F$a2$)\",\n+  \"negv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(negv$I$a2$)\",\n+  \"abs_optab->handlers[$A].insn_code = CODE_FOR_$(abs$P$a2$)\",\n+  \"absv_optab->handlers[(int) $A].insn_code =\\n\\\n+    abs_optab->handlers[(int) $A].insn_code = CODE_FOR_$(abs$F$a2$)\",\n+  \"absv_optab->handlers[(int) $A].insn_code = CODE_FOR_$(absv$I$a2$)\",\n   \"sqrt_optab->handlers[$A].insn_code = CODE_FOR_$(sqrt$a2$)\",\n   \"sin_optab->handlers[$A].insn_code = CODE_FOR_$(sin$a2$)\",\n   \"cos_optab->handlers[$A].insn_code = CODE_FOR_$(cos$a2$)\",\n@@ -136,7 +155,7 @@ gen_insn (insn)\n \n   for (pindex = 0; pindex < ARRAY_SIZE (optabs); pindex++)\n     {\n-      int force_float = 0, force_int = 0;\n+      int force_float = 0, force_int = 0, force_partial_int = 0;\n       int force_consec = 0;\n       int matches = 1;\n \n@@ -160,9 +179,14 @@ gen_insn (insn)\n \t      case 'I':\n \t\tforce_int = 1;\n \t\tbreak;\n+\t      case 'P':\n+                force_partial_int = 1;\n+                break;\n \t      case 'F':\n \t\tforce_float = 1;\n \t\tbreak;\n+\t      case 'V':\n+                break;\n \t      case 'c':\n \t\tfor (op = 0; op < NUM_RTX_CODE; op++)\n \t\t  {\n@@ -196,6 +220,9 @@ gen_insn (insn)\n \n \t\t    if (*p == 0\n \t\t\t&& (! force_int || mode_class[i] == MODE_INT)\n+\t\t        && (! force_partial_int\n+                            || mode_class[i] == MODE_INT\n+                            || mode_class[i] == MODE_PARTIAL_INT)\n \t\t\t&& (! force_float || mode_class[i] == MODE_FLOAT))\n \t\t      break;\n \t\t  }\n@@ -207,7 +234,7 @@ gen_insn (insn)\n \t\telse\n \t\t  m2 = i, np += strlen (GET_MODE_NAME(i));\n \n-\t\tforce_int = force_float = 0;\n+\t\tforce_int = force_partial_int = force_float = 0;\n \t\tbreak;\n \n \t      default:\n@@ -243,6 +270,10 @@ gen_insn (insn)\n \t  case '(':  case ')':\n \t  case 'I':  case 'F':  case 'N':\n \t    break;\n+\t  case 'V':\n+            if (GET_MODE_CLASS (m1) == MODE_FLOAT)\n+              printf (\"v\");\n+            break;\n \t  case 'a':\n \t    for (np = GET_MODE_NAME(m1); *np; np++)\n \t      putchar (TOLOWER (*np));"}, {"sha": "73dd1d9c85b0146692ecffcb5733df1bae655e03", "filename": "gcc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -173,7 +173,7 @@ in the following sections.\n -fdata-sections  -ffunction-sections  -fgcse \n -finline-functions  -finline-limit=@var{n}  -fkeep-inline-functions\n -fmove-all-movables  -fno-default-inline  -fno-defer-pop\n--fno-function-cse  -fno-inline  -fno-peephole\n+-fno-function-cse  -fno-inline  -fno-peephole -ftrapv\n -fomit-frame-pointer  -foptimize-register-moves -foptimize-sibling-calls\n -fregmove -frerun-cse-after-loop  -frerun-loop-opt  -freduce-all-givs\n -fschedule-insns  -fschedule-insns2  -fssa -fstrength-reduce\n@@ -2664,6 +2664,10 @@ Usage, gcc.info, Using and Porting GCC}.@refill\n @item -foptimize-sibling-calls\n Optimize sibling and tail recursive calls.\n \n+@item -ftrapv\n+This option generates traps for signed overflow on addition, subtraction,\n+multiplication operations.\n+\n @item -fno-inline\n Don't pay attention to the @code{inline} keyword.  Normally this option\n is used to keep the compiler from expanding any functions inline."}, {"sha": "00a50e6b43efeba9bd3f760816aa5ba997d54582", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -50,6 +50,176 @@ Boston, MA 02111-1307, USA.  */\n #if defined (L_divdi3) || defined (L_moddi3)\n static inline\n #endif\n+\n+#ifdef L_addvsi3\n+SItype\n+__addvsi3 (SItype a, SItype b)\n+{\n+  SItype w, w1;\n+\n+  w = a + b;\n+\n+  if (b >= 0 ? w < a : w > a)\n+    abort ();\n+\n+  return w;\n+} \n+\f\n+#ifdef L_addvdi3\n+DItype\n+__addvdi3 (DItype a, DItype b)\n+{\n+  DItype w;\n+\n+  w = a + b;\n+\n+  if (b >= 0 ? w < a : w > a)\n+    abort ();\n+\n+  return w;\n+}\n+#endif\n+\f\n+#ifdef L_subvsi3\n+SItype\n+__subvsi3 (SItype a, SItype b)\n+{\n+#ifdef L_addvsi3\n+  return __addvsi3 (a, (-b));\n+#else\n+  DItype w;\n+\n+  w = a - b;\n+\n+  if (b >= 0 ? w > a : w < a)\n+    abort ();\n+\n+  return w;\n+#endif\n+}\n+#endif\n+\f\n+#ifdef L_subvdi3\n+DItype\n+__subvdi3 (DItype a, DItype b)\n+{\n+#ifdef L_addvdi3\n+  return (a, (-b));\n+#else\n+  DItype w;\n+\n+  w = a - b;\n+\n+  if (b >= 0 ? w > a : w < a)\n+    abort ();\n+\n+  return w;\n+#endif\n+}\n+#endif\n+\f\n+#ifdef L_mulvsi3\n+SItype\n+__mulvsi3 (SItype a, SItype b)\n+{\n+  DItype w;\n+\n+  w = a * b;\n+\n+  if ((a >= 0 && b >= 0) ? w < 0\n+                         : (a >= 0 || b >= 0) ? w > 0 : w < 0)\n+    abort ();\n+\n+  return w;\n+}\n+#endif\n+\f\n+#ifdef L_negvsi2\n+SItype\n+__negvsi2 (SItype a)\n+{\n+   SItype w;\n+\n+   w  = -a;\n+\n+  if (a >= 0 ? w > 0 : w < 0)\n+    abort ();\n+\n+   return w;\n+}\n+#endif\n+\f\n+#ifdef L_negvdi2\n+DItype\n+__negvdi2 (DItype a)\n+{\n+   DItype w;\n+\n+   w  = -a;\n+\n+  if (a >= 0 ? w > 0 : w < 0)\n+    abort ();\n+\n+   return w;\n+}\n+#endif\n+\f\n+#ifdef L_absvsi2\n+SItype\n+__absvsi2 (SItype a)\n+{\n+   SItype w = a;\n+\n+   if (a < 0)\n+#ifdef L_negvsi2\n+     w = __negvsi2 (a);\n+#else\n+     w = -a;\n+\n+   if (w < 0)\n+     abort ();\n+#endif\n+\n+   return w;\n+}\n+#endif\n+\f\n+#ifdef L_absvdi2\n+DItype\n+__absvdi2 (DItype a)\n+{\n+   DItype w = a;\n+\n+   if (a < 0)\n+#ifdef L_negvsi2\n+     w = __negvsi2 (a);\n+#else\n+     w = -a;\n+\n+   if (w < 0)\n+     abort ();\n+#endif\n+\n+   return w;\n+}\n+#endif\n+\f\n+#ifdef L_mulvdi3\n+DItype\n+__mulvdi3 (DItype u, DItype v)\n+{\n+   DItype w;\n+\n+  w = u * v;\n+\n+  if ((u >= 0 && v >= 0) ? w < 0\n+                         : (u >= 0 || v >= 0) ? w > 0 : w < 0)\n+    abort ();\n+\n+  return w;\n+}\n+#endif\n+\f\n DWtype\n __negdi2 (DWtype u)\n {"}, {"sha": "23ee292f0917c3d01f666559eaefc9e75855356d", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -6877,7 +6877,7 @@ emit_iv_add_mult (b, m, a, reg, insert_before)\n   update_reg_last_use (m, insert_before);\n \n   start_sequence ();\n-  result = expand_mult_add (b, reg, m, a, GET_MODE (reg), 0);\n+  result = expand_mult_add (b, reg, m, a, GET_MODE (reg), 1);\n   if (reg != result)\n     emit_move_insn (reg, result);\n   seq = gen_sequence ();\n@@ -6961,7 +6961,7 @@ product_cheap_p (a, b)\n      of insns is generated.  */\n \n   start_sequence ();\n-  expand_mult (GET_MODE (a), a, b, NULL_RTX, 0);\n+  expand_mult (GET_MODE (a), a, b, NULL_RTX, 1);\n   tmp = gen_sequence ();\n   end_sequence ();\n "}, {"sha": "16433a9a3dc08fa9f73323ea26599cdf4c2ff992", "filename": "gcc/optabs.c", "status": "modified", "additions": 114, "deletions": 53, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -218,7 +218,19 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n   rtx real_t, imag_t;\n   rtx temp1, temp2;\n   rtx res;\n+  optab this_add_optab = add_optab;\n+  optab this_sub_optab = sub_optab;\n+  optab this_neg_optab = neg_optab;\n+  optab this_mul_optab = smul_optab;\n \t      \n+  if (binoptab == sdivv_optab)\n+    {\n+      this_add_optab = addv_optab;\n+      this_sub_optab = subv_optab;\n+      this_neg_optab = negv_optab;\n+      this_mul_optab = smulv_optab;\n+    }\n+\n   /* Don't fetch these from memory more than once.  */\n   real0 = force_reg (submode, real0);\n   real1 = force_reg (submode, real1);\n@@ -229,16 +241,16 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n   imag1 = force_reg (submode, imag1);\n \n   /* Divisor: c*c + d*d.  */\n-  temp1 = expand_binop (submode, smul_optab, real1, real1,\n+  temp1 = expand_binop (submode, this_mul_optab, real1, real1,\n \t\t\tNULL_RTX, unsignedp, methods);\n \n-  temp2 = expand_binop (submode, smul_optab, imag1, imag1,\n+  temp2 = expand_binop (submode, this_mul_optab, imag1, imag1,\n \t\t\tNULL_RTX, unsignedp, methods);\n \n   if (temp1 == 0 || temp2 == 0)\n     return 0;\n \n-  divisor = expand_binop (submode, add_optab, temp1, temp2,\n+  divisor = expand_binop (submode, this_add_optab, temp1, temp2,\n \t\t\t  NULL_RTX, unsignedp, methods);\n   if (divisor == 0)\n     return 0;\n@@ -249,44 +261,44 @@ expand_cmplxdiv_straight (real0, real1, imag0, imag1, realr, imagr, submode,\n       /* Computationally, (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)).  */\n \n       /* Calculate the dividend.  */\n-      real_t = expand_binop (submode, smul_optab, real0, real1,\n+      real_t = expand_binop (submode, this_mul_optab, real0, real1,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \t\t  \n-      imag_t = expand_binop (submode, smul_optab, real0, imag1,\n+      imag_t = expand_binop (submode, this_mul_optab, real0, imag1,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n       if (real_t == 0 || imag_t == 0)\n \treturn 0;\n \n-      imag_t = expand_unop (submode, neg_optab, imag_t,\n+      imag_t = expand_unop (submode, this_neg_optab, imag_t,\n \t\t\t    NULL_RTX, unsignedp);\n     }\n   else\n     {\n       /* Mathematically, ((a+ib)(c-id))/divider.  */\n       /* Calculate the dividend.  */\n-      temp1 = expand_binop (submode, smul_optab, real0, real1,\n+      temp1 = expand_binop (submode, this_mul_optab, real0, real1,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n-      temp2 = expand_binop (submode, smul_optab, imag0, imag1,\n+      temp2 = expand_binop (submode, this_mul_optab, imag0, imag1,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n       if (temp1 == 0 || temp2 == 0)\n \treturn 0;\n \n-      real_t = expand_binop (submode, add_optab, temp1, temp2,\n+      real_t = expand_binop (submode, this_add_optab, temp1, temp2,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \t\t  \n-      temp1 = expand_binop (submode, smul_optab, imag0, real1,\n+      temp1 = expand_binop (submode, this_mul_optab, imag0, real1,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n-      temp2 = expand_binop (submode, smul_optab, real0, imag1,\n+      temp2 = expand_binop (submode, this_mul_optab, real0, imag1,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n       if (temp1 == 0 || temp2 == 0)\n \treturn 0;\n \n-      imag_t = expand_binop (submode, sub_optab, temp1, temp2,\n+      imag_t = expand_binop (submode, this_sub_optab, temp1, temp2,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n       if (real_t == 0 || imag_t == 0)\n@@ -340,6 +352,18 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n   enum machine_mode mode;\n   int align;\n   rtx res;\n+  optab this_add_optab = add_optab;\n+  optab this_sub_optab = sub_optab;\n+  optab this_neg_optab = neg_optab;\n+  optab this_mul_optab = smul_optab;\n+\n+  if (binoptab == sdivv_optab)\n+    {\n+      this_add_optab = addv_optab;\n+      this_sub_optab = subv_optab;\n+      this_neg_optab = negv_optab;\n+      this_mul_optab = smulv_optab;\n+    }\n \t      \n   /* Don't fetch these from memory more than once.  */\n   real0 = force_reg (submode, real0);\n@@ -358,8 +382,8 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n     }\n   else\n     {\n-      temp1 = expand_abs (submode, real1, NULL_RTX, 1);\n-      temp2 = expand_abs (submode, imag1, NULL_RTX, 1);\n+      temp1 = expand_abs (submode, real1, NULL_RTX, unsignedp, 1);\n+      temp2 = expand_abs (submode, imag1, NULL_RTX, unsignedp, 1);\n     }\n \n   if (temp1 == 0 || temp2 == 0)\n@@ -385,13 +409,13 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n \n   /* Calculate divisor.  */\n \n-  temp1 = expand_binop (submode, smul_optab, imag1, ratio,\n+  temp1 = expand_binop (submode, this_mul_optab, imag1, ratio,\n \t\t\tNULL_RTX, unsignedp, methods);\n \n   if (temp1 == 0)\n     return 0;\n \n-  divisor = expand_binop (submode, add_optab, temp1, real1,\n+  divisor = expand_binop (submode, this_add_optab, temp1, real1,\n \t\t\t  NULL_RTX, unsignedp, methods);\n \n   if (divisor == 0)\n@@ -405,13 +429,13 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n \n       /* Compute a / (c+id) as a / (c+d(d/c)) + i (-a(d/c)) / (c+d(d/c)).  */\n \n-      imag_t = expand_binop (submode, smul_optab, real0, ratio,\n+      imag_t = expand_binop (submode, this_mul_optab, real0, ratio,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n       if (imag_t == 0)\n \treturn 0;\n \n-      imag_t = expand_unop (submode, neg_optab, imag_t,\n+      imag_t = expand_unop (submode, this_neg_optab, imag_t,\n \t\t\t    NULL_RTX, unsignedp);\n \n       if (real_t == 0 || imag_t == 0)\n@@ -422,22 +446,22 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n       /* Compute (a+ib)/(c+id) as\n \t (a+b(d/c))/(c+d(d/c) + i(b-a(d/c))/(c+d(d/c)).  */\n \n-      temp1 = expand_binop (submode, smul_optab, imag0, ratio,\n+      temp1 = expand_binop (submode, this_mul_optab, imag0, ratio,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n       if (temp1 == 0)\n \treturn 0;\n \n-      real_t = expand_binop (submode, add_optab, temp1, real0,\n+      real_t = expand_binop (submode, this_add_optab, temp1, real0,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n-      temp1 = expand_binop (submode, smul_optab, real0, ratio,\n+      temp1 = expand_binop (submode, this_mul_optab, real0, ratio,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n       if (temp1 == 0)\n \treturn 0;\n \n-      imag_t = expand_binop (submode, sub_optab, imag0, temp1,\n+      imag_t = expand_binop (submode, this_sub_optab, imag0, temp1,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n       if (real_t == 0 || imag_t == 0)\n@@ -490,13 +514,13 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n \n   /* Calculate divisor.  */\n \n-  temp1 = expand_binop (submode, smul_optab, real1, ratio,\n+  temp1 = expand_binop (submode, this_mul_optab, real1, ratio,\n \t\t\tNULL_RTX, unsignedp, methods);\n \n   if (temp1 == 0)\n     return 0;\n \n-  divisor = expand_binop (submode, add_optab, temp1, imag1,\n+  divisor = expand_binop (submode, this_add_optab, temp1, imag1,\n \t\t\t  NULL_RTX, unsignedp, methods);\n \n   if (divisor == 0)\n@@ -508,10 +532,10 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n     {\n       /* Compute a / (c+id) as a(c/d) / (c(c/d)+d) + i (-a) / (c(c/d)+d).  */\n \n-      real_t = expand_binop (submode, smul_optab, real0, ratio,\n+      real_t = expand_binop (submode, this_mul_optab, real0, ratio,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n-      imag_t = expand_unop (submode, neg_optab, real0,\n+      imag_t = expand_unop (submode, this_neg_optab, real0,\n \t\t\t    NULL_RTX, unsignedp);\n \n       if (real_t == 0 || imag_t == 0)\n@@ -522,22 +546,22 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n       /* Compute (a+ib)/(c+id) as\n \t (a(c/d)+b)/(c(c/d)+d) + i (b(c/d)-a)/(c(c/d)+d).  */\n \n-      temp1 = expand_binop (submode, smul_optab, real0, ratio,\n+      temp1 = expand_binop (submode, this_mul_optab, real0, ratio,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n       if (temp1 == 0)\n \treturn 0;\n \n-      real_t = expand_binop (submode, add_optab, temp1, imag0,\n+      real_t = expand_binop (submode, this_add_optab, temp1, imag0,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n-      temp1 = expand_binop (submode, smul_optab, imag0, ratio,\n+      temp1 = expand_binop (submode, this_mul_optab, imag0, ratio,\n \t\t\t    NULL_RTX, unsignedp, methods);\n \n       if (temp1 == 0)\n \treturn 0;\n \n-      imag_t = expand_binop (submode, sub_optab, temp1, real0,\n+      imag_t = expand_binop (submode, this_sub_optab, temp1, real0,\n \t\t\t     NULL_RTX, unsignedp, methods);\n \n       if (real_t == 0 || imag_t == 0)\n@@ -1491,7 +1515,9 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  else if (imag0)\n \t    res = imag0;\n \t  else if (binoptab->code == MINUS)\n-\t    res = expand_unop (submode, neg_optab, imag1, imagr, unsignedp);\n+            res = expand_unop (submode,\n+                                binoptab == subv_optab ? negv_optab : neg_optab,\n+                                imag1, imagr, unsignedp);\n \t  else\n \t    res = imag1;\n \n@@ -1525,8 +1551,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      if (temp1 == 0 || temp2 == 0)\n \t\tbreak;\n \n-\t      res = expand_binop (submode, sub_optab, temp1, temp2,\n-\t\t\t\t  realr, unsignedp, methods);\n+\t      res = (expand_binop\n+                     (submode,\n+                      binoptab == smulv_optab ? subv_optab : sub_optab,\n+                      temp1, temp2, realr, unsignedp, methods));\n \n \t      if (res == 0)\n \t\tbreak;\n@@ -1542,8 +1570,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      if (temp1 == 0 || temp2 == 0)\n \t\t  break;\n \n-\t      res = expand_binop (submode, add_optab, temp1, temp2,\n-\t\t\t\t  imagr, unsignedp, methods);\n+\t      res = (expand_binop\n+                     (submode,\n+                      binoptab == smulv_optab ? addv_optab : add_optab,\n+                      temp1, temp2, imagr, unsignedp, methods));\n \n \t      if (res == 0)\n \t\tbreak;\n@@ -2120,7 +2150,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n     }\n \n   /* Open-code the complex negation operation.  */\n-  else if (unoptab == neg_optab\n+  else if (unoptab->code == NEG\n \t   && (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT))\n     {\n       rtx target_piece;\n@@ -2231,11 +2261,13 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \n   /* If there is no negate operation, try doing a subtract from zero.\n      The US Software GOFAST library needs this.  */\n-  if (unoptab == neg_optab)\n+  if (unoptab->code == NEG)\n     {    \n       rtx temp;\n-      temp = expand_binop (mode, sub_optab, CONST0_RTX (mode), op0,\n-\t\t\t   target, unsignedp, OPTAB_LIB_WIDEN);\n+      temp = expand_binop (mode,\n+                           unoptab == negv_optab ? subv_optab : sub_optab,\n+                           CONST0_RTX (mode), op0,\n+                           target, unsignedp, OPTAB_LIB_WIDEN);\n       if (temp)\n \treturn temp;\n     }\n@@ -2253,16 +2285,21 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n  */\n \n rtx\n-expand_abs (mode, op0, target, safe)\n+expand_abs (mode, op0, target, result_unsignedp, safe)\n      enum machine_mode mode;\n      rtx op0;\n      rtx target;\n+     int result_unsignedp;\n      int safe;\n {\n   rtx temp, op1;\n \n+  if (! flag_trapv)\n+    result_unsignedp = 1;\n+\n   /* First try to do it with a special abs instruction.  */\n-  temp = expand_unop (mode, abs_optab, op0, target, 0);\n+  temp = expand_unop (mode, result_unsignedp ? abs_optab : absv_optab,\n+                      op0, target, 0);\n   if (temp != 0)\n     return temp;\n \n@@ -2298,8 +2335,8 @@ expand_abs (mode, op0, target, safe)\n       temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n \t\t\t   OPTAB_LIB_WIDEN);\n       if (temp != 0)\n-\ttemp = expand_binop (mode, sub_optab, temp, extended, target, 0,\n-\t\t\t     OPTAB_LIB_WIDEN);\n+\ttemp = expand_binop (mode, result_unsignedp ? sub_optab : subv_optab,\n+                             temp, extended, target, 0, OPTAB_LIB_WIDEN);\n \n       if (temp != 0)\n \treturn temp;\n@@ -2335,7 +2372,8 @@ expand_abs (mode, op0, target, safe)\n     do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n \t\t\t     NULL_RTX, 0, NULL_RTX, op1);\n \n-  op0 = expand_unop (mode, neg_optab, target, target, 0);\n+  op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,\n+                     target, target, 0);\n   if (op0 != target)\n     emit_move_insn (target, op0);\n   emit_label (op1);\n@@ -2365,6 +2403,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n   rtx entry_last = get_last_insn ();\n   rtx last;\n   rtx pat;\n+  optab this_abs_optab;\n \n   /* Find the correct mode for the real and imaginary parts.  */\n   enum machine_mode submode\n@@ -2387,9 +2426,13 @@ expand_complex_abs (mode, op0, target, unsignedp)\n   if (target)\n     target = protect_from_queue (target, 1);\n \n-  if (abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+  this_abs_optab = ! unsignedp && flag_trapv\n+                   && (GET_MODE_CLASS(mode) == MODE_INT)\n+                   ? absv_optab : abs_optab;\n+\n+  if (this_abs_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n-      int icode = (int) abs_optab->handlers[(int) mode].insn_code;\n+      int icode = (int) this_abs_optab->handlers[(int) mode].insn_code;\n       enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n       rtx xop0 = op0;\n \n@@ -2414,10 +2457,12 @@ expand_complex_abs (mode, op0, target, unsignedp)\n       if (pat)\n \t{\n \t  if (GET_CODE (pat) == SEQUENCE\n-\t      && ! add_equal_note (pat, temp, abs_optab->code, xop0, NULL_RTX))\n+\t      && ! add_equal_note (pat, temp, this_abs_optab->code, xop0, \n+\t\t\t\t   NULL_RTX))\n \t    {\n \t      delete_insns_since (last);\n-\t      return expand_unop (mode, abs_optab, op0, NULL_RTX, unsignedp);\n+\t      return expand_unop (mode, this_abs_optab, op0, NULL_RTX, \n+\t\t\t\t  unsignedp);\n \t    }\n \n \t  emit_insn (pat);\n@@ -2433,7 +2478,8 @@ expand_complex_abs (mode, op0, target, unsignedp)\n   for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n        wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n     {\n-      if (abs_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+      if (this_abs_optab->handlers[(int) wider_mode].insn_code \n+\t  != CODE_FOR_nothing)\n \t{\n \t  rtx xop0 = op0;\n \n@@ -2483,7 +2529,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n     }\n \n   /* Now try a library call in this mode.  */\n-  if (abs_optab->handlers[(int) mode].libfunc)\n+  if (this_abs_optab->handlers[(int) mode].libfunc)\n     {\n       rtx insns;\n       rtx value;\n@@ -2499,7 +2545,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n \n       target = gen_reg_rtx (submode);\n       emit_libcall_block (insns, target, value,\n-\t\t\t  gen_rtx_fmt_e (abs_optab->code, mode, op0));\n+\t\t\t  gen_rtx_fmt_e (this_abs_optab->code, mode, op0));\n \n       return target;\n     }\n@@ -2509,9 +2555,9 @@ expand_complex_abs (mode, op0, target, unsignedp)\n   for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n        wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n     {\n-      if ((abs_optab->handlers[(int) wider_mode].insn_code\n+      if ((this_abs_optab->handlers[(int) wider_mode].insn_code\n \t   != CODE_FOR_nothing)\n-\t  || abs_optab->handlers[(int) wider_mode].libfunc)\n+\t  || this_abs_optab->handlers[(int) wider_mode].libfunc)\n \t{\n \t  rtx xop0 = op0;\n \n@@ -4528,13 +4574,17 @@ init_optabs ()\n #endif\n \n   add_optab = init_optab (PLUS);\n+  addv_optab = init_optab (PLUS);\n   sub_optab = init_optab (MINUS);\n+  subv_optab = init_optab (MINUS);\n   smul_optab = init_optab (MULT);\n+  smulv_optab = init_optab (MULT);\n   smul_highpart_optab = init_optab (UNKNOWN);\n   umul_highpart_optab = init_optab (UNKNOWN);\n   smul_widen_optab = init_optab (UNKNOWN);\n   umul_widen_optab = init_optab (UNKNOWN);\n   sdiv_optab = init_optab (DIV);\n+  sdivv_optab = init_optab (DIV);\n   sdivmod_optab = init_optab (UNKNOWN);\n   udiv_optab = init_optab (UDIV);\n   udivmod_optab = init_optab (UNKNOWN);\n@@ -4560,7 +4610,9 @@ init_optabs ()\n   ucmp_optab = init_optab (UNKNOWN);\n   tst_optab = init_optab (UNKNOWN);\n   neg_optab = init_optab (NEG);\n+  negv_optab = init_optab (NEG);\n   abs_optab = init_optab (ABS);\n+  absv_optab = init_optab (ABS);\n   one_cmpl_optab = init_optab (NOT);\n   ffs_optab = init_optab (FFS);\n   sqrt_optab = init_optab (SQRT);\n@@ -4595,11 +4647,18 @@ init_optabs ()\n   /* Initialize the optabs with the names of the library functions.  */\n   init_integral_libfuncs (add_optab, \"add\", '3');\n   init_floating_libfuncs (add_optab, \"add\", '3');\n+  init_integral_libfuncs (addv_optab, \"addv\", '3');\n+  init_floating_libfuncs (addv_optab, \"add\", '3');\n   init_integral_libfuncs (sub_optab, \"sub\", '3');\n   init_floating_libfuncs (sub_optab, \"sub\", '3');\n+  init_integral_libfuncs (subv_optab, \"subv\", '3');\n+  init_floating_libfuncs (subv_optab, \"sub\", '3');\n   init_integral_libfuncs (smul_optab, \"mul\", '3');\n   init_floating_libfuncs (smul_optab, \"mul\", '3');\n+  init_integral_libfuncs (smulv_optab, \"mulv\", '3');\n+  init_floating_libfuncs (smulv_optab, \"mul\", '3');\n   init_integral_libfuncs (sdiv_optab, \"div\", '3');\n+  init_integral_libfuncs (sdivv_optab, \"divv\", '3');\n   init_integral_libfuncs (udiv_optab, \"udiv\", '3');\n   init_integral_libfuncs (sdivmod_optab, \"divmod\", '4');\n   init_integral_libfuncs (udivmod_optab, \"udivmod\", '4');\n@@ -4621,6 +4680,8 @@ init_optabs ()\n   init_integral_libfuncs (umax_optab, \"umax\", '3');\n   init_integral_libfuncs (neg_optab, \"neg\", '2');\n   init_floating_libfuncs (neg_optab, \"neg\", '2');\n+  init_integral_libfuncs (negv_optab, \"negv\", '2');\n+  init_floating_libfuncs (negv_optab, \"neg\", '2');\n   init_integral_libfuncs (one_cmpl_optab, \"one_cmpl\", '2');\n   init_integral_libfuncs (ffs_optab, \"ffs\", '2');\n "}, {"sha": "1dfa7f5cbf7060c7171102af40eea5bb0e7d0ef9", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -947,6 +947,8 @@ typedef struct\n }\n lang_independent_options;\n \n+int flag_trapv = 0;\n+\n /* Add or remove a leading underscore from user symbols.  */\n int flag_leading_underscore = -1;\n \n@@ -1145,6 +1147,8 @@ lang_independent_options f_options[] =\n    \"Report time taken by each compiler pass at end of run\"},\n   {\"mem-report\", &mem_report, 1,\n    \"Report on permanent memory allocation at end of run\"},\n+  { \"trapv\", &flag_trapv, 1,\n+    \"Trap for signed overflow in addition / subtraction / multiplication.\" },\n };\n \n /* Table of language-specific options.  */"}, {"sha": "68ccbbf8dd3008f7f5a8a9ac7e67589fb9839ab6", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ce572a07eddf596d9846c7e80393b628fdd20b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=91ce572a07eddf596d9846c7e80393b628fdd20b", "patch": "@@ -574,6 +574,8 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n    The same bit is used in functions as DECL_BUILT_IN_NONANSI.  */\n #define TREE_UNSIGNED(NODE) ((NODE)->common.unsigned_flag)\n \n+#define TYPE_TRAP_SIGNED(NODE) (flag_trapv && ! TREE_UNSIGNED (NODE))\n+\n /* Nonzero in a VAR_DECL means assembler code has been written.\n    Nonzero in a FUNCTION_DECL means that the function has been compiled.\n    This is interesting in an inline function, since it might not need"}]}