{"sha": "b194a722446f51ffa11ea49affe6893a6361cfac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5NGE3MjI0NDZmNTFmZmExMWVhNDlhZmZlNjg5M2E2MzYxY2ZhYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:46:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:46:38Z"}, "message": "Use extract_bit_field_as_subreg for vectors\n\nextract_bit_field_1 tries to use vec_extract to extract part of a\nvector.  However, if that pattern isn't defined or if the operands\naren't suitable, another good approach is to try a direct subreg\nreference.  This is particularly useful for multi-vector modes on\nSVE (e.g. when extracting one vector from an LD2 result).\n\nThe function would go on to try the same thing anyway, but only\nif there is an integer mode with the same size as the vector mode,\nwhich isn't true for SVE modes (and doesn't seem a good thing to\nrequire in general).  Even when there is an integer mode, doing the\noperation on the original modes avoids some unnecessary bitcasting.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* expmed.c (extract_bit_field_1): For vector extracts,\n\tfall back to extract_bit_field_as_subreg if vec_extract\n\tisn't available.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256209", "tree": {"sha": "723e0087b658c0c78b9cd5821bcf18a50d70fc36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/723e0087b658c0c78b9cd5821bcf18a50d70fc36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b194a722446f51ffa11ea49affe6893a6361cfac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b194a722446f51ffa11ea49affe6893a6361cfac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b194a722446f51ffa11ea49affe6893a6361cfac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b194a722446f51ffa11ea49affe6893a6361cfac/comments", "author": null, "committer": null, "parents": [{"sha": "799d6b901de53dcb43cea2fc10ebde9423d09c52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/799d6b901de53dcb43cea2fc10ebde9423d09c52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/799d6b901de53dcb43cea2fc10ebde9423d09c52"}], "stats": {"total": 66, "additions": 45, "deletions": 21}, "files": [{"sha": "5dbf3ba55249bf8356ba2ae274f642b13523cff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b194a722446f51ffa11ea49affe6893a6361cfac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b194a722446f51ffa11ea49affe6893a6361cfac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b194a722446f51ffa11ea49affe6893a6361cfac", "patch": "@@ -1,3 +1,11 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expmed.c (extract_bit_field_1): For vector extracts,\n+\tfall back to extract_bit_field_as_subreg if vec_extract\n+\tisn't available.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d88ea3508e45fa5712713dad2d8c70c80fe191f1", "filename": "gcc/expmed.c", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b194a722446f51ffa11ea49affe6893a6361cfac/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b194a722446f51ffa11ea49affe6893a6361cfac/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b194a722446f51ffa11ea49affe6893a6361cfac", "patch": "@@ -1709,33 +1709,49 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n     }\n \n   /* Use vec_extract patterns for extracting parts of vectors whenever\n-     available.  */\n+     available.  If that fails, see whether the current modes and bitregion\n+     give a natural subreg.  */\n   machine_mode outermode = GET_MODE (op0);\n-  scalar_mode innermode = GET_MODE_INNER (outermode);\n-  poly_uint64 pos;\n-  if (VECTOR_MODE_P (outermode)\n-      && !MEM_P (op0)\n-      && (convert_optab_handler (vec_extract_optab, outermode, innermode)\n-\t  != CODE_FOR_nothing)\n-      && known_eq (bitsize, GET_MODE_BITSIZE (innermode))\n-      && multiple_p (bitnum, GET_MODE_BITSIZE (innermode), &pos))\n+  if (VECTOR_MODE_P (outermode) && !MEM_P (op0))\n     {\n-      struct expand_operand ops[3];\n+      scalar_mode innermode = GET_MODE_INNER (outermode);\n       enum insn_code icode\n \t= convert_optab_handler (vec_extract_optab, outermode, innermode);\n+      poly_uint64 pos;\n+      if (icode != CODE_FOR_nothing\n+\t  && known_eq (bitsize, GET_MODE_BITSIZE (innermode))\n+\t  && multiple_p (bitnum, GET_MODE_BITSIZE (innermode), &pos))\n+\t{\n+\t  struct expand_operand ops[3];\n \n-      create_output_operand (&ops[0], target, innermode);\n-      ops[0].target = 1;\n-      create_input_operand (&ops[1], op0, outermode);\n-      create_integer_operand (&ops[2], pos);\n-      if (maybe_expand_insn (icode, 3, ops))\n+\t  create_output_operand (&ops[0], target, innermode);\n+\t  ops[0].target = 1;\n+\t  create_input_operand (&ops[1], op0, outermode);\n+\t  create_integer_operand (&ops[2], pos);\n+\t  if (maybe_expand_insn (icode, 3, ops))\n+\t    {\n+\t      if (alt_rtl && ops[0].target)\n+\t\t*alt_rtl = target;\n+\t      target = ops[0].value;\n+\t      if (GET_MODE (target) != mode)\n+\t\treturn gen_lowpart (tmode, target);\n+\t      return target;\n+\t    }\n+\t}\n+      /* Using subregs is useful if we're extracting the least-significant\n+\t vector element, or if we're extracting one register vector from\n+\t a multi-register vector.  extract_bit_field_as_subreg checks\n+\t for valid bitsize and bitnum, so we don't need to do that here.\n+\n+\t The mode check makes sure that we're extracting either\n+\t a single element or a subvector with the same element type.\n+\t If the modes aren't such a natural fit, fall through and\n+\t bitcast to integers first.  */\n+      if (GET_MODE_INNER (mode) == innermode)\n \t{\n-\t  if (alt_rtl && ops[0].target)\n-\t    *alt_rtl = target;\n-\t  target = ops[0].value;\n-      \t  if (GET_MODE (target) != mode)\n-\t    return gen_lowpart (tmode, target);\n-\t  return target;\n+\t  rtx sub = extract_bit_field_as_subreg (mode, op0, bitsize, bitnum);\n+\t  if (sub)\n+\t    return sub;\n \t}\n     }\n "}]}