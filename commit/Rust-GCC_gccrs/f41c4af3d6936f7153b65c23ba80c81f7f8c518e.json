{"sha": "f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQxYzRhZjNkNjkzNmY3MTUzYjY1YzIzYmE4MGM4MWY3ZjhjNTE4ZQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2009-05-10T10:28:34Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2009-05-10T10:28:34Z"}, "message": "pretty-print.h (struct pretty_print_info): Add translate_identifiers.\n\n\t* pretty-print.h (struct pretty_print_info): Add\n\ttranslate_identifiers.\n\t(pp_translate_identifiers): New.\n\t(pp_identifier): Only conditionally translate identifier to locale\n\tcharacter set.\n\t* pretty-print.c (pp_construct): Set pp_translate_identifiers.\n\t(pp_base_tree_identifier): Only conditionally translate identifier\n\tto locale character set.\n\t* c-pretty-print.c (M_): Define.\n\t(pp_c_type_specifier, pp_c_primary_expression): Mark English\n\tfragments for conditional translation with M_.\n\t* tree-pretty-print.c (maybe_init_pretty_print): Disable\n\tidentifier translation.\n\ncp:\n\t* call.c (name_as_c_string): Call type_as_string_translate.\n\tTranslate identifiers to locale character set.\n\t* cp-tree.h (lang_decl_name): Update prototype.\n\t(type_as_string_translate, decl_as_string_translate,\n\tcxx_printable_name_translate): Declare.\n\t* cxx-pretty-print.c (M_): Define.\n\t(pp_cxx_unqualified_id, pp_cxx_canonical_template_parameter): Mark\n\tEnglish fragments for conditional translation with M_.\n\t* decl.c (grokdeclarator): Translate identifiers to locale\n\tcharacter set for diagnostics.\n\t* error.c (M_): Define.\n\t(dump_template_bindings, dump_type, dump_aggr_type,\n\tdump_type_prefix, dump_global_iord, dump_simple_decl, dump_decl,\n\tdump_function_decl, dump_template_parms, dump_expr,\n\tdump_binary_op, op_to_string, assop_to_string): Mark English\n\tfragments for conditional translation with M_.\n\t(type_as_string): Disable translation of identifiers.\n\t(type_as_string_translate): New.\n\t(expr_as_string): Disable translation of identifiers.\n\t(decl_as_string): Disable translation of identifiers.\n\t(decl_as_string_translate): New.\n\t(lang_decl_name): Add parameter translate.\n\t(args_to_string): Call type_as_string_translate.\n\t(cp_print_error_function): Call cxx_printable_name_translate.\n\t(print_instantiation_full_context,\n\tprint_instantiation_partial_context): Call\n\tdecl_as_string_translate.\n\t* parser.c (cp_lexer_get_preprocessor_token): Use %qE for\n\tidentifier in diagnostic.\n\t* tree.c (cxx_printable_name): Change to\n\tcxx_printable_name_internal.  Add parameter translate.\n\t(cxx_printable_name, cxx_printable_name_translate): New wrappers\n\tround cxx_printable_name_internal.\n\nobjc:\n\t* objc-act.c: Include intl.h.\n\t(objc_lookup_protocol): Use complete sentences for diagnostics\n\twith %qE for identifiers and translating results of\n\tgen_type_name_0 to locale character set.\n\t(objc_check_decl, check_protocol_recursively,\n\tlookup_and_install_protocols, objc_build_string_object,\n\tobjc_get_class_reference, objc_declare_alias, objc_declare_class,\n\tobjc_get_class_ivars, error_with_ivar, check_duplicates,\n\tobjc_finish_message_expr, objc_build_protocol_expr,\n\tobjc_build_selector_expr, build_ivar_reference, objc_add_method,\n\tadd_category, add_instance_variable, objc_is_public,\n\tcheck_methods, check_methods_accessible, check_protocol,\n\tstart_class, finish_class, start_protocol, really_start_method,\n\tget_super_receiver, objc_lookup_ivar): Use %E and %qE for\n\tidentifiers in diagnostics.  Translate generated text to locale\n\tcharacter set as needed.\n\t(check_protocol, check_protocols): Change name parameter to type\n\ttree.\n\t(lang_report_error_function): Remove.\n\nFrom-SVN: r147333", "tree": {"sha": "a02bdc44763aa1057cf075a959ca0e50e4188797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a02bdc44763aa1057cf075a959ca0e50e4188797"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082b1749a179b056f33db0e6971ad1edeca17cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/082b1749a179b056f33db0e6971ad1edeca17cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/082b1749a179b056f33db0e6971ad1edeca17cdc"}], "stats": {"total": 544, "additions": 335, "deletions": 209}, "files": [{"sha": "c2e3f12bd65ce3d71236dae4502ac7ab70901adf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -1,3 +1,19 @@\n+2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* pretty-print.h (struct pretty_print_info): Add\n+\ttranslate_identifiers.\n+\t(pp_translate_identifiers): New.\n+\t(pp_identifier): Only conditionally translate identifier to locale\n+\tcharacter set.\n+\t* pretty-print.c (pp_construct): Set pp_translate_identifiers.\n+\t(pp_base_tree_identifier): Only conditionally translate identifier\n+\tto locale character set.\n+\t* c-pretty-print.c (M_): Define.\n+\t(pp_c_type_specifier, pp_c_primary_expression): Mark English\n+\tfragments for conditional translation with M_.\n+\t* tree-pretty-print.c (maybe_init_pretty_print): Disable\n+\tidentifier translation.\n+\n 2009-05-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/40081"}, {"sha": "f9694bfc080c81993ae0341f7ec22336ef541e80", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -31,6 +31,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"diagnostic.h\"\n \n+/* Translate if being used for diagnostics, but not for dump files or\n+   __PRETTY_FUNCTION.  */\n+#define M_(msgid) (pp_translate_identifiers (pp) ? _(msgid) : (msgid))\n+\n /* The pretty-printer code is primarily designed to closely follow\n    (GNU) C and C++ grammars.  That is to be contrasted with spaghetti\n    codes we used to have in the past.  Following a structured\n@@ -307,7 +311,7 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n   switch (code)\n     {\n     case ERROR_MARK:\n-      pp_c_ws_string (pp, _(\"<type-error>\"));\n+      pp_c_ws_string (pp, M_(\"<type-error>\"));\n       break;\n \n     case IDENTIFIER_NODE:\n@@ -346,14 +350,14 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n \t\t{\n \t\tcase INTEGER_TYPE:\n \t\t  pp_string (pp, (TYPE_UNSIGNED (t)\n-\t\t\t\t  ? _(\"<unnamed-unsigned:\")\n-\t\t\t\t  : _(\"<unnamed-signed:\")));\n+\t\t\t\t  ? M_(\"<unnamed-unsigned:\")\n+\t\t\t\t  : M_(\"<unnamed-signed:\")));\n \t\t  break;\n \t\tcase REAL_TYPE:\n-\t\t  pp_string (pp, _(\"<unnamed-float:\"));\n+\t\t  pp_string (pp, M_(\"<unnamed-float:\"));\n \t\t  break;\n \t\tcase FIXED_POINT_TYPE:\n-\t\t  pp_string (pp, _(\"<unnamed-fixed:\"));\n+\t\t  pp_string (pp, M_(\"<unnamed-fixed:\"));\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -368,7 +372,7 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n       if (DECL_NAME (t))\n \tpp_id_expression (pp, t);\n       else\n-\tpp_c_ws_string (pp, _(\"<typedef-error>\"));\n+\tpp_c_ws_string (pp, M_(\"<typedef-error>\"));\n       break;\n \n     case UNION_TYPE:\n@@ -381,12 +385,12 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n       else if (code == ENUMERAL_TYPE)\n \tpp_c_ws_string (pp, \"enum\");\n       else\n-\tpp_c_ws_string (pp, _(\"<tag-error>\"));\n+\tpp_c_ws_string (pp, M_(\"<tag-error>\"));\n \n       if (TYPE_NAME (t))\n \tpp_id_expression (pp, TYPE_NAME (t));\n       else\n-\tpp_c_ws_string (pp, _(\"<anonymous>\"));\n+\tpp_c_ws_string (pp, M_(\"<anonymous>\"));\n       break;\n \n     default:\n@@ -1119,11 +1123,11 @@ pp_c_primary_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case ERROR_MARK:\n-      pp_c_ws_string (pp, _(\"<erroneous-expression>\"));\n+      pp_c_ws_string (pp, M_(\"<erroneous-expression>\"));\n       break;\n \n     case RESULT_DECL:\n-      pp_c_ws_string (pp, _(\"<return-value>\"));\n+      pp_c_ws_string (pp, M_(\"<return-value>\"));\n       break;\n \n     case INTEGER_CST:"}, {"sha": "8117f22dccbfa35a066c3cf3dd2783bd07b1bf60", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -1,3 +1,39 @@\n+2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* call.c (name_as_c_string): Call type_as_string_translate.\n+\tTranslate identifiers to locale character set.\n+\t* cp-tree.h (lang_decl_name): Update prototype.\n+\t(type_as_string_translate, decl_as_string_translate,\n+\tcxx_printable_name_translate): Declare.\n+\t* cxx-pretty-print.c (M_): Define.\n+\t(pp_cxx_unqualified_id, pp_cxx_canonical_template_parameter): Mark\n+\tEnglish fragments for conditional translation with M_.\n+\t* decl.c (grokdeclarator): Translate identifiers to locale\n+\tcharacter set for diagnostics.\n+\t* error.c (M_): Define.\n+\t(dump_template_bindings, dump_type, dump_aggr_type,\n+\tdump_type_prefix, dump_global_iord, dump_simple_decl, dump_decl,\n+\tdump_function_decl, dump_template_parms, dump_expr,\n+\tdump_binary_op, op_to_string, assop_to_string): Mark English\n+\tfragments for conditional translation with M_.\n+\t(type_as_string): Disable translation of identifiers.\n+\t(type_as_string_translate): New.\n+\t(expr_as_string): Disable translation of identifiers.\n+\t(decl_as_string): Disable translation of identifiers.\n+\t(decl_as_string_translate): New.\n+\t(lang_decl_name): Add parameter translate.\n+\t(args_to_string): Call type_as_string_translate.\n+\t(cp_print_error_function): Call cxx_printable_name_translate.\n+\t(print_instantiation_full_context,\n+\tprint_instantiation_partial_context): Call\n+\tdecl_as_string_translate.\n+\t* parser.c (cp_lexer_get_preprocessor_token): Use %qE for\n+\tidentifier in diagnostic.\n+\t* tree.c (cxx_printable_name): Change to\n+\tcxx_printable_name_internal.  Add parameter translate.\n+\t(cxx_printable_name, cxx_printable_name_translate): New wrappers\n+\tround cxx_printable_name_internal.\n+\n 2009-05-08  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c/36892"}, {"sha": "ee13ba2a414b753a92daa4b105629878d65ecf81", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -5731,7 +5731,7 @@ name_as_c_string (tree name, tree type, bool *free_p)\n   if (IDENTIFIER_CTOR_OR_DTOR_P (name))\n     {\n       pretty_name\n-\t= CONST_CAST (char *, IDENTIFIER_POINTER (constructor_name (type)));\n+\t= CONST_CAST (char *, identifier_to_locale (IDENTIFIER_POINTER (constructor_name (type))));\n       /* For a destructor, add the '~'.  */\n       if (name == complete_dtor_identifier\n \t  || name == base_dtor_identifier\n@@ -5745,14 +5745,14 @@ name_as_c_string (tree name, tree type, bool *free_p)\n   else if (IDENTIFIER_TYPENAME_P (name))\n     {\n       pretty_name = concat (\"operator \",\n-\t\t\t    type_as_string (TREE_TYPE (name),\n-\t\t\t\t\t    TFF_PLAIN_IDENTIFIER),\n+\t\t\t    type_as_string_translate (TREE_TYPE (name),\n+\t\t\t\t\t\t      TFF_PLAIN_IDENTIFIER),\n \t\t\t    NULL);\n       /* Remember that we need to free the memory allocated.  */\n       *free_p = true;\n     }\n   else\n-    pretty_name = CONST_CAST (char *, IDENTIFIER_POINTER (name));\n+    pretty_name = CONST_CAST (char *, identifier_to_locale (IDENTIFIER_POINTER (name)));\n \n   return pretty_name;\n }"}, {"sha": "0ea2d8623f69beffce05b34d460c65fe9a082aba", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -4422,9 +4422,11 @@ extern int parm_index                           (tree);\n /* in error.c */\n extern void init_error\t\t\t\t(void);\n extern const char *type_as_string\t\t(tree, int);\n+extern const char *type_as_string_translate\t(tree, int);\n extern const char *decl_as_string\t\t(tree, int);\n+extern const char *decl_as_string_translate\t(tree, int);\n extern const char *expr_as_string\t\t(tree, int);\n-extern const char *lang_decl_name\t\t(tree, int);\n+extern const char *lang_decl_name\t\t(tree, int, bool);\n extern const char *language_to_string\t\t(enum languages);\n extern const char *class_key_or_enum_as_string\t(tree);\n extern void print_instantiation_context\t\t(void);\n@@ -4839,6 +4841,7 @@ extern tree get_first_fn\t\t\t(tree);\n extern tree ovl_cons\t\t\t\t(tree, tree);\n extern tree build_overload\t\t\t(tree, tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n+extern const char *cxx_printable_name_translate\t(tree, int);\n extern tree build_exception_variant\t\t(tree, tree);\n extern tree bind_template_template_parm\t\t(tree, tree);\n extern tree array_type_nelts_total\t\t(tree);"}, {"sha": "b8732896aa45be1caedd9953e96924b6d773a969", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -29,6 +29,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-tree.h\"\n #include \"toplev.h\"\n \n+/* Translate if being used for diagnostics, but not for dump files or\n+   __PRETTY_FUNCTION.  */\n+#define M_(msgid) (pp_translate_identifiers (pp) ? _(msgid) : (msgid))\n+\n static void pp_cxx_unqualified_id (cxx_pretty_printer *, tree);\n static void pp_cxx_nested_name_specifier (cxx_pretty_printer *, tree);\n static void pp_cxx_qualified_id (cxx_pretty_printer *, tree);\n@@ -147,7 +151,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n   switch (code)\n     {\n     case RESULT_DECL:\n-      pp_cxx_ws_string (pp, _(\"<return-value>\"));\n+      pp_cxx_ws_string (pp, M_(\"<return-value>\"));\n       break;\n \n     case OVERLOAD:\n@@ -166,7 +170,7 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n \n     case IDENTIFIER_NODE:\n       if (t == NULL)\n-\tpp_cxx_ws_string (pp, _(\"<unnamed>\"));\n+\tpp_cxx_ws_string (pp, M_(\"<unnamed>\"));\n       else if (IDENTIFIER_TYPENAME_P (t))\n \tpp_cxx_conversion_function_id (pp, t);\n       else\n@@ -2048,7 +2052,7 @@ pp_cxx_canonical_template_parameter (cxx_pretty_printer *pp, tree parm)\n     parm = TEMPLATE_TYPE_PARM_INDEX (parm);\n \n   pp_cxx_begin_template_argument_list (pp);\n-  pp_cxx_ws_string (pp, _(\"template-parameter-\"));\n+  pp_cxx_ws_string (pp, M_(\"template-parameter-\"));\n   pp_wide_integer (pp, TEMPLATE_PARM_LEVEL (parm));\n   pp_minus (pp);\n   pp_wide_integer (pp, TEMPLATE_PARM_IDX (parm) + 1);"}, {"sha": "fd944f713db93b7cd15ad36bdfffb43a785ad874", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -7701,7 +7701,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  type = TREE_OPERAND (decl, 0);\n \t\t  if (TYPE_P (type))\n \t\t    type = constructor_name (type);\n-\t\t  name = IDENTIFIER_POINTER (type);\n+\t\t  name = identifier_to_locale (IDENTIFIER_POINTER (type));\n \t\t  dname = decl;\n \t\t}\n \t\tbreak;\n@@ -7727,18 +7727,18 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  {\n \t\t    error (\"declarator-id missing; using reserved word %qD\",\n \t\t\t   dname);\n-\t\t    name = IDENTIFIER_POINTER (dname);\n+\t\t    name = identifier_to_locale (IDENTIFIER_POINTER (dname));\n \t\t  }\n \t\telse if (!IDENTIFIER_TYPENAME_P (dname))\n-\t\t  name = IDENTIFIER_POINTER (dname);\n+\t\t  name = identifier_to_locale (IDENTIFIER_POINTER (dname));\n \t\telse\n \t\t  {\n \t\t    gcc_assert (flags == NO_SPECIAL);\n \t\t    flags = TYPENAME_FLAG;\n \t\t    ctor_return_type = TREE_TYPE (dname);\n \t\t    sfk = sfk_conversion;\n \t\t    if (is_typename_at_global_scope (dname))\n-\t\t      name = IDENTIFIER_POINTER (dname);\n+\t\t      name = identifier_to_locale (IDENTIFIER_POINTER (dname));\n \t\t    else\n \t\t      name = \"<invalid operator>\";\n \t\t  }"}, {"sha": "3c7a8d5c58e1f81c9ae74b1887969d83238bd0c3", "filename": "gcc/cp/error.c", "status": "modified", "additions": 63, "deletions": 37, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -41,6 +41,10 @@ along with GCC; see the file COPYING3.  If not see\n static cxx_pretty_printer scratch_pretty_printer;\n #define cxx_pp (&scratch_pretty_printer)\n \n+/* Translate if being used for diagnostics, but not for dump files or\n+   __PRETTY_FUNCTION.  */\n+#define M_(msgid) (pp_translate_identifiers (cxx_pp) ? _(msgid) : (msgid))\n+\n # define NEXT_CODE(T) (TREE_CODE (TREE_TYPE (T)))\n \n static const char *args_to_string (tree, int);\n@@ -298,7 +302,7 @@ dump_template_bindings (tree parms, tree args, VEC(tree,gc)* typenames)\n \t  if (arg)\n \t    dump_template_argument (arg, TFF_PLAIN_IDENTIFIER);\n \t  else\n-\t    pp_string (cxx_pp, _(\"<missing>\"));\n+\t    pp_string (cxx_pp, M_(\"<missing>\"));\n \n \t  ++arg_idx;\n \t  need_comma = 1;\n@@ -339,9 +343,9 @@ dump_type (tree t, int flags)\n     {\n     case UNKNOWN_TYPE:\n       if (t == init_list_type_node)\n-\tpp_string (cxx_pp, _(\"<brace-enclosed initializer list>\"));\n+\tpp_string (cxx_pp, M_(\"<brace-enclosed initializer list>\"));\n       else\n-\tpp_string (cxx_pp, _(\"<unresolved overloaded function type>\"));\n+\tpp_string (cxx_pp, M_(\"<unresolved overloaded function type>\"));\n       break;\n \n     case TREE_LIST:\n@@ -481,7 +485,7 @@ dump_type (tree t, int flags)\n       /* Fall through to error.  */\n \n     case ERROR_MARK:\n-      pp_string (cxx_pp, _(\"<type error>\"));\n+      pp_string (cxx_pp, M_(\"<type error>\"));\n       break;\n     }\n }\n@@ -578,9 +582,9 @@ dump_aggr_type (tree t, int flags)\n   if (name == 0 || ANON_AGGRNAME_P (name))\n     {\n       if (flags & TFF_CLASS_KEY_OR_ENUM)\n-\tpp_string (cxx_pp, _(\"<anonymous>\"));\n+\tpp_string (cxx_pp, M_(\"<anonymous>\"));\n       else\n-\tpp_printf (pp_base (cxx_pp), _(\"<anonymous %s>\"), variety);\n+\tpp_printf (pp_base (cxx_pp), M_(\"<anonymous %s>\"), variety);\n     }\n   else\n     pp_cxx_tree_identifier (cxx_pp, name);\n@@ -702,7 +706,7 @@ dump_type_prefix (tree t, int flags)\n       pp_unsupported_tree (cxx_pp, t);\n       /* fall through.  */\n     case ERROR_MARK:\n-      pp_string (cxx_pp, _(\"<typeprefixerror>\"));\n+      pp_string (cxx_pp, M_(\"<typeprefixerror>\"));\n       break;\n     }\n }\n@@ -812,9 +816,9 @@ dump_global_iord (tree t)\n   const char *p = NULL;\n \n   if (DECL_GLOBAL_CTOR_P (t))\n-    p = _(\"(static initializers for %s)\");\n+    p = M_(\"(static initializers for %s)\");\n   else if (DECL_GLOBAL_DTOR_P (t))\n-    p = _(\"(static destructors for %s)\");\n+    p = M_(\"(static destructors for %s)\");\n   else\n     gcc_unreachable ();\n \n@@ -841,7 +845,7 @@ dump_simple_decl (tree t, tree type, int flags)\n   if (DECL_NAME (t))\n     dump_decl (DECL_NAME (t), flags);\n   else\n-    pp_string (cxx_pp, _(\"<anonymous>\"));\n+    pp_string (cxx_pp, M_(\"<anonymous>\"));\n   if (flags & TFF_DECL_SPECIFIERS)\n     dump_type_suffix (type, flags);\n }\n@@ -884,7 +888,7 @@ dump_decl (tree t, int flags)\n     case VAR_DECL:\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n-\t  pp_string (cxx_pp, _(\"vtable for \"));\n+\t  pp_string (cxx_pp, M_(\"vtable for \"));\n \t  gcc_assert (TYPE_P (DECL_CONTEXT (t)));\n \t  dump_type (DECL_CONTEXT (t), flags);\n \t  break;\n@@ -896,7 +900,7 @@ dump_decl (tree t, int flags)\n       break;\n \n     case RESULT_DECL:\n-      pp_string (cxx_pp, _(\"<return value> \"));\n+      pp_string (cxx_pp, M_(\"<return value> \"));\n       dump_simple_decl (t, TREE_TYPE (t), flags);\n       break;\n \n@@ -909,7 +913,7 @@ dump_decl (tree t, int flags)\n \t    dump_scope (CP_DECL_CONTEXT (t), flags);\n \t  flags &= ~TFF_UNQUALIFIED_NAME;\n \t  if (DECL_NAME (t) == NULL_TREE)\n-\t    pp_string (cxx_pp, _(\"<unnamed>\"));\n+\t    pp_string (cxx_pp, M_(\"<unnamed>\"));\n \t  else\n \t    pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n \t}\n@@ -983,7 +987,7 @@ dump_decl (tree t, int flags)\n \n     case FUNCTION_DECL:\n       if (! DECL_LANG_SPECIFIC (t))\n-\tpp_string (cxx_pp, _(\"<built-in>\"));\n+\tpp_string (cxx_pp, M_(\"<built-in>\"));\n       else if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n \tdump_global_iord (t);\n       else\n@@ -1022,7 +1026,7 @@ dump_decl (tree t, int flags)\n       else if (DECL_INITIAL (t))\n \tdump_expr (DECL_INITIAL (t), flags | TFF_EXPR_IN_PARENS);\n       else\n-\tpp_string (cxx_pp, _(\"<enumerator>\"));\n+\tpp_string (cxx_pp, M_(\"<enumerator>\"));\n       break;\n \n     case USING_DECL:\n@@ -1062,7 +1066,7 @@ dump_decl (tree t, int flags)\n       /* Fall through to error.  */\n \n     case ERROR_MARK:\n-      pp_string (cxx_pp, _(\"<declaration error>\"));\n+      pp_string (cxx_pp, M_(\"<declaration error>\"));\n       break;\n     }\n }\n@@ -1292,7 +1296,7 @@ dump_function_decl (tree t, int flags)\n     {\n       pp_cxx_whitespace (cxx_pp);\n       pp_cxx_left_bracket (cxx_pp);\n-      pp_cxx_ws_string (cxx_pp, _(\"with\"));\n+      pp_cxx_ws_string (cxx_pp, M_(\"with\"));\n       pp_cxx_whitespace (cxx_pp);\n       dump_template_bindings (template_parms, template_args, typenames);\n       pp_cxx_right_bracket (cxx_pp);\n@@ -1457,7 +1461,7 @@ dump_template_parms (tree info, int primary, int flags)\n             pp_separate_with_comma (cxx_pp);\n           \n           if (!arg)\n-            pp_string (cxx_pp, _(\"<template parameter error>\"));\n+            pp_string (cxx_pp, M_(\"<template parameter error>\"));\n           else\n             dump_template_argument (arg, flags);\n         }\n@@ -1477,7 +1481,7 @@ dump_template_parms (tree info, int primary, int flags)\n \n           if (TREE_VEC_ELT (parms, ix) == error_mark_node)\n             {\n-              pp_string (cxx_pp, _(\"<template parameter error>\"));\n+              pp_string (cxx_pp, M_(\"<template parameter error>\"));\n               continue;\n             }\n \n@@ -1603,7 +1607,7 @@ dump_expr (tree t, int flags)\n \n   if (STATEMENT_CLASS_P (t))\n     {\n-      pp_cxx_ws_string (cxx_pp, _(\"<statement>\"));\n+      pp_cxx_ws_string (cxx_pp, M_(\"<statement>\"));\n       return;\n     }\n \n@@ -1632,7 +1636,7 @@ dump_expr (tree t, int flags)\n     case THROW_EXPR:\n       /* While waiting for caret diagnostics, avoid printing\n \t __cxa_allocate_exception, __cxa_throw, and the like.  */\n-      pp_cxx_ws_string (cxx_pp, _(\"<throw-expression>\"));\n+      pp_cxx_ws_string (cxx_pp, M_(\"<throw-expression>\"));\n       break;\n \n     case PTRMEM_CST:\n@@ -2078,7 +2082,7 @@ dump_expr (tree t, int flags)\n       break;\n \n     case DEFAULT_ARG:\n-      pp_string (cxx_pp, _(\"<unparsed>\"));\n+      pp_string (cxx_pp, M_(\"<unparsed>\"));\n       break;\n \n     case TRY_CATCH_EXPR:\n@@ -2224,7 +2228,7 @@ dump_expr (tree t, int flags)\n       pp_unsupported_tree (cxx_pp, t);\n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n-      pp_string (cxx_pp, _(\"<expression error>\"));\n+      pp_string (cxx_pp, M_(\"<expression error>\"));\n       break;\n     }\n }\n@@ -2238,7 +2242,7 @@ dump_binary_op (const char *opstring, tree t, int flags)\n   if (opstring)\n     pp_cxx_ws_string (cxx_pp, opstring);\n   else\n-    pp_string (cxx_pp, _(\"<unknown operator>\"));\n+    pp_string (cxx_pp, M_(\"<unknown operator>\"));\n   pp_cxx_whitespace (cxx_pp);\n   dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n   pp_cxx_right_paren (cxx_pp);\n@@ -2271,6 +2275,15 @@ reinit_cxx_pp (void)\n \n const char *\n type_as_string (tree typ, int flags)\n+{\n+  reinit_cxx_pp ();\n+  pp_translate_identifiers (cxx_pp) = false;\n+  dump_type (typ, flags);\n+  return pp_formatted_text (cxx_pp);\n+}\n+\n+const char *\n+type_as_string_translate (tree typ, int flags)\n {\n   reinit_cxx_pp ();\n   dump_type (typ, flags);\n@@ -2281,12 +2294,22 @@ const char *\n expr_as_string (tree decl, int flags)\n {\n   reinit_cxx_pp ();\n+  pp_translate_identifiers (cxx_pp) = false;\n   dump_expr (decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n const char *\n decl_as_string (tree decl, int flags)\n+{\n+  reinit_cxx_pp ();\n+  pp_translate_identifiers (cxx_pp) = false;\n+  dump_decl (decl, flags);\n+  return pp_formatted_text (cxx_pp);\n+}\n+\n+const char *\n+decl_as_string_translate (tree decl, int flags)\n {\n   reinit_cxx_pp ();\n   dump_decl (decl, flags);\n@@ -2296,12 +2319,15 @@ decl_as_string (tree decl, int flags)\n /* Generate the three forms of printable names for cxx_printable_name.  */\n \n const char *\n-lang_decl_name (tree decl, int v)\n+lang_decl_name (tree decl, int v, bool translate)\n {\n   if (v >= 2)\n-    return decl_as_string (decl, TFF_DECL_SPECIFIERS);\n+    return (translate\n+\t    ? decl_as_string_translate (decl, TFF_DECL_SPECIFIERS)\n+\t    : decl_as_string (decl, TFF_DECL_SPECIFIERS));\n \n   reinit_cxx_pp ();\n+  pp_translate_identifiers (cxx_pp) = translate;\n   if (v == 1 && DECL_CLASS_SCOPE_P (decl))\n     {\n       dump_type (CP_DECL_CONTEXT (decl), TFF_PLAIN_IDENTIFIER);\n@@ -2420,7 +2446,7 @@ static const char *\n op_to_string (enum tree_code p)\n {\n   tree id = operator_name_info[(int) p].identifier;\n-  return id ? IDENTIFIER_POINTER (id) : _(\"<unknown>\");\n+  return id ? IDENTIFIER_POINTER (id) : M_(\"<unknown>\");\n }\n \n static const char *\n@@ -2440,7 +2466,7 @@ static const char *\n assop_to_string (enum tree_code p)\n {\n   tree id = assignment_operator_name_info[(int) p].identifier;\n-  return id ? IDENTIFIER_POINTER (id) : _(\"{unknown}\");\n+  return id ? IDENTIFIER_POINTER (id) : M_(\"{unknown}\");\n }\n \n static const char *\n@@ -2454,7 +2480,7 @@ args_to_string (tree p, int verbose)\n     return \"\";\n \n   if (TYPE_P (TREE_VALUE (p)))\n-    return type_as_string (p, flags);\n+    return type_as_string_translate (p, flags);\n \n   reinit_cxx_pp ();\n   for (; p; p = TREE_CHAIN (p))\n@@ -2541,7 +2567,7 @@ cp_print_error_function (diagnostic_context *context,\n \t    fndecl = current_function_decl;\n \n \t  pp_printf (context->printer, function_category (fndecl),\n-\t\t     cxx_printable_name (fndecl, 2));\n+\t\t     cxx_printable_name_translate (fndecl, 2));\n \n \t  while (abstract_origin)\n \t    {\n@@ -2592,18 +2618,18 @@ cp_print_error_function (diagnostic_context *context,\n \t\t      if (flag_show_column && s.column != 0)\n \t\t\tpp_printf (context->printer,\n \t\t\t\t   _(\"    inlined from %qs at %s:%d:%d\"),\n-\t\t\t\t   cxx_printable_name (fndecl, 2),\n+\t\t\t\t   cxx_printable_name_translate (fndecl, 2),\n \t\t\t\t   s.file, s.line, s.column);\n \t\t      else\n \t\t\tpp_printf (context->printer,\n \t\t\t\t   _(\"    inlined from %qs at %s:%d\"),\n-\t\t\t\t   cxx_printable_name (fndecl, 2),\n+\t\t\t\t   cxx_printable_name_translate (fndecl, 2),\n \t\t\t\t   s.file, s.line);\n \n \t\t    }\n \t\t  else\n \t\t    pp_printf (context->printer, _(\"    inlined from %qs\"),\n-\t\t\t       cxx_printable_name (fndecl, 2));\n+\t\t\t       cxx_printable_name_translate (fndecl, 2));\n \t\t}\n \t    }\n \t  pp_base_character (context->printer, ':');\n@@ -2662,8 +2688,8 @@ print_instantiation_full_context (diagnostic_context *context)\n \t    pp_verbatim (context->printer,\n \t\t\t _(\"%s: In instantiation of %qs:\\n\"),\n \t\t\t LOCATION_FILE (location),\n-\t\t\t decl_as_string (p->decl,\n-\t\t\t\t\t TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n+\t\t\t decl_as_string_translate (p->decl,\n+\t\t\t\t\t\t   TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n \n \t  location = p->locus;\n \t  p = p->next;\n@@ -2686,8 +2712,8 @@ print_instantiation_partial_context (diagnostic_context *context,\n \tbreak;\n       pp_verbatim (context->printer, _(\"%s:%d:   instantiated from %qs\\n\"),\n \t\t   xloc.file, xloc.line,\n-\t\t   decl_as_string (t->decl,\n-\t\t\t\t   TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n+\t\t   decl_as_string_translate (t->decl,\n+\t\t\t\t\t     TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n       loc = t->locus;\n     }\n   pp_verbatim (context->printer, _(\"%s:%d:   instantiated from here\"),"}, {"sha": "1fc9469fcdff532af487f2619feca4b77e797afd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -428,8 +428,8 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n               /* Warn about the C++0x keyword (but still treat it as\n                  an identifier).  */\n               warning (OPT_Wc__0x_compat, \n-                       \"identifier %<%s%> will become a keyword in C++0x\",\n-                       IDENTIFIER_POINTER (token->u.value));\n+                       \"identifier %qE will become a keyword in C++0x\",\n+                       token->u.value);\n \n               /* Clear out the C_RID_CODE so we don't warn about this\n                  particular identifier-turned-keyword again.  */"}, {"sha": "9cc767da07c6500d8ac42c027bc83b08096214ac", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -1238,23 +1238,24 @@ build_overload (tree decl, tree chain)\n \f\n #define PRINT_RING_SIZE 4\n \n-const char *\n-cxx_printable_name (tree decl, int v)\n+static const char *\n+cxx_printable_name_internal (tree decl, int v, bool translate)\n {\n   static unsigned int uid_ring[PRINT_RING_SIZE];\n   static char *print_ring[PRINT_RING_SIZE];\n+  static bool trans_ring[PRINT_RING_SIZE];\n   static int ring_counter;\n   int i;\n \n   /* Only cache functions.  */\n   if (v < 2\n       || TREE_CODE (decl) != FUNCTION_DECL\n       || DECL_LANG_SPECIFIC (decl) == 0)\n-    return lang_decl_name (decl, v);\n+    return lang_decl_name (decl, v, translate);\n \n   /* See if this print name is lying around.  */\n   for (i = 0; i < PRINT_RING_SIZE; i++)\n-    if (uid_ring[i] == DECL_UID (decl))\n+    if (uid_ring[i] == DECL_UID (decl) && translate == trans_ring[i])\n       /* yes, so return it.  */\n       return print_ring[i];\n \n@@ -1273,10 +1274,23 @@ cxx_printable_name (tree decl, int v)\n   if (print_ring[ring_counter])\n     free (print_ring[ring_counter]);\n \n-  print_ring[ring_counter] = xstrdup (lang_decl_name (decl, v));\n+  print_ring[ring_counter] = xstrdup (lang_decl_name (decl, v, translate));\n   uid_ring[ring_counter] = DECL_UID (decl);\n+  trans_ring[ring_counter] = translate;\n   return print_ring[ring_counter];\n }\n+\n+const char *\n+cxx_printable_name (tree decl, int v)\n+{\n+  return cxx_printable_name_internal (decl, v, false);\n+}\n+\n+const char *\n+cxx_printable_name_translate (tree decl, int v)\n+{\n+  return cxx_printable_name_internal (decl, v, true);\n+}\n \f\n /* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n    listed in RAISES.  */"}, {"sha": "58f60d2b9c9a417d1282b44ab412a95a8c87cffd", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -1,3 +1,25 @@\n+2009-05-10  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* objc-act.c: Include intl.h.\n+\t(objc_lookup_protocol): Use complete sentences for diagnostics\n+\twith %qE for identifiers and translating results of\n+\tgen_type_name_0 to locale character set.\n+\t(objc_check_decl, check_protocol_recursively,\n+\tlookup_and_install_protocols, objc_build_string_object,\n+\tobjc_get_class_reference, objc_declare_alias, objc_declare_class,\n+\tobjc_get_class_ivars, error_with_ivar, check_duplicates,\n+\tobjc_finish_message_expr, objc_build_protocol_expr,\n+\tobjc_build_selector_expr, build_ivar_reference, objc_add_method,\n+\tadd_category, add_instance_variable, objc_is_public,\n+\tcheck_methods, check_methods_accessible, check_protocol,\n+\tstart_class, finish_class, start_protocol, really_start_method,\n+\tget_super_receiver, objc_lookup_ivar): Use %E and %qE for\n+\tidentifiers in diagnostics.  Translate generated text to locale\n+\tcharacter set as needed.\n+\t(check_protocol, check_protocols): Change name parameter to type\n+\ttree.\n+\t(lang_report_error_function): Remove.\n+\n 2009-04-27  Ian Lance Taylor  <iant@google.com>\n \n \t* objc-act.c (objc_gimplify_expr): Add casts to enum type."}, {"sha": "02bff7d17f195a6489592e72f980178b3584e248", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 123, "deletions": 140, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -69,6 +69,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"target.h\"\n #include \"diagnostic.h\"\n+#include \"intl.h\"\n #include \"cgraph.h\"\n #include \"tree-iterator.h\"\n #include \"libfuncs.h\"\n@@ -980,17 +981,17 @@ objc_lookup_protocol (tree proto, tree cls, tree typ, bool warn)\n \n   if (warn)\n     {\n-      strcpy (errbuf, class_type ? \"class \\'\" : \"type \\'\");\n+      *errbuf = 0;\n       gen_type_name_0 (class_type ? typ : TYPE_POINTER_TO (typ));\n-      strcat (errbuf, \"\\' does not \");\n       /* NB: Types 'id' and 'Class' cannot reasonably be described as\n \t \"implementing\" a given protocol, since they do not have an\n \t implementation.  */\n-      strcat (errbuf, class_type ? \"implement\" : \"conform to\");\n-      strcat (errbuf, \" the \\'\");\n-      strcat (errbuf, IDENTIFIER_POINTER (PROTOCOL_NAME (proto)));\n-      strcat (errbuf, \"\\' protocol\");\n-      warning (0, errbuf);\n+      if (class_type)\n+\twarning (0, \"class %qs does not implement the %qE protocol\",\n+\t\t identifier_to_locale (errbuf), PROTOCOL_NAME (proto));\n+      else\n+\twarning (0, \"type %qs does not conform to the %qE protocol\",\n+\t\t identifier_to_locale (errbuf), PROTOCOL_NAME (proto));\n     }\n \n   return false;\n@@ -1338,8 +1339,8 @@ objc_check_decl (tree decl)\n   if (TREE_CODE (type) != RECORD_TYPE)\n     return;\n   if (OBJC_TYPE_NAME (type) && (type = objc_is_class_name (OBJC_TYPE_NAME (type))))\n-    error (\"statically allocated instance of Objective-C class %qs\",\n-\t   IDENTIFIER_POINTER (type));\n+    error (\"statically allocated instance of Objective-C class %qE\",\n+\t   type);\n }\n \n /* Construct a PROTOCOLS-qualified variant of INTERFACE, where INTERFACE may\n@@ -1415,8 +1416,8 @@ check_protocol_recursively (tree proto, tree list)\n \tpp = lookup_protocol (pp);\n \n       if (pp == proto)\n-\tfatal_error (\"protocol %qs has circular dependency\",\n-\t\t     IDENTIFIER_POINTER (PROTOCOL_NAME (pp)));\n+\tfatal_error (\"protocol %qE has circular dependency\",\n+\t\t     PROTOCOL_NAME (pp));\n       if (pp)\n \tcheck_protocol_recursively (proto, PROTOCOL_LIST (pp));\n     }\n@@ -1440,8 +1441,8 @@ lookup_and_install_protocols (tree protocols)\n \treturn_value = chainon (return_value,\n \t\t\t\tbuild_tree_list (NULL_TREE, p));\n       else if (ident != error_mark_node)\n-\terror (\"cannot find protocol declaration for %qs\",\n-\t       IDENTIFIER_POINTER (ident));\n+\terror (\"cannot find protocol declaration for %qE\",\n+\t       ident);\n     }\n \n   return return_value;\n@@ -1904,17 +1905,17 @@ objc_build_string_object (tree string)\n       if (!constant_string_class\n \t  || !(constant_string_type\n \t       = CLASS_STATIC_TEMPLATE (constant_string_class)))\n-\terror (\"cannot find interface declaration for %qs\",\n-\t       IDENTIFIER_POINTER (constant_string_id));\n+\terror (\"cannot find interface declaration for %qE\",\n+\t       constant_string_id);\n       /* The NSConstantString/NXConstantString ivar layout is now known.  */\n       else if (!check_string_class_template ())\n-\terror (\"interface %qs does not have valid constant string layout\",\n-\t       IDENTIFIER_POINTER (constant_string_id));\n+\terror (\"interface %qE does not have valid constant string layout\",\n+\t       constant_string_id);\n       /* For the NeXT runtime, we can generate a literal reference\n \t to the string class, don't need to run a constructor.  */\n       else if (flag_next_runtime && !setup_string_decl ())\n-\terror (\"cannot find reference tag for class %qs\",\n-\t       IDENTIFIER_POINTER (constant_string_id));\n+\terror (\"cannot find reference tag for class %qE\",\n+\t       constant_string_id);\n       else\n \t{\n \t  string_layout_checked = 1;  /* Success!  */\n@@ -2753,8 +2754,8 @@ objc_get_class_reference (tree ident)\n \n   if (local_scope || !(ident = objc_is_class_name (ident)))\n     {\n-      error (\"%qs is not an Objective-C class name or alias\",\n-\t     IDENTIFIER_POINTER (orig_ident));\n+      error (\"%qE is not an Objective-C class name or alias\",\n+\t     orig_ident);\n       return error_mark_node;\n     }\n \n@@ -2886,9 +2887,9 @@ objc_declare_alias (tree alias_ident, tree class_ident)\n #endif /* OBJCPLUS */\n \n   if (!(underlying_class = objc_is_class_name (class_ident)))\n-    warning (0, \"cannot find class %qs\", IDENTIFIER_POINTER (class_ident));\n+    warning (0, \"cannot find class %qE\", class_ident);\n   else if (objc_is_class_name (alias_ident))\n-    warning (0, \"class %qs already exists\", IDENTIFIER_POINTER (alias_ident));\n+    warning (0, \"class %qE already exists\", alias_ident);\n   else\n     {\n       /* Implement @compatibility_alias as a typedef.  */\n@@ -2932,8 +2933,8 @@ objc_declare_class (tree ident_list)\n \t      if (!TYPE_HAS_OBJC_INFO (type)\n \t\t  || !TYPE_OBJC_INTERFACE (type))\n \t\t{\n-\t\t  error (\"%qs redeclared as different kind of symbol\",\n-\t\t\t IDENTIFIER_POINTER (ident));\n+\t\t  error (\"%qE redeclared as different kind of symbol\",\n+\t\t\t ident);\n \t\t  error (\"previous declaration of %q+D\",\n \t\t\t record);\n \t\t}\n@@ -3354,8 +3355,8 @@ objc_get_class_ivars (tree class_name)\n   if (interface)\n     return get_class_ivars (interface, true);\n \n-  error (\"cannot find interface declaration for %qs\",\n-\t IDENTIFIER_POINTER (class_name));\n+  error (\"cannot find interface declaration for %qE\",\n+\t class_name);\n \n   return error_mark_node;\n }\n@@ -4970,7 +4971,7 @@ static void\n error_with_ivar (const char *message, tree decl)\n {\n   error (\"%J%s %qs\", decl,\n-         message, gen_declaration (decl));\n+         message, identifier_to_locale (gen_declaration (decl)));\n \n }\n \n@@ -6103,23 +6104,23 @@ check_duplicates (hash hsh, int methods, int is_class)\n \t    {\n \t      bool type = TREE_CODE (meth) == INSTANCE_METHOD_DECL;\n \n-\t      warning (0, \"multiple methods named %<%c%s%> found\",\n+\t      warning (0, \"multiple methods named %<%c%E%> found\",\n \t\t       (is_class ? '+' : '-'),\n-\t\t       IDENTIFIER_POINTER (METHOD_SEL_NAME (meth)));\n+\t\t       METHOD_SEL_NAME (meth));\n \t      inform (0, \"%Jusing %<%c%s%>\", meth,\n \t\t      (type ? '-' : '+'),\n-\t\t      gen_method_decl (meth));\n+\t\t      identifier_to_locale (gen_method_decl (meth)));\n \t    }\n \t  else\n \t    {\n \t      bool type = TREE_CODE (meth) == INSTANCE_METHOD_DECL;\n \n-\t      warning (0, \"multiple selectors named %<%c%s%> found\",\n+\t      warning (0, \"multiple selectors named %<%c%E%> found\",\n \t\t       (is_class ? '+' : '-'),\n-\t\t       IDENTIFIER_POINTER (METHOD_SEL_NAME (meth)));\n+\t\t       METHOD_SEL_NAME (meth));\n \t      inform (0, \"%Jfound %<%c%s%>\", meth,\n \t\t      (type ? '-' : '+'),\n-\t\t      gen_method_decl (meth));\n+\t\t      identifier_to_locale (gen_method_decl (meth)));\n \t    }\n \n \t  for (loop = hsh->list; loop; loop = loop->next)\n@@ -6128,7 +6129,7 @@ check_duplicates (hash hsh, int methods, int is_class)\n \n \t      inform (0, \"%Jalso found %<%c%s%>\", loop->value, \n \t\t      (type ? '-' : '+'),\n-\t\t      gen_method_decl (loop->value));\n+\t\t      identifier_to_locale (gen_method_decl (loop->value)));\n \t    }\n         }\n     }\n@@ -6340,8 +6341,8 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t{\n \t  if (!CLASS_SUPER_NAME (implementation_template))\n \t    {\n-\t      error (\"no super class declared in @interface for %qs\",\n-\t\t     IDENTIFIER_POINTER (CLASS_NAME (implementation_template)));\n+\t      error (\"no super class declared in @interface for %qE\",\n+\t\t     CLASS_NAME (implementation_template));\n \t      return error_mark_node;\n \t    }\n \t  rtype = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n@@ -6378,9 +6379,8 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \t\t= lookup_method_in_protocol_list (rprotos, sel_name, 0);\n \n \t      if (method_prototype)\n-\t\twarning (0, \"found %<-%s%> instead of %<+%s%> in protocol(s)\",\n-\t\t\t IDENTIFIER_POINTER (sel_name),\n-\t\t\t IDENTIFIER_POINTER (sel_name));\n+\t\twarning (0, \"found %<-%E%> instead of %<+%E%> in protocol(s)\",\n+\t\t\t sel_name, sel_name);\n \t    }\n \t}\n     }\n@@ -6438,7 +6438,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n       else\n \t{\n \t  warning (0, \"invalid receiver type %qs\",\n-\t\t   gen_type_name (orig_rtype));\n+\t\t   identifier_to_locale (gen_type_name (orig_rtype)));\n \t  /* After issuing the \"invalid receiver\" warning, perform method\n \t     lookup as if we were messaging 'id'.  */\n \t  rtype = rprotos = NULL_TREE;\n@@ -6452,9 +6452,9 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n   if (!method_prototype)\n     {\n       if (rprotos)\n-\twarning (0, \"%<%c%s%> not found in protocol(s)\",\n+\twarning (0, \"%<%c%E%> not found in protocol(s)\",\n \t\t (class_tree ? '+' : '-'),\n-\t\t IDENTIFIER_POINTER (sel_name));\n+\t\t sel_name);\n \n       if (!rtype)\n \tmethod_prototype\n@@ -6466,17 +6466,17 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n       static bool warn_missing_methods = false;\n \n       if (rtype)\n-\twarning (0, \"%qs may not respond to %<%c%s%>\",\n-\t\t IDENTIFIER_POINTER (OBJC_TYPE_NAME (rtype)),\n+\twarning (0, \"%qE may not respond to %<%c%E%>\",\n+\t\t OBJC_TYPE_NAME (rtype),\n \t\t (class_tree ? '+' : '-'),\n-\t\t IDENTIFIER_POINTER (sel_name));\n+\t\t sel_name);\n       /* If we are messaging an 'id' or 'Class' object and made it here,\n \t then we have failed to find _any_ instance or class method,\n \t respectively.  */\n       else\n-\twarning (0, \"no %<%c%s%> method found\",\n+\twarning (0, \"no %<%c%E%> method found\",\n \t\t (class_tree ? '+' : '-'),\n-\t\t IDENTIFIER_POINTER (sel_name));\n+\t\t sel_name);\n \n       if (!warn_missing_methods)\n \t{\n@@ -6616,8 +6616,8 @@ objc_build_protocol_expr (tree protoname)\n \n   if (!p)\n     {\n-      error (\"cannot find protocol declaration for %qs\",\n-\t     IDENTIFIER_POINTER (protoname));\n+      error (\"cannot find protocol declaration for %qE\",\n+\t     protoname);\n       return error_mark_node;\n     }\n \n@@ -6716,7 +6716,7 @@ objc_build_selector_expr (tree selnamelist)\n       /* If still not found, print out a warning.  */\n       if (!hsh)\n \t{\n-\t  warning (0, \"undeclared selector %qs\", IDENTIFIER_POINTER (selname));\n+\t  warning (0, \"undeclared selector %qE\", selname);\n \t}\n     }\n \n@@ -6758,8 +6758,8 @@ build_ivar_reference (tree id)\n \t to an instance variable.  It's better to catch the cases\n \t where this is done unknowingly than to support the above\n \t paradigm.  */\n-      warning (0, \"instance variable %qs accessed in class method\",\n-\t       IDENTIFIER_POINTER (id));\n+      warning (0, \"instance variable %qE accessed in class method\",\n+\t       id);\n       self_decl = convert (objc_instance_type, self_decl); /* cast */\n     }\n \n@@ -6992,9 +6992,9 @@ objc_add_method (tree klass, tree method, int is_class)\n       if ((TREE_CODE (klass) == CLASS_INTERFACE_TYPE\n \t   || TREE_CODE (klass) == CATEGORY_INTERFACE_TYPE)\n \t  && !comp_proto_with_proto (method, mth, 1))\n-\terror (\"duplicate declaration of method %<%c%s%>\",\n+\terror (\"duplicate declaration of method %<%c%E%>\",\n \t\tis_class ? '+' : '-',\n-\t\tIDENTIFIER_POINTER (METHOD_SEL_NAME (mth)));\n+\t\tMETHOD_SEL_NAME (mth));\n     }\n \n   if (is_class)\n@@ -7053,9 +7053,9 @@ add_category (tree klass, tree category)\n \n   if (cat)\n     {\n-      warning (0, \"duplicate interface declaration for category %<%s(%s)%>\",\n-\t       IDENTIFIER_POINTER (CLASS_NAME (klass)),\n-\t       IDENTIFIER_POINTER (CLASS_SUPER_NAME (category)));\n+      warning (0, \"duplicate interface declaration for category %<%E(%E)%>\",\n+\t       CLASS_NAME (klass),\n+\t       CLASS_SUPER_NAME (category));\n     }\n   else\n     {\n@@ -7074,8 +7074,8 @@ add_instance_variable (tree klass, int visibility, tree field_decl)\n {\n   tree field_type = TREE_TYPE (field_decl);\n   const char *ivar_name = DECL_NAME (field_decl)\n-\t\t\t  ? IDENTIFIER_POINTER (DECL_NAME (field_decl))\n-\t\t\t  : \"<unnamed>\";\n+\t\t\t  ? identifier_to_locale (IDENTIFIER_POINTER (DECL_NAME (field_decl)))\n+\t\t\t  : _(\"<unnamed>\");\n \n #ifdef OBJCPLUS\n   if (TREE_CODE (field_type) == REFERENCE_TYPE)\n@@ -7106,7 +7106,7 @@ add_instance_variable (tree klass, int visibility, tree field_decl)\n \t  || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type)\n \t  || TYPE_POLYMORPHIC_P (field_type)))\n     {\n-      const char *type_name = IDENTIFIER_POINTER (OBJC_TYPE_NAME (field_type));\n+      tree type_name = OBJC_TYPE_NAME (field_type);\n \n       if (flag_objc_call_cxx_cdtors)\n         {\n@@ -7116,13 +7116,13 @@ add_instance_variable (tree klass, int visibility, tree field_decl)\n \t  if (TYPE_NEEDS_CONSTRUCTING (field_type)\n \t      && !TYPE_HAS_DEFAULT_CONSTRUCTOR (field_type))\n \t    {\n-\t      warning (0, \"type %qs has no default constructor to call\",\n+\t      warning (0, \"type %qE has no default constructor to call\",\n \t\t       type_name);\n \n \t      /* If we cannot call a constructor, we should also avoid\n \t\t calling the destructor, for symmetry.  */\n \t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type))\n-\t\twarning (0, \"destructor for %qs shall not be run either\",\n+\t\twarning (0, \"destructor for %qE shall not be run either\",\n \t\t\t type_name);\n \t    }\n         }\n@@ -7134,8 +7134,8 @@ add_instance_variable (tree klass, int visibility, tree field_decl)\n \t    {\n \t      /* Vtable pointers are Real Bad(tm), since Obj-C cannot\n \t\t initialize them.  */\n-\t      error (\"type %qs has virtual member functions\", type_name);\n-\t      error (\"illegal aggregate type %qs specified \"\n+\t      error (\"type %qE has virtual member functions\", type_name);\n+\t      error (\"illegal aggregate type %qE specified \"\n \t\t     \"for instance variable %qs\",\n \t\t     type_name, ivar_name);\n \t      /* Return class as is without adding this ivar.  */\n@@ -7145,9 +7145,9 @@ add_instance_variable (tree klass, int visibility, tree field_decl)\n \t  /* User-defined constructors and destructors are not known to Obj-C\n \t     and hence will not be called.  This may or may not be a problem. */\n \t  if (TYPE_NEEDS_CONSTRUCTING (field_type))\n-\t    warning (0, \"type %qs has a user-defined constructor\", type_name);\n+\t    warning (0, \"type %qE has a user-defined constructor\", type_name);\n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (field_type))\n-\t    warning (0, \"type %qs has a user-defined destructor\", type_name);\n+\t    warning (0, \"type %qE has a user-defined destructor\", type_name);\n \n \t  if (!warn_cxx_ivars)\n \t    {\n@@ -7231,8 +7231,8 @@ objc_is_public (tree expr, tree identifier)\n \n \t  if (!klass)\n \t    {\n-\t      error (\"cannot find interface declaration for %qs\",\n-\t\t     IDENTIFIER_POINTER (OBJC_TYPE_NAME (basetype)));\n+\t      error (\"cannot find interface declaration for %qE\",\n+\t\t     OBJC_TYPE_NAME (basetype));\n \t      return 0;\n \t    }\n \n@@ -7260,8 +7260,8 @@ objc_is_public (tree expr, tree identifier)\n \t\t      int priv = is_private (decl);\n \n \t\t      if (priv)\n-\t\t\terror (\"instance variable %qs is declared private\",\n-\t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t\t\terror (\"instance variable %qE is declared private\",\n+\t\t\t       DECL_NAME (decl));\n \n \t\t      return !priv;\n \t\t    }\n@@ -7271,15 +7271,15 @@ objc_is_public (tree expr, tree identifier)\n \t\t non-@public ivars.  We will let this slide for now...  */\n \t      if (!objc_method_context)\n \t      {\n-\t\twarning (0, \"instance variable %qs is %s; \"\n+\t\twarning (0, \"instance variable %qE is %s; \"\n \t\t\t \"this will be a hard error in the future\",\n-\t\t\t IDENTIFIER_POINTER (identifier),\n+\t\t\t identifier,\n \t\t\t TREE_PRIVATE (decl) ? \"@private\" : \"@protected\");\n \t\treturn 1;\n \t      }\n \n-\t      error (\"instance variable %qs is declared %s\",\n-\t\t     IDENTIFIER_POINTER (identifier),\n+\t      error (\"instance variable %qE is declared %s\",\n+\t\t     identifier,\n \t\t     TREE_PRIVATE (decl) ? \"private\" : \"protected\");\n \t      return 0;\n \t    }\n@@ -7304,17 +7304,17 @@ check_methods (tree chain, tree list, int mtype)\n \t    {\n \t      if (TREE_CODE (objc_implementation_context)\n \t\t  == CLASS_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of class %qs\",\n-\t\t\t IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context)));\n+\t\twarning (0, \"incomplete implementation of class %qE\",\n+\t\t\t CLASS_NAME (objc_implementation_context));\n \t      else if (TREE_CODE (objc_implementation_context)\n \t\t       == CATEGORY_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of category %qs\",\n-\t\t\t IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context)));\n+\t\twarning (0, \"incomplete implementation of category %qE\",\n+\t\t\t CLASS_SUPER_NAME (objc_implementation_context));\n \t      first = 0;\n \t    }\n \n-\t  warning (0, \"method definition for %<%c%s%> not found\",\n-\t\t   mtype, IDENTIFIER_POINTER (METHOD_SEL_NAME (chain)));\n+\t  warning (0, \"method definition for %<%c%E%> not found\",\n+\t\t   mtype, METHOD_SEL_NAME (chain));\n \t}\n \n       chain = TREE_CHAIN (chain);\n@@ -7392,18 +7392,16 @@ check_methods_accessible (tree chain, tree context, int mtype)\n \t    {\n \t      if (TREE_CODE (objc_implementation_context)\n \t\t  == CLASS_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of class %qs\",\n-\t\t\t IDENTIFIER_POINTER\n-\t\t\t   (CLASS_NAME (objc_implementation_context)));\n+\t\twarning (0, \"incomplete implementation of class %qE\",\n+\t\t\t CLASS_NAME (objc_implementation_context));\n \t      else if (TREE_CODE (objc_implementation_context)\n \t\t       == CATEGORY_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of category %qs\",\n-\t\t\t IDENTIFIER_POINTER\n-\t\t\t   (CLASS_SUPER_NAME (objc_implementation_context)));\n+\t\twarning (0, \"incomplete implementation of category %qE\",\n+\t\t\t CLASS_SUPER_NAME (objc_implementation_context));\n \t      first = 0;\n \t    }\n-\t  warning (0, \"method definition for %<%c%s%> not found\",\n-\t\t   mtype, IDENTIFIER_POINTER (METHOD_SEL_NAME (chain)));\n+\t  warning (0, \"method definition for %<%c%E%> not found\",\n+\t\t   mtype, METHOD_SEL_NAME (chain));\n \t}\n \n       chain = TREE_CHAIN (chain); /* next method...  */\n@@ -7416,7 +7414,7 @@ check_methods_accessible (tree chain, tree context, int mtype)\n    with any protocols that P inherits.  */\n \n static void\n-check_protocol (tree p, const char *type, const char *name)\n+check_protocol (tree p, const char *type, tree name)\n {\n   if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n     {\n@@ -7443,8 +7441,8 @@ check_protocol (tree p, const char *type, const char *name)\n \t}\n \n       if (!f1 || !f2)\n-\twarning (0, \"%s %qs does not fully implement the %qs protocol\",\n-\t\t type, name, IDENTIFIER_POINTER (PROTOCOL_NAME (p)));\n+\twarning (0, \"%s %qE does not fully implement the %qE protocol\",\n+\t\t type, name, PROTOCOL_NAME (p));\n     }\n \n   /* Check protocols recursively.  */\n@@ -7472,7 +7470,7 @@ check_protocol (tree p, const char *type, const char *name)\n    in PROTO_LIST.  */\n \n static void\n-check_protocols (tree proto_list, const char *type, const char *name)\n+check_protocols (tree proto_list, const char *type, tree name)\n {\n   for ( ; proto_list; proto_list = TREE_CHAIN (proto_list))\n     {\n@@ -7520,9 +7518,9 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \n       if (!super || !lookup_interface (super))\n \t{\n-\t  error (\"cannot find interface declaration for %qs, superclass of %qs\",\n-\t\t IDENTIFIER_POINTER (super ? super : super_name),\n-\t\t IDENTIFIER_POINTER (class_name));\n+\t  error (\"cannot find interface declaration for %qE, superclass of %qE\",\n+\t\t super ? super : super_name,\n+\t\t class_name);\n \t  super_name = NULL_TREE;\n \t}\n       else\n@@ -7536,8 +7534,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n   if (! objc_is_class_name (class_name)\n       && (decl = lookup_name (class_name)))\n     {\n-      error (\"%qs redeclared as different kind of symbol\",\n-\t     IDENTIFIER_POINTER (class_name));\n+      error (\"%qE redeclared as different kind of symbol\",\n+\t     class_name);\n       error (\"previous declaration of %q+D\",\n \t     decl);\n     }\n@@ -7550,8 +7548,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n         for (chain = implemented_classes; chain; chain = TREE_CHAIN (chain))\n            if (TREE_VALUE (chain) == class_name)\n \t     {\n-\t       error (\"reimplementation of class %qs\",\n-\t\t      IDENTIFIER_POINTER (class_name));\n+\t       error (\"reimplementation of class %qE\",\n+\t\t      class_name);\n \t       return error_mark_node;\n \t     }\n         implemented_classes = tree_cons (NULL_TREE, class_name,\n@@ -7567,8 +7565,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \n       if (!(implementation_template = lookup_interface (class_name)))\n         {\n-\t  warning (0, \"cannot find interface declaration for %qs\",\n-\t\t   IDENTIFIER_POINTER (class_name));\n+\t  warning (0, \"cannot find interface declaration for %qE\",\n+\t\t   class_name);\n \t  add_class (implementation_template = objc_implementation_context,\n \t\t     class_name);\n         }\n@@ -7580,11 +7578,12 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t  && (super_name != CLASS_SUPER_NAME (implementation_template)))\n         {\n \t  tree previous_name = CLASS_SUPER_NAME (implementation_template);\n-          const char *const name =\n-\t    previous_name ? IDENTIFIER_POINTER (previous_name) : \"\";\n-\t  error (\"conflicting super class name %qs\",\n-\t\t IDENTIFIER_POINTER (super_name));\n-\t  error (\"previous declaration of %qs\", name);\n+\t  error (\"conflicting super class name %qE\",\n+\t\t super_name);\n+\t  if (previous_name)\n+\t    error (\"previous declaration of %qE\", previous_name);\n+\t  else\n+\t    error (\"previous declaration\");\n         }\n \n       else if (! super_name)\n@@ -7598,11 +7597,11 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n     {\n       if (lookup_interface (class_name))\n #ifdef OBJCPLUS\n-\terror (\"duplicate interface declaration for class %qs\",\n+\terror (\"duplicate interface declaration for class %qE\",\n #else\n-\twarning (0, \"duplicate interface declaration for class %qs\",\n+\twarning (0, \"duplicate interface declaration for class %qE\",\n #endif\n-        IDENTIFIER_POINTER (class_name));\n+        class_name);\n       else\n         add_class (klass, class_name);\n \n@@ -7621,8 +7620,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \n       if (!(class_category_is_assoc_with = lookup_interface (class_name)))\n \t{\n-\t  error (\"cannot find interface declaration for %qs\",\n-\t\t IDENTIFIER_POINTER (class_name));\n+\t  error (\"cannot find interface declaration for %qE\",\n+\t\t class_name);\n \t  exit (FATAL_EXIT_CODE);\n \t}\n       else\n@@ -7646,8 +7645,8 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \n       if (!(implementation_template = lookup_interface (class_name)))\n         {\n-\t  error (\"cannot find interface declaration for %qs\",\n-\t\t IDENTIFIER_POINTER (class_name));\n+\t  error (\"cannot find interface declaration for %qE\",\n+\t\t class_name);\n \t  exit (FATAL_EXIT_CODE);\n         }\n     }\n@@ -7741,7 +7740,7 @@ finish_class (tree klass)\n \t  if (CLASS_PROTOCOL_LIST (implementation_template))\n \t    check_protocols (CLASS_PROTOCOL_LIST (implementation_template),\n \t\t\t     \"class\",\n-\t\t\t     IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context)));\n+\t\t\t     CLASS_NAME (objc_implementation_context));\n \t}\n     }\n \n@@ -7760,7 +7759,7 @@ finish_class (tree klass)\n \t  if (CLASS_PROTOCOL_LIST (category))\n \t    check_protocols (CLASS_PROTOCOL_LIST (category),\n \t\t\t     \"category\",\n-\t\t\t     IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context)));\n+\t\t\t     CLASS_SUPER_NAME (objc_implementation_context));\n \t}\n     }\n }\n@@ -7854,8 +7853,8 @@ start_protocol (enum tree_code code, tree name, tree list)\n     }\n   else\n     {\n-      warning (0, \"duplicate declaration for protocol %qs\",\n-\t       IDENTIFIER_POINTER (name));\n+      warning (0, \"duplicate declaration for protocol %qE\",\n+\t       name);\n     }\n   return protocol;\n }\n@@ -8684,10 +8683,10 @@ really_start_method (tree method,\n \n \t      warning (0, \"%Jconflicting types for %<%c%s%>\", method,\n \t\t       (type ? '-' : '+'),\n-\t\t       gen_method_decl (method));\n+\t\t       identifier_to_locale (gen_method_decl (method)));\n \t      inform (0, \"%Jprevious declaration of %<%c%s%>\", proto,\n \t\t      (type ? '-' : '+'),\n-\t\t      gen_method_decl (proto));\n+\t\t      identifier_to_locale (gen_method_decl (proto)));\n \t    }\n \t}\n       else\n@@ -8771,8 +8770,8 @@ get_super_receiver (void)\n \t  /* Barf if super used in a category of Object.  */\n \t  if (!super_name)\n \t    {\n-\t      error (\"no super class declared in interface for %qs\",\n-\t\t    IDENTIFIER_POINTER (CLASS_NAME (implementation_template)));\n+\t      error (\"no super class declared in interface for %qE\",\n+\t\t     CLASS_NAME (implementation_template));\n \t      return error_mark_node;\n \t    }\n \n@@ -8866,22 +8865,6 @@ objc_finish_method_definition (tree fndecl)\n     warning (0, \"method possibly missing a [super dealloc] call\");\n }\n \n-#if 0\n-int\n-lang_report_error_function (tree decl)\n-{\n-  if (objc_method_context)\n-    {\n-      fprintf (stderr, \"In method %qs\\n\",\n-\t       IDENTIFIER_POINTER (METHOD_SEL_NAME (objc_method_context)));\n-      return 1;\n-    }\n-\n-  else\n-    return 0;\n-}\n-#endif\n-\n /* Given a tree DECL node, produce a printable description of it in the given\n    buffer, overwriting the buffer.  */\n \n@@ -9493,8 +9476,8 @@ objc_lookup_ivar (tree other, tree id)\n       && !DECL_FILE_SCOPE_P (other))\n #endif\n     {\n-      warning (0, \"local declaration of %qs hides instance variable\",\n-\t       IDENTIFIER_POINTER (id));\n+      warning (0, \"local declaration of %qE hides instance variable\",\n+\t       id);\n \n       return other;\n     }"}, {"sha": "55bc3feeeac17475308d11eaf38e1f9155a4ef7e", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -719,6 +719,7 @@ pp_construct (pretty_printer *pp, const char *prefix, int maximum_length)\n   pp_line_cutoff (pp) = maximum_length;\n   pp_prefixing_rule (pp) = DIAGNOSTICS_SHOW_PREFIX_ONCE;\n   pp_set_prefix (pp, prefix);\n+  pp_translate_identifiers (pp) = true;\n }\n \n /* Append a string delimited by START and END to the output area of\n@@ -855,8 +856,14 @@ pp_base_maybe_space (pretty_printer *pp)\n void\n pp_base_tree_identifier (pretty_printer *pp, tree id)\n {\n-  const char *text = identifier_to_locale (IDENTIFIER_POINTER (id));\n-  pp_append_text (pp, text, text + strlen (text));\n+  if (pp_translate_identifiers (pp))\n+    {\n+      const char *text = identifier_to_locale (IDENTIFIER_POINTER (id));\n+      pp_append_text (pp, text, text + strlen (text));\n+    }\n+  else\n+    pp_append_text (pp, IDENTIFIER_POINTER (id),\n+\t\t    IDENTIFIER_POINTER (id) + IDENTIFIER_LENGTH (id));\n }\n \f\n /* The string starting at P has LEN (at least 1) bytes left; if they"}, {"sha": "5c4ddca80434154cfc41db7b843ff6853147620f", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -148,6 +148,10 @@ typedef bool (*printer_fn) (pretty_printer *, text_info *, const char *,\n /* The amount of whitespace to be emitted when starting a new line.  */\n #define pp_indentation(PP) pp_base (PP)->indent_skip\n \n+/* True if identifiers are translated to the locale character set on\n+   output.  */\n+#define pp_translate_identifiers(PP) pp_base (PP)->translate_identifiers\n+\n /* The data structure that contains the bare minimum required to do\n    proper pretty-printing.  Clients may derived from this structure\n    and add additional fields they need.  */\n@@ -187,6 +191,10 @@ struct pretty_print_info\n \n   /* Nonzero means one should emit a newline before outputting anything.  */\n   bool need_newline;\n+\n+  /* Nonzero means identifiers are translated to the locale character\n+     set on output.  */\n+  bool translate_identifiers;\n };\n \n #define pp_set_line_maximum_length(PP, L) \\\n@@ -273,7 +281,9 @@ struct pretty_print_info\n    pp_scalar (PP, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT) I)\n #define pp_pointer(PP, P)      pp_scalar (PP, \"%p\", P)\n \n-#define pp_identifier(PP, ID)  pp_string (PP, identifier_to_locale (ID))\n+#define pp_identifier(PP, ID)  pp_string (PP, (pp_translate_identifiers (PP) \\\n+\t\t\t\t\t  ? identifier_to_locale (ID)\t\\\n+\t\t\t\t\t  : (ID)))\n #define pp_tree_identifier(PP, T)                      \\\n   pp_base_tree_identifier (pp_base (PP), T)\n "}, {"sha": "d9d31eee79b13f5fe2507445d012fe56a6b8c151", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41c4af3d6936f7153b65c23ba80c81f7f8c518e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=f41c4af3d6936f7153b65c23ba80c81f7f8c518e", "patch": "@@ -2767,6 +2767,7 @@ maybe_init_pretty_print (FILE *file)\n     {\n       pp_construct (&buffer, /* prefix */NULL, /* line-width */0);\n       pp_needs_newline (&buffer) = true;\n+      pp_translate_identifiers (&buffer) = false;\n       initialized = 1;\n     }\n "}]}