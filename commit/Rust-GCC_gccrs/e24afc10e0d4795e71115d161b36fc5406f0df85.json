{"sha": "e24afc10e0d4795e71115d161b36fc5406f0df85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI0YWZjMTBlMGQ0Nzk1ZTcxMTE1ZDE2MWIzNmZjNTQwNmYwZGY4NQ==", "commit": {"author": {"name": "Tristan Gingold", "email": "gingold@adacore.com", "date": "2015-05-29T08:40:20Z"}, "committer": {"name": "Tristan Gingold", "email": "gingold@gcc.gnu.org", "date": "2015-05-29T08:40:20Z"}, "message": "libbacktrace: add support of PE/COFF\n\nlibbacktrace/\n2015-05-29  Tristan Gingold  <gingold@adacore.com>\n\n\t* pecoff.c: New file.\n\t* Makefile.am (FORMAT_FILES): Add pecoff.c and dependencies.\n\t* Makefile.in: Regenerate.\n\t* filetype.awk: Detect pecoff.\n\t* configure.ac: Define BACKTRACE_SUPPORTS_DATA on elf platforms.\n\tAdd pecoff.\n\t* btest.c (test5): Test enabled only if BACKTRACE_SUPPORTS_DATA is\n\ttrue.\n\t* backtrace-supported.h.in (BACKTRACE_SUPPORTS_DATA): Define.\n\t* configure: Regenerate.\n\t* pecoff.c: New file.\n\nFrom-SVN: r223859", "tree": {"sha": "d6375a46135746eb6a0b5529013ddbf4b0267ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6375a46135746eb6a0b5529013ddbf4b0267ad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e24afc10e0d4795e71115d161b36fc5406f0df85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24afc10e0d4795e71115d161b36fc5406f0df85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24afc10e0d4795e71115d161b36fc5406f0df85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24afc10e0d4795e71115d161b36fc5406f0df85/comments", "author": {"login": "gingold-adacore", "id": 16334725, "node_id": "MDQ6VXNlcjE2MzM0NzI1", "avatar_url": "https://avatars.githubusercontent.com/u/16334725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gingold-adacore", "html_url": "https://github.com/gingold-adacore", "followers_url": "https://api.github.com/users/gingold-adacore/followers", "following_url": "https://api.github.com/users/gingold-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/gingold-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/gingold-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gingold-adacore/subscriptions", "organizations_url": "https://api.github.com/users/gingold-adacore/orgs", "repos_url": "https://api.github.com/users/gingold-adacore/repos", "events_url": "https://api.github.com/users/gingold-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/gingold-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c469078de7c017978bda033baff3e991987b5509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c469078de7c017978bda033baff3e991987b5509", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c469078de7c017978bda033baff3e991987b5509"}], "stats": {"total": 995, "additions": 993, "deletions": 2}, "files": [{"sha": "e105e38ee957ee710f52175ca5c92a0bd372f2e9", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -1,3 +1,17 @@\n+2015-05-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* pecoff.c: New file.\n+\t* Makefile.am (FORMAT_FILES): Add pecoff.c and dependencies.\n+\t* Makefile.in: Regenerate.\n+\t* filetype.awk: Detect pecoff.\n+\t* configure.ac: Define BACKTRACE_SUPPORTS_DATA on elf platforms.\n+\tAdd pecoff.\n+\t* btest.c (test5): Test enabled only if BACKTRACE_SUPPORTS_DATA is\n+\ttrue.\n+\t* backtrace-supported.h.in (BACKTRACE_SUPPORTS_DATA): Define.\n+\t* configure: Regenerate.\n+\t* pecoff.c: New file.\n+\n 2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n \n \t* Makefile.in: Regenerated with automake-1.11.6."}, {"sha": "c5f0dcbcf7a19157326dec3e9e408d4cdafd8e60", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -56,6 +56,7 @@ BACKTRACE_FILES = \\\n \n FORMAT_FILES = \\\n \telf.c \\\n+\tpecoff.c \\\n \tunknown.c\n \n VIEW_FILES = \\\n@@ -124,6 +125,7 @@ fileline.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n nounwind.lo: config.h internal.h\n+pecoff.lo: config.h backtrace.h internal.h\n posix.lo: config.h backtrace.h internal.h\n print.lo: config.h backtrace.h internal.h\n read.lo: config.h backtrace.h internal.h"}, {"sha": "b434d76edb620e81aa048bdea1019c0fd8213a4a", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -299,6 +299,7 @@ BACKTRACE_FILES = \\\n \n FORMAT_FILES = \\\n \telf.c \\\n+\tpecoff.c \\\n \tunknown.c\n \n VIEW_FILES = \\\n@@ -753,6 +754,7 @@ fileline.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n nounwind.lo: config.h internal.h\n+pecoff.lo: config.h backtrace.h internal.h\n posix.lo: config.h backtrace.h internal.h\n print.lo: config.h backtrace.h internal.h\n read.lo: config.h backtrace.h internal.h"}, {"sha": "ab051a1689826ba57d4bdf8688beb1a643a97e98", "filename": "libbacktrace/backtrace-supported.h.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbacktrace-supported.h.in?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -59,3 +59,8 @@ POSSIBILITY OF SUCH DAMAGE.  */\n    as 0.  */\n \n #define BACKTRACE_SUPPORTS_THREADS @BACKTRACE_SUPPORTS_THREADS@\n+\n+/* BACKTRACE_SUPPORTS_DATA will be #defined'd as 1 if the backtrace_syminfo\n+   will work for variables.  It will always work for functions.  */\n+\n+#define BACKTRACE_SUPPORTS_DATA @BACKTRACE_SUPPORTS_DATA@"}, {"sha": "9821e34c0c1ba69c48b98e71b75e46533c8a030e", "filename": "libbacktrace/btest.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fbtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbtest.c?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -616,6 +616,8 @@ f33 (int f1line, int f2line)\n   return failures;\n }\n \n+#if BACKTRACE_SUPPORTS_DATA\n+\n int global = 1;\n \n static int\n@@ -684,6 +686,8 @@ test5 (void)\n   return failures;\n }\n \n+#endif /* BACKTRACE_SUPPORTS_DATA  */\n+\n static void\n error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n \t\t       int errnum)\n@@ -708,7 +712,9 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n   test2 ();\n   test3 ();\n   test4 ();\n+#if BACKTRACE_SUPPORTS_DATA\n   test5 ();\n+#endif\n #endif\n \n   exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);"}, {"sha": "19418c91e003d444a1d32ca0da446fcacff1a503", "filename": "libbacktrace/configure", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -607,6 +607,7 @@ NATIVE_TRUE\n BACKTRACE_USES_MALLOC\n ALLOC_FILE\n VIEW_FILE\n+BACKTRACE_SUPPORTS_DATA\n BACKTRACE_SUPPORTED\n FORMAT_FILE\n BACKTRACE_SUPPORTS_THREADS\n@@ -11129,7 +11130,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11132 \"configure\"\n+#line 11133 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11235,7 +11236,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11238 \"configure\"\n+#line 11239 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11826,8 +11827,12 @@ $as_echo \"$libbacktrace_cv_sys_filetype\" >&6; }\n \n # Match the file type to decide what files to compile.\n FORMAT_FILE=\n+backtrace_supports_data=yes\n case \"$libbacktrace_cv_sys_filetype\" in\n elf*) FORMAT_FILE=\"elf.lo\" ;;\n+pecoff) FORMAT_FILE=\"pecoff.lo\"\n+        backtrace_supports_data=no\n+\t;;\n *) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: could not determine output file type\" >&5\n $as_echo \"$as_me: WARNING: could not determine output file type\" >&2;}\n    FORMAT_FILE=\"unknown.lo\"\n@@ -11841,6 +11846,7 @@ elfsize=\n case \"$libbacktrace_cv_sys_filetype\" in\n elf32) elfsize=32 ;;\n elf64) elfsize=64 ;;\n+*)     elfsize=unused\n esac\n \n cat >>confdefs.h <<_ACEOF\n@@ -11854,6 +11860,12 @@ if test \"$backtrace_supported\" = \"yes\"; then\n fi\n \n \n+BACKTRACE_SUPPORTS_DATA=0\n+if test \"$backtrace_supports_data\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_DATA=1\n+fi\n+\n+\n \n \n inttype_headers=`echo inttypes.h sys/inttypes.h  | sed -e 's/,/ /g'`"}, {"sha": "2e5b9c7cb7f3fa0cf13910e962c7a2d939db285f", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -229,8 +229,12 @@ libbacktrace_cv_sys_filetype=$filetype])\n \n # Match the file type to decide what files to compile.\n FORMAT_FILE=\n+backtrace_supports_data=yes\n case \"$libbacktrace_cv_sys_filetype\" in\n elf*) FORMAT_FILE=\"elf.lo\" ;;\n+pecoff) FORMAT_FILE=\"pecoff.lo\"\n+        backtrace_supports_data=no\n+\t;;\n *) AC_MSG_WARN([could not determine output file type])\n    FORMAT_FILE=\"unknown.lo\"\n    backtrace_supported=no\n@@ -243,6 +247,7 @@ elfsize=\n case \"$libbacktrace_cv_sys_filetype\" in\n elf32) elfsize=32 ;;\n elf64) elfsize=64 ;;\n+*)     elfsize=unused\n esac\n AC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n \n@@ -252,6 +257,12 @@ if test \"$backtrace_supported\" = \"yes\"; then\n fi\n AC_SUBST(BACKTRACE_SUPPORTED)\n \n+BACKTRACE_SUPPORTS_DATA=0\n+if test \"$backtrace_supports_data\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_DATA=1\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTS_DATA)\n+\n GCC_HEADER_STDINT(gstdint.h)\n \n AC_CHECK_HEADERS(sys/mman.h)"}, {"sha": "57bab797a9a8abc1a1310ec077786f499775cfaa", "filename": "libbacktrace/filetype.awk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffiletype.awk?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -1,3 +1,5 @@\n # An awk script to determine the type of a file.\n /\\177ELF\\001/ { if (NR == 1) { print \"elf32\"; exit } }\n /\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }\n+/\\114\\001/    { if (NR == 1) { print \"pecoff\"; exit } }\n+/\\144\\206/    { if (NR == 1) { print \"pecoff\"; exit } }"}, {"sha": "ba555b56582804ccf1dc6da0e3ceb24a1dd6d29d", "filename": "libbacktrace/pecoff.c", "status": "added", "additions": 937, "deletions": 0, "changes": 937, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fpecoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e24afc10e0d4795e71115d161b36fc5406f0df85/libbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fpecoff.c?ref=e24afc10e0d4795e71115d161b36fc5406f0df85", "patch": "@@ -0,0 +1,937 @@\n+/* pecoff.c -- Get debug data from a PE/COFFF file for backtraces.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Adapted from elf.c by Tristan Gingold, AdaCore.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Coff file header.  */\n+\n+typedef struct {\n+  uint16_t machine;\n+  uint16_t number_of_sections;\n+  uint32_t time_date_stamp;\n+  uint32_t pointer_to_symbol_table;\n+  uint32_t number_of_symbols;\n+  uint16_t size_of_optional_header;\n+  uint16_t characteristics;\n+} b_coff_file_header;\n+\n+/* Coff optional header.  */\n+\n+typedef struct {\n+  uint16_t magic;\n+  uint8_t  major_linker_version;\n+  uint8_t  minor_linker_version;\n+  uint32_t size_of_code;\n+  uint32_t size_of_initialized_data;\n+  uint32_t size_of_uninitialized_data;\n+  uint32_t address_of_entry_point;\n+  uint32_t base_of_code;\n+  union {\n+    struct {\n+      uint32_t base_of_data;\n+      uint32_t image_base;\n+    } pe;\n+    struct {\n+      uint64_t image_base;\n+    } pep;\n+  } u;\n+} b_coff_optional_header;\n+\n+/* Values of magic in optional header.  */\n+\n+#define PE_MAGIC 0x10b\t\t/* PE32 executable.  */\n+#define PEP_MAGIC 0x20b\t\t/* PE32+ executable (for 64bit targets).  */\n+\n+/* Coff section header.  */\n+\n+typedef struct {\n+  char name[8];\n+  uint32_t virtual_size;\n+  uint32_t virtual_address;\n+  uint32_t size_of_raw_data;\n+  uint32_t pointer_to_raw_data;\n+  uint32_t pointer_to_relocations;\n+  uint32_t pointer_to_line_numbers;\n+  uint16_t number_of_relocations;\n+  uint16_t number_of_line_numbers;\n+  uint32_t characteristics;\n+} b_coff_section_header;\n+\n+/* Coff symbol name.  */\n+\n+typedef union {\n+  char short_name[8];\n+  struct {\n+    unsigned char zeroes[4];\n+    unsigned char off[4];\n+  } long_name;\n+} b_coff_name;\n+\n+/* Coff symbol (external representation which is unaligned).  */\n+\n+typedef struct {\n+  b_coff_name name;\n+  unsigned char value[4];\n+  unsigned char section_number[2];\n+  unsigned char type[2];\n+  unsigned char storage_class;\n+  unsigned char number_of_aux_symbols;\n+} b_coff_external_symbol;\n+\n+/* Symbol types.  */\n+\n+#define N_TBSHFT 4\t\t\t/* Shift for the derived type.  */\n+#define IMAGE_SYM_DTYPE_FUNCTION 2\t/* Function derived type.  */\n+\n+/* Size of a coff symbol.  */\n+\n+#define SYM_SZ 18\n+\n+/* Coff symbol, internal representation (aligned).  */\n+\n+typedef struct {\n+  const char *name;\n+  uint32_t value;\n+  int16_t sec;\n+  uint16_t type;\n+  uint16_t sc;\n+} b_coff_internal_symbol;\n+\n+/* An index of sections we care about.  */\n+\n+enum debug_section\n+{\n+  DEBUG_INFO,\n+  DEBUG_LINE,\n+  DEBUG_ABBREV,\n+  DEBUG_RANGES,\n+  DEBUG_STR,\n+  DEBUG_MAX\n+};\n+\n+/* Names of sections, indexed by enum debug_section.  */\n+\n+static const char * const debug_section_names[DEBUG_MAX] =\n+{\n+  \".debug_info\",\n+  \".debug_line\",\n+  \".debug_abbrev\",\n+  \".debug_ranges\",\n+  \".debug_str\"\n+};\n+\n+/* Information we gather for the sections we care about.  */\n+\n+struct debug_section_info\n+{\n+  /* Section file offset.  */\n+  off_t offset;\n+  /* Section size.  */\n+  size_t size;\n+  /* Section contents, after read from file.  */\n+  const unsigned char *data;\n+};\n+\n+/* Information we keep for an coff symbol.  */\n+\n+struct coff_symbol\n+{\n+  /* The name of the symbol.  */\n+  const char *name;\n+  /* The address of the symbol.  */\n+  uintptr_t address;\n+};\n+\n+/* Information to pass to coff_syminfo.  */\n+\n+struct coff_syminfo_data\n+{\n+  /* Symbols for the next module.  */\n+  struct coff_syminfo_data *next;\n+  /* The COFF symbols, sorted by address.  */\n+  struct coff_symbol *symbols;\n+  /* The number of symbols.  */\n+  size_t count;\n+};\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+coff_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t      uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t      backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in PE/COFF executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+coff_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t     uintptr_t addr ATTRIBUTE_UNUSED,\n+\t     backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t     backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in PE/COFF executable\", -1);\n+}\n+\n+/* Read a potentially unaligned 4 byte word at P, using native endianness.  */\n+\n+static uint32_t\n+coff_read4 (const unsigned char *p)\n+{\n+  uint32_t res;\n+\n+  memcpy (&res, p, 4);\n+  return res;\n+}\n+\n+/* Read a potentially unaligned 2 byte word at P, using native endianness.\n+   All 2 byte word in symbols are always aligned, but for coherency all\n+   fields are declared as char arrays.  */\n+\n+static uint16_t\n+coff_read2 (const unsigned char *p)\n+{\n+  uint16_t res;\n+\n+  memcpy (&res, p, sizeof (res));\n+  return res;\n+}\n+\n+/* Return the length (without the trailing 0) of a COFF short name.  */\n+\n+static size_t\n+coff_short_name_len (const char *name)\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    if (name[i] == 0)\n+      return i;\n+  return 8;\n+}\n+\n+/* Return true iff COFF short name CNAME is the same as NAME (a NUL-terminated\n+   string).  */\n+\n+static int\n+coff_short_name_eq (const char *name, const char *cname)\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      if (name[i] != cname[i])\n+\treturn 0;\n+      if (name[i] == 0)\n+\treturn 1;\n+    }\n+  return name[8] == 0;\n+}\n+\n+/* Return true iff NAME is the same as string at offset OFF.  */\n+\n+static int\n+coff_long_name_eq (const char *name, unsigned int off,\n+\t\t   struct backtrace_view *str_view)\n+{\n+  if (off >= str_view->len)\n+    return 0;\n+  return strcmp (name, (const char *)str_view->data + off) == 0;\n+}\n+\n+/* Compare struct coff_symbol for qsort.  */\n+\n+static int\n+coff_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct coff_symbol *e1 = (const struct coff_symbol *) v1;\n+  const struct coff_symbol *e2 = (const struct coff_symbol *) v2;\n+\n+  if (e1->address < e2->address)\n+    return -1;\n+  else if (e1->address > e2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Convert SYM to internal (and aligned) format ISYM, using string table\n+   from STRTAB and STRTAB_SIZE, and number of sections SECTS_NUM.\n+   Return -1 in case of error (invalid section number or string index).  */\n+\n+static int\n+coff_expand_symbol (b_coff_internal_symbol *isym,\n+\t\t    const b_coff_external_symbol *sym,\n+\t\t    uint16_t sects_num,\n+\t\t    const unsigned char *strtab, size_t strtab_size)\n+{\n+  isym->type = coff_read2 (sym->type);\n+  isym->sec = coff_read2 (sym->section_number);\n+  isym->sc = sym->storage_class;\n+\n+  if (isym->sec > 0 && (uint16_t) isym->sec > sects_num)\n+    return -1;\n+  if (sym->name.short_name[0] != 0)\n+    isym->name = sym->name.short_name;\n+  else\n+    {\n+      uint32_t off = coff_read4 (sym->name.long_name.off);\n+\n+      if (off >= strtab_size)\n+\treturn -1;\n+      isym->name = (const char *) strtab + off;\n+    }\n+  return 0;\n+}\n+\n+/* Return true iff SYM is a defined symbol for a function.  Data symbols\n+   aren't considered because they aren't easily identified (same type as\n+   section names, presence of symbols defined by the linker script).  */\n+\n+static int\n+coff_is_function_symbol (const b_coff_internal_symbol *isym)\n+{\n+  return (isym->type >> N_TBSHFT) == IMAGE_SYM_DTYPE_FUNCTION\n+    && isym->sec > 0;\n+}\n+\n+/* Initialize the symbol table info for coff_syminfo.  */\n+\n+static int\n+coff_initialize_syminfo (struct backtrace_state *state,\n+\t\t\t uintptr_t base_address,\n+\t\t\t const b_coff_section_header *sects, size_t sects_num,\n+\t\t\t const b_coff_external_symbol *syms, size_t syms_size,\n+\t\t\t const unsigned char *strtab, size_t strtab_size,\n+\t\t\t backtrace_error_callback error_callback,\n+\t\t\t void *data, struct coff_syminfo_data *sdata)\n+{\n+  size_t syms_count;\n+  char *coff_symstr;\n+  size_t coff_symstr_len;\n+  size_t coff_symbol_count;\n+  size_t coff_symbol_size;\n+  struct coff_symbol *coff_symbols;\n+  struct coff_symbol *coff_sym;\n+  char *coff_str;\n+  size_t i;\n+\n+  syms_count = syms_size / SYM_SZ;\n+\n+  /* We only care about function symbols.  Count them.  Also count size of\n+     strings for in-symbol names.  */\n+  coff_symbol_count = 0;\n+  coff_symstr_len = 0;\n+  for (i = 0; i < syms_count; ++i)\n+    {\n+      const b_coff_external_symbol *asym = &syms[i];\n+      b_coff_internal_symbol isym;\n+\n+      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size) < 0)\n+\t{\n+\t  error_callback (data, \"invalid section or offset in coff symbol\", 0);\n+\t  return 0;\n+\t}\n+      if (coff_is_function_symbol (&isym))\n+\t{\n+\t  ++coff_symbol_count;\n+\t  if (asym->name.short_name[0] != 0)\n+\t    coff_symstr_len += coff_short_name_len (asym->name.short_name) + 1;\n+\t}\n+\n+      i += asym->number_of_aux_symbols;\n+    }\n+\n+  coff_symbol_size = (coff_symbol_count + 1) * sizeof (struct coff_symbol);\n+  coff_symbols = ((struct coff_symbol *)\n+\t\t  backtrace_alloc (state, coff_symbol_size, error_callback,\n+\t\t\t\t   data));\n+  if (coff_symbols == NULL)\n+    return 0;\n+\n+  /* Allocate memory for symbols strings.  */\n+  if (coff_symstr_len > 0)\n+    {\n+      coff_symstr = ((char *)\n+\t\t     backtrace_alloc (state, coff_symstr_len, error_callback,\n+\t\t\t\t      data));\n+      if (coff_symstr == NULL)\n+\t{\n+\t  backtrace_free (state, coff_symbols, coff_symbol_size,\n+\t\t\t  error_callback, data);\n+\t  return 0;\n+\t}\n+    }\n+  else\n+    coff_symstr = NULL;\n+\n+  /* Copy symbols.  */\n+  coff_sym = coff_symbols;\n+  coff_str = coff_symstr;\n+  for (i = 0; i < syms_count; ++i)\n+    {\n+      const b_coff_external_symbol *asym = &syms[i];\n+      b_coff_internal_symbol isym;\n+\n+      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size))\n+\t{\n+\t  /* Should not fail, as it was already tested in the previous\n+\t     loop.  */\n+\t  abort ();\n+\t}\n+      if (coff_is_function_symbol (&isym))\n+\t{\n+\t  const char *name;\n+\t  int16_t secnum;\n+\n+\t  if (asym->name.short_name[0] != 0)\n+\t    {\n+\t      size_t len = coff_short_name_len (isym.name);\n+\t      name = coff_str;\n+\t      memcpy (coff_str, isym.name, len);\n+\t      coff_str[len] = 0;\n+\t      coff_str += len + 1;\n+\t    }\n+\t  else\n+\t    name = isym.name;\n+\n+\t  /* Strip leading '_'.  */\n+\t  if (name[0] == '_')\n+\t    name++;\n+\n+\t  /* Symbol value is section relative, so we need to read the address\n+\t     of its section.  */\n+\t  secnum = coff_read2 (asym->section_number);\n+\n+\t  coff_sym->name = name;\n+\t  coff_sym->address = (coff_read4 (asym->value)\n+\t\t\t       + sects[secnum - 1].virtual_address\n+\t\t\t       + base_address);\n+\t  coff_sym++;\n+\t}\n+\n+      i += asym->number_of_aux_symbols;\n+    }\n+\n+  /* End of symbols marker.  */\n+  coff_sym->name = NULL;\n+  coff_sym->address = -1;\n+\n+  backtrace_qsort (coff_symbols, coff_symbol_count,\n+\t\t   sizeof (struct coff_symbol), coff_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = coff_symbols;\n+  sdata->count = coff_symbol_count;\n+\n+  return 1;\n+}\n+\n+/* Add EDATA to the list in STATE.  */\n+\n+static void\n+coff_add_syminfo_data (struct backtrace_state *state,\n+\t\t       struct coff_syminfo_data *sdata)\n+{\n+  if (!state->threaded)\n+    {\n+      struct coff_syminfo_data **pp;\n+\n+      for (pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = sdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct coff_syminfo_data **pp;\n+\n+\t  pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct coff_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, sdata))\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* Compare an ADDR against an elf_symbol for bsearch.  We allocate one\n+   extra entry in the array so that this can look safely at the next\n+   entry.  */\n+\n+static int\n+coff_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct coff_symbol *entry = (const struct coff_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if (addr >= entry[1].address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Return the symbol name and value for an ADDR.  */\n+\n+static void\n+coff_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t      backtrace_syminfo_callback callback,\n+\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t      void *data)\n+{\n+  struct coff_syminfo_data *sdata;\n+  struct coff_symbol *sym = NULL;\n+\n+  if (!state->threaded)\n+    {\n+      for (sdata = (struct coff_syminfo_data *) state->syminfo_data;\n+\t   sdata != NULL;\n+\t   sdata = sdata->next)\n+\t{\n+\t  sym = ((struct coff_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct coff_syminfo_data **pp;\n+\n+      pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  sdata = backtrace_atomic_load_pointer (pp);\n+\t  if (sdata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct coff_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &sdata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->address, 0);\n+}\n+\n+/* Add the backtrace data for one PE/COFF file.  Returns 1 on success,\n+   0 on failure (in both cases descriptor is closed).  */\n+\n+static int\n+coff_add (struct backtrace_state *state, int descriptor,\n+\t  backtrace_error_callback error_callback, void *data,\n+\t  fileline *fileline_fn, int *found_sym, int *found_dwarf)\n+{\n+  struct backtrace_view fhdr_view;\n+  off_t fhdr_off;\n+  int magic_ok;\n+  b_coff_file_header fhdr;\n+  off_t opt_sects_off;\n+  size_t opt_sects_size;\n+  unsigned int sects_num;\n+  struct backtrace_view sects_view;\n+  int sects_view_valid;\n+  const b_coff_optional_header *opt_hdr;\n+  const b_coff_section_header *sects;\n+  struct backtrace_view str_view;\n+  int str_view_valid;\n+  size_t str_size;\n+  off_t str_off;\n+  struct backtrace_view syms_view;\n+  off_t syms_off;\n+  size_t syms_size;\n+  int syms_view_valid;\n+  unsigned int syms_num;\n+  unsigned int i;\n+  struct debug_section_info sections[DEBUG_MAX];\n+  off_t min_offset;\n+  off_t max_offset;\n+  struct backtrace_view debug_view;\n+  int debug_view_valid;\n+  uintptr_t image_base;\n+\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  sects_view_valid = 0;\n+  syms_view_valid = 0;\n+  str_view_valid = 0;\n+  debug_view_valid = 0;\n+\n+  /* Map the MS-DOS stub (if any) and extract file header offset.  */\n+  if (!backtrace_get_view (state, descriptor, 0, 0x40, error_callback,\n+\t\t\t   data, &fhdr_view))\n+    goto fail;\n+\n+  {\n+    const char *vptr = (const char *)fhdr_view.data;\n+\n+    if (vptr[0] == 'M' && vptr[1] == 'Z')\n+      memcpy (&fhdr_off, vptr + 0x3c, 4);\n+    else\n+      fhdr_off = 0;\n+  }\n+\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  /* Map the coff file header.  */\n+  if (!backtrace_get_view (state, descriptor, fhdr_off,\n+\t\t\t   sizeof (b_coff_file_header) + 4,\n+\t\t\t   error_callback, data, &fhdr_view))\n+    goto fail;\n+\n+  if (fhdr_off != 0)\n+    {\n+      const char *magic = (const char *) fhdr_view.data;\n+      magic_ok = memcmp (magic, \"PE\\0\", 4) == 0;\n+      fhdr_off += 4;\n+\n+      memcpy (&fhdr, fhdr_view.data + 4, sizeof fhdr);\n+    }\n+  else\n+    {\n+      memcpy (&fhdr, fhdr_view.data, sizeof fhdr);\n+      /* TODO: test fhdr.machine for coff but non-PE platforms.  */\n+      magic_ok = 0;\n+    }\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  if (!magic_ok)\n+    {\n+      error_callback (data, \"executable file is not COFF\", 0);\n+      goto fail;\n+    }\n+\n+  sects_num = fhdr.number_of_sections;\n+  syms_num = fhdr.number_of_symbols;\n+\n+  opt_sects_off = fhdr_off + sizeof (fhdr);\n+  opt_sects_size = (fhdr.size_of_optional_header\n+\t\t    + sects_num * sizeof (b_coff_section_header));\n+\n+  /* To translate PC to file/line when using DWARF, we need to find\n+     the .debug_info and .debug_line sections.  */\n+\n+  /* Read the optional header and the section headers.  */\n+\n+  if (!backtrace_get_view (state, descriptor, opt_sects_off, opt_sects_size,\n+\t\t\t   error_callback, data, &sects_view))\n+    goto fail;\n+  sects_view_valid = 1;\n+  opt_hdr = (const b_coff_optional_header *) sects_view.data;\n+  sects = (const b_coff_section_header *)\n+    (sects_view.data + fhdr.size_of_optional_header);\n+\n+  if (fhdr.size_of_optional_header > sizeof (*opt_hdr))\n+    {\n+      if (opt_hdr->magic == PE_MAGIC)\n+\timage_base = opt_hdr->u.pe.image_base;\n+      else if (opt_hdr->magic == PEP_MAGIC)\n+\timage_base = opt_hdr->u.pep.image_base;\n+      else\n+\t{\n+\t  error_callback (data, \"bad magic in PE optional header\", 0);\n+\t  goto fail;\n+\t}\n+    }\n+  else\n+    image_base = 0;\n+\n+  /* Read the symbol table and the string table.  */\n+\n+  if (fhdr.pointer_to_symbol_table == 0)\n+    {\n+      /* No symbol table, no string table.  */\n+      str_off = 0;\n+      str_size = 0;\n+      syms_num = 0;\n+      syms_size = 0;\n+    }\n+  else\n+    {\n+      /* Symbol table is followed by the string table.  The string table\n+\t starts with its length (on 4 bytes).\n+\t Map the symbol table and the length of the string table.  */\n+      syms_off = fhdr.pointer_to_symbol_table;\n+      syms_size = syms_num * SYM_SZ;\n+\n+      if (!backtrace_get_view (state, descriptor, syms_off, syms_size + 4,\n+\t\t\t       error_callback, data, &syms_view))\n+\tgoto fail;\n+      syms_view_valid = 1;\n+\n+      memcpy (&str_size, syms_view.data + syms_size, 4);\n+\n+      str_off = syms_off + syms_size;\n+\n+      if (str_size > 4)\n+\t{\n+\t  /* Map string table (including the length word).  */\n+\n+\t  if (!backtrace_get_view (state, descriptor, str_off, str_size,\n+\t\t\t\t   error_callback, data, &str_view))\n+\t    goto fail;\n+\t  str_view_valid = 1;\n+\t}\n+    }\n+\n+  memset (sections, 0, sizeof sections);\n+\n+  /* Look for the symbol table.  */\n+  for (i = 0; i < sects_num; ++i)\n+    {\n+      const b_coff_section_header *s = sects + i;\n+      unsigned int str_off;\n+      int j;\n+\n+      if (s->name[0] == '/')\n+\t{\n+\t  /* Extended section name.  */\n+\t  str_off = atoi (s->name + 1);\n+\t}\n+      else\n+\tstr_off = 0;\n+\n+      for (j = 0; j < (int) DEBUG_MAX; ++j)\n+\t{\n+\t  const char *dbg_name = debug_section_names[j];\n+\t  int match;\n+\n+\t  if (str_off != 0)\n+\t    match = coff_long_name_eq (dbg_name, str_off, &str_view);\n+\t  else\n+\t    match = coff_short_name_eq (dbg_name, s->name);\n+\t  if (match)\n+\t    {\n+\t      sections[j].offset = s->pointer_to_raw_data;\n+\t      sections[j].size = s->virtual_size <= s->size_of_raw_data ?\n+\t\ts->virtual_size : s->size_of_raw_data;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (syms_num != 0)\n+    {\n+      struct coff_syminfo_data *sdata;\n+\n+      sdata = ((struct coff_syminfo_data *)\n+\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+      if (sdata == NULL)\n+\tgoto fail;\n+\n+      if (!coff_initialize_syminfo (state, image_base,\n+\t\t\t\t    sects, sects_num,\n+\t\t\t\t    syms_view.data, syms_size,\n+\t\t\t\t    str_view.data, str_size,\n+\t\t\t\t    error_callback, data, sdata))\n+\t{\n+\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      *found_sym = 1;\n+\n+      coff_add_syminfo_data (state, sdata);\n+    }\n+\n+  backtrace_release_view (state, &sects_view, error_callback, data);\n+  sects_view_valid = 0;\n+  backtrace_release_view (state, &syms_view, error_callback, data);\n+  syms_view_valid = 0;\n+\n+  /* Read all the debug sections in a single view, since they are\n+     probably adjacent in the file.  We never release this view.  */\n+\n+  min_offset = 0;\n+  max_offset = 0;\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      off_t end;\n+\n+      if (sections[i].size == 0)\n+\tcontinue;\n+      if (min_offset == 0 || sections[i].offset < min_offset)\n+\tmin_offset = sections[i].offset;\n+      end = sections[i].offset + sections[i].size;\n+      if (end > max_offset)\n+\tmax_offset = end;\n+    }\n+  if (min_offset == 0 || max_offset == 0)\n+    {\n+      if (!backtrace_close (descriptor, error_callback, data))\n+\tgoto fail;\n+      *fileline_fn = coff_nodebug;\n+      return 1;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, min_offset,\n+\t\t\t   max_offset - min_offset,\n+\t\t\t   error_callback, data, &debug_view))\n+    goto fail;\n+  debug_view_valid = 1;\n+\n+  /* We've read all we need from the executable.  */\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      if (sections[i].size == 0)\n+\tsections[i].data = NULL;\n+      else\n+\tsections[i].data = ((const unsigned char *) debug_view.data\n+\t\t\t    + (sections[i].offset - min_offset));\n+    }\n+\n+  if (!backtrace_dwarf_add (state, /* base_address */ 0,\n+\t\t\t    sections[DEBUG_INFO].data,\n+\t\t\t    sections[DEBUG_INFO].size,\n+\t\t\t    sections[DEBUG_LINE].data,\n+\t\t\t    sections[DEBUG_LINE].size,\n+\t\t\t    sections[DEBUG_ABBREV].data,\n+\t\t\t    sections[DEBUG_ABBREV].size,\n+\t\t\t    sections[DEBUG_RANGES].data,\n+\t\t\t    sections[DEBUG_RANGES].size,\n+\t\t\t    sections[DEBUG_STR].data,\n+\t\t\t    sections[DEBUG_STR].size,\n+\t\t\t    0, /* FIXME */\n+\t\t\t    error_callback, data, fileline_fn))\n+    goto fail;\n+\n+  *found_dwarf = 1;\n+\n+  return 1;\n+\n+ fail:\n+  if (sects_view_valid)\n+    backtrace_release_view (state, &sects_view, error_callback, data);\n+  if (str_view_valid)\n+    backtrace_release_view (state, &str_view, error_callback, data);\n+  if (syms_view_valid)\n+    backtrace_release_view (state, &syms_view, error_callback, data);\n+  if (debug_view_valid)\n+    backtrace_release_view (state, &debug_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Initialize the backtrace data we need from an ELF executable.  At\n+   the ELF level, all we need to do is find the debug info\n+   sections.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  int found_sym;\n+  int found_dwarf;\n+  fileline coff_fileline_fn;\n+\n+  ret = coff_add (state, descriptor, error_callback, data,\n+\t\t  &coff_fileline_fn, &found_sym, &found_dwarf);\n+  if (!ret)\n+    return 0;\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = coff_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = coff_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, coff_syminfo);\n+      else\n+\t__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, coff_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == coff_nodebug)\n+\t*fileline_fn = coff_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == coff_nodebug)\n+\t*fileline_fn = coff_fileline_fn;\n+    }\n+\n+  return 1;\n+}"}]}