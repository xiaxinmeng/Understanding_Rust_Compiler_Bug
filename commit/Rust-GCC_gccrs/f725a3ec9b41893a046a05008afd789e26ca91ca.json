{"sha": "f725a3ec9b41893a046a05008afd789e26ca91ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcyNWEzZWM5YjQxODkzYTA0NmEwNTAwOGFmZDc4OWUyNmNhOTFjYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-07T01:17:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-09-07T01:17:00Z"}, "message": "* calls.c: Fix formatting.\n\nFrom-SVN: r36219", "tree": {"sha": "c109f945c2fc199adf91ff756754ea4335239529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c109f945c2fc199adf91ff756754ea4335239529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f725a3ec9b41893a046a05008afd789e26ca91ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f725a3ec9b41893a046a05008afd789e26ca91ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f725a3ec9b41893a046a05008afd789e26ca91ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f725a3ec9b41893a046a05008afd789e26ca91ca/comments", "author": null, "committer": null, "parents": [{"sha": "f133a43eab88b0093f16d966a3b2d1d0e45388e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f133a43eab88b0093f16d966a3b2d1d0e45388e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f133a43eab88b0093f16d966a3b2d1d0e45388e1"}], "stats": {"total": 264, "additions": 134, "deletions": 130}, "files": [{"sha": "f21bd1afe56ecb95d5cb0d4e88b228fbe03d1ded", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f725a3ec9b41893a046a05008afd789e26ca91ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f725a3ec9b41893a046a05008afd789e26ca91ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f725a3ec9b41893a046a05008afd789e26ca91ca", "patch": "@@ -1,3 +1,7 @@\n+2000-09-06  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* calls.c: Fix formatting.\n+\n 2000-09-06  Graham Stott  <grahams@cygnus.co.uk>\n \n         * config/i386/i386.h (ADDRESS_COST): Fix typo."}, {"sha": "885817d5410e988be5b79e7d24bb64d98440e66c", "filename": "gcc/calls.c", "status": "modified", "additions": 130, "deletions": 130, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f725a3ec9b41893a046a05008afd789e26ca91ca/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f725a3ec9b41893a046a05008afd789e26ca91ca/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f725a3ec9b41893a046a05008afd789e26ca91ca", "patch": "@@ -163,11 +163,11 @@ int stack_arg_under_construction;\n static int calls_function\tPARAMS ((tree, int));\n static int calls_function_1\tPARAMS ((tree, int));\n \n-/* Nonzero if this is a call to a `const' function. */\n+/* Nonzero if this is a call to a `const' function.  */\n #define ECF_CONST\t\t1\n /* Nonzero if this is a call to a `volatile' function.  */\n #define ECF_NORETURN\t\t2\n-/* Nonzero if this is a call to malloc or a related function. */\n+/* Nonzero if this is a call to malloc or a related function.  */\n #define ECF_MALLOC\t\t4\n /* Nonzero if it is plausible that this is a call to alloca.  */\n #define ECF_MAY_BE_ALLOCA\t8\n@@ -203,7 +203,7 @@ static int finalize_must_preallocate\t\tPARAMS ((int, int,\n \t\t\t\t\t\t\t struct args_size *));\n static void precompute_arguments \t\tPARAMS ((int, int,\n \t\t\t\t\t\t\t struct arg_data *));\n-static int compute_argument_block_size\t\tPARAMS ((int, \n+static int compute_argument_block_size\t\tPARAMS ((int,\n \t\t\t\t\t\t\t struct args_size *,\n \t\t\t\t\t\t\t int));\n static void initialize_argument_information\tPARAMS ((int,\n@@ -437,7 +437,7 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n \n    CALL_FUSAGE is either empty or an EXPR_LIST of USE expressions that\n    denote registers used by the called function.   */\n-  \n+\n static void\n emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \t     struct_value_size, next_arg_reg, valreg, old_inhibit_defer_pop,\n@@ -472,8 +472,8 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n #if defined (HAVE_sibcall_pop) && defined (HAVE_sibcall_value_pop)\n   if ((ecf_flags & ECF_SIBCALL)\n       && HAVE_sibcall_pop && HAVE_sibcall_value_pop\n-      && (RETURN_POPS_ARGS (fndecl, funtype, stack_size) > 0 \n-          || stack_size == 0))\n+      && (RETURN_POPS_ARGS (fndecl, funtype, stack_size) > 0\n+\t  || stack_size == 0))\n     {\n       rtx n_pop = GEN_INT (RETURN_POPS_ARGS (fndecl, funtype, stack_size));\n       rtx pat;\n@@ -653,7 +653,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n \n      ??? We may optimize similar to defer_pop above, but it is\n      probably not worthwhile.\n-   \n+\n      ??? It will be worthwhile to enable combine_stack_adjustments even for\n      such machines.  */\n   else if (n_popped)\n@@ -757,7 +757,7 @@ special_function_p (fndecl, flags)\n          it may return the same address across multiple calls.\n          C++ operator new is not suitable because it is not required\n          to return a unique pointer; indeed, the standard placement new\n-\t just returns its argument. */\n+\t just returns its argument.  */\n       else if (TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))) == Pmode\n \t       && (! strcmp (tname, \"malloc\")\n \t\t   || ! strcmp (tname, \"calloc\")\n@@ -808,7 +808,6 @@ flags_from_decl_or_type (exp)\n   return flags;\n }\n \n-\n /* Precompute all register parameters as described by ARGS, storing values\n    into fields within the ARGS array.\n \n@@ -853,7 +852,7 @@ precompute_register_parameters (num_actuals, args, reg_parm_seen)\n \t\t\t     TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n \t\t\t     args[i].value, args[i].unsignedp);\n \n-\t/* If the value is expensive, and we are inside an appropriately \n+\t/* If the value is expensive, and we are inside an appropriately\n \t   short loop, put the value into a pseudo and then put the pseudo\n \t   into the hard reg.\n \n@@ -915,7 +914,7 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n \n       /* If we don't have the required alignment, must do this in BLKmode.  */\n       if ((*low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n-\t\t\t        BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\t\t\t\tBIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n \tsave_mode = BLKmode;\n \n #ifdef ARGS_GROW_DOWNWARD\n@@ -980,11 +979,11 @@ restore_fixed_argument_area (save_area, argblock, high_to_save, low_to_save)\n \t\t    high_to_save - low_to_save + 1, PARM_BOUNDARY);\n }\n #endif\n-\t  \n+\n /* If any elements in ARGS refer to parameters that are to be passed in\n    registers, but not in memory, and whose alignment does not permit a\n    direct copy into registers.  Copy the values into a group of pseudos\n-   which we will later copy into the appropriate hard registers. \n+   which we will later copy into the appropriate hard registers.\n \n    Pseudos for each unaligned argument will be stored into the array\n    args[argnum].aligned_regs.  The caller is responsible for deallocating\n@@ -996,7 +995,7 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n      int num_actuals;\n {\n   int i, j;\n-     \n+\n   for (i = 0; i < num_actuals; i++)\n     if (args[i].reg != 0 && ! args[i].pass_on_stack\n \t&& args[i].mode == BLKmode\n@@ -1053,7 +1052,7 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n }\n \n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n-   ACTPARMS. \n+   ACTPARMS.\n \n    NUM_ACTUALS is the total number of parameters.\n \n@@ -1101,7 +1100,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n   struct args_size alignment_pad;\n   int i;\n   tree p;\n-  \n+\n   args_size->constant = 0;\n   args_size->var = 0;\n \n@@ -1184,8 +1183,8 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t         but it is safe in the only case where this is a useful\n \t         optimization; namely, when the argument is a plain object.\n \t         In that case, the frontend is just asking the backend to\n-\t         make a bitwise copy of the argument. */\n-\t\t \n+\t         make a bitwise copy of the argument.  */\n+\n \t      if (TREE_CODE (args[i].tree_value) == TARGET_EXPR\n \t\t  && (DECL_P (TREE_OPERAND (args[i].tree_value, 1)))\n \t\t  && ! REG_P (DECL_RTL (TREE_OPERAND (args[i].tree_value, 1))))\n@@ -1254,7 +1253,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t register window has to be unwinded before calling the routine, so\n \t arguments have to go into the incoming registers.  */\n       args[i].tail_call_reg = FUNCTION_INCOMING_ARG (*args_so_far, mode, type,\n-\t\t\t\t\t     argpos < n_named_args);\n+\t\t\t\t\t\t     argpos < n_named_args);\n #else\n       args[i].tail_call_reg = args[i].reg;\n #endif\n@@ -1314,7 +1313,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \targs[i].size.constant -= ((args[i].partial * UNITS_PER_WORD)\n \t\t\t\t  / (PARM_BOUNDARY / BITS_PER_UNIT)\n \t\t\t\t  * (PARM_BOUNDARY / BITS_PER_UNIT));\n-      \n+\n       /* Update ARGS_SIZE, the total stack space for args so far.  */\n \n       args_size->constant += args[i].size.constant;\n@@ -1349,7 +1348,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \n static int\n compute_argument_block_size (reg_parm_stack_space, args_size,\n-    \t\t\t     preferred_stack_boundary)\n+\t\t\t     preferred_stack_boundary)\n      int reg_parm_stack_space;\n      struct args_size *args_size;\n      int preferred_stack_boundary ATTRIBUTE_UNUSED;\n@@ -1378,10 +1377,10 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n       if (preferred_stack_boundary > 1)\n \t{\n \t  /* We don't handle this case yet.  To handle it correctly we have\n-\t     to add the delta, round and substract the delta.  \n+\t     to add the delta, round and substract the delta.\n \t     Currently no machine description requires this support.  */\n \t  if (stack_pointer_delta & (preferred_stack_boundary - 1))\n-\t    abort();\n+\t    abort ();\n \t  args_size->var = round_up (args_size->var, preferred_stack_boundary);\n \t}\n #endif\n@@ -1436,9 +1435,9 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n \n    NUM_ACTUALS is the number of arguments.\n \n-   ARGS is an array containing information for each argument; this routine\n-   fills in the INITIAL_VALUE and VALUE fields for each precomputed argument.  \n-   */\n+   ARGS is an array containing information for each argument; this\n+   routine fills in the INITIAL_VALUE and VALUE fields for each\n+   precomputed argument.  */\n \n static void\n precompute_arguments (flags, num_actuals, args)\n@@ -1489,7 +1488,7 @@ precompute_arguments (flags, num_actuals, args)\n \tif (TYPE_MODE (TREE_TYPE (args[i].tree_value)) != args[i].mode)\n \t  {\n \t    args[i].value\n-\t      = convert_modes (args[i].mode, \n+\t      = convert_modes (args[i].mode,\n \t\t\t       TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n \t\t\t       args[i].value, args[i].unsignedp);\n #ifdef PROMOTE_FOR_CALL_ONLY\n@@ -1573,7 +1572,7 @@ finalize_must_preallocate (must_preallocate, num_actuals, args, args_size)\n /* If we preallocated stack space, compute the address of each argument\n    and store it into the ARGS array.\n \n-   We need not ensure it is a valid memory address here; it will be \n+   We need not ensure it is a valid memory address here; it will be\n    validized when it is used.\n \n    ARGBLOCK is an rtx for the address of the outgoing arguments.  */\n@@ -1631,7 +1630,7 @@ compute_argument_addresses (args, argblock, num_actuals)\n \t}\n     }\n }\n-\t\t\t\t\t       \n+\n /* Given a FNDECL and EXP, return an rtx suitable for use as a target address\n    in a call instruction.\n \n@@ -1666,18 +1665,18 @@ rtx_for_function_call (fndecl, exp)\n     {\n       rtx funaddr;\n       push_temp_slots ();\n-      funaddr = funexp = \n-\t  expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n-      pop_temp_slots ();\t/* FUNEXP can't be BLKmode */\n+      funaddr = funexp =\n+\texpand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n+      pop_temp_slots ();\t/* FUNEXP can't be BLKmode.  */\n \n       /* Check the function is executable.  */\n       if (current_function_check_memory_usage)\n \t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  /* It might be OK to convert funexp in place, but there's\n \t     a lot going on between here and when it happens naturally\n-\t     that this seems safer. */\n-          funaddr = convert_memory_address (Pmode, funexp);\n+\t     that this seems safer.  */\n+\t  funaddr = convert_memory_address (Pmode, funexp);\n #endif\n \t  emit_library_call (chkr_check_exec_libfunc, 1,\n \t\t\t     VOIDmode, 1,\n@@ -1690,7 +1689,7 @@ rtx_for_function_call (fndecl, exp)\n \n /* Do the register loads required for any wholly-register parms or any\n    parms which are passed both on the stack and in a register.  Their\n-   expressions were already evaluated. \n+   expressions were already evaluated.\n \n    Mark all register-parms as living through the call, putting these USE\n    insns in the CALL_INSN_FUNCTION_USAGE field.  */\n@@ -1842,7 +1841,7 @@ try_to_integrate (fndecl, actparms, target, ignore, type, structure_value_addr)\n \t\t     outgoing argument list in addition to the requested\n \t\t     space, but there is no way to ask for stack space such\n \t\t     that an argument list of a certain length can be\n-\t\t     safely constructed. \n+\t\t     safely constructed.\n \n \t\t     Add the stack space reserved for register arguments, if\n \t\t     any, in the inline function.  What is really needed is the\n@@ -1911,7 +1910,7 @@ combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n      just pushed the arguments without adjust the stack here.  */\n   HOST_WIDE_INT unadjusted_alignment;\n \n-  unadjusted_alignment \n+  unadjusted_alignment\n     = ((stack_pointer_delta + unadjusted_args_size)\n        % preferred_unit_stack_boundary);\n \n@@ -1922,25 +1921,25 @@ combine_pending_stack_adjustment_and_call (unadjusted_args_size,\n      -UNADJUSTED_ALIGNMENT modulo the PREFERRED_UNIT_STACK_BOUNDARY.  */\n \n   /* Begin by trying to pop all the bytes.  */\n-  unadjusted_alignment \n-    = (unadjusted_alignment \n+  unadjusted_alignment\n+    = (unadjusted_alignment\n        - (pending_stack_adjust % preferred_unit_stack_boundary));\n   adjustment = pending_stack_adjust;\n   /* Push enough additional bytes that the stack will be aligned\n      after the arguments are pushed.  */\n   if (preferred_unit_stack_boundary > 1)\n     {\n       if (unadjusted_alignment >= 0)\n-        adjustment -= preferred_unit_stack_boundary - unadjusted_alignment;\n+\tadjustment -= preferred_unit_stack_boundary - unadjusted_alignment;\n       else\n-        adjustment += unadjusted_alignment;\n+\tadjustment += unadjusted_alignment;\n     }\n-  \n+\n   /* Now, sets ARGS_SIZE->CONSTANT so that we pop the right number of\n      bytes after the call.  The right number is the entire\n      PENDING_STACK_ADJUST less our ADJUSTMENT plus the amount required\n      by the arguments in the first place.  */\n-  args_size->constant \n+  args_size->constant\n     = pending_stack_adjust - adjustment + unadjusted_args_size;\n \n   return adjustment;\n@@ -1990,24 +1989,23 @@ check_sibcall_argument_overlap_1 (x)\n       return 0;\n     }\n \n-  /* Scan all subexpressions. */\n+  /* Scan all subexpressions.  */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n       if (*fmt == 'e')\n-        {\n-          if (check_sibcall_argument_overlap_1 (XEXP (x, i)))\n-            return 1;\n-        }\n+\t{\n+\t  if (check_sibcall_argument_overlap_1 (XEXP (x, i)))\n+\t    return 1;\n+\t}\n       else if (*fmt == 'E')\n-        {\n-          for (j = 0; j < XVECLEN (x, i); j++)\n-            if (check_sibcall_argument_overlap_1 (XVECEXP (x, i, j)))\n-              return 1;\n-        }\n+\t{\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (check_sibcall_argument_overlap_1 (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n     }\n   return 0;\n-\n }\n \n /* Scan sequence after INSN if it does not dereference any argument slots\n@@ -2020,7 +2018,7 @@ static int\n check_sibcall_argument_overlap (insn, arg)\n      rtx insn;\n      struct arg_data *arg;\n-{     \n+{\n   int low, high;\n \n   if (insn == NULL_RTX)\n@@ -2029,8 +2027,8 @@ check_sibcall_argument_overlap (insn, arg)\n     insn = NEXT_INSN (insn);\n \n   for (; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) &&\n-\tcheck_sibcall_argument_overlap_1 (PATTERN (insn)))\n+    if (INSN_P (insn)\n+\t&& check_sibcall_argument_overlap_1 (PATTERN (insn)))\n       break;\n \n #ifdef ARGS_GROW_DOWNWARD\n@@ -2119,7 +2117,7 @@ expand_call (exp, target, ignore)\n   int reg_parm_seen;\n   /* Nonzero if this is an indirect function call.  */\n \n-  /* Nonzero if we must avoid push-insns in the args for this call. \n+  /* Nonzero if we must avoid push-insns in the args for this call.\n      If stack space is allocated for register parameters, but not by the\n      caller, then it is preallocated in the fixed part of the stack frame.\n      So the entire argument block must then be preallocated (i.e., we\n@@ -2203,7 +2201,7 @@ expand_call (exp, target, ignore)\n       flags |= flags_from_decl_or_type (fndecl);\n     }\n \n-  /* If we don't have specific function to call, see if we have a \n+  /* If we don't have specific function to call, see if we have a\n      attributes set in the type.  */\n   else\n     flags |= flags_from_decl_or_type (TREE_TYPE (TREE_TYPE (p)));\n@@ -2213,7 +2211,7 @@ expand_call (exp, target, ignore)\n       && TYPE_RETURNS_STACK_DEPRESSED (TREE_TYPE (TREE_TYPE (p))))\n     {\n       flags |= ECF_SP_DEPRESSED;\n-      flags &= ~ (ECF_PURE | ECF_CONST);\n+      flags &= ~(ECF_PURE | ECF_CONST);\n     }\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -2377,10 +2375,8 @@ expand_call (exp, target, ignore)\n      or not.  */\n   INIT_CUMULATIVE_ARGS (args_so_far, funtype, NULL_RTX, (fndecl == 0));\n \n-\n   /* Make a vector to hold all the information about each arg.  */\n-  args = (struct arg_data *) alloca (num_actuals\n-\t\t\t\t     * sizeof (struct arg_data));\n+  args = (struct arg_data *) alloca (num_actuals * sizeof (struct arg_data));\n   bzero ((char *) args, num_actuals * sizeof (struct arg_data));\n \n   /* Build up entries inthe ARGS array, compute the size of the arguments\n@@ -2425,7 +2421,7 @@ expand_call (exp, target, ignore)\n      there's pending loops or cleanups we know there's code to follow\n      the call.\n \n-     If rtx_equal_function_value_matters is false, that means we've \n+     If rtx_equal_function_value_matters is false, that means we've\n      finished with regular parsing.  Which means that some of the\n      machinery we use to generate tail-calls is no longer in place.\n      This is most often true of sjlj-exceptions, which we couldn't\n@@ -2490,7 +2486,7 @@ expand_call (exp, target, ignore)\n \t (See unsafe_for_reeval commentary for details.)\n \n \t Generate a new argument list.  Pass safe arguments through\n-\t unchanged.  For the easy badness wrap them in UNSAVE_EXPRs.  \n+\t unchanged.  For the easy badness wrap them in UNSAVE_EXPRs.\n \t For hard badness, evaluate them now and put their resulting\n \t rtx in a temporary VAR_DECL.\n \n@@ -2505,7 +2501,7 @@ expand_call (exp, target, ignore)\n \t  end = num_actuals;\n \t}\n       else\n-\t  {\n+\t{\n \t  inc = -1;\n \t  i = num_actuals - 1;\n \t  end = -1;\n@@ -2515,26 +2511,26 @@ expand_call (exp, target, ignore)\n \t{\n \t  switch (unsafe_for_reeval (args[i].tree_value))\n \t    {\n-\t  case 0: /* Safe.  */\n-\t    break;\n+\t    case 0: /* Safe.  */\n+\t      break;\n \n-\t  case 1: /* Mildly unsafe.  */\n-\t    args[i].tree_value = unsave_expr (args[i].tree_value);\n-\t    break;\n+\t    case 1: /* Mildly unsafe.  */\n+\t      args[i].tree_value = unsave_expr (args[i].tree_value);\n+\t      break;\n \n-\t  case 2: /* Wildly unsafe.  */\n-\t    {\n-\t      tree var = build_decl (VAR_DECL, NULL_TREE,\n+\t    case 2: /* Wildly unsafe.  */\n+\t      {\n+\t\ttree var = build_decl (VAR_DECL, NULL_TREE,\n \t\t\t\t       TREE_TYPE (args[i].tree_value));\n \t\tDECL_RTL (var) = expand_expr (args[i].tree_value, NULL_RTX,\n-\t\t\t\t\t    VOIDmode, EXPAND_NORMAL);\n+\t\t\t\t\t      VOIDmode, EXPAND_NORMAL);\n \t\targs[i].tree_value = var;\n-\t    }\n-\t    break;\n+\t      }\n+\t      break;\n \n-\t  default:\n-\t    abort ();\n-\t  }\n+\t    default:\n+\t      abort ();\n+\t    }\n \t  /* We need to build actparms for optimize_tail_recursion.  We can\n \t     safely trash away TREE_PURPOSE, since it is unused by this\n \t     function.  */\n@@ -2648,7 +2644,7 @@ expand_call (exp, target, ignore)\n       argblock = 0;\n       call_fusage = 0;\n \n-      /* Start a new sequence for the normal call case. \n+      /* Start a new sequence for the normal call case.\n \n \t From this point on, if the sibling call fails, we want to set\n \t sibcall_failure instead of continuing the loop.  */\n@@ -2681,7 +2677,6 @@ expand_call (exp, target, ignore)\n \t temporaries we make.  */\n       push_temp_slots ();\n \n-\n #ifdef FINAL_REG_PARM_STACK_SPACE\n       reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n \t\t\t\t\t\t\t args_size.var);\n@@ -2702,11 +2697,12 @@ expand_call (exp, target, ignore)\n \t pattern, do not round up, since we'll be re-using whatever space our\n \t caller provided.  */\n       unadjusted_args_size\n-\t= compute_argument_block_size (reg_parm_stack_space, &adjusted_args_size,\n+\t= compute_argument_block_size (reg_parm_stack_space,\n+\t\t\t\t       &adjusted_args_size,\n \t\t\t\t       (pass == 0 ? 0\n \t\t\t\t\t: preferred_stack_boundary));\n \n-      old_stack_allocated =  stack_pointer_delta - pending_stack_adjust;\n+      old_stack_allocated = stack_pointer_delta - pending_stack_adjust;\n \n       /* The argument block when performing a sibling call is the\n          incoming argument block.  */\n@@ -2763,7 +2759,7 @@ expand_call (exp, target, ignore)\n \t\t     Therefore, we save any area of the stack that was already\n \t\t     written and that we are using.  Here we set up to do this\n \t\t     by making a new stack usage map from the old one.  The\n-\t\t     actual save will be done by store_one_arg. \n+\t\t     actual save will be done by store_one_arg.\n \n \t\t     Another approach might be to try to reorder the argument\n \t\t     evaluations to avoid this conflicting stack usage.  */\n@@ -2798,18 +2794,18 @@ expand_call (exp, target, ignore)\n \t\t  /* The address of the outgoing argument list must not be\n \t\t     copied to a register here, because argblock would be left\n \t\t     pointing to the wrong place after the call to\n-\t\t     allocate_dynamic_stack_space below. */\n+\t\t     allocate_dynamic_stack_space below.  */\n \n \t\t  argblock = virtual_outgoing_args_rtx;\n-\t        }\n+\t\t}\n \t      else\n \t\t{\n \t\t  if (inhibit_defer_pop == 0)\n \t\t    {\n \t\t      /* Try to reuse some or all of the pending_stack_adjust\n \t\t\t to get this space.  */\n \t\t      needed\n-\t\t\t= (combine_pending_stack_adjustment_and_call \n+\t\t\t= (combine_pending_stack_adjustment_and_call\n \t\t\t   (unadjusted_args_size,\n \t\t\t    &adjusted_args_size,\n \t\t\t    preferred_unit_stack_boundary));\n@@ -2829,7 +2825,7 @@ expand_call (exp, target, ignore)\n \t\t\t  do_pending_stack_adjust ();\n \t\t\t  needed = 0;\n \t\t\t}\n-\t\t      else \n+\t\t      else\n \t\t\t/* We need to allocate space.  We'll do that in\n \t\t\t   push_block below.  */\n \t\t\tpending_stack_adjust = 0;\n@@ -2907,12 +2903,12 @@ expand_call (exp, target, ignore)\n \t{\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n-\t  if (pending_stack_adjust \n+\t  if (pending_stack_adjust\n \t      && ! (flags & (ECF_CONST | ECF_PURE))\n \t      && ! inhibit_defer_pop)\n \t    {\n \t      pending_stack_adjust\n-\t\t= (combine_pending_stack_adjustment_and_call \n+\t\t= (combine_pending_stack_adjustment_and_call\n \t\t   (unadjusted_args_size,\n \t\t    &adjusted_args_size,\n \t\t    preferred_unit_stack_boundary));\n@@ -3015,7 +3011,7 @@ expand_call (exp, target, ignore)\n \t passed in registers.  */\n #ifdef OUTGOING_REG_PARM_STACK_SPACE\n       if (!ACCUMULATE_OUTGOING_ARGS\n-\t   && must_preallocate == 0 && reg_parm_stack_space > 0)\n+\t  && must_preallocate == 0 && reg_parm_stack_space > 0)\n \tanti_adjust_stack (GEN_INT (reg_parm_stack_space));\n #endif\n \n@@ -3032,7 +3028,7 @@ expand_call (exp, target, ignore)\n \t  if (current_function_check_memory_usage)\n \t    emit_library_call (chkr_set_right_libfunc, 1,\n \t\t\t       VOIDmode, 3,\n-\t\t\t       structure_value_addr, ptr_mode, \n+\t\t\t       structure_value_addr, ptr_mode,\n \t\t\t       GEN_INT (struct_value_size),\n \t\t\t       TYPE_MODE (sizetype),\n \t\t\t       GEN_INT (MEMORY_USE_WO),\n@@ -3046,7 +3042,7 @@ expand_call (exp, target, ignore)\n \t\t\t\t     reg_parm_seen);\n \n       load_register_parameters (args, num_actuals, &call_fusage, flags);\n-     \n+\n       /* Perform postincrements before actually calling the function.  */\n       emit_queue ();\n \n@@ -3082,8 +3078,8 @@ expand_call (exp, target, ignore)\n \n       /* Verify that we've deallocated all the stack we used.  */\n       if (pass\n-          && old_stack_allocated != stack_pointer_delta - pending_stack_adjust)\n-\tabort();\n+\t  && old_stack_allocated != stack_pointer_delta - pending_stack_adjust)\n+\tabort ();\n \n       /* If call is cse'able, make appropriate pair of reg-notes around it.\n \t Test valreg so we don't crash; may safely ignore `const'\n@@ -3117,7 +3113,7 @@ expand_call (exp, target, ignore)\n \t\t\t\t    \t gen_rtx_SCRATCH (VOIDmode))), note);\n \n \t  emit_libcall_block (insns, temp, valreg, note);\n-  \n+\n \t  valreg = temp;\n \t}\n       else if (flags & (ECF_CONST | ECF_PURE))\n@@ -3133,7 +3129,7 @@ expand_call (exp, target, ignore)\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n \t  rtx last, insns;\n \n-\t  /* The return value from a malloc-like function is a pointer. */\n+\t  /* The return value from a malloc-like function is a pointer.  */\n \t  if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n \t    mark_reg_pointer (temp, BIGGEST_ALIGNMENT);\n \n@@ -3142,7 +3138,7 @@ expand_call (exp, target, ignore)\n \t  /* The return value from a malloc-like function can not alias\n \t     anything else.  */\n \t  last = get_last_insn ();\n-\t  REG_NOTES (last) = \n+\t  REG_NOTES (last) =\n \t    gen_rtx_EXPR_LIST (REG_NOALIAS, temp, REG_NOTES (last));\n \n \t  /* Write out the sequence.  */\n@@ -3332,7 +3328,7 @@ expand_call (exp, target, ignore)\n \t  stack_usage_map = initial_stack_usage_map;\n \t}\n \n-      /* If this was alloca, record the new stack level for nonlocal gotos.  \n+      /* If this was alloca, record the new stack level for nonlocal gotos.\n \t Check for the handler slots since we might not have a save area\n \t for non-local gotos.  */\n \n@@ -3372,7 +3368,7 @@ expand_call (exp, target, ignore)\n \t  stack_pointer_delta = save_stack_pointer_delta;\n \n \t  /* Prepare arg structure for next iteration.  */\n-\t  for (i = 0 ; i < num_actuals ; i++)\n+\t  for (i = 0; i < num_actuals; i++)\n \t    {\n \t      args[i].value = 0;\n \t      args[i].aligned_regs = 0;\n@@ -3391,7 +3387,7 @@ expand_call (exp, target, ignore)\n      function who's expansion contains another CALL_PLACEHOLDER.\n \n      If there are any C_Ps in any of these sequences, replace them\n-     with their normal call. */\n+     with their normal call.  */\n \n   for (insn = normal_call_insns; insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == CALL_INSN\n@@ -3462,7 +3458,7 @@ libfunc_nothrow (fun)\n }\n \f\n /* Output a library call to function FUN (a SYMBOL_REF rtx).\n-   The RETVAL parameter specifies whether return value needs to be saved, other \n+   The RETVAL parameter specifies whether return value needs to be saved, other\n    parameters are documented in the emit_library_call function bellow.  */\n static rtx\n emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n@@ -3485,8 +3481,16 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   struct args_size alignment_pad;\n   rtx argblock = 0;\n   CUMULATIVE_ARGS args_so_far;\n-  struct arg { rtx value; enum machine_mode mode; rtx reg; int partial;\n-\t       struct args_size offset; struct args_size size; rtx save_area; };\n+  struct arg\n+  {\n+    rtx value;\n+    enum machine_mode mode;\n+    rtx reg;\n+    int partial;\n+    struct args_size offset;\n+    struct args_size size;\n+    rtx save_area;\n+  };\n   struct arg *argvec;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   rtx call_fusage = 0;\n@@ -3502,7 +3506,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n   int low_to_save = -1, high_to_save = 0;\n-  rtx save_area = 0;            /* Place that it is saved */\n+  rtx save_area = 0;            /* Place that it is saved.  */\n #endif\n \n   /* Size of the stack reserved for parameter registers.  */\n@@ -3614,7 +3618,6 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t\t\t   NULL_TREE, &args_size, &argvec[count].offset,\n \t\t\t   &argvec[count].size, &alignment_pad);\n \n-\n       if (argvec[count].reg == 0 || argvec[count].partial != 0\n \t  || reg_parm_stack_space > 0)\n \targs_size.constant += argvec[count].size.constant;\n@@ -3676,7 +3679,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n       locate_and_pad_parm (mode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n-                           1,\n+\t\t\t   1,\n #else\n \t\t\t   argvec[count].reg != 0,\n #endif\n@@ -3767,8 +3770,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \n       /* The address of the outgoing argument list must not be copied to a\n \t register here, because argblock would be left pointing to the\n-\t wrong place after the call to allocate_dynamic_stack_space below.\n-\t */\n+\t wrong place after the call to allocate_dynamic_stack_space below.  */\n \n       argblock = virtual_outgoing_args_rtx;\n     }\n@@ -3812,7 +3814,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n       for (count = 0; count < reg_parm_stack_space; count++)\n #endif\n \t{\n-\t  if (count >=  highest_outgoing_arg_in_use\n+\t  if (count >= highest_outgoing_arg_in_use\n \t      || stack_usage_map[count] == 0)\n \t    continue;\n \n@@ -3838,7 +3840,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t  stack_area = gen_rtx_MEM (save_mode,\n \t\t\t\t    memory_address (save_mode,\n \t\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t\t   - high_to_save)));\n+\t\t\t\t\t\t\t\t   -high_to_save)));\n #else\n \t  stack_area = gen_rtx_MEM (save_mode,\n \t\t\t\t    memory_address (save_mode,\n@@ -3859,7 +3861,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t}\n     }\n #endif\n-\t  \n+\n   /* Push the args that need to be pushed.  */\n \n   /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n@@ -3899,7 +3901,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t      if (i != upper_bound)\n \t\t{\n \t\t  /* We need to make a save area.  See what mode we can make\n-\t\t     it. */\n+\t\t     it.  */\n \t\t  enum machine_mode save_mode\n \t\t    = mode_for_size (argvec[argnum].size.constant\n \t\t\t\t     * BITS_PER_UNIT,\n@@ -3985,7 +3987,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t\t\t\t force_operand (XEXP (mem_value, 0),\n \t\t\t\t\t\tNULL_RTX)));\n       if (GET_CODE (struct_value_rtx) == REG)\n-\t  use_reg (&call_fusage, struct_value_rtx);\n+\tuse_reg (&call_fusage, struct_value_rtx);\n     }\n \n   /* Don't allow popping to be deferred, since then\n@@ -3997,7 +3999,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n #ifdef PREFERRED_STACK_BOUNDARY\n   /* Stack must be properly aligned now.  */\n   if (stack_pointer_delta & (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1))\n-    abort();\n+    abort ();\n #endif\n \n   /* We pass the old value of inhibit_defer_pop + 1 to emit_call_1, which\n@@ -4007,11 +4009,11 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      always signed.  We also assume that the list of arguments passed has\n      no impact, so we pretend it is unknown.  */\n \n-  emit_call_1 (fun, \n-               get_identifier (XSTR (orgfun, 0)),\n+  emit_call_1 (fun,\n+\t       get_identifier (XSTR (orgfun, 0)),\n \t       build_function_type (outmode == VOIDmode ? void_type_node\n \t\t\t\t    : type_for_mode (outmode, 0), NULL_TREE),\n-               original_args_size.constant, args_size.constant,\n+\t       original_args_size.constant, args_size.constant,\n \t       struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       valreg,\n@@ -4103,7 +4105,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t\t\t     PARM_BOUNDARY);\n \t}\n #endif\n-\t      \n+\n       /* If we saved any argument areas, restore them.  */\n       for (count = 0; count < nargs; count++)\n \tif (argvec[count].save_area)\n@@ -4249,20 +4251,19 @@ target_for_arg (type, size, args_addr, offset)\n    or 0 on a machine where arguments are pushed individually.\n \n    MAY_BE_ALLOCA nonzero says this could be a call to `alloca'\n-   so must be careful about how the stack is used. \n+   so must be careful about how the stack is used.\n \n    VARIABLE_SIZE nonzero says that this was a variable-sized outgoing\n    argument stack.  This is used if ACCUMULATE_OUTGOING_ARGS to indicate\n    that we need not worry about saving and restoring the stack.\n \n    FNDECL is the declaration of the function we are calling.\n-   \n+\n    Return non-zero if this arg should cause sibcall failure,\n    zero otherwise.  */\n \n static int\n-store_one_arg (arg, argblock, flags, variable_size,\n-\t       reg_parm_stack_space)\n+store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n      struct arg_data *arg;\n      rtx argblock;\n      int flags;\n@@ -4330,7 +4331,7 @@ store_one_arg (arg, argblock, flags, variable_size,\n \t\t\t\t\t\t      arg->size.constant, 0);\n \t\t  MEM_SET_IN_STRUCT_P (arg->save_area,\n \t\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE\n-\t\t\t\t\t\t\t (arg->tree_value))); \n+\t\t\t\t\t\t\t (arg->tree_value)));\n \t\t  preserve_temp_slots (arg->save_area);\n \t\t  emit_block_move (validize_mem (arg->save_area), stack_area,\n \t\t\t\t   GEN_INT (arg->size.constant),\n@@ -4366,7 +4367,7 @@ store_one_arg (arg, argblock, flags, variable_size,\n      here.  */\n   if (arg->n_aligned_regs != 0)\n     reg = 0;\n-  \n+\n   /* If this is being passed partially in a register, we can't evaluate\n      it directly into its stack slot.  Otherwise, we can.  */\n   if (arg->value == 0)\n@@ -4420,7 +4421,7 @@ store_one_arg (arg, argblock, flags, variable_size,\n       if (current_function_check_memory_usage && GET_CODE (arg->stack) == MEM)\n \t{\n \t  emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t     XEXP (arg->stack, 0), Pmode, \n+\t\t\t     XEXP (arg->stack, 0), Pmode,\n \t\t\t     ARGS_SIZE_RTX (arg->size),\n \t\t\t     TYPE_MODE (sizetype),\n \t\t\t     GEN_INT (MEMORY_USE_RW),\n@@ -4434,7 +4435,7 @@ store_one_arg (arg, argblock, flags, variable_size,\n       /* Argument is a scalar, not entirely passed in registers.\n \t (If part is passed in registers, arg->partial says how much\n \t and emit_push_insn will take care of putting it there.)\n-\t \n+\n \t Push it, and if its size is less than the\n \t amount of space allocated to it,\n \t also bump stack pointer by the additional space.\n@@ -4532,9 +4533,8 @@ store_one_arg (arg, argblock, flags, variable_size,\n \t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n     }\n \n-\n   /* Unless this is a partially-in-register argument, the argument is now\n-     in the stack. \n+     in the stack.\n \n      ??? Note that this can change arg->value from arg->stack to\n      arg->stack_slot and it matters when they are not the same."}]}