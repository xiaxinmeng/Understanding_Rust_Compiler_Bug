{"sha": "bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMwOGVjYmEyYjM1MzA5NDRhOWZkMDNhY2M5MGFhN2NkNTI4OWJkMQ==", "commit": {"author": {"name": "Prasad Ghangal", "email": "prasad.ghangal@gmail.com", "date": "2016-11-14T14:13:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-11-14T14:13:32Z"}, "message": "Make-lang.in (C_AND_OBJC_OBJS): Add gimple-parser.o.\n\n2016-11-14  Prasad Ghangal  <prasad.ghangal@gmail.com>\n\tRichard Biener  <rguenther@suse.de>\n    \n    \tc/\n    \t* Make-lang.in (C_AND_OBJC_OBJS): Add gimple-parser.o.\n    \t* config-lang.in (gtfiles): Add c/c-parser.h.\n    \t* c-tree.h (enum c_declspec_word): Add cdw_gimple.\n    \t(struct c_declspecs): Add gimple_pass member and gimple_p flag.\n    \t* c-parser.c (enum c_id_kind, struct c_token,\n    \tc_parser_next_token_is, c_parser_next_token_is_not,\n    \tc_parser_next_token_is_keyword,\n    \tenum c_lookahead_kind, enum c_dtr_syn, enum c_parser_prec):\n    \tSplit out to ...\n    \t* c-parser.h: ... new header.\n    \t* c-parser.c: Include c-parser.h and gimple-parser.h.\n\t(c_parser_peek_token, c_parser_peek_2nd_token,\n    \tc_token_starts_typename, c_parser_next_token_starts_declspecs,\n    \tc_parser_next_tokens_start_declaration, c_parser_consume_token,\n    \tc_parser_error, c_parser_require, c_parser_skip_until_found,\n    \tc_parser_declspecs, c_parser_declarator, c_parser_peek_nth_token,\n    \tc_parser_type_name): Export.\n    \t(c_parser_tokens_buf): New function.\n    \t(c_parser_error): Likewise.\n    \t(c_parser_set_error): Likewise.\n    \t(c_parser_declspecs): Handle RID_GIMPLE.\n\t(c_parser_declaration_or_fndef): Parse __GIMPLE marked body\n\tvia c_parser_parse_gimple_body.\n    \t* c-parser.h (c_parser_peek_token, c_parser_peek_2nd_token,\n    \tc_token_starts_typename, c_parser_next_token_starts_declspecs,\n    \tc_parser_next_tokens_start_declaration, c_parser_consume_token,\n    \tc_parser_error, c_parser_require, c_parser_skip_until_found,\n    \tc_parser_declspecs, c_parser_declarator, c_parser_peek_nth_token,\n    \tc_parser_type_name): Declare.\n\t(struct c_parser): Declare forward.\n\t(c_parser_tokens_buf): Declare.\n        (c_parser_error): Likewise.\n        (c_parser_set_error): Likewise.\n    \t* gimple-parser.c: New file.\n    \t* gimple-parser.h: Likewise.\n    \n    \tobj-c/\n    \t* config-lang.in (gtfiles): Add c/c-parser.h.\n\n    \tc-family/\n    \t* c-common.h (c_common_resword): Add RID_GIMPLE, RID_PHI types.\n    \t* c-common.h (enum rid): Add RID_GIMPLE, RID_PHI.\n    \t* c.opt (fgimple): New option.\n\n\t* doc/invoke.texi (fgimple): Document.\n \n    \t* dumpfile.h (TDF_GIMPLE): Add.\n    \t* dumpfile.c (dump_options): Add gimple.\n    \t* gimple-pretty-print.c (dump_gimple_switch): Adjust dump\n\tfor TDF_GIMPLE.\n\t(dump_gimple_label): Likewise.\n\t(dump_gimple_phi): Likewise.\n\t(dump_gimple_bb_header): Likewise.\n\t(dump_phi_nodes): Likewise.\n\t(pp_cfg_jump): Likewise.  Pass in dump flags.\n\t(dump_implicit_edges): Adjust.\n    \t* passes.c (pass_init_dump_file): Do not dump function header\n    \tfor TDF_GIMPLE.\n    \t* tree-cfg.c (dump_function_to_file): Dump function return type\n\tand __GIMPLE keyword for TDF_GIMPLE.  Change guard for dumping\n\tGIMPLE stmts.\n    \t* tree-pretty-print.c (dump_decl_name): Adjust dump for TDF_GIMPLE.\n    \t(dump_generic_node): Likewise.\n\n\t* function.h (struct function): Add pass_startwith member.\n\t* passes.c (execute_one_pass): Implement startwith.\n\n    \t* tree-ssanames.c (make_ssa_name_fn): New argument, check for version\n    \tand assign proper version for parsed ssa names.\n    \t* tree-ssanames.h (make_ssa_name_fn): Add new argument to the function.\n    \t* internal-fn.c (expand_PHI): New function.\n    \t* internal-fn.h (expand_PHI): Declared here.\n    \t* internal-fn.def: New defination for PHI.\n    \t* tree-cfg.c (lower_phi_internal_fn): New function.\n\t(build_gimple_cfg): Call it.\n    \t(verify_gimple_call): Condition for passing label as arg in internal\n    \tfunction PHI.\n\t* tree-into-ssa.c (rewrite_add_phi_arguments): Handle already\n\tpresent PHIs with arguments.\n\n    \ttestsuite/\n    \t* gcc.dg/gimplefe-1.c: New testcase.\n    \t* gcc.dg/gimplefe-2.c: Likewise.\n    \t* gcc.dg/gimplefe-3.c: Likewise.\n    \t* gcc.dg/gimplefe-4.c: Likewise.\n    \t* gcc.dg/gimplefe-5.c: Likewise.\n    \t* gcc.dg/gimplefe-6.c: Likewise.\n    \t* gcc.dg/gimplefe-7.c: Likewise.\n    \t* gcc.dg/gimplefe-8.c: Likewise.\n    \t* gcc.dg/gimplefe-9.c: Likewise.\n    \t* gcc.dg/gimplefe-10.c: Likewise.\n    \t* gcc.dg/gimplefe-11.c: Likewise.\n    \t* gcc.dg/gimplefe-12.c: Likewise.\n    \t* gcc.dg/gimplefe-13.c: Likewise.\n    \t* gcc.dg/gimplefe-14.c: Likewise.\n    \t* gcc.dg/gimplefe-15.c: Likewise.\n    \t* gcc.dg/gimplefe-16.c: Likewise.\n    \t* gcc.dg/gimplefe-17.c: Likewise.\n    \t* gcc.dg/gimplefe-18.c: Likewise.\n\nFrom-SVN: r242388", "tree": {"sha": "0c6654faae2b87c8a413b38b923795a69b96beb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c6654faae2b87c8a413b38b923795a69b96beb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/comments", "author": {"login": "PrasadG193", "id": 7098659, "node_id": "MDQ6VXNlcjcwOTg2NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/7098659?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PrasadG193", "html_url": "https://github.com/PrasadG193", "followers_url": "https://api.github.com/users/PrasadG193/followers", "following_url": "https://api.github.com/users/PrasadG193/following{/other_user}", "gists_url": "https://api.github.com/users/PrasadG193/gists{/gist_id}", "starred_url": "https://api.github.com/users/PrasadG193/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PrasadG193/subscriptions", "organizations_url": "https://api.github.com/users/PrasadG193/orgs", "repos_url": "https://api.github.com/users/PrasadG193/repos", "events_url": "https://api.github.com/users/PrasadG193/events{/privacy}", "received_events_url": "https://api.github.com/users/PrasadG193/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ee62b926411dda2bffbca8019b494481183ee15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ee62b926411dda2bffbca8019b494481183ee15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ee62b926411dda2bffbca8019b494481183ee15"}], "stats": {"total": 1977, "additions": 1977, "deletions": 0}, "files": [{"sha": "ff8aceb8b83e9e8ee7b36b5f5759bc03031ee148", "filename": "gcc/c/c-parser.h", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Fc%2Fc-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Fc%2Fc-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.h?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,189 @@\n+/* Declarations for the parser for C and Objective-C.\n+   Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+\n+   Parser actions based on the old Bison parser; structure somewhat\n+   influenced by and fragments based on the C++ parser.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_C_PARSER_H\n+#define GCC_C_PARSER_H\n+\n+/* The C lexer intermediates between the lexer in cpplib and c-lex.c\n+   and the C parser.  Unlike the C++ lexer, the parser structure\n+   stores the lexer information instead of using a separate structure.\n+   Identifiers are separated into ordinary identifiers, type names,\n+   keywords and some other Objective-C types of identifiers, and some\n+   look-ahead is maintained.\n+\n+   ??? It might be a good idea to lex the whole file up front (as for\n+   C++).  It would then be possible to share more of the C and C++\n+   lexer code, if desired.  */\n+\n+/* More information about the type of a CPP_NAME token.  */\n+enum c_id_kind {\n+  /* An ordinary identifier.  */\n+  C_ID_ID,\n+  /* An identifier declared as a typedef name.  */\n+  C_ID_TYPENAME,\n+  /* An identifier declared as an Objective-C class name.  */\n+  C_ID_CLASSNAME,\n+  /* An address space identifier.  */\n+  C_ID_ADDRSPACE,\n+  /* Not an identifier.  */\n+  C_ID_NONE\n+};\n+\n+/* A single C token after string literal concatenation and conversion\n+   of preprocessing tokens to tokens.  */\n+struct GTY (()) c_token {\n+  /* The kind of token.  */\n+  ENUM_BITFIELD (cpp_ttype) type : 8;\n+  /* If this token is a CPP_NAME, this value indicates whether also\n+     declared as some kind of type.  Otherwise, it is C_ID_NONE.  */\n+  ENUM_BITFIELD (c_id_kind) id_kind : 8;\n+  /* If this token is a keyword, this value indicates which keyword.\n+     Otherwise, this value is RID_MAX.  */\n+  ENUM_BITFIELD (rid) keyword : 8;\n+  /* If this token is a CPP_PRAGMA, this indicates the pragma that\n+     was seen.  Otherwise it is PRAGMA_NONE.  */\n+  ENUM_BITFIELD (pragma_kind) pragma_kind : 8;\n+  /* The location at which this token was found.  */\n+  location_t location;\n+  /* The value associated with this token, if any.  */\n+  tree value;\n+  /* Token flags.  */\n+  unsigned char flags;\n+\n+  source_range get_range () const\n+  {\n+    return get_range_from_loc (line_table, location);\n+  }\n+\n+  location_t get_finish () const\n+  {\n+    return get_range ().m_finish;\n+  }\n+};\n+\n+/* The parser.  */\n+struct c_parser;\n+\n+/* Possibly kinds of declarator to parse.  */\n+enum c_dtr_syn {\n+  /* A normal declarator with an identifier.  */\n+  C_DTR_NORMAL,\n+  /* An abstract declarator (maybe empty).  */\n+  C_DTR_ABSTRACT,\n+  /* A parameter declarator: may be either, but after a type name does\n+     not redeclare a typedef name as an identifier if it can\n+     alternatively be interpreted as a typedef name; see DR#009,\n+     applied in C90 TC1, omitted from C99 and reapplied in C99 TC2\n+     following DR#249.  For example, given a typedef T, \"int T\" and\n+     \"int *T\" are valid parameter declarations redeclaring T, while\n+     \"int (T)\" and \"int * (T)\" and \"int (T[])\" and \"int (T (int))\" are\n+     abstract declarators rather than involving redundant parentheses;\n+     the same applies with attributes inside the parentheses before\n+     \"T\".  */\n+  C_DTR_PARM\n+};\n+\n+/* The binary operation precedence levels, where 0 is a dummy lowest level\n+   used for the bottom of the stack.  */\n+enum c_parser_prec {\n+  PREC_NONE,\n+  PREC_LOGOR,\n+  PREC_LOGAND,\n+  PREC_BITOR,\n+  PREC_BITXOR,\n+  PREC_BITAND,\n+  PREC_EQ,\n+  PREC_REL,\n+  PREC_SHIFT,\n+  PREC_ADD,\n+  PREC_MULT,\n+  NUM_PRECS\n+};\n+\n+enum c_lookahead_kind {\n+  /* Always treat unknown identifiers as typenames.  */\n+  cla_prefer_type,\n+\n+  /* Could be parsing a nonabstract declarator.  Only treat an identifier\n+     as a typename if followed by another identifier or a star.  */\n+  cla_nonabstract_decl,\n+\n+  /* Never treat identifiers as typenames.  */\n+  cla_prefer_id\n+};\n+\n+\n+extern c_token * c_parser_peek_token (c_parser *parser);\n+extern c_token * c_parser_peek_2nd_token (c_parser *parser);\n+extern c_token * c_parser_peek_nth_token (c_parser *parser, unsigned int n);\n+extern bool c_parser_require (c_parser *parser, enum cpp_ttype type,\n+\t\t\t      const char *msgid);\n+extern void c_parser_error (c_parser *parser, const char *gmsgid);\n+extern void c_parser_consume_token (c_parser *parser);\n+extern void c_parser_skip_until_found (c_parser *parser, enum cpp_ttype type,\n+\t\t\t\t       const char *msgid);\n+extern bool c_parser_next_token_starts_declspecs (c_parser *parser);\n+bool c_parser_next_tokens_start_declaration (c_parser *parser);\n+bool c_token_starts_typename (c_token *token);\n+\n+/* Abstraction to avoid defining c_parser here which messes up gengtype\n+   output wrt ObjC due to vec<c_token> routines being put in gtype-c.h\n+   but not gtype-objc.h.  */\n+extern c_token * c_parser_tokens_buf (c_parser *parser, unsigned n);\n+extern bool c_parser_error (c_parser *parser);\n+extern void c_parser_set_error (c_parser *parser, bool);\n+\n+/* Return true if the next token from PARSER has the indicated\n+   TYPE.  */\n+\n+static inline bool\n+c_parser_next_token_is (c_parser *parser, enum cpp_ttype type)\n+{\n+  return c_parser_peek_token (parser)->type == type;\n+}\n+\n+/* Return true if the next token from PARSER does not have the\n+   indicated TYPE.  */\n+\n+static inline bool\n+c_parser_next_token_is_not (c_parser *parser, enum cpp_ttype type)\n+{\n+  return !c_parser_next_token_is (parser, type);\n+}\n+\n+/* Return true if the next token from PARSER is the indicated\n+   KEYWORD.  */\n+\n+static inline bool\n+c_parser_next_token_is_keyword (c_parser *parser, enum rid keyword)\n+{\n+  return c_parser_peek_token (parser)->keyword == keyword;\n+}\n+\n+extern struct c_declarator *\n+c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n+\t\t     bool *seen_id);\n+extern void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n+\t\t\t\tbool, bool, bool, enum c_lookahead_kind);\n+extern struct c_type_name *c_parser_type_name (c_parser *);\n+\n+#endif"}, {"sha": "9b6af13257f618a7b80ce491bbfdea0d61acf201", "filename": "gcc/c/gimple-parser.c", "status": "added", "additions": 1435, "deletions": 0, "changes": 1435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,1435 @@\n+/* Parser for GIMPLE.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"function.h\"\n+#include \"c-tree.h\"\n+#include \"timevar.h\"\n+#include \"stringpool.h\"\n+#include \"cgraph.h\"\n+#include \"attribs.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"trans-mem.h\"\n+#include \"c-family/c-pragma.h\"\n+#include \"c-lang.h\"\n+#include \"c-family/c-objc.h\"\n+#include \"plugin.h\"\n+#include \"omp-low.h\"\n+#include \"builtins.h\"\n+#include \"gomp-constants.h\"\n+#include \"c-family/c-indentation.h\"\n+#include \"gimple-expr.h\"\n+#include \"context.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"c-parser.h\"\n+#include \"tree-vrp.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tree.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-ssa.h\"\n+#include \"pass_manager.h\"\n+#include \"tree-ssanames.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-dfa.h\"\n+#include \"tree-dump.h\"\n+\n+\n+/* Gimple parsing functions.  */\n+static bool c_parser_gimple_compound_statement (c_parser *, gimple_seq *);\n+static void c_parser_gimple_label (c_parser *, gimple_seq *);\n+static void c_parser_gimple_statement (c_parser *, gimple_seq *);\n+static struct c_expr c_parser_gimple_binary_expression (c_parser *);\n+static struct c_expr c_parser_gimple_unary_expression (c_parser *);\n+static struct c_expr c_parser_gimple_postfix_expression (c_parser *);\n+static struct c_expr c_parser_gimple_postfix_expression_after_primary (c_parser *,\n+\t\t\t\t\t\t\t\t       location_t,\n+\t\t\t\t\t\t\t\t       struct c_expr);\n+static void c_parser_gimple_declaration (c_parser *);\n+static void c_parser_gimple_goto_stmt (location_t, tree, gimple_seq *);\n+static void c_parser_gimple_if_stmt (c_parser *, gimple_seq *);\n+static void c_parser_gimple_switch_stmt (c_parser *, gimple_seq *);\n+static void c_parser_gimple_return_stmt (c_parser *, gimple_seq *);\n+static void c_finish_gimple_return (location_t, tree);\n+static tree c_parser_gimple_paren_condition (c_parser *);\n+static vec<tree, va_gc> *c_parser_gimple_expr_list (c_parser *,\n+\t\t    vec<tree, va_gc> **, vec<location_t> *);\n+\n+\n+/* Parse the body of a function declaration marked with \"__GIMPLE\".  */\n+\n+void\n+c_parser_parse_gimple_body (c_parser *parser)\n+{\n+  gimple_seq seq = NULL;\n+  gimple_seq body = NULL;\n+  tree stmt = push_stmt_list ();\n+  push_scope ();\n+  location_t loc1 = c_parser_peek_token (parser)->location;\n+\n+  init_tree_ssa (cfun);\n+\n+  if (! c_parser_gimple_compound_statement (parser, &seq))\n+    {\n+      gimple *ret = gimple_build_return (NULL);\n+      gimple_seq_add_stmt (&seq, ret);\n+    }\n+\n+  tree block = pop_scope ();\n+  stmt = pop_stmt_list (stmt);\n+  stmt = c_build_bind_expr (loc1, block, stmt);\n+\n+  block = DECL_INITIAL (current_function_decl);\n+  BLOCK_SUBBLOCKS (block) = NULL_TREE;\n+  BLOCK_CHAIN (block) = NULL_TREE;\n+  TREE_ASM_WRITTEN (block) = 1;\n+\n+  gbind *bind_stmt = gimple_build_bind (BIND_EXPR_VARS (stmt), NULL,\n+\t\t\t\t\tBIND_EXPR_BLOCK (stmt));\n+  gimple_bind_set_body (bind_stmt, seq);\n+  gimple_seq_add_stmt (&body, bind_stmt);\n+  gimple_set_body (current_function_decl, body);\n+\n+  /* While we have SSA names in the IL we do not have a CFG built yet\n+     and PHIs are represented using a PHI internal function.  We do\n+     have lowered control flow and exception handling (well, we do not\n+     have parser support for EH yet).  But as we still have BINDs\n+     we have to go through lowering again.  */\n+  cfun->curr_properties = PROP_gimple_any;\n+\n+  dump_function (TDI_generic, current_function_decl);\n+}\n+\n+/* Parse a compound statement in gimple function body.\n+\n+   gimple-statement:\n+     gimple-statement\n+     gimple-declaration-statement\n+     gimple-if-statement\n+     gimple-switch-statement\n+     gimple-labeled-statement\n+     gimple-expression-statement\n+     gimple-goto-statement\n+     gimple-phi-statement\n+     gimple-return-statement\n+*/\n+\n+static bool\n+c_parser_gimple_compound_statement (c_parser *parser, gimple_seq *seq)\n+{\n+  bool return_p = false;\n+\n+  if (! c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n+    return false;\n+\n+  /* A compund statement starts with optional declarations.  */\n+  while (c_parser_next_tokens_start_declaration (parser))\n+    {\n+      c_parser_gimple_declaration (parser);\n+      if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+\treturn false;\n+    }\n+\n+  while (c_parser_next_token_is_not (parser, CPP_CLOSE_BRACE))\n+    {\n+      if (c_parser_error (parser))\n+\t{\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);\n+\t  return return_p;\n+\t}\n+      else if (c_parser_next_token_is (parser, CPP_EOF))\n+\t{\n+\t  c_parser_error (parser, \"expected declaration or statement\");\n+\t  return return_p;\n+\t}\n+\n+      switch (c_parser_peek_token (parser)->type)\n+\t{\n+\tcase CPP_KEYWORD:\n+\t  switch (c_parser_peek_token (parser)->keyword)\n+\t    {\n+\t    case RID_IF:\n+\t      c_parser_gimple_if_stmt (parser, seq);\n+\t      break;\n+\t    case RID_SWITCH:\n+\t      c_parser_gimple_switch_stmt (parser, seq);\n+\t      break;\n+\t    case RID_GOTO:\n+\t      {\n+\t\tlocation_t loc = c_parser_peek_token (parser)->location;\n+\t\tc_parser_consume_token (parser);\n+\t\tif (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t  {\n+\t\t    c_parser_gimple_goto_stmt (loc,\n+\t\t\t\t\t       c_parser_peek_token\n+\t\t\t\t\t       (parser)->value,\n+\t\t\t\t\t       seq);\n+\t\t    c_parser_consume_token (parser);\n+\t\t    if (! c_parser_require (parser, CPP_SEMICOLON,\n+\t\t\t\t\t    \"expected %<;%>\"))\n+\t\t      return return_p;\n+\t\t  }\n+\t\t}\n+\t      break;\n+\t    case RID_RETURN:\n+\t      return_p = true;\n+\t      c_parser_gimple_return_stmt (parser, seq);\n+\t      if (! c_parser_require (parser, CPP_SEMICOLON,\n+\t\t\t\t      \"expected %<;%>\"))\n+\t\treturn return_p;\n+\t      break;\n+\t    default:\n+\t      goto expr_stmt;\n+\t    }\n+\t  break;\n+\tcase CPP_NAME:\n+\t  if (c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+\t    {\n+\t      c_parser_gimple_label (parser, seq);\n+\t      break;\n+\t    }\n+\t  goto expr_stmt;\n+\n+\tdefault:\n+expr_stmt:\n+\t  c_parser_gimple_statement (parser, seq);\n+\t  if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+\t    return return_p;\n+\t}\n+    }\n+  c_parser_consume_token (parser);\n+  return return_p;\n+}\n+\n+/* Parse a gimple statement.\n+\n+   gimple-statement:\n+     gimple-call-expression\n+     gimple-assign-statement\n+     gimple-phi-statement\n+\n+   gimple-assign-statement:\n+     gimple-unary-expression = gimple-assign-rhs\n+ \n+   gimple-assign-rhs:\n+     gimple-cast-expression\n+     gimple-unary-expression\n+     gimple-binary-expression\n+     gimple-call-expression\n+\n+   gimple-phi-statement:\n+     identifier = __PHI ( label : gimple_primary-expression, ... )\n+\n+   gimple-call-expr:\n+     gimple-primary-expression ( argument-list )\n+\n+   gimple-cast-expression:\n+     ( type-name ) gimple-primary-expression\n+\n+*/\n+\n+static void\n+c_parser_gimple_statement (c_parser *parser, gimple_seq *seq)\n+{\n+  struct c_expr lhs, rhs;\n+  gimple *assign = NULL;\n+  location_t loc;\n+  tree arg = NULL_TREE;\n+  auto_vec<tree> vargs;\n+\n+  lhs = c_parser_gimple_unary_expression (parser);\n+  loc = EXPR_LOCATION (lhs.value);\n+  rhs.value = error_mark_node;\n+\n+  /* GIMPLE call statement without LHS.  */\n+  if (c_parser_next_token_is (parser, CPP_SEMICOLON)\n+      && TREE_CODE (lhs.value) == CALL_EXPR)\n+    {\n+      gimple *call;\n+      call = gimple_build_call_from_tree (lhs.value);\n+      gimple_seq_add_stmt (seq, call);\n+      gimple_set_location (call, loc);\n+      return;\n+    }\n+\n+  /* All following cases are statements with LHS.  */\n+  if (! c_parser_require (parser, CPP_EQ, \"expected %<=%>\"))\n+    return;\n+\n+  /* Cast expression.  */\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n+      && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n+    {\n+      c_parser_consume_token (parser);\n+      struct c_type_name *type_name = c_parser_type_name (parser);\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      if (type_name == NULL)\n+\treturn;\n+      /* ???  The actual type used in the cast expression is ignored as\n+         in GIMPLE it is encoded by the type of the LHS.  */\n+      rhs = c_parser_gimple_postfix_expression (parser);\n+      if (lhs.value != error_mark_node\n+\t  && rhs.value != error_mark_node)\n+\t{\n+\t  enum tree_code code = NOP_EXPR;\n+\t  if (VECTOR_TYPE_P (TREE_TYPE (lhs.value)))\n+\t    {\n+\t      code = VIEW_CONVERT_EXPR;\n+\t      rhs.value = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t  TREE_TYPE (lhs.value), rhs.value);\n+\t    }\n+\t  else if (FLOAT_TYPE_P (TREE_TYPE (lhs.value))\n+\t\t   && ! FLOAT_TYPE_P (TREE_TYPE (rhs.value)))\n+\t    code = FLOAT_EXPR;\n+\t  else if (! FLOAT_TYPE_P (TREE_TYPE (lhs.value))\n+\t\t   && FLOAT_TYPE_P (TREE_TYPE (rhs.value)))\n+\t    code = FIX_TRUNC_EXPR;\n+\t  assign = gimple_build_assign (lhs.value, code, rhs.value);\n+\t  gimple_seq_add_stmt (seq, assign);\n+\t  gimple_set_location (assign, loc);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Unary expression.  */\n+  switch (c_parser_peek_token (parser)->type)\n+    {\n+    case CPP_KEYWORD:\n+      if (c_parser_peek_token (parser)->keyword != RID_REALPART\n+\t  && c_parser_peek_token (parser)->keyword != RID_IMAGPART)\n+\tbreak;\n+      /* Fallthru.  */\n+    case CPP_AND:\n+    case CPP_PLUS:\n+    case CPP_MINUS:\n+    case CPP_COMPL:\n+    case CPP_NOT:\n+    case CPP_MULT: /* pointer deref */\n+      rhs = c_parser_gimple_unary_expression (parser);\n+      assign = gimple_build_assign (lhs.value, rhs.value);\n+      gimple_set_location (assign, loc);\n+      gimple_seq_add_stmt (seq, assign);\n+      return;\n+\n+    default:;\n+    }\n+\n+  /* GIMPLE PHI statement.  */\n+  if (c_parser_next_token_is_keyword (parser, RID_PHI))\n+    {\n+      c_parser_consume_token (parser);\n+\n+      if (! c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\treturn;\n+\n+      if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+\tc_parser_consume_token (parser);\n+\n+      while (c_parser_next_token_is_not (parser, CPP_CLOSE_PAREN))\n+\t{\n+\t  if (c_parser_next_token_is (parser, CPP_NAME)\n+\t      && c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n+\t    {\n+\t      arg = lookup_label_for_goto (loc,\n+\t\t\t\t\t   c_parser_peek_token (parser)->value);\n+\t      c_parser_consume_token (parser);\n+\n+\t      if (c_parser_next_token_is (parser, CPP_COLON))\n+\t\tc_parser_consume_token (parser);\n+\t      vargs.safe_push (arg);\n+\t    }\n+\t  else if (c_parser_next_token_is (parser, CPP_COMMA))\n+\t    c_parser_consume_token (parser);\n+\t  else\n+\t    {\n+\t      arg = c_parser_gimple_unary_expression (parser).value;\n+\t      vargs.safe_push (arg);\n+\t    }\n+\t}\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t \"expected %<)%>\");\n+\n+      /* Build internal function for PHI.  */\n+      gcall *call_stmt = gimple_build_call_internal_vec (IFN_PHI, vargs);\n+      gimple_call_set_lhs (call_stmt, lhs.value);\n+      gimple_set_location (call_stmt, UNKNOWN_LOCATION);\n+      gimple_seq_add_stmt (seq, call_stmt);\n+      return;\n+    }\n+\n+  /* GIMPLE call with lhs.  */\n+  if (c_parser_next_token_is (parser, CPP_NAME)\n+      && c_parser_peek_2nd_token (parser)->type == CPP_OPEN_PAREN\n+      && lookup_name (c_parser_peek_token (parser)->value))\n+    {\n+      rhs = c_parser_gimple_unary_expression (parser);\n+      gimple *call = gimple_build_call_from_tree (rhs.value);\n+      gimple_call_set_lhs (call, lhs.value);\n+      gimple_seq_add_stmt (seq, call);\n+      gimple_set_location (call, loc);\n+      return;\n+    }\n+\n+  rhs = c_parser_gimple_binary_expression (parser);\n+  if (lhs.value != error_mark_node\n+      && rhs.value != error_mark_node)\n+    {\n+      assign = gimple_build_assign (lhs.value, rhs.value);\n+      gimple_seq_add_stmt (seq, assign);\n+      gimple_set_location (assign, loc);\n+    }\n+  return;\n+}\n+\n+/* Parse gimple binary expr.\n+\n+   gimple-binary-expression:\n+     gimple-unary-expression * gimple-unary-expression\n+     gimple-unary-expression / gimple-unary-expression\n+     gimple-unary-expression % gimple-unary-expression\n+     gimple-unary-expression + gimple-unary-expression\n+     gimple-unary-expression - gimple-unary-expression\n+     gimple-unary-expression << gimple-unary-expression\n+     gimple-unary-expression >> gimple-unary-expression\n+     gimple-unary-expression < gimple-unary-expression\n+     gimple-unary-expression > gimple-unary-expression\n+     gimple-unary-expression <= gimple-unary-expression\n+     gimple-unary-expression >= gimple-unary-expression\n+     gimple-unary-expression == gimple-unary-expression\n+     gimple-unary-expression != gimple-unary-expression\n+     gimple-unary-expression & gimple-unary-expression\n+     gimple-unary-expression ^ gimple-unary-expression\n+     gimple-unary-expression | gimple-unary-expression\n+\n+*/\n+\n+static c_expr\n+c_parser_gimple_binary_expression (c_parser *parser)\n+{\n+  /* Location of the binary operator.  */\n+  struct c_expr ret, lhs, rhs;\n+  enum tree_code code = ERROR_MARK;\n+  ret.value = error_mark_node;\n+  lhs = c_parser_gimple_postfix_expression (parser);\n+  if (c_parser_error (parser))\n+    return ret;\n+  tree ret_type = TREE_TYPE (lhs.value);\n+  switch (c_parser_peek_token (parser)->type)\n+    {\n+    case CPP_MULT:\n+      code = MULT_EXPR;\n+      break;\n+    case CPP_DIV:\n+      code = TRUNC_DIV_EXPR;\n+      break;\n+    case CPP_MOD:\n+      code = TRUNC_MOD_EXPR;\n+      break;\n+    case CPP_PLUS:\n+      if (POINTER_TYPE_P (TREE_TYPE (lhs.value)))\n+\tcode = POINTER_PLUS_EXPR;\n+      else\n+\tcode = PLUS_EXPR;\n+      break;\n+    case CPP_MINUS:\n+      code = MINUS_EXPR;\n+      break;\n+    case CPP_LSHIFT:\n+      code = LSHIFT_EXPR;\n+      break;\n+    case CPP_RSHIFT:\n+      code = RSHIFT_EXPR;\n+      break;\n+    case CPP_LESS:\n+      code = LT_EXPR;\n+      ret_type = boolean_type_node;\n+      break;\n+    case CPP_GREATER:\n+      code = GT_EXPR;\n+      ret_type = boolean_type_node;\n+      break;\n+    case CPP_LESS_EQ:\n+      code = LE_EXPR;\n+      ret_type = boolean_type_node;\n+      break;\n+    case CPP_GREATER_EQ:\n+      code = GE_EXPR;\n+      ret_type = boolean_type_node;\n+      break;\n+    case CPP_EQ_EQ:\n+      code = EQ_EXPR;\n+      ret_type = boolean_type_node;\n+      break;\n+    case CPP_NOT_EQ:\n+      code = NE_EXPR;\n+      ret_type = boolean_type_node;\n+      break;\n+    case CPP_AND:\n+      code = BIT_AND_EXPR;\n+      break;\n+    case CPP_XOR:\n+      code = BIT_XOR_EXPR;\n+      break;\n+    case CPP_OR:\n+      code = BIT_IOR_EXPR;\n+      break;\n+    case CPP_AND_AND:\n+      c_parser_error (parser, \"%<&&%> not valid in GIMPLE\");\n+      return ret;\n+    case CPP_OR_OR:\n+      c_parser_error (parser, \"%<||%> not valid in GIMPLE\");\n+      return ret;\n+    default:\n+      /* Not a binary expression.  */\n+      return lhs;\n+    }\n+  location_t ret_loc = c_parser_peek_token (parser)->location;\n+  c_parser_consume_token (parser);\n+  rhs = c_parser_gimple_postfix_expression (parser);\n+  if (c_parser_error (parser))\n+    return ret;\n+  ret.value = build2_loc (ret_loc, code, ret_type, lhs.value, rhs.value);\n+  return ret;\n+}\n+\n+/* Parse gimple unary expression.\n+\n+   gimple-unary-expression:\n+     gimple-postfix-expression\n+     unary-operator gimple-postfix-expression\n+\n+   unary-operator: one of\n+     & * + - ~\n+*/\n+\n+static c_expr\n+c_parser_gimple_unary_expression (c_parser *parser)\n+{\n+  struct c_expr ret, op;\n+  location_t op_loc = c_parser_peek_token (parser)->location;\n+  location_t finish;\n+  ret.original_code = ERROR_MARK;\n+  ret.original_type = NULL;\n+  ret.value = error_mark_node;\n+  switch (c_parser_peek_token (parser)->type)\n+    {\n+    case CPP_AND:\n+      c_parser_consume_token (parser);\n+      op = c_parser_gimple_postfix_expression (parser);\n+      mark_exp_read (op.value);\n+      return parser_build_unary_op (op_loc, ADDR_EXPR, op);\n+    case CPP_MULT:\n+      {\n+\tc_parser_consume_token (parser);\n+\top = c_parser_gimple_postfix_expression (parser);\n+\tfinish = op.get_finish ();\n+\tlocation_t combined_loc = make_location (op_loc, op_loc, finish);\n+\tret.value = build_simple_mem_ref_loc (combined_loc, op.value);\n+\tTREE_SIDE_EFFECTS (ret.value)\n+\t  = TREE_THIS_VOLATILE (ret.value)\n+\t  = TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (op.value)));\n+\tret.src_range.m_start = op_loc;\n+\tret.src_range.m_finish = finish;\n+\treturn ret;\n+      }\n+    case CPP_PLUS:\n+      c_parser_consume_token (parser);\n+      op = c_parser_gimple_postfix_expression (parser);\n+      return parser_build_unary_op (op_loc, CONVERT_EXPR, op);\n+    case CPP_MINUS:\n+      c_parser_consume_token (parser);\n+      op = c_parser_gimple_postfix_expression (parser);\n+      return parser_build_unary_op (op_loc, NEGATE_EXPR, op);\n+    case CPP_COMPL:\n+      c_parser_consume_token (parser);\n+      op = c_parser_gimple_postfix_expression (parser);\n+      return parser_build_unary_op (op_loc, BIT_NOT_EXPR, op);\n+    case CPP_NOT:\n+      c_parser_error (parser, \"%<!%> not valid in GIMPLE\");\n+      return ret;\n+    case CPP_KEYWORD:\n+      switch (c_parser_peek_token (parser)->keyword)\n+\t{\n+\tcase RID_REALPART:\n+\t  c_parser_consume_token (parser);\n+\t  op = c_parser_gimple_postfix_expression (parser);\n+\t  return parser_build_unary_op (op_loc, REALPART_EXPR, op);\n+\tcase RID_IMAGPART:\n+\t  c_parser_consume_token (parser);\n+\t  op = c_parser_gimple_postfix_expression (parser);\n+\t  return parser_build_unary_op (op_loc, IMAGPART_EXPR, op);\n+\tdefault:\n+\t  return c_parser_gimple_postfix_expression (parser);\n+\t}\n+    default:\n+      return c_parser_gimple_postfix_expression (parser);\n+    }\n+}\n+\n+/* Decompose ID into base name (ID until ver_offset) and VERSION.  Return\n+   true if ID matches a SSA name.  */\n+\n+static bool\n+c_parser_parse_ssa_name_id (tree id, unsigned *version, unsigned *ver_offset)\n+{\n+  const char *token = IDENTIFIER_POINTER (id);\n+  const char *var_version = strrchr (token, '_');\n+  if (! var_version)\n+    return false;\n+\n+  *ver_offset = var_version - token;\n+  for (const char *p = var_version + 1; *p; ++p)\n+    if (! ISDIGIT (*p))\n+      return false;\n+  *version = atoi (var_version + 1);\n+  return *version > 0;\n+}\n+\n+/* Get at the actual SSA name ID with VERSION starting at VER_OFFSET.\n+   TYPE is the type if the SSA name is being declared.  */\n+\n+static tree \n+c_parser_parse_ssa_name (c_parser *parser,\n+\t\t\t tree id, tree type, unsigned version,\n+\t\t\t unsigned ver_offset)\n+{\n+  tree name = NULL_TREE;\n+  const char *token = IDENTIFIER_POINTER (id);\n+\n+  if (ver_offset == 0)\n+    {\n+      /* Anonymous unnamed SSA name.  */\n+      if (version < num_ssa_names)\n+\tname = ssa_name (version);\n+      if (! name)\n+\t{\n+\t  if (! type)\n+\t    {\n+\t      c_parser_error (parser, \"SSA name not declared\"); \n+\t      return error_mark_node;\n+\t    }\n+\t  name = make_ssa_name_fn (cfun, type, NULL, version);\n+\t}\n+    }\n+  else\n+    {\n+      if (version < num_ssa_names)\n+\tname = ssa_name (version);\n+      if (! name)\n+\t{\n+\t  /* Separate var name from version.  */\n+\t  char *var_name = XNEWVEC (char, ver_offset + 1);\n+\t  memcpy (var_name, token, ver_offset);\n+\t  var_name[ver_offset] = '\\0';\n+\t  /* lookup for parent decl.  */\n+\t  id = get_identifier (var_name);\n+\t  tree parent = lookup_name (id);\n+\t  XDELETEVEC (var_name);\n+\t  if (! parent)\n+\t    {\n+\t      c_parser_error (parser, \"base variable or SSA name not declared\"); \n+\t      return error_mark_node;\n+\t    }\n+\t  if (VECTOR_TYPE_P (TREE_TYPE (parent))\n+\t      || TREE_CODE (TREE_TYPE (parent)) == COMPLEX_TYPE)\n+\t    DECL_GIMPLE_REG_P (parent) = 1;\n+\t  name = make_ssa_name_fn (cfun, parent,\n+\t\t\t\t   gimple_build_nop (), version);\n+\t}\n+    }\n+\n+  return name;\n+}\n+\n+/* Parse gimple postfix expression.\n+\n+   gimple-postfix-expression:\n+     gimple-primary-expression\n+     gimple-primary-xpression [ gimple-primary-expression ]\n+     gimple-primary-expression ( gimple-argument-expression-list[opt] )\n+     postfix-expression . identifier\n+     postfix-expression -> identifier\n+\n+   gimple-argument-expression-list:\n+     gimple-unary-expression\n+     gimple-argument-expression-list , gimple-unary-expression\n+\n+   gimple-primary-expression:\n+     identifier\n+     constant\n+     string-literal\n+\n+*/\n+\n+static struct c_expr\n+c_parser_gimple_postfix_expression (c_parser *parser)\n+{\n+  struct c_expr expr;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  source_range tok_range = c_parser_peek_token (parser)->get_range ();\n+  expr.original_code = ERROR_MARK;\n+  expr.original_type = NULL;\n+  switch (c_parser_peek_token (parser)->type)\n+    {\n+    case CPP_NUMBER:\n+      expr.value = c_parser_peek_token (parser)->value;\n+      set_c_expr_source_range (&expr, tok_range);\n+      loc = c_parser_peek_token (parser)->location;\n+      c_parser_consume_token (parser);\n+      break;\n+    case CPP_CHAR:\n+    case CPP_CHAR16:\n+    case CPP_CHAR32:\n+    case CPP_WCHAR:\n+      expr.value = c_parser_peek_token (parser)->value;\n+      set_c_expr_source_range (&expr, tok_range);\n+      c_parser_consume_token (parser);\n+      break;\n+    case CPP_STRING:\n+    case CPP_STRING16:\n+    case CPP_STRING32:\n+    case CPP_WSTRING:\n+    case CPP_UTF8STRING:\n+      expr.value = c_parser_peek_token (parser)->value;\n+      set_c_expr_source_range (&expr, tok_range);\n+      expr.original_code = STRING_CST;\n+      c_parser_consume_token (parser);\n+      break;\n+    case CPP_NAME:\n+      if (c_parser_peek_token (parser)->id_kind == C_ID_ID)\n+\t{\n+\t  tree id = c_parser_peek_token (parser)->value;\n+\t  unsigned version, ver_offset;\n+\t  if (! lookup_name (id)\n+\t      && c_parser_parse_ssa_name_id (id, &version, &ver_offset))\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      expr.value = c_parser_parse_ssa_name (parser, id, NULL_TREE,\n+\t\t\t\t\t\t    version, ver_offset);\n+\t      /* For default definition SSA names.  */\n+\t      if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n+\t\t  && c_parser_peek_2nd_token (parser)->type == CPP_NAME\n+\t\t  && strcmp (\"D\",\n+\t\t\t     IDENTIFIER_POINTER\n+\t\t\t       (c_parser_peek_2nd_token (parser)->value)) == 0\n+\t\t  && c_parser_peek_nth_token (parser, 3)->type == CPP_CLOSE_PAREN)\n+\t\t{\n+\t\t  c_parser_consume_token (parser);\n+\t\t  c_parser_consume_token (parser);\n+\t\t  c_parser_consume_token (parser);\n+\t\t  if (! SSA_NAME_IS_DEFAULT_DEF (expr.value))\n+\t\t    {\n+\t\t      set_ssa_default_def (cfun, SSA_NAME_VAR (expr.value),\n+\t\t\t\t\t   expr.value);\n+\t\t      SSA_NAME_DEF_STMT (expr.value) = gimple_build_nop ();\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      c_parser_consume_token (parser);\n+\t      expr.value\n+\t\t= build_external_ref (loc, id,\n+\t\t\t\t      (c_parser_peek_token (parser)->type\n+\t\t\t\t       == CPP_OPEN_PAREN), &expr.original_type);\n+\t      set_c_expr_source_range (&expr, tok_range);\n+\t    }\n+\t  break;\n+\t}\n+      else\n+\t{\n+\t  c_parser_error (parser, \"expected expression\");\n+\t  expr.set_error ();\n+\t  break;\n+\t}\n+      break;\n+    default:\n+      c_parser_error (parser, \"expected expression\");\n+      expr.set_error ();\n+      break;\n+    }\n+  return c_parser_gimple_postfix_expression_after_primary\n+    (parser, EXPR_LOC_OR_LOC (expr.value, loc), expr);\n+}\n+\n+/* Parse a gimple postfix expression after the initial primary or compound\n+   literal.  */\n+\n+static struct c_expr\n+c_parser_gimple_postfix_expression_after_primary (c_parser *parser,\n+\t\t\t\t\t\t  location_t expr_loc,\n+\t\t\t\t\t\t  struct c_expr expr)\n+{\n+  struct c_expr orig_expr;\n+  vec<tree, va_gc> *exprlist;\n+  vec<tree, va_gc> *origtypes = NULL;\n+  vec<location_t> arg_loc = vNULL;\n+  location_t start;\n+  location_t finish;\n+  tree ident;\n+  location_t comp_loc;\n+\n+  while (true)\n+    {\n+      location_t op_loc = c_parser_peek_token (parser)->location;\n+      switch (c_parser_peek_token (parser)->type)\n+\t{\n+\tcase CPP_OPEN_SQUARE:\n+\t  {\n+\t    c_parser_consume_token (parser);\n+\t    tree idx = c_parser_gimple_unary_expression (parser).value;\n+\n+\t    if (! c_parser_require (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\"))\n+\t      break;\n+\n+\t    start = expr.get_start ();\n+\t    finish = c_parser_tokens_buf (parser, 0)->location;\n+\t    expr.value = build_array_ref (op_loc, expr.value, idx);\n+\t    set_c_expr_source_range (&expr, start, finish);\n+\n+\t    expr.original_code = ERROR_MARK;\n+\t    expr.original_type = NULL;\n+\t    break;\n+\t  }\n+\tcase CPP_OPEN_PAREN:\n+\t  {\n+\t    /* Function call.  */\n+\t    c_parser_consume_token (parser);\n+\t    if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+\t      exprlist = NULL;\n+\t    else\n+\t      exprlist = c_parser_gimple_expr_list (parser, &origtypes,\n+\t\t\t\t\t\t    &arg_loc);\n+\t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t       \"expected %<)%>\");\n+\t    orig_expr = expr;\n+\t    start = expr.get_start ();\n+\t    finish = c_parser_tokens_buf (parser, 0)->get_finish ();\n+\t    expr.value = c_build_function_call_vec (expr_loc, arg_loc,\n+\t\t\t\t\t\t    expr.value,\n+\t\t\t\t\t\t    exprlist, origtypes);\n+\t    set_c_expr_source_range (&expr, start, finish);\n+\n+\t    expr.original_code = ERROR_MARK;\n+\t    if (TREE_CODE (expr.value) == INTEGER_CST\n+\t\t&& TREE_CODE (orig_expr.value) == FUNCTION_DECL\n+\t\t&& DECL_BUILT_IN_CLASS (orig_expr.value) == BUILT_IN_NORMAL\n+\t\t&& DECL_FUNCTION_CODE (orig_expr.value) == BUILT_IN_CONSTANT_P)\n+\t      expr.original_code = C_MAYBE_CONST_EXPR;\n+\t    expr.original_type = NULL;\n+\t    if (exprlist)\n+\t      {\n+\t\trelease_tree_vector (exprlist);\n+\t\trelease_tree_vector (origtypes);\n+\t      }\n+\t    arg_loc.release ();\n+\t    break;\n+\t  }\n+\tcase CPP_DOT:\n+\t  {\n+\t    /* Structure element reference.  */\n+\t    c_parser_consume_token (parser);\n+\t    if (c_parser_next_token_is (parser, CPP_NAME))\n+\t      {\n+\t\tc_token *comp_tok = c_parser_peek_token (parser);\n+\t\tident = comp_tok->value;\n+\t\tcomp_loc = comp_tok->location;\n+\t      }\n+\t    else\n+\t      {\n+\t\tc_parser_error (parser, \"expected identifier\");\n+\t\texpr.set_error ();\n+\t\texpr.original_code = ERROR_MARK;\n+\t\texpr.original_type = NULL;\n+\t\treturn expr;\n+\t      }\n+\t    start = expr.get_start ();\n+\t    finish = c_parser_peek_token (parser)->get_finish ();\n+\t    c_parser_consume_token (parser);\n+\t    expr.value = build_component_ref (op_loc, expr.value, ident,\n+\t\t\t\t\t      comp_loc);\n+\t    set_c_expr_source_range (&expr, start, finish);\n+\t    expr.original_code = ERROR_MARK;\n+\t    if (TREE_CODE (expr.value) != COMPONENT_REF)\n+\t      expr.original_type = NULL;\n+\t    else\n+\t      {\n+\t\t/* Remember the original type of a bitfield.  */\n+\t\ttree field = TREE_OPERAND (expr.value, 1);\n+\t\tif (TREE_CODE (field) != FIELD_DECL)\n+\t\t  expr.original_type = NULL;\n+\t\telse\n+\t\t  expr.original_type = DECL_BIT_FIELD_TYPE (field);\n+\t      }\n+\t    break;\n+\t  }\n+\tcase CPP_DEREF:\n+\t  {\n+\t    /* Structure element reference.  */\n+\t    c_parser_consume_token (parser);\n+\t    if (c_parser_next_token_is (parser, CPP_NAME))\n+\t      {\n+\t\tc_token *comp_tok = c_parser_peek_token (parser);\n+\t\tident = comp_tok->value;\n+\t\tcomp_loc = comp_tok->location;\n+\t      }\n+\t    else\n+\t      {\n+\t\tc_parser_error (parser, \"expected identifier\");\n+\t\texpr.set_error ();\n+\t\texpr.original_code = ERROR_MARK;\n+\t\texpr.original_type = NULL;\n+\t\treturn expr;\n+\t      }\n+\t    start = expr.get_start ();\n+\t    finish = c_parser_peek_token (parser)->get_finish ();\n+\t    c_parser_consume_token (parser);\n+\t    expr.value = build_component_ref (op_loc,\n+\t\t\t\t\t      build_simple_mem_ref_loc\n+\t\t\t\t\t        (op_loc, expr.value),\n+\t\t\t\t\t      ident, comp_loc);\n+\t    set_c_expr_source_range (&expr, start, finish);\n+\t    expr.original_code = ERROR_MARK;\n+\t    if (TREE_CODE (expr.value) != COMPONENT_REF)\n+\t      expr.original_type = NULL;\n+\t    else\n+\t      {\n+\t\t/* Remember the original type of a bitfield.  */\n+\t\ttree field = TREE_OPERAND (expr.value, 1);\n+\t\tif (TREE_CODE (field) != FIELD_DECL)\n+\t\t  expr.original_type = NULL;\n+\t\telse\n+\t\t  expr.original_type = DECL_BIT_FIELD_TYPE (field);\n+\t      }\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  return expr;\n+\t}\n+    }\n+}\n+\n+/* Parse expression list.\n+\n+   gimple-expr-list:\n+     gimple-unary-expression\n+     gimple-expr-list , gimple-unary-expression\n+\n+ */\n+\n+static vec<tree, va_gc> *\n+c_parser_gimple_expr_list (c_parser *parser, vec<tree, va_gc> **p_orig_types,\n+\t\t\t   vec<location_t> *locations)\n+{\n+  vec<tree, va_gc> *ret;\n+  vec<tree, va_gc> *orig_types;\n+  struct c_expr expr;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+\n+  ret = make_tree_vector ();\n+  if (p_orig_types == NULL)\n+    orig_types = NULL;\n+  else\n+    orig_types = make_tree_vector ();\n+\n+  expr = c_parser_gimple_unary_expression (parser);\n+  vec_safe_push (ret, expr.value);\n+  if (orig_types)\n+    vec_safe_push (orig_types, expr.original_type);\n+  if (locations)\n+    locations->safe_push (loc);\n+  while (c_parser_next_token_is (parser, CPP_COMMA))\n+    {\n+      c_parser_consume_token (parser);\n+      loc = c_parser_peek_token (parser)->location;\n+      expr = c_parser_gimple_unary_expression (parser);\n+      vec_safe_push (ret, expr.value);\n+      if (orig_types)\n+\tvec_safe_push (orig_types, expr.original_type);\n+      if (locations)\n+\tlocations->safe_push (loc);\n+    }\n+  if (orig_types)\n+    *p_orig_types = orig_types;\n+  return ret;\n+}\n+\n+/* Parse gimple label.\n+\n+   gimple-label:\n+     identifier :\n+     case constant-expression :\n+     default :\n+\n+*/\n+\n+static void\n+c_parser_gimple_label (c_parser *parser, gimple_seq *seq)\n+{\n+  tree name = c_parser_peek_token (parser)->value;\n+  location_t loc1 = c_parser_peek_token (parser)->location;\n+  gcc_assert (c_parser_next_token_is (parser, CPP_NAME));\n+  c_parser_consume_token (parser);\n+  gcc_assert (c_parser_next_token_is (parser, CPP_COLON));\n+  c_parser_consume_token (parser);\n+  tree label = define_label (loc1, name);\n+  gimple_seq_add_stmt (seq, gimple_build_label (label));\n+  return;\n+}\n+\n+/* Parse gimple pass list.\n+\n+   gimple-pass-list:\n+     startwith(\"pass-name\")\n+ */\n+\n+char *\n+c_parser_gimple_pass_list (c_parser *parser)\n+{\n+  char *pass = NULL;\n+\n+  /* Accept __GIMPLE.  */\n+  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n+    return NULL;\n+  c_parser_consume_token (parser);\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *op = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      c_parser_consume_token (parser);\n+      if (! strcmp (op, \"startwith\"))\n+\t{\n+\t  if (! c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\t    return NULL;\n+\t  if (c_parser_next_token_is_not (parser, CPP_STRING))\n+\t    {\n+\t      error_at (c_parser_peek_token (parser)->location,\n+\t\t\t\"expected pass name\");\n+\t      return NULL;\n+\t    }\n+\t  pass = xstrdup (TREE_STRING_POINTER\n+\t\t\t\t(c_parser_peek_token (parser)->value));\n+\t  c_parser_consume_token (parser);\n+\t  if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+\t    return NULL;\n+\t}\n+      else\n+\t{\n+\t  error_at (c_parser_peek_token (parser)->location,\n+\t\t    \"invalid operation\");\n+\t  return NULL;\n+\t}\n+    }\n+\n+  if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+    return NULL;\n+\n+  return pass;\n+}\n+\n+/* Parse gimple local declaration.\n+\n+   declaration-specifiers:\n+     storage-class-specifier declaration-specifiers[opt]\n+     type-specifier declaration-specifiers[opt]\n+     type-qualifier declaration-specifiers[opt]\n+     function-specifier declaration-specifiers[opt]\n+     alignment-specifier declaration-specifiers[opt]\n+\n+   storage-class-specifier:\n+     typedef\n+     extern\n+     static\n+     auto\n+     register\n+\n+   type-specifier:\n+     void\n+     char\n+     short\n+     int\n+     long\n+     float\n+     double\n+     signed\n+     unsigned\n+     _Bool\n+     _Complex\n+\n+   type-qualifier:\n+     const\n+     restrict\n+     volatile\n+     address-space-qualifier\n+     _Atomic\n+\n+ */\n+\n+static void\n+c_parser_gimple_declaration (c_parser *parser)\n+{\n+  struct c_declarator *declarator;\n+  struct c_declspecs *specs = build_null_declspecs ();\n+  c_parser_declspecs (parser, specs, true, true, true,\n+\t\t      true, true, cla_nonabstract_decl);\n+  finish_declspecs (specs);\n+\n+  /* Provide better error recovery.  Note that a type name here is usually\n+     better diagnosed as a redeclaration.  */\n+  if (c_parser_next_token_starts_declspecs (parser)\n+      && ! c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      c_parser_error (parser, \"expected %<;%>\");\n+      c_parser_set_error (parser, false);\n+      return;\n+    }\n+\n+  bool dummy = false;\n+  declarator = c_parser_declarator (parser,\n+\t\t\t\t    specs->typespec_kind != ctsk_none,\n+\t\t\t\t    C_DTR_NORMAL, &dummy);\n+\n+  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+    {\n+      /* Handle SSA name decls specially, they do not go into the identifier\n+         table but we simply build the SSA name for later lookup.  */\n+      unsigned version, ver_offset;\n+      if (declarator->kind == cdk_id\n+\t  && is_gimple_reg_type (specs->type)\n+\t  && c_parser_parse_ssa_name_id (declarator->u.id,\n+\t\t\t\t\t &version, &ver_offset)\n+\t  /* The following restricts it to unnamed anonymous SSA names\n+\t     which fails parsing of named ones in dumps (we could\n+\t     decide to not dump their name for -gimple).  */\n+\t  && ver_offset == 0)\n+\tc_parser_parse_ssa_name (parser, declarator->u.id, specs->type,\n+\t\t\t\t version, ver_offset);\n+      else\n+\t{\n+\t  tree postfix_attrs = NULL_TREE;\n+\t  tree all_prefix_attrs = specs->attrs;\n+\t  specs->attrs = NULL;\n+\t  tree decl = start_decl (declarator, specs, false,\n+\t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n+\t  if (decl)\n+\t    finish_decl (decl, UNKNOWN_LOCATION, NULL_TREE, NULL_TREE,\n+\t\t\t NULL_TREE);\n+\t}\n+    }\n+  else\n+    {\n+      c_parser_error (parser, \"expected %<;%>\");\n+      return;\n+    }\n+}\n+\n+/* Parse gimple goto statement.  */\n+\n+static void\n+c_parser_gimple_goto_stmt (location_t loc, tree label, gimple_seq *seq)\n+{\n+  tree decl = lookup_label_for_goto (loc, label);\n+  gimple_seq_add_stmt (seq, gimple_build_goto (decl));\n+  return;\n+}\n+\n+/* Parse a parenthesized condition.\n+   gimple-condition:\n+     ( gimple-binary-expression )    */\n+\n+static tree\n+c_parser_gimple_paren_condition (c_parser *parser)\n+{\n+  if (! c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return error_mark_node;\n+  tree cond = c_parser_gimple_binary_expression (parser).value;\n+  if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+    return error_mark_node;\n+  return cond;\n+}\n+\n+/* Parse gimple if-else statement.\n+\n+   if-statement:\n+     if ( gimple-binary-expression ) gimple-goto-statement\n+     if ( gimple-binary-expression ) gimple-goto-statement \\\n+\t\t\t\t\telse gimple-goto-statement\n+ */\n+\n+static void\n+c_parser_gimple_if_stmt (c_parser *parser, gimple_seq *seq)\n+{\n+  tree t_label, f_label, label;\n+  location_t loc;\n+  c_parser_consume_token (parser);\n+  tree cond = c_parser_gimple_paren_condition (parser);\n+\n+  if (c_parser_next_token_is_keyword (parser, RID_GOTO))\n+    {\n+      loc = c_parser_peek_token (parser)->location;\n+      c_parser_consume_token (parser);\n+      label = c_parser_peek_token (parser)->value;\n+      t_label = lookup_label_for_goto (loc, label);\n+      c_parser_consume_token (parser);\n+      if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+\treturn;\n+    }\n+  else\n+    {\n+      c_parser_error (parser, \"expected goto expression\");\n+      return;\n+    }\n+\n+  if (c_parser_next_token_is_keyword (parser, RID_ELSE))\n+    c_parser_consume_token (parser);\n+  else\n+    {\n+      c_parser_error (parser, \"expected else statement\");\n+      return;\n+    }\n+\n+  if (c_parser_next_token_is_keyword (parser, RID_GOTO))\n+    {\n+      loc = c_parser_peek_token (parser)->location;\n+      c_parser_consume_token (parser);\n+      label = c_parser_peek_token (parser)->value;\n+      f_label = lookup_label_for_goto (loc, label);\n+      c_parser_consume_token (parser);\n+      if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n+\treturn;\n+    }\n+  else\n+    {\n+      c_parser_error (parser, \"expected goto expression\");\n+      return;\n+    }\n+\n+  gimple_seq_add_stmt (seq, gimple_build_cond_from_tree (cond, t_label,\n+\t\t\t\t\t\t\t f_label));\n+}\n+\n+/* Parse gimple switch-statement.\n+\n+   gimple-switch-statement:\n+     switch (gimple-postfix-expression) gimple-case-statement\n+\n+   gimple-case-statement:\n+     gimple-case-statement\n+     gimple-label-statement : gimple-goto-statment\n+*/\n+\n+static void\n+c_parser_gimple_switch_stmt (c_parser *parser, gimple_seq *seq)\n+{\n+  c_expr cond_expr;\n+  tree case_label, label;\n+  auto_vec<tree> labels;\n+  tree default_label = NULL_TREE;\n+  gimple_seq switch_body = NULL;\n+  c_parser_consume_token (parser);\n+\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      cond_expr = c_parser_gimple_postfix_expression (parser);\n+      if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+\treturn;\n+    }\n+\n+  if (c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n+    {\n+      while (c_parser_next_token_is_not (parser, CPP_CLOSE_BRACE))\n+\t{\n+\t  if (c_parser_next_token_is (parser, CPP_EOF))\n+\t    {\n+\t      c_parser_error (parser, \"expected statement\");\n+\t      return;\n+\t    }\n+\n+\t  switch (c_parser_peek_token (parser)->keyword)\n+\t    {\n+\t    case RID_CASE:\n+\t      {\n+\t\tc_expr exp1;\n+\t\tlocation_t loc = c_parser_peek_token (parser)->location;\n+\t\tc_parser_consume_token (parser);\n+\n+\t\tif (c_parser_next_token_is (parser, CPP_NAME)\n+\t\t    || c_parser_peek_token (parser)->type == CPP_NUMBER)\n+\t\t  exp1 = c_parser_gimple_postfix_expression (parser);\n+\t\telse\n+\t\t  c_parser_error (parser, \"expected expression\");\n+\n+\t\tif (c_parser_next_token_is (parser, CPP_COLON))\n+\t\t  {\n+\t\t    c_parser_consume_token (parser);\n+\t\t    if (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t      {\n+\t\t\tlabel = c_parser_peek_token (parser)->value;\n+\t\t\tc_parser_consume_token (parser);\n+\t\t\ttree decl = lookup_label_for_goto (loc, label);\n+\t\t\tcase_label = build_case_label (exp1.value, NULL_TREE,\n+\t\t\t\t\t\t       decl);\n+\t\t\tlabels.safe_push (case_label);\n+\t\t\tif (! c_parser_require (parser, CPP_SEMICOLON,\n+\t\t\t\t\t\t\"expected %<;%>\"))\n+\t\t\t  return;\n+\t\t      }\n+\t\t    else if (! c_parser_require (parser, CPP_NAME,\n+\t\t\t\t\t\t \"expected label\"))\n+\t\t      return;\n+\t\t  }\n+\t\telse if (! c_parser_require (parser, CPP_SEMICOLON,\n+\t\t\t\t\t    \"expected %<:%>\"))\n+\t\t  return;\n+\t\tbreak;\n+\t      }\n+\t    case RID_DEFAULT:\n+\t      {\n+\t\tlocation_t loc = c_parser_peek_token (parser)->location;\n+\t\tc_parser_consume_token (parser);\n+\t\tif (c_parser_next_token_is (parser, CPP_COLON))\n+\t\t  {\n+\t\t    c_parser_consume_token (parser);\n+\t\t    if (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t      {\n+\t\t\tlabel = c_parser_peek_token (parser)->value;\n+\t\t\tc_parser_consume_token (parser);\n+\t\t\ttree decl = lookup_label_for_goto (loc, label);\n+\t\t\tdefault_label = build_case_label (NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t\t  decl);\n+\t\t\tif (! c_parser_require (parser, CPP_SEMICOLON,\n+\t\t\t\t\t\t\"expected %<;%>\"))\n+\t\t\t  return;\n+\t\t      }\n+\t\t    else if (! c_parser_require (parser, CPP_NAME,\n+\t\t\t\t\t\t \"expected label\"))\n+\t\t      return;\n+\t\t  }\n+\t\telse if (! c_parser_require (parser, CPP_SEMICOLON,\n+\t\t\t\t\t    \"expected %<:%>\"))\n+\t\t  return;\n+\t\tbreak;\n+\t      }\n+\t    case RID_GOTO:\n+\t      {\n+\t\tlocation_t loc = c_parser_peek_token (parser)->location;\n+\t\tc_parser_consume_token (parser);\n+\t\tif (c_parser_next_token_is (parser, CPP_NAME))\n+\t\t  {\n+\t\t    c_parser_gimple_goto_stmt (loc,\n+\t\t\t\t\t       c_parser_peek_token\n+\t\t\t\t\t         (parser)->value,\n+\t\t\t\t\t       &switch_body);\n+\t\t    c_parser_consume_token (parser);\n+\t\t    if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\t\t      c_parser_consume_token (parser);\n+\t\t    else\n+\t\t      {\n+\t\t\tc_parser_error (parser, \"expected semicolon\");\n+\t\t\treturn;\n+\t\t      }\n+\t\t  }\n+\t\telse if (! c_parser_require (parser, CPP_NAME,\n+\t\t\t\t\t    \"expected label\"))\n+\t\t  return;\n+\t\tbreak;\n+\t      }\n+\t    default:\n+\t      c_parser_error (parser, \"expected case label or goto statement\");\n+\t      return;\n+\t    }\n+\n+\t}\n+    }\n+  if (! c_parser_require (parser, CPP_CLOSE_BRACE, \"expected %<}%>\"))\n+    return;\n+  gimple_seq_add_stmt (seq, gimple_build_switch (cond_expr.value,\n+\t\t\t\t\t\t default_label, labels));\n+  gimple_seq_add_seq (seq, switch_body);\n+  labels.release();\n+}\n+\n+/* Parse gimple return statement.  */\n+\n+static void\n+c_parser_gimple_return_stmt (c_parser *parser, gimple_seq *seq)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  gimple *ret = NULL;\n+  c_parser_consume_token (parser);\n+  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+    {\n+      c_finish_gimple_return (loc, NULL_TREE);\n+      ret = gimple_build_return (NULL);\n+      gimple_seq_add_stmt (seq, ret);\n+    }\n+  else\n+    {\n+      location_t xloc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_gimple_unary_expression (parser);\n+      c_finish_gimple_return (xloc, expr.value);\n+      ret = gimple_build_return (expr.value);\n+      gimple_seq_add_stmt (seq, ret);\n+    }\n+}\n+\n+/* Support function for c_parser_gimple_return_stmt.  */\n+\n+static void\n+c_finish_gimple_return (location_t loc, tree retval)\n+{\n+  tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl));\n+\n+  /* Use the expansion point to handle cases such as returning NULL\n+     in a function returning void.  */\n+  source_location xloc = expansion_point_location_if_in_system_header (loc);\n+\n+  if (TREE_THIS_VOLATILE (current_function_decl))\n+    warning_at (xloc, 0,\n+\t\t\"function declared %<noreturn%> has a %<return%> statement\");\n+\n+  if (! retval)\n+    current_function_returns_null = 1;\n+  else if (valtype == 0 || TREE_CODE (valtype) == VOID_TYPE)\n+    {\n+      current_function_returns_null = 1;\n+      if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n+\t{\n+\t  error_at\n+\t    (xloc, \"%<return%> with a value, in function returning void\");\n+\t  inform (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t  \"declared here\");\n+\t}\n+    }\n+  else if (TREE_CODE (valtype) != TREE_CODE (TREE_TYPE (retval)))\n+    {\n+      error_at\n+\t(xloc, \"invalid conversion in return statement\");\n+      inform (DECL_SOURCE_LOCATION (current_function_decl),\n+\t      \"declared here\");\n+    }\n+  return;\n+}"}, {"sha": "f72b62657d4e31ef67556ce1bcb6627f61e3a9e2", "filename": "gcc/c/gimple-parser.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Fc%2Fgimple-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Fc%2Fgimple-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.h?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,27 @@\n+/* Declarations for the parser for GIMPLE.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_PARSER_H\n+#define GCC_GIMPLE_PARSER_H\n+\n+/* Gimple parsing functions.  */\n+extern void c_parser_parse_gimple_body (c_parser *);\n+extern char *c_parser_gimple_pass_list (c_parser *);\n+\n+#endif"}, {"sha": "a81ed1ff38a3acf572b62c64b77e2ca192bdf1f5", "filename": "gcc/testsuite/gcc.dg/gimplefe-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-1.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+int i;\n+void __GIMPLE foo()\n+{\n+  i = 1;\n+}"}, {"sha": "7f63c587c0357a1bef028d373536a1e00e5efda2", "filename": "gcc/testsuite/gcc.dg/gimplefe-10.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-10.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+int __GIMPLE() bar(int a, int b, int c)\n+{\n+  a = 1;\n+  b = a + 1;\n+  c = b * 4;\n+  return b;\n+}\n+\n+void __GIMPLE() foo()\n+{\n+  int a;\n+  int b;\n+  int c;\n+  b = bar(a, b, c);\n+}"}, {"sha": "e1483f4c360c8dab9b9d80e4e04f4f322258138f", "filename": "gcc/testsuite/gcc.dg/gimplefe-11.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-11.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+void __GIMPLE() bar(int a, int b, int c)\n+{\n+  a = 1;\n+  b = a + 1;\n+  c = b * 4;\n+  return;\n+}\n+\n+void __GIMPLE() foo()\n+{\n+  int a;\n+  int b;\n+  int c;\n+  bar(a, b, c);\n+}"}, {"sha": "28632287799944871070ec885907b58158f95601", "filename": "gcc/testsuite/gcc.dg/gimplefe-12.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-12.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fgimple\" } */\n+\n+void __GIMPLE (startwith (\"ccp1\")) foo ()\n+{\n+  int a;\n+  int b;\n+  a = b + 2;\n+  return;\n+}"}, {"sha": "f0af7611fb904621b22e3deb044e3439fb834c4a", "filename": "gcc/testsuite/gcc.dg/gimplefe-13.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-13.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fgimple\" } */\n+\n+void __GIMPLE (startwith (\"dse2\")) foo ()\n+{\n+  int a;\n+\n+bb_2:\n+  if (a > 4)\n+    goto bb_3;\n+  else\n+    goto bb_4;\n+\n+bb_3:\n+  a_2 = 10;\n+  goto bb_5;\n+\n+bb_4:\n+  a_3 = 20;\n+\n+bb_5:\n+  a_1 = __PHI (bb_3: a_2, bb_4: a_3);\n+  a_4 = a_1 + 4;\n+\n+return;\n+}"}, {"sha": "c0dd54ab430c33f0921c7780b4e56f16d16b965e", "filename": "gcc/testsuite/gcc.dg/gimplefe-14.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-14.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -fgimple\" } */\n+\n+int __GIMPLE ()\n+main (int argc, char * * argv)\n+{\n+  int a;\n+\n+  bb_2:\n+  switch (argc_2(D)) {default: L2; case 1: L0; case 2: L1; }\n+\n+L0:\n+  a_4 = 0;\n+  goto bb_6;\n+\n+L1:\n+  a_3 = 3;\n+  goto bb_6;\n+\n+L2:\n+  a_5 = -1;\n+\n+  bb_6:\n+  a_1 = __PHI (L0: a_4, L1: a_3, L2: a_5);\n+  return a_1;\n+\n+}\n+\n+"}, {"sha": "ca990313c4ebb6d69a45c21d11a6e6179410b6fd", "filename": "gcc/testsuite/gcc.dg/gimplefe-15.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-15.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fgimple\" } */\n+\n+struct Y { int b[2]; };\n+struct X { int a; struct Y y; };\n+struct X x;\n+\n+int __GIMPLE ()\n+foo (struct X *p, _Complex int q)\n+{\n+  int b;\n+  b = __real q;\n+  p->a = b;\n+  x.y.b[b] = b;\n+  b = p->y.b[1];\n+  b = x.a;\n+  return b;\n+}"}, {"sha": "2949249151ed4f3b8227a1c0c52382f7216b5515", "filename": "gcc/testsuite/gcc.dg/gimplefe-16.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-16.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fgimple\" } */\n+\n+struct Y { int b[2]; };\n+struct X { int a; struct Y y; };\n+struct X x;\n+\n+int __GIMPLE ()\n+foo (struct X *p, _Complex int q)\n+{\n+  int b;\n+  b_1 = __real q;\n+  p_4(D)->a = b_1;\n+  x.y.b[b_1] = b_1;\n+  b_2 = p->y.b[1];\n+  b_3 = x.a;\n+  return b_3;\n+}"}, {"sha": "c5633eee34f957be15464b357754d77764985f5d", "filename": "gcc/testsuite/gcc.dg/gimplefe-17.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-17.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple -fdump-tree-ssa\" } */\n+\n+int \n+__GIMPLE () *\n+foo ()\n+{\n+  int _1;\n+  int j;\n+  int *b;\n+  _1 = 1;\n+bb1:\n+  if (_1)\n+    goto bb3;\n+  else\n+    goto bb2;\n+\n+bb2:\n+  b_2 = (int *)0;\n+\n+bb3:\n+  b_4 = __PHI (bb1: b_3(D), bb2: b_2);\n+  return b_4;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"_1_\" \"ssa\" } } */"}, {"sha": "ba918b2bc0492d815fe58c856cb9ed160d4886e0", "filename": "gcc/testsuite/gcc.dg/gimplefe-18.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-18.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+int\n+__GIMPLE () *\n+foo ()\n+{\n+  int _1;\n+  int j;\n+  int *b;\n+  _1 = 1;\n+bb1:\n+  if (_1)\n+    goto bb3;\n+  else\n+    goto bb2;\n+\n+bb2:\n+  b_2 = (int *)0;\n+\n+bb3:\n+  b_4 = __PHI (bb1: &j, bb2: b_2);\n+  return b_4;\n+}"}, {"sha": "e3a23cf4ff317eada53b0981e3ec3da07d370522", "filename": "gcc/testsuite/gcc.dg/gimplefe-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-2.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile }*/\n+/* { dg-options \"-fgimple\" } */\n+\n+int a;\n+void __GIMPLE () foo ()\n+{\n+  int b;\n+  b = a;\n+  b = b + 1;\n+  a = b;\n+}"}, {"sha": "595365e0b0c60404f519d5b27e9dfda0bcf04853", "filename": "gcc/testsuite/gcc.dg/gimplefe-3.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-3.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+void __GIMPLE () foo ()\n+{\n+  int *b;\n+  *b = 1;\n+}"}, {"sha": "3600c7ca1c75bef3740d4e1ce60d35e5c095777c", "filename": "gcc/testsuite/gcc.dg/gimplefe-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-4.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+void __GIMPLE () foo ()\n+{\n+  int a;\n+  char b;\n+  a = (int) b;\n+  return;\n+}"}, {"sha": "1dab4af4f87a9a77ebc6b525adb8a85d1a53869b", "filename": "gcc/testsuite/gcc.dg/gimplefe-5.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-5.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+int a;\n+void __GIMPLE () foo ()\n+{\n+  int b;\n+  int c;\n+\n+bb_2:\n+  b = a;\n+  if (b > 3)\n+    goto bb_3;\n+  else\n+    goto bb_4;\n+\n+bb_3:\n+  b = c + 4;\n+  goto bb_5;\n+\n+bb_4:\n+  b = b + 1;\n+  goto bb_5;\n+\n+bb_5:\n+  a = b;\n+  return;\n+}"}, {"sha": "242e08fe1a04ecf83042f24330972e24e29a4fb7", "filename": "gcc/testsuite/gcc.dg/gimplefe-6.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-6.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+void __GIMPLE () foo ()\n+{\n+  int a;\n+  int b;\n+  int c;\n+  int d;\n+\n+bb_2:\n+  a = ~b;\n+  b = a << c;\n+  c = a & b;\n+  d = b | c;\n+\n+bb_3:\n+  return;\n+}"}, {"sha": "61255412ab5143b699a23ff2c9d1c3f7bd24fa3f", "filename": "gcc/testsuite/gcc.dg/gimplefe-7.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-7.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+void __GIMPLE () foo ()\n+{\n+  int a;\n+\n+bb_2:\n+  if (a > 4)\n+    goto bb_3;\n+  else\n+    goto bb_4;\n+\n+bb_3:\n+  a_2 = 10;\n+  goto bb_5;\n+\n+bb_4:\n+  a_3 = 20;\n+\n+bb_5:\n+  a_1 = __PHI (bb_3: a_2, bb_4: a_3);\n+  a_4 = a_1 + 4;\n+\n+return;\n+}\n+"}, {"sha": "4936bec334fbb9af78fe5174cacb2426e1295d75", "filename": "gcc/testsuite/gcc.dg/gimplefe-8.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-8.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+int __GIMPLE () foo ()\n+{\n+  int a;\n+  int b;\n+\n+bb_2:\n+  b = a_1(D) + 1;\n+bb_3:\n+  return b;\n+}"}, {"sha": "a24be273ef95e3f1b5a2d96e262c327660e34c91", "filename": "gcc/testsuite/gcc.dg/gimplefe-9.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc08ecba2b3530944a9fd03acc90aa7cd5289bd1/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-9.c?ref=bc08ecba2b3530944a9fd03acc90aa7cd5289bd1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgimple\" } */\n+\n+int __GIMPLE() bar()\n+{\n+  int a;\n+  a = a + 1;\n+  return a;\n+}\n+\n+void __GIMPLE() foo()\n+{\n+  int b;\n+  b = bar();\n+}"}]}