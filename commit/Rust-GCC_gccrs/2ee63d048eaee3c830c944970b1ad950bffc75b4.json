{"sha": "2ee63d048eaee3c830c944970b1ad950bffc75b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVlNjNkMDQ4ZWFlZTNjODMwYzk0NDk3MGIxYWQ5NTBiZmZjNzViNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-12-06T20:16:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-12-06T20:16:27Z"}, "message": "PR c++/92831 - CWG 1299, not extending temporary lifetime for ?:\n\n\t* cp-tree.h (extend_ref_init_temps): Add a new argument with NULL\n\tdefault arg.\n\t* call.c (set_up_extended_ref_temp): Add COND_GUARD argument, pass it\n\tdown to extend_ref_init_temps.  Before pushing cleanup, if COND_GUARD\n\tis non-NULL, create a bool temporary if needed, initialize to false\n\tand guard the cleanup with the temporary being true.\n\t(extend_ref_init_temps_1): Add COND_GUARD argument, pass it down\n\tto recursive calls and set_up_extended_ref_temp.  Handle COND_EXPR.\n\t(extend_ref_init_temps): Add COND_GUARD argument, pass it down to\n\trecursive calls and to extend_ref_init_temps_1.\n\n\t* g++.dg/cpp0x/temp-extend2.C: New test.\n\nFrom-SVN: r279064", "tree": {"sha": "9b852594e7de1b641f92cda0e5cbecd9eea84934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b852594e7de1b641f92cda0e5cbecd9eea84934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ee63d048eaee3c830c944970b1ad950bffc75b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee63d048eaee3c830c944970b1ad950bffc75b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee63d048eaee3c830c944970b1ad950bffc75b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee63d048eaee3c830c944970b1ad950bffc75b4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eff6af8e0e9d750e13bedbe40ba70c395ba6234c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff6af8e0e9d750e13bedbe40ba70c395ba6234c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff6af8e0e9d750e13bedbe40ba70c395ba6234c"}], "stats": {"total": 137, "additions": 124, "deletions": 13}, "files": [{"sha": "3ee98a43f836142997172569fe6379d0dabf3a50", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2ee63d048eaee3c830c944970b1ad950bffc75b4", "patch": "@@ -1,3 +1,17 @@\n+2019-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/92831 - CWG 1299, not extending temporary lifetime for ?:\n+\t* cp-tree.h (extend_ref_init_temps): Add a new argument with NULL\n+\tdefault arg.\n+\t* call.c (set_up_extended_ref_temp): Add COND_GUARD argument, pass it\n+\tdown to extend_ref_init_temps.  Before pushing cleanup, if COND_GUARD\n+\tis non-NULL, create a bool temporary if needed, initialize to false\n+\tand guard the cleanup with the temporary being true.\n+\t(extend_ref_init_temps_1): Add COND_GUARD argument, pass it down\n+\tto recursive calls and set_up_extended_ref_temp.  Handle COND_EXPR.\n+\t(extend_ref_init_temps): Add COND_GUARD argument, pass it down to\n+\trecursive calls and to extend_ref_init_temps_1.\n+\n 2019-12-06  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* decl.c (start_decl_1): Use verify_type_context to check whether"}, {"sha": "af36f5f919efbb32035800a89fb2451f4c760cb8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 66, "deletions": 12, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2ee63d048eaee3c830c944970b1ad950bffc75b4", "patch": "@@ -11965,7 +11965,7 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n \n static tree\n set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,\n-\t\t\t  tree *initp)\n+\t\t\t  tree *initp, tree *cond_guard)\n {\n   tree init;\n   tree type;\n@@ -11996,7 +11996,8 @@ set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,\n \n   /* Recursively extend temps in this initializer.  */\n   TARGET_EXPR_INITIAL (expr)\n-    = extend_ref_init_temps (decl, TARGET_EXPR_INITIAL (expr), cleanups);\n+    = extend_ref_init_temps (decl, TARGET_EXPR_INITIAL (expr), cleanups,\n+\t\t\t     cond_guard);\n \n   /* Any reference temp has a non-trivial initializer.  */\n   DECL_NONTRIVIALLY_INITIALIZED_P (var) = true;\n@@ -12037,7 +12038,24 @@ set_up_extended_ref_temp (tree decl, tree expr, vec<tree, va_gc> **cleanups,\n \t{\n \t  tree cleanup = cxx_maybe_build_cleanup (var, tf_warning_or_error);\n \t  if (cleanup)\n-\t    vec_safe_push (*cleanups, cleanup);\n+\t    {\n+\t      if (cond_guard && cleanup != error_mark_node)\n+\t\t{\n+\t\t  if (*cond_guard == NULL_TREE)\n+\t\t    {\n+\t\t      *cond_guard = build_local_temp (boolean_type_node);\n+\t\t      add_decl_expr (*cond_guard);\n+\t\t      tree set = cp_build_modify_expr (UNKNOWN_LOCATION,\n+\t\t\t\t\t\t       *cond_guard, NOP_EXPR,\n+\t\t\t\t\t\t       boolean_false_node,\n+\t\t\t\t\t\t       tf_warning_or_error);\n+\t\t      finish_expr_stmt (set);\n+\t\t    }\n+\t\t  cleanup = build3 (COND_EXPR, void_type_node,\n+\t\t\t\t    *cond_guard, cleanup, NULL_TREE);\n+\t\t}\n+\t      vec_safe_push (*cleanups, cleanup);\n+\t    }\n \t}\n \n       /* We must be careful to destroy the temporary only\n@@ -12142,28 +12160,61 @@ initialize_reference (tree type, tree expr,\n    which is bound either to a reference or a std::initializer_list.  */\n \n static tree\n-extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups)\n+extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups,\n+\t\t\t tree *cond_guard)\n {\n   tree sub = init;\n   tree *p;\n   STRIP_NOPS (sub);\n   if (TREE_CODE (sub) == COMPOUND_EXPR)\n     {\n       TREE_OPERAND (sub, 1)\n-        = extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 1), cleanups);\n+\t= extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 1), cleanups,\n+\t\t\t\t   cond_guard);\n+      return init;\n+    }\n+  if (TREE_CODE (sub) == COND_EXPR)\n+    {\n+      tree cur_cond_guard = NULL_TREE;\n+      if (TREE_OPERAND (sub, 1))\n+\tTREE_OPERAND (sub, 1)\n+\t  = extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 1), cleanups,\n+\t\t\t\t     &cur_cond_guard);\n+      if (cur_cond_guard)\n+\t{\n+\t  tree set = cp_build_modify_expr (UNKNOWN_LOCATION, cur_cond_guard,\n+\t\t\t\t\t   NOP_EXPR, boolean_true_node,\n+\t\t\t\t\t   tf_warning_or_error);\n+\t  TREE_OPERAND (sub, 1)\n+\t    = cp_build_compound_expr (set, TREE_OPERAND (sub, 1),\n+\t\t\t\t      tf_warning_or_error);\n+\t}\n+      cur_cond_guard = NULL_TREE;\n+      if (TREE_OPERAND (sub, 2))\n+\tTREE_OPERAND (sub, 2)\n+\t  = extend_ref_init_temps_1 (decl, TREE_OPERAND (sub, 2), cleanups,\n+\t\t\t\t     &cur_cond_guard);\n+      if (cur_cond_guard)\n+\t{\n+\t  tree set = cp_build_modify_expr (UNKNOWN_LOCATION, cur_cond_guard,\n+\t\t\t\t\t   NOP_EXPR, boolean_true_node,\n+\t\t\t\t\t   tf_warning_or_error);\n+\t  TREE_OPERAND (sub, 2)\n+\t    = cp_build_compound_expr (set, TREE_OPERAND (sub, 2),\n+\t\t\t\t      tf_warning_or_error);\n+\t}\n       return init;\n     }\n   if (TREE_CODE (sub) != ADDR_EXPR)\n     return init;\n   /* Deal with binding to a subobject.  */\n   for (p = &TREE_OPERAND (sub, 0);\n-       (TREE_CODE (*p) == COMPONENT_REF\n-\t|| TREE_CODE (*p) == ARRAY_REF); )\n+       TREE_CODE (*p) == COMPONENT_REF || TREE_CODE (*p) == ARRAY_REF; )\n     p = &TREE_OPERAND (*p, 0);\n   if (TREE_CODE (*p) == TARGET_EXPR)\n     {\n       tree subinit = NULL_TREE;\n-      *p = set_up_extended_ref_temp (decl, *p, cleanups, &subinit);\n+      *p = set_up_extended_ref_temp (decl, *p, cleanups, &subinit, cond_guard);\n       recompute_tree_invariant_for_addr_expr (sub);\n       if (init != sub)\n \tinit = fold_convert (TREE_TYPE (init), sub);\n@@ -12178,13 +12229,14 @@ extend_ref_init_temps_1 (tree decl, tree init, vec<tree, va_gc> **cleanups)\n    lifetime to match that of DECL.  */\n \n tree\n-extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)\n+extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups,\n+\t\t       tree *cond_guard)\n {\n   tree type = TREE_TYPE (init);\n   if (processing_template_decl)\n     return init;\n   if (TYPE_REF_P (type))\n-    init = extend_ref_init_temps_1 (decl, init, cleanups);\n+    init = extend_ref_init_temps_1 (decl, init, cleanups, cond_guard);\n   else\n     {\n       tree ctor = init;\n@@ -12203,7 +12255,8 @@ extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)\n \t      /* The temporary array underlying a std::initializer_list\n \t\t is handled like a reference temporary.  */\n \t      tree array = CONSTRUCTOR_ELT (ctor, 0)->value;\n-\t      array = extend_ref_init_temps_1 (decl, array, cleanups);\n+\t      array = extend_ref_init_temps_1 (decl, array, cleanups,\n+\t\t\t\t\t       cond_guard);\n \t      CONSTRUCTOR_ELT (ctor, 0)->value = array;\n \t    }\n \t  else\n@@ -12212,7 +12265,8 @@ extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups)\n \t      constructor_elt *p;\n \t      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ctor);\n \t      FOR_EACH_VEC_SAFE_ELT (elts, i, p)\n-\t\tp->value = extend_ref_init_temps (decl, p->value, cleanups);\n+\t\tp->value = extend_ref_init_temps (decl, p->value, cleanups,\n+\t\t\t\t\t\t  cond_guard);\n \t    }\n \t  recompute_constructor_flags (ctor);\n \t  if (decl_maybe_constant_var_p (decl) && TREE_CONSTANT (ctor))"}, {"sha": "d7df6d91dae3dcdd335442ef15f1a5db33a20fed", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2ee63d048eaee3c830c944970b1ad950bffc75b4", "patch": "@@ -6321,7 +6321,9 @@ extern tree convert_for_arg_passing\t\t(tree, tree, tsubst_flags_t);\n extern bool is_properly_derived_from\t\t(tree, tree);\n extern tree initialize_reference\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree extend_ref_init_temps\t\t(tree, tree, vec<tree, va_gc>**);\n+extern tree extend_ref_init_temps\t\t(tree, tree,\n+\t\t\t\t\t\t vec<tree, va_gc>**,\n+\t\t\t\t\t\t tree * = NULL);\n extern tree make_temporary_var_for_ref_to_temp\t(tree, tree);\n extern bool type_has_extended_temps\t\t(tree);\n extern tree strip_top_quals\t\t\t(tree);"}, {"sha": "fba5f81b50beb8b287226b3b714862591463c541", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ee63d048eaee3c830c944970b1ad950bffc75b4", "patch": "@@ -1,3 +1,8 @@\n+2019-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/92831 - CWG 1299, not extending temporary lifetime for ?:\n+\t* g++.dg/cpp0x/temp-extend2.C: New test.\n+\n 2019-12-06  Andreas Krebbel  <krebbel@linux.ibm.com>\n \t    Vladimir Makarov  <vmakarov@redhat.com>\n "}, {"sha": "0b904e3ffbcbb0215985118ed46e48ac223e8fa4", "filename": "gcc/testsuite/g++.dg/cpp0x/temp-extend2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-extend2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ee63d048eaee3c830c944970b1ad950bffc75b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-extend2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-extend2.C?ref=2ee63d048eaee3c830c944970b1ad950bffc75b4", "patch": "@@ -0,0 +1,36 @@\n+// PR c++/92831\n+// { dg-do run { target c++11 } }\n+\n+template<typename T> using id = T;\n+struct S { S () { s++; } ~S () { s--; } S (int) { s++; } static int s; };\n+int S::s = 0;\n+\n+void\n+bar (bool cond, bool cond2)\n+{\n+  if (S::s != (cond ? cond2 ? 7 : 5 : cond2 ? 8 : 9))\n+    __builtin_abort ();\n+}\n+\n+void\n+foo (bool cond, bool cond2)\n+{\n+  int i = 1;\n+  // temporary array has same lifetime as a\n+  S&& a = id<S[3]>{1, 2, 3}[i];\n+  // temporary S has same lifetime as b\n+  const S& b = static_cast<const S&>(0);\n+  // exactly one of the four temporaries is lifetime-extended\n+  S&& c = cond ? cond2 ? id<S[3]>{1, 2, 3}[i] : static_cast<S&&>(0)\n+\t       : cond2 ? id<S[4]>{1, 2, 3, 4}[i] : id<S[5]>{1, 2, 3, 4, 5}[i];\n+  bar (cond, cond2);\n+}\n+\n+int\n+main ()\n+{\n+  foo (true, true);\n+  foo (true, false);\n+  foo (false, true);\n+  foo (false, false);\n+}"}]}