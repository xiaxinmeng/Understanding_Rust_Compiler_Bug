{"sha": "47e0da377eb7021c043244cd4ff99669eb1a370c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdlMGRhMzc3ZWI3MDIxYzA0MzI0NGNkNGZmOTk2NjllYjFhMzcwYw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-10-14T16:15:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-10-14T16:15:38Z"}, "message": "Introduce gcc::dump_manager class\n\ngcc/\n\t* dumpfile.h (gcc::dump_manager): New class, to hold state\n\trelating to dumpfile management.\n\t(get_dump_file_name): Remove in favor of method of dump_manager.\n\t(dump_initialized_p): Likewise.\n\t(dump_start): Likewise.\n\t(dump_finish): Likewise.\n\t(dump_switch_p): Likewise.\n\t(dump_register): Likewise.\n\t(get_dump_file_info): Likewise.\n\t* context.c (gcc::context::context): Construct the dump_manager\n\tinstance.\n\t* context.h (gcc::context::get_dumps): New.\n\t(gcc::context::m_dumps): New.\n\t* coverage.c (coverage_init): Port to dump_manager API.\n\t* dumpfile.c (extra_dump_files): Convert to field of\n\tgcc::dump_manager.\n\t(extra_dump_files_in_use): Likewise.\n\t(extra_dump_files_alloced): Likewise.\n\t(gcc::dump_manager::dump_manager): New.\n\t(dump_register): Convert to...\n\t(gcc::dump_manager::dump_register): ...method, replacing\n\tfunction-static next_dump with m_next_dump field.\n\t(get_dump_file_info): Convert to...\n\t(gcc::dump_manager::get_dump_file_info): ...method.\n\t(get_dump_file_name): Convert to...\n\t(gcc::dump_manager::get_dump_file_name): ...method.\n\t(dump_start): Convert to...\n\t(gcc::dump_manager::dump_start): ...method.\n\t(dump_finish): Convert to...\n\t(gcc::dump_manager::dump_finish): ...method.\n\t(dump_begin): Replace body with...\n\t(gcc::dump_manager::dump_begin): ...new method.\n\t(dump_phase_enabled_p): Convert to...\n\t(gcc::dump_manager::dump_phase_enabled_p): ...method.\n\t(dump_phase_enabled_p): Convert to...\n\t(gcc::dump_manager::dump_phase_enabled_p): ...method.\n\t(dump_initialized_p):  Convert to...\n\t(gcc::dump_manager::dump_initialized_p): ...method.\n\t(dump_flag_name): Replace body with...\n\t(gcc::dump_manager::dump_flag_name): ...new method.\n\t(dump_enable_all): Convert to...\n\t(gcc::dump_manager::dump_enable_all): ...new method.\n\t(opt_info_enable_passes): Convert to...\n\t(gcc::dump_manager::opt_info_enable_passes): ...new method.\n\t(dump_switch_p_1): Convert to...\n\t(gcc::dump_manager::dump_switch_p_1): ...new method.\n\t(dump_switch_p):  Convert to...\n\t(gcc::dump_manager::dump_switch_p): ...new method.\n\t(opt_info_switch_p): Port to dump_manager API.\n\t(enable_rtl_dump_file): Likewise.\n\t* opts-global.c (handle_common_deferred_options): Port to new\n\tdump_manager API.\n\t* passes.c (pass_manager::finish_optimization_passes): Likewise.\n\t(pass_manager::register_one_dump_file): Likewise.\n\t(pass_manager::register_pass): Likewise.\n\t(pass_init_dump_file): Likewise.\n\t(pass_fini_dump_file): Likewise.\n\t* statistics.c (statistics_early_init): Likewise.\n\ngcc/java/\n\n\t* lang.c (java_handle_option): Update for introduction of\n\tgcc::dump_manager.\n\nFrom-SVN: r203569", "tree": {"sha": "a2a58a4c89a20875a0fa23706d4171d2fe967ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2a58a4c89a20875a0fa23706d4171d2fe967ef5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47e0da377eb7021c043244cd4ff99669eb1a370c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e0da377eb7021c043244cd4ff99669eb1a370c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e0da377eb7021c043244cd4ff99669eb1a370c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e0da377eb7021c043244cd4ff99669eb1a370c/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "811189d91a29fbced411a62f9fcea66e2b7882cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/811189d91a29fbced411a62f9fcea66e2b7882cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/811189d91a29fbced411a62f9fcea66e2b7882cb"}], "stats": {"total": 365, "additions": 279, "deletions": 86}, "files": [{"sha": "8a38316d8d8296a2fd1af72a1ffdcae219c6fec3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -1,3 +1,64 @@\n+2013-10-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dumpfile.h (gcc::dump_manager): New class, to hold state\n+\trelating to dumpfile management.\n+\t(get_dump_file_name): Remove in favor of method of dump_manager.\n+\t(dump_initialized_p): Likewise.\n+\t(dump_start): Likewise.\n+\t(dump_finish): Likewise.\n+\t(dump_switch_p): Likewise.\n+\t(dump_register): Likewise.\n+\t(get_dump_file_info): Likewise.\n+\t* context.c (gcc::context::context): Construct the dump_manager\n+\tinstance.\n+\t* context.h (gcc::context::get_dumps): New.\n+\t(gcc::context::m_dumps): New.\n+\t* coverage.c (coverage_init): Port to dump_manager API.\n+\t* dumpfile.c (extra_dump_files): Convert to field of\n+\tgcc::dump_manager.\n+\t(extra_dump_files_in_use): Likewise.\n+\t(extra_dump_files_alloced): Likewise.\n+\t(gcc::dump_manager::dump_manager): New.\n+\t(dump_register): Convert to...\n+\t(gcc::dump_manager::dump_register): ...method, replacing\n+\tfunction-static next_dump with m_next_dump field.\n+\t(get_dump_file_info): Convert to...\n+\t(gcc::dump_manager::get_dump_file_info): ...method.\n+\t(get_dump_file_name): Convert to...\n+\t(gcc::dump_manager::get_dump_file_name): ...method.\n+\t(dump_start): Convert to...\n+\t(gcc::dump_manager::dump_start): ...method.\n+\t(dump_finish): Convert to...\n+\t(gcc::dump_manager::dump_finish): ...method.\n+\t(dump_begin): Replace body with...\n+\t(gcc::dump_manager::dump_begin): ...new method.\n+\t(dump_phase_enabled_p): Convert to...\n+\t(gcc::dump_manager::dump_phase_enabled_p): ...method.\n+\t(dump_phase_enabled_p): Convert to...\n+\t(gcc::dump_manager::dump_phase_enabled_p): ...method.\n+\t(dump_initialized_p):  Convert to...\n+\t(gcc::dump_manager::dump_initialized_p): ...method.\n+\t(dump_flag_name): Replace body with...\n+\t(gcc::dump_manager::dump_flag_name): ...new method.\n+\t(dump_enable_all): Convert to...\n+\t(gcc::dump_manager::dump_enable_all): ...new method.\n+\t(opt_info_enable_passes): Convert to...\n+\t(gcc::dump_manager::opt_info_enable_passes): ...new method.\n+\t(dump_switch_p_1): Convert to...\n+\t(gcc::dump_manager::dump_switch_p_1): ...new method.\n+\t(dump_switch_p):  Convert to...\n+\t(gcc::dump_manager::dump_switch_p): ...new method.\n+\t(opt_info_switch_p): Port to dump_manager API.\n+\t(enable_rtl_dump_file): Likewise.\n+\t* opts-global.c (handle_common_deferred_options): Port to new\n+\tdump_manager API.\n+\t* passes.c (pass_manager::finish_optimization_passes): Likewise.\n+\t(pass_manager::register_one_dump_file): Likewise.\n+\t(pass_manager::register_pass): Likewise.\n+\t(pass_init_dump_file): Likewise.\n+\t(pass_fini_dump_file): Likewise.\n+\t* statistics.c (statistics_early_init): Likewise.\n+\n 2013-10-14  Richard Biener  <rguenther@suse.de>\n \n \t* gimple.c (gimple_canonical_types, canonical_type_hash_cache,"}, {"sha": "3dd4526845e60297f6dcb5a09c0f6a5cf6c8b21b", "filename": "gcc/context.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fcontext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fcontext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.c?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -23,11 +23,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"context.h\"\n #include \"pass_manager.h\"\n+#include \"dumpfile.h\"\n \n /* The singleton holder of global state: */\n gcc::context *g;\n \n gcc::context::context ()\n {\n+  /* The pass manager's constructor uses the dump manager (to set up\n+     dumps for the various passes), so the dump manager must be set up\n+     before the pass manager.  */\n+  m_dumps = new gcc::dump_manager ();\n   m_passes = new gcc::pass_manager (this);\n }"}, {"sha": "d6555ccbd16c5f632d1ab90cc7cdaa8126e9911c", "filename": "gcc/context.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fcontext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fcontext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.h?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n namespace gcc {\n \n class pass_manager;\n+class dump_manager;\n \n /* GCC's internal state can be divided into zero or more\n    \"parallel universe\" of state; an instance of this class is one such\n@@ -36,10 +37,17 @@ class context\n \n   pass_manager *get_passes () { gcc_assert (m_passes); return m_passes; }\n \n+  /* Handling dump files.  */\n+\n+  dump_manager *get_dumps () {gcc_assert (m_dumps); return m_dumps; }\n+\n private:\n   /* Pass-management.  */\n   pass_manager *m_passes;\n \n+  /* Dump files.  */\n+  dump_manager *m_dumps;\n+\n }; // class context\n \n } // namespace gcc"}, {"sha": "e450151ac3e34dd5cba896bc46262f0e92767b18", "filename": "gcc/coverage.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -1137,7 +1137,9 @@ coverage_init (const char *filename)\n   /* Since coverage_init is invoked very early, before the pass\n      manager, we need to set up the dumping explicitly. This is\n      similar to the handling in finish_optimization_passes.  */\n-  dump_start (g->get_passes ()->get_pass_profile ()->static_pass_number, NULL);\n+  int profile_pass_num =\n+    g->get_passes ()->get_pass_profile ()->static_pass_number;\n+  g->get_dumps ()->dump_start (profile_pass_num, NULL);\n \n   if (!profile_data_prefix && !IS_ABSOLUTE_PATH (filename))\n     profile_data_prefix = getpwd ();\n@@ -1182,7 +1184,7 @@ coverage_init (const char *filename)\n \t}\n     }\n \n-  dump_finish (g->get_passes ()->get_pass_profile ()->static_pass_number);\n+  g->get_dumps ()->dump_finish (profile_pass_num);\n }\n \n /* Performs file-level cleanup.  Close notes file, generate coverage"}, {"sha": "e80f9bf37e27fd48fcae2fa63b2fd71e636e61cc", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 85, "deletions": 54, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"tree.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"context.h\"\n \n /* If non-NULL, return one past-the-end of the matching SUBPART of\n    the WHOLE string.  */\n@@ -34,7 +35,6 @@ static int pflags;                   /* current dump_flags */\n static int alt_flags;                /* current opt_info flags */\n \n static void dump_loc (int, FILE *, source_location);\n-static int dump_phase_enabled_p (int);\n static FILE *dump_open_alternate_stream (struct dump_file_info *);\n \n /* These are currently used for communicating between passes.\n@@ -74,11 +74,6 @@ static struct dump_file_info dump_files[TDI_end] =\n    0, 0, 0, 0, 0},\n };\n \n-/* Dynamically registered tree dump files and switches.  */\n-static struct dump_file_info *extra_dump_files;\n-static size_t extra_dump_files_in_use;\n-static size_t extra_dump_files_alloced;\n-\n /* Define a name->number mapping for a dump flag value.  */\n struct dump_option_value_info\n {\n@@ -141,33 +136,41 @@ static const struct dump_option_value_info optgroup_options[] =\n   {NULL, 0}\n };\n \n+gcc::dump_manager::dump_manager ():\n+  m_next_dump (FIRST_AUTO_NUMBERED_DUMP),\n+  m_extra_dump_files (NULL),\n+  m_extra_dump_files_in_use (0),\n+  m_extra_dump_files_alloced (0)\n+{\n+}\n+\n unsigned int\n+gcc::dump_manager::\n dump_register (const char *suffix, const char *swtch, const char *glob,\n \t       int flags, int optgroup_flags)\n {\n-  static int next_dump = FIRST_AUTO_NUMBERED_DUMP;\n-  int num = next_dump++;\n+  int num = m_next_dump++;\n \n-  size_t count = extra_dump_files_in_use++;\n+  size_t count = m_extra_dump_files_in_use++;\n \n-  if (count >= extra_dump_files_alloced)\n+  if (count >= m_extra_dump_files_alloced)\n     {\n-      if (extra_dump_files_alloced == 0)\n-\textra_dump_files_alloced = 32;\n+      if (m_extra_dump_files_alloced == 0)\n+\tm_extra_dump_files_alloced = 32;\n       else\n-\textra_dump_files_alloced *= 2;\n-      extra_dump_files = XRESIZEVEC (struct dump_file_info,\n-\t\t\t\t     extra_dump_files,\n-\t\t\t\t     extra_dump_files_alloced);\n+\tm_extra_dump_files_alloced *= 2;\n+      m_extra_dump_files = XRESIZEVEC (struct dump_file_info,\n+\t\t\t\t       m_extra_dump_files,\n+\t\t\t\t       m_extra_dump_files_alloced);\n     }\n \n-  memset (&extra_dump_files[count], 0, sizeof (struct dump_file_info));\n-  extra_dump_files[count].suffix = suffix;\n-  extra_dump_files[count].swtch = swtch;\n-  extra_dump_files[count].glob = glob;\n-  extra_dump_files[count].pflags = flags;\n-  extra_dump_files[count].optgroup_flags = optgroup_flags;\n-  extra_dump_files[count].num = num;\n+  memset (&m_extra_dump_files[count], 0, sizeof (struct dump_file_info));\n+  m_extra_dump_files[count].suffix = suffix;\n+  m_extra_dump_files[count].swtch = swtch;\n+  m_extra_dump_files[count].glob = glob;\n+  m_extra_dump_files[count].pflags = flags;\n+  m_extra_dump_files[count].optgroup_flags = optgroup_flags;\n+  m_extra_dump_files[count].num = num;\n \n   return count + TDI_end;\n }\n@@ -176,22 +179,24 @@ dump_register (const char *suffix, const char *swtch, const char *glob,\n /* Return the dump_file_info for the given phase.  */\n \n struct dump_file_info *\n-get_dump_file_info (int phase)\n+gcc::dump_manager::\n+get_dump_file_info (int phase) const\n {\n   if (phase < TDI_end)\n     return &dump_files[phase];\n-  else if ((size_t) (phase - TDI_end) >= extra_dump_files_in_use)\n+  else if ((size_t) (phase - TDI_end) >= m_extra_dump_files_in_use)\n     return NULL;\n   else\n-    return extra_dump_files + (phase - TDI_end);\n+    return m_extra_dump_files + (phase - TDI_end);\n }\n \n \n /* Return the name of the dump file for the given phase.\n    If the dump is not enabled, returns NULL.  */\n \n char *\n-get_dump_file_name (int phase)\n+gcc::dump_manager::\n+get_dump_file_name (int phase) const\n {\n   char dump_id[10];\n   struct dump_file_info *dfi;\n@@ -391,6 +396,7 @@ dump_printf_loc (int dump_kind, source_location loc, const char *format, ...)\n    -fopt-info stream. */\n \n int\n+gcc::dump_manager::\n dump_start (int phase, int *flag_ptr)\n {\n   int count = 0;\n@@ -443,6 +449,7 @@ dump_start (int phase, int *flag_ptr)\n    reset the globals DUMP_FILE, ALT_DUMP_FILE, and DUMP_FLAGS.  */\n \n void\n+gcc::dump_manager::\n dump_finish (int phase)\n {\n   struct dump_file_info *dfi;\n@@ -475,6 +482,13 @@ dump_finish (int phase)\n \n FILE *\n dump_begin (int phase, int *flag_ptr)\n+{\n+  return g->get_dumps ()->dump_begin (phase, flag_ptr);\n+}\n+\n+FILE *\n+gcc::dump_manager::\n+dump_begin (int phase, int *flag_ptr)\n {\n   char *name;\n   struct dump_file_info *dfi;\n@@ -512,17 +526,18 @@ dump_begin (int phase, int *flag_ptr)\n    If PHASE is TDI_tree_all, return nonzero if any dump is enabled for\n    any phase.  */\n \n-static int\n-dump_phase_enabled_p (int phase)\n+int\n+gcc::dump_manager::\n+dump_phase_enabled_p (int phase) const\n {\n   if (phase == TDI_tree_all)\n     {\n       size_t i;\n       for (i = TDI_none + 1; i < (size_t) TDI_end; i++)\n \tif (dump_files[i].pstate || dump_files[i].alt_state)\n \t  return 1;\n-      for (i = 0; i < extra_dump_files_in_use; i++)\n-\tif (extra_dump_files[i].pstate || extra_dump_files[i].alt_state)\n+      for (i = 0; i < m_extra_dump_files_in_use; i++)\n+\tif (m_extra_dump_files[i].pstate || m_extra_dump_files[i].alt_state)\n \t  return 1;\n       return 0;\n     }\n@@ -536,7 +551,8 @@ dump_phase_enabled_p (int phase)\n /* Returns nonzero if tree dump PHASE has been initialized.  */\n \n int\n-dump_initialized_p (int phase)\n+gcc::dump_manager::\n+dump_initialized_p (int phase) const\n {\n   struct dump_file_info *dfi = get_dump_file_info (phase);\n   return dfi->pstate > 0 || dfi->alt_state > 0;\n@@ -546,6 +562,13 @@ dump_initialized_p (int phase)\n \n const char *\n dump_flag_name (int phase)\n+{\n+  return g->get_dumps ()->dump_flag_name (phase);\n+}\n+\n+const char *\n+gcc::dump_manager::\n+dump_flag_name (int phase) const\n {\n   struct dump_file_info *dfi = get_dump_file_info (phase);\n   return dfi->swtch;\n@@ -564,7 +587,8 @@ dump_end (int phase ATTRIBUTE_UNUSED, FILE *stream)\n /* Enable all tree dumps with FLAGS on FILENAME.  Return number of\n    enabled tree dumps.  */\n \n-static int\n+int\n+gcc::dump_manager::\n dump_enable_all (int flags, const char *filename)\n {\n   int ir_dump_type = (flags & (TDF_TREE | TDF_RTL | TDF_IPA));\n@@ -592,21 +616,21 @@ dump_enable_all (int flags, const char *filename)\n         }\n     }\n \n-  for (i = 0; i < extra_dump_files_in_use; i++)\n+  for (i = 0; i < m_extra_dump_files_in_use; i++)\n     {\n-      if ((extra_dump_files[i].pflags & ir_dump_type))\n+      if ((m_extra_dump_files[i].pflags & ir_dump_type))\n         {\n-          const char *old_filename = extra_dump_files[i].pfilename;\n-          extra_dump_files[i].pstate = -1;\n-          extra_dump_files[i].pflags |= flags;\n+          const char *old_filename = m_extra_dump_files[i].pfilename;\n+          m_extra_dump_files[i].pstate = -1;\n+          m_extra_dump_files[i].pflags |= flags;\n           n++;\n           /* Override the existing filename.  */\n           if (filename)\n             {\n-              extra_dump_files[i].pfilename = xstrdup (filename);\n+              m_extra_dump_files[i].pfilename = xstrdup (filename);\n               /* Since it is a command-line provided file, which is\n                  common to all the phases, use it in append mode.  */\n-              extra_dump_files[i].pstate = 1;\n+              m_extra_dump_files[i].pstate = 1;\n             }\n           if (old_filename && filename != old_filename)\n             free (CONST_CAST (char *, old_filename));\n@@ -620,7 +644,8 @@ dump_enable_all (int flags, const char *filename)\n    Enable dumps with FLAGS on FILENAME.  Return the number of enabled\n    dumps.  */\n \n-static int\n+int\n+gcc::dump_manager::\n opt_info_enable_passes (int optgroup_flags, int flags, const char *filename)\n {\n   int n = 0;\n@@ -644,19 +669,19 @@ opt_info_enable_passes (int optgroup_flags, int flags, const char *filename)\n         }\n     }\n \n-  for (i = 0; i < extra_dump_files_in_use; i++)\n+  for (i = 0; i < m_extra_dump_files_in_use; i++)\n     {\n-      if ((extra_dump_files[i].optgroup_flags & optgroup_flags))\n+      if ((m_extra_dump_files[i].optgroup_flags & optgroup_flags))\n         {\n-          const char *old_filename = extra_dump_files[i].alt_filename;\n+          const char *old_filename = m_extra_dump_files[i].alt_filename;\n           /* Since this file is shared among different passes, it\n              should be opened in append mode.  */\n-          extra_dump_files[i].alt_state = 1;\n-          extra_dump_files[i].alt_flags |= flags;\n+          m_extra_dump_files[i].alt_state = 1;\n+          m_extra_dump_files[i].alt_flags |= flags;\n           n++;\n           /* Override the existing filename.  */\n           if (filename)\n-            extra_dump_files[i].alt_filename = xstrdup (filename);\n+            m_extra_dump_files[i].alt_filename = xstrdup (filename);\n           if (old_filename && filename != old_filename)\n             free (CONST_CAST (char *, old_filename));\n         }\n@@ -668,7 +693,8 @@ opt_info_enable_passes (int optgroup_flags, int flags, const char *filename)\n /* Parse ARG as a dump switch. Return nonzero if it is, and store the\n    relevant details in the dump_files array.  */\n \n-static int\n+int\n+gcc::dump_manager::\n dump_switch_p_1 (const char *arg, struct dump_file_info *dfi, bool doglob)\n {\n   const char *option_value;\n@@ -743,6 +769,7 @@ dump_switch_p_1 (const char *arg, struct dump_file_info *dfi, bool doglob)\n }\n \n int\n+gcc::dump_manager::\n dump_switch_p (const char *arg)\n {\n   size_t i;\n@@ -756,12 +783,12 @@ dump_switch_p (const char *arg)\n     for (i = TDI_none + 1; i != TDI_end; i++)\n       any |= dump_switch_p_1 (arg, &dump_files[i], true);\n \n-  for (i = 0; i < extra_dump_files_in_use; i++)\n-    any |= dump_switch_p_1 (arg, &extra_dump_files[i], false);\n+  for (i = 0; i < m_extra_dump_files_in_use; i++)\n+    any |= dump_switch_p_1 (arg, &m_extra_dump_files[i], false);\n \n   if (!any)\n-    for (i = 0; i < extra_dump_files_in_use; i++)\n-      any |= dump_switch_p_1 (arg, &extra_dump_files[i], true);\n+    for (i = 0; i < m_extra_dump_files_in_use; i++)\n+      any |= dump_switch_p_1 (arg, &m_extra_dump_files[i], true);\n \n \n   return any;\n@@ -853,6 +880,7 @@ opt_info_switch_p (const char *arg)\n   int optgroup_flags;\n   char *filename;\n   static char *file_seen = NULL;\n+  gcc::dump_manager *dumps = g->get_dumps ();\n \n   if (!opt_info_switch_p_1 (arg, &flags, &optgroup_flags, &filename))\n     return 0;\n@@ -874,7 +902,7 @@ opt_info_switch_p (const char *arg)\n   if (!optgroup_flags)\n     optgroup_flags = OPTGROUP_ALL;\n \n-  return opt_info_enable_passes (optgroup_flags, flags, filename);\n+  return dumps->opt_info_enable_passes (optgroup_flags, flags, filename);\n }\n \n /* Print basic block on the dump streams.  */\n@@ -902,5 +930,8 @@ print_combine_total_stats (void)\n bool\n enable_rtl_dump_file (void)\n {\n-  return dump_enable_all (TDF_RTL | TDF_DETAILS | TDF_BLOCKS, NULL) > 0;\n+  gcc::dump_manager *dumps = g->get_dumps ();\n+  int num_enabled =\n+    dumps->dump_enable_all (TDF_RTL | TDF_DETAILS | TDF_BLOCKS, NULL);\n+  return num_enabled > 0;\n }"}, {"sha": "a6b377eaf8c9336c4ba04fc246fe14bda3c51b61", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 80, "deletions": 10, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -121,13 +121,8 @@ struct dump_file_info\n };\n \n /* In dumpfile.c */\n-extern char *get_dump_file_name (int);\n-extern int dump_initialized_p (int);\n extern FILE *dump_begin (int, int *);\n extern void dump_end (int, FILE *);\n-extern int dump_start (int, int *);\n-extern void dump_finish (int);\n-extern int dump_switch_p (const char *);\n extern int opt_info_switch_p (const char *);\n extern const char *dump_flag_name (int);\n extern void dump_printf (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n@@ -139,8 +134,6 @@ extern void dump_generic_expr (int, int, tree);\n extern void dump_gimple_stmt_loc (int, source_location, int, gimple, int);\n extern void dump_gimple_stmt (int, int, gimple, int);\n extern void print_combine_total_stats (void);\n-extern unsigned int dump_register (const char *, const char *, const char *,\n-                                   int, int);\n extern bool enable_rtl_dump_file (void);\n \n /* In tree-dump.c  */\n@@ -157,14 +150,91 @@ extern FILE *alt_dump_file;\n extern int dump_flags;\n extern const char *dump_file_name;\n \n-/* Return the dump_file_info for the given phase.  */\n-extern struct dump_file_info *get_dump_file_info (int);\n-\n /* Return true if any of the dumps is enabled, false otherwise. */\n static inline bool\n dump_enabled_p (void)\n {\n   return (dump_file || alt_dump_file);\n }\n \n+namespace gcc {\n+\n+class dump_manager\n+{\n+public:\n+\n+  dump_manager ();\n+\n+  unsigned int\n+  dump_register (const char *suffix, const char *swtch, const char *glob,\n+\t\t int flags, int optgroup_flags);\n+\n+  /* Return the dump_file_info for the given phase.  */\n+  struct dump_file_info *\n+  get_dump_file_info (int phase) const;\n+\n+  /* Return the name of the dump file for the given phase.\n+     If the dump is not enabled, returns NULL.  */\n+  char *\n+  get_dump_file_name (int phase) const;\n+\n+  int\n+  dump_switch_p (const char *arg);\n+\n+  /* Start a dump for PHASE. Store user-supplied dump flags in\n+     *FLAG_PTR.  Return the number of streams opened.  Set globals\n+     DUMP_FILE, and ALT_DUMP_FILE to point to the opened streams, and\n+     set dump_flags appropriately for both pass dump stream and\n+     -fopt-info stream. */\n+  int\n+  dump_start (int phase, int *flag_ptr);\n+\n+  /* Finish a tree dump for PHASE and close associated dump streams.  Also\n+     reset the globals DUMP_FILE, ALT_DUMP_FILE, and DUMP_FLAGS.  */\n+  void\n+  dump_finish (int phase);\n+\n+  FILE *\n+  dump_begin (int phase, int *flag_ptr);\n+\n+  /* Returns nonzero if tree dump PHASE has been initialized.  */\n+  int\n+  dump_initialized_p (int phase) const;\n+\n+  /* Returns the switch name of PHASE.  */\n+  const char *\n+  dump_flag_name (int phase) const;\n+\n+private:\n+\n+  int\n+  dump_phase_enabled_p (int phase) const;\n+\n+  int\n+  dump_switch_p_1 (const char *arg, struct dump_file_info *dfi, bool doglob);\n+\n+  int\n+  dump_enable_all (int flags, const char *filename);\n+\n+  int\n+  opt_info_enable_passes (int optgroup_flags, int flags, const char *filename);\n+\n+private:\n+\n+  /* Dynamically registered dump files and switches.  */\n+  int m_next_dump;\n+  struct dump_file_info *m_extra_dump_files;\n+  size_t m_extra_dump_files_in_use;\n+  size_t m_extra_dump_files_alloced;\n+\n+  /* Grant access to dump_enable_all.  */\n+  friend bool ::enable_rtl_dump_file (void);\n+\n+  /* Grant access to opt_info_enable_passes.  */\n+  friend int ::opt_info_switch_p (const char *arg);\n+\n+}; // class dump_manager\n+\n+} // namespace gcc\n+\n #endif /* GCC_DUMPFILE_H */"}, {"sha": "3c6563eaa8e557ad29e84b9cd22abc7bfa6a8883", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -1,3 +1,8 @@\n+2013-10-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* lang.c (java_handle_option): Update for introduction of\n+\tgcc::dump_manager.\n+\n 2013-09-25  Tom Tromey  <tromey@redhat.com>\n \n \t* Make-lang.in (jvspec.o): Remove."}, {"sha": "6d89134debe60193f8bfdbd6399db3c045bdf164", "filename": "gcc/java/lang.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -42,6 +42,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"opts.h\"\n #include \"options.h\"\n #include \"target.h\"\n+#include \"context.h\"\n \n static bool java_init (void);\n static void java_finish (void);\n@@ -271,7 +272,7 @@ java_handle_option (size_t scode, const char *arg, int value,\n       break;\n \n     case OPT_fdump_:\n-      if (!dump_switch_p (arg))\n+      if (!g->get_dumps ()->dump_switch_p (arg))\n \treturn false;\n       break;\n "}, {"sha": "8ce705ea6369ac07be91569d417e5ade3b4c093b", "filename": "gcc/opts-global.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fopts-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fopts-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-global.c?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"toplev.h\"\n #include \"tree-pass.h\"\n+#include \"context.h\"\n \n typedef const char *const_char_p; /* For DEF_VEC_P.  */\n \n@@ -385,7 +386,7 @@ handle_common_deferred_options (void)\n \t  break;\n \n \tcase OPT_fdump_:\n-\t  if (!dump_switch_p (opt->arg))\n+\t  if (!g->get_dumps ()->dump_switch_p (opt->arg))\n \t    error (\"unrecognized command line option %<-fdump-%s%>\", opt->arg);\n \t  break;\n "}, {"sha": "5e6b8e5cc0167cb275a38a3cac4ec20fe91361dd", "filename": "gcc/passes.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -279,27 +279,28 @@ finish_optimization_passes (void)\n   int i;\n   struct dump_file_info *dfi;\n   char *name;\n+  gcc::dump_manager *dumps = m_ctxt->get_dumps ();\n \n   timevar_push (TV_DUMP);\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n-      dump_start (pass_profile_1->static_pass_number, NULL);\n+      dumps->dump_start (pass_profile_1->static_pass_number, NULL);\n       end_branch_prob ();\n-      dump_finish (pass_profile_1->static_pass_number);\n+      dumps->dump_finish (pass_profile_1->static_pass_number);\n     }\n \n   if (optimize > 0)\n     {\n-      dump_start (pass_profile_1->static_pass_number, NULL);\n+      dumps->dump_start (pass_profile_1->static_pass_number, NULL);\n       print_combine_total_stats ();\n-      dump_finish (pass_profile_1->static_pass_number);\n+      dumps->dump_finish (pass_profile_1->static_pass_number);\n     }\n \n   /* Do whatever is necessary to finish printing the graphs.  */\n-  for (i = TDI_end; (dfi = get_dump_file_info (i)) != NULL; ++i)\n-    if (dump_initialized_p (i)\n+  for (i = TDI_end; (dfi = dumps->get_dump_file_info (i)) != NULL; ++i)\n+    if (dumps->dump_initialized_p (i)\n \t&& (dfi->pflags & TDF_GRAPH) != 0\n-\t&& (name = get_dump_file_name (i)) != NULL)\n+\t&& (name = dumps->get_dump_file_name (i)) != NULL)\n       {\n \tfinish_graph_dump_file (name);\n \tfree (name);\n@@ -642,6 +643,7 @@ pass_manager::register_one_dump_file (struct opt_pass *pass)\n   char num[10];\n   int flags, id;\n   int optgroup_flags = OPTGROUP_NONE;\n+  gcc::dump_manager *dumps = m_ctxt->get_dumps ();\n \n   /* See below in next_pass_1.  */\n   num[0] = '\\0';\n@@ -682,7 +684,8 @@ pass_manager::register_one_dump_file (struct opt_pass *pass)\n      any dump messages are emitted properly under -fopt-info(-optall).  */\n   if (optgroup_flags == OPTGROUP_NONE)\n     optgroup_flags = OPTGROUP_OTHER;\n-  id = dump_register (dot_name, flag_name, glob_name, flags, optgroup_flags);\n+  id = dumps->dump_register (dot_name, flag_name, glob_name, flags,\n+\t\t\t     optgroup_flags);\n   set_pass_for_id (id, pass);\n   full_name = concat (prefix, pass->name, num, NULL);\n   register_pass_name (pass, full_name);\n@@ -1390,6 +1393,7 @@ void\n pass_manager::register_pass (struct register_pass_info *pass_info)\n {\n   bool all_instances, success;\n+  gcc::dump_manager *dumps = m_ctxt->get_dumps ();\n \n   /* The checks below could fail in buggy plugins.  Existing GCC\n      passes should never fail these checks, so we mention plugin in\n@@ -1447,9 +1451,9 @@ pass_manager::register_pass (struct register_pass_info *pass_info)\n       else\n         tdi = TDI_rtl_all;\n       /* Check if dump-all flag is specified.  */\n-      if (get_dump_file_info (tdi)->pstate)\n-        get_dump_file_info (added_pass_nodes->pass->static_pass_number)\n-            ->pstate = get_dump_file_info (tdi)->pstate;\n+      if (dumps->get_dump_file_info (tdi)->pstate)\n+        dumps->get_dump_file_info (added_pass_nodes->pass->static_pass_number)\n+            ->pstate = dumps->get_dump_file_info (tdi)->pstate;\n       XDELETE (added_pass_nodes);\n       added_pass_nodes = next_node;\n     }\n@@ -1932,9 +1936,11 @@ pass_init_dump_file (struct opt_pass *pass)\n   if (pass->static_pass_number != -1)\n     {\n       timevar_push (TV_DUMP);\n-      bool initializing_dump = !dump_initialized_p (pass->static_pass_number);\n-      dump_file_name = get_dump_file_name (pass->static_pass_number);\n-      dump_start (pass->static_pass_number, &dump_flags);\n+      gcc::dump_manager *dumps = g->get_dumps ();\n+      bool initializing_dump =\n+\t!dumps->dump_initialized_p (pass->static_pass_number);\n+      dump_file_name = dumps->get_dump_file_name (pass->static_pass_number);\n+      dumps->dump_start (pass->static_pass_number, &dump_flags);\n       if (dump_file && current_function_decl)\n         dump_function_header (dump_file, current_function_decl, dump_flags);\n       if (initializing_dump\n@@ -1963,7 +1969,7 @@ pass_fini_dump_file (struct opt_pass *pass)\n       dump_file_name = NULL;\n     }\n \n-  dump_finish (pass->static_pass_number);\n+  g->get_dumps ()->dump_finish (pass->static_pass_number);\n   timevar_pop (TV_DUMP);\n }\n "}, {"sha": "51d3f3af088c7959a2d41c1a54f368c8d66579b3", "filename": "gcc/statistics.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47e0da377eb7021c043244cd4ff99669eb1a370c/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=47e0da377eb7021c043244cd4ff99669eb1a370c", "patch": "@@ -260,17 +260,20 @@ statistics_fini (void)\n void\n statistics_early_init (void)\n {\n-  statistics_dump_nr = dump_register (\".statistics\", \"statistics\",\n-\t\t\t\t      \"statistics\", TDF_TREE, OPTGROUP_NONE);\n+  gcc::dump_manager *dumps = g->get_dumps ();\n+  statistics_dump_nr = dumps->dump_register (\".statistics\", \"statistics\",\n+\t\t\t\t\t     \"statistics\", TDF_TREE,\n+\t\t\t\t\t     OPTGROUP_NONE);\n }\n \n /* Init the statistics.  */\n \n void\n statistics_init (void)\n {\n+  gcc::dump_manager *dumps = g->get_dumps ();\n   statistics_dump_file = dump_begin (statistics_dump_nr, NULL);\n-  statistics_dump_flags = get_dump_file_info (statistics_dump_nr)->pflags;\n+  statistics_dump_flags = dumps->get_dump_file_info (statistics_dump_nr)->pflags;\n }\n \n /* Lookup or add a statistics counter in the hashtable HASH with ID, VAL"}]}