{"sha": "25250265baeee2bdca9b08958620f501b80e760a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUyNTAyNjViYWVlZTJiZGNhOWIwODk1ODYyMGY1MDFiODBlNzYwYQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@redhat.com", "date": "2001-04-14T03:49:46Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2001-04-14T03:49:46Z"}, "message": "Fix linux kernel -foptimize-sibling-calls miscompilation\n\nFix linux kernel -foptimize-sibling-calls miscompilation\n\t* config/ia64/ia64.c (ia64_expand_epilogue): Emit alloc if sibcall_p.\n\t(first_instruction): New static variable.\n\t(rtx_needs_barrier): Return 1 for alloc.\n\t(init_insn_group_barriers): Set first_instruction.\n\t(rws_sum): Delete duplicate definition.\n\t(group_barrier_needed_p): Return 0 when first_instruction true.\n\t(safe_group_barrier_needed_p): Save and restore first_instruction\n\taround group_barrier_needed_p call.\n\nFrom-SVN: r41347", "tree": {"sha": "8e1730685406e09ce3a77740f3a41246b8a91d3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e1730685406e09ce3a77740f3a41246b8a91d3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25250265baeee2bdca9b08958620f501b80e760a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25250265baeee2bdca9b08958620f501b80e760a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25250265baeee2bdca9b08958620f501b80e760a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25250265baeee2bdca9b08958620f501b80e760a/comments", "author": null, "committer": null, "parents": [{"sha": "b215b52e59a5fe300f5327a4fd886c9e1673a4c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b215b52e59a5fe300f5327a4fd886c9e1673a4c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b215b52e59a5fe300f5327a4fd886c9e1673a4c0"}], "stats": {"total": 63, "additions": 53, "deletions": 10}, "files": [{"sha": "9dcb55d7ce7045cb0da3ad31a9ee467b9bb3c7b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25250265baeee2bdca9b08958620f501b80e760a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25250265baeee2bdca9b08958620f501b80e760a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25250265baeee2bdca9b08958620f501b80e760a", "patch": "@@ -1,3 +1,14 @@\n+2001-04-13  Jim Wilson  <wilson@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_expand_epilogue): Emit alloc if sibcall_p.\n+\t(first_instruction): New static variable.\n+\t(rtx_needs_barrier): Return 1 for alloc.\n+\t(init_insn_group_barriers): Set first_instruction.\n+\t(rws_sum): Delete duplicate definition.\n+\t(group_barrier_needed_p): Return 0 when first_instruction true.\n+\t(safe_group_barrier_needed_p): Save and restore first_instruction\n+\taround group_barrier_needed_p call.\n+\n Fri Apr 13 21:40:28 2001  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* expr.h (enum libfunc_index): Add LTI_memmove."}, {"sha": "5b6ffba626deb51111e88028c6167130ef0e3231", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25250265baeee2bdca9b08958620f501b80e760a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25250265baeee2bdca9b08958620f501b80e760a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=25250265baeee2bdca9b08958620f501b80e760a", "patch": "@@ -2399,6 +2399,18 @@ ia64_expand_epilogue (sibcall_p)\n  \n   if (! sibcall_p)\n     emit_jump_insn (gen_return_internal (gen_rtx_REG (DImode, BR_REG (0))));\n+  else\n+    /* We must emit an alloc to force the input registers to become output\n+       registers.  Otherwise, if the callee tries to pass its parameters\n+       through to another call without an intervening alloc, then these\n+       values get lost.  */\n+    /* ??? We don't need to preserve all input registers.  We only need to\n+       preserve those input registers used as arguments to the sibling call.\n+       It is unclear how to compute that number here.  */\n+    emit_insn (gen_alloc (gen_rtx_REG (DImode, GR_REG (2)),\n+\t\t\t  GEN_INT (0), GEN_INT (0),\n+\t\t\t  GEN_INT (current_frame_info.n_input_regs),\n+\t\t\t  GEN_INT (0)));\n }\n \n /* Return 1 if br.ret can do all the work required to return from a\n@@ -3818,6 +3830,11 @@ struct reg_write_state rws_sum[NUM_REGS];\n    stop bit is emitted.  */\n struct reg_write_state rws_insn[NUM_REGS];\n \n+/* Indicates whether this is the first instruction after a stop bit,\n+   in which case we don't need another stop bit.  Without this, we hit\n+   the abort in ia64_variable_issue when scheduling an alloc.  */\n+static int first_instruction;\n+\n /* Misc flags needed to compute RAW/WAW dependencies while we are traversing\n    RTL for one instruction.  */\n struct reg_flags\n@@ -4379,14 +4396,18 @@ rtx_needs_barrier (x, flags, pred)\n       switch (XINT (x, 1))\n \t{\n \tcase 0: /* alloc */\n-\t  /* Alloc must always be the first instruction.  Currently, we\n-\t     only emit it at the function start, so we don't need to worry\n-\t     about emitting a stop bit before it.  */\n-\t  need_barrier = rws_access_regno (AR_PFS_REGNUM, flags, pred);\n+\t  /* Alloc must always be the first instruction of a group.\n+\t     We force this by always returning true.  */\n+\t  /* ??? We might get better scheduling if we explicitly check for\n+\t     input/local/output register dependencies, and modify the\n+\t     scheduler so that alloc is always reordered to the start of\n+\t     the current group.  We could then eliminate all of the\n+\t     first_instruction code.  */\n+\t  rws_access_regno (AR_PFS_REGNUM, flags, pred);\n \n \t  new_flags.is_write = 1;\n-\t  need_barrier |= rws_access_regno (REG_AR_CFM, new_flags, pred);\n-\t  return need_barrier;\n+\t  rws_access_regno (REG_AR_CFM, new_flags, pred);\n+\t  return 1;\n \n \tcase 1: /* blockage */\n \tcase 2: /* insn group barrier */\n@@ -4455,11 +4476,9 @@ static void\n init_insn_group_barriers ()\n {\n   memset (rws_sum, 0, sizeof (rws_sum));\n+  first_instruction = 1;\n }\n \n-/* Cumulative info for the current instruction group.  */\n-struct reg_write_state rws_sum[NUM_REGS];\n-\n /* Given the current state, recorded by previous calls to this function,\n    determine whether a group barrier (a stop bit) is necessary before INSN.\n    Return nonzero if so.  */\n@@ -4537,12 +4556,18 @@ group_barrier_needed_p (insn)\n \t asm.  */\n       if (! need_barrier)\n \tneed_barrier = rws_access_regno (REG_VOLATILE, flags, 0);\n-\n       break;\n \n     default:\n       abort ();\n     }\n+\n+  if (first_instruction)\n+    {\n+      need_barrier = 0;\n+      first_instruction = 0;\n+    }\n+\n   return need_barrier;\n }\n \n@@ -4553,10 +4578,17 @@ safe_group_barrier_needed_p (insn)\n      rtx insn;\n {\n   struct reg_write_state rws_saved[NUM_REGS];\n+  int saved_first_instruction;\n   int t;\n+\n   memcpy (rws_saved, rws_sum, NUM_REGS * sizeof *rws_saved);\n+  saved_first_instruction = first_instruction;\n+\n   t = group_barrier_needed_p (insn);\n+\n   memcpy (rws_sum, rws_saved, NUM_REGS * sizeof *rws_saved);\n+  first_instruction = saved_first_instruction;\n+\n   return t;\n }\n "}]}