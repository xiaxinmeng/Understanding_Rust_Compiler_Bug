{"sha": "15794a956736ea9e48c66498cb7c5507300188be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU3OTRhOTU2NzM2ZWE5ZTQ4YzY2NDk4Y2I3YzU1MDczMDAxODhiZQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gnu.org", "date": "2000-07-20T07:27:26Z"}, "committer": {"name": "Ovidiu Predescu", "email": "ovidiu@gcc.gnu.org", "date": "2000-07-20T07:27:26Z"}, "message": "Applied H.J.Lu's patch to not require -lpthread when compiling single threaded Objective-C programs.\n\nFrom-SVN: r35141", "tree": {"sha": "d58bf86c68a47e2d7676ceb24f237b52dec0b901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d58bf86c68a47e2d7676ceb24f237b52dec0b901"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15794a956736ea9e48c66498cb7c5507300188be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15794a956736ea9e48c66498cb7c5507300188be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15794a956736ea9e48c66498cb7c5507300188be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15794a956736ea9e48c66498cb7c5507300188be/comments", "author": null, "committer": null, "parents": [{"sha": "0ea1e106b2ee766350163d1c8d3185dd8046357a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea1e106b2ee766350163d1c8d3185dd8046357a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ea1e106b2ee766350163d1c8d3185dd8046357a"}], "stats": {"total": 1759, "additions": 1723, "deletions": 36}, "files": [{"sha": "bcd6f9bea5e6c97f7b9d3501bafac24fed14e8b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -5122,6 +5122,15 @@ Sat May 13 11:05:47 2000  Philippe De Muyter  <phdm@macqel.be>\n \n \t* ifcvt.c (if_convert): Do not free NULL.\n \n+2000-05-12  H.J. Lu  (hjl@gnu.org)\n+\n+\t* gthr-dce.h: Add support for libobjc.\n+\t* gthr-posix.h: Likewise.\n+\t* gthr-solaris.h: Likewise.\n+\t* gthr-vxworks.h: Likewise.\n+\t* gthr-single.h: Likewise.\n+\t* gthr-win32.h: Likewise.\n+\n 2000-05-12  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/fr30/fr30.c (fr30_move_double): New function:  Emit code"}, {"sha": "e41987b454a774652eb7bb15ad5b3138f9a3439a", "filename": "gcc/gthr-dce.h", "status": "modified", "additions": 311, "deletions": 2, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-dce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-dce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-dce.h?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1,6 +1,6 @@\n \n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -48,7 +48,7 @@ typedef pthread_mutex_t __gthread_mutex_t;\n \n #pragma weak pthread_once\n #pragma weak pthread_once_init\n-#pragma weak pthread_key_create\n+#pragma weak pthread_keycreate\n #pragma weak pthread_key_delete\n #pragma weak pthread_getspecific\n #pragma weak pthread_setspecific\n@@ -58,6 +58,21 @@ typedef pthread_mutex_t __gthread_mutex_t;\n #pragma weak pthread_mutex_trylock\n #pragma weak pthread_mutex_unlock\n \n+#ifdef _LIBOBJC\n+/* Objective C. */\n+#pragma weak pthread_cond_broadcast\n+#pragma weak pthread_cond_destroy\n+#pragma weak pthread_cond_init\n+#pragma weak pthread_cond_signal\n+#pragma weak pthread_cond_wait\n+#pragma weak pthread_exit\n+#pragma weak pthread_getunique_np\n+#pragma weak pthread_mutex_init\n+#pragma weak pthread_mutex_destroy\n+#pragma weak pthread_self\n+#pragma weak pthread_yield\n+#endif\n+\n static void *__gthread_active_ptr = &pthread_create;\n \n static inline int\n@@ -76,6 +91,298 @@ __gthread_active_p (void)\n \n #endif /* SUPPORTS_WEAK */\n \n+#ifdef _LIBOBJC\n+\n+/* Key structure for maintaining thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+static inline int\n+__gthread_objc_init_thread_system(void)\n+{\n+  if (__gthread_active_p ())\n+    /* Initialize the thread storage key */\n+    return pthread_keycreate (&_objc_thread_storage, NULL);\n+  else\n+    return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+static inline int\n+__gthread_objc_close_thread_system(void)\n+{\n+  if (__gthread_active_p ())\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+static inline objc_thread_t\n+__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if (!__gthread_active_p ())\n+    return NULL;\n+ \n+  if ( !(pthread_create(&new_thread_handle, pthread_attr_default,\n+  \t\t\t(void *)func, arg)) )\n+    {\n+      /* ??? May not work! (64bit) */\n+      thread_id = *(objc_thread_t *)&new_thread_handle;\n+      pthread_detach(&new_thread_handle); /* Fully detach thread. */\n+    }\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_set_priority(int priority)\n+{\n+  int sys_priority = 0;\n+\n+  if (!__gthread_active_p ())\n+    return -1;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n+      break;\n+    }\n+    \n+  /* Change the priority. */\n+  if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n+    return 0;\n+  else\n+    /* Failed */\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_get_priority(void)\n+{\n+  int sys_priority;\n+\n+  if (__gthread_active_p ())\n+    {\n+      if ((sys_priority = pthread_getprio(pthread_self())) >= 0)\n+        {\n+\t  if (sys_priority >= PRI_FG_MIN_NP\n+\t      && sys_priority <= PRI_FG_MAX_NP)\n+\t    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+\t  if (sys_priority >= PRI_BG_MIN_NP\n+\t      && sys_priority <= PRI_BG_MAX_NP)\n+\t    return OBJC_THREAD_BACKGROUND_PRIORITY;\n+\t  return OBJC_THREAD_LOW_PRIORITY;\n+\t}\n+\n+      /* Failed */\n+      return -1;\n+    }\n+  else\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+static inline void\n+__gthread_objc_thread_yield(void)\n+{\n+  if (__gthread_active_p ())\n+    pthread_yield();\n+}\n+\n+/* Terminate the current thread. */\n+static inline int\n+__gthread_objc_thread_exit(void)\n+{\n+  if (__gthread_active_p ())\n+    /* exit the thread */\n+    pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+static inline objc_thread_t\n+__gthread_objc_thread_id(void)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      pthread_t self = pthread_self();\n+\n+      return (objc_thread_t) pthread_getunique_np (&self);\n+    }\n+  else\n+    return (objc_thread_t)1;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+static inline int\n+__gthread_objc_thread_set_data(void *value)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_setspecific(_objc_thread_storage, value);\n+  else\n+    {\n+      thread_local_storage = value;\n+      return 0;\n+    }\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+static inline void *\n+__gthread_objc_thread_get_data(void)\n+{\n+  void *value = NULL;\n+\n+  if (__gthread_active_p ())\n+    {\n+      if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n+\treturn value;\n+\n+      return NULL;\n+    }\n+  else\n+    return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && pthread_mutex_init((pthread_mutex_t *)mutex->backend,\n+      \t\t\t    pthread_mutexattr_default))\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_lock((pthread_mutex_t *)mutex->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && pthread_mutex_trylock((pthread_mutex_t *)mutex->backend) != 1)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+static inline int\n+__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+static inline int\n+__gthread_objc_condition_allocate(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ()\n+    /* Unimplemented. */\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a condition. */\n+static inline int\n+__gthread_objc_condition_deallocate(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    /* Unimplemented. */\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Wait on the condition */\n+static inline int\n+__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    /* Unimplemented. */\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_broadcast(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    /* Unimplemented. */\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_signal(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    /* Unimplemented. */\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+#else /* _LIBOBJC */\n+\n static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n@@ -147,4 +454,6 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+#endif /* _LIBOBJC */\n+\n #endif /* not __gthr_dce_h */"}, {"sha": "91de78ae4b84daede5e45e4a6f2818b268acb1d6", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 304, "deletions": 11, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1,6 +1,6 @@\n-/* Threads compatibility routines for libgcc2.  */\n+/* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -45,16 +45,30 @@ typedef pthread_mutex_t __gthread_mutex_t;\n \n #if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n \n- #pragma weak pthread_once\n- #pragma weak pthread_key_create\n- #pragma weak pthread_key_delete\n- #pragma weak pthread_getspecific\n- #pragma weak pthread_setspecific\n- #pragma weak pthread_create\n+#pragma weak pthread_once\n+#pragma weak pthread_key_create\n+#pragma weak pthread_key_delete\n+#pragma weak pthread_getspecific\n+#pragma weak pthread_setspecific\n+#pragma weak pthread_create\n \n- #pragma weak pthread_mutex_lock \n- #pragma weak pthread_mutex_trylock \n- #pragma weak pthread_mutex_unlock \n+#pragma weak pthread_mutex_lock \n+#pragma weak pthread_mutex_trylock \n+#pragma weak pthread_mutex_unlock \n+\n+#ifdef _LIBOBJC\n+/* Objective C. */\n+#pragma weak pthread_cond_broadcast\n+#pragma weak pthread_cond_destroy\n+#pragma weak pthread_cond_init\n+#pragma weak pthread_cond_signal\n+#pragma weak pthread_cond_wait\n+#pragma weak pthread_exit\n+#pragma weak pthread_mutex_init\n+#pragma weak pthread_mutex_destroy\n+#pragma weak pthread_self\n+#pragma weak sched_yield\n+#endif\n \n static void *__gthread_active_ptr = &pthread_create;\n \n@@ -74,6 +88,283 @@ __gthread_active_p (void)\n \n #endif /* SUPPORTS_WEAK */\n \n+#ifdef _LIBOBJC\n+\n+/* Key structure for maintaining thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+static inline int\n+__gthread_objc_init_thread_system(void)\n+{\n+  if (__gthread_active_p ())\n+    /* Initialize the thread storage key */\n+    return pthread_key_create(&_objc_thread_storage, NULL);\n+  else\n+    return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+static inline int\n+__gthread_objc_close_thread_system(void)\n+{\n+  if (__gthread_active_p ())\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+static inline objc_thread_t\n+__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  if (!__gthread_active_p ())\n+    return NULL;\n+ \n+  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n+    thread_id = *(objc_thread_t *)&new_thread_handle;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_set_priority(int priority)\n+{\n+  /* Not implemented yet */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_get_priority(void)\n+{\n+  if (__gthread_active_p ())\n+    /* Not implemented yet */\n+    return -1;\n+  else\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+static inline void\n+__gthread_objc_thread_yield(void)\n+{\n+  if (__gthread_active_p ())\n+    sched_yield();\n+}\n+\n+/* Terminate the current thread. */\n+static inline int\n+__gthread_objc_thread_exit(void)\n+{\n+  if (__gthread_active_p ())\n+    /* exit the thread */\n+    pthread_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+static inline objc_thread_t\n+__gthread_objc_thread_id(void)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      pthread_t self = pthread_self();\n+\n+      return *(objc_thread_t *)&self;\n+    }\n+  else\n+    return (objc_thread_t)1;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+static inline int\n+__gthread_objc_thread_set_data(void *value)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_setspecific(_objc_thread_storage, value);\n+  else\n+    {\n+      thread_local_storage = value;\n+      return 0;\n+    }\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+static inline void *\n+__gthread_objc_thread_get_data(void)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_getspecific(_objc_thread_storage);\n+  else\n+    return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      mutex->backend = objc_malloc(sizeof(pthread_mutex_t));\n+\n+      if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))\n+\t{\n+\t  objc_free(mutex->backend);\n+\t  mutex->backend = NULL;\n+\t  return -1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      int count;\n+\n+      /*\n+       * Posix Threads specifically require that the thread be unlocked\n+       * for pthread_mutex_destroy to work.\n+       */\n+\n+      do\n+\t{\n+\t  count = pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n+\t  if (count < 0)\n+\t    return -1;\n+\t}\n+      while (count);\n+\n+      if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n+\treturn -1;\n+\n+      objc_free(mutex->backend);\n+      mutex->backend = NULL;\n+    }\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_lock((pthread_mutex_t *)mutex->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_trylock((pthread_mutex_t *)mutex->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+static inline int\n+__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+static inline int\n+__gthread_objc_condition_allocate(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      condition->backend = objc_malloc(sizeof(pthread_cond_t));\n+\n+      if (pthread_cond_init((pthread_cond_t *)condition->backend, NULL))\n+\t{\n+\t  objc_free(condition->backend);\n+\t  condition->backend = NULL;\n+\t  return -1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+static inline int\n+__gthread_objc_condition_deallocate(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      if (pthread_cond_destroy((pthread_cond_t *)condition->backend))\n+\treturn -1;\n+\n+      objc_free(condition->backend);\n+      condition->backend = NULL;\n+    }\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+static inline int\n+__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_cond_wait((pthread_cond_t *)condition->backend,\n+\t\t\t   (pthread_mutex_t *)mutex->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_broadcast(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_cond_broadcast((pthread_cond_t *)condition->backend);\n+  else\n+    return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_signal(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return pthread_cond_signal((pthread_cond_t *)condition->backend);\n+  else\n+    return 0;\n+}\n+\n+#else /* _LIBOBJC */\n+\n static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n@@ -144,4 +435,6 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+#endif /* _LIBOBJC */\n+\n #endif /* not __gthr_posix_h */"}, {"sha": "4bfea5e308769647c12f81077b234a1050714974", "filename": "gcc/gthr-single.h", "status": "modified", "additions": 170, "deletions": 2, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-single.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-single.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-single.h?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1,6 +1,6 @@\n-/* Threads compatibility routines for libgcc2.  */\n+/* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -35,6 +35,172 @@ typedef int __gthread_mutex_t;\n \n #define __GTHREAD_MUTEX_INIT 0\n \n+#ifdef _LIBOBJC\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+static inline int\n+__gthread_objc_init_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+static inline int\n+__gthread_objc_close_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+static inline objc_thread_t\n+__gthread_objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  /* No thread support available */\n+  return NULL;\n+}\n+\n+/* Set the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_set_priority(int priority)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_get_priority(void)\n+{\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+static inline void\n+__gthread_objc_thread_yield(void)\n+{\n+  return;\n+}\n+\n+/* Terminate the current thread. */\n+static inline int\n+__gthread_objc_thread_exit(void)\n+{\n+  /* No thread support available */\n+  /* Should we really exit the program */\n+  /* exit(&__objc_thread_exit_status); */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+static inline objc_thread_t\n+__gthread_objc_thread_id(void)\n+{\n+  /* No thread support, use 1. */\n+  return (objc_thread_t)1;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+static inline int\n+__gthread_objc_thread_set_data(void *value)\n+{\n+  thread_local_storage = value;\n+  return 0;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+static inline void *\n+__gthread_objc_thread_get_data(void)\n+{\n+  return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+static inline int\n+__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+static inline int\n+__gthread_objc_condition_allocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+static inline int\n+__gthread_objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+static inline int\n+__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_signal(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+#else /* _LIBOBJC */\n+\n static inline int\n __gthread_active_p (void)\n {\n@@ -59,4 +225,6 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex __attribute__ ((__unused__)))\n   return 0;\n }\n \n+#endif /* _LIBOBJC */\n+\n #endif /* not __gthr_single_h */"}, {"sha": "fca3084f9a70599280438f3223875973701a7edc", "filename": "gcc/gthr-solaris.h", "status": "modified", "additions": 305, "deletions": 2, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-solaris.h?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1,6 +1,6 @@\n-/* Threads compatibility routines for libgcc2.  */\n+/* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -60,6 +60,24 @@ typedef mutex_t __gthread_mutex_t;\n #pragma weak mutex_trylock\n #pragma weak mutex_unlock\n \n+#ifdef _LIBOBJC\n+#pragma weak thr_exit\n+#pragma weak thr_keycreate\n+#pragma weak thr_getprio\n+#pragma weak thr_self\n+#pragma weak thr_setprio\n+#pragma weak thr_yield\n+\n+#pragma weak cond_init\n+#pragma weak cond_destroy\n+#pragma weak cond_wait\n+#pragma weak cond_broadcast\n+#pragma weak cond_signal\n+\n+#pragma weak mutex_init\n+#pragma weak mutex_destroy\n+#endif\n+\n /* This will not actually work in Solaris 2.5, since libc contains\n    dummy symbols of all thr_* routines. */\n \n@@ -81,6 +99,289 @@ __gthread_active_p (void)\n \n #endif /* SUPPORTS_WEAK */\n \n+#ifdef _LIBOBJC\n+\n+/* Key structure for maintaining thread specific storage */\n+static thread_key_t _objc_thread_storage;\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+static inline int\n+__gthread_objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  if (__gthread_active_p ()\n+      && thr_keycreate(&_objc_thread_storage, NULL) == 0)\n+    return 0;\n+\n+  return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+static inline int\n+__gthread_objc_close_thread_system(void)\n+{\n+  if (__gthread_active_p ())\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+static inline objc_thread_t\n+__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n+{\n+  objc_thread_t thread_id;\n+  thread_t new_thread_id = 0;\n+\n+  if (!__gthread_active_p ())\n+    return NULL;\n+ \n+  if (thr_create(NULL, 0, (void *)func, arg,\n+  \t\t THR_DETACHED | THR_NEW_LWP,\n+\t\t &new_thread_id) == 0)\n+    thread_id = *(objc_thread_t *)&new_thread_id;\n+  else\n+    thread_id = NULL;\n+  \n+  return thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_set_priority(int priority)\n+{\n+  int sys_priority = 0;\n+\n+  if (!__gthread_active_p ())\n+    return -1;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = 300;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = 200;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = 1000;\n+      break;\n+    }\n+\n+  /* Change priority */\n+  if (thr_setprio(thr_self(), sys_priority) == 0)\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+static inline int\n+__gthread_objc_thread_get_priority(void)\n+{\n+  int sys_priority;\n+\n+  if (!__gthread_active_p ())\n+    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+                                                   \n+  if (thr_getprio(thr_self(), &sys_priority) == 0)\n+    {\n+      if (sys_priority >= 250)\n+\treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n+      else if (sys_priority >= 150)\n+\treturn OBJC_THREAD_BACKGROUND_PRIORITY;\n+      return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+\n+  /* Couldn't get priority. */\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+static inline void\n+__gthread_objc_thread_yield(void)\n+{\n+  if (__gthread_active_p ())\n+    thr_yield();\n+}\n+\n+/* Terminate the current thread. */\n+static inline int\n+__gthread_objc_thread_exit(void)\n+{\n+  if (__gthread_active_p ())\n+    /* exit the thread */\n+    thr_exit(&__objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+static inline objc_thread_t\n+__gthread_objc_thread_id(void)\n+{\n+  if (__gthread_active_p ())\n+    return (objc_thread_t)thr_self();\n+  else\n+    return (objc_thread_t)1;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+static inline int\n+__gthread_objc_thread_set_data(void *value)\n+{\n+  if (__gthread_active_p ())\n+    {\n+      if (thr_setspecific(_objc_thread_storage, value) == 0)\n+\treturn 0;\n+      else\n+\treturn -1;\n+    }\n+  else\n+    {\n+      thread_local_storage = value;\n+      return 0;\n+    }\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+static inline void *\n+__gthread_objc_thread_get_data(void)\n+{\n+  void *value = NULL;\n+\n+  if (__gthread_active_p ())\n+    {\n+      if (thr_getspecific(_objc_thread_storage, &value) == 0)\n+\treturn value;\n+      else\n+\treturn NULL;\n+    }\n+  else\n+    return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && mutex_init( (mutex_t *)(&(mutex->backend)), USYNC_THREAD, 0))\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+static inline int\n+__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    mutex_destroy((mutex_t *)(&(mutex->backend)));\n+\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && mutex_lock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+static inline int\n+__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && mutex_trylock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+static inline int\n+__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ()\n+      && mutex_unlock((mutex_t *)(&(mutex->backend))) != 0)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+static inline int\n+__gthread_objc_condition_allocate(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return cond_init((cond_t *)(&(condition->backend)), USYNC_THREAD,\n+    \t\t     NULL);\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a condition. */\n+static inline int\n+__gthread_objc_condition_deallocate(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return cond_destroy((cond_t *)(&(condition->backend)));\n+  else\n+    return 0;\n+}\n+\n+/* Wait on the condition */\n+static inline int\n+__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  if (__gthread_active_p ())\n+    return cond_wait((cond_t *)(&(condition->backend)),\n+    \t\t     (mutex_t *)(&(mutex->backend)));\n+  else\n+    return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_broadcast(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return cond_broadcast((cond_t *)(&(condition->backend)));\n+  else\n+    return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+static inline int\n+__gthread_objc_condition_signal(objc_condition_t condition)\n+{\n+  if (__gthread_active_p ())\n+    return cond_signal((cond_t *)(&(condition->backend)));\n+  else\n+    return 0;\n+}\n+\n+#else /* _LIBOBJC */\n+\n static inline int\n __gthread_once (__gthread_once_t *once, void (*func) (void))\n {\n@@ -174,4 +475,6 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+#endif /* _LIBOBJC */\n+\n #endif /* not __gthr_solaris_h */"}, {"sha": "c140cf85f0eb739f40014b5226e9a7ec4c79e55d", "filename": "gcc/gthr-vxworks.h", "status": "modified", "additions": 170, "deletions": 2, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-vxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-vxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-vxworks.h?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1,6 +1,6 @@\n-/* Threads compatibility routines for libgcc2 for VxWorks.  */\n+/* Threads compatibility routines for libgcc2 and libobjc for VxWorks.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@wrs.com>.\n \n This file is part of GNU CC.\n@@ -30,6 +30,172 @@ Boston, MA 02111-1307, USA.  */\n #ifndef __gthr_vxworks_h\n #define __gthr_vxworks_h\n \n+#ifdef _LIBOBJC\n+\n+/* Thread local storage for a single thread */\n+static void *thread_local_storage = NULL;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__gthread_objc_init_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__gthread_objc_close_thread_system(void)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__gthread_objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  /* No thread support available */\n+  return NULL;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__gthread_objc_thread_set_priority(int priority)\n+{\n+  /* No thread support available */\n+  return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__gthread_objc_thread_get_priority(void)\n+{\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__gthread_objc_thread_yield(void)\n+{\n+  return;\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__gthread_objc_thread_exit(void)\n+{\n+  /* No thread support available */\n+  /* Should we really exit the program */\n+  /* exit(&__objc_thread_exit_status); */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__gthread_objc_thread_id(void)\n+{\n+  /* No thread support, use 1. */\n+  return (objc_thread_t)1;\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__gthread_objc_thread_set_data(void *value)\n+{\n+  thread_local_storage = value;\n+  return 0;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__gthread_objc_thread_get_data(void)\n+{\n+  return thread_local_storage;\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  /* There can only be one thread, so we always get the lock */\n+  return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__gthread_objc_condition_allocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__gthread_objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wait on the condition */\n+int\n+__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return 0;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__gthread_objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__gthread_objc_condition_signal(objc_condition_t condition)\n+{\n+  return 0;\n+}\n+\n+#else /* _LIBOBJC */\n+\n /* POSIX threads specific definitions.\n    Easy, since the interface is just one-to-one mapping. */\n \n@@ -139,4 +305,6 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n   return semGive (*mutex);\n }\n \n+#endif /* _LIBOBJC */\n+\n #endif /* not __gthr_vxworks_h */"}, {"sha": "119cbc7d9b9933ddcc7d4985eb18be22c6dbd2cb", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 245, "deletions": 2, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1,4 +1,4 @@\n-/* Threads compatibility routines for libgcc2.  */\n+/* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n /* Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n@@ -65,7 +65,248 @@ Boston, MA 02111-1307, USA.  */\n #define __GTHREADS 1\n \n #include <windows.h>\n-#include <errno.h>\n+\n+#ifdef _LIBOBJC\n+\n+/* Key structure for maintaining thread specific storage */\n+static DWORD\t__gthread_objc_data_tls = (DWORD)-1;\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__gthread_objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  if ((__gthread_objc_data_tls = TlsAlloc()) != (DWORD)-1)\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__gthread_objc_close_thread_system(void)\n+{\n+  if (__gthread_objc_data_tls != (DWORD)-1)\n+    TlsFree(__gthread_objc_data_tls);\n+  return 0;\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__gthread_objc_thread_detach(void (*func)(void *arg), void *arg)\n+{\n+  DWORD\tthread_id = 0;\n+  HANDLE win32_handle;\n+\n+  if (!(win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n+                                   arg, 0, &thread_id)))\n+    thread_id = 0;\n+  \n+  return (objc_thread_t)thread_id;\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__gthread_objc_thread_set_priority(int priority)\n+{\n+  int sys_priority = 0;\n+\n+  switch (priority)\n+    {\n+    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_NORMAL;\n+      break;\n+    default:\n+    case OBJC_THREAD_BACKGROUND_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n+      break;\n+    case OBJC_THREAD_LOW_PRIORITY:\n+      sys_priority = THREAD_PRIORITY_LOWEST;\n+      break;\n+    }\n+\n+  /* Change priority */\n+  if (SetThreadPriority(GetCurrentThread(), sys_priority))\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__gthread_objc_thread_get_priority(void)\n+{\n+  int sys_priority;\n+\n+  sys_priority = GetThreadPriority(GetCurrentThread());\n+  \n+  switch (sys_priority)\n+    {\n+    case THREAD_PRIORITY_HIGHEST:\n+    case THREAD_PRIORITY_TIME_CRITICAL:\n+    case THREAD_PRIORITY_ABOVE_NORMAL:\n+    case THREAD_PRIORITY_NORMAL:\n+      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n+\n+    default:\n+    case THREAD_PRIORITY_BELOW_NORMAL:\n+      return OBJC_THREAD_BACKGROUND_PRIORITY;\n+    \n+    case THREAD_PRIORITY_IDLE:\n+    case THREAD_PRIORITY_LOWEST:\n+      return OBJC_THREAD_LOW_PRIORITY;\n+    }\n+\n+  /* Couldn't get priority. */\n+  return -1;\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__gthread_objc_thread_yield(void)\n+{\n+  Sleep(0);\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__gthread_objc_thread_exit(void)\n+{\n+  /* exit the thread */\n+  ExitThread(__gthread_objc_thread_exit_status);\n+\n+  /* Failed if we reached here */\n+  return -1;\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__gthread_objc_thread_id(void)\n+{\n+  return (objc_thread_t)GetCurrentThreadId();\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__gthread_objc_thread_set_data(void *value)\n+{\n+  if (TlsSetValue(__gthread_objc_data_tls, value))\n+    return 0;\n+  else\n+    return -1;\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__gthread_objc_thread_get_data(void)\n+{\n+  return TlsGetValue(__gthread_objc_data_tls);          /* Return thread data.      */\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  if ((mutex->backend = (void *)CreateMutex(NULL, 0, NULL)) == NULL)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  CloseHandle((HANDLE)(mutex->backend));\n+  return 0;\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  int status;\n+\n+  status = WaitForSingleObject((HANDLE)(mutex->backend), INFINITE);\n+  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  int status;\n+\n+  status = WaitForSingleObject((HANDLE)(mutex->backend), 0);\n+  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Unlock the mutex */\n+int\n+__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  if (ReleaseMutex((HANDLE)(mutex->backend)) == 0)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__gthread_objc_condition_allocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__gthread_objc_condition_deallocate(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wait on the condition */\n+int\n+__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__gthread_objc_condition_broadcast(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__gthread_objc_condition_signal(objc_condition_t condition)\n+{\n+  /* Unimplemented. */\n+  return -1;\n+}\n+\n+#else /* _LIBOBJC */\n+\n #ifdef __MINGW32__\n #include <_mingw.h>\n #endif\n@@ -227,5 +468,7 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n     return 0;\n }\n \n+#endif /* _LIBOBJC */\n+\n #endif /* not __gthr_win32_h */\n "}, {"sha": "d94fcd87374cfd2b6ada444ebe4908fc5dbef6ef", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1,3 +1,15 @@\n+2000-05-12  H.J. Lu  (hjl@gnu.org)\n+\n+\t* Makefile.in (GTHREAD_FLAGS): New.\n+\t(ALL_CFLAGS): Add $(GTHREAD_FLAGS).\n+\t(OBJC_THREAD_FILE): Changed to thr-objc.\n+\n+\t* configure.in (GTHREAD_FLAGS): New, check and replace it for\n+\tMakefile.\n+\t(OBJC_THREAD_FILE): Removed.\n+\n+\t* thr-objc.c: New.\n+\n 2000-07-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* objc/hash.h: Include string.h."}, {"sha": "1180d6b5786dab8ece529ac864715759cf5bf221", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -60,8 +60,9 @@ RANLIB = @RANLIB@\n \n CC = @CC@\n CFLAGS = @CFLAGS@\n+GTHREAD_FLAGS=@GTHREAD_FLAGS@\n ALL_CFLAGS = -I. -I$(srcdir) $(CPPFLAGS) $(DEFS) $(CFLAGS) \\\n-\t-DIN_GCC -DIN_TARGET_LIBS\n+\t$(GTHREAD_FLAGS) -DIN_GCC -DIN_TARGET_LIBS\n \n #\n # Define the cc1obj in terms of the CC that is passed on from higher\n@@ -76,7 +77,7 @@ INCLUDES = -I$(srcdir)/objc  -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n   -I$(srcdir)/$(MULTISRCTOP)../include\n \n OBJC_GCFLAGS=-DOBJC_WITH_GC=1\n-OBJC_THREAD_FILE=thr-@OBJC_THREAD_FILE@\n+OBJC_THREAD_FILE=thr-objc\n \n .SUFFIXES:\n .SUFFIXES: .c .m .o"}, {"sha": "9d0322d79acbc6b6b0479e22322d2d6578d69aff", "filename": "libobjc/configure", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fconfigure?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -1140,23 +1140,23 @@ EOF\n fi\n \n \n-# Determine the name of the GCC thread file.\n+# Determine gthread FLAGS.\n \n-echo $ac_n \"checking for thread file\"\"... $ac_c\" 1>&6\n-echo \"configure:1147: checking for thread file\" >&5\n-if eval \"test \\\"`echo '$''{'objc_cv_thread_file'+set}'`\\\" = set\"; then\n+echo $ac_n \"checking for gthread FLAGS\"\"... $ac_c\" 1>&6\n+echo \"configure:1147: checking for gthread FLAGS\" >&5\n+if eval \"test \\\"`echo '$''{'objc_cv_gthread_flags'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -f \"$r\"/gcc/Makefile\n then\n-  objc_cv_thread_file=`grep \\^GCC_THREAD_FILE \"$r\"/gcc/Makefile | awk -F= '{ print $2 }'`\n+  objc_cv_gthread_flags=`grep \\^GTHREAD_FLAGS \"$r\"/gcc/Makefile | awk -F= '{ print $2 }'`\n else\n   { echo \"configure: error: not found\" 1>&2; exit 1; }\n fi\n fi\n \n-echo \"$ac_t\"\"$objc_cv_thread_file\" 1>&6\n-OBJC_THREAD_FILE=$objc_cv_thread_file\n+echo \"$ac_t\"\"$objc_cv_gthread_flags\" 1>&6\n+GTHREAD_FLAGS=$objc_cv_gthread_flags\n \n \n # Check whether --enable-objc-gc or --disable-objc-gc was given.\n@@ -1327,7 +1327,7 @@ s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g\n s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g\n s%@INSTALL_DATA@%$INSTALL_DATA%g\n s%@CPP@%$CPP%g\n-s%@OBJC_THREAD_FILE@%$OBJC_THREAD_FILE%g\n+s%@GTHREAD_FLAGS@%$GTHREAD_FLAGS%g\n s%@OBJC_BOEHM_GC@%$OBJC_BOEHM_GC%g\n \n CEOF"}, {"sha": "b2d656a27730f130acd800898f3aeb311ba075a4", "filename": "libobjc/configure.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fconfigure.in?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -91,17 +91,17 @@ the Objective C runtime system.  If necessary, install gcc now with\n \n AC_HEADER_STDC\n \n-# Determine the name of the GCC thread file.\n+# Determine CFLAGS for gthread.\n \n-AC_CACHE_CHECK([for thread file],objc_cv_thread_file,\n+AC_CACHE_CHECK([for gthread cflags],objc_cv_gthread_flags,\n [if test -f \"$r\"/gcc/Makefile\n then\n-  objc_cv_thread_file=`grep \\^GCC_THREAD_FILE \"$r\"/gcc/Makefile | awk -F= '{ print $2 }'`\n+  objc_cv_gthread_flags=`grep \\^GTHREAD_FLAGS \"$r\"/gcc/Makefile | awk -F= '{ print $2 }'`\n else\n   AC_MSG_ERROR([not found])\n fi])\n-OBJC_THREAD_FILE=$objc_cv_thread_file\n-AC_SUBST(OBJC_THREAD_FILE)\n+GTHREAD_FLAGS=$objc_cv_gthread_flags\n+AC_SUBST(GTHREAD_FLAGS)\n \n AC_ARG_ENABLE(objc-gc,\n [  --enable-objc-gc       enable the use of Boehm's garbage collector with"}, {"sha": "48150f0ef3e4dc6b111df76bb73a96f2aa574194", "filename": "libobjc/thr-objc.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2Fthr-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15794a956736ea9e48c66498cb7c5507300188be/libobjc%2Fthr-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-objc.c?ref=15794a956736ea9e48c66498cb7c5507300188be", "patch": "@@ -0,0 +1,181 @@\n+/* GNU Objective C Runtime Thread Interface.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#define _LIBOBJC\n+#include \"tconfig.h\"\n+#include \"defaults.h\"\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+#include <gthr.h>\n+\n+/* Backend initialization functions */\n+\n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  return __gthread_objc_init_thread_system ();\n+}\n+\n+/* Close the threads subsystem. */\n+int\n+__objc_close_thread_system(void)\n+{\n+  return __gthread_objc_close_thread_system ();\n+}\n+\n+/* Backend thread functions */\n+\n+/* Create a new thread of execution. */\n+objc_thread_t\n+__objc_thread_detach(void (*func)(void *), void *arg)\n+{\n+  return __gthread_objc_thread_detach (func, arg);\n+}\n+\n+/* Set the current thread's priority. */\n+int\n+__objc_thread_set_priority(int priority)\n+{\n+  return __gthread_objc_thread_set_priority (priority);\n+}\n+\n+/* Return the current thread's priority. */\n+int\n+__objc_thread_get_priority(void)\n+{\n+  return __gthread_objc_thread_get_priority ();\n+}\n+\n+/* Yield our process time to another thread. */\n+void\n+__objc_thread_yield(void)\n+{\n+  __gthread_objc_thread_yield ();\n+}\n+\n+/* Terminate the current thread. */\n+int\n+__objc_thread_exit(void)\n+{\n+  return __gthread_objc_thread_exit ();\n+}\n+\n+/* Returns an integer value which uniquely describes a thread. */\n+objc_thread_t\n+__objc_thread_id(void)\n+{\n+  return __gthread_objc_thread_id ();\n+}\n+\n+/* Sets the thread's local storage pointer. */\n+int\n+__objc_thread_set_data(void *value)\n+{\n+  return __gthread_objc_thread_set_data (value);\n+}\n+\n+/* Returns the thread's local storage pointer. */\n+void *\n+__objc_thread_get_data(void)\n+{\n+  return __gthread_objc_thread_get_data ();\n+}\n+\n+/* Backend mutex functions */\n+\n+/* Allocate a mutex. */\n+int\n+__objc_mutex_allocate(objc_mutex_t mutex)\n+{\n+  return __gthread_objc_mutex_allocate (mutex);\n+}\n+\n+/* Deallocate a mutex. */\n+int\n+__objc_mutex_deallocate(objc_mutex_t mutex)\n+{\n+  return __gthread_objc_mutex_deallocate (mutex);\n+}\n+\n+/* Grab a lock on a mutex. */\n+int\n+__objc_mutex_lock(objc_mutex_t mutex)\n+{\n+  return __gthread_objc_mutex_lock (mutex);\n+}\n+\n+/* Try to grab a lock on a mutex. */\n+int\n+__objc_mutex_trylock(objc_mutex_t mutex)\n+{\n+  return __gthread_objc_mutex_trylock (mutex);\n+}\n+\n+/* Unlock the mutex */\n+int\n+__objc_mutex_unlock(objc_mutex_t mutex)\n+{\n+  return __gthread_objc_mutex_unlock (mutex);\n+}\n+\n+/* Backend condition mutex functions */\n+\n+/* Allocate a condition. */\n+int\n+__objc_condition_allocate(objc_condition_t condition)\n+{\n+  return __gthread_objc_condition_allocate (condition);\n+}\n+\n+/* Deallocate a condition. */\n+int\n+__objc_condition_deallocate(objc_condition_t condition)\n+{\n+  return __gthread_objc_condition_deallocate (condition);\n+}\n+\n+/* Wait on the condition */\n+int\n+__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+{\n+  return __gthread_objc_condition_wait (condition, mutex);\n+}\n+\n+/* Wake up all threads waiting on this condition. */\n+int\n+__objc_condition_broadcast(objc_condition_t condition)\n+{\n+  return __gthread_objc_condition_broadcast (condition);\n+}\n+\n+/* Wake up one thread waiting on this condition. */\n+int\n+__objc_condition_signal(objc_condition_t condition)\n+{\n+  return __gthread_objc_condition_signal (condition);\n+}\n+\n+/* End of File */"}]}