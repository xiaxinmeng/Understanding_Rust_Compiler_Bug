{"sha": "6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ1YzM3ZDAwNDFmN2RjMzY5OTYyM2FjN2ZjN2VhZjY4YWZiYWI0Yg==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2016-10-26T17:07:55Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2016-10-26T17:07:55Z"}, "message": "haifa-sched.c (call_used_regs_num): Rename to...\n\n\t* haifa-sched.c (call_used_regs_num): Rename to...\n\t(call_saved_regs_num): ...this.\n\t(fixed_regs_num): New variable.\n\t(sched_pressure_start_bb): Subtract out fixed_regs. Scale call_saved \n\tregs not call_used.\n\t(alloc_global_sched_pressure_data): Compute call_saved and fixed regs.\n\nFrom-SVN: r241590", "tree": {"sha": "7734eb0522b2f7df32754f0a65529b439dc60da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7734eb0522b2f7df32754f0a65529b439dc60da7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b/comments", "author": null, "committer": null, "parents": [{"sha": "eaa402fcc706116a06d474e7f148e787d3c78ae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa402fcc706116a06d474e7f148e787d3c78ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa402fcc706116a06d474e7f148e787d3c78ae0"}], "stats": {"total": 40, "additions": 28, "deletions": 12}, "files": [{"sha": "c50d8f44abe067932d2e2f9babc7f6efa4e29b80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b", "patch": "@@ -1,3 +1,12 @@\n+2016-10-26  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* haifa-sched.c (call_used_regs_num): Rename to...\n+\t(call_saved_regs_num): ...this.\n+\t(fixed_regs_num): New variable.\n+\t(sched_pressure_start_bb): Subtract out fixed_regs. Scale call_saved\n+\tregs not call_used.\n+\t(alloc_global_sched_pressure_data): Compute call_saved and fixed regs.\n+\n 2016-10-26  David Malcolm  <dmalcolm@redhat.com>\n \n \t* print-rtl-function.c (print_rtx_function): Rewrite in terms of"}, {"sha": "580a795d5d4d946afc3386a92679d9f46dd04c70", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6d5c37d0041f7dc3699623ac7fc7eaf68afbab4b", "patch": "@@ -933,9 +933,10 @@ static bitmap region_ref_regs;\n /* Effective number of available registers of a given class (see comment\n    in sched_pressure_start_bb).  */\n static int sched_class_regs_num[N_REG_CLASSES];\n-/* Number of call_used_regs.  This is a helper for calculating of\n+/* Number of call_saved_regs and fixed_regs.  Helpers for calculating of\n    sched_class_regs_num.  */\n-static int call_used_regs_num[N_REG_CLASSES];\n+static int call_saved_regs_num[N_REG_CLASSES];\n+static int fixed_regs_num[N_REG_CLASSES];\n \n /* Initiate register pressure relative info for scheduling the current\n    region.  Currently it is only clearing register mentioned in the\n@@ -3897,17 +3898,19 @@ sched_pressure_start_bb (basic_block bb)\n      * If the basic block executes much more often than the prologue/epilogue\n      (e.g., inside a hot loop), then cost of spill in the prologue is close to\n      nil, so the effective number of available registers is\n-     (ira_class_hard_regs_num[cl] - 0).\n+     (ira_class_hard_regs_num[cl] - fixed_regs_num[cl] - 0).\n      * If the basic block executes as often as the prologue/epilogue,\n      then spill in the block is as costly as in the prologue, so the effective\n      number of available registers is\n-     (ira_class_hard_regs_num[cl] - call_used_regs_num[cl]).\n+     (ira_class_hard_regs_num[cl] - fixed_regs_num[cl]\n+      - call_saved_regs_num[cl]).\n      Note that all-else-equal, we prefer to spill in the prologue, since that\n      allows \"extra\" registers for other basic blocks of the function.\n      * If the basic block is on the cold path of the function and executes\n      rarely, then we should always prefer to spill in the block, rather than\n      in the prologue/epilogue.  The effective number of available register is\n-     (ira_class_hard_regs_num[cl] - call_used_regs_num[cl]).  */\n+     (ira_class_hard_regs_num[cl] - fixed_regs_num[cl]\n+      - call_saved_regs_num[cl]).  */\n   {\n     int i;\n     int entry_freq = ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency;\n@@ -3924,9 +3927,10 @@ sched_pressure_start_bb (basic_block bb)\n     for (i = 0; i < ira_pressure_classes_num; ++i)\n       {\n \tenum reg_class cl = ira_pressure_classes[i];\n-\tsched_class_regs_num[cl] = ira_class_hard_regs_num[cl];\n+\tsched_class_regs_num[cl] = ira_class_hard_regs_num[cl]\n+\t\t\t\t   - fixed_regs_num[cl];\n \tsched_class_regs_num[cl]\n-\t  -= (call_used_regs_num[cl] * entry_freq) / bb_freq;\n+\t  -= (call_saved_regs_num[cl] * entry_freq) / bb_freq;\n       }\n   }\n \n@@ -7238,17 +7242,20 @@ alloc_global_sched_pressure_data (void)\n \t  region_ref_regs = BITMAP_ALLOC (NULL);\n \t}\n \n-      /* Calculate number of CALL_USED_REGS in register classes that\n-\t we calculate register pressure for.  */\n+      /* Calculate number of CALL_SAVED_REGS and FIXED_REGS in register classes\n+\t that we calculate register pressure for.  */\n       for (int c = 0; c < ira_pressure_classes_num; ++c)\n \t{\n \t  enum reg_class cl = ira_pressure_classes[c];\n \n-\t  call_used_regs_num[cl] = 0;\n+\t  call_saved_regs_num[cl] = 0;\n+\t  fixed_regs_num[cl] = 0;\n \n \t  for (int i = 0; i < ira_class_hard_regs_num[cl]; ++i)\n-\t    if (call_used_regs[ira_class_hard_regs[cl][i]])\n-\t      ++call_used_regs_num[cl];\n+\t    if (!call_used_regs[ira_class_hard_regs[cl][i]])\n+\t      ++call_saved_regs_num[cl];\n+\t    else if (fixed_regs[ira_class_hard_regs[cl][i]])\n+\t      ++fixed_regs_num[cl];\n \t}\n     }\n }"}]}