{"sha": "8a9b94d8c3ac6c691fa49585756c0df234602d8b", "node_id": "C_kwDOANBUbNoAKDhhOWI5NGQ4YzNhYzZjNjkxZmE0OTU4NTc1NmMwZGYyMzQ2MDJkOGI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-07-20T12:40:18Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:24Z"}, "message": "Port over:\n\n - cxx_bind_parameters_in_call\n - addr_of_non_const_var\n - adjust_temp_type\n\nThere is alot of cleanup we can do when we get more of this working but\nfor now its best to keep porting like this.", "tree": {"sha": "2af8f4b7b0dcf806a580a8ec580df62f59bceffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2af8f4b7b0dcf806a580a8ec580df62f59bceffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a9b94d8c3ac6c691fa49585756c0df234602d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9b94d8c3ac6c691fa49585756c0df234602d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9b94d8c3ac6c691fa49585756c0df234602d8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9b94d8c3ac6c691fa49585756c0df234602d8b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44b80bf0240aefb56d9abcce59c15a24a22048f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b80bf0240aefb56d9abcce59c15a24a22048f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44b80bf0240aefb56d9abcce59c15a24a22048f4"}], "stats": {"total": 134, "additions": 134, "deletions": 0}, "files": [{"sha": "aa2d4708a9bfc67f070aa74494bb9b857a9125a1", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a9b94d8c3ac6c691fa49585756c0df234602d8b/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a9b94d8c3ac6c691fa49585756c0df234602d8b/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=8a9b94d8c3ac6c691fa49585756c0df234602d8b", "patch": "@@ -47,6 +47,8 @@ static HOST_WIDE_INT\n find_array_ctor_elt (tree ary, tree dindex, bool insert = false);\n static int\n array_index_cmp (tree key, tree index);\n+inline tree\n+get_nth_callarg (tree t, int n);\n \n struct constexpr_global_ctx\n {\n@@ -388,6 +390,138 @@ eval_binary_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   return fold_binary_loc (loc, code, type, lhs, rhs);\n }\n \n+/* TEMP is the constant value of a temporary object of type TYPE.  Adjust\n+   the type of the value to match.  */\n+\n+static tree\n+adjust_temp_type (tree type, tree temp)\n+{\n+  if (same_type_p (TREE_TYPE (temp), type))\n+    return temp;\n+\n+  gcc_assert (scalarish_type_p (type));\n+  /* Now we know we're dealing with a scalar, and a prvalue of non-class\n+     type is cv-unqualified.  */\n+  return fold_convert (cv_unqualified (type), temp);\n+}\n+\n+/* Helper function of cxx_bind_parameters_in_call.  Return non-NULL\n+   if *TP is address of a static variable (or part of it) currently being\n+   constructed or of a heap artificial variable.  */\n+\n+static tree\n+addr_of_non_const_var (tree *tp, int *walk_subtrees, void *data)\n+{\n+  if (TREE_CODE (*tp) == ADDR_EXPR)\n+    if (tree var = get_base_address (TREE_OPERAND (*tp, 0)))\n+      if (VAR_P (var) && TREE_STATIC (var))\n+\t{\n+\t  if (DECL_NAME (var) == heap_uninit_identifier\n+\t      || DECL_NAME (var) == heap_identifier\n+\t      || DECL_NAME (var) == heap_vec_uninit_identifier\n+\t      || DECL_NAME (var) == heap_vec_identifier)\n+\t    return var;\n+\n+\t  constexpr_global_ctx *global = (constexpr_global_ctx *) data;\n+\t  if (global->values.get (var))\n+\t    return var;\n+\t}\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = false;\n+  return NULL_TREE;\n+}\n+\n+/* Subroutine of cxx_eval_call_expression.\n+   We are processing a call expression (either CALL_EXPR or\n+   AGGR_INIT_EXPR) in the context of CTX.  Evaluate\n+   all arguments and bind their values to correspondings\n+   parameters, making up the NEW_CALL context.  */\n+\n+static tree\n+rs_bind_parameters_in_call (const constexpr_ctx *ctx, tree t, tree fun,\n+\t\t\t    bool *non_constant_p, bool *overflow_p,\n+\t\t\t    bool *non_constant_args)\n+{\n+  const int nargs = call_expr_nargs (t);\n+  tree parms = DECL_ARGUMENTS (fun);\n+  int i;\n+  /* We don't record ellipsis args below.  */\n+  int nparms = list_length (parms);\n+  int nbinds = nargs < nparms ? nargs : nparms;\n+  tree binds = make_tree_vec (nbinds);\n+  for (i = 0; i < nargs; ++i)\n+    {\n+      tree x, arg;\n+      tree type = parms ? TREE_TYPE (parms) : void_type_node;\n+      if (parms && DECL_BY_REFERENCE (parms))\n+\ttype = TREE_TYPE (type);\n+      x = get_nth_callarg (t, i);\n+\n+      if (TREE_ADDRESSABLE (type))\n+\t/* Undo convert_for_arg_passing work here.  */\n+\tx = convert_from_reference (x);\n+      /* Normally we would strip a TARGET_EXPR in an initialization context\n+\t such as this, but here we do the elision differently: we keep the\n+\t TARGET_EXPR, and use its CONSTRUCTOR as the value of the parm.  */\n+      arg = constexpr_expression (ctx, x, /*lval=*/false, non_constant_p,\n+\t\t\t\t  overflow_p);\n+      /* Don't VERIFY_CONSTANT here.  */\n+      if (*non_constant_p && ctx->quiet)\n+\tbreak;\n+      /* Just discard ellipsis args after checking their constantitude.  */\n+      if (!parms)\n+\tcontinue;\n+\n+      if (!*non_constant_p)\n+\t{\n+\t  /* Make sure the binding has the same type as the parm.  But\n+\t     only for constant args.  */\n+\t  if (!TYPE_REF_P (type))\n+\t    arg = adjust_temp_type (type, arg);\n+\t  if (!TREE_CONSTANT (arg))\n+\t    *non_constant_args = true;\n+\t  else if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+\t    /* The destructor needs to see any modifications the callee makes\n+\t       to the argument.  */\n+\t    *non_constant_args = true;\n+\t  /* If arg is or contains address of a heap artificial variable or\n+\t     of a static variable being constructed, avoid caching the\n+\t     function call, as those variables might be modified by the\n+\t     function, or might be modified by the callers in between\n+\t     the cached function and just read by the function.  */\n+\t  else if (!*non_constant_args\n+\t\t   && rs_walk_tree (&arg, addr_of_non_const_var, ctx->global,\n+\t\t\t\t    NULL))\n+\t    *non_constant_args = true;\n+\n+\t  // /* For virtual calls, adjust the this argument, so that it is\n+\t  //    the object on which the method is called, rather than\n+\t  //    one of its bases.  */\n+\t  // if (i == 0 && DECL_VIRTUAL_P (fun))\n+\t  //   {\n+\t  //     tree addr = arg;\n+\t  //     STRIP_NOPS (addr);\n+\t  //     if (TREE_CODE (addr) == ADDR_EXPR)\n+\t  //       {\n+\t  //         tree obj = TREE_OPERAND (addr, 0);\n+\t  //         while (TREE_CODE (obj) == COMPONENT_REF\n+\t  //       \t && DECL_FIELD_IS_BASE (TREE_OPERAND (obj, 1))\n+\t  //       \t && !same_type_ignoring_top_level_qualifiers_p (\n+\t  //       \t   TREE_TYPE (obj), DECL_CONTEXT (fun)))\n+\t  //           obj = TREE_OPERAND (obj, 0);\n+\t  //         if (obj != TREE_OPERAND (addr, 0))\n+\t  //           arg = build_fold_addr_expr_with_type (obj, TREE_TYPE\n+\t  //           (arg));\n+\t  //       }\n+\t  //   }\n+\t  TREE_VEC_ELT (binds, i) = arg;\n+\t}\n+      parms = TREE_CHAIN (parms);\n+    }\n+\n+  return binds;\n+}\n+\n // Subroutine of cxx_eval_constant_expression.\n // Evaluate the call expression tree T in the context of OLD_CALL expression\n // evaluation."}]}