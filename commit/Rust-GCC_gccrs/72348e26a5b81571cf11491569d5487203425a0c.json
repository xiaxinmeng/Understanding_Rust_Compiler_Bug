{"sha": "72348e26a5b81571cf11491569d5487203425a0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIzNDhlMjZhNWI4MTU3MWNmMTE0OTE1NjlkNTQ4NzIwMzQyNWEwYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-10T10:35:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-10T10:35:38Z"}, "message": "[multiple changes]\n\n2012-01-10  Bob Duff  <duff@adacore.com>\n\n\t* sem_intr.adb (Check_Shift): Use RM_Size instead of Esize, when\n\tchecking that the 'Size is correct. If the type is \"mod 2**12\",\n\tfor example, it's illegal, but Esize is the 'Object_Size, which\n\twill be something like 16 or 32, so the error ('Size = 12) was\n\tnot detected.\n\t* gnat_rm.texi: Improve documentation of shift\n\tand rotate intrinsics.\n\n2012-01-10  Pascal Obry  <obry@adacore.com>\n\n\t* prj.adb (For_Every_Project_Imported): Fix\n\timplementation to make sure we return each project only once\n\tfor aggragte libraries. It is fine to return a project twice for\n\taggregate projects, this was the case as a Project_Id is different\n\tin each project tree. The new implementation use a table based on\n\tthe project name to ensure proper detection of duplicate project\n\tin aggregate library. A new context is then created to continue\n\tretrurning duplicate project for aggregate libraries.\n\nFrom-SVN: r183059", "tree": {"sha": "b77b2038989d2dc9139ce86712170793b691c18d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b77b2038989d2dc9139ce86712170793b691c18d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72348e26a5b81571cf11491569d5487203425a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72348e26a5b81571cf11491569d5487203425a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72348e26a5b81571cf11491569d5487203425a0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72348e26a5b81571cf11491569d5487203425a0c/comments", "author": null, "committer": null, "parents": [{"sha": "cba300dd7dfadf5069d9943c6a54c65a34614d20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba300dd7dfadf5069d9943c6a54c65a34614d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba300dd7dfadf5069d9943c6a54c65a34614d20"}], "stats": {"total": 260, "additions": 140, "deletions": 120}, "files": [{"sha": "89a8830b4a597404dfbdcb82ea511db07028813e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=72348e26a5b81571cf11491569d5487203425a0c", "patch": "@@ -1,3 +1,24 @@\n+2012-01-10  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_intr.adb (Check_Shift): Use RM_Size instead of Esize, when\n+\tchecking that the 'Size is correct. If the type is \"mod 2**12\",\n+\tfor example, it's illegal, but Esize is the 'Object_Size, which\n+\twill be something like 16 or 32, so the error ('Size = 12) was\n+\tnot detected.\n+\t* gnat_rm.texi: Improve documentation of shift\n+\tand rotate intrinsics.\n+\n+2012-01-10  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj.adb (For_Every_Project_Imported): Fix\n+\timplementation to make sure we return each project only once\n+\tfor aggragte libraries. It is fine to return a project twice for\n+\taggregate projects, this was the case as a Project_Id is different\n+\tin each project tree. The new implementation use a table based on\n+\tthe project name to ensure proper detection of duplicate project\n+\tin aggregate library. A new context is then created to continue\n+\tretrurning duplicate project for aggregate libraries.\n+\n 2012-01-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (call_to_gnu): Create the temporary for the"}, {"sha": "fb2be33d96a35861444c5799a1fb4fa627c9213f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 20, "deletions": 50, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=72348e26a5b81571cf11491569d5487203425a0c", "patch": "@@ -10385,11 +10385,7 @@ There are no restrictions on pragma @code{Restrictions}.\n * Exception_Name::\n * File::\n * Line::\n-* Rotate_Left::\n-* Rotate_Right::\n-* Shift_Left::\n-* Shift_Right::\n-* Shift_Right_Arithmetic::\n+* Shifts and Rotates::\n * Source_Location::\n @end menu\n \n@@ -10506,61 +10502,35 @@ application program should simply call the function\n @code{GNAT.Source_Info.Line} to obtain the number of the current\n source line.\n \n-@node Rotate_Left\n-@section Rotate_Left\n+@node Shifts and Rotates\n+@section Shifts and Rotates\n+@cindex Shift_Left\n+@cindex Shift_Right\n+@cindex Shift_Right_Arithmetic\n @cindex Rotate_Left\n+@cindex Rotate_Right\n @noindent\n-In standard Ada, the @code{Rotate_Left} function is available only\n+In standard Ada, the shift and rotate functions are available only\n for the predefined modular types in package @code{Interfaces}.  However, in\n-GNAT it is possible to define a Rotate_Left function for a user\n-defined modular type or any signed integer type as in this example:\n+GNAT it is possible to define these functions for any integer\n+type (signed or modular), as in this example:\n \n @smallexample @c ada\n    function Shift_Left\n-     (Value  : My_Modular_Type;\n+     (Value  : T;\n       Amount : Natural)\n-      return   My_Modular_Type;\n+      return   T;\n @end smallexample\n \n @noindent\n-The requirements are that the profile be exactly as in the example\n-above.  The only modifications allowed are in the formal parameter\n-names, and in the type of @code{Value} and the return type, which\n-must be the same, and must be either a signed integer type, or\n-a modular integer type with a binary modulus, and the size must\n-be 8.  16, 32 or 64 bits.\n-\n-@node Rotate_Right\n-@section Rotate_Right\n-@cindex Rotate_Right\n-@noindent\n-A @code{Rotate_Right} function can be defined for any user defined\n-binary modular integer type, or signed integer type, as described\n-above for @code{Rotate_Left}.\n-\n-@node Shift_Left\n-@section Shift_Left\n-@cindex Shift_Left\n-@noindent\n-A @code{Shift_Left} function can be defined for any user defined\n-binary modular integer type, or signed integer type, as described\n-above for @code{Rotate_Left}.\n-\n-@node Shift_Right\n-@section Shift_Right\n-@cindex Shift_Right\n-@noindent\n-A @code{Shift_Right} function can be defined for any user defined\n-binary modular integer type, or signed integer type, as described\n-above for @code{Rotate_Left}.\n-\n-@node Shift_Right_Arithmetic\n-@section Shift_Right_Arithmetic\n-@cindex Shift_Right_Arithmetic\n-@noindent\n-A @code{Shift_Right_Arithmetic} function can be defined for any user\n-defined binary modular integer type, or signed integer type, as described\n-above for @code{Rotate_Left}.\n+The function name must be one of\n+Shift_Left, Shift_Right, Shift_Right_Arithmetic, Rotate_Left, or\n+Rotate_Right. T must be an integer type. T'Size must be\n+8, 16, 32 or 64 bits; if T is modular, the modulus\n+must be 2**8, 2**16, 2**32 or 2**64.\n+The result type must be the same as the type of @code{Value}.\n+The shift amount must be Natural.\n+The formal parameter names can be anything.\n \n @node Source_Location\n @section Source_Location"}, {"sha": "32fa2a13c5b8c1b0632101dd415b3cd0587282a7", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 91, "deletions": 63, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=72348e26a5b81571cf11491569d5487203425a0c", "patch": "@@ -34,6 +34,7 @@ with Snames;   use Snames;\n with Uintp;    use Uintp;\n \n with Ada.Characters.Handling;    use Ada.Characters.Handling;\n+with Ada.Containers.Ordered_Sets;\n with Ada.Unchecked_Deallocation;\n \n with GNAT.Case_Util;            use GNAT.Case_Util;\n@@ -523,101 +524,128 @@ package body Prj is\n       Include_Aggregated : Boolean := True;\n       Imported_First     : Boolean := False)\n    is\n-\n       use Project_Boolean_Htable;\n-      Seen : Project_Boolean_Htable.Instance := Project_Boolean_Htable.Nil;\n \n-      procedure Recursive_Check\n+      procedure Recursive_Check_Context\n         (Project          : Project_Id;\n          Tree             : Project_Tree_Ref;\n          In_Aggregate_Lib : Boolean);\n-      --  Check if a project has already been seen. If not seen, mark it\n-      --  as Seen, Call Action, and check all its imported and aggregated\n-      --  projects.\n+      --  Recursively handle the project tree creating a new context for\n+      --  keeping track about already handled projects.\n \n-      ---------------------\n-      -- Recursive_Check --\n-      ---------------------\n+      -----------------------------\n+      -- Recursive_Check_Context --\n+      -----------------------------\n \n-      procedure Recursive_Check\n+      procedure Recursive_Check_Context\n         (Project          : Project_Id;\n          Tree             : Project_Tree_Ref;\n          In_Aggregate_Lib : Boolean)\n       is\n-         List : Project_List;\n-         T    : Project_Tree_Ref;\n+         package Name_Id_Set is\n+           new Ada.Containers.Ordered_Sets (Element_Type => Name_Id);\n \n-      begin\n-         if not Get (Seen, Project) then\n+         Seen_Name : Name_Id_Set.Set;\n+         --  This set is needed to ensure that we do not haandle the same\n+         --  project twice in the context of aggregate libraries.\n \n-            --  Even if a project is aggregated multiple times, we will only\n-            --  return it once.\n+         procedure Recursive_Check\n+           (Project          : Project_Id;\n+            Tree             : Project_Tree_Ref;\n+            In_Aggregate_Lib : Boolean);\n+         --  Check if project has already been seen. If not, mark it as Seen,\n+         --  Call Action, and check all its imported and aggregated projects.\n \n-            Set (Seen, Project, True);\n+         ---------------------\n+         -- Recursive_Check --\n+         ---------------------\n \n-            if not Imported_First then\n-               Action (Project, Tree, In_Aggregate_Lib, With_State);\n-            end if;\n+         procedure Recursive_Check\n+           (Project          : Project_Id;\n+            Tree             : Project_Tree_Ref;\n+            In_Aggregate_Lib : Boolean)\n+         is\n+            List : Project_List;\n+            T    : Project_Tree_Ref;\n+\n+         begin\n+            if not Seen_Name.Contains (Project.Name) then\n \n-            --  Visit all extended projects\n+               --  Even if a project is aggregated multiple times in an\n+               --  aggregated library, we will only return it once.\n \n-            if Project.Extends /= No_Project then\n-               Recursive_Check (Project.Extends, Tree, In_Aggregate_Lib);\n-            end if;\n+               Seen_Name.Include (Project.Name);\n \n-            --  Visit all imported projects if needed. This is not needed\n-            --  for an aggregate library as imported libraries are just\n-            --  there for dependency support.\n+               if not Imported_First then\n+                  Action (Project, Tree, In_Aggregate_Lib, With_State);\n+               end if;\n+\n+               --  Visit all extended projects\n+\n+               if Project.Extends /= No_Project then\n+                  Recursive_Check (Project.Extends, Tree, In_Aggregate_Lib);\n+               end if;\n+\n+               --  Visit all imported projects\n \n-            if Project.Qualifier /= Aggregate_Library\n-              or else not Include_Aggregated\n-            then\n                List := Project.Imported_Projects;\n                while List /= null loop\n                   Recursive_Check (List.Project, Tree, In_Aggregate_Lib);\n                   List := List.Next;\n                end loop;\n-            end if;\n \n-            --  Visit all aggregated projects\n+               --  Visit all aggregated projects\n \n-            if Include_Aggregated\n-              and then Project.Qualifier in Aggregate_Project\n-            then\n-               declare\n-                  Agg : Aggregated_Project_List;\n-               begin\n-                  Agg := Project.Aggregated_Projects;\n-                  while Agg /= null loop\n-                     pragma Assert (Agg.Project /= No_Project);\n-\n-                     --  For aggregated libraries, the tree must be the one\n-                     --  of the aggregate library.\n-\n-                     if Project.Qualifier = Aggregate_Library then\n-                        T := Tree;\n-                     else\n-                        T := Agg.Tree;\n-                     end if;\n-\n-                     Recursive_Check\n-                       (Agg.Project, T, Project.Qualifier = Aggregate_Library);\n-                     Agg := Agg.Next;\n-                  end loop;\n-               end;\n-            end if;\n+               if Include_Aggregated\n+                 and then Project.Qualifier in Aggregate_Project\n+               then\n+                  declare\n+                     Agg : Aggregated_Project_List;\n+\n+                  begin\n+                     Agg := Project.Aggregated_Projects;\n+                     while Agg /= null loop\n+                        pragma Assert (Agg.Project /= No_Project);\n+\n+                        --  For aggregated libraries, the tree must be the one\n+                        --  of the aggregate library.\n+\n+                        if Project.Qualifier = Aggregate_Library then\n+                           T := Tree;\n+                           Recursive_Check (Agg.Project, T, True);\n+\n+                        else\n+                           T := Agg.Tree;\n+\n+                           --  Use a new context as we want to returns the same\n+                           --  project in different project tree for aggregated\n+                           --  projects.\n \n-            if Imported_First then\n-               Action (Project, Tree, In_Aggregate_Lib, With_State);\n+                           Recursive_Check_Context (Agg.Project, T, False);\n+                        end if;\n+\n+                        Agg := Agg.Next;\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               if Imported_First then\n+                  Action (Project, Tree, In_Aggregate_Lib, With_State);\n+               end if;\n             end if;\n-         end if;\n-      end Recursive_Check;\n+         end Recursive_Check;\n+\n+      --  Start of processing for Recursive_Check_Context\n+\n+      begin\n+         Recursive_Check (Project, Tree, In_Aggregate_Lib);\n+      end Recursive_Check_Context;\n \n    --  Start of processing for For_Every_Project_Imported\n \n    begin\n-      Recursive_Check (Project => By, Tree => Tree, In_Aggregate_Lib => False);\n-      Reset (Seen);\n+      Recursive_Check_Context\n+        (Project => By, Tree => Tree, In_Aggregate_Lib => False);\n    end For_Every_Project_Imported;\n \n    -----------------"}, {"sha": "f650be9c5790088334ee83b57a9ed3259331766e", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72348e26a5b81571cf11491569d5487203425a0c/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=72348e26a5b81571cf11491569d5487203425a0c", "patch": "@@ -455,12 +455,14 @@ package body Sem_Intr is\n          return;\n       end if;\n \n-      Size := UI_To_Int (Esize (Typ1));\n+      --  type'Size (not 'Object_Size!) must be one of the allowed values\n \n-      if Size /= 8\n-        and then Size /= 16\n-        and then Size /= 32\n-        and then Size /= 64\n+      Size := UI_To_Int (RM_Size (Typ1));\n+\n+      if Size /= 8  and then\n+         Size /= 16 and then\n+         Size /= 32 and then\n+         Size /= 64\n       then\n          Errint\n            (\"first argument for shift must have size 8, 16, 32 or 64\",\n@@ -469,8 +471,7 @@ package body Sem_Intr is\n \n       elsif Non_Binary_Modulus (Typ1) then\n          Errint\n-           (\"shifts not allowed for non-binary modular types\",\n-            Ptyp1, N);\n+           (\"shifts not allowed for non-binary modular types\", Ptyp1, N);\n \n       elsif Etype (Arg1) /= Etype (E) then\n          Errint"}]}