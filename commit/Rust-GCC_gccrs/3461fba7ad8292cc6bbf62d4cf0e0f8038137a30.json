{"sha": "3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ2MWZiYTdhZDgyOTJjYzZiYmY2MmQ0Y2YwZTBmODAzODEzN2EzMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-07-21T00:03:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-07-21T00:03:21Z"}, "message": "Remove old-abi remnants.\n\n\tRemove old-abi remnants. Remove comments about old abi\n\tbehaviour. Remove refences to 'new-abi' in comments.\n\t* cp-tree.h: Adjust comments.\n\t(vbase_offsets_in_vtable_p): Delete.\n\t(vcall_offsets_in_vtable_p): Delete.\n\t(vptrs_present_everywhere_p): Delete.\n\t(all_overridden_vfuns_in_vtables_p): Delete.\n\t(merge_primary_and_secondary_vtables_p): Delete.\n\t(TYPE_CONTAINS_VPTR_P): Adjust.\n\t(VTT_NAME_PREFIX): Remove.\n\t(CTOR_VTBL_NAME_PREFIX): Remove.\n\t(init_vbase_pointers): Remove.\n\t* class.c: Adjust coments.\n\t(build_vbase_pointer_fields): Delete.\n\t(build_vbase_pointer): Remove old-abi code.\n\t(build_secondary_vtable): Likewise.\n\t(modify_all_vtables): Likewise.\n\t(create_vtable_ptr): Likewise.\n\t(layout_class_type): Likewise.\n\t(finish_struct_1): Likewise.\n\t(finish_vtbls): Likewise.\n\t(dfs_finish_vtbls): Delete.\n\t(build_vbase_offset_vtbl_entries): Remove old-abi code.\n\t* cvt.c: Adjust comments.\n\t* decl.c: Adjust comments.\n\t* decl2.c: Adjust comments.\n\t* init.c: Adjust comments.\n\t(construct_virtual_bases): Remove old-abi code.\n\t* lang-specs.h: Remove -fno-new-abi.\n\t* mangle.c: Adjust comments.\n\t* rtti.c: Adjust comments.\n\t(get_base_offset): Remove old-abi-code.\n\t* search.c: Adjust comments.\n\t(dfs_init_vbase_pointers): Remove.\n\t(dfs_vtable_path_unmark): Remove.\n\t(init_vbase_pointers): Remove.\n\t* semantics.c: Adjust comments.\n\t(emit_associated_thunks): Remove old-abi code.\n\t* typeck.c: Adjust comments.\n\nFrom-SVN: r44215", "tree": {"sha": "fcf4022c73cb6f01329bee1631bcc45d94dff2ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcf4022c73cb6f01329bee1631bcc45d94dff2ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/comments", "author": null, "committer": null, "parents": [{"sha": "50b996bfb88f3492796f26aad1a67901095ce4ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b996bfb88f3492796f26aad1a67901095ce4ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b996bfb88f3492796f26aad1a67901095ce4ed"}], "stats": {"total": 898, "additions": 206, "deletions": 692}, "files": [{"sha": "10da3aedd04d19a18040fb69361acb5b703fb451", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -1,3 +1,45 @@\n+2001-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tRemove old-abi remnants. Remove comments about old abi\n+\tbehaviour. Remove refences to 'new-abi' in comments.\n+\t* cp-tree.h: Adjust comments.\n+\t(vbase_offsets_in_vtable_p): Delete.\n+\t(vcall_offsets_in_vtable_p): Delete.\n+\t(vptrs_present_everywhere_p): Delete.\n+\t(all_overridden_vfuns_in_vtables_p): Delete.\n+\t(merge_primary_and_secondary_vtables_p): Delete.\n+\t(TYPE_CONTAINS_VPTR_P): Adjust.\n+\t(VTT_NAME_PREFIX): Remove.\n+\t(CTOR_VTBL_NAME_PREFIX): Remove.\n+\t(init_vbase_pointers): Remove.\n+\t* class.c: Adjust coments.\n+\t(build_vbase_pointer_fields): Delete.\n+\t(build_vbase_pointer): Remove old-abi code.\n+\t(build_secondary_vtable): Likewise.\n+\t(modify_all_vtables): Likewise.\n+\t(create_vtable_ptr): Likewise.\n+\t(layout_class_type): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t(finish_vtbls): Likewise.\n+\t(dfs_finish_vtbls): Delete.\n+\t(build_vbase_offset_vtbl_entries): Remove old-abi code.\n+\t* cvt.c: Adjust comments.\n+\t* decl.c: Adjust comments.\n+\t* decl2.c: Adjust comments.\n+\t* init.c: Adjust comments.\n+\t(construct_virtual_bases): Remove old-abi code.\n+\t* lang-specs.h: Remove -fno-new-abi.\n+\t* mangle.c: Adjust comments.\n+\t* rtti.c: Adjust comments.\n+\t(get_base_offset): Remove old-abi-code.\n+\t* search.c: Adjust comments.\n+\t(dfs_init_vbase_pointers): Remove.\n+\t(dfs_vtable_path_unmark): Remove.\n+\t(init_vbase_pointers): Remove.\n+\t* semantics.c: Adjust comments.\n+\t(emit_associated_thunks): Remove old-abi code.\n+\t* typeck.c: Adjust comments.\n+\n 2001-07-20  Daniel Berlin  <dan@cgsoftware.com>\n \n \t* Make-lang.in (cp/optimize.o): Depend on $(PARAMS_H), not"}, {"sha": "99c8638eeea280edea9e6e072e8b7521feb3388f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 108, "deletions": 383, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -112,7 +112,6 @@ static tree get_vtable_name PARAMS ((tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n-static tree dfs_finish_vtbls PARAMS ((tree, void *));\n static void finish_vtbls PARAMS ((tree));\n static void modify_vtable_entry PARAMS ((tree, tree, tree, tree, tree *));\n static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n@@ -147,7 +146,6 @@ static bool build_base_field PARAMS ((record_layout_info, tree, int *,\n \t\t\t\t     splay_tree, tree));\n static bool build_base_fields PARAMS ((record_layout_info, int *,\n \t\t\t\t      splay_tree, tree));\n-static tree build_vbase_pointer_fields PARAMS ((record_layout_info, int *));\n static tree build_vtbl_or_vbase_field PARAMS ((tree, tree, tree, tree, tree,\n \t\t\t\t\t       int *));\n static void check_methods PARAMS ((tree));\n@@ -241,121 +239,34 @@ int n_inner_fields_searched = 0;\n \n /* Virtual base class layout.  */\n \n-/* Returns a list of virtual base class pointers as a chain of\n-   FIELD_DECLS.  */\n-\n-static tree\n-build_vbase_pointer_fields (rli, empty_p)\n-     record_layout_info rli;\n-     int *empty_p;\n-{\n-  /* Chain to hold all the new FIELD_DECLs which point at virtual\n-     base classes.  */\n-  tree rec = rli->t;\n-  tree vbase_decls = NULL_TREE;\n-  tree binfos = TYPE_BINFO_BASETYPES (rec);\n-  int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n-  tree decl;\n-  int i;\n-\n-  /* Under the new ABI, there are no vbase pointers in the object.\n-     Instead, the offsets are stored in the vtable.  */\n-  if (vbase_offsets_in_vtable_p ())\n-    return NULL_TREE;\n-\n-  /* Loop over the baseclasses, adding vbase pointers as needed.  */\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      register tree basetype = BINFO_TYPE (base_binfo);\n-\n-      if (!COMPLETE_TYPE_P (basetype))\n-\t/* This error is now reported in xref_tag, thus giving better\n-\t   location information.  */\n-\tcontinue;\n-\n-      /* All basetypes are recorded in the association list of the\n-\t derived type.  */\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  int j;\n-\t  const char *name;\n-\n-\t  /* The offset for a virtual base class is only used in computing\n-\t     virtual function tables and for initializing virtual base\n-\t     pointers.  It is built once `get_vbase_types' is called.  */\n-\n-\t  /* If this basetype can come from another vbase pointer\n-\t     without an additional indirection, we will share\n-\t     that pointer.  If an indirection is involved, we\n-\t     make our own pointer.  */\n-\t  for (j = 0; j < n_baseclasses; j++)\n-\t    {\n-\t      tree other_base_binfo = TREE_VEC_ELT (binfos, j);\n-\t      if (! TREE_VIA_VIRTUAL (other_base_binfo)\n-\t\t  && binfo_for_vbase (basetype, BINFO_TYPE (other_base_binfo)))\n-\t\tgoto got_it;\n-\t    }\n-\t  FORMAT_VBASE_NAME (name, basetype);\n-\t  decl = build_vtbl_or_vbase_field (get_identifier (name), \n-\t\t\t\t\t    get_identifier (VTABLE_BASE),\n-\t\t\t\t\t    build_pointer_type (basetype),\n-\t\t\t\t\t    rec,\n-\t\t\t\t\t    basetype,\n-\t\t\t\t\t    empty_p);\n-\t  BINFO_VPTR_FIELD (base_binfo) = decl;\n-\t  TREE_CHAIN (decl) = vbase_decls;\n-\t  place_field (rli, decl);\n-\t  vbase_decls = decl;\n-\t  *empty_p = 0;\n-\n-\tgot_it:\n-\t  /* The space this decl occupies has already been accounted for.  */\n-\t  ;\n-\t}\n-    }\n-\n-  return vbase_decls;\n-}\n-\n /* Returns a pointer to the virtual base class of EXP that has the\n    indicated TYPE.  EXP is of class type, not a pointer type.  */\n \n static tree\n build_vbase_pointer (exp, type)\n      tree exp, type;\n {\n-  if (vbase_offsets_in_vtable_p ())\n-    {\n-      tree vbase;\n-      tree vbase_ptr;\n-\n-      /* Find the shared copy of TYPE; that's where the vtable offset\n-\t is recorded.  */\n-      vbase = binfo_for_vbase (type, TREE_TYPE (exp));\n-      /* Find the virtual function table pointer.  */\n-      vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n-      /* Compute the location where the offset will lie.  */\n-      vbase_ptr = build (PLUS_EXPR, \n-\t\t\t TREE_TYPE (vbase_ptr),\n-\t\t\t vbase_ptr,\n-\t\t\t BINFO_VPTR_FIELD (vbase));\n-      vbase_ptr = build1 (NOP_EXPR, \n-\t\t\t  build_pointer_type (ptrdiff_type_node),\n-\t\t\t  vbase_ptr);\n-      /* Add the contents of this location to EXP.  */\n-      return build (PLUS_EXPR,\n-\t\t    build_pointer_type (type),\n-\t\t    build_unary_op (ADDR_EXPR, exp, /*noconvert=*/0),\n-\t\t    build1 (INDIRECT_REF, ptrdiff_type_node, vbase_ptr));\n-    }\n-  else\n-    {\n-      char *name;\n-      FORMAT_VBASE_NAME (name, type);\n-      return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n-    }\n+  tree vbase;\n+  tree vbase_ptr;\n+\n+  /* Find the shared copy of TYPE; that's where the vtable offset is\n+     recorded.  */\n+  vbase = binfo_for_vbase (type, TREE_TYPE (exp));\n+  /* Find the virtual function table pointer.  */\n+  vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n+  /* Compute the location where the offset will lie.  */\n+  vbase_ptr = build (PLUS_EXPR, \n+\t\t     TREE_TYPE (vbase_ptr),\n+\t\t     vbase_ptr,\n+\t\t     BINFO_VPTR_FIELD (vbase));\n+  vbase_ptr = build1 (NOP_EXPR, \n+\t\t      build_pointer_type (ptrdiff_type_node),\n+\t\t      vbase_ptr);\n+  /* Add the contents of this location to EXP.  */\n+  return build (PLUS_EXPR,\n+\t\tbuild_pointer_type (type),\n+\t\tbuild_unary_op (ADDR_EXPR, exp, /*noconvert=*/0),\n+\t\tbuild1 (INDIRECT_REF, ptrdiff_type_node, vbase_ptr));\n }\n \n /* Build multi-level access to EXPR using hierarchy path PATH.\n@@ -603,8 +514,8 @@ build_vtbl_ref (instance, idx)\n \t{\n \t  vtbl = TYPE_BINFO_VTABLE (basetype);\n \t  /* Knowing the dynamic type of INSTANCE we can easily obtain\n-\t     the correct vtable entry.  In the new ABI, we resolve\n-\t     this back to be in terms of the primary vtable.  */\n+\t     the correct vtable entry.  We resolve this back to be in\n+\t     terms of the primary vtable.  */\n \t  if (TREE_CODE (vtbl) == PLUS_EXPR)\n \t    {\n \t      idx = fold (build (PLUS_EXPR,\n@@ -818,15 +729,15 @@ build_primary_vtable (binfo, type)\n   return 1;\n }\n \n-/* Give TYPE a new virtual function table which is initialized\n+/* Give BINFO a new virtual function table which is initialized\n    with a skeleton-copy of its original initialization.  The only\n    entry that changes is the `delta' entry, so we can really\n    share a lot of structure.\n \n-   FOR_TYPE is the derived type which caused this table to\n+   FOR_TYPE is the most derived type which caused this table to\n    be needed.\n \n-   BINFO is the type association which provided TYPE for FOR_TYPE.\n+   Returns non-zero if we haven't met BINFO before.\n \n    The order in which vtables are built (by calling this function) for\n    an object must remain the same, otherwise a binary incompatibility\n@@ -836,143 +747,28 @@ static int\n build_secondary_vtable (binfo, for_type)\n      tree binfo, for_type;\n {\n-  tree basetype;\n-  tree orig_decl = BINFO_VTABLE (binfo);\n-  tree name;\n-  tree new_decl;\n-  tree offset;\n-  tree path = binfo;\n-  char *buf;\n-  const char *buf2;\n-  char joiner = '_';\n-  int i;\n-\n-#ifdef JOINER\n-  joiner = JOINER;\n-#endif\n-\n-  if (TREE_VIA_VIRTUAL (binfo))\n-    my_friendly_assert (binfo == binfo_for_vbase (BINFO_TYPE (binfo),\n-\t\t\t\t\t\t  current_class_type),\n-\t\t\t170);\n+  my_friendly_assert (binfo == CANONICAL_BINFO (binfo, for_type), 20010605);\n \n-  if (BINFO_NEW_VTABLE_MARKED (binfo, current_class_type))\n+  if (BINFO_NEW_VTABLE_MARKED (binfo, for_type))\n     /* We already created a vtable for this base.  There's no need to\n        do it again.  */\n     return 0;\n \n   /* Remember that we've created a vtable for this BINFO, so that we\n      don't try to do so again.  */\n-  SET_BINFO_NEW_VTABLE_MARKED (binfo, current_class_type);\n+  SET_BINFO_NEW_VTABLE_MARKED (binfo, for_type);\n   \n   /* Make fresh virtual list, so we can smash it later.  */\n   BINFO_VIRTUALS (binfo) = copy_virtuals (binfo);\n \n-  my_friendly_assert (binfo == CANONICAL_BINFO (binfo, for_type), 20010605);\n-  offset = BINFO_OFFSET (binfo);\n-\n-  /* In the new ABI, secondary vtables are laid out as part of the\n-     same structure as the primary vtable.  */\n-  if (merge_primary_and_secondary_vtables_p ())\n-    {\n-      BINFO_VTABLE (binfo) = NULL_TREE;\n-      return 1;\n-    }\n-\n-  /* Create the declaration for the secondary vtable.  */\n-  basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (binfo));\n-  buf2 = TYPE_ASSEMBLER_NAME_STRING (basetype);\n-  i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1;\n-\n-  /* We know that the vtable that we are going to create doesn't exist\n-     yet in the global namespace, and when we finish, it will be\n-     pushed into the global namespace.  In complex MI hierarchies, we\n-     have to loop while the name we are thinking of adding is globally\n-     defined, adding more name components to the vtable name as we\n-     loop, until the name is unique.  This is because in complex MI\n-     cases, we might have the same base more than once.  This means\n-     that the order in which this function is called for vtables must\n-     remain the same, otherwise binary compatibility can be\n-     compromised.  */\n-\n-  while (1)\n-    {\n-      char *buf1 = (char *) alloca (TYPE_ASSEMBLER_NAME_LENGTH (for_type)\n-\t\t\t\t    + 1 + i);\n-      char *new_buf2;\n-\n-      sprintf (buf1, \"%s%c%s\", TYPE_ASSEMBLER_NAME_STRING (for_type), joiner,\n-\t       buf2);\n-      buf = (char *) alloca (strlen (VTABLE_NAME_PREFIX) + strlen (buf1) + 1);\n-      sprintf (buf, \"%s%s\", VTABLE_NAME_PREFIX, buf1);\n-      name = get_identifier (buf);\n-\n-      /* If this name doesn't clash, then we can use it, otherwise\n-\t we add more to the name until it is unique.  */\n-\n-      if (! IDENTIFIER_GLOBAL_VALUE (name))\n-\tbreak;\n-\n-      /* Set values for next loop through, if the name isn't unique.  */\n-\n-      path = BINFO_INHERITANCE_CHAIN (path);\n-\n-      /* We better not run out of stuff to make it unique.  */\n-      my_friendly_assert (path != NULL_TREE, 368);\n-\n-      basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (path));\n-\n-      if (for_type == basetype)\n-\t{\n-\t  /* If we run out of basetypes in the path, we have already\n-\t     found created a vtable with that name before, we now\n-\t     resort to tacking on _%d to distinguish them.  */\n-\t  int j = 2;\n-\t  i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1 + i + 1 + 3;\n-\t  buf1 = (char *) alloca (i);\n-\t  do {\n-\t    sprintf (buf1, \"%s%c%s%c%d\",\n-\t\t     TYPE_ASSEMBLER_NAME_STRING (basetype), joiner,\n-\t\t     buf2, joiner, j);\n-\t    buf = (char *) alloca (strlen (VTABLE_NAME_PREFIX)\n-\t\t\t\t   + strlen (buf1) + 1);\n-\t    sprintf (buf, \"%s%s\", VTABLE_NAME_PREFIX, buf1);\n-\t    name = get_identifier (buf);\n-\n-\t    /* If this name doesn't clash, then we can use it,\n-\t       otherwise we add something different to the name until\n-\t       it is unique.  */\n-\t  } while (++j <= 999 && IDENTIFIER_GLOBAL_VALUE (name));\n-\n-\t  /* Hey, they really like MI don't they?  Increase the 3\n-             above to 6, and the 999 to 999999.  :-)  */\n-\t  my_friendly_assert (j <= 999, 369);\n-\n-\t  break;\n-\t}\n-\n-      i = TYPE_ASSEMBLER_NAME_LENGTH (basetype) + 1 + i;\n-      new_buf2 = (char *) alloca (i);\n-      sprintf (new_buf2, \"%s%c%s\",\n-\t       TYPE_ASSEMBLER_NAME_STRING (basetype), joiner, buf2);\n-      buf2 = new_buf2;\n-    }\n-\n-  new_decl = build_vtable (for_type, name, TREE_TYPE (orig_decl));\n-  DECL_ALIGN (new_decl) = DECL_ALIGN (orig_decl);\n-  DECL_USER_ALIGN (new_decl) = DECL_USER_ALIGN (orig_decl);\n-  BINFO_VTABLE (binfo) = pushdecl_top_level (new_decl);\n-\n-#ifdef GATHER_STATISTICS\n-  n_vtables += 1;\n-  n_vtable_elems += list_length (BINFO_VIRTUALS (binfo));\n-#endif\n-\n+  /* Secondary vtables are laid out as part of the same structure as\n+     the primary vtable.  */\n+  BINFO_VTABLE (binfo) = NULL_TREE;\n   return 1;\n }\n \n /* Create a new vtable for BINFO which is the hierarchy dominated by\n-   T.  */\n+   T. Return non-zero if we actually created a new vtable.  */\n \n static int\n make_new_vtable (t, binfo)\n@@ -1903,9 +1699,8 @@ determine_primary_base (t, vfuns_p)\n \t  if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t    CLASSTYPE_RTTI (t) = CLASSTYPE_RTTI (basetype);\n \n-\t  /* A virtual baseclass can't be the primary base under the\n-\t     old ABI.  And under the new ABI we still prefer a\n-\t     non-virtual base.  */\n+\t  /* We prefer a non-virtual base, although a virtual one will\n+\t     do.  */\n \t  if (TREE_VIA_VIRTUAL (base_binfo))\n \t    continue;\n \n@@ -1974,9 +1769,8 @@ determine_primary_base (t, vfuns_p)\n \t}\n     }\n \n-  /* The new ABI allows for the use of a \"nearly-empty\" virtual base\n-     class as the primary base class if no non-virtual polymorphic\n-     base can be found.  */\n+  /* A \"nearly-empty\" virtual base class can be the primary base\n+     class, if no non-virtual polymorphic base can be found.  */\n   if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     {\n       /* If not NULL, this is the best primary base candidate we have\n@@ -2759,9 +2553,8 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n      the final overrider, and not to an intermediate virtual base.  */\n   virtual_base = NULL_TREE;\n \n-  /* Under the new ABI, we will convert to an intermediate virtual\n-     base first, and then use the vcall offset located there to finish\n-     the conversion.  */\n+  /* We will convert to an intermediate virtual base first, and then\n+     use the vcall offset located there to finish the conversion.  */\n   while (b)\n     {\n       /* If we find the final overrider, then we can stop\n@@ -2851,9 +2644,6 @@ dfs_modify_vtables (binfo, data)\n \n       t = (tree) data;\n \n-      /* If we're supporting RTTI then we always need a new vtable to\n-\t point to the RTTI information.  Under the new ABI we may need\n-\t a new vtable to contain vcall and vbase offsets.  */\n       make_new_vtable (t, binfo);\n       \n       /* Now, go through each of the virtual functions in the virtual\n@@ -2890,9 +2680,8 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n      int *vfuns_p;\n      tree overridden_virtuals;\n {\n-  tree binfo;\n-\n-  binfo = TYPE_BINFO (t);\n+  tree binfo = TYPE_BINFO (t);\n+  tree *fnsp;\n \n   /* Update all of the vtables.  */\n   dfs_walk (binfo, \n@@ -2901,43 +2690,35 @@ modify_all_vtables (t, vfuns_p, overridden_virtuals)\n \t    t);\n   dfs_walk (binfo, dfs_unmark, dfs_marked_real_bases_queue_p, t);\n \n-  /* If we should include overriding functions for secondary vtables\n-     in our primary vtable, add them now.  */\n-  if (all_overridden_vfuns_in_vtables_p ())\n+  /* Include overriding functions for secondary vtables in our primary\n+     vtable.  */\n+  for (fnsp = &overridden_virtuals; *fnsp; )\n     {\n-      tree *fnsp = &overridden_virtuals;\n+      tree fn = TREE_VALUE (*fnsp);\n \n-      while (*fnsp)\n+      if (!BINFO_VIRTUALS (binfo)\n+\t  || !value_member (fn, BINFO_VIRTUALS (binfo)))\n \t{\n-\t  tree fn = TREE_VALUE (*fnsp);\n-\n-\t  if (!BINFO_VIRTUALS (binfo)\n-\t      || !value_member (fn, BINFO_VIRTUALS (binfo)))\n-\t    {\n-\t      /* Set the vtable index.  */\n-\t      set_vindex (fn, vfuns_p);\n-\t      /* We don't need to convert to a base class when calling\n-\t\t this function.  */\n-\t      DECL_VIRTUAL_CONTEXT (fn) = t;\n-\n-\t      /* We don't need to adjust the `this' pointer when\n-\t\t calling this function.  */\n-\t      BV_DELTA (*fnsp) = integer_zero_node;\n-\t      BV_VCALL_INDEX (*fnsp) = NULL_TREE;\n-\n-\t      /* This is an overridden function not already in our\n-\t\t vtable.  Keep it.  */\n-\t      fnsp = &TREE_CHAIN (*fnsp);\n-\t    }\n-\t  else\n-\t    /* We've already got an entry for this function.  Skip\n-\t       it.  */\n-\t    *fnsp = TREE_CHAIN (*fnsp);\n+\t  /* Set the vtable index.  */\n+\t  set_vindex (fn, vfuns_p);\n+\t  /* We don't need to convert to a base class when calling\n+\t     this function.  */\n+\t  DECL_VIRTUAL_CONTEXT (fn) = t;\n+\n+\t  /* We don't need to adjust the `this' pointer when\n+\t     calling this function.  */\n+\t  BV_DELTA (*fnsp) = integer_zero_node;\n+\t  BV_VCALL_INDEX (*fnsp) = NULL_TREE;\n+\n+\t  /* This is an overridden function not already in our\n+\t     vtable.  Keep it.  */\n+\t  fnsp = &TREE_CHAIN (*fnsp);\n \t}\n+      else\n+\t/* We've already got an entry for this function.  Skip it.  */\n+\t*fnsp = TREE_CHAIN (*fnsp);\n     }\n-  else\n-    overridden_virtuals = NULL_TREE;\n-\n+  \n   return overridden_virtuals;\n }\n \n@@ -4179,8 +3960,7 @@ build_base_fields (rli, empty_p, offsets, t)\n   int i;\n   bool atend = 0;\n \n-  /* Under the new ABI, the primary base class is always allocated\n-     first.  */\n+  /* The primary base class is always allocated first.  */\n   if (CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n     build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (rec), \n \t\t      empty_p, offsets, t);\n@@ -4192,8 +3972,8 @@ build_base_fields (rli, empty_p, offsets, t)\n \n       base_binfo = BINFO_BASETYPE (TYPE_BINFO (rec), i);\n \n-      /* Under the new ABI, the primary base was already allocated\n-\t above, so we don't need to allocate it again here.  */\n+      /* The primary base was already allocated above, so we don't\n+\t need to allocate it again here.  */\n       if (base_binfo == CLASSTYPE_PRIMARY_BINFO (rec))\n \tcontinue;\n \n@@ -4710,9 +4490,7 @@ create_vtable_ptr (t, empty_p, vfuns_p,\n      here.  Even if there weren't any new virtual functions, we might need a\n      new virtual function table if we're supposed to include vptrs in\n      all classes that need them.  */\n-  if (!TYPE_VFIELD (t)\n-      && (*vfuns_p \n-\t  || (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ())))\n+  if (!TYPE_VFIELD (t) && (*vfuns_p || TYPE_CONTAINS_VPTR_P (t)))\n     {\n       /* We build this decl with vtbl_ptr_type_node, which is a\n \t `vtable_entry_type*'.  It might seem more precise to use\n@@ -4917,10 +4695,8 @@ layout_virtual_bases (t, offsets)\n   TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), BITS_PER_UNIT);\n \n   /* Go through the virtual bases, allocating space for each virtual\n-     base that is not already a primary base class.  Under the old\n-     ABI, these are allocated according to a depth-first left-to-right\n-     postorder traversal; in the new ABI, inheritance graph order is\n-     used instead.  */\n+     base that is not already a primary base class.  These are\n+     allocated in inheritance graph order.  */\n   for (vbases = TYPE_BINFO (t);\n        vbases; \n        vbases = TREE_CHAIN (vbases))\n@@ -4947,8 +4723,8 @@ layout_virtual_bases (t, offsets)\n \t     appropriately aligned offset.  */\n \t  dsize = CEIL (dsize, desired_align) * desired_align;\n \n-\t  /* Under the new ABI, we try to squish empty virtual bases in\n-\t     just like ordinary empty bases.  */\n+\t  /* We try to squish empty virtual bases in just like\n+\t     ordinary empty bases.  */\n \t  if (is_empty_class (basetype))\n \t    layout_empty_base (vbase,\n \t\t\t       size_int (CEIL (dsize, BITS_PER_UNIT)),\n@@ -5130,8 +4906,7 @@ layout_class_type (t, empty_p, vfuns_p,\n   vptr = create_vtable_ptr (t, empty_p, vfuns_p,\n \t\t\t    new_virtuals_p, overridden_virtuals_p);\n \n-  /* Under the new ABI, the vptr is always the first thing in the\n-     class.  */\n+  /* The vptr is always the first thing in the class.  */\n   if (vptr)\n     {\n       TYPE_FIELDS (t) = chainon (vptr, TYPE_FIELDS (t));\n@@ -5144,10 +4919,6 @@ layout_class_type (t, empty_p, vfuns_p,\n   if (build_base_fields (rli, empty_p, empty_base_offsets, t))\n     CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n   \n-  /* Add pointers to all of our virtual base-classes.  */\n-  TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (rli, empty_p),\n-\t\t\t     TYPE_FIELDS (t));\n-\n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n      we have to save this before we start modifying\n      TYPE_NONCOPIED_PARTS.  */\n@@ -5170,10 +4941,8 @@ layout_class_type (t, empty_p, vfuns_p,\n       type = TREE_TYPE (field);\n \n       /* If this field is a bit-field whose width is greater than its\n-\t type, then there are some special rules for allocating it\n-\t under the new ABI.  Under the old ABI, there were no special\n-\t rules, but the back-end can't handle bitfields longer than a\n-\t `long long', so we use the same mechanism.  */\n+\t type, then there are some special rules for allocating\n+\t it.  */\n       if (DECL_C_BIT_FIELD (field)\n \t  && INT_CST_LT (TYPE_SIZE (type), DECL_SIZE (field)))\n \t{\n@@ -5238,10 +5007,10 @@ layout_class_type (t, empty_p, vfuns_p,\n     }\n \n   /* We make all structures have at least one element, so that they\n-     have non-zero size.  In the new ABI, the class may be empty even\n-     if it has basetypes.  Therefore, we add the fake field after all\n-     the other fields; if there are already FIELD_DECLs on the list,\n-     their offsets will not be disturbed.  */\n+     have non-zero size.  The class may be empty even if it has\n+     basetypes.  Therefore, we add the fake field after all the other\n+     fields; if there are already FIELD_DECLs on the list, their\n+     offsets will not be disturbed.  */\n   if (!eoc && *empty_p)\n     {\n       tree padding;\n@@ -5400,9 +5169,7 @@ finish_struct_1 (t)\n       = chainon (CLASSTYPE_VFIELDS (t), build_tree_list (NULL_TREE, t));\n \n   /* If necessary, create the primary vtable for this class.  */\n-  if (new_virtuals\n-      || overridden_virtuals\n-      || (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ()))\n+  if (new_virtuals || overridden_virtuals || TYPE_CONTAINS_VPTR_P (t))\n     {\n       new_virtuals = nreverse (new_virtuals);\n       /* We must enter these virtuals into the table.  */\n@@ -6779,10 +6546,9 @@ note_name_declared_in_class (name, decl)\n     }\n }\n \n-/* Returns the VAR_DECL for the complete vtable associated with\n-   BINFO.  (Under the new ABI, secondary vtables are merged with\n-   primary vtables; this function will return the VAR_DECL for the\n-   primary vtable.)  */\n+/* Returns the VAR_DECL for the complete vtable associated with BINFO.\n+   Secondary vtables are merged with primary vtables; this function\n+   will return the VAR_DECL for the primary vtable.  */\n \n tree\n get_vtbl_decl_for_binfo (binfo)\n@@ -7130,64 +6896,34 @@ static void\n finish_vtbls (t)\n      tree t;\n {\n-  if (merge_primary_and_secondary_vtables_p ())\n-    {\n-      tree list;\n-      tree vbase;\n+  tree list;\n+  tree vbase;\n \n-      /* Under the new ABI, we lay out the primary and secondary\n-\t vtables in one contiguous vtable.  The primary vtable is\n-\t first, followed by the non-virtual secondary vtables in\n-\t inheritance graph order.  */\n-      list = build_tree_list (TYPE_BINFO_VTABLE (t), NULL_TREE);\n-      accumulate_vtbl_inits (TYPE_BINFO (t), TYPE_BINFO (t),\n-\t\t\t     TYPE_BINFO (t), t, list);\n-      /* Then come the virtual bases, also in inheritance graph\n-\t order.  */\n-      for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n-\t{\n-\t  tree real_base;\n+  /* We lay out the primary and secondary vtables in one contiguous\n+     vtable.  The primary vtable is first, followed by the non-virtual\n+     secondary vtables in inheritance graph order.  */\n+  list = build_tree_list (TYPE_BINFO_VTABLE (t), NULL_TREE);\n+  accumulate_vtbl_inits (TYPE_BINFO (t), TYPE_BINFO (t),\n+\t\t\t TYPE_BINFO (t), t, list);\n+  \n+  /* Then come the virtual bases, also in inheritance graph order.  */\n+  for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n+    {\n+      tree real_base;\n \t  \n-\t  if (!TREE_VIA_VIRTUAL (vbase))\n-\t    continue;\n+      if (!TREE_VIA_VIRTUAL (vbase))\n+\tcontinue;\n           \n-          /* Although we walk in inheritance order, that might not get the\n-             canonical base.  */\n-          real_base = binfo_for_vbase (BINFO_TYPE (vbase), t);\n+      /* Although we walk in inheritance order, that might not get the\n+         canonical base.  */\n+      real_base = binfo_for_vbase (BINFO_TYPE (vbase), t);\n           \n-\t  accumulate_vtbl_inits (real_base, real_base,\n-\t                         TYPE_BINFO (t), t, list);\n-\t}\n-\n-      if (TYPE_BINFO_VTABLE (t))\n-\tinitialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n-    }\n-  else\n-    {\n-      dfs_walk (TYPE_BINFO (t), dfs_finish_vtbls, \n-\t\tdfs_unmarked_real_bases_queue_p, t);\n-      dfs_walk (TYPE_BINFO (t), dfs_unmark, \n-\t\tdfs_marked_real_bases_queue_p, t);\n+      accumulate_vtbl_inits (real_base, real_base,\n+\t\t\t     TYPE_BINFO (t), t, list);\n     }\n-}\n \n-/* Called from finish_vtbls via dfs_walk.  */\n-\n-static tree\n-dfs_finish_vtbls (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  tree t = (tree) data;\n-\n-  if (BINFO_NEW_VTABLE_MARKED (binfo, t))\n-    initialize_vtable (binfo, \n-\t\t       build_vtbl_initializer (binfo, binfo, t, \n-\t\t\t\t\t       TYPE_BINFO (t), NULL));\n-\n-  SET_BINFO_MARKED (binfo);\n-\n-  return NULL_TREE;\n+  if (TYPE_BINFO_VTABLE (t))\n+    initialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n }\n \n /* Initialize the vtable for BINFO with the INITS.  */\n@@ -7666,9 +7402,8 @@ accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n     }\n }\n \n-/* Called from accumulate_vtbl_inits when using the new ABI.\n-   Accumulates the vtable initializers for all of the vtables into\n-   TREE_VALUE (DATA).  Returns the initializers for the BINFO vtable.  */\n+/* Called from accumulate_vtbl_inits.  Returns the initializers for\n+   the BINFO vtable.  */\n \n static tree\n dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n@@ -7958,11 +7693,6 @@ build_vbase_offset_vtbl_entries (binfo, vid)\n   tree vbase;\n   tree t;\n \n-  /* Under the old ABI, pointers to virtual bases are stored in each\n-     object.  */\n-  if (!vbase_offsets_in_vtable_p ())\n-    return;\n-\n   /* If there are no virtual baseclasses, then there is nothing to\n      do.  */\n   if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n@@ -8039,11 +7769,6 @@ build_vcall_offset_vtbl_entries (binfo, vid)\n      tree binfo;\n      vtbl_init_data *vid;\n {\n-  /* Under the old ABI, the adjustments to the `this' pointer were made\n-     elsewhere.  */\n-  if (!vcall_offsets_in_vtable_p ())\n-    return;\n-\n   /* We only need these entries if this base is a virtual base.  */\n   if (!TREE_VIA_VIRTUAL (binfo))\n     return;"}, {"sha": "465ba5198c26d34fee2caab122965fbf49c39176", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 106, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -133,11 +133,9 @@ Boston, MA 02111-1307, USA.  */\n      The BV_FN is the declaration for the virtual function itself.\n \n    BINFO_VTABLE\n-     Sometimes this is a VAR_DECL.  Under the new ABI, it is instead\n-     an expression with POINTER_TYPE pointing that gives the value\n+     This is an expression with POINTER_TYPE that gives the value\n      to which the vptr should be initialized.  Use get_vtbl_decl_for_binfo\n-     to extract the VAR_DECL for the complete vtable; that macro works\n-     in both ABIs.\n+     to extract the VAR_DECL for the complete vtable.\n \n    DECL_ARGUMENTS\n      For a VAR_DECL this is DECL_ANON_UNION_ELEMS.\n@@ -224,40 +222,6 @@ extern int flag_rtti;\n \n extern int flag_huge_objects;\n \n-/* Nonzero if virtual base class offsets are stored in the virtual\n-   function table.  Zero if, instead, a pointer to the virtual base is\n-   stored in the object itself.  */\n-#define vbase_offsets_in_vtable_p() (1)\n-\n-/* Nonzero if displacements to the `this' pointer to use when calling\n-   virtual functions in a virtual base class are present in the\n-   vtable.  */\n-#define vcall_offsets_in_vtable_p() (1)\n-\n-/* Nonzero if a derived class that needs a vptr should always get one,\n-   even if a non-primary base class already has one.  For example,\n-   given:\n-\n-     struct S { int i; virtual void f(); };\n-     struct T : virtual public S {};\n-\n-   one could either reuse the vptr in `S' for `T', or create a new\n-   vptr for `T'.  If this flag is nonzero we choose the latter\n-   alternative; otherwise, we choose the former.  */\n-#define vptrs_present_everywhere_p() (1)\n-\n-/* Nonzero if the vtable for a derived class should contain the\n-   virtual functions from the primary base and all virtual functions\n-   present in the class itself.  Zero if, instead, it should contain\n-   only those virtual functions from the primary base together with\n-   the functions declared in the derived class (but not in any base\n-   class).  */\n-#define all_overridden_vfuns_in_vtables_p() (1)\n-\n-/* Nonzero if primary and secondary vtables are combined into a single\n-   vtable.  */\n-#define merge_primary_and_secondary_vtables_p() (1)\n-\n \f\n /* Language-dependent contents of an identifier.  */\n \n@@ -2431,8 +2395,7 @@ struct lang_decl\n /* Nonzero if this class has a virtual function table pointer.  */\n #define TYPE_CONTAINS_VPTR_P(NODE)\t\t\\\n   (TYPE_POLYMORPHIC_P (NODE)\t\t\t\\\n-   || (vbase_offsets_in_vtable_p ()\t\t\\\n-       && TYPE_USES_VIRTUAL_BASECLASSES (NODE)))\n+   || TYPE_USES_VIRTUAL_BASECLASSES (NODE))\n \n extern int flag_new_for_scope;\n \n@@ -2587,67 +2550,15 @@ extern int flag_new_for_scope;\n \n /* A pointer-to-function member type looks like:\n \n-   struct {\n-     short __delta;\n-     short __index;\n-     union {\n-       P __pfn;\n-       short __delta2;\n-     } __pfn_or_delta2;\n-   };\n-\n-   where P is a POINTER_TYPE to a METHOD_TYPE appropriate for the\n-   pointer to member.  The fields are used as follows:\n-\n-     If __INDEX is -1, then the function to call is non-virtual, and\n-     is located at the address given by __PFN.\n-\n-     If __INDEX is zero, then this a NULL pointer-to-member.\n-\n-     Otherwise, the function to call is virtual.  Then, __DELTA2 gives\n-     the offset from an instance of the object to the virtual function\n-     table, and __INDEX - 1 is the index into the vtable to use to\n-     find the function.\n-\n-     The value to use for the THIS parameter is the address of the\n-     object plus __DELTA.\n-\n-   For example, given:\n-\n-     struct B1 {\n-       int i;\n-     };\n-\n-     struct B2 {\n-       double d;\n-       void f();\n-     };\n-\n-     struct S : public B1, B2 {};\n-\n-   the pointer-to-member for `&S::f' looks like:\n-\n-     { 4, -1, { &f__2B2 } };\n-\n-   The `4' means that given an `S*' you have to add 4 bytes to get to\n-   the address of the `B2*'.  Then, the -1 indicates that this is a\n-   non-virtual function.  Of course, `&f__2B2' is the name of that\n-   function.\n-\n-   (Of course, the exact values may differ depending on the mangling\n-   scheme, sizes of types, and such.).\n-\n-   Under the new ABI, we do:\n-\n      struct {\n        __P __pfn;\n        ptrdiff_t __delta;\n      };\n \n-   (We don't need DELTA2, because the vtable is always the first thing\n-   in the object.)  If the function is virtual, then PFN is one plus\n-   twice the index into the vtable; otherwise, it is just a pointer to\n-   the function.\n+   (As the vtable is always the first thing in the object, we don't\n+   need an offset to it.)  If the function is virtual, then PFN is one\n+   plus twice the index into the vtable; otherwise, it is just a\n+   pointer to the function.\n \n    Unfortunately, using the lowest bit of PFN doesn't work in\n    architectures that don't impose alignment requirements on function\n@@ -3342,15 +3253,6 @@ extern varray_type local_classes;\n \n #define EXCEPTION_CLEANUP_NAME\t\"exception cleanup\"\n \n-/* The name used as a prefix for VTTs.  When the new ABI mangling\n-   scheme is implemented, this should be removed.  */\n-\n-#define VTT_NAME_PREFIX \"__vtt_\"\n-\n-/* The name used as a prefix for construction vtables.  */\n-\n-#define CTOR_VTBL_NAME_PREFIX \"__ctorvt_\"\n-\n #define THIS_NAME_P(ID_NODE) (strcmp(IDENTIFIER_POINTER (ID_NODE), \"this\") == 0)\n \n #if !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL)\n@@ -4165,7 +4067,6 @@ extern tree lookup_fnfields\t\t\tPARAMS ((tree, tree, int));\n extern tree lookup_member\t\t\tPARAMS ((tree, tree, int, int));\n extern int look_for_overrides\t\t\tPARAMS ((tree, tree));\n extern void get_pure_virtuals\t\t        PARAMS ((tree));\n-extern tree init_vbase_pointers\t\t\tPARAMS ((tree, tree));\n extern void get_vbase_types\t\t\tPARAMS ((tree));\n extern void maybe_suppress_debug_info\t\tPARAMS ((tree));\n extern void note_debug_info_needed\t\tPARAMS ((tree));"}, {"sha": "385ad2e5f9b30766cdbc0126eaeb3ce4f1935fb0", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -259,8 +259,8 @@ cp_convert_to_pointer (type, expr, force)\n \treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n \n       if (TYPE_PTRMEM_P (type))\n-\t/* Under the new ABI, a NULL pointer-to-member is represented\n-\t   by -1, not by zero.  */\n+\t/* A NULL pointer-to-member is represented by -1, not by\n+\t   zero.  */\n \texpr = build_int_2 (-1, -1);\n       else\n \texpr = build_int_2 (0, 0);"}, {"sha": "2abddd24d3b2f136bbc83aebacc67a253a8dd374", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -48,8 +48,7 @@ Boston, MA 02111-1307, USA.  */\n extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n \n #ifndef BOOL_TYPE_SIZE\n-/* In the new ABI, `bool' has size and alignment `1', on all\n-   platforms.  */\n+/* `bool' has size and alignment `1', on all platforms.  */\n #define BOOL_TYPE_SIZE CHAR_TYPE_SIZE\n #endif\n \n@@ -9475,7 +9474,6 @@ check_special_function_return_type (sfk, type, optype)\n       if (type)\n \tcp_error (\"return type specification for constructor invalid\");\n \n-      /* In the new ABI constructors do not return a value.  */\n       type = void_type_node;\n       break;\n "}, {"sha": "d2d8ec5fa62a93ba169d49504a8fd1e4b4e2ab53", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -2291,12 +2291,12 @@ comdat_linkage (decl)\n        address, and this will not hold when we emit multiple copies of\n        the function.  However, there's little else we can do.  \n \n-       Also, by default, the typeinfo implementation for the new ABI\n-       assumes that there will be only one copy of the string used as\n-       the name for each type.  Therefore, if weak symbols are\n-       unavailable, the run-time library should perform a more\n-       conservative check; it should perform a string comparison,\n-       rather than an address comparison.  */\n+       Also, by default, the typeinfo implementation assumes that\n+       there will be only one copy of the string used as the name for\n+       each type.  Therefore, if weak symbols are unavailable, the\n+       run-time library should perform a more conservative check; it\n+       should perform a string comparison, rather than an address\n+       comparison.  */\n     TREE_PUBLIC (decl) = 0;\n   else\n     {\n@@ -2744,8 +2744,8 @@ get_guard (decl)\n     {\n       tree guard_type;\n \n-      /* Under the new ABI, we use a type that is big enough to\n-\t contain a mutex as well as an integer counter.  */\n+      /* We use a type that is big enough to contain a mutex as well\n+\t as an integer counter.  */\n       guard_type = long_long_integer_type_node;\n       guard = build_decl (VAR_DECL, sname, guard_type);\n       \n@@ -2772,8 +2772,8 @@ static tree\n get_guard_bits (guard)\n      tree guard;\n {\n-  /* Under the new ABI, we only set the first byte of the guard,\n-     in order to leave room for a mutex in the high-order bits.  */\n+  /* We only set the first byte of the guard, in order to leave room\n+     for a mutex in the high-order bits.  */\n   guard = build1 (ADDR_EXPR, \n \t\t  build_pointer_type (TREE_TYPE (guard)),\n \t\t  guard);"}, {"sha": "0cf2847daa2563fe8ff7c92fc818359df1ee3b7b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -175,9 +175,9 @@ initialize_vtbl_ptrs (addr)\n   list = build_tree_list (type, addr);\n \n   /* Walk through the hierarchy, initializing the vptr in each base\n-     class.  We do these in pre-order because under the new ABI we\n-     can't find the virtual bases for a class until we've initialized\n-     the vtbl for that class.  */\n+     class.  We do these in pre-order because can't find the virtual\n+     bases for a class until we've initialized the vtbl for that\n+     class.  */\n   dfs_walk_real (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs, \n \t\t NULL, dfs_unmarked_real_bases_queue_p, list);\n   dfs_walk (TYPE_BINFO (type), dfs_unmark,\n@@ -851,8 +851,8 @@ expand_virtual_init (binfo, decl)\n   /* Compute the initializer for vptr.  */\n   vtbl = build_vtbl_address (binfo);\n \n-  /* Under the new ABI, we may get this vptr from a VTT, if this is a\n-     subobject constructor or subobject destructor.  */\n+  /* We may get this vptr from a VTT, if this is a subobject\n+     constructor or subobject destructor.  */\n   vtt_index = BINFO_VPTR_INDEX (binfo);\n   if (vtt_index)\n     {\n@@ -951,22 +951,6 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n   /* If there are no virtual baseclasses, we shouldn't even be here.  */\n   my_friendly_assert (TYPE_USES_VIRTUAL_BASECLASSES (type), 19990621);\n \n-  /* First set the pointers in our object that tell us where to find\n-     our virtual baseclasses.  */\n-  if (!vbase_offsets_in_vtable_p ())\n-    {\n-      tree if_stmt;\n-      tree result;\n-\n-      if_stmt = begin_if_stmt ();\n-      finish_if_stmt_cond (flag, if_stmt);\n-      result = init_vbase_pointers (type, this_ptr);\n-      if (result)\n-\tfinish_expr_stmt (build_compound_expr (result));\n-      finish_then_clause (if_stmt);\n-      finish_if_stmt ();\n-    }\n-\n   /* Now, run through the baseclasses, initializing each.  */ \n   for (vbases = CLASSTYPE_VBASECLASSES (type); vbases;\n        vbases = TREE_CHAIN (vbases))\n@@ -2213,7 +2197,7 @@ build_java_class_ref (type)\n       jclass_node = TREE_TYPE (jclass_node);\n     }\n \n-  /* Mangle the class$ field, new and old ABI */\n+  /* Mangle the class$ field */\n   {\n     tree field;\n     for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n@@ -2252,8 +2236,8 @@ get_cookie_size (type)\n {\n   tree cookie_size;\n \n-  /* Under the new ABI, we need to allocate an additional max\n-     (sizeof (size_t), alignof (true_type)) bytes.  */\n+  /* We need to allocate an additional max (sizeof (size_t), alignof\n+     (true_type)) bytes.  */\n   tree sizetype_size;\n   tree type_align;\n   \n@@ -2360,9 +2344,7 @@ build_new_1 (exp)\n   if (!has_array || !TYPE_VEC_NEW_USES_COOKIE (true_type))\n     use_cookie = 0;\n   /* When using placement new, users may not realize that they need\n-     the extra storage.  Under the old ABI, we don't allocate the\n-     cookie whenever they use one placement argument of type `void\n-     *'.  Under the new ABI, we require that the operator called be\n+     the extra storage.  We require that the operator called be\n      the global placement operator delete[].  */\n   else if (placement && !TREE_CHAIN (placement) \n \t   && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n@@ -2479,9 +2461,8 @@ build_new_1 (exp)\n       tree cookie;\n \n       /* Store the number of bytes allocated so that we can know how\n-\t many elements to destroy later.  Under the new ABI, we use\n-\t the last sizeof (size_t) bytes to store the number of\n-\t elements.  */\n+\t many elements to destroy later.  We use the last sizeof\n+\t (size_t) bytes to store the number of elements.  */\n       cookie = build (MINUS_EXPR, build_pointer_type (sizetype),\n \t\t      alloc_node, size_in_bytes (sizetype));\n       cookie = build_indirect_ref (cookie, NULL);"}, {"sha": "67a3ecbe3e8cc7084e7afa21349f59034339ed7f", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -38,22 +38,22 @@ Boston, MA 02111-1307, USA.  */\n     \"%{E|M|MM:cpp0 -lang-c++ %{!no-gcc:-D__GNUG__=%v1}\\\n        %{!Wno-deprecated:-D__DEPRECATED}\\\n        %{!fno-exceptions:-D__EXCEPTIONS}\\\n-       %{!fno-new-abi:-D__GXX_ABI_VERSION=100}\\\n+       -D__GXX_ABI_VERSION=100\\\n        %{ansi:-D__STRICT_ANSI__ -trigraphs -$} %(cpp_options)}\\\n      %{!E:%{!M:%{!MM:\\\n        %{save-temps:cpp0 -lang-c++ \\\n \t\t    %{!no-gcc:-D__GNUG__=%v1}\\\n        \t\t    %{!Wno-deprecated:-D__DEPRECATED}\\\n \t\t    %{!fno-exceptions:-D__EXCEPTIONS}\\\n-\t\t    %{!fno-new-abi:-D__GXX_ABI_VERSION=100}\\\n+\t\t    -D__GXX_ABI_VERSION=100\\\n \t\t    %{ansi:-D__STRICT_ANSI__ -trigraphs -$}\\\n \t\t    %(cpp_options) %b.ii \\n}\\\n       cc1plus %{save-temps:-fpreprocessed %b.ii}\\\n               %{!save-temps:%(cpp_options)\\\n \t\t\t    %{!no-gcc:-D__GNUG__=%v1} \\\n        \t\t\t    %{!Wno-deprecated:-D__DEPRECATED}\\\n \t\t\t    %{!fno-exceptions:-D__EXCEPTIONS}\\\n-\t\t\t    %{!fno-new-abi:-D__GXX_ABI_VERSION=100}\\\n+\t\t\t    -D__GXX_ABI_VERSION=100\\\n \t\t\t    %{ansi:-D__STRICT_ANSI__}}\\\n        %{ansi:-trigraphs -$}\\\n        %(cc1_options) %2 %{+e1*}\\"}, {"sha": "2b1b00952909de78ba5b9ad2354a52becac6ca17", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -1,4 +1,4 @@\n-/* Name mangling for the new standard C++ ABI.\n+/* Name mangling for the 3.0 C++ ABI.\n    Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n    Written by Alex Samuel <sameul@codesourcery.com>\n \n@@ -1168,10 +1168,9 @@ write_identifier (identifier)\n \n    Currently, allocating constructors are never used. \n \n-   We also need to provide unique mangled names (which should never be\n-   exported) for the constructor that takes an in-charge parameter,\n-   and for a constructor whose name is the same as its class's name.\n-   We use \"C*INTERNAL*\" for these.  */\n+   We also need to provide mangled names for the maybe-in-charge\n+   constructor, so we treat it here too.  mangle_decl_string will\n+   append *INTERNAL* to that, to make sure we never emit it.  */\n \n static void\n write_special_name_constructor (ctor)\n@@ -1190,15 +1189,15 @@ write_special_name_constructor (ctor)\n }\n \n /* Handle destructor productions of non-terminal <special-name>.\n-   DTOR is a denstructor FUNCTION_DECL. \n+   DTOR is a destructor FUNCTION_DECL. \n \n      <special-name> ::= D0 # deleting (in-charge) destructor\n                     ::= D1 # complete object (in-charge) destructor\n-                    ::= D2 # base object (not-in-charge) destructor \n+                    ::= D2 # base object (not-in-charge) destructor\n \n-   We also need to provide unique mngled names for old-ABI\n-   destructors, sometimes.  These should only be used internally.  We\n-   use \"D*INTERNAL*\" for these.  */\n+   We also need to provide mangled names for the maybe-incharge\n+   destructor, so we treat it here too.  mangle_decl_string will\n+   append *INTERNAL* to that, to make sure we never emit it.  */\n \n static void\n write_special_name_destructor (dtor)"}, {"sha": "6e32ed3821f855cff3da02794ee450453f426c58", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -130,8 +130,7 @@ build_headof (exp)\n   /* We use this a couple of times below, protect it.  */\n   exp = save_expr (exp);\n \n-  /* Under the new ABI, the offset-to-top field is at index -2 from\n-     the vptr.  */\n+  /* The offset-to-top field is at index -2 from the vptr.  */\n   index = build_int_2 (-2, -1);\n \n   aref = build_vtbl_ref (build_indirect_ref (exp, NULL), index);\n@@ -452,36 +451,12 @@ get_base_offset (binfo, parent)\n {\n   if (! TREE_VIA_VIRTUAL (binfo))\n     return BINFO_OFFSET (binfo);\n-  else if (! vbase_offsets_in_vtable_p ())\n-    {\n-      const char *name;\n-      tree result;\n-      tree field;\n-    \n-      FORMAT_VBASE_NAME (name, BINFO_TYPE (binfo));\n-      field = lookup_field (parent, get_identifier (name), 0, 0);\n-      result = byte_position (field);\n-      \n-      if (DECL_CONTEXT (field) != parent)\n-        {\n-          /* The vbase pointer might be in a non-virtual base of PARENT.\n-           * Adjust for the offset of that base in PARENT.  */\n-          tree path;\n-          \n-          get_base_distance (DECL_CONTEXT (field), parent, -1, &path);\n-          result = build (PLUS_EXPR, TREE_TYPE (result),\n-                          result, BINFO_OFFSET (path));\n-          result = fold (result);\n-        }\n-      return result;\n-    }\n   else\n-    /* Under the new ABI, we store the vtable offset at which\n-       the virtual base offset can be found.  */\n+    /* We store the vtable offset at which the virtual base offset can\n+       be found.  */\n     return convert (sizetype,\n \t\t    BINFO_VPTR_FIELD (binfo_for_vbase (BINFO_TYPE (binfo),\n \t\t\t\t\t\t       parent)));\n-\n }\n \n /* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working\n@@ -833,8 +808,8 @@ tinfo_base_init (desc, target)\n     DECL_EXTERNAL (name_decl) = 0;\n     TREE_PUBLIC (name_decl) = 1;\n     comdat_linkage (name_decl);\n-    /* The new ABI specifies the external name of the string\n-       containing the type's name.  */\n+    /* External name of the string containing the type's name has a\n+       special name.  */\n     SET_DECL_ASSEMBLER_NAME (name_decl,\n \t\t\t     mangle_typeinfo_string_for_type (target));\n     DECL_INITIAL (name_decl) = name_string;\n@@ -1295,8 +1270,7 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n   vtable_decl = get_vtable_decl (real_type, /*complete=*/1);\n   vtable_decl = build_unary_op (ADDR_EXPR, vtable_decl, 0);\n \n-  /* Under the new ABI, we need to point into the middle of the\n-     vtable.  */\n+  /* We need to point into the middle of the vtable.  */\n   vtable_decl = build (PLUS_EXPR,\n \t\t       TREE_TYPE (vtable_decl),\n \t\t       vtable_decl,"}, {"sha": "87157ba83bd8caf680d67ab31ce262c3afe819f2", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -102,7 +102,6 @@ static tree marked_pushdecls_p PARAMS ((tree, void *));\n static tree unmarked_pushdecls_p PARAMS ((tree, void *));\n static tree dfs_debug_unmarkedp PARAMS ((tree, void *));\n static tree dfs_debug_mark PARAMS ((tree, void *));\n-static tree dfs_init_vbase_pointers PARAMS ((tree, void *));\n static tree dfs_get_vbase_types PARAMS ((tree, void *));\n static tree dfs_push_type_decls PARAMS ((tree, void *));\n static tree dfs_push_decls PARAMS ((tree, void *));\n@@ -140,7 +139,6 @@ static tree get_shared_vbase_if_not_primary PARAMS ((tree, void *));\n static tree dfs_find_vbase_instance PARAMS ((tree, void *));\n static tree dfs_get_pure_virtuals PARAMS ((tree, void *));\n static tree dfs_build_inheritance_graph_order PARAMS ((tree, void *));\n-static tree dfs_vtable_path_unmark PARAMS ((tree, void *));\n \n /* Allocate a level of searching.  */\n \n@@ -2335,108 +2333,6 @@ dfs_unmark (binfo, data)\n }\n \n \f\n-static tree\n-dfs_init_vbase_pointers (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  struct vbase_info *vi = (struct vbase_info *) data;\n-  tree type = BINFO_TYPE (binfo);\n-  tree fields;\n-  tree this_vbase_ptr;\n-\n-  /* Don't initialize the same base more than once.  */\n-  SET_BINFO_VTABLE_PATH_MARKED (binfo);\n-\n-  /* We know that VI->DECL_PTR points to the complete object.  So,\n-     finding a pointer to this subobject is easy.  */\n-  this_vbase_ptr = build (PLUS_EXPR,\n-\t\t\t  build_pointer_type (type),\n-\t\t\t  vi->decl_ptr,\n-\t\t\t  BINFO_OFFSET (binfo));\n-\n-  /* We're going to iterate through all the pointers to virtual\n-     base-classes.  They come at the beginning of the class.  */\n-  fields = TYPE_FIELDS (type);\n-\n-  if (fields == NULL_TREE\n-      || DECL_NAME (fields) == NULL_TREE\n-      || ! VBASE_NAME_P (DECL_NAME (fields)))\n-    return NULL_TREE;\n-\n-  if (build_pointer_type (type) \n-      != TYPE_MAIN_VARIANT (TREE_TYPE (this_vbase_ptr)))\n-    my_friendly_abort (125);\n-\n-  while (fields && DECL_NAME (fields) && VBASE_NAME_P (DECL_NAME (fields)))\n-    {\n-      tree ref = build (COMPONENT_REF, TREE_TYPE (fields),\n-\t\t\tbuild_indirect_ref (this_vbase_ptr, NULL), fields);\n-      tree init;\n-      tree vbase_type;\n-      tree vbase_binfo;\n-\n-      vbase_type = TREE_TYPE (TREE_TYPE (fields));\n-      vbase_binfo = binfo_for_vbase (vbase_type, vi->type);\n-      init = build (PLUS_EXPR, \n-\t\t    build_pointer_type (vbase_type),\n-\t\t    vi->decl_ptr,\n-\t\t    BINFO_OFFSET (vbase_binfo));\n-      vi->inits \n-\t= tree_cons (vbase_binfo,\n-\t\t     build_modify_expr (ref, NOP_EXPR, init),\n-\t\t     vi->inits);\n-      fields = TREE_CHAIN (fields);\n-    }\n-  \n-  return NULL_TREE;\n-}\n-\n-/* Call CLEAR_BINFO_VTABLE_PATH_MARKED for BINFO.  */\n-\n-static tree\n-dfs_vtable_path_unmark (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n-  return NULL_TREE;\n-}\n-\n-tree\n-init_vbase_pointers (type, decl_ptr)\n-     tree type;\n-     tree decl_ptr;\n-{\n-  my_friendly_assert (!vbase_offsets_in_vtable_p (), 20000516);\n-\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-    {\n-      struct vbase_info vi;\n-      tree binfo = TYPE_BINFO (type);\n-\n-      /* Find all the virtual base classes, marking them for later\n-\t initialization.  */\n-      vi.type = type;\n-      vi.decl_ptr = decl_ptr;\n-      vi.inits = NULL_TREE;\n-\n-      /* Build up a list of the initializers.  */\n-      dfs_walk_real (binfo, \n-\t\t     dfs_init_vbase_pointers, 0,\n-\t\t     unmarked_vtable_pathp,\n-\t\t     &vi);\n-      dfs_walk (binfo,\n-\t\tdfs_vtable_path_unmark,\n-\t\tmarked_vtable_pathp,\n-\t\tNULL);\n-\n-      return vi.inits;\n-    }\n-\n-  return 0;\n-}\n-\n /* get the virtual context (the vbase that directly contains the\n    DECL_CONTEXT of the FNDECL) that the given FNDECL is declared in,\n    or NULL_TREE if there is none."}, {"sha": "a5857aa3971edea39d8b4795623a37393f781fe5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -2337,7 +2337,7 @@ emit_associated_thunks (fn)\n      is so that you can know statically the entire set of thunks that\n      will ever be needed for a given virtual function, thereby\n      enabling you to output all the thunks with the function itself.  */\n-  if (vcall_offsets_in_vtable_p () && DECL_VIRTUAL_P (fn))\n+  if (DECL_VIRTUAL_P (fn))\n     {\n       tree binfo;\n       tree v;\n@@ -2403,8 +2403,8 @@ expand_body (fn)\n \t\t\t\tsimplify_aggr_init_exprs_r,\n \t\t\t\tNULL);\n \n-  /* If this is a constructor or destructor body, we have to clone it\n-     under the new ABI.  */\n+  /* If this is a constructor or destructor body, we have to clone\n+     it.  */\n   if (maybe_clone_body (fn))\n     {\n       /* We don't want to process FN again, so pretend we've written"}, {"sha": "9db741c38d8f5c5c065979e7e83a9854c6feb055", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3461fba7ad8292cc6bbf62d4cf0e0f8038137a30/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3461fba7ad8292cc6bbf62d4cf0e0f8038137a30", "patch": "@@ -6105,8 +6105,7 @@ build_ptrmemfunc (type, pfn, force)\n \t  delta = build_component_ref (pfn, delta_identifier, NULL_TREE, 0);\n \t}\n \n-      /* Under the new ABI, the conversion is easy.  Just adjust\n-\t the DELTA field.  */\n+      /* Just adjust the DELTA field.  */\n       delta = cp_convert (ptrdiff_type_node, delta);\n       if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_delta)\n \tn = cp_build_binary_op (LSHIFT_EXPR, n, integer_one_node);\n@@ -6171,10 +6170,9 @@ expand_ptrmemfunc_cst (cst, delta, pfn)\n       *delta = fold (build (PLUS_EXPR, TREE_TYPE (*delta),\n \t\t\t    *delta, BINFO_OFFSET (binfo)));\n \n-      /* Under the new ABI, we set PFN to the vtable offset at\n-\t which the function can be found, plus one (unless\n-\t ptrmemfunc_vbit_in_delta, in which case delta is shifted\n-\t left, and then incremented).  */\n+      /* We set PFN to the vtable offset at which the function can be\n+\t found, plus one (unless ptrmemfunc_vbit_in_delta, in which\n+\t case delta is shifted left, and then incremented).  */\n       *pfn = DECL_VINDEX (fn);\n       *pfn = fold (build (MULT_EXPR, integer_type_node, *pfn,\n \t\t\t  TYPE_SIZE_UNIT (vtable_entry_type)));"}]}