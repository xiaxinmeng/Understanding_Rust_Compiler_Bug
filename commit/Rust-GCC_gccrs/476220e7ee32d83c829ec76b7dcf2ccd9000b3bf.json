{"sha": "476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc2MjIwZTdlZTMyZDgzYzgyOWVjNzZiN2RjZjJjY2Q5MDAwYjNiZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-05-21T07:35:05Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-05-21T07:35:05Z"}, "message": "re PR fortran/25746 (Elemental assignment gives wrong result)\n\n2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25746\n\t* interface.c (gfc_extend_assign): Use new code EXEC_ASSIGN_CALL.\n\t* gfortran.h : Put EXEC_ASSIGN_CALL in enum.\n\t* trans-stmt.c (gfc_conv_elemental_dependencies): New function.\n\t(gfc_trans_call): Call it.  Add new boolian argument to flag\n\tneed for dependency checking. Assert intent OUT and IN for arg1\n\tand arg2.\n\t(gfc_trans_forall_1): Use new code EXEC_ASSIGN_CALL.\n\ttrans-stmt.h : Modify prototype of gfc_trans_call.\n\ttrans.c (gfc_trans_code): Add call for EXEC_ASSIGN_CALL.\n\tst.c (gfc_free_statement): Free actual for EXEC_ASSIGN_CALL.\n\t* dependency.c (gfc_check_fncall_dependency): Don't check other\n\tagainst itself.\n\n\tPR fortran/25090\n\t* resolve.c : Remove resolving_index_expr.\n\t(entry_parameter): Remove.\n\t(gfc_resolve_expr, resolve_charlen, resolve_fl_variable): Remove\n\tcalls to entry_parameter and references to resolving_index_expr.\n\n\tPR fortran/27584\n\t* check.c (gfc_check_associated): Replace NULL assert with an\n\terror message, since it is possible to generate bad code that\n\thas us fall through to here..\n\n\tPR fortran/19015\n\t* iresolve.c (maxloc, minloc): If DIM is not present, pass the\n\trank of ARRAY as the shape of the result.  Otherwise, pass the\n\tshape of ARRAY, less the dimension DIM.\n\t(maxval, minval): The same, when DIM is present, otherwise no\n\tchange.\n\n2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25746\n\t* gfortran.dg/elemental_subroutine_3.f90: New test.\n\n\tPR fortran/25090\n\t* gfortran.dg/entry_dummy_ref_1.f90: Remove.\n\n\tPR fortran/27584\n\t* gfortran.dg/associated_target_1.f90: New test.\n\n\tPR fortran/19015\n\t* gfortran.dg/maxloc_shape_1.f90: New test.\n\nFrom-SVN: r113949", "tree": {"sha": "878bb615e69fdec9b7bc4f6adf7213bd3d53693f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/878bb615e69fdec9b7bc4f6adf7213bd3d53693f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/comments", "author": null, "committer": null, "parents": [{"sha": "80980ba989e054549ac5172f1d95cd0d8c247ab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80980ba989e054549ac5172f1d95cd0d8c247ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80980ba989e054549ac5172f1d95cd0d8c247ab6"}], "stats": {"total": 443, "additions": 350, "deletions": 93}, "files": [{"sha": "7e98c4677d1584201834b771d567495545e32e1b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -1,3 +1,37 @@\n+2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25746\n+\t* interface.c (gfc_extend_assign): Use new EXEC_ASSIGN_CALL.\n+\t* gfortran.h : Put EXEC_ASSIGN_CALL in enum.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies): New function.\n+\t(gfc_trans_call): Call it.  Add new boolian argument to flag\n+\tneed for dependency checking. Assert intent OUT and IN for arg1\n+\tand arg2.\n+\t(gfc_trans_forall_1): Use new code EXEC_ASSIGN_CALL.\n+\ttrans-stmt.h : Modify prototype of gfc_trans_call.\n+\ttrans.c (gfc_trans_code): Add call for EXEC_ASSIGN_CALL.\n+\tst.c (gfc_free_statement): Free actual for EXEC_ASSIGN_CALL.\n+\t* dependency.c (gfc_check_fncall_dependency): Don't check other\n+\tagainst itself.\n+\n+\tPR fortran/25090\n+\t* resolve.c : Remove resolving_index_expr.\n+\t(entry_parameter): Remove.\n+\t(gfc_resolve_expr, resolve_charlen, resolve_fl_variable): Lift\n+\tcalls to entry_parameter and references to resolving_index_expr.\n+\n+\tPR fortran/27584\n+\t* check.c (gfc_check_associated): Replace NULL assert with an\n+\terror message, since it is possible to generate bad code that\n+\thas us fall through to here..\n+\n+\tPR fortran/19015\n+\t* iresolve.c (maxloc, minloc): If DIM is not present, pass the\n+\trank of ARRAY as the shape of the result.  Otherwise, pass the\n+\tshape of ARRAY, less the dimension DIM.\n+\t(maxval, minval): The same, when DIM is present, otherwise no\n+\tchange.\n+\n 2006-05-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR fortran/27662\n@@ -64,7 +98,7 @@\n \t* resolve.c (resolve_code): Add error condition that the return\n \texpression must be scalar.\n \n-\tPR fortran/24711\n+\tPR fortran/27411\n \t* matchexp.c (gfc_get_parentheses): New function.\n \t(match_primary): Remove inline code and call above.\n \t* gfortran.h: Provide prototype for gfc_get_parentheses.\n@@ -244,7 +278,7 @@\n \tresult, is also automatic character length.  If so, process\n \tthe character length.\n \n-\tPR fortran/18803\n+\tPR fortran/18003\n \tPR fortran/25669\n \tPR fortran/26834\n \t* trans_intrinsic.c (gfc_walk_intrinsic_bound): Set"}, {"sha": "947bcdccc955a876f49f97d7d069140c1a8e0713", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -532,7 +532,12 @@ gfc_check_associated (gfc_expr * pointer, gfc_expr * target)\n   else if (target->expr_type == EXPR_FUNCTION)\n     attr = target->symtree->n.sym->attr;\n   else\n-    gcc_assert (0); /* Target must be a variable or a function.  */\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a pointer \"\n+\t\t \"or target VARIABLE or FUNCTION\", gfc_current_intrinsic_arg[1],\n+\t\t gfc_current_intrinsic, &target->where);\n+      return FAILURE;\n+    }\n \n   if (!attr.pointer && !attr.target)\n     {"}, {"sha": "28c6498d2b86c18b0a0029bf216151f5abebdef6", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -513,6 +513,10 @@ gfc_check_fncall_dependency (gfc_expr * other, sym_intent intent,\n       if (!expr)\n \tcontinue;\n \n+      /* Skip other itself.  */\n+      if (expr == other)\n+\tcontinue;\n+\n       /* Skip intent(in) arguments if OTHER itself is intent(in).  */\n       if (formal\n \t  && intent == INTENT_IN"}, {"sha": "d5b341133c79332b13961b337d1e7c2dc8845c2b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -1487,7 +1487,7 @@ gfc_forall_iterator;\n typedef enum\n {\n   EXEC_NOP = 1, EXEC_ASSIGN, EXEC_LABEL_ASSIGN, EXEC_POINTER_ASSIGN,\n-  EXEC_GOTO, EXEC_CALL, EXEC_RETURN, EXEC_ENTRY,\n+  EXEC_GOTO, EXEC_CALL, EXEC_ASSIGN_CALL, EXEC_RETURN, EXEC_ENTRY,\n   EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE,\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT,\n   EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT,"}, {"sha": "74f76697593a7cd4d4dd1ef115c5ba470d43aa40", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -1827,7 +1827,7 @@ gfc_extend_assign (gfc_code * c, gfc_namespace * ns)\n     }\n \n   /* Replace the assignment with the call.  */\n-  c->op = EXEC_CALL;\n+  c->op = EXEC_ASSIGN_CALL;\n   c->symtree = find_sym_in_symtree (sym);\n   c->expr = NULL;\n   c->expr2 = NULL;"}, {"sha": "3cf84db6f27a126ebd93a1f0a2bc034688e99fb8", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -1081,16 +1081,32 @@ gfc_resolve_maxloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t    gfc_expr * mask)\n {\n   const char *name;\n+  int i, j, idim;\n \n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n \n   if (dim == NULL)\n-    f->rank = 1;\n+    {\n+      f->rank = 1;\n+      f->shape = gfc_get_shape (1);\n+      mpz_init_set_si (f->shape[0], array->rank);\n+    }\n   else\n     {\n       f->rank = array->rank - 1;\n       gfc_resolve_dim_arg (dim);\n+      if (array->shape && dim->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  idim = (int) mpz_get_si (dim->value.integer);\n+\t  f->shape = gfc_get_shape (f->rank);\n+\t  for (i = 0, j = 0; i < f->rank; i++, j++)\n+\t    {\n+\t      if (i == (idim - 1))\n+\t        j++;\n+\t      mpz_init_set (f->shape[i], array->shape[j]);\n+\t    }\n+\t}\n     }\n \n   if (mask)\n@@ -1125,13 +1141,26 @@ gfc_resolve_maxval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t    gfc_expr * mask)\n {\n   const char *name;\n+  int i, j, idim;\n \n   f->ts = array->ts;\n \n   if (dim != NULL)\n     {\n       f->rank = array->rank - 1;\n       gfc_resolve_dim_arg (dim);\n+\n+      if (f->rank && array->shape && dim->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  idim = (int) mpz_get_si (dim->value.integer);\n+\t  f->shape = gfc_get_shape (f->rank);\n+\t  for (i = 0, j = 0; i < f->rank; i++, j++)\n+\t    {\n+\t      if (i == (idim - 1))\n+\t        j++;\n+\t      mpz_init_set (f->shape[i], array->shape[j]);\n+\t    }\n+\t}\n     }\n \n   if (mask)\n@@ -1188,16 +1217,32 @@ gfc_resolve_minloc (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t    gfc_expr * mask)\n {\n   const char *name;\n+  int i, j, idim;\n \n   f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n \n   if (dim == NULL)\n-    f->rank = 1;\n+    {\n+      f->rank = 1;\n+      f->shape = gfc_get_shape (1);\n+      mpz_init_set_si (f->shape[0], array->rank);\n+    }\n   else\n     {\n       f->rank = array->rank - 1;\n       gfc_resolve_dim_arg (dim);\n+      if (array->shape && dim->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  idim = (int) mpz_get_si (dim->value.integer);\n+\t  f->shape = gfc_get_shape (f->rank);\n+\t  for (i = 0, j = 0; i < f->rank; i++, j++)\n+\t    {\n+\t      if (i == (idim - 1))\n+\t        j++;\n+\t      mpz_init_set (f->shape[i], array->shape[j]);\n+\t    }\n+\t}\n     }\n \n   if (mask)\n@@ -1232,13 +1277,26 @@ gfc_resolve_minval (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t    gfc_expr * mask)\n {\n   const char *name;\n+  int i, j, idim;\n \n   f->ts = array->ts;\n \n   if (dim != NULL)\n     {\n       f->rank = array->rank - 1;\n       gfc_resolve_dim_arg (dim);\n+\n+      if (f->rank && array->shape && dim->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  idim = (int) mpz_get_si (dim->value.integer);\n+\t  f->shape = gfc_get_shape (f->rank);\n+\t  for (i = 0, j = 0; i < f->rank; i++, j++)\n+\t    {\n+\t      if (i == (idim - 1))\n+\t        j++;\n+\t      mpz_init_set (f->shape[i], array->shape[j]);\n+\t    }\n+\t}\n     }\n \n   if (mask)"}, {"sha": "0affecc06a2e2e9e368fee4c013dc52f693775dd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 64, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -60,9 +60,6 @@ static int omp_workshare_flag;\n    resets the flag each time that it is read.  */\n static int formal_arg_flag = 0;\n \n-/* True if we are resolving a specification expression.  */\n-static int resolving_index_expr = 0;\n-\n int\n gfc_is_formal_arg (void)\n {\n@@ -2683,43 +2680,6 @@ resolve_variable (gfc_expr * e)\n }\n \n \n-/* Emits an error if the expression is a variable that is not a parameter\n-   in all entry formal argument lists for the namespace.  */\n-\n-static void\n-entry_parameter (gfc_expr *e)\n-{\n-  gfc_symbol *sym, *esym;\n-  gfc_entry_list *entry;\n-  gfc_formal_arglist *f;\n-  bool p;\n-\n-\n-  sym = e->symtree->n.sym;\n-\n-  if (sym->attr.use_assoc\n-\t|| !sym->attr.dummy\n-\t|| sym->ns != gfc_current_ns)\n-    return;\n-\n-  entry = sym->ns->entries;\n-  for (; entry; entry = entry->next)\n-    {\n-      esym = entry->sym;\n-      p = false;\n-      for (f = esym->formal; f && !p; f = f->next)\n-\t{\n-\t  if (f->sym && f->sym->name && sym->name == f->sym->name)\n-\t    p = true;\n-\t}\n-      if (!p)\n-\tgfc_error (\"%s at %L must be a parameter of the entry at %L\",\n-\t\t   sym->name, &e->where, &esym->declared_at);\n-    }\n-  return;\n-}\n-\n-\n /* Resolve an expression.  That is, make sure that types of operands agree\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n@@ -2744,10 +2704,6 @@ gfc_resolve_expr (gfc_expr * e)\n \n     case EXPR_VARIABLE:\n       t = resolve_variable (e);\n-\n-      if (gfc_current_ns->entries && resolving_index_expr)\n-\tentry_parameter (e);\n-\n       if (t == SUCCESS)\n \texpression_rank (e);\n       break;\n@@ -4699,6 +4655,7 @@ resolve_values (gfc_symbol * sym)\n static try\n resolve_index_expr (gfc_expr * e)\n {\n+\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n@@ -4721,12 +4678,9 @@ resolve_charlen (gfc_charlen *cl)\n \n   cl->resolved = 1;\n \n-  resolving_index_expr = 1;\n-\n   if (resolve_index_expr (cl->length) == FAILURE)\n     return FAILURE;\n \n-  resolving_index_expr = 0;\n   return SUCCESS;\n }\n \n@@ -4813,29 +4767,20 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   if (resolve_fl_var_and_proc (sym, mp_flag) == FAILURE)\n     return FAILURE;\n \n-  /* Set this flag to check that variables are parameters of all entries.\n-     This check is effected by the call to gfc_resolve_expr through\n-     is_non_contant_shape_array.  */\n-  resolving_index_expr = 1;\n-\n-  if (!sym->attr.use_assoc\n+  /* The shape of a main program or module array needs to be constant.  */\n+  if (sym->ns->proc_name\n+\t&& (sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t     || sym->ns->proc_name->attr.is_main_program)\n+\t&& !sym->attr.use_assoc\n \t&& !sym->attr.allocatable\n \t&& !sym->attr.pointer\n \t&& is_non_constant_shape_array (sym))\n     {\n-\t/* The shape of a main program or module array needs to be constant.  */\n-\tif (sym->ns->proc_name\n-\t      && (sym->ns->proc_name->attr.flavor == FL_MODULE\n-\t\t    || sym->ns->proc_name->attr.is_main_program))\n-\t  {\n-\t    gfc_error (\"The module or main program array '%s' at %L must \"\n-\t\t       \"have constant shape\", sym->name, &sym->declared_at);\n-\t    return FAILURE;\n-\t  }\n+       gfc_error (\"The module or main program array '%s' at %L must \"\n+\t\t     \"have constant shape\", sym->name, &sym->declared_at);\n+\t  return FAILURE;\n     }\n \n-  resolving_index_expr = 0;\n-\n   if (sym->ts.type == BT_CHARACTER)\n     {\n       /* Make sure that character string variables with assumed length are"}, {"sha": "cc866872a08cda5c89ea41eec90aa0eeecf71558", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -112,6 +112,7 @@ gfc_free_statement (gfc_code * p)\n       break;\n \n     case EXEC_CALL:\n+    case EXEC_ASSIGN_CALL:\n       gfc_free_actual_arglist (p->ext.actual);\n       break;\n "}, {"sha": "ab7d5a5eb6075667ee10877730424a97634565d5", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 131, "deletions": 5, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -199,10 +199,121 @@ gfc_trans_entry (gfc_code * code)\n }\n \n \n+/* Check for dependencies between INTENT(IN) and INTENT(OUT) arguments of\n+   elemental subroutines.  Make temporaries for output arguments if any such\n+   dependencies are found.  Output arguments are chosen because internal_unpack\n+   can be used, as is, to copy the result back to the variable.  */\n+static void\n+gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n+\t\t\t\t gfc_symbol * sym, gfc_actual_arglist * arg)\n+{\n+  gfc_actual_arglist *arg0;\n+  gfc_expr *e;\n+  gfc_formal_arglist *formal;\n+  gfc_loopinfo tmp_loop;\n+  gfc_se parmse;\n+  gfc_ss *ss;\n+  gfc_ss_info *info;\n+  gfc_symbol *fsym;\n+  int n;\n+  stmtblock_t block;\n+  tree data;\n+  tree offset;\n+  tree size;\n+  tree tmp;\n+\n+  if (loopse->ss == NULL)\n+    return;\n+\n+  ss = loopse->ss;\n+  arg0 = arg;\n+  formal = sym->formal;\n+\n+  /* Loop over all the arguments testing for dependencies.  */\n+  for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n+    {\n+      e = arg->expr;\n+      if (e == NULL)\n+\tcontinue;\n+\n+      /* Obtain the info structure for the current argument.  */ \n+      info = NULL;\n+      for (ss = loopse->ss; ss && ss != gfc_ss_terminator; ss = ss->next)\n+\t{\n+\t  if (ss->expr != e)\n+\t    continue;\n+\t  info = &ss->data.info;\n+\t  break;\n+\t}\n+\n+      /* If there is a dependency, create a temporary and use it\n+\t instead of the variable. */\n+      fsym = formal ? formal->sym : NULL;\n+      if (e->expr_type == EXPR_VARIABLE\n+\t    && e->rank && fsym\n+\t    && fsym->attr.intent == INTENT_OUT\n+\t    && gfc_check_fncall_dependency (e, INTENT_OUT, sym, arg0))\n+\t{\n+\t  /* Make a local loopinfo for the temporary creation, so that\n+\t     none of the other ss->info's have to be renormalized.  */\n+\t  gfc_init_loopinfo (&tmp_loop);\n+\t  for (n = 0; n < info->dimen; n++)\n+\t    {\n+\t      tmp_loop.to[n] = loopse->loop->to[n];\n+\t      tmp_loop.from[n] = loopse->loop->from[n];\n+\t      tmp_loop.order[n] = loopse->loop->order[n];\n+\t    }\n+\n+\t  /* Generate the temporary.  Merge the block so that the\n+\t     declarations are put at the right binding level.  */\n+\t  size = gfc_create_var (gfc_array_index_type, NULL);\n+\t  data = gfc_create_var (pvoid_type_node, NULL);\n+\t  gfc_start_block (&block);\n+\t  tmp = gfc_typenode_for_spec (&e->ts);\n+\t  tmp = gfc_trans_create_temp_array (&se->pre, &se->post,\n+\t\t\t\t\t      &tmp_loop, info, tmp,\n+\t\t\t\t\t      false, true, false);\n+\t  gfc_add_modify_expr (&se->pre, size, tmp);\n+\t  tmp = fold_convert (pvoid_type_node, info->data);\n+\t  gfc_add_modify_expr (&se->pre, data, tmp);\n+\t  gfc_merge_block_scope (&block);\n+\n+\t  /* Obtain the argument descriptor for unpacking.  */\n+\t  gfc_init_se (&parmse, NULL);\n+\t  parmse.want_pointer = 1;\n+\t  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));\n+\t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n+\n+\t  /* Calculate the offset for the temporary.  */\n+\t  offset = gfc_index_zero_node;\n+\t  for (n = 0; n < info->dimen; n++)\n+\t    {\n+\t      tmp = gfc_conv_descriptor_stride (info->descriptor,\n+\t\t\t\t\t\tgfc_rank_cst[n]);\n+\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t loopse->loop->from[n], tmp);\n+\t      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t\t  offset, tmp);\n+\t    }\n+\t  info->offset = gfc_create_var (gfc_array_index_type, NULL);\t  \n+\t  gfc_add_modify_expr (&se->pre, info->offset, offset);\n+\n+\t  /* Copy the result back using unpack.  */\n+\t  tmp = gfc_chainon_list (NULL_TREE, parmse.expr);\n+\t  tmp = gfc_chainon_list (tmp, data);\n+\t  tmp = build_function_call_expr (gfor_fndecl_in_unpack, tmp);\n+\t  gfc_add_expr_to_block (&se->post, tmp);\n+\n+\t  gfc_add_block_to_block (&se->post, &parmse.post);\n+\t}\n+    }\n+}\n+\n+\n /* Translate the CALL statement.  Builds a call to an F95 subroutine.  */\n \n tree\n-gfc_trans_call (gfc_code * code)\n+gfc_trans_call (gfc_code * code, bool dependency_check)\n {\n   gfc_se se;\n   gfc_ss * ss;\n@@ -269,11 +380,25 @@ gfc_trans_call (gfc_code * code)\n       gfc_conv_loop_setup (&loop);\n       gfc_mark_ss_chain_used (ss, 1);\n \n+      /* Convert the arguments, checking for dependencies.  */\n+      gfc_copy_loopinfo_to_se (&loopse, &loop);\n+      loopse.ss = ss;\n+\n+      /* For operator assignment, we need to do dependency checking.  \n+\t We also check the intent of the parameters.  */\n+      if (dependency_check)\n+\t{\n+\t  gfc_symbol *sym;\n+\t  sym = code->resolved_sym;\n+\t  gcc_assert (sym->formal->sym->attr.intent = INTENT_OUT);\n+\t  gcc_assert (sym->formal->next->sym->attr.intent = INTENT_IN);\n+\t  gfc_conv_elemental_dependencies (&se, &loopse, sym,\n+\t\t\t\t\t   code->ext.actual);\n+\t}\n+\n       /* Generate the loop body.  */\n       gfc_start_scalarized_body (&loop, &body);\n       gfc_init_block (&block);\n-      gfc_copy_loopinfo_to_se (&loopse, &loop);\n-      loopse.ss = ss;\n \n       /* Add the subroutine call to the block.  */\n       gfc_conv_function_call (&loopse, code->resolved_sym, code->ext.actual);\n@@ -287,6 +412,7 @@ gfc_trans_call (gfc_code * code)\n       gfc_trans_scalarizing_loops (&loop, &body);\n       gfc_add_block_to_block (&se.pre, &loop.pre);\n       gfc_add_block_to_block (&se.pre, &loop.post);\n+      gfc_add_block_to_block (&se.pre, &se.post);\n       gfc_cleanup_loop (&loop);\n     }\n \n@@ -2539,8 +2665,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n \t/* Explicit subroutine calls are prevented by the frontend but interface\n \t   assignments can legitimately produce them.  */\n-\tcase EXEC_CALL:\n-\t  assign = gfc_trans_call (c);\n+\tcase EXEC_ASSIGN_CALL:\n+\t  assign = gfc_trans_call (c, true);\n           tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1, 1);\n           gfc_add_expr_to_block (&block, tmp);\n           break;"}, {"sha": "e30cb23fd118f2c98137bf5256022d44d21ee4b2", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -38,7 +38,7 @@ tree gfc_trans_goto (gfc_code *);\n tree gfc_trans_entry (gfc_code *);\n tree gfc_trans_pause (gfc_code *);\n tree gfc_trans_stop (gfc_code *);\n-tree gfc_trans_call (gfc_code *);\n+tree gfc_trans_call (gfc_code *, bool);\n tree gfc_trans_return (gfc_code *);\n tree gfc_trans_if (gfc_code *);\n tree gfc_trans_arithmetic_if (gfc_code *);"}, {"sha": "3eec75c3444103dc60717c93d36f66bf301c40fc", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -494,7 +494,11 @@ gfc_trans_code (gfc_code * code)\n \t  break;\n \n \tcase EXEC_CALL:\n-\t  res = gfc_trans_call (code);\n+\t  res = gfc_trans_call (code, false);\n+\t  break;\n+\n+\tcase EXEC_ASSIGN_CALL:\n+\t  res = gfc_trans_call (code, true);\n \t  break;\n \n \tcase EXEC_RETURN:"}, {"sha": "d1441069635151247b462ecde99e2bc402a16802", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -1,3 +1,17 @@\n+2006-05-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25746\n+\t* gfortran.dg/elemental_subroutine_3.f90: New test.\n+\n+\tPR fortran/25090\n+\t* gfortran.dg/entry_dummy_ref_1.f90: Remove.\n+\n+\tPR fortran/27584\n+\t* gfortran.dg/associated_target_1.f90: New test.\n+\n+\tPR fortran/19015\n+\t* gfortran.dg/maxloc_shape_1.f90: New test.\n+\n 2006-05-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/24459\n@@ -147,7 +161,7 @@\n \tPR fortran/25082\n \t* gfortran.dg/scalar_return_1.f90: New test.\n \n-\tPR fortran/24711\n+\tPR fortran/27411\n \t* gfortran.dg/derived_comp_array_ref_1.f90: New test.\n \n 2006-05-15  Jakub Jelinek  <jakub@redhat.com>\n@@ -814,7 +828,7 @@\n \tPR fortran/27089\n \t* gfortran.dg/specification_type_resolution_1.f90\n \n-\tPR fortran/18803\n+\tPR fortran/18003\n \tPR fortran/25669\n \tPR fortran/26834\n \t* gfortran.dg/bounds_temporaries_1.f90: New test."}, {"sha": "13df47023c8af71ecc8f2fde836a1100325b2bed", "filename": "gcc/testsuite/gfortran.dg/associated_target_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociated_target_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociated_target_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociated_target_1.f90?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! This tests the patch for PR27584, where an ICE would ensue if\n+! a bad argument was fed for the target in ASSOCIATED.\n+!\n+! Contributed by Tobias Burnus  <tobias.burnus@physik.fu-berlin.de>\n+!\n+program test\n+   implicit none\n+   real, pointer :: x\n+   real, target :: y\n+   if(ASSOCIATED(X,(Y))) print *, 'Hello' ! { dg-error \"VARIABLE or FUNCTION\" }\n+end program test"}, {"sha": "138a46c658e884d1a0e8936fa0f980d7a4462c3e", "filename": "gcc/testsuite/gfortran.dg/elemental_subroutine_3.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_3.f90?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run }\n+! Test the fix for PR25746, in which dependency checking was not being\n+! done for elemental subroutines and therefore for interface assignments.\n+!\n+! This test is based on\n+! http://home.comcast.net/~kmbtib/Fortran_stuff/elem_assign.f90\n+! as reported by Harald Anlauf <anlauf@gmx.de> in the PR.\n+! \n+module elem_assign\n+   implicit none\n+   type mytype\n+      integer x\n+   end type mytype\n+   interface assignment(=)\n+      module procedure myassign\n+   end interface assignment(=)\n+   contains\n+      elemental subroutine myassign(x,y)\n+         type(mytype), intent(out) :: x\n+         type(mytype), intent(in) :: y\n+! Multiply the components by 2 to verify that this is being called.\n+         x%x = y%x*2\n+      end subroutine myassign\n+end module elem_assign\n+\n+program test\n+   use elem_assign\n+   implicit none\n+   type(mytype) :: y(6), x(6) = (/mytype(1),mytype(20),mytype(300),&\n+                                  mytype(4000),mytype(50000),&\n+\t\t\t\t  mytype(1000000)/)\n+   type(mytype) :: z(2, 3)\n+! The original case - dependency between lhs and rhs. \n+   x = x((/2,3,1,4,5,6/))\n+   if (any(x%x .ne. (/40, 600, 2, 8000, 100000, 2000000/))) call abort ()\n+! Slightly more elborate case with non-trivial array ref on lhs.\n+   x(4:1:-1) = x((/1,3,2,4/))\n+   if (any(x%x .ne. (/16000, 1200, 4, 80, 100000, 2000000/))) call abort ()\n+! Check that no-dependence case works....\n+   y = x\n+   if (any(y%x .ne. (/32000, 2400, 8, 160, 200000, 4000000/))) call abort ()\n+! ...and now a case that caused headaches during the preparation of the patch\n+   x(2:5) = x(1:4)\n+   if (any(x%x .ne. (/16000, 32000, 2400, 8, 160, 2000000/))) call abort ()\n+! Check offsets are done correctly in multi-dimensional cases\n+   z = reshape (x, (/2,3/))\n+   z(:, 3:2:-1) = z(:, 1:2)\n+   y = reshape (z, (/6/))\n+   if (any(y%x .ne. (/ 64000, 128000, 19200, 64, 128000, 256000/))) call abort ()\n+end program test\n+\n+! { dg-final { cleanup-modules \"elem_assign\" } }\n+"}, {"sha": "c6ee1cc606013699a3fc3fed8e6cdbfea95509bc", "filename": "gcc/testsuite/gfortran.dg/entry_dummy_ref_1.f90", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80980ba989e054549ac5172f1d95cd0d8c247ab6/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80980ba989e054549ac5172f1d95cd0d8c247ab6/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_dummy_ref_1.f90?ref=80980ba989e054549ac5172f1d95cd0d8c247ab6", "patch": "@@ -1,13 +0,0 @@\n-! { dg-do compile }\n-! Tests fix for PR25090 in which references in specification\n-! expressions to variables that were not entry formal arguments\n-! would be missed.\n-!\n-! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>\n-!\n-   SUBROUTINE S1(I) ! { dg-error \"must be a parameter of the entry\" }\n-   CHARACTER(LEN=I+J) :: a ! { dg-error \"must be a parameter of the entry\" }\n-   real :: x(i:j) ! { dg-error \"must be a parameter of the entry\" }\n-   ENTRY E1(J) ! { dg-error \"must be a parameter of the entry\" }\n-   END SUBROUTINE S1\n-   END"}, {"sha": "69f5866d0e724b1a6f52d5b1b634878f1a8b0b20", "filename": "gcc/testsuite/gfortran.dg/maxloc_shape_1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_shape_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/476220e7ee32d83c829ec76b7dcf2ccd9000b3bf/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_shape_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmaxloc_shape_1.f90?ref=476220e7ee32d83c829ec76b7dcf2ccd9000b3bf", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! Tests the implementation of compile-time shape testing, required to fix\n+! PR19015.  The functionality of maxloc and friends is tested by existing\n+! testcases.\n+!\n+! Contributed by Thomas Koeing  <Thomas.Koenig@online.de>\n+!\n+  integer, dimension(0:1,0:1) :: n\n+  integer, dimension(1) :: i\n+  n = reshape((/1, 2, 3, 4/), shape(n))\n+  i = maxloc(n) ! { dg-error \"different shape for Array assignment\" }\n+  i = maxloc(n,dim=1) ! { dg-error \"different shape for Array assignment\" }\n+!  print *,i\n+end program"}]}