{"sha": "8456b95a5af348aa220ad0adc2101835f221f5d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ1NmI5NWE1YWYzNDhhYTIyMGFkMGFkYzIxMDE4MzVmMjIxZjVkMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-12-06T11:49:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-06T11:49:46Z"}, "message": "final.c (count_basic_block, [...]): Kill.\n\n\t* final.c (count_basic_block, add_bb, add_bb_string):\n\tKill.\n\t(end_final, final_start_function, final, final_scan_insn,\n\tleaf_function_p): Kill BB profiler related code.\n\t* flags.h (profile_block_flag): Kill.\n\t* libgcc2.c (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE,\n\tBB_BUCKETS, BBINBUFSIZE, bb_edge, bb_func_mode, bb_func,\n\t__bb, bb_src, bb_dst, bb_tracefile, bb_hashbuckets,\n\tbb_func_head, bb_callcount, bb_mode, bb_stack, bb_stacksize\n\treported, GOPENDECOMPRESS, GOPENCOMPRESS, gopen, gclose,\n\t__bb_exit_trace_func, __bb_init_prg, __bb_trace_func,\n\t__bb_trace_func_ret, __bb_init_file, __bb_trace_ret,\n\t__bb_init_trace_func): Kill.\n\t* toplev.c (profile_block_flag): Kill.\n\t(indepdendent_decode_option, process_options): Kill -a related code.\n\t* alpha.c (direct_call_operand): Likewise.\n\t* arm.c (arm_expand_prologue, thumb_expand_prologue,\n\tthumb_expand_epilogue): Likewise.\n\t* c4x.c (c4x_expand_prologue, c4x_null_epilogue_p): Likewise.\n\t* c4x.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* d30v.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* fr30.c (fr30_expand_prologue): Kill BB profiler related code.\n\t* i386.c (ix86_can_use_return_insn_p, ix86_expand_prologue,\n\tix86_expand_epilogue, ix86_expand_epilogue): Kill BB profiler related\n\tcode.\n\t(ix86_output_function_block_profiler, ix86_output_block_profiler): Kill.\n\t* i386.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* fr30.c (fr30_expand_prologue): Kill BB profiler related code.\n\t* i960.c (i960_output_function_prologue): Kill BB profiler related\n\tcode.\n\t* ia64.c (ia64_compute_frame_size): Likewise.\n\t* ia64.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* m32r.c (m32r_expand_prolofue): Kill BB profiler related code.\n\t* m68hc11.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* m68k.c (m68k_output_function_epilogue): Kill BB profiler related code.\n\t* m68k.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* m88k.c (output_options, m88k_layout_frame, m88k_expand_prologue):\n\tKill BB profiler related code.\n\t* m88k.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* mips.c (mips_expand_prologue): Kill BB profiler related code.\n\t* mmix.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* rs6000.c (rs6000_override_options): Kill BB profiler related code.\n\t* s960.c (s390_function_prologue): Kill BB profiler related code.\n\t* s960.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* linux-aout.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n\t* linux.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n\t* linux64.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n\t* sol2.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n\t* sparc.c (sparc_override_options, eligible_for_sibcall_delay,\n\tsparc_nonflat_function_epilogue): Kill BB profiler related code.\n\t(sparc_function_block_profiler, sparc_block_profiler,\n\tsparc_function_block_profiler_exit): Kill.\n\t* sparc.h (OVERRIDE_OPTIONS): Kill BB profiler related code.\n\t(FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* sun4o3.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n\t* sunos4.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n\t* stormy16.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\t* doc/invoke.texi: Kill documentation of -a and -ax.\n\t* tm.texi (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n\tMACHINE_STATE_RESTORE): Kill.\n\nFrom-SVN: r47712", "tree": {"sha": "487983e5d02cf99f65e621df94291838c8f26701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/487983e5d02cf99f65e621df94291838c8f26701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8456b95a5af348aa220ad0adc2101835f221f5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8456b95a5af348aa220ad0adc2101835f221f5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8456b95a5af348aa220ad0adc2101835f221f5d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8456b95a5af348aa220ad0adc2101835f221f5d3/comments", "author": null, "committer": null, "parents": [{"sha": "a39353e095675385b5fcc09039846eecf6383542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39353e095675385b5fcc09039846eecf6383542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a39353e095675385b5fcc09039846eecf6383542"}], "stats": {"total": 3711, "additions": 115, "deletions": 3596}, "files": [{"sha": "3dde901f9e654067dcf4ed05b318505a7b027122", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1,3 +1,89 @@\n+Thu Dec  6 12:45:33 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* final.c (count_basic_block, add_bb, add_bb_string):\n+\tKill.\n+\t(end_final, final_start_function, final, final_scan_insn,\n+\tleaf_function_p): Kill BB profiler related code.\n+\t* flags.h (profile_block_flag): Kill.\n+\t* libgcc2.c (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE,\n+\tBB_BUCKETS, BBINBUFSIZE, bb_edge, bb_func_mode, bb_func,\n+\t__bb, bb_src, bb_dst, bb_tracefile, bb_hashbuckets,\n+\tbb_func_head, bb_callcount, bb_mode, bb_stack, bb_stacksize\n+\treported, GOPENDECOMPRESS, GOPENCOMPRESS, gopen, gclose,\n+\t__bb_exit_trace_func, __bb_init_prg, __bb_trace_func,\n+\t__bb_trace_func_ret, __bb_init_file, __bb_trace_ret,\n+\t__bb_init_trace_func): Kill.\n+\t* toplev.c (profile_block_flag): Kill.\n+\t(indepdendent_decode_option, process_options): Kill -a related code.\n+\t* alpha.c (direct_call_operand): Likewise.\n+\t* arm.c (arm_expand_prologue, thumb_expand_prologue,\n+\tthumb_expand_epilogue): Likewise.\n+\t* c4x.c (c4x_expand_prologue, c4x_null_epilogue_p): Likewise.\n+\t* c4x.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* d30v.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* fr30.c (fr30_expand_prologue): Kill BB profiler related code.\n+\t* i386.c (ix86_can_use_return_insn_p, ix86_expand_prologue,\n+\tix86_expand_epilogue, ix86_expand_epilogue): Kill BB profiler related\n+\tcode.\n+\t(ix86_output_function_block_profiler, ix86_output_block_profiler): Kill.\n+\t* i386.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* fr30.c (fr30_expand_prologue): Kill BB profiler related code.\n+\t* i960.c (i960_output_function_prologue): Kill BB profiler related\n+\tcode.\n+\t* ia64.c (ia64_compute_frame_size): Likewise.\n+\t* ia64.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* m32r.c (m32r_expand_prolofue): Kill BB profiler related code.\n+\t* m68hc11.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* m68k.c (m68k_output_function_epilogue): Kill BB profiler related code.\n+\t* m68k.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* m88k.c (output_options, m88k_layout_frame, m88k_expand_prologue):\n+\tKill BB profiler related code.\n+\t* m88k.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* mips.c (mips_expand_prologue): Kill BB profiler related code.\n+\t* mmix.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* rs6000.c (rs6000_override_options): Kill BB profiler related code.\n+\t* s960.c (s390_function_prologue): Kill BB profiler related code.\n+\t* s960.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* linux-aout.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n+\t* linux.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n+\t* linux64.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n+\t* sol2.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n+\t* sparc.c (sparc_override_options, eligible_for_sibcall_delay,\n+\tsparc_nonflat_function_epilogue): Kill BB profiler related code.\n+\t(sparc_function_block_profiler, sparc_block_profiler,\n+\tsparc_function_block_profiler_exit): Kill.\n+\t* sparc.h (OVERRIDE_OPTIONS): Kill BB profiler related code.\n+\t(FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* sun4o3.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n+\t* sunos4.h (MACHINE_STATE_SAVE, MACHINE_STATE_RESTORE): Kill.\n+\t* stormy16.h (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\t* doc/invoke.texi: Kill documentation of -a and -ax.\n+\t* tm.texi (FUNCTION_BLOCK_PROFILER, BLOCK_PROFILER,\n+\tFUNCTION_BLOCK_PROFILER_EXIT, MACHINE_STATE_SAVE,\n+\tMACHINE_STATE_RESTORE): Kill.\n+\n 2001-10-26  Steve Christiansen  <smc@us.ibm.com>\n \n \t* doc/rtl.texi: Use a table to display RTL format characters."}, {"sha": "db5f943b39167d284a2c06050995f1862c6b881e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -875,7 +875,7 @@ direct_call_operand (op, mode)\n      but is approximately correct for the OSF ABIs.  Don't know\n      what to do for VMS, NT, or UMK.  */\n   if (! TARGET_PROFILING_NEEDS_GP\n-      && ! profile_flag && ! profile_block_flag)\n+      && ! profile_flag)\n     return 0;\n \n   return 1;"}, {"sha": "b7058b4801804dff82624fed1890a91e4f40f4b7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -8302,7 +8302,7 @@ arm_expand_prologue ()\n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  Similarly if the user has requested no\n      scheduling in the prolog.  */\n-  if (profile_flag || profile_block_flag || TARGET_NO_SCHED_PRO)\n+  if (profile_flag || TARGET_NO_SCHED_PRO)\n     emit_insn (gen_blockage ());\n \n   /* If the link register is being kept alive, with the return address in it,\n@@ -10079,7 +10079,7 @@ thumb_expand_prologue ()\n \t}\n     }\n   \n-  if (profile_flag || profile_block_flag || TARGET_NO_SCHED_PRO)\n+  if (profile_flag || TARGET_NO_SCHED_PRO)\n     emit_insn (gen_blockage ());\n }\n \n@@ -10116,7 +10116,7 @@ thumb_expand_epilogue ()\n      the stack adjustment will not be deleted.  */\n   emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n \n-  if (profile_flag || profile_block_flag || TARGET_NO_SCHED_PRO)\n+  if (profile_flag || TARGET_NO_SCHED_PRO)\n     emit_insn (gen_blockage ());\n }\n "}, {"sha": "3559652fe4051a5e0e8ac53286bfd841dcda01d6", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -851,13 +851,6 @@ c4x_expand_prologue ()\n       return;\n     }\n   \n-#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n-  if (profile_block_flag == 2)\n-    {\n-      FUNCTION_BLOCK_PROFILER_EXIT\n-    }\n-#endif\n-\n   /* For __interrupt__ function build specific prologue.  */\n   if (c4x_interrupt_function_p ())\n     {\n@@ -1239,7 +1232,6 @@ c4x_null_epilogue_p ()\n       && ! c4x_interrupt_function_p ()\n       && ! current_function_calls_alloca\n       && ! current_function_args_size\n-      && ! (profile_block_flag == 2)\n       && ! (optimize < 2)\n       && ! get_frame_size ())\n     {"}, {"sha": "5dd4a122c24925f66ae7cb3a7fca71ce90a0687e", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1194,269 +1194,6 @@ CUMULATIVE_ARGS;\n \tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n      }\n \n-/* There are three profiling modes for basic blocks available.\n-   The modes are selected at compile time by using the options\n-   -a or -ax of the gnu compiler.\n-   The variable `profile_block_flag' will be set according to the\n-   selected option.\n-\n-   profile_block_flag == 0, no option used:\n-\n-      No profiling done.\n-\n-   profile_block_flag == 1, -a option used.\n-\n-      Count frequency of execution of every basic block.\n-\n-   profile_block_flag == 2, -ax option used.\n-\n-      Generate code to allow several different profiling modes at run time. \n-      Available modes are:\n-             Produce a trace of all basic blocks.\n-             Count frequency of jump instructions executed.\n-      In every mode it is possible to start profiling upon entering\n-      certain functions and to disable profiling of some other functions.\n-\n-    The result of basic-block profiling will be written to a file `bb.out'.\n-    If the -ax option is used parameters for the profiling will be read\n-    from file `bb.in'.\n-\n-*/\n-\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCKNO) \t\t\t\\\n-  if (profile_block_flag == 2)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (! TARGET_C3X)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tr2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tldhi\\t^LPBX0,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n-\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldhi\\t%d,r2\\n\", (BLOCKNO) >> 16);\t\\\n-\t    fprintf (FILE, \"\\tor\\t%d,r2\\n\", (BLOCKNO));\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n- \telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldiu\\t%d,r2\\n\", (BLOCKNO));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tcall\\t___bb_init_trace_func\\n\");\t\\\n-\tfprintf (FILE, \"\\tpop\\tr2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tr2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tldiu\\t^LPBX0,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n-\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldi\\t%d,r2\\n\", (BLOCKNO) >> 16);\t\\\n-\t    fprintf (FILE, \"\\tlsh\\t16,r2\\n\");\t\t\t\\\n-\t    fprintf (FILE, \"\\tor\\t%d,r2\\n\", (BLOCKNO));\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n- \telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldiu\\t%d,r2\\n\", (BLOCKNO));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tcall\\t___bb_init_trace_func\\n\");\t\\\n-\tfprintf (FILE, \"\\tpop\\tr2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (! TARGET_C3X)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldhi\\t^LPBX0,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tcmpi\\t0,*ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tbne\\t$+2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tcall\\t___bb_init_func\\n\");\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tr2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tldiu\\t^LPBX0,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldi\\t*ar2,r2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tbne\\t$+2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tcall\\t___bb_init_func\\n\");\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tr2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    }\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO) \t\t\t\t\\\n-  if (profile_block_flag == 2)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (! TARGET_C3X)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldhi\\t^___bb,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#___bb,ar2\\n\");\t\t\t\\\n-\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldhi\\t%d,ar0\\n\", (BLOCKNO) >> 16);\\\n-\t    fprintf (FILE, \"\\tor\\t%d,ar0\\n\", (BLOCKNO));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n- \telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldiu\\t%d,ar0\\n\", (BLOCKNO));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldhi\\t^LPBX0,ar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX0,ar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tsti\\tar0,*+ar2(1)\\n\");\t\t\\\n-\tfprintf (FILE, \"\\tcall\\t___bb_trace_func\\n\");\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n-        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldiu\\t^___bb,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#___bb,ar2\\n\");\t\t\t\\\n-\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldi\\t%d,ar0\\n\", (BLOCKNO) >> 16);\t\\\n-\t    fprintf (FILE, \"\\tlsh\\t16,ar0\\n\");\t\t\t\\\n-\t    fprintf (FILE, \"\\tor\\t%d,ar0\\n\", (BLOCKNO));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n- \telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"\\tldiu\\t%d,ar0\\n\", (BLOCKNO));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldiu\\t^LPBX0,ar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tlsh\\t16,ar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX0,ar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tsti\\tar0,*+ar2(1)\\n\");\t\t\\\n-\tfprintf (FILE, \"\\tcall\\t___bb_trace_func\\n\");\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n-        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (! TARGET_C3X)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldhi\\t^LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n-\tfprintf (FILE, \"\\taddi3\\t1,*ar2,ar0\\n\");\t\t\\\n-\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n-        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldiu\\t^LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n-\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n-\tfprintf (FILE, \"\\tldiu\\t*ar2,ar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\taddi\\t1,ar0\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n-        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    }\n-\n-#define FUNCTION_BLOCK_PROFILER_EXIT\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      emit_insn (gen_push_st ()); \t\t\t\t\\\n-      emit_insn (gen_pushqi (\t\t\t\t\t\\\n-\t\tgen_rtx_REG (QImode, AR2_REGNO)));\t\t\\\n-      emit_call_insn (gen_nodb_call (\t\t\t\t\\\n-\t\tgen_rtx_SYMBOL_REF (QImode, \"__bb_trace_ret\")));\\\n-      emit_insn (gen_popqi_unspec (\t\t\t\t\\\n-\t\tgen_rtx_REG (QImode, AR2_REGNO)));\t\t\\\n-      emit_insn (gen_pop_st ());\t\t\t\t\\\n-    }\n-\n-#define\tMACHINE_STATE_SAVE(ID)\t\t\\\n-\tasm(\"\tpush\tr0\");\t\t\\\n-\tasm(\"\tpushf\tr0\");\t\t\\\n-\tasm(\"\tpush\tr1\");\t\t\\\n-\tasm(\"\tpushf\tr1\");\t\t\\\n-\tasm(\"\tpush\tr2\");\t\t\\\n-\tasm(\"\tpushf\tr2\");\t\t\\\n-\tasm(\"\tpush\tr3\");\t\t\\\n-\tasm(\"\tpushf\tr3\");\t\t\\\n-\tasm(\"\tpush\tar0\");\t\t\\\n-\tasm(\"\tpush\tar1\");\t\t\\\n-\tasm(\"\t.if\t.BIGMODEL\");\t\\\n-\tasm(\"\tpush\tdp\");\t\t\\\n-\tasm(\"\t.endif\");\t\t\\\n-\tasm(\"\tpush\tir0\");\t\t\\\n-\tasm(\"\tpush\tir1\");\t\t\\\n-\tasm(\"\tpush\tbk\");\t\t\\\n-\tasm(\"\tpush\trs\");\t\t\\\n-\tasm(\"\tpush\tre\");\t\t\\\n-\tasm(\"\tpush\trc\");\t\t\\\n-\tasm(\"\t.if\t.tms320C40\");\t\\\n-\tasm(\"\tpush\tr9\");\t\t\\\n-\tasm(\"\tpushf\tr9\");\t\t\\\n-\tasm(\"\tpush\tr10\");\t\t\\\n-\tasm(\"\tpushf\tr10\");\t\t\\\n-\tasm(\"\tpush\tr11\");\t\t\\\n-\tasm(\"\tpushf\tr11\");\t\t\\\n-\tasm(\"\t.endif\");\n-\n-#define\tMACHINE_STATE_RESTORE(ID)\t\\\n-\tasm(\"\t.if\t.tms320C40\");\t\\\n-\tasm(\"\tpopf\tr11\");\t\t\\\n-\tasm(\"\tpop\tr11\");\t\t\\\n-\tasm(\"\tpopf\tr10\");\t\t\\\n-\tasm(\"\tpop\tr10\");\t\t\\\n-\tasm(\"\tpopf\tr9\");\t\t\\\n-\tasm(\"\tpop\tr9\");\t\t\\\n-\tasm(\"\t.endif\");\t\t\\\n-\tasm(\"\tpop\trc\");\t\t\\\n-\tasm(\"\tpop\tre\");\t\t\\\n-\tasm(\"\tpop\trs\");\t\t\\\n-\tasm(\"\tpop\tbk\");\t\t\\\n-\tasm(\"\tpop\tir1\");\t\t\\\n-\tasm(\"\tpop\tir0\");\t\t\\\n-\tasm(\"\t.if\t.BIGMODEL\");\t\\\n-\tasm(\"\tpop\tdp\");\t\t\\\n-\tasm(\"\t.endif\");\t\t\\\n-\tasm(\"\tpop\tar1\");\t\t\\\n-\tasm(\"\tpop\tar0\");\t\t\\\n-\tasm(\"\tpopf\tr3\");\t\t\\\n-\tasm(\"\tpop\tr3\");\t\t\\\n-\tasm(\"\tpopf\tr2\");\t\t\\\n-\tasm(\"\tpop\tr2\");\t\t\\\n-\tasm(\"\tpopf\tr1\");\t\t\\\n-\tasm(\"\tpop\tr1\");\t\t\\\n-\tasm(\"\tpopf\tr0\");\t\t\\\n-\tasm(\"\tpop\tr0\");\t\t\\\n-\n /* Implicit Calls to Library Routines.  */\n \n #define MULQI3_LIBCALL      \"__mulqi3\""}, {"sha": "af641b35bc2e2c3818022765f25122ad752f3110", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -2735,137 +2735,6 @@ typedef struct machine_function\n    function prologue.  Normally, the profiling code comes after.  */\n /* #define PROFILE_BEFORE_PROLOGUE */\n \n-/* A C statement or compound statement to output to FILE some assembler code to\n-   initialize basic-block profiling for the current object module.  The global\n-   compile flag `profile_block_flag' distingishes two profile modes.\n-\n-   profile_block_flag != 2'\n-        Output code to call the subroutine `__bb_init_func' once per\n-        object module, passing it as its sole argument the address of\n-        a block allocated in the object module.\n-\n-        The name of the block is a local symbol made with this\n-        statement:\n-\n-             ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-        Of course, since you are writing the definition of\n-        `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro,\n-        you can take a short cut in the definition of this macro and\n-        use the name that you know will result.\n-\n-        The first word of this block is a flag which will be nonzero\n-        if the object module has already been initialized.  So test\n-        this word first, and do not call `__bb_init_func' if the flag\n-        is nonzero.  BLOCK_OR_LABEL contains a unique number which\n-        may be used to generate a label as a branch destination when\n-        `__bb_init_func' will not be called.\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-\n-               cmp (LPBX0),0\n-               bne local_label\n-               parameter1 <- LPBX0\n-               call __bb_init_func\n-             local_label:\n-\n-   profile_block_flag == 2'\n-        Output code to call the subroutine `__bb_init_trace_func' and\n-        pass two parameters to it.  The first parameter is the same as\n-        for `__bb_init_func'.  The second parameter is the number of\n-        the first basic block of the function as given by\n-        BLOCK_OR_LABEL.  Note that `__bb_init_trace_func' has to be\n-        called, even if the object module has been initialized\n-        already.\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-             parameter1 <- LPBX0\n-             parameter2 <- BLOCK_OR_LABEL\n-             call __bb_init_trace_func  */\n-/* #define FUNCTION_BLOCK_PROFILER (FILE, LABELNO) */\n-\n-/* A C statement or compound statement to output to FILE some assembler code to\n-   increment the count associated with the basic block number BLOCKNO.  The\n-   global compile flag `profile_block_flag' distingishes two profile modes.\n-\n-   profile_block_flag != 2'\n-        Output code to increment the counter directly.  Basic blocks\n-        are numbered separately from zero within each compilation.\n-        The count associated with block number BLOCKNO is at index\n-        BLOCKNO in a vector of words; the name of this array is a\n-        local symbol made with this statement:\n-\n-             ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-        Of course, since you are writing the definition of\n-        `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro,\n-        you can take a short cut in the definition of this macro and\n-        use the name that you know will result.\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-\n-             inc (LPBX2+4*BLOCKNO)\n-\n-   profile_block_flag == 2'\n-        Output code to initialize the global structure `__bb' and\n-        call the function `__bb_trace_func', which will increment the\n-        counter.\n-\n-        `__bb' consists of two words.  In the first word, the current\n-        basic block number, as given by BLOCKNO, has to be stored.  In\n-        the second word, the address of a block allocated in the\n-        object module has to be stored.  The address is given by the\n-        label created with this statement:\n-\n-             ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-             move BLOCKNO -> (__bb)\n-             move LPBX0 -> (__bb+4)\n-             call __bb_trace_func  */\n-/* #define BLOCK_PROFILER(FILE, BLOCKNO) */\n-\n-/* A C statement or compound statement to output to FILE assembler\n-   code to call function `__bb_trace_ret'.  The assembler code should\n-   only be output if the global compile flag `profile_block_flag' ==\n-   2.  This macro has to be used at every place where code for\n-   returning from a function is generated (e.g. output_function_epilogue()).\n-   Although you have to write the definition of output_function_epilogue()\n-   as well, you have to define this macro to tell the compiler, that\n-   the proper call to `__bb_trace_ret' is produced.  */\n-/* #define FUNCTION_BLOCK_PROFILER_EXIT(FILE) */\n-\n-/* A C statement or compound statement to save all registers, which may be\n-   clobbered by a function call, including condition codes.  The `asm'\n-   statement will be mostly likely needed to handle this task.  Local labels in\n-   the assembler code can be concatenated with the string ID, to obtain a\n-   unique lable name.\n-\n-   Registers or condition codes clobbered by output_function_prologue()\n-   or output_function_epilogue() must be saved in the macros\n-   `FUNCTION_BLOCK_PROFILER', FUNCTION_BLOCK_PROFILER_EXIT' and\n-   `BLOCK_PROFILER' prior calling `__bb_init_trace_func', `__bb_trace_ret'\n-   and `__bb_trace_func' respectively.  */\n-/* #define MACHINE_STATE_SAVE(ID) */\n-\n-/* A C statement or compound statement to restore all registers, including\n-   condition codes, saved by `MACHINE_STATE_SAVE'.\n-\n-   Registers or condition codes clobbered by output_function_prologue()\n-   or output_function_epilogue() must be restored in the macros\n-   `FUNCTION_BLOCK_PROFILER', `FUNCTION_BLOCK_PROFILER_EXIT' and\n-   `BLOCK_PROFILER' after calling `__bb_init_trace_func', `__bb_trace_ret' and\n-   `__bb_trace_func' respectively.  */\n-/* #define MACHINE_STATE_RESTORE(ID) */\n-\n-/* A C function or functions which are needed in the library to support block\n-   profiling.  */\n-/* #define BLOCK_PROFILER_CODE */\n-\n \f\n /* Implementing the Varargs Macros.  */\n "}, {"sha": "eb90c6b318c9aacc524a52819b8777b6ee6f0316", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -330,7 +330,7 @@ fr30_expand_prologue ()\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  if (profile_flag || profile_block_flag)\n+  if (profile_flag)\n     emit_insn (gen_blockage ());\n }\n "}, {"sha": "760a15c86b028f409c50828bc0dc8e5f283d35d4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 258, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -3401,10 +3401,6 @@ ix86_can_use_return_insn_p ()\n   if (NON_SAVING_SETJMP && current_function_calls_setjmp)\n     return 0;\n #endif\n-#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n-  if (profile_block_flag == 2)\n-    return 0;\n-#endif\n \n   if (! reload_completed || frame_pointer_needed)\n     return 0;\n@@ -4029,7 +4025,7 @@ ix86_expand_prologue ()\n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  However, if -fpic, the above call will have\n      done that.  */\n-  if ((profile_flag || profile_block_flag) && ! pic_reg_used)\n+  if (profile_flag && ! pic_reg_used)\n     emit_insn (gen_blockage ());\n }\n \n@@ -4075,13 +4071,6 @@ ix86_expand_epilogue (style)\n     offset -= 2;\n   offset *= -UNITS_PER_WORD;\n \n-#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n-  if (profile_block_flag == 2)\n-    {\n-      FUNCTION_BLOCK_PROFILER_EXIT;\n-    }\n-#endif\n-\n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n      less work than reloading sp and popping the register.\n@@ -6406,252 +6395,6 @@ output_fp_compare (insn, operands, eflags_p, unordered_p)\n     }\n }\n \n-/* Output assembler code to FILE to initialize basic-block profiling.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to call the subroutine `__bb_init_trace_func'\n-\tand pass two parameters to it. The first parameter is\n-\tthe address of a block allocated in the object module.\n-\tThe second parameter is the number of the first basic block\n-\tof the function.\n-\n-\tThe name of the block is a local symbol made with this statement:\n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tThe number of the first basic block of the function is\n-\tpassed to the macro in BLOCK_OR_LABEL.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tparameter1 <- LPBX0\n-\t\tparameter2 <- BLOCK_OR_LABEL\n-\t\tcall __bb_init_trace_func\n-\n-    else if profile_block_flag != 0\n-\n-\tOutput code to call the subroutine `__bb_init_func'\n-\tand pass one single parameter to it, which is the same\n-\tas the first parameter to `__bb_init_trace_func'.\n-\n-\tThe first word of this parameter is a flag which will be nonzero if\n-\tthe object module has already been initialized.  So test this word\n-\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n-\tNote: When profile_block_flag == 2 the test need not be done\n-\tbut `__bb_init_trace_func' *must* be called.\n-\n-\tBLOCK_OR_LABEL may be used to generate a label number as a\n-\tbranch destination in case `__bb_init_func' will not be called.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tcmp (LPBX0),0\n-\t\tjne local_label\n-\t\tparameter1 <- LPBX0\n-\t\tcall __bb_init_func\n-\t      local_label:\n-*/\n-\n-void\n-ix86_output_function_block_profiler (file, block_or_label)\n-     FILE *file;\n-     int block_or_label;\n-{\n-  static int num_func = 0;\n-  rtx xops[8];\n-  char block_table[80], false_label[80];\n-\n-  ASM_GENERATE_INTERNAL_LABEL (block_table, \"LPBX\", 0);\n-\n-  xops[1] = gen_rtx_SYMBOL_REF (VOIDmode, block_table);\n-  xops[5] = stack_pointer_rtx;\n-  xops[7] = gen_rtx_REG (Pmode, 0); /* eax */\n-\n-  CONSTANT_POOL_ADDRESS_P (xops[1]) = TRUE;\n-\n-  switch (profile_block_flag)\n-    {\n-    case 2:\n-      xops[2] = GEN_INT (block_or_label);\n-      xops[3] = gen_rtx_MEM (Pmode,\n-\t\t     gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_init_trace_func\"));\n-      xops[6] = GEN_INT (8);\n-\n-      output_asm_insn (\"push{l}\\t%2\", xops);\n-      if (!flag_pic)\n-\toutput_asm_insn (\"push{l}\\t%1\", xops);\n-      else\n-\t{\n-\t  output_asm_insn (\"lea{l}\\t{%a1, %7|%7, %a1}\", xops);\n-\t  output_asm_insn (\"push{l}\\t%7\", xops);\n-\t}\n-      output_asm_insn (\"call\\t%P3\", xops);\n-      output_asm_insn (\"add{l}\\t{%6, %5|%5, %6}\", xops);\n-      break;\n-\n-    default:\n-      ASM_GENERATE_INTERNAL_LABEL (false_label, \"LPBZ\", num_func);\n-\n-      xops[0] = const0_rtx;\n-      xops[2] = gen_rtx_MEM (Pmode,\n-\t\t\t     gen_rtx_SYMBOL_REF (VOIDmode, false_label));\n-      xops[3] = gen_rtx_MEM (Pmode,\n-\t\t\t     gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_init_func\"));\n-      xops[4] = gen_rtx_MEM (Pmode, xops[1]);\n-      xops[6] = GEN_INT (4);\n-\n-      CONSTANT_POOL_ADDRESS_P (xops[2]) = TRUE;\n-\n-      output_asm_insn (\"cmp{l}\\t{%0, %4|%4, %0}\", xops);\n-      output_asm_insn (\"jne\\t%2\", xops);\n-\n-      if (!flag_pic)\n-\toutput_asm_insn (\"push{l}\\t%1\", xops);\n-      else\n-\t{\n-\t  output_asm_insn (\"lea{l}\\t{%a1, %7|%7, %a2}\", xops);\n-\t  output_asm_insn (\"push{l}\\t%7\", xops);\n-\t}\n-      output_asm_insn (\"call\\t%P3\", xops);\n-      output_asm_insn (\"add{l}\\t{%6, %5|%5, %6}\", xops);\n-      ASM_OUTPUT_INTERNAL_LABEL (file, \"LPBZ\", num_func);\n-      num_func++;\n-      break;\n-    }\n-}\n-\n-/* Output assembler code to FILE to increment a counter associated\n-   with basic block number BLOCKNO.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to initialize the global structure `__bb' and\n-\tcall the function `__bb_trace_func' which will increment the\n-\tcounter.\n-\n-\t`__bb' consists of two words. In the first word the number\n-\tof the basic block has to be stored. In the second word\n-\tthe address of a block allocated in the object module\n-\thas to be stored.\n-\n-\tThe basic block number is given by BLOCKNO.\n-\n-\tThe address of the block is given by the label created with\n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tby FUNCTION_BLOCK_PROFILER.\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tmove BLOCKNO -> (__bb)\n-\t\tmove LPBX0 -> (__bb+4)\n-\t\tcall __bb_trace_func\n-\n-\tNote that function `__bb_trace_func' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE\n-\tand MACHINE_STATE_RESTORE. The last two macros will be\n-\tused in the function `__bb_trace_func', so you must make\n-\tsure that the function prologue does not change any\n-\tregister prior to saving it with MACHINE_STATE_SAVE.\n-\n-   else if profile_block_flag != 0\n-\n-\tOutput code to increment the counter directly.\n-\tBasic blocks are numbered separately from zero within each\n-\tcompiled object module. The count associated with block number\n-\tBLOCKNO is at index BLOCKNO in an array of words; the name of\n-\tthis array is a local symbol made with this statement:\n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tinc (LPBX2+4*BLOCKNO)\n-*/\n-\n-void\n-ix86_output_block_profiler (file, blockno)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     int blockno;\n-{\n-  rtx xops[8], cnt_rtx;\n-  char counts[80];\n-  char *block_table = counts;\n-\n-  switch (profile_block_flag)\n-    {\n-    case 2:\n-      ASM_GENERATE_INTERNAL_LABEL (block_table, \"LPBX\", 0);\n-\n-      xops[1] = gen_rtx_SYMBOL_REF (VOIDmode, block_table);\n-      xops[2] = GEN_INT (blockno);\n-      xops[3] = gen_rtx_MEM (Pmode,\n-\t\t\t     gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_trace_func\"));\n-      xops[4] = gen_rtx_SYMBOL_REF (VOIDmode, \"__bb\");\n-      xops[5] = plus_constant (xops[4], 4);\n-      xops[0] = gen_rtx_MEM (SImode, xops[4]);\n-      xops[6] = gen_rtx_MEM (SImode, xops[5]);\n-\n-      CONSTANT_POOL_ADDRESS_P (xops[1]) = TRUE;\n-\n-      output_asm_insn (\"pushf\", xops);\n-      output_asm_insn (\"mov{l}\\t{%2, %0|%0, %2}\", xops);\n-      if (flag_pic)\n-\t{\n-\t  xops[7] = gen_rtx_REG (Pmode, 0); /* eax */\n-\t  output_asm_insn (\"push{l}\\t%7\", xops);\n-\t  output_asm_insn (\"lea{l}\\t{%a1, %7|%7, %a1}\", xops);\n-\t  output_asm_insn (\"mov{l}\\t{%7, %6|%6, %7}\", xops);\n-\t  output_asm_insn (\"pop{l}\\t%7\", xops);\n-\t}\n-      else\n-\toutput_asm_insn (\"mov{l}\\t{%1, %6|%6, %1}\", xops);\n-      output_asm_insn (\"call\\t%P3\", xops);\n-      output_asm_insn (\"popf\", xops);\n-\n-      break;\n-\n-    default:\n-      ASM_GENERATE_INTERNAL_LABEL (counts, \"LPBX\", 2);\n-      cnt_rtx = gen_rtx_SYMBOL_REF (VOIDmode, counts);\n-      SYMBOL_REF_FLAG (cnt_rtx) = TRUE;\n-\n-      if (blockno)\n-\tcnt_rtx = plus_constant (cnt_rtx, blockno*4);\n-\n-      if (flag_pic)\n-\tcnt_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, cnt_rtx);\n-\n-      xops[0] = gen_rtx_MEM (SImode, cnt_rtx);\n-      output_asm_insn (\"inc{l}\\t%0\", xops);\n-\n-      break;\n-    }\n-}\n-\n void\n ix86_output_addr_vec_elt (file, value)\n      FILE *file;"}, {"sha": "a7d7702971c291dc52cafe320bb926dedeefdecb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 119, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1678,124 +1678,6 @@ typedef struct ix86_args {\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-\n-/* There are three profiling modes for basic blocks available.\n-   The modes are selected at compile time by using the options\n-   -a or -ax of the gnu compiler.\n-   The variable `profile_block_flag' will be set according to the\n-   selected option.\n-\n-   profile_block_flag == 0, no option used:\n-\n-      No profiling done.\n-\n-   profile_block_flag == 1, -a option used.\n-\n-      Count frequency of execution of every basic block.\n-\n-   profile_block_flag == 2, -ax option used.\n-\n-      Generate code to allow several different profiling modes at run time. \n-      Available modes are:\n-             Produce a trace of all basic blocks.\n-             Count frequency of jump instructions executed.\n-      In every mode it is possible to start profiling upon entering\n-      certain functions and to disable profiling of some other functions.\n-\n-    The result of basic-block profiling will be written to a file `bb.out'.\n-    If the -ax option is used parameters for the profiling will be read\n-    from file `bb.in'.\n-\n-*/\n-\n-/* The following macro shall output assembler code to FILE\n-   to initialize basic-block profiling.  */\n-\n-#undef\tFUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL) \\\n-\tix86_output_function_block_profiler (FILE, BLOCK_OR_LABEL)\n-\n-/* The following macro shall output assembler code to FILE\n-   to increment a counter associated with basic block number BLOCKNO.  */\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n-\tix86_output_block_profiler (FILE, BLOCKNO)\n-\n-/* The following macro shall output rtl for the epilogue\n-   to indicate a return from function during basic-block profiling.\n-\n-   If profiling_block_flag == 2:\n-\n-\tOutput assembler code to call function `__bb_trace_ret'.\n-\n-\tNote that function `__bb_trace_ret' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE\n-\tand MACHINE_STATE_RESTORE. The last two macros will be\n-\tused in the function `__bb_trace_ret', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE.\n-\n-   else if profiling_block_flag != 0:\n-\n-\tThe macro will not be used, so it need not distinguish\n-\tthese cases.\n-*/\n-\n-#define FUNCTION_BLOCK_PROFILER_EXIT\t\t\t\\\n-emit_call_insn (gen_call (gen_rtx_MEM (QImode,\t\t\\\n-  gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_trace_ret\")),\t\\\n-  const0_rtx, constm1_rtx))\n-\n-/* The function `__bb_trace_func' is called in every basic block\n-   and is not allowed to change the machine state. Saving (restoring)\n-   the state can either be done in the BLOCK_PROFILER macro,\n-   before calling function (rsp. after returning from function)\n-   `__bb_trace_func', or it can be done inside the function by\n-   defining the macros:\n-\n-\tMACHINE_STATE_SAVE(ID)\n-\tMACHINE_STATE_RESTORE(ID)\n-\n-   In the latter case care must be taken, that the prologue code\n-   of function `__bb_trace_func' does not already change the\n-   state prior to saving it with MACHINE_STATE_SAVE.\n-\n-   The parameter `ID' is a string identifying a unique macro use.\n-\n-   On the i386 the initialization code at the begin of\n-   function `__bb_trace_func' contains a `sub' instruction\n-   therefore we handle save and restore of the flag register \n-   in the BLOCK_PROFILER macro.\n-\n-   Note that ebx, esi, and edi are callee-save, so we don't have to\n-   preserve them explicitly.  */\n-\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  register int eax_ __asm__(\"eax\");\t\t\t\t\\\n-  register int ecx_ __asm__(\"ecx\");\t\t\t\t\\\n-  register int edx_ __asm__(\"edx\");\t\t\t\t\\\n-  __asm__ __volatile__ (\"\\\n-push{l} %0\\n\\t\\\n-push{l} %1\\n\\t\\\n-push{l} %2\"\t\t\t\t\t\t\t\\\n-\t: : \"r\"(eax_), \"r\"(ecx_), \"r\"(edx_));\t\t\t\\\n-} while (0);\n-\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  register int eax_ __asm__(\"eax\");\t\t\t\t\\\n-  register int ecx_ __asm__(\"ecx\");\t\t\t\t\\\n-  register int edx_ __asm__(\"edx\");\t\t\t\t\\\n-  __asm__ __volatile__ (\"\\\n-pop{l} %2\\n\\t\\\n-pop{l} %1\\n\\t\\\n-pop{l} %0\"\t\t\t\t\t\t\t\\\n-\t: \"=r\"(eax_), \"=r\"(ecx_), \"=r\"(edx_));\t\t\t\\\n-} while (0);\n-\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n@@ -2315,7 +2197,7 @@ while (0)\n #define FINALIZE_PIC\t\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    current_function_uses_pic_offset_table |= profile_flag | profile_block_flag; \\\n+    current_function_uses_pic_offset_table |= profile_flag; \\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n "}, {"sha": "68d9edac69dccdf0443fd9dc492dabc2a51f42c2", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1308,7 +1308,7 @@ i960_output_function_prologue (file, size)\n \n   epilogue_string[0] = '\\0';\n \n-  if (profile_flag || profile_block_flag)\n+  if (profile_flag)\n     {\n       /* When profiling, we may use registers 20 to 27 to save arguments, so\n \t they can't be used here for saving globals.  J is the number of"}, {"sha": "52b3ba6c0da2c4bf8597c7f7f03e240d1a913ffa", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1433,10 +1433,8 @@ ia64_compute_frame_size (size)\n      Likwise for -a profiling for the bb_init_func argument.  For -ax\n      profiling, we need two output registers for the two bb_init_trace_func\n      arguments.  */\n-  if (profile_flag || profile_block_flag == 1)\n+  if (profile_flag)\n     i = MAX (i, 1);\n-  else if (profile_block_flag == 2)\n-    i = MAX (i, 2);\n   current_frame_info.n_output_regs = i;\n \n   /* ??? No rotating register support yet.  */"}, {"sha": "49e50a44ff550b8b46c0a460aef3c74e8ebe679f", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1554,106 +1554,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fputs (\"\\tmov out2 = b0\\n\", FILE);\t\t\t\t\t\\\n   fputs (\"\\tbr.call.sptk.many b0 = _mcount;;\\n\", FILE);\t\t\t\\\n } while (0)\n-\n-/* A C statement or compound statement to output to FILE some assembler code to\n-   initialize basic-block profiling for the current object module.  */\n-\n-/* ??? Unclear if this will actually work.  No way to test this currently.  */\n-\n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  int labelno = LABELNO;\t\t\t\t\t\t\\\n-  switch (profile_block_flag)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case 2:\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\taddl r16 = @ltoff(LPBX0), gp\\n\", FILE);\t\t\t\\\n-      fprintf (FILE, \"\\tmov out1 = %d;;\\n\", labelno);\t\t\t\\\n-      fputs (\"\\tld8 out0 = [r16]\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tmov r17 = r1\\n\", FILE);\t\t\t\t\t\\\n-      fputs (\"\\tmov r18 = b0\\n\", FILE);\t\t\t\t\t\\\n-      fputs (\"\\tbr.call.sptk.many rp = __bb_init_trace_func;;\\n\", FILE);\\\n-      fputs (\"\\tmov r1 = r17\\n\", FILE);\t\t\t\t\t\\\n-      fputs (\"\\tmov b0 = r18;;\\n\", FILE);\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\taddl r16 = @ltoff(LPBX0), gp;;\\n\", FILE);\t\t\\\n-      fputs (\"\\tld8 out0 = [r16];;\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tld8 r17 = [out0];;\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tcmp.eq p6, p0 = r0, r17;;\\n\", FILE);\t\t\t\\\n-      fputs (\"(p6)\\tmov r16 = r1\\n\", FILE);\t\t\t\t\\\n-      fputs (\"(p6)\\tmov r17 = b0\\n\", FILE);\t\t\t\t\\\n-      fputs (\"(p6)\\tbr.call.sptk.many rp = __bb_init_func;;\\n\", FILE);\t\\\n-      fputs (\"(p6)\\tmov r1 = r16\\n\", FILE);\t\t\t\t\\\n-      fputs (\"(p6)\\tmov b0 = r17;;\\n\", FILE);\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* A C statement or compound statement to output to FILE some assembler code to\n-   increment the count associated with the basic block number BLOCKNO.  */\n-\n-/* ??? This can't work unless we mark some registers as fixed, so that we\n-   can use them as temporaries in this macro.  We need two registers for -a\n-   profiling and 4 registers for -ax profiling.  */\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  int blockn = BLOCKNO;\t\t\t\t\t\t\t\\\n-  switch (profile_block_flag)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case 2:\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\taddl r2 = @ltoff(__bb), gp\\n\", FILE);\t\t\t\\\n-      fputs (\"\\taddl r3 = @ltoff(LPBX0), gp;;\\n\", FILE);\t\t\\\n-      fprintf (FILE, \"\\tmov r9 = %d\\n\", blockn);\t\t\t\\\n-      fputs (\"\\tld8 r2 = [r2]\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tld8 r3 = [r3];;\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tadd r8 = 8, r2\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tst8 [r2] = r9;;\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tst8 [r8] = r3\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tbr.call.sptk.many rp = __bb_trace_func\\n\", FILE);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\taddl r2 = @ltoff(LPBX2), gp;;\\n\", FILE);\t\t\\\n-      fputs (\"\\tld8 r2 = [r2];;\\n\", FILE);\t\t\t\t\\\n-      fprintf (FILE, \"\\taddl r2 = %d, r2;;\\n\", 8 * blockn);\t\t\\\n-      fputs (\"\\tld8 r3 = [r2];;\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tadd r3 = 1, r3;;\\n\", FILE);\t\t\t\t\\\n-      fputs (\"\\tst8 [r2] = r3;;\\n\", FILE);\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while(0)\n-\n-/* A C statement or compound statement to output to FILE assembler\n-   code to call function `__bb_trace_ret'.  */\n-\n-/* ??? Unclear if this will actually work.  No way to test this currently.  */\n-\n-/* ??? This needs to be emitted into the epilogue.  Perhaps rewrite to emit\n-   rtl and call from ia64_expand_epilogue?  */\n-\n-#define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n-  fputs (\"\\tbr.call.sptk.many rp = __bb_trace_ret\\n\", FILE);\n-#undef FUNCTION_BLOCK_PROFILER_EXIT\n-\n-/* A C statement or compound statement to save all registers, which may be\n-   clobbered by a function call, including condition codes.  */\n-\n-/* ??? We would have to save 20 GRs, 106 FRs, 10 PRs, 2 BRs, and possibly\n-   other things.  This is not practical.  Perhaps leave this feature (-ax)\n-   unsupported by undefining above macros?  */\n-\n-/* #define MACHINE_STATE_SAVE(ID) */\n-\n-/* A C statement or compound statement to restore all registers, including\n-   condition codes, saved by `MACHINE_STATE_SAVE'.  */\n-\n-/* ??? We would have to restore 20 GRs, 106 FRs, 10 PRs, 2 BRs, and possibly\n-   other things.  This is not practical.  Perhaps leave this feature (-ax)\n-   unsupported by undefining above macros?  */\n-\n-/* #define MACHINE_STATE_RESTORE(ID) */\n-\n \f\n /* Implementing the Varargs Macros.  */\n "}, {"sha": "cdb3f257d8c3755ed2b713fc0c96a1ee36c9bf1f", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -2013,7 +2013,7 @@ m32r_expand_prologue ()\n   if (frame_pointer_needed)\n     emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n \n-  if (profile_flag || profile_block_flag)\n+  if (profile_flag)\n     emit_insn (gen_blockage ());\n }\n "}, {"sha": "73b38fb6f070e72a97b2eadde21e0401f75de016", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1131,44 +1131,6 @@ typedef struct m68hc11_args\n    for profiling a function entry.  */\n #define FUNCTION_PROFILER(FILE, LABELNO)\t\t\\\n     asm_fprintf (FILE, \"\\tldy\\t.LP%d\\n\\tjsr mcount\\n\", (LABELNO))\n-\n-/* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done.  */\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\\\n-    m68hc11_function_block_profiler(FILE, BLOCK_OR_LABEL)\n-\n-/* Output assembler code to FILE to increment the counter for\n-  the BLOCKNO'th basic block in this source file.  */\n-#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t\t\\\n-    m68hc11_block_profiler(FILE, BLOCKNO)\n-\n-/* Output assembler code to FILE to indicate return from \n-   a function during basic block profiling.  */\n-#define FUNCTION_BLOCK_PROFILER_EXIT(FILE)\t\t\\\n-    asm_fprintf (FILE, \"\\tjsr %U__bb_trace_ret\\n\");\n-\n-/* Save all registers which may be clobbered by a function call.\n-   MACHINE_STATE_SAVE and MACHINE_STATE_RESTORE are target-code macros,\n-   used in libgcc2.c.  They may not refer to TARGET_* macros !!!\n-\n-   We don't need to save the CCR nor the soft registers because\n-   they will be saved by gcc.  */\n-#define MACHINE_STATE_SAVE(id) \\\n-  {\t\t\t       \\\n-    asm (\"pshy\");\t       \\\n-    asm (\"pshx\");\t       \\\n-    asm (\"psha\");\t       \\\n-    asm (\"pshb\");\t       \\\n-  }\n-\n-#define MACHINE_STATE_RESTORE(id) \\\n-  {\t\t\t       \\\n-    asm (\"pulb\");\t       \\\n-    asm (\"pula\");\t       \\\n-    asm (\"pulx\");\t       \\\n-    asm (\"puly\");\t       \\\n-  }\n-\n /* Length in units of the trampoline for entering a nested function.  */\n #define TRAMPOLINE_SIZE\t\t(TARGET_M6811 ? 11 : 9)\n "}, {"sha": "f8932037775a3afc2cc334725ab8300a8d72835c", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1185,13 +1185,6 @@ m68k_output_function_epilogue (stream, size)\n       return;\n     }\n \n-#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n-  if (profile_block_flag == 2)\n-    {\n-      FUNCTION_BLOCK_PROFILER_EXIT (stream);\n-    }\n-#endif\n-\n #ifdef FUNCTION_EXTRA_EPILOGUE\n   FUNCTION_EXTRA_EPILOGUE (stream, size);\n #endif"}, {"sha": "65a34eeba2654a17926df2cb102f2dd57b9bc129", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1092,168 +1092,6 @@ extern enum reg_class regno_reg_class[];\n #define FUNCTION_PROFILER(FILE, LABELNO)  \\\n   asm_fprintf (FILE, \"\\tlea %LLP%d,%Ra0\\n\\tjsr mcount\\n\", (LABELNO))\n \n-/* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done.  */\n-\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    switch (profile_block_flag)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case 2:\t\t\t\t\t\t\\\n-        asm_fprintf (FILE, \"\\tpea %d\\n\\tpea %LLPBX0\\n\\tjsr %U__bb_init_trace_func\\n\\taddql %I8,%Rsp\\n\", \\\n-                           (BLOCK_OR_LABEL)); \\\n-        break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\\\n-        asm_fprintf (FILE, \"\\ttstl %LLPBX0\\n\\tbne %LLPI%d\\n\\tpea %LLPBX0\\n\\tjsr %U__bb_init_func\\n\\taddql %I4,%Rsp\\n%LLPI%d:\\n\", \\\n-                           (BLOCK_OR_LABEL), (BLOCK_OR_LABEL)); \\\n-        break;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-while(0)\n-\n-/* Output assembler code to FILE to increment the counter for\n-   the BLOCKNO'th basic block in this source file.  */\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n-do\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    switch (profile_block_flag)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-      case 2:\t\t\t\t\t\t\\\n-        asm_fprintf (FILE, \"\\tmovel %Ra1,%Rsp@-\\n\\tlea ___bb,%Ra1\\n\\tmovel %I%d,%Ra1@(0)\\n\\tmovel %I%LLPBX0,%Ra1@(4)\\n\\tmovel %Rsp@+,%Ra1\\n\\tjsr %U__bb_trace_func\\n\", \\\n-                           BLOCKNO);\t\t\t\\\n-        break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\\\n-        asm_fprintf (FILE, \"\\taddql %I1,%LLPBX2+%d\\n\", 4 * BLOCKNO); \\\n-        break;\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-while(0)\n-\n-/* Output assembler code to FILE to indicate return from \n-   a function during basic block profiling.  */\n-\n-#define FUNCTION_BLOCK_PROFILER_EXIT(FILE)\t\t\\\n-  asm_fprintf (FILE, \"\\tjsr %U__bb_trace_ret\\n\");\n-\n-/* Save all registers which may be clobbered by a function call.\n-   MACHINE_STATE_SAVE and MACHINE_STATE_RESTORE are target-code macros,\n-   used in libgcc2.c.  They may not refer to TARGET_* macros !!! */\n-#if defined (__mc68010__) || defined(mc68010) \\\n-\t|| defined(__mc68020__) || defined(mc68020) \\\n-\t|| defined(__mc68030__) || defined(mc68030) \\\n-\t|| defined(__mc68040__) || defined(mc68040) \\\n-\t|| defined(__mcpu32__) || defined(mcpu32)\n-#define MACHINE_STATE_m68010_up\n-#endif\n-\n-#ifdef MOTOROLA\n-#if defined(__mcf5200__)\n-#define MACHINE_STATE_SAVE(id)\t\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"sub.l 20,%sp\");\t\t\\\n-      asm (\"movm.l &0x0303,4(%sp)\");\t\\\n-      asm (\"move.w %ccr,%d0\");\t\t\\\n-      asm (\"movm.l &0x0001,(%sp)\");\t\\\n-    }\n-#else /* !__mcf5200__ */\n-#if defined(MACHINE_STATE_m68010_up)\n-#ifdef __HPUX_ASM__\n-/* HPUX assembler does not accept %ccr.  */\n-#define MACHINE_STATE_SAVE(id)\t\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"move.w %cc,-(%sp)\");\t\\\n-      asm (\"movm.l &0xc0c0,-(%sp)\");\t\\\n-    }\n-#else /* ! __HPUX_ASM__ */\n-#define MACHINE_STATE_SAVE(id)\t\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"move.w %ccr,-(%sp)\");\t\\\n-      asm (\"movm.l &0xc0c0,-(%sp)\");\t\\\n-    }\n-#endif /* __HPUX_ASM__ */\n-#else /* !MACHINE_STATE_m68010_up */\n-#define MACHINE_STATE_SAVE(id)\t\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"move.w %sr,-(%sp)\");\t\\\n-      asm (\"movm.l &0xc0c0,-(%sp)\");\t\\\n-    }\n-#endif /* MACHINE_STATE_m68010_up */\n-#endif /* __mcf5200__ */\n-#else /* !MOTOROLA */\n-#if defined(__mcf5200__)\n-#define MACHINE_STATE_SAVE(id)\t\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"subl %#20,%/sp\" : );\t\\\n-      asm (\"movml %/d0/%/d1/%/a0/%/a1,%/sp@(4)\" : ); \\\n-      asm (\"movew %/cc,%/d0\" : );\t\\\n-      asm (\"movml %/d0,%/sp@\" : );\t\\\n-    }\n-#else /* !__mcf5200__ */\n-#if defined(MACHINE_STATE_m68010_up)\n-#define MACHINE_STATE_SAVE(id)\t\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"movew %/cc,%/sp@-\" : );\t\\\n-      asm (\"moveml %/d0/%/d1/%/a0/%/a1,%/sp@-\" : ); \\\n-    }\n-#else /* !MACHINE_STATE_m68010_up */\n-#define MACHINE_STATE_SAVE(id)\t\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"movew %/sr,%/sp@-\" : );\t\\\n-      asm (\"moveml %/d0/%/d1/%/a0/%/a1,%/sp@-\" : ); \\\n-    }\n-#endif /* MACHINE_STATE_m68010_up */\n-#endif /* __mcf5200__ */\n-#endif /* MOTOROLA */\n-\n-/* Restore all registers saved by MACHINE_STATE_SAVE.  */\n-\n-#ifdef MOTOROLA\n-#if defined(__mcf5200__)\n-#define MACHINE_STATE_RESTORE(id)\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"movm.l (%sp),&0x0001\");\t\\\n-      asm (\"move.w %d0,%ccr\");\t\t\\\n-      asm (\"movm.l 4(%sp),&0x0303\");\t\\\n-      asm (\"add.l 20,%sp\");\t\t\\\n-    }\n-#else /* !__mcf5200__ */\n-#ifdef __HPUX_ASM__\n-/* HPUX assembler does not accept %ccr.  */\n-#define MACHINE_STATE_RESTORE(id)\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"movm.l (%sp)+,&0x0303\");\t\\\n-      asm (\"move.w (%sp)+,%cc\");\t\\\n-    }\n-#else /* ! __HPUX_ASM__ */\n-#define MACHINE_STATE_RESTORE(id)\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"movm.l (%sp)+,&0x0303\");\t\\\n-      asm (\"move.w (%sp)+,%ccr\");\t\\\n-    }\n-#endif /* __HPUX_ASM__ */\n-#endif /* __mcf5200__ */\n-#else /* !MOTOROLA */\n-#if defined(__mcf5200__)\n-#define MACHINE_STATE_RESTORE(id)\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"movml %/sp@,%/d0\" : );\t\\\n-      asm (\"movew %/d0,%/cc\" : );\t\\\n-      asm (\"movml %/sp@(4),%/d0/%/d1/%/a0/%/a1\" : ); \\\n-      asm (\"addl %#20,%/sp\" : );\t\\\n-    }\n-#else /* !__mcf5200__ */\n-#define MACHINE_STATE_RESTORE(id)\t\\\n-    {\t\t\t\t\t\\\n-      asm (\"moveml %/sp@+,%/d0/%/d1/%/a0/%/a1\" : ); \\\n-      asm (\"movew %/sp@+,%/cc\" : );\t\\\n-    }\n-#endif /* __mcf5200__ */\n-#endif /* MOTOROLA */\n-\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers."}, {"sha": "05a22f709dc9246b7300013a1d3d062f8872192a", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1560,9 +1560,6 @@ output_options (file, f_options, f_len, W_options, W_len,\n     pos = output_option (file, sep, \"-traditional\", \"\", indent, pos, max);\n   if (profile_flag)\n     pos = output_option (file, sep, \"-p\", \"\", indent, pos, max);\n-  if (profile_block_flag)\n-    pos = output_option (file, sep, \"-a\", \"\", indent, pos, max);\n-\n   for (j = 0; j < f_len; j++)\n     if (*f_options[j].variable == f_options[j].on_value)\n       pos = output_option (file, sep, \"-f\", f_options[j].string,\n@@ -1820,7 +1817,7 @@ m88k_layout_frame ()\n   frame_size = get_frame_size ();\n \n   /* Since profiling requires a call, make sure r1 is saved.  */\n-  if (profile_flag || profile_block_flag)\n+  if (profile_flag)\n     save_regs[1] = 1;\n \n   /* If we are producing debug information, store r1 and r30 where the\n@@ -2031,7 +2028,7 @@ m88k_expand_prologue ()\n       if (! save_regs[1])\n \temit_move_insn (return_reg, temp_reg);\n     }\n-  if (profile_flag || profile_block_flag)\n+  if (profile_flag)\n     emit_insn (gen_blockage ());\n }\n \f"}, {"sha": "c47619d742c8597c084b3dfc5635bdaa26c614e9", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1555,19 +1555,10 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n   else if (GET_CODE (RTX) == NOTE\t\t\t\t\t\\\n \t   && NOTE_LINE_NUMBER (RTX) == NOTE_INSN_PROLOGUE_END)\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (profile_block_flag)\t\t\t\t\t\t\\\n-\tLENGTH += FUNCTION_BLOCK_PROFILER_LENGTH;\t\t\t\\\n       if (profile_flag)\t\t\t\t\t\t\t\\\n \tLENGTH += (FUNCTION_PROFILER_LENGTH + REG_PUSH_LENGTH\t\t\\\n \t\t   + REG_POP_LENGTH);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else if (profile_block_flag\t\t\t\t\t\t\\\n-\t   && (GET_CODE (RTX) == CODE_LABEL\t\t\t\t\\\n-\t       || GET_CODE (RTX) == JUMP_INSN\t\t\t\t\\\n-\t       || (GET_CODE (RTX) == INSN\t\t\t\t\\\n-\t\t   && GET_CODE (PATTERN (RTX)) == SEQUENCE\t\t\\\n-\t\t   && GET_CODE (XVECEXP (PATTERN (RTX), 0, 0)) == JUMP_INSN)))\\\n-    LENGTH += BLOCK_PROFILER_LENGTH;\n \n /* Track the state of the last volatile memory reference.  Clear the\n    state with CC_STATUS_INIT for now.  */"}, {"sha": "1d79f8ed3f830eb8108b2f886644ba67ea2bd7d8", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -7505,7 +7505,7 @@ mips_expand_prologue ()\n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */\n \n-  if (profile_flag || profile_block_flag)\n+  if (profile_flag)\n     emit_insn (gen_blockage ());\n }\n \f"}, {"sha": "4fcc27ec2f915fee1ec704acaee3a24ee2d5b127", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -771,26 +771,6 @@ typedef struct { int regs; int lib; int now_varargs; } CUMULATIVE_ARGS;\n #define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n  mmix_function_profiler (FILE, LABELNO)\n \n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)\t\\\n- mmix_function_block_profiler (FILE, LABELNO)\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t\\\n- mmix_block_profiler (FILE, BLOCKNO)\n-\n-#define FUNCTION_BLOCK_PROFILER_EXIT(FILE)\t\\\n- mmix_function_block_profiler_exit PARAMS ((FILE *));\n-\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\\\n-  __asm__ (\"SAVE $255,0\t\t\\n\\t\"\t\t\\\n-\t   \"SUBU $254,$254,8\t\\n\\t\"\t\t\\\n- \t   \"STOU $255,$254,0\")\n-\n-#define MACHINE_STATE_RESTORE(ID)\t\t\\\n-  __asm__ (\"LDOU  $255,$254,0\t\\n\\t\"\t\t\\\n-\t   \"UNSAVE $255,0\")\n-\n-\n-\n /* Node: Varargs */\n \n /* For the moment, let's stick to pushing argument registers on the stack."}, {"sha": "fe358c07fe1e3bd7692528beb24d178695af128f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -52,8 +52,6 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_NO_PROTOTYPE 0\n #endif\n \n-extern int profile_block_flag;\n-\n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n \n@@ -380,8 +378,6 @@ rs6000_override_options (default_cpu)\n   /* Save current -mstring/-mno-string status.  */\n   int string = TARGET_STRING;\n \n-  profile_block_flag = 0;\n-\n   /* Identify the processor type.  */\n   rs6000_select[0].string = default_cpu;\n   rs6000_cpu = TARGET_POWERPC64 ? PROCESSOR_DEFAULT64 : PROCESSOR_DEFAULT;"}, {"sha": "34945b054a97348d27a067a84b68e2a970db1302", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -2495,17 +2495,6 @@ s390_function_prologue (file, lsize)\n \n   /* Profile code (-p, -a, -ax needs some literals).  */\n \n-  if (profile_block_flag && !TARGET_64BIT)\n-    {\n-      s390_profile[0] = s390_force_const_mem_symbol (\"__bb_init_func\", 1, 1);\n-      s390_profile[1] = s390_force_const_mem_symbol (\"__bb_init_trace_func\", 1, 1);\n-      s390_profile[2] = s390_force_const_mem_symbol (\"__bb_trace_func\", 1, 1);\n-      s390_profile[3] = s390_force_const_mem_symbol (\"__bb_trace_ret\", 1, 1);\n-      s390_profile[5] = s390_force_const_mem_symbol (\"__bb\", 0, 1);\n-      s390_profile[6] = s390_force_const_mem_symbol (\".LPBX0\", 0, 0);\n-      s390_profile[7] = s390_force_const_mem_symbol (\".LPBX2\", 0, 0);\n-    }\n-\n   if (profile_flag && !TARGET_64BIT)\n     {\n       static char label[128];"}, {"sha": "12ebceb6800ba224a9a5b90bd859e47e601627eb", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 445, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -855,451 +855,6 @@ do {                                     \t\t\t\\\n \n /* #define PROFILE_BEFORE_PROLOGUE */\n \n-/* There are three profiling modes for basic blocks available.\n-   The modes are selected at compile time by using the options\n-   -a or -ax of the gnu compiler.\n-   The variable `profile_block_flag' will be set according to the\n-   selected option.\n-\n-   profile_block_flag == 0, no option used:\n-\n-      No profiling done.\n-\n-   profile_block_flag == 1, -a option used.\n-\n-      Count frequency of execution of every basic block.\n-\n-   profile_block_flag == 2, -ax option used.\n-\n-      Generate code to allow several different profiling modes at run time. \n-      Available modes are:\n-             Produce a trace of all basic blocks.\n-             Count frequency of jump instructions executed.\n-      In every mode it is possible to start profiling upon entering\n-      certain functions and to disable profiling of some other functions.\n-\n-    The result of basic-block profiling will be written to a file `bb.out'.\n-    If the -ax option is used parameters for the profiling will be read\n-    from file `bb.in'.\n-\n-*/\n-\n-/* The following macro shall output assembler code to FILE\n-   to initialize basic-block profiling.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to call the subroutine `__bb_init_trace_func'\n-\tand pass two parameters to it. The first parameter is\n-\tthe address of a block allocated in the object module.\n-\tThe second parameter is the number of the first basic block\n-\tof the function.\n-\n-\tThe name of the block is a local symbol made with this statement:\n-\t\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tThe number of the first basic block of the function is\n-\tpassed to the macro in BLOCK_OR_LABEL.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tparameter1 <- LPBX0\n-\t\tparameter2 <- BLOCK_OR_LABEL\n-\t\tcall __bb_init_trace_func\n-\n-    else if profile_block_flag != 0\n-\n-\tOutput code to call the subroutine `__bb_init_func'\n-\tand pass one single parameter to it, which is the same\n-\tas the first parameter to `__bb_init_trace_func'.\n-\n-\tThe first word of this parameter is a flag which will be nonzero if\n-\tthe object module has already been initialized.  So test this word\n-\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n-\tNote: When profile_block_flag == 2 the test need not be done\n-\tbut `__bb_init_trace_func' *must* be called.\n-\n-\tBLOCK_OR_LABEL may be used to generate a label number as a\n-\tbranch destination in case `__bb_init_func' will not be called.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tcmp (LPBX0),0\n-\t\tjne local_label\n-\t\tparameter1 <- LPBX0\n-\t\tcall __bb_init_func\n-local_label:\n-\n-*/\n-\n-#undef\tFUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\t\t            \\\n-do\t\t\t\t\t\t\t\t\t            \\\n-  {\t\t\t\t\t\t\t\t\t            \\\n-    if (TARGET_64BIT) \t\t\t\t\t\t                    \\\n-      {\t\t\t\t\t\t\t\t                    \\\n-    \trtx tmp[1];\t                                                            \\\n-\tfprintf (FILE, \"# function block profiler %d \\n\", profile_block_flag);      \\\n-\toutput_asm_insn (\"ipm   0\", tmp);              \t\t    \t            \\\n-\toutput_asm_insn (\"aghi  15,-224\", tmp);                           \t    \\\n-\toutput_asm_insn (\"stmg  14,5,160(15)\", tmp);             \t\t    \\\n-\toutput_asm_insn (\"larl  2,.LPBX0\", tmp);               \t\t    \t    \\\n-\tswitch (profile_block_flag) \t\t\t\t\t            \\\n-\t  {\t\t\t\t\t\t\t\t\t    \\\n-\t  case 2:\t\t\t\t\t\t\t\t    \\\n-\t    if (BLOCK_OR_LABEL < 0x10000) {                                         \\\n-\t      tmp[0] = gen_rtx_CONST_INT (Pmode, (BLOCK_OR_LABEL));                 \\\n-\t      output_asm_insn (\"llill 3,%x0\", tmp);                                 \\\n-\t    } else {                                         \t     \t            \\\n-\t      int bo = BLOCK_OR_LABEL;                                              \\\n-\t      tmp[0] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);                        \\\n-\t      output_asm_insn (\"llill 3,%x0\", tmp);                                 \\\n-\t      tmp[0] = gen_rtx_CONST_INT (Pmode, (bo&0xffff0000)>>16);              \\\n-\t      output_asm_insn (\"iilh 3,%x0\", tmp);                                  \\\n- \t    }                                                                       \\\n-            tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_init_trace_func\");            \\\n-            if (flag_pic)\t\t\t\t\t\t\t    \\\n-              {\t\t\t\t\t\t\t\t\t    \\\n-                tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \t    \\\n-                tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t\t    \\\n-              }\t\t\t\t\t\t\t\t\t    \\\n-            output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t            \\\n-\t    break;\t\t\t\t\t\t\t\t    \\\n-\t  default:\t\t\t\t\t\t\t\t    \\\n-\t    output_asm_insn (\"cli   7(2),0\", tmp);                       \t    \\\n-\t    output_asm_insn (\"jne   2f\", tmp);\t        \t\t            \\\n-            tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_init_func\");                  \\\n-            if (flag_pic)\t\t\t\t\t\t\t    \\\n-              {\t\t\t\t\t\t\t\t\t    \\\n-                tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \t    \\\n-                tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t\t    \\\n-              }\t\t\t\t\t\t\t\t\t    \\\n-            output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t            \\\n-\t    break;\t\t\t\t\t\t\t\t    \\\n-\t  }\t\t\t\t\t\t\t\t\t    \\\n-\toutput_asm_insn (\"2:\", tmp);                                                \\\n-\toutput_asm_insn (\"lmg   14,5,160(15)\", tmp);                                \\\n-\toutput_asm_insn (\"aghi  15,224\", tmp);    \t\t                    \\\n-\toutput_asm_insn (\"spm   0\", tmp);       \t\t\t\t    \\\n-      }\t\t\t\t\t\t\t\t                    \\\n-    else                                                                            \\\n-      {\t\t\t\t\t\t\t\t                    \\\n-    \textern rtx s390_profile[];\t\t\t\t\t\t    \\\n-\tfprintf (FILE, \"# function block profiler %d \\n\", profile_block_flag);      \\\n-\toutput_asm_insn (\"ipm   0\", s390_profile);     \t\t    \t            \\\n-\toutput_asm_insn (\"ahi   15,-128\", s390_profile);                  \t    \\\n-\toutput_asm_insn (\"stm   14,5,96(15)\", s390_profile);     \t\t    \\\n-\toutput_asm_insn (\"l     2,%6\", s390_profile);     \t\t    \t    \\\n-\tif (flag_pic)\t\t\t\t\t\t\t            \\\n-\t  output_asm_insn (\"ar    2,13\", s390_profile);\t\t\t            \\\n-\tswitch (profile_block_flag) \t\t\t\t\t            \\\n-\t  {\t\t\t\t\t\t\t\t\t    \\\n-\t  case 2:\t\t\t\t\t\t\t\t    \\\n-\t    output_asm_insn (\"l     4,%1\", s390_profile);\t\t       \t    \\\n-\t    if (BLOCK_OR_LABEL < 0x8000) {                                          \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (BLOCK_OR_LABEL));        \\\n-\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                         \\\n-\t    } else {                                         \t     \t            \\\n-\t      int bo = BLOCK_OR_LABEL;                                              \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (bo&0xffff8000)>>15);     \\\n-\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                         \\\n-\t      output_asm_insn (\"sll   3,15\", s390_profile);                         \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);               \\\n-\t      output_asm_insn (\"ahi   3,%8\", s390_profile);                         \\\n-\t    }                                                                       \\\n-\t    break;\t\t\t\t\t\t\t\t    \\\n-\t  default:\t\t\t\t\t\t\t\t    \\\n-\t    output_asm_insn (\"l     4,%0\", s390_profile);\t      \t\t    \\\n-\t    output_asm_insn (\"cli   3(2),0\", s390_profile);              \t    \\\n-\t    output_asm_insn (\"jne   2f\", s390_profile);\t\t\t            \\\n-\t    break;\t\t\t\t\t\t\t\t    \\\n-\t  }\t\t\t\t\t\t\t\t\t    \\\n-\tif (flag_pic)\t\t\t\t\t\t\t            \\\n-\t  output_asm_insn (\"bas   14,0(4,13)\", s390_profile);\t       \t            \\\n-\telse\t\t\t\t\t\t\t\t            \\\n-\t  output_asm_insn (\"basr  14,4\", s390_profile);\t                            \\\n-\toutput_asm_insn (\"2:\", s390_profile);                                       \\\n-\toutput_asm_insn (\"lm    14,5,96(15)\", s390_profile);                        \\\n-\toutput_asm_insn (\"ahi   15,128\", s390_profile);\t\t                    \\\n-\toutput_asm_insn (\"spm   0\", s390_profile);\t\t\t\t    \\\n-      }\t\t\t\t\t\t\t\t                    \\\n-  } while (0)\n-\n-/* The following macro shall output assembler code to FILE\n-   to increment a counter associated with basic block number BLOCKNO.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to initialize the global structure `__bb' and\n-\tcall the function `__bb_trace_func' which will increment the\n-\tcounter.\n-\n-\t`__bb' consists of two words. In the first word the number\n-\tof the basic block has to be stored. In the second word\n-\tthe address of a block allocated in the object module \n-\thas to be stored.\n-\n-\tThe basic block number is given by BLOCKNO.\n-\n-\tThe address of the block is given by the label created with \n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tby FUNCTION_BLOCK_PROFILER.\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tmove BLOCKNO -> (__bb)\n-\t\tmove LPBX0 -> (__bb+4)\n-\t\tcall __bb_trace_func\n-\n-\tNote that function `__bb_trace_func' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE\n-\tand MACHINE_STATE_RESTORE. The last two macros will be\n-\tused in the function `__bb_trace_func', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE.\n-\n-   else if profile_block_flag != 0\n-\n-\tOutput code to increment the counter directly.\n-\tBasic blocks are numbered separately from zero within each\n-\tcompiled object module. The count associated with block number\n-\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n-\tthis array is a local symbol made with this statement:\n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result. \n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tinc (LPBX2+4*BLOCKNO)\n-\n-*/\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t                \t           \\\n-do\t\t\t\t\t\t\t\t\t           \\\n-  {\t\t\t\t\t\t\t\t\t           \\\n-    if (TARGET_64BIT)\t\t\t\t                                   \\\n-      {\t\t\t\t\t\t                                   \\\n-    \trtx tmp[1];\t                                                           \\\n-\tfprintf (FILE, \"# block profiler %d block %d \\n\",                          \\\n-\t\t\t profile_block_flag, BLOCKNO); \t                           \\\n-\toutput_asm_insn (\"ipm   14\", tmp);              \t\t           \\\n-\toutput_asm_insn (\"aghi  15,-224\", tmp);                           \t   \\\n-\toutput_asm_insn (\"stmg  14,5,160(15)\", tmp);             \t\t   \\\n-\toutput_asm_insn (\"larl  2,_bb\", tmp);                      \t\t   \\\n-        if ((BLOCKNO*8) < 0x10000) {                                               \\\n-\t  tmp[0] = gen_rtx_CONST_INT (Pmode, (BLOCKNO*8));                         \\\n-\t  output_asm_insn (\"llill 3,%x0\", tmp);                                    \\\n-\t} else {                                              \t                   \\\n-\t  int bo = BLOCKNO*8;                                                      \\\n-\t  tmp[0] = gen_rtx_CONST_INT (Pmode, bo&0xffff);                           \\\n-\t  output_asm_insn (\"llill 3,%x0\", tmp);                                    \\\n-\t  tmp[0] = gen_rtx_CONST_INT (Pmode, (bo&0xffff0000)>>16);                 \\\n-\t  output_asm_insn (\"iilh 3,%x0\", tmp);                                     \\\n-\t}                                                       \t           \\\n-    \tswitch (profile_block_flag) \t\t\t\t\t           \\\n-\t  {\t\t\t\t\t\t\t\t\t   \\\n-\t  case 2:\t\t\t\t\t\t\t\t   \\\n-\t    output_asm_insn (\"stg   3,0(2)\", tmp);              \t     \t   \\\n-    \t    output_asm_insn (\"larl  3,.LPBX0\", tmp);                   \t\t   \\\n-\t    output_asm_insn (\"stg   3,0(2)\", tmp);              \t     \t   \\\n-            tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_trace_func\");                \\\n-            if (flag_pic)\t\t\t\t\t\t\t   \\\n-              {\t\t\t\t\t\t\t\t\t   \\\n-                tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113); \t   \\\n-                tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t\t   \\\n-              }\t\t\t\t\t\t\t\t\t   \\\n-            output_asm_insn (\"brasl\\t14,%0\", tmp);\t\t\t           \\\n-\t    break;\t\t\t\t\t\t\t\t   \\\n-\t  default:\t\t\t\t\t\t\t\t   \\\n-            output_asm_insn (\"larl  2,.LPBX2\", tmp);                   \t\t   \\\n-            output_asm_insn (\"la    2,0(2,3)\", tmp);                   \t\t   \\\n-\t    output_asm_insn (\"lg    3,0(2)\", tmp);              \t     \t   \\\n-    \t    output_asm_insn (\"aghi  3,1\", tmp);                  \t     \t   \\\n-    \t    output_asm_insn (\"stg   3,0(2)\", tmp);              \t     \t   \\\n-    \t    break;\t\t\t\t\t\t\t\t   \\\n-         }\t\t\t\t\t                                   \\\n-\toutput_asm_insn (\"lmg   14,5,160(15)\", tmp);                               \\\n-\toutput_asm_insn (\"ahi   15,224\", tmp);          \t                   \\\n-\toutput_asm_insn (\"spm   14\", tmp);          \t\t\t\t   \\\n-      }\t\t\t\t\t\t                                   \\\n-    else\t\t\t\t\t                                   \\\n-      {\t\t\t\t\t\t                                   \\\n-    \textern rtx s390_profile[];                                                 \\\n-\tfprintf (FILE, \"# block profiler %d block %d \\n\",                          \\\n-\t\t\t profile_block_flag,BLOCKNO); \t                           \\\n-\toutput_asm_insn (\"ipm   14\", s390_profile);     \t\t    \t   \\\n-\toutput_asm_insn (\"ahi   15,-128\", s390_profile);     \t       \t           \\\n-\toutput_asm_insn (\"stm   14,5,96(15)\", s390_profile);     \t\t   \\\n-\tswitch (profile_block_flag) \t\t\t\t\t           \\\n-\t  {\t\t\t\t\t\t\t\t\t   \\\n-\t  case 2:\t\t\t\t\t\t\t\t   \\\n-\t    output_asm_insn (\"l     4,%2\", s390_profile);     \t     \t           \\\n-\t    output_asm_insn (\"l     2,%5\", s390_profile);     \t     \t           \\\n-\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n-\t      output_asm_insn (\"ar    2,13\", s390_profile);\t\t\t   \\\n-\t    if (BLOCKNO < 0x8000) {                                                \\\n-\t      s390_profile[7] = gen_rtx_CONST_INT (Pmode, (BLOCKNO)*4);            \\\n-\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                        \\\n-\t    } else {                                         \t     \t           \\\n-\t      int bo = BLOCKNO;                                                    \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (bo&0xffff8000)>>15);    \\\n-\t      output_asm_insn (\"lhi   3,%8\", s390_profile);                        \\\n-\t      output_asm_insn (\"sll   3,15\", s390_profile);                        \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);              \\\n-\t      output_asm_insn (\"ahi   3,%7\", s390_profile);                        \\\n-\t    }                                                                      \\\n-\t    output_asm_insn (\"st    3,0(2)\", s390_profile);     \t     \t   \\\n-\t    output_asm_insn (\"mvc   0(4,2),%5\", s390_profile);     \t     \t   \\\n-\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n-\t      output_asm_insn (\"bas   14,0(4,13)\", s390_profile);\t\t   \\\n-\t    else\t\t\t\t\t\t\t\t   \\\n-\t      output_asm_insn (\"basr  14,4\", s390_profile);\t                   \\\n-\t    break;\t\t\t\t\t\t\t\t   \\\n-\t  default:\t\t\t\t\t\t\t\t   \\\n-\t    if (BLOCKNO < 0x2000) {                                                \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (BLOCKNO)*4);            \\\n-\t      output_asm_insn (\"lhi   2,%8\", s390_profile);                        \\\n-\t    } else {                                         \t     \t           \\\n-\t      int bo = BLOCKNO*4;                                                  \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, (bo&0xffff8000)>>15);    \\\n-\t      output_asm_insn (\"lhi   2,%8\", s390_profile);                        \\\n-\t      output_asm_insn (\"sll   2,15\", s390_profile);                        \\\n-\t      s390_profile[8] = gen_rtx_CONST_INT (Pmode, bo&0x7fff);              \\\n-\t      output_asm_insn (\"ahi   2,%8\", s390_profile);                        \\\n-\t    }                                                                      \\\n-\t    output_asm_insn (\"a     2,%7\", s390_profile);     \t     \t           \\\n-\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n-\t      output_asm_insn (\"l     3,0(2,13)\", s390_profile);           \t   \\\n-\t    else                                                                   \\\n-\t      output_asm_insn (\"l     3,0(2)\", s390_profile);     \t     \t   \\\n-\t    output_asm_insn (\"ahi   3,1\", s390_profile);         \t     \t   \\\n-\t    if (flag_pic)\t\t\t\t\t\t\t   \\\n-\t      output_asm_insn (\"st    3,0(2,13)\", s390_profile);          \t   \\\n-\t    else                                                                   \\\n-\t      output_asm_insn (\"st    3,0(2)\", s390_profile);     \t     \t   \\\n-\t    break;\t\t\t\t\t\t\t\t   \\\n-\t  }\t\t\t\t\t\t\t\t\t   \\\n-\toutput_asm_insn (\"lm    14,5,96(15)\", s390_profile);                       \\\n-\toutput_asm_insn (\"ahi   15,128\", s390_profile);\t\t                   \\\n-\toutput_asm_insn (\"spm   14\", s390_profile);\t\t\t\t   \\\n-     }                                                                             \\\n-  } while (0)\n-\n-\n-/* The following macro shall output assembler code to FILE\n-   to indicate a return from function during basic-block profiling.\n-\n-   If profiling_block_flag == 2:\n-\n-\tOutput assembler code to call function `__bb_trace_ret'.\n-\n-\tNote that function `__bb_trace_ret' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE_RET\n-\tand MACHINE_STATE_RESTORE_RET. The last two macros will be\n-\tused in the function `__bb_trace_ret', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE_RET.\n-\n-   else if profiling_block_flag != 0:\n-\n-\tThe macro will not be used, so it need not distinguish\n-\tthese cases.\n-*/\n-\n-#define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n-do {                                                                       \\\n-    if (TARGET_64BIT)\t\t\t\t                           \\\n-      {\t\t\t\t\t\t                           \\\n-    \trtx tmp[1];\t                                                   \\\n-\tfprintf (FILE, \"# block profiler exit \\n\");                        \\\n-\toutput_asm_insn (\"ipm   14\", tmp);                                 \\\n-\toutput_asm_insn (\"aghi  15,-224\", tmp);              \t       \t   \\\n-\toutput_asm_insn (\"stmg  14,5,160(15)\", tmp);              \t   \\\n-        tmp[0] = gen_rtx_SYMBOL_REF (Pmode, \"__bb_trace_ret\");             \\\n-        if (flag_pic)\t\t\t\t\t\t\t   \\\n-          {\t\t\t\t\t\t\t\t   \\\n-            tmp[0] = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, tmp[0]), 113);   \\\n-            tmp[0] = gen_rtx_CONST (Pmode, tmp[0]);\t\t\t   \\\n-          }\t\t\t\t\t\t\t\t   \\\n-    \toutput_asm_insn (\"brasl 14,%0\", tmp);                       \t   \\\n-\toutput_asm_insn (\"lmg   14,5,160(15)\", tmp);              \t   \\\n-\toutput_asm_insn (\"aghi  15,224\", tmp);              \t       \t   \\\n-    \toutput_asm_insn (\"spm   14\", tmp);                                 \\\n-      }                                                                    \\\n-    else                                                                   \\\n-      {                                                                    \\\n-    \textern rtx s390_profile[];\t\t\t\t           \\\n-\tfprintf (FILE, \"# block profiler exit \\n\");                        \\\n-\toutput_asm_insn (\"ipm   14\", s390_profile);     \t\t   \\\n-\toutput_asm_insn (\"ahi   15,-128\", s390_profile);     \t       \t   \\\n-\toutput_asm_insn (\"stm   14,5,96(15)\", s390_profile);     \t   \\\n-\toutput_asm_insn (\"l     4,%3\", s390_profile);\t\t      \t   \\\n-\tif (flag_pic)\t\t\t\t\t\t\t   \\\n-\t  output_asm_insn (\"bas   14,0(4,13)\", s390_profile);\t           \\\n-\telse\t\t\t\t\t\t\t\t   \\\n-\t  output_asm_insn (\"basr  14,4\", s390_profile);\t                   \\\n-\toutput_asm_insn (\"lm    14,5,96(15)\", s390_profile);               \\\n-\toutput_asm_insn (\"ahi   15,128\", s390_profile);\t\t           \\\n-\toutput_asm_insn (\"spm   14\", s390_profile);\t\t\t   \\\n-     }                                                                     \\\n-  } while (0)\n-\n-/* The function `__bb_trace_func' is called in every basic block\n-   and is not allowed to change the machine state. Saving (restoring)\n-   the state can either be done in the BLOCK_PROFILER macro,\n-   before calling function (rsp. after returning from function)\n-   `__bb_trace_func', or it can be done inside the function by\n-   defining the macros:\n-\n-\tMACHINE_STATE_SAVE(ID)\n-\tMACHINE_STATE_RESTORE(ID)\n-\n-   In the latter case care must be taken, that the prologue code\n-   of function `__bb_trace_func' does not already change the\n-   state prior to saving it with MACHINE_STATE_SAVE.\n-\n-   The parameter `ID' is a string identifying a unique macro use.\n-\n-   On the s390 all save/restore is done in macros above\n-*/\n-\n-/*\n-#define MACHINE_STATE_SAVE(ID) \\\n-      fprintf (FILE, \"\\tahi   15,-128 # save state\\n\");\t\t\t  \\\n-      fprintf (FILE, \"\\tstm   14,5,96(15)\\n\");\t\t\t\t  \\\n-\n-#define MACHINE_STATE_RESTORE(ID) \\\n-      fprintf (FILE, \"\\tlm    14,5,96(15) # restore state\\n\");            \\\n-      fprintf (FILE, \"\\tahi   15,128\\n\");\t\t \t\t  \\\n-*/\n-\n-\n /* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n    pointer does not matter (provided there is a frame pointer).  */\n "}, {"sha": "55c833f24a878a084e074ae7ffd02bcaa61897ed", "filename": "gcc/config/sparc/linux-aout.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Flinux-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Flinux-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux-aout.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -96,21 +96,3 @@ Boston, MA 02111-1307, USA.  */\n #define ASM_SPEC \\\n   \"%{V} %{v:%{!V:-V}} %{n} %{T} %{Ym,*} %{Wa,*:%*} -s %{fpic:-K PIC} %{fPIC:-K PIC}\"\n \f\n-/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n-   traps available which can get and set the condition codes\n-   reliably.  */\n-#undef MACHINE_STATE_SAVE\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n-  unsigned long int ms_flags, ms_saveret;\t\t\\\n-  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n-\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n-\n-#undef MACHINE_STATE_RESTORE\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n-  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n-\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n-\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n-\t       : /* no outputs */\t\t\t\\\n-\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}, {"sha": "dff005ba360872288947789a0e3d3f19e3d150d1", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -243,21 +243,3 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n #endif\n \f\n-/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n-   traps available which can get and set the condition codes\n-   reliably.  */\n-#undef MACHINE_STATE_SAVE\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n-  unsigned long int ms_flags, ms_saveret;\t\t\\\n-  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n-\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n-\n-#undef MACHINE_STATE_RESTORE\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n-  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n-\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n-\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n-\t       : /* no outputs */\t\t\t\\\n-\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}, {"sha": "62f0c742160bc8aea5967501c0b3a7df0edc1801", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -368,23 +368,3 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* #define DWARF_OFFSET_SIZE PTR_SIZE */\n \f\n-#if TARGET_ARCH32\n-/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n-   traps available which can get and set the condition codes\n-   reliably.  */\n-#undef MACHINE_STATE_SAVE\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n-  unsigned long int ms_flags, ms_saveret;\t\t\\\n-  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n-\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n-\n-#undef MACHINE_STATE_RESTORE\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n-  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n-\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n-\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n-\t       : /* no outputs */\t\t\t\\\n-\t       : \"r\" (ms_flags), \"r\" (ms_saveret));\n-#endif /* sparc32 */"}, {"sha": "9f6e38c25960e45359d8ee94e1b2f832766fee91", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -225,27 +225,6 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT (MASK_EPILOGUE + MASK_FPU + MASK_V8PLUS + MASK_LONG_DOUBLE_128)\n \f\n-#if TARGET_ARCH32\n-/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n-   traps available which can get and set the condition codes\n-   reliably.  */\n-#undef MACHINE_STATE_SAVE\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n-  unsigned long int ms_flags, ms_saveret;\t\t\\\n-  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n-\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n-\n-#undef MACHINE_STATE_RESTORE\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n-  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n-\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n-\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n-\t       : /* no outputs */\t\t\t\\\n-\t       : \"r\" (ms_flags), \"r\" (ms_saveret));\n-#endif /* sparc32 */\n-\f\n /*\n  * Attempt to turn on access permissions for the stack.\n  *"}, {"sha": "4f9070fd4ca5c309b3bdb060962b3f7e8acb243d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 3, "deletions": 285, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -404,7 +404,7 @@ sparc_override_options ()\n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n \n-  if ((profile_flag || profile_block_flag)\n+  if ((profile_flag)\n       && sparc_cmodel != CM_32 && sparc_cmodel != CM_MEDLOW)\n     {\n       error (\"profiling does not support code models other than medlow\");\n@@ -2525,7 +2525,7 @@ eligible_for_sibcall_delay (trial)\n   if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n     return 0;\n \n-  if (get_attr_length (trial) != 1 || profile_block_flag == 2)\n+  if (get_attr_length (trial) != 1)\n     return 0;\n \n   pat = PATTERN (trial);\n@@ -3645,14 +3645,7 @@ sparc_nonflat_function_epilogue (file, size, leaf_function)\n       final_scan_insn (get_last_insn (), file, 0, 0, 1);\n     }\n \n-#ifdef FUNCTION_BLOCK_PROFILER_EXIT\n-  else if (profile_block_flag == 2)\n-    {\n-      FUNCTION_BLOCK_PROFILER_EXIT(file);\n-    }\n-#endif\n-\n-  else if (current_function_epilogue_delay_list == 0)\n+  if (current_function_epilogue_delay_list == 0)\n     {\n       /* If code does not drop into the epilogue, we need\n \t do nothing except output pending case vectors.  */\n@@ -8433,281 +8426,6 @@ sparc_function_profiler (file, labelno)\n }\n \n \n-/* The following macro shall output assembler code to FILE\n-   to initialize basic-block profiling.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to call the subroutine `__bb_init_trace_func'\n-\tand pass two parameters to it. The first parameter is\n-\tthe address of a block allocated in the object module.\n-\tThe second parameter is the number of the first basic block\n-\tof the function.\n-\n-\tThe name of the block is a local symbol made with this statement:\n-\t\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tThe number of the first basic block of the function is\n-\tpassed to the macro in BLOCK_OR_LABEL.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tparameter1 <- LPBX0\n-\t\tparameter2 <- BLOCK_OR_LABEL\n-\t\tcall __bb_init_trace_func\n-\n-    else if profile_block_flag != 0\n-\n-\tOutput code to call the subroutine `__bb_init_func'\n-\tand pass one single parameter to it, which is the same\n-\tas the first parameter to `__bb_init_trace_func'.\n-\n-\tThe first word of this parameter is a flag which will be nonzero if\n-\tthe object module has already been initialized.  So test this word\n-\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n-\tNote: When profile_block_flag == 2 the test need not be done\n-\tbut `__bb_init_trace_func' *must* be called.\n-\n-\tBLOCK_OR_LABEL may be used to generate a label number as a\n-\tbranch destination in case `__bb_init_func' will not be called.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tcmp (LPBX0),0\n-\t\tjne local_label\n-\t\tparameter1 <- LPBX0\n-\t\tcall __bb_init_func\n-\t    local_label:\n-\n-*/\n-\n-void\n-sparc_function_block_profiler(file, block_or_label)\n-     FILE *file;\n-     int block_or_label;\n-{\n-  char LPBX[32];\n-  ASM_GENERATE_INTERNAL_LABEL (LPBX, \"LPBX\", 0);\n-\n-  if (profile_block_flag == 2)\n-    {\n-      fputs (\"\\tsethi\\t%hi(\", file);\n-      assemble_name (file, LPBX);\n-      fputs (\"), %o0\\n\", file);\n-  \n-      fprintf (file, \"\\tsethi\\t%%hi(%d), %%o1\\n\", block_or_label);\n-\n-      fputs (\"\\tor\\t%o0, %lo(\", file);\n-      assemble_name (file, LPBX);\n-      fputs (\"), %o0\\n\", file);\n-  \n-      fprintf (file, \"\\tcall\\t%s__bb_init_trace_func\\n\", user_label_prefix);\n-\n-      fprintf (file, \"\\t or\\t%%o1, %%lo(%d), %%o1\\n\", block_or_label);\n-    }\n-  else if (profile_block_flag != 0)\n-    {\n-      char LPBY[32];\n-      ASM_GENERATE_INTERNAL_LABEL (LPBY, \"LPBY\", block_or_label);\n-\n-      fputs (\"\\tsethi\\t%hi(\", file);\n-      assemble_name (file, LPBX);\n-      fputs (\"), %o0\\n\", file);\n-      \n-      fputs (\"\\tld\\t[%lo(\", file);\n-      assemble_name (file, LPBX);\n-      fputs (\")+%o0], %o1\\n\", file);\n-\n-      fputs (\"\\ttst\\t%o1\\n\", file);\n-\n-      if (TARGET_V9)\n-\t{\n-\t  fputs (\"\\tbne,pn\\t%icc,\", file);\n-\t  assemble_name (file, LPBY);\n-\t  putc ('\\n', file);\n-\t}\n-      else\n-\t{\n-\t  fputs (\"\\tbne\\t\", file);\n-\t  assemble_name (file, LPBY);\n-\t  putc ('\\n', file);\n-\t}\n-\n-      fputs (\"\\t or\\t%o0, %lo(\", file);\n-      assemble_name (file, LPBX);\n-      fputs (\"), %o0\\n\", file);\n-\n-      fprintf (file, \"\\tcall\\t%s__bb_init_func\\n\\t nop\\n\", user_label_prefix);\n-\n-      ASM_OUTPUT_INTERNAL_LABEL (file, \"LPBY\", block_or_label);\n-    }\n-}\n-\n-/* The following macro shall output assembler code to FILE\n-   to increment a counter associated with basic block number BLOCKNO.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to initialize the global structure `__bb' and\n-\tcall the function `__bb_trace_func' which will increment the\n-\tcounter.\n-\n-\t`__bb' consists of two words. In the first word the number\n-\tof the basic block has to be stored. In the second word\n-\tthe address of a block allocated in the object module \n-\thas to be stored.\n-\n-\tThe basic block number is given by BLOCKNO.\n-\n-\tThe address of the block is given by the label created with \n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tby FUNCTION_BLOCK_PROFILER.\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tmove BLOCKNO -> (__bb)\n-\t\tmove LPBX0 -> (__bb+4)\n-\t\tcall __bb_trace_func\n-\n-\tNote that function `__bb_trace_func' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE\n-\tand MACHINE_STATE_RESTORE. The last two macros will be\n-\tused in the function `__bb_trace_func', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE.\n-\n-   else if profile_block_flag != 0\n-\n-\tOutput code to increment the counter directly.\n-\tBasic blocks are numbered separately from zero within each\n-\tcompiled object module. The count associated with block number\n-\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n-\tthis array is a local symbol made with this statement:\n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result. \n-\n-\tIf described in a virtual assembler language, the code to be\n-\toutput looks like:\n-\n-\t\tinc (LPBX2+4*BLOCKNO)\n-\n-*/\n-\n-void\n-sparc_block_profiler(file, blockno)\n-     FILE *file;\n-     int blockno;\n-{\n-  char LPBX[32];\n-  int bbreg = TARGET_ARCH64 ? 4 : 2;\n-\n-  if (profile_block_flag == 2)\n-    {\n-      ASM_GENERATE_INTERNAL_LABEL (LPBX, \"LPBX\", 0);\n-\n-      fprintf (file, \"\\tsethi\\t%%hi(%s__bb), %%g1\\n\", user_label_prefix);\n-      fprintf (file, \"\\tsethi\\t%%hi(%d), %%g%d\\n\", blockno, bbreg);\n-      fprintf (file, \"\\tor\\t%%g1, %%lo(%s__bb), %%g1\\n\", user_label_prefix);\n-      fprintf (file, \"\\tor\\t%%g%d, %%lo(%d), %%g%d\\n\", bbreg, blockno, bbreg);\n-\n-      fprintf (file, \"\\tst\\t%%g%d, [%%g1]\\n\", bbreg);\n-\n-      fputs (\"\\tsethi\\t%hi(\", file);\n-      assemble_name (file, LPBX);\n-      fprintf (file, \"), %%g%d\\n\", bbreg);\n-  \n-      fputs (\"\\tor\\t%o2, %lo(\", file);\n-      assemble_name (file, LPBX);\n-      fprintf (file, \"), %%g%d\\n\", bbreg);\n-  \n-      fprintf (file, \"\\tst\\t%%g%d, [%%g1 + 4]\\n\", bbreg);\n-      fprintf (file, \"\\tmov\\t%%o7, %%g%d\\n\", bbreg);\n-\n-      fprintf (file, \"\\tcall\\t%s__bb_trace_func\\n\\t nop\\n\", user_label_prefix);\n-\n-      fprintf (file, \"\\tmov\\t%%g%d, %%o7\\n\", bbreg);\n-    }\n-  else if (profile_block_flag != 0)\n-    {\n-      ASM_GENERATE_INTERNAL_LABEL (LPBX, \"LPBX\", 2);\n-\n-      fputs (\"\\tsethi\\t%hi(\", file);\n-      assemble_name (file, LPBX);\n-      fprintf (file, \"+%d), %%g1\\n\", blockno*4);\n-\n-      fputs (\"\\tld\\t[%g1+%lo(\", file);\n-      assemble_name (file, LPBX);\n-      if (TARGET_ARCH64 && USE_AS_OFFSETABLE_LO10)\n-\tfprintf (file, \")+%d], %%g%d\\n\", blockno*4, bbreg);\n-      else\n-\tfprintf (file, \"+%d)], %%g%d\\n\", blockno*4, bbreg);\n-\n-      fprintf (file, \"\\tadd\\t%%g%d, 1, %%g%d\\n\", bbreg, bbreg);\n-\n-      fprintf (file, \"\\tst\\t%%g%d, [%%g1+%%lo(\", bbreg);\n-      assemble_name (file, LPBX);\n-      if (TARGET_ARCH64 && USE_AS_OFFSETABLE_LO10)\n-\tfprintf (file, \")+%d]\\n\", blockno*4);\n-      else\n-\tfprintf (file, \"+%d)]\\n\", blockno*4);\n-    }\n-}\n-\n-/* The following macro shall output assembler code to FILE\n-   to indicate a return from function during basic-block profiling.\n-\n-   If profile_block_flag == 2:\n-\n-\tOutput assembler code to call function `__bb_trace_ret'.\n-\n-\tNote that function `__bb_trace_ret' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE_RET\n-\tand MACHINE_STATE_RESTORE_RET. The last two macros will be\n-\tused in the function `__bb_trace_ret', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE_RET.\n-\n-   else if profile_block_flag != 0:\n-\n-\tThe macro will not be used, so it need not distinguish\n-\tthese cases.\n-*/\n-\n-void\n-sparc_function_block_profiler_exit(file)\n-     FILE *file;\n-{\n-  if (profile_block_flag == 2)\n-    fprintf (file, \"\\tcall\\t%s__bb_trace_ret\\n\\t nop\\n\", user_label_prefix);\n-  else\n-    abort ();\n-}\n-\n /* Mark ARG, which is really a struct ultrasparc_pipline_state *, for\n    GC.  */\n "}, {"sha": "e287a7c297271ae2491ab5a44d5d6c40ab619c52", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 167, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -388,7 +388,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \n #define OVERRIDE_OPTIONS \\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    if (profile_flag || profile_block_flag || profile_arc_flag)\t\t\\\n+    if (profile_flag || profile_arc_flag)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tif (flag_pic)\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n@@ -1071,13 +1071,6 @@ do\t\t\t\t\t\t\t\t\\\n \t/* Disable leaf functions */\t\t\t\t\\\n \tmemset (sparc_leaf_regs, 0, FIRST_PSEUDO_REGISTER);\t\\\n       }\t\t\t\t\t\t\t\t\\\n-    if (profile_block_flag)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\t/* %g1 and %g2 (sparc32) resp. %g4 (sparc64) must be\t\\\n-\t   fixed, because BLOCK_PROFILER uses them.  */\t\t\\\n-\tfixed_regs[1] = 1;\t\t\t\t\t\\\n-\tfixed_regs[TARGET_ARCH64 ? 4 : 2] = 1;\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)\n \n@@ -1869,165 +1862,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Set the name of the mcount function for the system.  */\n \n #define MCOUNT_FUNCTION \"*mcount\"\n-\n-/* The following macro shall output assembler code to FILE\n-   to initialize basic-block profiling.  */\n-\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL) \\\n-  sparc_function_block_profiler(FILE, BLOCK_OR_LABEL)\n-\n-/* The following macro shall output assembler code to FILE\n-   to increment a counter associated with basic block number BLOCKNO.  */\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n-  sparc_block_profiler (FILE, BLOCKNO)\n-\n-/* The following macro shall output assembler code to FILE\n-   to indicate a return from function during basic-block profiling.  */\n-\n-#define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n-  sparc_function_block_profiler_exit(FILE)\n-\n-#ifdef IN_LIBGCC2\n-\n-/* The function `__bb_trace_func' is called in every basic block\n-   and is not allowed to change the machine state. Saving (restoring)\n-   the state can either be done in the BLOCK_PROFILER macro,\n-   before calling function (rsp. after returning from function)\n-   `__bb_trace_func', or it can be done inside the function by\n-   defining the macros:\n-\n-\tMACHINE_STATE_SAVE(ID)\n-\tMACHINE_STATE_RESTORE(ID)\n-\n-   In the latter case care must be taken, that the prologue code\n-   of function `__bb_trace_func' does not already change the\n-   state prior to saving it with MACHINE_STATE_SAVE.\n-\n-   The parameter `ID' is a string identifying a unique macro use.\n-\n-   On sparc it is sufficient to save the psw register to memory.\n-   Unfortunately the psw register can be read in supervisor mode only,\n-   so we read only the condition codes by using branch instructions\n-   and hope that this is enough.\n-   \n-   On V9, life is much sweater:  there is a user accessible %ccr\n-   register, but we use it for 64bit libraries only.  */\n-\n-#if TARGET_ARCH32\n-\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\\\n-  int ms_flags, ms_saveret;\t\t\t\\\n-  asm volatile(\t\t\t\t\t\\\n-\t\"mov %%g2,%1\\n\\\n-\tmov %%g0,%0\\n\\\n-\tbe,a LFLGNZ\"ID\"\\n\\\n-\tor %0,4,%0\\n\\\n-LFLGNZ\"ID\":\\n\\\n-\tbcs,a LFLGNC\"ID\"\\n\\\n-\tor %0,1,%0\\n\\\n-LFLGNC\"ID\":\\n\\\n-\tbvs,a LFLGNV\"ID\"\\n\\\n-\tor %0,2,%0\\n\\\n-LFLGNV\"ID\":\\n\\\n-\tbneg,a LFLGNN\"ID\"\\n\\\n-\tor %0,8,%0\\n\\\n-LFLGNN\"ID\":\"\t\t\t\t\t\\\n-\t: \"=r\"(ms_flags), \"=r\"(ms_saveret));\n-\n-#else\n-\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\\\n-  unsigned long ms_flags, ms_saveret;\t\t\\\n-  asm volatile(\t\t\t\t\t\\\n-\t\"mov %%g4,%1\\n\\\n-\trd %%ccr,%0\"\t\t\t\t\\\n-\t: \"=r\"(ms_flags), \"=r\"(ms_saveret));\n-\n-#endif\n-\n-/* On sparc MACHINE_STATE_RESTORE restores the psw register from memory.\n-   The psw register can be written in supervisor mode only,\n-   which is true even for simple condition codes.\n-   We use some combination of instructions to produce the\n-   proper condition codes, but some flag combinations can not\n-   be generated in this way. If this happens an unimplemented\n-   instruction will be executed to abort the program.  */\n-\n-#if TARGET_ARCH32\n-\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\t\\\n-{ extern char flgtab[] __asm__(\"LFLGTAB\"ID);\t\t\t\\\n-  int scratch;\t\t\t\t\t\t\t\\\n-  asm volatile (\t\t\t\t\t\t\\\n-\t\"jmpl %2+%1,%%g0\\n\\\n-    ! Do part of VC in the delay slot here, as it needs 3 insns.\\n\\\n-\t addcc 2,%3,%%g0\\n\\\n-LFLGTAB\" ID \":\\n\\\n-    ! 0\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t orcc 1,%%g0,%%g0\\n\\\n-    ! C\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t addcc 2,%3,%%g0\\n\\\n-    ! V\\n\\\n-\tunimp\\n\\\n-\tnop\\n\\\n-    ! VC\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t addxcc %4,%4,%0\\n\\\n-    ! Z\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t subcc %%g0,%%g0,%%g0\\n\\\n-    ! ZC\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t addcc 1,%3,%0\\n\\\n-    ! ZVC\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t addcc %4,%4,%0\\n\\\n-    ! N\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t orcc %%g0,-1,%%g0\\n\\\n-    ! NC\\n\\\n-\tba LFLGRET\"ID\"\\n\\\n-\t addcc %%g0,%3,%%g0\\n\\\n-    ! NV\\n\\\n-\tunimp\\n\\\n-\tnop\\n\\\n-    ! NVC\\n\\\n-\tunimp\\n\\\n-\tnop\\n\\\n-    ! NZ\\n\\\n-\tunimp\\n\\\n-\tnop\\n\\\n-    ! NZC\\n\\\n-\tunimp\\n\\\n-\tnop\\n\\\n-    ! NZV\\n\\\n-\tunimp\\n\\\n-\tnop\\n\\\n-    ! NZVC\\n\\\n-\tunimp\\n\\\n-\tnop\\n\\\n-LFLGRET\"ID\":\\n\\\n-\tmov %5,%%g2\"\t\t\t\t\t\t\\\n-\t: \"=r\"(scratch)\t\t\t\t\t\t\\\n-\t: \"r\"(ms_flags*8), \"r\"(flgtab), \"r\"(-1),\t\t\\\n-\t  \"r\"(0x80000000), \"r\"(ms_saveret)\t\t\t\\\n-\t: \"cc\", \"g2\"); }\n-\n-#else\n-\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\t\\\n-  asm volatile (\t\t\t\t\t\t\\\n-\t\"wr %0,0,%%ccr\\n\\\n-\tmov %1,%%g4\"\t\t\t\t\t\t\\\n-\t: : \"r\"(ms_flags), \"r\"(ms_saveret)\t\t\t\\\n-\t: \"cc\", \"g4\");\n-\n-#endif\n-\n-#endif /* IN_LIBGCC2 */\n \f\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in"}, {"sha": "e79a4c8d32901bb24735ca972bca7c443fd224a7", "filename": "gcc/config/sparc/sun4o3.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsun4o3.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -9,22 +9,3 @@\n /* LINK_SPEC is needed only for SunOS 4.  */\n \n #undef LINK_SPEC\n-\n-/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n-   traps available which can get and set the condition codes\n-   reliably.  */\n-#undef MACHINE_STATE_SAVE\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n-  unsigned long int ms_flags, ms_saveret;\t\t\\\n-  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n-\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n-\n-#undef MACHINE_STATE_RESTORE\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n-  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n-\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n-\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n-\t       : /* no outputs */\t\t\t\\\n-\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}, {"sha": "e5ec1ee3a662eab500521b587cdda2edfc862227", "filename": "gcc/config/sparc/sunos4.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsunos4.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -30,25 +30,6 @@ Boston, MA 02111-1307, USA.  */\n /* The Sun as doesn't like unaligned data.  */\n #define DWARF2_UNWIND_INFO 0\n \n-/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n-   traps available which can get and set the condition codes\n-   reliably.  */\n-#undef MACHINE_STATE_SAVE\n-#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n-  unsigned long int ms_flags, ms_saveret;\t\t\\\n-  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n-\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n-\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n-\n-#undef MACHINE_STATE_RESTORE\n-#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n-  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n-\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n-\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n-\t       : /* no outputs */\t\t\t\\\n-\t       : \"r\" (ms_flags), \"r\" (ms_saveret));\n-\n /* SunOS has on_exit instead of atexit.  */\n /* The man page says it returns int.  */\n extern int on_exit PARAMS ((void *, void *));"}, {"sha": "5d3d90f092a1fd3ca7af634fa813d8e9f0faec1f", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -2451,139 +2451,6 @@ typedef int CUMULATIVE_ARGS;\n    function prologue.  Normally, the profiling code comes after.  */\n /* #define PROFILE_BEFORE_PROLOGUE */\n \n-/* A C statement or compound statement to output to FILE some assembler code to\n-   initialize basic-block profiling for the current object module.  The global\n-   compile flag `profile_block_flag' distingishes two profile modes.\n-\n-   profile_block_flag != 2'\n-        Output code to call the subroutine `__bb_init_func' once per\n-        object module, passing it as its sole argument the address of\n-        a block allocated in the object module.\n-\n-        The name of the block is a local symbol made with this\n-        statement:\n-\n-             ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-        Of course, since you are writing the definition of\n-        `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro,\n-        you can take a short cut in the definition of this macro and\n-        use the name that you know will result.\n-\n-        The first word of this block is a flag which will be nonzero\n-        if the object module has already been initialized.  So test\n-        this word first, and do not call `__bb_init_func' if the flag\n-        is nonzero.  BLOCK_OR_LABEL contains a unique number which\n-        may be used to generate a label as a branch destination when\n-        `__bb_init_func' will not be called.\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-\n-               cmp (LPBX0),0\n-               bne local_label\n-               parameter1 <- LPBX0\n-               call __bb_init_func\n-             local_label:\n-\n-   profile_block_flag == 2'\n-        Output code to call the subroutine `__bb_init_trace_func' and\n-        pass two parameters to it.  The first parameter is the same as\n-        for `__bb_init_func'.  The second parameter is the number of\n-        the first basic block of the function as given by\n-        BLOCK_OR_LABEL.  Note that `__bb_init_trace_func' has to be\n-        called, even if the object module has been initialized\n-        already.\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-             parameter1 <- LPBX0\n-             parameter2 <- BLOCK_OR_LABEL\n-             call __bb_init_trace_func  */\n-/* #define FUNCTION_BLOCK_PROFILER (FILE, LABELNO) */\n-\n-/* A C statement or compound statement to output to FILE some assembler code to\n-   increment the count associated with the basic block number BLOCKNO.  The\n-   global compile flag `profile_block_flag' distingishes two profile modes.\n-\n-   profile_block_flag != 2'\n-        Output code to increment the counter directly.  Basic blocks\n-        are numbered separately from zero within each compilation.\n-        The count associated with block number BLOCKNO is at index\n-        BLOCKNO in a vector of words; the name of this array is a\n-        local symbol made with this statement:\n-\n-             ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-        Of course, since you are writing the definition of\n-        `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro,\n-        you can take a short cut in the definition of this macro and\n-        use the name that you know will result.\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-\n-             inc (LPBX2+4*BLOCKNO)\n-\n-   profile_block_flag == 2'\n-        Output code to initialize the global structure `__bb' and\n-        call the function `__bb_trace_func', which will increment the\n-        counter.\n-\n-        `__bb' consists of two words.  In the first word, the current\n-        basic block number, as given by BLOCKNO, has to be stored.  In\n-        the second word, the address of a block allocated in the\n-        object module has to be stored.  The address is given by the\n-        label created with this statement:\n-\n-             ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-        Described in assembler language, the code to be output looks\n-        like:\n-             move BLOCKNO -> (__bb)\n-             move LPBX0 -> (__bb+4)\n-             call __bb_trace_func  */\n-/* #define BLOCK_PROFILER(FILE, BLOCKNO) */\n-\n-/* A C statement or compound statement to output to FILE assembler\n-   code to call function `__bb_trace_ret'.  The assembler code should\n-   only be output if the global compile flag `profile_block_flag' ==\n-   2.  This macro has to be used at every place where code for\n-   returning from a function is generated\n-   (e.g. `TARGET_ASM_FUNCTION_EPILOGUE').  Although you have to write\n-   the definition of `TARGET_ASM_FUNCTION_EPILOGUE' as well, you have\n-   to define this macro to tell the compiler, that the proper call to\n-   `__bb_trace_ret' is produced.  */\n-/* #define FUNCTION_BLOCK_PROFILER_EXIT(FILE) */\n-\n-/* A C statement or compound statement to save all registers, which may be\n-   clobbered by a function call, including condition codes.  The `asm'\n-   statement will be mostly likely needed to handle this task.  Local labels in\n-   the assembler code can be concatenated with the string ID, to obtain a\n-   unique lable name.\n-\n-   Registers or condition codes clobbered by\n-   `TARGET_ASM_FUNCTION_PROLOGUE' or `TARGET_ASM_FUNCTION_EPILOGUE'\n-   must be saved in the macros `FUNCTION_BLOCK_PROFILER',\n-   `FUNCTION_BLOCK_PROFILER_EXIT' and `BLOCK_PROFILER' prior calling\n-   `__bb_init_trace_func', `__bb_trace_ret' and `__bb_trace_func'\n-   respectively.  */\n-/* #define MACHINE_STATE_SAVE(ID) */\n-\n-/* A C statement or compound statement to restore all registers, including\n-   condition codes, saved by `MACHINE_STATE_SAVE'.\n-\n-   Registers or condition codes clobbered by `TARGET_ASM_FUNCTION_PROLOGUE' or\n-   `TARGET_ASM_FUNCTION_EPILOGUE' must be restored in the macros\n-   `FUNCTION_BLOCK_PROFILER', `FUNCTION_BLOCK_PROFILER_EXIT' and\n-   `BLOCK_PROFILER' after calling `__bb_init_trace_func', `__bb_trace_ret' and\n-   `__bb_trace_func' respectively.  */\n-/* #define MACHINE_STATE_RESTORE(ID) */\n-\n-/* A C function or functions which are needed in the library to support block\n-   profiling.  */\n-/* #define BLOCK_PROFILER_CODE */\n-\n \f\n /* If the target has particular reasons why a function cannot be inlined,\n    it may define the TARGET_CANNOT_INLINE_P.  This macro takes one argument,"}, {"sha": "e9175ecd545cc0d869e415ba37b71777ba8f045d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -240,7 +240,7 @@ in the following sections.\n @item Debugging Options\n @xref{Debugging Options,,Options for Debugging Your Program or GCC}.\n @gccoptlist{\n--a  -ax  -d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion @gol\n+-d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion @gol\n -fdump-unnumbered \n -fdump-class-hierarchy@r{[}-@var{n}@r{]} @gol\n -fdump-tree-original@r{[}-@var{n}@r{]} -fdump-tree-optimized@r{[}-@var{n}@r{]} @gol\n@@ -2753,80 +2753,6 @@ pass when it finishes.\n Makes the compiler print some statistics about permanent memory\n allocation when it finishes.\n \n-@item -ax\n-@opindex ax\n-Generate extra code to profile basic blocks.  Your executable will\n-produce output that is a superset of that produced when @option{-a} is\n-used.  Additional output is the source and target address of the basic\n-blocks where a jump takes place, the number of times a jump is executed,\n-and (optionally) the complete sequence of basic blocks being executed.\n-The output is appended to file @file{bb.out}.\n-\n-You can examine different profiling aspects without recompilation.  Your\n-executable will read a list of function names from file @file{bb.in}.\n-Profiling starts when a function on the list is entered and stops when\n-that invocation is exited.  To exclude a function from profiling, prefix\n-its name with @samp{-}.  If a function name is not unique, you can\n-disambiguate it by writing it in the form\n-@samp{/path/filename.d:functionname}.  Your executable will write the\n-available paths and filenames in file @file{bb.out}.\n-\n-Several function names have a special meaning:\n-@table @code\n-@item __bb_jumps__\n-Write source, target and frequency of jumps to file @file{bb.out}.\n-@item __bb_hidecall__\n-Exclude function calls from frequency count.\n-@item __bb_showret__\n-Include function returns in frequency count.\n-@item __bb_trace__\n-Write the sequence of basic blocks executed to file @file{bbtrace.gz}.\n-The file will be compressed using the program @samp{gzip}, which must\n-exist in your @env{PATH}.  On systems without the @samp{popen}\n-function, the file will be named @file{bbtrace} and will not be\n-compressed.  @strong{Profiling for even a few seconds on these systems\n-will produce a very large file.}  Note: @code{__bb_hidecall__} and\n-@code{__bb_showret__} will not affect the sequence written to\n-@file{bbtrace.gz}.\n-@end table\n-\n-Here's a short example using different profiling parameters\n-in file @file{bb.in}.  Assume function @code{foo} consists of basic blocks\n-1 and 2 and is called twice from block 3 of function @code{main}.  After\n-the calls, block 3 transfers control to block 4 of @code{main}.\n-\n-With @code{__bb_trace__} and @code{main} contained in file @file{bb.in},\n-the following sequence of blocks is written to file @file{bbtrace.gz}:\n-0 3 1 2 1 2 4.  The return from block 2 to block 3 is not shown, because\n-the return is to a point inside the block and not to the top.  The\n-block address 0 always indicates, that control is transferred\n-to the trace from somewhere outside the observed functions.  With\n-@samp{-foo} added to @file{bb.in}, the blocks of function\n-@code{foo} are removed from the trace, so only 0 3 4 remains.\n-\n-With @code{__bb_jumps__} and @code{main} contained in file @file{bb.in},\n-jump frequencies will be written to file @file{bb.out}.  The\n-frequencies are obtained by constructing a trace of blocks\n-and incrementing a counter for every neighbouring pair of blocks\n-in the trace.  The trace 0 3 1 2 1 2 4 displays the following\n-frequencies:\n-\n-@example\n-Jump from block 0x0 to block 0x3 executed 1 time(s)\n-Jump from block 0x3 to block 0x1 executed 1 time(s)\n-Jump from block 0x1 to block 0x2 executed 2 time(s)\n-Jump from block 0x2 to block 0x1 executed 1 time(s)\n-Jump from block 0x2 to block 0x4 executed 1 time(s)\n-@end example\n-\n-With @code{__bb_hidecall__}, control transfer due to call instructions\n-is removed from the trace, that is the trace is cut into three parts: 0\n-3 4, 0 1 2 and 0 1 2.  With @code{__bb_showret__}, control transfer due\n-to return instructions is added to the trace.  The trace becomes: 0 3 1\n-2 3 1 2 3 4.  Note, that this trace is not the same, as the sequence\n-written to @file{bbtrace.gz}.  It is solely used for counting jump\n-frequencies.\n-\n @item -fprofile-arcs\n @opindex fprofile-arcs\n Instrument @dfn{arcs} during compilation to generate coverage data"}, {"sha": "67b78e623256042a0f73b80314a227c2c5256644", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -4039,175 +4039,6 @@ must not use the @var{labelno} argument to @code{FUNCTION_PROFILER}.\n Define this macro if the code for function profiling should come before\n the function prologue.  Normally, the profiling code comes after.\n \n-@findex FUNCTION_BLOCK_PROFILER\n-@vindex profile_block_flag\n-@item FUNCTION_BLOCK_PROFILER (@var{file}, @var{labelno})\n-A C statement or compound statement to output to @var{file} some\n-assembler code to initialize basic-block profiling for the current\n-object module.  The global compile flag @code{profile_block_flag}\n-distinguishes two profile modes.\n-\n-@table @code\n-@findex __bb_init_func\n-@item profile_block_flag != 2\n-Output code to call the subroutine @code{__bb_init_func} once per\n-object module, passing it as its sole argument the address of a block\n-allocated in the object module.\n-\n-The name of the block is a local symbol made with this statement:\n-\n-@smallexample\n-ASM_GENERATE_INTERNAL_LABEL (@var{buffer}, \"LPBX\", 0);\n-@end smallexample\n-\n-Of course, since you are writing the definition of\n-@code{ASM_GENERATE_INTERNAL_LABEL} as well as that of this macro, you\n-can take a short cut in the definition of this macro and use the name\n-that you know will result.\n-\n-The first word of this block is a flag which will be nonzero if the\n-object module has already been initialized.  So test this word first,\n-and do not call @code{__bb_init_func} if the flag is\n-nonzero.  @var{labelno} contains a unique number which may be used to\n-generate a label as a branch destination when @code{__bb_init_func}\n-will not be called.\n-\n-Described in assembler language, the code to be output looks like:\n-\n-@example\n-  cmp (LPBX0),0\n-  bne local_label\n-  parameter1 <- LPBX0\n-  call __bb_init_func\n-local_label:\n-@end example\n-\n-@findex __bb_init_trace_func\n-@item profile_block_flag == 2\n-Output code to call the subroutine @code{__bb_init_trace_func}\n-and pass two parameters to it.  The first parameter is the same as\n-for @code{__bb_init_func}.  The second parameter is the number of the\n-first basic block of the function as given by @var{labelno}.  Note\n-that @code{__bb_init_trace_func} has to be called, even if the object\n-module has been initialized already.\n-\n-Described in assembler language, the code to be output looks like:\n-@example\n-parameter1 <- LPBX0\n-parameter2 <- @var{labelno}\n-call __bb_init_trace_func\n-@end example\n-@end table\n-\n-@findex BLOCK_PROFILER\n-@vindex profile_block_flag\n-@item BLOCK_PROFILER (@var{file}, @var{blockno})\n-A C statement or compound statement to output to @var{file} some\n-assembler code to increment the count associated with the basic\n-block number @var{blockno}.  The global compile flag\n-@code{profile_block_flag} distinguishes two profile modes.\n-\n-@table @code\n-@item profile_block_flag != 2\n-Output code to increment the counter directly.  Basic blocks are\n-numbered separately from zero within each compilation.  The count\n-associated with block number @var{blockno} is at index\n-@var{blockno} in a vector of words; the name of this array is a local\n-symbol made with this statement:\n-\n-@smallexample\n-ASM_GENERATE_INTERNAL_LABEL (@var{buffer}, \"LPBX\", 2);\n-@end smallexample\n-\n-@c This paragraph is the same as one a few paragraphs up.\n-@c That is not an error.\n-Of course, since you are writing the definition of\n-@code{ASM_GENERATE_INTERNAL_LABEL} as well as that of this macro, you\n-can take a short cut in the definition of this macro and use the name\n-that you know will result.\n-\n-Described in assembler language, the code to be output looks like:\n-\n-@smallexample\n-inc (LPBX2+4*@var{blockno})\n-@end smallexample\n-\n-@vindex __bb\n-@findex __bb_trace_func\n-@item profile_block_flag == 2\n-Output code to initialize the global structure @code{__bb} and\n-call the function @code{__bb_trace_func}, which will increment the\n-counter.\n-\n-@code{__bb} consists of two words.  In the first word, the current\n-basic block number, as given by @var{blockno}, has to be stored.  In\n-the second word, the address of a block allocated in the object\n-module has to be stored.  The address is given by the label created\n-with this statement:\n-\n-@smallexample\n-ASM_GENERATE_INTERNAL_LABEL (@var{buffer}, \"LPBX\", 0);\n-@end smallexample\n-\n-Described in assembler language, the code to be output looks like:\n-@example\n-move @var{blockno} -> (__bb)\n-move LPBX0 -> (__bb+4)\n-call __bb_trace_func\n-@end example\n-@end table\n-\n-@findex FUNCTION_BLOCK_PROFILER_EXIT\n-@findex __bb_trace_ret\n-@vindex profile_block_flag\n-@item FUNCTION_BLOCK_PROFILER_EXIT (@var{file})\n-A C statement or compound statement to output to @var{file} assembler\n-code to call function @code{__bb_trace_ret}.  The assembler code should\n-only be output if the global compile flag @code{profile_block_flag} ==\n-2.  This macro has to be used at every place where code for returning\n-from a function is generated (e.g.@:\n-@code{TARGET_ASM_FUNCTION_EPILOGUE}).  Although you have to write the\n-definition of @code{TARGET_ASM_FUNCTION_EPILOGUE} as well, you have to\n-define this macro to tell the compiler, that the proper call to\n-@code{__bb_trace_ret} is produced.\n-\n-@findex MACHINE_STATE_SAVE\n-@findex __bb_init_trace_func\n-@findex __bb_trace_func\n-@findex __bb_trace_ret\n-@item MACHINE_STATE_SAVE (@var{id})\n-A C statement or compound statement to save all registers, which may\n-be clobbered by a function call, including condition codes.  The\n-@code{asm} statement will be mostly likely needed to handle this\n-task.  Local labels in the assembler code can be concatenated with the\n-string @var{id}, to obtain a unique label name.\n-\n-Registers or condition codes clobbered by\n-@code{TARGET_ASM_FUNCTION_PROLOGUE} or\n-@code{TARGET_ASM_FUNCTION_EPILOGUE} must be saved in the macros\n-@code{FUNCTION_BLOCK_PROFILER}, @code{FUNCTION_BLOCK_PROFILER_EXIT} and\n-@code{BLOCK_PROFILER} prior calling @code{__bb_init_trace_func},\n-@code{__bb_trace_ret} and @code{__bb_trace_func} respectively.\n-\n-@findex MACHINE_STATE_RESTORE\n-@findex __bb_init_trace_func\n-@findex __bb_trace_func\n-@findex __bb_trace_ret\n-@item MACHINE_STATE_RESTORE (@var{id})\n-A C statement or compound statement to restore all registers, including\n-condition codes, saved by @code{MACHINE_STATE_SAVE}.\n-\n-Registers or condition codes clobbered by\n-@code{TARGET_ASM_FUNCTION_PROLOGUE} or\n-@code{TARGET_ASM_FUNCTION_EPILOGUE} must be restored in the macros\n-@code{FUNCTION_BLOCK_PROFILER}, @code{FUNCTION_BLOCK_PROFILER_EXIT} and\n-@code{BLOCK_PROFILER} after calling @code{__bb_init_trace_func},\n-@code{__bb_trace_ret} and @code{__bb_trace_func} respectively.\n-\n-@findex BLOCK_PROFILER_CODE\n-@item BLOCK_PROFILER_CODE\n-A C function or functions which are needed in the library to\n-support block profiling.\n \n @findex TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER\n @item TARGET_ALLOWS_PROFILING_WITHOUT_FRAME_POINTER"}, {"sha": "9725c0ba078dcdf695358df9047d2f7b68b29399", "filename": "gcc/final.c", "status": "modified", "additions": 10, "deletions": 284, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -114,10 +114,6 @@ static int high_function_linenum;\n /* Filename of last NOTE.  */\n static const char *last_filename;\n \n-/* Number of basic blocks seen so far;\n-   used if profile_block_flag is set.  */\n-static int count_basic_blocks;\n-\n /* Number of instrumented arcs when profile_arc_flag is set.  */\n extern int count_instrumented_edges;\n \n@@ -240,8 +236,6 @@ static int asm_insn_count\tPARAMS ((rtx));\n #endif\n static void profile_function\tPARAMS ((FILE *));\n static void profile_after_prologue PARAMS ((FILE *));\n-static void add_bb\t\tPARAMS ((FILE *));\n-static int add_bb_string\tPARAMS ((const char *, int));\n static void notice_source_line\tPARAMS ((rtx));\n static rtx walk_alter_subreg\tPARAMS ((rtx *));\n static void output_asm_name\tPARAMS ((void));\n@@ -284,7 +278,7 @@ end_final (filename)\n {\n   int i;\n \n-  if (profile_block_flag || profile_arc_flag)\n+  if (profile_arc_flag)\n     {\n       char name[20];\n       int align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n@@ -296,10 +290,7 @@ end_final (filename)\n       int pointer_bytes = POINTER_SIZE / BITS_PER_UNIT;\n       unsigned int align2 = LONG_TYPE_SIZE;\n \n-      if (profile_block_flag)\n-\tsize = long_bytes * count_basic_blocks;\n-      else\n-\tsize = gcov_type_bytes * count_instrumented_edges;\n+      size = gcov_type_bytes * count_instrumented_edges;\n       rounded = size;\n \n       rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;\n@@ -347,53 +338,24 @@ end_final (filename)\n       assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes,\n \t\t\talign2, 1);\n \n-      /* Count of the # of basic blocks or # of instrumented arcs.  */\n-      assemble_integer (GEN_INT (profile_block_flag\n-\t\t\t\t ? count_basic_blocks\n-\t\t\t\t : count_instrumented_edges),\n+      /* Count of the # of instrumented arcs.  */\n+      assemble_integer (GEN_INT (count_instrumented_edges),\n \t\t\tlong_bytes, align2, 1);\n \n       /* Zero word (link field).  */\n       assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n \n-      /* address of basic block start address table */\n-      if (profile_block_flag)\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t    pointer_bytes, align2, 1);\n-\t}\n-      else\n-\tassemble_integer (const0_rtx, pointer_bytes, align2, 1);\n+      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n \n       /* Byte count for extended structure.  */\n       assemble_integer (GEN_INT (11 * UNITS_PER_WORD), long_bytes, align2, 1);\n \n       /* Address of function name table.  */\n-      if (profile_block_flag)\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 4);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t    pointer_bytes, align2, 1);\n-\t}\n-      else\n-\tassemble_integer (const0_rtx, pointer_bytes, align2, 1);\n+      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n \n       /* Address of line number and filename tables if debugging.  */\n-      if (write_symbols != NO_DEBUG && profile_block_flag)\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 5);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t    pointer_bytes, align2, 1);\n-\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 6);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t    pointer_bytes, align2, 1);\n-\t}\n-      else\n-\t{\n-\t  assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n-\t  assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n-\t}\n+      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n+      assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n \n       /* Space for extension ptr (link field).  */\n       assemble_integer (const0_rtx, UNITS_PER_WORD, align2, 1);\n@@ -410,10 +372,7 @@ end_final (filename)\n \tstrcat (data_file, \"/\");\n \tstrcat (data_file, filename);\n \tstrip_off_ending (data_file, len);\n-\tif (profile_block_flag)\n-\t  strcat (data_file, \".d\");\n-\telse\n-\t  strcat (data_file, \".da\");\n+\tstrcat (data_file, \".da\");\n \tassemble_string (data_file, strlen (data_file) + 1);\n       }\n \n@@ -446,95 +405,6 @@ end_final (filename)\n #endif\n #endif\n \t}\n-\n-      /* Output any basic block strings */\n-      if (profile_block_flag)\n-\t{\n-\t  readonly_data_section ();\n-\t  if (sbb_head)\n-\t    {\n-\t      ASM_OUTPUT_ALIGN (asm_out_file, align);\n-\t      for (sptr = sbb_head; sptr != 0; sptr = sptr->next)\n-\t\t{\n-\t\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBC\",\n-\t\t\t\t\t     sptr->label_num);\n-\t\t  assemble_string (sptr->string, sptr->length);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Output the table of addresses.  */\n-      if (profile_block_flag)\n-\t{\n-\t  /* Realign in new section */\n-\t  ASM_OUTPUT_ALIGN (asm_out_file, align);\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 3);\n-\t  for (i = 0; i < count_basic_blocks; i++)\n-\t    {\n-\t      ASM_GENERATE_INTERNAL_LABEL (name, \"LPB\", i);\n-\t      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t\tpointer_bytes, align2, 1);\n-\t    }\n-\t}\n-\n-      /* Output the table of function names.  */\n-      if (profile_block_flag)\n-\t{\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 4);\n-\t  for ((ptr = bb_head), (i = 0); ptr != 0; (ptr = ptr->next), i++)\n-\t    {\n-\t      if (ptr->func_label_num >= 0)\n-\t\t{\n-\t\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBC\",\n-\t\t\t\t\t       ptr->func_label_num);\n-\t\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t\t    pointer_bytes, align2, 1);\n-\t\t}\n-\t      else\n-\t\tassemble_integer (const0_rtx, pointer_bytes, align2, 1);\n-\t    }\n-\n-\t  for (; i < count_basic_blocks; i++)\n-\t    assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n-\t}\n-\n-      if (write_symbols != NO_DEBUG && profile_block_flag)\n-\t{\n-\t  /* Output the table of line numbers.  */\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 5);\n-\t  for ((ptr = bb_head), (i = 0); ptr != 0; (ptr = ptr->next), i++)\n-\t    assemble_integer (GEN_INT (ptr->line_num), long_bytes, align2, 1);\n-\n-\t  for (; i < count_basic_blocks; i++)\n-\t    assemble_integer (const0_rtx, long_bytes, align2, 1);\n-\n-\t  /* Output the table of file names.  */\n-\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LPBX\", 6);\n-\t  for ((ptr = bb_head), (i = 0); ptr != 0; (ptr = ptr->next), i++)\n-\t    {\n-\t      if (ptr->file_label_num >= 0)\n-\t\t{\n-\t\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBC\",\n-\t\t\t\t\t       ptr->file_label_num);\n-\t\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t\t    pointer_bytes, align2, 1);\n-\t\t}\n-\t      else\n-\t\tassemble_integer (const0_rtx, pointer_bytes, align2, 1);\n-\t    }\n-\n-\t  for (; i < count_basic_blocks; i++)\n-\t    assemble_integer (const0_rtx, pointer_bytes, align2, 1);\n-\t}\n-\n-      /* End with the address of the table of addresses,\n-\t so we can find it easily, as the last word in the file's text.  */\n-      if (profile_block_flag)\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n-\t\t\t    pointer_bytes, align2, 1);\n-\t}\n     }\n }\n \n@@ -1729,28 +1599,12 @@ final_start_function (first, file, optimize)\n     profile_after_prologue (file);\n \n   profile_label_no++;\n-\n-  /* If we are doing basic block profiling, remember a printable version\n-     of the function name.  */\n-  if (profile_block_flag)\n-    {\n-      bb_func_label_num =\n-\tadd_bb_string ((*decl_printable_name) (current_function_decl, 2),\n-\t\t       FALSE);\n-    }\n }\n \n static void\n profile_after_prologue (file)\n      FILE *file ATTRIBUTE_UNUSED;\n {\n-#ifdef FUNCTION_BLOCK_PROFILER\n-  if (profile_block_flag)\n-    {\n-      FUNCTION_BLOCK_PROFILER (file, count_basic_blocks);\n-    }\n-#endif /* FUNCTION_BLOCK_PROFILER */\n-\n #ifndef PROFILE_BEFORE_PROLOGUE\n   if (profile_flag)\n     profile_function (file);\n@@ -1860,89 +1714,6 @@ final_end_function ()\n   bb_func_label_num = -1;\t/* not in function, nuke label # */\n }\n \f\n-/* Add a block to the linked list that remembers the current line/file/function\n-   for basic block profiling.  Emit the label in front of the basic block and\n-   the instructions that increment the count field.  */\n-\n-static void\n-add_bb (file)\n-     FILE *file;\n-{\n-  struct bb_list *ptr =\n-    (struct bb_list *) permalloc (sizeof (struct bb_list));\n-\n-  /* Add basic block to linked list.  */\n-  ptr->next = 0;\n-  ptr->line_num = last_linenum;\n-  ptr->file_label_num = bb_file_label_num;\n-  ptr->func_label_num = bb_func_label_num;\n-  *bb_tail = ptr;\n-  bb_tail = &ptr->next;\n-\n-  /* Enable the table of basic-block use counts\n-     to point at the code it applies to.  */\n-  ASM_OUTPUT_INTERNAL_LABEL (file, \"LPB\", count_basic_blocks);\n-\n-  /* Before first insn of this basic block, increment the\n-     count of times it was entered.  */\n-#ifdef BLOCK_PROFILER\n-  BLOCK_PROFILER (file, count_basic_blocks);\n-#endif\n-#ifdef HAVE_cc0\n-  CC_STATUS_INIT;\n-#endif\n-\n-  new_block = 0;\n-  count_basic_blocks++;\n-}\n-\n-/* Add a string to be used for basic block profiling.  */\n-\n-static int\n-add_bb_string (string, perm_p)\n-     const char *string;\n-     int perm_p;\n-{\n-  int len;\n-  struct bb_str *ptr = 0;\n-\n-  if (!string)\n-    {\n-      string = \"<unknown>\";\n-      perm_p = TRUE;\n-    }\n-\n-  /* Allocate a new string if the current string isn't permanent.  If\n-     the string is permanent search for the same string in other\n-     allocations.  */\n-\n-  len = strlen (string) + 1;\n-  if (!perm_p)\n-    {\n-      char *p = (char *) permalloc (len);\n-      memcpy (p, string, len);\n-      string = p;\n-    }\n-  else\n-    for (ptr = sbb_head; ptr != (struct bb_str *) 0; ptr = ptr->next)\n-      if (ptr->string == string)\n-\tbreak;\n-\n-  /* Allocate a new string block if we need to.  */\n-  if (!ptr)\n-    {\n-      ptr = (struct bb_str *) permalloc (sizeof (*ptr));\n-      ptr->next = 0;\n-      ptr->length = len;\n-      ptr->label_num = sbb_label_num++;\n-      ptr->string = string;\n-      *sbb_tail = ptr;\n-      sbb_tail = &ptr->next;\n-    }\n-\n-  return ptr->label_num;\n-}\n-\f\n /* Output assembler code for some insns: all or part of a function.\n    For description of args, see `final_start_function', above.\n \n@@ -2051,11 +1822,6 @@ final (first, file, optimize, prescan)\n       insn = final_scan_insn (insn, file, optimize, prescan, 0);\n     }\n \n-  /* Do basic-block profiling here\n-     if the last insn was a conditional branch.  */\n-  if (profile_block_flag && new_block)\n-    add_bb (file);\n-\n   free (line_note_exists);\n   line_note_exists = NULL;\n }\n@@ -2490,11 +2256,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    break;\n \t  }\n \n-\t/* Do basic-block profiling when we reach a new block.\n-\t   Done here to avoid jump tables.  */\n-\tif (profile_block_flag && new_block)\n-\t  add_bb (file);\n-\n \tif (GET_CODE (body) == ASM_INPUT)\n \t  {\n \t    const char *string = XSTR (body, 0);\n@@ -2601,22 +2362,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t      {\n \t\tCC_STATUS_INIT;\n \t      }\n-\n-\t    /* Following a conditional branch sequence, we have a new basic\n-\t       block.  */\n-\t    if (profile_block_flag)\n-\t      {\n-\t\trtx insn = XVECEXP (body, 0, 0);\n-\t\trtx body = PATTERN (insn);\n-\n-\t\tif ((GET_CODE (insn) == JUMP_INSN && GET_CODE (body) == SET\n-\t\t     && GET_CODE (SET_SRC (body)) != LABEL_REF)\n-\t\t    || (GET_CODE (insn) == JUMP_INSN\n-\t\t\t&& GET_CODE (body) == PARALLEL\n-\t\t\t&& GET_CODE (XVECEXP (body, 0, 0)) == SET\n-\t\t\t&& GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) != LABEL_REF))\n-\t\t  new_block = 1;\n-\t      }\n \t    break;\n \t  }\n \n@@ -2675,17 +2420,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  }\n #endif\n \n-\t/* Following a conditional branch, we have a new basic block.\n-\t   But if we are inside a sequence, the new block starts after the\n-\t   last insn of the sequence.  */\n-\tif (profile_block_flag && final_sequence == 0\n-\t    && ((GET_CODE (insn) == JUMP_INSN && GET_CODE (body) == SET\n-\t\t && GET_CODE (SET_SRC (body)) != LABEL_REF)\n-\t\t|| (GET_CODE (insn) == JUMP_INSN && GET_CODE (body) == PARALLEL\n-\t\t    && GET_CODE (XVECEXP (body, 0, 0)) == SET\n-\t\t    && GET_CODE (SET_SRC (XVECEXP (body, 0, 0))) != LABEL_REF)))\n-\t  new_block = 1;\n-\n #ifndef STACK_REGS\n \t/* Don't bother outputting obvious no-ops, even without -O.\n \t   This optimization is fast and doesn't interfere with debugging.\n@@ -2990,14 +2724,6 @@ notice_source_line (insn)\n {\n   const char *filename = NOTE_SOURCE_FILE (insn);\n \n-  /* Remember filename for basic block profiling.\n-     Filenames are allocated on the permanent obstack\n-     or are passed in ARGV, so we don't have to save\n-     the string.  */\n-\n-  if (profile_block_flag && last_filename != filename)\n-    bb_file_label_num = add_bb_string (filename, TRUE);\n-\n   last_filename = filename;\n   last_linenum = NOTE_LINE_NUMBER (insn);\n   high_block_linenum = MAX (last_linenum, high_block_linenum);\n@@ -4123,7 +3849,7 @@ leaf_function_p ()\n   rtx insn;\n   rtx link;\n \n-  if (profile_flag || profile_block_flag || profile_arc_flag)\n+  if (profile_flag || profile_arc_flag)\n     return 0;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))"}, {"sha": "b5933a63b47b69bcc77ec922dfda5216581f8f03", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -173,10 +173,6 @@ extern int warn_disabled_optimization;\n \n extern int profile_flag;\n \n-/* Nonzero if generating code to do profiling on the basis of basic blocks.  */\n-\n-extern int profile_block_flag;\n-\n /* Nonzero if generating code to profile program flow graph arcs.  */\n \n extern int profile_arc_flag;"}, {"sha": "cece1c06944c5b5990c9d368a1383000e3d12f12", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 0, "deletions": 719, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -1640,725 +1640,6 @@ __bb_fork_func (void)\n     }\n }\n \n-#ifndef MACHINE_STATE_SAVE\n-#define MACHINE_STATE_SAVE(ID)\n-#endif\n-#ifndef MACHINE_STATE_RESTORE\n-#define MACHINE_STATE_RESTORE(ID)\n-#endif\n-\n-/* Number of buckets in hashtable of basic block addresses.  */\n-\n-#define BB_BUCKETS 311\n-\n-/* Maximum length of string in file bb.in.  */\n-\n-#define BBINBUFSIZE 500\n-\n-struct bb_edge\n-{\n-  struct bb_edge *next;\n-  unsigned long src_addr;\n-  unsigned long dst_addr;\n-  unsigned long count;\n-};\n-\n-enum bb_func_mode\n-{\n-  TRACE_KEEP = 0, TRACE_ON = 1, TRACE_OFF = 2\n-};\n-\n-struct bb_func\n-{\n-  struct bb_func *next;\n-  char *funcname;\n-  char *filename;\n-  enum bb_func_mode mode;\n-};\n-\n-/* This is the connection to the outside world.\n-   The BLOCK_PROFILER macro must set __bb.blocks\n-   and __bb.blockno.  */\n-\n-struct {\n-  unsigned long blockno;\n-  struct bb *blocks;\n-} __bb;\n-\n-/* Vars to store addrs of source and destination basic blocks\n-   of a jump.  */\n-\n-static unsigned long bb_src = 0;\n-static unsigned long bb_dst = 0;\n-\n-static FILE *bb_tracefile = (FILE *) 0;\n-static struct bb_edge **bb_hashbuckets = (struct bb_edge **) 0;\n-static struct bb_func *bb_func_head = (struct bb_func *) 0;\n-static unsigned long bb_callcount = 0;\n-static int bb_mode = 0;\n-\n-static unsigned long *bb_stack = (unsigned long *) 0;\n-static size_t bb_stacksize = 0;\n-\n-static int reported = 0;\n-\n-/* Trace modes:\n-Always             :   Print execution frequencies of basic blocks\n-                       to file bb.out.\n-bb_mode & 1 != 0   :   Dump trace of basic blocks to file bbtrace[.gz]\n-bb_mode & 2 != 0   :   Print jump frequencies to file bb.out.\n-bb_mode & 4 != 0   :   Cut call instructions from basic block flow.\n-bb_mode & 8 != 0   :   Insert return instructions in basic block flow.\n-*/\n-\n-#ifdef HAVE_POPEN\n-\n-/*#include <sys/types.h>*/\n-#include <sys/stat.h>\n-/*#include <malloc.h>*/\n-\n-/* Commands executed by gopen.  */\n-\n-#define GOPENDECOMPRESS \"gzip -cd \"\n-#define GOPENCOMPRESS \"gzip -c >\"\n-\n-/* Like fopen but pipes through gzip.  mode may only be \"r\" or \"w\".\n-   If it does not compile, simply replace gopen by fopen and delete\n-   '.gz' from any first parameter to gopen.  */\n-\n-static FILE *\n-gopen (char *fn, char *mode)\n-{\n-  int use_gzip;\n-  char *p;\n-\n-  if (mode[1])\n-    return (FILE *) 0;\n-\n-  if (mode[0] != 'r' && mode[0] != 'w')\n-    return (FILE *) 0;\n-\n-  p = fn + strlen (fn)-1;\n-  use_gzip = ((p[-1] == '.' && (p[0] == 'Z' || p[0] == 'z'))\n-\t      || (p[-2] == '.' && p[-1] == 'g' && p[0] == 'z'));\n-\n-  if (use_gzip)\n-    {\n-      if (mode[0]=='r')\n-        {\n-          FILE *f;\n-          char *s = (char *) malloc (sizeof (char) * strlen (fn)\n-\t\t\t\t     + sizeof (GOPENDECOMPRESS));\n-          strcpy (s, GOPENDECOMPRESS);\n-          strcpy (s + (sizeof (GOPENDECOMPRESS)-1), fn);\n-          f = popen (s, mode);\n-          free (s);\n-          return f;\n-        }\n-\n-      else\n-        {\n-          FILE *f;\n-          char *s = (char *) malloc (sizeof (char) * strlen (fn)\n-\t\t\t\t     + sizeof (GOPENCOMPRESS));\n-          strcpy (s, GOPENCOMPRESS);\n-          strcpy (s + (sizeof (GOPENCOMPRESS)-1), fn);\n-          if (!(f = popen (s, mode)))\n-            f = fopen (s, mode);\n-          free (s);\n-          return f;\n-        }\n-    }\n-\n-  else\n-    return fopen (fn, mode);\n-}\n-\n-static int\n-gclose (FILE *f)\n-{\n-  struct stat buf;\n-\n-  if (f != 0)\n-    {\n-      if (!fstat (fileno (f), &buf) && S_ISFIFO (buf.st_mode))\n-        return pclose (f);\n-\n-      return fclose (f);\n-    }\n-  return 0;\n-}\n-\n-#endif /* HAVE_POPEN */\n-\n-/* Called once per program.  */\n-\n-static void\n-__bb_exit_trace_func (void)\n-{\n-  FILE *file = fopen (\"bb.out\", \"a\");\n-  struct bb_func *f;\n-  struct bb *b;\n-\n-  if (!file)\n-    perror (\"bb.out\");\n-\n-  if (bb_mode & 1)\n-    {\n-      if (!bb_tracefile)\n-        perror (\"bbtrace\");\n-      else\n-#ifdef HAVE_POPEN\n-        gclose (bb_tracefile);\n-#else\n-        fclose (bb_tracefile);\n-#endif /* HAVE_POPEN */\n-    }\n-\n-  /* Check functions in `bb.in'.  */\n-\n-  if (file)\n-    {\n-      long time_value;\n-      const struct bb_func *p;\n-      int printed_something = 0;\n-      struct bb *ptr;\n-      long blk;\n-\n-      /* This is somewhat type incorrect.  */\n-      time ((void *) &time_value);\n-\n-      for (p = bb_func_head; p != (struct bb_func *) 0; p = p->next)\n-        {\n-          for (ptr = bb_head; ptr != (struct bb *) 0; ptr = ptr->next)\n-            {\n-              if (!ptr->filename || (p->filename != (char *) 0 && strcmp (p->filename, ptr->filename)))\n-                continue;\n-              for (blk = 0; blk < ptr->ncounts; blk++)\n-                {\n-                  if (!strcmp (p->funcname, ptr->functions[blk]))\n-                    goto found;\n-                }\n-            }\n-\n-          if (!printed_something)\n-            {\n-              fprintf (file,\n-      \"Functions in `bb.in' not executed during basic block profiling on %s\\n\",\n-\t\t       ctime ((void *) &time_value));\n-              printed_something = 1;\n-            }\n-\n-          fprintf (file, \"\\tFunction %s\", p->funcname);\n-          if (p->filename)\n-              fprintf (file, \" of file %s\", p->filename);\n-          fprintf (file, \"\\n\" );\n-\n-found:        ;\n-        }\n-\n-      if (printed_something)\n-       fprintf (file, \"\\n\");\n-\n-    }\n-\n-  if (bb_mode & 2)\n-    {\n-      if (!bb_hashbuckets)\n-        {\n-          if (!reported)\n-            {\n-              fprintf (stderr, \"Profiler: out of memory\\n\");\n-              reported = 1;\n-            }\n-          return;\n-        }\n-\n-      else if (file)\n-        {\n-          long time_value;\n-          int i;\n-          unsigned long addr_max = 0;\n-          unsigned long cnt_max  = 0;\n-          int cnt_len;\n-          int addr_len;\n-\n-          /* This is somewhat type incorrect, but it avoids worrying about\n-             exactly where time.h is included from.  It should be ok unless\n-             a void * differs from other pointer formats, or if sizeof (long)\n-             is < sizeof (time_t).  It would be nice if we could assume the\n-             use of rationale standards here.  */\n-\n-          time ((void *) &time_value);\n-          fprintf (file, \"Basic block jump tracing\");\n-\n-          switch (bb_mode & 12)\n-            {\n-              case 0:\n-                fprintf (file, \" (with call)\");\n-              break;\n-\n-              case 4:\n-\t\t/* Print nothing.  */\n-              break;\n-\n-              case 8:\n-                fprintf (file, \" (with call & ret)\");\n-              break;\n-\n-              case 12:\n-                fprintf (file, \" (with ret)\");\n-              break;\n-            }\n-\n-          fprintf (file, \" finished on %s\\n\", ctime ((void *) &time_value));\n-\n-          for (i = 0; i < BB_BUCKETS; i++)\n-            {\n-               struct bb_edge *bucket = bb_hashbuckets[i];\n-               for ( ; bucket; bucket = bucket->next )\n-                 {\n-                   if (addr_max < bucket->src_addr)\n-                     addr_max = bucket->src_addr;\n-                   if (addr_max < bucket->dst_addr)\n-                     addr_max = bucket->dst_addr;\n-                   if (cnt_max < bucket->count)\n-                     cnt_max = bucket->count;\n-                 }\n-            }\n-          addr_len = num_digits (addr_max, 16);\n-          cnt_len  = num_digits (cnt_max, 10);\n-\n-          for ( i = 0; i < BB_BUCKETS; i++)\n-            {\n-               struct bb_edge *bucket = bb_hashbuckets[i];\n-               for ( ; bucket; bucket = bucket->next )\n-                 {\n-                   fprintf (file,\n-\t\"Jump from block 0x%.*lx to block 0x%.*lx executed %*lu time(s)\\n\",\n-                            addr_len, bucket->src_addr,\n-                            addr_len, bucket->dst_addr,\n-                            cnt_len, bucket->count);\n-                 }\n-            }\n-\n-          fprintf (file, \"\\n\");\n-\n-        }\n-    }\n-\n-   if (file)\n-     fclose (file);\n-\n-   /* Free allocated memory.  */\n-\n-   f = bb_func_head;\n-   while (f)\n-     {\n-       struct bb_func *old = f;\n-\n-       f = f->next;\n-       if (old->funcname) free (old->funcname);\n-       if (old->filename) free (old->filename);\n-       free (old);\n-     }\n-\n-   if (bb_stack)\n-     free (bb_stack);\n-\n-   if (bb_hashbuckets)\n-     {\n-       int i;\n-\n-       for (i = 0; i < BB_BUCKETS; i++)\n-         {\n-           struct bb_edge *old, *bucket = bb_hashbuckets[i];\n-\n-           while (bucket)\n-             {\n-               old = bucket;\n-               bucket = bucket->next;\n-               free (old);\n-             }\n-         }\n-       free (bb_hashbuckets);\n-     }\n-\n-   for (b = bb_head; b; b = b->next)\n-     if (b->flags) free (b->flags);\n-}\n-\n-/* Called once per program.  */\n-\n-static void\n-__bb_init_prg (void)\n-{\n-  FILE *file;\n-  char buf[BBINBUFSIZE];\n-  const char *p;\n-  const char *pos;\n-  enum bb_func_mode m;\n-  int i;\n-\n-  /* Initialize destructor.  */\n-  atexit (__bb_exit_func);\n-\n-  if (!(file = fopen (\"bb.in\", \"r\")))\n-    return;\n-\n-  while(fgets (buf, BBINBUFSIZE, file) != 0)\n-    {\n-      i = strlen (buf);\n-      if (buf[i] == '\\n')\n-\tbuf[i--] = '\\0';\n-\n-      p = buf;\n-      if (*p == '-')\n-        {\n-          m = TRACE_OFF;\n-          p++;\n-        }\n-      else\n-        {\n-          m = TRACE_ON;\n-        }\n-      if (!strcmp (p, \"__bb_trace__\"))\n-        bb_mode |= 1;\n-      else if (!strcmp (p, \"__bb_jumps__\"))\n-        bb_mode |= 2;\n-      else if (!strcmp (p, \"__bb_hidecall__\"))\n-        bb_mode |= 4;\n-      else if (!strcmp (p, \"__bb_showret__\"))\n-        bb_mode |= 8;\n-      else\n-        {\n-          struct bb_func *f = (struct bb_func *) malloc (sizeof (struct bb_func));\n-          if (f)\n-            {\n-              unsigned long l;\n-              f->next = bb_func_head;\n-              if ((pos = strchr (p, ':')))\n-                {\n-                  if (!(f->funcname = (char *) malloc (strlen (pos+1)+1)))\n-                    continue;\n-                  strcpy (f->funcname, pos+1);\n-                  l = pos-p;\n-                  if ((f->filename = (char *) malloc (l+1)))\n-                    {\n-                      strncpy (f->filename, p, l);\n-                      f->filename[l] = '\\0';\n-                    }\n-                  else\n-                    f->filename = (char *) 0;\n-                }\n-              else\n-                {\n-                  if (!(f->funcname = (char *) malloc (strlen (p)+1)))\n-                    continue;\n-                  strcpy (f->funcname, p);\n-                  f->filename = (char *) 0;\n-                }\n-              f->mode = m;\n-              bb_func_head = f;\n-\t    }\n-         }\n-    }\n-  fclose (file);\n-\n-#ifdef HAVE_POPEN\n-\n-  if (bb_mode & 1)\n-      bb_tracefile = gopen (\"bbtrace.gz\", \"w\");\n-\n-#else\n-\n-  if (bb_mode & 1)\n-      bb_tracefile = fopen (\"bbtrace\", \"w\");\n-\n-#endif /* HAVE_POPEN */\n-\n-  if (bb_mode & 2)\n-    {\n-      bb_hashbuckets = (struct bb_edge **)\n-                   malloc (BB_BUCKETS * sizeof (struct bb_edge *));\n-      if (bb_hashbuckets)\n-\t/* Use a loop here rather than calling bzero to avoid having to\n-\t   conditionalize its existence.  */\n-\tfor (i = 0; i < BB_BUCKETS; i++)\n-\t  bb_hashbuckets[i] = 0;\n-    }\n-\n-  if (bb_mode & 12)\n-    {\n-      bb_stacksize = 10;\n-      bb_stack = (unsigned long *) malloc (bb_stacksize * sizeof (*bb_stack));\n-    }\n-\n-  /* Initialize destructor.  */\n-  atexit (__bb_exit_trace_func);\n-}\n-\n-/* Called upon entering a basic block.  */\n-\n-void\n-__bb_trace_func (void)\n-{\n-  struct bb_edge *bucket;\n-\n-  MACHINE_STATE_SAVE(\"1\")\n-\n-  if (!bb_callcount || (__bb.blocks->flags && (__bb.blocks->flags[__bb.blockno] & TRACE_OFF)))\n-    goto skip;\n-\n-  bb_dst = __bb.blocks->addresses[__bb.blockno];\n-  __bb.blocks->counts[__bb.blockno]++;\n-\n-  if (bb_tracefile)\n-    {\n-      fwrite (&bb_dst, sizeof (unsigned long), 1, bb_tracefile);\n-    }\n-\n-  if (bb_hashbuckets)\n-    {\n-      struct bb_edge **startbucket, **oldnext;\n-\n-      oldnext = startbucket\n-\t= & bb_hashbuckets[ (((int) bb_src*8) ^ (int) bb_dst) % BB_BUCKETS ];\n-      bucket = *startbucket;\n-\n-      for (bucket = *startbucket; bucket;\n-           oldnext = &(bucket->next), bucket = *oldnext)\n-        {\n-          if (bucket->src_addr == bb_src\n-\t      && bucket->dst_addr == bb_dst)\n-            {\n-              bucket->count++;\n-              *oldnext = bucket->next;\n-              bucket->next = *startbucket;\n-              *startbucket = bucket;\n-              goto ret;\n-            }\n-        }\n-\n-      bucket = (struct bb_edge *) malloc (sizeof (struct bb_edge));\n-\n-      if (!bucket)\n-        {\n-          if (!reported)\n-            {\n-              fprintf (stderr, \"Profiler: out of memory\\n\");\n-              reported = 1;\n-            }\n-        }\n-\n-      else\n-        {\n-          bucket->src_addr = bb_src;\n-          bucket->dst_addr = bb_dst;\n-          bucket->next = *startbucket;\n-          *startbucket = bucket;\n-          bucket->count = 1;\n-        }\n-    }\n-\n-ret:\n-  bb_src = bb_dst;\n-\n-skip:\n-  ;\n-\n-  MACHINE_STATE_RESTORE(\"1\")\n-\n-}\n-\n-/* Called when returning from a function and `__bb_showret__' is set.  */\n-\n-static void\n-__bb_trace_func_ret (void)\n-{\n-  struct bb_edge *bucket;\n-\n-  if (!bb_callcount || (__bb.blocks->flags && (__bb.blocks->flags[__bb.blockno] & TRACE_OFF)))\n-    goto skip;\n-\n-  if (bb_hashbuckets)\n-    {\n-      struct bb_edge **startbucket, **oldnext;\n-\n-      oldnext = startbucket\n-\t= & bb_hashbuckets[ (((int) bb_dst * 8) ^ (int) bb_src) % BB_BUCKETS ];\n-      bucket = *startbucket;\n-\n-      for (bucket = *startbucket; bucket;\n-           oldnext = &(bucket->next), bucket = *oldnext)\n-        {\n-          if (bucket->src_addr == bb_dst\n-\t       && bucket->dst_addr == bb_src)\n-            {\n-              bucket->count++;\n-              *oldnext = bucket->next;\n-              bucket->next = *startbucket;\n-              *startbucket = bucket;\n-              goto ret;\n-            }\n-        }\n-\n-      bucket = (struct bb_edge *) malloc (sizeof (struct bb_edge));\n-\n-      if (!bucket)\n-        {\n-          if (!reported)\n-            {\n-              fprintf (stderr, \"Profiler: out of memory\\n\");\n-              reported = 1;\n-            }\n-        }\n-\n-      else\n-        {\n-          bucket->src_addr = bb_dst;\n-          bucket->dst_addr = bb_src;\n-          bucket->next = *startbucket;\n-          *startbucket = bucket;\n-          bucket->count = 1;\n-        }\n-    }\n-\n-ret:\n-  bb_dst = bb_src;\n-\n-skip:\n-  ;\n-\n-}\n-\n-/* Called upon entering the first function of a file.  */\n-\n-static void\n-__bb_init_file (struct bb *blocks)\n-{\n-\n-  const struct bb_func *p;\n-  long blk, ncounts = blocks->ncounts;\n-  const char **functions = blocks->functions;\n-\n-  /* Set up linked list.  */\n-  blocks->zero_word = 1;\n-  blocks->next = bb_head;\n-  bb_head = blocks;\n-\n-  blocks->flags = 0;\n-  if (!bb_func_head\n-      || !(blocks->flags = (char *) malloc (sizeof (char) * blocks->ncounts)))\n-    return;\n-\n-  for (blk = 0; blk < ncounts; blk++)\n-    blocks->flags[blk] = 0;\n-\n-  for (blk = 0; blk < ncounts; blk++)\n-    {\n-      for (p = bb_func_head; p; p = p->next)\n-        {\n-          if (!strcmp (p->funcname, functions[blk])\n-\t      && (!p->filename || !strcmp (p->filename, blocks->filename)))\n-            {\n-              blocks->flags[blk] |= p->mode;\n-            }\n-        }\n-    }\n-\n-}\n-\n-/* Called when exiting from a function.  */\n-\n-void\n-__bb_trace_ret (void)\n-{\n-\n-  MACHINE_STATE_SAVE(\"2\")\n-\n-  if (bb_callcount)\n-    {\n-      if ((bb_mode & 12) && bb_stacksize > bb_callcount)\n-        {\n-          bb_src = bb_stack[bb_callcount];\n-          if (bb_mode & 8)\n-            __bb_trace_func_ret ();\n-        }\n-\n-      bb_callcount -= 1;\n-    }\n-\n-  MACHINE_STATE_RESTORE(\"2\")\n-\n-}\n-\n-/* Called when entering a function.  */\n-\n-void\n-__bb_init_trace_func (struct bb *blocks, unsigned long blockno)\n-{\n-  static int trace_init = 0;\n-\n-  MACHINE_STATE_SAVE(\"3\")\n-\n-  if (!blocks->zero_word)\n-    {\n-      if (!trace_init)\n-        {\n-          trace_init = 1;\n-          __bb_init_prg ();\n-        }\n-      __bb_init_file (blocks);\n-    }\n-\n-  if (bb_callcount)\n-    {\n-\n-      bb_callcount += 1;\n-\n-      if (bb_mode & 12)\n-        {\n-          if (bb_callcount >= bb_stacksize)\n-            {\n-              size_t newsize = bb_callcount + 100;\n-\n-              bb_stack = (unsigned long *) realloc (bb_stack, newsize);\n-              if (! bb_stack)\n-                {\n-                  if (!reported)\n-                    {\n-                      fprintf (stderr, \"Profiler: out of memory\\n\");\n-                      reported = 1;\n-                    }\n-                  bb_stacksize = 0;\n-                  goto stack_overflow;\n-                }\n-\t      bb_stacksize = newsize;\n-            }\n-          bb_stack[bb_callcount] = bb_src;\n-\n-          if (bb_mode & 4)\n-            bb_src = 0;\n-\n-        }\n-\n-stack_overflow:;\n-\n-    }\n-\n-  else if (blocks->flags && (blocks->flags[blockno] & TRACE_ON))\n-    {\n-      bb_callcount = 1;\n-      bb_src = 0;\n-\n-      if (bb_stack)\n-          bb_stack[bb_callcount] = bb_src;\n-    }\n-\n-  MACHINE_STATE_RESTORE(\"3\")\n-}\n-\n #endif /* not inhibit_libc */\n #endif /* not BLOCK_PROFILER_CODE */\n #endif /* L_bb */"}, {"sha": "66615008200e659e82fb5d4d441e4c9061acbbbc", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8456b95a5af348aa220ad0adc2101835f221f5d3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8456b95a5af348aa220ad0adc2101835f221f5d3", "patch": "@@ -408,10 +408,6 @@ int flag_eliminate_dwarf2_dups = 0;\n \n int profile_flag = 0;\n \n-/* Nonzero if generating code to do profiling on a line-by-line basis.  */\n-\n-int profile_block_flag;\n-\n /* Nonzero if generating code to profile program flow graph arcs.  */\n \n int profile_arc_flag = 0;\n@@ -4238,47 +4234,6 @@ independent_decode_option (argc, argv)\n \treturn decode_W_option (arg + 1);\n       break;\n \n-    case 'a':\n-      if (arg[1] == 0)\n-\t{\n-#if !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n-\t  warning (\"`-a' option (basic block profile) not supported\");\n-#else\n-\t  profile_block_flag = (profile_block_flag < 2) ? 1 : 3;\n-#endif\n-\t}\n-      else if (!strcmp (arg, \"ax\"))\n-\t{\n-#if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)\n-\t  warning (\"`-ax' option (jump profiling) not supported\");\n-#else\n-\t  profile_block_flag = (!profile_block_flag\n-\t\t\t\t|| profile_block_flag == 2) ? 2 : 3;\n-#endif\n-\t}\n-      else if (!strncmp (arg, \"aux-info\", 8))\n-\t{\n-\t  if (arg[8] == '\\0')\n-\t    {\n-\t      if (argc == 1)\n-\t\treturn 0;\n-\n-\t      aux_info_file_name = argv[1];\n-\t      flag_gen_aux_info = 1;\n-\t      return 2;\n-\t    }\n-\t  else if (arg[8] == '=')\n-\t    {\n-\t      aux_info_file_name = arg + 9;\n-\t      flag_gen_aux_info = 1;\n-\t    }\n-\t  else\n-\t    return 0;\n-\t}\n-      else\n-\treturn 0;\n-      break;\n-\n     case 'o':\n       if (arg[1] == 0)\n \t{\n@@ -4837,12 +4792,6 @@ process_options ()\n   if (align_functions <= 0) align_functions = 1;\n   align_functions_log = floor_log2 (align_functions * 2 - 1);\n \n-  if (profile_block_flag == 3)\n-    {\n-      warning (\"`-ax' and `-a' are conflicting options. `-a' ignored\");\n-      profile_block_flag = 2;\n-    }\n-\n   /* Unrolling all loops implies that standard loop unrolling must also\n      be done.  */\n   if (flag_unroll_all_loops)\n@@ -4913,7 +4862,6 @@ process_options ()\n     {\n       write_symbols = NO_DEBUG;\n       profile_flag = 0;\n-      profile_block_flag = 0;\n     }\n \n   /* Now we know write_symbols, set up the debug hooks based on it.\n@@ -4967,8 +4915,7 @@ process_options ()\n \t}\n     }\n \n-  if (flag_function_sections\n-      && (profile_flag || profile_block_flag))\n+  if (flag_function_sections && profile_flag)\n     {\n       warning (\"-ffunction-sections disabled; it makes profiling impossible\");\n       flag_function_sections = 0;"}]}