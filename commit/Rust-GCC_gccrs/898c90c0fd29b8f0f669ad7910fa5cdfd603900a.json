{"sha": "898c90c0fd29b8f0f669ad7910fa5cdfd603900a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk4YzkwYzBmZDI5YjhmMGY2NjlhZDc5MTBmYTVjZGZkNjAzOTAwYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-05-11T23:05:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-05-11T23:05:51Z"}, "message": "cfgrtl.c (commit_one_edge_insertion): Remove always-true test and reindent the subsequent block.\n\n\t* cfgrtl.c (commit_one_edge_insertion): Remove always-true test and\n\treindent the subsequent block.\n\nFrom-SVN: r173685", "tree": {"sha": "aed8ba81a890f041714412643c47c7e40ffa6bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed8ba81a890f041714412643c47c7e40ffa6bbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/898c90c0fd29b8f0f669ad7910fa5cdfd603900a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898c90c0fd29b8f0f669ad7910fa5cdfd603900a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/898c90c0fd29b8f0f669ad7910fa5cdfd603900a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898c90c0fd29b8f0f669ad7910fa5cdfd603900a/comments", "author": null, "committer": null, "parents": [{"sha": "cddebdb7a8f75dca13c20a3d6d51c73069979031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cddebdb7a8f75dca13c20a3d6d51c73069979031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cddebdb7a8f75dca13c20a3d6d51c73069979031"}], "stats": {"total": 119, "additions": 60, "deletions": 59}, "files": [{"sha": "038bd095db85d92f14738a7f0a38ed59873ead1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898c90c0fd29b8f0f669ad7910fa5cdfd603900a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898c90c0fd29b8f0f669ad7910fa5cdfd603900a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=898c90c0fd29b8f0f669ad7910fa5cdfd603900a", "patch": "@@ -1,3 +1,8 @@\n+2011-05-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* cfgrtl.c (commit_one_edge_insertion): Remove always-true test and\n+\treindent the subsequent block.\n+\n 2011-05-11  Satoru Takabayashi  <satorux@google.com>\n \t    Paul Pluzhnikov  <ppluzhnikov@google.com>\n "}, {"sha": "5bafc0f3c2507007569e09893c498c116562d34d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 55, "deletions": 59, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/898c90c0fd29b8f0f669ad7910fa5cdfd603900a/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/898c90c0fd29b8f0f669ad7910fa5cdfd603900a/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=898c90c0fd29b8f0f669ad7910fa5cdfd603900a", "patch": "@@ -1465,80 +1465,76 @@ void\n commit_one_edge_insertion (edge e)\n {\n   rtx before = NULL_RTX, after = NULL_RTX, insns, tmp, last;\n-  basic_block bb = NULL;\n+  basic_block bb;\n \n   /* Pull the insns off the edge now since the edge might go away.  */\n   insns = e->insns.r;\n   e->insns.r = NULL_RTX;\n \n-  if (!before && !after)\n-    {\n-      /* Figure out where to put these things.  If the destination has\n-\t one predecessor, insert there.  Except for the exit block.  */\n-      if (single_pred_p (e->dest) && e->dest != EXIT_BLOCK_PTR)\n-\t{\n-\t  bb = e->dest;\n-\n-\t  /* Get the location correct wrt a code label, and \"nice\" wrt\n-\t     a basic block note, and before everything else.  */\n-\t  tmp = BB_HEAD (bb);\n-\t  if (LABEL_P (tmp))\n-\t    tmp = NEXT_INSN (tmp);\n-\t  if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n-\t    tmp = NEXT_INSN (tmp);\n-\t  if (tmp == BB_HEAD (bb))\n-\t    before = tmp;\n-\t  else if (tmp)\n-\t    after = PREV_INSN (tmp);\n-\t  else\n-\t    after = get_last_insn ();\n-\t}\n-\n-      /* If the source has one successor and the edge is not abnormal,\n-\t insert there.  Except for the entry block.  */\n-      else if ((e->flags & EDGE_ABNORMAL) == 0\n-\t       && single_succ_p (e->src)\n-\t       && e->src != ENTRY_BLOCK_PTR)\n-\t{\n-\t  bb = e->src;\n+  /* Figure out where to put these insns.  If the destination has\n+     one predecessor, insert there.  Except for the exit block.  */\n+  if (single_pred_p (e->dest) && e->dest != EXIT_BLOCK_PTR)\n+    {\n+      bb = e->dest;\n+\n+      /* Get the location correct wrt a code label, and \"nice\" wrt\n+\t a basic block note, and before everything else.  */\n+      tmp = BB_HEAD (bb);\n+      if (LABEL_P (tmp))\n+\ttmp = NEXT_INSN (tmp);\n+      if (NOTE_INSN_BASIC_BLOCK_P (tmp))\n+\ttmp = NEXT_INSN (tmp);\n+      if (tmp == BB_HEAD (bb))\n+\tbefore = tmp;\n+      else if (tmp)\n+\tafter = PREV_INSN (tmp);\n+      else\n+\tafter = get_last_insn ();\n+    }\n \n-\t  /* It is possible to have a non-simple jump here.  Consider a target\n-\t     where some forms of unconditional jumps clobber a register.  This\n-\t     happens on the fr30 for example.\n+  /* If the source has one successor and the edge is not abnormal,\n+     insert there.  Except for the entry block.  */\n+  else if ((e->flags & EDGE_ABNORMAL) == 0\n+\t   && single_succ_p (e->src)\n+\t   && e->src != ENTRY_BLOCK_PTR)\n+    {\n+      bb = e->src;\n \n-\t     We know this block has a single successor, so we can just emit\n-\t     the queued insns before the jump.  */\n-\t  if (JUMP_P (BB_END (bb)))\n-\t    before = BB_END (bb);\n-\t  else\n-\t    {\n-\t      /* We'd better be fallthru, or we've lost track of\n-\t\t what's what.  */\n-\t      gcc_assert (e->flags & EDGE_FALLTHRU);\n+      /* It is possible to have a non-simple jump here.  Consider a target\n+\t where some forms of unconditional jumps clobber a register.  This\n+\t happens on the fr30 for example.\n \n-\t      after = BB_END (bb);\n-\t    }\n-\t}\n-      /* Otherwise we must split the edge.  */\n+\t We know this block has a single successor, so we can just emit\n+\t the queued insns before the jump.  */\n+      if (JUMP_P (BB_END (bb)))\n+\tbefore = BB_END (bb);\n       else\n \t{\n-\t  bb = split_edge (e);\n-\t  after = BB_END (bb);\n+\t  /* We'd better be fallthru, or we've lost track of what's what.  */\n+\t  gcc_assert (e->flags & EDGE_FALLTHRU);\n \n-\t  if (flag_reorder_blocks_and_partition\n-\t      && targetm.have_named_sections\n-\t      && e->src != ENTRY_BLOCK_PTR\n-\t      && BB_PARTITION (e->src) == BB_COLD_PARTITION\n-\t      && !(e->flags & EDGE_CROSSING)\n-\t      && JUMP_P (after)\n-\t      && !any_condjump_p (after)\n-\t      && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n-\t    add_reg_note (after, REG_CROSSING_JUMP, NULL_RTX);\n+\t  after = BB_END (bb);\n \t}\n     }\n \n-  /* Now that we've found the spot, do the insertion.  */\n+  /* Otherwise we must split the edge.  */\n+  else\n+    {\n+      bb = split_edge (e);\n+      after = BB_END (bb);\n+\n+      if (flag_reorder_blocks_and_partition\n+\t  && targetm.have_named_sections\n+\t  && e->src != ENTRY_BLOCK_PTR\n+\t  && BB_PARTITION (e->src) == BB_COLD_PARTITION\n+\t  && !(e->flags & EDGE_CROSSING)\n+\t  && JUMP_P (after)\n+\t  && !any_condjump_p (after)\n+\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n+\tadd_reg_note (after, REG_CROSSING_JUMP, NULL_RTX);\n+    }\n \n+  /* Now that we've found the spot, do the insertion.  */\n   if (before)\n     {\n       emit_insn_before_noloc (insns, before, bb);"}]}