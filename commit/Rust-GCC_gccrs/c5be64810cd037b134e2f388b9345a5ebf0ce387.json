{"sha": "c5be64810cd037b134e2f388b9345a5ebf0ce387", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzViZTY0ODEwY2QwMzdiMTM0ZTJmMzg4YjkzNDVhNWViZjBjZTM4Nw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-11-17T23:35:44Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-11-17T23:35:44Z"}, "message": "Implement std::pmr::synchronized_pool_resource\n\nDefine the thread-safe pool resource, using a shared_mutex to allow\nmultiple threads to concurrently allocate from thread-specific pools.\n\nDefine new weak symbols for the pthread_rwlock_t functions, to avoid\nmaking libstdc++.so depend on libpthread.so\n\nWhen the necessary Gthread support is absent only define the\nfeature-test macro to 1, rather than 201603. This is intended to imply\nincomplete support, because everything except synchronized_pool_resource\nworks.\n\n\tImplement std::pmr::synchronized_pool_resource\n\t* config/abi/pre/gnu.ver: Add new symbols.\n\t* include/std/memory_resource [_GLIBCXX_HAS_GTHREADS]\n\t(__cpp_lib_memory_resource): Define to expected value, 201603.\n\t(synchronized_pool_resource): New class.\n\t[!_GLIBCXX_HAS_GTHREADS] (__cpp_lib_memory_resource): Define to 1.\n\t* include/std/shared_mutex (__glibcxx_rwlock_rdlock)\n\t(__glibcxx_rwlock_tryrdlock, __glibcxx_rwlock_wrlock)\n\t(__glibcxx_rwlock_trywrlock, __glibcxx_rwlock_unlock)\n\t(__glibcxx_rwlock_destroy, __glibcxx_rwlock_init)\n\t(__glibcxx_rwlock_timedrdlock, __glibcxx_rwlock_timedwrlock): Define\n\tweak symbols for POSIX rwlock functions.\n\t(__shared_mutex_pthread): Use weak symbols.\n\t* include/std/version (__cpp_lib_memory_resource): Define.\n\t* src/c++17/memory_resource.cc [_GLIBCXX_HAS_GTHREADS]\n\t(synchronized_pool_resource::_TPools): New class.\n\t(destroy_TPools): New function for pthread_key_create destructor.\n\t(synchronized_pool_resource::synchronized_pool_resource)\n\t(synchronized_pool_resource::~synchronized_pool_resource)\n\t(synchronized_pool_resource::release)\n\t(synchronized_pool_resource::do_allocate)\n\t(synchronized_pool_resource::do_deallocate): Define public members.\n\t(synchronized_pool_resource::_M_thread_specific_pools)\n\t(synchronized_pool_resource::_M_alloc_tpools)\n\t(synchronized_pool_resource::_M_alloc_shared_tpools): Define private\n\tmembers.\n\t* testsuite/20_util/synchronized_pool_resource/allocate.cc: New test.\n\t* testsuite/20_util/synchronized_pool_resource/cons.cc: New test.\n\t* testsuite/20_util/synchronized_pool_resource/is_equal.cc: New test.\n\t* testsuite/20_util/synchronized_pool_resource/multithreaded.cc: New\n\ttest.\n\t* testsuite/20_util/synchronized_pool_resource/release.cc: New test.\n\t* testsuite/performance/20_util/memory_resource/pools.cc: Add\n\tmultithreaded tests using pmr::synchronized_pool_resource.\n\nFrom-SVN: r266242", "tree": {"sha": "fb731c4af3dad3470490f611f5941ab972bfa6f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb731c4af3dad3470490f611f5941ab972bfa6f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5be64810cd037b134e2f388b9345a5ebf0ce387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5be64810cd037b134e2f388b9345a5ebf0ce387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5be64810cd037b134e2f388b9345a5ebf0ce387", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5be64810cd037b134e2f388b9345a5ebf0ce387/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b579523b7bcd02739e6f06fe21a7ac6eb24dd6ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b579523b7bcd02739e6f06fe21a7ac6eb24dd6ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b579523b7bcd02739e6f06fe21a7ac6eb24dd6ec"}], "stats": {"total": 1442, "additions": 1387, "deletions": 55}, "files": [{"sha": "b3940b2853c9a65fb6ec4e5c14a720d4f9178bc5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -1,3 +1,40 @@\n+2018-11-17  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tImplement std::pmr::synchronized_pool_resource\n+\t* config/abi/pre/gnu.ver: Add new symbols.\n+\t* include/std/memory_resource [_GLIBCXX_HAS_GTHREADS]\n+\t(__cpp_lib_memory_resource): Define to expected value, 201603.\n+\t(synchronized_pool_resource): New class.\n+\t[!_GLIBCXX_HAS_GTHREADS] (__cpp_lib_memory_resource): Define to 1.\n+\t* include/std/shared_mutex (__glibcxx_rwlock_rdlock)\n+\t(__glibcxx_rwlock_tryrdlock, __glibcxx_rwlock_wrlock)\n+\t(__glibcxx_rwlock_trywrlock, __glibcxx_rwlock_unlock)\n+\t(__glibcxx_rwlock_destroy, __glibcxx_rwlock_init)\n+\t(__glibcxx_rwlock_timedrdlock, __glibcxx_rwlock_timedwrlock): Define\n+\tweak symbols for POSIX rwlock functions.\n+\t(__shared_mutex_pthread): Use weak symbols.\n+\t* include/std/version (__cpp_lib_memory_resource): Define.\n+\t* src/c++17/memory_resource.cc [_GLIBCXX_HAS_GTHREADS]\n+\t(synchronized_pool_resource::_TPools): New class.\n+\t(destroy_TPools): New function for pthread_key_create destructor.\n+\t(synchronized_pool_resource::synchronized_pool_resource)\n+\t(synchronized_pool_resource::~synchronized_pool_resource)\n+\t(synchronized_pool_resource::release)\n+\t(synchronized_pool_resource::do_allocate)\n+\t(synchronized_pool_resource::do_deallocate): Define public members.\n+\t(synchronized_pool_resource::_M_thread_specific_pools)\n+\t(synchronized_pool_resource::_M_alloc_tpools)\n+\t(synchronized_pool_resource::_M_alloc_shared_tpools): Define private\n+\tmembers.\n+\t* testsuite/20_util/synchronized_pool_resource/allocate.cc: New test.\n+\t* testsuite/20_util/synchronized_pool_resource/cons.cc: New test.\n+\t* testsuite/20_util/synchronized_pool_resource/is_equal.cc: New test.\n+\t* testsuite/20_util/synchronized_pool_resource/multithreaded.cc: New\n+\ttest.\n+\t* testsuite/20_util/synchronized_pool_resource/release.cc: New test.\n+\t* testsuite/performance/20_util/memory_resource/pools.cc: Add\n+\tmultithreaded tests using pmr::synchronized_pool_resource.\n+\n 2018-11-16  Renlin Li  <renlin.li@arm.com>\n \t    Tejas Belagod  <tejas.belagod@arm.com>\n "}, {"sha": "e4bda4f6f1eff65c28796b0e62e93def2677ef36", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -2039,13 +2039,6 @@ GLIBCXX_3.4.26 {\n     _ZNSt7__cxx1118basic_stringstreamI[cw]St11char_traitsI[cw]ESaI[cw]EEC[12]Ev;\n     _ZNSt7__cxx1119basic_[io]stringstreamI[cw]St11char_traitsI[cw]ESaI[cw]EEC[12]Ev;\n \n-    _ZNSt3pmr19new_delete_resourceEv;\n-    _ZNSt3pmr20null_memory_resourceEv;\n-    _ZNSt3pmr20get_default_resourceEv;\n-    _ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE;\n-    _ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferE[jmy][jmy];\n-    _ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv;\n-\n     # std::__throw_ios_failure(const char*, int);\n     _ZSt19__throw_ios_failurePKci;\n \n@@ -2057,6 +2050,18 @@ GLIBCXX_3.4.26 {\n     _ZN11__gnu_debug25_Safe_local_iterator_base16_M_attach_singleEPNS_19_Safe_sequence_baseEb;\n \n     # <memory_resource> members\n+    _ZNSt3pmr19new_delete_resourceEv;\n+    _ZNSt3pmr20null_memory_resourceEv;\n+    _ZNSt3pmr20get_default_resourceEv;\n+    _ZNSt3pmr20set_default_resourceEPNS_15memory_resourceE;\n+    _ZNSt3pmr25monotonic_buffer_resource13_M_new_bufferE[jmy][jmy];\n+    _ZNSt3pmr25monotonic_buffer_resource18_M_release_buffersEv;\n+    _ZTINSt3pmr26synchronized_pool_resourceE;\n+    _ZNSt3pmr26synchronized_pool_resourceC[12]ERKNS_12pool_optionsEPNS_15memory_resourceE;\n+    _ZNSt3pmr26synchronized_pool_resourceD[12]Ev;\n+    _ZNSt3pmr26synchronized_pool_resource7releaseEv;\n+    _ZNSt3pmr26synchronized_pool_resource11do_allocateE[jmy][jmy];\n+    _ZNSt3pmr26synchronized_pool_resource13do_deallocateEPv[jmy][jmy];\n     _ZTINSt3pmr28unsynchronized_pool_resourceE;\n     _ZNSt3pmr28unsynchronized_pool_resourceC[12]ERKNS_12pool_optionsEPNS_15memory_resourceE;\n     _ZNSt3pmr28unsynchronized_pool_resourceD[12]Ev;"}, {"sha": "87ad25d60f39a0cb83941f937fedee90dd4f68c7", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -37,14 +37,21 @@\n #include <utility>\t\t\t// pair, index_sequence\n #include <vector>\t\t\t// vector\n #include <cstddef>\t\t\t// size_t, max_align_t\n+#include <shared_mutex>\t\t\t// shared_mutex\n #include <debug/assertions.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n namespace pmr\n {\n-// #define __cpp_lib_memory_resource 201603\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+  // Header and all contents are present.\n+# define __cpp_lib_memory_resource 201603\n+#else\n+  // The pmr::synchronized_pool_resource type is missing.\n+# define __cpp_lib_memory_resource 1\n+#endif\n \n   class memory_resource;\n \n@@ -60,7 +67,9 @@ namespace pmr\n \n   // Pool resource classes\n   struct pool_options;\n+#ifdef _GLIBCXX_HAS_GTHREADS\n   class synchronized_pool_resource;\n+#endif\n   class unsynchronized_pool_resource;\n   class monotonic_buffer_resource;\n \n@@ -338,7 +347,72 @@ namespace pmr\n     const int _M_npools;\n   };\n \n-  // TODO class synchronized_pool_resource\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+  /// A thread-safe memory resource that manages pools of fixed-size blocks.\n+  class synchronized_pool_resource : public memory_resource\n+  {\n+  public:\n+    synchronized_pool_resource(const pool_options& __opts,\n+\t\t\t\t memory_resource* __upstream)\n+    __attribute__((__nonnull__));\n+\n+    synchronized_pool_resource()\n+    : synchronized_pool_resource(pool_options(), get_default_resource())\n+    { }\n+\n+    explicit\n+    synchronized_pool_resource(memory_resource* __upstream)\n+    __attribute__((__nonnull__))\n+    : synchronized_pool_resource(pool_options(), __upstream)\n+    { }\n+\n+    explicit\n+    synchronized_pool_resource(const pool_options& __opts)\n+    : synchronized_pool_resource(__opts, get_default_resource()) { }\n+\n+    synchronized_pool_resource(const synchronized_pool_resource&) = delete;\n+\n+    virtual ~synchronized_pool_resource();\n+\n+    synchronized_pool_resource&\n+    operator=(const synchronized_pool_resource&) = delete;\n+\n+    void release();\n+\n+    memory_resource*\n+    upstream_resource() const noexcept\n+    __attribute__((__returns_nonnull__))\n+    { return _M_impl.resource(); }\n+\n+    pool_options options() const noexcept { return _M_impl._M_opts; }\n+\n+  protected:\n+    void*\n+    do_allocate(size_t __bytes, size_t __alignment) override;\n+\n+    void\n+    do_deallocate(void* __p, size_t __bytes, size_t __alignment) override;\n+\n+    bool\n+    do_is_equal(const memory_resource& __other) const noexcept override\n+    { return this == &__other; }\n+\n+  public:\n+    // Thread-specific pools (only public for access by implementation details)\n+    struct _TPools;\n+\n+  private:\n+    _TPools* _M_alloc_tpools(lock_guard<shared_mutex>&);\n+    _TPools* _M_alloc_shared_tpools(lock_guard<shared_mutex>&);\n+    auto _M_thread_specific_pools() noexcept;\n+\n+    __pool_resource _M_impl;\n+    __gthread_key_t _M_key;\n+    // Linked list of thread-specific pools. All threads share _M_tpools[0].\n+    _TPools* _M_tpools = nullptr;\n+    mutable shared_mutex _M_mx;\n+  };\n+#endif\n \n   /// A non-thread-safe memory resource that manages pools of fixed-size blocks.\n   class unsynchronized_pool_resource : public memory_resource"}, {"sha": "8aa6e9f0d4f9a8bdcd48ce0290ace89eee99069b", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 93, "deletions": 9, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -57,6 +57,90 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   class shared_timed_mutex;\n \n #if _GLIBCXX_USE_PTHREAD_RWLOCK_T\n+#ifdef __gthrw\n+#define _GLIBCXX_GTHRW(name) \\\n+  __gthrw(pthread_ ## name); \\\n+  static inline int \\\n+  __glibcxx_ ## name (pthread_rwlock_t *__rwlock) \\\n+  { \\\n+    if (__gthread_active_p ()) \\\n+      return __gthrw_(pthread_ ## name) (__rwlock); \\\n+    else \\\n+      return 0; \\\n+  }\n+  _GLIBCXX_GTHRW(rwlock_rdlock)\n+  _GLIBCXX_GTHRW(rwlock_tryrdlock)\n+  _GLIBCXX_GTHRW(rwlock_wrlock)\n+  _GLIBCXX_GTHRW(rwlock_trywrlock)\n+  _GLIBCXX_GTHRW(rwlock_unlock)\n+# ifndef PTHREAD_RWLOCK_INITIALIZER\n+  _GLIBCXX_GTHRW(rwlock_destroy)\n+  __gthrw(pthread_rwlock_init);\n+  static inline int\n+  __glibcxx_rwlock_init (pthread_rwlock_t *__rwlock)\n+  {\n+    if (__gthread_active_p ())\n+      return __gthrw_(pthread_rwlock_init) (__rwlock, NULL);\n+    else\n+      return 0;\n+  }\n+# endif\n+# if _GTHREAD_USE_MUTEX_TIMEDLOCK\n+   __gthrw(pthread_rwlock_timedrdlock);\n+  static inline int\n+  __glibcxx_rwlock_timedrdlock (pthread_rwlock_t *__rwlock,\n+\t\t\t\tconst timespec *__ts)\n+  {\n+    if (__gthread_active_p ())\n+      return __gthrw_(pthread_rwlock_timedrdlock) (__rwlock, __ts);\n+    else\n+      return 0;\n+  }\n+   __gthrw(pthread_rwlock_timedwrlock);\n+  static inline int\n+  __glibcxx_rwlock_timedwrlock (pthread_rwlock_t *__rwlock,\n+\t\t\t\tconst timespec *__ts)\n+  {\n+    if (__gthread_active_p ())\n+      return __gthrw_(pthread_rwlock_timedwrlock) (__rwlock, __ts);\n+    else\n+      return 0;\n+  }\n+# endif\n+#else\n+  static inline int\n+  __glibcxx_rwlock_rdlock (pthread_rwlock_t *__rwlock)\n+  { return pthread_rwlock_rdlock (__rwlock); }\n+  static inline int\n+  __glibcxx_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)\n+  { return pthread_rwlock_tryrdlock (__rwlock); }\n+  static inline int\n+  __glibcxx_rwlock_wrlock (pthread_rwlock_t *__rwlock)\n+  { return pthread_rwlock_wrlock (__rwlock); }\n+  static inline int\n+  __glibcxx_rwlock_trywrlock (pthread_rwlock_t *__rwlock)\n+  { return pthread_rwlock_trywrlock (__rwlock); }\n+  static inline int\n+  __glibcxx_rwlock_unlock (pthread_rwlock_t *__rwlock)\n+  { return pthread_rwlock_unlock (__rwlock); }\n+  static inline int\n+  __glibcxx_rwlock_destroy(pthread_rwlock_t *__rwlock)\n+  { return pthread_rwlock_destroy (__rwlock); }\n+  static inline int\n+  __glibcxx_rwlock_init(pthread_rwlock_t *__rwlock)\n+  { return pthread_rwlock_init (__rwlock, NULL); }\n+# if _GTHREAD_USE_MUTEX_TIMEDLOCK\n+  static inline int\n+  __glibcxx_rwlock_timedrdlock (pthread_rwlock_t *__rwlock,\n+\t\t\t\tconst timespec *__ts)\n+  { return pthread_rwlock_timedrdlock (__rwlock, __ts); }\n+  static inline int\n+  __glibcxx_rwlock_timedwrlock (pthread_rwlock_t *__rwlock,\n+\t\t\t\tconst timespec *__ts)\n+  { return pthread_rwlock_timedwrlock (__rwlock, __ts); }\n+# endif\n+#endif\n+\n   /// A shared mutex type implemented using pthread_rwlock_t.\n   class __shared_mutex_pthread\n   {\n@@ -74,7 +158,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   public:\n     __shared_mutex_pthread()\n     {\n-      int __ret = pthread_rwlock_init(&_M_rwlock, NULL);\n+      int __ret = __glibcxx_rwlock_init(&_M_rwlock, NULL);\n       if (__ret == ENOMEM)\n \t__throw_bad_alloc();\n       else if (__ret == EAGAIN)\n@@ -87,7 +171,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     ~__shared_mutex_pthread()\n     {\n-      int __ret __attribute((__unused__)) = pthread_rwlock_destroy(&_M_rwlock);\n+      int __ret __attribute((__unused__)) = __glibcxx_rwlock_destroy(&_M_rwlock);\n       // Errors not handled: EBUSY, EINVAL\n       __glibcxx_assert(__ret == 0);\n     }\n@@ -99,7 +183,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     lock()\n     {\n-      int __ret = pthread_rwlock_wrlock(&_M_rwlock);\n+      int __ret = __glibcxx_rwlock_wrlock(&_M_rwlock);\n       if (__ret == EDEADLK)\n \t__throw_system_error(int(errc::resource_deadlock_would_occur));\n       // Errors not handled: EINVAL\n@@ -109,7 +193,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool\n     try_lock()\n     {\n-      int __ret = pthread_rwlock_trywrlock(&_M_rwlock);\n+      int __ret = __glibcxx_rwlock_trywrlock(&_M_rwlock);\n       if (__ret == EBUSY) return false;\n       // Errors not handled: EINVAL\n       __glibcxx_assert(__ret == 0);\n@@ -119,7 +203,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     unlock()\n     {\n-      int __ret __attribute((__unused__)) = pthread_rwlock_unlock(&_M_rwlock);\n+      int __ret __attribute((__unused__)) = __glibcxx_rwlock_unlock(&_M_rwlock);\n       // Errors not handled: EPERM, EBUSY, EINVAL\n       __glibcxx_assert(__ret == 0);\n     }\n@@ -135,7 +219,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // is okay based on the current specification of forward progress\n       // guarantees by the standard.\n       do\n-\t__ret = pthread_rwlock_rdlock(&_M_rwlock);\n+\t__ret = __glibcxx_rwlock_rdlock(&_M_rwlock);\n       while (__ret == EAGAIN);\n       if (__ret == EDEADLK)\n \t__throw_system_error(int(errc::resource_deadlock_would_occur));\n@@ -146,7 +230,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool\n     try_lock_shared()\n     {\n-      int __ret = pthread_rwlock_tryrdlock(&_M_rwlock);\n+      int __ret = __glibcxx_rwlock_tryrdlock(&_M_rwlock);\n       // If the maximum number of read locks has been exceeded, we just fail\n       // to acquire the lock.  Unlike for lock(), we are not allowed to throw\n       // an exception.\n@@ -413,7 +497,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    static_cast<long>(__ns.count())\n \t  };\n \n-\tint __ret = pthread_rwlock_timedwrlock(&_M_rwlock, &__ts);\n+\tint __ret = __glibcxx_rwlock_timedwrlock(&_M_rwlock, &__ts);\n \t// On self-deadlock, we just fail to acquire the lock.  Technically,\n \t// the program violated the precondition.\n \tif (__ret == ETIMEDOUT || __ret == EDEADLK)\n@@ -466,7 +550,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// mistaken for a spurious failure, which might help users realise\n \t// there is a deadlock.\n \tdo\n-\t  __ret = pthread_rwlock_timedrdlock(&_M_rwlock, &__ts);\n+\t  __ret = __glibcxx_rwlock_timedrdlock(&_M_rwlock, &__ts);\n \twhile (__ret == EAGAIN || __ret == EDEADLK);\n \tif (__ret == ETIMEDOUT)\n \t  return false;"}, {"sha": "95950d82c310a6e818a60690a6b4c42bfac55f8d", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -118,6 +118,11 @@\n #define __cpp_lib_map_insertion 201411\n #define __cpp_lib_map_try_emplace 201411\n #define __cpp_lib_math_special_functions 201603L\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+# define __cpp_lib_memory_resource 201603\n+#else\n+# define __cpp_lib_memory_resource 1\n+#endif\n #define __cpp_lib_node_extract 201606\n #define __cpp_lib_nonmember_container_access 201411\n #define __cpp_lib_not_fn 201603"}, {"sha": "a37663117257fed3e7e88f819aec2be5dc59d6f3", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -896,6 +896,11 @@ namespace pmr\n     return n + 1;\n   }\n \n+#ifdef _GLIBCXX_HAS_GTHREADS\n+  using shared_lock = std::shared_lock<shared_mutex>;\n+  using exclusive_lock = lock_guard<shared_mutex>;\n+#endif\n+\n   } // namespace\n \n   __pool_resource::\n@@ -987,6 +992,292 @@ namespace pmr\n     return p;\n   }\n \n+#ifdef _GLIBCXX_HAS_GTHREADS\n+  // synchronized_pool_resource members.\n+\n+  /* Notes on implementation and thread safety:\n+   *\n+   * Each synchronized_pool_resource manages an linked list of N+1 _TPools\n+   * objects, where N is the number of threads using the pool resource.\n+   * Each _TPools object has its own set of pools, with their own chunks.\n+   * The first element of the list, _M_tpools[0], can be used by any thread.\n+   * The rest of the list contains a _TPools object for each thread,\n+   * accessed via the thread-specific key _M_key (and referred to for\n+   * exposition as _M_tpools[_M_key]).\n+   * The first element, _M_tpools[0], contains \"orphaned chunks\" which were\n+   * allocated by a thread which has since exited, and so there is no\n+   * _M_tpools[_M_key] for that thread.\n+   * A thread can access its own thread-specific set of pools via _M_key\n+   * while holding a shared lock on _M_mx. Accessing _M_impl._M_unpooled\n+   * or _M_tpools[0] or any other thread's _M_tpools[_M_key] requires an\n+   * exclusive lock.\n+   * The upstream_resource() pointer can be obtained without a lock, but\n+   * any dereference of that pointer requires an exclusive lock.\n+   * The _M_impl._M_opts and _M_impl._M_npools members are immutable,\n+   * and can safely be accessed concurrently.\n+   */\n+\n+  extern \"C\" {\n+    static void destroy_TPools(void*);\n+  }\n+\n+  struct synchronized_pool_resource::_TPools\n+  {\n+    // Exclusive lock must be held in the thread where this constructor runs.\n+    explicit\n+    _TPools(synchronized_pool_resource& owner, exclusive_lock&)\n+    : owner(owner), pools(owner._M_impl._M_alloc_pools())\n+    {\n+      // __builtin_printf(\"%p constructing\\n\", this);\n+      __glibcxx_assert(pools);\n+    }\n+\n+    // Exclusive lock must be held in the thread where this destructor runs.\n+    ~_TPools()\n+    {\n+      __glibcxx_assert(pools);\n+      if (pools)\n+\t{\n+\t  memory_resource* r = owner.upstream_resource();\n+\t  for (int i = 0; i < owner._M_impl._M_npools; ++i)\n+\t    pools[i].release(r);\n+\t  std::destroy_n(pools, owner._M_impl._M_npools);\n+\t  polymorphic_allocator<__pool_resource::_Pool> a(r);\n+\t  a.deallocate(pools, owner._M_impl._M_npools);\n+\t}\n+      if (prev)\n+\tprev->next = next;\n+      if (next)\n+\tnext->prev = prev;\n+    }\n+\n+    // Exclusive lock must be held in the thread where this function runs.\n+    void move_nonempty_chunks()\n+    {\n+      __glibcxx_assert(pools);\n+      if (!pools)\n+\treturn;\n+      memory_resource* r = owner.upstream_resource();\n+      // move all non-empty chunks to the shared _TPools\n+      for (int i = 0; i < owner._M_impl._M_npools; ++i)\n+\tfor (auto& c : pools[i]._M_chunks)\n+\t  if (!c.empty())\n+\t    owner._M_tpools->pools[i]._M_chunks.insert(std::move(c), r);\n+    }\n+\n+    synchronized_pool_resource& owner;\n+    __pool_resource::_Pool* pools = nullptr;\n+    _TPools* prev = nullptr;\n+    _TPools* next = nullptr;\n+\n+    static void destroy(_TPools* p)\n+    {\n+      exclusive_lock l(p->owner._M_mx);\n+      // __glibcxx_assert(p != p->owner._M_tpools);\n+      p->move_nonempty_chunks();\n+      polymorphic_allocator<_TPools> a(p->owner.upstream_resource());\n+      p->~_TPools();\n+      a.deallocate(p, 1);\n+    }\n+  };\n+\n+  // Called when a thread exits\n+  extern \"C\" {\n+    static void destroy_TPools(void* p)\n+    {\n+      using _TPools = synchronized_pool_resource::_TPools;\n+      _TPools::destroy(static_cast<_TPools*>(p));\n+    }\n+  }\n+\n+  // Constructor\n+  synchronized_pool_resource::\n+  synchronized_pool_resource(const pool_options& opts,\n+\t\t\t     memory_resource* upstream)\n+  : _M_impl(opts, upstream)\n+  {\n+    if (int err = __gthread_key_create(&_M_key, destroy_TPools))\n+      __throw_system_error(err);\n+    exclusive_lock l(_M_mx);\n+    _M_tpools = _M_alloc_shared_tpools(l);\n+  }\n+\n+  // Destructor\n+  synchronized_pool_resource::~synchronized_pool_resource()\n+  {\n+    release();\n+    __gthread_key_delete(_M_key); // does not run destroy_TPools\n+  }\n+\n+  void\n+  synchronized_pool_resource::release()\n+  {\n+    exclusive_lock l(_M_mx);\n+    if (_M_tpools)\n+      {\n+\t__gthread_key_delete(_M_key); // does not run destroy_TPools\n+\t__gthread_key_create(&_M_key, destroy_TPools);\n+\tpolymorphic_allocator<_TPools> a(upstream_resource());\n+\t// destroy+deallocate each _TPools\n+\tdo\n+\t  {\n+\t    _TPools* p = _M_tpools;\n+\t    _M_tpools = _M_tpools->next;\n+\t    p->~_TPools();\n+\t    a.deallocate(p, 1);\n+\t  }\n+\twhile (_M_tpools);\n+      }\n+    // release unpooled memory\n+    _M_impl.release();\n+  }\n+\n+  // Caller must hold shared or exclusive lock to ensure the pointer\n+  // isn't invalidated before it can be used.\n+  auto\n+  synchronized_pool_resource::_M_thread_specific_pools() noexcept\n+  {\n+    __pool_resource::_Pool* pools = nullptr;\n+    if (auto tp = static_cast<_TPools*>(__gthread_getspecific(_M_key)))\n+      {\n+      pools = tp->pools;\n+      __glibcxx_assert(tp->pools);\n+      }\n+    return pools;\n+  }\n+\n+  // Override for memory_resource::do_allocate\n+  void*\n+  synchronized_pool_resource::\n+  do_allocate(size_t bytes, size_t alignment)\n+  {\n+    const auto block_size = std::max(bytes, alignment);\n+    if (block_size <= _M_impl._M_opts.largest_required_pool_block)\n+      {\n+\tconst ptrdiff_t index = pool_index(block_size, _M_impl._M_npools);\n+\tmemory_resource* const r = upstream_resource();\n+\tconst pool_options opts = _M_impl._M_opts;\n+\t{\n+\t  // Try to allocate from the thread-specific pool\n+\t  shared_lock l(_M_mx);\n+\t  if (auto pools = _M_thread_specific_pools()) // [[likely]]\n+\t    {\n+\t      // Need exclusive lock to replenish so use try_allocate:\n+\t      if (void* p = pools[index].try_allocate())\n+\t\treturn p;\n+\t      // Need to take exclusive lock and replenish pool.\n+\t    }\n+\t  // Need to allocate or replenish thread-specific pools using\n+\t  // upstream resource, so need to hold exclusive lock.\n+\t}\n+\t// N.B. Another thread could call release() now lock is not held.\n+\texclusive_lock excl(_M_mx);\n+\tif (!_M_tpools) // [[unlikely]]\n+\t  _M_tpools = _M_alloc_shared_tpools(excl);\n+\tauto pools = _M_thread_specific_pools();\n+\tif (!pools)\n+\t  pools = _M_alloc_tpools(excl)->pools;\n+\treturn pools[index].allocate(r, opts);\n+      }\n+    exclusive_lock l(_M_mx);\n+    return _M_impl.allocate(bytes, alignment); // unpooled allocation\n+  }\n+\n+  // Override for memory_resource::do_deallocate\n+  void\n+  synchronized_pool_resource::\n+  do_deallocate(void* p, size_t bytes, size_t alignment)\n+  {\n+    size_t block_size = std::max(bytes, alignment);\n+    if (block_size <= _M_impl._M_opts.largest_required_pool_block)\n+      {\n+\tconst ptrdiff_t index = pool_index(block_size, _M_impl._M_npools);\n+\t__glibcxx_assert(index != -1);\n+\t{\n+\t  shared_lock l(_M_mx);\n+\t  auto pools = _M_thread_specific_pools();\n+\t  if (pools)\n+\t    {\n+\t      // No need to lock here, no other thread is accessing this pool.\n+\t      if (pools[index].deallocate(upstream_resource(), p))\n+\t\treturn;\n+\t    }\n+\t  // Block might have come from a different thread's pool,\n+\t  // take exclusive lock and check every pool.\n+\t}\n+\t// TODO store {p, bytes, alignment} somewhere and defer returning\n+\t// the block to the correct thread-specific pool until we next\n+\t// take the exclusive lock.\n+\texclusive_lock excl(_M_mx);\n+\tfor (_TPools* t = _M_tpools; t != nullptr; t = t->next)\n+\t  {\n+\t    if (t->pools) // [[likely]]\n+\t      {\n+\t\tif (t->pools[index].deallocate(upstream_resource(), p))\n+\t\t  return;\n+\t      }\n+\t  }\n+      }\n+    exclusive_lock l(_M_mx);\n+    _M_impl.deallocate(p, bytes, alignment);\n+  }\n+\n+  // Allocate a thread-specific _TPools object and add it to the linked list.\n+  auto\n+  synchronized_pool_resource::_M_alloc_tpools(exclusive_lock& l)\n+  -> _TPools*\n+  {\n+    __glibcxx_assert(_M_tpools != nullptr);\n+    // dump_list(_M_tpools);\n+    polymorphic_allocator<_TPools> a(upstream_resource());\n+    _TPools* p = a.allocate(1);\n+    bool constructed = false;\n+    __try\n+      {\n+\ta.construct(p, *this, l);\n+\tconstructed = true;\n+\t// __glibcxx_assert(__gthread_getspecific(_M_key) == nullptr);\n+\tif (int err = __gthread_setspecific(_M_key, p))\n+\t  __throw_system_error(err);\n+      }\n+    __catch(...)\n+      {\n+\tif (constructed)\n+\t  a.destroy(p);\n+\ta.deallocate(p, 1);\n+\t__throw_exception_again;\n+      }\n+    p->prev = _M_tpools;\n+    p->next = _M_tpools->next;\n+    _M_tpools->next = p;\n+    if (p->next)\n+      p->next->prev = p;\n+    return p;\n+  }\n+\n+  // Allocate the shared _TPools object, _M_tpools[0]\n+  auto\n+  synchronized_pool_resource::_M_alloc_shared_tpools(exclusive_lock& l)\n+  -> _TPools*\n+  {\n+    __glibcxx_assert(_M_tpools == nullptr);\n+    polymorphic_allocator<_TPools> a(upstream_resource());\n+    _TPools* p = a.allocate(1);\n+    __try\n+      {\n+\ta.construct(p, *this, l);\n+      }\n+    __catch(...)\n+      {\n+\ta.deallocate(p, 1);\n+\t__throw_exception_again;\n+      }\n+    // __glibcxx_assert(p->next == nullptr);\n+    // __glibcxx_assert(p->prev == nullptr);\n+    return p;\n+  }\n+#endif // _GLIBCXX_HAS_GTHREADS\n+\n   // unsynchronized_pool_resource member functions\n \n   // Constructor"}, {"sha": "e2a0390e3772252b34384e93a90ff5cf6c90dc6e", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/allocate.cc", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fallocate.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -0,0 +1,159 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17 -pthread\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory_resource>\n+#include <cstring>\n+#include <testsuite_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  {\n+    std::pmr::synchronized_pool_resource r(&test_mr);\n+    void* p1 = r.allocate(1, 1);\n+    VERIFY( p1 != nullptr );\n+    auto n = test_mr.number_of_active_allocations();\n+    VERIFY( n > 0 );\n+    // Ensure memory region can be written to (without corrupting heap!)\n+    std::memset(p1, 0xff, 1);\n+    void* p2 = r.allocate(1, 1);\n+    VERIFY( p2 != nullptr );\n+    VERIFY( p2 != p1 );\n+    VERIFY( test_mr.number_of_active_allocations() == n );\n+    std::memset(p1, 0xff, 1);\n+    r.deallocate(p1, 1, 1);\n+    // Returning single blocks to the pool doesn't return them upstream:\n+    VERIFY( test_mr.number_of_active_allocations() == n );\n+    r.deallocate(p2, 1, 1);\n+    VERIFY( test_mr.number_of_active_allocations() == n );\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  struct nullable_memory_resource : public std::pmr::memory_resource\n+  {\n+    void*\n+    do_allocate(std::size_t bytes, std::size_t alignment) override\n+    { return upstream->allocate(bytes, alignment); }\n+\n+    void\n+    do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override\n+    { upstream->deallocate(p, bytes, alignment); }\n+\n+    bool\n+    do_is_equal(const memory_resource& r) const noexcept override\n+    { return &r == this; }\n+\n+    std::pmr::memory_resource* upstream = std::pmr::get_default_resource();\n+  };\n+\n+  nullable_memory_resource test_mr;\n+  std::pmr::synchronized_pool_resource r(&test_mr);\n+  void* p1 = r.allocate(8, 1);\n+  VERIFY( p1 != nullptr );\n+  std::memset(p1, 0xff, 8);\n+  test_mr.upstream = nullptr;\n+  void* p2 = r.allocate(8, 1); //should not need to replenish\n+  VERIFY( p2 != nullptr );\n+  VERIFY( p2 != p1 );\n+  std::memset(p1, 0xff, 8);\n+  r.deallocate(p1, 8, 1); // should not use upstream\n+  r.deallocate(p2, 8, 1); // should not use upstream\n+\n+  // Destructor will return memory upstream, so restore the upstream resource:\n+  test_mr.upstream = std::pmr::get_default_resource();\n+}\n+\n+void\n+test03()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  {\n+    std::pmr::synchronized_pool_resource r({10, 16}, &test_mr);\n+    std::size_t largest_pool = r.options().largest_required_pool_block;\n+    void* p1 = r.allocate(2 * largest_pool);\n+    VERIFY( p1 != nullptr );\n+    const std::size_t n = test_mr.number_of_active_allocations();\n+    // Allocation of pools + allocation of pmr::vector + oversize allocation:\n+    VERIFY( n >= 1 );\n+    std::memset(p1, 0xff, 2 * largest_pool);\n+    void* p2 = r.allocate(3 * largest_pool);\n+    VERIFY( p2 != nullptr );\n+    VERIFY( p2 != p1 );\n+    VERIFY( test_mr.number_of_active_allocations() == n + 1 );\n+    std::memset(p2, 0xff, 3 * largest_pool);\n+    r.deallocate(p1, 2 * largest_pool);\n+    VERIFY( test_mr.number_of_active_allocations() ==  n );\n+    r.deallocate(p2, 3 * largest_pool);\n+    VERIFY( test_mr.number_of_active_allocations() == n - 1 );\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::synchronized_pool_resource r({16, 16}, &test_mr);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2 * r.options().largest_required_pool_block);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+void\n+test04()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  std::pmr::synchronized_pool_resource r({256, 256}, &test_mr);\n+  // Check alignment\n+  void* p1 = r.allocate(2, 64);\n+  VERIFY( (std::uintptr_t)p1 % 64 == 0 );\n+  void* p2 = r.allocate(2, 128);\n+  VERIFY( (std::uintptr_t)p2 % 128 == 0 );\n+  void* p3 = r.allocate(2, 256);\n+  VERIFY( (std::uintptr_t)p3 % 256 == 0 );\n+  const std::size_t largest_pool = r.options().largest_required_pool_block;\n+  void* p4 = r.allocate(2 * largest_pool, 1024);\n+  VERIFY( (std::uintptr_t)p4 % 1024 == 0 );\n+  r.deallocate(p1, 2, 64);\n+  r.deallocate(p2, 2, 128);\n+  r.deallocate(p3, 2, 256);\n+  r.deallocate(p4, 2 * largest_pool, 1024);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "f02636ec1bec2e372321c8dd2bbdb6ffc9c581c3", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/cons.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fcons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fcons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fcons.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17 -pthread\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory_resource>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource test_mr1, test_mr2;\n+  __gnu_test::default_resource_mgr mgr(&test_mr1);\n+\n+  const std::pmr::pool_options opts{1, 2};\n+  using std::pmr::synchronized_pool_resource;\n+\n+  synchronized_pool_resource p1 = {opts, &test_mr2};\n+  VERIFY( p1.upstream_resource() == &test_mr2 );\n+  synchronized_pool_resource p2;\n+  VERIFY( p2.upstream_resource() == std::pmr::get_default_resource() );\n+  synchronized_pool_resource p3{&test_mr2};\n+  VERIFY( p3.upstream_resource() == &test_mr2 );\n+  synchronized_pool_resource p4{opts};\n+  VERIFY( p4.upstream_resource() == std::pmr::get_default_resource() );\n+\n+  static_assert(!std::is_copy_constructible_v<synchronized_pool_resource>);\n+  static_assert(!std::is_copy_assignable_v<synchronized_pool_resource>);\n+  static_assert(std::is_destructible_v<synchronized_pool_resource>);\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::memory_resource test_mr1, test_mr2;\n+  __gnu_test::default_resource_mgr mgr(&test_mr1);\n+\n+  const std::pmr::pool_options opts{1, 2};\n+\n+  struct derived : std::pmr::synchronized_pool_resource\n+  {\n+    using synchronized_pool_resource::synchronized_pool_resource;\n+  };\n+\n+  derived p1 = {opts, &test_mr2};\n+  VERIFY( p1.upstream_resource() == &test_mr2 );\n+  derived p2;\n+  VERIFY( p2.upstream_resource() == std::pmr::get_default_resource() );\n+  derived p3{&test_mr2};\n+  VERIFY( p3.upstream_resource() == &test_mr2 );\n+  derived p4{opts};\n+  VERIFY( p4.upstream_resource() == std::pmr::get_default_resource() );\n+\n+  static_assert(!std::is_copy_constructible_v<derived>);\n+  static_assert(!std::is_copy_assignable_v<derived>);\n+  static_assert(std::is_destructible_v<derived>);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "68529387e9a8d8e3773d80e4b239831acec506ae", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/is_equal.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fis_equal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fis_equal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fis_equal.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17 -pthread\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory_resource>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::pmr::synchronized_pool_resource r1;\n+  VERIFY( r1 == r1 );\n+  std::pmr::synchronized_pool_resource r2;\n+  VERIFY( r1 != r2 );\n+  VERIFY( r2 != r1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "d01d65a3bc6d6df22b8a341cfee197020e99d77b", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/multithreaded.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fmultithreaded.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fmultithreaded.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Fmultithreaded.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17 -pthread\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory_resource>\n+#include <future>\n+#include <testsuite_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  std::pmr::synchronized_pool_resource smr(&test_mr);\n+\n+  const std::size_t largest_pool = smr.options().largest_required_pool_block;\n+\n+  auto do_alloc = [&smr](void*& p, size_t n) {\n+    // perform some other allocations and deallocations on the same thread:\n+    void* p2 = smr.allocate(n);\n+    smr.deallocate(p2, n);\n+    p2 = smr.allocate(n);\n+    p = smr.allocate(n);\n+    smr.deallocate(p2, n);\n+  };\n+  auto do_dealloc = [&smr](void* p, size_t n) { smr.deallocate(p, n); };\n+\n+  void* p1;\n+  void* p2;\n+  void* p3;\n+  auto f1 = std::async(std::launch::async, do_alloc, std::ref(p1), 8);\n+  auto f2 = std::async(std::launch::async, do_alloc, std::ref(p2), 64);\n+  auto f3 = std::async(std::launch::async, do_alloc, std::ref(p3),\n+\t\t       largest_pool* 2);\n+\n+  f1.get();\n+  f2.get();\n+  f3.get();\n+  VERIFY( p1 != nullptr );\n+  VERIFY( p2 != nullptr );\n+  VERIFY( p3 != nullptr );\n+  size_t nallocs = test_mr.number_of_active_allocations();\n+  VERIFY( nallocs >= 4 );\n+\n+  // deallocate on different threads from allocation:\n+  f1 = std::async(std::launch::async, do_dealloc, p1, 8);\n+  f2 = std::async(std::launch::async, do_dealloc, p2, 64);\n+  f1.get();\n+  f2.get();\n+  // No additional memory is allocated by deallocating on new threads:\n+  VERIFY( test_mr.number_of_active_allocations() == nallocs );\n+\n+  // Deallocate large unpooled allocation:\n+  f3 = std::async(std::launch::async, do_dealloc, p3, largest_pool * 2);\n+  f3.get();\n+  // The large allocation should have been returned upstream:\n+  VERIFY( test_mr.number_of_active_allocations() == nallocs - 1 );\n+\n+  smr.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "a0b63773d0c006c205e040b8773a9e3827da724c", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/options.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Foptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Foptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Foptions.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17 -pthread\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory_resource>\n+#include <testsuite_hooks.h>\n+\n+bool eq(const std::pmr::pool_options& lhs, const std::pmr::pool_options& rhs)\n+{\n+  return lhs.max_blocks_per_chunk == rhs.max_blocks_per_chunk\n+    && lhs.largest_required_pool_block == rhs.largest_required_pool_block;\n+}\n+\n+void\n+test01()\n+{\n+  std::pmr::synchronized_pool_resource r0;\n+  const std::pmr::pool_options opts = r0.options();\n+  VERIFY( opts.max_blocks_per_chunk != 0 );\n+  VERIFY( opts.largest_required_pool_block != 0 );\n+\n+  std::pmr::synchronized_pool_resource r1(opts);\n+  const auto opts1 = r1.options();\n+  VERIFY( eq(opts, opts1) );\n+\n+  std::pmr::synchronized_pool_resource r2(std::pmr::pool_options{0, 0});\n+  const auto opts2 = r2.options();\n+  VERIFY( eq(opts, opts2) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "af3055df5645992625570b6475b4307c92a875bd", "filename": "libstdc++-v3/testsuite/20_util/synchronized_pool_resource/release.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Frelease.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Frelease.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fsynchronized_pool_resource%2Frelease.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -0,0 +1,116 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+// { dg-options \"-std=gnu++17 -pthread\" }\n+// { dg-require-effective-target c++17 }\n+// { dg-require-effective-target pthread }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory_resource>\n+#include <testsuite_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  std::pmr::synchronized_pool_resource r(&test_mr);\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  (void) r.allocate(1);\n+  VERIFY( test_mr.number_of_active_allocations() != 0 );\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  r.release();\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  struct nullable_memory_resource : public std::pmr::memory_resource\n+  {\n+    void*\n+    do_allocate(std::size_t bytes, std::size_t alignment) override\n+    { return upstream->allocate(bytes, alignment); }\n+\n+    void\n+    do_deallocate(void* p, std::size_t bytes, std::size_t alignment) override\n+    { upstream->deallocate(p, bytes, alignment); }\n+\n+    bool\n+    do_is_equal(const memory_resource& r) const noexcept override\n+    { return &r == this; }\n+\n+    std::pmr::memory_resource* upstream = std::pmr::get_default_resource();\n+  };\n+\n+  nullable_memory_resource test_mr;\n+  std::pmr::synchronized_pool_resource r(&test_mr);\n+  r.release();\n+  test_mr.upstream = nullptr;\n+  r.release(); // should not need to call anything through upstream pointer\n+}\n+\n+void\n+test03()\n+{\n+  __gnu_test::memory_resource test_mr;\n+  {\n+    std::pmr::synchronized_pool_resource r(&test_mr);\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::synchronized_pool_resource r(&test_mr);\n+    (void) r.allocate(1);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::synchronized_pool_resource r({10, 16}, &test_mr);\n+    (void) r.allocate(2 * r.options().largest_required_pool_block);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+  {\n+    std::pmr::synchronized_pool_resource r({16, 16}, &test_mr);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2);\n+    (void) r.allocate(8);\n+    (void) r.allocate(16);\n+    (void) r.allocate(2 * r.options().largest_required_pool_block);\n+    VERIFY( test_mr.number_of_active_allocations() != 0 );\n+    // Destructor calls release()\n+  }\n+  VERIFY( test_mr.number_of_active_allocations() == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "8a2a5f1facf22d3a5be4d919d9672c16534d9d25", "filename": "libstdc++-v3/testsuite/performance/20_util/memory_resource/pools.cc", "status": "modified", "additions": 334, "deletions": 37, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fmemory_resource%2Fpools.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be64810cd037b134e2f388b9345a5ebf0ce387/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fmemory_resource%2Fpools.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fmemory_resource%2Fpools.cc?ref=c5be64810cd037b134e2f388b9345a5ebf0ce387", "patch": "@@ -15,40 +15,34 @@\n \n // Override the -std flag in the check_performance script: STD=gnu++17\n \n+// Run the test as both single- and multi-threaded: TEST_B\n+\n #include <memory_resource>\n #include <list>\n #include <string>\n #include <testsuite_performance.h>\n \n-struct size16 { char c[16]; };\n-struct size32 { char c[32]; };\n-struct size64 { char c[64]; };\n-struct size128 { char c[128]; };\n+const int iterations = 100;\n \n // Insert and remove elements of various sizes in std::list containers.\n-// If report=true the function will measure and report the total performance\n-// including the time taken to destroy the lists and deallocate everything.\n-// If dest=false the function will measure and report the performance of\n-// insert/remove operations only, not the destruction of the lists.\n+// If timers!=nullptr the function will pause the timer while the lists\n+// are cleared and deallocated, so that only insertions/removals are timed.\n+// Otherwise, the time taken to deallocate the lists is also counted.\n void\n-populate_lists(std::pmr::memory_resource* r, std::string name, bool dest,\n-\t       int kmax = 100)\n+populate_lists(std::pmr::memory_resource* r, __gnu_test::time_counter* timers,\n+\t       int kmax = iterations)\n {\n-  name += \" std::list push/pop\";\n-  if (dest)\n-    name += \"/destroy\";\n+  struct size16 { char c[16]; };\n+  struct size32 { char c[32]; };\n+  struct size64 { char c[64]; };\n+  struct size128 { char c[128]; };\n \n   std::pmr::list<int> l4(r);\n   std::pmr::list<size16> l16(r);\n   std::pmr::list<size32> l32(r);\n   std::pmr::list<size64> l64(r);\n   std::pmr::list<size128> l128(r);\n \n-  using namespace __gnu_test;\n-  time_counter time;\n-  resource_counter resource;\n-  start_counters(time, resource);\n-\n   const int imax = 1000;\n   const int jmax = 100;\n   for (int k = 0; k < kmax; ++k)\n@@ -70,8 +64,8 @@ populate_lists(std::pmr::memory_resource* r, std::string name, bool dest,\n       l128.pop_front();\n     }\n \n-    if (!dest)\n-      time.stop();\n+    if (timers)\n+      timers->stop();\n \n     // Deallocate everything:\n     l4.clear();\n@@ -80,35 +74,338 @@ populate_lists(std::pmr::memory_resource* r, std::string name, bool dest,\n     l64.clear();\n     l128.clear();\n \n-    if (!dest)\n-      time.restart();\n+    if (timers)\n+      timers->restart();\n   }\n-\n-  stop_counters(time, resource);\n-\n-  report_performance(__FILE__, name.c_str(), time, resource);\n-  clear_counters(time, resource);\n }\n \n-int main()\n+// Test allocations and deallocations of node-based containers (std::list).\n+// In this test pmr::unsynchronized_pool_resource should be faster than\n+// pmr::new_delete_resource().\n+void test_lists_single_thread()\n {\n   std::pmr::memory_resource* newdel = std::pmr::new_delete_resource();\n   std::pmr::unsynchronized_pool_resource pool;\n+#ifndef NOTHREAD\n+  std::pmr::synchronized_pool_resource syncpool;\n+#endif\n+\n+  auto run_test = [](auto* memres, std::string name, bool time_dtors) {\n+    name += \" std::list push/pop\";\n+    if (time_dtors)\n+      name += \"/destroy\";\n+    __gnu_test::time_counter time;\n+    __gnu_test::resource_counter resource;\n+    start_counters(time, resource);\n+    populate_lists(memres, time_dtors ? nullptr : &time);\n+    stop_counters(time, resource);\n+    report_performance(__FILE__, name, time, resource);\n+  };\n \n-  for (auto b : { false, true })\n+  for (auto time_dtors : {false, true})\n   {\n+    run_test(newdel, \"new-delete-1 \", time_dtors);\n+    run_test(newdel, \"new-delete-2 \", time_dtors);\n+    run_test(newdel, \"new-delete-3 \", time_dtors);\n+\n     // Start with an empty set of pools:\n     pool.release();\n-\n-    populate_lists(newdel, \"new_delete 1\", b);\n-    populate_lists(newdel, \"new_delete 2\", b);\n-    populate_lists(newdel, \"new_delete 3\", b);\n-\n-    populate_lists(&pool, \"unsync pool 1\", b);\n+    run_test(&pool, \"unsync-pool-1\", time_dtors);\n     // Destroy pools and start fresh:\n     pool.release();\n-    populate_lists(&pool, \"unsync pool 2\", b);\n+    run_test(&pool, \"unsync-pool-2\", time_dtors);\n+    // Do not destroy pools, reuse allocated memory:\n+    run_test(&pool, \"unsync-pool-3\", time_dtors);\n+\n+#ifndef NOTHREAD\n+    syncpool.release();\n+    run_test(&syncpool, \"sync-pool-1  \", time_dtors);\n+    // Destroy pools and start fresh:\n+    syncpool.release();\n+    run_test(&syncpool, \"sync-pool-2  \", time_dtors);\n     // Do not destroy pools, reuse allocated memory:\n-    populate_lists(&pool, \"unsync pool 3\", b);\n+    run_test(&syncpool, \"sync-pool-3  \", time_dtors);\n+#endif\n+  }\n+}\n+\n+// TODO test non-pooled large allocations from (un)synchronized_pool_resource\n+\n+#ifndef NOTHREAD\n+# include <thread>\n+# include <mutex>\n+# include <cassert>\n+\n+// Multithreaded std::list test with each thread having its own resource.\n+// (pmr::new_delete vs pmr::unsynchronized_pool vs pmr::synchronized_pool)\n+//\n+// In this test both pmr::unsynchronized_pool_resource and\n+// pmr::synchronized_pool_resource should be faster than\n+// pmr::new_delete_resource().\n+void test_lists_resource_per_thread()\n+{\n+  std::mutex mx;\n+  std::unique_lock<std::mutex> gate(mx, std::defer_lock);\n+\n+  struct state\n+  {\n+    std::thread thread;\n+\n+    // Per-thread pool resources:\n+    std::pmr::unsynchronized_pool_resource unsync;\n+    std::pmr::synchronized_pool_resource sync;\n+\n+    std::pmr::memory_resource* memres[3] = {\n+      std::pmr::new_delete_resource(), &unsync, &sync\n+    };\n+  };\n+\n+  state states[4];\n+\n+  const std::string resnames[] = {\"new-delete \", \"unsync-pool\", \"sync-pool  \"};\n+\n+  auto run_test = [&mx] (std::pmr::memory_resource* memres,\n+\t\t\t __gnu_test::time_counter* timers)\n+  {\n+    std::lock_guard<std::mutex>{mx};  // block until the mutex can be locked\n+    populate_lists(memres, timers);\n+  };\n+\n+  auto time_threads = [&] (std::string testname, bool time_dtors, int which) {\n+    __gnu_test::time_counter time;\n+    __gnu_test::resource_counter resource;\n+    gate.lock();\n+    auto* time_ptr = time_dtors ? nullptr : &time;\n+    for (auto& s : states)\n+      s.thread = std::thread{ run_test, s.memres[which], time_ptr };\n+    start_counters(time, resource);\n+    gate.unlock(); // let the threads run\n+    for (auto& s : states)\n+      s.thread.join();\n+    stop_counters(time, resource);\n+    report_performance(__FILE__, resnames[which] + testname, time, resource);\n+  };\n+\n+  for (auto time_dtors : {false, true})\n+  {\n+    std::string testname = \" resource-per-thread std::list push/pop\";\n+    if (time_dtors)\n+      testname += \"/destroy\";\n+    for (int which : {0, 1, 2})\n+      time_threads(testname, time_dtors, which);\n+  }\n+}\n+\n+// A naive memory_resource that adds a mutex to unsynchronized_pool_resource\n+struct locking_pool_resource : std::pmr::unsynchronized_pool_resource\n+{\n+  void* do_allocate(std::size_t b, std::size_t a) override\n+  {\n+    std::lock_guard<std::mutex> l(m);\n+    return unsynchronized_pool_resource::do_allocate(b, a);\n+  }\n+\n+  void do_deallocate(void* p, std::size_t b, std::size_t a) override\n+  {\n+    std::lock_guard<std::mutex> l(m);\n+    return unsynchronized_pool_resource::do_deallocate(p, b, a);\n   }\n+\n+  std::mutex m;\n+};\n+\n+// Multithreaded std::list test with all threads sharing the same resource.\n+// (new_delete vs unsynchronized_pool+mutex vs synchronized_pool)\n+//\n+// pmr::synchronized_pool_resource is not expected to be anywhere near\n+// as fast as pmr::new_delete_resource() here, but should perform much\n+// better than the naive locking_pool_resource type.\n+void test_lists_shared_resource()\n+{\n+  std::mutex mx;\n+  std::unique_lock<std::mutex> gate(mx, std::defer_lock);\n+\n+  locking_pool_resource unsync;\n+  std::pmr::synchronized_pool_resource sync;\n+\n+  std::pmr::memory_resource* memres[3] = {\n+    std::pmr::new_delete_resource(), &unsync, &sync\n+  };\n+\n+  std::thread threads[4];\n+\n+  const std::string resnames[3] = { \"new-delete\", \"mutex-pool\", \"sync-pool \" };\n+\n+  auto run_test = [&mx] (std::pmr::memory_resource* memres,\n+\t\t\t __gnu_test::time_counter* timers)\n+  {\n+    std::lock_guard<std::mutex>{mx};  // block until the mutex can be locked\n+    populate_lists(memres, timers);\n+  };\n+\n+  auto time_threads = [&] (std::string testname, bool time_dtors, int which) {\n+    __gnu_test::time_counter time;\n+    __gnu_test::resource_counter resource;\n+    gate.lock();\n+    auto* time_ptr = time_dtors ? nullptr : &time;\n+    for (auto& t : threads)\n+      t = std::thread{ run_test, memres[which], time_ptr };\n+    start_counters(time, resource);\n+    gate.unlock(); // let the threads run\n+    for (auto& t : threads)\n+      t.join();\n+    stop_counters(time, resource);\n+    report_performance(__FILE__, resnames[which] + testname, time, resource);\n+  };\n+\n+  for (auto time_dtors : {false, true})\n+  {\n+    std::string testname = \" shared-resource std::list push/pop\";\n+    if (time_dtors)\n+      testname += \"/destroy\";\n+    for (int which : {0, 1, 2})\n+      time_threads(testname, time_dtors, which);\n+  }\n+}\n+\n+// TODO threaded test just doing loads of allocations, no deallocs\n+// both with per-thread resource (unsync vs sync vs newdel)\n+// and shared resource (locked vs sync vs newdel)\n+\n+// TODO threaded test just doing loads of deallocations, no allocs\n+// both with per-thread resource (unsync vs sync vs newdel)\n+// and shared resource (locked vs sync vs newdel)\n+\n+// Multithreaded test where deallocations happen on different threads.\n+// (new_delete vs unsynchronized_pool+mutex vs synchronized_pool)\n+//\n+// This hits the slow path for pmr::synchronized_pool_resource, where\n+// an exclusive lock must be taken to access other threads' pools.\n+// pmr::synchronized_pool_resource is not expected to be anywhere near\n+// as fast as pmr::new_delete_resource() here, but should perform much\n+// better than the naive locking_pool_resource type.\n+void test_cross_thread_dealloc()\n+{\n+  const int num_threads = 4;\n+\n+  struct X {\n+    void* ptr;\n+    unsigned size;\n+  };\n+\n+  // A buffer for each thread, and extra buffers for half of the threads:\n+  std::vector<X> allocs[num_threads * 3 / 2];\n+  for (auto& v : allocs)\n+    v.resize(1000 * iterations);\n+\n+  // Use a few different pools\n+  const std::size_t sizes[] = { 8, 16, 8, 16, 32, 64, 8, 16, 32, 64 };\n+\n+  std::mutex mx;\n+\n+  auto run_test =\n+  [&, num_threads] (std::pmr::memory_resource* memres, int i, bool with_exit)\n+  {\n+    std::size_t counter = 0;\n+    std::lock_guard<std::mutex>{mx};\n+    // Fill this thread's buffer with allocations:\n+    for (X& x : allocs[i])\n+    {\n+      x.size = sizes[counter++ % 10];\n+      x.ptr = memres->allocate(x.size, 1);\n+    }\n+\n+    if (with_exit && i == 0)\n+    {\n+      // One of the threads exits, so that its pools transfer to the\n+      // non-thread-specific list of pools.\n+      return;\n+    }\n+    else if (i < num_threads / 2)\n+    {\n+      // Other threads continue allocating, into the extra buffers:\n+      for (X& x : allocs[num_threads + i])\n+      {\n+\tx.size = sizes[counter++ % 10];\n+\tx.ptr = memres->allocate(x.size, 1);\n+      }\n+    }\n+    else\n+    {\n+      // Half of the threads start deallocating their own memory and the\n+      // memory belonging to another pool\n+      const int other = i - num_threads / 2;\n+      for (unsigned n = 0; n < allocs[i].size(); ++n)\n+      {\n+\t// Deallocate memory allocated in this thread:\n+\tX& x1 = allocs[i][n];\n+\tmemres->deallocate(x1.ptr, x1.size, 1);\n+\tx1 = {};\n+\t// Deallocate memory allocated in another thread:\n+\tX& x2 = allocs[other][n];\n+\tmemres->deallocate(x2.ptr, x2.size, 1);\n+\tx2 = {};\n+      }\n+    }\n+  };\n+\n+  std::thread threads[num_threads];\n+\n+  locking_pool_resource unsync;\n+  std::pmr::synchronized_pool_resource sync;\n+\n+  std::pmr::memory_resource* memres[3] = {\n+    std::pmr::new_delete_resource(), &unsync, &sync\n+  };\n+  const std::string resnames[3] = { \"new-delete\", \"mutex-pool\", \"sync-pool \" };\n+\n+  auto time_threads = [&] (std::string name, int which, bool with_exit)\n+  {\n+    __gnu_test::time_counter time;\n+    __gnu_test::resource_counter resource;\n+    std::unique_lock<std::mutex> gate(mx);\n+    for (auto& t : threads)\n+      t = std::thread{ run_test, memres[which], &t - threads, with_exit };\n+    start_counters(time, resource);\n+    gate.unlock();\n+    for (auto& t : threads)\n+      t.join();\n+    stop_counters(time, resource);\n+    report_performance(__FILE__, resnames[which] + name, time, resource);\n+\n+    // Clean up:\n+    for (auto& a : allocs)\n+    {\n+      const int i = (&a - allocs);\n+      if (i < num_threads) // These allocations were freed\n+\tfor (auto& x : a)\n+\t{\n+\t  assert(x.ptr == nullptr);\n+\t}\n+      else if (with_exit && i == num_threads)\n+\t;\n+      else\n+\tfor (auto& x : a)\n+\t{\n+\t  memres[which]->deallocate(x.ptr, x.size, 1);\n+\t  x = {};\n+\t}\n+    }\n+  };\n+\n+  for (int which : {0, 1, 2})\n+    time_threads(\" cross-thread dealloc\", which, false);\n+  for (int which : {0, 1, 2})\n+    time_threads(\" cross-thread dealloc w/exit\", which, true);\n+}\n+#endif\n+\n+int main()\n+{\n+  test_lists_single_thread();\n+#ifndef NOTHREAD\n+  test_lists_resource_per_thread();\n+  test_lists_shared_resource();\n+  test_cross_thread_dealloc();\n+#endif\n }"}]}