{"sha": "42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJkZmNmODRjMjY5NjBiY2M5YzBkMmY3N2Y5YzlhYjRjZTQyNDkyNw==", "commit": {"author": {"name": "Wu Yongwei", "email": "adah@sh163.net", "date": "2004-06-23T23:57:27Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2004-06-23T23:57:27Z"}, "message": "gthr-win32.h (__GTHREAD_MUTEX_INIT_DEFAULT): Adjust.\n\n2004-06-23  Wu Yongwei  <adah@sh163.net>\n\n\t* gthr-win32.h (__GTHREAD_MUTEX_INIT_DEFAULT): Adjust.\n\t(__gthr_i486_lock_cmp_xchg): New inline assembly function.\n\t(__GTHR_W32_InterlockedCompareExchange): New macro to choose a\n\tsuitable function for interlocked compare-and-exchange.\n\t(__gthread_mutex_trylock): Use\n\t__GTHR_W32_InterlockedCompareExchange.\n\t(__gthread_mutex_init_function, __gthread_mutex_lock,\n\t__gthread_mutex_trylock, __gthread_mutex_unlock): Adjust the\n\tinitial counter value to work correctly under Windows 95.\n\t* config/i386/gthr-win32.c: Adjust include order.\n\tDefine __GTHREAD_I486_INLINE_LOCK_PRIMITIVES before including\n\tgthr-win32.h.\n\t(__gthr_win32_mutex_init_function, __gthr_win32_mutex_lock,\n\t__gthr_win32_mutex_trylock, __gthr_win32_mutex_unlock): Adjust\n\tto match inline versions in gthr-win32.h.\n\nFrom-SVN: r83569", "tree": {"sha": "71286fc768d32129b2b42546dd5ec76ecaa760bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71286fc768d32129b2b42546dd5ec76ecaa760bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927/comments", "author": null, "committer": null, "parents": [{"sha": "11ac38b22e3f3de50a968364c86c1430e56627ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11ac38b22e3f3de50a968364c86c1430e56627ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11ac38b22e3f3de50a968364c86c1430e56627ac"}], "stats": {"total": 71, "additions": 57, "deletions": 14}, "files": [{"sha": "214eec74acfbe63d4e2dcab5d6d009b444382d57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927", "patch": "@@ -1,3 +1,21 @@\n+2004-06-23  Wu Yongwei  <adah@sh163.net>\n+\n+\t* gthr-win32.h (__GTHREAD_MUTEX_INIT_DEFAULT): Adjust.\n+\t(__gthr_i486_lock_cmp_xchg): New inline assembly function.\n+\t(__GTHR_W32_InterlockedCompareExchange): New macro to choose a\n+\tsuitable function for interlocked compare-and-exchange.\n+\t(__gthread_mutex_trylock): Use\n+\t__GTHR_W32_InterlockedCompareExchange.\n+\t(__gthread_mutex_init_function, __gthread_mutex_lock,\n+\t__gthread_mutex_trylock, __gthread_mutex_unlock): Adjust the\n+\tinitial counter value to work correctly under Windows 95.\n+\t* config/i386/gthr-win32.c: Adjust include order.\n+\tDefine __GTHREAD_I486_INLINE_LOCK_PRIMITIVES before including\n+\tgthr-win32.h.\n+\t(__gthr_win32_mutex_init_function, __gthr_win32_mutex_lock,\n+\t__gthr_win32_mutex_trylock, __gthr_win32_mutex_unlock): Adjust\n+\tto match inline versions in gthr-win32.h.\n+\n 2004-06-23  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_use_dfa_pipeline_interface): Delete."}, {"sha": "c53369bca50c4c81cf1a3dcf957d06e8a21389cb", "filename": "gcc/config/i386/gthr-win32.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgthr-win32.c?ref=42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927", "patch": "@@ -31,11 +31,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    the executable file might be covered by the GNU General Public License.  */\n \n \n+#include <windows.h>\n #ifndef __GTHREAD_HIDE_WIN32API\n # define __GTHREAD_HIDE_WIN32API 1\n #endif\n+#undef  __GTHREAD_I486_INLINE_LOCK_PRIMITIVES\n+#define __GTHREAD_I486_INLINE_LOCK_PRIMITIVES\n #include <gthr-win32.h>\n-#include <windows.h>\n \n /* Windows32 threads specific definitions. The windows32 threading model\n    does not map well into pthread-inspired gcc's threading model, and so \n@@ -144,20 +146,20 @@ __gthr_win32_setspecific (__gthread_key_t key, const void *ptr)\n void\n __gthr_win32_mutex_init_function (__gthread_mutex_t *mutex)\n {\n-  mutex->counter = 0;\n+  mutex->counter = -1;\n   mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n }\n \n int\n __gthr_win32_mutex_lock (__gthread_mutex_t *mutex)\n {\n-  if (InterlockedIncrement (&mutex->counter) == 1 ||\n+  if (InterlockedIncrement (&mutex->counter) == 0 ||\n       WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n     return 0;\n   else\n     {\n-      // WaitForSingleObject returns WAIT_FAILED, and we can only do\n-      // some best-effort cleanup here.\n+      /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n+         some best-effort cleanup here.  */\n       InterlockedDecrement (&mutex->counter);\n       return 1;\n     }\n@@ -166,7 +168,7 @@ __gthr_win32_mutex_lock (__gthread_mutex_t *mutex)\n int\n __gthr_win32_mutex_trylock (__gthread_mutex_t *mutex)\n {\n-  if (InterlockedCompareExchange (&mutex->counter, 1, 0 ) == 0)\n+  if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n     return 0;\n   else\n     return 1;\n@@ -175,7 +177,7 @@ __gthr_win32_mutex_trylock (__gthread_mutex_t *mutex)\n int\n __gthr_win32_mutex_unlock (__gthread_mutex_t *mutex)\n {\n-  if (InterlockedDecrement (&mutex->counter))\n+  if (InterlockedDecrement (&mutex->counter) >= 0)\n     return ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n   else\n     return 0;"}, {"sha": "b7618048430107b85106efdc428797f9d8f84f0f", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=42dfcf84c26960bcc9c0d2f77f9c9ab4ce424927", "patch": "@@ -345,7 +345,7 @@ typedef struct {\n \n #define __GTHREAD_ONCE_INIT {0, -1}\n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n-#define __GTHREAD_MUTEX_INIT_DEFAULT {0, 0}\n+#define __GTHREAD_MUTEX_INIT_DEFAULT {-1, 0}\n \n #if __MINGW32_MAJOR_VERSION >= 1 || \\\n   (__MINGW32_MAJOR_VERSION == 0 && __MINGW32_MINOR_VERSION > 2)\n@@ -357,6 +357,29 @@ extern int _CRT_MT;\n extern int __mingwthr_key_dtor (unsigned long, void (*) (void *));\n #endif /* __MINGW32__ version */\n \n+/* The Windows95 kernel does not export InterlockedCompareExchange.\n+   This provides a substitute.   When building apps that reference\n+   gthread_mutex_try_lock, the  __GTHREAD_I486_INLINE_LOCK_PRIMITIVES\n+   macro  must be defined if Windows95 is a target.  Currently\n+   gthread_mutex_try_lock is not referenced by libgcc or libstdc++.  */\n+#ifdef __GTHREAD_I486_INLINE_LOCK_PRIMITIVES\n+static inline long\n+__gthr_i486_lock_cmp_xchg(long *dest, long xchg, long comperand)\n+{\n+  long result;\n+  __asm__ __volatile__ (\"\\n\\\n+\tlock\\n\\\n+\tcmpxchg{l} {%4, %1|%1, %4}\\n\"\n+\t: \"=a\" (result), \"=m\" (*dest)\n+\t: \"0\" (comperand), \"m\" (*dest), \"r\" (xchg)\n+\t: \"cc\");\n+  return result;\n+}\n+#define __GTHR_W32_InterlockedCompareExchange __gthr_i486_lock_cmp_xchg\n+#else  /* __GTHREAD_I486_INLINE_LOCK_PRIMITIVES */\n+#define __GTHR_W32_InterlockedCompareExchange InterlockedCompareExchange\n+#endif /* __GTHREAD_I486_INLINE_LOCK_PRIMITIVES */\n+\n static inline int\n __gthread_active_p (void)\n {\n@@ -536,7 +559,7 @@ __gthread_setspecific (__gthread_key_t key, const void *ptr)\n static inline void\n __gthread_mutex_init_function (__gthread_mutex_t *mutex)\n {\n-  mutex->counter = 0;\n+  mutex->counter = -1;\n   mutex->sema = CreateSemaphore (NULL, 0, 65535, NULL);\n }\n \n@@ -547,13 +570,13 @@ __gthread_mutex_lock (__gthread_mutex_t *mutex)\n \n   if (__gthread_active_p ())\n     {\n-      if (InterlockedIncrement (&mutex->counter) == 1 ||\n+      if (InterlockedIncrement (&mutex->counter) == 0 ||\n \t  WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n \tstatus = 0;\n       else\n \t{\n-\t  // WaitForSingleObject returns WAIT_FAILED, and we can only do\n-\t  // some best-effort cleanup here.\n+\t  /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n+\t     some best-effort cleanup here.  */\n \t  InterlockedDecrement (&mutex->counter);\n \t  status = 1;\n \t}\n@@ -568,7 +591,7 @@ __gthread_mutex_trylock (__gthread_mutex_t *mutex)\n \n   if (__gthread_active_p ())\n     {\n-      if (InterlockedCompareExchange (&mutex->counter, 1, 0 ) == 0)\n+      if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n \tstatus = 0;\n       else\n \tstatus = 1;\n@@ -581,7 +604,7 @@ __gthread_mutex_unlock (__gthread_mutex_t *mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      if (InterlockedDecrement (&mutex->counter))\n+      if (InterlockedDecrement (&mutex->counter) >= 0)\n \treturn ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n     }\n   return 0;"}]}