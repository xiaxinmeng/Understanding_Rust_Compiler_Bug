{"sha": "98359f20cd2d9268df582ea1ee289e0ea69efcb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgzNTlmMjBjZDJkOTI2OGRmNTgyZWExZWUyODllMGVhNjllZmNiNQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-19T21:13:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-19T21:13:36Z"}, "message": "Merge #685\n\n685: Add v0 type mangling prefixing for simple types r=philberty a=CohenArthur\n\nThis PR adds the generation of type prefixes for simple types, which are numeric types, booleans, chars, strings, empty tuples/unit types and placeholder types.\r\n\r\nI'm unsure as to how to test this, even in the long run. There might be some shenanigans we can pull using an elf reader and regexes in order to compare ABI names with rustc.\r\n\r\nThe entire implementation of v0 name mangling is very large, so I thought I'd split it up in multiple PRs.\n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>", "tree": {"sha": "51e58a17019b1a30f135549ca1f09f6d73eee8cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51e58a17019b1a30f135549ca1f09f6d73eee8cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98359f20cd2d9268df582ea1ee289e0ea69efcb5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhR6gACRBK7hj4Ov3rIwAA1oYIAG5WVj2o6CtIKQwoxuPUQssA\n3u1KCqyfuMsDcxbIVEaQAhooLzuBIGKm2fuycqMwrnS7XkgoRWK0Mh7M0853B98c\nEuzl3ZbzdsZlE+9gmXbOHZU6Uz0f+/SMwSO1t+ulqTgtXS2RbXcmkL36uMc1laBr\n+cm7pRb/yjfbGoddYUFJNLMy17/67B9fOyMGa3Z+G8RX6gRhpbl6SlxussvQO6D5\no2SgvSQUbVfBVQ7ZjSoh76vUSoTB49ecweFVrsQeNjjkCWpmD4A1/8IHh7PPlKob\nlhdv5STCbyJQGXTQsTy2KSO2uyqUvlho8PHkT17d35mXlFObcOVDwAW9JUqWo7s=\n=xWUz\n-----END PGP SIGNATURE-----\n", "payload": "tree 51e58a17019b1a30f135549ca1f09f6d73eee8cf\nparent de43a0ac6d4d5816a5b59cde78aabce651d43cc8\nparent 6c1a482c9b6162f31270f35a95a6e4cf19195232\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632086016 +0000\ncommitter GitHub <noreply@github.com> 1632086016 +0000\n\nMerge #685\n\n685: Add v0 type mangling prefixing for simple types r=philberty a=CohenArthur\n\nThis PR adds the generation of type prefixes for simple types, which are numeric types, booleans, chars, strings, empty tuples/unit types and placeholder types.\r\n\r\nI'm unsure as to how to test this, even in the long run. There might be some shenanigans we can pull using an elf reader and regexes in order to compare ABI names with rustc.\r\n\r\nThe entire implementation of v0 name mangling is very large, so I thought I'd split it up in multiple PRs.\n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98359f20cd2d9268df582ea1ee289e0ea69efcb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98359f20cd2d9268df582ea1ee289e0ea69efcb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98359f20cd2d9268df582ea1ee289e0ea69efcb5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de43a0ac6d4d5816a5b59cde78aabce651d43cc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de43a0ac6d4d5816a5b59cde78aabce651d43cc8"}, {"sha": "6c1a482c9b6162f31270f35a95a6e4cf19195232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1a482c9b6162f31270f35a95a6e4cf19195232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c1a482c9b6162f31270f35a95a6e4cf19195232"}], "stats": {"total": 109, "additions": 97, "deletions": 12}, "files": [{"sha": "840acb992e00a7e9e723b20d5bc231fe4fdd22b3", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "modified", "additions": 97, "deletions": 12, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98359f20cd2d9268df582ea1ee289e0ea69efcb5/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98359f20cd2d9268df582ea1ee289e0ea69efcb5/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=98359f20cd2d9268df582ea1ee289e0ea69efcb5", "patch": "@@ -79,6 +79,92 @@ legacy_mangle_self (const TyTy::BaseType *self)\n   return legacy_mangle_name (buf);\n }\n \n+static std::string\n+v0_tuple_prefix (const TyTy::BaseType *ty)\n+{\n+  if (ty->is_unit ())\n+    return \"u\";\n+\n+  // FIXME: ARTHUR: Add rest of algorithm\n+  return \"\";\n+}\n+\n+static std::string\n+v0_numeric_prefix (const TyTy::BaseType *ty)\n+{\n+  static const std::map<std::string, std::string> num_prefixes = {\n+    {\"[i8]\", \"a\"},    {\"[u8]\", \"h\"},\t{\"[i16]\", \"s\"}, {\"[u16]\", \"t\"},\n+    {\"[i32]\", \"l\"},   {\"[u32]\", \"m\"},\t{\"[i64]\", \"x\"}, {\"[u64]\", \"y\"},\n+    {\"[isize]\", \"i\"}, {\"[usize]\", \"j\"}, {\"[f32]\", \"f\"}, {\"[f64]\", \"d\"},\n+  };\n+\n+  auto ty_kind = ty->get_kind ();\n+  auto ty_str = ty->as_string ();\n+  auto numeric_iter = num_prefixes.end ();\n+\n+  // Special numeric types\n+  if (ty_kind == TyTy::TypeKind::ISIZE)\n+    return \"i\";\n+  else if (ty_kind == TyTy::TypeKind::USIZE)\n+    return \"j\";\n+\n+  numeric_iter = num_prefixes.find (ty_str);\n+  if (numeric_iter != num_prefixes.end ())\n+    return numeric_iter->second;\n+\n+  return \"\";\n+}\n+\n+static std::string\n+v0_simple_type_prefix (const TyTy::BaseType *ty)\n+{\n+  switch (ty->get_kind ())\n+    {\n+    case TyTy::TypeKind::BOOL:\n+      return \"b\";\n+    case TyTy::TypeKind::CHAR:\n+      return \"c\";\n+    case TyTy::TypeKind::STR:\n+      return \"e\";\n+    case TyTy::TypeKind::NEVER:\n+      return \"z\";\n+\n+      // Placeholder types\n+    case TyTy::TypeKind::ERROR:\t      // Fallthrough\n+    case TyTy::TypeKind::INFER:\t      // Fallthrough\n+    case TyTy::TypeKind::PLACEHOLDER: // Fallthrough\n+    case TyTy::TypeKind::PARAM:\n+      // FIXME: TyTy::TypeKind::BOUND is also a valid variant in rustc\n+      return \"p\";\n+\n+    case TyTy::TypeKind::TUPLE:\n+      return v0_tuple_prefix (ty);\n+\n+    case TyTy::TypeKind::UINT:\t// Fallthrough\n+    case TyTy::TypeKind::INT:\t// Fallthrough\n+    case TyTy::TypeKind::FLOAT: // Fallthrough\n+    case TyTy::TypeKind::ISIZE: // Fallthrough\n+    case TyTy::TypeKind::USIZE: // Fallthrough\n+      return v0_numeric_prefix (ty);\n+\n+    default:\n+      return \"\";\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+static std::string\n+v0_type_prefix (const TyTy::BaseType *ty)\n+{\n+  auto ty_prefix = v0_simple_type_prefix (ty);\n+  if (!ty_prefix.empty ())\n+    return ty_prefix;\n+\n+  // FIXME: We need to fetch more type prefixes\n+  gcc_unreachable ();\n+}\n+\n static std::string\n legacy_mangle_item (const TyTy::BaseType *ty,\n \t\t    const Resolver::CanonicalPath &path,\n@@ -104,17 +190,16 @@ legacy_mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n \t + kMangledSymbolDelim;\n }\n \n-// FIXME: Uncomment once v0 mangling is implemented\n-// static std::string\n-// Mangler::v0_mangle_item (const TyTy::BaseType *ty,\n-// \t\t\t const std::string &name)\n-// {}\n-//\n-// static std::string\n-// Mangler::v0_mangle_impl_item (const TyTy::BaseType *self,\n-// \t\t\t      const TyTy::BaseType *ty,\n-// \t\t\t      const std::string &name)\n-// {}\n+static std::string\n+v0_mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path,\n+\t\tconst std::string &crate_name)\n+{\n+  auto ty_prefix = v0_type_prefix (ty);\n+}\n+\n+static std::string\n+v0_mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n+\t\t     const std::string &name, const std::string &crate_name);\n \n std::string\n Mangler::mangle_item (const TyTy::BaseType *ty,\n@@ -126,7 +211,7 @@ Mangler::mangle_item (const TyTy::BaseType *ty,\n     case Mangler::MangleVersion::LEGACY:\n       return legacy_mangle_item (ty, path, crate_name);\n     case Mangler::MangleVersion::V0:\n-      gcc_unreachable ();\n+      return v0_mangle_item (ty, path, crate_name);\n     default:\n       gcc_unreachable ();\n     }"}]}