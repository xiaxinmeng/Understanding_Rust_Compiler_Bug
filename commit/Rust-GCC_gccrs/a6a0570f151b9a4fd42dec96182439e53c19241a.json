{"sha": "a6a0570f151b9a4fd42dec96182439e53c19241a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhMDU3MGYxNTFiOWE0ZmQ0MmRlYzk2MTgyNDM5ZTUzYzE5MjQxYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-12-03T13:10:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-12-03T13:10:39Z"}, "message": "builtins.c (fold_builtin_fpclassify): Change to take array of arguments instead of CALL_EXPR tree.\n\n2014-12-03  Richard Biener  <rguenther@suse.de>\n\n\t* builtins.c (fold_builtin_fpclassify): Change to take\n\tarray of arguments instead of CALL_EXPR tree.\n\t(MAX_ARGS_TO_FOLD_BUILTIN): Remove.\n\t(fold_builtin_n): Dispatch to fold_builtin_varargs.\n\t(fold_call_expr): Always use fold_builtin_n.\n\t(fold_builtin_call_array): Change to not build the unfolded call,\n\talways use fold_builtin_n.\n\t(fold_builtin_varargs): Change to take array of arguments instead\n\tof CALL_EXPR tree.\n\t(fold_call_stmt): Always use fold_builtin_n.\n\t* tree.c (build_call_expr_loc_array): Use fold_build_call_array_loc.\n\t* fold-const.c (fold_build_call_array_loc): Build the call\n\tif fold_builtin_call_array returned NULL_TREE.\n\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Do not build\n\ta CALL_EXPR and use fold_builtin_call_array instead of\n\tfold_call_expr.\n\n\tcp/\n\t* constexpr.c (cxx_eval_builtin_function_call): Use\n\tfold_build_call_array_loc.\n\nFrom-SVN: r218311", "tree": {"sha": "35cb5d29ee00714e432effd24006281aa7ec24d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35cb5d29ee00714e432effd24006281aa7ec24d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a0570f151b9a4fd42dec96182439e53c19241a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a0570f151b9a4fd42dec96182439e53c19241a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a0570f151b9a4fd42dec96182439e53c19241a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a0570f151b9a4fd42dec96182439e53c19241a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a844a6958395311c579a982d82958088b418be77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a844a6958395311c579a982d82958088b418be77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a844a6958395311c579a982d82958088b418be77"}], "stats": {"total": 168, "additions": 84, "deletions": 84}, "files": [{"sha": "5e3920e0d9a33a5437c8ccc5be544509c8c48ae1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6a0570f151b9a4fd42dec96182439e53c19241a", "patch": "@@ -1,3 +1,22 @@\n+2014-12-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* builtins.c (fold_builtin_fpclassify): Change to take\n+\tarray of arguments instead of CALL_EXPR tree.\n+\t(MAX_ARGS_TO_FOLD_BUILTIN): Remove.\n+\t(fold_builtin_n): Dispatch to fold_builtin_varargs.\n+\t(fold_call_expr): Always use fold_builtin_n.\n+\t(fold_builtin_call_array): Change to not build the unfolded call,\n+\talways use fold_builtin_n.\n+\t(fold_builtin_varargs): Change to take array of arguments instead\n+\tof CALL_EXPR tree.\n+\t(fold_call_stmt): Always use fold_builtin_n.\n+\t* tree.c (build_call_expr_loc_array): Use fold_build_call_array_loc.\n+\t* fold-const.c (fold_build_call_array_loc): Build the call\n+\tif fold_builtin_call_array returned NULL_TREE.\n+\t* gimple-fold.c (gimple_fold_stmt_to_constant_1): Do not build\n+\ta CALL_EXPR and use fold_builtin_call_array instead of\n+\tfold_call_expr.\n+\n 2014-12-03  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (aarch64_simd_dup<mode>, orn<mode>3,"}, {"sha": "236f9207ede83926102fdf511b0c9236ebaa1786", "filename": "gcc/builtins.c", "status": "modified", "additions": 53, "deletions": 78, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a6a0570f151b9a4fd42dec96182439e53c19241a", "patch": "@@ -196,7 +196,7 @@ static tree fold_builtin_1 (location_t, tree, tree, bool);\n static tree fold_builtin_2 (location_t, tree, tree, tree, bool);\n static tree fold_builtin_3 (location_t, tree, tree, tree, tree, bool);\n static tree fold_builtin_4 (location_t, tree, tree, tree, tree, tree, bool);\n-static tree fold_builtin_varargs (location_t, tree, tree, bool);\n+static tree fold_builtin_varargs (location_t, tree, tree*, int, bool);\n \n static tree fold_builtin_strpbrk (location_t, tree, tree, tree);\n static tree fold_builtin_strstr (location_t, tree, tree, tree);\n@@ -9692,7 +9692,7 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n    one floating point argument which is \"type generic\".  */\n \n static tree\n-fold_builtin_fpclassify (location_t loc, tree exp)\n+fold_builtin_fpclassify (location_t loc, tree *args, int nargs)\n {\n   tree fp_nan, fp_infinite, fp_normal, fp_subnormal, fp_zero,\n     arg, type, res, tmp;\n@@ -9701,17 +9701,21 @@ fold_builtin_fpclassify (location_t loc, tree exp)\n   char buf[128];\n \n   /* Verify the required arguments in the original call.  */\n-  if (!validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE,\n-\t\t\t INTEGER_TYPE, INTEGER_TYPE,\n-\t\t\t INTEGER_TYPE, REAL_TYPE, VOID_TYPE))\n+  if (nargs != 6\n+      || !validate_arg (args[0], INTEGER_TYPE)\n+      || !validate_arg (args[1], INTEGER_TYPE)\n+      || !validate_arg (args[2], INTEGER_TYPE)\n+      || !validate_arg (args[3], INTEGER_TYPE)\n+      || !validate_arg (args[4], INTEGER_TYPE)\n+      || !validate_arg (args[5], REAL_TYPE))\n     return NULL_TREE;\n \n-  fp_nan = CALL_EXPR_ARG (exp, 0);\n-  fp_infinite = CALL_EXPR_ARG (exp, 1);\n-  fp_normal = CALL_EXPR_ARG (exp, 2);\n-  fp_subnormal = CALL_EXPR_ARG (exp, 3);\n-  fp_zero = CALL_EXPR_ARG (exp, 4);\n-  arg = CALL_EXPR_ARG (exp, 5);\n+  fp_nan = args[0];\n+  fp_infinite = args[1];\n+  fp_normal = args[2];\n+  fp_subnormal = args[3];\n+  fp_zero = args[4];\n+  arg = args[5];\n   type = TREE_TYPE (arg);\n   mode = TYPE_MODE (type);\n   arg = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));\n@@ -10621,14 +10625,9 @@ fold_builtin_4 (location_t loc, tree fndecl,\n }\n \n /* Fold a call to built-in function FNDECL.  ARGS is an array of NARGS\n-    arguments, where NARGS <= 4.  IGNORE is true if the result of the\n-    function call is ignored.  This function returns NULL_TREE if no\n-    simplification was possible.  Note that this only folds builtins with\n-    fixed argument patterns.  Foldings that do varargs-to-varargs\n-    transformations, or that match calls with more than 4 arguments,\n-    need to be handled with fold_builtin_varargs instead.  */\n-\n-#define MAX_ARGS_TO_FOLD_BUILTIN 4\n+   arguments.  IGNORE is true if the result of the\n+   function call is ignored.  This function returns NULL_TREE if no\n+   simplification was possible.  */\n \n tree\n fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool ignore)\n@@ -10654,6 +10653,7 @@ fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool ignore)\n  \t\t\t    ignore);\n       break;\n     default:\n+      ret = fold_builtin_varargs (loc, fndecl, args, nargs, ignore);\n       break;\n     }\n   if (ret)\n@@ -10750,76 +10750,52 @@ fold_call_expr (location_t loc, tree exp, bool ignore)\n \t\t\t\t     CALL_EXPR_ARGP (exp), ignore);\n       else\n \t{\n-\t  if (nargs <= MAX_ARGS_TO_FOLD_BUILTIN)\n-\t    {\n-\t      tree *args = CALL_EXPR_ARGP (exp);\n-\t      ret = fold_builtin_n (loc, fndecl, args, nargs, ignore);\n-\t    }\n-\t  if (!ret)\n-\t    ret = fold_builtin_varargs (loc, fndecl, exp, ignore);\n+\t  tree *args = CALL_EXPR_ARGP (exp);\n+\t  ret = fold_builtin_n (loc, fndecl, args, nargs, ignore);\n \t  if (ret)\n \t    return ret;\n \t}\n     }\n   return NULL_TREE;\n }\n \n-/* Construct a CALL_EXPR with type TYPE with FN as the function expression.\n-   N arguments are passed in the array ARGARRAY.  */\n+/* Fold a CALL_EXPR with type TYPE with FN as the function expression.\n+   N arguments are passed in the array ARGARRAY.  Return a folded\n+   expression or NULL_TREE if no simplification was possible.  */\n \n tree\n-fold_builtin_call_array (location_t loc, tree type,\n+fold_builtin_call_array (location_t loc, tree,\n \t\t\t tree fn,\n \t\t\t int n,\n \t\t\t tree *argarray)\n {\n-  tree ret = NULL_TREE;\n-   tree exp;\n-\n-  if (TREE_CODE (fn) == ADDR_EXPR)\n-  {\n-    tree fndecl = TREE_OPERAND (fn, 0);\n-    if (TREE_CODE (fndecl) == FUNCTION_DECL\n-        && DECL_BUILT_IN (fndecl))\n-      {\n-\t/* If last argument is __builtin_va_arg_pack (), arguments to this\n-\t   function are not finalized yet.  Defer folding until they are.  */\n-\tif (n && TREE_CODE (argarray[n - 1]) == CALL_EXPR)\n-\t  {\n-\t    tree fndecl2 = get_callee_fndecl (argarray[n - 1]);\n-\t    if (fndecl2\n-\t\t&& TREE_CODE (fndecl2) == FUNCTION_DECL\n-\t\t&& DECL_BUILT_IN_CLASS (fndecl2) == BUILT_IN_NORMAL\n-\t\t&& DECL_FUNCTION_CODE (fndecl2) == BUILT_IN_VA_ARG_PACK)\n-\t      return build_call_array_loc (loc, type, fn, n, argarray);\n-\t  }\n-\tif (avoid_folding_inline_builtin (fndecl))\n-\t  return build_call_array_loc (loc, type, fn, n, argarray);\n-        if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n-          {\n-\t    ret = targetm.fold_builtin (fndecl, n, argarray, false);\n-\t    if (ret)\n-\t      return ret;\n+  if (TREE_CODE (fn) != ADDR_EXPR)\n+    return NULL_TREE;\n \n-\t    return build_call_array_loc (loc, type, fn, n, argarray);\n-          }\n-        else if (n <= MAX_ARGS_TO_FOLD_BUILTIN)\n-          {\n-            /* First try the transformations that don't require consing up\n-               an exp.  */\n-            ret = fold_builtin_n (loc, fndecl, argarray, n, false);\n-            if (ret)\n-              return ret;\n-          }\n-\n-        /* If we got this far, we need to build an exp.  */\n-        exp = build_call_array_loc (loc, type, fn, n, argarray);\n-        ret = fold_builtin_varargs (loc, fndecl, exp, false);\n-        return ret ? ret : exp;\n-      }\n-  }\n+  tree fndecl = TREE_OPERAND (fn, 0);\n+  if (TREE_CODE (fndecl) == FUNCTION_DECL\n+      && DECL_BUILT_IN (fndecl))\n+    {\n+      /* If last argument is __builtin_va_arg_pack (), arguments to this\n+\t function are not finalized yet.  Defer folding until they are.  */\n+      if (n && TREE_CODE (argarray[n - 1]) == CALL_EXPR)\n+\t{\n+\t  tree fndecl2 = get_callee_fndecl (argarray[n - 1]);\n+\t  if (fndecl2\n+\t      && TREE_CODE (fndecl2) == FUNCTION_DECL\n+\t      && DECL_BUILT_IN_CLASS (fndecl2) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (fndecl2) == BUILT_IN_VA_ARG_PACK)\n+\t    return NULL_TREE;\n+\t}\n+      if (avoid_folding_inline_builtin (fndecl))\n+\treturn NULL_TREE;\n+      if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n+\treturn targetm.fold_builtin (fndecl, n, argarray, false);\n+      else\n+\treturn fold_builtin_n (loc, fndecl, argarray, n, false);\n+    }\n \n-  return build_call_array_loc (loc, type, fn, n, argarray);\n+  return NULL_TREE;\n }\n \n /* Construct a new CALL_EXPR using the tail of the argument list of EXP\n@@ -11827,7 +11803,7 @@ fold_builtin_object_size (tree ptr, tree ost)\n    result of the function call is ignored.  */\n \n static tree\n-fold_builtin_varargs (location_t loc, tree fndecl, tree exp,\n+fold_builtin_varargs (location_t loc, tree fndecl, tree *args, int nargs,\n \t\t      bool ignore ATTRIBUTE_UNUSED)\n {\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -11836,7 +11812,7 @@ fold_builtin_varargs (location_t loc, tree fndecl, tree exp,\n   switch (fcode)\n     {\n     case BUILT_IN_FPCLASSIFY:\n-      ret = fold_builtin_fpclassify (loc, exp);\n+      ret = fold_builtin_fpclassify (loc, args, nargs);\n       break;\n \n     default:\n@@ -12747,8 +12723,7 @@ fold_call_stmt (gcall *stmt, bool ignore)\n         }\n       else\n \t{\n-\t  if (nargs <= MAX_ARGS_TO_FOLD_BUILTIN)\n-\t    ret = fold_builtin_n (loc, fndecl, args, nargs, ignore);\n+\t  ret = fold_builtin_n (loc, fndecl, args, nargs, ignore);\n \t  if (ret)\n \t    {\n \t      /* Propagate location information from original call to"}, {"sha": "24fbdd56012709342d8d6047d22aae419336b9f6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a6a0570f151b9a4fd42dec96182439e53c19241a", "patch": "@@ -1,3 +1,8 @@\n+2014-12-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* constexpr.c (cxx_eval_builtin_function_call): Use\n+\tfold_build_call_array_loc.\n+\n 2014-12-02  Marek Polacek  <polacek@redhat.com>\n \n \t* constexpr.c (cxx_eval_check_shift_p): New function."}, {"sha": "d18025f457c5a7490ada94c8508385919f7fb090", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=a6a0570f151b9a4fd42dec96182439e53c19241a", "patch": "@@ -1008,8 +1008,8 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n     }\n   if (*non_constant_p)\n     return t;\n-  new_call = fold_builtin_call_array (EXPR_LOCATION (t), TREE_TYPE (t),\n-\t\t\t\t      CALL_EXPR_FN (t), nargs, args);\n+  new_call = fold_build_call_array_loc (EXPR_LOCATION (t), TREE_TYPE (t),\n+\t\t\t\t\tCALL_EXPR_FN (t), nargs, args);\n   VERIFY_CONSTANT (new_call);\n   return new_call;\n }"}, {"sha": "17eb5bb9f0f5f4ad098b4bf299bab5675f2d8de6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a6a0570f151b9a4fd42dec96182439e53c19241a", "patch": "@@ -14405,6 +14405,8 @@ fold_build_call_array_loc (location_t loc, tree type, tree fn,\n #endif\n \n   tem = fold_builtin_call_array (loc, type, fn, nargs, argarray);\n+  if (!tem)\n+    tem = build_call_array_loc (loc, type, fn, nargs, argarray);\n \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);"}, {"sha": "bdc6088ec0e455e0bae3b4aae3c571811ca2a12f", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=a6a0570f151b9a4fd42dec96182439e53c19241a", "patch": "@@ -4744,14 +4744,13 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree),\n \t\t\t\t\t\t       TREE_OPERAND (fn, 0)))\n \t  {\n \t    tree *args = XALLOCAVEC (tree, gimple_call_num_args (stmt));\n-\t    tree call, retval;\n+\t    tree retval;\n \t    unsigned i;\n \t    for (i = 0; i < gimple_call_num_args (stmt); ++i)\n \t      args[i] = (*valueize) (gimple_call_arg (stmt, i));\n-\t    call = build_call_array_loc (loc,\n+\t    retval = fold_builtin_call_array (loc,\n \t\t\t\t\t gimple_call_return_type (call_stmt),\n \t\t\t\t\t fn, gimple_call_num_args (stmt), args);\n-\t    retval = fold_call_expr (EXPR_LOCATION (call), call, false);\n \t    if (retval)\n \t      {\n \t\t/* fold_call_expr wraps the result inside a NOP_EXPR.  */"}, {"sha": "3a857c0073442ed2d52d47de331980479ed77dcb", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a0570f151b9a4fd42dec96182439e53c19241a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a6a0570f151b9a4fd42dec96182439e53c19241a", "patch": "@@ -10591,7 +10591,7 @@ build_call_expr_loc_array (location_t loc, tree fndecl, int n, tree *argarray)\n   tree fntype = TREE_TYPE (fndecl);\n   tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n  \n-  return fold_builtin_call_array (loc, TREE_TYPE (fntype), fn, n, argarray);\n+  return fold_build_call_array_loc (loc, TREE_TYPE (fntype), fn, n, argarray);\n }\n \n /* Conveniently construct a function call expression.  FNDECL names the"}]}