{"sha": "ad19c4be9ab0c334aa539e3785380108a7bf5953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQxOWM0YmU5YWIwYzMzNGFhNTM5ZTM3ODUzODAxMDhhN2JmNTk1Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-04-15T08:48:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-04-15T08:48:15Z"}, "message": "gimplify.c: Fix issues in comments throughout.\n\n\t* gimplify.c: Fix issues in comments throughout.\n\t(voidify_wrapper_expr): Fix long line.\n\t(build_stack_save_restore): Likewise.\n\t(gimplify_loop_expr): Likewise.\n\t(gimplify_compound_lval): Likewise.\n\t(gimplify_init_ctor_eval): Likewise.\n\t(gimplify_modify_expr_rhs): Likewise.\n\t(omp_notice_threadprivate_variable): Likewise.\n\nFrom-SVN: r172476", "tree": {"sha": "c3275b7563f2dde4cec8f6aeae56ed3fec7ac39c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3275b7563f2dde4cec8f6aeae56ed3fec7ac39c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad19c4be9ab0c334aa539e3785380108a7bf5953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad19c4be9ab0c334aa539e3785380108a7bf5953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad19c4be9ab0c334aa539e3785380108a7bf5953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad19c4be9ab0c334aa539e3785380108a7bf5953/comments", "author": null, "committer": null, "parents": [{"sha": "b25aa0e83fa9918bf5a95d28487fabe3c37f40f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25aa0e83fa9918bf5a95d28487fabe3c37f40f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25aa0e83fa9918bf5a95d28487fabe3c37f40f6"}], "stats": {"total": 155, "additions": 80, "deletions": 75}, "files": [{"sha": "404387792ca0d28c10fc59d898c67463e51b455c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad19c4be9ab0c334aa539e3785380108a7bf5953/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad19c4be9ab0c334aa539e3785380108a7bf5953/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad19c4be9ab0c334aa539e3785380108a7bf5953", "patch": "@@ -1,3 +1,14 @@\n+2011-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimplify.c: Fix issues in comments throughout.\n+\t(voidify_wrapper_expr): Fix long line.\n+\t(build_stack_save_restore): Likewise.\n+\t(gimplify_loop_expr): Likewise.\n+\t(gimplify_compound_lval): Likewise.\n+\t(gimplify_init_ctor_eval): Likewise.\n+\t(gimplify_modify_expr_rhs): Likewise.\n+\t(omp_notice_threadprivate_variable): Likewise.\n+\n 2011-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cfgexpand.c (expand_call_stmt): Convert the function type to the"}, {"sha": "34bdabfa650d5b183210412b10141308fdf7d908", "filename": "gcc/gimplify.c", "status": "modified", "additions": 69, "deletions": 75, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad19c4be9ab0c334aa539e3785380108a7bf5953/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad19c4be9ab0c334aa539e3785380108a7bf5953/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ad19c4be9ab0c334aa539e3785380108a7bf5953", "patch": "@@ -91,7 +91,7 @@ static struct gimplify_ctx *gimplify_ctxp;\n static struct gimplify_omp_ctx *gimplify_omp_ctxp;\n \n \n-/* Formal (expression) temporary table handling: Multiple occurrences of\n+/* Formal (expression) temporary table handling: multiple occurrences of\n    the same scalar expression are evaluated into the same temporary.  */\n \n typedef struct gimple_temp_hash_elt\n@@ -100,11 +100,12 @@ typedef struct gimple_temp_hash_elt\n   tree temp;  /* Value */\n } elt_t;\n \n-/* Forward declarations.  */\n+/* Forward declaration.  */\n static enum gimplify_status gimplify_compound_expr (tree *, gimple_seq *, bool);\n \n /* Mark X addressable.  Unlike the langhook we expect X to be in gimple\n    form and we don't do any syntax checking.  */\n+\n void\n mark_addressable (tree x)\n {\n@@ -232,6 +233,8 @@ pop_gimplify_context (gimple body)\n     htab_delete (c->temp_htab);\n }\n \n+/* Push a GIMPLE_BIND tuple onto the stack of bindings.  */\n+\n static void\n gimple_push_bind_expr (gimple gimple_bind)\n {\n@@ -240,27 +243,31 @@ gimple_push_bind_expr (gimple gimple_bind)\n   VEC_safe_push (gimple, heap, gimplify_ctxp->bind_expr_stack, gimple_bind);\n }\n \n+/* Pop the first element off the stack of bindings.  */\n+\n static void\n gimple_pop_bind_expr (void)\n {\n   VEC_pop (gimple, gimplify_ctxp->bind_expr_stack);\n }\n \n+/* Return the first element of the stack of bindings.  */\n+\n gimple\n gimple_current_bind_expr (void)\n {\n   return VEC_last (gimple, gimplify_ctxp->bind_expr_stack);\n }\n \n-/* Return the stack GIMPLE_BINDs created during gimplification.  */\n+/* Return the stack of bindings created during gimplification.  */\n \n VEC(gimple, heap) *\n gimple_bind_expr_stack (void)\n {\n   return gimplify_ctxp->bind_expr_stack;\n }\n \n-/* Returns true iff there is a COND_EXPR between us and the innermost\n+/* Return true iff there is a COND_EXPR between us and the innermost\n    CLEANUP_POINT_EXPR.  This info is used by gimple_push_cleanup.  */\n \n static bool\n@@ -392,7 +399,7 @@ remove_suffix (char *name, int len)\n     }\n }\n \n-/* Create a new temporary name with PREFIX.  Returns an identifier.  */\n+/* Create a new temporary name with PREFIX.  Return an identifier.  */\n \n static GTY(()) unsigned int tmp_var_id_num;\n \n@@ -413,9 +420,8 @@ create_tmp_var_name (const char *prefix)\n   return get_identifier (tmp_name);\n }\n \n-\n /* Create a new temporary variable declaration of type TYPE.\n-   Does NOT push it into the current binding.  */\n+   Do NOT push it into the current binding.  */\n \n tree\n create_tmp_var_raw (tree type, const char *prefix)\n@@ -446,7 +452,7 @@ create_tmp_var_raw (tree type, const char *prefix)\n   return tmp_var;\n }\n \n-/* Create a new temporary variable declaration of type TYPE.  DOES push the\n+/* Create a new temporary variable declaration of type TYPE.  DO push the\n    variable into the current binding.  Further, assume that this is called\n    only from gimplification or optimization, at which point the creation of\n    certain types are bugs.  */\n@@ -537,7 +543,6 @@ lookup_tmp_var (tree val, bool is_formal)\n   return ret;\n }\n \n-\n /* Return true if T is a CALL_EXPR or an expression that can be\n    assigned to a temporary.  Note that this predicate should only be\n    used during gimplification.  See the rationale for this in\n@@ -605,7 +610,7 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n   return t;\n }\n \n-/* Returns a formal temporary variable initialized with VAL.  PRE_P is as\n+/* Return a formal temporary variable initialized with VAL.  PRE_P is as\n    in gimplify_expr.  Only use this function if:\n \n    1) The value of the unfactored expression represented by VAL will not\n@@ -623,7 +628,7 @@ get_formal_tmp_var (tree val, gimple_seq *pre_p)\n   return internal_get_tmp_var (val, pre_p, NULL, true);\n }\n \n-/* Returns a temporary variable initialized with VAL.  PRE_P and POST_P\n+/* Return a temporary variable initialized with VAL.  PRE_P and POST_P\n    are as in gimplify_expr.  */\n \n tree\n@@ -632,8 +637,8 @@ get_initialized_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p)\n   return internal_get_tmp_var (val, pre_p, post_p, false);\n }\n \n-/* Declares all the variables in VARS in SCOPE.  If DEBUG_INFO is\n-   true, generate debug info for them; otherwise don't.  */\n+/* Declare all the variables in VARS in SCOPE.  If DEBUG_INFO is true,\n+   generate debug info for them; otherwise don't.  */\n \n void\n declare_vars (tree vars, gimple scope, bool debug_info)\n@@ -696,6 +701,8 @@ force_constant_size (tree var)\n     = build_int_cst (TREE_TYPE (DECL_SIZE (var)), max_size * BITS_PER_UNIT);\n }\n \n+/* Push the temporary variable TMP into the current binding.  */\n+\n void\n gimple_add_tmp_var (tree tmp)\n {\n@@ -738,7 +745,7 @@ gimple_add_tmp_var (tree tmp)\n     }\n }\n \n-/* Determines whether to assign a location to the statement GS.  */\n+/* Determine whether to assign a location to the statement GS.  */\n \n static bool\n should_carry_location_p (gimple gs)\n@@ -752,7 +759,6 @@ should_carry_location_p (gimple gs)\n   return true;\n }\n \n-\n /* Return true if a location should not be emitted for this statement\n    by annotate_one_with_location.  */\n \n@@ -784,7 +790,6 @@ annotate_one_with_location (gimple gs, location_t location)\n     gimple_set_location (gs, location);\n }\n \n-\n /* Set LOCATION for all the statements after iterator GSI in sequence\n    SEQ.  If GSI is pointing to the end of the sequence, start with the\n    first statement in SEQ.  */\n@@ -802,7 +807,6 @@ annotate_all_with_location_after (gimple_seq seq, gimple_stmt_iterator gsi,\n     annotate_one_with_location (gsi_stmt (gsi), location);\n }\n \n-\n /* Set the location for all the statements in a sequence STMT_P to LOCATION.  */\n \n void\n@@ -1022,7 +1026,7 @@ unshare_expr (tree expr)\n \f\n /* WRAPPER is a code such as BIND_EXPR or CLEANUP_POINT_EXPR which can both\n    contain statements and have a value.  Assign its value to a temporary\n-   and give it void_type_node.  Returns the temporary, or NULL_TREE if\n+   and give it void_type_node.  Return the temporary, or NULL_TREE if\n    WRAPPER was already void.  */\n \n tree\n@@ -1064,7 +1068,8 @@ voidify_wrapper_expr (tree wrapper, tree temp)\n \t      break;\n \n \t    case COMPOUND_EXPR:\n-\t      /* Advance to the last statement.  Set all container types to void.  */\n+\t      /* Advance to the last statement.  Set all container types to\n+\t\t void.  */\n \t      for (; TREE_CODE (*p) == COMPOUND_EXPR; p = &TREE_OPERAND (*p, 1))\n \t\t{\n \t\t  TREE_SIDE_EFFECTS (*p) = 1;\n@@ -1113,8 +1118,9 @@ build_stack_save_restore (gimple *save, gimple *restore)\n   tmp_var = create_tmp_var (ptr_type_node, \"saved_stack\");\n   gimple_call_set_lhs (*save, tmp_var);\n \n-  *restore = gimple_build_call (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n-\t\t\t    1, tmp_var);\n+  *restore\n+    = gimple_build_call (implicit_built_in_decls[BUILT_IN_STACK_RESTORE],\n+\t\t\t 1, tmp_var);\n }\n \n /* Gimplify a BIND_EXPR.  Just voidify and recurse.  */\n@@ -1302,6 +1308,8 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Gimplify a variable-length array DECL.  */\n+\n static void\n gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n {\n@@ -1340,8 +1348,7 @@ gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n   gimplify_ctxp->save_stack = true;\n }\n \n-\n-/* Gimplifies a DECL_EXPR node *STMT_P by making any necessary allocation\n+/* Gimplify a DECL_EXPR node *STMT_P by making any necessary allocation\n    and initialization explicit.  */\n \n static enum gimplify_status\n@@ -1417,15 +1424,16 @@ gimplify_loop_expr (tree *expr_p, gimple_seq *pre_p)\n   gimplify_seq_add_stmt (pre_p, gimple_build_goto (start_label));\n \n   if (gimplify_ctxp->exit_label)\n-    gimplify_seq_add_stmt (pre_p, gimple_build_label (gimplify_ctxp->exit_label));\n+    gimplify_seq_add_stmt (pre_p,\n+\t\t\t   gimple_build_label (gimplify_ctxp->exit_label));\n \n   gimplify_ctxp->exit_label = saved_label;\n \n   *expr_p = NULL;\n   return GS_ALL_DONE;\n }\n \n-/* Gimplifies a statement list onto a sequence.  These may be created either\n+/* Gimplify a statement list onto a sequence.  These may be created either\n    by an enlightened front-end, or by shortcut_cond_expr.  */\n \n static enum gimplify_status\n@@ -1469,7 +1477,6 @@ compare_case_labels (const void *p1, const void *p2)\n     return tree_int_cst_compare (CASE_LOW (case1), CASE_LOW (case2));\n }\n \n-\n /* Sort the case labels in LABEL_VEC in place in ascending order.  */\n \n void\n@@ -1478,7 +1485,6 @@ sort_case_labels (VEC(tree,heap)* label_vec)\n   VEC_qsort (tree, label_vec, compare_case_labels);\n }\n \n-\n /* Gimplify a SWITCH_EXPR, and collect a TREE_VEC of the labels it can\n    branch to.  */\n \n@@ -1615,6 +1621,7 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Gimplify the CASE_LABEL_EXPR pointed to by EXPR_P.  */\n \n static enum gimplify_status\n gimplify_case_label_expr (tree *expr_p, gimple_seq *pre_p)\n@@ -1849,7 +1856,7 @@ gimplify_conversion (tree *expr_p)\n /* Nonlocal VLAs seen in the current function.  */\n static struct pointer_set_t *nonlocal_vlas;\n \n-/* Gimplify a VAR_DECL or PARM_DECL.  Returns GS_OK if we expanded a\n+/* Gimplify a VAR_DECL or PARM_DECL.  Return GS_OK if we expanded a\n    DECL_VALUE_EXPR, and it's worth re-examining things.  */\n \n static enum gimplify_status\n@@ -1915,7 +1922,6 @@ gimplify_var_or_parm_decl (tree *expr_p)\n   return GS_ALL_DONE;\n }\n \n-\n /* Gimplify the COMPONENT_REF, ARRAY_REF, REALPART_EXPR or IMAGPART_EXPR\n    node *EXPR_P.\n \n@@ -2018,7 +2024,8 @@ gimplify_compound_lval (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \t      /* Divide the element size by the alignment of the element\n \t\t type (above).  */\n-\t      elmt_size = size_binop_loc (loc, EXACT_DIV_EXPR, elmt_size, factor);\n+\t      elmt_size\n+\t\t= size_binop_loc (loc, EXACT_DIV_EXPR, elmt_size, factor);\n \n \t      if (!is_gimple_min_invariant (elmt_size))\n \t\t{\n@@ -2210,7 +2217,6 @@ gimplify_self_mod_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     }\n }\n \n-\n /* If *EXPR_P has a variable sized type, wrap it in a WITH_SIZE_EXPR.  */\n \n static void\n@@ -2237,7 +2243,6 @@ maybe_with_size_expr (tree *expr_p)\n   *expr_p = build2 (WITH_SIZE_EXPR, type, expr, size);\n }\n \n-\n /* Helper for gimplify_call_expr.  Gimplify a single argument *ARG_P\n    Store any side-effects in PRE_P.  CALL_LOCATION is the location of\n    the CALL_EXPR.  */\n@@ -2283,7 +2288,6 @@ gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location)\n   return gimplify_expr (arg_p, pre_p, NULL, test, fb);\n }\n \n-\n /* Gimplify the CALL_EXPR node *EXPR_P into the GIMPLE sequence PRE_P.\n    WANT_VALUE is true if the result of the call is desired.  */\n \n@@ -2887,7 +2891,7 @@ gimplify_pure_cond_expr (tree *expr_p, gimple_seq *pre_p)\n   return MIN (ret, tret);\n }\n \n-/* Returns true if evaluating EXPR could trap.\n+/* Return true if evaluating EXPR could trap.\n    EXPR is GENERIC, while tree_could_trap_p can be called\n    only on GIMPLE.  */\n \n@@ -3265,7 +3269,7 @@ gimplify_modify_expr_to_memset (tree *expr_p, tree size, bool want_value,\n \n /* A subroutine of gimplify_init_ctor_preeval.  Called via walk_tree,\n    determine, cautiously, if a CONSTRUCTOR overlaps the lhs of an\n-   assignment.  Returns non-null if we detect a potential overlap.  */\n+   assignment.  Return non-null if we detect a potential overlap.  */\n \n struct gimplify_init_ctor_preeval_data\n {\n@@ -3551,8 +3555,9 @@ gimplify_init_ctor_eval (tree object, VEC(constructor_elt,gc) *elts,\n \t{\n \t  /* Do not use bitsizetype for ARRAY_REF indices.  */\n \t  if (TYPE_DOMAIN (TREE_TYPE (object)))\n-\t    purpose = fold_convert (TREE_TYPE (TYPE_DOMAIN (TREE_TYPE (object))),\n-\t\t\t\t    purpose);\n+\t    purpose\n+\t      = fold_convert (TREE_TYPE (TYPE_DOMAIN (TREE_TYPE (object))),\n+\t\t\t      purpose);\n \t  cref = build4 (ARRAY_REF, array_elt_type, unshare_expr (object),\n \t\t\t purpose, NULL_TREE, NULL_TREE);\n \t}\n@@ -3576,8 +3581,7 @@ gimplify_init_ctor_eval (tree object, VEC(constructor_elt,gc) *elts,\n     }\n }\n \n-\n-/* Returns the appropriate RHS predicate for this LHS.  */\n+/* Return the appropriate RHS predicate for this LHS.  */\n \n gimple_predicate\n rhs_predicate_for (tree lhs)\n@@ -3664,8 +3668,6 @@ optimize_compound_literals_in_ctor (tree orig_ctor)\n   return ctor;\n }\n \n-\n-\n /* A subroutine of gimplify_modify_expr.  Break out elements of a\n    CONSTRUCTOR used as an initializer into separate MODIFY_EXPRs.\n \n@@ -4329,10 +4331,10 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \t      if (!(rhs_predicate_for (*to_p))(*from_p))\n \t\t/* If we need a temporary, *to_p isn't accurate.  */\n \t\tuse_target = false;\n+\t      /* It's OK to use the return slot directly unless it's an NRV. */\n \t      else if (TREE_CODE (*to_p) == RESULT_DECL\n \t\t       && DECL_NAME (*to_p) == NULL_TREE\n \t\t       && needs_to_live_in_memory (*to_p))\n-\t\t/* It's OK to use the return slot directly unless it's an NRV. */\n \t\tuse_target = true;\n \t      else if (is_gimple_reg_type (TREE_TYPE (*to_p))\n \t\t       || (DECL_P (*to_p) && DECL_REGISTER (*to_p)))\n@@ -4431,7 +4433,6 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n   return ret;\n }\n \n-\n /* Promote partial stores to COMPLEX variables to total stores.  *EXPR_P is\n    a MODIFY_EXPR with a lhs of a REAL/IMAGPART_EXPR of a variable with\n    DECL_GIMPLE_REG_P set.\n@@ -4474,7 +4475,6 @@ gimplify_modify_expr_complex_part (tree *expr_p, gimple_seq *pre_p,\n   return GS_ALL_DONE;\n }\n \n-\n /* Gimplify the MODIFY_EXPR node pointed to by EXPR_P.\n \n       modify_expr\n@@ -4651,8 +4651,8 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   return GS_ALL_DONE;\n }\n \n-/*  Gimplify a comparison between two variable-sized objects.  Do this\n-    with a call to BUILT_IN_MEMCMP.  */\n+/* Gimplify a comparison between two variable-sized objects.  Do this\n+   with a call to BUILT_IN_MEMCMP.  */\n \n static enum gimplify_status\n gimplify_variable_sized_compare (tree *expr_p)\n@@ -4678,8 +4678,8 @@ gimplify_variable_sized_compare (tree *expr_p)\n   return GS_OK;\n }\n \n-/*  Gimplify a comparison between two aggregate objects of integral scalar\n-    mode as a comparison between the bitwise equivalent scalar values.  */\n+/* Gimplify a comparison between two aggregate objects of integral scalar\n+   mode as a comparison between the bitwise equivalent scalar values.  */\n \n static enum gimplify_status\n gimplify_scalar_mode_aggregate_compare (tree *expr_p)\n@@ -4700,15 +4700,15 @@ gimplify_scalar_mode_aggregate_compare (tree *expr_p)\n   return GS_OK;\n }\n \n-/*  Gimplify TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR expressions.  EXPR_P\n-    points to the expression to gimplify.\n+/* Gimplify TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR expressions.  EXPR_P\n+   points to the expression to gimplify.\n \n-    Expressions of the form 'a && b' are gimplified to:\n+   Expressions of the form 'a && b' are gimplified to:\n \n \ta && b ? true : false\n \n-    LOCUS is the source location to be put on the generated COND_EXPR.\n-    gimplify_cond_expr will do the rest.  */\n+   LOCUS is the source location to be put on the generated COND_EXPR.\n+   gimplify_cond_expr will do the rest.  */\n \n static enum gimplify_status\n gimplify_boolean_expr (tree *expr_p, location_t locus)\n@@ -4725,8 +4725,8 @@ gimplify_boolean_expr (tree *expr_p, location_t locus)\n   return GS_OK;\n }\n \n-/* Gimplifies an expression sequence.  This function gimplifies each\n-   expression and re-writes the original expression with the last\n+/* Gimplify an expression sequence.  This function gimplifies each\n+   expression and rewrites the original expression with the last\n    expression of the sequence in GIMPLE form.\n \n    PRE_P points to the list where the side effects for all the\n@@ -4762,13 +4762,12 @@ gimplify_compound_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n     }\n }\n \n-\n /* Gimplify a SAVE_EXPR node.  EXPR_P points to the expression to\n    gimplify.  After gimplification, EXPR_P will point to a new temporary\n    that holds the original value of the SAVE_EXPR node.\n \n    PRE_P points to the list where side effects that must happen before\n-      *EXPR_P should be stored.  */\n+   *EXPR_P should be stored.  */\n \n static enum gimplify_status\n gimplify_save_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n@@ -4803,7 +4802,7 @@ gimplify_save_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   return ret;\n }\n \n-/*  Re-write the ADDR_EXPR node pointed to by EXPR_P\n+/* Rewrite the ADDR_EXPR node pointed to by EXPR_P\n \n       unary_expr\n \t      : ...\n@@ -5380,7 +5379,6 @@ gimplify_stmt (tree *stmt_p, gimple_seq *seq_p)\n   return last != gimple_seq_last (*seq_p);\n }\n \n-\n /* Add FIRSTPRIVATE entries for DECL in the OpenMP the surrounding parallels\n    to CTX.  If entries already exist, force them to be some flavor of private.\n    If there is no enclosing parallel, do nothing.  */\n@@ -5578,7 +5576,8 @@ omp_notice_threadprivate_variable (struct gimplify_omp_ctx *ctx, tree decl,\n   n = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n   if (n == NULL)\n     {\n-      error (\"threadprivate variable %qE used in untied task\", DECL_NAME (decl));\n+      error (\"threadprivate variable %qE used in untied task\",\n+\t     DECL_NAME (decl));\n       error_at (ctx->location, \"enclosing task\");\n       splay_tree_insert (ctx->variables, (splay_tree_key)decl, 0);\n     }\n@@ -6415,10 +6414,10 @@ goa_lhs_expr_p (tree expr, tree addr)\n   return false;\n }\n \n-/* Walk *EXPR_P and replace\n-   appearances of *LHS_ADDR with LHS_VAR.  If an expression does not involve\n-   the lhs, evaluate it into a temporary.  Return 1 if the lhs appeared as\n-   a subexpression, 0 if it did not, or -1 if an error was encountered.  */\n+/* Walk *EXPR_P and replace appearances of *LHS_ADDR with LHS_VAR.  If an\n+   expression does not involve the lhs, evaluate it into a temporary.\n+   Return 1 if the lhs appeared as a subexpression, 0 if it did not,\n+   or -1 if an error was encountered.  */\n \n static int\n goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n@@ -6479,7 +6478,6 @@ goa_stabilize_expr (tree *expr_p, gimple_seq *pre_p, tree lhs_addr,\n   return saw_lhs;\n }\n \n-\n /* Gimplify an OMP_ATOMIC statement.  */\n \n static enum gimplify_status\n@@ -6508,8 +6506,7 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n    return GS_ALL_DONE;\n }\n \n-\n-/* Converts the GENERIC expression tree *EXPR_P to GIMPLE.  If the\n+/* Convert the GENERIC expression tree *EXPR_P to GIMPLE.  If the\n    expression produces a value to be used as an operand inside a GIMPLE\n    statement, the value will be stored back in *EXPR_P.  This value will\n    be a tree of class tcc_declaration, tcc_constant, tcc_reference or\n@@ -7695,7 +7692,6 @@ gimplify_one_sizepos (tree *expr_p, gimple_seq *stmt_p)\n     }\n }\n \n-\n /* Gimplify the body of statements pointed to by BODY_P and return a\n    GIMPLE_BIND containing the sequence of GIMPLE statements\n    corresponding to BODY_P.  FNDECL is the function decl containing\n@@ -7836,7 +7832,7 @@ flag_instrument_functions_exclude_p (tree fndecl)\n /* Entry point to the gimplification pass.  FNDECL is the FUNCTION_DECL\n    node for the function we want to gimplify.\n \n-   Returns the sequence of GIMPLE statements corresponding to the body\n+   Return the sequence of GIMPLE statements corresponding to the body\n    of FNDECL.  */\n \n void\n@@ -7938,7 +7934,6 @@ gimplify_function_tree (tree fndecl)\n   pop_cfun ();\n }\n \n-\n /* Some transformations like inlining may invalidate the GIMPLE form\n    for operands.  This function traverses all the operands in STMT and\n    gimplifies anything that is not a valid gimple operand.  Any new\n@@ -8128,8 +8123,7 @@ gimple_regimplify_operands (gimple stmt, gimple_stmt_iterator *gsi_p)\n   pop_gimplify_context (NULL);\n }\n \n-\n-/* Expands EXPR to list of gimple statements STMTS.  GIMPLE_TEST_F specifies\n+/* Expand EXPR to list of gimple statements STMTS.  GIMPLE_TEST_F specifies\n    the predicate that will hold for the result.  If VAR is not NULL, make the\n    base variable of the final destination be VAR if suitable.  */\n \n@@ -8178,7 +8172,7 @@ force_gimple_operand_1 (tree expr, gimple_seq *stmts,\n   return expr;\n }\n \n-/* Expands EXPR to list of gimple statements STMTS.  If SIMPLE is true,\n+/* Expand EXPR to list of gimple statements STMTS.  If SIMPLE is true,\n    force the result to be either ssa_name or an invariant, otherwise\n    just force it to be a rhs expression.  If VAR is not NULL, make the\n    base variable of the final destination be VAR if suitable.  */\n@@ -8191,7 +8185,7 @@ force_gimple_operand (tree expr, gimple_seq *stmts, bool simple, tree var)\n \t\t\t\t var);\n }\n \n-/* Invokes force_gimple_operand_1 for EXPR with parameters GIMPLE_TEST_F\n+/* Invoke force_gimple_operand_1 for EXPR with parameters GIMPLE_TEST_F\n    and VAR.  If some statements are produced, emits them at GSI.\n    If BEFORE is true.  the statements are appended before GSI, otherwise\n    they are appended after it.  M specifies the way GSI moves after\n@@ -8226,7 +8220,7 @@ force_gimple_operand_gsi_1 (gimple_stmt_iterator *gsi, tree expr,\n   return expr;\n }\n \n-/* Invokes force_gimple_operand_1 for EXPR with parameter VAR.\n+/* Invoke force_gimple_operand_1 for EXPR with parameter VAR.\n    If SIMPLE is true, force the result to be either ssa_name or an invariant,\n    otherwise just force it to be a rhs expression.  If some statements are\n    produced, emits them at GSI.  If BEFORE is true, the statements are"}]}