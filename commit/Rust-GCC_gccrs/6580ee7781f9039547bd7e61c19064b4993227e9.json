{"sha": "6580ee7781f9039547bd7e61c19064b4993227e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU4MGVlNzc4MWY5MDM5NTQ3YmQ3ZTYxYzE5MDY0YjQ5OTMyMjdlOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-15T23:05:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-15T23:05:23Z"}, "message": "Makefile.in (cfg.o): Add new dependencies.\n\n\n\t* Makefile.in (cfg.o): Add new dependencies.\n\t* basic-block.h (reorder_block_def): Kill\n\toriginal/copy/duplicated/copy_number fields.\n\t(BB_DUPLICATED): New flag.\n\t(initialize_original_copy_tables, free_original_copy_tables,\n\tset_bb_original, get_bb_original, set_bb_copy, get_bb_copy): New.\n\t* cfg.c: Include hashtab.h and alloc-pool.h\n\t(bb_original, bb_copy, original_copy_bb_pool): New static vars.\n\t(htab_bb_copy_original_entry): New struct.\n\t(bb_copy_original_hash, bb_copy_original_eq): New static functions.\n\t(initialize_original_copy_tables, free_original_copy_tables,\n\tset_bb_original, get_bb_original, set_bb_copy, get_bb_copy): New\n\tglobal functions.\n\t* cfghooks.c (duplicate_block): Update original/copy handling.\n\t* cfglayout.c (fixup_reorder_chain): Likewise.\n\t(cfg_layout_initialize): Initialize orignal_copy tables.\n\t(cfg_layout_finalize): FInalize original_copy tables.\n\t(can_copy_bbs_p): Use BB_DUPLICATED flag.\n\t(copy_bbs): Likewise.\n\t* cfgloopmanip.c (update-single_exits_after_duplication): Likewise.\n\t(duplicate_loop_to_header_edge): Likewise; update handling of\n\tcopy_number.\n\t(loop_version): Likewise.\n\t* dominance.c (get_dominated_by_region): Use BB_DUPLICATED_FLAG.\n\t* except.c (expand_resx_expr): Check that reg->resume is not set.\n\t* loop-unroll.c (unroll_loop_constant_iterations,\n\tunroll_loop_runtime_iterations, apply_opt_in_copies): Update\n\tcopy/original handling.\n\t* loop-unwitch.c (unswitch_loop): Likewise.\n\t* tree-cfg.c (create_bb): Do not initialize RBI.\n\t(disband_implicit_edges): Do not kill RBI.\n\t(add_phi_args_after_copy_bb): Use new original/copy mapping.\n\t(add_phi_args_after_copy): Use BB_DUPLICATED flag.\n\t(tree_duplicate_sese_region): Update original/copy handling.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Likewise.\n\t* tree-ssa-loop-manip.c (copy_phi_node_args): Likewise.\n\t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Likewise.\n\nFrom-SVN: r101000", "tree": {"sha": "1d0023517e2f2d1588dbafdad22f8ee98e9d9ce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d0023517e2f2d1588dbafdad22f8ee98e9d9ce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6580ee7781f9039547bd7e61c19064b4993227e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6580ee7781f9039547bd7e61c19064b4993227e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6580ee7781f9039547bd7e61c19064b4993227e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6580ee7781f9039547bd7e61c19064b4993227e9/comments", "author": null, "committer": null, "parents": [{"sha": "f652253b03b53794e5f2544ff1a05967a2070a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f652253b03b53794e5f2544ff1a05967a2070a56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f652253b03b53794e5f2544ff1a05967a2070a56"}], "stats": {"total": 329, "additions": 263, "deletions": 66}, "files": [{"sha": "82fb8a6ca94ed1cade4035df25b65529436a5d10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -1,3 +1,43 @@\n+2005-06-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (cfg.o): Add new dependencies.\n+\t* basic-block.h (reorder_block_def): Kill\n+\toriginal/copy/duplicated/copy_number fields.\n+\t(BB_DUPLICATED): New flag.\n+\t(initialize_original_copy_tables, free_original_copy_tables,\n+\tset_bb_original, get_bb_original, set_bb_copy, get_bb_copy): New.\n+\t* cfg.c: Include hashtab.h and alloc-pool.h\n+\t(bb_original, bb_copy, original_copy_bb_pool): New static vars.\n+\t(htab_bb_copy_original_entry): New struct.\n+\t(bb_copy_original_hash, bb_copy_original_eq): New static functions.\n+\t(initialize_original_copy_tables, free_original_copy_tables,\n+\tset_bb_original, get_bb_original, set_bb_copy, get_bb_copy): New\n+\tglobal functions.\n+\t* cfghooks.c (duplicate_block): Update original/copy handling.\n+\t* cfglayout.c (fixup_reorder_chain): Likewise.\n+\t(cfg_layout_initialize): Initialize orignal_copy tables.\n+\t(cfg_layout_finalize): FInalize original_copy tables.\n+\t(can_copy_bbs_p): Use BB_DUPLICATED flag.\n+\t(copy_bbs): Likewise.\n+\t* cfgloopmanip.c (update-single_exits_after_duplication): Likewise.\n+\t(duplicate_loop_to_header_edge): Likewise; update handling of\n+\tcopy_number.\n+\t(loop_version): Likewise.\n+\t* dominance.c (get_dominated_by_region): Use BB_DUPLICATED_FLAG.\n+\t* except.c (expand_resx_expr): Check that reg->resume is not set.\n+\t* loop-unroll.c (unroll_loop_constant_iterations,\n+\tunroll_loop_runtime_iterations, apply_opt_in_copies): Update\n+\tcopy/original handling.\n+\t* loop-unwitch.c (unswitch_loop): Likewise.\n+\t* tree-cfg.c (create_bb): Do not initialize RBI.\n+\t(disband_implicit_edges): Do not kill RBI.\n+\t(add_phi_args_after_copy_bb): Use new original/copy mapping.\n+\t(add_phi_args_after_copy): Use BB_DUPLICATED flag.\n+\t(tree_duplicate_sese_region): Update original/copy handling.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Likewise.\n+\t* tree-ssa-loop-manip.c (copy_phi_node_args): Likewise.\n+\t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Likewise.\n+\n 2005-06-15  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/21923"}, {"sha": "b54ddf36f608e558cc0266c0b6363eb6f18f8af8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -2180,7 +2180,7 @@ flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(EXPR_H) $(TM_P_H) $(OBSTACK_H) $(SPLAY_TREE_H) $(TIMEVAR_H)\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    $(REGS_H) hard-reg-set.h output.h toplev.h function.h except.h $(GGC_H) \\\n-   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H)\n+   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h $(HASHTAB_H)\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\"}, {"sha": "d9244d271fd38ae7e22a758e6a8baf1d7b5584ab", "filename": "gcc/basic-block.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -279,16 +279,6 @@ struct reorder_block_def GTY(())\n \n   basic_block next;\n \n-  /* These pointers may be unreliable as the first is only used for\n-     debugging (and should probably be removed, and the second is only\n-     used by copying.  The basic blocks pointed to may be removed and\n-     that leaves these pointers pointing to garbage.  */\n-  basic_block GTY ((skip (\"\"))) original;\n-  basic_block GTY ((skip (\"\"))) copy;\n-\n-  int duplicated;\n-  int copy_number;\n-\n   /* This field is used by the bb-reorder and tracer passes.  */\n   int visited;\n };\n@@ -332,7 +322,10 @@ enum\n   BB_HOT_PARTITION = 64,\n \n   /* Set on blocks that should be put in a cold section.  */\n-  BB_COLD_PARTITION = 128\n+  BB_COLD_PARTITION = 128,\n+\n+  /* Set on block that was duplicated.  */\n+  BB_DUPLICATED = 256\n };\n \n /* Dummy flag for convenience in the hot/cold partitioning code.  */\n@@ -984,6 +977,13 @@ extern void break_superblocks (void);\n extern void check_bb_profile (basic_block, FILE *);\n extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n \n+extern void initialize_original_copy_tables (void);\n+extern void free_original_copy_tables (void);\n+extern void set_bb_original (basic_block, basic_block);\n+extern basic_block get_bb_original (basic_block);\n+extern void set_bb_copy (basic_block, basic_block);\n+extern basic_block get_bb_copy (basic_block);\n+\n #include \"cfghooks.h\"\n \n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "f33a95061a0673475369c630ab2ebcd5fc3be7ad", "filename": "gcc/cfg.c", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -63,6 +63,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"obstack.h\"\n #include \"timevar.h\"\n #include \"ggc.h\"\n+#include \"hashtab.h\"\n+#include \"alloc-pool.h\"\n \n /* The obstack on which the flow graph components are allocated.  */\n \n@@ -940,3 +942,145 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n \te->count = (e->count * num) /den;\n     }\n }\n+\n+/* Datastructures used to maintain mapping between basic blocks and copies.  */\n+static htab_t bb_original;\n+static htab_t bb_copy;\n+static alloc_pool original_copy_bb_pool;\n+\n+struct htab_bb_copy_original_entry\n+{\n+  /* Block we are attaching info to.  */\n+  int index1;\n+  /* Index of original or copy (depending on the hashtable) */\n+  int index2;\n+};\n+\n+static hashval_t\n+bb_copy_original_hash (const void *p)\n+{\n+  struct htab_bb_copy_original_entry *data\n+    = ((struct htab_bb_copy_original_entry *)p);\n+\n+  return data->index1;\n+}\n+static int\n+bb_copy_original_eq (const void *p, const void *q)\n+{\n+  struct htab_bb_copy_original_entry *data\n+    = ((struct htab_bb_copy_original_entry *)p);\n+  struct htab_bb_copy_original_entry *data2\n+    = ((struct htab_bb_copy_original_entry *)q);\n+\n+  return data->index1 == data2->index1;\n+}\n+\n+/* Initialize the datstructures to maintain mapping between blocks and it's copies.  */\n+void\n+initialize_original_copy_tables (void)\n+{\n+  gcc_assert (!original_copy_bb_pool);\n+  original_copy_bb_pool\n+    = create_alloc_pool (\"original_copy\",\n+\t\t\t sizeof (struct htab_bb_copy_original_entry), 10);\n+  bb_original = htab_create (10, bb_copy_original_hash,\n+\t\t\t     bb_copy_original_eq, NULL);\n+  bb_copy = htab_create (10, bb_copy_original_hash, bb_copy_original_eq, NULL);\n+}\n+\n+/* Free the datstructures to maintain mapping between blocks and it's copies.  */\n+void\n+free_original_copy_tables (void)\n+{\n+  gcc_assert (original_copy_bb_pool);\n+  htab_delete (bb_copy);\n+  htab_delete (bb_original);\n+  free_alloc_pool (original_copy_bb_pool);\n+  bb_copy = NULL;\n+  bb_original = NULL;\n+  original_copy_bb_pool = NULL;\n+}\n+\n+/* Set original for basic block.  Do nothing when datstructures are not\n+   intialized so passes not needing this don't need to care.  */\n+void\n+set_bb_original (basic_block bb, basic_block original)\n+{\n+  if (original_copy_bb_pool)\n+    {\n+      struct htab_bb_copy_original_entry **slot;\n+      struct htab_bb_copy_original_entry key;\n+\n+      key.index1 = bb->index;\n+      slot =\n+\t(struct htab_bb_copy_original_entry **) htab_find_slot (bb_original,\n+\t\t\t\t\t\t\t       &key, INSERT);\n+      if (*slot)\n+\t(*slot)->index2 = original->index;\n+      else\n+\t{\n+\t  *slot = pool_alloc (original_copy_bb_pool);\n+\t  (*slot)->index1 = bb->index;\n+\t  (*slot)->index2 = original->index;\n+\t}\n+    }\n+}\n+\n+/* Get the original basic block.  */\n+basic_block\n+get_bb_original (basic_block bb)\n+{\n+  struct htab_bb_copy_original_entry *entry;\n+  struct htab_bb_copy_original_entry key;\n+\n+  gcc_assert (original_copy_bb_pool);\n+\n+  key.index1 = bb->index;\n+  entry = (struct htab_bb_copy_original_entry *) htab_find (bb_original, &key);\n+  if (entry)\n+    return BASIC_BLOCK (entry->index2);\n+  else\n+    return NULL;\n+}\n+\n+/* Set copy for basic block.  Do nothing when datstructures are not\n+   intialized so passes not needing this don't need to care.  */\n+void\n+set_bb_copy (basic_block bb, basic_block copy)\n+{\n+  if (original_copy_bb_pool)\n+    {\n+      struct htab_bb_copy_original_entry **slot;\n+      struct htab_bb_copy_original_entry key;\n+\n+      key.index1 = bb->index;\n+      slot =\n+\t(struct htab_bb_copy_original_entry **) htab_find_slot (bb_copy,\n+\t\t\t\t\t\t\t       &key, INSERT);\n+      if (*slot)\n+\t(*slot)->index2 = copy->index;\n+      else\n+\t{\n+\t  *slot = pool_alloc (original_copy_bb_pool);\n+\t  (*slot)->index1 = bb->index;\n+\t  (*slot)->index2 = copy->index;\n+\t}\n+    }\n+}\n+\n+/* Get the copy of basic block.  */\n+basic_block\n+get_bb_copy (basic_block bb)\n+{\n+  struct htab_bb_copy_original_entry *entry;\n+  struct htab_bb_copy_original_entry key;\n+\n+  gcc_assert (original_copy_bb_pool);\n+\n+  key.index1 = bb->index;\n+  entry = (struct htab_bb_copy_original_entry *) htab_find (bb_copy, &key);\n+  if (entry)\n+    return BASIC_BLOCK (entry->index2);\n+  else\n+    return NULL;\n+}"}, {"sha": "2af7c0612cbd19a86cc33ede78b6b5cf20181940", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -756,8 +756,8 @@ duplicate_block (basic_block bb, edge e)\n       new_bb->frequency = bb->frequency;\n     }\n \n-  new_bb->rbi->original = bb;\n-  bb->rbi->copy = new_bb;\n+  set_bb_original (new_bb, bb);\n+  set_bb_copy (bb, new_bb);\n \n   return new_bb;\n }"}, {"sha": "7cf0dcf27431cbb51423cf0cf5659f20388989b0", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -802,9 +802,9 @@ fixup_reorder_chain (void)\n \t   bb = bb->rbi->next, index++)\n \t{\n \t  fprintf (dump_file, \" %i \", index);\n-\t  if (bb->rbi->original)\n+\t  if (get_bb_original (bb))\n \t    fprintf (dump_file, \"duplicate of %i \",\n-\t\t     bb->rbi->original->index);\n+\t\t     get_bb_original (bb)->index);\n \t  else if (forwarder_block_p (bb)\n \t\t   && !LABEL_P (BB_HEAD (bb)))\n \t    fprintf (dump_file, \"compensation \");\n@@ -1100,6 +1100,8 @@ cfg_layout_initialize (unsigned int flags)\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     initialize_bb_rbi (bb);\n \n+  initialize_original_copy_tables ();\n+\n   cfg_layout_rtl_register_cfg_hooks ();\n \n   record_effective_endpoints ();\n@@ -1166,6 +1168,8 @@ cfg_layout_finalize (void)\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n+\n+  free_original_copy_tables ();\n }\n \n /* Checks whether all N blocks in BBS array can be copied.  */\n@@ -1177,15 +1181,15 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n   int ret = true;\n \n   for (i = 0; i < n; i++)\n-    bbs[i]->rbi->duplicated = 1;\n+    bbs[i]->flags |= BB_DUPLICATED;\n \n   for (i = 0; i < n; i++)\n     {\n       /* In case we should redirect abnormal edge during duplication, fail.  */\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n \tif ((e->flags & EDGE_ABNORMAL)\n-\t    && e->dest->rbi->duplicated)\n+\t    && (e->dest->flags & BB_DUPLICATED))\n \t  {\n \t    ret = false;\n \t    goto end;\n@@ -1200,7 +1204,7 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n \n end:\n   for (i = 0; i < n; i++)\n-    bbs[i]->rbi->duplicated = 0;\n+    bbs[i]->flags &= ~BB_DUPLICATED;\n \n   return ret;\n }\n@@ -1235,7 +1239,7 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n       /* Duplicate.  */\n       bb = bbs[i];\n       new_bb = new_bbs[i] = duplicate_block (bb, NULL);\n-      bb->rbi->duplicated = 1;\n+      bb->flags |= BB_DUPLICATED;\n       /* Add to loop.  */\n       add_bb_to_loop (new_bb, bb->loop_father->copy);\n       /* Possibly set header.  */\n@@ -1253,9 +1257,9 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n       new_bb = new_bbs[i];\n \n       dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-      if (dom_bb->rbi->duplicated)\n+      if (dom_bb->flags & BB_DUPLICATED)\n \t{\n-\t  dom_bb = dom_bb->rbi->copy;\n+\t  dom_bb = get_bb_copy (dom_bb);\n \t  set_immediate_dominator (CDI_DOMINATORS, new_bb, dom_bb);\n \t}\n     }\n@@ -1275,15 +1279,15 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n \t    if (edges[j] && edges[j]->src == bb && edges[j]->dest == e->dest)\n \t      new_edges[j] = e;\n \n-\t  if (!e->dest->rbi->duplicated)\n+\t  if (!(e->dest->flags & BB_DUPLICATED))\n \t    continue;\n-\t  redirect_edge_and_branch_force (e, e->dest->rbi->copy);\n+\t  redirect_edge_and_branch_force (e, get_bb_copy (e->dest));\n \t}\n     }\n \n   /* Clear information about duplicates.  */\n   for (i = 0; i < n; i++)\n-    bbs[i]->rbi->duplicated = 0;\n+    bbs[i]->flags &= ~BB_DUPLICATED;\n }\n \n #include \"gt-cfglayout.h\""}, {"sha": "9972378a79004dc681771bff1a570bad10ef4e5c", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -813,19 +813,19 @@ update_single_exits_after_duplication (basic_block *bbs, unsigned nbbs,\n   unsigned i;\n \n   for (i = 0; i < nbbs; i++)\n-    bbs[i]->rbi->duplicated = 1;\n+    bbs[i]->flags |= BB_DUPLICATED;\n \n   for (; loop->outer; loop = loop->outer)\n     {\n       if (!loop->single_exit)\n \tcontinue;\n \n-      if (loop->single_exit->src->rbi->duplicated)\n+      if (loop->single_exit->src->flags & BB_DUPLICATED)\n \tloop->single_exit = NULL;\n     }\n \n   for (i = 0; i < nbbs; i++)\n-    bbs[i]->rbi->duplicated = 0;\n+    bbs[i]->flags &= ~BB_DUPLICATED;\n }\n \n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n@@ -983,13 +983,16 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop);\n \n       for (i = 0; i < n; i++)\n-\tnew_bbs[i]->rbi->copy_number = j + 1;\n+\t{\n+\t  gcc_assert (!new_bbs[i]->aux);\n+\t  new_bbs[i]->aux = (void *)(size_t)(j + 1);\n+\t}\n \n       /* Note whether the blocks and edges belong to an irreducible loop.  */\n       if (add_irreducible_flag)\n \t{\n \t  for (i = 0; i < n; i++)\n-\t    new_bbs[i]->rbi->duplicated = 1;\n+\t    new_bbs[i]->flags |= BB_DUPLICATED;\n \t  for (i = 0; i < n; i++)\n \t    {\n \t      edge_iterator ei;\n@@ -998,13 +1001,13 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t\tnew_bb->flags |= BB_IRREDUCIBLE_LOOP;\n \n \t      FOR_EACH_EDGE (ae, ei, new_bb->succs)\n-\t\tif (ae->dest->rbi->duplicated\n+\t\tif ((ae->dest->flags & BB_DUPLICATED)\n \t\t    && (ae->src->loop_father == target\n \t\t\t|| ae->dest->loop_father == target))\n \t\t  ae->flags |= EDGE_IRREDUCIBLE_LOOP;\n \t    }\n \t  for (i = 0; i < n; i++)\n-\t    new_bbs[i]->rbi->duplicated = 0;\n+\t    new_bbs[i]->flags &= ~BB_DUPLICATED;\n \t}\n \n       /* Redirect the special edges.  */\n@@ -1064,7 +1067,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       int n_dom_bbs,j;\n \n       bb = bbs[i];\n-      bb->rbi->copy_number = 0;\n+      bb->aux = 0;\n \n       n_dom_bbs = get_dominated_by (CDI_DOMINATORS, bb, &dom_bbs);\n       for (j = 0; j < n_dom_bbs; j++)\n@@ -1447,18 +1450,18 @@ loop_version (struct loops *loops, struct loop * loop,\n       return NULL;\n     }\n \n-  latch_edge = single_succ_edge (loop->latch->rbi->copy);\n+  latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n   \n   extract_cond_bb_edges (*condition_bb, &true_edge, &false_edge);\n   nloop = loopify (loops,\n \t\t   latch_edge,\n-\t\t   single_pred_edge (loop->header->rbi->copy),\n+\t\t   single_pred_edge (get_bb_copy (loop->header)),\n \t\t   *condition_bb, true_edge, false_edge,\n \t\t   false /* Do not redirect all edges.  */);\n \n   exit = loop->single_exit;\n   if (exit)\n-    nloop->single_exit = find_edge (exit->src->rbi->copy, exit->dest);\n+    nloop->single_exit = find_edge (get_bb_copy (exit->src), exit->dest);\n \n   /* loopify redirected latch_edge. Update its PENDING_STMTS.  */ \n   lv_flush_pending_stmts (latch_edge);"}, {"sha": "1018d1ae30e62f58a6f5d4459aa744bc78eb52f2", "filename": "gcc/dominance.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -746,15 +746,15 @@ get_dominated_by_region (enum cdi_direction dir, basic_block *region,\n   basic_block dom;\n \n   for (i = 0; i < n_region; i++)\n-    region[i]->rbi->duplicated = 1;\n+    region[i]->flags |= BB_DUPLICATED;\n   for (i = 0; i < n_region; i++)\n     for (dom = first_dom_son (dir, region[i]);\n \t dom;\n \t dom = next_dom_son (dir, dom))\n-      if (!dom->rbi->duplicated)\n+      if (!(dom->flags & BB_DUPLICATED))\n \tdoms[n_doms++] = dom;\n   for (i = 0; i < n_region; i++)\n-    region[i]->rbi->duplicated = 0;\n+    region[i]->flags &= ~BB_DUPLICATED;\n \n   return n_doms;\n }"}, {"sha": "e78341110d9d60226bd7424d60ac0de0603000e3", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -562,6 +562,7 @@ expand_resx_expr (tree exp)\n   int region_nr = TREE_INT_CST_LOW (TREE_OPERAND (exp, 0));\n   struct eh_region *reg = cfun->eh->region_array[region_nr];\n \n+  gcc_assert (!reg->resume);\n   reg->resume = emit_jump_insn (gen_rtx_RESX (VOIDmode, region_nr));\n   emit_barrier ();\n }"}, {"sha": "72fda46e3918a691af9c4ce8adb33c25a000865d", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -790,7 +790,7 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \n   if (exit_at_end)\n     {\n-      basic_block exit_block = desc->in_edge->src->rbi->copy;\n+      basic_block exit_block = get_bb_copy (desc->in_edge->src);\n       /* Find a new in and out edge; they are in the last copy we have made.  */\n       \n       if (EDGE_SUCC (exit_block, 0)->dest == desc->out_edge->dest)\n@@ -1110,7 +1110,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n \n   if (exit_at_end)\n     {\n-      basic_block exit_block = desc->in_edge->src->rbi->copy;\n+      basic_block exit_block = get_bb_copy (desc->in_edge->src);\n       /* Find a new in and out edge; they are in the last copy we have\n \t made.  */\n       \n@@ -2058,9 +2058,11 @@ apply_opt_in_copies (struct opt_info *opt_info,\n   for (i = opt_info->first_new_block; i < (unsigned) last_basic_block; i++)\n     {\n       bb = BASIC_BLOCK (i);\n-      orig_bb = bb->rbi->original;\n+      orig_bb = get_bb_original (bb);\n       \n-      delta = determine_split_iv_delta (bb->rbi->copy_number, n_copies,\n+      /* bb->aux holds position in copy sequence initialized by\n+\t duplicate_loop_to_header_edge.  */\n+      delta = determine_split_iv_delta ((size_t)bb->aux, n_copies,\n \t\t\t\t\tunrolling);\n       orig_insn = BB_HEAD (orig_bb);\n       for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb)); insn = next)\n@@ -2124,12 +2126,12 @@ apply_opt_in_copies (struct opt_info *opt_info,\n   \n   /* Rewrite also the original loop body.  Find them as originals of the blocks\n      in the last copied iteration, i.e. those that have\n-     bb->rbi->original->copy == bb.  */\n+     get_bb_copy (get_bb_original (bb)) == bb.  */\n   for (i = opt_info->first_new_block; i < (unsigned) last_basic_block; i++)\n     {\n       bb = BASIC_BLOCK (i);\n-      orig_bb = bb->rbi->original;\n-      if (orig_bb->rbi->copy != bb)\n+      orig_bb = get_bb_original (bb);\n+      if (get_bb_copy (orig_bb) != bb)\n \tcontinue;\n       \n       delta = determine_split_iv_delta (0, n_copies, unrolling);"}, {"sha": "27a8bca26251b16649c5b6b4fd835f630cd6a197", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -431,10 +431,10 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   entry->flags |= irred_flag;\n \n   /* Record the block with condition we unswitch on.  */\n-  unswitch_on_alt = unswitch_on->rbi->copy;\n+  unswitch_on_alt = get_bb_copy (unswitch_on);\n   true_edge = BRANCH_EDGE (unswitch_on_alt);\n   false_edge = FALLTHRU_EDGE (unswitch_on);\n-  latch_edge = single_succ_edge (loop->latch->rbi->copy);\n+  latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n \n   /* Create a block with the condition.  */\n   prob = true_edge->probability;\n@@ -465,7 +465,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n   nloop = loopify (loops, latch_edge,\n-\t\t   single_pred_edge (loop->header->rbi->copy), switch_bb,\n+\t\t   single_pred_edge (get_bb_copy (loop->header)), switch_bb,\n \t\t   BRANCH_EDGE (switch_bb), FALLTHRU_EDGE (switch_bb), true);\n \n   /* Remove branches that are now unreachable in new loops.  */"}, {"sha": "6a72250e32887dbc416f21b83789bc4485c30b19", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -390,7 +390,6 @@ create_bb (void *h, void *e, basic_block after)\n   n_basic_blocks++;\n   last_basic_block++;\n \n-  initialize_bb_rbi (bb);\n   return bb;\n }\n \n@@ -2569,11 +2568,7 @@ disband_implicit_edges (void)\n void\n delete_tree_cfg_annotations (void)\n {\n-  basic_block bb;\n-\n   label_to_block_map = NULL;\n-  FOR_EACH_BB (bb)\n-    bb->rbi = NULL;\n }\n \n \n@@ -4161,7 +4156,7 @@ tree_duplicate_bb (basic_block bb)\n \n /* Basic block BB_COPY was created by code duplication.  Add phi node\n    arguments for edges going out of BB_COPY.  The blocks that were\n-   duplicated have rbi->duplicated set to one.  */\n+   duplicated have BB_DUPLICATED set.  */\n \n void\n add_phi_args_after_copy_bb (basic_block bb_copy)\n@@ -4171,15 +4166,15 @@ add_phi_args_after_copy_bb (basic_block bb_copy)\n   edge_iterator ei;\n   tree phi, phi_copy, phi_next, def;\n       \n-  bb = bb_copy->rbi->original;\n+  bb = get_bb_original (bb_copy);\n \n   FOR_EACH_EDGE (e_copy, ei, bb_copy->succs)\n     {\n       if (!phi_nodes (e_copy->dest))\n \tcontinue;\n \n-      if (e_copy->dest->rbi->duplicated)\n-\tdest = e_copy->dest->rbi->original;\n+      if (e_copy->dest->flags & BB_DUPLICATED)\n+\tdest = get_bb_original (e_copy->dest);\n       else\n \tdest = e_copy->dest;\n \n@@ -4190,8 +4185,8 @@ add_phi_args_after_copy_bb (basic_block bb_copy)\n \t     In this case we are not looking for edge to dest, but to\n \t     duplicated block whose original was dest.  */\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (e->dest->rbi->duplicated\n-\t\t&& e->dest->rbi->original == dest)\n+\t    if ((e->dest->flags & BB_DUPLICATED)\n+\t\t&& get_bb_original (e->dest) == dest)\n \t      break;\n \n \t  gcc_assert (e != NULL);\n@@ -4218,13 +4213,13 @@ add_phi_args_after_copy (basic_block *region_copy, unsigned n_region)\n   unsigned i;\n \n   for (i = 0; i < n_region; i++)\n-    region_copy[i]->rbi->duplicated = 1;\n+    region_copy[i]->flags |= BB_DUPLICATED;\n \n   for (i = 0; i < n_region; i++)\n     add_phi_args_after_copy_bb (region_copy[i]);\n \n   for (i = 0; i < n_region; i++)\n-    region_copy[i]->rbi->duplicated = 0;\n+    region_copy[i]->flags &= ~BB_DUPLICATED;\n }\n \n /* Duplicates a REGION (set of N_REGION basic blocks) with just a single\n@@ -4298,6 +4293,8 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   /* Record blocks outside the region that are dominated by something\n      inside.  */\n   doms = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  initialize_original_copy_tables ();\n+\n   n_doms = get_dominated_by_region (CDI_DOMINATORS, region, n_region, doms);\n \n   total_freq = entry->dest->frequency;\n@@ -4321,7 +4318,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n     }\n \n   /* Redirect the entry and add the phi node arguments.  */\n-  redirected = redirect_edge_and_branch (entry, entry->dest->rbi->copy);\n+  redirected = redirect_edge_and_branch (entry, get_bb_copy (entry->dest));\n   gcc_assert (redirected != NULL);\n   flush_pending_stmts (entry);\n \n@@ -4330,7 +4327,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n      region, but was dominated by something inside needs recounting as\n      well.  */\n   set_immediate_dominator (CDI_DOMINATORS, entry->dest, entry->src);\n-  doms[n_doms++] = entry->dest->rbi->original;\n+  doms[n_doms++] = get_bb_original (entry->dest);\n   iterate_fix_dominators (CDI_DOMINATORS, doms, n_doms);\n   free (doms);\n \n@@ -4343,6 +4340,7 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   if (free_region_copy)\n     free (region_copy);\n \n+  free_original_copy_tables ();\n   return true;\n }\n "}, {"sha": "c38c2f2b00707a9364bd5417e1f2cef181510730", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -226,15 +226,18 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n       old_cond = COND_EXPR_COND (cond);\n       COND_EXPR_COND (cond) = dont_exit;\n       update_stmt (cond);\n+      initialize_original_copy_tables ();\n \n       if (!tree_duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t       loops, n_unroll, NULL,\n \t\t\t\t\t       NULL, NULL, NULL, 0))\n \t{\n \t  COND_EXPR_COND (cond) = old_cond;\n \t  update_stmt (cond);\n+          free_original_copy_tables ();\n \t  return false;\n \t}\n+      free_original_copy_tables ();\n     }\n   \n   COND_EXPR_COND (cond) = do_exit;"}, {"sha": "50989710dc474deb4a4a3560720f97b3292b2736", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -566,13 +566,13 @@ copy_phi_node_args (unsigned first_new_block)\n   unsigned i;\n \n   for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n-    BASIC_BLOCK (i)->rbi->duplicated = 1;\n+    BASIC_BLOCK (i)->flags |= BB_DUPLICATED;\n \n   for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n     add_phi_args_after_copy_bb (BASIC_BLOCK (i));\n \n   for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n-    BASIC_BLOCK (i)->rbi->duplicated = 0;\n+    BASIC_BLOCK (i)->flags &= ~BB_DUPLICATED;\n }\n \n "}, {"sha": "21dc6b5f9ff3375b87e01dec2b0b473e4c35c70c", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6580ee7781f9039547bd7e61c19064b4993227e9/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=6580ee7781f9039547bd7e61c19064b4993227e9", "patch": "@@ -249,13 +249,15 @@ tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \";; Unswitching loop\\n\");\n \n+  initialize_original_copy_tables ();\n   /* Unswitch the loop on this condition.  */\n   nloop = tree_unswitch_loop (loops, loop, bbs[i], cond);\n   if (!nloop)\n     return changed;\n \n   /* Update the SSA form after unswitching.  */\n   update_ssa (TODO_update_ssa);\n+  free_original_copy_tables ();\n \n   /* Invoke itself on modified loops.  */\n   tree_unswitch_single_loop (loops, nloop, num + 1);"}]}