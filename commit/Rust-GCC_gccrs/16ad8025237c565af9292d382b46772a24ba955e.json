{"sha": "16ad8025237c565af9292d382b46772a24ba955e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZhZDgwMjUyMzdjNTY1YWY5MjkyZDM4MmI0Njc3MmEyNGJhOTU1ZQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2010-07-05T17:40:57Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2010-07-05T17:40:57Z"}, "message": "re PR middle-end/42505 (loop canonicalization causes a lot of unnecessary temporary variables)\n\n2010-07-05  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tPR middle-end/42505\n\n\tgcc/\n\t* tree-ssa-loop-ivopts.c (determine_set_costs): Delete obsolete\n\tcomments about cost model.\n\t(try_add_cand_for):  Add second strategy for choosing initial set\n\tbased on original IVs, controlled by ORIGINALP argument.\n\t(get_initial_solution): Add ORIGINALP argument.\n\t(find_optimal_iv_set_1): New function, split from find_optimal_iv_set.\n\t(find_optimal_iv_set): Try two different strategies for choosing\n\tthe IV set, and return the one with lower cost.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/pr42505.c: New test case.\n\nFrom-SVN: r161844", "tree": {"sha": "f20842f5f809320a8d5943d03419f981e5f8a32d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f20842f5f809320a8d5943d03419f981e5f8a32d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16ad8025237c565af9292d382b46772a24ba955e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ad8025237c565af9292d382b46772a24ba955e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ad8025237c565af9292d382b46772a24ba955e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ad8025237c565af9292d382b46772a24ba955e/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "22a4778a0d558eeeedb14db4e811e36483675983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a4778a0d558eeeedb14db4e811e36483675983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a4778a0d558eeeedb14db4e811e36483675983"}], "stats": {"total": 134, "additions": 100, "deletions": 34}, "files": [{"sha": "eb2d24b53c35e043e2bb0c837f65cd92de9c6fb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ad8025237c565af9292d382b46772a24ba955e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ad8025237c565af9292d382b46772a24ba955e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16ad8025237c565af9292d382b46772a24ba955e", "patch": "@@ -1,3 +1,16 @@\n+2010-07-05  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR middle-end/42505\n+\n+\t* tree-ssa-loop-ivopts.c (determine_set_costs): Delete obsolete\n+\tcomments about cost model.\n+\t(try_add_cand_for):  Add second strategy for choosing initial set\n+\tbased on original IVs, controlled by ORIGINALP argument.\n+\t(get_initial_solution): Add ORIGINALP argument.\n+\t(find_optimal_iv_set_1): New function, split from find_optimal_iv_set.\n+\t(find_optimal_iv_set): Try two different strategies for choosing\n+\tthe IV set, and return the one with lower cost.\n+\n 2010-07-05  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Copy"}, {"sha": "ae6ec62cb15caed1a30a25c16d6052139c7d6698", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ad8025237c565af9292d382b46772a24ba955e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ad8025237c565af9292d382b46772a24ba955e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16ad8025237c565af9292d382b46772a24ba955e", "patch": "@@ -1,3 +1,9 @@\n+2010-07-05  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR middle-end/42505\n+\n+\t* gcc.target/arm/pr42505.c: New test case.\n+\n 2010-07-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/44808"}, {"sha": "60902c35d27b5ed524ce4ebfd03c6186a08b6cc1", "filename": "gcc/testsuite/gcc.target/arm/pr42505.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ad8025237c565af9292d382b46772a24ba955e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42505.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ad8025237c565af9292d382b46772a24ba955e/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42505.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42505.c?ref=16ad8025237c565af9292d382b46772a24ba955e", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-options \"-mthumb -Os -march=armv5te\" }  */\n+/* { dg-require-effective-target arm_thumb1_ok } */\n+/* { dg-final { scan-assembler-not \"str\\[\\\\t \\]*r.,\\[\\\\t \\]*.sp,\" } } */\n+\n+struct A {\n+ int f1;\n+ int f2;\n+};\n+\n+int func(int c);\n+\n+/* This function should not need to spill anything to the stack.  */\n+int test(struct A* src, struct A* dst, int count)\n+{\n+  while (count--) {\n+    if (!func(src->f2)) {\n+        return 0;\n+      }\n+      *dst++ = *src++;\n+  }\n+\n+  return 1;\n+}"}, {"sha": "c0a2194cfd09181eaf23f6a0572ca89f41dd06b8", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ad8025237c565af9292d382b46772a24ba955e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ad8025237c565af9292d382b46772a24ba955e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=16ad8025237c565af9292d382b46772a24ba955e", "patch": "@@ -4446,26 +4446,6 @@ determine_set_costs (struct ivopts_data *data)\n   struct loop *loop = data->current_loop;\n   bitmap_iterator bi;\n \n-  /* We use the following model (definitely improvable, especially the\n-     cost function -- TODO):\n-\n-     We estimate the number of registers available (using MD data), name it A.\n-\n-     We estimate the number of registers used by the loop, name it U.  This\n-     number is obtained as the number of loop phi nodes (not counting virtual\n-     registers and bivs) + the number of variables from outside of the loop.\n-\n-     We set a reserve R (free regs that are used for temporary computations,\n-     etc.).  For now the reserve is a constant 3.\n-\n-     Let I be the number of induction variables.\n-\n-     -- if U + I + R <= A, the cost is I * SMALL_COST (just not to encourage\n-\tmake a lot of ivs without a reason).\n-     -- if A - R < U + I <= A, the cost is I * PRES_COST\n-     -- if U + I > A, the cost is I * PRES_COST and\n-        number of uses * SPILL_COST * (U + I - A) / (U + I) is added.  */\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Global costs:\\n\");\n@@ -5089,11 +5069,13 @@ iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n }\n \n /* Tries to extend the sets IVS in the best possible way in order\n-   to express the USE.  */\n+   to express the USE.  If ORIGINALP is true, prefer candidates from\n+   the original set of IVs, otherwise favor important candidates not\n+   based on any memory object.  */\n \n static bool\n try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n-\t\t  struct iv_use *use)\n+\t\t  struct iv_use *use, bool originalp)\n {\n   comp_cost best_cost, act_cost;\n   unsigned i;\n@@ -5112,7 +5094,8 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n       iv_ca_set_no_cp (data, ivs, use);\n     }\n \n-  /* First try important candidates not based on any memory object.  Only if\n+  /* If ORIGINALP is true, try to find the original IV for the use.  Otherwise\n+     first try important candidates not based on any memory object.  Only if\n      this fails, try the specific ones.  Rationale -- in loops with many\n      variables the best choice often is to use just one generic biv.  If we\n      added here many ivs specific to the uses, the optimization algorithm later\n@@ -5124,7 +5107,10 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n     {\n       cand = iv_cand (data, i);\n \n-      if (cand->iv->base_object != NULL_TREE)\n+      if (originalp && cand->pos !=IP_ORIGINAL)\n+\tcontinue;\n+\n+      if (!originalp && cand->iv->base_object != NULL_TREE)\n \tcontinue;\n \n       if (iv_ca_cand_used_p (ivs, cand))\n@@ -5160,8 +5146,13 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \t    continue;\n \n \t  /* Already tried this.  */\n-\t  if (cand->important && cand->iv->base_object == NULL_TREE)\n-\t    continue;\n+\t  if (cand->important)\n+\t    {\n+\t      if (originalp && cand->pos == IP_ORIGINAL)\n+\t\tcontinue;\n+\t      if (!originalp && cand->iv->base_object == NULL_TREE)\n+\t\tcontinue;\n+\t    }\n \n \t  if (iv_ca_cand_used_p (ivs, cand))\n \t    continue;\n@@ -5195,13 +5186,13 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n /* Finds an initial assignment of candidates to uses.  */\n \n static struct iv_ca *\n-get_initial_solution (struct ivopts_data *data)\n+get_initial_solution (struct ivopts_data *data, bool originalp)\n {\n   struct iv_ca *ivs = iv_ca_new (data);\n   unsigned i;\n \n   for (i = 0; i < n_iv_uses (data); i++)\n-    if (!try_add_cand_for (data, ivs, iv_use (data, i)))\n+    if (!try_add_cand_for (data, ivs, iv_use (data, i), originalp))\n       {\n \tiv_ca_free (&ivs);\n \treturn NULL;\n@@ -5273,14 +5264,12 @@ try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n    solution and remove the unused ivs while this improves the cost.  */\n \n static struct iv_ca *\n-find_optimal_iv_set (struct ivopts_data *data)\n+find_optimal_iv_set_1 (struct ivopts_data *data, bool originalp)\n {\n-  unsigned i;\n   struct iv_ca *set;\n-  struct iv_use *use;\n \n   /* Get the initial solution.  */\n-  set = get_initial_solution (data);\n+  set = get_initial_solution (data, originalp);\n   if (!set)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -5303,11 +5292,46 @@ find_optimal_iv_set (struct ivopts_data *data)\n \t}\n     }\n \n+  return set;\n+}\n+\n+static struct iv_ca *\n+find_optimal_iv_set (struct ivopts_data *data)\n+{\n+  unsigned i;\n+  struct iv_ca *set, *origset;\n+  struct iv_use *use;\n+  comp_cost cost, origcost;\n+\n+  /* Determine the cost based on a strategy that starts with original IVs,\n+     and try again using a strategy that prefers candidates not based\n+     on any IVs.  */\n+  origset = find_optimal_iv_set_1 (data, true);\n+  set = find_optimal_iv_set_1 (data, false);\n+\n+  if (!origset && !set)\n+    return NULL;\n+\n+  origcost = origset ? iv_ca_cost (origset) : infinite_cost;\n+  cost = set ? iv_ca_cost (set) : infinite_cost;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      comp_cost cost = iv_ca_cost (set);\n-      fprintf (dump_file, \"Final cost %d (complexity %d)\\n\\n\", cost.cost, cost.complexity);\n+      fprintf (dump_file, \"Original cost %d (complexity %d)\\n\\n\",\n+\t       origcost.cost, origcost.complexity);\n+      fprintf (dump_file, \"Final cost %d (complexity %d)\\n\\n\",\n+\t       cost.cost, cost.complexity);\n+    }\n+\n+  /* Choose the one with the best cost.  */\n+  if (compare_costs (origcost, cost) <= 0)\n+    {\n+      if (set)\n+\tiv_ca_free (&set);\n+      set = origset;\n     }\n+  else if (origset)\n+    iv_ca_free (&origset);\n \n   for (i = 0; i < n_iv_uses (data); i++)\n     {"}]}