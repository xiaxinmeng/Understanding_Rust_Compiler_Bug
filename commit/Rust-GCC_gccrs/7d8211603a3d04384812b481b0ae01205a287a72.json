{"sha": "7d8211603a3d04384812b481b0ae01205a287a72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4MjExNjAzYTNkMDQzODQ4MTJiNDgxYjBhZTAxMjA1YTI4N2E3Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-30T14:28:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-01T07:47:58Z"}, "message": "tree-optimization/101178 - handle VEC_PERM in SLP permute propagation\n\nThis adds handling of VEC_PERM nodes to SLP permute propagation.\nPreviously VEC_PERM acted as forced materialization of incoming\npermutes since it is a good place to do that (with the constraint\nof those only appearing for two-operator nodes).  The following\npatch, in addition to supporting (but not forcing) this, enables\nVEC_PERM nodes acting as \"any\" permute on the outgoing side since\nthey also can consume arbitrary permutes on that side.\n\nThis again (meh) changes how we represent permutes and materialization\non the graph vertices now explicitely having the common incoming\npermute as well as an outgoing permute and in case both are\ndifferent the vertex acts as materialization point of the incoming\npermute.\n\n2021-06-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101178\n\t* tree-vect-slp.c (slpg_vertex::materialize): Remove.\n\t(slpg::perm_in): Add.\n\t(slpg::get_perm_in): Remove.\n\t(slpg::get_perm_materialized): Add.\n\t(vect_optimize_slp): Handle VEC_PERM nodes more optimally\n\tduring permute propagation and materialization.\n\n\t* gcc.dg/vect/bb-slp-72.c: New testcase.\n\t* gcc.dg/vect/bb-slp-73.c: Likewise.\n\t* gcc.dg/vect/bb-slp-74.c: Likewise.", "tree": {"sha": "92a399096554ae139a5713d648a1a5dda3daa7a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92a399096554ae139a5713d648a1a5dda3daa7a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d8211603a3d04384812b481b0ae01205a287a72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8211603a3d04384812b481b0ae01205a287a72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8211603a3d04384812b481b0ae01205a287a72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8211603a3d04384812b481b0ae01205a287a72/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0ab968999c9af88d45acf552ca673ef3960306a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ab968999c9af88d45acf552ca673ef3960306a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ab968999c9af88d45acf552ca673ef3960306a"}], "stats": {"total": 288, "additions": 204, "deletions": 84}, "files": [{"sha": "5b243fc1ace73a1ec286bd7f2e8a26e189019534", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-72.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-72.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-72.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-72.c?ref=7d8211603a3d04384812b481b0ae01205a287a72", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+double x[2], y[2], z[2], w[2];\n+\n+void __attribute__((noipa)) foo ()\n+{\n+  double tem0 = x[1] + y[1];\n+  double tem1 = x[0] - y[0];\n+  double tem2 = z[1] * tem0;\n+  double tem3 = z[0] * tem1;\n+  z[0] = tem2 - w[0];\n+  z[1] = tem3 + w[1];\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  x[0] = 1.; x[1] = 2.;\n+  y[0] = 7.; y[1] = -5.;\n+  z[0] = 2.; z[1] = 3.;\n+  w[0] = 9.; w[1] = -5.;\n+  foo ();\n+  if (z[0] != -18. || z[1] != -17.)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "d4c8a514b1c1571e423f4f6e65314b744af60d04", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-73.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-73.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-73.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-73.c?ref=7d8211603a3d04384812b481b0ae01205a287a72", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+double x[2], y[2], z[2], w[2];\n+\n+void __attribute__((noipa)) foo ()\n+{\n+  double tem0 = x[1] + y[1];\n+  double tem1 = x[0] - y[0];\n+  double tem2 = z[1] * tem0;\n+  double tem3 = z[0] * tem1;\n+  z[0] = tem2 - w[1];\n+  z[1] = tem3 + w[0];\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  x[0] = 1.; x[1] = 2.;\n+  y[0] = 7.; y[1] = -5.;\n+  z[0] = 2.; z[1] = 3.;\n+  w[0] = 9.; w[1] = -5.;\n+  foo ();\n+  if (z[0] != -4. || z[1] != -3.)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "d3d5a02a29b7262aa122368b7349548d65150e6c", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-74.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-74.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-74.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-74.c?ref=7d8211603a3d04384812b481b0ae01205a287a72", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+double a[2], b[2], c[2];\n+\n+void __attribute__((noipa)) foo ()\n+{\n+  double tem0 = a[1] + b[1];\n+  double tem1 = a[0] - b[0];\n+  c[0] = 2. * tem0;\n+  c[1] = 5. * tem1;\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  a[0] = 1.; a[1] = 3.;\n+  b[0] = -5.; b[1] = 13.;\n+  foo ();\n+  if (c[0] != 32. || c[1] != 30.)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* We'd like to see at most one VEC_PERM_EXPR, not one for a blend\n+   and one for a permute materialized somewhere else.  But addsub\n+   pattern recog can likely get in the way here.  */\n+/* { dg-final { scan-tree-dump-times \"  \\[^ \\]\\+ = VEC_PERM_EXPR\" 1 \"slp2\" } } */"}, {"sha": "966b281ffaeec718d6fd2dc3fd9cbec3b67688ac", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 116, "deletions": 84, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8211603a3d04384812b481b0ae01205a287a72/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7d8211603a3d04384812b481b0ae01205a287a72", "patch": "@@ -3470,16 +3470,19 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n struct slpg_vertex\n {\n   slpg_vertex (slp_tree node_)\n-    : node (node_), perm_out (-1), materialize (0) {}\n+    : node (node_), perm_in (-1), perm_out (-1) {}\n \n-  int get_perm_in () const { return materialize ? materialize : perm_out; }\n+  int get_perm_materialized () const\n+    { return perm_in != perm_out ? perm_in : 0; }\n \n   slp_tree node;\n-  /* The permutation on the outgoing lanes (towards SLP parents).  */\n+  /* The common permutation on the incoming lanes (towards SLP children).  */\n+  int perm_in;\n+  /* The permutation on the outgoing lanes (towards SLP parents).  When\n+     the node is a materialization point for a permute this differs\n+     from perm_in (and is then usually zero).  Materialization happens\n+     on the input side.  */\n   int perm_out;\n-  /* The permutation that is applied by this node.  perm_out is\n-     relative to this.  */\n-  int materialize;\n };\n \n /* Fill the vertices and leafs vector with all nodes in the SLP graph.  */\n@@ -3614,7 +3617,11 @@ vect_optimize_slp (vec_info *vinfo)\n       /* Leafs do not change across iterations.  Note leafs also double\n \t as entries to the reverse graph.  */\n       if (!slpg->vertices[idx].succ)\n-\tvertices[idx].perm_out = 0;\n+\t{\n+\t  vertices[idx].perm_in = 0;\n+\t  vertices[idx].perm_out = 0;\n+\t}\n+\n       /* Loads are the only thing generating permutes.  */\n       if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \tcontinue;\n@@ -3663,6 +3670,7 @@ vect_optimize_slp (vec_info *vinfo)\n       for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n \tperm[j] = SLP_TREE_LOAD_PERMUTATION (node)[j] - imin;\n       perms.safe_push (perm);\n+      vertices[idx].perm_in = perms.length () - 1;\n       vertices[idx].perm_out = perms.length () - 1;\n     }\n \n@@ -3702,8 +3710,11 @@ vect_optimize_slp (vec_info *vinfo)\n \t      if (STMT_VINFO_DATA_REF (rep)\n \t\t  && DR_IS_WRITE (STMT_VINFO_DATA_REF (rep)))\n \t\t{\n+\t\t  /* ???  We're forcing materialization in place\n+\t\t     of the child here, we'd need special handling\n+\t\t     in materialization to leave perm_in -1 here.  */\n+\t\t  vertices[idx].perm_in = 0;\n \t\t  vertices[idx].perm_out = 0;\n-\t\t  continue;\n \t\t}\n \t      /* We cannot move a permute across an operation that is\n \t\t not independent on lanes.  Note this is an explicit\n@@ -3717,20 +3728,19 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t  case CFN_COMPLEX_MUL:\n \t\t  case CFN_COMPLEX_MUL_CONJ:\n \t\t  case CFN_VEC_ADDSUB:\n+\t\t    vertices[idx].perm_in = 0;\n \t\t    vertices[idx].perm_out = 0;\n-\t\t    continue;\n \t\t  default:;\n \t\t  }\n \t    }\n \n-\t  int perm;\n \t  if (!slpg->vertices[idx].succ)\n \t    /* Pick up pre-computed leaf values.  */\n-\t    perm = vertices[idx].perm_out;\n+\t    ;\n \t  else\n \t    {\n \t      bool any_succ_perm_out_m1 = false;\n-\t      perm = vertices[idx].get_perm_in ();\n+\t      int perm_in = vertices[idx].perm_in;\n \t      for (graph_edge *succ = slpg->vertices[idx].succ;\n \t\t   succ; succ = succ->succ_next)\n \t\t{\n@@ -3752,18 +3762,18 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t\tany_succ_perm_out_m1 = true;\n \t\t      continue;\n \t\t    }\n-\t\t  if (perm == -1)\n-\t\t    perm = succ_perm;\n+\t\t  if (perm_in == -1)\n+\t\t    perm_in = succ_perm;\n \t\t  else if (succ_perm == 0\n-\t\t\t   || !vect_slp_perms_eq (perms, perm, succ_perm))\n+\t\t\t   || !vect_slp_perms_eq (perms, perm_in, succ_perm))\n \t\t    {\n-\t\t      perm = 0;\n+\t\t      perm_in = 0;\n \t\t      break;\n \t\t    }\n \t\t}\n \n \t      /* Adjust any incoming permutes we treated optimistically.  */\n-\t      if (perm != -1 && any_succ_perm_out_m1)\n+\t      if (perm_in != -1 && any_succ_perm_out_m1)\n \t\t{\n \t\t  for (graph_edge *succ = slpg->vertices[idx].succ;\n \t\t       succ; succ = succ->succ_next)\n@@ -3772,24 +3782,36 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t      if (vertices[succ->dest].perm_out == -1\n \t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_external_def\n \t\t\t  && SLP_TREE_DEF_TYPE (succ_node) != vect_constant_def)\n-\t\t\tvertices[succ->dest].perm_out = perm;\n+\t\t\t{\n+\t\t\t  vertices[succ->dest].perm_out = perm_in;\n+\t\t\t  /* And ensure this propagates.  */\n+\t\t\t  if (vertices[succ->dest].perm_in == -1)\n+\t\t\t    vertices[succ->dest].perm_in = perm_in;\n+\t\t\t}\n \t\t    }\n \t\t  changed = true;\n \t\t}\n \n-\t      if (!vect_slp_perms_eq (perms, perm,\n-\t\t\t\t      vertices[idx].get_perm_in ()))\n+\t      if (!vect_slp_perms_eq (perms, perm_in,\n+\t\t\t\t      vertices[idx].perm_in))\n \t\t{\n \t\t  /* Make sure we eventually converge.  */\n-\t\t  gcc_checking_assert (vertices[idx].get_perm_in () == -1\n-\t\t\t\t       || perm == 0);\n-\t\t  if (perm == 0)\n-\t\t    {\n-\t\t      vertices[idx].perm_out = 0;\n-\t\t      vertices[idx].materialize = 0;\n-\t\t    }\n-\t\t  if (!vertices[idx].materialize)\n-\t\t    vertices[idx].perm_out = perm;\n+\t\t  gcc_checking_assert (vertices[idx].perm_in == -1\n+\t\t\t\t       || perm_in == 0);\n+\t\t  vertices[idx].perm_in = perm_in;\n+\n+\t\t  /* While we can handle VEC_PERM nodes as transparent\n+\t\t     pass-through they can be a cheap materialization\n+\t\t     point as well.  In addition they can act as source\n+\t\t     of a random permutation as well.\n+\t\t     The following ensures that former materialization\n+\t\t     points that now have zero incoming permutes no\n+\t\t     longer appear as such and that former \"any\" permutes\n+\t\t     get pass-through.  We keep VEC_PERM nodes optimistic\n+\t\t     as \"any\" outgoing permute though.  */\n+\t\t  if (vertices[idx].perm_out != 0\n+\t\t      && SLP_TREE_CODE (node) != VEC_PERM_EXPR)\n+\t\t    vertices[idx].perm_out = perm_in;\n \t\t  changed = true;\n \t\t}\n \t    }\n@@ -3799,25 +3821,19 @@ vect_optimize_slp (vec_info *vinfo)\n \t  if (!do_materialization)\n \t    continue;\n \n+\t  int perm = vertices[idx].perm_out;\n \t  if (perm == 0 || perm == -1)\n \t    continue;\n \n \t  /* Decide on permute materialization.  Look whether there's\n \t     a use (pred) edge that is permuted differently than us.\n-\t     In that case mark ourselves so the permutation is applied.\n-\t     For VEC_PERM_EXPRs the permutation doesn't carry along\n-\t     from children to parents so force materialization at the\n-\t     point of the VEC_PERM_EXPR.  In principle VEC_PERM_EXPRs\n-\t     are a source of an arbitrary permutation again, similar\n-\t     to constants/externals - that's something we do not yet\n-\t     optimally handle.  */\n-\t  bool all_preds_permuted = (SLP_TREE_CODE (node) != VEC_PERM_EXPR\n-\t\t\t\t     && slpg->vertices[idx].pred != NULL);\n+\t     In that case mark ourselves so the permutation is applied.  */\n+\t  bool all_preds_permuted = slpg->vertices[idx].pred != NULL;\n \t  if (all_preds_permuted)\n \t    for (graph_edge *pred = slpg->vertices[idx].pred;\n \t\t pred; pred = pred->pred_next)\n \t      {\n-\t\tint pred_perm = vertices[pred->src].get_perm_in ();\n+\t\tint pred_perm = vertices[pred->src].perm_in;\n \t\tgcc_checking_assert (pred_perm != -1);\n \t\tif (!vect_slp_perms_eq (perms, perm, pred_perm))\n \t\t  {\n@@ -3827,10 +3843,8 @@ vect_optimize_slp (vec_info *vinfo)\n \t      }\n \t  if (!all_preds_permuted)\n \t    {\n-\t      if (!vertices[idx].materialize)\n-\t\tchanged = true;\n-\t      vertices[idx].materialize = perm;\n \t      vertices[idx].perm_out = 0;\n+\t      changed = true;\n \t    }\n \t}\n \n@@ -3848,46 +3862,43 @@ vect_optimize_slp (vec_info *vinfo)\n   /* Materialize.  */\n   for (i = 0; i < vertices.length (); ++i)\n     {\n-      int perm = vertices[i].get_perm_in ();\n-      if (perm <= 0)\n-\tcontinue;\n-\n+      int perm_in = vertices[i].perm_in;\n       slp_tree node = vertices[i].node;\n \n-      /* First permute invariant/external original successors.  */\n+      /* First permute invariant/external original successors, we handle\n+\t those optimistically during propagation and duplicate them if\n+\t they are used with different permutations.  */\n       unsigned j;\n       slp_tree child;\n-      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-\t{\n-\t  if (!child\n-\t      || (SLP_TREE_DEF_TYPE (child) != vect_constant_def\n-\t\t  && SLP_TREE_DEF_TYPE (child) != vect_external_def))\n-\t    continue;\n+      if (perm_in > 0)\n+\tFOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n+\t  {\n+\t    if (!child\n+\t\t|| (SLP_TREE_DEF_TYPE (child) != vect_constant_def\n+\t\t    && SLP_TREE_DEF_TYPE (child) != vect_external_def))\n+\t      continue;\n \n-\t  /* If the vector is uniform there's nothing to do.  */\n-\t  if (vect_slp_tree_uniform_p (child))\n-\t    continue;\n+\t    /* If the vector is uniform there's nothing to do.  */\n+\t    if (vect_slp_tree_uniform_p (child))\n+\t      continue;\n \n-\t  /* We can end up sharing some externals via two_operator\n-\t     handling.  Be prepared to unshare those.  */\n-\t  if (child->refcnt != 1)\n-\t    {\n-\t      gcc_assert (slpg->vertices[child->vertex].pred->pred_next);\n-\t      SLP_TREE_CHILDREN (node)[j] = child\n-\t\t= vect_create_new_slp_node\n-\t\t    (SLP_TREE_SCALAR_OPS (child).copy ());\n-\t    }\n-\t  vect_slp_permute (perms[perm],\n-\t\t\t    SLP_TREE_SCALAR_OPS (child), true);\n-\t}\n+\t    /* We can end up sharing some externals via two_operator\n+\t       handling.  Be prepared to unshare those.  */\n+\t    if (child->refcnt != 1)\n+\t      {\n+\t\tgcc_assert (slpg->vertices[child->vertex].pred->pred_next);\n+\t\tSLP_TREE_CHILDREN (node)[j] = child\n+\t\t  = vect_create_new_slp_node\n+\t\t      (SLP_TREE_SCALAR_OPS (child).copy ());\n+\t      }\n+\t    vect_slp_permute (perms[perm_in],\n+\t\t\t      SLP_TREE_SCALAR_OPS (child), true);\n+\t  }\n \n-      if (vertices[i].materialize)\n+      if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n \t{\n-\t  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-\t    /* For loads simply drop the permutation, the load permutation\n-\t       already performs the desired permutation.  */\n-\t    ;\n-\t  else if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n+\t  /* Apply the common permutes to the input vectors.  */\n+\t  if (perm_in > 0)\n \t    {\n \t      /* If the node is already a permute node we can apply\n \t\t the permutation to the lane selection, effectively\n@@ -3896,12 +3907,30 @@ vect_optimize_slp (vec_info *vinfo)\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t \"simplifying permute node %p\\n\",\n \t\t\t\t node);\n-\n \t      for (unsigned k = 0;\n \t\t   k < SLP_TREE_LANE_PERMUTATION (node).length (); ++k)\n \t\tSLP_TREE_LANE_PERMUTATION (node)[k].second\n-\t\t  = perms[perm][SLP_TREE_LANE_PERMUTATION (node)[k].second];\n+\t\t  = perms[perm_in][SLP_TREE_LANE_PERMUTATION (node)[k].second];\n+\t    }\n+\t  /* Apply the anticipated output permute to the permute and\n+\t     stmt vectors.  */\n+\t  int perm_out = vertices[i].perm_out;\n+\t  if (perm_out > 0)\n+\t    {\n+\t      vect_slp_permute (perms[perm_out],\n+\t\t\t\tSLP_TREE_SCALAR_STMTS (node), true);\n+\t      vect_slp_permute (perms[perm_out],\n+\t\t\t\tSLP_TREE_LANE_PERMUTATION (node), true);\n \t    }\n+\t}\n+      else if (vertices[i].get_perm_materialized () != 0)\n+\t{\n+\t  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n+\t    /* For loads simply drop the permutation, the load permutation\n+\t       already performs the desired permutation.  */\n+\t    ;\n+\t  else if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n+\t    gcc_unreachable ();\n \t  else\n \t    {\n \t      if (dump_enabled_p ())\n@@ -3916,7 +3945,7 @@ vect_optimize_slp (vec_info *vinfo)\n \t      SLP_TREE_CHILDREN (node) = vNULL;\n \t      SLP_TREE_SCALAR_STMTS (copy)\n \t\t= SLP_TREE_SCALAR_STMTS (node).copy ();\n-\t      vect_slp_permute (perms[perm],\n+\t      vect_slp_permute (perms[perm_in],\n \t\t\t\tSLP_TREE_SCALAR_STMTS (copy), true);\n \t      gcc_assert (!SLP_TREE_SCALAR_OPS (node).exists ());\n \t      SLP_TREE_REPRESENTATIVE (copy) = SLP_TREE_REPRESENTATIVE (node);\n@@ -3936,28 +3965,31 @@ vect_optimize_slp (vec_info *vinfo)\n \t      SLP_TREE_LANE_PERMUTATION (node).create (SLP_TREE_LANES (node));\n \t      for (unsigned j = 0; j < SLP_TREE_LANES (node); ++j)\n \t\tSLP_TREE_LANE_PERMUTATION (node)\n-\t\t  .quick_push (std::make_pair (0, perms[perm][j]));\n+\t\t  .quick_push (std::make_pair (0, perms[perm_in][j]));\n \t      SLP_TREE_CODE (node) = VEC_PERM_EXPR;\n \t    }\n \t}\n-      else\n+      else if (perm_in > 0) /* perm_in == perm_out */\n \t{\n \t  /* Apply the reverse permutation to our stmts.  */\n-\t  vect_slp_permute (perms[perm],\n+\t  vect_slp_permute (perms[perm_in],\n \t\t\t    SLP_TREE_SCALAR_STMTS (node), true);\n-\t  /* And to the load permutation, which we can simply\n+\t  /* And to the lane/load permutation, which we can simply\n \t     make regular by design.  */\n \t  if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \t    {\n+\t      gcc_assert (!SLP_TREE_LANE_PERMUTATION (node).exists ());\n \t      /* ???  When we handle non-bijective permutes the idea\n \t\t is that we can force the load-permutation to be\n \t\t { min, min + 1, min + 2, ... max }.  But then the\n \t\t scalar defs might no longer match the lane content\n \t\t which means wrong-code with live lane vectorization.\n \t\t So we possibly have to have NULL entries for those.  */\n-\t      vect_slp_permute (perms[perm],\n+\t      vect_slp_permute (perms[perm_in],\n \t\t\t\tSLP_TREE_LOAD_PERMUTATION (node), true);\n \t    }\n+\t  else if (SLP_TREE_LANE_PERMUTATION (node).exists ())\n+\t    gcc_unreachable ();\n \t}\n     }\n \n@@ -3991,14 +4023,14 @@ vect_optimize_slp (vec_info *vinfo)\n \t    }\n \t  else if (SLP_TREE_LOAD_PERMUTATION (old).exists ()\n \t\t   && SLP_TREE_REF_COUNT (old) == 1\n-\t\t   && vertices[old->vertex].materialize)\n+\t\t   && vertices[old->vertex].get_perm_materialized () != 0)\n \t    {\n \t      /* ???  For loads the situation is more complex since\n \t\t we can't modify the permute in place in case the\n \t\t node is used multiple times.  In fact for loads this\n \t\t should be somehow handled in the propagation engine.  */\n \t      /* Apply the reverse permutation to our stmts.  */\n-\t      int perm = vertices[old->vertex].get_perm_in ();\n+\t      int perm = vertices[old->vertex].get_perm_materialized ();\n \t      vect_slp_permute (perms[perm],\n \t\t\t\tSLP_TREE_SCALAR_STMTS (old), true);\n \t      vect_slp_permute (perms[perm],"}]}