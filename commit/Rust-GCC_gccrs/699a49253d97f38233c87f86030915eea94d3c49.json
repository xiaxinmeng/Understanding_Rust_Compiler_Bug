{"sha": "699a49253d97f38233c87f86030915eea94d3c49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk5YTQ5MjUzZDk3ZjM4MjMzYzg3Zjg2MDMwOTE1ZWVhOTRkM2M0OQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-10-28T09:47:45Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-10-28T09:47:45Z"}, "message": "arm.c (arm_output_epilogue): When using a frame pointer...\n\n* arm.c (arm_output_epilogue): When using a frame pointer, don't emit\nan extra stack adjustment insn if the stack pointer is already\npointing at the right place.\n(use_return_insn): Allow a return insn to be used when we have a\nframe pointer if the stack pointer is in the right place.\n(output_return_instruction): Handle it.\n\nFrom-SVN: r73003", "tree": {"sha": "be6a3846aefab2d821be31d2841191f89592989d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be6a3846aefab2d821be31d2841191f89592989d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/699a49253d97f38233c87f86030915eea94d3c49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/699a49253d97f38233c87f86030915eea94d3c49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/699a49253d97f38233c87f86030915eea94d3c49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/699a49253d97f38233c87f86030915eea94d3c49/comments", "author": null, "committer": null, "parents": [{"sha": "578e81709125628d0e641343de40e5f48b394f65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/578e81709125628d0e641343de40e5f48b394f65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/578e81709125628d0e641343de40e5f48b394f65"}], "stats": {"total": 48, "additions": 30, "deletions": 18}, "files": [{"sha": "a9f43073fc4661b8136d5086078be3d7e811e45e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699a49253d97f38233c87f86030915eea94d3c49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699a49253d97f38233c87f86030915eea94d3c49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=699a49253d97f38233c87f86030915eea94d3c49", "patch": "@@ -1,3 +1,12 @@\n+2003-10-28  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_output_epilogue): When using a frame pointer, don't emit\n+\tan extra stack adjustment insn if the stack pointer is already \n+\tpointing at the right place.\n+\t(use_return_insn): Allow a return insn to be used when we have a\n+\tframe pointer if the stack pointer is in the right place.\n+\t(output_return_instruction): Handle it.\n+\n 2003-10-28  Andreas Jaeger  <aj@suse.de>\n \n \t* ggc-zone.c (check_cookies): Add missing variable."}, {"sha": "cab1d96fd4f5e13b2580f7345cec8c4d219f0fee", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/699a49253d97f38233c87f86030915eea94d3c49/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/699a49253d97f38233c87f86030915eea94d3c49/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=699a49253d97f38233c87f86030915eea94d3c49", "patch": "@@ -1015,10 +1015,6 @@ use_return_insn (int iscond)\n   if (!reload_completed)\n     return 0;\n \n-  /* We need two instructions when there's a frame pointer. */\n-  if (frame_pointer_needed)\n-    return 0;\n-  \n   func_type = arm_current_func_type ();\n \n   /* Naked functions and volatile functions need special\n@@ -1033,11 +1029,12 @@ use_return_insn (int iscond)\n   /* As do variadic functions.  */\n   if (current_function_pretend_args_size\n       || cfun->machine->uses_anonymous_args\n-      /* Of if the function calls __builtin_eh_return () */\n+      /* Or if the function calls __builtin_eh_return () */\n       || ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER\n-      /* Or if there is no frame pointer and there is a stack adjustment.  */\n-      || ((arm_get_frame_size () + current_function_outgoing_args_size != 0)\n-\t  && !frame_pointer_needed))\n+      /* Or if the function calls alloca */\n+      || current_function_calls_alloca\n+      /* Or if there is a stack adjustment.  */\n+      || (arm_get_frame_size () + current_function_outgoing_args_size != 0))\n     return 0;\n \n   saved_int_regs = arm_compute_save_reg_mask ();\n@@ -8098,7 +8095,7 @@ arm_compute_save_reg_mask (void)\n   return save_reg_mask;\n }\n \n-/* Generate a function exit sequence.  If REALLY_RETURN is true, then do\n+/* Generate a function exit sequence.  If REALLY_RETURN is false, then do\n    everything bar the final return instruction.  */\n const char *\n output_return_instruction (rtx operand, int really_return, int reverse)\n@@ -8116,8 +8113,9 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \n   if (IS_VOLATILE (func_type) && TARGET_ABORT_NORETURN)\n     {\n-      /* If this function was declared non-returning, and we have found a tail \n-\t call, then we have to trust that the called function won't return.  */\n+      /* If this function was declared non-returning, and we have\n+\t found a tail call, then we have to trust that the called\n+\t function won't return.  */\n       if (really_return)\n \t{\n \t  rtx ops[2];\n@@ -8189,10 +8187,11 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t  char *p;\n \t  int first = 1;\n \n-\t  /* Generate the load multiple instruction to restore the registers.  */\n-\t  if (frame_pointer_needed)\n-\t    sprintf (instr, \"ldm%sea\\t%%|fp, {\", conditional);\n-\t  else if (live_regs_mask & (1 << SP_REGNUM))\n+\t  /* Generate the load multiple instruction to restore the\n+\t     registers.  Note we can get here, even if\n+\t     frame_pointer_needed is true, but only if sp already\n+\t     points to the base of the saved core registers.  */\n+\t  if (live_regs_mask & (1 << SP_REGNUM))\n \t    sprintf (instr, \"ldm%sfd\\t%%|sp, {\", conditional);\n \t  else\n \t    sprintf (instr, \"ldm%sfd\\t%%|sp!, {\", conditional);\n@@ -8552,9 +8551,13 @@ arm_output_epilogue (int really_return)\n          longer indicate the safe area of stack, and we can get stack\n          corruption.  Using SP as the base register means that it will\n          be reset correctly to the original value, should an interrupt\n-         occur.  */\n-      asm_fprintf (f, \"\\tsub\\t%r,%r,#%d\\n\", SP_REGNUM, FP_REGNUM,\n-\t\t   4 * bit_count (saved_regs_mask));\n+         occur.  If the stack pointer already points at the right\n+         place, then omit the subtraction.  */\n+      if (((frame_size + current_function_outgoing_args_size + floats_offset)\n+\t   != 4 * (1 + (int) bit_count (saved_regs_mask)))\n+\t  || current_function_calls_alloca)\n+\tasm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\", SP_REGNUM, FP_REGNUM,\n+\t\t     4 * bit_count (saved_regs_mask));\n       print_multi_reg (f, \"ldmfd\\t%r\", SP_REGNUM, saved_regs_mask);\n \n       if (IS_INTERRUPT (func_type))"}]}