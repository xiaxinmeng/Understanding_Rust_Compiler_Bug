{"sha": "01d412ef36f56c6961858f4d3d395d000e3f1c06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkNDEyZWYzNmY1NmM2OTYxODU4ZjRkM2QzOTVkMDAwZTNmMWMwNg==", "commit": {"author": {"name": "Mike Crowe", "email": "mac@mcrowe.com", "date": "2020-09-11T13:25:00Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-11T13:25:00Z"}, "message": "libstdc++: Support futex waiting on chrono::steady_clock directly\n\nThe user-visible effect of this change is for std::future::wait_until to\nuse CLOCK_MONOTONIC when passed a timeout of std::chrono::steady_clock\ntype.  This makes it immune to any changes made to the system clock\nCLOCK_REALTIME.\n\nAdd an overload of __atomic_futex_unsigned::_M_load_and_text_until_impl\nthat accepts a std::chrono::steady_clock, and correctly passes this\nthrough to __atomic_futex_unsigned_base::_M_futex_wait_until_steady\nwhich uses CLOCK_MONOTONIC for the timeout within the futex system call.\nThese functions are mostly just copies of the std::chrono::system_clock\nversions with small tweaks.\n\nPrior to this commit, a std::chrono::steady timeout would be converted\nvia std::chrono::system_clock which risks reducing or increasing the\ntimeout if someone changes CLOCK_REALTIME whilst the wait is happening.\n(The commit immediately prior to this one increases the window of\nopportunity for that from a short period during the calculation of a\nrelative timeout, to the entire duration of the wait.)\n\nFUTEX_WAIT_BITSET was added in kernel v2.6.25.  If futex reports ENOSYS\nto indicate that this operation is not supported then the code falls\nback to using clock_gettime(2) to calculate a relative time to wait for.\n\nI believe that I've added this functionality in a way that it doesn't\nbreak ABI compatibility, but that has made it more verbose and less type\nsafe.  I believe that it would be better to maintain the timeout as an\ninstance of the correct clock type all the way down to a single\n_M_futex_wait_until function with an overload for each clock.  The\ncurrent scheme of separating out the seconds and nanoseconds early risks\naccidentally calling the wait function for the wrong clock.\nUnfortunately, doing this would break code that compiled against the old\nheader.\n\nlibstdc++-v3/ChangeLog:\n\n\t* config/abi/pre/gnu.ver: Update for addition of\n\t__atomic_futex_unsigned_base::_M_futex_wait_until_steady.\n\t* include/bits/atomic_futex.h (__atomic_futex_unsigned_base):\n\tAdd comments to clarify that _M_futex_wait_until and\n\t_M_load_and_test_until use CLOCK_REALTIME.\n\t(__atomic_futex_unsigned_base::_M_futex_wait_until_steady)\n\t(__atomic_futex_unsigned_base::_M_load_and_text_until_steady):\n\tNew member functions that use CLOCK_MONOTONIC.\n\t(__atomic_futex_unsigned_base::_M_load_and_test_until_impl)\n\t(__atomic_futex_unsigned_base::_M_load_when_equal_until): Add\n\toverloads that accept a steady_clock time_point and use the\n\tnew member functions.\n\t* src/c++11/futex.cc: Include headers required for\n\tclock_gettime.\n\t(futex_clock_monotonic_flag): New constant to tell futex to\n\tuse CLOCK_MONOTONIC to match existing futex_clock_realtime_flag.\n\t(futex_clock_monotonic_unavailable): New global to store the\n\tresult of trying to use CLOCK_MONOTONIC.\n\t(__atomic_futex_unsigned_base::_M_futex_wait_until_steady): Add\n\tnew variant of _M_futex_wait_until that uses CLOCK_MONOTONIC to\n\tsupport waiting using steady_clock.", "tree": {"sha": "697e8fb22e6e0d068d0503c2e09fc2eba98b7446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/697e8fb22e6e0d068d0503c2e09fc2eba98b7446"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01d412ef36f56c6961858f4d3d395d000e3f1c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d412ef36f56c6961858f4d3d395d000e3f1c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d412ef36f56c6961858f4d3d395d000e3f1c06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d412ef36f56c6961858f4d3d395d000e3f1c06/comments", "author": {"login": "mikecrowe", "id": 93615, "node_id": "MDQ6VXNlcjkzNjE1", "avatar_url": "https://avatars.githubusercontent.com/u/93615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikecrowe", "html_url": "https://github.com/mikecrowe", "followers_url": "https://api.github.com/users/mikecrowe/followers", "following_url": "https://api.github.com/users/mikecrowe/following{/other_user}", "gists_url": "https://api.github.com/users/mikecrowe/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikecrowe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikecrowe/subscriptions", "organizations_url": "https://api.github.com/users/mikecrowe/orgs", "repos_url": "https://api.github.com/users/mikecrowe/repos", "events_url": "https://api.github.com/users/mikecrowe/events{/privacy}", "received_events_url": "https://api.github.com/users/mikecrowe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bad23ceec0bfc9fea7c3da10b187366052de369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bad23ceec0bfc9fea7c3da10b187366052de369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bad23ceec0bfc9fea7c3da10b187366052de369"}], "stats": {"total": 159, "additions": 154, "deletions": 5}, "files": [{"sha": "87a48a21f5310fbaeec16236c62f893cc1f8a1d7", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d412ef36f56c6961858f4d3d395d000e3f1c06/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d412ef36f56c6961858f4d3d395d000e3f1c06/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=01d412ef36f56c6961858f4d3d395d000e3f1c06", "patch": "@@ -1922,10 +1922,9 @@ GLIBCXX_3.4.21 {\n     _ZNSt7codecvtID[is]c*;\n     _ZT[ISV]St7codecvtID[is]c*E;\n \n-    extern \"C++\"\n-    {\n-      std::__atomic_futex_unsigned_base*;\n-    };\n+    # std::__atomic_futex_unsigned_base members\n+    _ZNSt28__atomic_futex_unsigned_base19_M_futex_notify_all*;\n+    _ZNSt28__atomic_futex_unsigned_base19_M_futex_wait_until*;\n \n     # codecvt_utf8 etc.\n     _ZNKSt19__codecvt_utf8_base*;\n@@ -2320,6 +2319,9 @@ GLIBCXX_3.4.29 {\n     _ZNSbIwSt11char_traitsIwESaIwEE7reserveEv;\n     _ZNSt7__cxx1112basic_stringI[cw]St11char_traitsI[cw]ESaI[cw]EE7reserveEv;\n \n+    # std::__atomic_futex_unsigned_base::_M_futex_wait_until_steady\n+    _ZNSt28__atomic_futex_unsigned_base26_M_futex_wait_until_steady*;\n+\n } GLIBCXX_3.4.28;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "507c5c9061040ed5f0a1e3aa7e76998030b56ff6", "filename": "libstdc++-v3/include/bits/atomic_futex.h", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d412ef36f56c6961858f4d3d395d000e3f1c06/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d412ef36f56c6961858f4d3d395d000e3f1c06/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h?ref=01d412ef36f56c6961858f4d3d395d000e3f1c06", "patch": "@@ -52,11 +52,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #if defined(_GLIBCXX_HAVE_LINUX_FUTEX) && ATOMIC_INT_LOCK_FREE > 1\n   struct __atomic_futex_unsigned_base\n   {\n-    // Returns false iff a timeout occurred.\n+    // __s and __ns are measured against CLOCK_REALTIME. Returns false\n+    // iff a timeout occurred.\n     bool\n     _M_futex_wait_until(unsigned *__addr, unsigned __val, bool __has_timeout,\n \tchrono::seconds __s, chrono::nanoseconds __ns);\n \n+    // __s and __ns are measured against CLOCK_MONOTONIC. Returns\n+    // false iff a timeout occurred.\n+    bool\n+    _M_futex_wait_until_steady(unsigned *__addr, unsigned __val,\n+\tbool __has_timeout, chrono::seconds __s, chrono::nanoseconds __ns);\n+\n     // This can be executed after the object has been destroyed.\n     static void _M_futex_notify_all(unsigned* __addr);\n   };\n@@ -86,6 +93,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     // value if equal is false.\n     // The assumed value is the caller's assumption about the current value\n     // when making the call.\n+    // __s and __ns are measured against CLOCK_REALTIME.\n     unsigned\n     _M_load_and_test_until(unsigned __assumed, unsigned __operand,\n \tbool __equal, memory_order __mo, bool __has_timeout,\n@@ -110,6 +118,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n+    // If a timeout occurs, returns a current value after the timeout;\n+    // otherwise, returns the operand's value if equal is true or a different\n+    // value if equal is false.\n+    // The assumed value is the caller's assumption about the current value\n+    // when making the call.\n+    // __s and __ns are measured against CLOCK_MONOTONIC.\n+    unsigned\n+    _M_load_and_test_until_steady(unsigned __assumed, unsigned __operand,\n+\tbool __equal, memory_order __mo, bool __has_timeout,\n+\tchrono::seconds __s, chrono::nanoseconds __ns)\n+    {\n+      for (;;)\n+\t{\n+\t  // Don't bother checking the value again because we expect the caller\n+\t  // to have done it recently.\n+\t  // memory_order_relaxed is sufficient because we can rely on just the\n+\t  // modification order (store_notify uses an atomic RMW operation too),\n+\t  // and the futex syscalls synchronize between themselves.\n+\t  _M_data.fetch_or(_Waiter_bit, memory_order_relaxed);\n+\t  bool __ret = _M_futex_wait_until_steady((unsigned*)(void*)&_M_data,\n+\t\t\t\t\t   __assumed | _Waiter_bit,\n+\t\t\t\t\t   __has_timeout, __s, __ns);\n+\t  // Fetch the current value after waiting (clears _Waiter_bit).\n+\t  __assumed = _M_load(__mo);\n+\t  if (!__ret || ((__operand == __assumed) == __equal))\n+\t    return __assumed;\n+\t  // TODO adapt wait time\n+\t}\n+    }\n+\n     // Returns the operand's value if equal is true or a different value if\n     // equal is false.\n     // The assumed value is the caller's assumption about the current value\n@@ -140,6 +178,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  true, __s.time_since_epoch(), __ns);\n     }\n \n+    template<typename _Dur>\n+    unsigned\n+    _M_load_and_test_until_impl(unsigned __assumed, unsigned __operand,\n+\tbool __equal, memory_order __mo,\n+\tconst chrono::time_point<std::chrono::steady_clock, _Dur>& __atime)\n+    {\n+      auto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+      auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+      // XXX correct?\n+      return _M_load_and_test_until_steady(__assumed, __operand, __equal, __mo,\n+\t  true, __s.time_since_epoch(), __ns);\n+    }\n+\n   public:\n \n     _GLIBCXX_ALWAYS_INLINE unsigned\n@@ -200,6 +251,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return (__i & ~_Waiter_bit) == __val;\n     }\n \n+    // Returns false iff a timeout occurred.\n+    template<typename _Duration>\n+    _GLIBCXX_ALWAYS_INLINE bool\n+    _M_load_when_equal_until(unsigned __val, memory_order __mo,\n+\tconst chrono::time_point<std::chrono::steady_clock, _Duration>& __atime)\n+    {\n+      unsigned __i = _M_load(__mo);\n+      if ((__i & ~_Waiter_bit) == __val)\n+\treturn true;\n+      // TODO Spin-wait first.  Ignore effect on timeout.\n+      __i = _M_load_and_test_until_impl(__i, __val, true, __mo, __atime);\n+      return (__i & ~_Waiter_bit) == __val;\n+    }\n+\n     _GLIBCXX_ALWAYS_INLINE void\n     _M_store_notify_all(unsigned __val, memory_order __mo)\n     {"}, {"sha": "0331bd6df64f43a9ff22cd42f2b980c50178ccae", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d412ef36f56c6961858f4d3d395d000e3f1c06/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d412ef36f56c6961858f4d3d395d000e3f1c06/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=01d412ef36f56c6961858f4d3d395d000e3f1c06", "patch": "@@ -33,16 +33,23 @@\n #include <errno.h>\n #include <debug/debug.h>\n \n+#ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n+#include <unistd.h>\n+#include <sys/syscall.h>\n+#endif\n+\n // Constants for the wait/wake futex syscall operations\n const unsigned futex_wait_op = 0;\n const unsigned futex_wait_bitset_op = 9;\n+const unsigned futex_clock_monotonic_flag = 0;\n const unsigned futex_clock_realtime_flag = 256;\n const unsigned futex_bitset_match_any = ~0;\n const unsigned futex_wake_op = 1;\n \n namespace\n {\n   std::atomic<bool> futex_clock_realtime_unavailable;\n+  std::atomic<bool> futex_clock_monotonic_unavailable;\n }\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -121,6 +128,81 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n   }\n \n+  bool\n+  __atomic_futex_unsigned_base::_M_futex_wait_until_steady(unsigned *__addr,\n+      unsigned __val,\n+      bool __has_timeout, chrono::seconds __s, chrono::nanoseconds __ns)\n+  {\n+    if (!__has_timeout)\n+      {\n+\t// Ignore whether we actually succeeded to block because at worst,\n+\t// we will fall back to spin-waiting.  The only thing we could do\n+\t// here on errors is abort.\n+\tint ret __attribute__((unused));\n+\tret = syscall (SYS_futex, __addr, futex_wait_op, __val, nullptr);\n+\t__glibcxx_assert(ret == 0 || errno == EINTR || errno == EAGAIN);\n+\treturn true;\n+      }\n+    else\n+      {\n+\tif (!futex_clock_monotonic_unavailable.load(std::memory_order_relaxed))\n+\t  {\n+\t    struct timespec rt;\n+\t    rt.tv_sec = __s.count();\n+\t    rt.tv_nsec = __ns.count();\n+\n+\t    if (syscall (SYS_futex, __addr,\n+\t\t\t futex_wait_bitset_op | futex_clock_monotonic_flag,\n+\t\t\t __val, &rt, nullptr, futex_bitset_match_any) == -1)\n+\t      {\n+\t\t__glibcxx_assert(errno == EINTR || errno == EAGAIN\n+\t\t\t\t || errno == ETIMEDOUT || errno == ENOSYS);\n+\t\tif (errno == ETIMEDOUT)\n+\t\t  return false;\n+\t\telse if (errno == ENOSYS)\n+\t\t  {\n+\t\t    futex_clock_monotonic_unavailable.store(true,\n+\t\t\t\t\t\t    std::memory_order_relaxed);\n+\t\t    // Fall through to legacy implementation if the system\n+\t\t    // call is unavailable.\n+\t\t  }\n+\t\telse\n+\t\t  return true;\n+\t      }\n+\t  }\n+\n+\t// We only get to here if futex_clock_monotonic_unavailable was\n+\t// true or has just been set to true.\n+\tstruct timespec ts;\n+#ifdef _GLIBCXX_USE_CLOCK_GETTIME_SYSCALL\n+\tsyscall(SYS_clock_gettime, CLOCK_MONOTONIC, &ts);\n+#else\n+\tclock_gettime(CLOCK_MONOTONIC, &ts);\n+#endif\n+\t// Convert the absolute timeout value to a relative timeout\n+\tstruct timespec rt;\n+\trt.tv_sec = __s.count() - ts.tv_sec;\n+\trt.tv_nsec = __ns.count() - ts.tv_nsec;\n+\tif (rt.tv_nsec < 0)\n+\t  {\n+\t    rt.tv_nsec += 1000000000;\n+\t    --rt.tv_sec;\n+\t  }\n+\t// Did we already time out?\n+\tif (rt.tv_sec < 0)\n+\t  return false;\n+\n+\tif (syscall (SYS_futex, __addr, futex_wait_op, __val, &rt) == -1)\n+\t  {\n+\t    __glibcxx_assert(errno == EINTR || errno == EAGAIN\n+\t\t\t     || errno == ETIMEDOUT);\n+\t    if (errno == ETIMEDOUT)\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+  }\n+\n   void\n   __atomic_futex_unsigned_base::_M_futex_notify_all(unsigned* __addr)\n   {"}]}