{"sha": "721c3b4275799e26710b77ffa94e8c971369fc06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIxYzNiNDI3NTc5OWUyNjcxMGI3N2ZmYTk0ZThjOTcxMzY5ZmMwNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-24T06:15:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-24T06:15:04Z"}, "message": "cp-tree.h (lang_decl_flags): Rename mutable_flag to uninlinable and bitfield to tinfo_fn_p.\n\n\t* cp-tree.h (lang_decl_flags): Rename mutable_flag to uninlinable\n\tand bitfield to tinfo_fn_p.\n\t(DECL_TINFO_FN_P): Adjust.\n\t(SET_DECL_TINFO_FN_P): Likewise.\n\t(DECL_MUTABLE_P): Likewise.\n\t(DECL_C_BIT_FIELD): Likewise.\n\t(SET_DECL_C_BIT_FIELD): Likewise.\n\t(CLEAR_DECL_C_BIT_FIELD): Likewise.\n\t(DECL_UNINLINABLE): Likewise.\n\t* class.c (alter_access): Call retrofit_lang_decl if ncessary.\n\t(handle_using_decl): Remove assertion.\n\t(build_vtbl_or_vbase_field): Use build_decl, not build_lang_decl,\n\tto build FIELD_DECLs.\n\t(build_base_field): Likewise.\n\t(layout_class_type): Likewise.\n\t* decl.c (init_decl_processing): Likewise.\n\t(build_ptrmemfunc_type): Likewise.\n\t(grokdeclarator): Likewise.\n\t* decl2.c (grok_x_components): Likewise.\n\t* except.c (call_eh_info): Likewise.\n\t* init.c (init_init_processing): Likewise.\n\t* rtti.c (expand_class_desc): Likewise.\n\t(create_pseudo_type_info): Likewise.\n\t(get_vmi_pseudo_type_info): Likewise.\n\t(create_tinfo_types): Likewise.\n\t* ptree.c (print_lang_decl): Adjust.\n\t* typeck.c (build_component_ref): Don't check DECL_LANG_SPECIFIC\n\tbefore checking DECL_MUTABLE_P.\n\nFrom-SVN: r34125", "tree": {"sha": "8e2371cfca8f35a1de18c2cef46477b400969c19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e2371cfca8f35a1de18c2cef46477b400969c19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/721c3b4275799e26710b77ffa94e8c971369fc06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/721c3b4275799e26710b77ffa94e8c971369fc06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/721c3b4275799e26710b77ffa94e8c971369fc06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/721c3b4275799e26710b77ffa94e8c971369fc06/comments", "author": null, "committer": null, "parents": [{"sha": "d6c6b5531ee200f0773cd1666160380785557161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c6b5531ee200f0773cd1666160380785557161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6c6b5531ee200f0773cd1666160380785557161"}], "stats": {"total": 200, "additions": 117, "deletions": 83}, "files": [{"sha": "97b525dc4e84a2299f62519043cd8f91620399ad", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -1,5 +1,34 @@\n 2000-05-23  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (lang_decl_flags): Rename mutable_flag to uninlinable\n+\tand bitfield to tinfo_fn_p.\n+\t(DECL_TINFO_FN_P): Adjust.\n+\t(SET_DECL_TINFO_FN_P): Likewise.\n+\t(DECL_MUTABLE_P): Likewise.\n+\t(DECL_C_BIT_FIELD): Likewise.\n+\t(SET_DECL_C_BIT_FIELD): Likewise.\n+\t(CLEAR_DECL_C_BIT_FIELD): Likewise.\n+\t(DECL_UNINLINABLE): Likewise.\n+\t* class.c (alter_access): Call retrofit_lang_decl if ncessary.\n+\t(handle_using_decl): Remove assertion.\n+\t(build_vtbl_or_vbase_field): Use build_decl, not build_lang_decl,\n+\tto build FIELD_DECLs.\n+\t(build_base_field): Likewise.\n+\t(layout_class_type): Likewise.\n+\t* decl.c (init_decl_processing): Likewise.\n+\t(build_ptrmemfunc_type): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t* decl2.c (grok_x_components): Likewise.\n+\t* except.c (call_eh_info): Likewise.\n+\t* init.c (init_init_processing): Likewise.\n+\t* rtti.c (expand_class_desc): Likewise.\n+\t(create_pseudo_type_info): Likewise.\n+\t(get_vmi_pseudo_type_info): Likewise.\n+\t(create_tinfo_types): Likewise.\n+\t* ptree.c (print_lang_decl): Adjust.\n+\t* typeck.c (build_component_ref): Don't check DECL_LANG_SPECIFIC\n+\tbefore checking DECL_MUTABLE_P.\n+\t\n \t* decl2.c (maybe_retrofit_in_chrg): Don't create in-charge\n \tparameters for template functions.\n \t* pt.c (tsubst_decl): Make sure we call maybe_retrofit_in_chrg for"}, {"sha": "b86bac460c0688448718ded39a72cee9aefc69e7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -1435,7 +1435,12 @@ alter_access (t, fdecl, access)\n      tree fdecl;\n      tree access;\n {\n-  tree elem = purpose_member (t, DECL_ACCESS (fdecl));\n+  tree elem;\n+\n+  if (!DECL_LANG_SPECIFIC (fdecl))\n+    retrofit_lang_decl (fdecl);\n+\n+  elem = purpose_member (t, DECL_ACCESS (fdecl));\n   if (elem)\n     {\n       if (TREE_VALUE (elem) != access)\n@@ -1516,8 +1521,6 @@ handle_using_decl (using_decl, t)\n \n   if (is_overloaded_fn (fdecl))\n     flist = fdecl;\n-  else if (! DECL_LANG_SPECIFIC (fdecl))\n-    my_friendly_abort (20000221);\n \n   if (! old_value)\n     ;\n@@ -3540,7 +3543,7 @@ build_vtbl_or_vbase_field (name, assembler_name, type, class_type, fcontext,\n   *empty_p = 0;\n \n   /* Build the FIELD_DECL.  */\n-  field = build_lang_decl (FIELD_DECL, name, type);\n+  field = build_decl (FIELD_DECL, name, type);\n   DECL_ASSEMBLER_NAME (field) = assembler_name;\n   DECL_VIRTUAL_P (field) = 1;\n   DECL_ARTIFICIAL (field) = 1;\n@@ -3760,7 +3763,7 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n        location information.  */\n     return;\n   \n-  decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n+  decl = build_decl (FIELD_DECL, NULL_TREE, basetype);\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_FIELD_CONTEXT (decl) = rli->t;\n   DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n@@ -4755,7 +4758,7 @@ layout_class_type (t, empty_p, vfuns_p,\n     {\n       tree padding;\n \n-      padding = build_lang_decl (FIELD_DECL, NULL_TREE, char_type_node);\n+      padding = build_decl (FIELD_DECL, NULL_TREE, char_type_node);\n       place_field (rli, padding);\n       TYPE_NONCOPIED_PARTS (t) \n \t= tree_cons (NULL_TREE, padding, TYPE_NONCOPIED_PARTS (t));"}, {"sha": "d58a5a50fabbf9bd9872b73aa986504333c95e25", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -90,8 +90,10 @@ Boston, MA 02111-1307, USA.  */\n    0: DECL_ERROR_REPORTED (in VAR_DECL).\n       DECL_TEMPLATE_PARM_P (in CONST_DECL, TYPE_DECL, or TEMPLATE_DECL)\n       DECL_LOCAL_FUNCTION_P (in FUNCTION_DECL)\n+      DECL_MUTABLE_P (in FIELD_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n+      DECL_C_BITFIELD (in FIELD_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n@@ -1829,20 +1831,20 @@ struct lang_decl_flags\n   unsigned static_function : 1;\n   unsigned pure_virtual : 1;\n   unsigned has_in_charge_parm_p : 1;\n-  unsigned bitfield : 1;\n+  unsigned uninlinable : 1;\n \n-  unsigned mutable_flag : 1;\n   unsigned deferred : 1;\n   unsigned use_template : 2;\n   unsigned nonconverting : 1;\n   unsigned declared_inline : 1;\n   unsigned not_really_extern : 1;\n   unsigned needs_final_overrider : 1;\n-\n   unsigned defined_in_class : 1;\n+\n   unsigned pending_inline_p : 1;\n   unsigned global_ctor_p : 1;\n   unsigned global_dtor_p : 1;\n+  unsigned tinfo_fn_p : 1;\n   unsigned dummy : 4;\n \n   tree context;\n@@ -1989,11 +1991,11 @@ struct lang_decl\n #define DECL_TINFO_FN_P(NODE) \t\t\t\t\t\\\n   (TREE_CODE (NODE) == FUNCTION_DECL\t\t\t\t\\\n    && DECL_ARTIFICIAL (NODE)\t\t\t\t\t\\\n-   && DECL_LANG_SPECIFIC(NODE)->decl_flags.mutable_flag)\n+   && DECL_LANG_SPECIFIC(NODE)->decl_flags.tinfo_fn_p)\n \n /* Mark NODE as a type-info function.  */\n #define SET_DECL_TINFO_FN_P(NODE) \\\n-  (DECL_LANG_SPECIFIC((NODE))->decl_flags.mutable_flag = 1)\n+  (DECL_LANG_SPECIFIC((NODE))->decl_flags.tinfo_fn_p = 1)\n \n /* Nonzero if NODE is an overloaded `operator delete[]' function.  */\n #define DECL_ARRAY_DELETE_OPERATOR_P(NODE) \\\n@@ -2055,7 +2057,7 @@ struct lang_decl\n \n /* Nonzero for _DECL means that this member object type\n    is mutable.  */\n-#define DECL_MUTABLE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.mutable_flag)\n+#define DECL_MUTABLE_P(NODE) (DECL_LANG_FLAG_0 (NODE))\n \n /* Nonzero for _DECL means that this constructor is a non-converting\n    constructor.  */\n@@ -2427,16 +2429,15 @@ extern int flag_new_for_scope;\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n #define DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))\\\n-   && DECL_LANG_SPECIFIC (NODE)->decl_flags.bitfield)\n+  (DECL_LANG_FLAG_1 (FIELD_DECL_CHECK (NODE)) == 1)\n #define SET_DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->decl_flags.bitfield = 1)\n+  (DECL_LANG_FLAG_1 (FIELD_DECL_CHECK (NODE)) = 1)\n #define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n-  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->decl_flags.bitfield = 0)\n+  (DECL_LANG_FLAG_1 (FIELD_DECL_CHECK (NODE)) = 0)\n \n /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n #define DECL_UNINLINABLE(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.bitfield)\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.uninlinable)\n \n #define INTEGRAL_CODE_P(CODE) \\\n   (CODE == INTEGER_TYPE || CODE == ENUMERAL_TYPE || CODE == BOOLEAN_TYPE)"}, {"sha": "41cdb8cfed5c83b01d03a2166cb5b855e139b29d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -6384,12 +6384,12 @@ init_decl_processing ()\n   else\n     {\n       vtable_entry_type = make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_lang_decl (FIELD_DECL, delta_identifier,\n-\t\t\t\t   delta_type_node);\n-      fields[1] = build_lang_decl (FIELD_DECL, index_identifier,\n-\t\t\t\t   delta_type_node);\n-      fields[2] = build_lang_decl (FIELD_DECL, pfn_identifier,\n-\t\t\t\t   ptr_type_node);\n+      fields[0] = build_decl (FIELD_DECL, delta_identifier,\n+\t\t\t      delta_type_node);\n+      fields[1] = build_decl (FIELD_DECL, index_identifier,\n+\t\t\t      delta_type_node);\n+      fields[2] = build_decl (FIELD_DECL, pfn_identifier,\n+\t\t\t      ptr_type_node);\n       finish_builtin_type (vtable_entry_type, VTBL_PTR_TYPE, fields, 2,\n \t\t\t   double_type_node);\n \n@@ -9031,24 +9031,24 @@ build_ptrmemfunc_type (type)\n     {\n       u = make_aggr_type (UNION_TYPE);\n       SET_IS_AGGR_TYPE (u, 0);\n-      fields[0] = build_lang_decl (FIELD_DECL, pfn_identifier, type);\n-      fields[1] = build_lang_decl (FIELD_DECL, delta2_identifier,\n-\t\t\t\t   delta_type_node);\n+      fields[0] = build_decl (FIELD_DECL, pfn_identifier, type);\n+      fields[1] = build_decl (FIELD_DECL, delta2_identifier,\n+\t\t\t      delta_type_node);\n       finish_builtin_type (u, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n       TYPE_NAME (u) = NULL_TREE;\n \n-      fields[0] = build_lang_decl (FIELD_DECL, delta_identifier,\n-\t\t\t\t   delta_type_node);\n-      fields[1] = build_lang_decl (FIELD_DECL, index_identifier,\n-\t\t\t\t   delta_type_node);\n-      fields[2] = build_lang_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n+      fields[0] = build_decl (FIELD_DECL, delta_identifier,\n+\t\t\t      delta_type_node);\n+      fields[1] = build_decl (FIELD_DECL, index_identifier,\n+\t\t\t      delta_type_node);\n+      fields[2] = build_decl (FIELD_DECL, pfn_or_delta2_identifier, u);\n       finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n     }\n   else\n     {\n-      fields[0] = build_lang_decl (FIELD_DECL, pfn_identifier, type);\n-      fields[1] = build_lang_decl (FIELD_DECL, delta_identifier,\n-\t\t\t\t   delta_type_node);\n+      fields[0] = build_decl (FIELD_DECL, pfn_identifier, type);\n+      fields[1] = build_decl (FIELD_DECL, delta_identifier,\n+\t\t\t      delta_type_node);\n       finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n     }\n \n@@ -11411,7 +11411,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \t    else\n \t      {\n-\t\tdecl = build_lang_decl (FIELD_DECL, declarator, type);\n+\t\tdecl = build_decl (FIELD_DECL, declarator, type);\n \t\tif (RIDBIT_SETP (RID_MUTABLE, specbits))\n \t\t  {\n \t\t    DECL_MUTABLE_P (decl) = 1;"}, {"sha": "f97397f1cfdca847f2a632297b4baad1457f71e8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -914,7 +914,7 @@ grok_x_components (specs)\n     return;\n \n   fixup_anonymous_aggr (t);\n-  finish_member_declaration (build_lang_decl (FIELD_DECL, NULL_TREE, t)); \n+  finish_member_declaration (build_decl (FIELD_DECL, NULL_TREE, t)); \n \n   /* Ignore any inline function definitions in the anonymous union\n      since an anonymous union may not have function members.  */"}, {"sha": "ca73686a9c0ba29c5c2271c1f28523771400f2c9", "filename": "gcc/cp/except.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -210,46 +210,46 @@ call_eh_info ()\n       /* struct cp_eh_info.  This must match exception.cc.  Note that this\n \t type is not pushed anywhere.  */\n       t1= make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_lang_decl (FIELD_DECL, \n+      fields[0] = build_decl (FIELD_DECL, \n                     get_identifier (\"handler_label\"), ptr_type_node);\n-      fields[1] = build_lang_decl (FIELD_DECL, \n+      fields[1] = build_decl (FIELD_DECL, \n                     get_identifier (\"dynamic_handler_chain\"), ptr_type_node);\n-      fields[2] = build_lang_decl (FIELD_DECL, \n+      fields[2] = build_decl (FIELD_DECL, \n                     get_identifier (\"info\"), ptr_type_node);\n-      fields[3] = build_lang_decl (FIELD_DECL, \n+      fields[3] = build_decl (FIELD_DECL, \n                     get_identifier (\"table_index\"), ptr_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n       finish_builtin_type (t1, \"eh_context\", fields, 3, ptr_type_node);\n       t1 = build_pointer_type (t1);\n \n       t1= make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_lang_decl (FIELD_DECL, \n+      fields[0] = build_decl (FIELD_DECL, \n                     get_identifier (\"match_function\"), ptr_type_node);\n-      fields[1] = build_lang_decl (FIELD_DECL, \n+      fields[1] = build_decl (FIELD_DECL, \n                     get_identifier (\"language\"), short_integer_type_node);\n-      fields[2] = build_lang_decl (FIELD_DECL, \n+      fields[2] = build_decl (FIELD_DECL, \n                     get_identifier (\"version\"), short_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */\n       finish_builtin_type (t1, \"__eh_info\", fields, 2, ptr_type_node);\n       t = make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_lang_decl (FIELD_DECL, \n-\t\t\t\t   get_identifier (\"eh_info\"), t1);\n-      fields[1] = build_lang_decl (FIELD_DECL, get_identifier (\"value\"),\n-\t\t\t\t   ptr_type_node);\n-      fields[2] = build_lang_decl (FIELD_DECL, get_identifier (\"type\"),\n-\t\t\t\t   ptr_type_node);\n-      fields[3] = build_lang_decl\n+      fields[0] = build_decl (FIELD_DECL, \n+\t\t\t      get_identifier (\"eh_info\"), t1);\n+      fields[1] = build_decl (FIELD_DECL, get_identifier (\"value\"),\n+\t\t\t      ptr_type_node);\n+      fields[2] = build_decl (FIELD_DECL, get_identifier (\"type\"),\n+\t\t\t      ptr_type_node);\n+      fields[3] = build_decl\n \t(FIELD_DECL, get_identifier (\"cleanup\"),\n \t build_pointer_type (build_function_type\n \t\t\t     (ptr_type_node, tree_cons\n \t\t\t      (NULL_TREE, ptr_type_node, void_list_node))));\n-      fields[4] = build_lang_decl (FIELD_DECL, get_identifier (\"caught\"),\n-\t\t\t\t   boolean_type_node);\n-      fields[5] = build_lang_decl (FIELD_DECL, get_identifier (\"next\"),\n-\t\t\t\t   build_pointer_type (t));\n-      fields[6] = build_lang_decl\n+      fields[4] = build_decl (FIELD_DECL, get_identifier (\"caught\"),\n+\t\t\t      boolean_type_node);\n+      fields[5] = build_decl (FIELD_DECL, get_identifier (\"next\"),\n+\t\t\t      build_pointer_type (t));\n+      fields[6] = build_decl\n \t(FIELD_DECL, get_identifier (\"handlers\"), long_integer_type_node);\n       /* N.B.: The fourth field LEN is expected to be\n \t the number of fields - 1, not the total number of fields.  */"}, {"sha": "aece8ed4da302829ffe7c897e9dafd10e71cbbc7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -68,7 +68,7 @@ void init_init_processing ()\n   /* Define the structure that holds header information for\n      arrays allocated via operator new.  */\n   BI_header_type = make_aggr_type (RECORD_TYPE);\n-  fields[0] = build_lang_decl (FIELD_DECL, nelts_identifier, sizetype);\n+  fields[0] = build_decl (FIELD_DECL, nelts_identifier, sizetype);\n \n   /* Use the biggest alignment supported by the target to prevent operator\n      new from returning misaligned pointers. */"}, {"sha": "d3cd45eceac77bd7908146d9297bbb2a9dcc0003", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -32,16 +32,17 @@ print_lang_decl (file, node, indent)\n      tree node;\n      int indent;\n {\n-  if (!DECL_LANG_SPECIFIC (node))\n-    return;\n-  /* A FIELD_DECL only has the flags structure, which we aren't displaying\n-     anyways.  */\n-  if (DECL_MUTABLE_P (node))\n+  if (TREE_CODE (node) == FIELD_DECL)\n     {\n-      indent_to (file, indent + 3);\n-      fprintf (file, \" mutable \");\n+      if (DECL_MUTABLE_P (node))\n+\t{\n+\t  indent_to (file, indent + 3);\n+\t  fprintf (file, \" mutable \");\n+\t}\n+      return;\n     }\n-  if (TREE_CODE (node) == FIELD_DECL)\n+\n+  if (!DECL_LANG_SPECIFIC (node))\n     return;\n   indent_to (file, indent + 3);\n   if (TREE_CODE (node) == FUNCTION_DECL"}, {"sha": "bde623f9eef694d50458c19794989338640ef5b0", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -942,23 +942,23 @@ expand_class_desc (tdecl, type)\n       base_desc_type_node = make_aggr_type (RECORD_TYPE);\n \n       /* Actually const __user_type_info * */\n-      fields [0] = build_lang_decl\n+      fields [0] = build_decl\n \t(FIELD_DECL, NULL_TREE,\n \t build_pointer_type (build_qualified_type\n \t\t\t     (type_info_type_node,\n \t\t\t      TYPE_QUAL_CONST)));\n-      fields [1] = build_lang_decl\n+      fields [1] = build_decl\n \t(FIELD_DECL, NULL_TREE, \n \t flag_new_abi ? intSI_type_node : unsigned_intSI_type_node);\n       DECL_BIT_FIELD (fields[1]) = 1;\n       DECL_SIZE (fields[1]) = bitsize_int (29);\n \n-      fields [2] = build_lang_decl (FIELD_DECL, NULL_TREE, boolean_type_node);\n+      fields [2] = build_decl (FIELD_DECL, NULL_TREE, boolean_type_node);\n       DECL_BIT_FIELD (fields[2]) = 1;\n       DECL_SIZE (fields[2]) = bitsize_one_node;\n \n       /* Actually enum access */\n-      fields [3] = build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node);\n+      fields [3] = build_decl (FIELD_DECL, NULL_TREE, integer_type_node);\n       DECL_BIT_FIELD (fields[3]) = 1;\n       DECL_SIZE (fields[3]) = bitsize_int (2);\n \n@@ -1758,7 +1758,7 @@ create_pseudo_type_info VPARAMS((const char *real_name, int ident, ...))\n     }\n \n   /* First field is the pseudo type_info base class. */\n-  fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n+  fields[0] = build_decl (FIELD_DECL, NULL_TREE, ti_desc_type_node);\n   \n   /* Now add the derived fields.  */\n   for (ix = 0; (field_decl = va_arg (ap, tree));)\n@@ -1808,9 +1808,9 @@ get_vmi_pseudo_type_info (num_bases)\n \n   desc = create_pseudo_type_info\n             (\"__vmi_class_type_info\", num_bases,\n-             build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-             build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-             build_lang_decl (FIELD_DECL, NULL_TREE, base_array),\n+             build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+             build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+             build_decl (FIELD_DECL, NULL_TREE, base_array),\n              NULL);\n \n   pop_nested_namespace (abi_node);\n@@ -1841,8 +1841,8 @@ create_tinfo_types ()\n     tree fields[2];\n \n     ti_desc_type_node = make_aggr_type (RECORD_TYPE);\n-    fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, const_ptr_type_node);\n-    fields[1] = build_lang_decl (FIELD_DECL, NULL_TREE, const_string_type_node);\n+    fields[0] = build_decl (FIELD_DECL, NULL_TREE, const_ptr_type_node);\n+    fields[1] = build_decl (FIELD_DECL, NULL_TREE, const_string_type_node);\n     finish_builtin_type (ti_desc_type_node, \"__type_info_pseudo\",\n                          fields, 1, ptr_type_node);\n     TYPE_HAS_CONSTRUCTOR (ti_desc_type_node) = 1;\n@@ -1857,8 +1857,8 @@ create_tinfo_types ()\n      and pointer to the pointed to type.  */\n   ptr_desc_type_node = create_pseudo_type_info\n       (\"__pointer_type_info\", 0,\n-       build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-       build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+       build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+       build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n        NULL);\n \n   /* Array, function and enum type_info. No additional fields. */\n@@ -1881,16 +1881,16 @@ create_tinfo_types ()\n      This is really a descendant of __class_type_info.  */\n   si_class_desc_type_node = create_pseudo_type_info\n            (\"__si_class_type_info\", 0,\n-            build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+            build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n             NULL);\n   \n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags. */\n   {\n     tree fields[2];\n     \n-    fields[0] = build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info);\n-    fields[1] = build_lang_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n+    fields[0] = build_decl (FIELD_DECL, NULL_TREE, ptr_type_info);\n+    fields[1] = build_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n     base_desc_type_node = make_aggr_type (RECORD_TYPE);\n     finish_builtin_type (base_desc_type_node, \"__base_class_type_info_pseudo\",\n                          fields, 1, ptr_type_node);\n@@ -1905,9 +1905,9 @@ create_tinfo_types ()\n      This is really a descendant of __pointer_type_info.  */\n   ptmd_desc_type_node = create_pseudo_type_info\n        (\"__pointer_to_member_type_info\", 0,\n-        build_lang_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-        build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n-        build_lang_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+        build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+        build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n+        build_decl (FIELD_DECL, NULL_TREE, ptr_type_info),\n         NULL);\n \n   pop_nested_namespace (abi_node);"}, {"sha": "c0927efbe00a52461601b3cd881ceb0da6c0079b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/721c3b4275799e26710b77ffa94e8c971369fc06/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=721c3b4275799e26710b77ffa94e8c971369fc06", "patch": "@@ -2242,7 +2242,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       /* A field is const (volatile) if the enclosing object, or the\n \t field itself, is const (volatile).  But, a mutable field is\n \t not const, even within a const object.  */\n-      if (DECL_LANG_SPECIFIC (field) && DECL_MUTABLE_P (field))\n+      if (DECL_MUTABLE_P (field))\n \ttype_quals &= ~TYPE_QUAL_CONST;\n       field_type = cp_build_qualified_type (field_type, type_quals);\n     }"}]}