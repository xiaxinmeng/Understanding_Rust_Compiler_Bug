{"sha": "ab36b554bd90e8db279d13b133369118814f13fb", "node_id": "C_kwDOANBUbNoAKGFiMzZiNTU0YmQ5MGU4ZGIyNzlkMTNiMTMzMzY5MTE4ODE0ZjEzZmI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-10T19:57:54Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-10T19:57:54Z"}, "message": "c++: constexpr base-to-derived conversion with offset 0 [PR103879]\n\nr12-136 made us canonicalize an object/offset pair with negative offset\ninto one with a nonnegative offset, by iteratively absorbing the\ninnermost component into the offset and stopping as soon as the offset\nbecomes nonnegative.\n\nThis patch strengthens this transformation by making it keep on absorbing\neven if the offset is already 0 as long as the innermost component is at\nposition 0 (and thus absorbing doesn't change the offset).  This lets us\naccept the two constexpr testcases below, which we'd previously reject\nessentially because cxx_fold_indirect_ref would be unable to resolve\n*(B*)&b.D123 (where D123 is the base A subobject at position 0) to just b.\n\n\tPR c++/103879\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (cxx_fold_indirect_ref): Split out object/offset\n\tcanonicalization step into a local lambda.  Strengthen it to\n\tabsorb more components at position 0.  Use it before both calls\n\tto cxx_fold_indirect_ref_1.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1y/constexpr-base2.C: New test.\n\t* g++.dg/cpp1y/constexpr-base2a.C: New test.", "tree": {"sha": "6c4abc9617dec954ecde670d2c7be09e5044953a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c4abc9617dec954ecde670d2c7be09e5044953a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab36b554bd90e8db279d13b133369118814f13fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab36b554bd90e8db279d13b133369118814f13fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab36b554bd90e8db279d13b133369118814f13fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab36b554bd90e8db279d13b133369118814f13fb/comments", "author": null, "committer": null, "parents": [{"sha": "3e95a974c39e922d19bf7ac1246730c516ae01f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e95a974c39e922d19bf7ac1246730c516ae01f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e95a974c39e922d19bf7ac1246730c516ae01f2"}], "stats": {"total": 70, "additions": 58, "deletions": 12}, "files": [{"sha": "d0da4a70448e70c4f184ce028e4cecf487c26f83", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab36b554bd90e8db279d13b133369118814f13fb/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab36b554bd90e8db279d13b133369118814f13fb/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=ab36b554bd90e8db279d13b133369118814f13fb", "patch": "@@ -5215,6 +5215,25 @@ cxx_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n   if (!INDIRECT_TYPE_P (subtype))\n     return NULL_TREE;\n \n+  /* Canonicalizes the given OBJ/OFF pair by iteratively absorbing\n+     the innermost component into the offset until it would make the\n+     offset positive, so that cxx_fold_indirect_ref_1 can identify\n+     more folding opportunities.  */\n+  auto canonicalize_obj_off = [] (tree& obj, tree& off) {\n+    while (TREE_CODE (obj) == COMPONENT_REF\n+\t   && (tree_int_cst_sign_bit (off) || integer_zerop (off)))\n+      {\n+\ttree field = TREE_OPERAND (obj, 1);\n+\ttree pos = byte_position (field);\n+\tif (integer_zerop (off) && integer_nonzerop (pos))\n+\t  /* If the offset is already 0, keep going as long as the\n+\t     component is at position 0.  */\n+\t  break;\n+\toff = int_const_binop (PLUS_EXPR, off, pos);\n+\tobj = TREE_OPERAND (obj, 0);\n+      }\n+  };\n+\n   if (TREE_CODE (sub) == ADDR_EXPR)\n     {\n       tree op = TREE_OPERAND (sub, 0);\n@@ -5233,7 +5252,12 @@ cxx_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n \t    return op;\n \t}\n       else\n-\treturn cxx_fold_indirect_ref_1 (ctx, loc, type, op, 0, empty_base);\n+\t{\n+\t  tree off = integer_zero_node;\n+\t  canonicalize_obj_off (op, off);\n+\t  gcc_assert (integer_zerop (off));\n+\t  return cxx_fold_indirect_ref_1 (ctx, loc, type, op, 0, empty_base);\n+\t}\n     }\n   else if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n \t   && tree_fits_uhwi_p (TREE_OPERAND (sub, 1)))\n@@ -5245,17 +5269,7 @@ cxx_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n       if (TREE_CODE (op00) == ADDR_EXPR)\n \t{\n \t  tree obj = TREE_OPERAND (op00, 0);\n-\t  while (TREE_CODE (obj) == COMPONENT_REF\n-\t\t && tree_int_cst_sign_bit (off))\n-\t    {\n-\t      /* Canonicalize this object/offset pair by iteratively absorbing\n-\t\t the innermost component into the offset until the offset is\n-\t\t nonnegative, so that cxx_fold_indirect_ref_1 can identify\n-\t\t more folding opportunities.  */\n-\t      tree field = TREE_OPERAND (obj, 1);\n-\t      off = int_const_binop (PLUS_EXPR, off, byte_position (field));\n-\t      obj = TREE_OPERAND (obj, 0);\n-\t    }\n+\t  canonicalize_obj_off (obj, off);\n \t  return cxx_fold_indirect_ref_1 (ctx, loc, type, obj,\n \t\t\t\t\t  tree_to_uhwi (off), empty_base);\n \t}"}, {"sha": "a267c14bc8024d516b3404c5be70e27a3623404b", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-base2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab36b554bd90e8db279d13b133369118814f13fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab36b554bd90e8db279d13b133369118814f13fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base2.C?ref=ab36b554bd90e8db279d13b133369118814f13fb", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/103879\n+// { dg-do compile { target c++14 } }\n+\n+struct A { int n = 42; };\n+struct B : A { };\n+struct C { B b; };\n+\n+constexpr int f() {\n+  C c;\n+  A& a = static_cast<A&>(c.b);\n+  B& b = static_cast<B&>(a);\n+  return b.n;\n+}\n+\n+static_assert(f() == 42, \"\");"}, {"sha": "9eb72b96de99dff6bd7a6b41f29e6d81386c5d96", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-base2a.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab36b554bd90e8db279d13b133369118814f13fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab36b554bd90e8db279d13b133369118814f13fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-base2a.C?ref=ab36b554bd90e8db279d13b133369118814f13fb", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/103879\n+// { dg-do compile { target c++14 } }\n+\n+struct A { int n = 42; };\n+struct Y { int m = 0; };\n+struct X : Y, A { };\n+struct B : X { };\n+struct C { B b; };\n+\n+constexpr int f() {\n+  C c;\n+  A& a = static_cast<A&>(c.b);\n+  B& b = static_cast<B&>(a);\n+  return b.n;\n+}\n+\n+static_assert(f() == 42, \"\");"}]}