{"sha": "66954a387154c75fa317f495ab0f8917d157568d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY5NTRhMzg3MTU0Yzc1ZmEzMTdmNDk1YWIwZjg5MTdkMTU3NTY4ZA==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-01-08T11:11:21Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-01-08T11:11:21Z"}, "message": "entered into RCS\n\nFrom-SVN: r172", "tree": {"sha": "2566d75ff12ce631fa51137317cc56e93c729bdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2566d75ff12ce631fa51137317cc56e93c729bdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66954a387154c75fa317f495ab0f8917d157568d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66954a387154c75fa317f495ab0f8917d157568d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66954a387154c75fa317f495ab0f8917d157568d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66954a387154c75fa317f495ab0f8917d157568d/comments", "author": null, "committer": null, "parents": [{"sha": "7d0e3dd45e7437a5028ef04ef2314513f7bd1539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0e3dd45e7437a5028ef04ef2314513f7bd1539", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0e3dd45e7437a5028ef04ef2314513f7bd1539"}], "stats": {"total": 1115, "additions": 1115, "deletions": 0}, "files": [{"sha": "7b869117585e5500843e4cd2def64a0e7fbd42b8", "filename": "gcc/config/spur/spur.md", "status": "added", "additions": 1115, "deletions": 0, "changes": 1115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66954a387154c75fa317f495ab0f8917d157568d/gcc%2Fconfig%2Fspur%2Fspur.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66954a387154c75fa317f495ab0f8917d157568d/gcc%2Fconfig%2Fspur%2Fspur.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.md?ref=66954a387154c75fa317f495ab0f8917d157568d", "patch": "@@ -0,0 +1,1115 @@\n+;;- Machine description for SPUR chip for GNU C compiler\n+;;   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;;- Operand classes for the register allocator:\n+\f\n+;; Compare instructions.\n+;; This pattern is used for generating an \"insn\"\n+;; which does just a compare and sets a (fictitious) condition code.\n+\n+;; The actual SPUR insns are compare-and-conditional-jump.\n+;; The define_peephole's below recognize the combinations of\n+;; compares and jumps, and output each pair as a single assembler insn.\n+\n+;; This controls RTL generation and register allocation.\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"rK\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"rK\")))]\n+  \"\"\n+  \"*\n+{\n+  cc_status.value1 = operands[0], cc_status.value2 = operands[1];\n+  return \\\"\\\";\n+}\")\n+\n+;; We have to have this because cse can optimize the previous pattern\n+;; into this one.\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+{\n+  cc_status.value1 = operands[0], cc_status.value2 = const0_rtx;\n+  return \\\"\\\";\n+}\")\n+\n+\n+;; These control RTL generation for conditional jump insns\n+;; and match them for register allocation.\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"eq\\\", \\\"eq\\\", \\\"ne\\\", \\\"ne\\\"); \")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ne\\\", \\\"ne\\\", \\\"eq\\\", \\\"eq\\\"); \")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"gt\\\", \\\"lt\\\", \\\"le\\\", \\\"ge\\\"); \")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ugt\\\", \\\"ult\\\", \\\"ule\\\", \\\"uge\\\"); \")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"lt\\\", \\\"gt\\\", \\\"ge\\\", \\\"le\\\"); \")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ult\\\", \\\"ugt\\\", \\\"uge\\\", \\\"ule\\\"); \")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ge\\\", \\\"le\\\", \\\"lt\\\", \\\"gt\\\"); \")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"uge\\\", \\\"ule\\\", \\\"ult\\\", \\\"ugt\\\"); \")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"le\\\", \\\"ge\\\", \\\"gt\\\", \\\"lt\\\"); \")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ule\\\", \\\"uge\\\", \\\"ugt\\\", \\\"ult\\\"); \")\n+\f\n+;; These match inverted jump insns for register allocation.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ne\\\", \\\"ne\\\", \\\"eq\\\", \\\"eq\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"eq\\\", \\\"eq\\\", \\\"ne\\\", \\\"ne\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"le\\\", \\\"ge\\\", \\\"gt\\\", \\\"lt\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ule\\\", \\\"uge\\\", \\\"ugt\\\", \\\"ult\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ge\\\", \\\"le\\\", \\\"lt\\\", \\\"gt\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"uge\\\", \\\"ule\\\", \\\"ult\\\", \\\"ugt\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"lt\\\", \\\"gt\\\", \\\"ge\\\", \\\"le\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ult\\\", \\\"ugt\\\", \\\"uge\\\", \\\"ule\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"gt\\\", \\\"lt\\\", \\\"le\\\", \\\"ge\\\"); \")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"* return output_compare (operands, \\\"ugt\\\", \\\"ult\\\", \\\"ule\\\", \\\"uge\\\"); \")\n+\f\n+;; Move instructions\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,m\")\n+\t(match_operand:SI 1 \"general_operand\" \"rmi,rJ\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st_32 %r1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld_32 %0,%1\\;nop\\\";\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"add_nt %0,%1,$0\\\";\n+  if (GET_CODE (operands[1]) == SYMBOL_REF && operands[1]->unchanging)\n+    return \\\"add_nt %0,r24,$(%1-0b)\\\";\n+  return \\\"add_nt %0,r0,%1\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"ld_32 %0,%1,%2\\;nop\")\n+\f\n+;; Generate insns for moving single bytes.\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    operands[1] = copy_to_reg (operands[1]);\n+\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx tem = gen_reg_rtx (SImode);\n+      rtx addr = force_reg (SImode, XEXP (operands[1], 0));\n+      rtx subreg;\n+\n+      emit_move_insn (tem, gen_rtx (MEM, SImode, addr));\n+      if (GET_CODE (operands[0]) == SUBREG)\n+\tsubreg = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[0]),\n+\t\t\t  SUBREG_WORD (operands[0]));\n+      else\n+\tsubreg = gen_rtx (SUBREG, SImode, operands[0], 0);\n+\n+      emit_insn (gen_rtx (SET, VOIDmode, subreg,\n+\t\t\t  gen_rtx (ZERO_EXTRACT, SImode, tem,\n+\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, 8),\n+\t\t\t\t   addr)));\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      rtx tem = gen_reg_rtx (SImode);\n+      rtx addr = force_reg (SImode, XEXP (operands[0], 0));\n+      rtx subreg;\n+\n+      emit_move_insn (tem, gen_rtx (MEM, SImode, addr));\n+      if (! CONSTANT_ADDRESS_P (operands[1]))\n+\t{\n+\t  if (GET_CODE (operands[1]) == SUBREG)\n+\t    subreg = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+\t\t\t      SUBREG_WORD (operands[1]));\n+\t  else\n+\t    subreg = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\t}\n+\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  gen_rtx (ZERO_EXTRACT, SImode, tem,\n+\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, 8),\n+\t\t\t\t   addr),\n+\t\t\t  subreg));\n+      emit_move_insn (gen_rtx (MEM, SImode, addr), tem);\n+    }\n+  else\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+    }\n+  DONE;\n+}\")\n+\f\n+;; Recognize insns generated for moving single bytes.\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"rmi,r\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st_32 %1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld_32 %0,%1\\;nop\\\";\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"add_nt %0,%1,$0\\\";\n+  return \\\"add_nt %0,r0,%1\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"extract %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 1 \"nonmemory_operand\" \"rI\"))\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"ri\"))]\n+  \"\"\n+  \"wr_insert %1\\;insert %0,%0,%2\")\n+\n+;; Constant propagation can optimize the previous pattern into this pattern.\n+;[Not any more.  It could when the position-operand contains a MULT.]\n+\n+;(define_insn \"\"\n+;  [(set (zero_extract:QI (match_operand:SI 0 \"register_operand\" \"+r\")\n+;\t\t\t (const_int 8)\n+;\t\t\t (match_operand:SI 1 \"immediate_operand\" \"I\"))\n+;\t(match_operand:QI 2 \"register_operand\" \"r\"))]\n+;  \"GET_CODE (operands[1]) == CONST_INT\n+;   && INTVAL (operands[1]) % 8 == 0\n+;   && (unsigned) INTVAL (operands[1]) < 32\"\n+;  \"*\n+;{\n+;  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) / 8);\n+;  return \\\"wr_insert 0,0,%1\\;insert %0,%0,%2\\\";\n+;}\")\n+\f\n+;; The three define_expand patterns on this page\n+;; serve as subroutines of \"movhi\".\n+\n+;; Generate code to fetch an aligned halfword from memory.\n+;; Operand 0 is the destination register (HImode).\n+;; Operand 1 is the memory address (SImode).\n+;; Operand 2 is a temporary (SImode).\n+;; Operand 3 is a temporary (SImode).\n+;; Operand 4 is a temporary (QImode).\n+\n+;; Operand 5 is an internal temporary (HImode).\n+\n+(define_expand \"loadhi\"\n+  [(set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(mem:SI (match_operand:SI 1 \"register_operand\" \"\")))\n+   ;; Extract the low byte.\n+   (set (subreg:SI (match_dup 5) 0)\n+\t(zero_extract:SI (match_dup 2) (const_int 8) (match_dup 1)))\n+   ;; Form address of high byte.\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t(plus:SI (match_dup 1) (const_int 1)))\n+   ;; Extract the high byte.\n+   (set (subreg:SI (match_operand:QI 4 \"register_operand\" \"\") 0)\n+\t(zero_extract:SI (match_dup 2) (const_int 8) (match_dup 3)))\n+   ;; Put the high byte in with the low one.\n+   (set (zero_extract:SI (match_dup 5) (const_int 8) (const_int 1))\n+\t(subreg:SI (match_dup 4) 0))\n+   (set (match_operand:HI 0 \"register_operand\" \"\") (match_dup 5))]\n+  \"\"\n+  \"operands[5] = gen_reg_rtx (HImode);\")\n+\n+;; Generate code to store an aligned halfword into memory.\n+;; Operand 0 is the destination address (SImode).\n+;; Operand 1 is the source register (HImode, not constant).\n+;; Operand 2 is a temporary (SImode).\n+;; Operand 3 is a temporary (SImode).\n+;; Operand 4 is a temporary (QImode).\n+\n+;; Operand 5 is an internal variable made from operand 1.\n+\n+(define_expand \"storehi\"\n+  [(set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(mem:SI (match_operand:SI 0 \"register_operand\" \"\")))\n+   ;; Insert the low byte.\n+   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 0))\n+\t(match_dup 5))\n+   ;; Form address of high byte.\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t(plus:SI (match_dup 0) (const_int 1)))\n+   ;; Extract the high byte from the source.\n+   (set (subreg:SI (match_operand:QI 4 \"register_operand\" \"\") 0)\n+\t(zero_extract:SI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t (const_int 8) (const_int 1)))\n+   ;; Store high byte into the memory word\n+   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 3))\n+\t(subreg:SI (match_dup 4) 0))\n+   ;; Put memory word back into memory.\n+   (set (mem:SI (match_dup 0))\n+\t(match_dup 2))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == SUBREG)\n+    operands[5] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+\t\t\t   SUBREG_WORD (operands[1]));\n+  else\n+    operands[5] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+}\")\n+\n+;; Like storehi but operands[1] is a CONST_INT.\n+\n+(define_expand \"storeinthi\"\n+  [(set (match_operand:SI 2 \"register_operand\" \"\")\n+\t(mem:SI (match_operand:SI 0 \"register_operand\" \"\")))\n+   ;; Insert the low byte.\n+   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 0))\n+\t(match_dup 5))\n+   ;; Form address of high byte.\n+   (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t(plus:SI (match_dup 0) (const_int 1)))\n+   ;; Store high byte into the memory word\n+   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 3))\n+\t(match_dup 6))\n+   ;; Put memory word back into memory.\n+   (set (mem:SI (match_dup 0))\n+\t(match_dup 2))]\n+  \"\"\n+  \" operands[5] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) & 255);\n+    operands[6] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t   (INTVAL (operands[1]) >> 8) & 255);\n+\")\n+\f\n+;; Main entry for generating insns to move halfwords.\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    operands[1] = copy_to_reg (operands[1]);\n+  \n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      rtx insn =\n+\temit_insn (gen_loadhi (operands[0],\n+\t\t\t       force_reg (SImode, XEXP (operands[1], 0)),\n+\t\t\t       gen_reg_rtx (SImode), gen_reg_rtx (SImode),\n+\t\t\t       gen_reg_rtx (QImode)));\n+      /* Tell cse what value the loadhi produces, so it detect duplicates.  */\n+      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, operands[1],\n+\t\t\t\t\t     REG_NOTES (insn));\n+    }\n+  else if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\temit_insn (gen_storeinthi (force_reg (SImode, XEXP (operands[0], 0)),\n+\t\t\t           operands[1],\n+\t\t\t\t   gen_reg_rtx (SImode), gen_reg_rtx (SImode),\n+\t\t\t\t   gen_reg_rtx (QImode)));\n+      else\n+\t{\n+\t  if (CONSTANT_P (operands[1]))\n+            operands[1] = force_reg (HImode, operands[1]);\n+\t  emit_insn (gen_storehi (force_reg (SImode, XEXP (operands[0], 0)),\n+\t\t\t\t  operands[1],\n+\t\t\t\t  gen_reg_rtx (SImode), gen_reg_rtx (SImode),\n+\t\t\t\t  gen_reg_rtx (QImode)));\n+\t}\n+    }\n+  else\n+    emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\f\n+;; Recognize insns generated for moving halfwords.\n+;; (Note that the extract and insert patterns for single-byte moves\n+;;  are also involved in recognizing some of the insns used for this purpose.)\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"rmi,r\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st_32 %1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld_32 %0,%1\\;nop\\\";\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"add_nt %0,%1,$0\\\";\n+  return \\\"add_nt %0,r0,%1\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:SI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"extract %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:HI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 1 \"nonmemory_operand\" \"rI\"))\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"ri\"))]\n+  \"\"\n+  \"wr_insert %1\\;insert %0,%0,%2\")\n+\n+;; Constant propagation can optimize the previous pattern into this pattern.\n+\n+;(define_insn \"\"\n+;  [(set (zero_extract:QI (match_operand:HI 0 \"register_operand\" \"+r\")\n+;\t\t\t (const_int 8)\n+;\t\t\t (match_operand:SI 1 \"immediate_operand\" \"I\"))\n+;\t(match_operand:QI 2 \"register_operand\" \"r\"))]\n+;  \"GET_CODE (operands[1]) == CONST_INT\n+;   && INTVAL (operands[1]) % 8 == 0\n+;   && (unsigned) INTVAL (operands[1]) < 32\"\n+;  \"*\n+;{\n+;  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) / 8);\n+;  return \\\"wr_insert 0,0,%1\\;insert %0,%0,%2\\\";\n+;}\")\n+\f\n+;; This pattern forces (set (reg:DF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movdf pattern.\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=&r,f,&o\")\n+\t(match_operand:DF 1 \"\" \"mG,m,G\"))]\n+  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    return output_fp_move_double (operands);\n+  if (operands[1] == CONST0_RTX (DFmode) && GET_CODE (operands[0]) == REG)\n+    {\n+      operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      return \\\"add_nt %0,r0,$0\\;add_nt %1,r0,$0\\\";\n+    }\n+  if (operands[1] == CONST0_RTX (DFmode) && GET_CODE (operands[0]) == MEM)\n+    {\n+      operands[1] = adj_offsettable_operand (operands[0], 4);\n+      return \\\"st_32 r0,%0\\;st_32 r0,%1\\\";\n+    }\n+  return output_move_double (operands);\n+}\n+\")\n+  \n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,&r,m,?f,?rm\")\n+\t(match_operand:DF 1 \"general_operand\" \"r,m,r,rfm,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\n+\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=r,&r,m,?f,?rm\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,m,r,rfm,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\n+\")\n+\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=rf,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"rfm,rf\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fmov %0,%1\\\";\n+      if (GET_CODE (operands[1]) == REG)\n+\t{\n+\t  rtx xoperands[2];\n+\t  int offset = - get_frame_size () - 8;\n+\t  xoperands[1] = operands[1];\n+\t  xoperands[0] = gen_rtx (CONST_INT, VOIDmode, offset);\n+\t  output_asm_insn (\\\"st_32 %1,r25,%0\\\", xoperands);\n+\t  xoperands[1] = operands[0];\n+\t  output_asm_insn (\\\"ld_sgl %1,r25,%0\\;nop\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+      return \\\"ld_sgl %0,%1\\;nop\\\";\n+    }\n+  if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  rtx xoperands[2];\n+\t  int offset = - get_frame_size () - 8;\n+\t  xoperands[0] = gen_rtx (CONST_INT, VOIDmode, offset);\n+\t  xoperands[1] = operands[1];\n+\t  output_asm_insn (\\\"st_sgl %1,r25,%0\\\", xoperands);\n+\t  xoperands[1] = operands[0];\n+\t  output_asm_insn (\\\"ld_32 %1,r25,%0\\;nop\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+      return \\\"st_sgl %1,%0\\\";\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st_32 %r1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld_32 %0,%1\\;nop\\\";\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"add_nt %0,%1,$0\\\";\n+  return \\\"add_nt %0,r0,%1\\\";\n+}\")\n+\f\n+;;- truncation instructions\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(truncate:QI\n+\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"add_nt %0,%1,$0\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(truncate:QI\n+\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"add_nt %0,%1,$0\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(truncate:HI\n+\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"add_nt %0,%1,$0\")\n+\f\n+;;- zero extension instructions\n+\n+;; Note that the one starting from HImode comes before those for QImode\n+;; so that a constant operand will match HImode, not QImode.\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:HI 1 \"register_operand\" \"\") ;Changed to SI below\n+\t\t;; This constant is invalid, but reloading will handle it.\n+\t\t;; It's useless to generate here the insns to construct it\n+\t\t;; because constant propagation would simplify them anyway.\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == SUBREG)\n+    operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+\t\t\t   SUBREG_WORD (operands[1]));\n+  else\n+    operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\n+  operands[2] = force_reg (SImode, gen_rtx (CONST_INT, VOIDmode, 65535));\n+}\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extract %0,%1,$0\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"extract %0,%1,$0\")\n+\f\n+;;- sign extension instructions\n+;; Note that the one starting from HImode comes before those for QImode\n+;; so that a constant operand will match HImode, not QImode.\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_dup 2)\n+\t(and:SI (match_operand:HI 1 \"register_operand\" \"\") ;Changed to SI below\n+\t\t(match_dup 4)))\n+   (set (match_dup 3) (plus:SI (match_dup 2) (match_dup 5)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_dup 3) (match_dup 5)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == SUBREG)\n+    operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+\t\t\t   SUBREG_WORD (operands[1]));\n+  else\n+    operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\n+  operands[2] = gen_reg_rtx (SImode);\n+  operands[3] = gen_reg_rtx (SImode);\n+  operands[4] = force_reg (SImode, gen_rtx (CONST_INT, VOIDmode, 65535));\n+  operands[5] = force_reg (SImode, gen_rtx (CONST_INT, VOIDmode, -32768));\n+}\")\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_dup 2)\n+\t(and:HI (match_operand:QI 1 \"register_operand\" \"\") ;Changed to SI below\n+\t\t(const_int 255)))\n+   (set (match_dup 3)\n+\t(plus:SI (match_dup 2) (const_int -128)))\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_dup 3) (const_int -128)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == SUBREG)\n+    operands[1] = gen_rtx (SUBREG, HImode, SUBREG_REG (operands[1]),\n+\t\t\t   SUBREG_WORD (operands[1]));\n+  else\n+    operands[1] = gen_rtx (SUBREG, HImode, operands[1], 0);\n+\n+  operands[2] = gen_reg_rtx (HImode);\n+  operands[3] = gen_reg_rtx (HImode);\n+}\")\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_dup 2)\n+\t(and:SI (match_operand:QI 1 \"register_operand\" \"\") ;Changed to SI below\n+\t\t(const_int 255)))\n+   (set (match_dup 3) (plus:SI (match_dup 2) (const_int -128)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_dup 3) (const_int -128)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == SUBREG)\n+    operands[1] = gen_rtx (SUBREG, SImode, SUBREG_REG (operands[1]),\n+\t\t\t   SUBREG_WORD (operands[1]));\n+  else\n+    operands[1] = gen_rtx (SUBREG, SImode, operands[1], 0);\n+\n+  operands[2] = gen_reg_rtx (SImode);\n+  operands[3] = gen_reg_rtx (SImode);\n+}\")\n+\f\n+;;- arithmetic instructions\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"add %0,%1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"big_immediate_operand\" \"g\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT \n+   && (unsigned) (INTVAL (operands[2]) + 0x8000000) < 0x10000000\"\n+  \"*\n+{\n+  return \n+    output_add_large_offset (operands[0], operands[1], INTVAL (operands[2]));\n+}\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"sub %0,%1,%2\")\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"and %0,%1,%2\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"or %0,%1,%2\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"xor %0,%1,%2\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"nonmemory_operand\" \"rI\")))]\n+  \"\"\n+  \"sub %0,r0,%1\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor %0,%1,$-1\")\n+\f\n+;; Floating point arithmetic instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fadd %0,%1,%2\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fadd %0,%1,%2\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fsub %0,%1,%2\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fsub %0,%1,%2\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fmul %0,%1,%2\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fmul %0,%1,%2\")\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fdiv %0,%1,%2\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fdiv %0,%1,%2\")\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (match_operand:DF 1 \"nonmemory_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fneg %0,%1\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (match_operand:SF 1 \"nonmemory_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fneg %0,%1\")\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(abs:DF (match_operand:DF 1 \"nonmemory_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fabs %0,%1\")\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(abs:SF (match_operand:SF 1 \"nonmemory_operand\" \"f\")))]\n+  \"TARGET_FPU\"\n+  \"fabs %0,%1\")\n+\f\n+;; Shift instructions\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\"\n+  \"*\n+{\n+  unsigned int amount = INTVAL (operands[2]);\n+\n+  switch (amount)\n+    {\n+    case 0:\n+      return \\\"add_nt %0,%1,$0\\\";\n+    case 1:\n+      return \\\"sll %0,%1,$1\\\";\n+    case 2:\n+      return \\\"sll %0,%1,$2\\\";\n+    default:\n+      output_asm_insn (\\\"sll %0,%1,$3\\\", operands);\n+\n+      for (amount -= 3; amount >= 3; amount -= 3)\n+\toutput_asm_insn (\\\"sll %0,%0,$3\\\", operands);\n+\n+      if (amount > 0)\n+\toutput_asm_insn (amount == 1 ? \\\"sll %0,%0,$1\\\" : \\\"sll %0,%0,$2\\\",\n+\t\t\t operands);\n+      return \\\"\\\";\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t             (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\"\n+  \"*\n+{\n+  unsigned int amount = INTVAL (operands[2]);\n+\n+  if (amount == 0) \n+    return \\\"add_nt %0,%1,$0\\\";\n+  else\n+    output_asm_insn (\\\"sra %0,%1,$1\\\", operands);\n+  \n+  for (amount -= 1; amount > 0; amount -= 1)\n+    output_asm_insn (\\\"sra %0,%0,$1\\\", operands);\n+\n+  return \\\"\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t             (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\"\n+  \"*\n+{\n+  unsigned int amount = INTVAL (operands[2]);\n+\n+  if (amount == 0) \n+    return \\\"add_nt %0,%1,$0\\\";\n+  else\n+    output_asm_insn (\\\"srl %0,%1,$1\\\", operands);\n+  \n+  for (amount -= 1; amount > 0; amount -= 1)\n+    output_asm_insn (\\\"srl %0,%0,$1\\\", operands);\n+\n+  return \\\"\\\";\n+}\")\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || (! TARGET_EXPAND_SHIFTS && (unsigned) INTVAL (operands[2]) > 3))\n+    FAIL;\n+}\")\n+\n+(define_expand \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || (! TARGET_EXPAND_SHIFTS && (unsigned) INTVAL (operands[2]) > 3))\n+    FAIL;\n+}\")\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || (! TARGET_EXPAND_SHIFTS && (unsigned) INTVAL (operands[2]) > 1))\n+    FAIL;\n+}\")\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || (! TARGET_EXPAND_SHIFTS && (unsigned) INTVAL (operands[2]) > 1))\n+    FAIL;\n+}\")\n+\f\n+;; Unconditional and other jump instructions\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jump %l0\\;nop\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jump_reg r0,%0\\;nop\")\n+\n+;;- jump to subroutine\n+(define_insn \"call\"\n+  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"\"\n+  \"add_nt r2,%0\\;call .+8\\;jump_reg r0,r2\\;nop\")\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"\"\n+  \"add_nt r2,%1\\;call .+8\\;jump_reg r0,r2\\;nop\")\n+\n+;; A memory ref with constant address is not normally valid.\n+;; But it is valid in a call insns.  This pattern allows the\n+;; loading of the address to combine with the call.\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"\" \"i\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"GET_CODE (operands[0]) == SYMBOL_REF\"\n+  \"call %0\\;nop\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=g\")\n+\t(call (mem:SI (match_operand:SI 1 \"\" \"i\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  ;;- Don't use operand 1 for most machines.\n+  \"GET_CODE (operands[1]) == SYMBOL_REF\"\n+  \"call %1\\;nop\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:\n+"}]}