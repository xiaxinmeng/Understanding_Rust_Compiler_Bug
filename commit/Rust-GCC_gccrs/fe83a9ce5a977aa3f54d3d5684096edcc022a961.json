{"sha": "fe83a9ce5a977aa3f54d3d5684096edcc022a961", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU4M2E5Y2U1YTk3N2FhM2Y1NGQzZDU2ODQwOTZlZGNjMDIyYTk2MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-11-13T05:09:51Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-11-13T05:09:51Z"}, "message": "* gthr-posix.h: Fix formatting.\n\nFrom-SVN: r59064", "tree": {"sha": "4e86e6408a29a9d3e66960d5de06550a30cf126c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e86e6408a29a9d3e66960d5de06550a30cf126c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe83a9ce5a977aa3f54d3d5684096edcc022a961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe83a9ce5a977aa3f54d3d5684096edcc022a961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe83a9ce5a977aa3f54d3d5684096edcc022a961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe83a9ce5a977aa3f54d3d5684096edcc022a961/comments", "author": null, "committer": null, "parents": [{"sha": "eed13f9bdf84a00ef0877dcc996b41319d88a0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed13f9bdf84a00ef0877dcc996b41319d88a0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed13f9bdf84a00ef0877dcc996b41319d88a0ba"}], "stats": {"total": 165, "additions": 85, "deletions": 80}, "files": [{"sha": "95ed385fb3f8ae4ef7a508a6228d084fe21beeeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe83a9ce5a977aa3f54d3d5684096edcc022a961/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe83a9ce5a977aa3f54d3d5684096edcc022a961/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe83a9ce5a977aa3f54d3d5684096edcc022a961", "patch": "@@ -1,3 +1,7 @@\n+2002-11-13  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* gthr-posix.h: Fix formatting.\n+\n 2002-11-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (*andorsi3): New."}, {"sha": "9149e645ceb6a334c89e1e9c49b02785f1f913bf", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe83a9ce5a977aa3f54d3d5684096edcc022a961/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe83a9ce5a977aa3f54d3d5684096edcc022a961/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=fe83a9ce5a977aa3f54d3d5684096edcc022a961", "patch": "@@ -121,19 +121,19 @@ static void *thread_local_storage = NULL;\n \n /* Initialize the threads subsystem.  */\n static inline int\n-__gthread_objc_init_thread_system(void)\n+__gthread_objc_init_thread_system (void)\n {\n   if (__gthread_active_p ())\n     {\n       /* Initialize the thread storage key */\n-      if (pthread_key_create(&_objc_thread_storage, NULL) == 0)\n+      if (pthread_key_create (&_objc_thread_storage, NULL) == 0)\n \t{\n \t  /* The normal default detach state for threads is\n \t   * PTHREAD_CREATE_JOINABLE which causes threads to not die\n \t   * when you think they should.  */\n-\t  if (pthread_attr_init(&_objc_thread_attribs) == 0\n-\t      && pthread_attr_setdetachstate(&_objc_thread_attribs,\n-\t\t\t\t\t     PTHREAD_CREATE_DETACHED) == 0)\n+\t  if (pthread_attr_init (&_objc_thread_attribs) == 0\n+\t      && pthread_attr_setdetachstate (&_objc_thread_attribs,\n+\t\t\t\t\t      PTHREAD_CREATE_DETACHED) == 0)\n \t    return 0;\n \t}\n     }\n@@ -143,11 +143,11 @@ __gthread_objc_init_thread_system(void)\n \n /* Close the threads subsystem.  */\n static inline int\n-__gthread_objc_close_thread_system(void)\n+__gthread_objc_close_thread_system (void)\n {\n   if (__gthread_active_p ()\n-      && pthread_key_delete(_objc_thread_storage) == 0\n-      && pthread_attr_destroy(&_objc_thread_attribs) == 0)\n+      && pthread_key_delete (_objc_thread_storage) == 0\n+      && pthread_attr_destroy (&_objc_thread_attribs) == 0)\n     return 0;\n \n   return -1;\n@@ -157,15 +157,15 @@ __gthread_objc_close_thread_system(void)\n \n /* Create a new thread of execution.  */\n static inline objc_thread_t\n-__gthread_objc_thread_detach(void (*func)(void *), void *arg)\n+__gthread_objc_thread_detach (void (*func)(void *), void *arg)\n {\n   objc_thread_t thread_id;\n   pthread_t new_thread_handle;\n \n   if (!__gthread_active_p ())\n     return NULL;\n \n-  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n+  if (!(pthread_create (&new_thread_handle, NULL, (void *) func, arg)))\n     thread_id = (objc_thread_t) new_thread_handle;\n   else\n     thread_id = NULL;\n@@ -175,55 +175,56 @@ __gthread_objc_thread_detach(void (*func)(void *), void *arg)\n \n /* Set the current thread's priority.  */\n static inline int\n-__gthread_objc_thread_set_priority(int priority)\n+__gthread_objc_thread_set_priority (int priority)\n {\n-  if (!__gthread_active_p())\n+  if (!__gthread_active_p ())\n     return -1;\n-  else {\n+  else\n+    {\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n-    pthread_t thread_id = pthread_self();\n-    int policy;\n-    struct sched_param params;\n-    int priority_min, priority_max;\n-\n-    if (pthread_getschedparam(thread_id, &policy, &params) == 0)\n-      {\n-\tif ((priority_max = sched_get_priority_max(policy)) == -1)\n-\t  return -1;\n+      pthread_t thread_id = pthread_self ();\n+      int policy;\n+      struct sched_param params;\n+      int priority_min, priority_max;\n \n-\tif ((priority_min = sched_get_priority_min(policy)) == -1)\n-\t  return -1;\n+      if (pthread_getschedparam (thread_id, &policy, &params) == 0)\n+\t{\n+\t  if ((priority_max = sched_get_priority_max (policy)) == -1)\n+\t    return -1;\n+\n+\t  if ((priority_min = sched_get_priority_min (policy)) == -1)\n+\t    return -1;\n \n-\tif (priority > priority_max)\n-\t  priority = priority_max;\n-\telse if (priority < priority_min)\n-\t  priority = priority_min;\n-\tparams.sched_priority = priority;\n-\n-\t/*\n-\t * The solaris 7 and several other man pages incorrectly state that\n-\t * this should be a pointer to policy but pthread.h is universally\n-\t * at odds with this.\n-\t */\n-\tif (pthread_setschedparam(thread_id, policy, &params) == 0)\n-\t  return 0;\n-      }\n+\t  if (priority > priority_max)\n+\t    priority = priority_max;\n+\t  else if (priority < priority_min)\n+\t    priority = priority_min;\n+\t  params.sched_priority = priority;\n+\n+\t  /*\n+\t   * The solaris 7 and several other man pages incorrectly state that\n+\t   * this should be a pointer to policy but pthread.h is universally\n+\t   * at odds with this.\n+\t   */\n+\t  if (pthread_setschedparam (thread_id, policy, &params) == 0)\n+\t    return 0;\n+\t}\n #endif /* _POSIX_THREAD_PRIORITY_SCHEDULING */\n-    return -1;\n-  }\n+      return -1;\n+    }\n }\n \n /* Return the current thread's priority.  */\n static inline int\n-__gthread_objc_thread_get_priority(void)\n+__gthread_objc_thread_get_priority (void)\n {\n #ifdef _POSIX_THREAD_PRIORITY_SCHEDULING\n   if (__gthread_active_p ())\n     {\n       int policy;\n       struct sched_param params;\n \n-      if (pthread_getschedparam(pthread_self(), &policy, &params) == 0)\n+      if (pthread_getschedparam (pthread_self (), &policy, &params) == 0)\n \treturn params.sched_priority;\n       else\n \treturn -1;\n@@ -235,40 +236,40 @@ __gthread_objc_thread_get_priority(void)\n \n /* Yield our process time to another thread.  */\n static inline void\n-__gthread_objc_thread_yield(void)\n+__gthread_objc_thread_yield (void)\n {\n   if (__gthread_active_p ())\n-    sched_yield();\n+    sched_yield ();\n }\n \n /* Terminate the current thread.  */\n static inline int\n-__gthread_objc_thread_exit(void)\n+__gthread_objc_thread_exit (void)\n {\n   if (__gthread_active_p ())\n     /* exit the thread */\n-    pthread_exit(&__objc_thread_exit_status);\n+    pthread_exit (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n }\n \n /* Returns an integer value which uniquely describes a thread.  */\n static inline objc_thread_t\n-__gthread_objc_thread_id(void)\n+__gthread_objc_thread_id (void)\n {\n   if (__gthread_active_p ())\n-    return (objc_thread_t) pthread_self();\n+    return (objc_thread_t) pthread_self ();\n   else\n     return (objc_thread_t) 1;\n }\n \n /* Sets the thread's local storage pointer.  */\n static inline int\n-__gthread_objc_thread_set_data(void *value)\n+__gthread_objc_thread_set_data (void *value)\n {\n   if (__gthread_active_p ())\n-    return pthread_setspecific(_objc_thread_storage, value);\n+    return pthread_setspecific (_objc_thread_storage, value);\n   else\n     {\n       thread_local_storage = value;\n@@ -278,10 +279,10 @@ __gthread_objc_thread_set_data(void *value)\n \n /* Returns the thread's local storage pointer.  */\n static inline void *\n-__gthread_objc_thread_get_data(void)\n+__gthread_objc_thread_get_data (void)\n {\n   if (__gthread_active_p ())\n-    return pthread_getspecific(_objc_thread_storage);\n+    return pthread_getspecific (_objc_thread_storage);\n   else\n     return thread_local_storage;\n }\n@@ -290,15 +291,15 @@ __gthread_objc_thread_get_data(void)\n \n /* Allocate a mutex.  */\n static inline int\n-__gthread_objc_mutex_allocate(objc_mutex_t mutex)\n+__gthread_objc_mutex_allocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n     {\n-      mutex->backend = objc_malloc(sizeof(pthread_mutex_t));\n+      mutex->backend = objc_malloc (sizeof (pthread_mutex_t));\n \n-      if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))\n+      if (pthread_mutex_init ((pthread_mutex_t *) mutex->backend, NULL))\n \t{\n-\t  objc_free(mutex->backend);\n+\t  objc_free (mutex->backend);\n \t  mutex->backend = NULL;\n \t  return -1;\n \t}\n@@ -309,7 +310,7 @@ __gthread_objc_mutex_allocate(objc_mutex_t mutex)\n \n /* Deallocate a mutex.  */\n static inline int\n-__gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n+__gthread_objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n     {\n@@ -322,27 +323,27 @@ __gthread_objc_mutex_deallocate(objc_mutex_t mutex)\n \n       do\n \t{\n-\t  count = pthread_mutex_unlock((pthread_mutex_t *)mutex->backend);\n+\t  count = pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend);\n \t  if (count < 0)\n \t    return -1;\n \t}\n       while (count);\n \n-      if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n+      if (pthread_mutex_destroy ((pthread_mutex_t *) mutex->backend))\n \treturn -1;\n \n-      objc_free(mutex->backend);\n+      objc_free (mutex->backend);\n       mutex->backend = NULL;\n     }\n   return 0;\n }\n \n /* Grab a lock on a mutex.  */\n static inline int\n-__gthread_objc_mutex_lock(objc_mutex_t mutex)\n+__gthread_objc_mutex_lock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_lock((pthread_mutex_t *)mutex->backend) != 0)\n+      && pthread_mutex_lock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -352,10 +353,10 @@ __gthread_objc_mutex_lock(objc_mutex_t mutex)\n \n /* Try to grab a lock on a mutex.  */\n static inline int\n-__gthread_objc_mutex_trylock(objc_mutex_t mutex)\n+__gthread_objc_mutex_trylock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_trylock((pthread_mutex_t *)mutex->backend) != 0)\n+      && pthread_mutex_trylock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -365,10 +366,10 @@ __gthread_objc_mutex_trylock(objc_mutex_t mutex)\n \n /* Unlock the mutex */\n static inline int\n-__gthread_objc_mutex_unlock(objc_mutex_t mutex)\n+__gthread_objc_mutex_unlock (objc_mutex_t mutex)\n {\n   if (__gthread_active_p ()\n-      && pthread_mutex_unlock((pthread_mutex_t *)mutex->backend) != 0)\n+      && pthread_mutex_unlock ((pthread_mutex_t *) mutex->backend) != 0)\n     {\n       return -1;\n     }\n@@ -380,15 +381,15 @@ __gthread_objc_mutex_unlock(objc_mutex_t mutex)\n \n /* Allocate a condition.  */\n static inline int\n-__gthread_objc_condition_allocate(objc_condition_t condition)\n+__gthread_objc_condition_allocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n     {\n-      condition->backend = objc_malloc(sizeof(pthread_cond_t));\n+      condition->backend = objc_malloc (sizeof (pthread_cond_t));\n \n-      if (pthread_cond_init((pthread_cond_t *)condition->backend, NULL))\n+      if (pthread_cond_init ((pthread_cond_t *) condition->backend, NULL))\n \t{\n-\t  objc_free(condition->backend);\n+\t  objc_free (condition->backend);\n \t  condition->backend = NULL;\n \t  return -1;\n \t}\n@@ -399,46 +400,46 @@ __gthread_objc_condition_allocate(objc_condition_t condition)\n \n /* Deallocate a condition.  */\n static inline int\n-__gthread_objc_condition_deallocate(objc_condition_t condition)\n+__gthread_objc_condition_deallocate (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n     {\n-      if (pthread_cond_destroy((pthread_cond_t *)condition->backend))\n+      if (pthread_cond_destroy ((pthread_cond_t *) condition->backend))\n \treturn -1;\n \n-      objc_free(condition->backend);\n+      objc_free (condition->backend);\n       condition->backend = NULL;\n     }\n   return 0;\n }\n \n /* Wait on the condition */\n static inline int\n-__gthread_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+__gthread_objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_wait((pthread_cond_t *)condition->backend,\n-\t\t\t   (pthread_mutex_t *)mutex->backend);\n+    return pthread_cond_wait ((pthread_cond_t *) condition->backend,\n+\t\t\t      (pthread_mutex_t *) mutex->backend);\n   else\n     return 0;\n }\n \n /* Wake up all threads waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_broadcast(objc_condition_t condition)\n+__gthread_objc_condition_broadcast (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_broadcast((pthread_cond_t *)condition->backend);\n+    return pthread_cond_broadcast ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }\n \n /* Wake up one thread waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_signal(objc_condition_t condition)\n+__gthread_objc_condition_signal (objc_condition_t condition)\n {\n   if (__gthread_active_p ())\n-    return pthread_cond_signal((pthread_cond_t *)condition->backend);\n+    return pthread_cond_signal ((pthread_cond_t *) condition->backend);\n   else\n     return 0;\n }"}]}