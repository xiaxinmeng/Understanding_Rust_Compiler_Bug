{"sha": "7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZmNWVhYzNkODg1YjE1YzUyMjIzZGNkOGY2M2E3YjliODMyZDFiYQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2017-10-12T22:21:06Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2017-10-12T22:21:06Z"}, "message": "Asm memory constraints\n\n\t* doc/extend.texi (Clobbers): Correct vax example.  Delete old\n\texample of a memory input for a string of known length.  Move\n\tcommentary out of table.  Add a number of new examples\n\tcovering array memory inputs.\ntestsuite/\n\t* gcc.target/i386/asm-mem.c: New test.\n\nFrom-SVN: r253700", "tree": {"sha": "3430d19a9853238c4767a542872db55450bd5529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3430d19a9853238c4767a542872db55450bd5529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0af377c15a40ae329f6019155d07857df452f42b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af377c15a40ae329f6019155d07857df452f42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0af377c15a40ae329f6019155d07857df452f42b"}], "stats": {"total": 142, "additions": 135, "deletions": 7}, "files": [{"sha": "69d328aec8650ed87ffc3fc9d8f8fa2f6ab868a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "patch": "@@ -1,3 +1,10 @@\n+2017-10-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* doc/extend.texi (Clobbers): Correct vax example.  Delete old\n+\texample of a memory input for a string of known length.  Move\n+\tcommentary out of table.  Add a number of new examples\n+\tcovering array memory inputs.\n+\n 2017-10-12  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/82493"}, {"sha": "0391cc46050d4240faf2312d08f96dcf691a724e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "patch": "@@ -8802,7 +8802,7 @@ registers:\n asm volatile (\"movc3 %0, %1, %2\"\n                    : /* No outputs. */\n                    : \"g\" (from), \"g\" (to), \"g\" (count)\n-                   : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\");\n+                   : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"memory\");\n @end example\n \n Also, there are two special clobber arguments:\n@@ -8833,14 +8833,72 @@ Note that this clobber does not prevent the @emph{processor} from doing\n speculative reads past the @code{asm} statement. To prevent that, you need \n processor-specific fence instructions.\n \n-Flushing registers to memory has performance implications and may be an issue \n-for time-sensitive code.  You can use a trick to avoid this if the size of \n-the memory being accessed is known at compile time. For example, if accessing \n-ten bytes of a string, use a memory input like: \n+@end table\n \n-@code{@{\"m\"( (@{ struct @{ char x[10]; @} *p = (void *)ptr ; *p; @}) )@}}.\n+Flushing registers to memory has performance implications and may be\n+an issue for time-sensitive code.  You can provide better information\n+to GCC to avoid this, as shown in the following examples.  At a\n+minimum, aliasing rules allow GCC to know what memory @emph{doesn't}\n+need to be flushed.\n \n-@end table\n+Here is a fictitious sum of squares instruction, that takes two\n+pointers to floating point values in memory and produces a floating\n+point register output.\n+Notice that @code{x}, and @code{y} both appear twice in the @code{asm}\n+parameters, once to specify memory accessed, and once to specify a\n+base register used by the @code{asm}.  You won't normally be wasting a\n+register by doing this as GCC can use the same register for both\n+purposes.  However, it would be foolish to use both @code{%1} and\n+@code{%3} for @code{x} in this @code{asm} and expect them to be the\n+same.  In fact, @code{%3} may well not be a register.  It might be a\n+symbolic memory reference to the object pointed to by @code{x}.\n+\n+@smallexample\n+asm (\"sumsq %0, %1, %2\"\n+     : \"+f\" (result)\n+     : \"r\" (x), \"r\" (y), \"m\" (*x), \"m\" (*y));\n+@end smallexample\n+\n+Here is a fictitious @code{*z++ = *x++ * *y++} instruction.\n+Notice that the @code{x}, @code{y} and @code{z} pointer registers\n+must be specified as input/output because the @code{asm} modifies\n+them.\n+\n+@smallexample\n+asm (\"vecmul %0, %1, %2\"\n+     : \"+r\" (z), \"+r\" (x), \"+r\" (y), \"=m\" (*z)\n+     : \"m\" (*x), \"m\" (*y));\n+@end smallexample\n+\n+An x86 example where the string memory argument is of unknown length.\n+\n+@smallexample\n+asm(\"repne scasb\"\n+    : \"=c\" (count), \"+D\" (p)\n+    : \"m\" (*(const char (*)[]) p), \"0\" (-1), \"a\" (0));\n+@end smallexample\n+\n+If you know the above will only be reading a ten byte array then you\n+could instead use a memory input like:\n+@code{\"m\" (*(const char (*)[10]) p)}.\n+\n+Here is an example of a PowerPC vector scale implemented in assembly,\n+complete with vector and condition code clobbers, and some initialized\n+offset registers that are unchanged by the @code{asm}.\n+\n+@smallexample\n+void\n+dscal (size_t n, double *x, double alpha)\n+@{\n+  asm (\"/* lots of asm here */\"\n+       : \"+m\" (*(double (*)[n]) x), \"+&r\" (n), \"+b\" (x)\n+       : \"d\" (alpha), \"b\" (32), \"b\" (48), \"b\" (64),\n+         \"b\" (80), \"b\" (96), \"b\" (112)\n+       : \"cr0\",\n+         \"vs32\",\"vs33\",\"vs34\",\"vs35\",\"vs36\",\"vs37\",\"vs38\",\"vs39\",\n+         \"vs40\",\"vs41\",\"vs42\",\"vs43\",\"vs44\",\"vs45\",\"vs46\",\"vs47\");\n+@}\n+@end smallexample\n \n @anchor{GotoLabels}\n @subsubsection Goto Labels"}, {"sha": "e6522df7942505cd7c3f325b0ceddcb3f0e296b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "patch": "@@ -1,3 +1,7 @@\n+2017-10-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* gcc.target/i386/asm-mem.c: New test.\n+\n 2017-10-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82498"}, {"sha": "89b713f0201cb4f03eb786abd7fd7068fb55f3ff", "filename": "gcc/testsuite/gcc.target/i386/asm-mem.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-mem.c?ref=7ff5eac3d885b15c52223dcd8f63a7b9b832d1ba", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3\" } */\n+\n+/* Check that \"m\" array references are effective in preventing the\n+   array initialization from wandering past a use in the asm, and\n+   that the casts remain supported.  */\n+\n+static int\n+f1 (const char *p)\n+{\n+  int count;\n+\n+  __asm__ (\"repne scasb\"\n+\t   : \"=c\" (count), \"+D\" (p)\n+\t   : \"m\" (*(const char (*)[]) p), \"0\" (-1), \"a\" (0));\n+  return -2 - count;\n+}\n+\n+static int\n+f2 (const char *p)\n+{\n+  int count;\n+\n+  __asm__ (\"repne scasb\"\n+\t   : \"=c\" (count), \"+D\" (p)\n+\t   : \"m\" (*(const char (*)[48]) p), \"0\" (-1), \"a\" (0));\n+  return -2 - count;\n+}\n+\n+static int\n+f3 (int n, const char *p)\n+{\n+  int count;\n+\n+  __asm__ (\"repne scasb\"\n+\t   : \"=c\" (count), \"+D\" (p)\n+\t   : \"m\" (*(const char (*)[n]) p), \"0\" (-1), \"a\" (0));\n+  return -2 - count;\n+}\n+\n+int\n+main ()\n+{\n+  int a;\n+  char buff[48] = \"hello world\";\n+  buff[4] = 0;\n+  a = f1 (buff);\n+  if (a != 4)\n+    __builtin_abort ();\n+  buff[4] = 'o';\n+  a = f2 (buff);\n+  if (a != 11)\n+    __builtin_abort ();\n+  buff[4] = 0;\n+  a = f3 (48, buff);\n+  if (a != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}