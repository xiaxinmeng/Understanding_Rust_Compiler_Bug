{"sha": "2ce9c1b9e15da5507207c4f2f217bcdde90babea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNlOWMxYjllMTVkYTU1MDcyMDdjNGYyZjIxN2JjZGRlOTBiYWJlYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-10-02T15:10:27Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-10-02T15:10:27Z"}, "message": "(TARGET_SHORT_BY_BYTES): New macro.\n\n(TARGET_SWITCHES): Recognize switches -m[no-]short-load-bytes.\n(TARGET_DEFAULT): Only define if not already done so.\n(PROMOTE_MODE): Promote HImode unsigned if TARGET_SHORT_BY_BYTES.\n(SECONDARY_INPUT_RELOAD_CLASS): Need a scratch for reloading HImode if\nTARGET_SHORT_BY_BYTES.\n\nFrom-SVN: r8200", "tree": {"sha": "f12b7b34778e77959d3823219760c973ee8d27f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f12b7b34778e77959d3823219760c973ee8d27f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ce9c1b9e15da5507207c4f2f217bcdde90babea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce9c1b9e15da5507207c4f2f217bcdde90babea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce9c1b9e15da5507207c4f2f217bcdde90babea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce9c1b9e15da5507207c4f2f217bcdde90babea/comments", "author": null, "committer": null, "parents": [{"sha": "0b9d35ddc15d4caca438fb8d8b253d746bf0e476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b9d35ddc15d4caca438fb8d8b253d746bf0e476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b9d35ddc15d4caca438fb8d8b253d746bf0e476"}], "stats": {"total": 53, "additions": 35, "deletions": 18}, "files": [{"sha": "d7acc07593b32ac04bda378c87387ac546095037", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce9c1b9e15da5507207c4f2f217bcdde90babea/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce9c1b9e15da5507207c4f2f217bcdde90babea/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=2ce9c1b9e15da5507207c4f2f217bcdde90babea", "patch": "@@ -86,6 +86,12 @@ extern int target_flags;\n    of condition flags when returning from a branch & link (ie. a function) */\n #define TARGET_6        (target_flags & 8)\n \n+/* Leave some bits for new processor variants */\n+\n+/* Nonzero if shorts must be loaded byte at a time.  This is not necessary\n+   for the arm processor chip, but it is needed for some MMU chips.  */\n+#define TARGET_SHORT_BY_BYTES\t(target_flags & 0x200)\n+\n /* ARM_EXTRA_TARGET_SWITCHES is used in riscix.h to define some options which\n    are passed to the preprocessor and the assembler post-processor.  They\n    aren't needed in the main pass of the compiler, but if we don't define\n@@ -96,16 +102,20 @@ extern int target_flags;\n #define ARM_EXTRA_TARGET_SWITCHES\n #endif\n \n-#define TARGET_SWITCHES  \\\n-{                         \t\t\t\\\n-  {\"apcs\",\t\t 1},\t\t\t\\\n-  {\"poke-function-name\", 2},\t\t\t\\\n-  {\"fpe\",\t\t 4},\t\t\t\\\n-  {\"6\",\t\t\t 8},\t\t\t\\\n-  {\"2\",\t\t\t-8},\t\t\t\\\n-  {\"3\",\t\t\t-8},\t\t\t\\\n-  ARM_EXTRA_TARGET_SWITCHES\t\t\t\\\n-  {\"\",   \t\t TARGET_DEFAULT }\t\\\n+#define TARGET_SWITCHES  \t\t\t\t\\\n+{                         \t\t\t\t\\\n+  {\"apcs\",\t\t \t 1},\t\t\t\\\n+  {\"poke-function-name\", \t 2},\t\t\t\\\n+  {\"fpe\",\t\t \t 4},\t\t\t\\\n+  {\"6\",\t\t\t\t 8},\t\t\t\\\n+  {\"2\",\t\t\t\t-8},\t\t\t\\\n+  {\"3\",\t\t\t\t-8},\t\t\t\\\n+  {\"short-load-bytes\",\t\t (0x200)},\t\t\\\n+  {\"no-short-load-bytes\",\t-(0x200)},\t\t\\\n+  {\"short-load-words\", \t\t-(0x200)},\t\t\\\n+  {\"no-short-load-words\",\t (0x200)},\t\t\\\n+  ARM_EXTRA_TARGET_SWITCHES\t\t\t\t\\\n+  {\"\",   \t\t \t TARGET_DEFAULT }\t\\\n }\n \n /* Which processor we are running on.  Currently this is only used to\n@@ -138,7 +148,9 @@ enum floating_point_type\n \n extern enum floating_point_type arm_fpu;\n \n+#ifndef TARGET_DEFAULT\n #define TARGET_DEFAULT  0\n+#endif\n \n #define TARGET_MEM_FUNCTIONS 1\n \n@@ -172,14 +184,14 @@ extern enum floating_point_type arm_fpu;\n /* It is far faster to zero extend chars than to sign extend them */\n \n #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT \\\n-      && GET_MODE_SIZE (MODE) < 4)      \\\n-    {\t\t\t\t\t\\\n-      if (MODE == QImode)\t\t\\\n-\tUNSIGNEDP = 1;\t\t\t\\\n-      else if (MODE == HImode)\t\t\\\n-\tUNSIGNEDP = 0;\t\t\t\\\n-      (MODE) = SImode;\t\t\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 4)      \t\\\n+    {\t\t\t\t\t\t\\\n+      if (MODE == QImode)\t\t\t\\\n+\tUNSIGNEDP = 1;\t\t\t\t\\\n+      else if (MODE == HImode)\t\t\t\\\n+\tUNSIGNEDP = TARGET_SHORT_BY_BYTES != 0;\t\\\n+      (MODE) = SImode;\t\t\t\t\\\n     }\n \n /* Define for XFmode extended real floating point support.\n@@ -547,6 +559,11 @@ enum reg_class\n     && true_regnum (X) == -1) ? GENERAL_REGS\t\t\\\n    : ((MODE) == HImode && true_regnum (X) == -1) ? GENERAL_REGS : NO_REGS)\n \n+/* If we need to load shorts byte-at-a-time, then we need a scratch. */\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)\t\t\t\\\n+  (((MODE) == HImode && TARGET_SHORT_BY_BYTES && true_regnum (X) == -1)\t\\\n+   ? GENERAL_REGS : NO_REGS)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits while FPU regs can hold any FP mode */"}]}