{"sha": "25b1c156df5f643af8369b7ce3571875c0d91a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjViMWMxNTZkZjVmNjQzYWY4MzY5YjdjZTM1NzE4NzVjMGQ5MWEwYQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-10-12T10:53:08Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-10-12T10:53:08Z"}, "message": "thumb.c - add warning about PIC code not being supported just yet.\n\narm.c - synchronised with devo\narm.md - synchronised with devo\nREADME-interworking - sychronised with devo.\n\nFrom-SVN: r23013", "tree": {"sha": "2eec2ad3633f3627e9aacd634149cad7e28fa154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2eec2ad3633f3627e9aacd634149cad7e28fa154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25b1c156df5f643af8369b7ce3571875c0d91a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25b1c156df5f643af8369b7ce3571875c0d91a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25b1c156df5f643af8369b7ce3571875c0d91a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25b1c156df5f643af8369b7ce3571875c0d91a0a/comments", "author": null, "committer": null, "parents": [{"sha": "5d4a5ee6d9554f9c76d32f53c6b8faded5070975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d4a5ee6d9554f9c76d32f53c6b8faded5070975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d4a5ee6d9554f9c76d32f53c6b8faded5070975"}], "stats": {"total": 570, "additions": 388, "deletions": 182}, "files": [{"sha": "f2868a6ae50e32451e2a7e8b29c0458fe258bcb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25b1c156df5f643af8369b7ce3571875c0d91a0a", "patch": "@@ -1,3 +1,8 @@\n+Mon Oct 12 10:50:44 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/thumb.c (thumb_override_options): Add warning about\n+\tPIC code not being supported just yet.\n+\n Sun Oct 11 16:49:15 EDT 1998  John Wehle  (john@feith.com)\n \n \t* flow.c: Update comment."}, {"sha": "46b76c9924251d6369ff8b7456515df7a4d23b89", "filename": "gcc/config/arm/README-interworking", "status": "modified", "additions": 358, "deletions": 169, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2FREADME-interworking", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2FREADME-interworking", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2FREADME-interworking?ref=25b1c156df5f643af8369b7ce3571875c0d91a0a", "patch": "@@ -145,14 +145,14 @@ declspec for individual functions, indicating that that particular\n function should support being called by non-interworking aware code.\n The function should be defined like this:\n \n-\tint function __attribute__((interfacearm))\n+\tint __attribute__((interfacearm)) function \n \t{\n \t\t... body of function ...\n \t}\n \n or\n \n-\tint function __declspec(interfacearm)\n+\tint __declspec(interfacearm) function\n \t{\n \t\t... body of function ...\n \t}\n@@ -162,8 +162,63 @@ or\n 4. Interworking support in dlltool\n ==================================\n \n-Currently there is no interworking support in dlltool.  This may be a\n-future enhancement.\n+It is possible to create DLLs containing mixed ARM and Thumb code.  It\n+is also possible to call Thumb code in a DLL from an ARM program and\n+vice versa.  It is even possible to call ARM DLLs that have been compiled\n+without interworking support (say by an older version of the compiler),\n+from Thumb programs and still have things work properly.\n+\n+   A version of the `dlltool' program which supports the `--interwork'\n+command line switch is needed, as well as the following special\n+considerations when building programs and DLLs:\n+\n+*Use `-mthumb-interwork'*\n+     When compiling files for a DLL or a program the `-mthumb-interwork'\n+     command line switch should be specified if calling between ARM and\n+     Thumb code can happen.  If a program is being compiled and the\n+     mode of the DLLs that it uses is not known, then it should be\n+     assumed that interworking might occur and the switch used.\n+\n+*Use `-m thumb'*\n+     If the exported functions from a DLL are all Thumb encoded then the\n+     `-m thumb' command line switch should be given to dlltool when\n+     building the stubs.  This will make dlltool create Thumb encoded\n+     stubs, rather than its default of ARM encoded stubs.\n+\n+     If the DLL consists of both exported Thumb functions and exported\n+     ARM functions then the `-m thumb' switch should not be used.\n+     Instead the Thumb functions in the DLL should be compiled with the\n+     `-mcallee-super-interworking' switch, or with the `interfacearm'\n+     attribute specified on their prototypes.  In this way they will be\n+     given ARM encoded prologues, which will work with the ARM encoded\n+     stubs produced by dlltool.\n+\n+*Use `-mcaller-super-interworking'*\n+     If it is possible for Thumb functions in a DLL to call\n+     non-interworking aware code via a function pointer, then the Thumb\n+     code must be compiled with the `-mcaller-super-interworking'\n+     command line switch.  This will force the function pointer calls\n+     to use the _interwork_call_via_rX stub functions which will\n+     correctly restore Thumb mode upon return from the called function.\n+\n+*Link with `libgcc.a'*\n+     When the dll is built it may have to be linked with the GCC\n+     library (`libgcc.a') in order to extract the _call_via_rX functions\n+     or the _interwork_call_via_rX functions.  This represents a partial\n+     redundancy since the same functions *may* be present in the\n+     application itself, but since they only take up 372 bytes this\n+     should not be too much of a consideration.\n+\n+*Use `--support-old-code'*\n+     When linking a program with an old DLL which does not support\n+     interworking, the `--support-old-code' command line switch to the\n+     linker should be used.   This causes the linker to generate special\n+     interworking stubs which can cope with old, non-interworking aware\n+     ARM code, at the cost of generating bulkier code.  The linker will\n+     still generate a warning message along the lines of:\n+       \"Warning: input file XXX does not support interworking, whereas YYY does.\"\n+     but this can now be ignored because the --support-old-code switch\n+     has been used.\n \n \n \n@@ -363,191 +418,325 @@ be restored upon exit from the function.\n 8. Some examples\n ================\n \n-Given this test file:\n+   Given these two test files:\n+\n+             int arm (void) { return 1 + thumb (); }\n+\n+             int thumb (void) { return 2 + arm (); }\n+\n+   The following pieces of assembler are produced by the ARM and Thumb\n+version of GCC depending upon the command line options used:\n+\n+   `-O2':\n+             .code 32                               .code 16\n+             .global _arm                           .global _thumb\n+                                                    .thumb_func\n+     _arm:                                    _thumb:\n+             mov     ip, sp\n+             stmfd   sp!, {fp, ip, lr, pc}          push    {lr}\n+             sub     fp, ip, #4\n+             bl      _thumb                          bl      _arm\n+             add     r0, r0, #1                      add     r0, r0, #2\n+             ldmea   fp, {fp, sp, pc}                pop     {pc}\n+\n+   Note how the functions return without using the BX instruction.  If\n+these files were assembled and linked together they would fail to work\n+because they do not change mode when returning to their caller.\n+\n+   `-O2 -mthumb-interwork':\n+\n+             .code 32                               .code 16\n+             .global _arm                           .global _thumb\n+                                                    .thumb_func\n+     _arm:                                    _thumb:\n+             mov     ip, sp\n+             stmfd   sp!, {fp, ip, lr, pc}          push    {lr}\n+             sub     fp, ip, #4\n+             bl      _thumb                         bl       _arm\n+             add     r0, r0, #1                     add      r0, r0, #2\n+             ldmea   fp, {fp, sp, lr}               pop      {r1}\n+             bx      lr                             bx       r1\n+\n+   Now the functions use BX to return their caller.  They have grown by\n+4 and 2 bytes respectively, but they can now successfully be linked\n+together and be expect to work.  The linker will replace the\n+destinations of the two BL instructions with the addresses of calling\n+stubs which convert to the correct mode before jumping to the called\n+function.\n+\n+   `-O2 -mcallee-super-interworking':\n+\n+             .code 32                               .code 32\n+             .global _arm                           .global _thumb\n+     _arm:                                    _thumb:\n+                                                    orr      r12, pc, #1\n+                                                    bx       r12\n+             mov     ip, sp                         .code 16\n+             stmfd   sp!, {fp, ip, lr, pc}          push     {lr}\n+             sub     fp, ip, #4\n+             bl      _thumb                         bl       _arm\n+             add     r0, r0, #1                     add      r0, r0, #2\n+             ldmea   fp, {fp, sp, lr}               pop      {r1}\n+             bx      lr                             bx       r1\n+\n+   The thumb function now has an ARM encoded prologue, and it no longer\n+has the `.thumb-func' pseudo op attached to it.  The linker will not\n+generate a calling stub for the call from arm() to thumb(), but it will\n+still have to generate a stub for the call from thumb() to arm().  Also\n+note how specifying `--mcallee-super-interworking' automatically\n+implies `-mthumb-interworking'.\n+\n+\n+9. Some Function Pointer Examples\n+=================================\n \n-\tint func (void) { return 1; }\n+   Given this test file:\n+\n+     \tint func (void) { return 1; }\n+     \n+     \tint call (int (* ptr)(void)) { return ptr (); }\n+\n+   The following varying pieces of assembler are produced by the Thumb\n+version of GCC depending upon the command line options used:\n+\n+   `-O2':\n+     \t\t.code\t16\n+     \t\t.globl\t_func\n+     \t\t.thumb_func\n+     \t_func:\n+     \t\tmov\tr0, #1\n+     \t\tbx\tlr\n+     \n+     \t\t.globl\t_call\n+     \t\t.thumb_func\n+     \t_call:\n+     \t\tpush\t{lr}\n+     \t\tbl\t__call_via_r0\n+     \t\tpop\t{pc}\n+\n+   Note how the two functions have different exit sequences.  In\n+particular call() uses pop {pc} to return, which would not work if the\n+caller was in ARM mode.  func() however, uses the BX instruction, even\n+though `-mthumb-interwork' has not been specified, as this is the most\n+efficient way to exit a function when the return address is held in the\n+link register.\n+\n+   `-O2 -mthumb-interwork':\n+\n+     \t\t.code\t16\n+     \t\t.globl\t_func\n+     \t\t.thumb_func\n+     \t_func:\n+     \t\tmov\tr0, #1\n+     \t\tbx\tlr\n+     \n+     \t\t.globl\t_call\n+     \t\t.thumb_func\n+     \t_call:\n+     \t\tpush\t{lr}\n+     \t\tbl\t__call_via_r0\n+     \t\tpop\t{r1}\n+     \t\tbx\tr1\n+\n+   This time both functions return by using the BX instruction.  This\n+means that call() is now two bytes longer and several cycles slower\n+than the previous version.\n+\n+   `-O2 -mcaller-super-interworking':\n+     \t\t.code\t16\n+     \t\t.globl\t_func\n+     \t\t.thumb_func\n+     \t_func:\n+     \t\tmov\tr0, #1\n+     \t\tbx\tlr\n+     \n+     \t\t.globl\t_call\n+     \t\t.thumb_func\n+     \t_call:\n+     \t\tpush\t{lr}\n+     \t\tbl\t__interwork_call_via_r0\n+     \t\tpop\t{pc}\n+\n+   Very similar to the first (non-interworking) version, except that a\n+different stub is used to call via the function pointer.  This new stub\n+will work even if the called function is not interworking aware, and\n+tries to return to call() in ARM mode.  Note that the assembly code for\n+call() is still not interworking aware itself, and so should not be\n+called from ARM code.\n+\n+   `-O2 -mcallee-super-interworking':\n+\n+     \t\t.code\t32\n+     \t\t.globl\t_func\n+     \t_func:\n+     \t\torr\tr12, pc, #1\n+     \t\tbx\tr12\n+     \n+     \t\t.code\t16\n+     \t\t.globl .real_start_of_func\n+     \t\t.thumb_func\n+     \t.real_start_of_func:\n+     \t\tmov\tr0, #1\n+     \t\tbx\tlr\n+     \n+     \t\t.code\t32\n+     \t\t.globl\t_call\n+     \t_call:\n+     \t\torr\tr12, pc, #1\n+     \t\tbx\tr12\n+     \n+     \t\t.code\t16\n+     \t\t.globl .real_start_of_call\n+     \t\t.thumb_func\n+     \t.real_start_of_call:\n+     \t\tpush\t{lr}\n+     \t\tbl\t__call_via_r0\n+     \t\tpop\t{r1}\n+     \t\tbx\tr1\n+\n+   Now both functions have an ARM coded prologue, and both functions\n+return by using the BX instruction.  These functions are interworking\n+aware therefore and can safely be called from ARM code.  The code for\n+the call() function is now 10 bytes longer than the original, non\n+interworking aware version, an increase of over 200%.\n \n-\tint call (int (* ptr)(void)) { return ptr (); }\n+   If a prototype for call() is added to the source code, and this\n+prototype includes the `interfacearm' attribute:\n+\n+     \tint __attribute__((interfacearm)) call (int (* ptr)(void));\n+\n+   then this code is produced (with only -O2 specified on the command\n+line):\n+\n+     \t\t.code\t16\n+     \t\t.globl\t_func\n+     \t\t.thumb_func\n+     \t_func:\n+     \t\tmov\tr0, #1\n+     \t\tbx\tlr\n+     \n+     \t\t.globl\t_call\n+     \t\t.code\t32\n+     \t_call:\n+     \t\torr\tr12, pc, #1\n+     \t\tbx\tr12\n+     \n+     \t\t.code\t16\n+     \t\t.globl .real_start_of_call\n+     \t\t.thumb_func\n+     \t.real_start_of_call:\n+     \t\tpush\t{lr}\n+     \t\tbl\t__call_via_r0\n+     \t\tpop\t{r1}\n+     \t\tbx\tr1\n+\n+   So now both call() and func() can be safely called via\n+non-interworking aware ARM code.  If, when such a file is assembled,\n+the assembler detects the fact that call() is being called by another\n+function in the same file, it will automatically adjust the target of\n+the BL instruction to point to .real_start_of_call.  In this way there\n+is no need for the linker to generate a Thumb-to-ARM calling stub so\n+that call can be entered in ARM mode.\n+\n+\n+10. How to use dlltool to build ARM/Thumb DLLs\n+==============================================\n+   Given a program (`prog.c') like this:\n \n-The following varying pieces of assembler are produced depending upon\n-the command line options used:\n+             extern int func_in_dll (void);\n+     \n+             int main (void) { return func_in_dll(); }\n \n-no options:\n+   And a DLL source file (`dll.c') like this:\n \n-\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n-\t\t.code\t16\n-\t\t.text\n-\t\t.globl\t_func\n-\t\t.thumb_func\n-\t_func:\n-\t\tmov\tr0, #1\n-\t\tbx\tlr\n+             int func_in_dll (void) { return 1; }\n \n-\t\t.globl\t_call\n-\t\t.thumb_func\n-\t_call:\n-\t\tpush\t{lr}\n-\t\tbl\t__call_via_r0\n-\t\tpop\t{pc}\n+   Here is how to build the DLL and the program for a purely ARM based\n+environment:\n \n-Note how the two functions have different exit sequences.  In\n-particular call() uses pop {pc} to return.  This would not work if the\n-caller was in ARM mode.\n+*Step One\n+     Build a `.def' file describing the DLL:\n \n-If -mthumb-interwork is specified on the command line:\n+             ; example.def\n+             ; This file describes the contents of the DLL\n+             LIBRARY     example\n+             HEAPSIZE    0x40000, 0x2000\n+             EXPORTS\n+                          func_in_dll  1\n \n-\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n-\t\t.code\t16\n-\t\t.text\n-\t\t.globl\t_func\n-\t\t.thumb_func\n-\t_func:\n-\t\tmov\tr0, #1\n-\t\tbx\tlr\n+*Step Two\n+     Compile the DLL source code:\n \n-\t\t.globl\t_call\n-\t\t.thumb_func\n-\t_call:\n-\t\tpush\t{lr}\n-\t\tbl\t__call_via_r0\n-\t\tpop\t{r1}\n-\t\tbx\tr1\n+            arm-pe-gcc -O2 -c dll.c\n \n-This time both functions return by using the BX instruction.  This\n-means that call() is now two bytes longer and several cycles slower\n-than the version that is not interworking enabled.\n+*Step Three\n+     Use `dlltool' to create an exports file and a library file:\n \n-If -mcaller-super-interworking is specified:\n+            dlltool --def example.def --output-exp example.o --output-lib example.a\n \n-\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n-\t\t.code\t16\n-\t\t.text\n-\t\t.globl\t_func\n-\t\t.thumb_func\n-\t_func:\n-\t\tmov\tr0, #1\n-\t\tbx\tlr\n+*Step Four\n+     Link together the complete DLL:\n \n-\t\t.globl\t_call\n-\t\t.thumb_func\n-\t_call:\n-\t\tpush\t{lr}\n-\t\tbl\t__interwork_call_via_r0\n-\t\tpop\t{pc}\n-\n-Very similar to the first (non-interworking) version, except that a\n-different stub is used to call via the function pointer.  Note that\n-the assembly code for call() is not interworking aware, and so should\n-not be called from ARM code.\n-\n-If -mcallee-super-interworking is specified:\n-\n-\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n-\t\t.code\t16\n-\t\t.text\n-\t\t.globl\t_func\n-\t\t.code\t32\n-\t_func:\n-\t\torr\tr12, pc, #1\n-\t\tbx\tr12\n-\t\t.code\t16\n-\t\t.globl .real_start_of_func\n-\t\t.thumb_func\n-\t.real_start_of_func:\n-\t\tmov\tr0, #1\n-\t\tbx\tlr\n+            arm-pe-ld dll.o example.o -o example.dll\n \n-\t\t.globl\t_call\n-\t\t.code\t32\n-\t_call:\n-\t\torr\tr12, pc, #1\n-\t\tbx\tr12\n-\t\t.code\t16\n-\t\t.globl .real_start_of_call\n-\t\t.thumb_func\n-\t.real_start_of_call:\n-\t\tpush\t{lr}\n-\t\tbl\t__call_via_r0\n-\t\tpop\t{r1}\n-\t\tbx\tr1\n+*Step Five\n+     Compile the program's source code:\n \n-Now both functions have an ARM coded prologue, and both functions\n-return by using the BX instruction.  These functions are interworking\n-aware therefore and can safely be called from ARM code.  The code for\n-the call() function is now 10 bytes longer than the original, non\n-interworking aware version, an increase of over 200%.\n+            arm-pe-gcc -O2 -c prog.c\n \n-If the source code is slightly altered so that only the call function\n-has an (interfacearm) attribute:\n+*Step Six\n+     Link together the program and the DLL's library file:\n \n-\tint func (void) { return 1; }\n-\tint call () __attribute__((interfacearm));\n-\tint call (int (* ptr)(void)) { return ptr (); }\n-\tint main (void) { return printf (\"result: %d\\n\", call (func)); }\n+            arm-pe-gcc prog.o example.a -o prog\n \n-then this code is produced (with no command line switches):\n+   If instead this was a Thumb DLL being called from an ARM program, the\n+steps would look like this.  (To save space only those steps that are\n+different from the previous version are shown):\n \n-\t@ Generated by gcc cygnus-2.91.07 980205 (gcc-2.8.0 release) for ARM/pe\n-\t\t.code\t16\n-\t\t.text\n-\t\t.globl\t_func\n-\t\t.thumb_func\n-\t_func:\n-\t\tmov\tr0, #1\n-\t\tbx\tlr\n+*Step Two\n+     Compile the DLL source code (using the Thumb compiler):\n \n-\t\t.globl\t_call\n-\t\t.code\t32\n-\t_call:\n-\t\torr\tr12, pc, #1\n-\t\tbx\tr12\n-\t\t.code\t16\n-\t\t.globl .real_start_of_call\n-\t\t.thumb_func\n-\t.real_start_of_call:\n-\t\tpush\t{lr}\n-\t\tbl\t__call_via_r0\n-\t\tpop\t{r1}\n-\t\tbx\tr1\n+            thumb-pe-gcc -O2 -c dll.c -mthumb-interwork\n \n-\t\t.globl\t_main\n-\t\t.thumb_func\n-\t_main:\n-\t\tpush\t{r4, lr}\n-\t\tbl\t___gccmain\n-\t\tldr\tr4, .L4\n-\t\tldr\tr0, .L4+4\n-\t\tbl\t_call\n-\t\tadd\tr1, r0, #0\n-\t\tadd\tr0, r4, #0\n-\t\tbl\t_printf\n-\t\tpop\t{r4, pc}\n-\t.L4:\n-\t\t.word\t.LC0\n-\t\t.word\t_func\n-\n-\t\t.section .rdata\n-\t.LC0:\n-\t\t.ascii\t\"result: %d\\n\\000\"\n-\n-So now only call() can be called via non-interworking aware ARM code.\n-When this program is assembled, the assembler detects the fact that\n-main() is calling call() in Thumb mode, and so automatically adjusts\n-the BL instruction to point to the real start of call():\n-\n-\tDisassembly of section .text:\n-\n-\t00000028 <_main>:\n-\t  28:\tb530      \tb530\tpush\t{r4, r5, lr}\n-\t  2a:\tfffef7ff \tf7ff\tbl\t2a <_main+0x2>\n-\t  2e:\t4d06      \t4d06\tldr\tr5, [pc, #24]\t(48 <.L7>)\n-\t  30:\tffe8f7ff \tf7ff\tbl\t4 <_doit>\n-\t  34:\t1c04      \t1c04\tadd\tr4, r0, #0\n-\t  36:\t4805      \t4805\tldr\tr0, [pc, #20]\t(4c <.L7+0x4>)\n-\t  38:\tfff0f7ff \tf7ff\tbl\t1c <.real_start_of_call>\n-\t  3c:\t1824      \t1824\tadd\tr4, r4, r0\n-\t  3e:\t1c28      \t1c28\tadd\tr0, r5, #0\n-\t  40:\t1c21      \t1c21\tadd\tr1, r4, #0\n-\t  42:\tfffef7ff \tf7ff\tbl\t42 <_main+0x1a>\n-\t  46:\tbd30      \tbd30\tpop\t{r4, r5, pc}\n+*Step Three\n+     Build the exports and library files (and support interworking):\n+\n+            dlltool -d example.def -z example.o -l example.a --interwork -m thumb\n+\n+*Step Five\n+     Compile the program's source code (and support interworking):\n+\n+            arm-pe-gcc -O2 -c prog.c -mthumb-interwork\n+\n+   If instead, the DLL was an old, ARM DLL which does not support\n+interworking, and which cannot be rebuilt, then these steps would be\n+used.\n+\n+*Step One\n+     Skip.  If you do not have access to the sources of a DLL, there is\n+     no point in building a `.def' file for it.\n+\n+*Step Two\n+     Skip.  With no DLL sources there is nothing to compile.\n+\n+*Step Three\n+     Skip.  Without a `.def' file you cannot use dlltool to build an\n+     exports file or a library file.\n+\n+*Step Four\n+     Skip.  Without a set of DLL object files you cannot build the DLL.\n+     Besides it has already been built for you by somebody else.\n+\n+*Step Five\n+     Compile the program's source code, this is the same as before:\n+\n+            arm-pe-gcc -O2 -c prog.c\n+\n+*Step Six\n+     Link together the program and the DLL's library file, passing the\n+     `--support-old-code' option to the linker:\n+\n+            arm-pe-gcc prog.o example.a -Wl,--support-old-code -o prog\n \n+     Ignore the warning message about the input file not supporting\n+     interworking as the --support-old-code switch has taken care if this."}, {"sha": "feaf7ba6d22870cc211aa23a648e240ee498b69a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=25b1c156df5f643af8369b7ce3571875c0d91a0a", "patch": "@@ -222,11 +222,14 @@ arm_override_options ()\n   int arm_thumb_aware = 0;\n   int flags = 0;\n   unsigned i;\n-  struct arm_cpu_select *ptr;\n-  static struct cpu_default {\n-    int cpu;\n-    char *name;\n-  } cpu_defaults[] = {\n+  struct arm_cpu_select * ptr;\n+  static struct cpu_default\n+  {\n+    int    cpu;\n+    char * name;\n+  }\n+  cpu_defaults[] =\n+  {\n     { TARGET_CPU_arm2, \"arm2\" },\n     { TARGET_CPU_arm6, \"arm6\" },\n     { TARGET_CPU_arm610, \"arm610\" },\n@@ -3642,7 +3645,7 @@ find_barrier (from, max_count)\n       \n       /* Walk back to be just before any jump.  */\n       while (GET_CODE (from) == JUMP_INSN\n-             || GET_CODE (from) == NOTE\n+\t     || GET_CODE (from) == NOTE\n \t     || GET_CODE (from) == CODE_LABEL)\n \tfrom = PREV_INSN (from);\n       \n@@ -4857,7 +4860,7 @@ output_return_instruction (operand, really_return, reverse)\n   else if (really_return)\n     {\n       if (TARGET_THUMB_INTERWORK)\n-\tsprintf (instr, \"bx%%?%%%s\\t%%|lr\", reverse ? \"D\" : \"d\");\n+\tsprintf (instr, \"bx%%?%%%s0\\t%%|lr\", reverse ? \"D\" : \"d\");\n       else\n \tsprintf (instr, \"mov%%?%%%s0%s\\t%%|pc, %%|lr\",\n \t\t reverse ? \"D\" : \"d\", TARGET_APCS_32 ? \"\" : \"s\");\n@@ -5156,10 +5159,10 @@ output_func_epilogue (f, frame_size)\n \t  /* And finally, go home */\n \t  if (TARGET_THUMB_INTERWORK)\n \t    fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n+\t  else if (TARGET_APCS_32)\n+\t    fprintf (f, \"\\tmov\\t%spc, %slr\\n\", REGISTER_PREFIX, REGISTER_PREFIX );\n \t  else\n-\t    fprintf (f, (TARGET_APCS_32 ? \"\\tmov\\t%spc, %slr\\n\"\n-\t\t\t : \"\\tmovs\\t%spc, %slr\\n\"),\n-\t\t     REGISTER_PREFIX, REGISTER_PREFIX, f);\n+\t    fprintf (f, \"\\tmovs\\t%spc, %slr\\n\", REGISTER_PREFIX, REGISTER_PREFIX );\n \t}\n     }\n "}, {"sha": "ffbff79aff85edf2dc45f4e3ffb2c970c4a89943", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=25b1c156df5f643af8369b7ce3571875c0d91a0a", "patch": "@@ -5888,7 +5888,8 @@\n   \"sub%?s\\\\t%0, %1, #0\"\n [(set_attr \"conds\" \"set\")])\n \n-; Peepholes to spot possible load- and store-multiples.\n+; Peepholes to spot possible load- and store-multiples, if the ordering is\n+; reversed, check that the memory references aren't volatile.\n \n (define_peephole\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")"}, {"sha": "bd302a5966591639dc7ac11a5f86843ca4cabe2e", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25b1c156df5f643af8369b7ce3571875c0d91a0a/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=25b1c156df5f643af8369b7ce3571875c0d91a0a", "patch": "@@ -1465,7 +1465,8 @@ thumb_unexpanded_epilogue ()\n       if ((live_regs_mask & (1 << PROGRAM_COUNTER)) == 0)\n \tthumb_exit (asm_out_file,\n \t\t    (had_to_push_lr\n-\t\t     && is_called_in_ARM_mode (current_function_decl)) ? -1 : LINK_REGISTER);\n+\t\t     && is_called_in_ARM_mode (current_function_decl)) ?\n+\t\t    -1 : LINK_REGISTER);\n     }\n   else\n     {\n@@ -1971,7 +1972,8 @@ thumb_return_in_memory (type)\n   return 1;\n }\n \n-void thumb_override_options()\n+void\n+thumb_override_options ()\n {\n   if (structure_size_string != NULL)\n     {\n@@ -1982,4 +1984,10 @@ void thumb_override_options()\n       else\n \twarning (\"Structure size boundary can only be set to 8 or 32\");\n     }\n+\n+  if (flag_pic)\n+    {\n+      warning (\"Position independent code not supported.  Ignored\");\n+      flag_pic = 0;\n+    }\n }"}]}