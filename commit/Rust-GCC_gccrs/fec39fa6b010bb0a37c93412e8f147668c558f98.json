{"sha": "fec39fa6b010bb0a37c93412e8f147668c558f98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVjMzlmYTZiMDEwYmIwYTM3YzkzNDEyZThmMTQ3NjY4YzU1OGY5OA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2013-11-18T12:18:12Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2013-11-18T12:18:12Z"}, "message": "remove nolonger needed {cgraph,varpool}_node_{,asm_}name () functions\n\nFrom-SVN: r204946", "tree": {"sha": "a5a2310e101e4acec88120d4acdb8a49b8cf9bb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5a2310e101e4acec88120d4acdb8a49b8cf9bb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fec39fa6b010bb0a37c93412e8f147668c558f98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec39fa6b010bb0a37c93412e8f147668c558f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fec39fa6b010bb0a37c93412e8f147668c558f98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec39fa6b010bb0a37c93412e8f147668c558f98/comments", "author": null, "committer": null, "parents": [{"sha": "1f66e10e20b9b281a77ff85b2db40574524054ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f66e10e20b9b281a77ff85b2db40574524054ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f66e10e20b9b281a77ff85b2db40574524054ac"}], "stats": {"total": 430, "additions": 211, "deletions": 219}, "files": [{"sha": "8bb1a441535a4179e35f3e53e841c0f2fcb22e72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -1,3 +1,15 @@\n+2013-11-18  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* cgraph.h (symtab_node_asm_name): Rename to symtab_node::asm_name.\n+\t(symtab_node_name): Rename to symtab_node::name.\n+\t(cgraph_node_asm_name): Remove.\n+\t(varpool_node_asm_name): Remove.\n+\t* cgraph.c cgraphclones.c cgraphunit.c ipa-cp.c ipa-devirt.c\n+\tipa-inline-analysis.c ipa-inline-transform.c ipa-inline.c\n+\tipa-profile.c ipa-prop.c ipa-pure-const.c ipa-ref.c ipa-reference.c\n+\tipa-utils.c ipa.c symtab.c tree-inline.c tree-sra.c\n+\ttree-ssa-structalias.c value-prof.c varpool.c Adjust.\n+\n 2013-11-18  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/aarch-cost-tables.h (cortexa53_extra_costs): New table."}, {"sha": "018cc09adc4ea8f875c30f42b0885186cd864d76", "filename": "gcc/cgraph.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -562,11 +562,11 @@ cgraph_get_create_node (tree decl)\n       if (dump_file)\n \tfprintf (dump_file, \"Introduced new external node \"\n \t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n-\t\t xstrdup (cgraph_node_name (node)), node->order);\n+\t\t xstrdup (node->name ()), node->order);\n     }\n   else if (dump_file)\n     fprintf (dump_file, \"Introduced new external node \"\n-\t     \"(%s/%i).\\n\", xstrdup (cgraph_node_name (node)),\n+\t     \"(%s/%i).\\n\", xstrdup (node->name ()),\n \t     node->order);\n   return node;\n }\n@@ -1097,8 +1097,8 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n     {\n       fprintf (dump_file, \"Indirect call -> speculative call\"\n \t       \" %s/%i => %s/%i\\n\",\n-\t       xstrdup (cgraph_node_name (n)), n->order,\n-\t       xstrdup (cgraph_node_name (n2)), n2->order);\n+\t       xstrdup (n->name ()), n->order,\n+\t       xstrdup (n2->name ()), n2->order);\n     }\n   e->speculative = true;\n   e2 = cgraph_create_edge (n, n2, e->call_stmt, direct_count, direct_frequency);\n@@ -1217,16 +1217,16 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n \t    {\n \t      fprintf (dump_file, \"Speculative indirect call %s/%i => %s/%i has \"\n \t\t       \"turned out to have contradicting known target \",\n-\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->order,\n-\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->order);\n+\t\t       xstrdup (edge->caller->name ()), edge->caller->order,\n+\t\t       xstrdup (e2->callee->name ()), e2->callee->order);\n \t      print_generic_expr (dump_file, callee_decl, 0);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  else\n \t    {\n \t      fprintf (dump_file, \"Removing speculative call %s/%i => %s/%i\\n\",\n-\t\t       xstrdup (cgraph_node_name (edge->caller)), edge->caller->order,\n-\t\t       xstrdup (cgraph_node_name (e2->callee)), e2->callee->order);\n+\t\t       xstrdup (edge->caller->name ()), edge->caller->order,\n+\t\t       xstrdup (e2->callee->name ()), e2->callee->order);\n \t    }\n \t}\n     }\n@@ -1342,9 +1342,9 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not expanding speculative call of %s/%i -> %s/%i\\n\"\n \t\t     \"Type mismatch.\\n\",\n-\t\t     xstrdup (cgraph_node_name (e->caller)),\n+\t\t     xstrdup (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (cgraph_node_name (e->callee)),\n+\t\t     xstrdup (e->callee->name ()),\n \t\t     e->callee->order);\n \t  e = cgraph_resolve_speculation (e, NULL);\n \t  /* We are producing the final function body and will throw away the\n@@ -1361,9 +1361,9 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t    fprintf (dump_file,\n \t\t     \"Expanding speculative call of %s/%i -> %s/%i count:\"\n \t\t     HOST_WIDEST_INT_PRINT_DEC\"\\n\",\n-\t\t     xstrdup (cgraph_node_name (e->caller)),\n+\t\t     xstrdup (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (cgraph_node_name (e->callee)),\n+\t\t     xstrdup (e->callee->name ()),\n \t\t     e->callee->order,\n \t\t     (HOST_WIDEST_INT)e->count);\n \t  gcc_assert (e2->speculative);\n@@ -1411,8 +1411,8 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"updating call of %s/%i -> %s/%i: \",\n-\t       xstrdup (cgraph_node_name (e->caller)), e->caller->order,\n-\t       xstrdup (cgraph_node_name (e->callee)), e->callee->order);\n+\t       xstrdup (e->caller->name ()), e->caller->order,\n+\t       xstrdup (e->callee->name ()), e->callee->order);\n       print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n       if (e->callee->clone.combined_args_to_skip)\n \t{\n@@ -1891,13 +1891,13 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \n   if (node->global.inlined_to)\n     fprintf (f, \"  Function %s/%i is inline copy in %s/%i\\n\",\n-\t     xstrdup (cgraph_node_name (node)),\n+\t     xstrdup (node->name ()),\n \t     node->order,\n-\t     xstrdup (cgraph_node_name (node->global.inlined_to)),\n+\t     xstrdup (node->global.inlined_to->name ()),\n \t     node->global.inlined_to->order);\n   if (node->clone_of)\n     fprintf (f, \"  Clone of %s/%i\\n\",\n-\t     cgraph_node_asm_name (node->clone_of),\n+\t     node->clone_of->asm_name (),\n \t     node->clone_of->order);\n   if (cgraph_function_flags_ready)\n     fprintf (f, \"  Availability: %s\\n\",\n@@ -1912,7 +1912,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n \t     (HOST_WIDEST_INT)node->count);\n   if (node->origin)\n-    fprintf (f, \" nested in: %s\", cgraph_node_asm_name (node->origin));\n+    fprintf (f, \" nested in: %s\", node->origin->asm_name ());\n   if (gimple_has_body_p (node->decl))\n     fprintf (f, \" body\");\n   if (node->process)\n@@ -1958,7 +1958,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \n   for (edge = node->callers; edge; edge = edge->next_caller)\n     {\n-      fprintf (f, \"%s/%i \", cgraph_node_asm_name (edge->caller),\n+      fprintf (f, \"%s/%i \", edge->caller->asm_name (),\n \t       edge->caller->order);\n       if (edge->count)\n \tfprintf (f, \"(\"HOST_WIDEST_INT_PRINT_DEC\"x) \",\n@@ -1979,7 +1979,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   fprintf (f, \"\\n  Calls: \");\n   for (edge = node->callees; edge; edge = edge->next_callee)\n     {\n-      fprintf (f, \"%s/%i \", cgraph_node_asm_name (edge->callee),\n+      fprintf (f, \"%s/%i \", edge->callee->asm_name (),\n \t       edge->callee->order);\n       if (edge->speculative)\n \tfprintf (f, \"(speculative) \");\n@@ -2599,8 +2599,8 @@ verify_cgraph_node (struct cgraph_node *node)\n     if (e->aux)\n       {\n \terror (\"aux field set for edge %s->%s\",\n-\t       identifier_to_locale (cgraph_node_name (e->caller)),\n-\t       identifier_to_locale (cgraph_node_name (e->callee)));\n+\t       identifier_to_locale (e->caller->name ()),\n+\t       identifier_to_locale (e->callee->name ()));\n \terror_found = true;\n       }\n   if (node->count < 0)\n@@ -2638,15 +2638,15 @@ verify_cgraph_node (struct cgraph_node *node)\n       if (e->aux)\n \t{\n \t  error (\"aux field set for indirect edge from %s\",\n-\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n+\t\t identifier_to_locale (e->caller->name ()));\n \t  error_found = true;\n \t}\n       if (!e->indirect_unknown_callee\n \t  || !e->indirect_info)\n \t{\n \t  error (\"An indirect edge from %s is not marked as indirect or has \"\n \t\t \"associated indirect_info, the corresponding statement is: \",\n-\t\t identifier_to_locale (cgraph_node_name (e->caller)));\n+\t\t identifier_to_locale (e->caller->name ()));\n \t  cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n \t  error_found = true;\n \t}\n@@ -2866,8 +2866,8 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  if (!e->aux)\n \t    {\n \t      error (\"edge %s->%s has no corresponding call_stmt\",\n-\t\t     identifier_to_locale (cgraph_node_name (e->caller)),\n-\t\t     identifier_to_locale (cgraph_node_name (e->callee)));\n+\t\t     identifier_to_locale (e->caller->name ()),\n+\t\t     identifier_to_locale (e->callee->name ()));\n \t      cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n \t      error_found = true;\n \t    }\n@@ -2878,7 +2878,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  if (!e->aux && !e->speculative)\n \t    {\n \t      error (\"an indirect edge from %s has no corresponding call_stmt\",\n-\t\t     identifier_to_locale (cgraph_node_name (e->caller)));\n+\t\t     identifier_to_locale (e->caller->name ()));\n \t      cgraph_debug_gimple_stmt (this_cfun, e->call_stmt);\n \t      error_found = true;\n \t    }"}, {"sha": "db36f5e8be75a49b1b1f7116998acd5432d71608", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -44,6 +44,12 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   symtab_node\n {\n public:\n+  /* Return name.  */\n+  const char *name () const;\n+\n+  /* Return asm name.  */\n+  const char * asm_name () const;\n+\n   /* Type of the symbol.  */\n   ENUM_BITFIELD (symtab_type) type : 8;\n \n@@ -589,8 +595,6 @@ void symtab_unregister_node (symtab_node *);\n void symtab_remove_node (symtab_node *);\n symtab_node *symtab_get_node (const_tree);\n symtab_node *symtab_node_for_asm (const_tree asmname);\n-const char * symtab_node_asm_name (symtab_node *);\n-const char * symtab_node_name (symtab_node *);\n void symtab_insert_node_to_hashtable (symtab_node *);\n void symtab_add_to_same_comdat_group (symtab_node *, symtab_node *);\n void symtab_dissolve_same_comdat_group_list (symtab_node *node);\n@@ -879,34 +883,6 @@ varpool_get_node (const_tree decl)\n   return varpool (symtab_get_node (decl));\n }\n \n-/* Return asm name of cgraph node.  */\n-static inline const char *\n-cgraph_node_asm_name (struct cgraph_node *node)\n-{\n-  return symtab_node_asm_name (node);\n-}\n-\n-/* Return asm name of varpool node.  */\n-static inline const char *\n-varpool_node_asm_name (struct varpool_node *node)\n-{\n-  return symtab_node_asm_name (node);\n-}\n-\n-/* Return name of cgraph node.  */\n-static inline const char *\n-cgraph_node_name (struct cgraph_node *node)\n-{\n-  return symtab_node_name (node);\n-}\n-\n-/* Return name of varpool node.  */\n-static inline const char *\n-varpool_node_name (struct varpool_node *node)\n-{\n-  return symtab_node_name (node);\n-}\n-\n /* Walk all symbols.  */\n #define FOR_EACH_SYMBOL(node) \\\n    for ((node) = symtab_nodes; (node); (node) = (node)->next)"}, {"sha": "28e40639e32d10f2d08deb8d1bf5eee7898eb4f2", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -970,8 +970,8 @@ cgraph_materialize_all_clones (void)\n \t\t  if (cgraph_dump_file)\n \t\t    {\n \t\t      fprintf (cgraph_dump_file, \"cloning %s to %s\\n\",\n-\t\t\t       xstrdup (cgraph_node_name (node->clone_of)),\n-\t\t\t       xstrdup (cgraph_node_name (node)));\n+\t\t\t       xstrdup (node->clone_of->name ()),\n+\t\t\t       xstrdup (node->name ()));\n \t\t      if (node->clone.tree_map)\n \t\t        {\n \t\t\t  unsigned int i;"}, {"sha": "4a351180ae5b79a84169381ccad1565ff2228657", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -964,7 +964,7 @@ analyze_functions (void)\n \t\tfprintf (cgraph_dump_file, \"Trivially needed symbols:\");\n \t      changed = true;\n \t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \" %s\", symtab_node_asm_name (node));\n+\t\tfprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n \t      if (!changed && cgraph_dump_file)\n \t\tfprintf (cgraph_dump_file, \"\\n\");\n \t    }\n@@ -1077,7 +1077,7 @@ analyze_functions (void)\n       if (!node->aux && !referred_to_p (node))\n \t{\n \t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" %s\", symtab_node_name (node));\n+\t    fprintf (cgraph_dump_file, \" %s\", node->name ());\n \t  symtab_remove_node (node);\n \t  continue;\n \t}"}, {"sha": "a9d502d3d21fd4cedc0b07f45c1c640e7c5bd93a", "filename": "gcc/gdbhooks.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -223,7 +223,7 @@ def __init__(self, gdbval):\n     def to_string (self):\n         result = '<cgraph_node* 0x%x' % long(self.gdbval)\n         if long(self.gdbval):\n-            # symtab_node_name calls lang_hooks.decl_printable_name\n+            # symtab_node::name calls lang_hooks.decl_printable_name\n             # default implementation (lhd_decl_printable_name) is:\n             #    return IDENTIFIER_POINTER (DECL_NAME (decl));\n             tree_decl = Tree(self.gdbval['decl'])"}, {"sha": "97adbbd0f24adbe73200b9bdcbacc6318f7bb105", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -381,7 +381,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n       struct ipa_node_params *info;\n \n       info = IPA_NODE_REF (node);\n-      fprintf (f, \"  Node: %s/%i:\\n\", cgraph_node_name (node),\n+      fprintf (f, \"  Node: %s/%i:\\n\", node->name (),\n \t       node->order);\n       count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n@@ -432,7 +432,7 @@ determine_versionability (struct cgraph_node *node)\n \n   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n     fprintf (dump_file, \"Function %s/%i is not versionable, reason: %s.\\n\",\n-\t     cgraph_node_name (node), node->order, reason);\n+\t     node->name (), node->order, reason);\n \n   node->local.versionable = (reason == NULL);\n }\n@@ -504,7 +504,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n       if (dump_file)\n         fprintf (dump_file, \"Not considering %s for cloning; \"\n \t\t \"-fipa-cp-clone disabled.\\n\",\n- \t         cgraph_node_name (node));\n+ \t         node->name ());\n       return false;\n     }\n \n@@ -513,7 +513,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n       if (dump_file)\n         fprintf (dump_file, \"Not considering %s for cloning; \"\n \t\t \"optimizing it for size.\\n\",\n- \t         cgraph_node_name (node));\n+ \t         node->name ());\n       return false;\n     }\n \n@@ -524,7 +524,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Considering %s for cloning; code might shrink.\\n\",\n- \t         cgraph_node_name (node));\n+ \t         node->name ());\n       return true;\n     }\n \n@@ -538,20 +538,20 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Considering %s for cloning; \"\n \t\t     \"usually called directly.\\n\",\n-\t\t     cgraph_node_name (node));\n+\t\t     node->name ());\n \t  return true;\n         }\n     }\n   if (!stats.n_hot_calls)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not considering %s for cloning; no hot calls.\\n\",\n-\t\t cgraph_node_name (node));\n+\t\t node->name ());\n       return false;\n     }\n   if (dump_file)\n     fprintf (dump_file, \"Considering %s for cloning.\\n\",\n-\t     cgraph_node_name (node));\n+\t     node->name ());\n   return true;\n }\n \n@@ -712,7 +712,7 @@ initialize_node_lattices (struct cgraph_node *node)\n       if (dump_file && (dump_flags & TDF_DETAILS)\n \t  && !node->alias && !node->thunk.thunk_p)\n \tfprintf (dump_file, \"Marking all lattices of %s/%i as %s\\n\",\n-\t\t cgraph_node_name (node), node->order,\n+\t\t node->name (), node->order,\n \t\t disable ? \"BOTTOM\" : \"VARIABLE\");\n     }\n \n@@ -1817,7 +1817,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nEstimating effects for %s/%i, base_time: %i.\\n\",\n-\t     cgraph_node_name (node), node->order, base_time);\n+\t     node->name (), node->order, base_time);\n \n   always_const = gather_context_independent_values (info, &known_csts,\n \t\t\t\t\t\t    &known_binfos, &known_aggs,\n@@ -2506,14 +2506,14 @@ dump_profile_updates (struct cgraph_node *orig_node,\n   for (cs = new_node->callees; cs ; cs = cs->next_callee)\n     fprintf (dump_file, \"      edge to %s has count \"\n \t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t     cgraph_node_name (cs->callee), (HOST_WIDE_INT) cs->count);\n+\t     cs->callee->name (), (HOST_WIDE_INT) cs->count);\n \n   fprintf (dump_file, \"    setting count of the original node to \"\n \t   HOST_WIDE_INT_PRINT_DEC \"\\n\", (HOST_WIDE_INT) orig_node->count);\n   for (cs = orig_node->callees; cs ; cs = cs->next_callee)\n     fprintf (dump_file, \"      edge to %s is left with \"\n \t     HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t     cgraph_node_name (cs->callee), (HOST_WIDE_INT) cs->count);\n+\t     cs->callee->name (), (HOST_WIDE_INT) cs->count);\n }\n \n /* After a specialized NEW_NODE version of ORIG_NODE has been created, update\n@@ -2544,7 +2544,7 @@ update_profiling_info (struct cgraph_node *orig_node,\n \tfprintf (dump_file, \"    Problem: node %s/%i has too low count \"\n \t\t HOST_WIDE_INT_PRINT_DEC \" while the sum of incoming \"\n \t\t \"counts is \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t cgraph_node_name (orig_node), orig_node->order,\n+\t\t orig_node->name (), orig_node->order,\n \t\t (HOST_WIDE_INT) orig_node_count,\n \t\t (HOST_WIDE_INT) (orig_sum + new_sum));\n \n@@ -2683,7 +2683,7 @@ create_specialized_node (struct cgraph_node *node,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"     the new node is %s/%i.\\n\",\n-\t       cgraph_node_name (new_node), new_node->order);\n+\t       new_node->name (), new_node->order);\n       if (aggvals)\n \tipa_dump_agg_replacement_values (dump_file, aggvals);\n     }\n@@ -3235,9 +3235,9 @@ perhaps_add_new_callers (struct cgraph_node *node, struct ipcp_value *val)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \" - adding an extra caller %s/%i\"\n \t\t\t     \" of %s/%i\\n\",\n-\t\t\t     xstrdup (cgraph_node_name (cs->caller)),\n+\t\t\t     xstrdup (cs->caller->name ()),\n \t\t\t     cs->caller->order,\n-\t\t\t     xstrdup (cgraph_node_name (val->spec_node)),\n+\t\t\t     xstrdup (val->spec_node->name ()),\n \t\t\t     val->spec_node->order);\n \n \t\t  cgraph_redirect_edge_callee (cs, val->spec_node);\n@@ -3342,7 +3342,7 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n \n   if (dump_file)\n     fprintf (dump_file, \"  Creating a specialized node of %s/%i.\\n\",\n-\t     cgraph_node_name (node), node->order);\n+\t     node->name (), node->order);\n \n   callers = gather_edges_for_value (val, caller_count);\n   kv = known_csts.copy ();\n@@ -3379,7 +3379,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nEvaluating opportunities for %s/%i.\\n\",\n-\t     cgraph_node_name (node), node->order);\n+\t     node->name (), node->order);\n \n   gather_context_independent_values (info, &known_csts, &known_binfos,\n \t\t\t\t  info->do_clone_for_all_contexts ? &known_aggs\n@@ -3422,7 +3422,7 @@ decide_whether_version_node (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \" - Creating a specialized node of %s/%i \"\n-\t\t \"for all known contexts.\\n\", cgraph_node_name (node),\n+\t\t \"for all known contexts.\\n\", node->name (),\n \t\t node->order);\n \n       callers = collect_callers_of_node (node);\n@@ -3514,7 +3514,7 @@ identify_dead_nodes (struct cgraph_node *node)\n       for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n \tif (IPA_NODE_REF (v)->node_dead)\n \t  fprintf (dump_file, \"  Marking node as dead: %s/%i.\\n\",\n-\t\t   cgraph_node_name (v), v->order);\n+\t\t   v->name (), v->order);\n     }\n }\n "}, {"sha": "30bfd64686a378d6a090b1812664e885b14dc8fb", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -890,7 +890,7 @@ dump_possible_polymorphic_call_targets (FILE *f,\n \t   (int)otr_token,\n \t   final ? \" (full list)\" : \" (partial list, may call to other unit)\");\n   for (i = 0; i < targets.length (); i++)\n-    fprintf (f, \" %s/%i\", cgraph_node_name (targets[i]),\n+    fprintf (f, \" %s/%i\", targets[i]->name (),\n \t     targets[i]->order);\n   fprintf (f, \"\\n\");\n }\n@@ -988,7 +988,7 @@ ipa_devirt (void)\n       bool update = false;\n       if (dump_file && n->indirect_calls)\n \tfprintf (dump_file, \"\\n\\nProcesing function %s/%i\\n\",\n-\t\t cgraph_node_name (n), n->order);\n+\t\t n->name (), n->order);\n       for (e = n->indirect_calls; e; e = e->next_callee)\n \tif (e->indirect_info->polymorphic)\n \t  {\n@@ -1101,8 +1101,8 @@ ipa_devirt (void)\n \t\tif (dump_file)\n \t\t  fprintf (dump_file,\n \t\t\t   \"Speculatively devirtualizing call in %s/%i to %s/%i\\n\",\n-\t\t\t   cgraph_node_name (n), n->order,\n-\t\t\t   cgraph_node_name (likely_target),\n+\t\t\t   n->name (), n->order,\n+\t\t\t   likely_target->name (),\n \t\t\t   likely_target->order);\n \t\tif (!symtab_can_be_discarded (likely_target))\n \t\t  {"}, {"sha": "fb05caec6571d411423fdf2dce729c70de09e212", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -1301,7 +1301,7 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n       fprintf (f,\n \t       \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4i size:%2i\"\n \t       \" time: %2i callee size:%2i stack:%2i\",\n-\t       indent, \"\", cgraph_node_name (callee), callee->order,\n+\t       indent, \"\", callee->name (), callee->order,\n \t       !edge->inline_failed\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n \t       indent, \"\", es->loop_depth, edge->frequency,\n@@ -1366,7 +1366,7 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n       struct inline_summary *s = inline_summary (node);\n       size_time_entry *e;\n       int i;\n-      fprintf (f, \"Inline summary for %s/%i\", cgraph_node_name (node),\n+      fprintf (f, \"Inline summary for %s/%i\", node->name (),\n \t       node->order);\n       if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n \tfprintf (f, \" always_inline\");\n@@ -2383,7 +2383,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nAnalyzing function body size: %s\\n\",\n-\t     cgraph_node_name (node));\n+\t     node->name ());\n \n   /* When we run into maximal number of entries, we assign everything to the\n      constant truth case.  Be sure to have it in list. */\n@@ -2990,7 +2990,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     {\n       bool found = false;\n       fprintf (dump_file, \"   Estimating body: %s/%i\\n\"\n-\t       \"   Known to be false: \", cgraph_node_name (node),\n+\t       \"   Known to be false: \", node->name (),\n \t       node->order);\n \n       for (i = predicate_not_inlined_condition;\n@@ -3772,7 +3772,7 @@ inline_analyze_function (struct cgraph_node *node)\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nAnalyzing function: %s/%u\\n\",\n-\t     cgraph_node_name (node), node->order);\n+\t     node->name (), node->order);\n   if (optimize && !node->thunk.thunk_p)\n     inline_indirect_intraprocedural_analysis (node);\n   compute_inline_parameters (node, false);"}, {"sha": "7fb4ab97fa4a09e14a3e3b495392eefbb5b1ef13", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -310,7 +310,7 @@ save_inline_function_body (struct cgraph_node *node)\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nSaving body of %s for later reuse\\n\",\n-\t     cgraph_node_name (node));\n+\t     node->name ());\n  \n   gcc_assert (node == cgraph_get_node (node->decl));\n "}, {"sha": "c9a373bc08feec546747f319c83ef7b6df2d56af", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -222,8 +222,8 @@ report_inline_failed_reason (struct cgraph_edge *e)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"  not inlinable: %s/%i -> %s/%i, %s\\n\",\n-\t       xstrdup (cgraph_node_name (e->caller)), e->caller->order,\n-\t       xstrdup (cgraph_node_name (e->callee)), e->callee->order,\n+\t       xstrdup (e->caller->name ()), e->caller->order,\n+\t       xstrdup (e->callee->name ()), e->callee->order,\n \t       cgraph_inline_failed_string (e->inline_failed));\n     }\n }\n@@ -434,9 +434,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"call is cold and code would grow by %i\\n\",\n-\t\t     xstrdup (cgraph_node_name (e->caller)),\n+\t\t     xstrdup (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (cgraph_node_name (callee)), callee->order,\n+\t\t     xstrdup (callee->name ()), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -445,9 +445,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns\\n\",\n-\t\t     xstrdup (cgraph_node_name (e->caller)),\n+\t\t     xstrdup (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (cgraph_node_name (callee)), callee->order,\n+\t\t     xstrdup (callee->name ()), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -458,9 +458,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n \t    fprintf (dump_file, \"  will not early inline: %s/%i->%s/%i, \"\n \t\t     \"growth %i exceeds --param early-inlining-insns \"\n \t\t     \"divided by number of calls\\n\",\n-\t\t     xstrdup (cgraph_node_name (e->caller)),\n+\t\t     xstrdup (e->caller->name ()),\n \t\t     e->caller->order,\n-\t\t     xstrdup (cgraph_node_name (callee)), callee->order,\n+\t\t     xstrdup (callee->name ()), callee->order,\n \t\t     growth);\n \t  want_inline = false;\n \t}\n@@ -870,9 +870,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   if (dump)\n     {\n       fprintf (dump_file, \"    Badness calculation for %s/%i -> %s/%i\\n\",\n-\t       xstrdup (cgraph_node_name (edge->caller)),\n+\t       xstrdup (edge->caller->name ()),\n \t       edge->caller->order,\n-\t       xstrdup (cgraph_node_name (callee)),\n+\t       xstrdup (callee->name ()),\n \t       edge->callee->order);\n       fprintf (dump_file, \"      size growth %i, time %i \",\n \t       growth,\n@@ -1037,9 +1037,9 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t    {\n \t      fprintf (dump_file,\n \t\t       \"  decreasing badness %s/%i -> %s/%i, %i to %i\\n\",\n-\t\t       xstrdup (cgraph_node_name (edge->caller)),\n+\t\t       xstrdup (edge->caller->name ()),\n \t\t       edge->caller->order,\n-\t\t       xstrdup (cgraph_node_name (edge->callee)),\n+\t\t       xstrdup (edge->callee->name ()),\n \t\t       edge->callee->order,\n \t\t       (int)n->key,\n \t\t       badness);\n@@ -1054,9 +1054,9 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t {\n \t   fprintf (dump_file,\n \t\t    \"  enqueuing call %s/%i -> %s/%i, badness %i\\n\",\n-\t\t    xstrdup (cgraph_node_name (edge->caller)),\n+\t\t    xstrdup (edge->caller->name ()),\n \t\t    edge->caller->order,\n-\t\t    xstrdup (cgraph_node_name (edge->callee)),\n+\t\t    xstrdup (edge->callee->name ()),\n \t\t    edge->callee->order,\n \t\t    badness);\n \t }\n@@ -1288,7 +1288,7 @@ recursive_inlining (struct cgraph_edge *edge,\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"  Performing recursive inlining on %s\\n\",\n-\t     cgraph_node_name (node));\n+\t     node->name ());\n \n   /* Do the inlining and update list of recursive call during process.  */\n   while (!fibheap_empty (heap))\n@@ -1595,7 +1595,7 @@ inline_small_functions (void)\n \n       if (dump_file)\n \tfprintf (dump_file, \"Enqueueing calls in %s/%i.\\n\",\n-\t\t cgraph_node_name (node), node->order);\n+\t\t node->name (), node->order);\n \n       for (edge = node->callees; edge; edge = next)\n \t{\n@@ -1678,13 +1678,13 @@ inline_small_functions (void)\n \t{\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s/%i with %i size\\n\",\n-\t\t   cgraph_node_name (callee), callee->order,\n+\t\t   callee->name (), callee->order,\n \t\t   inline_summary (callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s/%i in %s:%i\\n\"\n \t\t   \" Estimated growth after inlined into all is %+i insns.\\n\"\n \t\t   \" Estimated badness is %i, frequency %.2f.\\n\",\n-\t\t   cgraph_node_name (edge->caller), edge->caller->order,\n+\t\t   edge->caller->name (), edge->caller->order,\n \t\t   flag_wpa ? \"unknown\"\n \t\t   : gimple_filename ((const_gimple) edge->call_stmt),\n \t\t   flag_wpa ? -1\n@@ -1797,7 +1797,7 @@ inline_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \" Inlined into %s which now has time %i and size %i,\"\n \t\t   \"net change of %+i.\\n\",\n-\t\t   cgraph_node_name (edge->caller),\n+\t\t   edge->caller->name (),\n \t\t   inline_summary (edge->caller)->time,\n \t\t   inline_summary (edge->caller)->size,\n \t\t   overall_size - old_size);\n@@ -1848,8 +1848,8 @@ flatten_function (struct cgraph_node *node, bool early)\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Not inlining %s into %s to avoid cycle.\\n\",\n-\t\t     xstrdup (cgraph_node_name (callee)),\n-\t\t     xstrdup (cgraph_node_name (e->caller)));\n+\t\t     xstrdup (callee->name ()),\n+\t\t     xstrdup (e->caller->name ()));\n \t  e->inline_failed = CIF_RECURSIVE_INLINING;\n \t  continue;\n \t}\n@@ -1889,8 +1889,8 @@ flatten_function (struct cgraph_node *node, bool early)\n          recursing through the original node if the node was cloned.  */\n       if (dump_file)\n \tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t xstrdup (cgraph_node_name (callee)),\n-\t\t xstrdup (cgraph_node_name (e->caller)));\n+\t\t xstrdup (callee->name ()),\n+\t\t xstrdup (e->caller->name ()));\n       orig_callee = callee;\n       inline_call (e, true, NULL, NULL, false);\n       if (e->callee != orig_callee)\n@@ -1935,19 +1935,19 @@ inline_to_all_callers (struct cgraph_node *node, void *data)\n \t{\n \t  fprintf (dump_file,\n \t\t   \"\\nInlining %s size %i.\\n\",\n-\t\t   cgraph_node_name (node),\n+\t\t   node->name (),\n \t\t   inline_summary (node)->size);\n \t  fprintf (dump_file,\n \t\t   \" Called once from %s %i insns.\\n\",\n-\t\t   cgraph_node_name (node->callers->caller),\n+\t\t   node->callers->caller->name (),\n \t\t   inline_summary (node->callers->caller)->size);\n \t}\n \n       inline_call (node->callers, true, NULL, NULL, true);\n       if (dump_file)\n \tfprintf (dump_file,\n \t\t \" Inlined into %s which now has %i size\\n\",\n-\t\t cgraph_node_name (caller),\n+\t\t caller->name (),\n \t\t inline_summary (caller)->size);\n       if (!(*num_calls)--)\n \t{\n@@ -2007,7 +2007,7 @@ ipa_inline (void)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n-\t\t     \"Flattening %s\\n\", cgraph_node_name (node));\n+\t\t     \"Flattening %s\\n\", node->name ());\n \t  flatten_function (node, false);\n \t}\n     }\n@@ -2115,7 +2115,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Not inlining recursive call to %s.\\n\",\n-\t\t     cgraph_node_name (e->callee));\n+\t\t     e->callee->name ());\n \t  e->inline_failed = CIF_RECURSIVE_INLINING;\n \t  continue;\n \t}\n@@ -2133,8 +2133,8 @@ inline_always_inline_functions (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \"  Inlining %s into %s (always_inline).\\n\",\n-\t\t xstrdup (cgraph_node_name (e->callee)),\n-\t\t xstrdup (cgraph_node_name (e->caller)));\n+\t\t xstrdup (e->callee->name ()),\n+\t\t xstrdup (e->caller->name ()));\n       inline_call (e, true, NULL, NULL, false);\n       inlined = true;\n     }\n@@ -2168,7 +2168,7 @@ early_inline_small_functions (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \"Considering inline candidate %s.\\n\",\n-\t\t cgraph_node_name (callee));\n+\t\t callee->name ());\n \n       if (!can_early_inline_edge_p (e))\n \tcontinue;\n@@ -2185,8 +2185,8 @@ early_inline_small_functions (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t xstrdup (cgraph_node_name (callee)),\n-\t\t xstrdup (cgraph_node_name (e->caller)));\n+\t\t xstrdup (callee->name ()),\n+\t\t xstrdup (e->caller->name ()));\n       inline_call (e, true, NULL, NULL, true);\n       inlined = true;\n     }\n@@ -2247,7 +2247,7 @@ early_inliner (void)\n \t all calls in it.  */\n       if (dump_file)\n \tfprintf (dump_file,\n-\t\t \"Flattening %s\\n\", cgraph_node_name (node));\n+\t\t \"Flattening %s\\n\", node->name ());\n       flatten_function (node, true);\n       inlined = true;\n     }"}, {"sha": "7ae001cc5e204a763ea5a0efd00b383012b9c33d", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -351,7 +351,7 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \tcase NODE_FREQUENCY_EXECUTED_ONCE:\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Called by %s that is executed once\\n\",\n-\t\t     cgraph_node_name (edge->caller));\n+\t\t     edge->caller->name ());\n \t  d->maybe_unlikely_executed = false;\n \t  if (inline_edge_summary (edge)->loop_depth)\n \t    {\n@@ -364,7 +364,7 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \tcase NODE_FREQUENCY_NORMAL:\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Called by %s that is normal or hot\\n\",\n-\t\t     cgraph_node_name (edge->caller));\n+\t\t     edge->caller->name ());\n \t  d->maybe_unlikely_executed = false;\n \t  d->maybe_executed_once = false;\n \t  break;\n@@ -407,7 +407,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n     return false;\n   gcc_assert (node->analyzed);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Processing frequency %s\\n\", cgraph_node_name (node));\n+    fprintf (dump_file, \"Processing frequency %s\\n\", node->name ());\n \n   cgraph_for_node_and_aliases (node, ipa_propagate_frequency_1, &d, true);\n \n@@ -417,7 +417,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n        node->only_called_at_startup = true;\n        if (dump_file)\n          fprintf (dump_file, \"Node %s promoted to only called at startup.\\n\",\n-\t\t  cgraph_node_name (node));\n+\t\t  node->name ());\n        changed = true;\n     }\n   if ((d.only_called_at_exit && !d.only_called_at_startup)\n@@ -426,7 +426,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n        node->only_called_at_exit = true;\n        if (dump_file)\n          fprintf (dump_file, \"Node %s promoted to only called at exit.\\n\",\n-\t\t  cgraph_node_name (node));\n+\t\t  node->name ());\n        changed = true;\n     }\n \n@@ -444,7 +444,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Node %s promoted to hot.\\n\",\n-\t\t\t cgraph_node_name (node));\n+\t\t\t node->name ());\n \t      node->frequency = NODE_FREQUENCY_HOT;\n \t      return true;\n \t    }\n@@ -454,7 +454,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Node %s reduced to normal.\\n\",\n-\t\t     cgraph_node_name (node));\n+\t\t     node->name ());\n \t  node->frequency = NODE_FREQUENCY_NORMAL;\n \t  changed = true;\n \t}\n@@ -468,15 +468,15 @@ ipa_propagate_frequency (struct cgraph_node *node)\n       node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n       if (dump_file)\n \tfprintf (dump_file, \"Node %s promoted to unlikely executed.\\n\",\n-\t\t cgraph_node_name (node));\n+\t\t node->name ());\n       changed = true;\n     }\n   else if (d.maybe_executed_once && node->frequency != NODE_FREQUENCY_EXECUTED_ONCE)\n     {\n       node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n       if (dump_file)\n \tfprintf (dump_file, \"Node %s promoted to executed once.\\n\",\n-\t\t cgraph_node_name (node));\n+\t\t node->name ());\n       changed = true;\n     }\n   return changed;\n@@ -590,8 +590,8 @@ ipa_profile (void)\n \t\t    {\n \t\t      fprintf (dump_file, \"Indirect call -> direct call from\"\n \t\t\t       \" other module %s/%i => %s/%i, prob %3.2f\\n\",\n-\t\t\t       xstrdup (cgraph_node_name (n)), n->order,\n-\t\t\t       xstrdup (cgraph_node_name (n2)), n2->order,\n+\t\t\t       xstrdup (n->name ()), n->order,\n+\t\t\t       xstrdup (n2->name ()), n2->order,\n \t\t\t       e->indirect_info->common_target_probability\n \t\t\t       / (float)REG_BR_PROB_BASE);\n \t\t    }"}, {"sha": "d673381b06291aec68ff05f830f87209e3dbb5d1", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -318,16 +318,16 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n {\n   struct cgraph_edge *cs;\n \n-  fprintf (f, \"  Jump functions of caller  %s/%i:\\n\", cgraph_node_name (node),\n+  fprintf (f, \"  Jump functions of caller  %s/%i:\\n\", node->name (),\n \t   node->order);\n   for (cs = node->callees; cs; cs = cs->next_callee)\n     {\n       if (!ipa_edge_args_info_available_for_edge_p (cs))\n \tcontinue;\n \n       fprintf (f, \"    callsite  %s/%i -> %s/%i : \\n\",\n-\t       xstrdup (cgraph_node_name (node)), node->order,\n-\t       xstrdup (cgraph_node_name (cs->callee)),\n+\t       xstrdup (node->name ()), node->order,\n+\t       xstrdup (cs->callee->name ()),\n \t       cs->callee->order);\n       ipa_print_node_jump_functions_for_edge (f, cs);\n     }\n@@ -2426,7 +2426,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered direct call to non-function\"\n \t\t\t\t\" in %s/%i, making it unreachable.\\n\",\n-\t\t     cgraph_node_name (ie->caller), ie->caller->order);\n+\t\t     ie->caller->name (), ie->caller->order);\n \t  target = builtin_decl_implicit (BUILT_IN_UNREACHABLE);\n \t  callee = cgraph_get_create_node (target);\n \t  unreachable = true;\n@@ -2452,9 +2452,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t  if (dump_file)\n \t    fprintf (dump_file, \"ipa-prop: Discovered call to a known target \"\n \t\t     \"(%s/%i -> %s/%i) but can not refer to it. Giving up.\\n\",\n-\t\t     xstrdup (cgraph_node_name (ie->caller)),\n+\t\t     xstrdup (ie->caller->name ()),\n \t\t     ie->caller->order,\n-\t\t     xstrdup (cgraph_node_name (ie->callee)),\n+\t\t     xstrdup (ie->callee->name ()),\n \t\t     ie->callee->order);\n \t  return NULL;\n \t}\n@@ -2471,9 +2471,9 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n       fprintf (dump_file, \"ipa-prop: Discovered %s call to a known target \"\n \t       \"(%s/%i -> %s/%i), for stmt \",\n \t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n-\t       xstrdup (cgraph_node_name (ie->caller)),\n+\t       xstrdup (ie->caller->name ()),\n \t       ie->caller->order,\n-\t       xstrdup (cgraph_node_name (callee)),\n+\t       xstrdup (callee->name ()),\n \t       callee->order);\n       if (ie->call_stmt)\n \tprint_gimple_stmt (dump_file, ie->call_stmt, 2, TDF_SLIM);\n@@ -2536,8 +2536,8 @@ remove_described_reference (symtab_node *symbol, struct ipa_cst_ref_desc *rdesc)\n   ipa_remove_reference (to_del);\n   if (dump_file)\n     fprintf (dump_file, \"ipa-prop: Removed a reference from %s/%i to %s.\\n\",\n-\t     xstrdup (cgraph_node_name (origin->caller)),\n-\t     origin->caller->order, xstrdup (symtab_node_name (symbol)));\n+\t     xstrdup (origin->caller->name ()),\n+\t     origin->caller->order, xstrdup (symbol->name ()));\n   return true;\n }\n \n@@ -2867,9 +2867,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n \t\t\t     \"reference from %s/%i to %s/%i.\\n\",\n-\t\t\t     xstrdup (cgraph_node_name (new_root)),\n+\t\t\t     xstrdup (new_root->name ()),\n \t\t\t     new_root->order,\n-\t\t\t     xstrdup (cgraph_node_name (n)), n->order);\n+\t\t\t     xstrdup (n->name ()), n->order);\n \t\t  ipa_remove_reference (ref);\n \t\t}\n \t    }\n@@ -2909,9 +2909,9 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t    fprintf (dump_file, \"ipa-prop: Removing \"\n \t\t\t\t     \"cloning-created reference \"\n \t\t\t\t     \"from %s/%i to %s/%i.\\n\",\n-\t\t\t\t     xstrdup (cgraph_node_name (clone)),\n+\t\t\t\t     xstrdup (clone->name ()),\n \t\t\t\t     clone->order,\n-\t\t\t\t     xstrdup (cgraph_node_name (n)),\n+\t\t\t\t     xstrdup (n->name ()),\n \t\t\t\t     n->order);\n \t\t\t  ipa_remove_reference (ref);\n \t\t\t}\n@@ -3295,7 +3295,7 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n     return;\n   info = IPA_NODE_REF (node);\n   fprintf (f, \"  function  %s/%i parameter descriptors:\\n\",\n-\t   cgraph_node_name (node), node->order);\n+\t   node->name (), node->order);\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n@@ -4553,7 +4553,7 @@ ipcp_transform_function (struct cgraph_node *node)\n \n   if (dump_file)\n     fprintf (dump_file, \"Modification phase of node %s/%i\\n\",\n-\t     cgraph_node_name (node), node->order);\n+\t     node->name (), node->order);\n \n   aggval = ipa_get_agg_replacements_for_node (node);\n   if (!aggval)"}, {"sha": "52be4bf8869f9c54f84a9bdbbbb730fa4c0c064f", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -743,7 +743,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\n\\n local analysis of %s\\n \",\n-\t       cgraph_node_name (fn));\n+\t       fn->name ());\n     }\n \n   push_cfun (DECL_STRUCT_FUNCTION (decl));\n@@ -1038,7 +1038,7 @@ pure_const_read_summary (void)\n \t\t{\n \t\t  int flags = flags_from_decl_or_type (node->decl);\n \t\t  fprintf (dump_file, \"Read info for %s/%i \",\n-\t\t\t   cgraph_node_name (node),\n+\t\t\t   node->name (),\n \t\t\t   node->order);\n \t\t  if (flags & ECF_CONST)\n \t\t    fprintf (dump_file, \" const\");\n@@ -1138,7 +1138,7 @@ propagate_pure_const (void)\n \t  funct_state w_l = get_function_state (w);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s/%i state:%s looping %i\\n\",\n-\t\t     cgraph_node_name (w),\n+\t\t     w->name (),\n \t\t     w->order,\n \t\t     pure_const_names[w_l->pure_const_state],\n \t\t     w_l->looping);\n@@ -1185,7 +1185,7 @@ propagate_pure_const (void)\n \t\t{\n \t\t  fprintf (dump_file,\n \t\t\t   \"    Call to %s/%i\",\n-\t\t\t   cgraph_node_name (e->callee),\n+\t\t\t   e->callee->name (),\n \t\t\t   e->callee->order);\n \t\t}\n \t      if (avail > AVAIL_OVERWRITABLE)\n@@ -1331,7 +1331,7 @@ propagate_pure_const (void)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n \t\t\t     this_looping ? \"looping \" : \"\",\n-\t\t\t     cgraph_node_name (w));\n+\t\t\t     w->name ());\n \t\t}\n \t      cgraph_set_const_flag (w, true, this_looping);\n \t      break;\n@@ -1343,7 +1343,7 @@ propagate_pure_const (void)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n \t\t\t     this_looping ? \"looping \" : \"\",\n-\t\t\t     cgraph_node_name (w));\n+\t\t\t     w->name ());\n \t\t}\n \t      cgraph_set_pure_flag (w, true, this_looping);\n \t      break;\n@@ -1446,7 +1446,7 @@ propagate_nothrow (void)\n \t      cgraph_set_nothrow_flag (w, true);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n-\t\t\t cgraph_node_name (w));\n+\t\t\t w->name ());\n \t    }\n \t  else if (can_throw && !TREE_NOTHROW (w->decl))\n \t    w_l->can_throw = true;"}, {"sha": "c0a11a7a562b7640e4cf9904e3321a5cab88bb19", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -154,7 +154,7 @@ ipa_dump_references (FILE * file, struct ipa_ref_list *list)\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n     {\n       fprintf (file, \"%s/%i (%s)\",\n-               symtab_node_asm_name (ref->referred),\n+               ref->referred->asm_name (),\n                ref->referred->order,\n \t       ipa_ref_use_name [ref->use]);\n       if (ref->speculative)\n@@ -173,7 +173,7 @@ ipa_dump_referring (FILE * file, struct ipa_ref_list *list)\n   for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n     {\n       fprintf (file, \"%s/%i (%s)\",\n-               symtab_node_asm_name (ref->referring),\n+               ref->referring->asm_name (),\n                ref->referring->order,\n \t       ipa_ref_use_name [ref->use]);\n       if (ref->speculative)"}, {"sha": "9f80086c747fcb7104ee540fb5f67c15ffea3447", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -562,7 +562,7 @@ generate_summary (void)\n \t  l = &get_reference_vars_info (node)->local;\n \t  fprintf (dump_file,\n \t\t   \"\\nFunction name:%s/%i:\",\n-\t\t   cgraph_node_asm_name (node), node->order);\n+\t\t   node->asm_name (), node->order);\n \t  fprintf (dump_file, \"\\n  locals read: \");\n \t  if (l->statics_read)\n \t    EXECUTE_IF_SET_IN_BITMAP (l->statics_read,\n@@ -600,7 +600,7 @@ read_write_all_from_decl (struct cgraph_node *node,\n       read_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n          fprintf (dump_file, \"   %s/%i -> read all\\n\",\n-\t\t  cgraph_node_asm_name (node), node->order);\n+\t\t  node->asm_name (), node->order);\n     }\n   else\n     {\n@@ -610,7 +610,7 @@ read_write_all_from_decl (struct cgraph_node *node,\n       write_all = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n          fprintf (dump_file, \"   %s/%i -> read all, write all\\n\",\n-\t\t  cgraph_node_asm_name (node), node->order);\n+\t\t  node->asm_name (), node->order);\n     }\n }\n \n@@ -723,7 +723,7 @@ propagate (void)\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Starting cycle with %s/%i\\n\",\n-\t\t  cgraph_node_asm_name (node), node->order);\n+\t\t  node->asm_name (), node->order);\n \n       vec<cgraph_node_ptr> cycle_nodes = ipa_get_nodes_in_cycle (node);\n \n@@ -732,7 +732,7 @@ propagate (void)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s/%i\\n\",\n-\t\t     cgraph_node_asm_name (w), w->order);\n+\t\t     w->asm_name (), w->order);\n \t  get_read_write_all_from_node (w, read_all, write_all);\n \t  if (read_all && write_all)\n \t    break;\n@@ -796,7 +796,7 @@ propagate (void)\n \n \t  fprintf (dump_file,\n \t\t   \"\\nFunction name:%s/%i:\",\n-\t\t   cgraph_node_asm_name (node), node->order);\n+\t\t   node->asm_name (), node->order);\n \n \t  ipa_reference_vars_info_t node_info = get_reference_vars_info (node);\n \t  ipa_reference_global_vars_info_t node_g = &node_info->global;\n@@ -808,7 +808,7 @@ propagate (void)\n \t      ipa_reference_local_vars_info_t w_l = &w_ri->local;\n \t      if (w != node)\n \t\tfprintf (dump_file, \"\\n  next cycle: %s/%i \",\n-\t\t\t cgraph_node_asm_name (w), w->order);\n+\t\t\t w->asm_name (), w->order);\n \t      fprintf (dump_file, \"\\n    locals read: \");\n \t      dump_static_vars_set_to_file (dump_file, w_l->statics_read);\n \t      fprintf (dump_file, \"\\n    locals written: \");\n@@ -1086,7 +1086,7 @@ ipa_reference_read_optimization_summary (void)\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n \t\t\t \"\\nFunction name:%s/%i:\\n  static not read:\",\n-\t\t\t cgraph_node_asm_name (node), node->order);\n+\t\t\t node->asm_name (), node->order);\n \n \t      /* Set the statics not read.  */\n \t      v_count = streamer_read_hwi (ib);"}, {"sha": "db775f4cdcc5967659c8cd48abceccee1ca75cf3", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -481,7 +481,7 @@ dump_cgraph_node_set (FILE *f, cgraph_node_set set)\n   for (iter = csi_start (set); !csi_end_p (iter); csi_next (&iter))\n     {\n       struct cgraph_node *node = csi_node (iter);\n-      fprintf (f, \" %s/%i\", cgraph_node_name (node), node->order);\n+      fprintf (f, \" %s/%i\", node->name (), node->order);\n     }\n   fprintf (f, \"\\n\");\n }\n@@ -610,7 +610,7 @@ dump_varpool_node_set (FILE *f, varpool_node_set set)\n   for (iter = vsi_start (set); !vsi_end_p (iter); vsi_next (&iter))\n     {\n       struct varpool_node *node = vsi_node (iter);\n-      fprintf (f, \" %s\", varpool_node_name (node));\n+      fprintf (f, \" %s\", node->name ());\n     }\n   fprintf (f, \"\\n\");\n }\n@@ -657,8 +657,8 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Merging profiles of %s/%i to %s/%i\\n\",\n-\t       xstrdup (cgraph_node_name (src)), src->order,\n-\t       xstrdup (cgraph_node_name (dst)), dst->order);\n+\t       xstrdup (src->name ()), src->order,\n+\t       xstrdup (dst->name ()), dst->order);\n     }\n   dst->count += src->count;\n "}, {"sha": "e541090ee3ad0d9745b37dff33a4dce50d46efc9", "filename": "gcc/ipa.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -218,9 +218,9 @@ walk_polymorphic_call_targets (pointer_set_t *reachable_call_targets,\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Devirtualizing call in %s/%i to %s/%i\\n\",\n-\t\t     cgraph_node_name (edge->caller),\n+\t\t     edge->caller->name (),\n \t\t     edge->caller->order,\n-\t\t     cgraph_node_name (target), target->order);\n+\t\t     target->name (), target->order);\n \t  edge = cgraph_make_edge_direct (edge, target);\n \t  if (!inline_summary_vec && edge->call_stmt)\n \t    cgraph_redirect_edge_call_stmt_to_callee (edge);\n@@ -451,7 +451,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       if (!node->aux)\n \t{\n \t  if (file)\n-\t    fprintf (file, \" %s\", cgraph_node_name (node));\n+\t    fprintf (file, \" %s\", node->name ());\n \t  cgraph_remove_node (node);\n \t  changed = true;\n \t}\n@@ -465,7 +465,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  if (node->definition)\n \t    {\n \t      if (file)\n-\t\tfprintf (file, \" %s\", cgraph_node_name (node));\n+\t\tfprintf (file, \" %s\", node->name ());\n \t      node->analyzed = false;\n \t      node->definition = false;\n \t      node->cpp_implicit_alias = false;\n@@ -511,7 +511,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  && (!flag_ltrans || !DECL_EXTERNAL (vnode->decl)))\n \t{\n \t  if (file)\n-\t    fprintf (file, \" %s\", varpool_node_name (vnode));\n+\t    fprintf (file, \" %s\", vnode->name ());\n \t  varpool_remove_node (vnode);\n \t  changed = true;\n \t}\n@@ -521,7 +521,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  if (vnode->definition)\n \t    {\n \t      if (file)\n-\t\tfprintf (file, \" %s\", varpool_node_name (vnode));\n+\t\tfprintf (file, \" %s\", vnode->name ());\n \t      changed = true;\n \t    }\n \t  vnode->definition = false;\n@@ -553,7 +553,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \tif (!cgraph_for_node_and_aliases (node, has_addr_references_p, NULL, true))\n \t  {\n \t    if (file)\n-\t      fprintf (file, \" %s\", cgraph_node_name (node));\n+\t      fprintf (file, \" %s\", node->name ());\n \t    node->address_taken = false;\n \t    changed = true;\n \t    if (cgraph_local_node_p (node))\n@@ -621,7 +621,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \tif (TREE_ADDRESSABLE (vnode->decl) && !address_taken)\n \t  {\n \t    if (dump_file)\n-\t      fprintf (dump_file, \" %s (addressable)\", varpool_node_name (vnode));\n+\t      fprintf (dump_file, \" %s (addressable)\", vnode->name ());\n \t    TREE_ADDRESSABLE (vnode->decl) = 0;\n \t  }\n \tif (!TREE_READONLY (vnode->decl) && !address_taken && !written\n@@ -631,7 +631,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t    && DECL_SECTION_NAME (vnode->decl) == NULL)\n \t  {\n \t    if (dump_file)\n-\t      fprintf (dump_file, \" %s (read-only)\", varpool_node_name (vnode));\n+\t      fprintf (dump_file, \" %s (read-only)\", vnode->name ());\n \t    TREE_READONLY (vnode->decl) = 1;\n \t  }\n       }\n@@ -1078,17 +1078,17 @@ function_and_variable_visibility (bool whole_program)\n       fprintf (dump_file, \"\\nMarking local functions:\");\n       FOR_EACH_DEFINED_FUNCTION (node)\n \tif (node->local.local)\n-\t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n+\t  fprintf (dump_file, \" %s\", node->name ());\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible functions:\");\n       FOR_EACH_DEFINED_FUNCTION (node)\n \tif (node->externally_visible)\n-\t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n+\t  fprintf (dump_file, \" %s\", node->name ());\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible variables:\");\n       FOR_EACH_DEFINED_VARIABLE (vnode)\n \tif (vnode->externally_visible)\n-\t  fprintf (dump_file, \" %s\", varpool_node_name (vnode));\n+\t  fprintf (dump_file, \" %s\", vnode->name ());\n       fprintf (dump_file, \"\\n\\n\");\n     }\n   cgraph_function_flags_ready = true;"}, {"sha": "266d00ff1e6283944189ea737677860e3127c2e3", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -1,3 +1,7 @@\n+2013-11-18  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* lto-partition.c lto-symtab.c lto.c Adjust.\n+\n 2013-10-31  David Malcolm  <dmalcolm@redhat.com>\n \n \tAutomated part of renaming of symtab_node_base to symtab_node."}, {"sha": "e0d020d30ec4904d0ee3bc9163e966c0003a6655", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -197,7 +197,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n       node->in_other_partition = 1;\n       if (cgraph_dump_file)\n         fprintf (cgraph_dump_file, \"Symbol node %s now used in multiple partitions\\n\",\n-\t\t symtab_node_name (node));\n+\t\t node->name ());\n     }\n   node->aux = (void *)((size_t)node->aux + 1);\n \n@@ -381,7 +381,7 @@ lto_max_map (void)\n       if (get_symbol_class (node) != SYMBOL_PARTITION\n \t  || symbol_partitioned_p (node))\n \tcontinue;\n-      partition = new_partition (symtab_node_asm_name (node));\n+      partition = new_partition (node->asm_name ());\n       add_symbol_to_partition (partition, node);\n       npartitions++;\n     }\n@@ -688,7 +688,7 @@ lto_balanced_map (void)\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i \"\n \t\t \"best %i/%i, step %i\\n\", i,\n-\t\t cgraph_node_name (order[i]), order[i]->order,\n+\t\t order[i]->name (), order[i]->order,\n \t\t partition->insns, cost, internal,\n \t\t best_cost, best_internal, best_i);\n       /* Partition is too large, unwind into step when best cost was reached and\n@@ -824,7 +824,7 @@ promote_symbol (symtab_node *node)\n   DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n-\t    \"Promoting as hidden: %s\\n\", symtab_node_name (node));\n+\t    \"Promoting as hidden: %s\\n\", node->name ());\n }\n \n /* Return true if NODE needs named section even if it won't land in the partition\n@@ -885,7 +885,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n-\t    \"Renaming statics with asm name: %s\\n\", symtab_node_name (node));\n+\t    \"Renaming statics with asm name: %s\\n\", node->name ());\n \n   /* Assign every symbol in the set that shares the same ASM name an unique\n      mangled name.  */"}, {"sha": "7c7075e50fcf27f3d0cdeceb318bc29d91ee9bde", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -45,8 +45,8 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n     {\n       fprintf (cgraph_dump_file, \"Replacing cgraph node %s/%i by %s/%i\"\n  \t       \" for symbol %s\\n\",\n-\t       cgraph_node_name (node), node->order,\n-\t       cgraph_node_name (prevailing_node),\n+\t       node->name (), node->order,\n+\t       prevailing_node->name (),\n \t       prevailing_node->order,\n \t       IDENTIFIER_POINTER ((*targetm.asm_out.mangle_assembler_name)\n \t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)))));\n@@ -428,7 +428,7 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Merging nodes for %s. Candidates:\\n\",\n-\t       symtab_node_asm_name (first));\n+\t       first->asm_name ());\n       for (e = first; e; e = e->next_sharing_asm_name)\n \tif (TREE_PUBLIC (e->decl))\n \t  dump_symtab_node (cgraph_dump_file, e);"}, {"sha": "6ecac0106e1b70967ee74a3a83bda5863df6d3ec", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -2480,7 +2480,7 @@ lto_wpa_write_files (void)\n \t       lsei_next_in_partition (&lsei))\n \t    {\n \t      symtab_node *node = lsei_node (lsei);\n-\t      fprintf (cgraph_dump_file, \"%s \", symtab_node_asm_name (node));\n+\t      fprintf (cgraph_dump_file, \"%s \", node->asm_name ());\n \t    }\n \t  fprintf (cgraph_dump_file, \"\\n  Symbols in boundary: \");\n \t  for (lsei = lsei_start (part->encoder); !lsei_end_p (lsei);\n@@ -2489,7 +2489,7 @@ lto_wpa_write_files (void)\n \t      symtab_node *node = lsei_node (lsei);\n \t      if (!lto_symtab_encoder_in_partition_p (part->encoder, node))\n \t\t{\n-\t          fprintf (cgraph_dump_file, \"%s \", symtab_node_asm_name (node));\n+\t          fprintf (cgraph_dump_file, \"%s \", node->asm_name ());\n \t\t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n \t\t  if (cnode\n \t\t      && lto_symtab_encoder_encode_body_p (part->encoder, cnode))"}, {"sha": "871fecc0f50c79cd3c54ee2e365fa76afa0010c9", "filename": "gcc/predict.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -2782,7 +2782,7 @@ drop_profile (struct cgraph_node *node, gcov_type call_count)\n   if (dump_file)\n     fprintf (dump_file,\n              \"Dropping 0 profile for %s/%i. %s based on calls.\\n\",\n-             cgraph_node_name (node), node->order,\n+             node->name (), node->order,\n              hot ? \"Function is hot\" : \"Function is normal\");\n   /* We only expect to miss profiles for functions that are reached\n      via non-zero call edges in cases where the function may have\n@@ -2800,11 +2800,11 @@ drop_profile (struct cgraph_node *node, gcov_type call_count)\n           if (dump_file)\n             fprintf (dump_file,\n                      \"Missing counts for called function %s/%i\\n\",\n-                     cgraph_node_name (node), node->order);\n+                     node->name (), node->order);\n         }\n       else\n         warning (0, \"Missing counts for called function %s/%i\",\n-                 cgraph_node_name (node), node->order);\n+                 node->name (), node->order);\n     }\n \n   profile_status_for_function (fn)"}, {"sha": "9426f75399dae5c0956ede1a5eca0106b685ed23", "filename": "gcc/symtab.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -540,19 +540,19 @@ symtab_dissolve_same_comdat_group_list (symtab_node *node)\n    is unknown go with identifier name.  */\n \n const char *\n-symtab_node_asm_name (symtab_node *node)\n+symtab_node::asm_name () const\n {\n-  if (!DECL_ASSEMBLER_NAME_SET_P (node->decl))\n-    return lang_hooks.decl_printable_name (node->decl, 2);\n-  return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl));\n+  if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n+    return lang_hooks.decl_printable_name (decl, 2);\n+  return IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n }\n \n /* Return printable identifier name.  */\n \n const char *\n-symtab_node_name (symtab_node *node)\n+symtab_node::name () const\n {\n-  return lang_hooks.decl_printable_name (node->decl, 2);\n+  return lang_hooks.decl_printable_name (decl, 2);\n }\n \n static const char * const symtab_type_names[] = {\"symbol\", \"function\", \"variable\"};\n@@ -567,9 +567,9 @@ dump_symtab_base (FILE *f, symtab_node *node)\n   };\n \n   fprintf (f, \"%s/%i (%s)\",\n-\t   symtab_node_asm_name (node),\n+\t   node->asm_name (),\n \t   node->order,\n-\t   symtab_node_name (node));\n+\t   node->name ());\n   dump_addr (f, \" @\", (void *)node);\n   fprintf (f, \"\\n  Type: %s\", symtab_type_names[node->type]);\n \n@@ -645,7 +645,7 @@ dump_symtab_base (FILE *f, symtab_node *node)\n   \n   if (node->same_comdat_group)\n     fprintf (f, \"  Same comdat group as: %s/%i\\n\",\n-\t     symtab_node_asm_name (node->same_comdat_group),\n+\t     node->same_comdat_group->asm_name (),\n \t     node->same_comdat_group->order);\n   if (node->next_sharing_asm_name)\n     fprintf (f, \"  next sharing asm name: %i\\n\","}, {"sha": "918a25c1c3bece293f93acd2bd398e630099b1b6", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -1851,7 +1851,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t  if (dump_file)\n \t\t    {\n \t\t      fprintf (dump_file, \"Created new direct edge to %s\\n\",\n-\t\t\t       cgraph_node_name (dest));\n+\t\t\t       dest->name ());\n \t\t    }\n \t\t}\n "}, {"sha": "c3f6823c5799543a55ab3bb24cf515fb40abec50", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -4846,9 +4846,9 @@ convert_callers_for_node (struct cgraph_node *node,\n \n       if (dump_file)\n \tfprintf (dump_file, \"Adjusting call %s/%i -> %s/%i\\n\",\n-\t\t xstrdup (cgraph_node_name (cs->caller)),\n+\t\t xstrdup (cs->caller->name ()),\n \t\t cs->caller->order,\n-\t\t xstrdup (cgraph_node_name (cs->callee)),\n+\t\t xstrdup (cs->callee->name ()),\n \t\t cs->callee->order);\n \n       ipa_modify_call_arguments (cs, cs->call_stmt, *adjustments);"}, {"sha": "b478304b965b65bb16ce72c0afeaf8738f0d5c66", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -7158,7 +7158,7 @@ ipa_pta_execute (void)\n       if (dump_file)\n \t{\n \t  fprintf (dump_file,\n-\t\t   \"Generating constraints for %s\", cgraph_node_name (node));\n+\t\t   \"Generating constraints for %s\", node->name ());\n \t  if (DECL_ASSEMBLER_NAME_SET_P (node->decl))\n \t    fprintf (dump_file, \" (%s)\",\n \t\t     IDENTIFIER_POINTER"}, {"sha": "f21ff00f2cbed5ac9747f7f64e5b0ce8a35191f8", "filename": "gcc/value-prof.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -1224,9 +1224,9 @@ init_node_map (bool local)\n \t\t  fprintf (dump_file, \"Local profile-id %i conflict\"\n \t\t\t   \" with nodes %s/%i %s/%i\\n\",\n \t\t\t   n->profile_id,\n-\t\t\t   cgraph_node_name (n),\n+\t\t\t   n->name (),\n \t\t\t   n->order,\n-\t\t\t   symtab_node_name (*(symtab_node **)val),\n+\t\t\t   (*(symtab_node **)val)->name (),\n \t\t\t   (*(symtab_node **)val)->order);\n \t\tn->profile_id = (n->profile_id + 1) & 0x7fffffff;\n \t      }\n@@ -1237,7 +1237,7 @@ init_node_map (bool local)\n \t      fprintf (dump_file,\n \t\t       \"Node %s/%i has no profile-id\"\n \t\t       \" (profile feedback missing?)\\n\",\n-\t\t       cgraph_node_name (n),\n+\t\t       n->name (),\n \t\t       n->order);\n \t    continue;\n \t  }\n@@ -1248,7 +1248,7 @@ init_node_map (bool local)\n \t      fprintf (dump_file,\n \t\t       \"Node %s/%i has IP profile-id %i conflict. \"\n \t\t       \"Giving up.\\n\",\n-\t\t       cgraph_node_name (n),\n+\t\t       n->name (),\n \t\t       n->order,\n \t\t       n->profile_id);\n \t    *val = NULL;\n@@ -1297,7 +1297,7 @@ check_ic_target (gimple call_stmt, struct cgraph_node *target)\n    if (dump_enabled_p ())\n      dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,\n                       \"Skipping target %s with mismatching types for icall\\n\",\n-                      cgraph_node_name (target));\n+                      target->name ());\n    return false;\n }\n "}, {"sha": "4521caf2b10645a56cfb27656de51b30c28ce758", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec39fa6b010bb0a37c93412e8f147668c558f98/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=fec39fa6b010bb0a37c93412e8f147668c558f98", "patch": "@@ -502,7 +502,7 @@ varpool_remove_unreferenced_decls (void)\n \t{\n \t  enqueue_node (node, &first);\n           if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" %s\", varpool_node_asm_name (node));\n+\t    fprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n \t}\n     }\n   while (first != (struct varpool_node *)(void *)1)\n@@ -540,7 +540,7 @@ varpool_remove_unreferenced_decls (void)\n       if (!node->aux)\n \t{\n           if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \" %s\", varpool_node_asm_name (node));\n+\t    fprintf (cgraph_dump_file, \" %s\", node->asm_name ());\n \t  varpool_remove_node (node);\n \t}\n     }"}]}