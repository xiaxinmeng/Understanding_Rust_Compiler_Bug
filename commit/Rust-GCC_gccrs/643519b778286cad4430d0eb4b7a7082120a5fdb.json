{"sha": "643519b778286cad4430d0eb4b7a7082120a5fdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQzNTE5Yjc3ODI4NmNhZDQ0MzBkMGViNGI3YTcwODIxMjBhNWZkYg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-02-20T19:52:56Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-02-20T19:52:56Z"}, "message": "ipa-type-escape.c: Tidy some comments and white space.\n\n\n\t* ipa-type-escape.c: Tidy some comments and white space.\n\t* tree-ssa-operands.c: Likewise.\n\nFrom-SVN: r111310", "tree": {"sha": "a2106808c0904112a16c1de36d3290f029ca4274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2106808c0904112a16c1de36d3290f029ca4274"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/643519b778286cad4430d0eb4b7a7082120a5fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643519b778286cad4430d0eb4b7a7082120a5fdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/643519b778286cad4430d0eb4b7a7082120a5fdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/643519b778286cad4430d0eb4b7a7082120a5fdb/comments", "author": null, "committer": null, "parents": [{"sha": "4b9e501c5ecefc6232a6de75bb2d53c75dbfb833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b9e501c5ecefc6232a6de75bb2d53c75dbfb833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b9e501c5ecefc6232a6de75bb2d53c75dbfb833"}], "stats": {"total": 153, "additions": 83, "deletions": 70}, "files": [{"sha": "16805024d3a8d98195b03c137e6dd08d00eae02c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643519b778286cad4430d0eb4b7a7082120a5fdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643519b778286cad4430d0eb4b7a7082120a5fdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=643519b778286cad4430d0eb4b7a7082120a5fdb", "patch": "@@ -1,3 +1,8 @@\n+2006-02-20  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* ipa-type-escape.c: Tidy some comments and white space.\n+\t* tree-ssa-operands.c: Likewise.\n+\n 2006-02-20  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/25879"}, {"sha": "37a61e43cb45852a1ae8871f2f6da44ea8033b37", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643519b778286cad4430d0eb4b7a7082120a5fdb/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643519b778286cad4430d0eb4b7a7082120a5fdb/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=643519b778286cad4430d0eb4b7a7082120a5fdb", "patch": "@@ -394,7 +394,7 @@ ipa_type_escape_type_contained_p (tree type)\n \t\t\tget_canon_type_uid (type, true, false));\n }\n \n-/* Return true a modification to a field of type FIELD_TYPE cannot\n+/* Return true if a modification to a field of type FIELD_TYPE cannot\n    clobber a record of RECORD_TYPE.  */\n \n bool "}, {"sha": "deea6f3dd4766796cc16337e9940960d63daeb31", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 77, "deletions": 69, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/643519b778286cad4430d0eb4b7a7082120a5fdb/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/643519b778286cad4430d0eb4b7a7082120a5fdb/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=643519b778286cad4430d0eb4b7a7082120a5fdb", "patch": "@@ -1050,9 +1050,10 @@ swap_tree_operands (tree stmt, tree *exp0, tree *exp1)\n   *exp1 = op0;\n }\n \n-/* Recursively scan the expression pointed to by EXPR_P in statement referred\n-   to by INFO.  FLAGS is one of the OPF_* constants modifying how to interpret\n-   the operands found.  */\n+\n+/* Recursively scan the expression pointed to by EXPR_P in statement\n+   referred to by INFO.  FLAGS is one of the OPF_* constants modifying\n+   how to interpret the operands found.  */\n \n static void\n get_expr_operands (tree stmt, tree *expr_p, int flags)\n@@ -1072,30 +1073,29 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     {\n     case ADDR_EXPR:\n       /* Taking the address of a variable does not represent a\n-\t reference to it, but the fact that the stmt takes its address will be\n-\t of interest to some passes (e.g. alias resolution).  */\n-      add_to_addressable_set (TREE_OPERAND (expr, 0),\n-\t\t\t      &s_ann->addresses_taken);\n+\t reference to it, but the fact that the statement takes its\n+\t address will be of interest to some passes (e.g. alias\n+\t resolution).  */\n+      add_to_addressable_set (TREE_OPERAND (expr, 0), &s_ann->addresses_taken);\n \n-      /* If the address is invariant, there may be no interesting variable\n-\t references inside.  */\n+      /* If the address is invariant, there may be no interesting\n+\t variable references inside.  */\n       if (is_gimple_min_invariant (expr))\n \treturn;\n \n-      /* There should be no VUSEs created, since the referenced objects are\n-\t not really accessed.  The only operands that we should find here\n-\t are ARRAY_REF indices which will always be real operands (GIMPLE\n-\t does not allow non-registers as array indices).  */\n+      /* Otherwise, there may be variables referenced inside but there\n+\t should be no VUSEs created, since the referenced objects are\n+\t not really accessed.  The only operands that we should find\n+\t here are ARRAY_REF indices which will always be real operands\n+\t (GIMPLE does not allow non-registers as array indices).  */\n       flags |= opf_no_vops;\n-\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case SSA_NAME:\n     case STRUCT_FIELD_TAG:\n     case TYPE_MEMORY_TAG:\n     case NAME_MEMORY_TAG:\n-\n      add_stmt_operand (expr_p, s_ann, flags);\n      return;\n \n@@ -1105,9 +1105,9 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       {\n \tsubvar_t svars;\n \t\n-\t/* Add the subvars for a variable if it has subvars, to DEFS or USES.\n-\t   Otherwise, add the variable itself.  \n-\t   Whether it goes to USES or DEFS depends on the operand flags.  */\n+\t/* Add the subvars for a variable if it has subvars, to DEFS\n+\t   or USES.  Otherwise, add the variable itself.  Whether it\n+\t   goes to USES or DEFS depends on the operand flags.  */\n \tif (var_can_have_subvars (expr)\n \t    && (svars = get_subvars_for_var (expr)))\n \t  {\n@@ -1116,11 +1116,11 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t      add_stmt_operand (&sv->var, s_ann, flags);\n \t  }\n \telse\n-\t  {\n-\t    add_stmt_operand (expr_p, s_ann, flags);\n-\t  }\n+\t  add_stmt_operand (expr_p, s_ann, flags);\n+\n \treturn;\n       }\n+\n     case MISALIGNED_INDIRECT_REF:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n       /* fall through */\n@@ -1139,9 +1139,6 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       /* Treat array references as references to the virtual variable\n \t representing the array.  The virtual variable for an ARRAY_REF\n \t is the VAR_DECL for the array.  */\n-\n-      /* Add the virtual variable for the ARRAY_REF to VDEFS or VUSES\n-\t according to the value of IS_DEF.  */\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n@@ -1156,30 +1153,33 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \ttree ref;\n \tHOST_WIDE_INT offset, size, maxsize;\n \tbool none = true;\n- \t/* This component ref becomes an access to all of the subvariables\n-\t   it can touch,  if we can determine that, but *NOT* the real one.\n-\t   If we can't determine which fields we could touch, the recursion\n-\t   will eventually get to a variable and add *all* of its subvars, or\n-\t   whatever is the minimum correct subset.  */\n \n+\t/* This component reference becomes an access to all of the\n+\t   subvariables it can touch, if we can determine that, but\n+\t   *NOT* the real one.  If we can't determine which fields we\n+\t   could touch, the recursion will eventually get to a\n+\t   variable and add *all* of its subvars, or whatever is the\n+\t   minimum correct subset.  */\n \tref = get_ref_base_and_extent (expr, &offset, &size, &maxsize);\n \tif (SSA_VAR_P (ref) && get_subvars_for_var (ref))\n-\t  {\t  \n-\t    subvar_t svars = get_subvars_for_var (ref);\n+\t  {\n \t    subvar_t sv;\n+\t    subvar_t svars = get_subvars_for_var (ref);\n+\n \t    for (sv = svars; sv; sv = sv->next)\n \t      {\n \t\tbool exact;\t\t\n+\n \t\tif (overlap_subvar (offset, maxsize, sv->var, &exact))\n \t\t  {\n \t            int subvar_flags = flags;\n \t\t    none = false;\n-\t\t    if (!exact\n-\t\t\t|| size != maxsize)\n+\t\t    if (!exact || size != maxsize)\n \t\t      subvar_flags &= ~opf_kill_def;\n \t\t    add_stmt_operand (&sv->var, s_ann, subvar_flags);\n \t\t  }\n \t      }\n+\n \t    if (!none)\n \t      flags |= opf_no_vops;\n \t  }\n@@ -1193,7 +1193,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t/* Even if we found subvars above we need to ensure to see\n \t   immediate uses for d in s.a[d].  In case of s.a having\n \t   a subvar we'd miss it otherwise.  */\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), \n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0),\n \t\t\t   flags & ~opf_kill_def);\n \t\n \tif (code == COMPONENT_REF)\n@@ -1208,8 +1208,10 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n             get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n             get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_none);\n \t  }\n+\n \treturn;\n       }\n+\n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR is a pass-through reference to its first argument,\n \t and an rvalue reference to its second argument.  */\n@@ -1368,10 +1370,9 @@ get_asm_expr_operands (tree stmt)\n \n   for (link = ASM_INPUTS (stmt); link; link = TREE_CHAIN (link))\n     {\n-      constraint\n-\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n+      constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (link)));\n       parse_input_constraint (&constraint, 0, 0, noutputs, 0,\n-\t  oconstraints, &allows_mem, &allows_reg);\n+\t\t\t      oconstraints, &allows_mem, &allows_reg);\n \n       /* Memory operands are addressable.  Note that STMT needs the\n \t address of this operand.  */\n@@ -1428,17 +1429,21 @@ get_asm_expr_operands (tree stmt)\n \n /* A subroutine of get_expr_operands to handle INDIRECT_REF,\n    ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.  \n+\n    STMT is the statement being processed, EXPR is the INDIRECT_REF\n-   that got us here.  FLAGS is as in get_expr_operands.\n+      that got us here.\n+   \n+   FLAGS is as in get_expr_operands.\n+\n    FULL_REF contains the full pointer dereference expression, if we\n-   have it, or NULL otherwise.\n+      have it, or NULL otherwise.\n+\n    OFFSET and SIZE are the location of the access inside the\n-   dereferenced pointer, if known.\n-   RECURSE_ON_BASE should be set to true if we want to continue\n-   calling get_expr_operands on the base pointer, and false if\n-   something else will do it for us.\n+      dereferenced pointer, if known.\n \n-*/\n+   RECURSE_ON_BASE should be set to true if we want to continue\n+      calling get_expr_operands on the base pointer, and false if\n+      something else will do it for us.  */\n \n static void\n get_indirect_ref_operands (tree stmt, tree expr, int flags,\n@@ -1496,25 +1501,27 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n \t\t\t\t full_ref, offset, size, false);\n \t}\n     }\n-\n-  /* If a constant is used as a pointer, we can't generate a real\n-     operand for it but we mark the statement volatile to prevent\n-     optimizations from messing things up.  */\n   else if (TREE_CODE (ptr) == INTEGER_CST)\n     {\n+      /* If a constant is used as a pointer, we can't generate a real\n+\t operand for it but we mark the statement volatile to prevent\n+\t optimizations from messing things up.  */\n       if (s_ann)\n \ts_ann->has_volatile_ops = true;\n       return;\n     }\n-  /* Ok, this isn't even is_gimple_min_invariant.  Something's broke.  */\n   else\n-    gcc_unreachable ();\n+    {\n+      /* Ok, this isn't even is_gimple_min_invariant.  Something's broke.  */\n+      gcc_unreachable ();\n+    }\n \n-  /* Add a USE operand for the base pointer.  */\n+  /* If requested, add a USE operand for the base pointer.  */\n   if (recurse_on_base)\n     get_expr_operands (stmt, pptr, opf_none);\n }\n \n+\n /* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */\n \n static void\n@@ -1567,6 +1574,7 @@ get_tmr_operands (tree stmt, tree expr, int flags)\n     }\n }\n \n+\n /* A subroutine of get_expr_operands to handle CALL_EXPR.  */\n \n static void\n@@ -1626,12 +1634,13 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n \n   /* If ALIAS is an SFT, it can't be touched if the offset     \n      and size of the access is not overlapping with the SFT offset and\n-     size.    This is only true if we are accessing through a pointer\n+     size.  This is only true if we are accessing through a pointer\n      to a type that is the same as SFT_PARENT_VAR.  Otherwise, we may\n      be accessing through a pointer to some substruct of the\n      structure, and if we try to prune there, we will have the wrong\n      offset, and get the wrong answer.\n      i.e., we can't prune without more work if we have something like\n+\n      struct gcc_target\n      {\n        struct asm_out\n@@ -1649,9 +1658,7 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n \n      SFT.1, which represents hi, will have SFT_OFFSET=32 because in\n      terms of SFT_PARENT_VAR, that is where it is.\n-     However, the access through the foo pointer will be at offset 0.\n-  */\n-\n+     However, the access through the foo pointer will be at offset 0.  */\n   if (size != -1\n       && TREE_CODE (alias) == STRUCT_FIELD_TAG\n       && base\n@@ -1672,12 +1679,12 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n      through a pointer to touch a random variable, unless that\n      variable *is* a structure or a pointer.\n \n-     \n-     IE given p->c, and some random global variable b,\n+     That is, given p->c, and some random global variable b,\n      there is no legal way that p->c could be an access to b.\n      \n      Without strict aliasing on, we consider it legal to do something\n      like:\n+\n      struct foos { int l; };\n      int foo;\n      static struct foos *getfoo(void);\n@@ -1695,7 +1702,6 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n      \n      (taken from 20000623-1.c)\n   */\n-\n   else if (ref \n \t   && flag_strict_aliasing\n \t   && TREE_CODE (ref) != INDIRECT_REF\n@@ -1717,7 +1723,6 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   /* If the offset of the access is greater than the size of one of\n      the possible aliases, it can't be touching that alias, because it\n      would be past the end of the structure.  */\n-\n   else if (ref\n \t   && flag_strict_aliasing\n \t   && TREE_CODE (ref) != INDIRECT_REF\n@@ -1737,11 +1742,12 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n #endif\n       return false;\n     }\t   \n+\n   return true;\n }\n \n \n-/* Add VAR to the virtual operands array. FLAGS is as in\n+/* Add VAR to the virtual operands array.  FLAGS is as in\n    get_expr_operands.  FULL_REF is a tree that contains the entire\n    pointer dereference expression, if available, or NULL otherwise.\n    OFFSET and SIZE come from the memory access expression that\n@@ -1771,8 +1777,8 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n      check that this only happens on non-specific stores.\n \n      Note that if this is a specific store, i.e. associated with a\n-     modify_expr, then we can't suppress the V_DEF, lest we run into\n-     validation problems.\n+     modify_expr, then we can't suppress the V_MAY_DEF, lest we run\n+     into validation problems.\n \n      This can happen when programs cast away const, leaving us with a\n      store to read-only memory.  If the statement is actually executed\n@@ -1796,12 +1802,10 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t{\n \t  if (flags & opf_kill_def)\n \t    {\n-\t      /* Only regular variables or struct fields may get a\n-\t\t V_MUST_DEF operand.  */\n-\t      gcc_assert (!MTAG_P (var)\n-\t\t\t  || TREE_CODE (var) == STRUCT_FIELD_TAG);\n \t      /* V_MUST_DEF for non-aliased, non-GIMPLE register \n \t\t variable definitions.  */\n+\t      gcc_assert (!MTAG_P (var)\n+\t\t\t  || TREE_CODE (var) == STRUCT_FIELD_TAG);\n \t      append_v_must_def (var);\n \t    }\n \t  else\n@@ -1926,6 +1930,7 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n     add_virtual_operand (var, s_ann, flags, NULL_TREE, 0, -1, false);\n }\n \n+\n /* Add the base address of REF to the set *ADDRESSES_TAKEN.  If\n    *ADDRESSES_TAKEN is NULL, a new set is created.  REF may be\n    a single variable whose address has been taken or any other valid\n@@ -1970,6 +1975,7 @@ add_to_addressable_set (tree ref, bitmap *addresses_taken)\n     }\n }\n \n+\n /* Add clobbering definitions for .GLOBAL_VAR or for each of the call\n    clobbered variables in the function.  */\n \n@@ -1997,7 +2003,6 @@ add_call_clobber_ops (tree stmt, tree callee)\n   /* Get info for local and module level statics.  There is a bit\n      set for each static if the call being processed does not read\n      or write that variable.  */\n-\n   not_read_b = callee ? ipa_reference_get_not_read_global (callee) : NULL; \n   not_written_b = callee ? ipa_reference_get_not_written_global (callee) : NULL; \n   /* Add a V_MAY_DEF operand for every call clobbered variable.  */\n@@ -2011,7 +2016,6 @@ add_call_clobber_ops (tree stmt, tree callee)\n       \n       /* Not read and not written are computed on regular vars, not\n \t subvars, so look at the parent var if this is an SFT. */\n-\n       if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n \treal_var = SFT_PARENT_VAR (var);\n \n@@ -2144,7 +2148,9 @@ verify_imm_links (FILE *f, tree var)\n \n       prev = ptr;\n       ptr = ptr->next;\n-      /* Avoid infinite loops.  50,000,000 uses probably indicates a problem.  */\n+\n+      /* Avoid infinite loops.  50,000,000 uses probably indicates a\n+\t problem.  */\n       if (count++ > 50000000)\n \tgoto error;\n     }\n@@ -2210,6 +2216,7 @@ dump_immediate_uses_for (FILE *file, tree var)\n   fprintf(file, \"\\n\");\n }\n \n+\n /* Dump all the immediate uses to FILE.  */\n \n void\n@@ -2244,4 +2251,5 @@ debug_immediate_uses_for (tree var)\n {\n   dump_immediate_uses_for (stderr, var);\n }\n+\n #include \"gt-tree-ssa-operands.h\""}]}