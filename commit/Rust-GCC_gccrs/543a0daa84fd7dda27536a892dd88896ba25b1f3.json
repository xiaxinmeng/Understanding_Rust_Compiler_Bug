{"sha": "543a0daa84fd7dda27536a892dd88896ba25b1f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzYTBkYWE4NGZkN2RkYTI3NTM2YTg5MmRkODg4OTZiYTI1YjFmMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-20T10:10:02Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-20T10:10:02Z"}, "message": "c-common.h (add_decl_stmt): Move to cp-tree.h.\n\n        * c-common.h (add_decl_stmt): Move to cp-tree.h.\n        * c-decl.c (finish_decl): Don't use add_decl_stmt.\n        * c-parse.in: Likewise.\n        * c-gimplify.c (gimplify_expr_stmt): Don't build CLEANUP_POINT_EXPR.\n        (gimplify_c_loop, gimplify_return_stmt, gimplify_decl_stmt): Likewise.\n        * c-semantics.c (add_decl_stmt): Move to cp/semantics.c.\ncp/\n        * cp-tree.h (add_decl_stmt): Declare.\n        * pt.c (tsubst_copy): Abort for CLEANUP_POINT_EXPR.\n        * semantics.c (maybe_cleanup_point_expr): New.\n        (add_decl_stmt, finish_expr_stmt, finish_return_stmt,\n        finish_for_expr, finish_switch_cond): Use it.\n        (finalize_nrv_r): Don't build an EXPR_STMT.  Don't frob TREE_CHAIN.\n\nFrom-SVN: r83409", "tree": {"sha": "3b1f57793fdac8988d25b629b21ba09e5cade391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b1f57793fdac8988d25b629b21ba09e5cade391"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/543a0daa84fd7dda27536a892dd88896ba25b1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543a0daa84fd7dda27536a892dd88896ba25b1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/543a0daa84fd7dda27536a892dd88896ba25b1f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543a0daa84fd7dda27536a892dd88896ba25b1f3/comments", "author": null, "committer": null, "parents": [{"sha": "aa33d725018cde8ab90b73e355114343be9072ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa33d725018cde8ab90b73e355114343be9072ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa33d725018cde8ab90b73e355114343be9072ce"}], "stats": {"total": 106, "additions": 69, "deletions": 37}, "files": [{"sha": "b6e81ff99e89cebb7718fb433faed8f7becdb48e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -1,3 +1,12 @@\n+2004-06-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-common.h (add_decl_stmt): Move to cp-tree.h.\n+\t* c-decl.c (finish_decl): Don't use add_decl_stmt.\n+\t* c-parse.in: Likewise.\n+\t* c-gimplify.c (gimplify_expr_stmt): Don't build CLEANUP_POINT_EXPR.\n+\t(gimplify_c_loop, gimplify_return_stmt, gimplify_decl_stmt): Likewise.\n+\t* c-semantics.c (add_decl_stmt): Move to cp/semantics.c.\n+\n 2004-06-20  Richard Henderson  <rth@redhat.com>\n \n \t* c-common.def (IF_STMT, CLEANUP_STMT): Move to cp-tree.def."}, {"sha": "f8d087b8dbd8f334dc42e2abb58ec214e8ef1bfd", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -294,7 +294,6 @@ extern tree push_stmt_list (void);\n extern tree re_push_stmt_list (tree);\n extern tree pop_stmt_list (tree);\n extern tree add_stmt (tree);\n-extern void add_decl_stmt (tree);\n extern void push_cleanup (tree, tree, bool);\n \n extern tree walk_stmt_tree (tree *, walk_tree_fn, void *);"}, {"sha": "aa23a9fa1670b7a2c64665da519ec4782d947d95", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -2940,7 +2940,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t    }\n \n \t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    add_decl_stmt (decl);\n+\t    add_stmt (build_stmt (DECL_STMT, decl));\n \t}\n \n       if (!DECL_FILE_SCOPE_P (decl))\n@@ -2967,7 +2967,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n     {\n       if (!DECL_FILE_SCOPE_P (decl)\n \t  && variably_modified_type_p (TREE_TYPE (decl)))\n-\tadd_decl_stmt (decl);\n+\tadd_stmt (build_stmt (DECL_STMT, decl));\n \n       rest_of_decl_compilation (decl, NULL, DECL_FILE_SCOPE_P (decl), 0);\n     }"}, {"sha": "57208e4c03f27b6ceda5c716aa3fa60cb18c9ff3", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -249,8 +249,6 @@ gimplify_expr_stmt (tree *stmt_p)\n \n   if (stmt == NULL_TREE)\n     stmt = build_empty_stmt ();\n-  else if (stmts_are_full_exprs_p ())\n-    stmt = build1 (CLEANUP_POINT_EXPR, void_type_node, stmt);\n \n   *stmt_p = stmt;\n \n@@ -383,8 +381,6 @@ gimplify_c_loop (tree cond, tree body, tree incr, bool cond_is_first)\n   cont_block = begin_bc_block (bc_continue);\n \n   gimplify_stmt (&body);\n-  if (incr && stmts_are_full_exprs_p ())\n-    incr = fold (build1 (CLEANUP_POINT_EXPR, void_type_node, incr));\n   gimplify_stmt (&incr);\n \n   body = finish_bc_block (cont_block, body);\n@@ -483,8 +479,6 @@ gimplify_return_stmt (tree *stmt_p)\n {\n   tree expr = RETURN_STMT_EXPR (*stmt_p);\n   expr = build1 (RETURN_EXPR, void_type_node, expr);\n-  if (stmts_are_full_exprs_p ())\n-    expr = build1 (CLEANUP_POINT_EXPR, void_type_node, expr);\n   *stmt_p = expr;\n   return GS_OK;\n }\n@@ -553,8 +547,6 @@ gimplify_decl_stmt (tree *stmt_p)\n               \n \t      DECL_INITIAL (decl) = NULL_TREE;\n \t      init = build (MODIFY_EXPR, void_type_node, decl, init);\n-\t      if (stmts_are_full_exprs_p ())\n-\t\tinit = build1 (CLEANUP_POINT_EXPR, void_type_node, init);\n \t      append_to_compound_expr (init, &pre);\n \t    }\n \t  else"}, {"sha": "02625a535bd9eca80cdad788b8de92a2f5306f03", "filename": "gcc/c-parse.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -1540,7 +1540,7 @@ nested_function:\n \t\t  add_stmt ($6);\n \t\t  finish_function ();\n \t\t  pop_function_context ();\n-\t\t  add_decl_stmt (decl); }\n+\t\t  add_stmt (build_stmt (DECL_STMT, decl)); }\n \t;\n \n notype_nested_function:\n@@ -1570,7 +1570,7 @@ notype_nested_function:\n \t\t  add_stmt ($6);\n \t\t  finish_function ();\n \t\t  pop_function_context ();\n-\t\t  add_decl_stmt (decl); }\n+\t\t  add_stmt (build_stmt (DECL_STMT, decl)); }\n \t;\n \n /* Any kind of declarator (thus, all declarators allowed\n@@ -2019,7 +2019,7 @@ label_decl:\n \t\t    {\n \t\t      tree label = declare_label (TREE_VALUE (link));\n \t\t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t\t      add_decl_stmt (label);\n+\t\t      add_stmt (build_stmt (DECL_STMT, label));\n \t\t    }\n \t\t}\n \t;"}, {"sha": "bda5161bbe4dcdbb83fd1bb2bd1d35c94eb64ff7", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -145,19 +145,6 @@ add_stmt (tree t)\n   return t;\n }\n \n-/* Create a declaration statement for the declaration given by the\n-   DECL.  */\n-\n-void\n-add_decl_stmt (tree decl)\n-{\n-  tree decl_stmt;\n-\n-  /* We need the type to last until instantiation time.  */\n-  decl_stmt = build_stmt (DECL_STMT, decl);\n-  add_stmt (decl_stmt);\n-}\n-\n /* Build a generic statement based on the given type of node and\n    arguments. Similar to `build_nt', except that we set\n    EXPR_LOCUS to be the current source location.  */"}, {"sha": "4ec0ee6d18c438ece0ab12b65fb1f2b2f1a46a8d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -1,3 +1,12 @@\n+2004-06-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-tree.h (add_decl_stmt): Declare.\n+\t* pt.c (tsubst_copy): Abort for CLEANUP_POINT_EXPR.\n+\t* semantics.c (maybe_cleanup_point_expr): New.\n+\t(add_decl_stmt, finish_expr_stmt, finish_return_stmt,\n+\tfinish_for_expr, finish_switch_cond): Use it.\n+\t(finalize_nrv_r): Don't build an EXPR_STMT.  Don't frob TREE_CHAIN.\n+\n 2004-06-20  Richard Henderson  <rth@redhat.com>\n \n \t* cp-tree.def (CLEANUP_STMT, IF_STMT): Move from c-common.def."}, {"sha": "9d668d398b76aeee812d104010cc2478ad810a27", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -4028,6 +4028,7 @@ extern void pop_to_parent_deferring_access_checks\t(void);\n extern void perform_deferred_access_checks\t(void);\n extern void perform_or_defer_access_check\t(tree, tree);\n extern void init_cp_semantics                   (void);\n+extern void add_decl_stmt\t\t\t(tree);\n extern tree finish_expr_stmt                    (tree);\n extern tree begin_if_stmt                       (void);\n extern void finish_if_stmt_cond                 (tree, tree);"}, {"sha": "de4ab281b2537910c7e45b56e9a8305c3acd9c1b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -7726,6 +7726,12 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t\t  in_decl),\n \t\t\t     tsubst (TREE_TYPE (t), args, complain, in_decl));\n \n+    case CLEANUP_POINT_EXPR:\n+      /* We shouldn't have built any of these during initial template\n+\t generation.  Instead, they should be built during instantiation\n+\t in response to the saved STMT_IS_FULL_EXPR_P setting.  */\n+      abort ();\n+\n     default:\n       return t;\n     }"}, {"sha": "92efe443a6d514fbff97674397f68f368ab45bee", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/543a0daa84fd7dda27536a892dd88896ba25b1f3/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=543a0daa84fd7dda27536a892dd88896ba25b1f3", "patch": "@@ -304,6 +304,27 @@ current_stmt_tree (void)\n \t  : &scope_chain->x_stmt_tree);\n }\n \n+/* If statements are full expressions, wrap STMT in a CLEANUP_POINT_EXPR.  */\n+\n+static tree\n+maybe_cleanup_point_expr (tree expr)\n+{\n+  if (!processing_template_decl && stmts_are_full_exprs_p ())\n+    expr = fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (expr), expr));\n+  return expr;\n+}\n+\n+/* Create a declaration statement for the declaration given by the DECL.  */\n+\n+void\n+add_decl_stmt (tree decl)\n+{\n+  tree r = build_stmt (DECL_STMT, decl);\n+  if (DECL_INITIAL (decl))\n+    r = maybe_cleanup_point_expr (r);\n+  add_stmt (r);\n+}\n+\n /* Nonzero if TYPE is an anonymous union or struct type.  We have to use a\n    flag for this because \"A union for which objects or pointers are\n    declared is not an anonymous union\" [class.union].  */\n@@ -478,8 +499,13 @@ finish_expr_stmt (tree expr)\n \n       /* Simplification of inner statement expressions, compound exprs,\n \t etc can result in the us already having an EXPR_STMT.  */\n-      if (TREE_CODE (expr) != EXPR_STMT)\n-\texpr = build_stmt (EXPR_STMT, expr);\n+      if (TREE_CODE (expr) != CLEANUP_POINT_EXPR)\n+\t{\n+\t  if (TREE_CODE (expr) != EXPR_STMT)\n+\t    expr = build_stmt (EXPR_STMT, expr);\n+\t  expr = maybe_cleanup_point_expr (expr);\n+\t}\n+\n       r = add_stmt (expr);\n     }\n \n@@ -636,7 +662,10 @@ finish_return_stmt (tree expr)\n \t  return finish_goto_stmt (dtor_label);\n \t}\n     }\n-  r = add_stmt (build_stmt (RETURN_STMT, expr));\n+\n+  r = build_stmt (RETURN_STMT, expr);\n+  r = maybe_cleanup_point_expr (r);\n+  r = add_stmt (r);\n   finish_stmt ();\n \n   return r;\n@@ -690,13 +719,16 @@ finish_for_cond (tree cond, tree for_stmt)\n void\n finish_for_expr (tree expr, tree for_stmt)\n {\n+  if (!expr)\n+    return;\n   /* If EXPR is an overloaded function, issue an error; there is no\n      context available to use to perform overload resolution.  */\n-  if (expr && type_unknown_p (expr))\n+  if (type_unknown_p (expr))\n     {\n       cxx_incomplete_type_error (expr, TREE_TYPE (expr));\n       expr = error_mark_node;\n     }\n+  expr = maybe_cleanup_point_expr (expr);\n   FOR_EXPR (for_stmt) = expr;\n }\n \n@@ -777,7 +809,7 @@ finish_switch_cond (tree cond, tree switch_stmt)\n \n \t     Integral promotions are performed.  */\n \t  cond = perform_integral_promotions (cond);\n-\t  cond = fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (cond), cond));\n+\t  cond = maybe_cleanup_point_expr (cond);\n \t}\n \n       if (cond != error_mark_node)\n@@ -1499,8 +1531,7 @@ finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n       init = TREE_OPERAND (target_expr, 1);\n       type = TREE_TYPE (init);\n \n-      if (stmts_are_full_exprs_p ())\n-\tinit = fold (build1 (CLEANUP_POINT_EXPR, type, init));\n+      init = maybe_cleanup_point_expr (init);\n       *result_stmt_p = init;\n \n       if (VOID_TYPE_P (type))\n@@ -2995,10 +3026,8 @@ finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n \t  DECL_INITIAL (dp->var) = error_mark_node;\n \t}\n       else\n-\tinit = NULL_TREE;\n-      init = build_stmt (EXPR_STMT, init);\n+\tinit = build_empty_stmt ();\n       SET_EXPR_LOCUS (init, EXPR_LOCUS (*tp));\n-      TREE_CHAIN (init) = TREE_CHAIN (*tp);\n       *tp = init;\n     }\n   /* And replace all uses of the NRV with the RESULT_DECL.  */"}]}