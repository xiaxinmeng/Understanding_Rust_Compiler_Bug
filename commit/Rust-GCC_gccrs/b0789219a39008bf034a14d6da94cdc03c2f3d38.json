{"sha": "b0789219a39008bf034a14d6da94cdc03c2f3d38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA3ODkyMTlhMzkwMDhiZjAzNGExNGQ2ZGE5NGNkYzAzYzJmM2QzOA==", "commit": {"author": {"name": "Tobias Grosser", "email": "grosser@fim.uni-passau.de", "date": "2009-02-05T00:29:48Z"}, "committer": {"name": "Tobias Grosser", "email": "grosser@gcc.gnu.org", "date": "2009-02-05T00:29:48Z"}, "message": "graphite.c (bb_in_sese_p, [...]): Moved.\n\n2009-02-04  Tobias Grosser  <grosser@fim.uni-passau.de> \n\n\t* graphite.c (bb_in_sese_p, sese_build_livein_liveouts_use,\n\tsese_build_livein_liveouts_bb, sese_build_livein_liveouts,\n\tregister_bb_in_sese, new_sese, free_sese): Moved.\n\t(dot_scop_1, build_scop_loop_nests, build_loop_iteration_domains,\n\toutermost_loop_in_scop, build_scop_iteration_domain,\n\texpand_scalar_variables_ssa_name, get_vdef_before_scop,\n\tlimit_scops): Use bb_in_sese_p instead of bb_in_scop_p.\n\tUse loop_in_sese_p instead of loop_in_scop_p.\n\t(new_graphite_bb, gloog): Do not initialize SCOP_BBS_B.\n\t(new_scop, free_scop): Remove SCOP_LOOP2CLOOG_LOOP and SCOP_BBS_B.\n\t(scopdet_basic_block_info): Fix bug in scop detection.\n\t(new_loop_to_cloog_loop_str, hash_loop_to_cloog_loop,\n\teq_loop_to_cloog_loop): Remove.\n\t(nb_loops_around_loop_in_scop, nb_loop\n\tref_nb_loops): Moved here...\n\t* graphite.h (ref_nb_loops): ... from here.\n\t(struct scop): Remove bbs_b bitmap and loop2cloog_loop.\n\t(loop_domain_dim, loop_iteration_vector_dim): Remove.\n\t(SCOP_BBS_B, bb_in_scop_p, loop_in_scop_p): Removed.\n\t* testsuite/gcc.dg/graphite/scop-19.c: New\n\nFrom-SVN: r143947", "tree": {"sha": "6683b37733710f6a5b7cdd25924143ec5da0c09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6683b37733710f6a5b7cdd25924143ec5da0c09d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0789219a39008bf034a14d6da94cdc03c2f3d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0789219a39008bf034a14d6da94cdc03c2f3d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0789219a39008bf034a14d6da94cdc03c2f3d38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0789219a39008bf034a14d6da94cdc03c2f3d38/comments", "author": {"login": "tobiasgrosser", "id": 521960, "node_id": "MDQ6VXNlcjUyMTk2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/521960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tobiasgrosser", "html_url": "https://github.com/tobiasgrosser", "followers_url": "https://api.github.com/users/tobiasgrosser/followers", "following_url": "https://api.github.com/users/tobiasgrosser/following{/other_user}", "gists_url": "https://api.github.com/users/tobiasgrosser/gists{/gist_id}", "starred_url": "https://api.github.com/users/tobiasgrosser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tobiasgrosser/subscriptions", "organizations_url": "https://api.github.com/users/tobiasgrosser/orgs", "repos_url": "https://api.github.com/users/tobiasgrosser/repos", "events_url": "https://api.github.com/users/tobiasgrosser/events{/privacy}", "received_events_url": "https://api.github.com/users/tobiasgrosser/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d75ea2a59296fce44ff0c3a98ba00e6051f9e332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75ea2a59296fce44ff0c3a98ba00e6051f9e332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75ea2a59296fce44ff0c3a98ba00e6051f9e332"}], "stats": {"total": 474, "additions": 262, "deletions": 212}, "files": [{"sha": "a06b164620a2bbddaa92a0284bd1524ba1dfc32a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0789219a39008bf034a14d6da94cdc03c2f3d38", "patch": "@@ -1,3 +1,26 @@\n+2009-02-04  Tobias Grosser  <grosser@fim.uni-passau.de>\t\n+\n+\t* graphite.c (bb_in_sese_p, sese_build_livein_liveouts_use,\n+\tsese_build_livein_liveouts_bb, sese_build_livein_liveouts,\n+\tregister_bb_in_sese, new_sese, free_sese): Moved.\n+\t(dot_scop_1, build_scop_loop_nests, build_loop_iteration_domains,\n+\toutermost_loop_in_scop, build_scop_iteration_domain,\n+\texpand_scalar_variables_ssa_name, get_vdef_before_scop,\n+\tlimit_scops): Use bb_in_sese_p instead of bb_in_scop_p.\n+\tUse loop_in_sese_p instead of loop_in_scop_p.\n+\t(new_graphite_bb, gloog): Do not initialize SCOP_BBS_B.\n+\t(new_scop, free_scop): Remove SCOP_LOOP2CLOOG_LOOP and SCOP_BBS_B.\n+\t(scopdet_basic_block_info): Fix bug in scop detection.\n+\t(new_loop_to_cloog_loop_str, hash_loop_to_cloog_loop,\n+\teq_loop_to_cloog_loop): Remove.\n+\t(nb_loops_around_loop_in_scop, nb_loop\n+\tref_nb_loops): Moved here...\n+\t* graphite.h (ref_nb_loops): ... from here.\n+\t(struct scop): Remove bbs_b bitmap and loop2cloog_loop.\n+\t(loop_domain_dim, loop_iteration_vector_dim): Remove.\n+\t(SCOP_BBS_B, bb_in_scop_p, loop_in_scop_p): Removed.\n+\t* testsuite/gcc.dg/graphite/scop-19.c: New\n+\n 2009-02-04  Paolo Bonzini  <bonzini@gnu.org>\n \t    Hans-Peter Nilsson  <hp@axis.com>\n "}, {"sha": "a4d5e36f132bf826093dc11286348ef2ce53e614", "filename": "gcc/graphite.c", "status": "modified", "additions": 197, "deletions": 151, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=b0789219a39008bf034a14d6da94cdc03c2f3d38", "patch": "@@ -69,6 +69,147 @@ gmp_cst_to_tree (tree type, Value v)\n   return build_int_cst (type, value_get_si (v));\n }\n \n+/* Returns true when BB is in REGION.  */\n+\n+static bool\n+bb_in_sese_p (basic_block bb, sese region)\n+{\n+  return pointer_set_contains (SESE_REGION_BBS (region), bb);\n+}\n+\n+/* Returns true when LOOP is in the SESE region R.  */\n+\n+static inline bool \n+loop_in_sese_p (struct loop *loop, sese r)\n+{\n+  return (bb_in_sese_p (loop->header, r)\n+\t  && bb_in_sese_p (loop->latch, r));\n+}\n+\n+/* For a USE in BB, if BB is outside REGION, mark the USE in the\n+   SESE_LIVEIN and SESE_LIVEOUT sets.  */\n+\n+static void\n+sese_build_livein_liveouts_use (sese region, basic_block bb, tree use)\n+{\n+  unsigned ver;\n+  basic_block def_bb;\n+\n+  if (TREE_CODE (use) != SSA_NAME)\n+    return;\n+\n+  ver = SSA_NAME_VERSION (use);\n+  def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n+  if (!def_bb\n+      || !bb_in_sese_p (def_bb, region)\n+      || bb_in_sese_p (bb, region))\n+    return;\n+\n+  if (!SESE_LIVEIN_VER (region, ver))\n+    SESE_LIVEIN_VER (region, ver) = BITMAP_ALLOC (NULL);\n+\n+  bitmap_set_bit (SESE_LIVEIN_VER (region, ver), bb->index);\n+  bitmap_set_bit (SESE_LIVEOUT (region), ver);\n+}\n+\n+/* Marks for rewrite all the SSA_NAMES defined in REGION and that are\n+   used in BB that is outside of the REGION.  */\n+\n+static void\n+sese_build_livein_liveouts_bb (sese region, basic_block bb)\n+{\n+  gimple_stmt_iterator bsi;\n+  edge e;\n+  edge_iterator ei;\n+  ssa_op_iter iter;\n+  tree var;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n+      sese_build_livein_liveouts_use (region, bb,\n+\t\t\t\t      PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e));\n+\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    FOR_EACH_SSA_TREE_OPERAND (var, gsi_stmt (bsi), iter, SSA_OP_ALL_USES)\n+      sese_build_livein_liveouts_use (region, bb, var);\n+}\n+\n+/* Build the SESE_LIVEIN and SESE_LIVEOUT for REGION.  */\n+\n+void\n+sese_build_livein_liveouts (sese region)\n+{\n+  basic_block bb;\n+\n+  SESE_LIVEOUT (region) = BITMAP_ALLOC (NULL);\n+  SESE_NUM_VER (region) = num_ssa_names;\n+  SESE_LIVEIN (region) = XCNEWVEC (bitmap, SESE_NUM_VER (region));\n+\n+  FOR_EACH_BB (bb)\n+    sese_build_livein_liveouts_bb (region, bb);\n+}\n+\n+/* Register basic blocks belonging to a region in a pointer set.  */\n+\n+static void\n+register_bb_in_sese (basic_block entry_bb, basic_block exit_bb, sese region)\n+{\n+  edge_iterator ei;\n+  edge e;\n+  basic_block bb = entry_bb;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (!pointer_set_contains (SESE_REGION_BBS (region), e->dest) &&\n+\t  e->dest->index != exit_bb->index)\n+\t{\t\n+\t  pointer_set_insert (SESE_REGION_BBS (region), e->dest);\n+\t  register_bb_in_sese (e->dest, exit_bb, region);\n+\t}\n+    }\n+}\n+\n+/* Builds a new SESE region from edges ENTRY and EXIT.  */\n+\n+sese\n+new_sese (edge entry, edge exit)\n+{\n+  sese res = XNEW (struct sese);\n+\n+  SESE_ENTRY (res) = entry;\n+  SESE_EXIT (res) = exit;\n+  SESE_REGION_BBS (res) = pointer_set_create ();\n+  register_bb_in_sese (entry->dest, exit->dest, res);\n+\n+  SESE_LIVEOUT (res) = NULL;\n+  SESE_NUM_VER (res) = 0;\n+  SESE_LIVEIN (res) = NULL;\n+\n+  return res;\n+}\n+\n+/* Deletes REGION.  */\n+\n+void\n+free_sese (sese region)\n+{\n+  int i;\n+\n+  for (i = 0; i < SESE_NUM_VER (region); i++)\n+    BITMAP_FREE (SESE_LIVEIN_VER (region, i));\n+\n+  if (SESE_LIVEIN (region))\n+    free (SESE_LIVEIN (region));\n+\n+  if (SESE_LIVEOUT (region))\n+    BITMAP_FREE (SESE_LIVEOUT (region));\n+\n+  pointer_set_destroy (SESE_REGION_BBS (region));\n+  XDELETE (region);\n+}\n+\n+\f\n+\n /* Debug the list of old induction variables for this SCOP.  */\n \n void\n@@ -701,7 +842,7 @@ dot_scop_1 (FILE *file, scop_p scop)\n       if (bb == exit)\n \tfprintf (file, \"%d [shape=box];\\n\", bb->index);\n \n-      if (bb_in_scop_p (bb, scop)) \n+      if (bb_in_sese_p (bb, SCOP_REGION (scop))) \n \tfprintf (file, \"%d [color=red];\\n\", bb->index);\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -755,7 +896,7 @@ dot_all_scops_1 (FILE *file)\n \n       /* Select color for SCoP.  */\n       for (i = 0; VEC_iterate (scop_p, current_scops, i, scop); i++)\n-\tif (bb_in_scop_p (bb, scop)\n+\tif (bb_in_sese_p (bb, SCOP_REGION (scop))\n \t    || (SCOP_EXIT (scop) == bb)\n \t    || (SCOP_ENTRY (scop) == bb))\n \t  {\n@@ -818,7 +959,7 @@ dot_all_scops_1 (FILE *file)\n \n \t    fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"%s\\\">\", color);\n         \n-\t    if (!bb_in_scop_p (bb, scop))\n+\t    if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n \t      fprintf (file, \" (\"); \n \n \t    if (bb == SCOP_ENTRY (scop)\n@@ -831,7 +972,7 @@ dot_all_scops_1 (FILE *file)\n \t    else\n \t      fprintf (file, \" %d \", bb->index);\n \n-\t    if (!bb_in_scop_p (bb, scop))\n+\t    if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n \t      fprintf (file, \")\");\n \n \t    fprintf (file, \"</TD></TR>\\n\");\n@@ -887,7 +1028,8 @@ outermost_loop_in_scop (scop_p scop, basic_block bb)\n   struct loop *nest;\n \n   nest = bb->loop_father;\n-  while (loop_outer (nest) && loop_in_scop_p (loop_outer (nest), scop))\n+  while (loop_outer (nest)\n+\t && loop_in_sese_p (loop_outer (nest), SCOP_REGION (scop)))\n     nest = loop_outer (nest);\n \n   return nest;\n@@ -1133,8 +1275,6 @@ new_graphite_bb (scop_p scop, basic_block bb)\n   struct loop *nest = outermost_loop_in_scop (scop, bb);\n   gimple_stmt_iterator gsi;\n \n-  bitmap_set_bit (SCOP_BBS_B (scop), bb->index);\n-\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     find_data_references_in_stmt (nest, gsi_stmt (gsi), &drs);\n \n@@ -1273,138 +1413,6 @@ get_new_name_from_old_name (htab_t map, tree old_name)\n \n \f\n \n-/* Returns true when BB is in REGION.  */\n-\n-static bool\n-bb_in_sese_p (basic_block bb, sese region)\n-{\n-  return pointer_set_contains (SESE_REGION_BBS (region), bb);\n-}\n-\n-/* For a USE in BB, if BB is outside REGION, mark the USE in the\n-   SESE_LIVEIN and SESE_LIVEOUT sets.  */\n-\n-static void\n-sese_build_livein_liveouts_use (sese region, basic_block bb, tree use)\n-{\n-  unsigned ver;\n-  basic_block def_bb;\n-\n-  if (TREE_CODE (use) != SSA_NAME)\n-    return;\n-\n-  ver = SSA_NAME_VERSION (use);\n-  def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n-  if (!def_bb\n-      || !bb_in_sese_p (def_bb, region)\n-      || bb_in_sese_p (bb, region))\n-    return;\n-\n-  if (!SESE_LIVEIN_VER (region, ver))\n-    SESE_LIVEIN_VER (region, ver) = BITMAP_ALLOC (NULL);\n-\n-  bitmap_set_bit (SESE_LIVEIN_VER (region, ver), bb->index);\n-  bitmap_set_bit (SESE_LIVEOUT (region), ver);\n-}\n-\n-/* Marks for rewrite all the SSA_NAMES defined in REGION and that are\n-   used in BB that is outside of the REGION.  */\n-\n-static void\n-sese_build_livein_liveouts_bb (sese region, basic_block bb)\n-{\n-  gimple_stmt_iterator bsi;\n-  edge e;\n-  edge_iterator ei;\n-  ssa_op_iter iter;\n-  tree var;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n-      sese_build_livein_liveouts_use (region, bb,\n-\t\t\t\t      PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e));\n-\n-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-    FOR_EACH_SSA_TREE_OPERAND (var, gsi_stmt (bsi), iter, SSA_OP_ALL_USES)\n-      sese_build_livein_liveouts_use (region, bb, var);\n-}\n-\n-/* Build the SESE_LIVEIN and SESE_LIVEOUT for REGION.  */\n-\n-void\n-sese_build_livein_liveouts (sese region)\n-{\n-  basic_block bb;\n-\n-  SESE_LIVEOUT (region) = BITMAP_ALLOC (NULL);\n-  SESE_NUM_VER (region) = num_ssa_names;\n-  SESE_LIVEIN (region) = XCNEWVEC (bitmap, SESE_NUM_VER (region));\n-\n-  FOR_EACH_BB (bb)\n-    sese_build_livein_liveouts_bb (region, bb);\n-}\n-\n-/* Register basic blocks belonging to a region in a pointer set.  */\n-\n-static void\n-register_bb_in_sese (basic_block entry_bb, basic_block exit_bb, sese region)\n-{\n-  edge_iterator ei;\n-  edge e;\n-  basic_block bb = entry_bb;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    {\n-      if (!pointer_set_contains (SESE_REGION_BBS (region), e->dest) &&\n-\t  e->dest->index != exit_bb->index)\n-\t{\t\n-\t  pointer_set_insert (SESE_REGION_BBS (region), e->dest);\n-\t  register_bb_in_sese (e->dest, exit_bb, region);\n-\t}\n-    }\n-}\n-\n-/* Builds a new SESE region from edges ENTRY and EXIT.  */\n-\n-sese\n-new_sese (edge entry, edge exit)\n-{\n-  sese res = XNEW (struct sese);\n-\n-  SESE_ENTRY (res) = entry;\n-  SESE_EXIT (res) = exit;\n-  SESE_REGION_BBS (res) = pointer_set_create ();\n-  register_bb_in_sese (entry->dest, exit->dest, res);\n-\n-  SESE_LIVEOUT (res) = NULL;\n-  SESE_NUM_VER (res) = 0;\n-  SESE_LIVEIN (res) = NULL;\n-\n-  return res;\n-}\n-\n-/* Deletes REGION.  */\n-\n-void\n-free_sese (sese region)\n-{\n-  int i;\n-\n-  for (i = 0; i < SESE_NUM_VER (region); i++)\n-    BITMAP_FREE (SESE_LIVEIN_VER (region, i));\n-\n-  if (SESE_LIVEIN (region))\n-    free (SESE_LIVEIN (region));\n-\n-  if (SESE_LIVEOUT (region))\n-    BITMAP_FREE (SESE_LIVEOUT (region));\n-\n-  pointer_set_destroy (SESE_REGION_BBS (region));\n-  XDELETE (region);\n-}\n-\n-\f\n-\n /* Creates a new scop starting with ENTRY.  */\n \n static scop_p\n@@ -1417,7 +1425,6 @@ new_scop (edge entry, edge exit)\n   SCOP_REGION (scop) = new_sese (entry, exit);\n   SCOP_BBS (scop) = VEC_alloc (graphite_bb_p, heap, 3);\n   SCOP_OLDIVS (scop) = VEC_alloc (name_tree, heap, 3);\n-  SCOP_BBS_B (scop) = BITMAP_ALLOC (NULL);\n   SCOP_LOOPS (scop) = BITMAP_ALLOC (NULL);\n   SCOP_LOOP_NEST (scop) = VEC_alloc (loop_p, heap, 3);\n   SCOP_ADD_PARAMS (scop) = true;\n@@ -1446,7 +1453,6 @@ free_scop (scop_p scop)\n     free_graphite_bb (gb);\n \n   VEC_free (graphite_bb_p, heap, SCOP_BBS (scop));\n-  BITMAP_FREE (SCOP_BBS_B (scop));\n   BITMAP_FREE (SCOP_LOOPS (scop));\n   VEC_free (loop_p, heap, SCOP_LOOP_NEST (scop));\n \n@@ -1632,6 +1638,12 @@ scopdet_basic_block_info (basic_block bb, VEC (sd_region, heap) **scops,\n       result.next = NULL;\n       result.exits = false;\n       result.last = bb;\n+\n+      /* Mark bbs terminating a SESE region difficult, if they start\n+\t a condition.  */\n+      if (VEC_length (edge, bb->succs) > 1)\n+\tresult.difficult = true; \n+\n       break;\n \n     case GBB_SIMPLE:\n@@ -2410,13 +2422,13 @@ build_scop_loop_nests (scop_p scop)\n   struct loop *loop0, *loop1;\n \n   FOR_EACH_BB (bb)\n-    if (bb_in_scop_p (bb, scop))\n+    if (bb_in_sese_p (bb, SCOP_REGION (scop)))\n       {\n \tstruct loop *loop = bb->loop_father;\n \n \t/* Only add loops if they are completely contained in the SCoP.  */\n \tif (loop->header == bb\n-\t    && bb_in_scop_p (loop->latch, scop))\n+\t    && bb_in_sese_p (loop->latch, SCOP_REGION (scop)))\n \t  {\n \t    if (!scop_record_loop (scop, loop))\n \t      return false;\n@@ -2442,6 +2454,40 @@ build_scop_loop_nests (scop_p scop)\n   return true;\n }\n \n+/* Calculate the number of loops around LOOP in the SCOP.  */\n+\n+static inline int\n+nb_loops_around_loop_in_scop (struct loop *l, scop_p scop)\n+{\n+  int d = 0;\n+\n+  for (; loop_in_sese_p (l, SCOP_REGION (scop)); d++, l = loop_outer (l));\n+\n+  return d;\n+}\n+\n+/* Calculate the number of loops around GB in the current SCOP.  */\n+\n+int\n+nb_loops_around_gb (graphite_bb_p gb)\n+{\n+  return nb_loops_around_loop_in_scop (gbb_loop (gb), GBB_SCOP (gb));\n+}\n+\n+/* Returns the dimensionality of an enclosing loop iteration domain\n+   with respect to enclosing SCoP for a given data reference REF.  The\n+   returned dimensionality is homogeneous (depth of loop nest + number\n+   of SCoP parameters + const).  */\n+\n+int\n+ref_nb_loops (data_reference_p ref)\n+{\n+  loop_p loop = loop_containing_stmt (DR_STMT (ref));\n+  scop_p scop = DR_SCOP (ref);\n+\n+  return nb_loops_around_loop_in_scop (loop, scop) + scop_nb_params (scop) + 2;\n+}\n+\n /* Build dynamic schedules for all the BBs. */\n \n static void\n@@ -3086,13 +3132,14 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n   else\n     gcc_unreachable ();\n \n-  if (loop->inner && loop_in_scop_p (loop->inner, scop))\n+  if (loop->inner && loop_in_sese_p (loop->inner, SCOP_REGION (scop)))\n     build_loop_iteration_domains (scop, loop->inner, cstr, nb_outer_loops + 1);\n \n   /* Only go to the next loops, if we are not at the outermost layer.  These\n      have to be handled seperately, as we can be sure, that the chain at this\n      layer will be connected.  */\n-  if (nb_outer_loops != 0 && loop->next && loop_in_scop_p (loop->next, scop))\n+  if (nb_outer_loops != 0 && loop->next && loop_in_sese_p (loop->next,\n+\t\t\t\t\t\t\t   SCOP_REGION (scop)))\n     build_loop_iteration_domains (scop, loop->next, outer_cstr, nb_outer_loops);\n \n   for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n@@ -3368,7 +3415,7 @@ build_scop_conditions_1 (VEC (gimple, heap) **conditions,\n   VEC (basic_block, heap) *dom;\n   \n   /* Make sure we are in the SCoP.  */\n-  if (!bb_in_scop_p (bb, scop))\n+  if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n     return true;\n \n   if (bb_contains_non_iv_scalar_phi_nodes (bb))\n@@ -3562,7 +3609,7 @@ build_scop_iteration_domain (scop_p scop)\n   /* Build cloog loop for all loops, that are in the uppermost loop layer of\n      this SCoP.  */\n   for (i = 0; VEC_iterate (loop_p, SCOP_LOOP_NEST (scop), i, loop); i++)\n-    if (!loop_in_scop_p (loop_outer (loop), scop))\n+    if (!loop_in_sese_p (loop_outer (loop), SCOP_REGION (scop)))\n       {\n         /* The outermost constraints is a matrix that has:\n            -first column: eq/ineq boolean\n@@ -4138,7 +4185,7 @@ expand_scalar_variables_ssa_name (tree op0, basic_block bb,\n   else\n     {\n       if (gimple_code (def_stmt) != GIMPLE_ASSIGN\n-\t  || !bb_in_scop_p (gimple_bb (def_stmt), scop))\n+\t  || !bb_in_sese_p (gimple_bb (def_stmt), SCOP_REGION (scop)))\n \treturn get_new_name_from_old_name (map, op0);\n \n       var0 = gimple_assign_rhs1 (def_stmt);\n@@ -5142,7 +5189,7 @@ get_vdef_before_scop (scop_p scop, tree name, sbitmap visited)\n   basic_block def_bb = gimple_bb (def_stmt);\n \n   if (!def_bb\n-      || !bb_in_scop_p (def_bb, scop))\n+      || !bb_in_sese_p (def_bb, SCOP_REGION (scop)))\n     return name;\n \n   if (TEST_BIT (visited, def_bb->index))\n@@ -5396,7 +5443,6 @@ gloog (scop_p scop, struct clast_stmt *stmt)\n     {\n       basic_block bb = SESE_EXIT (SCOP_REGION (scop))->dest;\n       SESE_EXIT (SCOP_REGION (scop)) = split_block_after_labels (bb);\n-      bitmap_set_bit (SCOP_BBS_B (scop), bb->index);\n       pointer_set_insert (SESE_REGION_BBS (SCOP_REGION (scop)), bb);\n     }\n \n@@ -6031,7 +6077,7 @@ limit_scops (void)\n \tcontinue;\n \n       for (j = 0; VEC_iterate (loop_p, SCOP_LOOP_NEST (scop), j, loop); j++) \n-        if (!loop_in_scop_p (loop_outer (loop), scop))\n+        if (!loop_in_sese_p (loop_outer (loop), SCOP_REGION (scop)))\n           {\n \t    sd_region open_scop;\n \t    open_scop.entry = loop->header;"}, {"sha": "1063a01110cf5d803bd5e669163fade52f87cf94", "filename": "gcc/graphite.h", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=b0789219a39008bf034a14d6da94cdc03c2f3d38", "patch": "@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"tree-data-ref.h\"\n \n+int ref_nb_loops (data_reference_p);\n+\n typedef struct graphite_bb *graphite_bb_p;\n DEF_VEC_P(graphite_bb_p);\n DEF_VEC_ALLOC_P (graphite_bb_p, heap);\n@@ -216,6 +218,8 @@ gbb_loop (struct graphite_bb *gbb)\n   return GBB_BB (gbb)->loop_father;\n }\n \n+int nb_loops_around_gb (graphite_bb_p);\n+\n /* Calculate the number of loops around GB in the current SCOP.  Only\n    works if GBB_DOMAIN is built.  */\n \n@@ -313,13 +317,11 @@ struct scop\n   /* A SCOP is defined as a SESE region.  */\n   sese region;\n \n-  /* All the basic blocks in this scop.  They have extra information\n-     attached to them, in the graphite_bb structure.  */\n+  /* All the basic blocks in this scop that contain memory references\n+     and that will be represented as statements in the polyhedral\n+     representation.  */\n   VEC (graphite_bb_p, heap) *bbs;\n \n-  /* Set for a basic block index when it belongs to this SCOP.  */\n-  bitmap bbs_b;\n-\n   lambda_vector static_schedule;\n \n   /* Parameters used within the SCOP.  */\n@@ -349,7 +351,6 @@ struct scop\n };\n \n #define SCOP_BBS(S) S->bbs\n-#define SCOP_BBS_B(S) S->bbs_b\n #define SCOP_REGION(S) S->region\n /* SCOP_ENTRY bb dominates all the bbs of the scop.  SCOP_EXIT bb\n    post-dominates all the bbs of the scop.  SCOP_EXIT potentially\n@@ -572,59 +573,4 @@ scop_gimple_loop_depth (scop_p scop, loop_p loop)\n   return depth;\n }\n \n-/* Static inline function prototypes.  */\n-\n-static inline unsigned scop_nb_params (scop_p scop);\n-\n-/* Returns true when BB is in SCOP.  */\n-\n-static inline bool\n-bb_in_scop_p (basic_block bb, scop_p scop)\n-{\n-  return bitmap_bit_p (SCOP_BBS_B (scop), bb->index);\n-}\n-\n-/* Returns true when LOOP is in SCOP.  */\n-\n-static inline bool \n-loop_in_scop_p (struct loop *loop, scop_p scop)\n-{\n-  return (bb_in_scop_p (loop->header, scop)\n-\t  && bb_in_scop_p (loop->latch, scop));\n-}\n-\n-/* Calculate the number of loops around LOOP in the SCOP.  */\n-\n-static inline int\n-nb_loops_around_loop_in_scop (struct loop *l, scop_p scop)\n-{\n-  int d = 0;\n-\n-  for (; loop_in_scop_p (l, scop); d++, l = loop_outer (l));\n-\n-  return d;\n-}\n-\n-/* Calculate the number of loops around GB in the current SCOP.  */\n-\n-static inline int\n-nb_loops_around_gb (graphite_bb_p gb)\n-{\n-  return nb_loops_around_loop_in_scop (gbb_loop (gb), GBB_SCOP (gb));\n-}\n-\n-/* Returns the dimensionality of an enclosing loop iteration domain\n-   with respect to enclosing SCoP for a given data reference REF.  The\n-   returned dimensionality is homogeneous (depth of loop nest + number\n-   of SCoP parameters + const).  */\n-\n-static inline int\n-ref_nb_loops (data_reference_p ref)\n-{\n-  loop_p loop = loop_containing_stmt (DR_STMT (ref));\n-  scop_p scop = DR_SCOP (ref);\n-\n-  return nb_loops_around_loop_in_scop (loop, scop) + scop_nb_params (scop) + 2;\n-}\n-\n #endif  /* GCC_GRAPHITE_H  */"}, {"sha": "3ad49971bc03bb4bc872f3ea5e64337f1b3799e9", "filename": "gcc/testsuite/gcc.dg/graphite/scop-19.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0789219a39008bf034a14d6da94cdc03c2f3d38/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-19.c?ref=b0789219a39008bf034a14d6da94cdc03c2f3d38", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n+typedef unsigned int __uint32_t;\n+typedef __uint32_t __size_t;\n+typedef __size_t size_t;\n+struct demangle_component\n+{\n+  union\n+  {\n+  } u;\n+};\n+enum d_builtin_type_print\n+{\n+  D_PRINT_VOID\n+};\n+struct d_growable_string\n+{\n+  size_t alc;\n+};\n+d_growable_string_resize (struct d_growable_string *dgs, size_t need)\n+{\n+  size_t newalc;\n+  newalc = dgs->alc > 0 ? dgs->alc : 2;\n+  while (newalc < need)\n+    newalc <<= 1;\n+}\n+d_growable_string_append_buffer (struct d_growable_string *dgs,\n+                                 const char *s, size_t l)\n+{\n+  size_t need;\n+  if (need > dgs->alc)\n+    d_growable_string_resize (dgs, need);\n+}\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 0\" 2 \"graphite\"} } */ \n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */\n+"}]}