{"sha": "fd0d7b4e3be10508119636f06807f23d5691088b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQwZDdiNGUzYmUxMDUwODExOTYzNmYwNjgwN2YyM2Q1NjkxMDg4Yg==", "commit": {"author": {"name": "Dmitriy Anisimkov", "email": "anisimko@adacore.com", "date": "2019-09-19T08:14:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-09-19T08:14:18Z"}, "message": "[Ada] New routine GNAT.Sockets.Create_Socket_Pair\n\nNew routine to create 2 connected sockets. This routine is analog of the\nUNIX system call socketpair. On UNIX platforms it is implemented on the\nbase of socketpair. On other platforms it is implemented by conecting\nnetwork sockets over loopback interface.\n\n2019-09-19  Dmitriy Anisimkov  <anisimko@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/g-socket.ads, libgnat/g-socket.adb\n\t(Create_Socket_Pair): New routine.\n\t* libgnat/g-socthi.ads (OS_Has_Socketpair): Boolean constant.\n\t(C_Socketpair): New imported routine.\n\t* libgnat/g-socthi__mingw.ads, libgnat/g-socthi__vxworks.ads\n\t(Default_Socket_Pair_Family): New constant.\n\t(C_Socketpair): New routine.\n\t* libgnat/g-socthi__mingw.adb, libgnat/g-socthi__vxworks.adb\n\t(C_Socketpair): Is separated in anouther file.\n\t* libgnat/g-sthcso.adb (C_Socketpair): Non UNIX implementation.\n\t* libgnat/g-stsifd__sockets.adb: Reuse C_Socketpair.\n\nFrom-SVN: r275951", "tree": {"sha": "8df8eec1c680c1ed52929a63b3f2f0b32266ec62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8df8eec1c680c1ed52929a63b3f2f0b32266ec62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd0d7b4e3be10508119636f06807f23d5691088b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd0d7b4e3be10508119636f06807f23d5691088b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd0d7b4e3be10508119636f06807f23d5691088b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd0d7b4e3be10508119636f06807f23d5691088b/comments", "author": {"login": "anisimkov", "id": 15864134, "node_id": "MDQ6VXNlcjE1ODY0MTM0", "avatar_url": "https://avatars.githubusercontent.com/u/15864134?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anisimkov", "html_url": "https://github.com/anisimkov", "followers_url": "https://api.github.com/users/anisimkov/followers", "following_url": "https://api.github.com/users/anisimkov/following{/other_user}", "gists_url": "https://api.github.com/users/anisimkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/anisimkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anisimkov/subscriptions", "organizations_url": "https://api.github.com/users/anisimkov/orgs", "repos_url": "https://api.github.com/users/anisimkov/repos", "events_url": "https://api.github.com/users/anisimkov/events{/privacy}", "received_events_url": "https://api.github.com/users/anisimkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fe56329e05e3e77c424929fdb102f2df075f74a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe56329e05e3e77c424929fdb102f2df075f74a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe56329e05e3e77c424929fdb102f2df075f74a"}], "stats": {"total": 476, "additions": 330, "deletions": 146}, "files": [{"sha": "a204c285d4c91cb797b0a7eeb8bb669c3d8ab0c9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -1,3 +1,17 @@\n+2019-09-19  Dmitriy Anisimkov  <anisimko@adacore.com>\n+\n+\t* libgnat/g-socket.ads, libgnat/g-socket.adb\n+\t(Create_Socket_Pair): New routine.\n+\t* libgnat/g-socthi.ads (OS_Has_Socketpair): Boolean constant.\n+\t(C_Socketpair): New imported routine.\n+\t* libgnat/g-socthi__mingw.ads, libgnat/g-socthi__vxworks.ads\n+\t(Default_Socket_Pair_Family): New constant.\n+\t(C_Socketpair): New routine.\n+\t* libgnat/g-socthi__mingw.adb, libgnat/g-socthi__vxworks.adb\n+\t(C_Socketpair): Is separated in anouther file.\n+\t* libgnat/g-sthcso.adb (C_Socketpair): Non UNIX implementation.\n+\t* libgnat/g-stsifd__sockets.adb: Reuse C_Socketpair.\n+\n 2019-09-19  Yannick Moy  <moy@adacore.com>\n \n \t* sem_prag.adb (Analyze_Depends_In_Decl_Part): Simplify previous"}, {"sha": "6c65424df6303874d4e66b016958dced0b1526c3", "filename": "gcc/ada/libgnat/g-socket.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socket.adb?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -867,6 +867,34 @@ package body GNAT.Sockets is\n       Socket := Socket_Type (Res);\n    end Create_Socket;\n \n+   ------------------------\n+   -- Create_Socket_Pair --\n+   ------------------------\n+\n+   procedure Create_Socket_Pair\n+     (Left   : out Socket_Type;\n+      Right  : out Socket_Type;\n+      Family : Family_Type := Family_Unspec;\n+      Mode   : Mode_Type   := Socket_Stream;\n+      Level  : Level_Type  := IP_Protocol_For_IP_Level)\n+   is\n+      Res  : C.int;\n+      Pair : aliased Thin_Common.Fd_Pair;\n+\n+   begin\n+      Res := C_Socketpair\n+        ((if Family = Family_Unspec then Default_Socket_Pair_Family\n+          else Families (Family)),\n+         Modes (Mode), Levels (Level), Pair'Access);\n+\n+      if Res = Failure then\n+         Raise_Socket_Error (Socket_Errno);\n+      end if;\n+\n+      Left  := Socket_Type (Pair (Pair'First));\n+      Right := Socket_Type (Pair (Pair'Last));\n+   end Create_Socket_Pair;\n+\n    -----------\n    -- Empty --\n    -----------"}, {"sha": "3962cc048915ab4f809770dee865285bdbadf724", "filename": "gcc/ada/libgnat/g-socket.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socket.ads?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -1104,7 +1104,17 @@ package GNAT.Sockets is\n       Family : Family_Type := Family_Inet;\n       Mode   : Mode_Type   := Socket_Stream;\n       Level  : Level_Type  := IP_Protocol_For_IP_Level);\n-   --  Create an endpoint for communication. Raises Socket_Error on error\n+   --  Create an endpoint for communication. Raises Socket_Error on error.\n+\n+   procedure Create_Socket_Pair\n+     (Left   : out Socket_Type;\n+      Right  : out Socket_Type;\n+      Family : Family_Type := Family_Unspec;\n+      Mode   : Mode_Type   := Socket_Stream;\n+      Level  : Level_Type  := IP_Protocol_For_IP_Level);\n+   --  Create two connected sockets. Raises Socket_Error on error.\n+   --  If Family is unspecified, it creates Family_Unix sockets on UNIX and\n+   --  Family_Inet sockets on non UNIX platforms.\n \n    procedure Accept_Socket\n      (Server  : Socket_Type;"}, {"sha": "56b31acb45b79aa1d2d88ebe4c25deb2a0173453", "filename": "gcc/ada/libgnat/g-socthi.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socthi.ads?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -184,6 +184,16 @@ package GNAT.Sockets.Thin is\n    function C_System\n      (Command : System.Address) return C.int;\n \n+   Default_Socket_Pair_Family : constant := SOSC.AF_UNIX;\n+   --  UNIX has socketpair system call and AF_UNIX family is widely supported\n+\n+   function C_Socketpair\n+     (Domain   : C.int;\n+      Typ      : C.int;\n+      Protocol : C.int;\n+      Fds      : not null access Fd_Pair) return C.int;\n+   --  Creates pair of connected sockets\n+\n    -------------------------------------------------------\n    -- Signalling file descriptors for selector abortion --\n    -------------------------------------------------------\n@@ -249,6 +259,7 @@ private\n    pragma Import (C, C_Select, \"select\");\n    pragma Import (C, C_Setsockopt, \"setsockopt\");\n    pragma Import (C, C_Shutdown, \"shutdown\");\n+   pragma Import (C, C_Socketpair, \"socketpair\");\n    pragma Import (C, C_System, \"system\");\n \n    pragma Import (C, Nonreentrant_Gethostbyname, \"gethostbyname\");"}, {"sha": "5ad292dfe925f4257b8081e80c889bd766e2bac4", "filename": "gcc/ada/libgnat/g-socthi__mingw.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.adb?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -511,6 +511,16 @@ package body GNAT.Sockets.Thin is\n       return System.CRTL.ssize_t (Count);\n    end C_Sendmsg;\n \n+   ------------------\n+   -- C_Socketpair --\n+   ------------------\n+\n+   function C_Socketpair\n+     (Domain   : C.int;\n+      Typ      : C.int;\n+      Protocol : C.int;\n+      Fds      : not null access Fd_Pair) return C.int is separate;\n+\n    --------------\n    -- Finalize --\n    --------------"}, {"sha": "a5aa67e5a777eeae237fc1650a1c6f2d17dfaff8", "filename": "gcc/ada/libgnat/g-socthi__mingw.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socthi__mingw.ads?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -177,6 +177,17 @@ package GNAT.Sockets.Thin is\n       Typ      : C.int;\n       Protocol : C.int) return C.int;\n \n+   Default_Socket_Pair_Family : constant := SOSC.AF_INET;\n+   --  Windows has not socketpair system call, and C_Socketpair below is\n+   --  implemented on loopback connected network sockets.\n+\n+   function C_Socketpair\n+     (Domain   : C.int;\n+      Typ      : C.int;\n+      Protocol : C.int;\n+      Fds      : not null access Fd_Pair) return C.int;\n+   --  Creates pair of connected sockets\n+\n    function C_System\n      (Command : System.Address) return C.int;\n "}, {"sha": "a2bbed631ff80476dcc85e1e6c6c77432672433f", "filename": "gcc/ada/libgnat/g-socthi__vxworks.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socthi__vxworks.adb?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -419,6 +419,16 @@ package body GNAT.Sockets.Thin is\n       return R;\n    end C_Socket;\n \n+   ------------------\n+   -- C_Socketpair --\n+   ------------------\n+\n+   function C_Socketpair\n+     (Domain   : C.int;\n+      Typ      : C.int;\n+      Protocol : C.int;\n+      Fds      : not null access Fd_Pair) return C.int is separate;\n+\n    --------------\n    -- Finalize --\n    --------------"}, {"sha": "664218dd559b7b60e2deb0cb0b652c58e491f248", "filename": "gcc/ada/libgnat/g-socthi__vxworks.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-socthi__vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socthi__vxworks.ads?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -178,6 +178,17 @@ package GNAT.Sockets.Thin is\n       Typ      : C.int;\n       Protocol : C.int) return C.int;\n \n+   Default_Socket_Pair_Family : constant := SOSC.AF_INET;\n+   --  VxWorks has not socketpair system call, and C_Socketpair below is\n+   --  implemented on loopback connected network sockets.\n+\n+   function C_Socketpair\n+     (Domain   : C.int;\n+      Typ      : C.int;\n+      Protocol : C.int;\n+      Fds      : not null access Fd_Pair) return C.int;\n+   --  Creates pair of connected sockets\n+\n    function C_System\n      (Command : System.Address) return C.int;\n "}, {"sha": "49c55f21a8a8664327228392d14d17e52a295aec", "filename": "gcc/ada/libgnat/g-sthcso.adb", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-sthcso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-sthcso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sthcso.adb?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -0,0 +1,213 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--     G N A T . S O C K E T S . T H I N . C _ S O C K E T P A I R          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2001-2019, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Portable sockets-based implementation of the C_Socketpair used for\n+--  platforms that do not support UNIX socketpair system call.\n+\n+--  Note: this code is only for non-UNIX platforms.\n+\n+separate (GNAT.Sockets.Thin)\n+function C_Socketpair\n+  (Domain   : C.int;\n+   Typ      : C.int;\n+   Protocol : C.int;\n+   Fds      : not null access Fd_Pair) return C.int\n+is\n+   use type C.char_array;\n+\n+   L_Sock, C_Sock, P_Sock : C.int := Failure;\n+   --  Listening socket, client socket and peer socket\n+\n+   Family : constant Family_Type :=\n+              (case Domain is\n+                  when SOSC.AF_INET  => Family_Inet,\n+                  when SOSC.AF_INET6 => Family_Inet6,\n+                  when others        => Family_Unspec);\n+\n+   Len   : aliased C.int := C.int (Lengths (Family));\n+\n+   C_Sin : aliased Sockaddr;\n+   C_Bin : aliased C.char_array (1 .. C.size_t (Len));\n+   for C_Bin'Address use C_Sin'Address;\n+   --  Address of listening and client socket and it's binary representation.\n+   --  We need binary representation because Ada does not allow to compare\n+   --  unchecked union if either of the operands lacks inferable discriminants.\n+   --  RM-B-3-3 23/2.\n+\n+   P_Sin : aliased Sockaddr;\n+   P_Bin : aliased C.char_array (1 .. C.size_t (Len));\n+   for P_Bin'Address use P_Sin'Address;\n+   --  Address of peer socket and it's binary representation\n+\n+   T_Sin : aliased Sockaddr;\n+   T_Bin : aliased C.char_array (1 .. C.size_t (Len));\n+   for T_Bin'Address use T_Sin'Address;\n+   --  Temporary address to compare and check that address and port of the\n+   --  socket equal to peer address and port of the opposite connected socket.\n+\n+   Res : C.int with Warnings => Off;\n+\n+begin\n+   Set_Family (C_Sin.Sin_Family, Family);\n+\n+   case Family is\n+      when Family_Inet =>\n+         C_Sin.Sin_Addr.S_B1 := 127;\n+         C_Sin.Sin_Addr.S_B4 := 1;\n+\n+      when Family_Inet6 =>\n+         C_Sin.Sin6_Addr (C_Sin.Sin6_Addr'Last) := 1;\n+\n+      when others =>\n+         Set_Socket_Errno (SOSC.EAFNOSUPPORT);\n+         return Failure;\n+   end case;\n+\n+   for J in 1 .. 10 loop\n+      --  Retry loop, in case the C_Connect below fails\n+\n+      C_Sin.Sin_Port := 0;\n+\n+      --  Create a listening socket\n+\n+      L_Sock := C_Socket (Domain, Typ, Protocol);\n+      exit when L_Sock = Failure;\n+\n+      --  Bind the socket to an available port on localhost\n+\n+      Res := C_Bind (L_Sock, C_Sin'Address, Len);\n+      exit when Res = Failure;\n+\n+      --  Get assigned port\n+\n+      Res := C_Getsockname (L_Sock, C_Sin'Address, Len'Access);\n+      exit when Res = Failure;\n+\n+      --  Set socket to listen mode, with a backlog of 1 to guarantee that\n+      --  exactly one call to connect(2) succeeds.\n+\n+      Res := C_Listen (L_Sock, 1);\n+      exit when Res = Failure;\n+\n+      --  Create read end (client) socket\n+\n+      C_Sock := C_Socket (Domain, Typ, Protocol);\n+      exit when C_Sock = Failure;\n+\n+      --  Connect listening socket\n+\n+      Res := C_Connect (C_Sock, C_Sin'Address, Len);\n+\n+      if Res = Failure then\n+         --  In rare cases, the above C_Bind chooses a port that is still\n+         --  marked \"in use\", even though it has been closed (perhaps by some\n+         --  other process that has already exited). This causes the above\n+         --  C_Connect to fail with EADDRINUSE. In this case, we close the\n+         --  ports, and loop back to try again. This mysterious Windows\n+         --  behavior is documented. See, for example:\n+         --    http://msdn2.microsoft.com/en-us/library/ms737625.aspx\n+         --  In an experiment with 2000 calls, 21 required exactly one retry, 7\n+         --  required two, and none required three or more. Note that no delay\n+         --  is needed between retries; retrying C_Bind will typically produce\n+         --  a different port.\n+\n+         exit when Socket_Errno /= SOSC.EADDRINUSE;\n+\n+         goto Repeat;\n+      end if;\n+\n+      --  Since the call to connect(2) has succeeded and the backlog limit\n+      --  on the listening socket is 1, we know that there is now exactly\n+      --  one pending connection on L_Sock, which is the one from R_Sock.\n+\n+      P_Sin.Sun_Path := (others => C.nul);\n+\n+      P_Sock := C_Accept (L_Sock, P_Sin'Address, Len'Access);\n+      exit when P_Sock = Failure;\n+\n+      --  Address and port of the socket equal to peer address and port of the\n+      --  opposite connected socket.\n+\n+      Res := C_Getsockname (P_Sock, T_Sin'Address, Len'Access);\n+      exit when Res = Failure;\n+\n+      if T_Bin /= C_Bin then\n+         goto Repeat;\n+      end if;\n+\n+      --  Address and port of the socket equal to peer address and port of the\n+      --  opposite connected socket.\n+\n+      Res := C_Getsockname (C_Sock, T_Sin'Address, Len'Access);\n+      exit when Res = Failure;\n+\n+      if T_Bin /= P_Bin then\n+         goto Repeat;\n+      end if;\n+\n+      --  Close listening socket (ignore exit status)\n+\n+      Res := C_Close (L_Sock);\n+\n+      Fds.all := (Read_End => C_Sock, Write_End => P_Sock);\n+\n+      return Thin_Common.Success;\n+\n+      <<Repeat>>\n+      Res := C_Close (C_Sock);\n+      C_Sock := Failure;\n+      Res := C_Close (P_Sock);\n+      P_Sock := Failure;\n+      Res := C_Close (L_Sock);\n+      L_Sock := Failure;\n+   end loop;\n+\n+   declare\n+      Saved_Errno : constant Integer := Socket_Errno;\n+\n+   begin\n+      if P_Sock /= Failure then\n+         Res := C_Close (P_Sock);\n+      end if;\n+\n+      if C_Sock /= Failure then\n+         Res := C_Close (C_Sock);\n+      end if;\n+\n+      if L_Sock /= Failure then\n+         Res := C_Close (L_Sock);\n+      end if;\n+\n+      Set_Socket_Errno (Saved_Errno);\n+   end;\n+\n+   return Failure;\n+end C_Socketpair;"}, {"sha": "90c98b710857c0dd4155b8440079b069ca86e2c1", "filename": "gcc/ada/libgnat/g-stsifd__sockets.adb", "status": "modified", "additions": 11, "deletions": 145, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-stsifd__sockets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd0d7b4e3be10508119636f06807f23d5691088b/gcc%2Fada%2Flibgnat%2Fg-stsifd__sockets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-stsifd__sockets.adb?ref=fd0d7b4e3be10508119636f06807f23d5691088b", "patch": "@@ -57,154 +57,20 @@ package body Signalling_Fds is\n    ------------\n \n    function Create (Fds : not null access Fd_Pair) return C.int is\n-      L_Sock, R_Sock, W_Sock : C.int := Failure;\n-      --  Listening socket, read socket and write socket\n-\n-      Sin : aliased Sockaddr;\n-      Len : aliased C.int;\n-      --  Address of listening socket\n-\n-      Res : C.int;\n-      pragma Warnings (Off, Res);\n-      --  Return status of system calls (usually ignored, hence warnings off)\n-\n+      Res : constant C.int :=\n+              C_Socketpair (SOSC.AF_INET, SOSC.SOCK_STREAM, 0, Fds);\n    begin\n-      Fds.all := (Read_End | Write_End => Failure);\n-\n-      --  We open two signalling sockets. One of them is used to send data\n-      --  to the other, which is included in a C_Select socket set. The\n-      --  communication is used to force the call to C_Select to complete,\n-      --  and the waiting task to resume its execution.\n-\n-      loop\n-         --  Retry loop, in case the C_Connect below fails\n-\n-         --  Create a listening socket\n-\n-         L_Sock := C_Socket (SOSC.AF_INET, SOSC.SOCK_STREAM, 0);\n-\n-         if L_Sock = Failure then\n-            goto Fail;\n-         end if;\n-\n-         --  Bind the socket to an available port on localhost\n-\n-         Set_Family (Sin.Sin_Family, Family_Inet);\n-         Sin.Sin_Addr.S_B1 := 127;\n-         Sin.Sin_Addr.S_B2 := 0;\n-         Sin.Sin_Addr.S_B3 := 0;\n-         Sin.Sin_Addr.S_B4 := 1;\n-         Sin.Sin_Port      := 0;\n-\n-         Len := C.int (Lengths (Family_Inet));\n-         Res := C_Bind (L_Sock, Sin'Address, Len);\n-\n-         if Res = Failure then\n-            goto Fail;\n-         end if;\n-\n-         --  Get assigned port\n-\n-         Res := C_Getsockname (L_Sock, Sin'Address, Len'Access);\n-         if Res = Failure then\n-            goto Fail;\n-         end if;\n-\n-         --  Set socket to listen mode, with a backlog of 1 to guarantee that\n-         --  exactly one call to connect(2) succeeds.\n-\n-         Res := C_Listen (L_Sock, 1);\n-\n-         if Res = Failure then\n-            goto Fail;\n-         end if;\n-\n-         --  Create read end (client) socket\n-\n-         R_Sock := C_Socket (SOSC.AF_INET, SOSC.SOCK_STREAM, 0);\n-\n-         if R_Sock = Failure then\n-            goto Fail;\n-         end if;\n-\n-         --  Connect listening socket\n-\n-         Res := C_Connect (R_Sock, Sin'Address, Len);\n-\n-         exit when Res /= Failure;\n-\n-         if Socket_Errno /= SOSC.EADDRINUSE then\n-            goto Fail;\n-         end if;\n-\n-         --  In rare cases, the above C_Bind chooses a port that is still\n-         --  marked \"in use\", even though it has been closed (perhaps by some\n-         --  other process that has already exited). This causes the above\n-         --  C_Connect to fail with EADDRINUSE. In this case, we close the\n-         --  ports, and loop back to try again. This mysterious Windows\n-         --  behavior is documented. See, for example:\n-         --    http://msdn2.microsoft.com/en-us/library/ms737625.aspx\n-         --  In an experiment with 2000 calls, 21 required exactly one retry, 7\n-         --  required two, and none required three or more. Note that no delay\n-         --  is needed between retries; retrying C_Bind will typically produce\n-         --  a different port.\n-\n-         pragma Assert (Res = Failure\n-                          and then\n-                        Socket_Errno = SOSC.EADDRINUSE);\n-         Res := C_Close (W_Sock);\n-         W_Sock := Failure;\n-         Res := C_Close (R_Sock);\n-         R_Sock := Failure;\n-      end loop;\n-\n-      --  Since the call to connect(2) has succeeded and the backlog limit on\n-      --  the listening socket is 1, we know that there is now exactly one\n-      --  pending connection on L_Sock, which is the one from R_Sock.\n-\n-      W_Sock := C_Accept (L_Sock, Sin'Address, Len'Access);\n-\n-      if W_Sock = Failure then\n-         goto Fail;\n+      if Res /= Failure then\n+         --  Set TCP_NODELAY on Fds (Write_End), since we always want to send\n+         --  the data out immediately.\n+\n+         Set_Socket_Option\n+           (Socket => Socket_Type (Fds (Write_End)),\n+            Level  => IP_Protocol_For_TCP_Level,\n+            Option => (Name => No_Delay, Enabled => True));\n       end if;\n \n-      --  Set TCP_NODELAY on W_Sock, since we always want to send the data out\n-      --  immediately.\n-\n-      Set_Socket_Option\n-        (Socket => Socket_Type (W_Sock),\n-         Level  => IP_Protocol_For_TCP_Level,\n-         Option => (Name => No_Delay, Enabled => True));\n-\n-      --  Close listening socket (ignore exit status)\n-\n-      Res := C_Close (L_Sock);\n-\n-      Fds.all := (Read_End => R_Sock, Write_End => W_Sock);\n-\n-      return Thin_Common.Success;\n-\n-   <<Fail>>\n-      declare\n-         Saved_Errno : constant Integer := Socket_Errno;\n-\n-      begin\n-         if W_Sock /= Failure then\n-            Res := C_Close (W_Sock);\n-         end if;\n-\n-         if R_Sock /= Failure then\n-            Res := C_Close (R_Sock);\n-         end if;\n-\n-         if L_Sock /= Failure then\n-            Res := C_Close (L_Sock);\n-         end if;\n-\n-         Set_Socket_Errno (Saved_Errno);\n-      end;\n-\n-      return Failure;\n+      return Res;\n    end Create;\n \n    ----------"}]}