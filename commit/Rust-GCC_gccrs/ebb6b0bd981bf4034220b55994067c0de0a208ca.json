{"sha": "ebb6b0bd981bf4034220b55994067c0de0a208ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiNmIwYmQ5ODFiZjQwMzQyMjBiNTU5OTQwNjdjMGRlMGEyMDhjYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T15:09:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T15:09:40Z"}, "message": "[multiple changes]\n\n2014-02-24  Yannick Moy  <moy@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Do not issue warning\n\tfor pre/post being ignored on imported subprogram in GNATprove\n\tmode.\n\n2014-02-24  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch5.adb, sem_ch5.adb, sem_type.adb, sem_res.adb, sem_attr.adb,\n\tstand.ads, sem_eval.adb: Minor reformatting.\n\n2014-02-24  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb: Minor rewording in error message.\n\n2014-02-24  Johannes Kanig  <kanig@adacore.com>\n\n\t* exp_util.adb (Expand_Subtype_From_Expr): Do not expand subtypes in\n\tGNATprove_mode, gnat2why doesn't need nor use these types.\n\n2014-02-24  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Op_Expon): On the AAMP\n\ttarget, in the case of signed integer exponentiation that uses a\n\trun-time routine, always select the Exp_* versions, since overflow\n\tchecking is automatically done by AAMP arithmetic instructions.\n\n2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n\tWhen the related context is a package instace, insert pragma\n\tAbstract_State after all internally-generated renamings related\n\tto the instance \"header\".\n\n2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Declarations): Analyze Contract of abstract\n\tsubprograms.\n\t* sem_disp.adb (Check_Dispatching_Context): A non-dispatching\n\tcall to an abstract subprogram is legal if it appears in a\n\tpre/postcondition of another abstract operation.\n\nFrom-SVN: r208070", "tree": {"sha": "d45dd7dade3c3d765f7a03a223fc0c16d070f786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d45dd7dade3c3d765f7a03a223fc0c16d070f786"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb6b0bd981bf4034220b55994067c0de0a208ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb6b0bd981bf4034220b55994067c0de0a208ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb6b0bd981bf4034220b55994067c0de0a208ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb6b0bd981bf4034220b55994067c0de0a208ca/comments", "author": null, "committer": null, "parents": [{"sha": "341c653c704e398070219534cd9fed97e56661b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341c653c704e398070219534cd9fed97e56661b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341c653c704e398070219534cd9fed97e56661b3"}], "stats": {"total": 289, "additions": 203, "deletions": 86}, "files": [{"sha": "76cae9f02f42fe372af47677317af9f9494c6cab", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -1,3 +1,45 @@\n+2014-02-24  Yannick Moy  <moy@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Do not issue warning\n+\tfor pre/post being ignored on imported subprogram in GNATprove\n+\tmode.\n+\n+2014-02-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch5.adb, sem_ch5.adb, sem_type.adb, sem_res.adb, sem_attr.adb,\n+\tstand.ads, sem_eval.adb: Minor reformatting.\n+\n+2014-02-24  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb: Minor rewording in error message.\n+\n+2014-02-24  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* exp_util.adb (Expand_Subtype_From_Expr): Do not expand subtypes in\n+\tGNATprove_mode, gnat2why doesn't need nor use these types.\n+\n+2014-02-24  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Expon): On the AAMP\n+\ttarget, in the case of signed integer exponentiation that uses a\n+\trun-time routine, always select the Exp_* versions, since overflow\n+\tchecking is automatically done by AAMP arithmetic instructions.\n+\n+2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n+\tWhen the related context is a package instace, insert pragma\n+\tAbstract_State after all internally-generated renamings related\n+\tto the instance \"header\".\n+\n+2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Declarations): Analyze Contract of abstract\n+\tsubprograms.\n+\t* sem_disp.adb (Check_Dispatching_Context): A non-dispatching\n+\tcall to an abstract subprogram is legal if it appears in a\n+\tpre/postcondition of another abstract operation.\n+\n 2014-02-24  Sergey Rybin  <rybin@adacore.com frybin>\n \n \t* gnat_ugn.texi: Misc updates."}, {"sha": "b11506ff9a6418d70de285dd714e015741dbfb2d", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -7611,7 +7611,11 @@ package body Exp_Ch4 is\n       then\n          Etyp := Standard_Long_Long_Integer;\n \n-         if Ovflo then\n+         --  Overflow checking is the only choice on the AAMP target, where\n+         --  arithmetic instructions check overflow automatically, so only\n+         --  one version of the exponentiation unit is needed.\n+\n+         if Ovflo or else AAMP_On_Target then\n             Rent := RE_Exp_Long_Long_Integer;\n          else\n             Rent := RE_Exn_Long_Long_Integer;\n@@ -7620,7 +7624,11 @@ package body Exp_Ch4 is\n       elsif Is_Signed_Integer_Type (Rtyp) then\n          Etyp := Standard_Integer;\n \n-         if Ovflo then\n+         --  Overflow checking is the only choice on the AAMP target, where\n+         --  arithmetic instructions check overflow automatically, so only\n+         --  one version of the exponentiation unit is needed.\n+\n+         if Ovflo or else AAMP_On_Target then\n             Rent := RE_Exp_Integer;\n          else\n             Rent := RE_Exn_Integer;"}, {"sha": "5398cd2c437b31a220f856ca6d89491fdb4c06e7", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -153,39 +153,38 @@ package body Exp_Ch5 is\n    is\n       Loc      : constant Source_Ptr := Sloc (N);\n       Stats    : constant List_Id    := Statements (N);\n-\n-      Typ      : constant Entity_Id := Base_Type (Etype (Container));\n-      First_Op : constant Entity_Id :=\n+      Typ      : constant Entity_Id  := Base_Type (Etype (Container));\n+      First_Op : constant Entity_Id  :=\n                    Get_Iterable_Type_Primitive (Typ, Name_First);\n-      Next_Op  : constant Entity_Id :=\n+      Next_Op  : constant Entity_Id  :=\n                    Get_Iterable_Type_Primitive (Typ, Name_Next);\n+\n       Has_Element_Op : constant Entity_Id :=\n                    Get_Iterable_Type_Primitive (Typ, Name_Has_Element);\n    begin\n       --  Declaration for Cursor\n \n       Init :=\n-         Make_Object_Declaration (Loc,\n-           Defining_Identifier => Cursor,\n-           Object_Definition => New_Occurrence_Of (Etype (First_Op),  Loc),\n-             Expression =>\n-               Make_Function_Call (Loc,\n-                 Name => New_Occurrence_Of (First_Op, Loc),\n-                   Parameter_Associations =>\n-                     New_List (New_Occurrence_Of (Container, Loc))));\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Cursor,\n+          Object_Definition   => New_Occurrence_Of (Etype (First_Op),  Loc),\n+          Expression          =>\n+            Make_Function_Call (Loc,\n+              Name                   => New_Occurrence_Of (First_Op, Loc),\n+              Parameter_Associations => New_List (\n+                New_Occurrence_Of (Container, Loc))));\n \n       --  Statement that advances cursor in loop\n \n       Advance :=\n         Make_Assignment_Statement (Loc,\n-          Name => New_Occurrence_Of (Cursor, Loc),\n+          Name       => New_Occurrence_Of (Cursor, Loc),\n           Expression =>\n             Make_Function_Call (Loc,\n-              Name => New_Occurrence_Of (Next_Op, Loc),\n-                Parameter_Associations =>\n-                  New_List\n-                    (New_Occurrence_Of (Container, Loc),\n-                     New_Occurrence_Of (Cursor, Loc))));\n+              Name                   => New_Occurrence_Of (Next_Op, Loc),\n+              Parameter_Associations => New_List (\n+                New_Occurrence_Of (Container, Loc),\n+                New_Occurrence_Of (Cursor, Loc))));\n \n       --  Iterator is rewritten as a while_loop\n \n@@ -195,14 +194,12 @@ package body Exp_Ch5 is\n             Make_Iteration_Scheme (Loc,\n               Condition =>\n                 Make_Function_Call (Loc,\n-                  Name                   =>\n-                    New_Occurrence_Of (Has_Element_Op, Loc),\n-                  Parameter_Associations =>\n-                    New_List\n-                     (New_Occurrence_Of (Container, Loc),\n-                      New_Occurrence_Of (Cursor, Loc)))),\n-          Statements => Stats,\n-          End_Label  => Empty);\n+                  Name => New_Occurrence_Of (Has_Element_Op, Loc),\n+                  Parameter_Associations => New_List (\n+                    New_Occurrence_Of (Container, Loc),\n+                    New_Occurrence_Of (Cursor, Loc)))),\n+          Statements       => Stats,\n+          End_Label        => Empty);\n    end Build_Formal_Container_Iteration;\n \n    ------------------------------\n@@ -2748,9 +2745,9 @@ package body Exp_Ch5 is\n       Container : constant Node_Id    := Entity (Name (I_Spec));\n       Stats     : constant List_Id    := Statements (N);\n \n-      Advance   : Node_Id;\n-      Init      : Node_Id;\n-      New_Loop  : Node_Id;\n+      Advance  : Node_Id;\n+      Init     : Node_Id;\n+      New_Loop : Node_Id;\n \n    begin\n       --  The expansion resembles the one for Ada containers, but the\n@@ -2790,13 +2787,12 @@ package body Exp_Ch5 is\n \n       Cursor    : constant Entity_Id :=\n                     Make_Defining_Identifier (Loc,\n-                     Chars => New_External_Name (Chars (Element), 'C'));\n+                      Chars => New_External_Name (Chars (Element), 'C'));\n       Elmt_Decl : Node_Id;\n       Elmt_Ref  : Node_Id;\n \n-      Element_Op     : constant Entity_Id :=\n-                         Get_Iterable_Type_Primitive\n-                           (Container_Typ, Name_Element);\n+      Element_Op : constant Entity_Id :=\n+                     Get_Iterable_Type_Primitive (Container_Typ, Name_Element);\n \n       Advance   : Node_Id;\n       Init      : Node_Id;\n@@ -2822,37 +2818,38 @@ package body Exp_Ch5 is\n \n       --  Declaration for Element.\n \n-      Elmt_Decl := Make_Object_Declaration (Loc,\n-        Defining_Identifier => Element,\n-        Object_Definition   => New_Occurrence_Of (Etype (Element_Op), Loc));\n+      Elmt_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Element,\n+          Object_Definition   => New_Occurrence_Of (Etype (Element_Op), Loc));\n \n       --  The element is only modified in expanded code, so it appears as\n       --  unassigned to the warning machinery. We must suppress this spurious\n       --  warning explicitly.\n \n       Set_Warnings_Off (Element);\n \n-      Elmt_Ref := Make_Assignment_Statement (Loc,\n-         Name       => New_Occurrence_Of (Element, Loc),\n-         Expression =>\n-           Make_Function_Call (Loc,\n-             Name => New_Occurrence_Of (Element_Op, Loc),\n-                 Parameter_Associations =>\n-                   New_List\n-                    (New_Occurrence_Of (Container, Loc),\n-                     New_Occurrence_Of (Cursor, Loc))));\n+      Elmt_Ref :=\n+        Make_Assignment_Statement (Loc,\n+          Name       => New_Occurrence_Of (Element, Loc),\n+          Expression =>\n+            Make_Function_Call (Loc,\n+              Name                   => New_Occurrence_Of (Element_Op, Loc),\n+              Parameter_Associations => New_List (\n+                New_Occurrence_Of (Container, Loc),\n+                New_Occurrence_Of (Cursor, Loc))));\n \n       Prepend (Elmt_Ref, Stats);\n       Append_To (Stats, Advance);\n \n-      --  The loop is rewritten as a block, to hold the declaration for the\n-      --  element.\n+      --  The loop is rewritten as a block, to hold the element declaration\n \n-      New_Loop := Make_Block_Statement (Loc,\n-         Declarations               => New_List (Elmt_Decl),\n-         Handled_Statement_Sequence =>\n-           Make_Handled_Sequence_Of_Statements (Loc,\n-             Statements =>  New_List (New_Loop)));\n+      New_Loop :=\n+        Make_Block_Statement (Loc,\n+          Declarations               => New_List (Elmt_Decl),\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements =>  New_List (New_Loop)));\n \n       Rewrite (N, New_Loop);\n       Analyze (New_Loop);\n@@ -3180,6 +3177,7 @@ package body Exp_Ch5 is\n          else\n             Expand_Formal_Container_Loop (N);\n          end if;\n+\n          return;\n       end if;\n "}, {"sha": "1ce77c6cd71d48c6c515624717e24929af7fc867", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -2074,19 +2074,15 @@ package body Exp_Util is\n       --  may be constants that depend on the bounds of a string literal, both\n       --  standard string types and more generally arrays of characters.\n \n-      --  In GNATprove mode, we also need the more precise subtype to be set\n+      --  In GNATprove mode, these extra subtypes are not needed\n \n-      if not (Expander_Active or GNATprove_Mode)\n-        and then (No (Etype (Exp)) or else not Is_String_Type (Etype (Exp)))\n-      then\n+      if GNATprove_Mode then\n          return;\n       end if;\n \n-      --  In GNATprove mode, Unc_Type might not be complete when analyzing\n-      --  a generic unit. As generic units are not analyzed directly in\n-      --  GNATprove, return here rather than failing later.\n-\n-      if GNATprove_Mode and then No (Underlying_Type (Unc_Type)) then\n+      if not Expander_Active\n+        and then (No (Etype (Exp)) or else not Is_String_Type (Etype (Exp)))\n+      then\n          return;\n       end if;\n "}, {"sha": "f4baae01bf557f16b0293583d5f96bc1c6025497", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -3868,16 +3868,20 @@ package body Freeze is\n                   end if;\n                end;\n \n-               --  Pre/post conditions are implemented through a subprogram in\n-               --  the corresponding body, and therefore are not checked on an\n-               --  imported subprogram for which the body is not available.\n+               --  Pre/post conditions are implemented through a subprogram\n+               --  in the corresponding body, and therefore are not checked on\n+               --  an imported subprogram for which the body is not available.\n+               --  This warning is not issued in GNATprove mode, as these\n+               --  contracts are handled in formal verification, so the\n+               --  warning would be misleading in that case.\n \n                --  Could consider generating a wrapper to take care of this???\n \n                if Is_Subprogram (E)\n                  and then Is_Imported (E)\n                  and then Present (Contract (E))\n                  and then Present (Pre_Post_Conditions (Contract (E)))\n+                 and then not GNATprove_Mode\n                then\n                   Error_Msg_NE\n                     (\"pre/post conditions on imported subprogram are not \""}, {"sha": "f45fe2acba805d7d2ae61e929064cd368d2b9ade", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -6319,7 +6319,7 @@ package body Sem_Attr is\n                      elsif Comp_Type /= Base_Type (Etype (Comp)) then\n                         Error_Msg_N\n                           (\"components in choice list must have same type\",\n-                             Assoc);\n+                           Assoc);\n                      end if;\n                   end if;\n                end if;"}, {"sha": "57abf9a4707d2e766788d86ccc585c8fe2fbcd26", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -2009,6 +2009,7 @@ package body Sem_Ch13 is\n \n                when Aspect_Abstract_State => Abstract_State : declare\n                   Context : Node_Id := N;\n+                  Decl    : Node_Id;\n                   Decls   : List_Id;\n \n                begin\n@@ -2023,21 +2024,63 @@ package body Sem_Ch13 is\n                   if Nkind_In (Context, N_Generic_Package_Declaration,\n                                         N_Package_Declaration)\n                   then\n-                     Decls := Visible_Declarations (Specification (Context));\n-\n                      Make_Aitem_Pragma\n                        (Pragma_Argument_Associations => New_List (\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Abstract_State);\n                      Decorate_Aspect_And_Pragma (Aspect, Aitem);\n \n-                     if No (Decls) then\n-                        Decls := New_List;\n-                        Set_Visible_Declarations (Context, Decls);\n-                     end if;\n+                     Decls := Visible_Declarations (Specification (Context));\n \n-                     Prepend_To (Decls, Aitem);\n+                     --  In general pragma Abstract_State must be at the top\n+                     --  of the existing visible declarations to emulate its\n+                     --  source counterpart. The only exception to this is a\n+                     --  generic instance in which case the pragma must be\n+                     --  inserted after the association renamings.\n+\n+                     if Present (Decls) then\n+\n+                        --  The visible declarations of a generic instance have\n+                        --  the following structure:\n+\n+                        --    <renamings of generic formals>\n+                        --    <renamings of internally-generated spec and body>\n+                        --    <first source declaration>\n+\n+                        --  The pragma must be inserted before the first source\n+                        --  declaration.\n+\n+                        if Is_Generic_Instance (Defining_Entity (Context)) then\n+\n+                           --  Skip the instance \"header\"\n+\n+                           Decl := First (Decls);\n+                           while Present (Decl)\n+                             and then not Comes_From_Source (Decl)\n+                           loop\n+                              Decl := Next (Decl);\n+                           end loop;\n+\n+                           if Present (Decl) then\n+                              Insert_Before (Decl, Aitem);\n+                           else\n+                              Append_To (Decls, Aitem);\n+                           end if;\n+\n+                        --  The related package is not a generic instance, the\n+                        --  corresponding pragma must be the first declaration.\n+\n+                        else\n+                           Prepend_To (Decls, Aitem);\n+                        end if;\n+\n+                     --  Otherwise the pragma forms a new declarative list\n+\n+                     else\n+                        Set_Visible_Declarations\n+                          (Specification (Context), New_List (Aitem));\n+                     end if;\n \n                   else\n                      Error_Msg_NE"}, {"sha": "2c7f7e07669bc5108aee811b83bc232ec2ccb3b4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -2381,7 +2381,10 @@ package body Sem_Ch3 is\n          elsif Nkind (Decl) = N_Subprogram_Body then\n             Analyze_Subprogram_Body_Contract (Defining_Entity (Decl));\n \n-         elsif Nkind (Decl) = N_Subprogram_Declaration then\n+         elsif Nkind_In (Decl,\n+           N_Subprogram_Declaration,\n+           N_Abstract_Subprogram_Declaration)\n+         then\n             Analyze_Subprogram_Contract (Defining_Entity (Decl));\n          end if;\n "}, {"sha": "031ec24e6e0498ff6d6a1bf3efe8c000930416e8", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -1856,10 +1856,12 @@ package body Sem_Ch5 is\n       else\n          Set_Ekind (Def_Id, E_Loop_Parameter);\n \n+         --  OF present\n+\n          if Of_Present (N) then\n             if Has_Aspect (Typ, Aspect_Iterable) then\n                if No (Get_Iterable_Type_Primitive (Typ, Name_Element)) then\n-                  Error_Msg_N (\"Missing Element primitive for iteration\", N);\n+                  Error_Msg_N (\"missing Element primitive for iteration\", N);\n                end if;\n \n             --  For a predefined container, The type of the loop variable is\n@@ -1868,23 +1870,25 @@ package body Sem_Ch5 is\n             else\n                declare\n                   Element : constant Entity_Id :=\n-                           Find_Value_Of_Aspect (Typ, Aspect_Iterator_Element);\n+                    Find_Value_Of_Aspect (Typ, Aspect_Iterator_Element);\n+\n                begin\n                   if No (Element) then\n                      Error_Msg_NE (\"cannot iterate over&\", N, Typ);\n                      return;\n+\n                   else\n                      Set_Etype (Def_Id, Entity (Element));\n \n                      --  If subtype indication was given, verify that it\n                      --  matches element type of container.\n \n                      if Present (Subt)\n-                        and then Bas /= Base_Type (Etype (Def_Id))\n+                       and then Bas /= Base_Type (Etype (Def_Id))\n                      then\n                         Error_Msg_N\n                           (\"subtype indication does not match element type\",\n-                             Subt);\n+                           Subt);\n                      end if;\n \n                      --  If the container has a variable indexing aspect, the\n@@ -1897,6 +1901,8 @@ package body Sem_Ch5 is\n                end;\n             end if;\n \n+         --  OF not present\n+\n          else\n             --  For an iteration of the form IN, the name must denote an\n             --  iterator, typically the result of a call to Iterate. Give a\n@@ -1936,7 +1942,8 @@ package body Sem_Ch5 is\n             if Has_Aspect (Typ, Aspect_Iterable) then\n                Set_Etype (Def_Id,\n                  Get_Cursor_Type\n-                  (Parent (Find_Value_Of_Aspect (Typ, Aspect_Iterable)), Typ));\n+                   (Parent (Find_Value_Of_Aspect (Typ, Aspect_Iterable)),\n+                    Typ));\n                Ent := Etype (Def_Id);\n \n             else\n@@ -1955,6 +1962,7 @@ package body Sem_Ch5 is\n \n       --  A loop parameter cannot be volatile. This check is peformed only when\n       --  SPARK_Mode is on as it is not a standard Ada legality check.\n+\n       --  Not clear whether this applies to element iterators, where the\n       --  cursor is not an explicit entity ???\n "}, {"sha": "b7647829c95fcb78562b9e3a0e916fb5816245e7", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -544,11 +544,17 @@ package body Sem_Disp is\n             --  the current declarative part. The expression will be properly\n             --  rewritten/reanalyzed when the postcondition procedure is built.\n \n+            --  Similarly, if this is a pre/postcondition for an abstract\n+            --  subprogram, it may call another abstract function which is\n+            --  a primitive of an abstract type. The call is non-dispatching\n+            --  but will be legal in overridings of the operation.\n+\n             elsif In_Spec_Expression\n               and then Is_Subprogram (Current_Scope)\n               and then\n-                Nkind (Parent (Current_Scope)) = N_Procedure_Specification\n-              and then Null_Present (Parent (Current_Scope))\n+                ((Nkind (Parent (Current_Scope)) = N_Procedure_Specification\n+                   and then Null_Present (Parent (Current_Scope)))\n+                 or else Is_Abstract_Subprogram (Current_Scope))\n             then\n                null;\n "}, {"sha": "bd1398aee51a5099d07b7a5263d9edd1e5953176", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -4803,7 +4803,8 @@ package body Sem_Eval is\n          --  If either subtype is nonstatic then they're not compatible\n \n          elsif not Is_Static_Subtype (T1)\n-           or else not Is_Static_Subtype (T2)\n+                 or else\n+               not Is_Static_Subtype (T2)\n          then\n             return False;\n \n@@ -4899,7 +4900,8 @@ package body Sem_Eval is\n       --  (and Esizes can be set when Frontend_Layout_On_Target is True).\n \n       elsif not Formal_Derived_Matching\n-        and then Known_Static_Esize (T1) and then Known_Static_Esize (T2)\n+        and then Known_Static_Esize (T1)\n+        and then Known_Static_Esize (T2)\n         and then Esize (T1) /= Esize (T2)\n       then\n          return False;"}, {"sha": "28e917264ced56f5dba217a3ef04435ec13fc735", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -4631,7 +4631,8 @@ package body Sem_Prag is\n             procedure Grouping_Error (Prag : Node_Id) is\n             begin\n                Error_Msg_Sloc := Sloc (Prag);\n-               Error_Pragma (\"pragma% must appear immediately after pragma#\");\n+               Error_Pragma\n+                 (\"pragma% should appear immediately after pragma#\");\n             end Grouping_Error;\n \n          --  Start of processing for Check_Loop_Pragma_Grouping"}, {"sha": "93edfe2df22bb9ca76c5da5ee7ffc5bcc587bd5e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -7399,6 +7399,7 @@ package body Sem_Res is\n       --  A useful optimization:  check whether the dereference denotes an\n       --  element of a container, and if so rewrite it as a call to the\n       --  corresponding Element function.\n+\n       --  Disabled for now, on advice of ARG. A more restricted form of the\n       --  predicate might be acceptable ???\n "}, {"sha": "22d10e6f5516ae9d3c7db37c03f425b07890784f", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -1128,7 +1128,7 @@ package body Sem_Type is\n       elsif BT2 = Any_Type then\n          return True;\n \n-      --  A Raise_Expressions is legal in any expression context.\n+      --  A Raise_Expressions is legal in any expression context\n \n       elsif BT2 = Raise_Type then\n          return True;"}, {"sha": "325286e36c22ff04f091056880025d0058aecc16", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb6b0bd981bf4034220b55994067c0de0a208ca/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=ebb6b0bd981bf4034220b55994067c0de0a208ca", "patch": "@@ -423,6 +423,11 @@ package Stand is\n    --  The type Raise_Type denotes the type of a Raise_Expression. It is\n    --  compatible with all other types, and must eventually resolve to a\n    --  concrete type that is imposed by the context.\n+   --\n+   --  Historical note: we used to use Any_Type for this purpose, but the\n+   --  confusion of meanings (Any_Type normally indicates an error) caused\n+   --  difficulties. In particular some needed expansions were skipped since\n+   --  the nodes in question looked like they had an error.\n \n    Universal_Integer : Entity_Id;\n    --  Entity for universal integer type. The bounds of this type correspond"}]}