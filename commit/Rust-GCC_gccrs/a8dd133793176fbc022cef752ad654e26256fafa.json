{"sha": "a8dd133793176fbc022cef752ad654e26256fafa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThkZDEzMzc5MzE3NmZiYzAyMmNlZjc1MmFkNjU0ZTI2MjU2ZmFmYQ==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2016-11-15T22:10:37Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2016-11-15T22:10:37Z"}, "message": "genattrtab.c (attr_rtx_1): Avoid allocating new rtx objects.\n\n2016-11-15  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * genattrtab.c (attr_rtx_1): Avoid allocating new rtx objects.\n        Clear ATTR_CURR_SIMPLIFIED_P for re-used binary rtx objects.\n        Use DEF_ATTR_STRING for string arguments.  Use RTL_HASH for\n        integer arguments.  Only set ATTR_PERMANENT_P on newly hashed\n        rtx when all sub-rtx are also permanent.\n        (attr_eq): Simplify.\n        (attr_copy_rtx): Remove.\n        (make_canonical, get_attr_value): Use attr_equal_p.\n        (copy_boolean): Rehash NOT.\n        (simplify_test_exp_in_temp,\n        optimize_attrs): Remove call to attr_copy_rtx.\n        (attr_alt_intersection, attr_alt_union,\n        attr_alt_complement, mk_attr_alt): Rehash EQ_ATTR_ALT.\n        (make_automaton_attrs): Use attr_eq.\n\nFrom-SVN: r242460", "tree": {"sha": "745ce1201ab430be25f2b58578df4d2bb0417aef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/745ce1201ab430be25f2b58578df4d2bb0417aef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8dd133793176fbc022cef752ad654e26256fafa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8dd133793176fbc022cef752ad654e26256fafa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8dd133793176fbc022cef752ad654e26256fafa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8dd133793176fbc022cef752ad654e26256fafa/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "839984f40444f7ab73ab0d83c94d82577718b657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839984f40444f7ab73ab0d83c94d82577718b657", "html_url": "https://github.com/Rust-GCC/gccrs/commit/839984f40444f7ab73ab0d83c94d82577718b657"}], "stats": {"total": 204, "additions": 72, "deletions": 132}, "files": [{"sha": "f796e148a9c34d0c45e843738a4c4e311eabe736", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8dd133793176fbc022cef752ad654e26256fafa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8dd133793176fbc022cef752ad654e26256fafa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8dd133793176fbc022cef752ad654e26256fafa", "patch": "@@ -1,3 +1,20 @@\n+2016-11-15  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* genattrtab.c (attr_rtx_1): Avoid allocating new rtx objects.\n+\tClear ATTR_CURR_SIMPLIFIED_P for re-used binary rtx objects.\n+\tUse DEF_ATTR_STRING for string arguments.  Use RTL_HASH for\n+\tinteger arguments.  Only set ATTR_PERMANENT_P on newly hashed\n+\trtx when all sub-rtx are also permanent.\n+\t(attr_eq): Simplify.\n+\t(attr_copy_rtx): Remove.\n+\t(make_canonical, get_attr_value): Use attr_equal_p.\n+\t(copy_boolean): Rehash NOT.\n+\t(simplify_test_exp_in_temp,\n+\toptimize_attrs): Remove call to attr_copy_rtx.\n+\t(attr_alt_intersection, attr_alt_union,\n+\tattr_alt_complement, mk_attr_alt): Rehash EQ_ATTR_ALT.\n+\t(make_automaton_attrs): Use attr_eq.\n+\n 2016-11-15  Matthias Klose  <doko@ubuntu.com>\n \n \t* doc/install.texi: Remove references to java/libjava."}, {"sha": "d22407375076d3dce7beae70ff1964e737bf45d6", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 55, "deletions": 132, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8dd133793176fbc022cef752ad654e26256fafa/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8dd133793176fbc022cef752ad654e26256fafa/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=a8dd133793176fbc022cef752ad654e26256fafa", "patch": "@@ -386,6 +386,7 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n   unsigned int hashcode;\n   struct attr_hash *h;\n   struct obstack *old_obstack = rtl_obstack;\n+  int permanent_p = 1;\n \n   /* For each of several cases, search the hash table for an existing entry.\n      Use that entry if one is found; otherwise create a new RTL and add it\n@@ -395,13 +396,8 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n     {\n       rtx arg0 = va_arg (p, rtx);\n \n-      /* A permanent object cannot point to impermanent ones.  */\n       if (! ATTR_PERMANENT_P (arg0))\n-\t{\n-\t  rt_val = rtx_alloc (code);\n-\t  XEXP (rt_val, 0) = arg0;\n-\t  return rt_val;\n-\t}\n+\tpermanent_p = 0;\n \n       hashcode = ((HOST_WIDE_INT) code + RTL_HASH (arg0));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n@@ -425,22 +421,19 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n       rtx arg0 = va_arg (p, rtx);\n       rtx arg1 = va_arg (p, rtx);\n \n-      /* A permanent object cannot point to impermanent ones.  */\n       if (! ATTR_PERMANENT_P (arg0) || ! ATTR_PERMANENT_P (arg1))\n-\t{\n-\t  rt_val = rtx_alloc (code);\n-\t  XEXP (rt_val, 0) = arg0;\n-\t  XEXP (rt_val, 1) = arg1;\n-\t  return rt_val;\n-\t}\n+\tpermanent_p = 0;\n \n       hashcode = ((HOST_WIDE_INT) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n \t    && GET_CODE (h->u.rtl) == code\n \t    && XEXP (h->u.rtl, 0) == arg0\n \t    && XEXP (h->u.rtl, 1) == arg1)\n-\t  return h->u.rtl;\n+\t  {\n+\t    ATTR_CURR_SIMPLIFIED_P (h->u.rtl) = 0;\n+\t    return h->u.rtl;\n+\t  }\n \n       if (h == 0)\n \t{\n@@ -481,6 +474,9 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n       char *arg0 = va_arg (p, char *);\n       char *arg1 = va_arg (p, char *);\n \n+      arg0 = DEF_ATTR_STRING (arg0);\n+      arg1 = DEF_ATTR_STRING (arg1);\n+\n       hashcode = ((HOST_WIDE_INT) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n       for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n \tif (h->hashcode == hashcode\n@@ -497,6 +493,29 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n \t  XSTR (rt_val, 1) = arg1;\n \t}\n     }\n+  else if (GET_RTX_LENGTH (code) == 2\n+\t   && GET_RTX_FORMAT (code)[0] == 'i'\n+\t   && GET_RTX_FORMAT (code)[1] == 'i')\n+    {\n+      int  arg0 = va_arg (p, int);\n+      int  arg1 = va_arg (p, int);\n+\n+      hashcode = ((HOST_WIDE_INT) code + RTL_HASH (arg0) + RTL_HASH (arg1));\n+      for (h = attr_hash_table[hashcode % RTL_HASH_SIZE]; h; h = h->next)\n+\tif (h->hashcode == hashcode\n+\t    && GET_CODE (h->u.rtl) == code\n+\t    && XINT (h->u.rtl, 0) == arg0\n+\t    && XINT (h->u.rtl, 1) == arg1)\n+\t  return h->u.rtl;\n+\n+      if (h == 0)\n+\t{\n+\t  rtl_obstack = hash_obstack;\n+\t  rt_val = rtx_alloc (code);\n+\t  XINT (rt_val, 0) = arg0;\n+\t  XINT (rt_val, 1) = arg1;\n+\t}\n+    }\n   else if (code == CONST_INT)\n     {\n       HOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n@@ -552,7 +571,7 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n \n   rtl_obstack = old_obstack;\n   attr_hash_add_rtx (hashcode, rt_val);\n-  ATTR_PERMANENT_P (rt_val) = 1;\n+  ATTR_PERMANENT_P (rt_val) = permanent_p;\n   return rt_val;\n }\n \n@@ -592,7 +611,7 @@ attr_printf (unsigned int len, const char *fmt, ...)\n static rtx\n attr_eq (const char *name, const char *value)\n {\n-  return attr_rtx (EQ_ATTR, DEF_ATTR_STRING (name), DEF_ATTR_STRING (value));\n+  return attr_rtx (EQ_ATTR, name, value);\n }\n \n static const char *\n@@ -646,89 +665,6 @@ attr_equal_p (rtx x, rtx y)\n \t\t     && rtx_equal_p (x, y)));\n }\n \n-/* Copy an attribute value expression,\n-   descending to all depths, but not copying any\n-   permanent hashed subexpressions.  */\n-\n-static rtx\n-attr_copy_rtx (rtx orig)\n-{\n-  rtx copy;\n-  int i, j;\n-  RTX_CODE code;\n-  const char *format_ptr;\n-\n-  /* No need to copy a permanent object.  */\n-  if (ATTR_PERMANENT_P (orig))\n-    return orig;\n-\n-  code = GET_CODE (orig);\n-\n-  switch (code)\n-    {\n-    case REG:\n-    CASE_CONST_ANY:\n-    case SYMBOL_REF:\n-    case MATCH_TEST:\n-    case CODE_LABEL:\n-    case PC:\n-    case CC0:\n-      return orig;\n-\n-    default:\n-      break;\n-    }\n-\n-  copy = rtx_alloc (code);\n-  PUT_MODE (copy, GET_MODE (orig));\n-  ATTR_IND_SIMPLIFIED_P (copy) = ATTR_IND_SIMPLIFIED_P (orig);\n-  ATTR_CURR_SIMPLIFIED_P (copy) = ATTR_CURR_SIMPLIFIED_P (orig);\n-  ATTR_PERMANENT_P (copy) = ATTR_PERMANENT_P (orig);\n-\n-  format_ptr = GET_RTX_FORMAT (GET_CODE (copy));\n-\n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (copy)); i++)\n-    {\n-      switch (*format_ptr++)\n-\t{\n-\tcase 'e':\n-\t  XEXP (copy, i) = XEXP (orig, i);\n-\t  if (XEXP (orig, i) != NULL)\n-\t    XEXP (copy, i) = attr_copy_rtx (XEXP (orig, i));\n-\t  break;\n-\n-\tcase 'E':\n-\tcase 'V':\n-\t  XVEC (copy, i) = XVEC (orig, i);\n-\t  if (XVEC (orig, i) != NULL)\n-\t    {\n-\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n-\t      for (j = 0; j < XVECLEN (copy, i); j++)\n-\t\tXVECEXP (copy, i, j) = attr_copy_rtx (XVECEXP (orig, i, j));\n-\t    }\n-\t  break;\n-\n-\tcase 'n':\n-\tcase 'i':\n-\t  XINT (copy, i) = XINT (orig, i);\n-\t  break;\n-\n-\tcase 'w':\n-\t  XWINT (copy, i) = XWINT (orig, i);\n-\t  break;\n-\n-\tcase 's':\n-\tcase 'S':\n-\t  XSTR (copy, i) = XSTR (orig, i);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  return copy;\n-}\n-\n /* Given a test expression EXP for attribute ATTR, ensure it is validly\n    formed.  LOC is the location of the .md construct that contains EXP.\n \n@@ -1236,7 +1172,7 @@ make_canonical (file_location loc, struct attr_desc *attr, rtx exp)\n \t    XVECEXP (exp, 0, i) = copy_boolean (XVECEXP (exp, 0, i));\n \t    XVECEXP (exp, 0, i + 1)\n \t      = make_canonical (loc, attr, XVECEXP (exp, 0, i + 1));\n-\t    if (! rtx_equal_p (XVECEXP (exp, 0, i + 1), defval))\n+\t    if (! attr_equal_p (XVECEXP (exp, 0, i + 1), defval))\n \t      allsame = 0;\n \t  }\n \tif (allsame)\n@@ -1257,6 +1193,8 @@ copy_boolean (rtx exp)\n   if (GET_CODE (exp) == AND || GET_CODE (exp) == IOR)\n     return attr_rtx (GET_CODE (exp), copy_boolean (XEXP (exp, 0)),\n \t\t     copy_boolean (XEXP (exp, 1)));\n+  else if (GET_CODE (exp) == NOT)\n+    return attr_rtx (NOT, copy_boolean (XEXP (exp, 0)));\n   if (GET_CODE (exp) == MATCH_OPERAND)\n     {\n       XSTR (exp, 1) = DEF_ATTR_STRING (XSTR (exp, 1));\n@@ -1298,7 +1236,7 @@ get_attr_value (file_location loc, rtx value, struct attr_desc *attr,\n     }\n \n   for (av = attr->first_value; av; av = av->next)\n-    if (rtx_equal_p (value, av->value)\n+    if (attr_equal_p (value, av->value)\n \t&& (num_alt == 0 || av->first_insn == NULL\n \t    || insn_alternatives[av->first_insn->def->insn_code]))\n       return av;\n@@ -2339,9 +2277,7 @@ simplify_test_exp_in_temp (rtx exp, int insn_code, int insn_index)\n   rtl_obstack = temp_obstack;\n   x = simplify_test_exp (exp, insn_code, insn_index);\n   rtl_obstack = old;\n-  if (x == exp || rtl_obstack == temp_obstack)\n-    return x;\n-  return attr_copy_rtx (x);\n+  return x;\n }\n \n /* Returns true if S1 is a subset of S2.  */\n@@ -2397,70 +2333,63 @@ attr_alt_subset_of_compl_p (rtx s1, rtx s2)\n static rtx\n attr_alt_intersection (rtx s1, rtx s2)\n {\n-  rtx result = rtx_alloc (EQ_ATTR_ALT);\n+  int result;\n \n   switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n     {\n     case (0 << 1) | 0:\n-      XINT (result, 0) = XINT (s1, 0) & XINT (s2, 0);\n+      result = XINT (s1, 0) & XINT (s2, 0);\n       break;\n     case (0 << 1) | 1:\n-      XINT (result, 0) = XINT (s1, 0) & ~XINT (s2, 0);\n+      result = XINT (s1, 0) & ~XINT (s2, 0);\n       break;\n     case (1 << 1) | 0:\n-      XINT (result, 0) = XINT (s2, 0) & ~XINT (s1, 0);\n+      result = XINT (s2, 0) & ~XINT (s1, 0);\n       break;\n     case (1 << 1) | 1:\n-      XINT (result, 0) = XINT (s1, 0) | XINT (s2, 0);\n+      result = XINT (s1, 0) | XINT (s2, 0);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n-  XINT (result, 1) = XINT (s1, 1) & XINT (s2, 1);\n \n-  return result;\n+  return attr_rtx (EQ_ATTR_ALT, result, XINT (s1, 1) & XINT (s2, 1));\n }\n \n /* Return EQ_ATTR_ALT expression representing union of S1 and S2.  */\n \n static rtx\n attr_alt_union (rtx s1, rtx s2)\n {\n-  rtx result = rtx_alloc (EQ_ATTR_ALT);\n+  int result;\n \n   switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n     {\n     case (0 << 1) | 0:\n-      XINT (result, 0) = XINT (s1, 0) | XINT (s2, 0);\n+      result = XINT (s1, 0) | XINT (s2, 0);\n       break;\n     case (0 << 1) | 1:\n-      XINT (result, 0) = XINT (s2, 0) & ~XINT (s1, 0);\n+      result = XINT (s2, 0) & ~XINT (s1, 0);\n       break;\n     case (1 << 1) | 0:\n-      XINT (result, 0) = XINT (s1, 0) & ~XINT (s2, 0);\n+      result = XINT (s1, 0) & ~XINT (s2, 0);\n       break;\n     case (1 << 1) | 1:\n-      XINT (result, 0) = XINT (s1, 0) & XINT (s2, 0);\n+      result = XINT (s1, 0) & XINT (s2, 0);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  XINT (result, 1) = XINT (s1, 1) | XINT (s2, 1);\n-  return result;\n+  return attr_rtx (EQ_ATTR_ALT, result, XINT (s1, 1) | XINT (s2, 1));\n }\n \n /* Return EQ_ATTR_ALT expression representing complement of S.  */\n \n static rtx\n attr_alt_complement (rtx s)\n {\n-  rtx result = rtx_alloc (EQ_ATTR_ALT);\n-\n-  XINT (result, 0) = XINT (s, 0);\n-  XINT (result, 1) = 1 - XINT (s, 1);\n-\n-  return result;\n+  return attr_rtx (EQ_ATTR_ALT, XINT (s, 0), 1 - XINT (s, 1));\n }\n \n /* Return EQ_ATTR_ALT expression representing set containing elements set\n@@ -2469,12 +2398,7 @@ attr_alt_complement (rtx s)\n static rtx\n mk_attr_alt (uint64_t e)\n {\n-  rtx result = rtx_alloc (EQ_ATTR_ALT);\n-\n-  XINT (result, 0) = e;\n-  XINT (result, 1) = 0;\n-\n-  return result;\n+  return attr_rtx (EQ_ATTR_ALT, (int)e, 0);\n }\n \n /* Given an expression, see if it can be simplified for a particular insn\n@@ -3045,7 +2969,6 @@ optimize_attrs (int num_insn_codes)\n \t      && attr_rtx_cost (newexp) < 26\n \t     )\n \t    {\n-\t      newexp = attr_copy_rtx (newexp);\n \t      remove_insn_ent (av, ie);\n \t      av = get_attr_value (ie->def->loc, newexp, attr,\n \t\t\t\t   ie->def->insn_code);\n@@ -5004,7 +4927,7 @@ make_automaton_attrs (void)\n \t{\n \t  int j;\n \t  char *name;\n-\t  rtx test = attr_rtx (EQ_ATTR, tune_attr->name, XSTR (val->value, 0));\n+\t  rtx test = attr_eq (tune_attr->name, XSTR (val->value, 0));\n \n \t  if (val == tune_attr->default_val)\n \t    continue;"}]}