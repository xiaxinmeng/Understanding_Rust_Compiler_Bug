{"sha": "3250221d1afe8f51f3265a71c680688daed4041f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI1MDIyMWQxYWZlOGY1MWYzMjY1YTcxYzY4MDY4OGRhZWQ0MDQxZg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-08-17T19:25:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-08-17T19:25:11Z"}, "message": "Initial revision\n\nFrom-SVN: r32", "tree": {"sha": "2b04f33ab691293de3ceaea3b20c90b6d2887d00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b04f33ab691293de3ceaea3b20c90b6d2887d00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3250221d1afe8f51f3265a71c680688daed4041f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3250221d1afe8f51f3265a71c680688daed4041f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3250221d1afe8f51f3265a71c680688daed4041f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3250221d1afe8f51f3265a71c680688daed4041f/comments", "author": null, "committer": null, "parents": [{"sha": "e506707db06d4be0f30aaddbb27b47f7914aba06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e506707db06d4be0f30aaddbb27b47f7914aba06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e506707db06d4be0f30aaddbb27b47f7914aba06"}], "stats": {"total": 119, "additions": 119, "deletions": 0}, "files": [{"sha": "5c62fd854bbe8af6bb5ee129783c9abd59e41d08", "filename": "gcc/integrate.h", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3250221d1afe8f51f3265a71c680688daed4041f/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3250221d1afe8f51f3265a71c680688daed4041f/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=3250221d1afe8f51f3265a71c680688daed4041f", "patch": "@@ -0,0 +1,119 @@\n+/* Function integration definitions for GNU C-Compiler\n+   Copyright (C) 1990 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This structure is used to remap objects in the function being inlined to\n+   those belonging to the calling function.  It is passed by\n+   expand_inline_function to its children.\n+\n+   This structure is also used when unrolling loops and otherwise\n+   replicating code, although not all fields are needed in this case;\n+   only those fields needed by copy_rtx_and_substitute() and its children\n+   are used.\n+\n+   This structure is used instead of static variables because\n+   expand_inline_function may be called recursively via expand_expr.  */\n+\n+struct inline_remap\n+{\n+  /* Definition of function be inlined.  */\n+  union tree_node *fndecl;\n+  /* Place to put insns needed at start of function.  */\n+  rtx insns_at_start;\n+  /* Mapping from old registers to new registers.\n+     It is allocated and deallocated in `expand_inline_function' */\n+  rtx *reg_map;\n+  /* Mapping from old code-labels to new code-labels.\n+     The first element of this map is label_map[min_labelno].  */\n+  rtx *label_map;\n+  /* Mapping from old insn uid's to copied insns.  The first element\n+   of this map is insn_map[min_insnno]; the last element is\n+   insn_map[max_insnno].  We keep the bounds here for when the map\n+   only covers a partial range of insns (such as loop unrolling or\n+   code replication).  */\n+  rtx *insn_map;\n+  int min_insnno, max_insnno;\n+\n+  /* Map pseudo reg number in calling function to equivalent constant.  We\n+     cannot in general substitute constants into parameter pseudo registers,\n+     since some machine descriptions (many RISCs) won't always handle\n+     the resulting insns.  So if an incoming parameter has a constant\n+     equivalent, we record it here, and if the resulting insn is\n+     recognizable, we go with it.\n+\n+     We also use this mechanism to convert references to incoming arguments\n+     and stacked variables.  copy_rtx_and_substitute will replace the virtual\n+     incoming argument and virtual stacked variables registers with new\n+     pseudos that contain pointers into the replacement area allocated for\n+     this inline instance.  These pseudos are then marked as being equivalent\n+     to the appropriate address and substituted if valid.  */\n+  rtx *const_equiv_map;\n+  /* This is incremented for each new basic block.\n+     It is used to store in const_age_map to record the domain of validity\n+     of each entry in const_equiv_map.\n+     A value of -1 indicates an entry for a reg which is a parm.\n+     All other values are \"positive\".  */\n+#define CONST_AGE_PARM (-1)\n+  unsigned int const_age;\n+  /* In parallel with const_equiv_map, record the valid age for each entry.\n+     The entry is invalid if its age is less than const_age.  */\n+  unsigned int *const_age_map;\n+  /* Target of the inline function being expanded, or NULL if none.  */\n+  rtx inline_target;\n+  /* When an insn is being copied by copy_rtx_and_substitute,\n+     this is nonzero if we have copied an ASM_OPERANDS.\n+     In that case, it is the original input-operand vector.  */\n+  rtvec orig_asm_operands_vector;\n+  /* When an insn is being copied by copy_rtx_and_substitute,\n+     this is nonzero if we have copied an ASM_OPERANDS.\n+     In that case, it is the copied input-operand vector.  */\n+  rtvec copy_asm_operands_vector;\n+  /* Likewise, this is the copied constraints vector.  */\n+  rtvec copy_asm_constraints_vector;\n+\n+  /* The next few fields are used for subst_constants to record the SETs\n+     that it saw.  */\n+  int num_sets;\n+  struct equiv_table\n+    {\n+      rtx dest;\n+      rtx equiv;\n+    }  equiv_sets[MAX_RECOG_OPERANDS];\n+  /* Record the last thing assigned to pc.  This is used for folded \n+     conditional branch insns.  */\n+  rtx last_pc_value;\n+#ifdef HAVE_cc0\n+  /* Record the last thing assigned to cc0.  */\n+  rtx last_cc0_value;\n+#endif\n+};\n+\n+/* Return a copy of an rtx (as needed), substituting pseudo-register,\n+   labels, and frame-pointer offsets as necessary.  */\n+extern rtx copy_rtx_and_substitute ();\n+\n+extern void try_constants ();\n+\n+extern void mark_stores ();\n+\n+/* We do some simple constant folding optimization.  This optimization\n+   really exists primarily to save time inlining a function.  It\n+   also helps users who ask for inline functions without -O.  */\n+extern rtx try_fold_condition ();\n+\n+extern rtx *global_const_equiv_map;"}]}