{"sha": "bd87cc14ebdb6789e067fb1828d5808407c308b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4N2NjMTRlYmRiNjc4OWUwNjdmYjE4MjhkNTgwODQwN2MzMDhiMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-11T10:51:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-11T11:51:40Z"}, "message": "tree-optimization/97623 - Avoid PRE hoist insertion iteration\n\nThe recent previous change in this area limited hoist insertion\niteration via a param but the following is IMHO better since\nwe are not really interested in PRE opportunities exposed by\nhoisting but only the other way around.  So this moves hoist\ninsertion after PRE iteration finished and removes hoist\ninsertion iteration alltogether.\n\n2020-11-11  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97623\n\t* params.opt (-param=max-pre-hoist-insert-iterations): Remove\n\tagain.\n\t* doc/invoke.texi (max-pre-hoist-insert-iterations): Likewise.\n\t* tree-ssa-pre.c (insert): Move hoist insertion after PRE\n\tinsertion iteration and do not iterate it.\n\n\t* gcc.dg/tree-ssa/ssa-hoist-3.c: Adjust.\n\t* gcc.dg/tree-ssa/ssa-hoist-7.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-30.c: Likewise.", "tree": {"sha": "b8a9996427f6fef9253105e725212f444c7bb178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8a9996427f6fef9253105e725212f444c7bb178"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd87cc14ebdb6789e067fb1828d5808407c308b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd87cc14ebdb6789e067fb1828d5808407c308b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd87cc14ebdb6789e067fb1828d5808407c308b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd87cc14ebdb6789e067fb1828d5808407c308b3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46c705e70e078f6a1920d92e49042125d5e18495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c705e70e078f6a1920d92e49042125d5e18495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c705e70e078f6a1920d92e49042125d5e18495"}], "stats": {"total": 51, "additions": 26, "deletions": 25}, "files": [{"sha": "8d0d2136831a21f3283e371a4823affa2359cb29", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bd87cc14ebdb6789e067fb1828d5808407c308b3", "patch": "@@ -13446,11 +13446,6 @@ is aborted and the load or store is not considered redundant.  The\n number of queries is algorithmically limited to the number of\n stores on all paths from the load to the function entry.\n \n-@item max-pre-hoist-insert-iterations\n-The maximum number of iterations doing insertion during code\n-hoisting which is done as part of the partial redundancy elimination\n-insertion phase.\n-\n @item ira-max-loops-num\n IRA uses regional register allocation by default.  If a function\n contains more loops than the number given by this parameter, only at most"}, {"sha": "7bac39a9d588024f8df142478ad425a4a7c60677", "filename": "gcc/params.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=bd87cc14ebdb6789e067fb1828d5808407c308b3", "patch": "@@ -597,10 +597,6 @@ Maximum depth of sqrt chains to use when synthesizing exponentiation by a real c\n Common Joined UInteger Var(param_max_predicted_iterations) Init(100) IntegerRange(0, 65536) Param Optimization\n The maximum number of loop iterations we predict statically.\n \n--param=max-pre-hoist-insert-iterations=\n-Common Joined UInteger Var(param_max_pre_hoist_insert_iterations) Init(3) Param Optimization\n-The maximum number of insert iterations done for PRE code hoisting.\n-\n -param=max-reload-search-insns=\n Common Joined UInteger Var(param_max_reload_search_insns) Init(100) Param Optimization\n The maximum number of instructions to search backward when looking for equivalent reload."}, {"sha": "de3051bfb50c055bc91431d9fb2b9a89e1eff945", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-3.c?ref=bd87cc14ebdb6789e067fb1828d5808407c308b3", "patch": "@@ -15,4 +15,4 @@ int test (int a, int b, int c, int g)\n /* We should hoist and CSE only the multiplication.  */\n \n /* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"pre\" } } */\n-/* { dg-final { scan-tree-dump \"Insertions: 1\" \"pre\" } } */\n+/* { dg-final { scan-tree-dump \"HOIST inserted: 1\" \"pre\" } } */"}, {"sha": "fdb6a3ed349902c3f51a0b91d665f645ccc5b8b6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-7.c?ref=bd87cc14ebdb6789e067fb1828d5808407c308b3", "patch": "@@ -49,6 +49,6 @@ void foo (int a, int b, int c, int d, int e, int x, int y, int z)\n \n /* Now inserting x + y five times is unnecessary but the cascading\n    cannot be avoided with the simple-minded dataflow.  But make sure\n-   we do the insertions all in the first iteration.  */\n-/* { dg-final { scan-tree-dump \"insert iterations == 2\" \"pre\" } } */\n+   we do not iterate PRE insertion.  */\n+/* { dg-final { scan-tree-dump \"insert iterations == 1\" \"pre\" } } */\n /* { dg-final { scan-tree-dump \"HOIST inserted: 5\" \"pre\" } } */"}, {"sha": "cf9317372d64f91df9e851fe3d61db3bd6b44b83", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-30.c?ref=bd87cc14ebdb6789e067fb1828d5808407c308b3", "patch": "@@ -24,4 +24,4 @@ bar (int b, int x)\n /* We should see the partial redundant loads of f even though they\n    are using different types (of the same size).  */\n \n-/* { dg-final { scan-tree-dump-times \"Replaced MEM\" 2 \"pre\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replaced MEM\" 3 \"pre\" } } */"}, {"sha": "d90249c01822ecebb2e1079aed0a5cba60d902bd", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd87cc14ebdb6789e067fb1828d5808407c308b3/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=bd87cc14ebdb6789e067fb1828d5808407c308b3", "patch": "@@ -3695,18 +3695,6 @@ insert (void)\n \tfprintf (dump_file, \"Starting insert iteration %d\\n\", num_iterations);\n \n       changed = false;\n-      /* Insert expressions for hoisting.  Do a backward walk here since\n-\t inserting into BLOCK exposes new opportunities in its predecessors.\n-\t Since PRE and hoist insertions can cause back-to-back iteration\n-\t limit that on the hoist side.  */\n-      if (flag_code_hoisting\n-\t  && num_iterations <= param_max_pre_hoist_insert_iterations)\n-\tfor (int idx = rpo_num - 1; idx >= 0; --idx)\n-\t  {\n-\t    basic_block block = BASIC_BLOCK_FOR_FN (cfun, rpo[idx]);\n-\t    if (EDGE_COUNT (block->succs) >= 2)\n-\t      changed |= do_hoist_insertion (block);\n-\t  }\n       for (int idx = 0; idx < rpo_num; ++idx)\n \t{\n \t  basic_block block = BASIC_BLOCK_FOR_FN (cfun, rpo[idx]);\n@@ -3754,6 +3742,28 @@ insert (void)\n \n   statistics_histogram_event (cfun, \"insert iterations\", num_iterations);\n \n+  /* AVAIL_OUT is not needed after insertion so we don't have to\n+     propagate NEW_SETS from hoist insertion.  */\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      bitmap_set_pool.remove (NEW_SETS (bb));\n+      NEW_SETS (bb) = NULL;\n+    }\n+\n+  /* Insert expressions for hoisting.  Do a backward walk here since\n+     inserting into BLOCK exposes new opportunities in its predecessors.\n+     Since PRE and hoist insertions can cause back-to-back iteration\n+     and we are interested in PRE insertion exposed hoisting opportunities\n+     but not in hoisting exposed PRE ones do hoist insertion only after\n+     PRE insertion iteration finished and do not iterate it.  */\n+  if (flag_code_hoisting)\n+    for (int idx = rpo_num - 1; idx >= 0; --idx)\n+      {\n+\tbasic_block block = BASIC_BLOCK_FOR_FN (cfun, rpo[idx]);\n+\tif (EDGE_COUNT (block->succs) >= 2)\n+\t  changed |= do_hoist_insertion (block);\n+      }\n+\n   free (rpo);\n }\n "}]}