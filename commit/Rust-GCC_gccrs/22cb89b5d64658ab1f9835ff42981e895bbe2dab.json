{"sha": "22cb89b5d64658ab1f9835ff42981e895bbe2dab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJjYjg5YjVkNjQ2NThhYjFmOTgzNWZmNDI5ODFlODk1YmJlMmRhYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T09:05:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T09:05:37Z"}, "message": "[multiple changes]\n\n2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_util.adb (Make_Subtype_From_Expr): If the unconstrained type is\n\tthe class-wide type for a private extension, and the completion is a\n\tsubtype, set the type of the class-wide type to the base type of the\n\tfull view.\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* g-socket.ads, sem_aggr.adb, einfo.ads, sem_elim.adb,\n\tsem_intr.adb, sem_eval.adb: Minor reformatting\n\n2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_type.adb (Is_Ancestor): If either type is private, examine full\n\tview.\n\nFrom-SVN: r160966", "tree": {"sha": "fdb6461959848edd0ac0162f136554c4a7f02f28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb6461959848edd0ac0162f136554c4a7f02f28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22cb89b5d64658ab1f9835ff42981e895bbe2dab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22cb89b5d64658ab1f9835ff42981e895bbe2dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22cb89b5d64658ab1f9835ff42981e895bbe2dab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22cb89b5d64658ab1f9835ff42981e895bbe2dab/comments", "author": null, "committer": null, "parents": [{"sha": "e9672ebe5d3c2695c61ca92c29af4a1df222db13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9672ebe5d3c2695c61ca92c29af4a1df222db13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9672ebe5d3c2695c61ca92c29af4a1df222db13"}], "stats": {"total": 384, "additions": 203, "deletions": 181}, "files": [{"sha": "b489a8d5b4b0bcac2d56baefdff19bed69c749aa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -1,3 +1,20 @@\n+2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_util.adb (Make_Subtype_From_Expr): If the unconstrained type is\n+\tthe class-wide type for a private extension, and the completion is a\n+\tsubtype, set the type of the class-wide type to the base type of the\n+\tfull view.\n+\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-socket.ads, sem_aggr.adb, einfo.ads, sem_elim.adb,\n+\tsem_intr.adb, sem_eval.adb: Minor reformatting\n+\n+2010-06-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_type.adb (Is_Ancestor): If either type is private, examine full\n+\tview.\n+\n 2010-06-18  Thomas Quinot  <quinot@adacore.com>\n \n \t* g-socket.adb, g-socket.ads (Check_Selector): Make Selector an IN"}, {"sha": "27c0b66eed15ddceb8c228da99c01ad8d0b51ae9", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -6189,7 +6189,7 @@ package Einfo is\n    --  have an RM_Size value of zero).\n \n    --  In two cases, Known_Static_Esize and Known_Static_RM_Size, there is one\n-   --  more consideration, which is that we always return false for generic\n+   --  more consideration, which is that we always return False for generic\n    --  types. Within a template, the size can look known, because of the fake\n    --  size values we put in template types, but they are not really known and\n    --  anyone testing if they are known within the template should get False as"}, {"sha": "4f2e7f7399d982cdd42e0727d37f03b992857ef1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -3475,7 +3475,7 @@ package body Exp_Util is\n             --  Generate warning if not suppressed\n \n             if W then\n-               Error_Msg_F\n+               Error_Msg_F -- CODEFIX???\n                  (\"?this code can never be executed and has been deleted!\", N);\n             end if;\n          end if;\n@@ -4052,6 +4052,20 @@ package body Exp_Util is\n             --  additional intermediate type to handle the assignment).\n \n             if Expander_Active and then Tagged_Type_Expansion then\n+\n+               --  If this is the class_wide type of a completion that is\n+               --  a record subtype, set the type of the class_wide type\n+               --  to be the full base type, for use in the expanded code\n+               --  for the equivalent type. Should this be done earlier when\n+               --  the completion is analyzed ???\n+\n+               if Is_Private_Type (Etype (Unc_Typ))\n+                 and then\n+                   Ekind (Full_View (Etype (Unc_Typ))) = E_Record_Subtype\n+               then\n+                  Set_Etype (Unc_Typ, Base_Type (Full_View (Etype (Unc_Typ))));\n+               end if;\n+\n                EQ_Typ := Make_CW_Equivalent_Type (Unc_Typ, E);\n             end if;\n "}, {"sha": "cfb8da518390856178e189e94e51fd5ee4617235", "filename": "gcc/ada/g-socket.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.ads?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -1088,9 +1088,11 @@ package GNAT.Sockets is\n    --  R_Socket_Set or W_Socket_Set. Status is set to Expired if no socket was\n    --  ready after a Timeout expiration. Status is set to Aborted if an abort\n    --  signal has been received while checking socket status.\n+   --\n    --  Note that two different Socket_Set_Type objects must be passed as\n    --  R_Socket_Set and W_Socket_Set (even if they denote the same set of\n    --  Sockets), or some event may be lost.\n+   --\n    --  Socket_Error is raised when the select(2) system call returns an\n    --  error condition, or when a read error occurs on the signalling socket\n    --  used for the implementation of Abort_Selector."}, {"sha": "464cd4964e65780a83464a989b07d30ecc0970c3", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1431,7 +1431,8 @@ package body Sem_Aggr is\n                   --  aggregate must not be enclosed in parentheses.\n \n                   if Paren_Count (Expr) /= 0 then\n-                     Error_Msg_N (\"no parenthesis allowed here\", Expr);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"no parenthesis allowed here\", Expr);\n                   end if;\n \n                   Make_String_Into_Aggregate (Expr);\n@@ -1443,8 +1444,9 @@ package body Sem_Aggr is\n                   --  a missing component association for a 1-aggregate.\n \n                   if Paren_Count (Expr) > 0 then\n-                     Error_Msg_N (\"\\if single-component aggregate is intended,\"\n-                                  & \" write e.g. (1 ='> ...)\", Expr);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"\\if single-component aggregate is intended,\"\n+                        & \" write e.g. (1 ='> ...)\", Expr);\n                   end if;\n                   return Failure;\n                end if;\n@@ -1547,13 +1549,13 @@ package body Sem_Aggr is\n                   if Choice /= First (Choices (Assoc))\n                     or else Present (Next (Choice))\n                   then\n-                     Error_Msg_N\n+                     Error_Msg_N -- CODEFIX???\n                        (\"OTHERS must appear alone in a choice list\", Choice);\n                      return Failure;\n                   end if;\n \n                   if Present (Next (Assoc)) then\n-                     Error_Msg_N\n+                     Error_Msg_N -- CODEFIX???\n                        (\"OTHERS must appear last in an aggregate\", Choice);\n                      return Failure;\n                   end if;\n@@ -2504,8 +2506,8 @@ package body Sem_Aggr is\n       --  New_Assoc_List the discriminant value specified in the ancestor part.\n       --\n       --  If the aggregate is in a context with expansion delayed, it will be\n-      --  reanalyzed, The inherited discriminant values must not be reinserted\n-      --  in the component list to prevent spurious errors, but it must be\n+      --  reanalyzed. The inherited discriminant values must not be reinserted\n+      --  in the component list to prevent spurious errors, but they must be\n       --  present on first analysis to build the proper subtype indications.\n       --  The flag Inherited_Discriminant is used to prevent the re-insertion.\n \n@@ -3023,13 +3025,15 @@ package body Sem_Aggr is\n                   if Selector_Name /= First (Choices (Assoc))\n                     or else Present (Next (Selector_Name))\n                   then\n-                     Error_Msg_N (\"OTHERS must appear alone in a choice list\",\n-                                  Selector_Name);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"OTHERS must appear alone in a choice list\",\n+                        Selector_Name);\n                      return;\n \n                   elsif Present (Next (Assoc)) then\n-                     Error_Msg_N (\"OTHERS must appear last in an aggregate\",\n-                                  Selector_Name);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"OTHERS must appear last in an aggregate\",\n+                        Selector_Name);\n                      return;\n \n                   --  (Ada2005): If this is an association with a box,\n@@ -3242,10 +3246,11 @@ package body Sem_Aggr is\n                if Nkind (Parent (Base_Type (Root_Typ))) =\n                                                N_Private_Type_Declaration\n                then\n-                  Error_Msg_NE\n+                  Error_Msg_NE -- CODEFIX???\n                     (\"type of aggregate has private ancestor&!\",\n                      N, Root_Typ);\n-                  Error_Msg_N  (\"must use extension aggregate!\", N);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"must use extension aggregate!\", N);\n                   return;\n                end if;\n \n@@ -3278,10 +3283,11 @@ package body Sem_Aggr is\n                                         N_Private_Extension_Declaration\n                then\n                   if Nkind (N) /= N_Extension_Aggregate then\n-                     Error_Msg_NE\n+                     Error_Msg_NE -- CODEFIX???\n                        (\"type of aggregate has private ancestor&!\",\n                         N, Parent_Typ);\n-                     Error_Msg_N  (\"must use extension aggregate!\", N);\n+                     Error_Msg_N  -- CODEFIX???\n+                       (\"must use extension aggregate!\", N);\n                      return;\n \n                   elsif Parent_Typ /= Root_Typ then\n@@ -3766,7 +3772,7 @@ package body Sem_Aggr is\n                if No (Others_Etype)\n                   and then not Others_Box\n                then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"OTHERS must represent at least one component\", Selectr);\n                end if;\n "}, {"sha": "b7d9348b418e5f52ef7c428ef0b9ed25c49a36a0", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -295,11 +295,11 @@ package body Sem_Elim is\n \n             Up := Elmt.Unit_Name'Last;\n \n-            --  If we are within a subunit, the name in the pragma  has been\n-            --  parsed as a child unit, but the current compilation unit is\n-            --  in fact the parent in which the subunit is embedded. We must\n-            --  skip the first name which is that of the subunit to match\n-            --  the pragma specification.\n+            --  If we are within a subunit, the name in the pragma has been\n+            --  parsed as a child unit, but the current compilation unit is in\n+            --  fact the parent in which the subunit is embedded. We must skip\n+            --  the first name which is that of the subunit to match the pragma\n+            --  specification.\n \n             declare\n                Par : Node_Id;"}, {"sha": "7ef747000d5d5a6507e94f8aaec5ee74ded578e6", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 125, "deletions": 150, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2069,8 +2069,7 @@ package body Sem_Eval is\n          Right_Int : constant Uint := Expr_Value (Right);\n \n       begin\n-\n-         --  VMS includes bitwise operations on signed types.\n+         --  VMS includes bitwise operations on signed types\n \n          if Is_Modular_Integer_Type (Etype (N))\n            or else Is_VMS_Operator (Entity (N))\n@@ -2149,9 +2148,7 @@ package body Sem_Eval is\n       --  Ignore if error in either operand, except to make sure that Any_Type\n       --  is properly propagated to avoid junk cascaded errors.\n \n-      if Etype (Left) = Any_Type\n-        or else Etype (Right) = Any_Type\n-      then\n+      if Etype (Left) = Any_Type or else Etype (Right) = Any_Type then\n          Set_Etype (N, Any_Type);\n          return;\n       end if;\n@@ -2224,7 +2221,8 @@ package body Sem_Eval is\n             declare\n                Typlen : constant Uint := String_Type_Len (Etype (Right));\n                Strlen : constant Uint :=\n-                 UI_From_Int (String_Length (Strval (Get_String_Val (Left))));\n+                          UI_From_Int\n+                            (String_Length (Strval (Get_String_Val (Left))));\n             begin\n                Result := (Typlen = Strlen);\n             end;\n@@ -2316,8 +2314,8 @@ package body Sem_Eval is\n                Result   : Uint;\n \n             begin\n-               --  Exponentiation of an integer raises the exception\n-               --  Constraint_Error for a negative exponent (RM 4.5.6)\n+               --  Exponentiation of an integer raises Constraint_Error for a\n+               --  negative exponent (RM 4.5.6).\n \n                if Right_Int < 0 then\n                   Apply_Compile_Time_Constraint_Error\n@@ -2432,9 +2430,9 @@ package body Sem_Eval is\n \n    begin\n       --  Can only fold if target is string or scalar and subtype is static.\n-      --  Also, do not fold if our parent is an allocator (this is because\n-      --  the qualified expression is really part of the syntactic structure\n-      --  of an allocator, and we do not want to end up with something that\n+      --  Also, do not fold if our parent is an allocator (this is because the\n+      --  qualified expression is really part of the syntactic structure of an\n+      --  allocator, and we do not want to end up with something that\n       --  corresponds to \"new 1\" where the 1 is the result of folding a\n       --  qualified expression).\n \n@@ -2620,7 +2618,7 @@ package body Sem_Eval is\n                --  entity name, and the two X's are the same and K1 and K2 are\n                --  known at compile time, in this case, the length can also be\n                --  computed at compile time, even though the bounds are not\n-               --  known. A common case of this is e.g. (X'First..X'First+5).\n+               --  known. A common case of this is e.g. (X'First .. X'First+5).\n \n                Extract_Length : declare\n                   procedure Decompose_Expr\n@@ -2879,9 +2877,9 @@ package body Sem_Eval is\n    -- Eval_Shift --\n    ----------------\n \n-   --  Shift operations are intrinsic operations that can never be static,\n-   --  so the only processing required is to perform the required check for\n-   --  a non static context for the two operands.\n+   --  Shift operations are intrinsic operations that can never be static, so\n+   --  the only processing required is to perform the required check for a non\n+   --  static context for the two operands.\n \n    --  Actually we could do some compile time evaluation here some time ???\n \n@@ -2895,8 +2893,8 @@ package body Sem_Eval is\n    -- Eval_Short_Circuit --\n    ------------------------\n \n-   --  A short circuit operation is potentially static if both operands\n-   --  are potentially static (RM 4.9 (13))\n+   --  A short circuit operation is potentially static if both operands are\n+   --  potentially static (RM 4.9 (13)).\n \n    procedure Eval_Short_Circuit (N : Node_Id) is\n       Kind     : constant Node_Kind := Nkind (N);\n@@ -2910,9 +2908,7 @@ package body Sem_Eval is\n    begin\n       --  Short circuit operations are never static in Ada 83\n \n-      if Ada_Version = Ada_83\n-        and then Comes_From_Source (N)\n-      then\n+      if Ada_Version = Ada_83 and then Comes_From_Source (N) then\n          Check_Non_Static_Context (Left);\n          Check_Non_Static_Context (Right);\n          return;\n@@ -2923,8 +2919,8 @@ package body Sem_Eval is\n       --  are a special case, they can still be foldable, even if the right\n       --  operand raises constraint error.\n \n-      --  If either operand is Any_Type, just propagate to result and\n-      --  do not try to fold, this prevents cascaded errors.\n+      --  If either operand is Any_Type, just propagate to result and do not\n+      --  try to fold, this prevents cascaded errors.\n \n       if Etype (Left) = Any_Type or else Etype (Right) = Any_Type then\n          Set_Etype (N, Any_Type);\n@@ -2997,8 +2993,8 @@ package body Sem_Eval is\n    -- Eval_Slice --\n    ----------------\n \n-   --  Slices can never be static, so the only processing required is to\n-   --  check for non-static context if an explicit range is given.\n+   --  Slices can never be static, so the only processing required is to check\n+   --  for non-static context if an explicit range is given.\n \n    procedure Eval_Slice (N : Node_Id) is\n       Drange : constant Node_Id := Discrete_Range (N);\n@@ -3008,7 +3004,7 @@ package body Sem_Eval is\n          Check_Non_Static_Context (High_Bound (Drange));\n       end if;\n \n-      --  A slice of the form  A (subtype), when the subtype is the index of\n+      --  A slice of the form A (subtype), when the subtype is the index of\n       --  the type of A, is redundant, the slice can be replaced with A, and\n       --  this is worth a warning.\n \n@@ -3026,10 +3022,11 @@ package body Sem_Eval is\n                     = Entity (Drange)\n                then\n                   if Warn_On_Redundant_Constructs then\n-                     Error_Msg_N (\"redundant slice denotes whole array?\", N);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"redundant slice denotes whole array?\", N);\n                   end if;\n \n-                  --  The following might be a useful optimization ????\n+                  --  The following might be a useful optimization????\n \n                   --  Rewrite (N, New_Occurrence_Of (E, Sloc (N)));\n                end if;\n@@ -3051,7 +3048,7 @@ package body Sem_Eval is\n \n    begin\n       --  Nothing to do if error type (handles cases like default expressions\n-      --  or generics where we have not yet fully resolved the type)\n+      --  or generics where we have not yet fully resolved the type).\n \n       if Bas = Any_Type or else Bas = Any_String then\n          return;\n@@ -3069,7 +3066,7 @@ package body Sem_Eval is\n          end if;\n \n       --  Here if Etype of string literal is normal Etype (not yet possible,\n-      --  but may be possible in future!)\n+      --  but may be possible in future).\n \n       elsif not Is_OK_Static_Expression\n                     (Type_Low_Bound (Etype (First_Index (Typ))))\n@@ -3085,12 +3082,12 @@ package body Sem_Eval is\n          return;\n       end if;\n \n-      --  Test for illegal Ada 95 cases. A string literal is illegal in\n-      --  Ada 95 if its bounds are outside the index base type and this\n-      --  index type is static. This can happen in only two ways. Either\n-      --  the string literal is too long, or it is null, and the lower\n-      --  bound is type'First. In either case it is the upper bound that\n-      --  is out of range of the index type.\n+      --  Test for illegal Ada 95 cases. A string literal is illegal in Ada 95\n+      --  if its bounds are outside the index base type and this index type is\n+      --  static. This can happen in only two ways. Either the string literal\n+      --  is too long, or it is null, and the lower bound is type'First. In\n+      --  either case it is the upper bound that is out of range of the index\n+      --  type.\n \n       if Ada_Version >= Ada_95 then\n          if Root_Type (Bas) = Standard_String\n@@ -3136,7 +3133,7 @@ package body Sem_Eval is\n \n    --  A type conversion is potentially static if its subtype mark is for a\n    --  static scalar subtype, and its operand expression is potentially static\n-   --  (RM 4.9 (10))\n+   --  (RM 4.9(10)).\n \n    procedure Eval_Type_Conversion (N : Node_Id) is\n       Operand     : constant Node_Id   := Expression (N);\n@@ -3147,9 +3144,9 @@ package body Sem_Eval is\n       Fold   : Boolean;\n \n       function To_Be_Treated_As_Integer (T : Entity_Id) return Boolean;\n-      --  Returns true if type T is an integer type, or if it is a\n-      --  fixed-point type to be treated as an integer (i.e. the flag\n-      --  Conversion_OK is set on the conversion node).\n+      --  Returns true if type T is an integer type, or if it is a fixed-point\n+      --  type to be treated as an integer (i.e. the flag Conversion_OK is set\n+      --  on the conversion node).\n \n       function To_Be_Treated_As_Real (T : Entity_Id) return Boolean;\n       --  Returns true if type T is a floating-point type, or if it is a\n@@ -3283,7 +3280,7 @@ package body Sem_Eval is\n    -------------------\n \n    --  Predefined unary operators are static functions (RM 4.9(20)) and thus\n-   --  are potentially static if the operand is potentially static (RM 4.9(7))\n+   --  are potentially static if the operand is potentially static (RM 4.9(7)).\n \n    procedure Eval_Unary_Op (N : Node_Id) is\n       Right : constant Node_Id := Right_Opnd (N);\n@@ -3380,8 +3377,8 @@ package body Sem_Eval is\n       if Is_Entity_Name (N) then\n          Ent := Entity (N);\n \n-         --  An enumeration literal that was either in the source or\n-         --  created as a result of static evaluation.\n+         --  An enumeration literal that was either in the source or created\n+         --  as a result of static evaluation.\n \n          if Ekind (Ent) = E_Enumeration_Literal then\n             return Enumeration_Rep (Ent);\n@@ -3393,8 +3390,8 @@ package body Sem_Eval is\n             return Expr_Rep_Value (Constant_Value (Ent));\n          end if;\n \n-      --  An integer literal that was either in the source or created\n-      --  as a result of static evaluation.\n+      --  An integer literal that was either in the source or created as a\n+      --  result of static evaluation.\n \n       elsif Kind = N_Integer_Literal then\n          return Intval (N);\n@@ -3421,11 +3418,11 @@ package body Sem_Eval is\n          pragma Assert (Kind = N_Character_Literal);\n          Ent := Entity (N);\n \n-         --  Since Character literals of type Standard.Character don't\n-         --  have any defining character literals built for them, they\n-         --  do not have their Entity set, so just use their Char\n-         --  code. Otherwise for user-defined character literals use\n-         --  their Pos value as usual which is the same as the Rep value.\n+         --  Since Character literals of type Standard.Character don't have any\n+         --  defining character literals built for them, they do not have their\n+         --  Entity set, so just use their Char code. Otherwise for user-\n+         --  defined character literals use their Pos value as usual which is\n+         --  the same as the Rep value.\n \n          if No (Ent) then\n             return Char_Literal_Value (N);\n@@ -3459,8 +3456,8 @@ package body Sem_Eval is\n       if Is_Entity_Name (N) then\n          Ent := Entity (N);\n \n-         --  An enumeration literal that was either in the source or\n-         --  created as a result of static evaluation.\n+         --  An enumeration literal that was either in the source or created as\n+         --  a result of static evaluation.\n \n          if Ekind (Ent) = E_Enumeration_Literal then\n             Val := Enumeration_Pos (Ent);\n@@ -3472,8 +3469,8 @@ package body Sem_Eval is\n             Val := Expr_Value (Constant_Value (Ent));\n          end if;\n \n-      --  An integer literal that was either in the source or created\n-      --  as a result of static evaluation.\n+      --  An integer literal that was either in the source or created as a\n+      --  result of static evaluation.\n \n       elsif Kind = N_Integer_Literal then\n          Val := Intval (N);\n@@ -3585,8 +3582,8 @@ package body Sem_Eval is\n          return Ureal_0;\n       end if;\n \n-      --  If we fall through, we have a node that cannot be interpreted\n-      --  as a compile time constant. That is definitely an error.\n+      --  If we fall through, we have a node that cannot be interpreted as a\n+      --  compile time constant. That is definitely an error.\n \n       raise Program_Error;\n    end Expr_Value_R;\n@@ -3650,8 +3647,8 @@ package body Sem_Eval is\n       Ent : Entity_Id;\n \n    begin\n-      --  If we are folding a named number, retain the entity in the\n-      --  literal, for ASIS use.\n+      --  If we are folding a named number, retain the entity in the literal,\n+      --  for ASIS use.\n \n       if Is_Entity_Name (N)\n         and then Ekind (Entity (N)) = E_Named_Integer\n@@ -3704,8 +3701,8 @@ package body Sem_Eval is\n       Ent : Entity_Id;\n \n    begin\n-      --  If we are folding a named number, retain the entity in the\n-      --  literal, for ASIS use.\n+      --  If we are folding a named number, retain the entity in the literal,\n+      --  for ASIS use.\n \n       if Is_Entity_Name (N)\n         and then Ekind (Entity (N)) = E_Named_Real\n@@ -3941,33 +3938,25 @@ package body Sem_Eval is\n             LB_Known := Compile_Time_Known_Value (Lo);\n             UB_Known := Compile_Time_Known_Value (Hi);\n \n-            --  Fixed point types should be considered as such only in\n-            --  flag Fixed_Int is set to False.\n+            --  Fixed point types should be considered as such only if flag\n+            --  Fixed_Int is set to False.\n \n             if Is_Floating_Point_Type (Typ)\n               or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n               or else Int_Real\n             then\n                Valr := Expr_Value_R (N);\n \n-               if LB_Known and then Valr >= Expr_Value_R (Lo)\n-                 and then UB_Known and then Valr <= Expr_Value_R (Hi)\n-               then\n-                  return True;\n-               else\n-                  return False;\n-               end if;\n+               return LB_Known and then Valr >= Expr_Value_R (Lo)\n+                        and then\n+                      UB_Known and then Valr <= Expr_Value_R (Hi);\n \n             else\n                Val := Expr_Value (N);\n \n-               if         LB_Known and then Val >= Expr_Value (Lo)\n-                 and then UB_Known and then Val <= Expr_Value (Hi)\n-               then\n-                  return True;\n-               else\n-                  return False;\n-               end if;\n+               return LB_Known and then Val >= Expr_Value (Lo)\n+                        and then\n+                      UB_Known and then Val <= Expr_Value (Hi);\n             end if;\n          end;\n       end if;\n@@ -4025,8 +4014,8 @@ package body Sem_Eval is\n    -- Is_OK_Static_Subtype --\n    --------------------------\n \n-   --  Determines if Typ is a static subtype as defined in (RM 4.9(26))\n-   --  where neither bound raises constraint error when evaluated.\n+   --  Determines if Typ is a static subtype as defined in (RM 4.9(26)) where\n+   --  neither bound raises constraint error when evaluated.\n \n    function Is_OK_Static_Subtype (Typ : Entity_Id) return Boolean is\n       Base_T   : constant Entity_Id := Base_Type (Typ);\n@@ -4068,8 +4057,8 @@ package body Sem_Eval is\n             return True;\n \n          else\n-            --  Scalar_Range (Typ) might be an N_Subtype_Indication, so\n-            --  use Get_Type_Low,High_Bound.\n+            --  Scalar_Range (Typ) might be an N_Subtype_Indication, so use\n+            --  Get_Type_{Low,High}_Bound.\n \n             return     Is_OK_Static_Subtype (Anc_Subt)\n               and then Is_OK_Static_Expression (Type_Low_Bound (Typ))\n@@ -4143,38 +4132,26 @@ package body Sem_Eval is\n             LB_Known := Compile_Time_Known_Value (Lo);\n             UB_Known := Compile_Time_Known_Value (Hi);\n \n-            --  Real types (note that fixed-point types are not treated\n-            --  as being of a real type if the flag Fixed_Int is set,\n-            --  since in that case they are regarded as integer types).\n+            --  Real types (note that fixed-point types are not treated as\n+            --  being of a real type if the flag Fixed_Int is set, since in\n+            --  that case they are regarded as integer types).\n \n             if Is_Floating_Point_Type (Typ)\n               or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n               or else Int_Real\n             then\n                Valr := Expr_Value_R (N);\n \n-               if LB_Known and then Valr < Expr_Value_R (Lo) then\n-                  return True;\n-\n-               elsif UB_Known and then Expr_Value_R (Hi) < Valr then\n-                  return True;\n-\n-               else\n-                  return False;\n-               end if;\n+               return (LB_Known and then Valr < Expr_Value_R (Lo))\n+                        or else\n+                      (UB_Known and then Expr_Value_R (Hi) < Valr);\n \n             else\n                Val := Expr_Value (N);\n \n-               if LB_Known and then Val < Expr_Value (Lo) then\n-                  return True;\n-\n-               elsif UB_Known and then Expr_Value (Hi) < Val then\n-                  return True;\n-\n-               else\n-                  return False;\n-               end if;\n+               return (LB_Known and then Val < Expr_Value (Lo))\n+                        or else\n+                      (UB_Known and then Expr_Value (Hi) < Val);\n             end if;\n          end;\n       end if;\n@@ -4302,10 +4279,9 @@ package body Sem_Eval is\n    begin\n       --  If we have the static expression case, then this is an illegality\n       --  in Ada 95 mode, except that in an instance, we never generate an\n-      --  error (if the error is legitimate, it was already diagnosed in\n-      --  the template). The expression to compute the length of a packed\n-      --  array is attached to the array type itself, and deserves a separate\n-      --  message.\n+      --  error (if the error is legitimate, it was already diagnosed in the\n+      --  template). The expression to compute the length of a packed array is\n+      --  attached to the array type itself, and deserves a separate message.\n \n       if Is_Static_Expression (N)\n         and then not In_Instance\n@@ -4327,8 +4303,8 @@ package body Sem_Eval is\n               (N, \"value not in range of}\", CE_Range_Check_Failed);\n          end if;\n \n-      --  Here we generate a warning for the Ada 83 case, or when we are\n-      --  in an instance, or when we have a non-static expression case.\n+      --  Here we generate a warning for the Ada 83 case, or when we are in an\n+      --  instance, or when we have a non-static expression case.\n \n       else\n          Apply_Compile_Time_Constraint_Error\n@@ -4344,22 +4320,22 @@ package body Sem_Eval is\n       Typ : constant Entity_Id := Etype (N);\n \n    begin\n-      --  If we want to raise CE in the condition of a raise_CE node\n-      --  we may as well get rid of the condition\n+      --  If we want to raise CE in the condition of a N_Raise_CE node\n+      --  we may as well get rid of the condition.\n \n       if Present (Parent (N))\n         and then Nkind (Parent (N)) = N_Raise_Constraint_Error\n       then\n          Set_Condition (Parent (N), Empty);\n \n-      --  If the expression raising CE is a N_Raise_CE node, we can use\n-      --  that one. We just preserve the type of the context\n+      --  If the expression raising CE is a N_Raise_CE node, we can use that\n+      --  one. We just preserve the type of the context.\n \n       elsif Nkind (Exp) = N_Raise_Constraint_Error then\n          Rewrite (N, Exp);\n          Set_Etype (N, Typ);\n \n-      --  We have to build an explicit raise_ce node\n+      --  Else build an explcit N_Raise_CE\n \n       else\n          Rewrite (N,\n@@ -4496,16 +4472,16 @@ package body Sem_Eval is\n          --  A constrained numeric subtype never matches an unconstrained\n          --  subtype, i.e. both types must be constrained or unconstrained.\n \n-         --  To understand the requirement for this test, see RM 4.9.1(1).\n-         --  As is made clear in RM 3.5.4(11), type Integer, for example\n-         --  is a constrained subtype with constraint bounds matching the\n-         --  bounds of its corresponding unconstrained base type. In this\n-         --  situation, Integer and Integer'Base do not statically match,\n-         --  even though they have the same bounds.\n+         --  To understand the requirement for this test, see RM 4.9.1(1). As\n+         --  is made clear in RM 3.5.4(11), type Integer, for example is a\n+         --  constrained subtype with constraint bounds matching the bounds of\n+         --  its corresponding unconstrained base type. In this situation,\n+         --  Integer and Integer'Base do not statically match, even though they\n+         --  have the same bounds.\n \n-         --  We only apply this test to types in Standard and types that\n-         --  appear in user programs. That way, we do not have to be\n-         --  too careful about setting Is_Constrained right for itypes.\n+         --  We only apply this test to types in Standard and types that appear\n+         --  in user programs. That way, we do not have to be too careful about\n+         --  setting Is_Constrained right for Itypes.\n \n          if Is_Numeric_Type (T1)\n            and then (Is_Constrained (T1) /= Is_Constrained (T2))\n@@ -4516,9 +4492,9 @@ package body Sem_Eval is\n          then\n             return False;\n \n-         --  A generic scalar type does not statically match its base\n-         --  type (AI-311). In this case we make sure that the formals,\n-         --  which are first subtypes of their bases, are constrained.\n+         --  A generic scalar type does not statically match its base type\n+         --  (AI-311). In this case we make sure that the formals, which are\n+         --  first subtypes of their bases, are constrained.\n \n          elsif Is_Generic_Type (T1)\n            and then Is_Generic_Type (T2)\n@@ -4527,8 +4503,8 @@ package body Sem_Eval is\n             return False;\n          end if;\n \n-         --  If there was an error in either range, then just assume\n-         --  the types statically match to avoid further junk errors\n+         --  If there was an error in either range, then just assume the types\n+         --  statically match to avoid further junk errors.\n \n          if Error_Posted (Scalar_Range (T1))\n               or else\n@@ -4559,8 +4535,8 @@ package body Sem_Eval is\n                then\n                   return False;\n \n-               --  If either type has constraint error bounds, then say\n-               --  that they match to avoid junk cascaded errors here.\n+               --  If either type has constraint error bounds, then say that\n+               --  they match to avoid junk cascaded errors here.\n \n                elsif not Is_OK_Static_Subtype (T1)\n                  or else not Is_OK_Static_Subtype (T2)\n@@ -4670,11 +4646,11 @@ package body Sem_Eval is\n \n          return True;\n \n-      --  A definite type does not match an indefinite or classwide type\n+      --  A definite type does not match an indefinite or classwide type.\n       --  However, a generic type with unknown discriminants may be\n       --  instantiated with a type with no discriminants, and conformance\n-      --  checking on an inherited operation may compare the actual with\n-      --  the subtype that renames it in the instance.\n+      --  checking on an inherited operation may compare the actual with the\n+      --  subtype that renames it in the instance.\n \n       elsif\n          Has_Unknown_Discriminants (T1) /= Has_Unknown_Discriminants (T2)\n@@ -4686,16 +4662,15 @@ package body Sem_Eval is\n \n       elsif Is_Array_Type (T1) then\n \n-         --  If either subtype is unconstrained then both must be,\n-         --  and if both are unconstrained then no further checking\n-         --  is needed.\n+         --  If either subtype is unconstrained then both must be, and if both\n+         --  are unconstrained then no further checking is neede.\n \n          if not Is_Constrained (T1) or else not Is_Constrained (T2) then\n             return not (Is_Constrained (T1) or else Is_Constrained (T2));\n          end if;\n \n-         --  Both subtypes are constrained, so check that the index\n-         --  subtypes statically match.\n+         --  Both subtypes are constrained, so check that the index subtypes\n+         --  statically match.\n \n          declare\n             Index1 : Node_Id := First_Index (T1);\n@@ -4846,8 +4821,8 @@ package body Sem_Eval is\n          Set_Etype (N, Any_Type);\n          return;\n \n-      --  If left operand raises constraint error, then replace node N with\n-      --  the raise constraint error node, and we are obviously not foldable.\n+      --  If left operand raises constraint error, then replace node N with the\n+      --  Raise_Constraint_Error node, and we are obviously not foldable.\n       --  Is_Static_Expression is set from the two operands in the normal way,\n       --  and we check the right operand if it is in a non-static context.\n \n@@ -4860,9 +4835,9 @@ package body Sem_Eval is\n          Set_Is_Static_Expression (N, Rstat);\n          return;\n \n-      --  Similar processing for the case of the right operand. Note that\n-      --  we don't use this routine for the short-circuit case, so we do\n-      --  not have to worry about that special case here.\n+      --  Similar processing for the case of the right operand. Note that we\n+      --  don't use this routine for the short-circuit case, so we do not have\n+      --  to worry about that special case here.\n \n       elsif Raises_Constraint_Error (Op2) then\n          if not Rstat then\n@@ -4882,7 +4857,7 @@ package body Sem_Eval is\n          return;\n \n       --  If result is not static, then check non-static contexts on operands\n-      --  since one of them may be static and the other one may not be static\n+      --  since one of them may be static and the other one may not be static.\n \n       elsif not Rstat then\n          Check_Non_Static_Context (Op1);\n@@ -4891,8 +4866,8 @@ package body Sem_Eval is\n                    and then Compile_Time_Known_Value (Op2);\n          return;\n \n-      --  Else result is static and foldable. Both operands are static,\n-      --  and neither raises constraint error, so we can definitely fold.\n+      --  Else result is static and foldable. Both operands are static, and\n+      --  neither raises constraint error, so we can definitely fold.\n \n       else\n          Set_Is_Static_Expression (N);\n@@ -4923,8 +4898,8 @@ package body Sem_Eval is\n       E   : Entity_Id;\n \n       procedure Why_Not_Static_List (L : List_Id);\n-      --  A version that can be called on a list of expressions. Finds\n-      --  all non-static violations in any element of the list.\n+      --  A version that can be called on a list of expressions. Finds all\n+      --  non-static violations in any element of the list.\n \n       -------------------------\n       -- Why_Not_Static_List --\n@@ -4946,8 +4921,8 @@ package body Sem_Eval is\n    --  Start of processing for Why_Not_Static\n \n    begin\n-      --  If in ACATS mode (debug flag 2), then suppress all these\n-      --  messages, this avoids massive updates to the ACATS base line.\n+      --  If in ACATS mode (debug flag 2), then suppress all these messages,\n+      --  this avoids massive updates to the ACATS base line.\n \n       if Debug_Flag_2 then\n          return;\n@@ -5071,8 +5046,8 @@ package body Sem_Eval is\n \n                return;\n \n-            --  Special case generic types, since again this is a common\n-            --  source of confusion.\n+            --  Special case generic types, since again this is a common source\n+            --  of confusion.\n \n             elsif Is_Generic_Actual_Type (E)\n                     or else"}, {"sha": "e5c779f1d7d22d06b0047f09d6169c96d7b7f72c", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,7 +54,7 @@ package body Sem_Intr is\n \n    procedure Check_Intrinsic_Operator (E : Entity_Id; N : Node_Id);\n    --  Check that operator is one of the binary arithmetic operators, and\n-   --  that the types involved both have underlying integer types..\n+   --  that the types involved both have underlying integer types.\n \n    procedure Check_Shift (E : Entity_Id; N : Node_Id);\n    --  Check intrinsic shift subprogram, the two arguments are the same"}, {"sha": "b19628615564b5c518762e2350153ee7889b288e", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22cb89b5d64658ab1f9835ff42981e895bbe2dab/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=22cb89b5d64658ab1f9835ff42981e895bbe2dab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2554,9 +2554,9 @@ package body Sem_Type is\n       BT1 := Base_Type (T1);\n       BT2 := Base_Type (T2);\n \n-      --  Handle underlying view of records with unknown discriminants\n-      --  using the original entity that motivated the construction of\n-      --  this underlying record view (see Build_Derived_Private_Type).\n+      --  Handle underlying view of records with unknown discriminants using\n+      --  the original entity that motivated the construction of this\n+      --  underlying record view (see Build_Derived_Private_Type).\n \n       if Is_Underlying_Record_View (BT1) then\n          BT1 := Underlying_Record_View (BT1);\n@@ -2569,12 +2569,20 @@ package body Sem_Type is\n       if BT1 = BT2 then\n          return True;\n \n+      --  The predicate must look past privacy\n+\n       elsif Is_Private_Type (T1)\n         and then Present (Full_View (T1))\n         and then BT2 = Base_Type (Full_View (T1))\n       then\n          return True;\n \n+      elsif Is_Private_Type (T2)\n+        and then Present (Full_View (T2))\n+        and then BT1 = Base_Type (Full_View (T2))\n+      then\n+         return True;\n+\n       else\n          Par := Etype (BT2);\n "}]}