{"sha": "4008290f65988de470218021818009fddeaf50dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAwODI5MGY2NTk4OGRlNDcwMjE4MDIxODE4MDA5ZmRkZWFmNTBkZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-12-22T08:54:19Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-12-22T08:54:19Z"}, "message": "New symbol_summary class introduced.\n\n\t* cgraph.h (symbol_table::allocate_cgraph_symbol): Summary UID\n\tis filled up.\n\t* symbol-summary.h: New file.\n\t* gengtype.c (open_base_files): Add symbol-summary.h.\n\t* toplev.c (general_init): Call constructor of symbol_table.\n\nFrom-SVN: r219004", "tree": {"sha": "6176621250914a21a9d2683fd1c64438388fa094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6176621250914a21a9d2683fd1c64438388fa094"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4008290f65988de470218021818009fddeaf50dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4008290f65988de470218021818009fddeaf50dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4008290f65988de470218021818009fddeaf50dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4008290f65988de470218021818009fddeaf50dd/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe55e976f18232df8ca3c1c928edb54fe06402c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe55e976f18232df8ca3c1c928edb54fe06402c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe55e976f18232df8ca3c1c928edb54fe06402c0"}], "stats": {"total": 304, "additions": 301, "deletions": 3}, "files": [{"sha": "d5e2b7b8899c235f26c0781821d072adfa314abc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4008290f65988de470218021818009fddeaf50dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4008290f65988de470218021818009fddeaf50dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4008290f65988de470218021818009fddeaf50dd", "patch": "@@ -1,3 +1,11 @@\n+2014-12-22  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.h (symbol_table::allocate_cgraph_symbol): Summary UID\n+\tis filled up.\n+\t* symbol-summary.h: New file.\n+\t* gengtype.c (open_base_files): Add symbol-summary.h.\n+\t* toplev.c (general_init): Call constructor of symbol_table.\n+\n 2014-12-17  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/55212"}, {"sha": "0cff779a0d84ca2cc76f23441ef86067f089b447", "filename": "gcc/cgraph.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4008290f65988de470218021818009fddeaf50dd/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4008290f65988de470218021818009fddeaf50dd/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4008290f65988de470218021818009fddeaf50dd", "patch": "@@ -1255,6 +1255,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   int count_materialization_scale;\n   /* Unique id of the node.  */\n   int uid;\n+  /* Summary unique id of the node.  */\n+  int summary_uid;\n   /* ID assigned by the profiling.  */\n   unsigned int profile_id;\n   /* Time profiler: first run of function.  */\n@@ -1837,6 +1839,10 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   friend class cgraph_node;\n   friend class cgraph_edge;\n \n+  symbol_table (): cgraph_max_summary_uid (1)\n+  {\n+  }\n+\n   /* Initialize callgraph dump file.  */\n   void initialize (void);\n \n@@ -2033,6 +2039,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n \n   int cgraph_count;\n   int cgraph_max_uid;\n+  int cgraph_max_summary_uid;\n \n   int edges_count;\n   int edges_max_uid;\n@@ -2361,6 +2368,7 @@ symbol_table::allocate_cgraph_symbol (void)\n       node->uid = cgraph_max_uid++;\n     }\n \n+  node->summary_uid = cgraph_max_summary_uid++;\n   return node;\n }\n "}, {"sha": "3f9ad0b3463934f81b594a65197eaa8a5f1ad1db", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4008290f65988de470218021818009fddeaf50dd/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4008290f65988de470218021818009fddeaf50dd/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=4008290f65988de470218021818009fddeaf50dd", "patch": "@@ -1740,8 +1740,8 @@ open_base_files (void)\n       \"tree-ssa-loop-niter.h\", \"tree-into-ssa.h\", \"tree-dfa.h\", \n       \"tree-ssa.h\", \"reload.h\", \"cpp-id-data.h\", \"tree-chrec.h\",\n       \"except.h\", \"output.h\",  \"cfgloop.h\", \"target.h\", \"lto-streamer.h\",\n-      \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"ipa-prop.h\", \n-      \"ipa-inline.h\", \"dwarf2out.h\", \"omp-low.h\", NULL\n+      \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"symbol-summary.h\",\n+      \"ipa-prop.h\", \"ipa-inline.h\", \"dwarf2out.h\", \"omp-low.h\", NULL\n     };\n     const char *const *ifp;\n     outf_p gtype_desc_c;"}, {"sha": "d001f640b1066aa686af68663cfbea4f71bc9cbb", "filename": "gcc/symbol-summary.h", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4008290f65988de470218021818009fddeaf50dd/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4008290f65988de470218021818009fddeaf50dd/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=4008290f65988de470218021818009fddeaf50dd", "patch": "@@ -0,0 +1,281 @@\n+/* Callgraph summary data structure.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Martin Liska\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SYMBOL_SUMMARY_H\n+#define GCC_SYMBOL_SUMMARY_H\n+\n+/* We want to pass just pointer types as argument for function_summary\n+   template class.  */\n+\n+template <class T>\n+class function_summary\n+{\n+private:\n+  function_summary();\n+};\n+\n+template <class T>\n+class GTY((user)) function_summary <T *>\n+{\n+public:\n+  /* Default construction takes SYMTAB as an argument.  */\n+  function_summary (symbol_table *symtab, bool ggc = false): m_ggc (ggc),\n+    m_map (13, ggc), m_insertion_enabled (true), m_symtab (symtab)\n+  {\n+#ifdef ENABLE_CHECKING\n+    cgraph_node *node;\n+\n+    FOR_EACH_FUNCTION (node)\n+    {\n+      gcc_checking_assert (node->summary_uid > 0);\n+    }\n+#endif\n+\n+    m_symtab_insertion_hook =\n+      symtab->add_cgraph_insertion_hook\n+      (function_summary::symtab_insertion, this);\n+\n+    m_symtab_removal_hook =\n+      symtab->add_cgraph_removal_hook\n+      (function_summary::symtab_removal, this);\n+    m_symtab_duplication_hook =\n+      symtab->add_cgraph_duplication_hook\n+      (function_summary::symtab_duplication, this);\n+  }\n+\n+  /* Destructor.  */\n+  virtual ~function_summary ()\n+  {\n+    release ();\n+  }\n+\n+  /* Destruction method that can be called for GGT purpose.  */\n+  void release ()\n+  {\n+    if (m_symtab_insertion_hook)\n+      m_symtab->remove_cgraph_insertion_hook (m_symtab_insertion_hook);\n+\n+    if (m_symtab_removal_hook)\n+      m_symtab->remove_cgraph_removal_hook (m_symtab_removal_hook);\n+\n+    if (m_symtab_duplication_hook)\n+      m_symtab->remove_cgraph_duplication_hook (m_symtab_duplication_hook);\n+\n+    m_symtab_insertion_hook = NULL;\n+    m_symtab_removal_hook = NULL;\n+    m_symtab_duplication_hook = NULL;\n+  }\n+\n+  /* Traverses all summarys with a function F called with\n+     ARG as argument.  */\n+  template<typename Arg, bool (*f)(const T &, Arg)>\n+  void traverse (Arg a) const\n+  {\n+    m_map.traverse <f> (a);\n+  }\n+\n+  /* Basic implementation of insert operation.  */\n+  virtual void insert (cgraph_node *, T *) {}\n+\n+  /* Basic implementation of removal operation.  */\n+  virtual void remove (cgraph_node *, T *) {}\n+\n+  /* Basic implementation of duplication operation.  */\n+  virtual void duplicate (cgraph_node *, cgraph_node *, T *, T *) {}\n+\n+  /* Allocates new data that are stored within map.  */\n+  T* allocate_new ()\n+  {\n+    return m_ggc ? new (ggc_alloc <T> ()) T() : new T () ;\n+  }\n+\n+  /* Getter for summary callgraph node pointer.  */\n+  T* get (cgraph_node *node)\n+  {\n+    return get (node->summary_uid);\n+  }\n+\n+  /* Return number of elements handled by data structure.  */\n+  size_t elements ()\n+  {\n+    return m_map.elements ();\n+  }\n+\n+  /* Enable insertion hook invocation.  */\n+  void enable_insertion_hook ()\n+  {\n+    m_insertion_enabled = true;\n+  }\n+\n+  /* Enable insertion hook invocation.  */\n+  void disable_insertion_hook ()\n+  {\n+    m_insertion_enabled = false;\n+  }\n+\n+  /* Symbol insertion hook that is registered to symbol table.  */\n+  static void symtab_insertion (cgraph_node *node, void *data)\n+  {\n+    function_summary *summary = (function_summary <T *> *) (data);\n+\n+    if (summary->m_insertion_enabled)\n+      summary->insert (node, summary->get (node));\n+  }\n+\n+  /* Symbol removal hook that is registered to symbol table.  */\n+  static void symtab_removal (cgraph_node *node, void *data)\n+  {\n+    gcc_checking_assert (node->summary_uid);\n+    function_summary *summary = (function_summary <T *> *) (data);\n+\n+    int summary_uid = node->summary_uid;\n+    T **v = summary->m_map.get (summary_uid);\n+\n+    if (v)\n+      {\n+\tsummary->remove (node, *v);\n+\n+\tif (!summary->m_ggc)\n+\t  delete (*v);\n+\n+\tsummary->m_map.remove (summary_uid);\n+      }\n+  }\n+\n+  /* Symbol duplication hook that is registered to symbol table.  */\n+  static void symtab_duplication (cgraph_node *node, cgraph_node *node2,\n+\t\t\t\t  void *data)\n+  {\n+    function_summary *summary = (function_summary <T *> *) (data);\n+    T **v = summary->m_map.get (node->summary_uid);\n+\n+    gcc_checking_assert (node2->summary_uid > 0);\n+\n+    if (v)\n+      {\n+\t/* This load is necessary, because we insert a new value!  */\n+\tT *data = *v;\n+\tT *duplicate = summary->allocate_new ();\n+\tsummary->m_map.put (node2->summary_uid, duplicate);\n+\tsummary->duplicate (node, node2, data, duplicate);\n+      }\n+  }\n+\n+protected:\n+  /* Indication if we use ggc summary.  */\n+  bool m_ggc;\n+\n+private:\n+  struct summary_hashmap_traits: default_hashmap_traits\n+  {\n+    static const int deleted_value = -1;\n+    static const int empty_value = 0;\n+\n+    static hashval_t\n+    hash (const int v)\n+    {\n+      return (hashval_t)v;\n+    }\n+\n+    template<typename Type>\n+    static bool\n+    is_deleted (Type &e)\n+    {\n+      return e.m_key == deleted_value;\n+    }\n+\n+    template<typename Type>\n+    static bool\n+    is_empty (Type &e)\n+    {\n+      return e.m_key == empty_value;\n+    }\n+\n+    template<typename Type>\n+    static void\n+    mark_deleted (Type &e)\n+    {\n+      e.m_key = deleted_value;\n+    }\n+\n+    template<typename Type>\n+    static void\n+    mark_empty (Type &e)\n+    {\n+      e.m_key = empty_value;\n+    }\n+  };\n+\n+  /* Getter for summary callgraph ID.  */\n+  T* get (int uid)\n+  {\n+    bool existed;\n+    T **v = &m_map.get_or_insert (uid, &existed);\n+    if (!existed)\n+      *v = allocate_new ();\n+\n+    return *v;\n+  }\n+\n+  /* Main summary store, where summary ID is used as key.  */\n+  hash_map <int, T *, summary_hashmap_traits> m_map;\n+  /* Internal summary insertion hook pointer.  */\n+  cgraph_node_hook_list *m_symtab_insertion_hook;\n+  /* Internal summary removal hook pointer.  */\n+  cgraph_node_hook_list *m_symtab_removal_hook;\n+  /* Internal summary duplication hook pointer.  */\n+  cgraph_2node_hook_list *m_symtab_duplication_hook;\n+  /* Indicates if insertion hook is enabled.  */\n+  bool m_insertion_enabled;\n+  /* Symbol table the summary is registered to.  */\n+  symbol_table *m_symtab;\n+\n+  template <typename U> friend void gt_ggc_mx (function_summary <U *> * const &);\n+  template <typename U> friend void gt_pch_nx (function_summary <U *> * const &);\n+  template <typename U> friend void gt_pch_nx (function_summary <U *> * const &,\n+      gt_pointer_operator, void *);\n+};\n+\n+template <typename T>\n+void\n+gt_ggc_mx(function_summary<T *>* const &summary)\n+{\n+  gcc_checking_assert (summary->m_ggc);\n+  gt_ggc_mx (&summary->m_map);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx(function_summary<T *>* const &summary)\n+{\n+  gcc_checking_assert (summary->m_ggc);\n+  gt_pch_nx (&summary->m_map);\n+}\n+\n+template <typename T>\n+void\n+gt_pch_nx(function_summary<T *>* const& summary, gt_pointer_operator op,\n+\t  void *cookie)\n+{\n+  gcc_checking_assert (summary->m_ggc);\n+  gt_pch_nx (&summary->m_map, op, cookie);\n+}\n+\n+#endif  /* GCC_SYMBOL_SUMMARY_H  */"}, {"sha": "7e06247f052c6ecbe3c0b4245eb22c0f328f349a", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4008290f65988de470218021818009fddeaf50dd/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4008290f65988de470218021818009fddeaf50dd/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4008290f65988de470218021818009fddeaf50dd", "patch": "@@ -92,6 +92,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dwarf2out.h\"\n #include \"bitmap.h\"\n #include \"ipa-reference.h\"\n+#include \"symbol-summary.h\"\n #include \"ipa-prop.h\"\n #include \"gcse.h\"\n #include \"insn-codes.h\"\n@@ -1212,7 +1213,7 @@ general_init (const char *argv0)\n   /* Create the singleton holder for global state.\n      Doing so also creates the pass manager and with it the passes.  */\n   g = new gcc::context ();\n-  symtab = ggc_cleared_alloc <symbol_table> ();\n+  symtab = new (ggc_cleared_alloc <symbol_table> ()) symbol_table ();\n \n   statistics_early_init ();\n   finish_params ();"}]}