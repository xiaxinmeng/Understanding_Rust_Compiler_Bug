{"sha": "09350e36ee3973f286340455d1e8c01506699f73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzNTBlMzZlZTM5NzNmMjg2MzQwNDU1ZDFlOGMwMTUwNjY5OWY3Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2005-07-20T11:12:26Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2005-07-20T11:12:26Z"}, "message": "bfin-protos.h (legitimize_pic_address): Don't declare.\n\n\t* config/bfin/bfin-protos.h (legitimize_pic_address): Don't declare.\n\t* config/bfin/bfin.c (legitimize_pic_address): Now static.  Take\n\textra arg \"picreg\" and use it instead of pic_offset_table_rtx.\n\tAll callers changed.\n\t(frame_related_constant_load): New arg \"related\" which controls\n\tsetting of RTX_FRAME_RELATED_P.  All callers changed.\n\t(bfin_load_pic_reg): New function, broken out of bfin_expand_prologue.\n\t(bfin_expand_prologue): Add stack limit checking.\n\t* config/bfin/bfin.md (trapifcc): New pattern.\n\nFrom-SVN: r102195", "tree": {"sha": "e9669b4398d2b9cbbb11f2e9f6d65e2c3ef9d3a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9669b4398d2b9cbbb11f2e9f6d65e2c3ef9d3a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09350e36ee3973f286340455d1e8c01506699f73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09350e36ee3973f286340455d1e8c01506699f73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09350e36ee3973f286340455d1e8c01506699f73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09350e36ee3973f286340455d1e8c01506699f73/comments", "author": null, "committer": null, "parents": [{"sha": "0590533746b2500bdb91af99562fe026f9a8e313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0590533746b2500bdb91af99562fe026f9a8e313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0590533746b2500bdb91af99562fe026f9a8e313"}], "stats": {"total": 275, "additions": 168, "deletions": 107}, "files": [{"sha": "da0313f1915ac0cdeaedfb50ba8d7fe4b3562247", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09350e36ee3973f286340455d1e8c01506699f73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09350e36ee3973f286340455d1e8c01506699f73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09350e36ee3973f286340455d1e8c01506699f73", "patch": "@@ -1,5 +1,15 @@\n 2005-07-20  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n+\t* config/bfin/bfin-protos.h (legitimize_pic_address): Don't declare.\n+\t* config/bfin/bfin.c (legitimize_pic_address): Now static.  Take\n+\textra arg \"picreg\" and use it instead of pic_offset_table_rtx.\n+\tAll callers changed.\n+\t(frame_related_constant_load): New arg \"related\" which controls\n+\tsetting of RTX_FRAME_RELATED_P.  All callers changed.\n+\t(bfin_load_pic_reg): New function, broken out of bfin_expand_prologue.\n+\t(bfin_expand_prologue): Add stack limit checking.\n+\t* config/bfin/bfin.md (trapifcc): New pattern.\n+\n \t* config/bfin/bfin.c: Include \"langhooks.h\".\n \t(def_builtin): Go through lang_hooks to call builtin_function.\n "}, {"sha": "ae38a07369d4b14f2b4e2a32e9e3319a1156e842", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09350e36ee3973f286340455d1e8c01506699f73/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09350e36ee3973f286340455d1e8c01506699f73/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=09350e36ee3973f286340455d1e8c01506699f73", "patch": "@@ -64,7 +64,6 @@ extern void print_operand (FILE *,  rtx, char);\n extern void print_address_operand (FILE *, rtx);\n extern void split_di (rtx [], int, rtx [], rtx []);\n extern int split_load_immediate (rtx []);\n-extern rtx legitimize_pic_address (rtx, rtx);\n extern void emit_pic_move (rtx *, Mmode);\n extern void override_options (void);\n extern void asm_conditional_branch (rtx, rtx *, int, int);"}, {"sha": "05541640c5629fd886f7c4d0357f718f47c04336", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 151, "deletions": 106, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09350e36ee3973f286340455d1e8c01506699f73/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09350e36ee3973f286340455d1e8c01506699f73/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=09350e36ee3973f286340455d1e8c01506699f73", "patch": "@@ -121,6 +121,93 @@ static e_funkind funkind (tree funtype)\n     return SUBROUTINE;\n }\n \f\n+/* Legitimize PIC addresses.  If the address is already position-independent,\n+   we return ORIG.  Newly generated position-independent addresses go into a\n+   reg.  This is REG if nonzero, otherwise we allocate register(s) as\n+   necessary.  PICREG is the register holding the pointer to the PIC offset\n+   table.  */\n+\n+rtx\n+legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n+{\n+  rtx addr = orig;\n+  rtx new = orig;\n+\n+  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n+    {\n+      if (GET_CODE (addr) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (addr))\n+\treg = new = orig;\n+      else\n+\t{\n+\t  if (reg == 0)\n+\t    {\n+\t      gcc_assert (!no_new_pseudos);\n+\t      reg = gen_reg_rtx (Pmode);\n+\t    }\n+\n+\t  if (flag_pic == 2)\n+\t    {\n+\t      emit_insn (gen_movsi_high_pic (reg, addr));\n+\t      emit_insn (gen_movsi_low_pic (reg, reg, addr));\n+\t      emit_insn (gen_addsi3 (reg, reg, picreg));\n+\t      new = gen_rtx_MEM (Pmode, reg);\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n+\t\t\t\t\tUNSPEC_MOVE_PIC);\n+\t      new = gen_rtx_MEM (Pmode,\n+\t\t\t\t gen_rtx_PLUS (Pmode, picreg, tmp));\n+\t    }\n+\t  emit_move_insn (reg, new);\n+\t}\n+      if (picreg == pic_offset_table_rtx)\n+\tcurrent_function_uses_pic_offset_table = 1;\n+      return reg;\n+    }\n+\n+  else if (GET_CODE (addr) == CONST || GET_CODE (addr) == PLUS)\n+    {\n+      rtx base;\n+\n+      if (GET_CODE (addr) == CONST)\n+\t{\n+\t  addr = XEXP (addr, 0);\n+\t  gcc_assert (GET_CODE (addr) == PLUS);\n+\t}\n+\n+      if (XEXP (addr, 0) == picreg)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\t{\n+\t  gcc_assert (!no_new_pseudos);\n+\t  reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      base = legitimize_pic_address (XEXP (addr, 0), reg, picreg);\n+      addr = legitimize_pic_address (XEXP (addr, 1),\n+\t\t\t\t     base == reg ? NULL_RTX : reg,\n+\t\t\t\t     picreg);\n+\n+      if (GET_CODE (addr) == CONST_INT)\n+\t{\n+\t  gcc_assert (! reload_in_progress && ! reload_completed);\n+\t  addr = force_reg (Pmode, addr);\n+\t}\n+\n+      if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n+\t{\n+\t  base = gen_rtx_PLUS (Pmode, base, XEXP (addr, 0));\n+\t  addr = XEXP (addr, 1);\n+\t}\n+\n+      return gen_rtx_PLUS (Pmode, base, addr);\n+    }\n+\n+  return new;\n+}\n+\f\n /* Stack frame layout. */\n \n /* Compute the number of DREGS to save with a push_multiple operation.\n@@ -422,11 +509,11 @@ bfin_initial_elimination_offset (int from, int to)\n }\n \n /* Emit code to load a constant CONSTANT into register REG; setting\n-   RTX_FRAME_RELATED_P on all insns we generate.  Make sure that the insns\n-   we generate need not be split.  */\n+   RTX_FRAME_RELATED_P on all insns we generate if RELATED is true.\n+   Make sure that the insns we generate need not be split.  */\n \n static void\n-frame_related_constant_load (rtx reg, HOST_WIDE_INT constant)\n+frame_related_constant_load (rtx reg, HOST_WIDE_INT constant, bool related)\n {\n   rtx insn;\n   rtx cst = GEN_INT (constant);\n@@ -438,10 +525,12 @@ frame_related_constant_load (rtx reg, HOST_WIDE_INT constant)\n       /* We don't call split_load_immediate here, since dwarf2out.c can get\n \t confused about some of the more clever sequences it can generate.  */\n       insn = emit_insn (gen_movsi_high (reg, cst));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      if (related)\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n       insn = emit_insn (gen_movsi_low (reg, reg, cst));\n     }\n-  RTX_FRAME_RELATED_P (insn) = 1;\n+  if (related)\n+    RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n /* Generate efficient code to add a value to the frame pointer.  We\n@@ -463,7 +552,7 @@ add_to_sp (rtx spreg, HOST_WIDE_INT value, int frame)\n       rtx insn;\n \n       if (frame)\n-\tframe_related_constant_load (tmpreg, value);\n+\tframe_related_constant_load (tmpreg, value, TRUE);\n       else\n \t{\n \t  insn = emit_move_insn (tmpreg, GEN_INT (value));\n@@ -529,7 +618,7 @@ emit_link_insn (rtx spreg, HOST_WIDE_INT frame_size)\n       /* Must use a call-clobbered PREG that isn't the static chain.  */\n       rtx tmpreg = gen_rtx_REG (Pmode, REG_P1);\n \n-      frame_related_constant_load (tmpreg, -frame_size);\n+      frame_related_constant_load (tmpreg, -frame_size, TRUE);\n       insn = emit_insn (gen_addsi3 (spreg, spreg, tmpreg));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n@@ -752,6 +841,24 @@ expand_interrupt_handler_epilogue (rtx spreg, e_funkind fkind)\n   emit_jump_insn (gen_return_internal (GEN_INT (fkind)));\n }\n \n+/* Used while emitting the prologue to generate code to load the correct value\n+   into the PIC register, which is passed in DEST.  */\n+\n+static void\n+bfin_load_pic_reg (rtx dest)\n+{\n+  rtx addr, insn;\n+      \n+  if (bfin_lib_id_given)\n+    addr = plus_constant (pic_offset_table_rtx, -4 - bfin_library_id * 4);\n+  else\n+    addr = gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\t\t UNSPEC_LIBRARY_OFFSET));\n+  insn = emit_insn (gen_movsi (dest, gen_rtx_MEM (Pmode, addr)));\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n+}\n+\n /* Generate RTL for the prologue of the current function.  */\n \n void\n@@ -761,33 +868,55 @@ bfin_expand_prologue (void)\n   HOST_WIDE_INT frame_size = get_frame_size ();\n   rtx spreg = gen_rtx_REG (Pmode, REG_SP);\n   e_funkind fkind = funkind (TREE_TYPE (current_function_decl));\n+  rtx pic_reg_loaded = NULL_RTX;\n \n   if (fkind != SUBROUTINE)\n     {\n       expand_interrupt_handler_prologue (spreg, fkind);\n       return;\n     }\n \n+  if (current_function_limit_stack)\n+    {\n+      HOST_WIDE_INT offset\n+\t= bfin_initial_elimination_offset (ARG_POINTER_REGNUM,\n+\t\t\t\t\t   STACK_POINTER_REGNUM);\n+      rtx lim = stack_limit_rtx;\n+\n+      if (GET_CODE (lim) == SYMBOL_REF)\n+\t{\n+\t  rtx p2reg = gen_rtx_REG (Pmode, REG_P2);\n+\t  if (TARGET_ID_SHARED_LIBRARY)\n+\t    {\n+\t      rtx p1reg = gen_rtx_REG (Pmode, REG_P1);\n+\t      rtx r3reg = gen_rtx_REG (Pmode, REG_R3);\n+\t      rtx val;\n+\t      pic_reg_loaded = p2reg;\n+\t      bfin_load_pic_reg (pic_reg_loaded);\n+\t      val = legitimize_pic_address (stack_limit_rtx, p1reg, p2reg);\n+\t      emit_move_insn (p1reg, val);\n+\t      frame_related_constant_load (p2reg, offset, FALSE);\n+\t      emit_insn (gen_addsi3 (p2reg, p2reg, p1reg));\n+\t      lim = p2reg;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx limit = plus_constant (stack_limit_rtx, offset);\n+\t      emit_move_insn (p2reg, limit);\n+\t      lim = p2reg;\n+\t    }\n+\t}\n+      emit_insn (gen_compare_lt (bfin_cc_rtx, spreg, lim));\n+      emit_insn (gen_trapifcc ());\n+    }\n   expand_prologue_reg_save (spreg, 0);\n \n   do_link (spreg, frame_size);\n \n   if (TARGET_ID_SHARED_LIBRARY\n       && (current_function_uses_pic_offset_table\n \t  || !current_function_is_leaf))\n-    {\n-      rtx addr;\n-      \n-      if (bfin_lib_id_given)\n-\taddr = plus_constant (pic_offset_table_rtx, -4 - bfin_library_id * 4);\n-      else\n-\taddr = gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n-\t\t\t     gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n-\t\t\t\t\t     UNSPEC_LIBRARY_OFFSET));\n-      insn = emit_insn (gen_movsi (pic_offset_table_rtx,\n-\t\t\t\t   gen_rtx_MEM (Pmode, addr)));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n-    }\n+    bfin_load_pic_reg (pic_offset_table_rtx);\n }\n \n /* Generate RTL for the epilogue of the current function.  NEED_RETURN is zero\n@@ -1374,91 +1503,6 @@ initialize_trampoline (tramp, fnaddr, cxt)\n   emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, t2));\n }\n \n-/* Legitimize PIC addresses.  If the address is already position-independent,\n-   we return ORIG.  Newly generated position-independent addresses go into a\n-   reg.  This is REG if nonzero, otherwise we allocate register(s) as\n-   necessary.  */\n-\n-rtx\n-legitimize_pic_address (rtx orig, rtx reg)\n-{\n-  rtx addr = orig;\n-  rtx new = orig;\n-\n-  if (GET_CODE (addr) == SYMBOL_REF || GET_CODE (addr) == LABEL_REF)\n-    {\n-      if (GET_CODE (addr) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (addr))\n-\treg = new = orig;\n-      else\n-\t{\n-\t  if (reg == 0)\n-\t    {\n-\t      gcc_assert (!no_new_pseudos);\n-\t      reg = gen_reg_rtx (Pmode);\n-\t    }\n-\n-\t  if (flag_pic == 2)\n-\t    {\n-\t      emit_insn (gen_movsi_high_pic (reg, addr));\n-\t      emit_insn (gen_movsi_low_pic (reg, reg, addr));\n-\t      emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));\n-\t      new = gen_rtx_MEM (Pmode, reg);\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n-\t\t\t\t\tUNSPEC_MOVE_PIC);\n-\t      new = gen_rtx_MEM (Pmode,\n-\t\t\t\t gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n-\t\t\t\t\t       tmp));\n-\t    }\n-\t  emit_move_insn (reg, new);\n-\t}\n-      current_function_uses_pic_offset_table = 1;\n-      return reg;\n-    }\n-\n-  else if (GET_CODE (addr) == CONST || GET_CODE (addr) == PLUS)\n-    {\n-      rtx base;\n-\n-      if (GET_CODE (addr) == CONST)\n-\t{\n-\t  addr = XEXP (addr, 0);\n-\t  gcc_assert (GET_CODE (addr) == PLUS);\n-\t}\n-\n-      if (XEXP (addr, 0) == pic_offset_table_rtx)\n-\treturn orig;\n-\n-      if (reg == 0)\n-\t{\n-\t  gcc_assert (!no_new_pseudos);\n-\t  reg = gen_reg_rtx (Pmode);\n-\t}\n-\n-      base = legitimize_pic_address (XEXP (addr, 0), reg);\n-      addr = legitimize_pic_address (XEXP (addr, 1),\n-\t\t\t\t     base == reg ? NULL_RTX : reg);\n-\n-      if (GET_CODE (addr) == CONST_INT)\n-\t{\n-\t  gcc_assert (! reload_in_progress && ! reload_completed);\n-\t  addr = force_reg (Pmode, addr);\n-\t}\n-\n-      if (GET_CODE (addr) == PLUS && CONSTANT_P (XEXP (addr, 1)))\n-\t{\n-\t  base = gen_rtx_PLUS (Pmode, base, XEXP (addr, 0));\n-\t  addr = XEXP (addr, 1);\n-\t}\n-\n-      return gen_rtx_PLUS (Pmode, base, addr);\n-    }\n-\n-  return new;\n-}\n-\n /* Emit insns to move operands[1] into operands[0].  */\n \n void\n@@ -1469,7 +1513,8 @@ emit_pic_move (rtx *operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n   if (GET_CODE (operands[0]) == MEM && SYMBOLIC_CONST (operands[1]))\n     operands[1] = force_reg (SImode, operands[1]);\n   else\n-    operands[1] = legitimize_pic_address (operands[1], temp);\n+    operands[1] = legitimize_pic_address (operands[1], temp,\n+\t\t\t\t\t  pic_offset_table_rtx);\n }\n \n /* Expand a move operation in mode MODE.  The operands are in OPERANDS.  */"}, {"sha": "1bbbacde7645d630ecead5adc582045d647a490c", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09350e36ee3973f286340455d1e8c01506699f73/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09350e36ee3973f286340455d1e8c01506699f73/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=09350e36ee3973f286340455d1e8c01506699f73", "patch": "@@ -1999,6 +1999,13 @@\n   \"ssync;\"\n   [(set_attr \"type\" \"sync\")])\n \n+(define_insn \"trapifcc\"\n+  [(trap_if (reg:BI REG_CC) (const_int 3))]\n+  \"\"\n+  \"if !cc jump 4 (bp); excpt 3;\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"4\")])\n+\n ;;; Vector instructions\n \n (define_insn \"addv2hi3\""}]}