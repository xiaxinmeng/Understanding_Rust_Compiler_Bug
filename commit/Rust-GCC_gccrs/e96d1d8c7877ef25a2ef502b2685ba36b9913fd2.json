{"sha": "e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2ZDFkOGM3ODc3ZWYyNWEyZWY1MDJiMjY4NWJhMzZiOTkxM2ZkMg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2018-12-07T10:33:30Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2018-12-07T10:33:30Z"}, "message": "Add a recursion limit to libiberty's demangling code.  The limit is enabled by default, but can be disabled via a new demangling option.\n\ninclude\t* demangle.h (DMGL_NO_RECURSE_LIMIT): Define.\n        (DEMANGLE_RECURSION_LIMIT): Define\n\n\tPR 87681\n\tPR 87675\n\tPR 87636\n\tPR 87350\n\tPR 87335\nlibiberty * cp-demangle.h (struct d_info): Add recursion_level field.\n\t* cp-demangle.c (d_function_type): Add recursion counter.\n\tIf the recursion limit is reached and the check is not disabled,\n\tthen return with a failure result.\n\t(cplus_demangle_init_info): Initialise the recursion_level field.\n        (d_demangle_callback): If the recursion limit is enabled, check\n\tfor a mangled string that is so long that there is not enough\n\tstack space for the local arrays.\n        * cplus-dem.c (struct work): Add recursion_level field.\n\t(squangle_mop_up): Set the numb and numk fields to zero.\n\t(work_stuff_copy_to_from): Handle the case where a btypevec or \n\tktypevec field is NULL.\n\t(demangle_nested_args): Add recursion counter.  If\n\tthe recursion limit is not disabled and reached, return with a\n\tfailure result.\n\nFrom-SVN: r266886", "tree": {"sha": "c7a769006e35e7c23d19c5fd82c84defb575f8bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7a769006e35e7c23d19c5fd82c84defb575f8bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0876cb1c7b291db11e1de0b2b2b13b28152c5823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0876cb1c7b291db11e1de0b2b2b13b28152c5823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0876cb1c7b291db11e1de0b2b2b13b28152c5823"}], "stats": {"total": 130, "additions": 117, "deletions": 13}, "files": [{"sha": "c26ddf4b4e33e5cbc917fc393dce1600ad72de4b", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "patch": "@@ -1,3 +1,8 @@\n+2018-12-07  Nick Clifton  <nickc@redhat.com>\n+\n+\t* demangle.h (DMGL_NO_RECURSE_LIMIT): Define.\n+        (DEMANGLE_RECURSION_LIMIT): Define\n+\n 2018-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gomp-constants.h (GOMP_TASK_FLAG_REDUCTION,"}, {"sha": "1e67fe2fb349da386abc6cf6264617339854f8db", "filename": "include/demangle.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "patch": "@@ -68,6 +68,17 @@ extern \"C\" {\n /* If none of these are set, use 'current_demangling_style' as the default. */\n #define DMGL_STYLE_MASK (DMGL_AUTO|DMGL_GNU|DMGL_LUCID|DMGL_ARM|DMGL_HP|DMGL_EDG|DMGL_GNU_V3|DMGL_JAVA|DMGL_GNAT|DMGL_DLANG|DMGL_RUST)\n \n+/* Disable a limit on the depth of recursion in mangled strings.\n+   Note if this limit is disabled then stack exhaustion is possible when\n+   demangling pathologically complicated strings.  Bug reports about stack\n+   exhaustion when the option is enabled will be rejected.  */  \n+#define DMGL_NO_RECURSE_LIMIT (1 << 18)\t\n+\n+/* If DMGL_NO_RECURSE_LIMIT is not enabled, then this is the value used as\n+   the maximum depth of recursion allowed.  It should be enough for any\n+   real-world mangled name.  */\n+#define DEMANGLE_RECURSION_LIMIT 1024\n+  \n /* Enumeration of possible demangling styles.\n \n    Lucid and ARM styles are still kept logically distinct, even though"}, {"sha": "5772008976ed59ed08cd5a58330686df00dcd8a7", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "patch": "@@ -1,3 +1,26 @@\n+2018-12-07  Nick Clifton  <nickc@redhat.com>\n+\n+\tPR 87681\n+\tPR 87675\n+\tPR 87636\n+\tPR 87350\n+\tPR 87335\n+\t* cp-demangle.h (struct d_info): Add recursion_level field.\n+\t* cp-demangle.c (d_function_type): Add recursion counter.\n+\tIf the recursion limit is reached and the check is not disabled,\n+\tthen return with a failure result.\n+\t(cplus_demangle_init_info): Initialise the recursion_level field.\n+        (d_demangle_callback): If the recursion limit is enabled, check\n+\tfor a mangled string that is so long that there is not enough\n+\tstack space for the local arrays.\n+        * cplus-dem.c (struct work): Add recursion_level field.\n+\t(squangle_mop_up): Set the numb and numk fields to zero.\n+\t(work_stuff_copy_to_from): Handle the case where a btypevec or\n+\tktypevec field is NULL.\n+\t(demangle_nested_args): Add recursion counter.  If\n+\tthe recursion limit is not disabled and reached, return with a\n+\tfailure result.\n+\n 2018-10-23  Jason Merrill  <jason@redhat.com>\n \n \tImplement P0732R2, class types in non-type template parameters."}, {"sha": "47bbc947f143d132c29ec71c5676ccfa4bdf6ff5", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "patch": "@@ -2852,21 +2852,35 @@ d_ref_qualifier (struct d_info *di, struct demangle_component *sub)\n static struct demangle_component *\n d_function_type (struct d_info *di)\n {\n-  struct demangle_component *ret;\n+  struct demangle_component *ret = NULL;\n \n-  if (! d_check_char (di, 'F'))\n-    return NULL;\n-  if (d_peek_char (di) == 'Y')\n+  if ((di->options & DMGL_NO_RECURSE_LIMIT) == 0)\n     {\n-      /* Function has C linkage.  We don't print this information.\n-\t FIXME: We should print it in verbose mode.  */\n-      d_advance (di, 1);\n+      if (di->recursion_level > DEMANGLE_RECURSION_LIMIT)\n+\t/* FIXME: There ought to be a way to report\n+\t   that the recursion limit has been reached.  */\n+\treturn NULL;\n+\n+      di->recursion_level ++;\n     }\n-  ret = d_bare_function_type (di, 1);\n-  ret = d_ref_qualifier (di, ret);\n \n-  if (! d_check_char (di, 'E'))\n-    return NULL;\n+  if (d_check_char (di, 'F'))\n+    {\n+      if (d_peek_char (di) == 'Y')\n+\t{\n+\t  /* Function has C linkage.  We don't print this information.\n+\t     FIXME: We should print it in verbose mode.  */\n+\t  d_advance (di, 1);\n+\t}\n+      ret = d_bare_function_type (di, 1);\n+      ret = d_ref_qualifier (di, ret);\n+      \n+      if (! d_check_char (di, 'E'))\n+\tret = NULL;\n+    }\n+\n+  if ((di->options & DMGL_NO_RECURSE_LIMIT) == 0)\n+    di->recursion_level --;\n   return ret;\n }\n \n@@ -6203,6 +6217,7 @@ cplus_demangle_init_info (const char *mangled, int options, size_t len,\n   di->expansion = 0;\n   di->is_expression = 0;\n   di->is_conversion = 0;\n+  di->recursion_level = 0;\n }\n \n /* Internal implementation for the demangler.  If MANGLED is a g++ v3 ABI\n@@ -6242,6 +6257,20 @@ d_demangle_callback (const char *mangled, int options,\n \n   cplus_demangle_init_info (mangled, options, strlen (mangled), &di);\n \n+  /* PR 87675 - Check for a mangled string that is so long\n+     that we do not have enough stack space to demangle it.  */\n+  if (((options & DMGL_NO_RECURSE_LIMIT) == 0)\n+      /* This check is a bit arbitrary, since what we really want to do is to\n+\t compare the sizes of the di.comps and di.subs arrays against the\n+\t amount of stack space remaining.  But there is no portable way to do\n+\t this, so instead we use the recursion limit as a guide to the maximum\n+\t size of the arrays.  */\n+      && (unsigned long) di.num_comps > DEMANGLE_RECURSION_LIMIT)\n+    {\n+      /* FIXME: We need a way to indicate that a stack limit has been reached.  */\n+      return 0;\n+    }\n+\n   {\n #ifdef CP_DYNAMIC_ARRAYS\n     __extension__ struct demangle_component comps[di.num_comps];"}, {"sha": "d87a830bb3155c87a1b91d36c87fcd33173d331f", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "patch": "@@ -122,6 +122,9 @@ struct d_info\n   /* Non-zero if we are parsing the type operand of a conversion\n      operator, but not when in an expression.  */\n   int is_conversion;\n+  /* If DMGL_NO_RECURSE_LIMIT is not active then this is set to\n+     the current recursion level.  */\n+  unsigned int recursion_level;\n };\n \n /* To avoid running past the ending '\\0', don't:"}, {"sha": "48c0cfd848a081220d7cf4422eb2e6f4bf4ed89d", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96d1d8c7877ef25a2ef502b2685ba36b9913fd2/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=e96d1d8c7877ef25a2ef502b2685ba36b9913fd2", "patch": "@@ -146,6 +146,7 @@ struct work_stuff\n   int *proctypevec;     /* Indices of currently processed remembered typevecs.  */\n   int proctypevec_size;\n   int nproctypes;\n+  unsigned int recursion_level;\n };\n \n #define PRINT_ANSI_QUALIFIERS (work -> options & DMGL_ANSI)\n@@ -1292,12 +1293,14 @@ squangle_mop_up (struct work_stuff *work)\n       free ((char *) work -> btypevec);\n       work->btypevec = NULL;\n       work->bsize = 0;\n+      work->numb = 0;\n     }\n   if (work -> ktypevec != NULL)\n     {\n       free ((char *) work -> ktypevec);\n       work->ktypevec = NULL;\n       work->ksize = 0;\n+      work->numk = 0;\n     }\n }\n \n@@ -1331,8 +1334,15 @@ work_stuff_copy_to_from (struct work_stuff *to, struct work_stuff *from)\n \n   for (i = 0; i < from->numk; i++)\n     {\n-      int len = strlen (from->ktypevec[i]) + 1;\n+      int len;\n+\n+      if (from->ktypevec[i] == NULL)\n+\t{\n+\t  to->ktypevec[i] = NULL;\n+\t  continue;\n+\t}\n \n+      len = strlen (from->ktypevec[i]) + 1;\n       to->ktypevec[i] = XNEWVEC (char, len);\n       memcpy (to->ktypevec[i], from->ktypevec[i], len);\n     }\n@@ -1342,8 +1352,15 @@ work_stuff_copy_to_from (struct work_stuff *to, struct work_stuff *from)\n \n   for (i = 0; i < from->numb; i++)\n     {\n-      int len = strlen (from->btypevec[i]) + 1;\n+      int len;\n+\n+      if (from->btypevec[i] == NULL)\n+\t{\n+\t  to->btypevec[i] = NULL;\n+\t  continue;\n+\t}\n \n+      len = strlen (from->btypevec[i]) + 1;\n       to->btypevec[i] = XNEWVEC (char , len);\n       memcpy (to->btypevec[i], from->btypevec[i], len);\n     }\n@@ -1401,6 +1418,7 @@ delete_non_B_K_work_stuff (struct work_stuff *work)\n \n       free ((char*) work->tmpl_argvec);\n       work->tmpl_argvec = NULL;\n+      work->ntmpl_args = 0;\n     }\n   if (work->previous_argument)\n     {\n@@ -4478,6 +4496,7 @@ remember_Btype (struct work_stuff *work, const char *start,\n }\n \n /* Lose all the info related to B and K type codes. */\n+\n static void\n forget_B_and_K_types (struct work_stuff *work)\n {\n@@ -4503,6 +4522,7 @@ forget_B_and_K_types (struct work_stuff *work)\n \t}\n     }\n }\n+\n /* Forget the remembered types, but not the type vector itself.  */\n \n static void\n@@ -4697,6 +4717,16 @@ demangle_nested_args (struct work_stuff *work, const char **mangled,\n   int result;\n   int saved_nrepeats;\n \n+  if ((work->options & DMGL_NO_RECURSE_LIMIT) == 0)\n+    {\n+      if (work->recursion_level > DEMANGLE_RECURSION_LIMIT)\n+\t/* FIXME: There ought to be a way to report\n+\t   that the recursion limit has been reached.  */\n+\treturn 0;\n+\n+      work->recursion_level ++;\n+    }\n+\n   /* The G++ name-mangling algorithm does not remember types on nested\n      argument lists, unless -fsquangling is used, and in that case the\n      type vector updated by remember_type is not used.  So, we turn\n@@ -4723,6 +4753,9 @@ demangle_nested_args (struct work_stuff *work, const char **mangled,\n   --work->forgetting_types;\n   work->nrepeats = saved_nrepeats;\n \n+  if ((work->options & DMGL_NO_RECURSE_LIMIT) == 0)\n+    --work->recursion_level;\n+\n   return result;\n }\n "}]}