{"sha": "82957a739c9ed37cc78d3cabfc61d04549e65867", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI5NTdhNzM5YzllZDM3Y2M3OGQzY2FiZmM2MWQwNDU0OWU2NTg2Nw==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2018-10-04T13:36:20Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2018-10-04T13:36:20Z"}, "message": "re PR rtl-optimization/87466 (IRA and LRA spill all pseudos that are live across setjmp calls)\n\ngcc/\n\tPR rtl-optimization/87466\n\t* target.def (setjmp_preserves_nonvolatile_regs_p): New target hook.\n\t* doc/tm.texi.in (TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* ira-lives.c (process_bb_node_lives): Use the new target hook.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* config/rs6000/rs6000.c (TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P):\n\tDefine.\n\ngcc/testsuite/\n\tPR rtl-optimization/87466\n\t* gcc.target/powerpc/pr87466.c: New test.\n\nFrom-SVN: r264842", "tree": {"sha": "c6391a013b017f1777208b69af63b59bb49804f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6391a013b017f1777208b69af63b59bb49804f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82957a739c9ed37cc78d3cabfc61d04549e65867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82957a739c9ed37cc78d3cabfc61d04549e65867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82957a739c9ed37cc78d3cabfc61d04549e65867", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82957a739c9ed37cc78d3cabfc61d04549e65867/comments", "author": null, "committer": null, "parents": [{"sha": "ac712e4eb43f3dd8d7f12624ea4014ecb2a9cf34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac712e4eb43f3dd8d7f12624ea4014ecb2a9cf34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac712e4eb43f3dd8d7f12624ea4014ecb2a9cf34"}], "stats": {"total": 62, "additions": 58, "deletions": 4}, "files": [{"sha": "7036fd71c1e0dc26f2db2b6ed1d795ab40411c2e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=82957a739c9ed37cc78d3cabfc61d04549e65867", "patch": "@@ -1978,6 +1978,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_ASM_GLOBALIZE_DECL_NAME\n #define TARGET_ASM_GLOBALIZE_DECL_NAME rs6000_globalize_decl_name\n #endif\n+\n+#undef TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P\n+#define TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P hook_bool_void_true\n \f\n \n /* Processor table.  */"}, {"sha": "0fcf8069b8cc948fcaf5604a1235fe269de7e8f3", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=82957a739c9ed37cc78d3cabfc61d04549e65867", "patch": "@@ -11008,6 +11008,19 @@ In order to enforce the representation of @code{mode},\n @code{mode}.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P (void)\n+On some targets, it is assumed that the compiler will spill all pseudos\n+  that are live across a call to @code{setjmp}, while other targets treat\n+  @code{setjmp} calls as normal function calls.\n+  \n+  This hook returns false if @code{setjmp} calls do not preserve all\n+  non-volatile registers so that gcc that must spill all pseudos that are\n+  live across @code{setjmp} calls.  Define this to return true if the\n+  target does not need to spill all pseudos live across @code{setjmp} calls.\n+  The default implementation conservatively assumes all pseudos must be\n+  spilled across @code{setjmp} calls.\n+@end deftypefn\n+\n @defmac STORE_FLAG_VALUE\n A C expression describing the value returned by a comparison operator\n with an integral mode and stored by a store-flag instruction"}, {"sha": "63b0c0a98aae660c618a5ecaac4b8462d6eebd38", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=82957a739c9ed37cc78d3cabfc61d04549e65867", "patch": "@@ -7509,6 +7509,8 @@ You need not define this macro if it would always have the value of zero.\n \n @hook TARGET_MODE_REP_EXTENDED\n \n+@hook TARGET_SETJMP_PRESERVES_NONVOLATILE_REGS_P\n+\n @defmac STORE_FLAG_VALUE\n A C expression describing the value returned by a comparison operator\n with an integral mode and stored by a store-flag instruction"}, {"sha": "f1a7d2797b2eb20b38617f340928ce91cac72092", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=82957a739c9ed37cc78d3cabfc61d04549e65867", "patch": "@@ -1207,8 +1207,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t     call, if this function receives a nonlocal\n \t\t     goto.  */\n \t\t  if (cfun->has_nonlocal_label\n-\t\t      || find_reg_note (insn, REG_SETJMP,\n-\t\t\t\t\tNULL_RTX) != NULL_RTX)\n+\t\t      || (!targetm.setjmp_preserves_nonvolatile_regs_p ()\n+\t\t\t  && (find_reg_note (insn, REG_SETJMP, NULL_RTX)\n+\t\t\t      != NULL_RTX)))\n \t\t    {\n \t\t      SET_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj));\n \t\t      SET_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj));"}, {"sha": "a3bc29c033db200313b669c55a7cec3fac7d8dcc", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=82957a739c9ed37cc78d3cabfc61d04549e65867", "patch": "@@ -895,8 +895,9 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t  sparseset_ior (pseudos_live_through_calls,\n \t\t\t pseudos_live_through_calls, pseudos_live);\n \t  if (cfun->has_nonlocal_label\n-\t      || find_reg_note (curr_insn, REG_SETJMP,\n-\t\t\t\tNULL_RTX) != NULL_RTX)\n+\t      || (!targetm.setjmp_preserves_nonvolatile_regs_p ()\n+\t\t  && (find_reg_note (curr_insn, REG_SETJMP, NULL_RTX)\n+\t\t      != NULL_RTX)))\n \t    sparseset_ior (pseudos_live_through_setjumps,\n \t\t\t   pseudos_live_through_setjumps, pseudos_live);\n \t}"}, {"sha": "ad27d352ca40feb92212a733d974aca7ed8e10f1", "filename": "gcc/target.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=82957a739c9ed37cc78d3cabfc61d04549e65867", "patch": "@@ -3123,6 +3123,21 @@ In order to enforce the representation of @code{mode},\\n\\\n  int, (scalar_int_mode mode, scalar_int_mode rep_mode),\n  default_mode_rep_extended)\n \n+ DEFHOOK\n+(setjmp_preserves_nonvolatile_regs_p,\n+ \"On some targets, it is assumed that the compiler will spill all pseudos\\n\\\n+  that are live across a call to @code{setjmp}, while other targets treat\\n\\\n+  @code{setjmp} calls as normal function calls.\\n\\\n+  \\n\\\n+  This hook returns false if @code{setjmp} calls do not preserve all\\n\\\n+  non-volatile registers so that gcc that must spill all pseudos that are\\n\\\n+  live across @code{setjmp} calls.  Define this to return true if the\\n\\\n+  target does not need to spill all pseudos live across @code{setjmp} calls.\\n\\\n+  The default implementation conservatively assumes all pseudos must be\\n\\\n+  spilled across @code{setjmp} calls.\",\n+ bool, (void),\n+ hook_bool_void_false)\n+\n /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n DEFHOOK\n (valid_pointer_mode,"}, {"sha": "2bb292cfed1f8658e473d067a8a9db887a4772ca", "filename": "gcc/testsuite/gcc.target/powerpc/pr87466.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87466.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82957a739c9ed37cc78d3cabfc61d04549e65867/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87466.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr87466.c?ref=82957a739c9ed37cc78d3cabfc61d04549e65867", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdlib.h>\n+#include <setjmp.h>\n+\n+extern void foo (jmp_buf);\n+\n+long\n+c (long var)\n+{\n+  jmp_buf env;\n+  if (setjmp(env) != 0)\n+    abort();\n+  foo (env);\n+  return var;\n+}\n+\n+/* { dg-final { scan-assembler {\\mmr\\M} } } */"}]}