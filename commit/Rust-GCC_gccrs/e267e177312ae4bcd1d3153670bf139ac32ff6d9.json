{"sha": "e267e177312ae4bcd1d3153670bf139ac32ff6d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI2N2UxNzczMTJhZTRiY2QxZDMxNTM2NzBiZjEzOWFjMzJmZjZkOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-01-25T12:42:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-25T12:42:25Z"}, "message": "sparc-protos.h (select_cc_mode): Declare.\n\n        * sparc-protos.h (select_cc_mode): Declare.\n        * sparc.c (select_cc_mode): New.  Handle unordered compares.\n        (output_cbranch): Always reverse via code change.  Handle\n        unordered compares.  Factor tests and string updates.\n        * sparc.h (SELECT_CC_MODE): Split out to select_cc_mode.\n        (REVERSIBLE_CC_MODE): Also exclude CCFPmode.\n        * sparc.md (bunordered, bordered): New.\n        (bungt, bunlt, buneq, bunge, bunle): New.\n\nFrom-SVN: r31609", "tree": {"sha": "13a12c95c0e35b5898cc2ae0ab7d7163c4417461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13a12c95c0e35b5898cc2ae0ab7d7163c4417461"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e267e177312ae4bcd1d3153670bf139ac32ff6d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e267e177312ae4bcd1d3153670bf139ac32ff6d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e267e177312ae4bcd1d3153670bf139ac32ff6d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e267e177312ae4bcd1d3153670bf139ac32ff6d9/comments", "author": null, "committer": null, "parents": [{"sha": "ddcc7cf6c826a0e81831743104d24d0b7aad52f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddcc7cf6c826a0e81831743104d24d0b7aad52f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddcc7cf6c826a0e81831743104d24d0b7aad52f8"}], "stats": {"total": 478, "additions": 340, "deletions": 138}, "files": [{"sha": "46a83ac76ab7082240a6c238ebae9bba80fb45dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e267e177312ae4bcd1d3153670bf139ac32ff6d9", "patch": "@@ -1,3 +1,14 @@\n+2000-01-25  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sparc-protos.h (select_cc_mode): Declare.\n+\t* sparc.c (select_cc_mode): New.  Handle unordered compares.\n+\t(output_cbranch): Always reverse via code change.  Handle\n+\tunordered compares.  Factor tests and string updates.\n+\t* sparc.h (SELECT_CC_MODE): Split out to select_cc_mode.\n+\t(REVERSIBLE_CC_MODE): Also exclude CCFPmode.\n+\t* sparc.md (bunordered, bordered): New.\n+\t(bungt, bunlt, buneq, bunge, bunle): New.\n+\n 2000-01-25  Richard Henderson  <rth@cygnus.com>\n \n \t* dwarf2out.c (dwarf2out_init): Use ggc_add_rtx_varray_root."}, {"sha": "c9c79a0ca367ff1e42b20231bc08b3d80f909e62", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=e267e177312ae4bcd1d3153670bf139ac32ff6d9", "patch": "@@ -77,6 +77,7 @@ extern void sparc_flat_save_restore PARAMS ((FILE *, const char *,\n \t\t\t\t\t     const char *, unsigned long));\n \n #ifdef RTX_CODE\n+extern enum machine_mode select_cc_mode PARAMS ((enum rtx_code, rtx, rtx));\n /* Define the function that build the compare insn for scc and bcc.  */\n extern rtx gen_compare_reg PARAMS ((enum rtx_code code, rtx, rtx));\n extern void sparc_emit_float_lib_cmp PARAMS ((rtx, rtx, enum rtx_code));"}, {"sha": "f459832d8f1c8e1c32ddadf9e2e6f45634fbcaca", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 197, "deletions": 130, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e267e177312ae4bcd1d3153670bf139ac32ff6d9", "patch": "@@ -2072,6 +2072,61 @@ sparc_emit_set_const64 (op0, op1)\n   sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits);\n }\n \n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  For floating-point,\n+   CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand\n+   is a PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special\n+   processing is needed.  */\n+\n+enum machine_mode\n+select_cc_mode (op, x, y)\n+     enum rtx_code op;\n+     rtx x;\n+     rtx y ATTRIBUTE_UNUSED;\n+{\n+  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+    {\n+      switch (op)\n+\t{\n+\tcase EQ:\n+\tcase NE:\n+\tcase UNORDERED:\n+\tcase ORDERED:\n+\tcase UNLT:\n+\tcase UNLE:\n+\tcase UNGT:\n+\tcase UNGE:\n+\tcase UNEQ:\n+\tcase UNNE:\n+\t  return CCFPmode;\n+\n+\tcase LT:\n+\tcase LE:\n+\tcase GT:\n+\tcase GE:\n+\t  return CCFPEmode;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  else if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\n+\t   || GET_CODE (x) == NEG || GET_CODE (x) == ASHIFT)\n+    {\n+      if (TARGET_ARCH64 && GET_MODE (x) == DImode)\n+\treturn CCX_NOOVmode;\n+      else\n+\treturn CC_NOOVmode;\n+    }\n+  else\n+    {\n+      if (TARGET_ARCH64 && GET_MODE (x) == DImode)\n+\treturn CCXmode;\n+      else\n+\treturn CCmode;\n+    }\n+}\n+\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for the cc reg in the proper mode.  */\n \n@@ -4583,6 +4638,7 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n   static char v9_xcc_labelno[] = \"%%xcc, %lX\";\n   static char v9_fcc_labelno[] = \"%%fccX, %lY\";\n   char *labelno;\n+  const char *branch;\n   int labeloff, spaces = 8;\n \n   /* ??? !v9: FP branches cannot be preceded by another floating point insn.\n@@ -4594,147 +4650,158 @@ output_cbranch (op, label, reversed, annul, noop, insn)\n   else\n     string[0] = '\\0';\n \n-  /* If not floating-point or if EQ or NE, we can just reverse the code.  */\n-  if (reversed\n-      && ((mode != CCFPmode && mode != CCFPEmode) || code == EQ || code == NE))\n-    code = reverse_condition (code), reversed = 0;\n-\n-  /* Start by writing the branch condition.  */\n-  switch (code)\n+  if (reversed)\n     {\n-    case NE:\n-      if (mode == CCFPmode || mode == CCFPEmode)\n-\t{\n-\t  strcat (string, \"fbne\");\n-\t  spaces -= 4;\n-\t}\n-      else\n-\t{\n-\t  strcpy (string, \"bne\");\n-\t  spaces -= 3;\n-\t}\n-      break;\n-\n-    case EQ:\n-      if (mode == CCFPmode || mode == CCFPEmode)\n-\t{\n-\t  strcat (string, \"fbe\");\n-\t  spaces -= 3;\n-\t}\n-      else\n-\t{\n-\t  strcpy (string, \"be\");\n-\t  spaces -= 2;\n-\t}\n-      break;\n-\n-    case GE:\n+      /* Reversal of FP compares takes care -- an ordered compare\n+\t becomes an unordered compare and vice versa.  */\n       if (mode == CCFPmode || mode == CCFPEmode)\n \t{\n-\t  if (reversed)\n-\t    strcat (string, \"fbul\");\n-\t  else\n-\t    strcat (string, \"fbge\");\n-\t  spaces -= 4;\n-\t}\n-      else if (mode == CC_NOOVmode)\n-\t{\n-\t  strcpy (string, \"bpos\");\n-\t  spaces -= 4;\n-\t}\n-      else\n-\t{\n-\t  strcpy (string, \"bge\");\n-\t  spaces -= 3;\n-\t}\n-      break;\n-\n-    case GT:\n-      if (mode == CCFPmode || mode == CCFPEmode)\n-\t{\n-\t  if (reversed)\n+\t  switch (code)\n \t    {\n-\t      strcat (string, \"fbule\");\n-\t      spaces -= 5;\n-\t    }\n-\t  else\n-\t    {\n-\t      strcat (string, \"fbg\");\n-\t      spaces -= 3;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  strcpy (string, \"bg\");\n-\t  spaces -= 2;\n-\t}\n-      break;\n-\n-    case LE:\n-      if (mode == CCFPmode || mode == CCFPEmode)\n-\t{\n-\t  if (reversed)\n-\t    strcat (string, \"fbug\");\n-\t  else\n-\t    strcat (string, \"fble\");\n-\t  spaces -= 4;\n-\t}\n-      else\n-\t{\n-\t  strcpy (string, \"ble\");\n-\t  spaces -= 3;\n-\t}\n-      break;\n+\t    case EQ:\n+\t      code = NE;\n+\t      break;\n+\t    case NE:\n+\t      code = EQ;\n+\t      break;\n+\t    case GE:\n+\t      code = UNLT;\n+\t      break;\n+\t    case GT:\n+\t      code = UNLE;\n+\t      break;\n+\t    case LE:\n+\t      code = UNGT;\n+\t      break;\n+\t    case LT:\n+\t      code = UNGE;\n+\t      break;\n+\t    case UNORDERED:\n+\t      code = ORDERED;\n+\t      break;\n+\t    case ORDERED:\n+\t      code = UNORDERED;\n+\t      break;\n+\t    case UNGT:\n+\t      code = LE;\n+\t      break;\n+\t    case UNLT:\n+\t      code = GE;\n+\t      break;\n+\t    case UNEQ:\n+\t      /* ??? We don't have a \"less or greater\" rtx code.  */\n+\t      code = UNKNOWN;\n+\t      break;\n+\t    case UNGE:\n+\t      code = LT;\n+\t      break;\n+\t    case UNLE:\n+\t      code = GT;\n+\t      break;\n \n-    case LT:\n-      if (mode == CCFPmode || mode == CCFPEmode)\n-\t{\n-\t  if (reversed)\n-\t    {\n-\t      strcat (string, \"fbuge\");\n-\t      spaces -= 5;\n+\t    default:\n+\t      abort ();\n \t    }\n-\t  else\n-\t    {\n-\t      strcat (string, \"fbl\");\n-\t      spaces -= 3;\n-\t    }\n-\t}\n-      else if (mode == CC_NOOVmode)\n-\t{\n-\t  strcpy (string, \"bneg\");\n-\t  spaces -= 4;\n \t}\n       else\n-\t{\n-\t  strcpy (string, \"bl\");\n-\t  spaces -= 2;\n-\t}\n-      break;\n-\n-    case GEU:\n-      strcpy (string, \"bgeu\");\n-      spaces -= 4;\n-      break;\n-\n-    case GTU:\n-      strcpy (string, \"bgu\");\n-      spaces -= 3;\n-      break;\n+\tcode = reverse_condition (code);\n+    }\n \n-    case LEU:\n-      strcpy (string, \"bleu\");\n-      spaces -= 4;\n-      break;\n+  /* Start by writing the branch condition.  */\n+  if (mode == CCFPmode || mode == CCFPEmode)\n+    switch (code)\n+      {\n+      case NE:\n+\tbranch = \"fbne\";\n+\tbreak;\n+      case EQ:\n+\tbranch = \"fbe\";\n+\tbreak;\n+      case GE:\n+\tbranch = \"fbge\";\n+\tbreak;\n+      case GT:\n+\tbranch = \"fbg\";\n+\tbreak;\n+      case LE:\n+\tbranch = \"fble\";\n+\tbreak;\n+      case LT:\n+\tbranch = \"fbl\";\n+\tbreak;\n+      case UNORDERED:\n+\tbranch = \"fbu\";\n+\tbreak;\n+      case ORDERED:\n+\tbranch = \"fbo\";\n+\tbreak;\n+      case UNGT:\n+\tbranch = \"fbug\";\n+\tbreak;\n+      case UNLT:\n+\tbranch = \"fbul\";\n+\tbreak;\n+      case UNEQ:\n+\tbranch = \"fbue\";\n+\tbreak;\n+      case UNGE:\n+\tbranch = \"fbuge\";\n+\tbreak;\n+      case UNLE:\n+\tbranch = \"fbule\";\n+\tbreak;\n+      case UNKNOWN:\n+\tbranch = \"fblg\";\n+\tbreak;\n \n-    case LTU:\n-      strcpy (string, \"blu\");\n-      spaces -= 3;\n-      break;\n+      default:\n+\tabort ();\n+      }\n+  else\n+    switch (code)\n+      {\n+      case NE:\n+\tbranch = \"bne\";\n+\tbreak;\n+      case EQ:\n+\tbranch = \"be\";\n+\tbreak;\n+      case GE:\n+\tif (mode == CC_NOOVmode)\n+\t  branch = \"bpos\";\n+\telse\n+\t  branch = \"bge\";\n+\tbreak;\n+      case GT:\n+\tbranch = \"bg\";\n+\tbreak;\n+      case LE:\n+\tbranch = \"ble\";\n+\tbreak;\n+      case LT:\n+\tif (mode == CC_NOOVmode)\n+\t  branch = \"bneg\";\n+\telse\n+\t  branch = \"bl\";\n+\tbreak;\n+      case GEU:\n+\tbranch = \"bgeu\";\n+\tbreak;\n+      case GTU:\n+\tbranch = \"bgu\";\n+\tbreak;\n+      case LEU:\n+\tbranch = \"bleu\";\n+\tbreak;\n+      case LTU:\n+\tbranch = \"blu\";\n+\tbreak;\n \n-    default:\n-      abort ();\n-    }\n+      default:\n+\tabort ();\n+      }\n+  strcpy (string, branch);\n+  spaces -= strlen (branch);\n \n   /* Now add the annulling, the label, and a possible noop.  */\n   if (annul)"}, {"sha": "02f01160ba4a251b90cec67c23ccd084cb9b6190", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e267e177312ae4bcd1d3153670bf139ac32ff6d9", "patch": "@@ -2672,18 +2672,12 @@ do {                                                                    \\\n    CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand is a\n    PLUS, MINUS, NEG, or ASHIFT.  CCmode should be used when no special\n    processing is needed.  */\n-#define SELECT_CC_MODE(OP,X,Y) \\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\t\\\n-   ? ((OP == EQ || OP == NE) ? CCFPmode : CCFPEmode)\t\t\t\\\n-   : ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\t\\\n-       || GET_CODE (X) == NEG || GET_CODE (X) == ASHIFT)\t\t\\\n-      ? (TARGET_ARCH64 && GET_MODE (X) == DImode ? CCX_NOOVmode : CC_NOOVmode) \\\n-      : ((TARGET_ARCH64 || TARGET_V8PLUS) && GET_MODE (X) == DImode ? CCXmode : CCmode)))\n+#define SELECT_CC_MODE(OP,X,Y)  select_cc_mode ((OP), (X), (Y))\n \n /* Return non-zero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n \n-#define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode)\n+#define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode && (MODE) != CCFPmode)\n \n /* A function address in a call instruction\n    is a byte address (for indexing purposes)"}, {"sha": "ac8f9aa4f23d72cf972f35f2c65db24421d5143e", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e267e177312ae4bcd1d3153670bf139ac32ff6d9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e267e177312ae4bcd1d3153670bf139ac32ff6d9", "patch": "@@ -1794,6 +1794,135 @@\n   \"\n { operands[1] = gen_compare_reg (LEU, sparc_compare_op0, sparc_compare_op1);\n }\")\n+\n+(define_expand \"bunordered\"\n+  [(set (pc)\n+\t(if_then_else (unordered (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1,\n+\t\t\t\tUNORDERED);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (UNORDERED, sparc_compare_op0,\n+\t\t\t\t sparc_compare_op1);\n+}\")\n+\n+(define_expand \"bordered\"\n+  [(set (pc)\n+\t(if_then_else (ordered (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, ORDERED);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (ORDERED, sparc_compare_op0,\n+\t\t\t\t sparc_compare_op1);\n+}\")\n+\n+(define_expand \"bungt\"\n+  [(set (pc)\n+\t(if_then_else (ungt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGT);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (UNGT, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"bunlt\"\n+  [(set (pc)\n+\t(if_then_else (unlt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLT);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (UNLT, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"buneq\"\n+  [(set (pc)\n+\t(if_then_else (uneq (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNEQ);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (UNEQ, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"bunge\"\n+  [(set (pc)\n+\t(if_then_else (unge (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGE);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (UNGE, sparc_compare_op0, sparc_compare_op1);\n+}\")\n+\n+(define_expand \"bunle\"\n+  [(set (pc)\n+\t(if_then_else (unle (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE (sparc_compare_op0) == TFmode\n+      && TARGET_ARCH64 && ! TARGET_HARD_QUAD)\n+    {\n+      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLE);\n+      emit_jump_insn (gen_bne (operands[0]));\n+      DONE;\n+    }\n+  operands[1] = gen_compare_reg (UNLE, sparc_compare_op0, sparc_compare_op1);\n+}\")\n \f\n ;; Now match both normal and inverted jump.\n "}]}