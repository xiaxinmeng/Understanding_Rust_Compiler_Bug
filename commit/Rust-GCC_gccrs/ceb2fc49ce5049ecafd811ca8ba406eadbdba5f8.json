{"sha": "ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ViMmZjNDljZTUwNDllY2FmZDgxMWNhOGJhNDA2ZWFkYmRiYTVmOA==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2013-09-14T06:13:18Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2013-09-14T06:13:18Z"}, "message": "mulsi3.S: Remove a few unneeded moves and branches.\n\n* config/rl78/mulsi3.S: Remove a few unneeded moves and branches.\n* config/rl78/vregs.h: New.\n* config/rl78/signbit.S: New file.  Implements signbit function.\n* config/rl78/divmodsi.S: New.\n* config/rl78/divmodhi.S: New.\n* config/rl78/divmodqi.S: New.\n* config/rl78/t-rl78: Build them here...\n* config/rl78/lib2div.c: ...but not here.\n\nCo-Authored-By: Nick Clifton <nickc@redhat.com>\n\nFrom-SVN: r202588", "tree": {"sha": "6f028c72a0421ebf758b7e3a0b11fc485361a541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f028c72a0421ebf758b7e3a0b11fc485361a541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/comments", "author": null, "committer": null, "parents": [{"sha": "03112d9463c2d0888ac4b0689573e4ae3d5e5b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03112d9463c2d0888ac4b0689573e4ae3d5e5b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03112d9463c2d0888ac4b0689573e4ae3d5e5b75"}], "stats": {"total": 1329, "additions": 1302, "deletions": 27}, "files": [{"sha": "518a26c9470cb0af1a67fc6a5bbb0dbadf144ce9", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -1,3 +1,15 @@\n+2013-09-14  DJ Delorie  <dj@redhat.com>\n+\t    Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/mulsi3.S: Remove a few unneeded moves and branches.\n+\t* config/rl78/vregs.h: New.\n+\t* config/rl78/signbit.S: New file.  Implements signbit function.\n+\t* config/rl78/divmodsi.S: New.\n+\t* config/rl78/divmodhi.S: New.\n+\t* config/rl78/divmodqi.S: New.\n+\t* config/rl78/t-rl78: Build them here...\n+\t* config/rl78/lib2div.c: ...but not here.\n+\n 2013-09-12  DJ Delorie  <dj@redhat.com>\n \n \t* config.host (msp*-*-elf): New."}, {"sha": "4e0a1237b28a866f19fee7d6b388ab3d9d829500", "filename": "libgcc/config/rl78/divmodhi.S", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fdivmodhi.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fdivmodhi.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fdivmodhi.S?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -0,0 +1,337 @@\n+/* HImode div/mod functions for the GCC support library for the Renesas RL78 processors.\n+   Copyright (C) 2012,2013 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __RL78_G10__\n+\n+#include \"vregs.h\"\n+\n+\t.macro make_generic  which,need_result\n+\n+\t.if \\need_result\n+\tquot = r8\n+\tnum = r10\n+\tden = r12\n+\tbit = r14\n+\t.else\n+\tnum = r8\n+\tquot = r10\n+\tden = r12\n+\tbit = r14\n+\t.endif\n+\n+\tquotB0 = quot\n+\tquotB1 = quot+1\n+\t\n+\tnumB0 = num\n+\tnumB1 = num+1\n+\t\n+\tdenB0 = den\n+\tdenB1 = den+1\n+\t\n+\tbitB0 = bit\n+\tbitB1 = bit+1\n+\n+#if 1\n+#define bit\tbc\n+#define bitB0\tc\n+#define bitB1\tb\n+#endif\n+\n+num_lt_den\\which:\n+\t.if \\need_result\n+\tmovw\tr8, #0\n+\t.else\n+\tmovw\tax, [sp+8]\n+\tmovw\tr8, ax\n+\t.endif\n+\tret\n+\n+\t;; These routines leave DE alone - the signed functions use DE\n+\t;; to store sign information that must remain intact\n+\n+\t.if \\need_result\n+\n+generic_div:\n+\n+\t.else\n+\n+generic_mod:\n+\n+\t.endif\n+\n+\t;; (quot,rem) = 8[sp] /% 10[sp]\n+\n+\tmovw\thl, sp\n+\tmovw\tax, [hl+10] ; denH\n+\tcmpw\tax, [hl+8] ; numH\n+\tbh\t$num_lt_den\\which\n+\n+\t;; (quot,rem) = 16[sp] /% 20[sp]\n+\n+\t;; copy numerator\n+\tmovw\tax, [hl+8]\n+\tmovw\tnum, ax\n+\n+\t;; copy denomonator\n+\tmovw\tax, [hl+10]\n+\tmovw\tden, ax\n+\n+\tmovw\tax, den\n+\tcmpw\tax, #0\n+\tbnz\t$den_not_zero\\which\n+\tmovw\tnum, #0\n+\tret\n+\n+den_not_zero\\which:\n+\t.if \\need_result\n+\t;; zero out quot\n+\tmovw\tquot, #0\n+\t.endif\n+\n+\t;; initialize bit to 1\n+\tmovw\tbit, #1\n+\n+; while (den < num && !(den & (1L << BITS_MINUS_1)))\n+\n+shift_den_bit\\which:\t\n+\tmovw\tax, den\n+\tmov1\tcy,a.7\n+\tbc\t$enter_main_loop\\which\n+\tcmpw\tax, num\n+\tbh\t$enter_main_loop\\which\n+\n+\t;; den <<= 1\n+;\tmovw\tax, den\t\t; already has it from the cmpw above\n+\tshlw\tax, 1\n+\tmovw\tden, ax\n+\n+\t;; bit <<= 1\n+\t.if \\need_result\n+#ifdef bit\n+\tshlw\tbit, 1\n+#else\n+\tmovw\tax, bit\n+\tshlw\tax, 1\n+\tmovw\tbit, ax\n+#endif\n+\t.else\n+\t;; if we don't need to compute the quotent, we don't need an\n+\t;; actual bit *mask*, we just need to keep track of which bit\n+\tinc\tbitB0\n+\t.endif\n+\n+\tbr\t$shift_den_bit\\which\n+\n+main_loop\\which:\n+\n+\t;; if (num >= den) (cmp den > num)\n+\tmovw\tax, den\n+\tcmpw\tax, num\n+\tbh\t$next_loop\\which\n+\n+\t;; num -= den\n+\tmovw\tax, num\n+\tsubw\tax, den\n+\tmovw\tnum, ax\n+\n+\t.if \\need_result\n+\t;; res |= bit\n+\tmov\ta, quotB0\n+\tor\ta, bitB0\n+\tmov\tquotB0, a\n+\tmov\ta, quotB1\n+\tor\ta, bitB1\n+\tmov\tquotB1, a\n+\t.endif\n+\n+next_loop\\which:\t\n+\n+\t;; den >>= 1\n+\tmovw\tax, den\n+\tshrw\tax, 1\n+\tmovw\tden, ax\n+\n+\t.if \\need_result\n+\t;; bit >>= 1\n+\tmovw\tax, bit\n+\tshrw\tax, 1\n+\tmovw\tbit, ax\n+\t.else\n+\tdec\tbitB0\n+\t.endif\n+\n+enter_main_loop\\which:\n+\t.if \\need_result\n+\tmovw\tax, bit\n+\tcmpw\tax, #0\n+\t.else\n+\tcmp0\tbitB0\n+\t.endif\n+\tbnz\t$main_loop\\which\n+\n+main_loop_done\\which:\t\n+\tret\n+\t.endm\n+\n+\tmake_generic _d 1\n+\tmake_generic _m 0\n+\n+;----------------------------------------------------------------------\n+\n+\t.global\t___udivhi3\n+\t.type\t___udivhi3,@function\n+___udivhi3:\n+\t;; r8 = 4[sp] / 6[sp]\n+\tcall\t$!generic_div\n+\tret\n+\t.size\t___udivhi3, . - ___udivhi3\n+\t\n+\n+\t.global\t___umodhi3\n+\t.type\t___umodhi3,@function\n+___umodhi3:\n+\t;; r8 = 4[sp] % 6[sp]\n+\tcall\t$!generic_mod\n+\tret\n+\t.size\t___umodhi3, . - ___umodhi3\n+\n+;----------------------------------------------------------------------\n+\n+\t.macro neg_ax\n+\tmovw\thl, ax\n+\tmovw\tax, #0\n+\tsubw\tax, [hl]\n+\tmovw\t[hl], ax\n+\t.endm\n+\n+\t.global\t___divhi3\n+\t.type\t___divhi3,@function\n+___divhi3:\n+\t;; r8 = 4[sp] / 6[sp]\n+\tmovw\tde, #0\n+\tmov\ta, [sp+5]\n+\tmov1\tcy, a.7\n+\tbc\t$div_signed_num\n+\tmov\ta, [sp+7]\n+\tmov1\tcy, a.7\n+\tbc\t$div_signed_den\n+\tcall\t$!generic_div\n+\tret\n+\t\n+div_signed_num:\n+\t;; neg [sp+4]\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+\tmov\td, #1\n+\tmov\ta, [sp+7]\n+\tmov1\tcy, a.7\n+\tbnc\t$div_unsigned_den\n+div_signed_den:\t\n+\t;; neg [sp+6]\n+\tmovw\tax, sp\n+\taddw\tax, #6\n+\tneg_ax\n+\tmov\te, #1\n+div_unsigned_den:\t\n+\tcall\t$!generic_div\n+\n+\tmov\ta, d\n+\tcmp0\ta\n+\tbz\t$div_skip_restore_num\n+\t;;  We have to restore the numerator [sp+4]\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+\tmov\ta, d\n+div_skip_restore_num:\t\n+\txor\ta, e\n+\tbz\t$div_no_neg\n+\tmovw\tax, #r8\n+\tneg_ax\n+div_no_neg:\n+\tmov\ta, e\n+\tcmp0\ta\n+\tbz\t$div_skip_restore_den\n+\tmovw\tax, sp\n+\taddw\tax, #6\n+\tneg_ax\n+div_skip_restore_den:\t\n+\tret\n+\t.size\t___divhi3, . - ___divhi3\n+\t\n+\n+\t.global\t___modhi3\n+\t.type\t___modhi3,@function\n+___modhi3:\n+\t;; r8 = 4[sp] % 6[sp]\n+\tmovw\tde, #0\n+\tmov\ta, [sp+5]\n+\tmov1\tcy, a.7\n+\tbc\t$mod_signed_num\n+\tmov\ta, [sp+7]\n+\tmov1\tcy, a.7\n+\tbc\t$mod_signed_den\n+\tcall\t$!generic_mod\n+\tret\n+\t\n+mod_signed_num:\n+\t;; neg [sp+4]\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+\tmov\td, #1\n+\tmov\ta, [sp+7]\n+\tmov1\tcy, a.7\n+\tbnc\t$mod_unsigned_den\n+mod_signed_den:\t\n+\t;; neg [sp+6]\n+\tmovw\tax, sp\n+\taddw\tax, #6\n+\tneg_ax\n+mod_unsigned_den:\t\n+\tcall\t$!generic_mod\n+\n+\tmov\ta, d\n+\tcmp0\ta\n+\tbz\t$mod_no_neg\n+\tmovw\tax, #r8\n+\tneg_ax\n+\t;;  Also restore numerator\n+\tmovw \tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+mod_no_neg:\n+\tmov\ta, e\n+\tcmp0\ta\n+\tbz\t$mod_skip_restore_den\n+\tmovw\tax, sp\n+\taddw\tax, #6\n+\tneg_ax\n+mod_skip_restore_den:\t\n+\tret\n+\t.size\t___modhi3, . - ___modhi3\n+\n+#endif"}, {"sha": "62d6f7761433b80ef2fbca50906f9ffee091f14a", "filename": "libgcc/config/rl78/divmodqi.S", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fdivmodqi.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fdivmodqi.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fdivmodqi.S?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -0,0 +1,310 @@\n+/* QImode div/mod functions for the GCC support library for the Renesas RL78 processors.\n+   Copyright (C) 2012,2013 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __RL78_G10__\n+\n+#include \"vregs.h\"\n+\n+\t.macro make_generic  which,need_result\n+\n+\t.if \\need_result\n+\tquot = r8\n+\tnum = r10\n+\tden = r12\n+\tbit = r14\n+\t.else\n+\tnum = r8\n+\tquot = r10\n+\tden = r12\n+\tbit = r14\n+\t.endif\n+\n+#if 1\n+#define bit\tb\n+#define den\tc\n+#define bitden\tbc\n+#endif\n+\n+num_lt_den\\which:\n+\t.if \\need_result\n+\tmov\tr8, #0\n+\t.else\n+\tmov\ta, [hl+4]\n+\tmov\tr8, a\n+\t.endif\n+\tret\n+\n+num_eq_den\\which:\n+\t.if \\need_result\n+\tmov\tr8, #1\n+\t.else\n+\tmov\tr8, #0\n+\t.endif\n+\tret\n+\t\n+den_is_zero\\which:\n+\tmov\tr8, #0xff\n+\tret\n+\n+\t;; These routines leave DE alone - the signed functions use DE\n+\t;; to store sign information that must remain intact\n+\n+\t.if \\need_result\n+\n+generic_div:\n+\n+\t.else\n+\n+generic_mod:\n+\n+\t.endif\n+\n+\t;; (quot,rem) = 4[hl] /% 6[hl]\n+\n+\tmov\ta, [hl+4] ; num\n+\tcmp\ta, [hl+6] ; den\n+\tbz\t$num_eq_den\\which\n+\tbnh\t$num_lt_den\\which\n+\t\n+\t;; copy numerator\n+;\tmov\ta, [hl+4]\t; already there from above\n+\tmov\tnum, a\n+\n+\t;; copy denomonator\n+\tmov\ta, [hl+6]\n+\tmov\tden, a\n+\n+\tcmp0\tden\n+\tbz\t$den_is_zero\\which\n+\n+den_not_zero\\which:\n+\t.if \\need_result\n+\t;; zero out quot\n+\tmov\tquot, #0\n+\t.endif\n+\n+\t;; initialize bit to 1\n+\tmov\tbit, #1\n+\n+; while (den < num && !(den & (1L << BITS_MINUS_1)))\n+\n+shift_den_bit\\which:\n+\t.macro\tsdb_one\\which\n+\tmov\ta, den\n+\tmov1\tcy,a.7\n+\tbc\t$enter_main_loop\\which\n+\tcmp\ta, num\n+\tbh\t$enter_main_loop\\which\n+\n+\t;; den <<= 1\n+;\tmov\ta, den\t\t; already has it from the cmpw above\n+\tshl\ta, 1\n+\tmov\tden, a\n+\n+\t;; bit <<= 1\n+\tshl\tbit, 1\n+\t.endm\n+\n+\tsdb_one\\which\n+\tsdb_one\\which\n+\n+\tbr\t$shift_den_bit\\which\n+\n+main_loop\\which:\n+\n+\t;; if (num >= den) (cmp den > num)\n+\tmov\ta, den\n+\tcmp\ta, num\n+\tbh\t$next_loop\\which\n+\n+\t;; num -= den\n+\tmov\ta, num\n+\tsub\ta, den\n+\tmov\tnum, a\n+\n+\t.if \\need_result\n+\t;; res |= bit\n+\tmov\ta, quot\n+\tor\ta, bit\n+\tmov\tquot, a\n+\t.endif\n+\n+next_loop\\which:\t\n+\n+\t;; den, bit >>= 1\n+\tmovw\tax, bitden\n+\tshrw\tax, 1\n+\tmovw\tbitden, ax\n+\n+enter_main_loop\\which:\n+\tcmp0\tbit\n+\tbnz\t$main_loop\\which\n+\n+main_loop_done\\which:\t\n+\tret\n+\t.endm\n+\n+\tmake_generic _d 1\n+\tmake_generic _m 0\n+\n+;----------------------------------------------------------------------\n+\n+\t.global\t___udivqi3\n+\t.type\t___udivqi3,@function\n+___udivqi3:\n+\t;; r8 = 4[sp] / 6[sp]\n+\tmovw\thl, sp\n+\tbr\t$!generic_div\n+\t.size\t___udivqi3, . - ___udivqi3\n+\t\n+\n+\t.global\t___umodqi3\n+\t.type\t___umodqi3,@function\n+___umodqi3:\n+\t;; r8 = 4[sp] % 6[sp]\n+\tmovw\thl, sp\n+\tbr\t$!generic_mod\n+\t.size\t___umodqi3, . - ___umodqi3\n+\n+;----------------------------------------------------------------------\n+\n+\t.macro neg_ax\n+\tmovw\thl, ax\n+\tmov\ta, #0\n+\tsub\ta, [hl]\n+\tmov\t[hl], a\n+\t.endm\n+\n+\t.global\t___divqi3\n+\t.type\t___divqi3,@function\n+___divqi3:\n+\t;; r8 = 4[sp] / 6[sp]\n+\tmovw\thl, sp\n+\tmovw\tde, #0\n+\tmov\ta, [sp+4]\n+\tmov1\tcy, a.7\n+\tbc\t$div_signed_num\n+\tmov\ta, [sp+6]\n+\tmov1\tcy, a.7\n+\tbc\t$div_signed_den\n+\tbr\t$!generic_div\n+\t\n+div_signed_num:\n+\t;; neg [sp+4]\n+\tmov\ta, #0\n+\tsub\ta, [hl+4]\n+\tmov\t[hl+4], a\n+\tmov\td, #1\n+\tmov\ta, [sp+6]\n+\tmov1\tcy, a.6\n+\tbnc\t$div_unsigned_den\n+div_signed_den:\t\n+\t;; neg [sp+6]\n+\tmov\ta, #0\n+\tsub\ta, [hl+6]\n+\tmov\t[hl+6], a\n+\tmov\te, #1\n+div_unsigned_den:\t\n+\tcall\t$!generic_div\n+\n+\tmov\ta, d\n+\tcmp0\ta\n+\tbz\t$div_skip_restore_num\n+\t;;  We have to restore the numerator [sp+4]\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+\tmov\ta, d\n+div_skip_restore_num:\t\n+\txor\ta, e\n+\tbz\t$div_no_neg\n+\tmovw\tax, #r8\n+\tneg_ax\n+div_no_neg:\n+\tmov\ta, e\n+\tcmp0\ta\n+\tbz\t$div_skip_restore_den\n+\tmovw\tax, sp\n+\taddw\tax, #6\n+\tneg_ax\n+div_skip_restore_den:\t\n+\tret\n+\t.size\t___divqi3, . - ___divqi3\n+\t\n+\n+\t.global\t___modqi3\n+\t.type\t___modqi3,@function\n+___modqi3:\n+\t;; r8 = 4[sp] % 6[sp]\n+\tmovw\thl, sp\n+\tmovw\tde, #0\n+\tmov\ta, [hl+4]\n+\tmov1\tcy, a.7\n+\tbc\t$mod_signed_num\n+\tmov\ta, [hl+6]\n+\tmov1\tcy, a.7\n+\tbc\t$mod_signed_den\n+\tbr\t$!generic_mod\n+\t\n+mod_signed_num:\n+\t;; neg [sp+4]\n+\tmov\ta, #0\n+\tsub\ta, [hl+4]\n+\tmov\t[hl+4], a\n+\tmov\td, #1\n+\tmov\ta, [hl+6]\n+\tmov1\tcy, a.7\n+\tbnc\t$mod_unsigned_den\n+mod_signed_den:\t\n+\t;; neg [sp+6]\n+\tmov\ta, #0\n+\tsub\ta, [hl+6]\n+\tmov\t[hl+6], a\n+\tmov\te, #1\n+mod_unsigned_den:\t\n+\tcall\t$!generic_mod\n+\n+\tmov\ta, d\n+\tcmp0\ta\n+\tbz\t$mod_no_neg\n+\tmov\ta, #0\n+\tsub\ta, r8\n+\tmov\tr8, a\n+\t;;  Also restore numerator\n+\tmovw \tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+mod_no_neg:\n+\tmov\ta, e\n+\tcmp0\ta\n+\tbz\t$mod_skip_restore_den\n+\tmovw\tax, sp\n+\taddw\tax, #6\n+\tneg_ax\n+mod_skip_restore_den:\t\n+\tret\n+\t.size\t___modqi3, . - ___modqi3\n+\n+#endif"}, {"sha": "e22b5ba56e850f890c5f4ae8ed299c053de036b9", "filename": "libgcc/config/rl78/divmodsi.S", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fdivmodsi.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fdivmodsi.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fdivmodsi.S?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -0,0 +1,521 @@\n+/* SImode div/mod functions for the GCC support library for the Renesas RL78 processors.\n+   Copyright (C) 2012,2013 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __RL78_G10__\n+\n+#include \"vregs.h\"\n+\n+\t.macro make_generic  which,need_result\n+\n+\t.if \\need_result\n+\tquot = r8\n+\tnum = r12\n+\tden = r16\n+\tbit = r20\n+\t.else\n+\tnum = r8\n+\tquot = r12\n+\tden = r16\n+\tbit = r20\n+\t.endif\n+\n+\tquotH = quot+2\n+\tquotL = quot\n+\tquotB0 = quot\n+\tquotB1 = quot+1\n+\tquotB2 = quot+2\n+\tquotB3 = quot+3\n+\t\n+\tnumH = num+2\n+\tnumL = num\n+\tnumB0 = num\n+\tnumB1 = num+1\n+\tnumB2 = num+2\n+\tnumB3 = num+3\n+\t\n+#define\tdenH bc\n+\tdenL = den\n+\tdenB0 = den\n+\tdenB1 = den+1\n+#define\tdenB2 c\n+#define\tdenB3 b\n+\t\n+\tbitH = bit+2\n+\tbitL = bit\n+\tbitB0 = bit\n+\tbitB1 = bit+1\n+\tbitB2 = bit+2\n+\tbitB3 = bit+3\n+\n+num_lt_den\\which:\n+\t.if \\need_result\n+\tmovw\tr8, #0\n+\tmovw\tr10, #0\n+\t.else\n+\tmovw\tax, [sp+8]\n+\tmovw\tr8, ax\n+\tmovw\tax, [sp+10]\n+\tmovw\tr10, ax\n+\t.endif\n+\tret\n+\n+shift_den_bit16\\which:\n+\tmovw\tax, denL\n+\tmovw\tdenH, ax\n+\tmovw\tdenL, #0\n+\t.if \\need_result\n+\tmovw\tax, bitL\n+\tmovw\tbitH, ax\n+\tmovw\tbitL, #0\n+\t.else\n+\tmov\ta, bit\n+\tadd\ta, #16\n+\tmov\tbit, a\n+\t.endif\n+\tbr\t$shift_den_bit\\which\n+\n+\t;; These routines leave DE alone - the signed functions use DE\n+\t;; to store sign information that must remain intact\n+\n+\t.if \\need_result\n+\n+generic_div:\n+\n+\t.else\n+\n+generic_mod:\n+\n+\t.endif\n+\n+\t;; (quot,rem) = 8[sp] /% 12[sp]\n+\n+\tmovw\thl, sp\n+\tmovw\tax, [hl+14] ; denH\n+\tcmpw\tax, [hl+10] ; numH\n+\tmovw\tax, [hl+12] ; denL\n+\tsknz\n+\tcmpw\tax, [hl+8] ; numL\n+\tbh\t$num_lt_den\\which\n+\n+\tsel\trb2\n+\tpush\tax\t\t; denL\n+;\tpush\tbc\t\t; denH\n+\tpush\tde\t\t; bitL\n+\tpush\thl\t\t; bitH - stored in BC\n+\tsel\trb0\n+\n+\t;; (quot,rem) = 16[sp] /% 20[sp]\n+\n+\t;; copy numerator\n+\tmovw\tax, [hl+8]\n+\tmovw\tnumL, ax\n+\tmovw\tax, [hl+10]\n+\tmovw\tnumH, ax\n+\n+\t;; copy denomonator\n+\tmovw\tax, [hl+12]\n+\tmovw\tdenL, ax\n+\tmovw\tax, [hl+14]\n+\tmovw\tdenH, ax\n+\n+\tmovw\tax, denL\n+\tor\ta, denB2\n+\tor\ta, denB3\t; not x\n+\tcmpw\tax, #0\n+\tbnz\t$den_not_zero\\which\n+\tmovw\tnumL, #0\n+\tmovw\tnumH, #0\n+\tret\n+\n+den_not_zero\\which:\n+\t.if \\need_result\n+\t;; zero out quot\n+\tmovw\tquotL, #0\n+\tmovw\tquotH, #0\n+\t.endif\n+\n+\t;; initialize bit to 1\n+\tmovw\tbitL, #1\n+\tmovw\tbitH, #0\n+\n+; while (den < num && !(den & (1L << BITS_MINUS_1)))\n+\n+\t.if 1\n+\t;; see if we can short-circuit a bunch of shifts\n+\tmovw\tax, denH\n+\tcmpw\tax, #0\n+\tbnz\t$shift_den_bit\\which\n+\tmovw\tax, denL\n+\tcmpw\tax, numH\n+\tbnh\t$shift_den_bit16\\which\n+\t.endif\n+\n+shift_den_bit\\which:\t\n+\tmovw\tax, denH\n+\tmov1\tcy,a.7\n+\tbc\t$enter_main_loop\\which\n+\tcmpw\tax, numH\n+\tmovw\tax, denL\t; we re-use this below\n+\tsknz\n+\tcmpw\tax, numL\n+\tbh\t$enter_main_loop\\which\n+\n+\t;; den <<= 1\n+;\tmovw\tax, denL\t; already has it from the cmpw above\n+\tshlw\tax, 1\n+\tmovw\tdenL, ax\n+;\tmovw\tax, denH\n+\trolwc\tdenH, 1\n+;\tmovw\tdenH, ax\n+\n+\t;; bit <<= 1\n+\t.if \\need_result\n+\tmovw\tax, bitL\n+\tshlw\tax, 1\n+\tmovw\tbitL, ax\n+\tmovw\tax, bitH\n+\trolwc\tax, 1\n+\tmovw\tbitH, ax\n+\t.else\n+\t;; if we don't need to compute the quotent, we don't need an\n+\t;; actual bit *mask*, we just need to keep track of which bit\n+\tinc\tbitB0\n+\t.endif\n+\n+\tbr\t$shift_den_bit\\which\n+\n+\t;; while (bit)\n+main_loop\\which:\n+\n+\t;; if (num >= den) (cmp den > num)\n+\tmovw\tax, numH\n+\tcmpw\tax, denH\n+\tmovw\tax, numL\n+\tsknz\n+\tcmpw\tax, denL\n+\tskz\n+\tbnh\t$next_loop\\which\n+\n+\t;; num -= den\n+;\tmovw\tax, numL\t; already has it from the cmpw above\n+\tsubw\tax, denL\n+\tmovw\tnumL, ax\n+\tmovw\tax, numH\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, denH\n+\tmovw\tnumH, ax\n+\n+\t.if \\need_result\n+\t;; res |= bit\n+\tmov\ta, quotB0\n+\tor\ta, bitB0\n+\tmov\tquotB0, a\n+\tmov\ta, quotB1\n+\tor\ta, bitB1\n+\tmov\tquotB1, a\n+\tmov\ta, quotB2\n+\tor\ta, bitB2\n+\tmov\tquotB2, a\n+\tmov\ta, quotB3\n+\tor\ta, bitB3\n+\tmov\tquotB3, a\n+\t.endif\n+\n+next_loop\\which:\t\n+\n+\t;; den >>= 1\n+\tmovw\tax, denH\n+\tshrw\tax, 1\n+\tmovw\tdenH, ax\n+\tmov\ta, denB1\n+\trorc\ta, 1\n+\tmov\tdenB1, a\n+\tmov\ta, denB0\n+\trorc\ta, 1\n+\tmov\tdenB0, a\n+\n+\t;; bit >>= 1\n+\t.if \\need_result\n+\tmovw\tax, bitH\n+\tshrw\tax, 1\n+\tmovw\tbitH, ax\n+\tmov\ta, bitB1\n+\trorc\ta, 1\n+\tmov\tbitB1, a\n+\tmov\ta, bitB0\n+\trorc\ta, 1\n+\tmov\tbitB0, a\n+\t.else\n+\tdec\tbitB0\n+\t.endif\n+\n+enter_main_loop\\which:\n+\t.if \\need_result\n+\tmovw\tax, bitH\n+\tcmpw\tax, #0\n+\tbnz\t$main_loop\\which\n+\t.else\n+\tcmp\tbitB0, #15\n+\tbh\t$main_loop\\which\n+\t.endif\n+\t;; bit is HImode now; check others\n+\tmovw\tax, numH\t; numerator\n+\tcmpw\tax, #0\n+\tbnz\t$bit_high_set\\which\n+\tmovw\tax, denH\t; denominator\n+\tcmpw\tax, #0\n+\tbz\t$switch_to_himode\\which\n+bit_high_set\\which:\t\n+\t.if \\need_result\n+\tmovw\tax, bitL\n+\tcmpw\tax, #0\n+\t.else\n+\tcmp0\tbitB0\n+\t.endif\n+\tbnz\t$main_loop\\which\n+\n+switch_to_himode\\which:\n+\t.if \\need_result\n+\tmovw\tax, bitL\n+\tcmpw\tax, #0\n+\t.else\n+\tcmp0\tbitB0\n+\t.endif\n+\tbz\t$main_loop_done_himode\\which\n+\n+\t;; From here on in, r22, r14, and r18 are all zero\n+\t;; while (bit)\n+main_loop_himode\\which:\n+\n+\t;; if (num >= den) (cmp den > num)\n+\tmovw\tax, denL\n+\tcmpw\tax, numL\n+\tbh\t$next_loop_himode\\which\n+\n+\t;; num -= den\n+\tmovw\tax, numL\n+\tsubw\tax, denL\n+\tmovw\tnumL, ax\n+\tmovw\tax, numH\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, denH\n+\tmovw\tnumH, ax\n+\n+\t.if \\need_result\n+\t;; res |= bit\n+\tmov\ta, quotB0\n+\tor\ta, bitB0\n+\tmov\tquotB0, a\n+\tmov\ta, quotB1\n+\tor\ta, bitB1\n+\tmov\tquotB1, a\n+\t.endif\n+\n+next_loop_himode\\which:\t\n+\n+\t;; den >>= 1\n+\tmovw\tax, denL\n+\tshrw\tax, 1\n+\tmovw\tdenL, ax\n+\n+\t.if \\need_result\n+\t;; bit >>= 1\n+\tmovw\tax, bitL\n+\tshrw\tax, 1\n+\tmovw\tbitL, ax\n+\t.else\n+\tdec\tbitB0\n+\t.endif\n+\n+\t.if \\need_result\n+\tmovw\tax, bitL\n+\tcmpw\tax, #0\n+\t.else\n+\tcmp0\tbitB0\n+\t.endif\n+\tbnz\t$main_loop_himode\\which\n+\n+main_loop_done_himode\\which:\t\n+\tsel\trb2\n+\tpop\thl\t\t; bitH - stored in BC\n+\tpop\tde\t\t; bitL\n+;\tpop\tbc\t\t; denH\n+\tpop\tax\t\t; denL\n+\tsel\trb0\n+\n+\tret\n+\t.endm\n+\n+\tmake_generic _d 1\n+\tmake_generic _m 0\n+\n+;----------------------------------------------------------------------\n+\n+\t.global\t___udivsi3\n+\t.type\t___udivsi3,@function\n+___udivsi3:\n+\t;; r8 = 4[sp] / 8[sp]\n+\tcall\t$!generic_div\n+\tret\n+\t.size\t___udivsi3, . - ___udivsi3\n+\t\n+\n+\t.global\t___umodsi3\n+\t.type\t___umodsi3,@function\n+___umodsi3:\n+\t;; r8 = 4[sp] % 8[sp]\n+\tcall\t$!generic_mod\n+\tret\n+\t.size\t___umodsi3, . - ___umodsi3\n+\n+;----------------------------------------------------------------------\n+\n+\t.macro neg_ax\n+\tmovw\thl, ax\n+\tmovw\tax, #0\n+\tsubw\tax, [hl]\n+\tmovw\t[hl], ax\n+\tmovw\tax, #0\n+\tsknc\n+\tdecw\tax\n+\tsubw\tax, [hl+2]\n+\tmovw\t[hl+2], ax\n+\t.endm\n+\n+\t.global\t___divsi3\n+\t.type\t___divsi3,@function\n+___divsi3:\n+\t;; r8 = 4[sp] / 8[sp]\n+\tmovw\tde, #0\n+\tmov\ta, [sp+7]\n+\tmov1\tcy, a.7\n+\tbc\t$div_signed_num\n+\tmov\ta, [sp+11]\n+\tmov1\tcy, a.7\n+\tbc\t$div_signed_den\n+\tcall\t$!generic_div\n+\tret\n+\t\n+div_signed_num:\n+\t;; neg [sp+4]\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+\tmov\td, #1\n+\tmov\ta, [sp+11]\n+\tmov1\tcy, a.7\n+\tbnc\t$div_unsigned_den\n+div_signed_den:\t\n+\t;; neg [sp+8]\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tneg_ax\n+\tmov\te, #1\n+div_unsigned_den:\t\n+\tcall\t$!generic_div\n+\n+\tmov\ta, d\n+\tcmp0\ta\n+\tbz\t$div_skip_restore_num\n+\t;;  We have to restore the numerator [sp+4]\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+\tmov\ta, d\n+div_skip_restore_num:\t\n+\txor\ta, e\n+\tbz\t$div_no_neg\n+\tmovw\tax, #r8\n+\tneg_ax\n+div_no_neg:\n+\tmov\ta, e\n+\tcmp0\ta\n+\tbz\t$div_skip_restore_den\n+\t;;  We have to restore the denominator [sp+8]\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tneg_ax\n+div_skip_restore_den:\n+\tret\n+\t.size\t___divsi3, . - ___divsi3\n+\t\n+\n+\t.global\t___modsi3\n+\t.type\t___modsi3,@function\n+___modsi3:\n+\t;; r8 = 4[sp] % 8[sp]\n+\tmovw\tde, #0\n+\tmov\ta, [sp+7]\n+\tmov1\tcy, a.7\n+\tbc\t$mod_signed_num\n+\tmov\ta, [sp+11]\n+\tmov1\tcy, a.7\n+\tbc\t$mod_signed_den\n+\tcall\t$!generic_mod\n+\tret\n+\t\n+mod_signed_num:\n+\t;; neg [sp+4]\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+\tmov\td, #1\n+\tmov\ta, [sp+11]\n+\tmov1\tcy, a.7\n+\tbnc\t$mod_unsigned_den\n+mod_signed_den:\t\n+\t;; neg [sp+8]\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tneg_ax\n+\tmov\te, #1\n+mod_unsigned_den:\t\n+\tcall\t$!generic_mod\n+\n+\tmov\ta, d\n+\tcmp0\ta\n+\tbz\t$mod_no_neg\n+\tmovw\tax, #r8\n+\tneg_ax\n+\t;;  We have to restore [sp+4] as well.\n+\tmovw\tax, sp\n+\taddw\tax, #4\n+\tneg_ax\n+mod_no_neg:\n+ .if 1\n+\tmov\ta, e\n+\tcmp0\ta\n+\tbz\t$mod_skip_restore_den\n+\tmovw\tax, sp\n+\taddw\tax, #8\n+\tneg_ax\n+mod_skip_restore_den:\t\n+ .endif\t\n+\tret\n+\t.size\t___modsi3, . - ___modsi3\n+\n+#endif"}, {"sha": "4b5033ef9708e0594546d38868739202634b5705", "filename": "libgcc/config/rl78/lib2div.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Flib2div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Flib2div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Flib2div.c?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -34,6 +34,8 @@ typedef int           word_type     __attribute__ ((mode (__word__)));\n #define C3B(a,b,c) a##b##c\n #define C3(a,b,c) C3B(a,b,c)\n \n+#if 0\n+\n #define UINT_TYPE\tuint32_type\n #define SINT_TYPE\tsint32_type\n #define BITS_MINUS_1\t31\n@@ -65,6 +67,8 @@ typedef int           word_type     __attribute__ ((mode (__word__)));\n \n #include \"rl78-divmod.h\"\n \n+#endif\n+\n /* See the comment by the definition of LIBGCC2_UNITS_PER_WORD in\n    m32c.h for why we are creating extra versions of some of the\n    functions defined in libgcc2.c.  */"}, {"sha": "012e87e285ffa86f5f360237f7745ae027b23ec4", "filename": "libgcc/config/rl78/mulsi3.S", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fmulsi3.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fmulsi3.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fmulsi3.S?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -70,10 +70,6 @@ ___mulsi3:\n \t;; B is at [sp+8]\n \t;; result is in R8..R11\n \n-\tmovw\tax, sp\n-\taddw\tax, #4\n-\tmovw\thl, ax\n-\n \tsel\trb2\n \tpush\tax\n \tpush\tbc\n@@ -83,37 +79,37 @@ ___mulsi3:\n \tmovw\tr8, ax\n \tmovw\tr16, ax\n \n-\tmovw\tax, [hl+6]\n+\tmovw\tax, [sp+14]\n \tcmpw\tax, #0\n \tbz\t$1f\n \tcmpw\tax, #0xffff\n \tbnz\t$2f\n-\tmovw\tax, [hl]\n+\tmovw\tax, [sp+8]\n \tsel\trb1\n \tsubw\tax, r_0\n \tsel\trb0\n \tbr\t$1f\n 2:\t\n \tmovw\tbc, ax\n-\tmovw\tax, [hl]\n+\tmovw\tax, [sp+8]\n \tcmpw\tax, #0\n \tskz\n \tcall\t!.Lmul_hi\n 1:\t\n \n-\tmovw\tax, [hl+2]\n+\tmovw\tax, [sp+10]\n \tcmpw\tax, #0\n \tbz\t$1f\n \tcmpw\tax, #0xffff\n \tbnz\t$2f\n-\tmovw\tax, [hl+4]\n+\tmovw\tax, [sp+12]\n \tsel\trb1\n \tsubw\tax, r_0\n \tsel\trb0\n \tbr\t$1f\n 2:\t\n \tmovw\tbc, ax\n-\tmovw\tax, [hl+4]\n+\tmovw\tax, [sp+12]\n \tcmpw\tax, #0\n \tskz\n \tcall\t!.Lmul_hi\n@@ -130,9 +126,9 @@ ___mulsi3:\n \t;; op2 is in BC.2 and BC.1 (bc can shlw/rolcw)\n \t;; res is in AX.2 and AX.1 (needs to addw)\n \n-\tmovw\tax, [hl]\n+\tmovw\tax, [sp+8]\n \tmovw\tr10, ax\t\t; BC.1\n-\tmovw\tax, [hl+4]\n+\tmovw\tax, [sp+12]\n \n \tcmpw\tax, r10\n \tbc\t$.Lmul_hisi_top\n@@ -191,6 +187,13 @@ ___mulsi3:\n \n ;----------------------------------------------------------------------\n \n+\t.global\t___mulhi3\n+___mulhi3:\n+\tmovw\tr8, #0\n+\tmovw\tax, [sp+6]\n+\tmovw\tbc, ax\n+\tmovw\tax, [sp+4]\n+\n \t;; R8 += AX * BC\n .Lmul_hi:\n \tcmpw\tax, bc\n@@ -218,18 +221,3 @@ ___mulsi3:\n \n .Lmul_hi_done:\n \tret\n-\n-;----------------------------------------------------------------------\n-\n-\t.global\t___mulhi3\n-___mulhi3:\n-\tsel\trb1\n-\tclrw\tax\n-\tsel\trb0\n-\tmovw\tax, sp\n-\taddw\tax, #4\n-\tmovw\thl, ax\n-\tmovw\tax, [hl+2]\n-\tmovw\tbc, ax\n-\tmovw\tax, [hl]\n-\tbr\t$.Lmul_hi"}, {"sha": "afd0f07eb475694c20b474316ca5e2085cd59e81", "filename": "libgcc/config/rl78/signbit.S", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fsignbit.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fsignbit.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fsignbit.S?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -0,0 +1,67 @@\n+;   Copyright (C) 2012,2013 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+#include \"vregs.h\"\n+\t\n+;; int signbitf (float X)\n+;; int signbit  (double X)\n+;; int signbitl (long double X)\n+;;\n+;;     `signbit' returns a nonzero value if the value of X has its sign\n+;;     bit set.\n+;;\n+;;     This is not the same as `x < 0.0', because IEEE 754 floating point\n+;;     allows zero to be signed.  The comparison `-0.0 < 0.0' is false,\n+;;     but `signbit (-0.0)' will return a nonzero value.\n+\n+;----------------------------------------------------------------------\n+\n+\t.text\n+\n+\t.global\t_signbit\n+_signbit:\n+\t.global\t_signbitf\n+_signbitf:\n+\t;; X is at [sp+4]\n+\t;; result is in R8..R9\n+\n+\tmovw\tr8, #0\n+\tmov\ta, [sp+7]\n+\tmov1\tcy, a.7\n+\tsknc\n+\tmovw\tr8, #1\n+\tret\n+\t.size\t_signbit, . - _signbit\n+\t.size\t_signbitf, . - _signbitf\n+\n+\t.global\t_signbitl\n+_signbitl:\n+\t;; X is at [sp+4]\n+\t;; result is in R8..R9\n+\n+\tmovw\tr8, #0\n+\tmov\ta, [sp+11]\n+\tmov1\tcy, a.7\n+\tsknc\n+\tmovw\tr8, #1\n+\tret\n+\t.size\t_signbitl, . - _signbitl"}, {"sha": "d3260aa23d257b4439296585fbd405de10ee4add", "filename": "libgcc/config/rl78/t-rl78", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Ft-rl78", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Ft-rl78", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ft-rl78?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -25,4 +25,8 @@ LIB2ADD = \\\n \t$(srcdir)/config/rl78/lib2shift.c \\\n \t$(srcdir)/config/rl78/lshrsi3.S \\\n \t$(srcdir)/config/rl78/mulsi3.S \\\n+\t$(srcdir)/config/rl78/divmodsi.S \\\n+\t$(srcdir)/config/rl78/divmodhi.S \\\n+\t$(srcdir)/config/rl78/divmodqi.S \\\n+\t$(srcdir)/config/rl78/signbit.S \\\n \t$(srcdir)/config/rl78/cmpsi2.S"}, {"sha": "f223be53ef8c13243b1736643e281d7fe823991c", "filename": "libgcc/config/rl78/vregs.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fvregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8/libgcc%2Fconfig%2Frl78%2Fvregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Fvregs.h?ref=ceb2fc49ce5049ecafd811ca8ba406eadbdba5f8", "patch": "@@ -0,0 +1,32 @@\n+\n+; real\n+; GAS defines r0..r7 as aliases for real registers; we want the saddr\n+; forms here.\n+r_0\t=\t0xffef8\n+r_1\t=\t0xffef9\n+r_2\t=\t0xffefa\n+r_3\t=\t0xffefb\n+r_4\t=\t0xffefc\n+r_5\t=\t0xffefd\n+r_6\t=\t0xffefe\n+r_7\t=\t0xffeff\n+\n+; clobberable\n+r8\t=\t0xffef0\n+r9\t=\t0xffef1\n+r10\t=\t0xffef2\n+r11\t=\t0xffef3\n+r12\t=\t0xffef4\n+r13\t=\t0xffef5\n+r14\t=\t0xffef6\n+r15\t=\t0xffef7\n+; preserved\n+r16\t=\t0xffee8\n+r17\t=\t0xffee9\n+r18\t=\t0xffeea\n+r19\t=\t0xffeeb\n+r20\t=\t0xffeec\n+r21\t=\t0xffeed\n+r22\t=\t0xffeee\n+r23\t=\t0xffeef\n+"}]}