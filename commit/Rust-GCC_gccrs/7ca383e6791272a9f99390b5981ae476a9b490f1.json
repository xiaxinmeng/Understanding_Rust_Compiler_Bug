{"sha": "7ca383e6791272a9f99390b5981ae476a9b490f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhMzgzZTY3OTEyNzJhOWY5OTM5MGI1OTgxYWU0NzZhOWI0OTBmMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-01-28T19:28:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-01-28T19:28:01Z"}, "message": "re PR c++/25855 (template specialisation not always found (partial ordering))\n\n\tPR c++/25855\n\t* class.c (resolve_address_of_overloaded_function): Adjust use of\n\treturn value from most_specialized_instantiation.\n\t* pt.c (determine_specialization): Avoid multiple calls to\n\tget_bindings.\n\t(most_specialized_instantiation): When a tie occurs, set the\n\tcurrent presumed champion to the next template.  Return the\n\tTREE_LIST node containing the template, rather than the template\n\titself.\n\t(most_specialized): Remove.\n\t* name-lookup.c (push_overloaded_decl): When duplicate_decls\n\tindicates a failed redeclaration, report that to callers.\n\tPR c++/25855\n\t* g++.dg/template/spec29.C: New test.\n\nFrom-SVN: r110332", "tree": {"sha": "cf01e7e1711bb0a24daf243f5df6daba7b5aa587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf01e7e1711bb0a24daf243f5df6daba7b5aa587"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ca383e6791272a9f99390b5981ae476a9b490f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca383e6791272a9f99390b5981ae476a9b490f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca383e6791272a9f99390b5981ae476a9b490f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca383e6791272a9f99390b5981ae476a9b490f1/comments", "author": null, "committer": null, "parents": [{"sha": "e94aab95ee93fd7c5f31ad1ec5aecdb9c3c97453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e94aab95ee93fd7c5f31ad1ec5aecdb9c3c97453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e94aab95ee93fd7c5f31ad1ec5aecdb9c3c97453"}], "stats": {"total": 115, "additions": 69, "deletions": 46}, "files": [{"sha": "ad3be507d4ecf45dc6d2b67fbc2f9849ba7ab51b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7ca383e6791272a9f99390b5981ae476a9b490f1", "patch": "@@ -1,3 +1,18 @@\n+2006-01-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25855\n+\t* class.c (resolve_address_of_overloaded_function): Adjust use of\n+\treturn value from most_specialized_instantiation.\n+\t* pt.c (determine_specialization): Avoid multiple calls to\n+\tget_bindings.\n+\t(most_specialized_instantiation): When a tie occurs, set the\n+\tcurrent presumed champion to the next template.  Return the\n+\tTREE_LIST node containing the template, rather than the template\n+\titself.\n+\t(most_specialized): Remove.\n+\t* name-lookup.c (push_overloaded_decl): When duplicate_decls\n+\tindicates a failed redeclaration, report that to callers.\n+\n 2006-01-26  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/16021"}, {"sha": "b9abaa82ddc0e25ea3e4fa7f773c43fd5ae4d376", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7ca383e6791272a9f99390b5981ae476a9b490f1", "patch": "@@ -5819,7 +5819,9 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  tree match = most_specialized_instantiation (matches);\n \n \t  if (match != error_mark_node)\n-\t    matches = tree_cons (match, NULL_TREE, NULL_TREE);\n+\t    matches = tree_cons (TREE_PURPOSE (match), \n+\t\t\t\t NULL_TREE, \n+\t\t\t\t NULL_TREE);\n \t}\n     }\n "}, {"sha": "ed7dd5361c9cf2df7f775cb04db46d049f7c8ab2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=7ca383e6791272a9f99390b5981ae476a9b490f1", "patch": "@@ -1892,6 +1892,7 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n \t  for (tmp = old; tmp; tmp = OVL_NEXT (tmp))\n \t    {\n \t      tree fn = OVL_CURRENT (tmp);\n+\t      tree dup;\n \n \t      if (TREE_CODE (tmp) == OVERLOAD && OVL_USED (tmp)\n \t\t  && !(flags & PUSH_USING)\n@@ -1901,8 +1902,11 @@ push_overloaded_decl (tree decl, int flags, bool is_friend)\n \t\terror (\"%q#D conflicts with previous using declaration %q#D\",\n \t\t       decl, fn);\n \n-\t      if (duplicate_decls (decl, fn, is_friend) == fn)\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n+\t      dup = duplicate_decls (decl, fn, is_friend);\n+\t      /* If DECL was a redeclaration of FN -- even an invalid\n+\t\t one -- pass that information along to our caller.  */\n+\t      if (dup == fn || dup == error_mark_node)\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, dup);\n \t    }\n \n \t  /* We don't overload implicit built-ins.  duplicate_decls()"}, {"sha": "e02cca47dc062025e61492c9a2081388f65e4f6a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 43, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7ca383e6791272a9f99390b5981ae476a9b490f1", "patch": "@@ -135,7 +135,6 @@ static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_args (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n static void regenerate_decl_from_template (tree, tree);\n-static tree most_specialized (tree, tree, tree);\n static tree most_specialized_class (tree, tree);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n static tree tsubst_arg_types (tree, tree, tsubst_flags_t, tree);\n@@ -1343,6 +1342,11 @@ determine_specialization (tree template_id,\n   tree targs;\n   tree explicit_targs;\n   tree candidates = NULL_TREE;\n+  /* A TREE_LIST of templates of which DECL may be a specialization.\n+     The TREE_VALUE of each node is a TEMPLATE_DECL.  The\n+     corresponding TREE_PURPOSE is the set of template arguments that,\n+     when used to instantiate the template, would produce a function\n+     with the signature of DECL.  */\n   tree templates = NULL_TREE;\n   int header_count;\n   struct cp_binding_level *b;\n@@ -1547,12 +1551,12 @@ determine_specialization (tree template_id,\n \t the EDG front-end has that behavior, and John Spicer claims\n \t that the committee simply forgot to delete the wording in\n \t [temp.expl.spec].  */\n-     tree tmpl = most_specialized (templates, decl, explicit_targs);\n-     if (tmpl && tmpl != error_mark_node)\n-       {\n-\t targs = get_bindings (tmpl, decl, explicit_targs, /*check_ret=*/true);\n-\t templates = tree_cons (targs, tmpl, NULL_TREE);\n-       }\n+      tree tmpl = most_specialized_instantiation (templates);\n+      if (tmpl != error_mark_node)\n+\t{\n+\t  templates = tmpl;\n+\t  TREE_CHAIN (templates) = NULL_TREE;\n+\t}\n     }\n \n   if (templates == NULL_TREE && candidates == NULL_TREE)\n@@ -10826,25 +10830,26 @@ get_class_bindings (tree tparms, tree parms, tree args)\n   return vec;\n }\n \n-/* In INSTANTIATIONS is a list of <INSTANTIATION, TEMPLATE> pairs.\n-   Pick the most specialized template, and return the corresponding\n-   instantiation, or if there is no corresponding instantiation, the\n-   template itself.  If there is no most specialized template,\n-   error_mark_node is returned.  If there are no templates at all,\n-   NULL_TREE is returned.  */\n+/* TEMPLATES is a TREE_LIST.  Each TREE_VALUE is a TEMPLATE_DECL.\n+   Return the TREE_LIST node with the most specialized template, if\n+   any.  If there is no most specialized template, the error_mark_node\n+   is returned.\n+\n+   Note that this function does not look at, or modify, the\n+   TREE_PURPOSE or TREE_TYPE of any of the nodes.  Since the node\n+   returned is one of the elements of INSTANTIATIONS, callers may\n+   store information in the TREE_PURPOSE or TREE_TYPE of the nodes,\n+   and retrieve it from the value returned.  */\n \n tree\n-most_specialized_instantiation (tree instantiations)\n+most_specialized_instantiation (tree templates)\n {\n   tree fn, champ;\n \n-  if (!instantiations)\n-    return NULL_TREE;\n-\n   ++processing_template_decl;\n \n-  champ = instantiations;\n-  for (fn = TREE_CHAIN (instantiations); fn; fn = TREE_CHAIN (fn))\n+  champ = templates;\n+  for (fn = TREE_CHAIN (templates); fn; fn = TREE_CHAIN (fn))\n     {\n       int fate = 0;\n \n@@ -10865,6 +10870,7 @@ most_specialized_instantiation (tree instantiations)\n \t  /* Equally specialized, move to next function.  If there\n \t     is no next function, nothing's most specialized.  */\n \t  fn = TREE_CHAIN (fn);\n+\t  champ = fn;\n \t  if (!fn)\n \t    break;\n \t}\n@@ -10873,7 +10879,7 @@ most_specialized_instantiation (tree instantiations)\n   if (champ)\n     /* Now verify that champ is better than everything earlier in the\n        instantiation list.  */\n-    for (fn = instantiations; fn != champ; fn = TREE_CHAIN (fn))\n+    for (fn = templates; fn != champ; fn = TREE_CHAIN (fn))\n       if (get_bindings (TREE_VALUE (champ),\n \t\t\tDECL_TEMPLATE_RESULT (TREE_VALUE (fn)),\n \t\t\tNULL_TREE, /*check_ret=*/false)\n@@ -10890,29 +10896,7 @@ most_specialized_instantiation (tree instantiations)\n   if (!champ)\n     return error_mark_node;\n \n-  return TREE_PURPOSE (champ) ? TREE_PURPOSE (champ) : TREE_VALUE (champ);\n-}\n-\n-/* Return the most specialized of the list of templates in FNS that can\n-   produce an instantiation matching DECL, given the explicit template\n-   arguments EXPLICIT_ARGS.  */\n-\n-static tree\n-most_specialized (tree fns, tree decl, tree explicit_args)\n-{\n-  tree candidates = NULL_TREE;\n-  tree fn, args;\n-\n-  for (fn = fns; fn; fn = TREE_CHAIN (fn))\n-    {\n-      tree candidate = TREE_VALUE (fn);\n-\n-      args = get_bindings (candidate, decl, explicit_args, /*check_ret=*/true);\n-      if (args)\n-\tcandidates = tree_cons (NULL_TREE, candidate, candidates);\n-    }\n-\n-  return most_specialized_instantiation (candidates);\n+  return champ;\n }\n \n /* If DECL is a specialization of some template, return the most"}, {"sha": "70b6deef740f86cab7a80a2ae1d4061bb2307cd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ca383e6791272a9f99390b5981ae476a9b490f1", "patch": "@@ -1,3 +1,8 @@\n+2006-01-28  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25855\n+\t* g++.dg/template/spec29.C: New test.\n+\n 2006-01-28  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR c/19606."}, {"sha": "4df00ee7d28df74365a788f12bd1c86b2f7f18d3", "filename": "gcc/testsuite/g++.dg/template/spec29.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca383e6791272a9f99390b5981ae476a9b490f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec29.C?ref=7ca383e6791272a9f99390b5981ae476a9b490f1", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/25855\n+// { dg-do run }\n+\n+template <typename T>  int qCompare(const T *t1, const T *t2) { return 1; }\n+template <typename T>  int qCompare(T *t1, T *t2) { return 2; }\n+template <typename T1, typename T2> int qCompare(const T1 *t1, const T2 *t2) {\n+  return 3; }\n+template<> int qCompare(const char *t1, const char *t2) { return 4; }\n+int main()\n+{\n+  if (qCompare(\"a\", \"b\") != 4)\n+    return 1;\n+}"}]}