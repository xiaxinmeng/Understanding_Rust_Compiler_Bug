{"sha": "038dc49afffb06ab20dd7bcc1be427fc668e6f80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM4ZGM0OWFmZmZiMDZhYjIwZGQ3YmNjMWJlNDI3ZmM2NjhlNmY4MA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-11-24T16:53:17Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-11-24T16:53:17Z"}, "message": "[multiple changes]\n\n2009-11-24  Michael Matz  <matz@suse.de>\n\n\t* expr.c (set_storage_via_libcall): Fix build_call_expr call.\n\n2009-11-24  David Binderman  <dcb314@hotmail.com>\n\n\t* expr.c (store_field): Remove set but not used local variable\n\twidth_mask.\n\t(expand_expr_real_2): Remove treeop2.\n\t* gcse.c (update_ld_motion_stores): Remove new_rtx.\n\t* haifa-sched.c (max_issue): Remove points.\n\t(sched_create_recovery_edges): Remove e.\n\t* ira-costs.c (setup_allocno_cover_class_and_costs): Remove mode.\n\nFrom-SVN: r154505", "tree": {"sha": "6be018fb02b4d16d658f952c905e38c1c1c753d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6be018fb02b4d16d658f952c905e38c1c1c753d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/038dc49afffb06ab20dd7bcc1be427fc668e6f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/038dc49afffb06ab20dd7bcc1be427fc668e6f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/038dc49afffb06ab20dd7bcc1be427fc668e6f80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/038dc49afffb06ab20dd7bcc1be427fc668e6f80/comments", "author": null, "committer": null, "parents": [{"sha": "356aaf8b70407acd2057011d0b051e0cadfeda62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356aaf8b70407acd2057011d0b051e0cadfeda62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/356aaf8b70407acd2057011d0b051e0cadfeda62"}], "stats": {"total": 36, "additions": 20, "deletions": 16}, "files": [{"sha": "fb72b46c8b11a1123740c4f17aabe2c6dac0a1b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=038dc49afffb06ab20dd7bcc1be427fc668e6f80", "patch": "@@ -1,3 +1,17 @@\n+2009-11-24  Michael Matz  <matz@suse.de>\n+\n+\t* expr.c (set_storage_via_libcall): Fix build_call_expr call.\n+\n+2009-11-24  David Binderman  <dcb314@hotmail.com>\n+\n+\t* expr.c (store_field): Remove set but not used local variable\n+\twidth_mask.\n+\t(expand_expr_real_2): Remove treeop2.\n+\t* gcse.c (update_ld_motion_stores): Remove new_rtx.\n+\t* haifa-sched.c (max_issue): Remove points.\n+\t(sched_create_recovery_edges): Remove e.\n+\t* ira-costs.c (setup_allocno_cover_class_and_costs): Remove mode.\n+\n 2009-11-24  Nick Clifton  <nickc@redhat.com>\n \n \t* config/v850/v850.c (function_arg): Fix handling of zero-length"}, {"sha": "923db8f49c8a7666228d49dd697eb95e08507110", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=038dc49afffb06ab20dd7bcc1be427fc668e6f80", "patch": "@@ -2712,8 +2712,7 @@ set_storage_via_libcall (rtx object, rtx size, rtx val, bool tailcall)\n   val_tree = make_tree (integer_type_node, val);\n \n   fn = clear_storage_libcall_fn (true);\n-  call_expr = build_call_expr (fn, 3,\n-\t\t\t       object_tree, integer_zero_node, size_tree);\n+  call_expr = build_call_expr (fn, 3, object_tree, val_tree, size_tree);\n   CALL_EXPR_TAILCALL (call_expr) = tailcall;\n \n   retval = expand_normal (call_expr);\n@@ -5762,17 +5761,13 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t     enum machine_mode mode, tree exp, tree type,\n \t     alias_set_type alias_set, bool nontemporal)\n {\n-  HOST_WIDE_INT width_mask = 0;\n-\n   if (TREE_CODE (exp) == ERROR_MARK)\n     return const0_rtx;\n \n   /* If we have nothing to store, do nothing unless the expression has\n      side-effects.  */\n   if (bitsize == 0)\n     return expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-  else if (bitsize >= 0 && bitsize < HOST_BITS_PER_WIDE_INT)\n-    width_mask = ((HOST_WIDE_INT) 1 << bitsize) - 1;\n \n   /* If we are storing into an unaligned field of an aligned union that is\n      in a register, we may have the mode of TARGET being an integer mode but\n@@ -7213,7 +7208,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n   gimple subexp0_def, subexp1_def;\n   tree top0, top1;\n   location_t loc = ops->location;\n-  tree treeop0, treeop1, treeop2;\n+  tree treeop0, treeop1;\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field\t\t\t  \\\n \t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n \t\t\t\t\t\t\t\t  target, \\\n@@ -7226,7 +7221,6 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n   treeop0 = ops->op0;\n   treeop1 = ops->op1;\n-  treeop2 = ops->op2;\n \n   /* We should be called only on simple (binary or unary) expressions,\n      exactly those that are valid in gimple expressions that aren't"}, {"sha": "0da075f258585a64c88001fe07be800b5e5dc223", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=038dc49afffb06ab20dd7bcc1be427fc668e6f80", "patch": "@@ -4884,7 +4884,7 @@ update_ld_motion_stores (struct expr * expr)\n \t  rtx pat = PATTERN (insn);\n \t  rtx src = SET_SRC (pat);\n \t  rtx reg = expr->reaching_reg;\n-\t  rtx copy, new_rtx;\n+\t  rtx copy;\n \n \t  /* If we've already copied it, continue.  */\n \t  if (expr->reaching_reg == src)\n@@ -4900,7 +4900,7 @@ update_ld_motion_stores (struct expr * expr)\n \t    }\n \n \t  copy = gen_move_insn (reg, copy_rtx (SET_SRC (pat)));\n-\t  new_rtx = emit_insn_before (copy, insn);\n+\t  emit_insn_before (copy, insn);\n \t  SET_SRC (pat) = reg;\n \t  df_insn_rescan (insn);\n "}, {"sha": "1f05a7231f686f38a8e7d86514cd11611d5681cf", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=038dc49afffb06ab20dd7bcc1be427fc668e6f80", "patch": "@@ -2503,7 +2503,7 @@ int\n max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \t   int *index)\n {\n-  int n, i, all, n_ready, best, delay, tries_num, points = -1, max_points;\n+  int n, i, all, n_ready, best, delay, tries_num, max_points;\n   int more_issue;\n   struct choice_entry *top;\n   rtx insn;\n@@ -2593,7 +2593,6 @@ max_issue (struct ready_list *ready, int privileged_n, state_t state,\n \t\t  /* This is the index of the insn issued first in this\n \t\t     solution.  */\n \t\t  *index = choice_stack [1].index;\n-\t\t  points = top->n;\n \t\t  if (top->n == max_points || best == all)\n \t\t    break;\n \t\t}\n@@ -4462,7 +4461,6 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n {\n   rtx label;\n   rtx jump;\n-  edge e;\n   int edge_flags;\n \n   /* This is fixing of incoming edge.  */\n@@ -4473,7 +4471,7 @@ sched_create_recovery_edges (basic_block first_bb, basic_block rec,\n   else\n     edge_flags = 0;\n       \n-  e = make_edge (first_bb, rec, edge_flags);\n+  make_edge (first_bb, rec, edge_flags);\n   label = block_label (second_bb);\n   jump = emit_jump_insn_after (gen_jump (label), BB_END (rec));\n   JUMP_LABEL (jump) = label;"}, {"sha": "f74a2cac4339098e677d9f964f01ab356d95837b", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/038dc49afffb06ab20dd7bcc1be427fc668e6f80/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=038dc49afffb06ab20dd7bcc1be427fc668e6f80", "patch": "@@ -1534,15 +1534,13 @@ setup_allocno_cover_class_and_costs (void)\n   int i, j, n, regno, num;\n   int *reg_costs;\n   enum reg_class cover_class, rclass;\n-  enum machine_mode mode;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n \n   ira_assert (allocno_p);\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       i = ALLOCNO_NUM (a);\n-      mode = ALLOCNO_MODE (a);\n       cover_class = regno_cover_class[ALLOCNO_REGNO (a)];\n       ira_assert (pref[i] == NO_REGS || cover_class != NO_REGS);\n       ALLOCNO_MEMORY_COST (a) = COSTS (costs, i)->mem_cost;"}]}