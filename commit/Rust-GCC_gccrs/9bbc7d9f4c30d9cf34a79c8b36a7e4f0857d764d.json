{"sha": "9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiYzdkOWY0YzMwZDljZjM0YTc5YzhiMzZhN2U0ZjA4NTdkNzY0ZA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@cygnus.com", "date": "1998-11-15T14:37:52Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-15T14:37:52Z"}, "message": "decl.c (error_mark_node):  New global.\n\n\ufffd\n\t* decl.c (error_mark_node), java-tree.h:  New global.\n\t* parse.y:  Use empty_stmt_node instead of size_zero_node.\n\t(build_if_else_statement):  If missing else, use empty_stmt_node.\n\t* parse.y (not_initialized_as_it_should_p):  Removed, with its callers.\n\t(java_complete_expand_method):  Complain if return is missing.\n\t(java_check_regular_methods):  Comment out incorrect error check.\n\t(not_accessible_p):  Fix incorrect handling of protected methods.\n\t(patch_method_invocation):  Pass correct context to not_accessible_p.\n\t(find_applicable_accessible_methods_list):  Likewise.\n\t(qualify_ambiguous_name):  If ARRAY_REF, it's an expression name.\n\t(java_complete_tree):  For CASE_EXPR and DEFAULT_EXPR, set\n\tTREE_TYPE (to void_type_node);  otherwise expand_expr crashes.\n\t(patch_if_else_statement):  Fix setting of CAN_COMPLETE_NORMALLY.\n\t* jcf-write.c (CHECK_OP, CHECK_PUT):  Add some error checking.\n\t(push_int_const):  Remove reundant NOTE_PUSH.\n\t(generate_bytecode_insns - case STRING_CST):  Do NOTE_PUSH.\n\t(- case SWITCH_EXPR):  Fix code generation bug.\n\t(- case PREDECREMENT_EXPR etc):  Remove redundant NOTE_PUSH.\n\t(generate_classfile):  More robust for abstract methods.\n\nFrom-SVN: r23661", "tree": {"sha": "57ca81d68872cd1049e8022307078e2a68dd88b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57ca81d68872cd1049e8022307078e2a68dd88b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/comments", "author": null, "committer": null, "parents": [{"sha": "175135a659ad8d2ba5e827c1404d42d4924d98fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/175135a659ad8d2ba5e827c1404d42d4924d98fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/175135a659ad8d2ba5e827c1404d42d4924d98fc"}], "stats": {"total": 261, "additions": 144, "deletions": 117}, "files": [{"sha": "a9da798460aaeb4a2295947e3e0e4688427810ad", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "patch": "@@ -1,3 +1,27 @@\n+Sun Nov 15 14:36:29 1998  Per Bothner  <bothner@cygnus.com>\n+\n+\t* decl.c (error_mark_node), java-tree.h:  New global.\n+\t* parse.y:  Use empty_stmt_node instead of size_zero_node.\n+\t(build_if_else_statement):  If missing else, use empty_stmt_node.\n+\n+\t* parse.y (not_initialized_as_it_should_p):  Removed, with its callers.\n+\t(java_complete_expand_method):  Complain if return is missing.\n+\t(java_check_regular_methods):  Comment out incorrect error check.\n+\t(not_accessible_p):  Fix incorrect handling of protected methods.\n+\t(patch_method_invocation):  Pass correct context to not_accessible_p.\n+\t(find_applicable_accessible_methods_list):  Likewise.\n+\t(qualify_ambiguous_name):  If ARRAY_REF, it's an expression name.\n+\t(java_complete_tree):  For CASE_EXPR and DEFAULT_EXPR, set\n+\tTREE_TYPE (to void_type_node);  otherwise expand_expr crashes.\n+\t(patch_if_else_statement):  Fix setting of CAN_COMPLETE_NORMALLY.\n+\n+\t* jcf-write.c (CHECK_OP, CHECK_PUT):  Add some error checking.\n+\t(push_int_const):  Remove reundant NOTE_PUSH.\n+\t(generate_bytecode_insns - case STRING_CST):  Do NOTE_PUSH.\n+\t(- case SWITCH_EXPR):  Fix code generation bug.\n+\t(- case PREDECREMENT_EXPR etc):  Remove redundant NOTE_PUSH.\n+\t(generate_classfile):  More robust for abstract methods.\n+\n Sun Nov 15 13:52:39 1998  Anthony Green  <green@cygnus.com>\n \n \t* Makefile.in: jv-scan and jvgenmain all require libiberty."}, {"sha": "24118b914cbad33d363dad3ba97efb9c18cf09b3", "filename": "gcc/java/decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "patch": "@@ -318,6 +318,7 @@ tree error_mark_node;\n    The first is of type `int', the second of type `void *'.  */\n tree integer_zero_node;\n tree null_pointer_node;\n+tree empty_stmt_node;\n \n /* Nodes for boolean constants TRUE and FALSE. */\n tree boolean_true_node, boolean_false_node;\n@@ -431,8 +432,6 @@ init_decl_processing ()\n   TREE_TYPE (size_zero_node) = sizetype;\n   size_one_node = build_int_2 (1, 0);\n   TREE_TYPE (size_one_node) = sizetype;\n-  /* Used by the parser to represent empty statements and blocks. */\n-  CAN_COMPLETE_NORMALLY (size_zero_node) = 1;\n \n   byte_type_node = make_signed_type (8);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"byte\"), byte_type_node));\n@@ -475,6 +474,10 @@ init_decl_processing ()\n   null_pointer_node = build_int_2 (0, 0);\n   TREE_TYPE (null_pointer_node) = ptr_type_node;\n \n+  /* Used by the parser to represent empty statements and blocks. */\n+  empty_stmt_node = build1 (NOP_EXPR, void_type_node, size_zero_node);\n+  CAN_COMPLETE_NORMALLY (empty_stmt_node) = 1;\n+\n #if 0\n   /* Make a type to be the domain of a few array types\n      whose domains don't really matter."}, {"sha": "de9e1a33ede697629375c5322199ff974af1a6b3", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "patch": "@@ -220,6 +220,7 @@ extern tree boolean_true_node, boolean_false_node;\n extern tree integer_negative_one_node;\n extern tree integer_two_node;\n extern tree integer_four_node;\n+extern tree empty_stmt_node;\n \n /* The type for struct methodtable. */\n extern tree methodtable_type;"}, {"sha": "64c9e06475ff3610c8269ebe5c9eb6c312ff1f92", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "patch": "@@ -50,34 +50,25 @@ char *jcf_write_base_directory = NULL;\n /* Make sure bytecode.data is big enough for at least N more bytes. */\n \n #define RESERVE(N) \\\n-  do { if (state->bytecode.ptr + (N) > state->bytecode.limit) \\\n+  do { CHECK_OP(state); \\\n+    if (state->bytecode.ptr + (N) > state->bytecode.limit) \\\n     buffer_grow (&state->bytecode, N); } while (0)\n \n /* Add a 1-byte instruction/operand I to bytecode.data,\n    assuming space has already been RESERVE'd. */\n \n-#define OP1(I) (*state->bytecode.ptr++ = (I))\n+#define OP1(I) (*state->bytecode.ptr++ = (I), CHECK_OP(state))\n \n /* Like OP1, but I is a 2-byte big endian integer. */\n \n #define OP2(I) \\\n-  do { int _i = (I);  OP1 (_i >> 8);  OP1 (_i); } while (0)\n+  do { int _i = (I); OP1 (_i >> 8);  OP1 (_i); CHECK_OP(state); } while (0)\n \n /* Like OP1, but I is a 4-byte big endian integer. */\n \n #define OP4(I) \\\n   do { int _i = (I);  OP1 (_i >> 24);  OP1 (_i >> 16); \\\n-       OP1 (_i >> 8); OP1 (_i); } while (0)\n-\n-/* The current stack size (stack pointer) in the current method. */\n-\n-int code_SP = 0;\n-\n-/* The largest extent of stack size (stack pointer) in the current method. */\n-\n-int code_SP_max = 0;\n-\n-CPool *code_cpool;\n+       OP1 (_i >> 8); OP1 (_i); CHECK_OP(state); } while (0)\n \n /* Macro to call each time we push I words on the JVM stack. */\n \n@@ -138,7 +129,13 @@ struct jcf_block\n   } u;\n };\n \n+/* A \"relocation\" type for the 0-3 bytes of padding at the start\n+   of a tableswitch or a lookupswitch. */\n #define SWITCH_ALIGN_RELOC 4\n+\n+/* A relocation type for the labels in a tableswitch or a lookupswitch;\n+   these are relative to the start of the instruction, but (due to\n+   th 0-3 bytes of padding), we don't know the offset before relocation. */\n #define BLOCK_START_RELOC 1\n \n struct jcf_relocation\n@@ -253,10 +250,26 @@ static void generate_bytecode_insns PROTO ((tree, int, struct jcf_partial *));\n    We assume a local variable 'ptr' points into where we want to\n    write next, and we assume enoygh space has been allocated. */\n \n-#define PUT1(X)  (*ptr++ = (X))\n+#ifdef ENABLE_CHECKING\n+int\n+CHECK_PUT(ptr, state, i)\n+     void *ptr;\n+     struct jcf_partial *state;\n+     int i;\n+{\n+  if (ptr < state->chunk->data\n+      || (char*)ptr + i > state->chunk->data + state->chunk->size)\n+    fatal (\"internal error - CHECK_PUT failed\");\n+  return 0;\n+}\n+#else\n+#define CHECK_PUT(PTR, STATE, I) 0\n+#endif\n+\n+#define PUT1(X)  (CHECK_PUT(ptr, state, 1), *ptr++ = (X))\n #define PUT2(X)  (PUT1((X) >> 8), PUT1((X) & 0xFF))\n #define PUT4(X)  (PUT2((X) >> 16), PUT2((X) & 0xFFFF))\n-#define PUTN(P, N)  (memcpy(ptr, P, N), ptr += (N))\n+#define PUTN(P, N)  (CHECK_PUT(ptr, state, N), memcpy(ptr, P, N), ptr += (N))\n \n \f\n /* Allocate a new chunk on obstack WORK, and link it in after LAST.\n@@ -284,6 +297,20 @@ alloc_chunk (last, data, size, work)\n   return chunk;\n }\n \n+#ifdef ENABLE_CHECKING\n+int\n+CHECK_OP(struct jcf_partial *state)\n+{\n+  if (state->bytecode.ptr > state->bytecode.limit)\n+    {\n+      fatal(\"internal error - CHECK_OP failed\");\n+    }\n+  return 0;\n+}\n+#else\n+#define CHECK_OP(STATE) 0\n+#endif\n+\n unsigned char *\n append_chunk (data, size, state)\n      unsigned char *data;\n@@ -574,6 +601,9 @@ write_chunks (stream, chunks)\n     fwrite (chunks->data, chunks->size, 1, stream);\n }\n \n+/* Push a 1-word constant in the constant pool at the given INDEX.\n+   (Caller is responsible for doing NOTE_PUSH.) */\n+\n static void\n push_constant1 (index, state)\n      int index;\n@@ -592,6 +622,9 @@ push_constant1 (index, state)\n     }\n }\n \n+/* Push a 2-word constant in the constant pool at the given INDEX.\n+   (Caller is responsible for doing NOTE_PUSH.) */\n+\n static void\n push_constant2 (index, state)\n      int index;\n@@ -622,7 +655,6 @@ push_int_const (i, state)\n     {\n       OP1(OPCODE_sipush);\n       OP2(i);\n-      NOTE_PUSH (1);\n     }\n   else\n     {\n@@ -1257,6 +1289,7 @@ generate_bytecode_insns (exp, target, state)\n       break;\n     case STRING_CST:\n       push_constant1 (find_string_constant (&state->cpool, exp), state);\n+      NOTE_PUSH (1);\n       break;\n     case VAR_DECL:\n       if (TREE_STATIC (exp))\n@@ -1473,12 +1506,16 @@ generate_bytecode_insns (exp, target, state)\n \t\tOP4 (sw_state.max_case);\n \t\tfor (i = sw_state.min_case; ; )\n \t\t  {\n-\t\t    if (i == sw_state.min_case + index)\n-\t\t      emit_case_reloc (relocs[index++], state);\n+\t\t    reloc = relocs[index];\n+\t\t    if (i == reloc->offset)\n+\t\t      {\n+\t\t\temit_case_reloc (reloc, state);\n+\t\t\tif (i == sw_state.max_case)\n+\t\t\t  break;\n+\t\t\tindex++;\n+\t\t      }\n \t\t    else\n \t\t      emit_switch_reloc (sw_state.default_label, state);\n-\t\t    if (i == sw_state.max_case)\n-\t\t      break;\n \t\t    i++;\n \t\t  }\n \t      }\n@@ -1619,12 +1656,8 @@ generate_bytecode_insns (exp, target, state)\n \t  if (target != IGNORE_TARGET && post_op)\n \t    emit_load (exp, state);\n \t  emit_iinc (exp, value, state);\n-\t  if (target != IGNORE_TARGET)\n-\t    {\n-\t      if (! post_op)\n-\t\temit_load (exp, state);\n-\t      NOTE_PUSH (1);\n-\t    }\n+\t  if (target != IGNORE_TARGET && ! post_op)\n+\t    emit_load (exp, state);\n \t  break;\n \t}\n       if (TREE_CODE (exp) == COMPONENT_REF)\n@@ -2225,6 +2258,8 @@ perform_relocations (state)\n \t      *--new_ptr = 0;\n \t      *--new_ptr = - reloc->kind;\n \t    }\n+\t  if (new_ptr != chunk->data)\n+\t    fatal (\"internal error - perform_relocations\");\n \t}\n     }\n   state->code_length = pc;\n@@ -2352,7 +2387,9 @@ generate_classfile (clas, state)\n   for (part = TYPE_METHODS (clas);  part;  part = TREE_CHAIN (part))\n     {\n       struct jcf_block *block;\n-      tree body = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (part));\n+      tree function_body = DECL_FUNCTION_BODY (part);\n+      tree body = function_body == NULL_TREE ? NULL_TREE\n+\t: BLOCK_EXPR_BODY (function_body);\n       tree name = DECL_CONSTRUCTOR_P (part) ? init_identifier_node\n \t: DECL_NAME (part);\n       tree type = TREE_TYPE (part);"}, {"sha": "7a114c2d34a603f79e472acfca5e9339a9c3093c", "filename": "gcc/java/parse.y", "status": "modified", "additions": 49, "deletions": 87, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=9bbc7d9f4c30d9cf34a79c8b36a7e4f0857d764d", "patch": "@@ -786,7 +786,7 @@ constructor_body:\n \t   addition (super invocation and field initialization) */\n \tblock_begin block_end\n \t\t{ \n-\t\t  BLOCK_EXPR_BODY ($2) = size_zero_node;\n+\t\t  BLOCK_EXPR_BODY ($2) = empty_stmt_node;\n \t\t  $$ = $2;\n \t\t}\n |\tblock_begin explicit_constructor_invocation block_end\n@@ -951,7 +951,7 @@ variable_initializers:\n /* 19.11 Production from 14: Blocks and Statements  */\n block:\n \tOCB_TK CCB_TK\n-\t\t{ $$ = size_zero_node; }\n+\t\t{ $$ = empty_stmt_node; }\n |\tblock_begin block_statements block_end\n \t\t{ $$ = $3; }\n ;\n@@ -1033,7 +1033,7 @@ statement_without_trailing_substatement:\n \n empty_statement:\n \tSC_TK\n-\t\t{ $$ = size_zero_node; }\n+\t\t{ $$ = empty_stmt_node; }\n ;\n \n label_decl:\n@@ -1273,7 +1273,7 @@ for_statement:\n \t\t  $$ = complete_for_loop (0, NULL_TREE, $4, $6);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n \t\t  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY ($$), 0) = \n-\t\t    size_zero_node;\n+\t\t    empty_stmt_node;\n \t\t}\n |\tfor_begin SC_TK error\n \t\t{yyerror (\"Invalid control expression\"); RECOVER;}\n@@ -1291,7 +1291,7 @@ for_statement_nsi:\n \t\t  $$ = complete_for_loop (0, NULL_TREE, $4, $6);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n \t\t  LOOP_EXPR_BODY_CONDITION_EXPR (LOOP_EXPR_BODY ($$), 0) = \n-\t\t    size_zero_node;\n+\t\t    empty_stmt_node;\n \t\t}\n ;\n \n@@ -1322,7 +1322,7 @@ for_begin:\n \t\t}\n ;\n for_init:\t\t\t/* Can be empty */\n-\t\t{ $$ = size_zero_node; }\n+\t\t{ $$ = empty_stmt_node; }\n |\tstatement_expression_list\n \t\t{ \n \t\t  /* Init statement recorded within the previously\n@@ -1340,7 +1340,7 @@ for_init:\t\t\t/* Can be empty */\n ;\n \n for_update:\t\t\t/* Can be empty */\n-\t\t{$$ = size_zero_node;}\n+\t\t{$$ = empty_stmt_node;}\n |\tstatement_expression_list\n \t\t{ $$ = build_debugable_stmt (BUILD_LOCATION (), $1); }\n ;\n@@ -1636,6 +1636,8 @@ dims:\n field_access:\n \tprimary DOT_TK identifier\n \t\t{ $$ = make_qualified_primary ($1, $3, $2.location); }\n+\t\t/*  FIXME - REWRITE TO: \n+\t\t{ $$ = build_binop (COMPONENT_REF, $2.location, $1, $3); } */\n |\tSUPER_TK DOT_TK identifier\n \t\t{\n \t\t  tree super_wfl = \n@@ -2164,7 +2166,7 @@ parse_jdk1_1_error (msg)\n {\n   sorry (\": `%s' JDK1.1(TM) feature\", msg);\n   java_error_count++;\n-  return size_zero_node;\n+  return empty_stmt_node;\n }\n \n static int do_warning = 0;\n@@ -4206,6 +4208,7 @@ java_check_regular_methods (class_decl)\n \t exceptions, if any */\n       check_throws_clauses (method, method_wfl, found);\n \n+#if 0\n       /* If the method has default access in an other package, then\n \t issue a warning that the current method doesn't override the\n \t one that was found elsewhere. Do not issue this warning when\n@@ -4220,6 +4223,7 @@ java_check_regular_methods (class_decl)\n \t   lang_printable_name (found, 0),\n \t   IDENTIFIER_POINTER (DECL_NAME (class_decl)),\n \t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+#endif\n \n       /* Inheriting multiple methods with the same signature. FIXME */\n     }\n@@ -5239,6 +5243,8 @@ java_complete_expand_method (mdecl)\n   /* Expand functions that have a body */\n   if (DECL_FUNCTION_BODY (mdecl))\n     {\n+      tree fbody = DECL_FUNCTION_BODY (mdecl);\n+      tree block_body = BLOCK_EXPR_BODY (fbody);\n       expand_start_java_method (mdecl);\n \n       current_this \n@@ -5251,9 +5257,16 @@ java_complete_expand_method (mdecl)\n       /* Install exceptions thrown with `throws' */\n       PUSH_EXCEPTIONS (DECL_FUNCTION_THROWS (mdecl));\n \n-      if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)))\n-\tjava_complete_tree (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (mdecl)));\n+      if (block_body != NULL_TREE)\n+\tblock_body = java_complete_tree (block_body);\n+      BLOCK_EXPR_BODY (fbody) = block_body;\n \n+      if ((block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n+\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n+\t{\n+\t  parse_error_context (fbody, \"Missing return statement\");\n+\t}\n+      \n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n@@ -6040,26 +6053,14 @@ int not_accessible_p (reference, member, from_super)\n       if (class_in_current_package (DECL_CONTEXT (member)))\n \treturn 0;\n \n-      if (TREE_CODE (member) == FUNCTION_DECL && DECL_CONSTRUCTOR_P (member))\n-\t{\n-\t  /* Access from SUPER is granted */\n-\t  if (from_super)\n-\t    return 0;\n-\t  /* Otherwise, access isn't granted */\n-\t  return 1;\n-\t}\n-      else\n-\t{\n-\t  /* If accessed with the form `super.member', then access is\n-             granted */\n-\t  if (from_super)\n-\t    return 0;\n+      /* If accessed with the form `super.member', then access is granted */\n+      if (from_super)\n+\treturn 0;\n \n-\t  /* Otherwise, access is granted if occuring from the class where\n-\t     member is declared or a subclass of it */\n-\t  if (inherits_from_p (reference, current_class))\n-\t    return 0;\n-\t}\n+      /* Otherwise, access is granted if occuring from the class where\n+\t member is declared or a subclass of it */\n+      if (inherits_from_p (reference, current_class))\n+\treturn 0;\n       return 1;\n     }\n \n@@ -6376,7 +6377,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \n   /* Check accessibility, position the is_static flag, build and\n      return the call */\n-  if (not_accessible_p (DECL_CONTEXT (list), list, 0))\n+  if (not_accessible_p (DECL_CONTEXT (current_function_decl), list, 0))\n     {\n       char *fct_name = strdup (lang_printable_name (list, 0));\n       parse_error_context \n@@ -6646,7 +6647,7 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t  if (argument_types_convertible (method, arglist))\n \t    {\n \t      /* Retain accessible methods only */\n-\t      if (!not_accessible_p (class, method, 0))\n+\t      if (!not_accessible_p (DECL_CONTEXT (current_function_decl), method, 0))\n \t\tlist = tree_cons (NULL_TREE, method, list);\n \t      else\n \t      /* Also retain all selected method here */\n@@ -6884,7 +6885,8 @@ qualify_ambiguous_name (id)\n     }\n \n   /* Method call are expression name */\n-  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR)\n+  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR\n+\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF)\n     RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n \n   /* Check here that NAME isn't declared by more than one\n@@ -6945,22 +6947,6 @@ breakdown_qualified (left, right, source)\n   return 0;\n }\n \n-static int\n-not_initialized_as_it_should_p (decl)\n-     tree decl;\n-{\n-  if (DECL_P (decl))\n-    {\n-      if (FIELD_FINAL (decl))\n-\treturn 0;\n-      if (TREE_CODE (decl) == FIELD_DECL \n-\t  && (METHOD_STATIC (current_function_decl)))\n-\treturn 0;\n-      return DECL_P (decl) && !INITIALIZED_P (decl);\n-    }\n-  return 0;\n-}\n-\n /* Patch tree nodes in a function body. When a BLOCK is found, push\n    local variable decls if present.  */\n \n@@ -7127,6 +7113,7 @@ java_complete_tree (node)\n \t value is checked during code generation. The case\n \t expression is allright so far. */\n       TREE_OPERAND (node, 0) = cn;\n+      TREE_TYPE (node) = void_type_node;\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       break;\n \n@@ -7142,6 +7129,7 @@ java_complete_tree (node)\n \t}\n       else\n \tSWITCH_HAS_DEFAULT (nn) = 1;\n+      TREE_TYPE (node) = void_type_node;\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       break;\n \n@@ -7427,6 +7415,13 @@ java_complete_tree (node)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n       return patch_array_ref (node, wfl_op1, wfl_op2);\n \n+#if 0 \n+    COMPONENT_REF:\n+      /* Planned re-write FIXME */\n+      TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));\n+      break;\n+#endif\n+\n     case THIS_EXPR:\n       /* Can't use THIS in a static environment */\n       if (!current_this)\n@@ -7490,11 +7485,6 @@ complete_function_arguments (node)\n       parm = maybe_build_primttype_type_ref (parm, wfl);\n \n       TREE_VALUE (cn) = parm;\n-      if (not_initialized_as_it_should_p (parm))\n-\t{\n-\t  ERROR_VARIABLE_NOT_INITIALIZED (wfl, EXPR_WFL_NODE (wfl));\n-\t  INITIALIZED_P (parm) = 1;\n-\t}\n     }\n   ctxp->explicit_constructor_p -= (CALL_THIS_CONSTRUCTOR_P (node) ? 1 : 0);\n   return flag;\n@@ -7622,14 +7612,14 @@ maybe_absorb_scoping_blocks ()\n    are building incomplete tree nodes and the patch_* functions that\n    are completing them.  */\n \n-/* Build a super() constructor invocation. Returns size_zero_node if\n+/* Build a super() constructor invocation. Returns empty_stmt_node if\n    we're currently dealing with the class java.lang.Object. */\n \n static tree\n build_super_invocation ()\n {\n   if (current_class == object_type_node)\n-    return size_zero_node;\n+    return empty_stmt_node;\n   else\n     {\n       tree super_wfl = build_wfl_node (super_identifier_node, \n@@ -7880,14 +7870,6 @@ patch_assignment (node, wfl_op1, wfl_op2)\n       error_found = 1;\n     }\n \n-  /* Before reporting type incompatibility errors, check that the rhs\n-     is initialized, if a variable */\n-  if (not_initialized_as_it_should_p (rhs))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op2, DECL_NAME (rhs));\n-      INITIALIZED_P (rhs) = 1;\n-    }\n-\n   /* Inline read access to java.lang.PRIMTYPE.TYPE */\n   rhs = maybe_build_primttype_type_ref (rhs, wfl_op2);\n \n@@ -8296,14 +8278,6 @@ patch_binop (node, wfl_op1, wfl_op2)\n \n   EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);\n \n-  /* Check initialization of LHS first. We then silence further error\n-     message if the variable wasn't initialized */\n-  if (not_initialized_as_it_should_p (cfi))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (cfi_wfl, DECL_NAME (cfi));\n-      INITIALIZED_P (op1) = 1;\n-    }\n-\n   switch (code)\n     {\n     /* 15.16 Multiplicative operators */\n@@ -8581,16 +8555,6 @@ patch_binop (node, wfl_op1, wfl_op2)\n       break;\n     }\n \n-  /* Then check the initialization of the RHS. We don't do that if\n-     we're dealing with a node that is part of a compound\n-     assignment. We then silence further error message if the variable\n-     wasn't initialized */\n-  if (not_initialized_as_it_should_p (op2) && !COMPOUND_ASSIGN_P (node))\n-    {\n-      ERROR_VARIABLE_NOT_INITIALIZED (wfl_op2, DECL_NAME (op2));\n-      INITIALIZED_P (op2) = 1;\n-    }\n-\n   if (error_found)\n     return error_mark_node;\n \n@@ -9424,10 +9388,8 @@ build_if_else_statement (location, expression, if_body, else_body)\n      tree expression, if_body, else_body;\n {\n   tree node;\n-  /* FIXME: make else body be a void node, where this function is\n-     called */\n   if (!else_body)\n-    else_body = build (COMPOUND_EXPR, void_type_node, NULL_TREE, NULL_TREE);\n+    else_body = empty_stmt_node;\n   node = build (COND_EXPR, NULL_TREE, expression, if_body, else_body);\n   EXPR_WFL_LINECOL (node) = location;\n   node = build_debugable_stmt (location, node);\n@@ -9457,8 +9419,8 @@ patch_if_else_statement (node)\n   TREE_TYPE (node) = void_type_node;\n   TREE_SIDE_EFFECTS (node) = 1;\n   CAN_COMPLETE_NORMALLY (node)\n-    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 0))\n-    | CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n+    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1))\n+    | CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 2));\n   return node;\n }\n \n@@ -9584,7 +9546,7 @@ build_loop_body (location, condition, reversed)\n   second = (reversed ? condition : body);\n   return \n     build (COMPOUND_EXPR, NULL_TREE, \n-\t   build (COMPOUND_EXPR, NULL_TREE, first, second), size_zero_node);\n+\t   build (COMPOUND_EXPR, NULL_TREE, first, second), empty_stmt_node);\n }\n \n /* Install CONDITION (if any) and loop BODY (using REVERSED to tell"}]}