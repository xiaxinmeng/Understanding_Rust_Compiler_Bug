{"sha": "981975b62d8e098e571a91c30b938b4bcc7a3fa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgxOTc1YjYyZDhlMDk4ZTU3MWE5MWMzMGI5MzhiNGJjYzdhM2ZhNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-16T19:31:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-16T19:31:19Z"}, "message": "dwarf2out.c: Revert most of 2000-11-25 and 2001-01-24 changes.\n\n        * dwarf2out.c: Revert most of 2000-11-25 and 2001-01-24 changes.\n        (LN_PROLOG_AS_LABEL, LN_PROLOG_END_LABEL): New.\n        (size_of_line_prolog): Remove.\n        (output_line_info): Compute prologue size via label difference.\n        (lookup_filename): Return \"unspecified\" for <internal> and <built-in>.\n\n        * configure.in (HAVE_AS_DWARF2_DEBUG_LINE): Require that the\n        assembler error when redefining file numbers.\n        * config.in, configure: Rebuild.\n\nFrom-SVN: r40559", "tree": {"sha": "7db1544714b472b5f49960ccbe71531952d9a218", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7db1544714b472b5f49960ccbe71531952d9a218"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/981975b62d8e098e571a91c30b938b4bcc7a3fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981975b62d8e098e571a91c30b938b4bcc7a3fa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/981975b62d8e098e571a91c30b938b4bcc7a3fa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981975b62d8e098e571a91c30b938b4bcc7a3fa7/comments", "author": null, "committer": null, "parents": [{"sha": "69e230371807f22b3dc52ee64e87314fb61c750c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e230371807f22b3dc52ee64e87314fb61c750c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69e230371807f22b3dc52ee64e87314fb61c750c"}], "stats": {"total": 337, "additions": 125, "deletions": 212}, "files": [{"sha": "4b1e27e9f4c47cf36f9362a95c490765697a319b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=981975b62d8e098e571a91c30b938b4bcc7a3fa7", "patch": "@@ -1,3 +1,15 @@\n+2001-03-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c: Revert most of 2000-11-25 and 2001-01-24 changes.\n+\t(LN_PROLOG_AS_LABEL, LN_PROLOG_END_LABEL): New.\n+\t(size_of_line_prolog): Remove.\n+\t(output_line_info): Compute prologue size via label difference.\n+\t(lookup_filename): Return \"unspecified\" for <internal> and <built-in>.\n+\n+\t* configure.in (HAVE_AS_DWARF2_DEBUG_LINE): Require that the\n+\tassembler error when redefining file numbers.\n+\t* config.in, configure: Rebuild.\n+\n 2001-03-16  Michael Meissner  <meissner@redhat.com>\n \n \t* mips.h (BITMASK_HIGH): Replacement for 0x80000000 that avoids"}, {"sha": "d47920426ec3429940d4751fb21ebf783d175442", "filename": "gcc/config.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=981975b62d8e098e571a91c30b938b4bcc7a3fa7", "patch": "@@ -465,7 +465,8 @@\n /* Define if your assembler supports offsetable %lo(). */\n #undef HAVE_AS_OFFSETABLE_LO10\n \n-/* Define if your assembler supports dwarf2 .file/.loc directives. */\n+/* Define if your assembler supports dwarf2 .file/.loc directives,\n+   and preserves file table indicies exactly as given. */\n #undef HAVE_AS_DWARF2_DEBUG_LINE\n \n /* Define to 1 if you want to enable namespaces (-fhonor-std) by default. */"}, {"sha": "9af92cb63930352586aa59737a625c791f748e55", "filename": "gcc/configure", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=981975b62d8e098e571a91c30b938b4bcc7a3fa7", "patch": "@@ -2098,7 +2098,7 @@ EOF\n fi\n \n # Find some useful tools\n-for ac_prog in mawk gawk nawk awk\n+for ac_prog in gawk mawk nawk awk\n do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n@@ -6688,9 +6688,21 @@ elif test x$gcc_cv_as != x -a x\"$insn\" != x ; then\n \techo '\t.file 0 \"conftest.s\"' > conftest.s\n \techo '\t.loc 0 3 0' >> conftest.s\n \techo \"\t$insn\" >> conftest.s\n+\t# ??? This fails with non-gnu grep.\n \tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1 \\\n \t   && grep debug_line conftest.o > /dev/null 2>&1 ; then\n-\t\tgcc_cv_as_dwarf2_debug_line=\"yes\"\n+\t\t# The .debug_line file table must be in the exact order that\n+\t\t# we specified the files, since these indicies are also used\n+\t\t# by DW_AT_decl_file.  Approximate this test by testing if\n+\t\t# the assembler bitches if the same index is assigned twice.\n+\t\techo '\t.file 1 \"foo.s\"' > conftest.s\n+\t\techo '\t.file 1 \"bar.s\"' >> conftest.s\n+\t\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1\n+\t\tthen\n+\t\t  gcc_cv_as_dwarf2_debug_line=\"no\"\n+\t\telse\n+\t\t  gcc_cv_as_dwarf2_debug_line=\"yes\"\n+\t\tfi\n \tfi\n \trm -f conftest.s conftest.o conftest.nm1 conftest.nm2\n fi\n@@ -6837,7 +6849,7 @@ EOF\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:6841: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:6853: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "c5fdc2d7cfc286852ca0c29381a087092536873c", "filename": "gcc/configure.in", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=981975b62d8e098e571a91c30b938b4bcc7a3fa7", "patch": "@@ -1494,15 +1494,28 @@ elif test x$gcc_cv_as != x -a x\"$insn\" != x ; then\n \techo '\t.file 0 \"conftest.s\"' > conftest.s\n \techo '\t.loc 0 3 0' >> conftest.s\n \techo \"\t$insn\" >> conftest.s\n+\t# ??? This fails with non-gnu grep.\n \tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1 \\\n \t   && grep debug_line conftest.o > /dev/null 2>&1 ; then\n-\t\tgcc_cv_as_dwarf2_debug_line=\"yes\"\n+\t\t# The .debug_line file table must be in the exact order that\n+\t\t# we specified the files, since these indicies are also used\n+\t\t# by DW_AT_decl_file.  Approximate this test by testing if\n+\t\t# the assembler bitches if the same index is assigned twice.\n+\t\techo '\t.file 1 \"foo.s\"' > conftest.s\n+\t\techo '\t.file 1 \"bar.s\"' >> conftest.s\n+\t\tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1\n+\t\tthen\n+\t\t  gcc_cv_as_dwarf2_debug_line=\"no\"\n+\t\telse\n+\t\t  gcc_cv_as_dwarf2_debug_line=\"yes\"\n+\t\tfi\n \tfi\n \trm -f conftest.s conftest.o conftest.nm1 conftest.nm2\n fi\n if test x\"$gcc_cv_as_dwarf2_debug_line\" = xyes; then\n \tAC_DEFINE(HAVE_AS_DWARF2_DEBUG_LINE, 1,\n-\t  [Define if your assembler supports dwarf2 .file/.loc directives.])\n+[Define if your assembler supports dwarf2 .file/.loc directives,\n+   and preserves file table indicies exactly as given.])\n fi\n AC_MSG_RESULT($gcc_cv_as_dwarf2_debug_line)\n "}, {"sha": "b192aab47d95ecaf9e677cb2ed2de4dead958c70", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 81, "deletions": 206, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/981975b62d8e098e571a91c30b938b4bcc7a3fa7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=981975b62d8e098e571a91c30b938b4bcc7a3fa7", "patch": "@@ -294,8 +294,10 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n #define FDE_AFTER_SIZE_LABEL\t\"LASFDE\"\n #define FDE_END_LABEL\t\t\"LEFDE\"\n #define FDE_LENGTH_LABEL\t\"LLFDE\"\n-#define LINE_NUMBER_BEGIN_LABEL\t\"LTSTART\"\n-#define LINE_NUMBER_END_LABEL\t\"LTEND\"\n+#define LINE_NUMBER_BEGIN_LABEL\t\"LSLT\"\n+#define LINE_NUMBER_END_LABEL\t\"LELT\"\n+#define LN_PROLOG_AS_LABEL\t\"LASLTP\"\n+#define LN_PROLOG_END_LABEL\t\"LELTP\"\n #define DIE_LABEL_PREFIX\t\"DW\"\n \n /* Definitions of defaults for various types of primitive assembly language\n@@ -2946,11 +2948,8 @@ struct file_table\n    table.  */\n #define FILE_TABLE_INCREMENT 64\n \n-/* Filenames referenced by declarations this compilation unit.  */\n-static struct file_table decl_file_table;\n-\n-/* Filenames referenced by line numbers in this compilation unit.  */\n-static struct file_table line_file_table;\n+/* Filenames referenced by this compilation unit.  */\n+static struct file_table file_table;\n \n /* Local pointer to the name of the main input file.  Initialized in\n    dwarf2out_init.  */\n@@ -3183,7 +3182,6 @@ static unsigned long size_of_die\tPARAMS ((dw_die_ref));\n static void calc_die_sizes\t\tPARAMS ((dw_die_ref));\n static void mark_dies\t\t\tPARAMS ((dw_die_ref));\n static void unmark_dies\t\t\tPARAMS ((dw_die_ref));\n-static unsigned long size_of_line_prolog PARAMS ((void));\n static unsigned long size_of_pubnames\tPARAMS ((void));\n static unsigned long size_of_aranges\tPARAMS ((void));\n static enum dwarf_form value_format\tPARAMS ((dw_attr_ref));\n@@ -3281,9 +3279,8 @@ static void gen_block_die\t\tPARAMS ((tree, dw_die_ref, int));\n static void decls_for_scope\t\tPARAMS ((tree, dw_die_ref, int));\n static int is_redundant_typedef\t\tPARAMS ((tree));\n static void gen_decl_die\t\tPARAMS ((tree, dw_die_ref));\n-static unsigned lookup_filename\t\tPARAMS ((struct file_table *,\n-\t\t\t\t\t\t const char *));\n-static void init_file_table\t\tPARAMS ((struct file_table *));\n+static unsigned lookup_filename\t\tPARAMS ((const char *));\n+static void init_file_table\t\tPARAMS ((void));\n static void add_incomplete_type\t\tPARAMS ((tree));\n static void retry_incomplete_types\tPARAMS ((void));\n static void gen_type_die_for_member\tPARAMS ((tree, tree, dw_die_ref));\n@@ -4738,7 +4735,7 @@ print_dwarf_line_table (outfile)\n     {\n       line_info = &line_info_table[i];\n       fprintf (outfile, \"%5d: \", i);\n-      fprintf (outfile, \"%-20s\", line_file_table.table[line_info->dw_file_num]);\n+      fprintf (outfile, \"%-20s\", file_table.table[line_info->dw_file_num]);\n       fprintf (outfile, \"%6ld\", line_info->dw_line_num);\n       fprintf (outfile, \"\\n\");\n     }\n@@ -5403,45 +5400,6 @@ unmark_dies (die)\n     unmark_dies (c);\n }\n \n-/* Return the size of the line information prolog generated for the\n-   compilation unit.  */\n-\n-static unsigned long\n-size_of_line_prolog ()\n-{\n-  register unsigned long size;\n-  register unsigned long ft_index;\n-\n-  size = DWARF_LINE_PROLOG_HEADER_SIZE;\n-\n-  /* Count the size of the table giving number of args for each\n-     standard opcode.  */\n-  size += DWARF_LINE_OPCODE_BASE - 1;\n-\n-  /* Include directory table is empty (at present).  Count only the\n-     null byte used to terminate the table.  */\n-  size += 1;\n-\n-  for (ft_index = 1; ft_index < decl_file_table.in_use; ++ft_index)\n-    {\n-      /* File name entry.  */\n-      size += size_of_string (decl_file_table.table[ft_index]);\n-\n-      /* Include directory index.  */\n-      size += size_of_uleb128 (0);\n-\n-      /* Modification time.  */\n-      size += size_of_uleb128 (0);\n-\n-      /* File length in bytes.  */\n-      size += size_of_uleb128 (0);\n-    }\n-\n-  /* Count the file table terminator.  */\n-  size += 1;\n-  return size;\n-}\n-\n /* Return the size of the .debug_pubnames table  generated for the\n    compilation unit.  */\n \n@@ -6003,8 +5961,6 @@ struct dir_info\n   char *path;\t\t/* Path including directory name.  */\n   int length;\t\t/* Path length.  */\n   int prefix;\t\t/* Index of directory entry which is a prefix.  */\n-  int nbytes;\t\t/* Total number of bytes in all file names excluding\n-\t\t\t   paths.  */\n   int count;\t\t/* Number of files in this directory.  */\n   int dir_idx;\t\t/* Index of directory used as base.  */\n   int used;\t\t/* Used in the end?  */\n@@ -6050,33 +6006,6 @@ file_info_cmp (p1, p2)\n     }\n }\n \n-/* Compute the maximum prefix of P2 appearing also in P1.  Entire\n-   directory names must match.  */\n-static int prefix_of PARAMS ((struct dir_info *, struct dir_info *));\n-static int\n-prefix_of (p1, p2)\n-     struct dir_info *p1;\n-     struct dir_info *p2;\n-{\n-  char *s1 = p1->path;\n-  char *s2 = p2->path;\n-  int len = p1->length < p2->length ? p1->length : p2->length;\n-\n-  while (*s1 == *s2 && s1 < p1->path + len)\n-    ++s1, ++s2;\n-\n-  if (*s1 == '/' && *s2 == '/')\n-    /* The whole of P1 is the prefix.  */\n-    return p1->length;\n-\n-  /* Go back to the last directory component.  */\n-  while (s1 > p1->path)\n-    if (*--s1 == '/')\n-      return s1 - p1->path + 1;\n-\n-  return 0;\n-}\n-\n /* Output the directory table and the file name table.  We try to minimize\n    the total amount of memory needed.  A heuristic is used to avoid large\n    slowdowns with many input files.  */\n@@ -6094,18 +6023,18 @@ output_file_names ()\n   int idx;\n \n   /* Allocate the various arrays we need.  */\n-  files = (struct file_info *) alloca (line_file_table.in_use\n+  files = (struct file_info *) alloca (file_table.in_use\n \t\t\t\t       * sizeof (struct file_info));\n-  dirs = (struct dir_info *) alloca (line_file_table.in_use * 2\n+  dirs = (struct dir_info *) alloca (file_table.in_use\n \t\t\t\t     * sizeof (struct dir_info));\n \n   /* Sort the file names.  */\n-   for (i = 1; i < (int) line_file_table.in_use; ++i)\n+  for (i = 1; i < (int) file_table.in_use; ++i)\n     {\n       char *f;\n \n       /* Skip all leading \"./\".  */\n-      f = line_file_table.table[i];\n+      f = file_table.table[i];\n       while (f[0] == '.' && f[1] == '/')\n \tf += 2;\n \n@@ -6118,86 +6047,48 @@ output_file_names ()\n       f = strrchr (f, '/');\n       files[i].fname = f == NULL ? files[i].path : f + 1;\n     }\n-  qsort (files + 1, line_file_table.in_use - 1, sizeof (files[0]),\n-\t file_info_cmp);\n+  qsort (files + 1, file_table.in_use - 1, sizeof (files[0]), file_info_cmp);\n \n   /* Find all the different directories used.  */\n   dirs[0].path = files[1].path;\n   dirs[0].length = files[1].fname - files[1].path;\n   dirs[0].prefix = -1;\n-  dirs[0].nbytes = files[1].length - dirs[1].length + 1;\n   dirs[0].count = 1;\n   dirs[0].dir_idx = 0;\n   dirs[0].used = 0;\n   files[1].dir_idx = 0;\n   ndirs = 1;\n \n-  for (i = 2; i < (int) line_file_table.in_use; ++i)\n+  for (i = 2; i < (int) file_table.in_use; ++i)\n     if (files[i].fname - files[i].path == dirs[ndirs - 1].length\n \t&& memcmp (dirs[ndirs - 1].path, files[i].path,\n \t\t   dirs[ndirs - 1].length) == 0)\n       {\n \t/* Same directory as last entry.  */\n \tfiles[i].dir_idx = ndirs - 1;\n-\tdirs[ndirs - 1].nbytes += files[i].length - dirs[ndirs - 1].length + 1;\n \t++dirs[ndirs - 1].count;\n       }\n     else\n       {\n \tint j;\n-\tint max_idx;\n-\tint max_len;\n \n \t/* This is a new directory.  */\n \tdirs[ndirs].path = files[i].path;\n \tdirs[ndirs].length = files[i].fname - files[i].path;\n-\tdirs[ndirs].nbytes = files[i].length - dirs[i].length + 1;\n \tdirs[ndirs].count = 1;\n \tdirs[ndirs].dir_idx = ndirs;\n \tdirs[ndirs].used = 0;\n \tfiles[i].dir_idx = ndirs;\n \n \t/* Search for a prefix.  */\n-\tmax_len = 0;\n-\tmax_idx = 0;\n+\tdirs[ndirs].prefix = -1;\n \tfor (j = 0; j < ndirs; ++j)\n-\t  if (dirs[j].length > max_len)\n-\t    {\n-\t      int this_len = prefix_of (&dirs[j], &dirs[ndirs]);\n-\n-\t      if (this_len > max_len)\n-\t\t{\n-\t\t  max_len = this_len;\n-\t\t  max_idx = j;\n-\t\t}\n-\t    }\n-\n-\t/* Remember the prefix.  If this is a known prefix simply\n-\t   remember the index.  Otherwise we will have to create an\n-\t   artificial entry.  */\n-\tif (max_len == dirs[max_idx].length)\n-\t  /* This is our prefix.  */\n-\t  dirs[ndirs].prefix = max_idx;\n-\telse if (max_len > 0)\n-\t  {\n-\t    /* Create an entry without associated file.  Since we have\n-\t       to keep the dirs array sorted (means, entries with paths\n-\t       which come first) we have to move the new entry in the\n-\t       place of the old one.  */\n-\t    dirs[++ndirs] = dirs[max_idx];\n-\n-\t    /* We don't have to set .path.  */\n-\t    dirs[max_idx].length = max_len;\n-\t    dirs[max_idx].nbytes = 0;\n-\t    dirs[max_idx].count = 0;\n-\t    dirs[max_idx].dir_idx = ndirs;\n-\t    dirs[max_idx].used = 0;\n-\t    dirs[max_idx].prefix = dirs[ndirs].prefix;\n-\n-\t    dirs[ndirs - 1].prefix = dirs[ndirs].prefix = max_idx;\n-\t  }\n-\telse\n-\t  dirs[ndirs].prefix = -1;\n+\t  if (dirs[j].length < dirs[ndirs].length\n+\t      && dirs[j].length > 1\n+\t      && (dirs[ndirs].prefix == -1\n+\t\t  || dirs[j].length > dirs[dirs[ndirs].prefix].length)\n+\t      && memcmp (dirs[j].path, dirs[ndirs].path, dirs[j].length) == 0)\n+\t    dirs[ndirs].prefix = j;\n \n \t++ndirs;\n       }\n@@ -6218,7 +6109,7 @@ output_file_names ()\n       int j;\n       int total;\n \n-      /* We can always safe some space for the current directory.  But\n+      /* We can always save some space for the current directory.  But\n \t this does not mean it will be enough to justify adding the\n \t directory.  */\n       savehere[i] = dirs[i].length;\n@@ -6234,26 +6125,26 @@ output_file_names ()\n \t\t dirs[j] path.  */\n \t      int k;\n \n-\t       k = dirs[j].prefix;\n-\t       while (k != -1 && k != i)\n-\t\t k = dirs[k].prefix;\n-\n-\t       if (k == i)\n-\t\t {\n-\t\t   /* Yes it is.  We can possibly safe some memory but\n-\t\t      writing the filenames in dirs[j] relative to\n-\t\t      dirs[i].  */\n-\t\t   savehere[j] = dirs[i].length;\n-\t\t   total += (savehere[j] - saved[j]) * dirs[j].count;\n-\t\t }\n+\t      k = dirs[j].prefix;\n+\t      while (k != -1 && k != i)\n+\t\tk = dirs[k].prefix;\n+\n+\t      if (k == i)\n+\t\t{\n+\t\t  /* Yes it is.  We can possibly safe some memory but\n+\t\t     writing the filenames in dirs[j] relative to\n+\t\t     dirs[i].  */\n+\t\t  savehere[j] = dirs[i].length;\n+\t\t  total += (savehere[j] - saved[j]) * dirs[j].count;\n+\t\t}\n \t    }\n \t}\n \n       /* Check whether we can safe enough to justify adding the dirs[i]\n \t directory.  */\n       if (total > dirs[i].length + 1)\n \t{\n-\t   /* It's worthwhile adding.  */\n+\t  /* It's worthwhile adding.  */\n           for (j = i; j < ndirs; ++j)\n \t    if (savehere[j] > 0)\n \t      {\n@@ -6266,12 +6157,12 @@ output_file_names ()\n \t}\n     }\n \n-  /* We have to emit them in the order they appear in the line_file_table\n+  /* We have to emit them in the order they appear in the file_table\n      array since the index is used in the debug info generation.  To\n      do this efficiently we generate a back-mapping of the indices\n      first.  */\n-  backmap = (int *) alloca (line_file_table.in_use * sizeof (int));\n-  for (i = 1; i < (int) line_file_table.in_use; ++i)\n+  backmap = (int *) alloca (file_table.in_use * sizeof (int));\n+  for (i = 1; i < (int) file_table.in_use; ++i)\n     {\n       backmap[files[i].file_idx] = i;\n       /* Mark this directory as used.  */\n@@ -6301,7 +6192,7 @@ output_file_names ()\n     dirs[0].used = 0;\n \n   /* Now write all the file names.  */\n-  for (i = 1; i < (int) line_file_table.in_use; ++i)\n+  for (i = 1; i < (int) file_table.in_use; ++i)\n     {\n       int file_idx = backmap[i];\n       int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;\n@@ -6328,7 +6219,7 @@ output_file_names ()\n static void\n output_line_info ()\n {\n-  char l1[20], l2[20];\n+  char l1[20], l2[20], p1[20], p2[20];\n   char line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char prev_line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register unsigned opc;\n@@ -6342,15 +6233,17 @@ output_line_info ()\n \n   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n+  ASM_GENERATE_INTERNAL_LABEL (p1, LN_PROLOG_AS_LABEL, 0);\n+  ASM_GENERATE_INTERNAL_LABEL (p2, LN_PROLOG_END_LABEL, 0);\n \n   dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n \t\t\t\"Length of Source Line Info\");\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n   dw2_asm_output_data (2, DWARF_VERSION, \"DWARF Version\");\n \n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, size_of_line_prolog (),\n-\t\t       \"Prolog Length\");\n+  dw2_asm_output_delta (DWARF_OFFSET_SIZE, p2, p1, \"Prolog Length\");\n+  ASM_OUTPUT_LABEL (asm_out_file, p1);\n \n   dw2_asm_output_data (1, DWARF_LINE_MIN_INSTR_LENGTH,\n \t\t       \"Minimum Instruction Length\");\n@@ -6389,6 +6282,7 @@ output_line_info ()\n \n   /* Write out the information about the files we use.  */\n   output_file_names ();\n+  ASM_OUTPUT_LABEL (asm_out_file, p2);\n \n   /* We used to set the address register to the first location in the text\n      section here, but that didn't accomplish anything since we already\n@@ -6451,7 +6345,7 @@ output_line_info ()\n \t  current_file = line_info->dw_file_num;\n \t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n \t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n-\t\t\t\t       line_file_table.table[current_file]);\n+\t\t\t\t       file_table.table[current_file]);\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -6562,7 +6456,7 @@ output_line_info ()\n \t  current_file = line_info->dw_file_num;\n \t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n \t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n-\t\t\t\t       line_file_table.table[current_file]);\n+\t\t\t\t       file_table.table[current_file]);\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -8570,8 +8464,7 @@ add_src_coords_attributes (die, decl)\n      register dw_die_ref die;\n      register tree decl;\n {\n-  register unsigned file_index = lookup_filename (&decl_file_table,\n-\t\t\t\t\t\t  DECL_SOURCE_FILE (decl));\n+  register unsigned file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n \n   add_AT_unsigned (die, DW_AT_decl_file, file_index);\n   add_AT_unsigned (die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n@@ -9315,8 +9208,7 @@ gen_subprogram_die (decl, context_die)\n     }\n   else if (old_die)\n     {\n-      register unsigned file_index\n-\t= lookup_filename (&decl_file_table, DECL_SOURCE_FILE (decl));\n+      unsigned file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n \n       if (!get_AT_flag (old_die, DW_AT_declaration)\n \t  /* We can have a normal definition following an inline one in the\n@@ -9577,8 +9469,7 @@ gen_variable_die (decl, context_die)\n       add_AT_die_ref (var_die, DW_AT_specification, old_die);\n       if (DECL_NAME (decl))\n \t{\n-\t  register unsigned file_index\n-\t    = lookup_filename (&decl_file_table, DECL_SOURCE_FILE (decl));\n+\t  unsigned file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n \n \t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n \t    add_AT_unsigned (var_die, DW_AT_decl_file, file_index);\n@@ -10620,7 +10511,7 @@ dwarf2out_add_library_unit_info (filename, context_list)\n \n       TREE_PUBLIC (context_list_decl) = TRUE;\n       add_name_attribute (unit_die, context_list);\n-      file_index = lookup_filename (&decl_file_table, filename);\n+      file_index = lookup_filename (filename);\n       add_AT_unsigned (unit_die, DW_AT_decl_file, file_index);\n       add_pubname (context_list_decl, unit_die);\n     }\n@@ -10794,54 +10685,57 @@ dwarf2out_ignore_block (block)\n    was looked up last.  This handles the majority of all searches.  */\n \n static unsigned\n-lookup_filename (t, file_name)\n-     struct file_table *t;\n+lookup_filename (file_name)\n      const char *file_name;\n {\n   register unsigned i;\n \n+  /* ??? Why isn't DECL_SOURCE_FILE left null instead.  */\n+  if (strcmp (file_name, \"<internal>\") == 0\n+      || strcmp (file_name, \"<built-in>\") == 0)\n+    return 0;\n+\n   /* Check to see if the file name that was searched on the previous\n      call matches this file name.  If so, return the index.  */\n-  if (t->last_lookup_index != 0)\n-    if (strcmp (file_name, t->table[t->last_lookup_index]) == 0)\n-      return t->last_lookup_index;\n+  if (file_table.last_lookup_index != 0)\n+    if (strcmp (file_name, file_table.table[file_table.last_lookup_index]) == 0)\n+      return file_table.last_lookup_index;\n \n   /* Didn't match the previous lookup, search the table */\n-  for (i = 1; i < t->in_use; ++i)\n-    if (strcmp (file_name, t->table[i]) == 0)\n+  for (i = 1; i < file_table.in_use; ++i)\n+    if (strcmp (file_name, file_table.table[i]) == 0)\n       {\n-\tt->last_lookup_index = i;\n+\tfile_table.last_lookup_index = i;\n \treturn i;\n       }\n \n   /* Prepare to add a new table entry by making sure there is enough space in\n      the table to do so.  If not, expand the current table.  */\n-  if (i == t->allocated)\n+  if (i == file_table.allocated)\n     {\n-      t->allocated = i + FILE_TABLE_INCREMENT;\n-      t->table = (char **)\n-\txrealloc (t->table, t->allocated * sizeof (char *));\n+      file_table.allocated = i + FILE_TABLE_INCREMENT;\n+      file_table.table = (char **)\n+\txrealloc (file_table.table, file_table.allocated * sizeof (char *));\n     }\n \n   /* Add the new entry to the end of the filename table.  */\n-  t->table[i] = xstrdup (file_name);\n-  t->in_use = i + 1;\n-  t->last_lookup_index = i;\n+  file_table.table[i] = xstrdup (file_name);\n+  file_table.in_use = i + 1;\n+  file_table.last_lookup_index = i;\n \n   return i;\n }\n \n static void\n-init_file_table (t)\n-     struct file_table *t;\n+init_file_table ()\n {\n   /* Allocate the initial hunk of the file_table.  */\n-  t->table = (char **) xcalloc (FILE_TABLE_INCREMENT, sizeof (char *));\n-  t->allocated = FILE_TABLE_INCREMENT;\n+  file_table.table = (char **) xcalloc (FILE_TABLE_INCREMENT, sizeof (char *));\n+  file_table.allocated = FILE_TABLE_INCREMENT;\n \n   /* Skip the first entry - file numbers begin at 1.  */\n-  t->in_use = 1;\n-  t->last_lookup_index = 0;\n+  file_table.in_use = 1;\n+  file_table.last_lookup_index = 0;\n }\n \n /* Output a label to mark the beginning of a source code line entry\n@@ -10859,28 +10753,10 @@ dwarf2out_line (filename, line)\n \n       if (DWARF2_ASM_LINE_DEBUG_INFO)\n \t{\n-#if 0\n-\t  unsigned old_in_use = line_file_table.in_use;\n-#endif\n-\t  unsigned file_num = lookup_filename (&line_file_table, filename);\n+\t  unsigned file_num = lookup_filename (filename);\n \n-\t  /* Emit the .file and .loc directives understood by GNU as.  */\n-#if 0\n-\t  /* ??? As of 2000-11-25, gas has a bug in which it doesn't\n-\t     actually use the file number argument.  It merely remembers\n-\t     the last .file directive emitted.  */\n-\t  if (file_num >= old_in_use)\n-\t    fprintf (asm_out_file, \"\\t.file %d \\\"%s\\\"\\n\", file_num, filename);\n+\t  /* Emit the .loc directive understood by GNU as.  */\n \t  fprintf (asm_out_file, \"\\t.loc %d %d 0\\n\", file_num, line);\n-#else\n-\t  static unsigned int last_file_num;\n-\t  if (file_num != last_file_num)\n-\t    {\n-\t      last_file_num = file_num;\n-\t      fprintf (asm_out_file, \"\\t.file 0 \\\"%s\\\"\\n\", filename);\n-\t    }\n-\t  fprintf (asm_out_file, \"\\t.loc 0 %d 0\\n\", line);\n-#endif\n \n \t  /* Indicate that line number info exists.  */\n \t  ++line_info_table_in_use;\n@@ -10913,7 +10789,7 @@ dwarf2out_line (filename, line)\n \t  /* Add the new entry at the end of the line_info_table.  */\n \t  line_info\n \t    = &separate_line_info_table[separate_line_info_table_in_use++];\n-\t  line_info->dw_file_num = lookup_filename (&line_file_table, filename);\n+\t  line_info->dw_file_num = lookup_filename (filename);\n \t  line_info->dw_line_num = line;\n \t  line_info->function = current_funcdef_number;\n \t}\n@@ -10940,7 +10816,7 @@ dwarf2out_line (filename, line)\n \n \t  /* Add the new entry at the end of the line_info_table.  */\n \t  line_info = &line_info_table[line_info_table_in_use++];\n-\t  line_info->dw_file_num = lookup_filename (&line_file_table, filename);\n+\t  line_info->dw_file_num = lookup_filename (filename);\n \t  line_info->dw_line_num = line;\n \t}\n     }\n@@ -11012,8 +10888,7 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   /* Remember the name of the primary input file.  */\n   primary_filename = main_input_filename;\n \n-  init_file_table (&decl_file_table);\n-  init_file_table (&line_file_table);\n+  init_file_table ();\n \n   /* Allocate the initial hunk of the decl_die_table.  */\n   decl_die_table"}]}