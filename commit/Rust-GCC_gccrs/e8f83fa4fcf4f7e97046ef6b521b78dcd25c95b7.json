{"sha": "e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThmODNmYTRmY2Y0ZjdlOTcwNDZlZjZiNTIxYjc4ZGNkMjVjOTViNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-27T00:21:52Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-27T15:50:49Z"}, "message": "libstdc++: Refactor dejagnu effective-target checks\n\nThis introduces two new procs to replace boilerplate in the\neffective-target checks.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/lib/libstdc++.exp (v3_try_preprocess): Define\n\tnew proc to preprocess a chunk of code.\n\t(v3_check_preprocessor_condition): Define new proc to test\n\ta preprocessor condition depending on GCC or libstdc++ macros.\n\t(check_v3_target_debug_mode, check_v3_target_normal_mode):\n\tUse v3_try_preprocess.\n\t(check_v3_target_normal_namespace)\n\t(check_v3_target_parallel_mode, check_v3_target_cstdint)\n\t(check_v3_target_cmath, check_v3_target_atomic_builtins)\n\t(check_v3_target_gthreads, check_v3_target_gthreads_timed)\n\t(check_v3_target_sleep, check_v3_target_sched_yield)\n\t(check_v3_target_string_conversions, check_v3_target_swprintf)\n\t(check_v3_target_binary_io, check_v3_target_nprocs): Use\n\tv3_check_preprocessor_condition.\n\t(check_effective_target_cxx11): Likewise.\n\t(check_effective_target_random_device): Likewise.\n\t(check_effective_target_tbb-backend): Likewise.\n\t(check_effective_target_futex): Likewise.\n\t(check_v3_target_little_endian) Call check_effective_target_le.\n\t(check_effective_target_atomic-builtins): New proc to define\n\tnew effective-target keyword.\n\t(check_effective_target_gthreads-timed): Likewise.", "tree": {"sha": "365888cfade8a9ffed0a123e9d0efb7bbc0f5a7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/365888cfade8a9ffed0a123e9d0efb7bbc0f5a7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9df6c9c7a3936ff0a38a7066281842128cdd6914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9df6c9c7a3936ff0a38a7066281842128cdd6914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9df6c9c7a3936ff0a38a7066281842128cdd6914"}], "stats": {"total": 622, "additions": 145, "deletions": 477}, "files": [{"sha": "e000dba968f77d90f1ab08bebb0d3235233c04f3", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 145, "deletions": 477, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=e8f83fa4fcf4f7e97046ef6b521b78dcd25c95b7", "patch": "@@ -945,153 +945,117 @@ proc check_v3_target_namedlocale { args } {\n     }]\n }\n \n-proc check_v3_target_debug_mode { } {\n-    return [check_v3_target_prop_cached et_debug_mode {\n-\tglobal tool\n-\t# Set up and preprocess a C++ test program that depends\n-\t# on debug mode activated.\n-\tset src debug_mode[pid].cc\n+# Returns 1 if the tokens in CODE can be preprocessed successfully using FLAGS,\n+# returns 0 otherwise.\n+proc v3_try_preprocess { name code flags } {\n+    global tool\n+    global cxxflags\n \n-\tset f [open $src \"w\"]\n-\tputs $f \"#ifndef _GLIBCXX_DEBUG\"\n-\tputs $f \"#  error No debug mode\"\n-\tputs $f \"#endif\"\n-\tclose $f\n+    # Set up and preprocess a C++ translation unit.\n+    set src $name[pid].cc\n \n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tfile delete $src\n+    set f [open $src \"w\"]\n+    puts $f $code\n+    close $f\n \n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t}\n-\treturn 0\n-    }]\n+    set cxxflags_saved $cxxflags\n+    set cxxflags \"$flags\"\n+\n+    set lines [v3_target_compile $src /dev/null preprocess \"\"]\n+    set cxxflags $cxxflags_saved\n+    file delete $src\n+\n+    if [string match \"\" $lines] {\n+\tverbose \"v3_try_preprocess $name: preprocessing passed\" 3\n+\t# No error message, preprocessing succeeded.\n+\treturn 1\n+    }\n+    verbose \"v3_try_preprocess $name: preprocessing failed\" 2\n+    return 0\n }\n \n-proc check_v3_target_normal_mode { } {\n-    return [check_v3_target_prop_cached et_normal_mode {\n-\tglobal tool\n-\t# Set up and compile a C++ test program that depends\n-\t# on normal mode activated.\n-\tset src normal_mode[pid].cc\n+# Return 1 if COND evaluates to true in the preprocessor, 0 otherwise.\n+# The <bits/c++config.h> config header is included.\n+proc v3_check_preprocessor_condition { name cond } {\n+    global cxxflags\n+    global DEFAULT_CXXFLAGS\n \n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#if defined(_GLIBCXX_DEBUG) || defined(_GLIBCXX_PARALLEL)\"\n-\tputs $f \"#  error No normal mode\"\n-\tputs $f \"#endif\"\n-\tclose $f\n+    set code \"\n+\t#include <bits/c++config.h>\n+\t#if ! ($cond)\n+\t#error '$cond' is false\n+\t#endif\n+\t\"\n+    set flags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n \n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tfile delete $src\n+    return [v3_try_preprocess name $code $flags]\n+}\n \n-\tif [string match \"\" $lines] {\n-\t    # No error message, compilation succeeded.\n-\t    return 1\n-\t}\n-\treturn 0\n+# Return 1 if Debug Mode is active, 0 otherwise.\n+proc check_v3_target_debug_mode { } {\n+    global cxxflags\n+    return [check_v3_target_prop_cached et_debug_mode {\n+\tset code \"\n+\t#if ! defined _GLIBCXX_DEBUG\n+\t# error no debug mode\n+\t#endif\n+\t\"\n+\treturn [v3_try_preprocess debug_mode $code $cxxflags]\n     }]\n }\n \n+# Return 1 if normal mode is active, 0 otherwise.\n+# i.e. neither Debug Mode nor Parallel Mode is active.\n+proc check_v3_target_normal_mode { } {\n+    global cxxflags\n+    return [check_v3_target_prop_cached et_normal_mode {\n+\tset code \"\n+\t#if defined _GLIBCXX_DEBUG\n+\t# error debug mode\n+\t#endif\n+\t#if defined _GLIBCXX_PARALLEL\n+\t# error parallel mode\n+\t#endif\n+\t\"\n+\treturn [v3_try_preprocess normal_mode $code $cxxflags]\n+    }]\n+}\n+\n+# Return 1 if unversioned namespace is in use, 0 otherwise.\n+# i.e. the library uses namespace std:: not std::__8:: or similar.\n proc check_v3_target_normal_namespace { } {\n     return [check_v3_target_prop_cached et_normal_namespace {\n-\tglobal tool\n-\t# Set up and compile a C++ test program that depends\n-\t# on normal std namespace.\n-\tset src normal_namespace[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#if _GLIBCXX_INLINE_VERSION\"\n-\tputs $f \"#  error No normal namespace\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, compilation succeeded.\n-\t    return 1\n-\t}\n-\treturn 0\n+\tset cond \"!_GLIBCXX_INLINE_VERSION\"\n+\treturn [v3_check_preprocessor_condition normal_namespace $cond]\n     }]\n }\n \n+# Return 1 if the libgomp is being used, 0 otherwise.\n proc check_v3_target_parallel_mode { } {\n     return [check_v3_target_prop_cached et_parallel_mode {\n \tglobal cxxflags\n \tglobal v3-libgomp\n-\t# If 'make check-parallel' is running the test succeeds.\n+\t# If 'make check-parallel' is running then the test succeeds.\n \tif { ${v3-libgomp} == 1 && [regexp \"libgomp\" $cxxflags] } {\n \t    return 1\n \t}\n \treturn 0\n     }]\n }\n \n+# Return 1 if the C99 stdint facilities are available, 0 otherwise.\n proc check_v3_target_cstdint { } {\n     return [check_v3_target_prop_cached et_cstdint {\n-\tglobal DEFAULT_CXXFLAGS\n-\tglobal cxxflags\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on the C99 stdint facilities to be available.\n-\tset src cstdint[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <tr1/cstdint>\"\n-\tputs $f \"#ifndef _GLIBCXX_USE_C99_STDINT_TR1\"\n-\tputs $f \"#  error No C99 stdint\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocess succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_cstdint: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"defined _GLIBCXX_USE_C99_STDINT_TR1\"\n+\treturn [v3_check_preprocessor_condition cstdint $cond]\n     }]\n }\n \n+# Return 1 if the C99 math facilities are available, 0 otherwise.\n proc check_v3_target_cmath { } {\n     return [check_v3_target_prop_cached et_c99_math {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on the C99 math facilities to be available.\n-\tset src c99_math[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <tr1/cmath>\"\n-\tputs $f \"#ifndef _GLIBCXX_USE_C99_MATH_TR1\"\n-\tputs $f \"#  error No C99 math\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocess succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_c99_math: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"defined _GLIBCXX_USE_C99_MATH_TR1\"\n+\treturn [v3_check_preprocessor_condition cmath $cond]\n     }]\n }\n \n@@ -1100,15 +1064,16 @@ proc check_v3_target_thread_fence { } {\n \tglobal cxxflags\n \tglobal DEFAULT_CXXFLAGS\n \n-\t# Set up and preprocess a C++11 test program that depends\n+\t# Set up and link a C++11 test program that depends\n \t# on the thread fence to be available.\n \tset src thread_fence[pid].cc\n \n \tset f [open $src \"w\"]\n-\tputs $f \"int main() {\"\n-\tputs $f \"__atomic_thread_fence (__ATOMIC_SEQ_CST);\"\n-\tputs $f \"return 0;\"\n-\tputs $f \"}\"\n+\tputs $f \"\n+\tint main() {\n+\t__atomic_thread_fence (__ATOMIC_SEQ_CST);\n+\treturn 0;\n+\t}\"\n \tclose $f\n \n \tset cxxflags_saved $cxxflags\n@@ -1128,309 +1093,106 @@ proc check_v3_target_thread_fence { } {\n     }]\n }\n \n+# Return 1 if atomics_bool and atomic_int are always lock-free, 0 otherwise.\n proc check_v3_target_atomic_builtins { } {\n     return [check_v3_target_prop_cached et_atomic_builtins {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\n-\t# Set up and preprocess a C++11 test program that depends\n-\t# on the atomic builtin facilities to be available.\n-\tset src atomic_builtins[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#if __GCC_ATOMIC_BOOL_LOCK_FREE < 2\"\n-\tputs $f \"#  error No atomic bool\"\n-\tputs $f \"#endif\"\n-\tputs $f \"#if __GCC_ATOMIC_INT_LOCK_FREE < 2\"\n-\tputs $f \"#  error No atomic int\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror -std=gnu++11\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocess succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_atomic_builtins: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"__GCC_ATOMIC_BOOL_LOCK_FREE > 1 && __GCC_ATOMIC_INT_LOCK_FREE > 1\"\n+\treturn [v3_check_preprocessor_condition atomic_builtins $cond]\n     }]\n }\n \n+# Define \"atomic-builtins\" as an effective-target keyword.\n+proc check_effective_target_atomic-builtins { } {\n+    return [check_v3_target_atomic_builtins]\n+}\n+\n+# Return 1 if C++11 [threads] facilities are available via gthreads,\n+# 0 otherwise.\n proc check_v3_target_gthreads { } {\n     return [check_v3_target_prop_cached et_gthreads {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on the gthreads facilities to be available.\n-\tset src gthreads[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#ifndef _GLIBCXX_HAS_GTHREADS\"\n-\tputs $f \"#  error No gthread\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_gthreads: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"defined _GLIBCXX_HAS_GTHREADS\"\n+\treturn [v3_check_preprocessor_condition gthreads $cond]\n     }]\n }\n \n+# Define \"gthreads\" as an effective-target keyword.\n+proc check_effective_target_gthreads { } {\n+    return [check_v3_target_gthreads]\n+}\n+\n+# Return 1 if C++11 timed mutexes are available via gthreads, 0 otherwise.\n proc check_v3_target_gthreads_timed { } {\n     return [check_v3_target_prop_cached et_gthreads_timed {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on the gthreads timed mutex facilities to be available.\n-\tset src gthreads_timed[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#ifndef _GLIBCXX_HAS_GTHREADS\"\n-\tputs $f \"#  error No gthread\"\n-\tputs $f \"#endif\"\n-\tputs $f \"#if !_GTHREAD_USE_MUTEX_TIMEDLOCK\"\n-\tputs $f \"#  error No gthread timed mutexes\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n+\tif [check_v3_target_gthreads] {\n+\t    set cond \"defined _GTHREAD_USE_MUTEX_TIMEDLOCK\"\n+\t    return [v3_check_preprocessor_condition gthreads_timed $cond]\n \t} else {\n-\t    verbose \"check_v3_target_gthreads_timed: compilation failed\" 2\n \t    return 0\n \t}\n     }]\n }\n \n+# Define \"gthreads-timed\" as an effective-target keyword.\n+proc check_effective_target_gthreads-timed { } {\n+    return [check_v3_target_gthreads_timed]\n+}\n+\n+# Return 1 if either nanosleep or sleep is available, 0 otherwise.\n proc check_v3_target_sleep { } {\n     return [check_v3_target_prop_cached et_sleep {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\t# Set up and preprocess a C++11 test program that depends\n-\t# on the sleep facilities to be available.\n-\tset src sleep[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#ifndef _GLIBCXX_USE_NANOSLEEP\"\n-\tputs $f \"# ifndef _GLIBCXX_HAVE_SLEEP\"\n-\tputs $f \"#  error No nanosleep or sleep\"\n-\tputs $f \"# endif\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_sleep: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"defined _GLIBCXX_USE_NANOSLEEP || defined _GLIBCXX_HAVE_SLEEP\"\n+\treturn [v3_check_preprocessor_condition sleep $cond]\n     }]\n }\n \n+# Return 1 if __gthread_yield is available, 0 otherwise.\n proc check_v3_target_sched_yield { } {\n     return [check_v3_target_prop_cached et_sched_yield {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on the sched_yield facility to be available.\n-\tset src sched_yield[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#ifndef _GLIBCXX_USE_SCHED_YIELD\"\n-\tputs $f \"#  error No sched yield\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_sched_yield: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"defined _GLIBCXX_USE_SCHED_YIELD\"\n+\treturn [v3_check_preprocessor_condition sched_yield $cond]\n     }]\n }\n \n+# Return 1 if the [string.conversions] facilities are available, 0 otherwise.\n proc check_v3_target_string_conversions { } {\n     return [check_v3_target_prop_cached et_string_conversions {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on the string_conversions facilities to be available.\n-\tset src string_conversions[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#if !(_GLIBCXX_USE_C99_STDIO && _GLIBCXX_USE_C99_STDLIB && _GLIBCXX_USE_C99_WCHAR) || defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF)\"\n-\tputs $f \"#  error No string conversions\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_string_conversions: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"_GLIBCXX_USE_C99_STDIO && _GLIBCXX_USE_C99_STDLIB\"\n+\tset cond \"$cond && _GLIBCXX_USE_C99_WCHAR\"\n+\tset cond \"$cond && !defined _GLIBCXX_HAVE_BROKEN_VSWPRINTF\"\n+\treturn [v3_check_preprocessor_condition string_conversions $cond]\n     }]\n }\n \n+# Return 1 if a standard-conforming swprintf is available, 0 otherwise.\n proc check_v3_target_swprintf { } {\n     return [check_v3_target_prop_cached et_swprintf {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on a standard swprintf function to be available.\n-\tset src swprintf[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#if defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF)\"\n-\tputs $f \"#  error No swprintf\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_swprintf: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"! defined _GLIBCXX_HAVE_BROKEN_VSWPRINTF\"\n+\treturn [v3_check_preprocessor_condition swprintf $cond]\n     }]\n }\n \n+# Return 1 if text and binary I/O are the same, 0 otherwise.\n proc check_v3_target_binary_io { } {\n     return [check_v3_target_prop_cached et_binary_io {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on text and binary I/O being the same.\n-\tset src binary_io[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#if defined(_GLIBCXX_HAVE_DOS_BASED_FILESYSTEM)\"\n-\tputs $f \"#  error No binary io\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_binary_io: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"! defined _GLIBCXX_HAVE_DOS_BASED_FILESYSTEM\"\n+\treturn [v3_check_preprocessor_condition binary_io $cond]\n     }]\n }\n \n+# Return 1 if get_nprocs or pthreads_num_processors_np or a suitable sysconf\n+# is available, 0 otherwise.\n proc check_v3_target_nprocs { } {\n     return [check_v3_target_prop_cached et_nprocs {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\t# Set up and preprocess a C++0x test program that depends\n-\t# on either get_nprocs or sysconf to be available.\n-\tset src nprocs[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#if defined(_GLIBCXX_USE_GET_NPROCS)\"\n-\tputs $f \"#elif defined(_GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP)\"\n-\tputs $f \"#elif defined(_GLIBCXX_USE_SYSCTL_HW_NCPU)\"\n-\tputs $f \"#elif defined(_GLIBCXX_USE_SC_NPROCESSORS_ONLN)\"\n-\tputs $f \"#elif defined(_GLIBCXX_USE_SC_NPROC_ONLN)\"\n-\tputs $f \"#else\"\n-\tputs $f \"#  error hardware_concurrency not implemented\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocess succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_nprocs: compilation failed\" 2\n-\t    return 0\n-\t}\n+\tset cond \"defined _GLIBCXX_USE_GET_NPROCS\"\n+\tset cond \"$cond || defined _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP\"\n+\tset cond \"$cond || defined _GLIBCXX_USE_SYSCTL_HW_NCPU\"\n+\tset cond \"$cond || defined _GLIBCXX_USE_SC_NPROCESSORS_ONLN\"\n+\tset cond \"$cond || defined _GLIBCXX_USE_SC_NPROC_ONLN\"\n+\treturn [v3_check_preprocessor_condition nprocs $cond]\n     }]\n }\n \n+# Return 1 if linking with -static-libstdc++ works, 0 otherwise.\n proc check_v3_target_static_libstdcxx { } {\n     return [check_v3_target_prop_cached et_static_libstdcxx {\n \tglobal cxxflags\n@@ -1466,32 +1228,7 @@ proc check_v3_target_static_libstdcxx { } {\n }\n \n proc check_v3_target_little_endian { } {\n-    return [check_v3_target_prop_cached et_little_endian {\n-\tglobal cxxflags\n-\tglobal DEFAULT_CXXFLAGS\n-\tset src little_endian[pid].cc\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__\"\n-\tputs $f \"#  error Not little endian\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset cxxflags_saved $cxxflags\n-\tset cxxflags \"$cxxflags $DEFAULT_CXXFLAGS -Werror\"\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tset cxxflags $cxxflags_saved\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    return 1\n-\t} else {\n-\t    verbose \"check_v3_target_little_endian: compilation failed\" 2\n-\t    return 0\n-\t}\n-    }]\n+    return [check_effective_target_le]\n }\n \n # Return 1 if the Filesystem TS is supported, 0 otherwise.\n@@ -1530,61 +1267,18 @@ proc check_v3_target_filesystem_ts { } {\n # Any flags provided by RUNTESTFLAGS or a target board will be used here.\n # Flags added in the test by dg-options or dg-add-options will not be used.\n proc check_effective_target_cxx11-abi { } {\n-    global cxxflags\n-\n-    # Set up and preprocess a C++ test program that depends\n-    # on the new ABI being enabled.\n-    set src cxx11_abi[pid].cc\n-\n-    set f [open $src \"w\"]\n-    puts $f \"#include <bits/c++config.h>\"\n-    puts $f \"#if ! _GLIBCXX_USE_CXX11_ABI\"\n-    puts $f \"#  error old ABI in use\"\n-    puts $f \"#endif\"\n-    close $f\n-\n-    set lines [v3_target_compile $src /dev/null preprocess \"\"]\n-    file delete $src\n-\n-    if [string match \"\" $lines] {\n-\t# No error message, preprocessing succeeded.\n-\tverbose \"check_v3_cxx11_abi: `1'\" 2\n-\treturn 1\n-    }\n-\n-    verbose \"check_v3_cxx11_abi: `0'\" 2\n-    return 0\n+    set cond \"_GLIBCXX_USE_CXX11_ABI\"\n+    return [v3_check_preprocessor_condition cxx11_abi $cond]\n }\n \n-# Return 1 if std::random_device should be usable using the current flags, 0 otherwise.\n+# Return 1 if std::random_device should be usable using the current flags,\n+# 0 otherwise.\n proc check_effective_target_random_device { } {\n-    global cxxflags\n-\n-    # Set up and preprocess a C++ test program that depends\n-    # on std::random_device being usable.\n-    set src random_device[pid].cc\n-\n-    set f [open $src \"w\"]\n-    puts $f \"#include <bits/c++config.h>\"\n-    puts $f \"#if ! _GLIBCXX_USE_RANDOM_TR1\"\n-    puts $f \"#  error No working std::random_device available\"\n-    puts $f \"#endif\"\n-    close $f\n-\n-    set lines [v3_target_compile $src /dev/null preprocess \"\"]\n-    file delete $src\n-\n-    if [string match \"\" $lines] {\n-\t# No error message, preprocessing succeeded.\n-\tverbose \"check_v3_random_device: `1'\" 2\n-\treturn 1\n-    }\n-\n-    verbose \"check_v3_random_device: `0'\" 2\n-    return 0\n+    set cond \"_GLIBCXX_USE_RANDOM_TR1\"\n+    return [v3_check_preprocessor_condition random_device $cond]\n }\n \n-# Return 1 if tbb parallel backend is available\n+# Return 1 if tbb parallel backend is available, 0 otherwise.\n proc check_effective_target_tbb-backend { } {\n     return [check_v3_target_prop_cached et_tbb {\n         # Set up and compile a C++ test program that depends on tbb\n@@ -1619,37 +1313,11 @@ proc check_effective_target_tbb-backend { } {\n # Return 1 if futex syscall is available\n proc check_effective_target_futex { } {\n     return [check_v3_target_prop_cached et_futex {\n-\t# Set up and compile a C++ test program that depends on futex\n-\t# being supported.\n-\tset src futex[pid].cc\n-\tset exe futex[pid].x\n-\n-\tset f [open $src \"w\"]\n-\tputs $f \"#include <bits/c++config.h>\"\n-\tputs $f \"#if ! _GLIBCXX_HAVE_LINUX_FUTEX\"\n-\tputs $f \"#  error No futex syscall available\"\n-\tputs $f \"#endif\"\n-\tclose $f\n-\n-\tset lines [v3_target_compile $src /dev/null preprocess \"\"]\n-\tfile delete $src\n-\n-\tif [string match \"\" $lines] {\n-\t    # No error message, preprocessing succeeded.\n-\t    verbose \"check_v3_futex: `1'\" 2\n-\t    return 1\n-\t}\n-\tverbose \"check_v3_futex: `0'\" 2\n-\treturn 0\n+\tset cond \"_GLIBCXX_HAVE_LINUX_FUTEX\"\n+\treturn [v3_check_preprocessor_condition futex $cond]\n     }]\n }\n \n-# Return 1 if C++11 [threads] facilities are available via gthreads,\n-# 0 otherwise.\n-proc check_effective_target_gthreads { } {\n-    return [check_v3_target_gthreads]\n-}\n-\n set additional_prunes \"\"\n \n if { [info exists env(GCC_RUNTEST_PARALLELIZE_DIR)] \\"}]}