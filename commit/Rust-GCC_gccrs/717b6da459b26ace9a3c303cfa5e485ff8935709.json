{"sha": "717b6da459b26ace9a3c303cfa5e485ff8935709", "node_id": "C_kwDOANBUbNoAKDcxN2I2ZGE0NTliMjZhY2U5YTNjMzAzY2ZhNWU0ODVmZjg5MzU3MDk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-23T23:09:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-23T23:09:25Z"}, "message": "Merge #814\n\n814: Set TREE_ADDRESSABLE when we need to borrow any expression r=philberty a=philberty\n\nGCC requires VAR_DECL's and PARAM_DECL's to be marked with TREE_ADDRESSABLE\r\nwhen the declaration will be used in borrow's ('&' getting the address).\r\nThis takes into account the implicit addresses when we do autoderef in\r\nmethod resolution/operator-overloading.\r\n\r\nIf it is not set we end up in cases like this:\r\n\r\n```c\r\ni32 main ()\r\n{\r\n  i32 a.1;\r\n  i32 D.86;\r\n  i32 a;\r\n\r\n  a = 1;\r\n  a.1 = a; // this is wrong\r\n  <i32 as AddAssign>::add_assign (&a.1, 2);\r\n  D.86 = 0;\r\n  return D.86;\r\n}\r\n```\r\n\r\nYou can see GCC will automatically make a copy of the VAR_DECL resulting bad code-generation.\r\n\r\nFixes #804\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "fad38abf4fc4875a2d3c72336a154d3892a7f1a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fad38abf4fc4875a2d3c72336a154d3892a7f1a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/717b6da459b26ace9a3c303cfa5e485ff8935709", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhnXSlCRBK7hj4Ov3rIwAAH0MIAHP2DzYMr2tBbiTkHmNqfPaf\nroq7XFjWCTMQtetNzObU2wkKP9yd0HaBBvkZoed5Vo6Golf3apNFDUKzOg3MjOEC\nB9uawbs17zWGvwu6PKj2TMQJmQDKZ4Sh1j0NLcsbDmNXpjlOCgkaCY0hqams4yXY\nUPlYVvK9YvEr1/fH2hFm2HqQjFCNV7sRgbyAd3huJOmp5ID4Hc+YqJKUnPOSHb5v\niCJ2b0HujnjpHChzXCw5lmWm68VmssFNS/hevypRGonPhp2Is/1lL0T1imQNpn3C\n1KvBt0pzScwN2XaqAy/k7+OiwcFumMVA/XmCGILmsRCSCYRAdmtIpDFum4Hv94s=\n=q9zv\n-----END PGP SIGNATURE-----\n", "payload": "tree fad38abf4fc4875a2d3c72336a154d3892a7f1a6\nparent a41851dfb5bec6f40fd89db01ae75fee557306ee\nparent 8b36f2b80ebd0e0304b6df4020b5992640662667\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637708965 +0000\ncommitter GitHub <noreply@github.com> 1637708965 +0000\n\nMerge #814\n\n814: Set TREE_ADDRESSABLE when we need to borrow any expression r=philberty a=philberty\n\nGCC requires VAR_DECL's and PARAM_DECL's to be marked with TREE_ADDRESSABLE\r\nwhen the declaration will be used in borrow's ('&' getting the address).\r\nThis takes into account the implicit addresses when we do autoderef in\r\nmethod resolution/operator-overloading.\r\n\r\nIf it is not set we end up in cases like this:\r\n\r\n```c\r\ni32 main ()\r\n{\r\n  i32 a.1;\r\n  i32 D.86;\r\n  i32 a;\r\n\r\n  a = 1;\r\n  a.1 = a; // this is wrong\r\n  <i32 as AddAssign>::add_assign (&a.1, 2);\r\n  D.86 = 0;\r\n  return D.86;\r\n}\r\n```\r\n\r\nYou can see GCC will automatically make a copy of the VAR_DECL resulting bad code-generation.\r\n\r\nFixes #804\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/717b6da459b26ace9a3c303cfa5e485ff8935709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/717b6da459b26ace9a3c303cfa5e485ff8935709", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/717b6da459b26ace9a3c303cfa5e485ff8935709/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a41851dfb5bec6f40fd89db01ae75fee557306ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41851dfb5bec6f40fd89db01ae75fee557306ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41851dfb5bec6f40fd89db01ae75fee557306ee"}, {"sha": "8b36f2b80ebd0e0304b6df4020b5992640662667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b36f2b80ebd0e0304b6df4020b5992640662667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b36f2b80ebd0e0304b6df4020b5992640662667"}], "stats": {"total": 368, "additions": 344, "deletions": 24}, "files": [{"sha": "6aaa0fc3227a4d5c0e6061388326354f5ad20d06", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -86,6 +86,7 @@ GRS_OBJS = \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n+    rust/rust-hir-address-taken.o \\\n     rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\"}, {"sha": "126b49f690eb4a66c0cc6fb09216c90dde5c7559", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -20,6 +20,7 @@\n #define RUST_COMPILE_FNPARAM\n \n #include \"rust-compile-base.h\"\n+#include \"rust-hir-address-taken.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -33,33 +34,41 @@ class CompileFnParam : public HIRCompileBase\n \t\t\t     HIR::FunctionParam *param, tree decl_type,\n \t\t\t     Location locus)\n   {\n-    CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n+    CompileFnParam compiler (ctx, fndecl, decl_type, locus, *param);\n     param->get_param_name ()->accept_vis (compiler);\n-    return compiler.translated;\n+    return compiler.compiled_param;\n   }\n \n   void visit (HIR::IdentifierPattern &pattern) override\n   {\n     if (!pattern.is_mut ())\n       decl_type = ctx->get_backend ()->immutable_type (decl_type);\n \n-    translated\n+    bool address_taken = false;\n+    address_taken_context->lookup_addess_taken (\n+      param.get_mappings ().get_hirid (), &address_taken);\n+\n+    compiled_param\n       = ctx->get_backend ()->parameter_variable (fndecl, pattern.variable_ident,\n-\t\t\t\t\t\t decl_type,\n-\t\t\t\t\t\t false /* address_taken */,\n+\t\t\t\t\t\t decl_type, address_taken,\n \t\t\t\t\t\t locus);\n   }\n \n private:\n-  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus)\n+  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus,\n+\t\t  const HIR::FunctionParam &param)\n     : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n-      locus (locus), translated (nullptr)\n+      locus (locus), param (param),\n+      compiled_param (ctx->get_backend ()->error_variable ()),\n+      address_taken_context (Resolver::AddressTakenContext::get ())\n   {}\n \n   tree fndecl;\n   tree decl_type;\n   Location locus;\n-  ::Bvariable *translated;\n+  const HIR::FunctionParam &param;\n+  Bvariable *compiled_param;\n+  const Resolver::AddressTakenContext *address_taken_context;\n };\n \n class CompileSelfParam : public HIRCompileBase\n@@ -74,9 +83,13 @@ class CompileSelfParam : public HIRCompileBase\n     if (is_immutable)\n       decl_type = ctx->get_backend ()->immutable_type (decl_type);\n \n+    const auto &address_taken_context = Resolver::AddressTakenContext::get ();\n+    bool address_taken = false;\n+    address_taken_context->lookup_addess_taken (\n+      self.get_mappings ().get_hirid (), &address_taken);\n+\n     return ctx->get_backend ()->parameter_variable (fndecl, \"self\", decl_type,\n-\t\t\t\t\t\t    false /* address_taken */,\n-\t\t\t\t\t\t    locus);\n+\t\t\t\t\t\t    address_taken, locus);\n   }\n };\n "}, {"sha": "097f5b8af38cf652b8733aadfd4a2b7cb845aacd", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -20,6 +20,7 @@\n #define RUST_COMPILE_VAR_DECL\n \n #include \"rust-compile-base.h\"\n+#include \"rust-hir-address-taken.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -33,10 +34,9 @@ class CompileVarDecl : public HIRCompileBase\n   {\n     CompileVarDecl compiler (ctx, fndecl);\n     stmt->accept_vis (compiler);\n-    rust_assert (compiler.translated != nullptr);\n     ctx->insert_var_decl (stmt->get_mappings ().get_hirid (),\n-\t\t\t  compiler.translated);\n-    return compiler.translated;\n+\t\t\t  compiler.compiled_variable);\n+    return compiler.compiled_variable;\n   }\n \n   void visit (HIR::LetStmt &stmt) override\n@@ -47,6 +47,8 @@ class CompileVarDecl : public HIRCompileBase\n \t\t\t\t\t      &resolved_type);\n     rust_assert (ok);\n \n+    address_taken_context->lookup_addess_taken (\n+      stmt.get_mappings ().get_hirid (), &address_taken);\n     translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n     stmt.get_pattern ()->accept_vis (*this);\n   }\n@@ -56,22 +58,27 @@ class CompileVarDecl : public HIRCompileBase\n     if (!pattern.is_mut ())\n       translated_type = ctx->get_backend ()->immutable_type (translated_type);\n \n-    translated\n+    compiled_variable\n       = ctx->get_backend ()->local_variable (fndecl, pattern.variable_ident,\n \t\t\t\t\t     translated_type, NULL /*decl_var*/,\n-\t\t\t\t\t     false /*address_taken*/, locus);\n+\t\t\t\t\t     address_taken, locus);\n   }\n \n private:\n   CompileVarDecl (Context *ctx, tree fndecl)\n-    : HIRCompileBase (ctx), fndecl (fndecl), translated_type (nullptr),\n-      translated (nullptr)\n+    : HIRCompileBase (ctx), fndecl (fndecl),\n+      translated_type (ctx->get_backend ()->error_type ()),\n+      compiled_variable (ctx->get_backend ()->error_variable ()),\n+      address_taken (false),\n+      address_taken_context (Resolver::AddressTakenContext::get ())\n   {}\n \n   tree fndecl;\n   tree translated_type;\n   Location locus;\n-  ::Bvariable *translated;\n+  Bvariable *compiled_variable;\n+  bool address_taken;\n+  const Resolver::AddressTakenContext *address_taken_context;\n };\n \n } // namespace Compile"}, {"sha": "99a3c48d4bdf66afc36e5e50ca2a5af5a40b75ac", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -560,7 +560,7 @@ struct FunctionParam\n \n   Type *get_type () { return type.get (); }\n \n-  Analysis::NodeMapping &get_mappings () { return mappings; }\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n };\n \n // Visibility of item - if the item has it, then it is some form of public"}, {"sha": "ef3827d099583dca8732bac0cc8446a26fa29bbe", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -73,32 +73,51 @@ class Adjuster\n public:\n   Adjuster (const TyTy::BaseType *ty) : base (ty) {}\n \n-  TyTy::BaseType *adjust_type (std::vector<Adjustment> adjustments)\n+  static bool needs_address (const std::vector<Adjustment> &adjustments)\n+  {\n+    for (auto &adjustment : adjustments)\n+      {\n+\tswitch (adjustment.get_type ())\n+\t  {\n+\t  case Adjustment::AdjustmentType::IMM_REF:\n+\t  case Adjustment::AdjustmentType::MUT_REF:\n+\t    return true;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+      }\n+\n+    return false;\n+  }\n+\n+  TyTy::BaseType *adjust_type (const std::vector<Adjustment> &adjustments)\n   {\n     TyTy::BaseType *ty = base->clone ();\n     for (auto &adjustment : adjustments)\n       {\n \tswitch (adjustment.get_type ())\n \t  {\n-\t  case Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\t  case Adjustment::AdjustmentType::IMM_REF:\n \t    ty = new TyTy::ReferenceType (ty->get_ref (),\n \t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n \t\t\t\t\t  Mutability::Imm);\n \t    break;\n \n-\t  case Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  case Adjustment::AdjustmentType::MUT_REF:\n \t    ty = new TyTy::ReferenceType (ty->get_ref (),\n \t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n \t\t\t\t\t  Mutability::Mut);\n \t    break;\n \n-\t  case Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  case Adjustment::AdjustmentType::DEREF_REF:\n \t    // FIXME this really needs to support deref lang-item operator\n \t    // overloads\n \t    rust_assert (ty->get_kind () == TyTy::TypeKind::REF);\n \t    const TyTy::ReferenceType *rr\n \t      = static_cast<const TyTy::ReferenceType *> (ty);\n \t    ty = rr->get_base ();\n+\n \t    break;\n \t  }\n       }"}, {"sha": "ae77763efb2f667a2f91b76bbd14a870584c1556", "filename": "gcc/rust/typecheck/rust-hir-address-taken.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.cc?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-address-taken.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+AddressTakenContext *\n+AddressTakenContext::get ()\n+{\n+  static AddressTakenContext *instance;\n+  if (instance == nullptr)\n+    instance = new AddressTakenContext ();\n+\n+  return instance;\n+}\n+\n+AddressTakenContext::~AddressTakenContext () {}\n+\n+bool\n+AddressTakenContext::lookup_addess_taken (HirId id, bool *address_taken) const\n+{\n+  const auto &it = ctx.find (id);\n+  if (it == ctx.end ())\n+    return false;\n+\n+  *address_taken = it->second;\n+  return true;\n+}\n+\n+void\n+AddressTakenContext::insert_address_taken (HirId id, bool address_taken)\n+{\n+  const auto &it = ctx.find (id);\n+  if (it != ctx.end ())\n+    {\n+      // assert that we never change a true result to a negative\n+      if (it->second == true)\n+\t{\n+\t  rust_assert (address_taken != false);\n+\t}\n+    }\n+\n+  ctx[id] = address_taken;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "19cbdef3cbf28f9a571747cc0b169e98c5726a4e", "filename": "gcc/rust/typecheck/rust-hir-address-taken.h", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.h?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -0,0 +1,159 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_ADDRESS_TAKEN\n+#define RUST_HIR_ADDRESS_TAKEN\n+\n+#include \"rust-hir-type-check-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class AddressTakenContext\n+{\n+public:\n+  static AddressTakenContext *get ();\n+\n+  ~AddressTakenContext ();\n+\n+  bool lookup_addess_taken (HirId id, bool *address_taken) const;\n+\n+  void insert_address_taken (HirId id, bool address_taken);\n+\n+private:\n+  std::map<HirId, bool> ctx;\n+};\n+\n+class AddressTakenResolver : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static void SetAddressTaken (HIR::Expr &expr)\n+  {\n+    AddressTakenResolver resolver;\n+    expr.accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::IdentifierExpr &expr) override\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      return;\n+\n+    // node back to HIR\n+    HirId ref = UNKNOWN_HIRID;\n+    bool reverse_lookup\n+      = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t      ref_node_id, &ref);\n+    rust_assert (reverse_lookup);\n+    context->insert_address_taken (ref, true);\n+  }\n+\n+  void visit (HIR::PathInExpression &expr) override\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      return;\n+\n+    // node back to HIR\n+    HirId ref = UNKNOWN_HIRID;\n+    bool reverse_lookup\n+      = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t      ref_node_id, &ref);\n+    rust_assert (reverse_lookup);\n+    context->insert_address_taken (ref, true);\n+  }\n+\n+  void visit (HIR::QualifiedPathInExpression &expr) override\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return;\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      return;\n+\n+    // node back to HIR\n+    HirId ref = UNKNOWN_HIRID;\n+    bool reverse_lookup\n+      = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t      ref_node_id, &ref);\n+    rust_assert (reverse_lookup);\n+    context->insert_address_taken (ref, true);\n+  }\n+\n+  void visit (HIR::DereferenceExpr &expr) override\n+  {\n+    expr.get_expr ()->accept_vis (*this);\n+  }\n+\n+private:\n+  AddressTakenResolver ()\n+    : TypeCheckBase (), context (AddressTakenContext::get ())\n+  {}\n+\n+  AddressTakenContext *context;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_ADDRESS_TAKEN"}, {"sha": "fb1cd9722933032fef5ee921952122653481f381", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -31,6 +31,7 @@\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n+#include \"rust-hir-address-taken.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -313,6 +314,10 @@ class TypeCheckExpr : public TypeCheckBase\n     Adjuster adj (receiver_tyty);\n     TyTy::BaseType *adjusted_self = adj.adjust_type (adjustments);\n \n+    // mark the required tree addressable\n+    if (Adjuster::needs_address (adjustments))\n+      AddressTakenResolver::SetAddressTaken (*expr.get_receiver ().get ());\n+\n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n \t\t\t\t\tstd::move (adjustments));\n@@ -1191,11 +1196,18 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::BaseType *resolved_base\n       = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n \n-    // FIXME double_reference\n+    if (expr.get_is_double_borrow ())\n+      {\n+\t// FIXME double_reference\n+\tgcc_unreachable ();\n+      }\n \n     infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n \t\t\t\t       TyTy::TyVar (resolved_base->get_ref ()),\n \t\t\t\t       expr.get_mut ());\n+\n+    // mark the borrowed as address_taken\n+    AddressTakenResolver::SetAddressTaken (*expr.get_expr ().get ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override\n@@ -1277,6 +1289,10 @@ class TypeCheckExpr : public TypeCheckBase\n     PathProbeCandidate *resolved_candidate\n       = MethodResolution::Select (candidates, lhs, adjustments);\n \n+    // mark the required tree addressable\n+    if (Adjuster::needs_address (adjustments))\n+      AddressTakenResolver::SetAddressTaken (*expr.get_expr ().get ());\n+\n     // is this the case we are recursive\n     // handle the case where we are within the impl block for this lang_item\n     // otherwise we end up with a recursive operator overload such as the i32"}, {"sha": "f6ad5c413165300cc42c4090a93afccb4741b2ad", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_6.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/717b6da459b26ace9a3c303cfa5e485ff8935709/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_6.rs?ref=717b6da459b26ace9a3c303cfa5e485ff8935709", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-output \"add_assign\\n3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add_assign\"]\n+pub trait AddAssign<Rhs = Self> {\n+    fn add_assign(&mut self, rhs: Rhs);\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .AddAssign::add_assign.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+impl AddAssign for i32 {\n+    fn add_assign(&mut self, other: i32) {\n+        unsafe {\n+            let a = \"add_assign\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+        *self += other\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let mut res = 1;\n+    res += 2;\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, res);\n+    }\n+\n+    0\n+}"}]}