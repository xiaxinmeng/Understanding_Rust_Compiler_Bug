{"sha": "1eef15537f20e7077ace626f55170c70c60191b5", "node_id": "C_kwDOANBUbNoAKDFlZWYxNTUzN2YyMGU3MDc3YWNlNjI2ZjU1MTcwYzcwYzYwMTkxYjU", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-05-25T12:18:39Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-06-01T08:45:11Z"}, "message": "expansion: Add base for deriving builtin macros (Clone, Copy...)\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add new object files to Makefile.\n\t* expand/rust-expand-visitor.cc (is_derive): Move function.\n\t(is_builtin): Likewise.\n\t(get_traits_to_derive): New function.\n\t(derive_item): Likewise.\n\t(ExpandVisitor::visit): Visit item/statements containers.\n\t(ExpandVisitor::visit_outer_attrs): Take a reference on the attribute\n\tinstead of a copy.\n\t(ExpandVisitor::is_derive): Deleted function.\n\t(ExpandVisitor::is_builtin): Likewise.\n\t* expand/rust-expand-visitor.h (RUST_EXPAND_VISITOR_H): Add missing #ifdef\n\tguards.\n\t(is_derive): Declare function.\n\t(is_builtin): Likewise.\n\t* expand/rust-macro-builtins.cc (builtin_macro_from_string): Use new\n\tMacroBuiltin::builtins map.\n\t(make_macro_path_str): Likewise.\n\t* expand/rust-macro-builtins.h (enum class): Add builtin derive macros.\n\t* expand/rust-derive-clone.cc: New file.\n\t* expand/rust-derive-clone.h: New file.\n\t* expand/rust-derive.cc: New file.\n\t* expand/rust-derive.h: New file.\n\t* util/rust-hir-map.cc (Mappings::insert_macro_def): Fix logic for\n\tsetting builtin macro transcribers.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/macro43.rs: Fix test with new derive macros.\n\t* rust/compile/derive_macro1.rs: New test.\n\t* rust/compile/derive_macro3.rs: New test.\n\t* rust/execute/torture/derive_macro1.rs: New test.\n\t* rust/execute/torture/derive_macro3.rs: New test.", "tree": {"sha": "49de960bb4c23b5a3f6ffac32268e32fecf22ec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49de960bb4c23b5a3f6ffac32268e32fecf22ec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eef15537f20e7077ace626f55170c70c60191b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eef15537f20e7077ace626f55170c70c60191b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eef15537f20e7077ace626f55170c70c60191b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eef15537f20e7077ace626f55170c70c60191b5/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0e39c36e20828b30b2f68a25292ecd7963fafce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e39c36e20828b30b2f68a25292ecd7963fafce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0e39c36e20828b30b2f68a25292ecd7963fafce"}], "stats": {"total": 903, "additions": 838, "deletions": 65}, "files": [{"sha": "209429c316189313df71117e7151ccf3f90bbadb", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -87,6 +87,9 @@ GRS_OBJS = \\\n     rust/rust-macro-expand.o \\\n     rust/rust-cfg-strip.o \\\n \trust/rust-expand-visitor.o \\\n+\trust/rust-ast-builder.o \\\n+\trust/rust-derive.o \\\n+\trust/rust-derive-clone.o \\\n     rust/rust-macro-invoc-lexer.o \\\n     rust/rust-macro-substitute-ctx.o \\\n     rust/rust-macro-builtins.o \\"}, {"sha": "b6414843155341b164645b461aef2acd28722d8f", "filename": "gcc/rust/expand/rust-derive-clone.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive-clone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive-clone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-derive-clone.cc?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,152 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-derive-clone.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+std::unique_ptr<Expr>\n+DeriveClone::clone_call (std::unique_ptr<Expr> &&to_clone)\n+{\n+  // $crate::core::clone::Clone::clone for the fully qualified path - we don't\n+  // link with `core` yet so that might be an issue. Use `Clone::clone` for now?\n+  // TODO: Factor this function inside the DeriveAccumulator\n+  auto path = std::unique_ptr<Expr> (\n+    new PathInExpression (builder.path_in_expression ({\"Clone\", \"clone\"})));\n+\n+  auto args = std::vector<std::unique_ptr<Expr>> ();\n+  args.emplace_back (std::move (to_clone));\n+\n+  return builder.call (std::move (path), std::move (args));\n+}\n+\n+/**\n+ * Create the actual \"clone\" function of the implementation, so\n+ *\n+ * fn clone(&self) -> Self { <clone_expr> }\n+ *\n+ */\n+std::unique_ptr<TraitImplItem>\n+DeriveClone::clone_fn (std::unique_ptr<Expr> &&clone_expr)\n+{\n+  auto block = std::unique_ptr<BlockExpr> (\n+    new BlockExpr ({}, std::move (clone_expr), {}, {}, loc, loc));\n+  auto big_self_type = builder.single_type_path (\"Self\");\n+\n+  return std::unique_ptr<TraitImplItem> (\n+    new Method (\"clone\", builder.fn_qualifiers (), /* generics */ {},\n+\t\tSelfParam (Lifetime::error (), /* is_mut */ false, loc),\n+\t\t/* function params */ {}, std::move (big_self_type),\n+\t\tWhereClause::create_empty (), std::move (block),\n+\t\tVisibility::create_private (), {}, loc));\n+}\n+\n+/**\n+ * Create the Clone trait implementation for a type\n+ *\n+ * impl Clone for <type> {\n+ *     <clone_fn>\n+ * }\n+ *\n+ */\n+std::unique_ptr<Item>\n+DeriveClone::clone_impl (std::unique_ptr<TraitImplItem> &&clone_fn,\n+\t\t\t std::string name)\n+{\n+  // should that be `$crate::core::clone::Clone` instead?\n+  auto segments = std::vector<std::unique_ptr<TypePathSegment>> ();\n+  segments.emplace_back (builder.type_path_segment (\"Clone\"));\n+  auto clone = TypePath (std::move (segments), loc);\n+\n+  auto trait_items = std::vector<std::unique_ptr<TraitImplItem>> ();\n+  trait_items.emplace_back (std::move (clone_fn));\n+\n+  return std::unique_ptr<Item> (\n+    new TraitImpl (clone, /* unsafe */ false,\n+\t\t   /* exclam */ false, std::move (trait_items),\n+\t\t   /* generics */ {}, builder.single_type_path (name),\n+\t\t   WhereClause::create_empty (), Visibility::create_private (),\n+\t\t   {}, {}, loc));\n+}\n+\n+// TODO: Create new `make_qualified_call` helper function\n+\n+DeriveClone::DeriveClone (Location loc)\n+  : loc (loc), expanded (nullptr), builder (AstBuilder (loc))\n+{}\n+\n+std::unique_ptr<AST::Item>\n+DeriveClone::go (Item &item)\n+{\n+  item.accept_vis (*this);\n+\n+  rust_assert (expanded);\n+\n+  return std::move (expanded);\n+}\n+\n+void\n+DeriveClone::visit_tuple (TupleStruct &item)\n+{\n+  auto cloned_fields = std::vector<std::unique_ptr<Expr>> ();\n+\n+  for (size_t idx = 0; idx < item.get_fields ().size (); idx++)\n+    cloned_fields.emplace_back (\n+      clone_call (builder.ref (builder.tuple_idx (\"self\", idx))));\n+\n+  auto path = std::unique_ptr<Expr> (new PathInExpression (\n+    builder.path_in_expression ({item.get_identifier ()})));\n+  auto constructor = builder.call (std::move (path), std::move (cloned_fields));\n+\n+  expanded\n+    = clone_impl (clone_fn (std::move (constructor)), item.get_identifier ());\n+}\n+\n+void\n+DeriveClone::visit_struct (StructStruct &item)\n+{\n+  if (item.is_unit_struct ())\n+    {\n+      auto unit_ctor = builder.struct_expr_struct (item.get_struct_name ());\n+      expanded = clone_impl (clone_fn (std::move (unit_ctor)),\n+\t\t\t     item.get_struct_name ());\n+    }\n+  else\n+    {\n+      rust_sorry_at (item.get_locus (), \"cannot derive %qs for these items yet\",\n+\t\t     \"Clone\");\n+    }\n+}\n+\n+void\n+DeriveClone::visit_enum (Enum &item)\n+{\n+  rust_sorry_at (item.get_locus (), \"cannot derive %qs for these items yet\",\n+\t\t \"Clone\");\n+}\n+\n+void\n+DeriveClone::visit_union (Union &item)\n+{\n+  rust_sorry_at (item.get_locus (), \"cannot derive %qs for these items yet\",\n+\t\t \"Clone\");\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "6c82a6478851fa00cd8b0e8e9385181a2646501c", "filename": "gcc/rust/expand/rust-derive-clone.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive-clone.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive-clone.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-derive-clone.h?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_DERIVE_CLONE_H\n+#define RUST_DERIVE_CLONE_H\n+\n+#include \"rust-derive.h\"\n+#include \"rust-ast-builder.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+class DeriveClone : DeriveVisitor\n+{\n+public:\n+  DeriveClone (Location loc);\n+\n+  std::unique_ptr<AST::Item> go (Item &item);\n+\n+private:\n+  Location loc;\n+  std::unique_ptr<AST::Item> expanded;\n+  AstBuilder builder;\n+\n+  /**\n+   * Create a call to \"clone\". For now, this creates a call to\n+   * `Clone::clone`, but should ultimately call into\n+   * `::core::clone::Clone::clone`\n+   *\n+   * Clone::clone(<to_clone>)\n+   */\n+  std::unique_ptr<Expr> clone_call (std::unique_ptr<Expr> &&to_clone);\n+\n+  /**\n+   * Create the actual \"clone\" function of the implementation, so\n+   *\n+   * fn clone(&self) -> Self { <clone_expr> }\n+   *\n+   */\n+  std::unique_ptr<TraitImplItem> clone_fn (std::unique_ptr<Expr> &&clone_expr);\n+\n+  /**\n+   * Create the Clone trait implementation for a type\n+   *\n+   * impl Clone for <type> {\n+   *     <clone_fn>\n+   * }\n+   *\n+   */\n+  std::unique_ptr<Item> clone_impl (std::unique_ptr<TraitImplItem> &&clone_fn,\n+\t\t\t\t    std::string name);\n+\n+  virtual void visit_struct (StructStruct &item);\n+  virtual void visit_tuple (TupleStruct &item);\n+  virtual void visit_enum (Enum &item);\n+  virtual void visit_union (Union &item);\n+};\n+\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif // ! RUST_DERIVE_CLONE_H"}, {"sha": "cf5126663f6a2f3e541b385c7b8848d70f91a855", "filename": "gcc/rust/expand/rust-derive.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-derive.cc?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-derive.h\"\n+#include \"rust-derive-clone.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+std::unique_ptr<Item>\n+DeriveVisitor::derive (Item &item, const Attribute &attr,\n+\t\t       BuiltinMacro to_derive)\n+{\n+  switch (to_derive)\n+    {\n+    case BuiltinMacro::Clone:\n+      return DeriveClone (attr.get_locus ()).go (item);\n+    case BuiltinMacro::Copy:\n+    case BuiltinMacro::Debug:\n+    case BuiltinMacro::Default:\n+    case BuiltinMacro::Eq:\n+    case BuiltinMacro::PartialEq:\n+    case BuiltinMacro::Ord:\n+    case BuiltinMacro::PartialOrd:\n+    case BuiltinMacro::Hash:\n+    default:\n+      rust_sorry_at (attr.get_locus (), \"uninmplemented builtin derive macro\");\n+      return nullptr;\n+    };\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "9a62c29e58f3b4d408e79763e9df42d57e602c14", "filename": "gcc/rust/expand/rust-derive.h", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-derive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-derive.h?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,222 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef DERIVE_VISITOR_H\n+#define DERIVE_VISITOR_H\n+\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-macro-builtins.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+/**\n+ * The goal of this class is to accumulate and create the required items from a\n+ * builtin `#[derive]` macro applied on a struct, enum or union.\n+ */\n+class DeriveVisitor : public AST::ASTVisitor\n+{\n+public:\n+  static std::unique_ptr<Item> derive (Item &item, const Attribute &derive,\n+\t\t\t\t       BuiltinMacro to_derive);\n+\n+private:\n+  // the 4 \"allowed\" visitors, which a derive-visitor can specify and override\n+  virtual void visit_struct (StructStruct &struct_item) = 0;\n+  virtual void visit_tuple (TupleStruct &tuple_item) = 0;\n+  virtual void visit_enum (Enum &enum_item) = 0;\n+  virtual void visit_union (Union &enum_item) = 0;\n+\n+  // all visitors are final, so no deriving class can implement `derive` for\n+  // anything other than structs, tuples, enums and unions\n+\n+  virtual void visit (StructStruct &struct_item) override final\n+  {\n+    visit_struct (struct_item);\n+  }\n+\n+  virtual void visit (TupleStruct &tuple_struct) override final\n+  {\n+    visit_tuple (tuple_struct);\n+  }\n+\n+  virtual void visit (Enum &enum_item) override final\n+  {\n+    visit_enum (enum_item);\n+  }\n+\n+  virtual void visit (Union &union_item) override final\n+  {\n+    visit_union (union_item);\n+  }\n+\n+  virtual void visit (Token &tok) override final{};\n+  virtual void visit (DelimTokenTree &delim_tok_tree) override final{};\n+  virtual void visit (AttrInputMetaItemContainer &input) override final{};\n+  virtual void visit (AttrInputMacro &expr) override final{};\n+  virtual void visit (IdentifierExpr &ident_expr) override final{};\n+  virtual void visit (Lifetime &lifetime) override final{};\n+  virtual void visit (LifetimeParam &lifetime_param) override final{};\n+  virtual void visit (ConstGenericParam &const_param) override final{};\n+  virtual void visit (PathInExpression &path) override final{};\n+  virtual void visit (TypePathSegment &segment) override final{};\n+  virtual void visit (TypePathSegmentGeneric &segment) override final{};\n+  virtual void visit (TypePathSegmentFunction &segment) override final{};\n+  virtual void visit (TypePath &path) override final{};\n+  virtual void visit (QualifiedPathInExpression &path) override final{};\n+  virtual void visit (QualifiedPathInType &path) override final{};\n+  virtual void visit (LiteralExpr &expr) override final{};\n+  virtual void visit (AttrInputLiteral &attr_input) override final{};\n+  virtual void visit (MetaItemLitExpr &meta_item) override final{};\n+  virtual void visit (MetaItemPathLit &meta_item) override final{};\n+  virtual void visit (BorrowExpr &expr) override final{};\n+  virtual void visit (DereferenceExpr &expr) override final{};\n+  virtual void visit (ErrorPropagationExpr &expr) override final{};\n+  virtual void visit (NegationExpr &expr) override final{};\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) override final{};\n+  virtual void visit (ComparisonExpr &expr) override final{};\n+  virtual void visit (LazyBooleanExpr &expr) override final{};\n+  virtual void visit (TypeCastExpr &expr) override final{};\n+  virtual void visit (AssignmentExpr &expr) override final{};\n+  virtual void visit (CompoundAssignmentExpr &expr) override final{};\n+  virtual void visit (GroupedExpr &expr) override final{};\n+  virtual void visit (ArrayElemsValues &elems) override final{};\n+  virtual void visit (ArrayElemsCopied &elems) override final{};\n+  virtual void visit (ArrayExpr &expr) override final{};\n+  virtual void visit (ArrayIndexExpr &expr) override final{};\n+  virtual void visit (TupleExpr &expr) override final{};\n+  virtual void visit (TupleIndexExpr &expr) override final{};\n+  virtual void visit (StructExprStruct &expr) override final{};\n+  virtual void visit (StructExprFieldIdentifier &field) override final{};\n+  virtual void visit (StructExprFieldIdentifierValue &field) override final{};\n+  virtual void visit (StructExprFieldIndexValue &field) override final{};\n+  virtual void visit (StructExprStructFields &expr) override final{};\n+  virtual void visit (StructExprStructBase &expr) override final{};\n+  virtual void visit (CallExpr &expr) override final{};\n+  virtual void visit (MethodCallExpr &expr) override final{};\n+  virtual void visit (FieldAccessExpr &expr) override final{};\n+  virtual void visit (ClosureExprInner &expr) override final{};\n+  virtual void visit (BlockExpr &expr) override final{};\n+  virtual void visit (ClosureExprInnerTyped &expr) override final{};\n+  virtual void visit (ContinueExpr &expr) override final{};\n+  virtual void visit (BreakExpr &expr) override final{};\n+  virtual void visit (RangeFromToExpr &expr) override final{};\n+  virtual void visit (RangeFromExpr &expr) override final{};\n+  virtual void visit (RangeToExpr &expr) override final{};\n+  virtual void visit (RangeFullExpr &expr) override final{};\n+  virtual void visit (RangeFromToInclExpr &expr) override final{};\n+  virtual void visit (RangeToInclExpr &expr) override final{};\n+  virtual void visit (ReturnExpr &expr) override final{};\n+  virtual void visit (UnsafeBlockExpr &expr) override final{};\n+  virtual void visit (LoopExpr &expr) override final{};\n+  virtual void visit (WhileLoopExpr &expr) override final{};\n+  virtual void visit (WhileLetLoopExpr &expr) override final{};\n+  virtual void visit (ForLoopExpr &expr) override final{};\n+  virtual void visit (IfExpr &expr) override final{};\n+  virtual void visit (IfExprConseqElse &expr) override final{};\n+  virtual void visit (IfLetExpr &expr) override final{};\n+  virtual void visit (IfLetExprConseqElse &expr) override final{};\n+  virtual void visit (MatchExpr &expr) override final{};\n+  virtual void visit (AwaitExpr &expr) override final{};\n+  virtual void visit (AsyncBlockExpr &expr) override final{};\n+  virtual void visit (TypeParam &param) override final{};\n+  virtual void visit (LifetimeWhereClauseItem &item) override final{};\n+  virtual void visit (TypeBoundWhereClauseItem &item) override final{};\n+  virtual void visit (Method &method) override final{};\n+  virtual void visit (Module &module) override final{};\n+  virtual void visit (ExternCrate &crate) override final{};\n+  virtual void visit (UseTreeGlob &use_tree) override final{};\n+  virtual void visit (UseTreeList &use_tree) override final{};\n+  virtual void visit (UseTreeRebind &use_tree) override final{};\n+  virtual void visit (UseDeclaration &use_decl) override final{};\n+  virtual void visit (Function &function) override final{};\n+  virtual void visit (TypeAlias &type_alias) override final{};\n+  virtual void visit (EnumItem &item) override final{};\n+  virtual void visit (EnumItemTuple &item) override final{};\n+  virtual void visit (EnumItemStruct &item) override final{};\n+  virtual void visit (EnumItemDiscriminant &item) override final{};\n+  virtual void visit (ConstantItem &const_item) override final{};\n+  virtual void visit (StaticItem &static_item) override final{};\n+  virtual void visit (TraitItemFunc &item) override final{};\n+  virtual void visit (TraitItemMethod &item) override final{};\n+  virtual void visit (TraitItemConst &item) override final{};\n+  virtual void visit (TraitItemType &item) override final{};\n+  virtual void visit (Trait &trait) override final{};\n+  virtual void visit (InherentImpl &impl) override final{};\n+  virtual void visit (TraitImpl &impl) override final{};\n+  virtual void visit (ExternalTypeItem &type) override final{};\n+  virtual void visit (ExternalStaticItem &item) override final{};\n+  virtual void visit (ExternalFunctionItem &item) override final{};\n+  virtual void visit (ExternBlock &block) override final{};\n+  virtual void visit (MacroMatchFragment &match) override final{};\n+  virtual void visit (MacroMatchRepetition &match) override final{};\n+  virtual void visit (MacroMatcher &matcher) override final{};\n+  virtual void visit (MacroRulesDefinition &rules_def) override final{};\n+  virtual void visit (MacroInvocation &macro_invoc) override final{};\n+  virtual void visit (MetaItemPath &meta_item) override final{};\n+  virtual void visit (MetaItemSeq &meta_item) override final{};\n+  virtual void visit (MetaWord &meta_item) override final{};\n+  virtual void visit (MetaNameValueStr &meta_item) override final{};\n+  virtual void visit (MetaListPaths &meta_item) override final{};\n+  virtual void visit (MetaListNameValueStr &meta_item) override final{};\n+  virtual void visit (LiteralPattern &pattern) override final{};\n+  virtual void visit (IdentifierPattern &pattern) override final{};\n+  virtual void visit (WildcardPattern &pattern) override final{};\n+  virtual void visit (RestPattern &pattern) override final{};\n+  virtual void visit (RangePatternBoundLiteral &bound) override final{};\n+  virtual void visit (RangePatternBoundPath &bound) override final{};\n+  virtual void visit (RangePatternBoundQualPath &bound) override final{};\n+  virtual void visit (RangePattern &pattern) override final{};\n+  virtual void visit (ReferencePattern &pattern) override final{};\n+  virtual void visit (StructPatternFieldTuplePat &field) override final{};\n+  virtual void visit (StructPatternFieldIdentPat &field) override final{};\n+  virtual void visit (StructPatternFieldIdent &field) override final{};\n+  virtual void visit (StructPattern &pattern) override final{};\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) override final{};\n+  virtual void visit (TupleStructItemsRange &tuple_items) override final{};\n+  virtual void visit (TupleStructPattern &pattern) override final{};\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) override final{};\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) override final{};\n+  virtual void visit (TuplePattern &pattern) override final{};\n+  virtual void visit (GroupedPattern &pattern) override final{};\n+  virtual void visit (SlicePattern &pattern) override final{};\n+  virtual void visit (AltPattern &pattern) override final{};\n+  virtual void visit (EmptyStmt &stmt) override final{};\n+  virtual void visit (LetStmt &stmt) override final{};\n+  virtual void visit (ExprStmt &stmt) override final{};\n+  virtual void visit (TraitBound &bound) override final{};\n+  virtual void visit (ImplTraitType &type) override final{};\n+  virtual void visit (TraitObjectType &type) override final{};\n+  virtual void visit (ParenthesisedType &type) override final{};\n+  virtual void visit (ImplTraitTypeOneBound &type) override final{};\n+  virtual void visit (TraitObjectTypeOneBound &type) override final{};\n+  virtual void visit (TupleType &type) override final{};\n+  virtual void visit (NeverType &type) override final{};\n+  virtual void visit (RawPointerType &type) override final{};\n+  virtual void visit (ReferenceType &type) override final{};\n+  virtual void visit (ArrayType &type) override final{};\n+  virtual void visit (SliceType &type) override final{};\n+  virtual void visit (InferredType &type) override final{};\n+  virtual void visit (BareFunctionType &type) override final{};\n+};\n+\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif // DERIVE_VISITOR_H"}, {"sha": "b95649d5cd6fb5af7f993f4f0946741bd0e109b7", "filename": "gcc/rust/expand/rust-expand-visitor.cc", "status": "modified", "additions": 178, "deletions": 43, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-expand-visitor.cc?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -18,38 +18,199 @@\n \n #include \"rust-expand-visitor.h\"\n #include \"rust-attributes.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-type.h\"\n+#include \"rust-derive.h\"\n \n namespace Rust {\n \n+bool\n+is_derive (AST::Attribute &attr)\n+{\n+  auto path = attr.get_path ();\n+  return attr.has_attr_input ()\n+\t && attr.get_attr_input ().get_attr_input_type ()\n+\t      == AST::AttrInput::TOKEN_TREE\n+\t && path == \"derive\";\n+}\n+\n+bool\n+is_builtin (AST::Attribute &attr)\n+{\n+  auto &segments = attr.get_path ().get_segments ();\n+  return !segments.empty ()\n+\t && !Analysis::BuiltinAttributeMappings::get ()\n+\t       ->lookup_builtin (segments[0].get_segment_name ())\n+\t       .is_error ();\n+}\n+\n /* Expand all of the macro invocations currently contained in a crate */\n void\n ExpandVisitor::go (AST::Crate &crate)\n+{\n+  expand_inner_items (crate.items);\n+}\n+\n+/**\n+ * Returns a list of all the derive macros to apply, as well as the Attribute\n+ * they are from.\n+ *\n+ * ```rust\n+ * #[derive(Clone, Copy)] // attr1\n+ * struct S;\n+ *\n+ * // returns [{Clone, &attr1}, {Copy, &attr1}]\n+ *\n+ * #[derive(Clone)] // attr1\n+ * #[derive(Copy, PartialEq, Ord)] // attr2\n+ * struct S;\n+ *\n+ * // returns [{Clone, &attr1}, {Copy, &attr2}, {PartialEq, &attr2}, {Ord,\n+ * &attr2}]\n+ * ```\n+ *\n+ * @param outer_attrs The list of attributes on the item to derive\n+ */\n+static std::vector<\n+  std::pair<std::string, std::reference_wrapper<const AST::Attribute>>>\n+get_traits_to_derive (std::vector<AST::Attribute> &outer_attrs)\n+{\n+  std::vector<\n+    std::pair<std::string, std::reference_wrapper<const AST::Attribute>>>\n+    to_derive;\n+  for (auto it = outer_attrs.begin (); it != outer_attrs.end ();)\n+    {\n+      auto &attr = *it;\n+\n+      if (is_derive (attr))\n+\t{\n+\t  auto &input = attr.get_attr_input ();\n+\t  switch (input.get_attr_input_type ())\n+\t    {\n+\t      // isn't there a better way to do this?? like parse it or\n+\t      // something idk. some function I'm not thinking of?\n+\t      case AST::AttrInput::TOKEN_TREE: {\n+\t\tauto &tokens = static_cast<AST::DelimTokenTree &> (input)\n+\t\t\t\t .get_token_trees ();\n+\n+\t\t// erase the delimiters\n+\t\trust_assert (tokens.size () >= 3);\n+\t\ttokens.erase (tokens.begin ());\n+\t\ttokens.pop_back ();\n+\n+\t\tfor (auto &token : tokens)\n+\t\t  {\n+\t\t    // skip commas, as they are part of the token stream\n+\t\t    if (token->as_string () == \",\")\n+\t\t      continue;\n+\n+\t\t    to_derive.emplace_back (token->as_string (), attr);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    case AST::AttrInput::LITERAL:\n+\t    case AST::AttrInput::META_ITEM:\n+\t    case AST::AttrInput::MACRO:\n+\t      gcc_unreachable ();\n+\t      break;\n+\t    }\n+\n+\t  it = outer_attrs.erase (it);\n+\t}\n+      else\n+\t{\n+\t  it++;\n+\t}\n+    }\n+\n+  return to_derive;\n+}\n+\n+static std::unique_ptr<AST::Item>\n+derive_item (std::unique_ptr<AST::Item> &item, const AST::Attribute &derive,\n+\t     BuiltinMacro to_derive)\n+{\n+  return AST::DeriveVisitor::derive (*item, derive, to_derive);\n+}\n+\n+void\n+ExpandVisitor::expand_inner_items (\n+  std::vector<std::unique_ptr<AST::Item>> &items)\n {\n   expander.push_context (MacroExpander::ContextType::ITEM);\n \n-  // expand attributes recursively and strip items if required\n-  //  AttrVisitor attr_visitor (*this);\n-  auto &items = crate.items;\n-  for (auto it = items.begin (); it != items.end ();)\n+  for (auto it = items.begin (); it != items.end (); it++)\n     {\n       auto &item = *it;\n-      item->accept_vis (*this);\n-\n-      auto fragment = expander.take_expanded_fragment ();\n-      if (fragment.should_expand ())\n+      if (item->has_outer_attrs ())\n \t{\n-\t  // Remove the current expanded invocation\n-\t  it = items.erase (it);\n-\t  for (auto &node : fragment.get_nodes ())\n+\t  auto traits_to_derive\n+\t    = get_traits_to_derive (item->get_outer_attrs ());\n+\n+\t  for (auto &to_derive : traits_to_derive)\n \t    {\n-\t      it = items.insert (it, node.take_item ());\n-\t      it++;\n+\t      auto &name = to_derive.first;\n+\t      auto &attr = to_derive.second;\n+\n+\t      auto maybe_builtin = MacroBuiltin::builtins.lookup (name);\n+\t      if (MacroBuiltin::builtins.is_iter_ok (maybe_builtin))\n+\t\t{\n+\t\t  auto new_item\n+\t\t    = derive_item (item, attr, maybe_builtin->second);\n+\t\t  // this inserts the derive *before* the item - is it a\n+\t\t  // problem?\n+\t\t  it = items.insert (it, std::move (new_item));\n+\t\t}\n \t    }\n \t}\n-      else\n-\tit++;\n     }\n \n+  std::function<std::unique_ptr<AST::Item> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_item (); };\n+\n+  expand_macro_children (items, extractor);\n+\n+  expander.pop_context ();\n+}\n+\n+void\n+ExpandVisitor::expand_inner_stmts (\n+  std::vector<std::unique_ptr<AST::Stmt>> &stmts)\n+{\n+  expander.push_context (MacroExpander::ContextType::BLOCK);\n+\n+  for (auto it = stmts.begin (); it != stmts.end (); it++)\n+    {\n+      // TODO: Eventually we need to derive here as well\n+\n+      // auto &stmt = *it;\n+\n+      // if (stmt->has_outer_attrs ())\n+      // {\n+      //   auto traits_to_derive\n+      //     = get_traits_to_derive (stmt->get_outer_attrs ());\n+\n+      //   // FIXME: This needs to be reworked absolutely\n+      //   static const std::set<std::string> builtin_derives\n+      //     = {\"Clone\", \"Copy\", \"Eq\", \"PartialEq\", \"Ord\", \"PartialOrd\"};\n+\n+      //   for (auto &to_derive : traits_to_derive)\n+      //     if (builtin_derives.find (to_derive) != builtin_derives.end ())\n+      //       {\n+      // \tauto new_item = derive_item (\n+      // \t  item, item->get_outer_attrs ()[0] /* FIXME: This is wrong */,\n+      // \t  to_derive);\n+      // \t// this inserts the derive *before* the item - is it a problem?\n+      // \tit = items.insert (it, std::move (new_item));\n+      //       }\n+      // }\n+    }\n+\n+  std::function<std::unique_ptr<AST::Stmt> (AST::SingleASTNode)> extractor\n+    = [] (AST::SingleASTNode node) { return node.take_stmt (); };\n+\n+  expand_macro_children (stmts, extractor);\n+\n   expander.pop_context ();\n }\n \n@@ -544,12 +705,7 @@ ExpandVisitor::visit (AST::ClosureExprInner &expr)\n void\n ExpandVisitor::visit (AST::BlockExpr &expr)\n {\n-  visit_outer_attrs (expr);\n-  std::function<std::unique_ptr<AST::Stmt> (AST::SingleASTNode)> extractor\n-    = [] (AST::SingleASTNode node) { return node.take_stmt (); };\n-\n-  expand_macro_children (MacroExpander::ContextType::BLOCK,\n-\t\t\t expr.get_statements (), extractor);\n+  expand_inner_stmts (expr.get_statements ());\n \n   expander.push_context (MacroExpander::ContextType::BLOCK);\n \n@@ -1404,7 +1560,7 @@ ExpandVisitor::visit_outer_attrs (T &item, std::vector<AST::Attribute> &attrs)\n {\n   for (auto it = attrs.begin (); it != attrs.end (); /* erase => No increment*/)\n     {\n-      auto current = *it;\n+      auto &current = *it;\n \n       if (!is_builtin (current) && !is_derive (current))\n \t{\n@@ -1509,25 +1665,4 @@ ExpandVisitor::visit_attrs_with_derive (T &item)\n \t}\n     }\n }\n-\n-bool\n-ExpandVisitor::is_derive (AST::Attribute &attr)\n-{\n-  auto &segments = attr.get_path ().get_segments ();\n-  return attr.has_attr_input ()\n-\t && attr.get_attr_input ().get_attr_input_type ()\n-\t      == AST::AttrInput::TOKEN_TREE\n-\t && !segments.empty () && \"derive\" == segments[0].get_segment_name ();\n-}\n-\n-bool\n-ExpandVisitor::is_builtin (AST::Attribute &attr)\n-{\n-  auto &segments = attr.get_path ().get_segments ();\n-  return !segments.empty ()\n-\t && !Analysis::BuiltinAttributeMappings::get ()\n-\t       ->lookup_builtin (segments[0].get_segment_name ())\n-\t       .is_error ();\n-}\n-\n } // namespace Rust"}, {"sha": "85893347defa10053efad807612e7f6ffb00360d", "filename": "gcc/rust/expand/rust-expand-visitor.h", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-expand-visitor.h?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -16,11 +16,26 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+#ifndef RUST_EXPAND_VISITOR_H\n+#define RUST_EXPAND_VISITOR_H\n+\n #include \"rust-ast-visitor.h\"\n #include \"rust-macro-expand.h\"\n \n namespace Rust {\n \n+/**\n+ * Whether or not an attribute is a derive attribute\n+ */\n+bool\n+is_derive (AST::Attribute &attr);\n+\n+/**\n+ * Whether or not an attribute is builtin\n+ */\n+bool\n+is_builtin (AST::Attribute &attr);\n+\n class ExpandVisitor : public AST::ASTVisitor\n {\n public:\n@@ -64,6 +79,7 @@ class ExpandVisitor : public AST::ASTVisitor\n    */\n   void expand_qualified_path_type (AST::QualifiedPathType &path_type);\n \n+  // FIXME: Add documentation\n   void expand_closure_params (std::vector<AST::ClosureParam> &params);\n   void expand_self_param (AST::SelfParam &self_param);\n   void expand_where_clause (AST::WhereClause &where_clause);\n@@ -88,6 +104,20 @@ class ExpandVisitor : public AST::ASTVisitor\n   {\n     expander.push_context (ctx);\n \n+    expand_macro_children (values, extractor);\n+\n+    expander.pop_context ();\n+  }\n+\n+  /**\n+   * Same as `expand_macro_children`, but does not push a context. This is\n+   * useful if you're already pushing the context manually anyway for proc macro\n+   * expansion, like in `expand_inner_{items, stmts}`\n+   */\n+  template <typename T, typename U>\n+  void expand_macro_children (T &values,\n+\t\t\t      std::function<U (AST::SingleASTNode)> extractor)\n+  {\n     for (auto it = values.begin (); it != values.end ();)\n       {\n \tauto &value = *it;\n@@ -116,10 +146,19 @@ class ExpandVisitor : public AST::ASTVisitor\n \t    ++it;\n \t  }\n       }\n-\n-    expander.pop_context ();\n   }\n \n+  /**\n+   * Perform in-place expansion of procedural macros and macro invocations for\n+   * an item container or statement container, such as `AST::Crate`,\n+   * `AST::Module` or `AST::BlockExpr`. This function will insert the expanded\n+   * nodes in place, and replace macro invocations with their expanded nodes.\n+   *\n+   * @param values Vector of values to mutate in-place and append into\n+   */\n+  void expand_inner_items (std::vector<std::unique_ptr<AST::Item>> &values);\n+  void expand_inner_stmts (std::vector<std::unique_ptr<AST::Stmt>> &values);\n+\n   // TODO: See if possible to make more specialization for Impl items, Block\n   // stmts etc? This could allow us to remove expand_macro_children or at least\n   // its extractor parameter\n@@ -325,8 +364,6 @@ class ExpandVisitor : public AST::ASTVisitor\n \n   template <typename T> void visit_inner_attrs (T &item);\n \n-  bool is_derive (AST::Attribute &attr);\n-\n   template <typename T>\n   void expand_derive (const T &item, std::unique_ptr<AST::TokenTree> &trait);\n \n@@ -335,10 +372,10 @@ class ExpandVisitor : public AST::ASTVisitor\n \n   template <typename T> void visit_attrs_with_derive (T &item);\n \n-  bool is_builtin (AST::Attribute &attr);\n-\n private:\n   MacroExpander &expander;\n };\n \n } // namespace Rust\n+\n+#endif // RUST_EXPAND_VISITOR_H"}, {"sha": "8104c572b45a4a91aef4ec03da6e747cb7d85919", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -29,10 +29,10 @@\n #include \"rust-macro.h\"\n #include \"rust-parse.h\"\n #include \"rust-session-manager.h\"\n-#include \"bi-map.h\"\n \n namespace Rust {\n-static const BiMap<std::string, BuiltinMacro> builtins = {{\n+\n+const BiMap<std::string, BuiltinMacro> MacroBuiltin::builtins = {{\n   {\"assert\", BuiltinMacro::Assert},\n   {\"file\", BuiltinMacro::File},\n   {\"line\", BuiltinMacro::Line},\n@@ -62,6 +62,16 @@ static const BiMap<std::string, BuiltinMacro> builtins = {{\n   {\"cfg_accessible\", BuiltinMacro::CfgAccessible},\n   {\"RustcEncodable\", BuiltinMacro::RustcDecodable},\n   {\"RustcDecodable\", BuiltinMacro::RustcEncodable},\n+  {\"Clone\", BuiltinMacro::Clone},\n+  {\"Copy\", BuiltinMacro::Copy},\n+  {\"Debug\", BuiltinMacro::Debug},\n+  {\"Default\", BuiltinMacro::Default},\n+  {\"Eq\", BuiltinMacro::Eq},\n+  {\"PartialEq\", BuiltinMacro::PartialEq},\n+  {\"Ord\", BuiltinMacro::Ord},\n+  {\"PartialOrd\", BuiltinMacro::PartialOrd},\n+  {\"Hash\", BuiltinMacro::Hash},\n+\n }};\n \n std::unordered_map<\n@@ -95,16 +105,14 @@ std::unordered_map<\n     {\"test_case\", MacroBuiltin::sorry},\n     {\"global_allocator\", MacroBuiltin::sorry},\n     {\"cfg_accessible\", MacroBuiltin::sorry},\n-    {\"RustcEncodable\", MacroBuiltin::sorry},\n-    {\"RustcDecodable\", MacroBuiltin::sorry},\n };\n \n // FIXME: This should return an Optional\n BuiltinMacro\n builtin_macro_from_string (const std::string &identifier)\n {\n-  auto macro = builtins.lookup (identifier);\n-  rust_assert (builtins.is_iter_ok (macro));\n+  auto macro = MacroBuiltin::builtins.lookup (identifier);\n+  rust_assert (MacroBuiltin::builtins.is_iter_ok (macro));\n \n   return macro->second;\n }\n@@ -113,8 +121,8 @@ namespace {\n std::string\n make_macro_path_str (BuiltinMacro kind)\n {\n-  auto str = builtins.lookup (kind);\n-  rust_assert (builtins.is_iter_ok (str));\n+  auto str = MacroBuiltin::builtins.lookup (kind);\n+  rust_assert (MacroBuiltin::builtins.is_iter_ok (str));\n \n   return str->second;\n }"}, {"sha": "cf70e49634e49986e5d4f602f9dbcd863ec554e6", "filename": "gcc/rust/expand/rust-macro-builtins.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-ast.h\"\n #include \"rust-ast-fragment.h\"\n #include \"rust-location.h\"\n+#include \"bi-map.h\"\n \n namespace Rust {\n \n@@ -63,6 +64,15 @@ enum class BuiltinMacro\n   CfgAccessible,\n   RustcDecodable,\n   RustcEncodable,\n+  Clone,\n+  Copy,\n+  Debug,\n+  Default,\n+  Eq,\n+  PartialEq,\n+  Ord,\n+  PartialOrd,\n+  Hash,\n };\n \n BuiltinMacro\n@@ -107,6 +117,7 @@ builtin_macro_from_string (const std::string &identifier);\n class MacroBuiltin\n {\n public:\n+  static const BiMap<std::string, BuiltinMacro> builtins;\n   static std::unordered_map<\n     std::string, std::function<AST::Fragment (Location, AST::MacroInvocData &)>>\n     builtin_transcribers;"}, {"sha": "3edbc201601b72598893d69ad213628aa02e316b", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -876,14 +876,18 @@ Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n \t\t   });\n   if (should_be_builtin)\n     {\n-      auto builtin\n+      auto builtin = MacroBuiltin::builtins.lookup (macro->get_rule_name ());\n+      if (!MacroBuiltin::builtins.is_iter_ok (builtin))\n+\t{\n+\t  rust_error_at (macro->get_locus (),\n+\t\t\t \"cannot find a built-in macro with name %qs\",\n+\t\t\t macro->get_rule_name ().c_str ());\n+\t  return;\n+\t}\n+\n+      auto transcriber\n \t= MacroBuiltin::builtin_transcribers.find (macro->get_rule_name ());\n-      if (builtin != MacroBuiltin::builtin_transcribers.end ())\n-\tmacro->set_builtin_transcriber (builtin->second);\n-      else\n-\trust_error_at (macro->get_locus (),\n-\t\t       \"cannot find a built-in macro with name %qs\",\n-\t\t       macro->get_rule_name ().c_str ());\n+      macro->set_builtin_transcriber (transcriber->second);\n     }\n \n   auto it = macroMappings.find (macro->get_node_id ());"}, {"sha": "131822820b0efce6802d66921335c34c25100deb", "filename": "gcc/testsuite/rust/compile/derive_macro1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fderive_macro1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fderive_macro1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fderive_macro1.rs?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,12 @@\n+pub trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+// This warning can be removed once we properly handle implems with #[automatically_derived]\n+#[derive(Clone)] // { dg-warning \"unused name .self.\" }\n+pub struct S;\n+\n+fn main() {\n+    let s = S;\n+    let _s_clone = s.clone();\n+}"}, {"sha": "35284d8fa3b7bdceee5de9e910a676ae0dc2dbb6", "filename": "gcc/testsuite/rust/compile/derive_macro3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fderive_macro3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fderive_macro3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fderive_macro3.rs?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,21 @@\n+pub trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+pub trait Copy {}\n+\n+impl Copy for i32 {}\n+\n+impl<T> Clone for T\n+where\n+    T: Copy,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+fn main() {\n+    let a = 15i32;\n+    let _ = a.clone();\n+}"}, {"sha": "992bc77cedf3239523622515b358f3cf6165417e", "filename": "gcc/testsuite/rust/compile/macro43.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro43.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro43.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro43.rs?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -11,7 +11,8 @@ macro_rules! nonzero_integers {\n             /// assert_eq!(size_of::<Option<std::num::NonZeroU32>>(), size_of::<u32>());\n             /// ```\n             #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n-            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+            // not all derive macros are implemented yet, and this test does not test these anyways\n+            // #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n             #[repr(transparent)]\n             pub struct $Ty(NonZero<$Int>);\n "}, {"sha": "6e0350de3de91222a6ebe52d0adec8c9dad55889", "filename": "gcc/testsuite/rust/execute/torture/derive_macro1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fderive_macro1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fderive_macro1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fderive_macro1.rs?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,23 @@\n+pub trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+pub trait Copy {}\n+\n+impl Copy for i32 {}\n+\n+impl<T> Clone for T\n+where\n+    T: Copy,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = 15i32;\n+    let b = a.clone();\n+\n+    a - b\n+}"}, {"sha": "716bd908f4e8e6a9798015c3463a242a66f18642", "filename": "gcc/testsuite/rust/execute/torture/derive_macro3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fderive_macro3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eef15537f20e7077ace626f55170c70c60191b5/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fderive_macro3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fderive_macro3.rs?ref=1eef15537f20e7077ace626f55170c70c60191b5", "patch": "@@ -0,0 +1,19 @@\n+pub trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+impl Clone for i32 {\n+    fn clone(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct S(i32, i32);\n+\n+fn main() -> i32 {\n+    let a = S(15, 15);\n+    let b = a.clone();\n+\n+    b.0 - b.1\n+}"}]}