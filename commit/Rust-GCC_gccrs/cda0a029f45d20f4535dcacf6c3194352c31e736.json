{"sha": "cda0a029f45d20f4535dcacf6c3194352c31e736", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RhMGEwMjlmNDVkMjBmNDUzNWRjYWNmNmMzMTk0MzUyYzMxZTczNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-11-14T00:08:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-11-14T00:08:05Z"}, "message": "Merge C++ delayed folding branch.\n\n\t* call.c (build_conditional_expr_1, convert_like_real)\n\t(convert_arg_to_ellipsis, convert_for_arg_passing): Don't fold.\n\t(build_new_op_1, build_over_call, build_cxx_call): Fold for warnings.\n\t* class.c (build_base_path, determine_primary_bases)\n\t(update_vtable_entry_for_fn, check_bitfield_decl)\n\t(layout_nonempty_base_or_field, layout_empty_base)\n\t(propagate_binfo_offsets, include_empty_classes)\n\t(layout_class_type, build_vbase_offset_vtbl_entries): Use\n\tfold_convert.\n\t* constexpr.c (cxx_eval_builtin_function_call): Fold away the NOP_EXPR.\n\t(cxx_eval_call_expression): Handle MEM_REF.\n\t(cxx_eval_pointer_plus_expression): Fold the second operand.\n\t(cxx_eval_constant_expression): Handle MEM_REF, UNARY_PLUS_EXPR.\n\t(fold_simple_1, fold_simple): New.\n\t(maybe_constant_value_1): Factor out from maybe_constant_value.\n\t(cv_cache, maybe_constant_value): Cache results.\n\t(maybe_constant_init): Handle null input.\n\t(potential_constant_expression_1): Handle RESULT_DECL, EMPTY_CLASS_EXPR.\n\t* cp-array-notation.c (build_array_notation_ref): Fold operands.\n\t* cp-gimplify.c (cp_fold_r, cp_fold): New.\n\t(cp_genericize_r): Use fold_convert.  Don't fold SIZEOF_EXPR.\n\t(cp_genericize): Fold everything.\n\t(contains_label_1, contains_label_p): New.\n\t(cp_fold, cp_fully_fold): New.\n\t* cp-tree.h (class cache_map): New.\n\t* cvt.c (cp_convert_to_pointer, ocp_convert): Use convert_to_*_nofold.\n\t(cp_convert_and_check): Use cp_fully_fold.\n\t(convert, convert_force): Don't fold.\n\t* decl.c (fold_sizeof_expr): Change from fold_sizeof_expr_r.\n\t(compute_array_index_type): Use cp_fully_fold.\n\t(build_enumerator): Use fold_convert.\n\t* decl2.c (get_guard_cond, set_guard): Use fold_convert.\n\t* init.c (build_zero_init_1): Fold zero-initializers.\n\t(build_new_1): Fold nelts calculations.\n\t(build_vec_delete_1): Fold conversions.\n\t(build_vec_init): Fold maxindex.\n\t* parser.c (cp_parser_binary_expression): Fold LHS of || and &&.\n\t(cp_parser_question_colon_clause): Fold LHS.\n\t* pt.c (convert_nontype_argument): Fold nullptr conversion.\n\t* semantics.c (finish_unary_op_expr): Fold for warnings.\n\t(handle_omp_array_sections_1): Fold length and low bound.\n\t(handle_omp_for_class_iterator): Fold various things.\n\t* tree.c (builtin_valid_in_constant_expr_p): Add\n\tBUILT_IN_ATOMIC_ALWAYS_LOCK_FREE.\n\t(convert_bitfield_to_declared_type): Don't fold.\n\t(handle_init_priority_attribute): Fold.\n\t(fold_if_not_in_template): Remove.\n\t* typeck.c (decay_conversion, build_class_member_access_expr)\n\t(build_simple_component_ref, cp_build_array_ref, build_vec_cmp)\n\t(cp_pointer_int_sum, pointer_diff): Don't fold.\n\t(cp_build_binary_op): Fold for warnings and PMF ops.\n\t(cp_build_unary_op): Fold negation of a constant, nothing else.\n\t(expand_ptrmemfunc_cst): Fold operations.\n\t* typeck2.c (split_nonconstant_init): Fold initializer.\n\t(store_init_value): Likewise.\n\t(check_narrowing): Try folding.\n\t* config-lang.in (gtfiles): Add cp-gimplify.c.\n\nFrom-SVN: r230365", "tree": {"sha": "e5f2d64459601fae812cfe90245af2831eebedb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5f2d64459601fae812cfe90245af2831eebedb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cda0a029f45d20f4535dcacf6c3194352c31e736", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda0a029f45d20f4535dcacf6c3194352c31e736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda0a029f45d20f4535dcacf6c3194352c31e736", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda0a029f45d20f4535dcacf6c3194352c31e736/comments", "author": null, "committer": null, "parents": [{"sha": "8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fe17e23b052741c8cbec99c7173c3c07f8e8c64"}], "stats": {"total": 1483, "additions": 1165, "deletions": 318}, "files": [{"sha": "2ea5448f08ecc38c7b9c29d9a1b4f417a9b350c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1,3 +1,65 @@\n+2015-11-13  Kai Tietz  <ktietz70@googlemail.com>\n+\t    Marek Polacek  <polacek@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\t* call.c (build_conditional_expr_1, convert_like_real)\n+\t(convert_arg_to_ellipsis, convert_for_arg_passing): Don't fold.\n+\t(build_new_op_1, build_over_call, build_cxx_call): Fold for warnings.\n+\t* class.c (build_base_path, determine_primary_bases)\n+\t(update_vtable_entry_for_fn, check_bitfield_decl)\n+\t(layout_nonempty_base_or_field, layout_empty_base)\n+\t(propagate_binfo_offsets, include_empty_classes)\n+\t(layout_class_type, build_vbase_offset_vtbl_entries): Use\n+\tfold_convert.\n+\t* constexpr.c (cxx_eval_builtin_function_call): Fold away the NOP_EXPR.\n+\t(cxx_eval_call_expression): Handle MEM_REF.\n+\t(cxx_eval_pointer_plus_expression): Fold the second operand.\n+\t(cxx_eval_constant_expression): Handle MEM_REF, UNARY_PLUS_EXPR.\n+\t(fold_simple_1, fold_simple): New.\n+\t(maybe_constant_value_1): Factor out from maybe_constant_value.\n+\t(cv_cache, maybe_constant_value): Cache results.\n+\t(maybe_constant_init): Handle null input.\n+\t(potential_constant_expression_1): Handle RESULT_DECL, EMPTY_CLASS_EXPR.\n+\t* cp-array-notation.c (build_array_notation_ref): Fold operands.\n+\t* cp-gimplify.c (cp_fold_r, cp_fold): New.\n+\t(cp_genericize_r): Use fold_convert.  Don't fold SIZEOF_EXPR.\n+\t(cp_genericize): Fold everything.\n+\t(contains_label_1, contains_label_p): New.\n+\t(cp_fold, cp_fully_fold): New.\n+\t* cp-tree.h (class cache_map): New.\n+\t* cvt.c (cp_convert_to_pointer, ocp_convert): Use convert_to_*_nofold.\n+\t(cp_convert_and_check): Use cp_fully_fold.\n+\t(convert, convert_force): Don't fold.\n+\t* decl.c (fold_sizeof_expr): Change from fold_sizeof_expr_r.\n+\t(compute_array_index_type): Use cp_fully_fold.\n+\t(build_enumerator): Use fold_convert.\n+\t* decl2.c (get_guard_cond, set_guard): Use fold_convert.\n+\t* init.c (build_zero_init_1): Fold zero-initializers.\n+\t(build_new_1): Fold nelts calculations.\n+\t(build_vec_delete_1): Fold conversions.\n+\t(build_vec_init): Fold maxindex.\n+\t* parser.c (cp_parser_binary_expression): Fold LHS of || and &&.\n+\t(cp_parser_question_colon_clause): Fold LHS.\n+\t* pt.c (convert_nontype_argument): Fold nullptr conversion.\n+\t* semantics.c (finish_unary_op_expr): Fold for warnings.\n+\t(handle_omp_array_sections_1): Fold length and low bound.\n+\t(handle_omp_for_class_iterator): Fold various things.\n+\t* tree.c (builtin_valid_in_constant_expr_p): Add\n+\tBUILT_IN_ATOMIC_ALWAYS_LOCK_FREE.\n+\t(convert_bitfield_to_declared_type): Don't fold.\n+\t(handle_init_priority_attribute): Fold.\n+\t(fold_if_not_in_template): Remove.\n+\t* typeck.c (decay_conversion, build_class_member_access_expr)\n+\t(build_simple_component_ref, cp_build_array_ref, build_vec_cmp)\n+\t(cp_pointer_int_sum, pointer_diff): Don't fold.\n+\t(cp_build_binary_op): Fold for warnings and PMF ops.\n+\t(cp_build_unary_op): Fold negation of a constant, nothing else.\n+\t(expand_ptrmemfunc_cst): Fold operations.\n+\t* typeck2.c (split_nonconstant_init): Fold initializer.\n+\t(store_init_value): Likewise.\n+\t(check_narrowing): Try folding.\n+\t* config-lang.in (gtfiles): Add cp-gimplify.c.\n+\n 2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* error.c (pedwarn_cxx98): Pass line_table to rich_location ctor."}, {"sha": "77c29366b1351c1cd93e2c09717f9ef5e1cd3179", "filename": "gcc/cp/call.c", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -4748,7 +4748,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t  tree cmp_type = build_same_sized_truth_vector_type (arg1_type);\n \t  arg1 = build2 (NE_EXPR, cmp_type, arg1, build_zero_cst (arg1_type));\n \t}\n-      return fold_build3 (VEC_COND_EXPR, arg2_type, arg1, arg2, arg3);\n+      return build3_loc (loc, VEC_COND_EXPR, arg2_type, arg1, arg2, arg3);\n     }\n \n   /* [expr.cond]\n@@ -5152,9 +5152,6 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \n  valid_operands:\n   result = build3_loc (loc, COND_EXPR, result_type, arg1, arg2, arg3);\n-  if (!cp_unevaluated_operand)\n-    /* Avoid folding within decltype (c++/42013) and noexcept.  */\n-    result = fold_if_not_in_template (result);\n \n   /* We can't use result_type below, as fold might have returned a\n      throw_expr.  */\n@@ -5690,8 +5687,8 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t\t decaying an enumerator to its value.  */\n \t      if (complain & tf_warning)\n \t\twarn_logical_operator (loc, code, boolean_type_node,\n-\t\t\t\t       code_orig_arg1, arg1,\n-\t\t\t\t       code_orig_arg2, arg2);\n+\t\t\t\t       code_orig_arg1, fold (arg1),\n+\t\t\t\t       code_orig_arg2, fold (arg2));\n \n \t      arg2 = convert_like (conv, arg2, complain);\n \t    }\n@@ -5729,7 +5726,8 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n     case TRUTH_OR_EXPR:\n       if (complain & tf_warning)\n \twarn_logical_operator (loc, code, boolean_type_node,\n-\t\t\t       code_orig_arg1, arg1, code_orig_arg2, arg2);\n+\t\t\t       code_orig_arg1, fold (arg1),\n+\t\t\t       code_orig_arg2, fold (arg2));\n       /* Fall through.  */\n     case GT_EXPR:\n     case LT_EXPR:\n@@ -5740,9 +5738,10 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n       if ((complain & tf_warning)\n \t  && ((code_orig_arg1 == BOOLEAN_TYPE)\n \t      ^ (code_orig_arg2 == BOOLEAN_TYPE)))\n-\tmaybe_warn_bool_compare (loc, code, arg1, arg2);\n+\tmaybe_warn_bool_compare (loc, code, fold (arg1),\n+\t\t\t\t fold (arg2));\n       if (complain & tf_warning && warn_tautological_compare)\n-\twarn_tautological_cmp (loc, code, arg1, arg2);\n+\twarn_tautological_cmp (loc, code, fold (arg1), fold (arg2));\n       /* Fall through.  */\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -6496,7 +6495,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  imag = perform_implicit_conversion (TREE_TYPE (totype),\n \t\t\t\t\t      imag, complain);\n \t  expr = build2 (COMPLEX_EXPR, totype, real, imag);\n-\t  return fold_if_not_in_template (expr);\n+\t  return expr;\n \t}\n       expr = reshape_init (totype, expr, complain);\n       expr = get_target_expr_sfinae (digest_init (totype, expr, complain),\n@@ -6737,7 +6736,7 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n \t\t    \"implicit conversion from %qT to %qT when passing \"\n \t\t    \"argument to function\",\n \t\t    arg_type, double_type_node);\n-      arg = convert_to_real (double_type_node, arg);\n+      arg = convert_to_real_nofold (double_type_node, arg);\n     }\n   else if (NULLPTR_TYPE_P (arg_type))\n     arg = null_pointer_node;\n@@ -6982,7 +6981,7 @@ convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n   bitfield_type = is_bitfield_expr_with_lowered_type (val);\n   if (bitfield_type \n       && TYPE_PRECISION (TREE_TYPE (val)) < TYPE_PRECISION (type))\n-    val = convert_to_integer (TYPE_MAIN_VARIANT (bitfield_type), val);\n+    val = convert_to_integer_nofold (TYPE_MAIN_VARIANT (bitfield_type), val);\n \n   if (val == error_mark_node)\n     ;\n@@ -7502,7 +7501,19 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   gcc_assert (j <= nargs);\n   nargs = j;\n \n-  check_function_arguments (TREE_TYPE (fn), nargs, argarray);\n+  /* Avoid to do argument-transformation, if warnings for format, and for\n+     nonnull are disabled.  Just in case that at least one of them is active\n+     the check_function_arguments function might warn about something.  */\n+\n+  if (warn_nonnull || warn_format || warn_suggest_attribute_format)\n+    {\n+      tree *fargs = (!nargs ? argarray\n+\t\t\t    : (tree *) alloca (nargs * sizeof (tree)));\n+      for (j = 0; j < nargs; j++)\n+\tfargs[j] = maybe_constant_value (argarray[j]);\n+\n+      check_function_arguments (TREE_TYPE (fn), nargs, fargs);\n+    }\n \n   /* Avoid actually calling copy constructors and copy assignment operators,\n      if possible.  */\n@@ -7693,7 +7704,6 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n \t\ttsubst_flags_t complain)\n {\n   tree fndecl;\n-  int optimize_sav;\n \n   /* Remember roughly where this call is.  */\n   location_t loc = EXPR_LOC_OR_LOC (fn, input_location);\n@@ -7705,9 +7715,18 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n   /* Check that arguments to builtin functions match the expectations.  */\n   if (fndecl\n       && DECL_BUILT_IN (fndecl)\n-      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-      && !check_builtin_function_arguments (fndecl, nargs, argarray))\n-    return error_mark_node;\n+      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+    {\n+      int i;\n+\n+      /* We need to take care that values to BUILT_IN_NORMAL\n+         are reduced.  */\n+      for (i = 0; i < nargs; i++)\n+\targarray[i] = maybe_constant_value (argarray[i]);\n+\n+      if (!check_builtin_function_arguments (fndecl, nargs, argarray))\n+\treturn error_mark_node;\n+    }\n \n     /* If it is a built-in array notation function, then the return type of\n      the function is the element type of the array passed in as array \n@@ -7741,17 +7760,6 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n \t}\n     }\n \n-  /* Some built-in function calls will be evaluated at compile-time in\n-     fold ().  Set optimize to 1 when folding __builtin_constant_p inside\n-     a constexpr function so that fold_builtin_1 doesn't fold it to 0.  */\n-  optimize_sav = optimize;\n-  if (!optimize && fndecl && DECL_IS_BUILTIN_CONSTANT_P (fndecl)\n-      && current_function_decl\n-      && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n-    optimize = 1;\n-  fn = fold_if_not_in_template (fn);\n-  optimize = optimize_sav;\n-\n   if (VOID_TYPE_P (TREE_TYPE (fn)))\n     return fn;\n "}, {"sha": "216a30141d486755a2479c6472dd72fc1475d45b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -421,7 +421,7 @@ build_base_path (enum tree_code code,\n \n \t  t = TREE_TYPE (TYPE_VFIELD (current_class_type));\n \t  t = build_pointer_type (t);\n-\t  v_offset = convert (t, current_vtt_parm);\n+\t  v_offset = fold_convert (t, current_vtt_parm);\n \t  v_offset = cp_build_indirect_ref (v_offset, RO_NULL, complain);\n \t}\n       else\n@@ -554,8 +554,6 @@ build_simple_base_path (tree expr, tree binfo)\n \texpr = build3 (COMPONENT_REF,\n \t\t       cp_build_qualified_type (type, type_quals),\n \t\t       expr, field, NULL_TREE);\n-\texpr = fold_if_not_in_template (expr);\n-\n \t/* Mark the expression const or volatile, as appropriate.\n \t   Even though we've dealt with the type above, we still have\n \t   to mark the expression itself.  */\n@@ -1847,9 +1845,9 @@ determine_primary_bases (tree t)\n \t\t another hierarchy. As we're about to use it as a\n \t\t primary base, make sure the offsets match.  */\n \t      delta = size_diffop_loc (input_location,\n-\t\t\t\t   convert (ssizetype,\n+\t\t\t\t   fold_convert (ssizetype,\n \t\t\t\t\t    BINFO_OFFSET (base_binfo)),\n-\t\t\t\t   convert (ssizetype,\n+\t\t\t\t   fold_convert (ssizetype,\n \t\t\t\t\t    BINFO_OFFSET (this_primary)));\n \n \t      propagate_binfo_offsets (this_primary, delta);\n@@ -1911,7 +1909,7 @@ determine_primary_bases (tree t)\n \t     another hierarchy. As we're about to use it as a primary\n \t     base, make sure the offsets match.  */\n \t  delta = size_diffop_loc (input_location, ssize_int (0),\n-\t\t\t       convert (ssizetype, BINFO_OFFSET (primary)));\n+\t\t\t       fold_convert (ssizetype, BINFO_OFFSET (primary)));\n \n \t  propagate_binfo_offsets (primary, delta);\n \t}\n@@ -2635,15 +2633,15 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t  if (virtual_offset\n \t      || (thunk_binfo && !BINFO_OFFSET_ZEROP (thunk_binfo)))\n \t    {\n-\t      tree offset = convert (ssizetype, BINFO_OFFSET (thunk_binfo));\n+\t      tree offset = fold_convert (ssizetype, BINFO_OFFSET (thunk_binfo));\n \n \t      if (virtual_offset)\n \t\t{\n \t\t  /* We convert via virtual base.  Adjust the fixed\n \t\t     offset to be from there.  */\n \t\t  offset = \n \t\t    size_diffop (offset,\n-\t\t\t\t convert (ssizetype,\n+\t\t\t\t fold_convert (ssizetype,\n \t\t\t\t\t  BINFO_OFFSET (virtual_offset)));\n \t\t}\n \t      if (fixed_offset)\n@@ -2732,8 +2730,8 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n     /* The `this' pointer needs to be adjusted from the declaration to\n        the nearest virtual base.  */\n     delta = size_diffop_loc (input_location,\n-\t\t\t convert (ssizetype, BINFO_OFFSET (virtual_base)),\n-\t\t\t convert (ssizetype, BINFO_OFFSET (first_defn)));\n+\t\t\t fold_convert (ssizetype, BINFO_OFFSET (virtual_base)),\n+\t\t\t fold_convert (ssizetype, BINFO_OFFSET (first_defn)));\n   else if (lost)\n     /* If the nearest definition is in a lost primary, we don't need an\n        entry in our vtable.  Except possibly in a constructor vtable,\n@@ -2745,9 +2743,9 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n        BINFO to pointing at the base where the final overrider\n        appears.  */\n     delta = size_diffop_loc (input_location,\n-\t\t\t convert (ssizetype,\n+\t\t\t fold_convert (ssizetype,\n \t\t\t\t  BINFO_OFFSET (TREE_VALUE (overrider))),\n-\t\t\t convert (ssizetype, BINFO_OFFSET (binfo)));\n+\t\t\t fold_convert (ssizetype, BINFO_OFFSET (binfo)));\n \n   modify_vtable_entry (t, binfo, overrider_fn, delta, virtuals);\n \n@@ -3469,7 +3467,7 @@ check_bitfield_decl (tree field)\n \n   if (w != error_mark_node)\n     {\n-      DECL_SIZE (field) = convert (bitsizetype, w);\n+      DECL_SIZE (field) = fold_convert (bitsizetype, w);\n       DECL_BIT_FIELD (field) = 1;\n       return true;\n     }\n@@ -4314,8 +4312,8 @@ layout_nonempty_base_or_field (record_layout_info rli,\n        OFFSET.  */\n     propagate_binfo_offsets (binfo,\n \t\t\t     size_diffop_loc (input_location,\n-\t\t\t\t\t  convert (ssizetype, offset),\n-\t\t\t\t\t  convert (ssizetype,\n+\t\t\t\t\t  fold_convert (ssizetype, offset),\n+\t\t\t\t\t  fold_convert (ssizetype,\n \t\t\t\t\t\t   BINFO_OFFSET (binfo))));\n }\n \n@@ -4362,7 +4360,7 @@ layout_empty_base (record_layout_info rli, tree binfo,\n       /* That didn't work.  Now, we move forward from the next\n \t available spot in the class.  */\n       atend = true;\n-      propagate_binfo_offsets (binfo, convert (ssizetype, eoc));\n+      propagate_binfo_offsets (binfo, fold_convert (ssizetype, eoc));\n       while (1)\n \t{\n \t  if (!layout_conflict_p (binfo,\n@@ -5976,9 +5974,9 @@ propagate_binfo_offsets (tree binfo, tree offset)\n \n   /* Update BINFO's offset.  */\n   BINFO_OFFSET (binfo)\n-    = convert (sizetype,\n+    = fold_convert (sizetype,\n \t       size_binop (PLUS_EXPR,\n-\t\t\t   convert (ssizetype, BINFO_OFFSET (binfo)),\n+\t\t\t   fold_convert (ssizetype, BINFO_OFFSET (binfo)),\n \t\t\t   offset));\n \n   /* Find the primary base class.  */\n@@ -6183,7 +6181,7 @@ include_empty_classes (record_layout_info rli)\n \t= size_binop (PLUS_EXPR,\n \t\t      rli->bitpos,\n \t\t      size_binop (MULT_EXPR,\n-\t\t\t\t  convert (bitsizetype,\n+\t\t\t\t  fold_convert (bitsizetype,\n \t\t\t\t\t   size_binop (MINUS_EXPR,\n \t\t\t\t\t\t       eoc, rli_size)),\n \t\t\t\t  bitsize_int (BITS_PER_UNIT)));\n@@ -6457,7 +6455,7 @@ layout_class_type (tree t, tree *virtuals_p)\n       eoc = end_of_class (t, /*include_virtuals_p=*/0);\n       TYPE_SIZE_UNIT (base_t)\n \t= size_binop (MAX_EXPR,\n-\t\t      convert (sizetype,\n+\t\t      fold_convert (sizetype,\n \t\t\t       size_binop (CEIL_DIV_EXPR,\n \t\t\t\t\t   rli_size_so_far (rli),\n \t\t\t\t\t   bitsize_int (BITS_PER_UNIT))),\n@@ -6466,7 +6464,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t= size_binop (MAX_EXPR,\n \t\t      rli_size_so_far (rli),\n \t\t      size_binop (MULT_EXPR,\n-\t\t\t\t  convert (bitsizetype, eoc),\n+\t\t\t\t  fold_convert (bitsizetype, eoc),\n \t\t\t\t  bitsize_int (BITS_PER_UNIT)));\n       TYPE_ALIGN (base_t) = rli->record_align;\n       TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);\n@@ -9302,7 +9300,7 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       /* Figure out where we can find this vbase offset.  */\n       delta = size_binop (MULT_EXPR,\n \t\t\t  vid->index,\n-\t\t\t  convert (ssizetype,\n+\t\t\t  fold_convert (ssizetype,\n \t\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n       if (vid->primary_vtbl_p)\n \tBINFO_VPTR_FIELD (b) = delta;"}, {"sha": "ba841dfef7711fced9dcfc6231d11228090e1cc1", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -29,4 +29,4 @@ compilers=\"cc1plus\\$(exeext)\"\n \n target_libs=\"target-libstdc++-v3\"\n \n-gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/cp-lang.c \\$(srcdir)/cp/except.c \\$(srcdir)/cp/vtable-class-hierarchy.c \\$(srcdir)/cp/constexpr.c\"\n+gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/cp-lang.c \\$(srcdir)/cp/except.c \\$(srcdir)/cp/vtable-class-hierarchy.c \\$(srcdir)/cp/constexpr.c \\$(srcdir)/cp/cp-gimplify.c\""}, {"sha": "aabb980915459ef1b7bd4657ee486361661ed65b", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 135, "deletions": 15, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1035,6 +1035,8 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n   force_folding_builtin_constant_p = true;\n   new_call = fold_build_call_array_loc (EXPR_LOCATION (t), TREE_TYPE (t),\n \t\t\t\t\tCALL_EXPR_FN (t), nargs, args);\n+  /* Fold away the NOP_EXPR from fold_builtin_n.  */\n+  new_call = fold (new_call);\n   force_folding_builtin_constant_p = save_ffbcp;\n   VERIFY_CONSTANT (new_call);\n   return new_call;\n@@ -1275,6 +1277,16 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       ctx->values->put (new_ctx.object, ctor);\n       ctx = &new_ctx;\n     }\n+  else if (DECL_BY_REFERENCE (DECL_RESULT (fun))\n+\t   && TREE_CODE (t) != AGGR_INIT_EXPR)\n+    {\n+      /* convert_to_void stripped our AGGR_INIT_EXPR, in which case we don't\n+\t care about a constant value.  ??? we could still optimize away the\n+\t call.  */\n+      gcc_assert (ctx->quiet && !ctx->object);\n+      *non_constant_p = true;\n+      return t;\n+    }\n \n   bool non_constant_args = false;\n   cxx_bind_parameters_in_call (ctx, t, &new_call,\n@@ -2540,6 +2552,17 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n   tree orig_op0 = TREE_OPERAND (t, 0);\n   bool empty_base = false;\n \n+  /* We can handle a MEM_REF like an INDIRECT_REF, if MEM_REF's second\n+     operand is an integer-zero.  Otherwise reject the MEM_REF for now.  */\n+\n+  if (TREE_CODE (t) == MEM_REF\n+      && (!TREE_OPERAND (t, 1) || !integer_zerop (TREE_OPERAND (t, 1))))\n+    {\n+      gcc_assert (ctx->quiet);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n   /* First try to simplify it directly.  */\n   tree r = cxx_fold_indirect_ref (EXPR_LOCATION (t), TREE_TYPE (t), orig_op0,\n \t\t\t\t  &empty_base);\n@@ -3073,6 +3096,8 @@ cxx_eval_pointer_plus_expression (const constexpr_ctx *ctx, tree t,\n   if (TREE_CODE (op00) != ADDR_EXPR)\n     return NULL_TREE;\n \n+  op01 = cxx_eval_constant_expression (ctx, op01, lval,\n+\t\t\t\t       non_constant_p, overflow_p);\n   op00 = TREE_OPERAND (op00, 0);\n \n   /* &A[i] p+ j => &A[i + j] */\n@@ -3333,6 +3358,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       /* These differ from cxx_eval_unary_expression in that this doesn't\n \t check for a constant operand or result; an address can be\n \t constant without its operand being, and vice versa.  */\n+    case MEM_REF:\n     case INDIRECT_REF:\n       r = cxx_eval_indirect_ref (ctx, t, lval,\n \t\t\t\t non_constant_p, overflow_p);\n@@ -3370,17 +3396,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case SIZEOF_EXPR:\n-      if (SIZEOF_EXPR_TYPE_P (t))\n-\tr = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (t, 0)),\n-\t\t\t\t\tSIZEOF_EXPR, false);\n-      else if (TYPE_P (TREE_OPERAND (t, 0)))\n-\tr = cxx_sizeof_or_alignof_type (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n-\t\t\t\t\tfalse);\n-      else\n-\tr = cxx_sizeof_or_alignof_expr (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n-\t\t\t\t\tfalse);\n-      if (r == error_mark_node)\n-\tr = size_one_node;\n+      r = fold_sizeof_expr (t);\n       VERIFY_CONSTANT (r);\n       break;\n \n@@ -3538,8 +3554,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case CONVERT_EXPR:\n     case VIEW_CONVERT_EXPR:\n     case NOP_EXPR:\n+    case UNARY_PLUS_EXPR:\n       {\n+\tenum tree_code tcode = TREE_CODE (t);\n \ttree oldop = TREE_OPERAND (t, 0);\n+\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n \t\t\t\t\t\tlval,\n \t\t\t\t\t\tnon_constant_p, overflow_p);\n@@ -3559,11 +3578,14 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    *non_constant_p = true;\n \t    return t;\n \t  }\n-\tif (op == oldop)\n+\tif (op == oldop && tcode != UNARY_PLUS_EXPR)\n \t  /* We didn't fold at the top so we could check for ptr-int\n \t     conversion.  */\n \t  return fold (t);\n-\tr = fold_build1 (TREE_CODE (t), type, op);\n+\tif (tcode == UNARY_PLUS_EXPR)\n+\t  r = fold_convert (TREE_TYPE (t), op);\n+\telse\n+\t  r = fold_build1 (tcode, type, op);\n \t/* Conversion of an out-of-range value has implementation-defined\n \t   behavior; the language considers it different from arithmetic\n \t   overflow, which is undefined.  */\n@@ -3831,12 +3853,86 @@ cxx_constant_value (tree t, tree decl)\n   return cxx_eval_outermost_constant_expr (t, false, true, decl);\n }\n \n+/* Helper routine for fold_simple function.  Either return simplified\n+   expression T, otherwise NULL_TREE.\n+   In contrast to cp_fully_fold, and to maybe_constant_value, we try to fold\n+   even if we are within template-declaration.  So be careful on call, as in\n+   such case types can be undefined.  */\n+\n+static tree\n+fold_simple_1 (tree t)\n+{\n+  tree op1;\n+  enum tree_code code = TREE_CODE (t);\n+\n+  switch (code)\n+    {\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case VECTOR_CST:\n+    case FIXED_CST:\n+    case COMPLEX_CST:\n+      return t;\n+\n+    case SIZEOF_EXPR:\n+      return fold_sizeof_expr (t);\n+\n+    case ABS_EXPR:\n+    case CONJ_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case NOP_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+    case CONVERT_EXPR:\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FIXED_CONVERT_EXPR:\n+    case ADDR_SPACE_CONVERT_EXPR:\n+\n+      op1 = TREE_OPERAND (t, 0);\n+\n+      t = const_unop (code, TREE_TYPE (t), op1);\n+      if (!t)\n+\treturn NULL_TREE;\n+\n+      if (CONVERT_EXPR_CODE_P (code)\n+\t  && TREE_OVERFLOW_P (t) && !TREE_OVERFLOW_P (op1))\n+\tTREE_OVERFLOW (t) = false;\n+      return t;\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* If T is a simple constant expression, returns its simplified value.\n+   Otherwise returns T.  In contrast to maybe_constant_value do we\n+   simplify only few operations on constant-expressions, and we don't\n+   try to simplify constexpressions.  */\n+\n+tree\n+fold_simple (tree t)\n+{\n+  tree r = NULL_TREE;\n+  if (processing_template_decl)\n+    return t;\n+\n+  r = fold_simple_1 (t);\n+  if (!r)\n+    r = t;\n+\n+  return r;\n+}\n+\n /* If T is a constant expression, returns its reduced value.\n    Otherwise, if T does not have TREE_CONSTANT set, returns T.\n    Otherwise, returns a version of T without TREE_CONSTANT.  */\n \n-tree\n-maybe_constant_value (tree t, tree decl)\n+static tree\n+maybe_constant_value_1 (tree t, tree decl)\n {\n   tree r;\n \n@@ -3862,6 +3958,24 @@ maybe_constant_value (tree t, tree decl)\n   return r;\n }\n \n+static GTY((cache, deletable)) cache_map cv_cache;\n+\n+/* If T is a constant expression, returns its reduced value.\n+   Otherwise, if T does not have TREE_CONSTANT set, returns T.\n+   Otherwise, returns a version of T without TREE_CONSTANT.  */\n+\n+tree\n+maybe_constant_value (tree t, tree decl)\n+{\n+  tree ret = cv_cache.get (t);\n+  if (!ret)\n+    {\n+      ret = maybe_constant_value_1 (t, decl);\n+      cv_cache.put (t, ret);\n+    }\n+  return ret;\n+}\n+\n /* Like maybe_constant_value but first fully instantiate the argument.\n \n    Note: this is equivalent to instantiate_non_dependent_expr_sfinae\n@@ -3927,6 +4041,8 @@ fold_non_dependent_expr (tree t)\n tree\n maybe_constant_init (tree t, tree decl)\n {\n+  if (!t)\n+    return t;\n   if (TREE_CODE (t) == EXPR_STMT)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == CONVERT_EXPR\n@@ -4037,6 +4153,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n       /* We can see a FIELD_DECL in a pointer-to-member expression.  */\n     case FIELD_DECL:\n     case PARM_DECL:\n+    case RESULT_DECL:\n     case USING_DECL:\n     case USING_STMT:\n     case PLACEHOLDER_EXPR:\n@@ -4625,6 +4742,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n       /* We can see these in statement-expressions.  */\n       return true;\n \n+    case EMPTY_CLASS_EXPR:\n+      return false;\n+\n     default:\n       if (objc_is_property_ref (t))\n \treturn false;"}, {"sha": "84d79258fdbbecb7ae85cf3f19b6cb30e9b55d89", "filename": "gcc/cp/cp-array-notation.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1380,7 +1380,12 @@ build_array_notation_ref (location_t loc, tree array, tree start, tree length,\n     \n   if (!stride) \n     stride = build_one_cst (ptrdiff_type_node);\n-  \n+\n+  stride = maybe_constant_value (stride);\n+  length = maybe_constant_value (length);\n+  if (start)\n+    start = maybe_constant_value (start);\n+\n   /* When dealing with templates, triplet type-checking will be done in pt.c \n      after type substitution.  */\n   if (processing_template_decl "}, {"sha": "5f5cd367f58830ad7b7e5b22306e7d31c0596f0f", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 471, "deletions": 17, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -36,7 +36,9 @@ along with GCC; see the file COPYING3.  If not see\n /* Forward declarations.  */\n \n static tree cp_genericize_r (tree *, int *, void *);\n+static tree cp_fold_r (tree *, int *, void *);\n static void cp_genericize_tree (tree*);\n+static tree cp_fold (tree);\n \n /* Local declarations.  */\n \n@@ -914,6 +916,71 @@ struct cp_genericize_data\n   bool no_sanitize_p;\n };\n \n+/* Perform any pre-gimplification folding of C++ front end trees to\n+   GENERIC.\n+   Note:  The folding of none-omp cases is something to move into\n+     the middle-end.  As for now we have most foldings only on GENERIC\n+     in fold-const, we need to perform this before transformation to\n+     GIMPLE-form.  */\n+\n+static tree\n+cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n+{\n+  tree stmt;\n+  enum tree_code code;\n+\n+  *stmt_p = stmt = cp_fold (*stmt_p);\n+\n+  code = TREE_CODE (stmt);\n+  if (code == OMP_FOR || code == OMP_SIMD || code == OMP_DISTRIBUTE\n+      || code == OMP_TASKLOOP || code == CILK_FOR || code == CILK_SIMD)\n+    {\n+      tree x;\n+      int i, n;\n+\n+      cp_walk_tree (&OMP_FOR_BODY (stmt), cp_fold_r, data, NULL);\n+      cp_walk_tree (&OMP_FOR_CLAUSES (stmt), cp_fold_r, data, NULL);\n+      cp_walk_tree (&OMP_FOR_INIT (stmt), cp_fold_r, data, NULL);\n+      x = OMP_FOR_COND (stmt);\n+      if (x && TREE_CODE_CLASS (TREE_CODE (x)) == tcc_comparison)\n+\t{\n+\t  cp_walk_tree (&TREE_OPERAND (x, 0), cp_fold_r, data, NULL);\n+\t  cp_walk_tree (&TREE_OPERAND (x, 1), cp_fold_r, data, NULL);\n+\t}\n+      else if (x && TREE_CODE (x) == TREE_VEC)\n+\t{\n+\t  n = TREE_VEC_LENGTH (x);\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      tree o = TREE_VEC_ELT (x, i);\n+\t      if (o && TREE_CODE_CLASS (TREE_CODE (o)) == tcc_comparison)\n+\t\tcp_walk_tree (&TREE_OPERAND (o, 1), cp_fold_r, data, NULL);\n+\t    }\n+\t}\n+      x = OMP_FOR_INCR (stmt);\n+      if (x && TREE_CODE (x) == TREE_VEC)\n+\t{\n+\t  n = TREE_VEC_LENGTH (x);\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      tree o = TREE_VEC_ELT (x, i);\n+\t      if (o && TREE_CODE (o) == MODIFY_EXPR)\n+\t\to = TREE_OPERAND (o, 1);\n+\t      if (o && (TREE_CODE (o) == PLUS_EXPR || TREE_CODE (o) == MINUS_EXPR\n+\t\t\t|| TREE_CODE (o) == POINTER_PLUS_EXPR))\n+\t\t{\n+\t\t  cp_walk_tree (&TREE_OPERAND (o, 0), cp_fold_r, data, NULL);\n+\t\t  cp_walk_tree (&TREE_OPERAND (o, 1), cp_fold_r, data, NULL);\n+\t\t}\n+\t    }\n+\t}\n+      cp_walk_tree (&OMP_FOR_PRE_BODY (stmt), cp_fold_r, data, NULL);\n+      *walk_subtrees = 0;\n+    }\n+\n+  return NULL;\n+}\n+\n /* Perform any pre-gimplification lowering of C++ front end trees to\n    GENERIC.  */\n \n@@ -973,7 +1040,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       if (__builtin_expect (wtd->omp_ctx != NULL, 0)\n \t  && omp_var_to_track (TREE_OPERAND (stmt, 0)))\n \tomp_cxx_notice_variable (wtd->omp_ctx, TREE_OPERAND (stmt, 0));\n-      *stmt_p = convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n+      *stmt_p = fold_convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n       *walk_subtrees = 0;\n     }\n   else if (TREE_CODE (stmt) == RETURN_EXPR\n@@ -1288,22 +1355,6 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t   || TREE_CODE (stmt) == OMP_DISTRIBUTE\n \t   || TREE_CODE (stmt) == OMP_TASKLOOP)\n     genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n-  else if (TREE_CODE (stmt) == SIZEOF_EXPR)\n-    {\n-      if (SIZEOF_EXPR_TYPE_P (stmt))\n-\t*stmt_p\n-\t  = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (stmt, 0)),\n-\t\t\t\t\tSIZEOF_EXPR, false);\n-      else if (TYPE_P (TREE_OPERAND (stmt, 0)))\n-\t*stmt_p = cxx_sizeof_or_alignof_type (TREE_OPERAND (stmt, 0),\n-\t\t\t\t\t      SIZEOF_EXPR, false);\n-      else\n-\t*stmt_p = cxx_sizeof_or_alignof_expr (TREE_OPERAND (stmt, 0),\n-\t\t\t\t\t      SIZEOF_EXPR, false);\n-      if (*stmt_p == error_mark_node)\n-\t*stmt_p = size_one_node;\n-      return NULL;\n-    }\n   else if ((flag_sanitize\n \t    & (SANITIZE_NULL | SANITIZE_ALIGNMENT | SANITIZE_VPTR))\n \t   && !wtd->no_sanitize_p)\n@@ -1414,6 +1465,10 @@ cp_genericize (tree fndecl)\n {\n   tree t;\n \n+  /* Fold ALL the trees!  FIXME we should be able to remove this, but\n+     apparently that still causes optimization regressions.  */\n+  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, NULL, NULL);\n+\n   /* Fix up the types of parms passed by invisible reference.  */\n   for (t = DECL_ARGUMENTS (fndecl); t; t = DECL_CHAIN (t))\n     if (TREE_ADDRESSABLE (TREE_TYPE (t)))\n@@ -1777,3 +1832,402 @@ cxx_omp_disregard_value_expr (tree decl, bool shared)\n \t && DECL_LANG_SPECIFIC (decl)\n \t && DECL_OMP_PRIVATIZED_MEMBER (decl);\n }\n+\n+/* Callback for walk_tree, looking for LABEL_EXPR.  Return *TP if it is\n+   a LABEL_EXPR; otherwise return NULL_TREE.  Do not check the subtrees\n+   of GOTO_EXPR.  */\n+\n+static tree\n+contains_label_1 (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  switch (TREE_CODE (*tp))\n+    {\n+    case LABEL_EXPR:\n+      return *tp;\n+\n+    case GOTO_EXPR:\n+      *walk_subtrees = 0;\n+\n+      /* ... fall through ...  */\n+\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Return whether the sub-tree ST contains a label which is accessible from\n+   outside the sub-tree.  */\n+\n+static bool\n+contains_label_p (tree st)\n+{\n+  return\n+   walk_tree_without_duplicates (&st, contains_label_1 , NULL) != NULL_TREE;\n+}\n+\n+/* Perform folding on expression X.  */\n+\n+tree\n+cp_fully_fold (tree x)\n+{\n+  return cp_fold (x);\n+}\n+\n+static GTY((cache, deletable)) cache_map fold_cache;\n+\n+/*  This function tries to fold an expression X.\n+    To avoid combinatorial explosion, folding results are kept in fold_cache.\n+    If we are processing a template or X is invalid, we don't fold at all.\n+    For performance reasons we don't cache expressions representing a\n+    declaration or constant.\n+    Function returns X or its folded variant.  */\n+\n+static tree\n+cp_fold (tree x)\n+{\n+  tree op0, op1, op2, op3;\n+  tree org_x = x, r = NULL_TREE;\n+  enum tree_code code;\n+  location_t loc;\n+\n+  if (!x || error_operand_p (x))\n+    return x;\n+\n+  if (processing_template_decl\n+      || (EXPR_P (x) && !TREE_TYPE (x)))\n+    return x;\n+\n+  /* Don't bother to cache DECLs or constants.  */\n+  if (DECL_P (x) || CONSTANT_CLASS_P (x))\n+    return x;\n+\n+  if (tree cached = fold_cache.get (x))\n+    return cached;\n+\n+  code = TREE_CODE (x);\n+  switch (code)\n+    {\n+    case SIZEOF_EXPR:\n+      x = fold_sizeof_expr (x);\n+      break;\n+\n+    case VIEW_CONVERT_EXPR:\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+    case NON_LVALUE_EXPR:\n+\n+      if (VOID_TYPE_P (TREE_TYPE (x)))\n+\treturn x;\n+\n+      if (!TREE_OPERAND (x, 0)\n+\t  || TREE_CODE (TREE_OPERAND (x, 0)) == NON_LVALUE_EXPR)\n+\treturn x;\n+\n+      loc = EXPR_LOCATION (x);\n+      op0 = TREE_OPERAND (x, 0);\n+\n+      if (TREE_CODE (x) == NOP_EXPR\n+\t  && TREE_OVERFLOW_P (op0)\n+\t  && TREE_TYPE (x) == TREE_TYPE (op0))\n+\treturn x;\n+\n+      op0 = cp_fold (op0);\n+\n+      if (op0 != TREE_OPERAND (x, 0))\n+        x = build1_loc (loc, code, TREE_TYPE (x), op0);\n+\n+      x = fold (x);\n+\n+      /* Conversion of an out-of-range value has implementation-defined\n+\t behavior; the language considers it different from arithmetic\n+\t overflow, which is undefined.  */\n+      if (TREE_CODE (op0) == INTEGER_CST\n+\t  && TREE_OVERFLOW_P (x) && !TREE_OVERFLOW_P (op0))\n+\tTREE_OVERFLOW (x) = false;\n+\n+      break;\n+\n+    case SAVE_EXPR:\n+    case ADDR_EXPR:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case CONJ_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case FLOAT_EXPR:\n+    case NEGATE_EXPR:\n+    case ABS_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case FIXED_CONVERT_EXPR:\n+    case UNARY_PLUS_EXPR:\n+    case INDIRECT_REF:\n+\n+      loc = EXPR_LOCATION (x);\n+      op0 = cp_fold (TREE_OPERAND (x, 0));\n+\n+      if (op0 != TREE_OPERAND (x, 0))\n+        x = build1_loc (loc, code, TREE_TYPE (x), op0);\n+\n+      x = fold (x);\n+\n+      gcc_assert (TREE_CODE (x) != COND_EXPR\n+\t\t  || !VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (x, 0))));\n+      break;\n+\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case INIT_EXPR:\n+\n+\tloc = EXPR_LOCATION (x);\n+\top0 = cp_fold (TREE_OPERAND (x, 0));\n+\top1 = cp_fold (TREE_OPERAND (x, 1));\n+\n+\tif (TREE_OPERAND (x, 0) != op0 || TREE_OPERAND (x, 1) != op1)\n+\t  x = build2_loc (loc, code, TREE_TYPE (x), op0, op1);\n+\n+\tbreak;\n+\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case COMPOUND_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case LT_EXPR: case LE_EXPR:\n+    case GT_EXPR: case GE_EXPR:\n+    case EQ_EXPR: case NE_EXPR:\n+    case UNORDERED_EXPR: case ORDERED_EXPR:\n+    case UNLT_EXPR: case UNLE_EXPR:\n+    case UNGT_EXPR: case UNGE_EXPR:\n+    case UNEQ_EXPR: case LTGT_EXPR:\n+    case RANGE_EXPR: case COMPLEX_EXPR:\n+    case MODIFY_EXPR:\n+\n+      loc = EXPR_LOCATION (x);\n+      op0 = cp_fold (TREE_OPERAND (x, 0));\n+      op1 = cp_fold (TREE_OPERAND (x, 1));\n+      if ((code == COMPOUND_EXPR || code == MODIFY_EXPR)\n+\t  && ((op1 && TREE_SIDE_EFFECTS (op1))\n+\t       || (op0 && TREE_SIDE_EFFECTS (op0))))\n+\tbreak;\n+      if (TREE_CODE (x) == COMPOUND_EXPR && !op0)\n+\top0 = build_empty_stmt (loc);\n+\n+      if (op0 != TREE_OPERAND (x, 0) || op1 != TREE_OPERAND (x, 1))\n+\tx = build2_loc (loc, code, TREE_TYPE (x), op0, op1);\n+\n+      x = fold (x);\n+\n+      if (TREE_CODE (x) == COMPOUND_EXPR && TREE_OPERAND (x, 0) == NULL_TREE\n+\t  && TREE_OPERAND (x, 1))\n+\treturn TREE_OPERAND (x, 1);\n+      break;\n+\n+    case VEC_COND_EXPR:\n+    case COND_EXPR:\n+\n+      loc = EXPR_LOCATION (x);\n+      op0 = cp_fold (TREE_OPERAND (x, 0));\n+\n+      if (TREE_SIDE_EFFECTS (op0))\n+\tbreak;\n+\n+      op1 = cp_fold (TREE_OPERAND (x, 1));\n+      op2 = cp_fold (TREE_OPERAND (x, 2));\n+\n+      if (TREE_CODE (op0) == INTEGER_CST)\n+\t{\n+\t  tree un;\n+\n+\t  if (integer_zerop (op0))\n+\t    {\n+\t      un = op1;\n+\t      r = op2;\n+\t    }\n+\t  else\n+\t    {\n+\t      un = op2;\n+\t      r = op1;\n+\t    }\n+\n+          if ((!TREE_SIDE_EFFECTS (un) || !contains_label_p (un))\n+              && (! VOID_TYPE_P (TREE_TYPE (r)) || VOID_TYPE_P (x)))\n+            {\n+\t      if (CAN_HAVE_LOCATION_P (r)\n+\t\t  && EXPR_LOCATION (r) != loc\n+\t\t  && !(TREE_CODE (r) == SAVE_EXPR\n+\t\t       || TREE_CODE (r) == TARGET_EXPR\n+\t\t       || TREE_CODE (r) == BIND_EXPR))\n+\t        {\n+\t\t  r = copy_node (r);\n+\t\t  SET_EXPR_LOCATION (r, loc);\n+\t        }\n+\t      x = r;\n+\t    }\n+\n+\t  break;\n+\t}\n+\n+      if (VOID_TYPE_P (TREE_TYPE (x)))\n+\tbreak;\n+\n+      x = build3_loc (loc, code, TREE_TYPE (x), op0, op1, op2);\n+\n+      if (code != COND_EXPR)\n+\tx = fold (x);\n+\n+      break;\n+\n+    case CALL_EXPR:\n+      {\n+\tint i, m, sv = optimize, nw = sv, changed = 0;\n+\ttree callee = get_callee_fndecl (x);\n+\n+\tif (callee && DECL_BUILT_IN (callee) && !optimize\n+\t    && DECL_IS_BUILTIN_CONSTANT_P (callee)\n+\t    && current_function_decl\n+\t    && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n+\t  nw = 1;\n+\toptimize = nw;\n+\tr = fold (x);\n+\toptimize = sv;\n+\n+\tif (TREE_CODE (r) != CALL_EXPR)\n+\t  {\n+\t    x = cp_fold (r);\n+\t    break;\n+\t  }\n+\n+\tx = copy_node (x);\n+\n+\tm = call_expr_nargs (x);\n+\tfor (i = 0; i < m; i++)\n+\t  {\n+\t    r = cp_fold (CALL_EXPR_ARG (x, i));\n+\t    if (r != CALL_EXPR_ARG (x, i))\n+\t      changed = 1;\n+\t    CALL_EXPR_ARG (x, i) = r;\n+\t  }\n+\n+\toptimize = nw;\n+\tr = fold (x);\n+\toptimize = sv;\n+\n+\tif (TREE_CODE (r) != CALL_EXPR)\n+\t  {\n+\t    x = cp_fold (r);\n+\t    break;\n+\t  }\n+\n+\toptimize = nw;\n+\n+\t/* Invoke maybe_constant_value for functions being declared\n+\t   constexpr, and are no AGGR_INIT_EXPRs ...\n+\t   TODO:\n+\t   Due issues in maybe_constant_value for CALL_EXPR with\n+\t   arguments passed by reference, it is disabled.  */\n+\tif (callee && DECL_DECLARED_CONSTEXPR_P (callee))\n+          r = maybe_constant_value (x);\n+\toptimize = sv;\n+\n+        if (TREE_CODE (r) != CALL_EXPR)\n+\t  {\n+\t    x = r;\n+\t    break;\n+\t  }\n+\n+\tif (!changed)\n+\t  x = org_x;\n+\tbreak;\n+      }\n+\n+    case CONSTRUCTOR:\n+      {\n+\tunsigned i;\n+\tconstructor_elt *p;\n+\tvec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (x);\n+\tFOR_EACH_VEC_SAFE_ELT (elts, i, p)\n+\t  p->value = cp_fold (p->value);\n+\tbreak;\n+      }\n+    case TREE_VEC:\n+      {\n+\tbool changed = false;\n+\tvec<tree, va_gc> *vec = make_tree_vector ();\n+\tint i, n = TREE_VEC_LENGTH (x);\n+\tvec_safe_reserve (vec, n);\n+\n+\tfor (i = 0; i < n; i++)\n+\t  {\n+\t    tree op = cp_fold (TREE_VEC_ELT (x, i));\n+\t    vec->quick_push (op);\n+\t    if (op != TREE_VEC_ELT (x, i))\n+\t      changed = true;\n+\t  }\n+\n+\tif (changed)\n+\t  {\n+\t    r = copy_node (x);\n+\t    for (i = 0; i < n; i++)\n+\t      TREE_VEC_ELT (r, i) = (*vec)[i];\n+\t    x = r;\n+\t  }\n+\n+\trelease_tree_vector (vec);\n+      }\n+\n+      break;\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+\n+      loc = EXPR_LOCATION (x);\n+      op0 = cp_fold (TREE_OPERAND (x, 0));\n+      op1 = cp_fold (TREE_OPERAND (x, 1));\n+      op2 = cp_fold (TREE_OPERAND (x, 2));\n+      op3 = cp_fold (TREE_OPERAND (x, 3));\n+\n+      if (op0 != TREE_OPERAND (x, 0) || op1 != TREE_OPERAND (x, 1)\n+\t  || op2 != TREE_OPERAND (x, 2) || op3 != TREE_OPERAND (x, 3))\n+\tx = build4_loc (loc, code, TREE_TYPE (x), op0, op1, op2, op3);\n+\n+      x = fold (x);\n+      break;\n+\n+    default:\n+      return org_x;\n+    }\n+\n+  fold_cache.put (org_x, x);\n+  /* Prevent that we try to fold an already folded result again.  */\n+  if (x != org_x)\n+    fold_cache.put (x, x);\n+\n+  return x;\n+}\n+\n+#include \"gt-cp-cp-gimplify.h\""}, {"sha": "84437b4a8277503fcbe64e6909aa5532a4da2d8d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -5447,6 +5447,42 @@ extern cp_parameter_declarator *no_parameters;\n /* True if we saw \"#pragma GCC java_exceptions\".  */\n extern bool pragma_java_exceptions;\n \n+/* Data structure for a mapping from tree to tree that's only used as a cache;\n+   we don't GC-mark trees in the map, and we clear the map when collecting\n+   garbage.  Global variables of this type must be marked\n+   GTY((cache,deletable)) so that the gt_cleare_cache function is called by\n+   ggc_collect but we don't try to load the map pointer from a PCH.\n+\n+   FIXME improve to use keep_cache_entry.  */\n+class cache_map\n+{\n+  /* Use a lazily initialized pointer rather than a map member since a\n+     hash_map can't be constructed in a static initializer.  */\n+  hash_map<tree, tree> *map;\n+\n+public:\n+  tree get (tree key)\n+  {\n+    if (map)\n+      if (tree *slot = map->get (key))\n+\treturn *slot;\n+    return NULL_TREE;\n+  }\n+\n+  bool put (tree key, tree val)\n+  {\n+    if (!map)\n+      map = new hash_map<tree, tree>;\n+    return map->put (key, val);\n+  }\n+\n+  friend inline void gt_cleare_cache (cache_map &cm)\n+  {\n+    if (cm.map)\n+      cm.map->empty();\n+  }\n+};\n+\n /* in call.c */\n extern bool check_dtor_name\t\t\t(tree, tree);\n bool magic_varargs_p                            (tree);\n@@ -6474,7 +6510,6 @@ extern tree cp_walk_subtrees (tree*, int*, walk_tree_fn,\n \twalk_tree_1 (tp, func, data, pset, cp_walk_subtrees)\n #define cp_walk_tree_without_duplicates(tp,func,data) \\\n \twalk_tree_without_duplicates_1 (tp, func, data, cp_walk_subtrees)\n-extern tree fold_if_not_in_template\t\t(tree);\n extern tree rvalue\t\t\t\t(tree);\n extern tree convert_bitfield_to_declared_type   (tree);\n extern tree cp_save_expr\t\t\t(tree);\n@@ -6705,6 +6740,7 @@ extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n extern void cxx_omp_finish_clause\t\t(tree, gimple_seq *);\n extern bool cxx_omp_privatize_by_reference\t(const_tree);\n extern bool cxx_omp_disregard_value_expr\t(tree, bool);\n+extern tree cp_fully_fold\t\t\t(tree);\n \n /* in name-lookup.c */\n extern void suggest_alternatives_for            (location_t, tree);\n@@ -6796,12 +6832,14 @@ extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE);\n extern tree fold_non_dependent_expr\t\t(tree);\n+extern tree fold_simple\t\t\t\t(tree);\n extern bool is_sub_constant_expr                (tree);\n extern bool reduced_constant_expression_p       (tree);\n extern bool is_instantiation_of_constexpr       (tree);\n extern bool var_in_constexpr_fn                 (tree);\n extern void explain_invalid_constexpr_fn        (tree);\n extern vec<tree> cx_error_context               (void);\n+extern tree fold_sizeof_expr\t\t\t(tree);\n \n /* In c-family/cilk.c */\n extern bool cilk_valid_spawn                    (tree);"}, {"sha": "0231efc95279b3f22f56e5244be9a535b61dea3a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -50,7 +50,7 @@ static void diagnose_ref_binding (location_t, tree, tree, tree);\n \n    Here is a list of all the functions that assume that widening and\n    narrowing is always done with a NOP_EXPR:\n-     In convert.c, convert_to_integer.\n+     In convert.c, convert_to_integer[_nofold].\n      In c-typeck.c, build_binary_op_nodefault (boolean ops),\n \tand c_common_truthvalue_conversion.\n      In expr.c: expand_expr, for operands of a MULT_EXPR.\n@@ -237,7 +237,7 @@ cp_convert_to_pointer (tree type, tree expr, tsubst_flags_t complain)\n       gcc_assert (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (expr)))\n \t\t  == GET_MODE_SIZE (TYPE_MODE (type)));\n \n-      return convert_to_pointer (type, expr);\n+      return convert_to_pointer_nofold (type, expr);\n     }\n \n   if (type_unknown_p (expr))\n@@ -630,22 +630,25 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n \n   if (TREE_TYPE (expr) == type)\n     return expr;\n-  \n+  if (expr == error_mark_node)\n+    return expr;\n   result = cp_convert (type, expr, complain);\n \n   if ((complain & tf_warning)\n       && c_inhibit_evaluation_warnings == 0)\n     {\n-      tree folded = maybe_constant_value (expr);\n-      tree stripped = folded;\n-      tree folded_result\n-\t= folded != expr ? cp_convert (type, folded, complain) : result;\n-\n-      /* maybe_constant_value wraps an INTEGER_CST with TREE_OVERFLOW in a\n-\t NOP_EXPR so that it isn't TREE_CONSTANT anymore.  */\n-      STRIP_NOPS (stripped);\n-\n-      if (!TREE_OVERFLOW_P (stripped)\n+      tree folded = cp_fully_fold (expr);\n+      tree folded_result;\n+      if (folded == expr)\n+\tfolded_result = result;\n+      else\n+\t{\n+\t  /* Avoid bogus -Wparentheses warnings.  */\n+\t  TREE_NO_WARNING (folded) = true;\n+\t  folded_result = cp_convert (type, folded, tf_none);\n+\t}\n+      folded_result = fold_simple (folded_result);\n+      if (!TREE_OVERFLOW_P (folded)\n \t  && folded_result != error_mark_node)\n \twarnings_for_convert_and_check (input_location, type, folded,\n \t\t\t\t\tfolded_result);\n@@ -703,9 +706,9 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n       /* For complex data types, we need to perform componentwise\n \t conversion.  */\n       else if (TREE_CODE (type) == COMPLEX_TYPE)\n-\treturn fold_if_not_in_template (convert_to_complex (type, e));\n+\treturn convert_to_complex_nofold (type, e);\n       else if (VECTOR_TYPE_P (type))\n-\treturn fold_if_not_in_template (convert_to_vector (type, e));\n+\treturn convert_to_vector (type, e);\n       else if (TREE_CODE (e) == TARGET_EXPR)\n \t{\n \t  /* Don't build a NOP_EXPR of class type.  Instead, change the\n@@ -718,7 +721,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t  /* We shouldn't be treating objects of ADDRESSABLE type as\n \t     rvalues.  */\n \t  gcc_assert (!TREE_ADDRESSABLE (type));\n-\t  return fold_if_not_in_template (build_nop (type, e));\n+\t  return build_nop (type, e);\n \t}\n     }\n \n@@ -796,7 +799,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t  return cp_truthvalue_conversion (e);\n \t}\n \n-      converted = fold_if_not_in_template (convert_to_integer (type, e));\n+      converted = convert_to_integer_nofold (type, e);\n \n       /* Ignore any integer overflow caused by the conversion.  */\n       return ignore_overflows (converted, e);\n@@ -808,7 +811,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n       return nullptr_node;\n     }\n   if (POINTER_TYPE_P (type) || TYPE_PTRMEM_P (type))\n-    return fold_if_not_in_template (cp_convert_to_pointer (type, e, complain));\n+    return cp_convert_to_pointer (type, e, complain);\n   if (code == VECTOR_TYPE)\n     {\n       tree in_vtype = TREE_TYPE (e);\n@@ -823,7 +826,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t\t      in_vtype, type);\n \t  return error_mark_node;\n \t}\n-      return fold_if_not_in_template (convert_to_vector (type, e));\n+      return convert_to_vector (type, e);\n     }\n   if (code == REAL_TYPE || code == COMPLEX_TYPE)\n     {\n@@ -839,9 +842,9 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n \t\t      TREE_TYPE (e));\n \t}\n       if (code == REAL_TYPE)\n-\treturn fold_if_not_in_template (convert_to_real (type, e));\n+\treturn convert_to_real_nofold (type, e);\n       else if (code == COMPLEX_TYPE)\n-\treturn fold_if_not_in_template (convert_to_complex (type, e));\n+\treturn convert_to_complex_nofold (type, e);\n     }\n \n   /* New C++ semantics:  since assignment is now based on\n@@ -1454,7 +1457,7 @@ convert (tree type, tree expr)\n   intype = TREE_TYPE (expr);\n \n   if (POINTER_TYPE_P (type) && POINTER_TYPE_P (intype))\n-    return fold_if_not_in_template (build_nop (type, expr));\n+    return build_nop (type, expr);\n \n   return ocp_convert (type, expr, CONV_OLD_CONVERT,\n \t\t      LOOKUP_NORMAL|LOOKUP_NO_CONVERSION,\n@@ -1472,13 +1475,11 @@ convert_force (tree type, tree expr, int convtype, tsubst_flags_t complain)\n   enum tree_code code = TREE_CODE (type);\n \n   if (code == REFERENCE_TYPE)\n-    return (fold_if_not_in_template\n-\t    (convert_to_reference (type, e, CONV_C_CAST, 0,\n-\t\t\t\t   NULL_TREE, complain)));\n+    return convert_to_reference (type, e, CONV_C_CAST, 0,\n+\t\t\t\t NULL_TREE, complain);\n \n   if (code == POINTER_TYPE)\n-    return fold_if_not_in_template (convert_to_pointer_force (type, e,\n-\t\t\t\t\t\t\t      complain));\n+    return convert_to_pointer_force (type, e, complain);\n \n   /* From typeck.c convert_for_assignment */\n   if (((TYPE_PTR_P (TREE_TYPE (e)) && TREE_CODE (e) == ADDR_EXPR"}, {"sha": "675342efcd9f0ac31df18d9e6f51d484ba2ed785", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 31, "deletions": 41, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -8589,33 +8589,24 @@ stabilize_vla_size (tree size)\n   cp_walk_tree (&size, stabilize_save_expr_r, &pset, &pset);\n }\n \n-/* Helper function for compute_array_index_type.  Look for SIZEOF_EXPR\n-   not inside of SAVE_EXPR and fold them.  */\n+/* Reduce a SIZEOF_EXPR to its value.  */\n \n-static tree\n-fold_sizeof_expr_r (tree *expr_p, int *walk_subtrees, void *data)\n-{\n-  tree expr = *expr_p;\n-  if (TREE_CODE (expr) == SAVE_EXPR || TYPE_P (expr))\n-    *walk_subtrees = 0;\n-  else if (TREE_CODE (expr) == SIZEOF_EXPR)\n-    {\n-      *(bool *)data = true;\n-      if (SIZEOF_EXPR_TYPE_P (expr))\n-\texpr = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (expr, 0)),\n-\t\t\t\t\t   SIZEOF_EXPR, false);\n-      else if (TYPE_P (TREE_OPERAND (expr, 0)))\n-\texpr = cxx_sizeof_or_alignof_type (TREE_OPERAND (expr, 0), SIZEOF_EXPR,\n-\t\t\t\t\t   false);\n-      else\n-        expr = cxx_sizeof_or_alignof_expr (TREE_OPERAND (expr, 0), SIZEOF_EXPR,\n-\t\t\t\t\t   false);\n-      if (expr == error_mark_node)\n-        expr = size_one_node;\n-      *expr_p = expr;\n-      *walk_subtrees = 0;\n-    }\n-  return NULL;\n+tree\n+fold_sizeof_expr (tree t)\n+{\n+  tree r;\n+  if (SIZEOF_EXPR_TYPE_P (t))\n+    r = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (t, 0)),\n+\t\t\t\t    SIZEOF_EXPR, false);\n+  else if (TYPE_P (TREE_OPERAND (t, 0)))\n+    r = cxx_sizeof_or_alignof_type (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n+\t\t\t\t    false);\n+  else\n+    r = cxx_sizeof_or_alignof_expr (TREE_OPERAND (t, 0), SIZEOF_EXPR,\n+\t\t\t\t    false);\n+  if (r == error_mark_node)\n+    r = size_one_node;\n+  return r;\n }\n \n /* Given the SIZE (i.e., number of elements) in an array, compute an\n@@ -8708,7 +8699,18 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n       SET_TYPE_STRUCTURAL_EQUALITY (itype);\n       return itype;\n     }\n-  \n+\n+  if (TREE_CODE (size) != INTEGER_CST)\n+    {\n+      tree folded = cp_fully_fold (size);\n+      if (TREE_CODE (folded) == INTEGER_CST)\n+\tpedwarn (location_of (size), OPT_Wpedantic,\n+\t\t \"size of array is not an integral constant-expression\");\n+      /* Use the folded result for VLAs, too; it will have resolved\n+\t SIZEOF_EXPR.  */\n+      size = folded;\n+    }\n+\n   /* Normally, the array-bound will be a constant.  */\n   if (TREE_CODE (size) == INTEGER_CST)\n     {\n@@ -8795,26 +8797,14 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n \t\t\t\t  cp_convert (ssizetype, integer_one_node,\n \t\t\t\t\t      complain),\n \t\t\t\t  complain);\n-      itype = fold (itype);\n+      itype = maybe_constant_value (itype);\n       processing_template_decl = saved_processing_template_decl;\n \n       if (!TREE_CONSTANT (itype))\n \t{\n \t  /* A variable sized array.  */\n \t  itype = variable_size (itype);\n \n-\t  if (TREE_CODE (itype) != SAVE_EXPR)\n-\t    {\n-\t      /* Look for SIZEOF_EXPRs in itype and fold them, otherwise\n-\t\t they might survive till gimplification.  */\n-\t      tree newitype = itype;\n-\t      bool found = false;\n-\t      cp_walk_tree_without_duplicates (&newitype,\n-\t\t\t\t\t       fold_sizeof_expr_r, &found);\n-\t      if (found)\n-\t\titype = variable_size (fold (newitype));\n-\t    }\n-\n \t  stabilize_vla_size (itype);\n \n \t  if (flag_sanitize & SANITIZE_VLA\n@@ -13514,7 +13504,7 @@ incremented enumerator value is too large for %<long%>\");\n \t\t   \"type %<%T%>\", value, ENUM_UNDERLYING_TYPE (enumtype));\n \n           /* Convert the value to the appropriate type.  */\n-          value = convert (ENUM_UNDERLYING_TYPE (enumtype), value);\n+          value = fold_convert (ENUM_UNDERLYING_TYPE (enumtype), value);\n         }\n     }\n "}, {"sha": "47c9ec96d24fa497fb7e30c1ade92955cb05c0f5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -3112,15 +3112,15 @@ get_guard_cond (tree guard, bool thread_safe)\n     {\n       guard_value = integer_one_node;\n       if (!same_type_p (TREE_TYPE (guard_value), TREE_TYPE (guard)))\n-\tguard_value = convert (TREE_TYPE (guard), guard_value);\n+\tguard_value = fold_convert (TREE_TYPE (guard), guard_value);\n       guard = cp_build_binary_op (input_location,\n \t\t\t\t  BIT_AND_EXPR, guard, guard_value,\n \t\t\t\t  tf_warning_or_error);\n     }\n \n   guard_value = integer_zero_node;\n   if (!same_type_p (TREE_TYPE (guard_value), TREE_TYPE (guard)))\n-    guard_value = convert (TREE_TYPE (guard), guard_value);\n+    guard_value = fold_convert (TREE_TYPE (guard), guard_value);\n   return cp_build_binary_op (input_location,\n \t\t\t     EQ_EXPR, guard, guard_value,\n \t\t\t     tf_warning_or_error);\n@@ -3138,7 +3138,7 @@ set_guard (tree guard)\n   guard = get_guard_bits (guard);\n   guard_init = integer_one_node;\n   if (!same_type_p (TREE_TYPE (guard_init), TREE_TYPE (guard)))\n-    guard_init = convert (TREE_TYPE (guard), guard_init);\n+    guard_init = fold_convert (TREE_TYPE (guard), guard_init);\n   return cp_build_modify_expr (guard, NOP_EXPR, guard_init, \n \t\t\t       tf_warning_or_error);\n }"}, {"sha": "fccd2896a87db3196db92352158cf15d867d39fb", "filename": "gcc/cp/init.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -175,9 +175,9 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n        initialized are initialized to zero.  */\n     ;\n   else if (TYPE_PTR_OR_PTRMEM_P (type))\n-    init = convert (type, nullptr_node);\n+    init = fold (convert (type, nullptr_node));\n   else if (SCALAR_TYPE_P (type))\n-    init = convert (type, integer_zero_node);\n+    init = fold (convert (type, integer_zero_node));\n   else if (RECORD_OR_UNION_CODE_P (TREE_CODE (type)))\n     {\n       tree field;\n@@ -2558,6 +2558,11 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n       outer_nelts_from_type = true;\n     }\n \n+  /* Lots of logic below. depends on whether we have a constant number of\n+     elements, so go ahead and fold it now.  */\n+  if (outer_nelts)\n+    outer_nelts = maybe_constant_value (outer_nelts);\n+\n   /* If our base type is an array, then make sure we know how many elements\n      it has.  */\n   for (elt_type = type;\n@@ -2608,7 +2613,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   /* Warn if we performed the (T[N]) to T[N] transformation and N is\n      variable.  */\n   if (outer_nelts_from_type\n-      && !TREE_CONSTANT (maybe_constant_value (outer_nelts)))\n+      && !TREE_CONSTANT (outer_nelts))\n     {\n       if (complain & tf_warning_or_error)\n \t{\n@@ -2708,7 +2713,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n       max_outer_nelts = wi::udiv_trunc (max_size, inner_size);\n       max_outer_nelts_tree = wide_int_to_tree (sizetype, max_outer_nelts);\n \n-      size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n+      size = size_binop (MULT_EXPR, size, fold_convert (sizetype, nelts));\n \n       if (TREE_CONSTANT (outer_nelts))\n \t{\n@@ -2897,7 +2902,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t{\n \t  placement_expr = get_target_expr (placement_first);\n \t  CALL_EXPR_ARG (alloc_call, 1)\n-\t    = convert (TREE_TYPE (placement), placement_expr);\n+\t    = fold_convert (TREE_TYPE (placement), placement_expr);\n \t}\n \n       if (!member_new_p\n@@ -3506,7 +3511,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   /* The below is short by the cookie size.  */\n   virtual_size = size_binop (MULT_EXPR, size_exp,\n-\t\t\t     convert (sizetype, maxindex));\n+\t\t\t     fold_convert (sizetype, maxindex));\n \n   tbase = create_temporary_var (ptype);\n   tbase_init\n@@ -3549,7 +3554,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n       /* The below is short by the cookie size.  */\n       virtual_size = size_binop (MULT_EXPR, size_exp,\n-\t\t\t\t convert (sizetype, maxindex));\n+\t\t\t\t fold_convert (sizetype, maxindex));\n \n       if (! TYPE_VEC_NEW_USES_COOKIE (type))\n \t/* no header */\n@@ -3595,8 +3600,8 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   body = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t      fold_build2_loc (input_location,\n \t\t\t\t   NE_EXPR, boolean_type_node, base,\n-\t\t\t\t   convert (TREE_TYPE (base),\n-\t\t\t\t\t    nullptr_node)),\n+\t\t\t\t   fold_convert (TREE_TYPE (base),\n+\t\t\t\t\t\t nullptr_node)),\n \t\t      body, integer_zero_node);\n   body = build1 (NOP_EXPR, void_type_node, body);\n \n@@ -3718,6 +3723,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   if (maxindex == NULL_TREE || maxindex == error_mark_node)\n     return error_mark_node;\n \n+  maxindex = maybe_constant_value (maxindex);\n   if (explicit_value_init_p)\n     gcc_assert (!init);\n \n@@ -3759,6 +3765,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n     }\n \n   maxindex = cp_convert (ptrdiff_type_node, maxindex, complain);\n+  maxindex = fold_simple (maxindex);\n+\n   if (TREE_CODE (atype) == ARRAY_TYPE)\n     {\n       ptype = build_pointer_type (type);"}, {"sha": "4ca79830712e96ee4050a62fb69dfe3568533ad8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -6778,7 +6778,7 @@ cp_parser_array_notation (location_t loc, cp_parser *parser, tree *init_index,\n \t 2. ARRAY [ EXP : EXP ]\n \t 3. ARRAY [ EXP : EXP : EXP ]  */\n \n-      *init_index = cp_parser_expression (parser);\t\n+      *init_index = cp_parser_expression (parser);\n       if (cp_lexer_peek_token (parser->lexer)->type != CPP_COLON)\n \t{  \n \t  /* This indicates that we have a normal array expression.  */\n@@ -8522,9 +8522,11 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n       /* For \"false && x\" or \"true || x\", x will never be executed;\n \t disable warnings while evaluating it.  */\n       if (current.tree_type == TRUTH_ANDIF_EXPR)\n-\tc_inhibit_evaluation_warnings += current.lhs == truthvalue_false_node;\n+\tc_inhibit_evaluation_warnings +=\n+\t  cp_fully_fold (current.lhs) == truthvalue_false_node;\n       else if (current.tree_type == TRUTH_ORIF_EXPR)\n-\tc_inhibit_evaluation_warnings += current.lhs == truthvalue_true_node;\n+\tc_inhibit_evaluation_warnings +=\n+\t  cp_fully_fold (current.lhs) == truthvalue_true_node;\n \n       /* Extract another operand.  It may be the RHS of this expression\n \t or the LHS of a new, higher priority expression.  */\n@@ -8571,9 +8573,11 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \n       /* Undo the disabling of warnings done above.  */\n       if (current.tree_type == TRUTH_ANDIF_EXPR)\n-\tc_inhibit_evaluation_warnings -= current.lhs == truthvalue_false_node;\n+\tc_inhibit_evaluation_warnings -=\n+\t  cp_fully_fold (current.lhs) == truthvalue_false_node;\n       else if (current.tree_type == TRUTH_ORIF_EXPR)\n-\tc_inhibit_evaluation_warnings -= current.lhs == truthvalue_true_node;\n+\tc_inhibit_evaluation_warnings -=\n+\t  cp_fully_fold (current.lhs) == truthvalue_true_node;\n \n       if (warn_logical_not_paren\n \t  && TREE_CODE_CLASS (current.tree_type) == tcc_comparison\n@@ -8659,7 +8663,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n static tree\n cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n {\n-  tree expr;\n+  tree expr, folded_logical_or_expr = cp_fully_fold (logical_or_expr);\n   tree assignment_expr;\n   struct cp_token *token;\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n@@ -8674,27 +8678,30 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n                \"ISO C++ does not allow ?: with omitted middle operand\");\n       /* Implicit true clause.  */\n       expr = NULL_TREE;\n-      c_inhibit_evaluation_warnings += logical_or_expr == truthvalue_true_node;\n+      c_inhibit_evaluation_warnings +=\n+\tfolded_logical_or_expr == truthvalue_true_node;\n       warn_for_omitted_condop (token->location, logical_or_expr);\n     }\n   else\n     {\n       bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n       parser->colon_corrects_to_scope_p = false;\n       /* Parse the expression.  */\n-      c_inhibit_evaluation_warnings += logical_or_expr == truthvalue_false_node;\n+      c_inhibit_evaluation_warnings +=\n+\tfolded_logical_or_expr == truthvalue_false_node;\n       expr = cp_parser_expression (parser);\n       c_inhibit_evaluation_warnings +=\n-\t((logical_or_expr == truthvalue_true_node)\n-\t - (logical_or_expr == truthvalue_false_node));\n+\t((folded_logical_or_expr == truthvalue_true_node)\n+\t - (folded_logical_or_expr == truthvalue_false_node));\n       parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n     }\n \n   /* The next token should be a `:'.  */\n   cp_parser_require (parser, CPP_COLON, RT_COLON);\n   /* Parse the assignment-expression.  */\n   assignment_expr = cp_parser_assignment_expression (parser);\n-  c_inhibit_evaluation_warnings -= logical_or_expr == truthvalue_true_node;\n+  c_inhibit_evaluation_warnings -=\n+    folded_logical_or_expr == truthvalue_true_node;\n \n   /* Build the conditional-expression.  */\n   return build_x_conditional_expr (loc, logical_or_expr,"}, {"sha": "29046572b2cf8ac4f4f6367c0c5237467bb8012c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -6211,7 +6211,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n   /* 14.3.2/5: The null pointer{,-to-member} conversion is applied\n      to a non-type argument of \"nullptr\".  */\n   if (expr == nullptr_node && TYPE_PTR_OR_PTRMEM_P (type))\n-    expr = convert (type, expr);\n+    expr = fold_simple (convert (type, expr));\n \n   /* In C++11, integral or enumeration non-type template arguments can be\n      arbitrary constant expressions.  Pointer and pointer to"}, {"sha": "67f8590f63865a44db4139f1d4371b52c4d2ae3b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -2562,9 +2562,26 @@ finish_unary_op_expr (location_t loc, enum tree_code code, tree expr,\n \t\t      tsubst_flags_t complain)\n {\n   tree result = build_x_unary_op (loc, code, expr, complain);\n-  if ((complain & tf_warning)\n-      && TREE_OVERFLOW_P (result) && !TREE_OVERFLOW_P (expr))\n-    overflow_warning (input_location, result);\n+  tree result_ovl, expr_ovl;\n+\n+  if (!(complain & tf_warning))\n+    return result;\n+\n+  result_ovl = result;\n+  expr_ovl = expr;\n+\n+  if (!processing_template_decl)\n+    expr_ovl = cp_fully_fold (expr_ovl);\n+\n+  if (!CONSTANT_CLASS_P (expr_ovl)\n+      || TREE_OVERFLOW_P (expr_ovl))\n+    return result;\n+\n+  if (!processing_template_decl)\n+    result_ovl = cp_fully_fold (result_ovl);\n+\n+  if (CONSTANT_CLASS_P (result_ovl) && TREE_OVERFLOW_P (result_ovl))\n+    overflow_warning (input_location, result_ovl);\n \n   return result;\n }\n@@ -4476,6 +4493,11 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n     low_bound = mark_rvalue_use (low_bound);\n   if (length)\n     length = mark_rvalue_use (length);\n+  /* We need to reduce to real constant-values for checks below.  */\n+  if (length)\n+    length = fold_simple (length);\n+  if (low_bound)\n+    low_bound = fold_simple (low_bound);\n   if (low_bound\n       && TREE_CODE (low_bound) == INTEGER_CST\n       && TYPE_PRECISION (TREE_TYPE (low_bound))\n@@ -7440,6 +7462,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n   if (init && EXPR_HAS_LOCATION (init))\n     elocus = EXPR_LOCATION (init);\n \n+  cond = cp_fully_fold (cond);\n   switch (TREE_CODE (cond))\n     {\n     case GT_EXPR:\n@@ -7475,6 +7498,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n   diff = build_x_binary_op (elocus, MINUS_EXPR, TREE_OPERAND (cond, 1),\n \t\t\t    ERROR_MARK, iter, ERROR_MARK, NULL,\n \t\t\t    tf_warning_or_error);\n+  diff = cp_fully_fold (diff);\n   if (error_operand_p (diff))\n     return true;\n   if (TREE_CODE (TREE_TYPE (diff)) != INTEGER_TYPE)\n@@ -7536,7 +7560,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t\t  if (TREE_CODE (rhs) == MINUS_EXPR)\n \t\t    {\n \t\t      incr = build1 (NEGATE_EXPR, TREE_TYPE (diff), incr);\n-\t\t      incr = fold_if_not_in_template (incr);\n+\t\t      incr = fold_simple (incr);\n \t\t    }\n \t\t  if (TREE_CODE (incr) != INTEGER_CST\n \t\t      && (TREE_CODE (incr) != NOP_EXPR"}, {"sha": "d2db31a628a0c796d8c2a317560a5d1d0f3448e5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -303,9 +303,19 @@ xvalue_p (const_tree ref)\n bool\n builtin_valid_in_constant_expr_p (const_tree decl)\n {\n-  /* At present BUILT_IN_CONSTANT_P is the only builtin we're allowing\n-     in constant-expressions.  We may want to add other builtins later. */\n-  return DECL_IS_BUILTIN_CONSTANT_P (decl);\n+  if (!(TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl)))\n+    /* Not a built-in.  */\n+    return false;\n+  switch (DECL_FUNCTION_CODE (decl))\n+    {\n+    case BUILT_IN_CONSTANT_P:\n+    case BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE:\n+      /* These have constant results even if their operands are\n+\t non-constant.  */\n+      return true;\n+    default:\n+      return false;\n+    }\n }\n \n /* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */\n@@ -681,8 +691,8 @@ convert_bitfield_to_declared_type (tree expr)\n \n   bitfield_type = is_bitfield_expr_with_lowered_type (expr);\n   if (bitfield_type)\n-    expr = convert_to_integer (TYPE_MAIN_VARIANT (bitfield_type),\n-\t\t\t       expr);\n+    expr = convert_to_integer_nofold (TYPE_MAIN_VARIANT (bitfield_type),\n+\t\t\t\t      expr);\n   return expr;\n }\n \n@@ -3479,10 +3489,13 @@ handle_init_priority_attribute (tree* node,\n \n   STRIP_NOPS (initp_expr);\n   initp_expr = default_conversion (initp_expr);\n+  if (initp_expr)\n+    initp_expr = maybe_constant_value (initp_expr);\n \n   if (!initp_expr || TREE_CODE (initp_expr) != INTEGER_CST)\n     {\n       error (\"requested init_priority is not an integer constant\");\n+      cxx_constant_value (initp_expr);\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n@@ -4257,26 +4270,6 @@ stabilize_init (tree init, tree *initp)\n   return !TREE_SIDE_EFFECTS (init);\n }\n \n-/* Like \"fold\", but should be used whenever we might be processing the\n-   body of a template.  */\n-\n-tree\n-fold_if_not_in_template (tree expr)\n-{\n-  /* In the body of a template, there is never any need to call\n-     \"fold\".  We will call fold later when actually instantiating the\n-     template.  Integral constant expressions in templates will be\n-     evaluated via instantiate_non_dependent_expr, as necessary.  */\n-  if (processing_template_decl)\n-    return expr;\n-\n-  /* Fold C++ front-end specific tree codes.  */\n-  if (TREE_CODE (expr) == UNARY_PLUS_EXPR)\n-    return fold_convert (TREE_TYPE (expr), TREE_OPERAND (expr, 0));\n-\n-  return fold (expr);\n-}\n-\n /* Returns true if a cast to TYPE may appear in an integral constant\n    expression.  */\n "}, {"sha": "6541e97cca5efe67483decc94af4d6a8df5ec25a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 59, "deletions": 68, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1945,8 +1945,6 @@ decay_conversion (tree exp,\n \n   code = TREE_CODE (type);\n \n-  /* FIXME remove for delayed folding.  */\n-  exp = scalar_constant_value (exp);\n   if (error_operand_p (exp))\n     return error_mark_node;\n \n@@ -2439,7 +2437,6 @@ build_class_member_access_expr (tree object, tree member,\n \n       result = build3_loc (input_location, COMPONENT_REF, member_type,\n \t\t\t   object, member, NULL_TREE);\n-      result = fold_if_not_in_template (result);\n \n       /* Mark the expression const or volatile, as appropriate.  Even\n \t though we've dealt with the type above, we still have to mark the\n@@ -2852,9 +2849,9 @@ build_simple_component_ref (tree object, tree member)\n {\n   tree type = cp_build_qualified_type (TREE_TYPE (member),\n \t\t\t\t       cp_type_quals (TREE_TYPE (object)));\n-  return fold_build3_loc (input_location,\n-\t\t\t  COMPONENT_REF, type,\n-\t\t\t  object, member, NULL_TREE);\n+  return build3_loc (input_location,\n+\t\t     COMPONENT_REF, type,\n+\t\t     object, member, NULL_TREE);\n }\n \n /* Return an expression for the MEMBER_NAME field in the internal\n@@ -3173,8 +3170,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \t|= (CP_TYPE_VOLATILE_P (type) | TREE_SIDE_EFFECTS (array));\n       TREE_THIS_VOLATILE (rval)\n \t|= (CP_TYPE_VOLATILE_P (type) | TREE_THIS_VOLATILE (array));\n-      ret = require_complete_type_sfinae (fold_if_not_in_template (rval),\n-\t\t\t\t\t  complain);\n+      ret = require_complete_type_sfinae (rval, complain);\n       protected_set_expr_location (ret, loc);\n       if (non_lvalue)\n \tret = non_lvalue_loc (loc, ret);\n@@ -3921,7 +3917,6 @@ build_vec_cmp (tree_code code, tree type,\n   tree minus_one_vec = build_minus_one_cst (type);\n   tree cmp_type = build_same_sized_truth_vector_type(type);\n   tree cmp = build2 (code, cmp_type, arg0, arg1);\n-  cmp = fold_if_not_in_template (cmp);\n   return build3 (VEC_COND_EXPR, type, cmp, minus_one_vec, zero_vec);\n }\n \n@@ -3976,7 +3971,7 @@ cp_build_binary_op (location_t location,\n      convert it to this type.  */\n   tree final_type = 0;\n \n-  tree result;\n+  tree result, result_ovl;\n   tree orig_type = NULL;\n \n   /* Nonzero if this is an operation like MIN or MAX which can\n@@ -4599,7 +4594,7 @@ cp_build_binary_op (location_t location,\n \t      op0 = cp_build_binary_op (location,\n \t\t\t\t\tTRUTH_ANDIF_EXPR, e1, e2,\n \t\t\t\t\tcomplain);\n-\t      op1 = cp_convert (TREE_TYPE (op0), integer_one_node, complain); \n+\t      op1 = cp_convert (TREE_TYPE (op0), integer_one_node, complain);\n \t    }\n      \t  else \n \t    {\n@@ -4640,10 +4635,12 @@ cp_build_binary_op (location_t location,\n \t    op1 = save_expr (op1);\n \n \t  pfn0 = pfn_from_ptrmemfunc (op0);\n+\t  pfn0 = cp_fully_fold (pfn0);\n \t  /* Avoid -Waddress warnings (c++/64877).  */\n \t  if (TREE_CODE (pfn0) == ADDR_EXPR)\n \t    TREE_NO_WARNING (pfn0) = 1;\n \t  pfn1 = pfn_from_ptrmemfunc (op1);\n+\t  pfn1 = cp_fully_fold (pfn1);\n \t  delta0 = delta_from_ptrmemfunc (op0);\n \t  delta1 = delta_from_ptrmemfunc (op1);\n \t  if (TARGET_PTRMEMFUNC_VBIT_LOCATION\n@@ -4997,10 +4994,7 @@ cp_build_binary_op (location_t location,\n \t\t  gcc_unreachable();\n \t\t}\n \t    }\n-\t  real = fold_if_not_in_template (real);\n-\t  imag = fold_if_not_in_template (imag);\n \t  result = build2 (COMPLEX_EXPR, result_type, real, imag);\n-\t  result = fold_if_not_in_template (result);\n \t  return result;\n \t}\n \n@@ -5028,20 +5022,12 @@ cp_build_binary_op (location_t location,\n \n       if (short_compare)\n \t{\n-\t  /* Don't write &op0, etc., because that would prevent op0\n-\t     from being kept in a register.\n-\t     Instead, make copies of the our local variables and\n-\t     pass the copies by reference, then copy them back afterward.  */\n-\t  tree xop0 = op0, xop1 = op1, xresult_type = result_type;\n+\t  /* We call shorten_compare only for diagnostic-reason.  */\n+\t  tree xop0 = fold_simple (op0), xop1 = fold_simple (op1),\n+\t       xresult_type = result_type;\n \t  enum tree_code xresultcode = resultcode;\n-\t  tree val\n-\t    = shorten_compare (location, &xop0, &xop1, &xresult_type,\n+\t  shorten_compare (location, &xop0, &xop1, &xresult_type,\n \t\t\t       &xresultcode);\n-\t  if (val != 0)\n-\t    return cp_convert (boolean_type_node, val, complain);\n-\t  op0 = xop0, op1 = xop1;\n-\t  converted = 1;\n-\t  resultcode = xresultcode;\n \t}\n \n       if ((short_compare || code == MIN_EXPR || code == MAX_EXPR)\n@@ -5060,9 +5046,9 @@ cp_build_binary_op (location_t location,\n \t  tree oop1 = maybe_constant_value (orig_op1);\n \n \t  if (TREE_CODE (oop0) != INTEGER_CST)\n-\t    oop0 = orig_op0;\n+\t    oop0 = cp_fully_fold (orig_op0);\n \t  if (TREE_CODE (oop1) != INTEGER_CST)\n-\t    oop1 = orig_op1;\n+\t    oop1 = cp_fully_fold (orig_op1);\n \t  warn_for_sign_compare (location, oop0, oop1, op0, op1, \n \t\t\t\t result_type, resultcode);\n \t}\n@@ -5117,18 +5103,30 @@ cp_build_binary_op (location_t location,\n     }\n \n   result = build2 (resultcode, build_type, op0, op1);\n-  result = fold_if_not_in_template (result);\n   if (final_type != 0)\n     result = cp_convert (final_type, result, complain);\n \n-  if (TREE_OVERFLOW_P (result) \n-      && !TREE_OVERFLOW_P (op0) \n-      && !TREE_OVERFLOW_P (op1))\n-    overflow_warning (location, result);\n-\n   if (instrument_expr != NULL)\n-    result = fold_build2 (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t\t  instrument_expr, result);\n+    result = build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t     instrument_expr, result);\n+\n+  if (!processing_template_decl)\n+    {\n+      op0 = cp_fully_fold (op0);\n+      /* Only consider the second argument if the first isn't overflowed.  */\n+      if (!CONSTANT_CLASS_P (op0) || TREE_OVERFLOW_P (op0))\n+\treturn result;\n+      op1 = cp_fully_fold (op1);\n+      if (!CONSTANT_CLASS_P (op1) || TREE_OVERFLOW_P (op1))\n+\treturn result;\n+    }\n+  else if (!CONSTANT_CLASS_P (op0) || !CONSTANT_CLASS_P (op1)\n+\t   || TREE_OVERFLOW_P (op0) || TREE_OVERFLOW_P (op1))\n+    return result;\n+\n+  result_ovl = fold_build2 (resultcode, build_type, op0, op1);\n+  if (TREE_OVERFLOW_P (result_ovl))\n+    overflow_warning (location, result_ovl);\n \n   return result;\n }\n@@ -5178,8 +5176,7 @@ cp_pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop,\n   complete_type (TREE_TYPE (res_type));\n \n   return pointer_int_sum (input_location, resultcode, ptrop,\n-\t\t\t  fold_if_not_in_template (intop),\n-\t\t\t  complain & tf_warning_or_error);\n+\t\t\t  intop, complain & tf_warning_or_error);\n }\n \n /* Return a tree for the difference of pointers OP0 and OP1.\n@@ -5255,7 +5252,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n \n   result = build2 (EXACT_DIV_EXPR, restype, op0,\n \t\t   cp_convert (restype, op1, complain));\n-  return fold_if_not_in_template (result);\n+  return result;\n }\n \f\n /* Construct and perhaps optimize a tree representation\n@@ -5771,6 +5768,10 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t    /* Make sure the result is not an lvalue: a unary plus or minus\n \t       expression is always a rvalue.  */\n \t    arg = rvalue (arg);\n+\n+\t    if (code == NEGATE_EXPR && CONSTANT_CLASS_P (arg))\n+\t      /* Immediately fold negation of a constant.  */\n+\t      return fold_build1 (code, TREE_TYPE (arg), arg);\n \t  }\n       }\n       break;\n@@ -5835,10 +5836,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n       arg = build_real_imag_expr (input_location, code, arg);\n-      if (arg == error_mark_node)\n-\treturn arg;\n-      else\n-\treturn fold_if_not_in_template (arg);\n+      return arg;\n \n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n@@ -6005,7 +6003,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n     {\n       if (argtype == 0)\n \targtype = TREE_TYPE (arg);\n-      return fold_if_not_in_template (build1 (code, argtype, arg));\n+      return build1 (code, argtype, arg);\n     }\n \n   if (complain & tf_error)\n@@ -6999,7 +6997,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     return rvalue (expr);\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n-    return fold_if_not_in_template (build_nop (type, expr));\n+    return build_nop (type, expr);\n   else if ((TYPE_PTRDATAMEM_P (type) && TYPE_PTRDATAMEM_P (intype))\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n@@ -7027,7 +7025,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (warn_strict_aliasing <= 2)\n \tstrict_aliasing_warning (intype, type, sexpr);\n \n-      return fold_if_not_in_template (build_nop (type, expr));\n+      return build_nop (type, expr);\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n \t   || (TYPE_PTRFN_P (intype) && TYPE_PTROBV_P (type)))\n@@ -7038,13 +7036,13 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \twarning (OPT_Wconditionally_supported,\n \t\t \"casting between pointer-to-function and pointer-to-object \"\n \t\t \"is conditionally-supported\");\n-      return fold_if_not_in_template (build_nop (type, expr));\n+      return build_nop (type, expr);\n     }\n   else if (VECTOR_TYPE_P (type))\n-    return fold_if_not_in_template (convert_to_vector (type, expr));\n+    return convert_to_vector (type, expr);\n   else if (VECTOR_TYPE_P (intype)\n \t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n-    return fold_if_not_in_template (convert_to_integer (type, expr));\n+    return convert_to_integer_nofold (type, expr);\n   else\n     {\n       if (valid_p)\n@@ -7896,8 +7894,7 @@ get_delta_difference (tree from, tree to,\n       }\n   }\n \n-  return fold_if_not_in_template (convert_to_integer (ptrdiff_type_node,\n-\t\t\t\t\t\t      result));\n+  return convert_to_integer (ptrdiff_type_node, result);\n }\n \n /* Return a constructor for the pointer-to-member-function TYPE using\n@@ -8078,41 +8075,35 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n \t fn; the call will do the opposite adjustment.  */\n       tree orig_class = DECL_CONTEXT (fn);\n       tree binfo = binfo_or_else (orig_class, fn_class);\n-      *delta = build2 (PLUS_EXPR, TREE_TYPE (*delta),\n-\t\t       *delta, BINFO_OFFSET (binfo));\n-      *delta = fold_if_not_in_template (*delta);\n+      *delta = fold_build2 (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t\t    *delta, BINFO_OFFSET (binfo));\n \n       /* We set PFN to the vtable offset at which the function can be\n \t found, plus one (unless ptrmemfunc_vbit_in_delta, in which\n \t case delta is shifted left, and then incremented).  */\n       *pfn = DECL_VINDEX (fn);\n-      *pfn = build2 (MULT_EXPR, integer_type_node, *pfn,\n-\t\t     TYPE_SIZE_UNIT (vtable_entry_type));\n-      *pfn = fold_if_not_in_template (*pfn);\n+      *pfn = fold_build2 (MULT_EXPR, integer_type_node, *pfn,\n+\t\t\t  TYPE_SIZE_UNIT (vtable_entry_type));\n \n       switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n \tcase ptrmemfunc_vbit_in_pfn:\n-\t  *pfn = build2 (PLUS_EXPR, integer_type_node, *pfn,\n-\t\t\t integer_one_node);\n-\t  *pfn = fold_if_not_in_template (*pfn);\n+\t  *pfn = fold_build2 (PLUS_EXPR, integer_type_node, *pfn,\n+\t\t\t      integer_one_node);\n \t  break;\n \n \tcase ptrmemfunc_vbit_in_delta:\n-\t  *delta = build2 (LSHIFT_EXPR, TREE_TYPE (*delta),\n-\t\t\t   *delta, integer_one_node);\n-\t  *delta = fold_if_not_in_template (*delta);\n-\t  *delta = build2 (PLUS_EXPR, TREE_TYPE (*delta),\n-\t\t\t   *delta, integer_one_node);\n-\t  *delta = fold_if_not_in_template (*delta);\n+\t  *delta = fold_build2 (LSHIFT_EXPR, TREE_TYPE (*delta),\n+\t\t\t\t*delta, integer_one_node);\n+\t  *delta = fold_build2 (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t\t\t*delta, integer_one_node);\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n-      *pfn = build_nop (TYPE_PTRMEMFUNC_FN_TYPE (type), *pfn);\n-      *pfn = fold_if_not_in_template (*pfn);\n+      *pfn = fold_convert (TYPE_PTRMEMFUNC_FN_TYPE (type), *pfn);\n     }\n }\n "}, {"sha": "839091c565ec473e0864fb0597c5c089174b5298", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -738,6 +738,7 @@ split_nonconstant_init (tree dest, tree init)\n     init = TARGET_EXPR_INITIAL (init);\n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n+      init = cp_fully_fold (init);\n       code = push_stmt_list ();\n       if (split_nonconstant_init_1 (dest, init))\n \tinit = NULL_TREE;\n@@ -828,6 +829,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = const_init;\n       TREE_CONSTANT (decl) = const_init && decl_maybe_constant_var_p (decl);\n     }\n+  value = cp_fully_fold (value);\n \n   if (cxx_dialect >= cxx14 && CLASS_TYPE_P (strip_array_types (type)))\n     /* Handle aggregate NSDMI in non-constant initializers, too.  */\n@@ -926,27 +928,43 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n \t}\n     }\n \n+  bool almost_ok = ok;\n+  if (!ok && !CONSTANT_CLASS_P (init) && (complain & tf_warning_or_error))\n+    {\n+      tree folded = cp_fully_fold (init);\n+      if (TREE_CONSTANT (folded) && check_narrowing (type, folded, tf_none))\n+\talmost_ok = true;\n+    }\n+\n   if (!ok)\n     {\n+      location_t loc = EXPR_LOC_OR_LOC (init, input_location);\n       if (cxx_dialect == cxx98)\n-\twarning_at (EXPR_LOC_OR_LOC (init, input_location), OPT_Wnarrowing,\n-\t\t    \"narrowing conversion of %qE from %qT to %qT inside { } \"\n-\t\t    \"is ill-formed in C++11\", init, ftype, type);\n-      else if (!TREE_CONSTANT (init))\n+\t{\n+\t  if (complain & tf_warning)\n+\t    warning_at (loc, OPT_Wnarrowing, \"narrowing conversion of %qE \"\n+\t\t\t\"from %qT to %qT inside { } is ill-formed in C++11\",\n+\t\t\tinit, ftype, type);\n+\t  ok = true;\n+\t}\n+      else if (!CONSTANT_CLASS_P (init))\n \t{\n \t  if (complain & tf_warning_or_error)\n \t    {\n-\t      pedwarn (EXPR_LOC_OR_LOC (init, input_location), OPT_Wnarrowing,\n-\t\t       \"narrowing conversion of %qE from %qT to %qT inside { }\",\n-\t\t       init, ftype, type);\n+\t      if (!almost_ok || pedantic)\n+\t\tpedwarn (loc, OPT_Wnarrowing, \"narrowing conversion of %qE \"\n+\t\t\t \"from %qT to %qT inside { }\", init, ftype, type);\n+\t      if (pedantic && almost_ok)\n+\t\tinform (loc, \" the expression has a constant value but is not \"\n+\t\t\t\"a C++ constant-expression\");\n \t      ok = true;\n \t    }\n \t}\n       else if (complain & tf_error)\n \t{\n \t  int savederrorcount = errorcount;\n \t  global_dc->pedantic_errors = 1;\n-\t  pedwarn (EXPR_LOC_OR_LOC (init, input_location), OPT_Wnarrowing,\n+\t  pedwarn (loc, OPT_Wnarrowing,\n \t\t   \"narrowing conversion of %qE from %qT to %qT \"\n \t\t   \"inside { }\", init, ftype, type);\n \t  if (errorcount == savederrorcount)\n@@ -955,7 +973,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n \t}\n     }\n \n-  return cxx_dialect == cxx98 || ok; \n+  return ok;\n }\n \n /* Process the initializer INIT for a variable of type TYPE, emitting"}, {"sha": "7bec6306872c6908948d9523edca63620ba854f3", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1,3 +1,7 @@\n+2015-11-13  Jason Merrill  <jason@redhat.com>\n+\n+\t* config-lang.in (gtfiles): Add cp-gimplify.c.\n+\n 2015-11-11  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* objcp-decl.c: Remove unused header files."}, {"sha": "5f3f4e09c8a696856cf99c0485f5ba58154463e5", "filename": "gcc/objcp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fobjcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Fobjcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fconfig-lang.in?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -45,6 +45,6 @@ subdir_requires=\"objc cp\"\n \n # This list is separated in two parts: the first one is identical to\n # the C++ one, the second one contains our ObjC++ additions.\n-gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/except.c \\$(srcdir)/cp/vtable-class-hierarchy.c \\$(srcdir)/cp/constexpr.c \\\n+gtfiles=\"\\$(srcdir)/cp/rtti.c \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/name-lookup.h \\$(srcdir)/cp/name-lookup.c \\$(srcdir)/cp/cp-tree.h \\$(srcdir)/cp/decl.h \\$(srcdir)/cp/call.c \\$(srcdir)/cp/decl.c \\$(srcdir)/cp/decl2.c \\$(srcdir)/cp/pt.c \\$(srcdir)/cp/repo.c \\$(srcdir)/cp/semantics.c \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/parser.h \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/method.c \\$(srcdir)/cp/typeck2.c \\$(srcdir)/c-family/c-common.c \\$(srcdir)/c-family/c-common.h \\$(srcdir)/c-family/c-objc.h \\$(srcdir)/c-family/c-lex.c \\$(srcdir)/c-family/c-pragma.h \\$(srcdir)/c-family/c-pragma.c \\$(srcdir)/cp/class.c \\$(srcdir)/cp/cp-objcp-common.c \\$(srcdir)/cp/except.c \\$(srcdir)/cp/vtable-class-hierarchy.c \\$(srcdir)/cp/constexpr.c \\$(srcdir)/cp/cp-gimplify.c \\\n \\$(srcdir)/objc/objc-map.h \\$(srcdir)/objc/objc-act.h \\$(srcdir)/objc/objc-act.c \\$(srcdir)/objc/objc-runtime-shared-support.c \\$(srcdir)/objc/objc-gnu-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-01.c \\$(srcdir)/objc/objc-next-runtime-abi-02.c \\$(srcdir)/c-family/c-cppbuiltin.c\"\n "}, {"sha": "8f1403456086bc7397ed9a2d4408097ec2126983", "filename": "gcc/testsuite/c-c++-common/Wshift-negative-value-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-1.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -47,3 +47,5 @@ right (int x)\n   r += -1U >> x;\n   return r;\n }\n+\n+/* { dg-error \"left operand of shift expression\" \"shift\" { target c++ } 9 } */"}, {"sha": "55523a531f570f939da3436e62e410b065430451", "filename": "gcc/testsuite/c-c++-common/Wshift-negative-value-2.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-2.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -47,3 +47,6 @@ right (int x)\n   r += -1U >> x;\n   return r;\n }\n+\n+/* { dg-error \"not an integer constant\" \"no constant\" { target c++ } 9 } */\n+/* { dg-error \"left operand of shift expression\" \"shift\" { target c++ } 9 } */"}, {"sha": "1295b725569bdd3fbb1a51dcafc7f1161e1aa60e", "filename": "gcc/testsuite/c-c++-common/Wshift-negative-value-3.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-3.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -47,3 +47,6 @@ right (int x)\n   r += -1U >> x;\n   return r;\n }\n+\n+/* { dg-error \"not an integer constant\" \"no constant\" { target c++ } 9 } */\n+/* { dg-error \"left operand of shift expression\" \"shift\" { target c++ } 9 } */"}, {"sha": "3088220ffa738a010f4a0a65d48bae91242b7384", "filename": "gcc/testsuite/c-c++-common/Wshift-negative-value-4.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWshift-negative-value-4.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -47,3 +47,6 @@ right (int x)\n   r += -1U >> x;\n   return r;\n }\n+\n+/* { dg-error \"not an integer constant\" \"no constant\" { target c++ } 9 } */\n+/* { dg-error \"left operand of shift expression\" \"shift\" { target c++ } 9 } */"}, {"sha": "a658ff15e49fedc355ee119931a97698e6ccbd81", "filename": "gcc/testsuite/c-c++-common/fold-bitand-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ffold-bitand-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ffold-bitand-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ffold-bitand-4.c?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile } */\n+/* { dg-do compile { target { c } } } */\n /* { dg-options \"-fdump-tree-original\" } */\n /* { dg-additional-options \"-fno-common\" { target hppa*-*-hpux* } } */\n "}, {"sha": "a5e3c1f109d0741506f5753657709042cb85d794", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-reinterpret1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -18,7 +18,7 @@ public:\n   {\n     /* I am surprised this is considered a constexpr */\n     return *((Inner *)4);\n-  } // { dg-error \"reinterpret_cast\" \"\" { xfail *-*-* } }\n+  } // { dg-error \"reinterpret_cast\" \"\" }\n };\n \n B B::instance;"}, {"sha": "deb5c1abd8b9900d4eb12839854003578c321b87", "filename": "gcc/testsuite/g++.dg/cpp0x/pr53792.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr53792.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr53792.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr53792.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/53792\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -fdump-tree-optimized\" }\n+// { dg-final { scan-tree-dump \"return 0\" \"optimized\" } }\n+\n+struct entry {\n+  char const* label;\n+  int         value;\n+};\n+\n+constexpr bool same(char const *x, char const *y) {\n+  return !*x && !*y ? true\n+    : /* default */    (*x == *y && same(x+1, y+1));\n+}\n+\n+constexpr int keyToValue(char const *label, entry const *entries) {\n+  return !entries->label ? entries->value\n+       : same(entries->label, label) ? entries->value\n+       : /*default*/                   keyToValue(label, entries+1);\n+}\n+\n+constexpr entry foo[] = {{\"Foo\", 0}, {\"Bar\", 1}, {\"FooBar\", 2}, {0, -1}};\n+\n+int\n+bar()\n+{\n+  int result = keyToValue(\"Foo\", foo);\n+  return result;\n+}"}, {"sha": "afa7edb0fb8f697a9ad152452adaf3ed03b26683", "filename": "gcc/testsuite/g++.dg/cpp0x/pr56868.cpp", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr56868.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr56868.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr56868.cpp?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile { target c++11 } }\n+\n+constexpr int f(void *) { return 0; }\n+constexpr int f(...) { return 1; }\n+constexpr int g1() { return f(0); }\n+constexpr int g2(int n) { return f(n); }\n+constexpr int g3(int n) { return f(n*0); }\n+\n+int main()\n+{\n+    static_assert(g1() == 0, \"g1 failed\");\n+    static_assert(g2(0) == 1, \"g2 failed\");\n+    static_assert(g3(0) == 1, \"g3 failed\");\n+}"}, {"sha": "e340de4179df6f0ae9d1239b90612481a4c69382", "filename": "gcc/testsuite/g++.dg/cpp0x/warn-ovl1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fwarn-ovl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fwarn-ovl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fwarn-ovl1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -Woverflow\" }\n+\n+#include <climits>\n+\n+constexpr int f() { return INT_MIN; }\n+\n+int main()\n+{\n+  return -f(); // { dg-warning \"overflow\" }\n+}\n+"}, {"sha": "6b5dff880237999f5880f9e2573fcaeb7fc85bef", "filename": "gcc/testsuite/g++.dg/cpp0x/warn-ovl2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fwarn-ovl2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fwarn-ovl2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fwarn-ovl2.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-O2 -Woverflow\" }\n+\n+#include <climits>\n+\n+constexpr int f() { return INT_MAX; }\n+\n+int main()\n+{\n+  return f() + 2; // { dg-warning \"overflow\" }\n+}\n+"}, {"sha": "39b35573483ff266830c4c3ce5d5fec1bb4647b5", "filename": "gcc/testsuite/g++.dg/delayedfold/df-warn-signedunsigned1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdelayedfold%2Fdf-warn-signedunsigned1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdelayedfold%2Fdf-warn-signedunsigned1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdelayedfold%2Fdf-warn-signedunsigned1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -Werror\" }  */\n+\n+extern int fl;\n+\n+#define MAK (fl < 0 ? 1 : (fl ? -1 : 0))\n+\n+int foo (int sz)\n+{\n+  if (MAK) return 1;\n+  return 0;\n+}\n+"}, {"sha": "fa91a4f34647d64af718f46605ec048da1deef96", "filename": "gcc/testsuite/g++.dg/delayedfold/df-warn-signedunsigned2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdelayedfold%2Fdf-warn-signedunsigned2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdelayedfold%2Fdf-warn-signedunsigned2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdelayedfold%2Fdf-warn-signedunsigned2.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall -Werror\" }  */\n+\n+extern int fl;\n+extern int arr[];\n+\n+#define MAK (fl < 0 ? 1 : (fl ? 2 : 0))\n+\n+int foo (int sz)\n+{\n+  unsigned i;\n+  int r = 0;\n+  for (i = 0; i < MAK; i++)\n+    r += arr[i];\n+  return r;\n+}\n+"}, {"sha": "0c5df6d29421cac0739e36708da6e14456c7dd24", "filename": "gcc/testsuite/g++.dg/ext/attr-aligned01.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-aligned01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-aligned01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-aligned01.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -5,8 +5,8 @@\n \n template<typename T>\n void type_alignment(const T&) {\n-  struct { char c; T t; } s;\n-  SA((char*)&s.t - (char*)&s.c == 1);\n+  struct S { char c; T t; } s;\n+  SA(__builtin_offsetof (S,t) - __builtin_offsetof (S,c) == 1);\n }\n \n template <class T> struct A { char c; T t; };\n@@ -17,7 +17,8 @@ int main() {\n \n   A<aligned> a;\t\t\t// { dg-warning \"ignoring attributes\" }\n \n-  SA((char*)&a.t - (char*)&a.c == 1);\n+  SA(  __builtin_offsetof (__typeof(a),t)\n+     - __builtin_offsetof (__typeof(a),c) == 1);\n \n   aligned z;\n   type_alignment(z);\t\t// { dg-warning \"ignoring attributes\" \"\" { xfail *-*-* } }"}, {"sha": "23f3537c74555a50ccd36b7482c4a672c39b2f1f", "filename": "gcc/testsuite/g++.dg/ext/offsetof1.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Foffsetof1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Foffsetof1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Foffsetof1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1,6 +1,7 @@\n // PR c++/27601\n // Origin: Patrik H\ufffdgglund  <patrik.hagglund@bredband.net>\n // { dg-do compile }\n+// { dg-options \"-Wno-pointer-arith\" }\n \n struct bar {\n   static int foo;\n@@ -10,7 +11,7 @@ struct bar {\n int a = __builtin_offsetof(bar, foo);  // { dg-error \"static data member\" }\n int av = __builtin_offsetof(volatile bar, foo);  // { dg-error \"static data member\" }\n int b = __builtin_offsetof(bar, baz);  // { dg-error \"member function\" }\n-int b0 = __builtin_offsetof(bar, baz[0]);  // { dg-error \"function\" }\n+int b0 = __builtin_offsetof(bar, baz[0]);  // { dg-error \"single identifier nor|member function\" }\n int bv0 = __builtin_offsetof(volatile bar, baz[0]);  // { dg-error \"function\" }\n int c = __builtin_offsetof(bar, ~bar);  // { dg-error \"member function\" }\n "}, {"sha": "e1f31bccf7cf9b3ebacbe16cac76d3d6d912d91a", "filename": "gcc/testsuite/g++.dg/init/const7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fconst7.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1,9 +1,9 @@\n // { dg-do compile }\n-// { dg-options \"-fdump-tree-gimple\" }\n+// { dg-options \"-fdump-tree-gimple -pedantic\" }\n \n struct s { int x, y; };\n short offsets[1] = {\n-  ((char*) &(((struct s*)16)->y) - (char *)16),\n+  ((char*) &(((struct s*)16)->y) - (char *)16), // { dg-message \"narrowing\" \"\" { target c++11 } }\n };\n \n // This ensures that we get a dump whether or not the bug is present."}, {"sha": "7620833c9b8d3b4df5fb7393ef8cae8a2335422d", "filename": "gcc/testsuite/g++.dg/init/self1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fself1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fself1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fself1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -10,7 +10,7 @@ void f(__SIZE_TYPE__) {\n \n int main()\n {\n-  int* const savepos = sizeof(*savepos) ? 0 : 0;\n+  int* const savepos = sizeof(*savepos) ? 0 : 0;  /* { dg-error \"invalid conversion\" \"convert\" { target c++11 }  } */\n \n   f (sizeof (*savepos));\n "}, {"sha": "eba0746ef2b43515e9b1bae02b73deff298ab765", "filename": "gcc/testsuite/g++.dg/other/error22.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror22.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -5,5 +5,5 @@ extern \"C\" double fabs (double);\n \n void foo (double x)\n {\n-  fabs (x) ();\t// { dg-error \"__builtin_abs\" }\n+  fabs (x) ();\t// { dg-error \"function\" }\n }"}, {"sha": "e5e6a4fa338932eaf1fb2c730f0b602c3676e738", "filename": "gcc/testsuite/g++.dg/other/error24.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror24.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -8,6 +8,6 @@ void\n bar (int i, int j, double k)\n {\n   foo (i && j) ();\t// { dg-error \"\\\\(\\\\(?i != 0\\\\)? \\\\&\\\\& \\\\(?j != 0\\\\)?\\\\)\" }\n-  foo (!i || !j) ();\t// { dg-error \"\\\\(\\\\(?i == 0\\\\)? \\\\|\\\\| \\\\(?j == 0\\\\)?\\\\)\" }\n-  foo (!i == !j) ();\t// { dg-error \"\\\\(\\\\(?i != 0\\\\)? \\\\^ \\\\(?j == 0\\\\)?\\\\)\" }\n+  foo (!i || !j) ();\t// { dg-error \"function\" }\n+  foo (!i == !j) ();\t// { dg-error \"function\" }\n }"}, {"sha": "ffe2728054bfec6f408fb13fe7a1ed99bc8616ad", "filename": "gcc/testsuite/g++.dg/other/error26.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror26.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -2,5 +2,5 @@\n \n void foo(__complex__ double x)\n {\n-  __builtin_conj(x)(); // { dg-error \"~x\" }\n+  __builtin_conj(x)(); // { dg-error \"function\" }\n }"}, {"sha": "3c833472d69b409963bbdabe19b2dd5f995462c1", "filename": "gcc/testsuite/g++.dg/parse/array-size2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Farray-size2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Farray-size2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Farray-size2.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -14,7 +14,7 @@ extern void bar (char *, char *);\n void\n foo (void)\n {\n-  char g[(char *) &((struct S *) 0)->b - (char *) 0];\n-  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];\n+  char g[(char *) &((struct S *) 0)->b - (char *) 0]; // { dg-error \"constant\" }\n+  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];\t      // { dg-error \"constant\" \"\" { xfail *-*-* } }\n   bar (g, h);\n }"}, {"sha": "80147054e88801479c76d81adaa371056b43cd3e", "filename": "gcc/testsuite/g++.dg/ubsan/div-by-zero-1.C", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fdiv-by-zero-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fdiv-by-zero-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fdiv-by-zero-1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -1,14 +1,10 @@\n /* { dg-do compile } */\n /* { dg-options \"-fsanitize=integer-divide-by-zero\" } */\n \n-/* TODO: We expect an error on the invalid case here, because that\n-   must be a constant-expression.  This will be fixed when we have\n-   proper delayed folding.  */\n-\n void\n foo (int i)\n {\n   switch (i)\n   case 0 * (1 / 0): /* { dg-warning \"division by zero\" } */\n-    ;  /* { dg-error \"division by zero\" \"\" { xfail *-*-* } 10 } */\n+    ;  /* { dg-error \"is not a constant.expression\" \"\" { target *-*-* } 8 } */\n }"}, {"sha": "493a55c2b5ecaa0a31d1a2e101e2678bf713627c", "filename": "gcc/testsuite/g++.dg/ubsan/shift-1.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fshift-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fshift-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fshift-1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -8,10 +8,10 @@ foo (int x)\n   /* None of the following should pass.  */\n   switch (x)\n     {\n-    case 1 >> -1: /* { dg-error \"is not a constant expression\" \"\" { xfail { *-*-* } } } */\n-    case -1 >> -1: /* { dg-error \"is not a constant expression\" \"\" { xfail { *-*-* } } } */\n-    case 1 << -1: /* { dg-error \"is not a constant expression\" \"\" { xfail { *-*-* } } } */\n-    case -1 << -1: /* { dg-error \"is not a constant expression\" \"\" { xfail { *-*-* } } } */\n+    case 1 >> -1: /* { dg-error \"operand of shift\" \"\" } */\n+    case -1 >> -1: /* { dg-error \"operand of shift\" \"\" } */\n+    case 1 << -1: /* { dg-error \"operand of shift\" \"\" } */\n+    case -1 << -1: /* { dg-error \"operand of shift\" \"\" } */\n       return 1;\n     }\n   return 0;\n@@ -23,8 +23,8 @@ bar (int x)\n   /* None of the following should pass.  */\n   switch (x)\n     {\n-    case -1 >> 200: /* { dg-error \"is not a constant expression\" \"\" { xfail { *-*-* } } } */\n-    case 1 << 200: /* { dg-error \"is not a constant expression\" \"\" { xfail { *-*-* } } } */\n+    case -1 >> 200: /* { dg-error \"operand of shift\" \"\" } */\n+    case 1 << 200: /* { dg-error \"operand of shift\" \"\" } */\n       return 1;\n     }\n   return 0;"}, {"sha": "a10e15b98118bed775db289475972957cd20bc64", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-1.C", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-1.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -17,7 +17,7 @@ enum e {\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target c++ } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n   /* Again, overflow in evaluated subexpression.  */\n@@ -126,3 +126,11 @@ h2i (int x)\n   ui = INT_MIN;\n   ui = x ? INT_MIN : 1U;\n }\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 19 } */\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 32 } */\n+/* { dg-warning \"invalid conversion from\" \"convert\" { target *-*-* } 56 } */\n+/* { dg-warning \"invalid conversion from\" \"convert\" { target c++11 } 58 } */\n+/* { dg-error \"is not a constant expression\" \"const\" { target *-*-* } 65 } */\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 65 } */\n+/* { dg-error \"width not an integer constant\" \"bit.field\" { target c++ } 32 } */\n+/* { dg-error \"is not a constant expression\" \"division\" { target c++ } 32 } */"}, {"sha": "c73a28c3277aafb8f5f6316a19c38f9f776e0ca5", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-3.C", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-3.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -17,7 +17,7 @@ enum e {\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target c++ } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n   /* Again, overflow in evaluated subexpression.  */\n@@ -56,7 +56,7 @@ void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" }\n /* { dg-warning \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 55 } */\n \n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-warning \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 58 } */\n+/* { dg-warning \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 58 } */\n void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } } */\n \n void\n@@ -65,7 +65,7 @@ g (int i)\n   switch (i)\n     {\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n-      ;\n+      ;  /* { dg-error \"is not a constant expression\" \"const\" { target *-*-* } 67 }  */\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n       /* { dg-warning \"overflow in constant expression\" \"constant\" { target *-*-* } 69 } */\n       ;\n@@ -128,3 +128,9 @@ h2i (int x)\n   ui = INT_MIN;\n   ui = x ? INT_MIN : 1U;\n }\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 19 } */\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 32 } */\n+/* { dg-warning \"invalid conversion from\" \"convert\" { target c++11 } 60 } */\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 67 } */\n+/* { dg-error \"width not an integer constant\" \"bit.field\" { target c++ } 32 } */\n+/* { dg-error \"is not a constant expression\" \"division\" { target c++ } 32 } */"}, {"sha": "23a2585e5323dbc940f9b070f60b29c43fc31fe8", "filename": "gcc/testsuite/g++.dg/warn/overflow-warn-4.C", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Foverflow-warn-4.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -17,7 +17,7 @@ enum e {\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n   E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { xfail *-*-* } 19 } */\n+  /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target c++ } 19 } */\n   E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n   /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 21 } */\n   /* { dg-error \"enumerator value for 'E5' is not an integer constant\" \"enum error\" { target *-*-* } 21 } */\n@@ -59,7 +59,7 @@ void *p = 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" }\n /* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 58 } */\n \n void *q = 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-/* { dg-error \"invalid conversion from 'int' to 'void*'\" \"null\" { xfail *-*-* } 61 } */\n+/* { dg-error \"invalid conversion from 'int' to 'void\" \"null\" { target *-*-* } 61 } */\n void *r = (1 ? 0 : INT_MAX+1); /* { dg-bogus \"integer overflow in expression\" \"\" { xfail *-*-* } } */\n \n void\n@@ -68,7 +68,7 @@ g (int i)\n   switch (i)\n     {\n     case 0 * (1/0): /* { dg-warning \"division by zero\" } */\n-      ;\n+      ;  /* { dg-error \"is not a constant expression\" \"const\" { target *-*-* } 70 } */\n     case 1 + 0 * (INT_MAX + 1): /* { dg-warning \"integer overflow in expression\" } */\n       /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 72 } */\n       ;\n@@ -131,3 +131,9 @@ h2i (int x)\n   ui = INT_MIN;\n   ui = x ? INT_MIN : 1U;\n }\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 19 } */\n+/* { dg-error \"invalid conversion from\" \"convert\" { target c++11 } 63 } */\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 34 } */\n+/* { dg-error \"division by zero is not a constant.expression\" \"division\" { target c++11 } 70 } */\n+/* { dg-error \"width not an integer constant\" \"bit.field\" { target c++ } 34 } */\n+/* { dg-error \"is not a constant expression\" \"division\" { target c++ } 34 } */"}, {"sha": "96691d3a2cc8b39660e3648256ebe22d864bd364", "filename": "gcc/testsuite/g++.old-deja/g++.other/null3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cda0a029f45d20f4535dcacf6c3194352c31e736/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fnull3.C?ref=cda0a029f45d20f4535dcacf6c3194352c31e736", "patch": "@@ -3,5 +3,5 @@\n void x()\n {\n  int* p = 1==0;\t// { dg-warning \"converting 'false' to pointer\" \"\" { target { ! c++11 } } }\n-// { dg-error \"cannot convert\" \"\" { target c++11 } 5 } \n+// { dg-error \"cannot convert\" \"\" { target { c++11 } } 5 }\n }"}]}