{"sha": "edbed3d31e8f6981f4bf4692c132b95081ab5112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRiZWQzZDMxZThmNjk4MWY0YmY0NjkyYzEzMmI5NTA4MWFiNTExMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-10-09T07:07:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-10-09T07:07:15Z"}, "message": "invoke.texi (align-threshold, [...]): Document.\n\n\n\t* invoke.texi (align-threshold, align-loop-iterations): Document.\n\t* final.c: Include cfgloop.h, params.h\n\t(compute_alignments): Dump decisions and compare them with loop\n\tstructure; honor given parameters.\n\t(pass_compute_alignments): New dump file.\n\t* params.def (PARAM_ALIGN_THRESHOLD, PARAM_ALIGN_LOOP_ITERATIONS): New.\n\t* Makefile.in (final.o): Add dependency on cfgloop.h and params.h\n\nFrom-SVN: r129162", "tree": {"sha": "2f06dba4798e87e7c5ac176d0fe66b8e2a3dc3ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f06dba4798e87e7c5ac176d0fe66b8e2a3dc3ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edbed3d31e8f6981f4bf4692c132b95081ab5112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edbed3d31e8f6981f4bf4692c132b95081ab5112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edbed3d31e8f6981f4bf4692c132b95081ab5112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edbed3d31e8f6981f4bf4692c132b95081ab5112/comments", "author": null, "committer": null, "parents": [{"sha": "8df9c702e68f7d493e39883145e03f947ce6e437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df9c702e68f7d493e39883145e03f947ce6e437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8df9c702e68f7d493e39883145e03f947ce6e437"}], "stats": {"total": 88, "additions": 81, "deletions": 7}, "files": [{"sha": "4717ca8a4b0e382d811991f5b6a691eb3e0ee552", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edbed3d31e8f6981f4bf4692c132b95081ab5112", "patch": "@@ -1,3 +1,13 @@\n+2007-10-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* invoke.texi (align-threshold, align-loop-iterations): Document.\n+\t* final.c: Include cfgloop.h, params.h\n+\t(compute_alignments): Dump decisions and compare them with loop\n+\tstructure; honor given parameters.\n+\t(pass_compute_alignments): New dump file.\n+\t* params.def (PARAM_ALIGN_THRESHOLD, PARAM_ALIGN_LOOP_ITERATIONS): New.\n+\t* Makefile.in (final.o): Add dependency on cfgloop.h and params.h\n+\n 2007-10-09  James E. Wilson  <wilson@specifix.com>\n \n \tPR tree-optimization/33655"}, {"sha": "5aee30e42baaabde0d569efdf76e9fb0c6a8a9a0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=edbed3d31e8f6981f4bf4692c132b95081ab5112", "patch": "@@ -2803,7 +2803,8 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(INSN_ATTR_H) $(FUNCTION_H) output.h hard-reg-set.h \\\n    except.h debug.h xcoffout.h toplev.h reload.h dwarf2out.h tree-pass.h \\\n    $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H) $(EXPR_H) $(CFGLAYOUT_H) dbxout.h \\\n-   $(TIMEVAR_H) $(CGRAPH_H) $(COVERAGE_H) $(REAL_H) $(DF_H) vecprim.h $(GGC_H)\n+   $(TIMEVAR_H) $(CGRAPH_H) $(COVERAGE_H) $(REAL_H) $(DF_H) vecprim.h $(GGC_H) \\\n+   $(CFGLOOP_H) $(PARAMS_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) $(REGS_H) $(RECOG_H) $(EXPR_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) toplev.h output.h reload.h \\"}, {"sha": "e5318eb2f260cd85ca22cfcdaf8c1e0a58b1edf5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=edbed3d31e8f6981f4bf4692c132b95081ab5112", "patch": "@@ -6873,6 +6873,16 @@ with unknown.  We predict the known number of iterations correctly, while\n the unknown number of iterations average to roughly 10.  This means that the\n loop without bounds would appear artificially cold relative to the other one.\n \n+@item align-threshold\n+\n+Select fraction of the maximal frequency of executions of basic block in\n+function given basic block will get aligned.\n+\n+@item align-loop-iterations\n+\n+A loop expected to iterate at lest the selected number of iterations will get\n+aligned.\n+\n @item tracer-dynamic-coverage\n @itemx tracer-dynamic-coverage-feedback\n "}, {"sha": "654f847c5e30bafe013e4dfa1b8a83ddaef75ffb", "filename": "gcc/final.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=edbed3d31e8f6981f4bf4692c132b95081ab5112", "patch": "@@ -78,6 +78,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"vecprim.h\"\n #include \"ggc.h\"\n+#include \"cfgloop.h\"\n+#include \"params.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -673,6 +675,8 @@ compute_alignments (void)\n {\n   int log, max_skip, max_log;\n   basic_block bb;\n+  int freq_max = 0;\n+  int freq_threshold = 0;\n \n   if (label_align)\n     {\n@@ -688,6 +692,19 @@ compute_alignments (void)\n   if (! optimize || optimize_size)\n     return 0;\n \n+  if (dump_file)\n+    {\n+      dump_flow_info (dump_file, TDF_DETAILS);\n+      flow_loops_dump (dump_file, NULL, 1);\n+      loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+    }\n+  FOR_EACH_BB (bb)\n+    if (bb->frequency > freq_max)\n+      freq_max = bb->frequency;\n+  freq_threshold = freq_max / PARAM_VALUE (PARAM_ALIGN_THRESHOLD);\n+\n+  if (dump_file)\n+    fprintf(dump_file, \"freq_max: %i\\n\",freq_max);\n   FOR_EACH_BB (bb)\n     {\n       rtx label = BB_HEAD (bb);\n@@ -697,7 +714,12 @@ compute_alignments (void)\n \n       if (!LABEL_P (label)\n \t  || probably_never_executed_bb_p (bb))\n-\tcontinue;\n+\t{\n+\t  if (dump_file)\n+\t    fprintf(dump_file, \"BB %4i freq %4i loop %2i loop_depth %2i skipped.\\n\",\n+\t\t    bb->index, bb->frequency, bb->loop_father->num, bb->loop_depth);\n+\t  continue;\n+\t}\n       max_log = LABEL_ALIGN (label);\n       max_skip = LABEL_ALIGN_MAX_SKIP;\n \n@@ -708,6 +730,18 @@ compute_alignments (void)\n \t  else\n \t    branch_frequency += EDGE_FREQUENCY (e);\n \t}\n+      if (dump_file)\n+\t{\n+\t  fprintf(dump_file, \"BB %4i freq %4i loop %2i loop_depth %2i fall %4i branch %4i\",\n+\t\t  bb->index, bb->frequency, bb->loop_father->num,\n+\t\t  bb->loop_depth,\n+\t\t  fallthru_frequency, branch_frequency);\n+\t  if (!bb->loop_father->inner && bb->loop_father->num)\n+\t    fprintf (dump_file, \" inner_loop\");\n+\t  if (bb->loop_father->header == bb)\n+\t    fprintf (dump_file, \" loop_header\");\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n \n       /* There are two purposes to align block with no fallthru incoming edge:\n \t 1) to avoid fetch stalls when branch destination is near cache boundary\n@@ -720,12 +754,14 @@ compute_alignments (void)\n \t when function is called.  */\n \n       if (!has_fallthru\n-\t  && (branch_frequency > BB_FREQ_MAX / 10\n+\t  && (branch_frequency > freq_threshold\n \t      || (bb->frequency > bb->prev_bb->frequency * 10\n \t\t  && (bb->prev_bb->frequency\n \t\t      <= ENTRY_BLOCK_PTR->frequency / 2))))\n \t{\n \t  log = JUMP_ALIGN (label);\n+\t  if (dump_file)\n+\t    fprintf(dump_file, \"  jump alignment added.\\n\");\n \t  if (max_log < log)\n \t    {\n \t      max_log = log;\n@@ -736,10 +772,13 @@ compute_alignments (void)\n \t align it.  It is most likely a first block of loop.  */\n       if (has_fallthru\n \t  && maybe_hot_bb_p (bb)\n-\t  && branch_frequency + fallthru_frequency > BB_FREQ_MAX / 10\n-\t  && branch_frequency > fallthru_frequency * 2)\n+\t  && branch_frequency + fallthru_frequency > freq_threshold\n+\t  && (branch_frequency\n+\t      > fallthru_frequency * PARAM_VALUE (PARAM_ALIGN_LOOP_ITERATIONS)))\n \t{\n \t  log = LOOP_ALIGN (label);\n+\t  if (dump_file)\n+\t    fprintf(dump_file, \"  internal loop alignment added.\\n\");\n \t  if (max_log < log)\n \t    {\n \t      max_log = log;\n@@ -749,12 +788,15 @@ compute_alignments (void)\n       LABEL_TO_ALIGNMENT (label) = max_log;\n       LABEL_TO_MAX_SKIP (label) = max_skip;\n     }\n+\n+  if (dump_file)\n+    loop_optimizer_finalize ();\n   return 0;\n }\n \n struct tree_opt_pass pass_compute_alignments =\n {\n-  NULL,                                 /* name */\n+  \"alignments\",                         /* name */\n   NULL,                                 /* gate */\n   compute_alignments,                   /* execute */\n   NULL,                                 /* sub */\n@@ -765,7 +807,8 @@ struct tree_opt_pass pass_compute_alignments =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n+  TODO_dump_func | TODO_verify_rtl_sharing\n+  | TODO_ggc_collect,                   /* todo_flags_finish */\n   0                                     /* letter */\n };\n "}, {"sha": "5cb1f6da7c2dee3dec7670421d7de1ce341b3af3", "filename": "gcc/params.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edbed3d31e8f6981f4bf4692c132b95081ab5112/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=edbed3d31e8f6981f4bf4692c132b95081ab5112", "patch": "@@ -334,6 +334,16 @@ DEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n \t \"Select fraction of the maximal frequency of executions of basic block in function given basic block needs to have to be considered hot\",\n \t 1000, 0, 0)\n \n+DEFPARAM (PARAM_ALIGN_THRESHOLD,\n+\t  \"align-threshold\",\n+\t  \"Select fraction of the maximal frequency of executions of basic block in function given basic block get alignment\",\n+\t  100, 0, 0)\n+\n+DEFPARAM (PARAM_ALIGN_LOOP_ITERATIONS,\n+\t  \"align-loop-iterations\",\n+\t  \"Loops iterating at least selected number of iterations will get loop alignement.\",\n+\t  4, 0, 0)\n+\n /* For guessed profiles, the loops having unknown number of iterations\n    are predicted to iterate relatively few (10) times at average.\n    For functions containing one loop with large known number of iterations"}]}