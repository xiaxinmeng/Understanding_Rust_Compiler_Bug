{"sha": "04e3ec78036a73b107ff87da6a9dafa91aa85bf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRlM2VjNzgwMzZhNzNiMTA3ZmY4N2RhNmE5ZGFmYTkxYWE4NWJmMw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-03-28T12:00:39Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-03-28T12:00:39Z"}, "message": "2000-03-28  Neil Booth  <NeilB@earthling.net>\n\n        * (cpplex.c) _cpp_read_and_prescan.  Mark end of input buffer with\n\t'\\\\' rather than a null character, so nulls are not special.  Fix\n\t\"\\\\\\n\" handling in end-of-buffer conditions.  Use trigraph map to\n\tspeed trigraph conversion.\n        (_cpp_init_input_buffer) Initialize trigraph map.\n\nFrom-SVN: r32781", "tree": {"sha": "ee1ac025fa207a1e9523553879f494e2e5fb0959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee1ac025fa207a1e9523553879f494e2e5fb0959"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04e3ec78036a73b107ff87da6a9dafa91aa85bf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e3ec78036a73b107ff87da6a9dafa91aa85bf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04e3ec78036a73b107ff87da6a9dafa91aa85bf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04e3ec78036a73b107ff87da6a9dafa91aa85bf3/comments", "author": null, "committer": null, "parents": [{"sha": "7e030e49fedd23d8215c8ada8b38ecd06b73ed87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e030e49fedd23d8215c8ada8b38ecd06b73ed87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e030e49fedd23d8215c8ada8b38ecd06b73ed87"}], "stats": {"total": 310, "additions": 140, "deletions": 170}, "files": [{"sha": "8c5d6e9a26145734a891a3c7b940c2fb3cbae49d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04e3ec78036a73b107ff87da6a9dafa91aa85bf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04e3ec78036a73b107ff87da6a9dafa91aa85bf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04e3ec78036a73b107ff87da6a9dafa91aa85bf3", "patch": "@@ -1,3 +1,11 @@\n+2000-03-28  Neil Booth  <NeilB@earthling.net>\n+\n+        * (cpplex.c) _cpp_read_and_prescan.  Mark end of input buffer with\n+\t'\\\\' rather than a null character, so nulls are not special.  Fix\n+\t\"\\\\\\n\" handling in end-of-buffer conditions.  Use trigraph map to\n+\tspeed trigraph conversion.\n+        (_cpp_init_input_buffer) Initialize trigraph map.\n+\n 2000-03-27  Alan Modra  <alan@linuxcare.com.au>\n \n \t* config/i386/i386.c (output_387_binary_op): Correct intel"}, {"sha": "0a36a805429e51c9d01f7b182412453d482df31f", "filename": "gcc/cpplex.c", "status": "modified", "additions": 132, "deletions": 170, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04e3ec78036a73b107ff87da6a9dafa91aa85bf3/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04e3ec78036a73b107ff87da6a9dafa91aa85bf3/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=04e3ec78036a73b107ff87da6a9dafa91aa85bf3", "patch": "@@ -1292,16 +1292,29 @@ find_position (start, limit, linep)\n    at the end of reload1.c is about 60%.  (reload1.c is 329k.)\n \n    If your file has more than one kind of end-of-line marker, you\n-   will get messed-up line numbering.  */\n+   will get messed-up line numbering.\n+   \n+   So that the cases of the switch statement do not have to concern\n+   themselves with the complications of reading beyond the end of the\n+   buffer, the buffer is guaranteed to have at least 3 characters in\n+   it (or however many are left in the file, if less) on entry to the\n+   switch.  This is enough to handle trigraphs and the \"\\\\\\n\\r\" and\n+   \"\\\\\\r\\n\" cases.\n+   \n+   The end of the buffer is marked by a '\\\\', which, being a special\n+   character, guarantees we will exit the fast-scan loops and perform\n+   a refill. */\n \n /* Table of characters that can't be handled in the inner loop.\n    Keep these contiguous to optimize the performance of the code generated\n    for the switch that uses them.  */\n #define SPECCASE_EMPTY     0\n-#define SPECCASE_NUL       1\n-#define SPECCASE_CR        2\n-#define SPECCASE_BACKSLASH 3\n-#define SPECCASE_QUESTION  4\n+#define SPECCASE_CR        1\n+#define SPECCASE_BACKSLASH 2\n+#define SPECCASE_QUESTION  3\n+\n+/* Maps trigraph characters to their replacements */\n+static unsigned int trigraph_map   [1 << CHAR_BIT] = {0};\n \n long\n _cpp_read_and_prescan (pfile, fp, desc, len)\n@@ -1316,241 +1329,181 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n   U_CHAR *speccase = pfile->input_speccase;\n   unsigned long line;\n   unsigned int deferred_newlines;\n-  int count;\n   size_t offset;\n+  int count = 0;\n \n   offset = 0;\n+  deferred_newlines = 0;\n   op = buf;\n   line_base = buf;\n   line = 1;\n-  ibase = pfile->input_buffer + 2;\n-  deferred_newlines = 0;\n+  ibase = pfile->input_buffer + 3;\n+  ip = ibase;\n+  ip[-1] = '\\0';  /* Guarantee no match with \\n for SPECCASE_CR */\n \n   for (;;)\n     {\n-    read_next:\n+      U_CHAR *near_buff_end;\n+\n+      /* Copy previous char plus unprocessed (at most 2) chars\n+\t to beginning of buffer, refill it with another\n+\t read(), and continue processing */\n+      memcpy(ip - count - 1, ip - 1, 3);\n+      ip -= count;\n \n-      count = read (desc, pfile->input_buffer + 2, pfile->input_buffer_len);\n+      count = read (desc, ibase, pfile->input_buffer_len);\n       if (count < 0)\n \tgoto error;\n-      else if (count == 0)\n-\tbreak;\n-\n-      offset += count;\n-      ip = ibase;\n-      ibase = pfile->input_buffer + 2;\n-      ibase[count] = ibase[count+1] = '\\0';\n-\n-      if (offset > len)\n+      \n+      ibase[count] = '\\\\';  /* Marks end of buffer */\n+      if (count)\n \t{\n-\t  size_t delta_op;\n-\t  size_t delta_line_base;\n-\t  len *= 2;\n+\t  near_buff_end = pfile->input_buffer + count;\n+\t  offset += count;\n \t  if (offset > len)\n-\t    /* len overflowed.\n-\t       This could happen if the file is larger than half the\n-\t       maximum address space of the machine. */\n-\t    goto too_big;\n-\n-\t  delta_op = op - buf;\n-\t  delta_line_base = line_base - buf;\n-\t  buf = (U_CHAR *) xrealloc (buf, len);\n-\t  op = buf + delta_op;\n-\t  line_base = buf + delta_line_base;\n+\t    {\n+\t      size_t delta_op;\n+\t      size_t delta_line_base;\n+\t      len *= 2;\n+\t      if (offset > len)\n+\t\t/* len overflowed.\n+\t\t   This could happen if the file is larger than half the\n+\t\t   maximum address space of the machine. */\n+\t\tgoto too_big;\n+\n+\t      delta_op = op - buf;\n+\t      delta_line_base = line_base - buf;\n+\t      buf = (U_CHAR *) xrealloc (buf, len);\n+\t      op = buf + delta_op;\n+\t      line_base = buf + delta_line_base;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (ip == ibase)\n+\t    break;\n+\t  /* Allow normal processing of the (at most 2) remaining\n+\t     characters.  The end-of-buffer marker is still present\n+\t     and prevents false matches within the switch. */\n+\t  near_buff_end = ibase - 1;\n \t}\n \n       for (;;)\n \t{\n-\t  unsigned int span = 0;\n+\t  unsigned int span;\n \n-\t  /* Deal with \\-newline in the middle of a token. */\n+\t  /* Deal with \\-newline, potentially in the middle of a token. */\n \t  if (deferred_newlines)\n \t    {\n-\t      while (speccase[ip[span]] == SPECCASE_EMPTY\n-\t\t     && ip[span] != '\\n'\n-\t\t     && ip[span] != '\\t'\n-\t\t     && ip[span] != ' ')\n-\t\tspan++;\n-\t      memcpy (op, ip, span);\n-\t      op += span;\n-\t      ip += span;\n-\t      /* If ip[0] is SPECCASE_EMPTY, we have hit white space.\n-\t\t Dump out the remaining deferred \\-newlines.  */\n-\t      if (speccase[ip[0]] == SPECCASE_EMPTY)\n-\t\twhile (deferred_newlines)\n-\t\t  deferred_newlines--, *op++ = '\\r';\n-\t      span = 0;\n+\t      if (op != buf && op[-1] != ' ' && op[-1] != '\\n' && op[-1] != '\\t' && op[-1] != '\\r')\n+\t\t{\n+\t\t  /* Previous was not white space.  Skip to white\n+\t\t     space, if we can, before outputting the \\r's */\n+\t\t  span = 0;\n+\t\t  while (ip[span] != ' '\n+\t\t\t && ip[span] != '\\t'\n+\t\t\t && ip[span] != '\\n'\n+\t\t\t && speccase[ip[span]] == SPECCASE_EMPTY)\n+\t\t    span++;\n+\t\t  memcpy (op, ip, span);\n+\t\t  op += span;\n+\t\t  ip += span;\n+\t\t  if (speccase[ip[0]] != SPECCASE_EMPTY)\n+\t\t    goto do_speccase;\n+\t\t}\n+\t      while (deferred_newlines)\n+\t\tdeferred_newlines--, *op++ = '\\r';\n \t    }\n \n \t  /* Copy as much as we can without special treatment. */\n+\t  span = 0;\n \t  while (speccase[ip[span]] == SPECCASE_EMPTY) span++;\n \t  memcpy (op, ip, span);\n \t  op += span;\n \t  ip += span;\n \n+\tdo_speccase:\n+\t  if (ip > near_buff_end) /* Do we have enough chars? */\n+\t    break;\n \t  switch (speccase[*ip++])\n \t    {\n-\t    case SPECCASE_NUL:  /* \\0 */\n-\t      ibase[-1] = op[-1];\n-\t      goto read_next;\n-\n \t    case SPECCASE_CR:  /* \\r */\n-\t      if (ip[-2] == '\\n')\n-\t\tcontinue;\n-\t      else if (*ip == '\\n')\n-\t\tip++;\n-\t      else if (*ip == '\\0')\n+\t      if (ip[-2] != '\\n')\n \t\t{\n-\t\t  *--ibase = '\\r';\n-\t\t  goto read_next;\n+\t\t  if (*ip == '\\n')\n+\t\t    ip++;\n+\t\t  *op++ = '\\n';\n \t\t}\n-\t      *op++ = '\\n';\n \t      break;\n \n \t    case SPECCASE_BACKSLASH:  /* \\ */\n-\t    backslash:\n-\t    {\n-\t      /* If we're at the end of the intermediate buffer,\n-\t\t we have to shift the backslash down to the start\n-\t\t and come back next pass. */\n-\t      if (*ip == '\\0')\n-\t\t{\n-\t\t  *--ibase = '\\\\';\n-\t\t  goto read_next;\n-\t\t}\n-\t      else if (*ip == '\\n')\n+\t      if (*ip == '\\n')\n \t\t{\n+\t\t  deferred_newlines++;\n \t\t  ip++;\n \t\t  if (*ip == '\\r') ip++;\n-\t\t  if (*ip == '\\n' || *ip == '\\t' || *ip == ' ')\n-\t\t    *op++ = '\\r';\n-\t\t  else if (op[-1] == '\\t' || op[-1] == ' '\n-\t\t\t   || op[-1] == '\\r' || op[-1] == '\\n')\n-\t\t    *op++ = '\\r';\n-\t\t  else\n-\t\t    deferred_newlines++;\n \t\t}\n \t      else if (*ip == '\\r')\n \t\t{\n+\t\t  deferred_newlines++;\n \t\t  ip++;\n \t\t  if (*ip == '\\n') ip++;\n-\t\t  else if (*ip == '\\0')\n-\t\t    {\n-\t\t      *--ibase = '\\r';\n-\t\t      *--ibase = '\\\\';\n-\t\t      goto read_next;\n-\t\t    }\n-\t\t  else if (*ip == '\\r' || *ip == '\\t' || *ip == ' ')\n-\t\t    *op++ = '\\r';\n-\t\t  else\n-\t\t    deferred_newlines++;\n \t\t}\n \t      else\n \t\t*op++ = '\\\\';\n-\t    }\n-\t    break;\n+\t      break;\n \n \t    case SPECCASE_QUESTION: /* ? */\n \t      {\n \t\tunsigned int d, t;\n-\t\t/* If we're at the end of the intermediate buffer,\n-\t\t   we have to shift the ?'s down to the start and\n-\t\t   come back next pass. */\n-\t\td = ip[0];\n-\t\tif (d == '\\0')\n-\t\t  {\n-\t\t    *--ibase = '?';\n-\t\t    goto read_next;\n-\t\t  }\n-\t\tif (d != '?')\n-\t\t  {\n-\t\t    *op++ = '?';\n-\t\t    break;\n-\t\t  }\n+\n+\t\t*op++ = '?'; /* Normal non-trigraph case */\n+\t\tif (ip[0] != '?')\n+\t\t  break;\n+\t\t    \n \t\td = ip[1];\n-\t\tif (d == '\\0')\n-\t\t  {\n-\t\t    *--ibase = '?';\n-\t\t    *--ibase = '?';\n-\t\t    goto read_next;\n-\t\t  }\n+\t\tt = trigraph_map[d];\n+\t\tif (t == 0)\n+\t\t  break;\n \n-\t\t/* Trigraph map:\n-\t\t *\tfrom\tto\tfrom\tto\tfrom\tto\n-\t\t *\t?? =\t#\t?? )\t]\t?? !\t|\n-\t\t *\t?? (\t[\t?? '\t^\t?? >\t}\n-\t\t *\t?? /\t\\\t?? <\t{\t?? -\t~\n-\t\t */\n-\t\tif (d == '=') t = '#';\n-\t\telse if (d == ')') t = ']';\n-\t\telse if (d == '!') t = '|';\n-\t\telse if (d == '(') t = '[';\n-\t\telse if (d == '\\'') t = '^';\n-\t\telse if (d == '>') t = '}';\n-\t\telse if (d == '/') t = '\\\\';\n-\t\telse if (d == '<') t = '{';\n-\t\telse if (d == '-') t = '~';\n-\t\telse\n-\t\t  {\n-\t\t    *op++ = '?';\n-\t\t    break;\n-\t\t  }\n-\t\tip += 2;\n \t\tif (CPP_OPTIONS (pfile)->warn_trigraphs)\n \t\t  {\n \t\t    unsigned long col;\n \t\t    line_base = find_position (line_base, op, &line);\n \t\t    col = op - line_base + 1;\n \t\t    if (CPP_OPTIONS (pfile)->trigraphs)\n \t\t      cpp_warning_with_line (pfile, line, col,\n-\t\t\t     \"trigraph ??%c converted to %c\", d, t);\n+\t\t\t\t\t     \"trigraph ??%c converted to %c\", d, t);\n \t\t    else\n \t\t      cpp_warning_with_line (pfile, line, col,\n-\t\t\t     \"trigraph ??%c ignored\", d);\n+\t\t\t\t\t     \"trigraph ??%c ignored\", d);\n \t\t  }\n+\n+\t\tip += 2;\n \t\tif (CPP_OPTIONS (pfile)->trigraphs)\n \t\t  {\n+\t\t    op[-1] = t;\t    /* Overwrite '?' */\n \t\t    if (t == '\\\\')\n-\t\t      goto backslash;\n-\t\t    else\n-\t\t      *op++ = t;\n+\t\t      {\n+\t\t\top--;\n+\t\t\t*--ip = '\\\\';\n+\t\t\tgoto do_speccase; /* May need buffer refill */\n+\t\t      }\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    *op++ = '?';\n \t\t    *op++ = '?';\n \t\t    *op++ = d;\n \t\t  }\n \t      }\n+\t      break;\n \t    }\n \t}\n     }\n \n   if (offset == 0)\n     return 0;\n \n-  /* Deal with pushed-back chars at true EOF.\n-     This may be any of:  ?? ? \\ \\r \\n \\\\r \\\\n.\n-     \\r must become \\n, \\\\r or \\\\n must become \\r.\n-     We know we have space already. */\n-  if (ibase == pfile->input_buffer)\n-    {\n-      if (*ibase == '?')\n-\t{\n-\t  *op++ = '?';\n-\t  *op++ = '?';\n-\t}\n-      else\n-\t*op++ = '\\r';\n-    }\n-  else if (ibase == pfile->input_buffer + 1)\n-    {\n-      if (*ibase == '\\r')\n-\t*op++ = '\\n';\n-      else\n-\t*op++ = *ibase;\n-    }\n-\n   if (op[-1] != '\\n')\n     {\n       unsigned long col;\n@@ -1582,10 +1535,10 @@ _cpp_read_and_prescan (pfile, fp, desc, len)\n   return -1;\n }\n \n-/* Initialize the `input_buffer' and `input_speccase' tables.\n-   These are only used by read_and_prescan, but they're large and\n-   somewhat expensive to set up, so we want them allocated once for\n-   the duration of the cpp run.  */\n+/* Initialize the `input_buffer' 'trigraph_map' and `input_speccase'\n+   tables.  These are only used by read_and_prescan, but they're large\n+   and somewhat expensive to set up, so we want them allocated once\n+   for the duration of the cpp run.  */\n \n void\n _cpp_init_input_buffer (pfile)\n@@ -1599,22 +1552,31 @@ _cpp_init_input_buffer (pfile)\n \n   tmp = (U_CHAR *) xmalloc (1 << CHAR_BIT);\n   memset (tmp, SPECCASE_EMPTY, 1 << CHAR_BIT);\n-  tmp['\\0'] = SPECCASE_NUL;\n   tmp['\\r'] = SPECCASE_CR;\n   tmp['\\\\'] = SPECCASE_BACKSLASH;\n   if (CPP_OPTIONS (pfile)->trigraphs || CPP_OPTIONS (pfile)->warn_trigraphs)\n     tmp['?'] = SPECCASE_QUESTION;\n-\n   pfile->input_speccase = tmp;\n \n+  /* Trigraph mappings */\n+  trigraph_map['='] = '#';\n+  trigraph_map[')'] = ']';\n+  trigraph_map['!'] = '|';\n+  trigraph_map['('] = '[';\n+  trigraph_map['\\''] = '^';\n+  trigraph_map['>'] = '}';\n+  trigraph_map['/'] = '\\\\';\n+  trigraph_map['<'] = '{';\n+  trigraph_map['-'] = '~';\n+\n   /* Determine the appropriate size for the input buffer.  Normal C\n      source files are smaller than eight K.  */\n-  /* 8Kbytes of buffer proper, 2 to detect running off the end without\n-     address arithmetic all the time, and 2 for pushback in the case\n-     there's a potential trigraph or end-of-line digraph at the end of\n-     a block. */\n+  /* 8Kbytes of buffer proper, 1 to detect running off the end without\n+     address arithmetic all the time, and 3 for pushback during buffer\n+     refill, in case there's a potential trigraph or end-of-line\n+     digraph at the end of a block. */\n \n-  tmp = (U_CHAR *) xmalloc (8192 + 2 + 2);\n+  tmp = (U_CHAR *) xmalloc (8192 + 1 + 3);\n   pfile->input_buffer = tmp;\n   pfile->input_buffer_len = 8192;\n }"}]}