{"sha": "5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzMWE1ZjBhODM5M2MwNWE2ZGE5OWY5YTU5OTVmZmM3YWE2YjhjYQ==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2012-10-25T21:45:28Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2012-10-25T21:45:28Z"}, "message": "Change hash_table to support a comparator type different from the value type stored in the hash table.\n\nChange hash_table to support a comparator type different from the\nvalue type stored in the hash table.  The 'find' functions now may\ntake a different type from the value type.  This requires introducing\na second typedef into the Descriptor conceptual type.  Change the\nDescriptor concept to use typedefs value_type and compare_type instead\nof T.  Change all users to match.\n\nAdd usage documentation to hash-table.h.\n\nTested on x86-64.\n\n\nIndex: gcc/ChangeLog\n\n2012-10-25  Lawrence Crowl  <crowl@google.com>\n\n\t* hash-table.h: Add usage documentation.\n\t(template struct typed_free_remove): Clarify documentation. \n\tRename template parameter.\n\t(struct typed_noop_remove): Likewise.\n\t(descriptor concept): Change typedef T to value_type.\n\tAdd typedef compare_type.  Use more precise template parameter name,\n\tDescriptor instead of Descr.  Update users to match.\n\t(struct hash_table): Change 'find' parameters to use compare_type\n\tinstead of the value type.\n\nFrom-SVN: r192823", "tree": {"sha": "723cd03031244c4befb8e0f3f168067dec16d361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/723cd03031244c4befb8e0f3f168067dec16d361"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/comments", "author": null, "committer": null, "parents": [{"sha": "2257bc19401e4dfd76f199fa40c0aa6c3bfdc612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2257bc19401e4dfd76f199fa40c0aa6c3bfdc612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2257bc19401e4dfd76f199fa40c0aa6c3bfdc612"}], "stats": {"total": 641, "additions": 414, "deletions": 227}, "files": [{"sha": "47a7a4e111cd1054eb52dd3e76dd67b59bb470c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -1,3 +1,15 @@\n+2012-10-25  Lawrence Crowl  <crowl@google.com>\n+\n+\t* hash-table.h: Add usage documentation.\n+\t(template struct typed_free_remove): Clarify documentation. \n+\tRename template parameter.\n+\t(struct typed_noop_remove): Likewise.\n+\t(descriptor concept): Change typedef T to value_type.\n+\tAdd typedef compare_type.  Use more precise template parameter name,\n+\tDescriptor instead of Descr.  Update users to match.\n+\t(struct hash_table): Change 'find' parameters to use compare_type\n+\tinstead of the value type.\n+\n 2012-10-25  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-cp.c (ipcp_discover_new_direct_edges): If something was turned"}, {"sha": "68d66ee1b93c3ff8ff5a9d7ebdfcea89b2eb0a78", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"alloc-pool.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n \n #define align_eight(x) (((x+7) >> 3) << 3)\n \n@@ -83,38 +83,42 @@ struct alloc_pool_descriptor\n   int elt_size;\n };\n \n+struct alloc_pool_hasher : typed_noop_remove <alloc_pool_descriptor>\n+{\n+  typedef alloc_pool_descriptor value_type;\n+  typedef char compare_type;\n+  static inline hashval_t hash (const alloc_pool_descriptor *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n /* Hashtable mapping alloc_pool names to descriptors.  */\n-static htab_t alloc_pool_hash;\n+static hash_table <alloc_pool_hasher>  alloc_pool_hash;\n \n /* Hashtable helpers.  */\n-static hashval_t\n-hash_descriptor (const void *p)\n+inline hashval_t\n+alloc_pool_hasher::hash (const value_type *d)\n {\n-  const struct alloc_pool_descriptor *const d =\n-    (const struct alloc_pool_descriptor * )p;\n   return htab_hash_pointer (d->name);\n }\n-static int\n-eq_descriptor (const void *p1, const void *p2)\n+\n+inline bool\n+alloc_pool_hasher::equal (const value_type *d,\n+                          const compare_type *p2)\n {\n-  const struct alloc_pool_descriptor *const d =\n-    (const struct alloc_pool_descriptor *) p1;\n   return d->name == p2;\n }\n \n /* For given name, return descriptor, create new if needed.  */\n static struct alloc_pool_descriptor *\n-alloc_pool_descriptor (const char *name)\n+allocate_pool_descriptor (const char *name)\n {\n   struct alloc_pool_descriptor **slot;\n \n-  if (!alloc_pool_hash)\n-    alloc_pool_hash = htab_create (10, hash_descriptor, eq_descriptor, NULL);\n+  if (!alloc_pool_hash.is_created ())\n+    alloc_pool_hash.create (10);\n \n-  slot = (struct alloc_pool_descriptor **)\n-    htab_find_slot_with_hash (alloc_pool_hash, name,\n-\t\t\t      htab_hash_pointer (name),\n-\t\t\t      INSERT);\n+  slot = alloc_pool_hash.find_slot_with_hash (name,\n+\t\t\t\t\t      htab_hash_pointer (name), INSERT);\n   if (*slot)\n     return *slot;\n   *slot = XCNEW (struct alloc_pool_descriptor);\n@@ -158,7 +162,7 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n \n   if (GATHER_STATISTICS)\n     {\n-      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (name);\n+      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (name);\n       desc->elt_size = size;\n       desc->created++;\n     }\n@@ -205,7 +209,7 @@ empty_alloc_pool (alloc_pool pool)\n \n   if (GATHER_STATISTICS)\n     {\n-      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n+      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (pool->name);\n       desc->current -= (pool->elts_allocated - pool->elts_free) * pool->elt_size;\n     }\n \n@@ -253,7 +257,7 @@ pool_alloc (alloc_pool pool)\n \n   if (GATHER_STATISTICS)\n     {\n-      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n+      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (pool->name);\n \n       desc->allocated += pool->elt_size;\n       desc->current += pool->elt_size;\n@@ -357,7 +361,7 @@ pool_free (alloc_pool pool, void *ptr)\n \n   if (GATHER_STATISTICS)\n     {\n-      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n+      struct alloc_pool_descriptor *desc = allocate_pool_descriptor (pool->name);\n       desc->current -= pool->elt_size;\n     }\n }\n@@ -371,19 +375,20 @@ struct output_info\n   unsigned long total_allocated;\n };\n \n-/* Called via htab_traverse.  Output alloc_pool descriptor pointed out by SLOT\n-   and update statistics.  */\n-static int\n-print_statistics (void **slot, void *b)\n+/* Called via hash_table.traverse.  Output alloc_pool descriptor pointed out by\n+   SLOT and update statistics.  */\n+int\n+print_alloc_pool_statistics (alloc_pool_descriptor **slot,\n+\t\t\t     struct output_info *i)\n {\n-  struct alloc_pool_descriptor *d = (struct alloc_pool_descriptor *) *slot;\n-  struct output_info *i = (struct output_info *) b;\n+  struct alloc_pool_descriptor *d = *slot;\n \n   if (d->allocated)\n     {\n-      fprintf (stderr, \"%-22s %6d %10lu %10lu(%10lu) %10lu(%10lu) %10lu(%10lu)\\n\", d->name,\n-\t       d->elt_size, d->created, d->allocated, d->allocated / d->elt_size,\n-\t       d->peak, d->peak / d->elt_size,\n+      fprintf (stderr,\n+\t       \"%-22s %6d %10lu %10lu(%10lu) %10lu(%10lu) %10lu(%10lu)\\n\",\n+\t       d->name, d->elt_size, d->created, d->allocated,\n+\t       d->allocated / d->elt_size, d->peak, d->peak / d->elt_size,\n \t       d->current, d->current / d->elt_size);\n       i->total_allocated += d->allocated;\n       i->total_created += d->created;\n@@ -400,14 +405,15 @@ dump_alloc_pool_statistics (void)\n   if (! GATHER_STATISTICS)\n     return;\n \n-  if (!alloc_pool_hash)\n+  if (!alloc_pool_hash.is_created ())\n     return;\n \n   fprintf (stderr, \"\\nAlloc-pool Kind         Elt size  Pools  Allocated (elts)            Peak (elts)            Leak (elts)\\n\");\n   fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n   info.total_created = 0;\n   info.total_allocated = 0;\n-  htab_traverse (alloc_pool_hash, print_statistics, &info);\n+  alloc_pool_hash.traverse <struct output_info *,\n+\t\t\t    print_alloc_pool_statistics> (&info);\n   fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n   fprintf (stderr, \"%-22s           %7lu %10lu\\n\",\n \t   \"Total\", info.total_created, info.total_allocated);"}, {"sha": "89c0d877034ba9fafe494bc6a4733ac7f2fd49b8", "filename": "gcc/cfg.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -988,19 +988,21 @@ struct htab_bb_copy_original_entry\n \n struct bb_copy_hasher : typed_noop_remove <htab_bb_copy_original_entry>\n {\n-  typedef htab_bb_copy_original_entry T;\n-  static inline hashval_t hash (const T *);\n-  static inline bool equal (const T *existing, const T * candidate);\n+  typedef htab_bb_copy_original_entry value_type;\n+  typedef htab_bb_copy_original_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *existing,\n+\t\t\t    const compare_type * candidate);\n };\n \n inline hashval_t\n-bb_copy_hasher::hash (const T *data)\n+bb_copy_hasher::hash (const value_type *data)\n {\n   return data->index1;\n }\n \n inline bool\n-bb_copy_hasher::equal (const T *data, const T *data2)\n+bb_copy_hasher::equal (const value_type *data, const compare_type *data2)\n {\n   return data->index1 == data2->index1;\n }"}, {"sha": "b634c82139686072172653f39ee6855c5dc1ff26", "filename": "gcc/coverage.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -79,10 +79,11 @@ typedef struct counts_entry\n   struct gcov_ctr_summary summary;\n \n   /* hash_table support.  */\n-  typedef counts_entry T;\n-  static inline hashval_t hash (const counts_entry *);\n-  static int equal (const counts_entry *, const counts_entry *);\n-  static void remove (counts_entry *);\n+  typedef counts_entry value_type;\n+  typedef counts_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static int equal (const value_type *, const compare_type *);\n+  static void remove (value_type *);\n } counts_entry_t;\n \n static GTY(()) struct coverage_data *functions_head = 0;\n@@ -150,20 +151,20 @@ get_gcov_unsigned_t (void)\n }\n \f\n inline hashval_t\n-counts_entry::hash (const counts_entry_t *entry)\n+counts_entry::hash (const value_type *entry)\n {\n   return entry->ident * GCOV_COUNTERS + entry->ctr;\n }\n \n inline int\n-counts_entry::equal (const counts_entry_t *entry1,\n-\t\t     const counts_entry_t *entry2)\n+counts_entry::equal (const value_type *entry1,\n+\t\t     const compare_type *entry2)\n {\n   return entry1->ident == entry2->ident && entry1->ctr == entry2->ctr;\n }\n \n inline void\n-counts_entry::remove (counts_entry_t *entry)\n+counts_entry::remove (value_type *entry)\n {\n   free (entry->counts);\n   free (entry);"}, {"sha": "3ae8353770ff53ca929f898214bc5848faeaa6a5", "filename": "gcc/dse.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -654,19 +654,21 @@ clear_alias_set_lookup (alias_set_type alias_set)\n \n struct invariant_group_base_hasher : typed_noop_remove <group_info>\n {\n-  typedef group_info T;\n-  static inline hashval_t hash (const T *);\n-  static inline bool equal (const T *, const T *);\n+  typedef group_info value_type;\n+  typedef group_info compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n };\n \n inline bool\n-invariant_group_base_hasher::equal (const T *gi1, const T *gi2)\n+invariant_group_base_hasher::equal (const value_type *gi1,\n+\t\t\t\t    const compare_type *gi2)\n {\n   return rtx_equal_p (gi1->rtx_base, gi2->rtx_base);\n }\n \n inline hashval_t\n-invariant_group_base_hasher::hash (const T *gi)\n+invariant_group_base_hasher::hash (const value_type *gi)\n {\n   int do_not_record;\n   return hash_rtx (gi->rtx_base, Pmode, &do_not_record, NULL, false);"}, {"sha": "a80100f193894fda562ad496e91c04287af3eb0c", "filename": "gcc/hash-table.h", "status": "modified", "additions": 292, "deletions": 137, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -21,7 +21,142 @@ along with GCC; see the file COPYING3.  If not see\n \n \n /* This file implements a typed hash table.\n-   The implementation borrows from libiberty's hashtab.  */\n+   The implementation borrows from libiberty's htab_t in hashtab.h.\n+\n+\n+   INTRODUCTION TO TYPES\n+\n+   Users of the hash table generally need to be aware of three types.\n+\n+      1. The type being placed into the hash table.  This type is called\n+      the value type.\n+\n+      2. The type used to describe how to handle the value type within\n+      the hash table.  This descriptor type provides the hash table with\n+      several things.\n+\n+         - A typedef named 'value_type' to the value type (from above).\n+\n+         - A static member function named 'hash' that takes a value_type\n+         pointer and returns a hashval_t value.\n+\n+         - A typedef named 'compare_type' that is used to test when an value\n+         is found.  This type is the comparison type.  Usually, it will be the\n+         same as value_type.  If it is not the same type, you must generally\n+         explicitly compute hash values and pass them to the hash table.\n+\n+         - A static member function named 'equal' that takes a value_type\n+         pointer and a compare_type pointer, and returns a bool.\n+\n+         - A static function named 'remove' that takes an value_type pointer\n+         and frees the memory allocated by it.  This function is used when\n+         individual elements of the table need to be disposed of (e.g.,\n+         when deleting a hash table, removing elements from the table, etc).\n+\n+      3. The type of the hash table itself.  (More later.)\n+\n+   In very special circumstances, users may need to know about a fourth type.\n+\n+      4. The template type used to describe how hash table memory\n+      is allocated.  This type is called the allocator type.  It is\n+      parameterized on the value type.  It provides four functions.\n+\n+         - A static member function named 'control_alloc'.  This function\n+         allocates the control data blocks for the table.\n+\n+         - A static member function named 'control_free'.  This function\n+         frees the control data blocks for the table.\n+\n+         - A static member function named 'data_alloc'.  This function\n+         allocates the data elements in the table.\n+\n+         - A static member function named 'data_free'.  This function\n+         deallocates the data elements in the table.\n+\n+   Hash table are instantiated with two type arguments.\n+\n+      * The descriptor type, (2) above.\n+\n+      * The allocator type, (4) above.  In general, you will not need to\n+      provide your own allocator type.  By default, hash tables will use\n+      the class template xcallocator, which uses malloc/free for allocation.\n+\n+\n+   DEFINING A DESCRIPTOR TYPE\n+\n+   The first task in using the hash table is to describe the element type.\n+   We compose this into a few steps.\n+\n+      1. Decide on a removal policy for values stored in the table.\n+         This header provides class templates for the two most common\n+         policies.\n+\n+         * typed_free_remove implements the static 'remove' member function\n+         by calling free().\n+\n+         * typed_noop_remove implements the static 'remove' member function\n+         by doing nothing.\n+\n+         You can use these policies by simply deriving the descriptor type\n+         from one of those class template, with the appropriate argument.\n+\n+         Otherwise, you need to write the static 'remove' member function\n+         in the descriptor class.\n+\n+      2. Choose a hash function.  Write the static 'hash' member function.\n+\n+      3. Choose an equality testing function.  In most cases, its two\n+      arguments will be value_type pointers.  If not, the first argument must\n+      be a value_type pointer, and the second argument a compare_type pointer.\n+\n+\n+   AN EXAMPLE DESCRIPTOR TYPE\n+\n+   Suppose you want to put some_type into the hash table.  You could define\n+   the descriptor type as follows.\n+\n+      struct some_type_hasher : typed_noop_remove <some_type>\n+      // Deriving from typed_noop_remove means that we get a 'remove' that does\n+      // nothing.  This choice is good for raw values.\n+      {\n+        typedef some_type value_type;\n+        typedef some_type compare_type;\n+        static inline hashval_t hash (const value_type *);\n+        static inline bool equal (const value_type *, const compare_type *);\n+      };\n+\n+      inline hashval_t\n+      some_type_hasher::hash (const value_type *e)\n+      { ... compute and return a hash value for E ... }\n+\n+      inline bool\n+      some_type_hasher::equal (const value_type *p1, const compare_type *p2)\n+      { ... compare P1 vs P2.  Return true if they are the 'same' ... }\n+\n+\n+   AN EXAMPLE HASH_TABLE DECLARATION\n+\n+   To instantiate a hash table for some_type:\n+\n+      hash_table <some_type_hasher> some_type_hash_table;\n+\n+   There is no need to mention some_type directly, as the hash table will\n+   obtain it using some_type_hasher::value_type.\n+\n+   You can then used any of the functions in hash_table's public interface.\n+   See hash_table for details.  The interface is very similar to libiberty's\n+   htab_t.\n+\n+\n+   EASY DESCRIPTORS FOR POINTERS\n+\n+   The class template pointer_hash provides everything you need to hash\n+   pointers (as opposed to what they point to).  So, to instantiate a hash\n+   table over pointers to whatever_type,\n+\n+      hash_table <pointer_hash <whatever_type>> whatever_type_hash_table;\n+\n+*/\n \n \n #ifndef TYPED_HASHTAB_H\n@@ -53,7 +188,7 @@ xcallocator <Type>::control_alloc (size_t count)\n }\n \n \n-/* Allocate memory for COUNT data blocks.  */ \n+/* Allocate memory for COUNT data blocks.  */\n \n template <typename Type>\n inline Type *\n@@ -71,7 +206,7 @@ xcallocator <Type>::control_free (Type *memory)\n {\n   return ::free (memory);\n }\n-  \n+\n \n /* Free memory for data blocks.  */\n \n@@ -83,50 +218,71 @@ xcallocator <Type>::data_free (Type *memory)\n }\n \n \n-/* Remove method dispatching to free.  */\n+/* Helpful type for removing with free.  */\n \n-template <typename Element>\n+template <typename Type>\n struct typed_free_remove\n {\n-  static inline void remove (Element *p) { free (p); }\n+  static inline void remove (Type *p);\n };\n \n-/* No-op remove method.  */\n \n-template <typename Element>\n+/* Remove with free.  */\n+\n+template <typename Type>\n+inline void\n+typed_free_remove <Type>::remove (Type *p)\n+{\n+  free (p);\n+}\n+\n+\n+/* Helpful type for a no-op remove.  */\n+\n+template <typename Type>\n struct typed_noop_remove\n {\n-  static inline void remove (Element *) {}\n+  static inline void remove (Type *p);\n };\n \n \n+/* Remove doing nothing.  */\n+\n+template <typename Type>\n+inline void\n+typed_noop_remove <Type>::remove (Type *p ATTRIBUTE_UNUSED)\n+{\n+}\n+\n+\n /* Pointer hash with a no-op remove method.  */\n \n-template <typename Element>\n-struct pointer_hash : typed_noop_remove <Element>\n+template <typename Type>\n+struct pointer_hash : typed_noop_remove <Type>\n {\n-  typedef Element T;\n+  typedef Type value_type;\n+  typedef Type compare_type;\n \n   static inline hashval_t\n-  hash (const T *);\n+  hash (const value_type *);\n \n   static inline int\n-  equal (const T *existing, const T * candidate);\n+  equal (const value_type *existing, const compare_type *candidate);\n };\n \n-template <typename Element>\n+template <typename Type>\n inline hashval_t\n-pointer_hash<Element>::hash (const T *candidate)\n+pointer_hash <Type>::hash (const value_type *candidate)\n {\n   /* This is a really poor hash function, but it is what the current code uses,\n      so I am reusing it to avoid an additional axis in testing.  */\n   return (hashval_t) ((intptr_t)candidate >> 3);\n }\n \n-template <typename Element>\n+template <typename Type>\n inline int\n-pointer_hash<Element>::equal (const T *existing,\n-\t\t\t      const T *candidate)\n+pointer_hash <Type>::equal (const value_type *existing,\n+\t\t\t   const compare_type *candidate)\n {\n   return existing == candidate;\n }\n@@ -185,141 +341,142 @@ struct hash_table_control\n \n /* User-facing hash table type.\n \n-   The table stores elements of type Element.\n+   The table stores elements of type Descriptor::value_type.\n \n-   It hashes elements with the hash function.\n+   It hashes values with the hash member function.\n      The table currently works with relatively weak hash functions.\n-     Use typed_pointer_hash <Element> when hashing pointers instead of objects.\n+     Use typed_pointer_hash <Value> when hashing pointers instead of objects.\n \n-   It compares elements with the equal function.\n+   It compares elements with the equal member function.\n      Two elements with the same hash may not be equal.\n-     Use typed_pointer_equal <Element> when hashing pointers instead of objects.\n+     Use typed_pointer_equal <Value> when hashing pointers instead of objects.\n \n-   It removes elements with the remove function.\n+   It removes elements with the remove member function.\n      This feature is useful for freeing memory.\n-     Use typed_null_remove <Element> when not freeing objects.\n-     Use typed_free_remove <Element> when doing a simple object free.\n+     Derive from typed_null_remove <Value> when not freeing objects.\n+     Derive from typed_free_remove <Value> when doing a simple object free.\n \n-   Use the Allocator template to allocate and free memory.\n+   Specify the template Allocator to allocate and free memory.\n      The default is xcallocator.\n \n */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator = xcallocator>\n class hash_table\n {\n public:\n-  typedef typename Descr::T T;\n+  typedef typename Descriptor::value_type value_type;\n+  typedef typename Descriptor::compare_type compare_type;\n \n private:\n-  hash_table_control <T> *htab;\n+  hash_table_control <value_type> *htab;\n \n-  T **find_empty_slot_for_expand (hashval_t hash);\n+  value_type **find_empty_slot_for_expand (hashval_t hash);\n   void expand ();\n \n public:\n   hash_table ();\n   void create (size_t initial_slots);\n   bool is_created ();\n   void dispose ();\n-  T *find (const T *comparable);\n-  T *find_with_hash (const T *comparable, hashval_t hash);\n-  T **find_slot (const T *comparable, enum insert_option insert);\n-  T **find_slot_with_hash (const T *comparable, hashval_t hash,\n-\t\t\t\t   enum insert_option insert);\n+  value_type *find (const compare_type *comparable);\n+  value_type *find_with_hash (const compare_type *comparable, hashval_t hash);\n+  value_type **find_slot (const compare_type *comparable,\n+\t\t\t  enum insert_option insert);\n+  value_type **find_slot_with_hash (const compare_type *comparable,\n+\t\t\t\t    hashval_t hash, enum insert_option insert);\n   void empty ();\n-  void clear_slot (T **slot);\n-  void remove_elt (const T *comparable);\n-  void remove_elt_with_hash (const T *comparable, hashval_t hash);\n+  void clear_slot (value_type **slot);\n+  void remove_elt (const compare_type *comparable);\n+  void remove_elt_with_hash (const compare_type *comparable, hashval_t hash);\n   size_t size();\n   size_t elements();\n   double collisions();\n \n   template <typename Argument,\n-\t    int (*Callback) (T **slot, Argument argument)>\n+\t    int (*Callback) (value_type **slot, Argument argument)>\n   void traverse_noresize (Argument argument);\n \n   template <typename Argument,\n-\t    int (*Callback) (T **slot, Argument argument)>\n+\t    int (*Callback) (value_type **slot, Argument argument)>\n   void traverse (Argument argument);\n };\n \n \n /* Construct the hash table.  The only useful operation next is create.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline\n-hash_table <Descr, Allocator>::hash_table ()\n+hash_table <Descriptor, Allocator>::hash_table ()\n : htab (NULL)\n {\n }\n \n \n /* See if the table has been created, as opposed to constructed.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline bool\n-hash_table <Descr, Allocator>::is_created ()\n+hash_table <Descriptor, Allocator>::is_created ()\n {\n   return htab != NULL;\n }\n \n \n /* Like find_with_hash, but compute the hash value from the element.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n-inline typename Descr::T *\n-hash_table <Descr, Allocator>::find (const T *comparable)\n+inline typename Descriptor::value_type *\n+hash_table <Descriptor, Allocator>::find (const compare_type *comparable)\n {\n-  return find_with_hash (comparable, Descr::hash (comparable));\n+  return find_with_hash (comparable, Descriptor::hash (comparable));\n }\n \n \n /* Like find_slot_with_hash, but compute the hash value from the element.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n-inline typename Descr::T **\n-hash_table <Descr, Allocator>\n-::find_slot (const T *comparable, enum insert_option insert)\n+inline typename Descriptor::value_type **\n+hash_table <Descriptor, Allocator>\n+::find_slot (const compare_type *comparable, enum insert_option insert)\n {\n-  return find_slot_with_hash (comparable, Descr::hash (comparable), insert);\n+  return find_slot_with_hash (comparable, Descriptor::hash (comparable), insert);\n }\n \n \n /* Like remove_elt_with_hash, but compute the hash value from the element.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline void\n-hash_table <Descr, Allocator>\n-::remove_elt (const T *comparable)\n+hash_table <Descriptor, Allocator>::remove_elt (const compare_type *comparable)\n {\n-  remove_elt_with_hash (comparable, Descr::hash (comparable));\n+  remove_elt_with_hash (comparable, Descriptor::hash (comparable));\n }\n \n \n /* Return the current size of this hash table.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline size_t\n-hash_table <Descr, Allocator>::size()\n+hash_table <Descriptor, Allocator>::size()\n {\n   return htab->size;\n }\n \n \n /* Return the current number of elements in this hash table. */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline size_t\n-hash_table <Descr, Allocator>::elements()\n+hash_table <Descriptor, Allocator>::elements()\n {\n   return htab->n_elements - htab->n_deleted;\n }\n@@ -328,10 +485,10 @@ hash_table <Descr, Allocator>::elements()\n   /* Return the fraction of fixed collisions during all work with given\n      hash table. */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n inline double\n-hash_table <Descr, Allocator>::collisions()\n+hash_table <Descriptor, Allocator>::collisions()\n {\n   if (htab->searches == 0)\n     return 0.0;\n@@ -342,19 +499,19 @@ hash_table <Descr, Allocator>::collisions()\n \n /* Create a hash table with at least the given number of INITIAL_SLOTS.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Descr, Allocator>::create (size_t size)\n+hash_table <Descriptor, Allocator>::create (size_t size)\n {\n   unsigned int size_prime_index;\n \n   size_prime_index = hash_table_higher_prime_index (size);\n   size = prime_tab[size_prime_index].prime;\n \n-  htab = Allocator <hash_table_control <T> > ::control_alloc (1);\n+  htab = Allocator <hash_table_control <value_type> > ::control_alloc (1);\n   gcc_assert (htab != NULL);\n-  htab->entries = Allocator <T*> ::data_alloc (size);\n+  htab->entries = Allocator <value_type*> ::data_alloc (size);\n   gcc_assert (htab->entries != NULL);\n   htab->size = size;\n   htab->size_prime_index = size_prime_index;\n@@ -364,20 +521,20 @@ hash_table <Descr, Allocator>::create (size_t size)\n /* Dispose of a hash table.  Free all memory and return this hash table to\n    the non-created state.  Naturally the hash table must already exist.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Descr, Allocator>::dispose ()\n+hash_table <Descriptor, Allocator>::dispose ()\n {\n   size_t size = htab->size;\n-  T **entries = htab->entries;\n+  value_type **entries = htab->entries;\n \n   for (int i = size - 1; i >= 0; i--)\n     if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n-      Descr::remove (entries[i]);\n+      Descriptor::remove (entries[i]);\n \n-  Allocator <T *> ::data_free (entries);\n-  Allocator <hash_table_control <T> > ::control_free (htab);\n+  Allocator <value_type *> ::data_free (entries);\n+  Allocator <hash_table_control <value_type> > ::control_free (htab);\n   htab = NULL;\n }\n \n@@ -389,15 +546,14 @@ hash_table <Descr, Allocator>::dispose ()\n    This function also assumes there are no deleted entries in the table.\n    HASH is the hash value for the element to be inserted.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n-typename Descr::T **\n-hash_table <Descr, Allocator>\n-::find_empty_slot_for_expand (hashval_t hash)\n+typename Descriptor::value_type **\n+hash_table <Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n {\n   hashval_t index = hash_table_mod1 (hash, htab->size_prime_index);\n   size_t size = htab->size;\n-  T **slot = htab->entries + index;\n+  value_type **slot = htab->entries + index;\n   hashval_t hash2;\n \n   if (*slot == HTAB_EMPTY_ENTRY)\n@@ -428,15 +584,15 @@ ::find_empty_slot_for_expand (hashval_t hash)\n    table entries is changed.  If memory allocation fails, this function\n    will abort.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Descr, Allocator>::expand ()\n+hash_table <Descriptor, Allocator>::expand ()\n {\n-  T **oentries;\n-  T **olimit;\n-  T **p;\n-  T **nentries;\n+  value_type **oentries;\n+  value_type **olimit;\n+  value_type **p;\n+  value_type **nentries;\n   size_t nsize, osize, elts;\n   unsigned int oindex, nindex;\n \n@@ -459,7 +615,7 @@ hash_table <Descr, Allocator>::expand ()\n       nsize = osize;\n     }\n \n-  nentries = Allocator <T *> ::data_alloc (nsize);\n+  nentries = Allocator <value_type *> ::data_alloc (nsize);\n   gcc_assert (nentries != NULL);\n   htab->entries = nentries;\n   htab->size = nsize;\n@@ -470,11 +626,11 @@ hash_table <Descr, Allocator>::expand ()\n   p = oentries;\n   do\n     {\n-      T *x = *p;\n+      value_type *x = *p;\n \n       if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n         {\n-          T **q = find_empty_slot_for_expand (Descr::hash (x));\n+          value_type **q = find_empty_slot_for_expand (Descriptor::hash (x));\n \n           *q = x;\n         }\n@@ -483,31 +639,31 @@ hash_table <Descr, Allocator>::expand ()\n     }\n   while (p < olimit);\n \n-  Allocator <T *> ::data_free (oentries);\n+  Allocator <value_type *> ::data_free (oentries);\n }\n \n \n /* This function searches for a hash table entry equal to the given\n    COMPARABLE element starting with the given HASH value.  It cannot\n    be used to insert or delete an element. */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n-typename Descr::T *\n-hash_table <Descr, Allocator>\n-::find_with_hash (const T *comparable, hashval_t hash)\n+typename Descriptor::value_type *\n+hash_table <Descriptor, Allocator>\n+::find_with_hash (const compare_type *comparable, hashval_t hash)\n {\n   hashval_t index, hash2;\n   size_t size;\n-  T *entry;\n+  value_type *entry;\n \n   htab->searches++;\n   size = htab->size;\n   index = hash_table_mod1 (hash, htab->size_prime_index);\n \n   entry = htab->entries[index];\n   if (entry == HTAB_EMPTY_ENTRY\n-      || (entry != HTAB_DELETED_ENTRY && Descr::equal (entry, comparable)))\n+      || (entry != HTAB_DELETED_ENTRY && Descriptor::equal (entry, comparable)))\n     return entry;\n \n   hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n@@ -520,7 +676,8 @@ ::find_with_hash (const T *comparable, hashval_t hash)\n \n       entry = htab->entries[index];\n       if (entry == HTAB_EMPTY_ENTRY\n-          || (entry != HTAB_DELETED_ENTRY && Descr::equal (entry, comparable)))\n+          || (entry != HTAB_DELETED_ENTRY\n+\t      && Descriptor::equal (entry, comparable)))\n         return entry;\n     }\n }\n@@ -534,17 +691,17 @@ ::find_with_hash (const T *comparable, hashval_t hash)\n    write the value you want into the returned slot.  When inserting an\n    entry, NULL may be returned if memory allocation fails. */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n-typename Descr::T **\n-hash_table <Descr, Allocator>\n-::find_slot_with_hash (const T *comparable, hashval_t hash,\n+typename Descriptor::value_type **\n+hash_table <Descriptor, Allocator>\n+::find_slot_with_hash (const compare_type *comparable, hashval_t hash,\n \t\t       enum insert_option insert)\n {\n-  T **first_deleted_slot;\n+  value_type **first_deleted_slot;\n   hashval_t index, hash2;\n   size_t size;\n-  T *entry;\n+  value_type *entry;\n \n   size = htab->size;\n   if (insert == INSERT && size * 3 <= htab->n_elements * 4)\n@@ -563,17 +720,17 @@ ::find_slot_with_hash (const T *comparable, hashval_t hash,\n     goto empty_entry;\n   else if (entry == HTAB_DELETED_ENTRY)\n     first_deleted_slot = &htab->entries[index];\n-  else if (Descr::equal (entry, comparable))\n+  else if (Descriptor::equal (entry, comparable))\n     return &htab->entries[index];\n-      \n+\n   hash2 = hash_table_mod2 (hash, htab->size_prime_index);\n   for (;;)\n     {\n       htab->collisions++;\n       index += hash2;\n       if (index >= size)\n \tindex -= size;\n-      \n+\n       entry = htab->entries[index];\n       if (entry == HTAB_EMPTY_ENTRY)\n \tgoto empty_entry;\n@@ -582,7 +739,7 @@ ::find_slot_with_hash (const T *comparable, hashval_t hash,\n \t  if (!first_deleted_slot)\n \t    first_deleted_slot = &htab->entries[index];\n \t}\n-      else if (Descr::equal (entry, comparable))\n+      else if (Descriptor::equal (entry, comparable))\n \treturn &htab->entries[index];\n     }\n \n@@ -593,7 +750,7 @@ ::find_slot_with_hash (const T *comparable, hashval_t hash,\n   if (first_deleted_slot)\n     {\n       htab->n_deleted--;\n-      *first_deleted_slot = static_cast <T *> (HTAB_EMPTY_ENTRY);\n+      *first_deleted_slot = static_cast <value_type *> (HTAB_EMPTY_ENTRY);\n       return first_deleted_slot;\n     }\n \n@@ -604,32 +761,32 @@ ::find_slot_with_hash (const T *comparable, hashval_t hash,\n \n /* This function clears all entries in the given hash table.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Descr, Allocator>::empty ()\n+hash_table <Descriptor, Allocator>::empty ()\n {\n   size_t size = htab->size;\n-  T **entries = htab->entries;\n+  value_type **entries = htab->entries;\n   int i;\n \n   for (i = size - 1; i >= 0; i--)\n     if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n-      Descr::remove (entries[i]);\n+      Descriptor::remove (entries[i]);\n \n   /* Instead of clearing megabyte, downsize the table.  */\n   if (size > 1024*1024 / sizeof (PTR))\n     {\n       int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n       int nsize = prime_tab[nindex].prime;\n \n-      Allocator <T *> ::data_free (htab->entries);\n-      htab->entries = Allocator <T *> ::data_alloc (nsize);\n+      Allocator <value_type *> ::data_free (htab->entries);\n+      htab->entries = Allocator <value_type *> ::data_alloc (nsize);\n       htab->size = nsize;\n       htab->size_prime_index = nindex;\n     }\n   else\n-    memset (entries, 0, size * sizeof (T *));\n+    memset (entries, 0, size * sizeof (value_type *));\n   htab->n_deleted = 0;\n   htab->n_elements = 0;\n }\n@@ -639,19 +796,18 @@ hash_table <Descr, Allocator>::empty ()\n    useful when you've already done the lookup and don't want to do it\n    again. */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Descr, Allocator>\n-::clear_slot (T **slot)\n+hash_table <Descriptor, Allocator>::clear_slot (value_type **slot)\n {\n   if (slot < htab->entries || slot >= htab->entries + htab->size\n       || *slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n     abort ();\n \n-  Descr::remove (*slot);\n+  Descriptor::remove (*slot);\n \n-  *slot = static_cast <T *> (HTAB_DELETED_ENTRY);\n+  *slot = static_cast <value_type *> (HTAB_DELETED_ENTRY);\n   htab->n_deleted++;\n }\n \n@@ -660,21 +816,21 @@ ::clear_slot (T **slot)\n    from hash table starting with the given HASH.  If there is no\n    matching element in the hash table, this function does nothing. */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n void\n-hash_table <Descr, Allocator>\n-::remove_elt_with_hash (const T *comparable, hashval_t hash)\n+hash_table <Descriptor, Allocator>\n+::remove_elt_with_hash (const compare_type *comparable, hashval_t hash)\n {\n-  T **slot;\n+  value_type **slot;\n \n   slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n   if (*slot == HTAB_EMPTY_ENTRY)\n     return;\n \n-  Descr::remove (*slot);\n+  Descriptor::remove (*slot);\n \n-  *slot = static_cast <T *> (HTAB_DELETED_ENTRY);\n+  *slot = static_cast <value_type *> (HTAB_DELETED_ENTRY);\n   htab->n_deleted++;\n }\n \n@@ -683,23 +839,22 @@ ::remove_elt_with_hash (const T *comparable, hashval_t hash)\n    each live entry.  If CALLBACK returns false, the iteration stops.\n    ARGUMENT is passed as CALLBACK's second argument. */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n template <typename Argument,\n-\t  int (*Callback) (typename Descr::T **slot, Argument argument)>\n+\t  int (*Callback) (typename Descriptor::value_type **slot, Argument argument)>\n void\n-hash_table <Descr, Allocator>\n-::traverse_noresize (Argument argument)\n+hash_table <Descriptor, Allocator>::traverse_noresize (Argument argument)\n {\n-  T **slot;\n-  T **limit;\n+  value_type **slot;\n+  value_type **limit;\n \n   slot = htab->entries;\n   limit = slot + htab->size;\n \n   do\n     {\n-      T *x = *slot;\n+      value_type *x = *slot;\n \n       if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n         if (! Callback (slot, argument))\n@@ -712,13 +867,13 @@ ::traverse_noresize (Argument argument)\n /* Like traverse_noresize, but does resize the table when it is too empty\n    to improve effectivity of subsequent calls.  */\n \n-template <typename Descr,\n+template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n template <typename Argument,\n-\t  int (*Callback) (typename Descr::T **slot, Argument argument)>\n+\t  int (*Callback) (typename Descriptor::value_type **slot,\n+\t\t\t   Argument argument)>\n void\n-hash_table <Descr, Allocator>\n-::traverse (Argument argument)\n+hash_table <Descriptor, Allocator>::traverse (Argument argument)\n {\n   size_t size = htab->size;\n   if (elements () * 8 < size && size > 32)"}, {"sha": "6a24f78ebd442541b5d902cf95d2cd67a0e2b652", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -276,19 +276,21 @@ find_classfile (char *filename, JCF *jcf, const char *dep_name)\n \n struct charstar_hash : typed_noop_remove <char>\n {\n-  typedef const char T;\n-  static inline hashval_t hash (const T *candidate);\n-  static inline bool equal (const T *existing, const T *candidate);\n+  typedef const char value_type;\n+  typedef const char compare_type;\n+  static inline hashval_t hash (const value_type *candidate);\n+  static inline bool equal (const value_type *existing,\n+\t\t\t    const compare_type *candidate);\n };\n \n inline hashval_t\n-charstar_hash::hash (const T *candidate)\n+charstar_hash::hash (const value_type *candidate)\n {\n   return htab_hash_string (candidate);\n }\n \n inline bool\n-charstar_hash::equal (const T *existing, const T *candidate)\n+charstar_hash::equal (const value_type *existing, const compare_type *candidate)\n {\n   return strcmp (existing, candidate) == 0;\n }"}, {"sha": "ed1a28f63c45251df33bab8fb655f5b209f6d0a1", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -3827,19 +3827,20 @@ objc_get_class_ivars (tree class_name)\n \n struct decl_name_hash : typed_noop_remove <tree_node>\n {\n-  typedef tree_node T;\n-  static inline hashval_t hash (const T *);\n-  static inline bool equal (const T *, const T *);\n+  typedef tree_node value_type;\n+  typedef tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n };\n \n inline hashval_t\n-decl_name_hash::hash (const T *q)\n+decl_name_hash::hash (const value_type *q)\n {\n   return (hashval_t) ((intptr_t)(DECL_NAME (q)) >> 3);\n }\n \n inline bool\n-decl_name_hash::equal (const T *a, const T *b)\n+decl_name_hash::equal (const value_type *a, const compare_type *b)\n {\n   return DECL_NAME (a) == DECL_NAME (b);\n }"}, {"sha": "f0d66ccb5f1dea89eb89500654c0dc4863dd33cd", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -1261,9 +1261,10 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n \n struct ssa_name_var_hash : typed_noop_remove <union tree_node>\n {\n-  typedef union tree_node T;\n-  static inline hashval_t hash (const_tree);\n-  static inline int equal (const_tree, const_tree);\n+  typedef union tree_node value_type;\n+  typedef union tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline int equal (const value_type *, const compare_type *);\n };\n \n inline hashval_t\n@@ -1273,7 +1274,7 @@ ssa_name_var_hash::hash (const_tree n)\n }\n \n inline int\n-ssa_name_var_hash::equal (const_tree n1, const_tree n2)\n+ssa_name_var_hash::equal (const value_type *n1, const compare_type *n2)\n {\n   return SSA_NAME_VAR (n1) == SSA_NAME_VAR (n2);\n }"}, {"sha": "6a075984ea52a848c4d8b3226f118d2ac355376f", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -173,7 +173,8 @@ typedef struct pre_expr_d : typed_noop_remove <pre_expr_d>\n   pre_expr_union u;\n \n   /* hash_table support.  */\n-  typedef pre_expr_d T;\n+  typedef pre_expr_d value_type;\n+  typedef pre_expr_d compare_type;\n   static inline hashval_t hash (const pre_expr_d *);\n   static inline int equal (const pre_expr_d *, const pre_expr_d *);\n } *pre_expr;\n@@ -186,7 +187,7 @@ typedef struct pre_expr_d : typed_noop_remove <pre_expr_d>\n /* Compare E1 and E1 for equality.  */\n \n inline int\n-pre_expr_d::equal (const struct pre_expr_d *e1, const struct pre_expr_d *e2)\n+pre_expr_d::equal (const value_type *e1, const compare_type *e2)\n {\n   if (e1->kind != e2->kind)\n     return false;\n@@ -211,7 +212,7 @@ pre_expr_d::equal (const struct pre_expr_d *e1, const struct pre_expr_d *e2)\n /* Hash E.  */\n \n inline hashval_t\n-pre_expr_d::hash (const struct pre_expr_d *e)\n+pre_expr_d::hash (const value_type *e)\n {\n   switch (e->kind)\n     {\n@@ -499,9 +500,10 @@ typedef struct expr_pred_trans_d : typed_free_remove<expr_pred_trans_d>\n   hashval_t hashcode;\n \n   /* hash_table support.  */\n-  typedef expr_pred_trans_d T;\n-  static inline hashval_t hash (const expr_pred_trans_d *);\n-  static inline int equal (const expr_pred_trans_d *, const expr_pred_trans_d *);\n+  typedef expr_pred_trans_d value_type;\n+  typedef expr_pred_trans_d compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline int equal (const value_type *, const compare_type *);\n } *expr_pred_trans_t;\n typedef const struct expr_pred_trans_d *const_expr_pred_trans_t;\n \n@@ -512,8 +514,8 @@ expr_pred_trans_d::hash (const expr_pred_trans_d *e)\n }\n \n inline int\n-expr_pred_trans_d::equal (const expr_pred_trans_d *ve1,\n-\t\t\t  const expr_pred_trans_d *ve2)\n+expr_pred_trans_d::equal (const value_type *ve1,\n+\t\t\t  const compare_type *ve2)\n {\n   basic_block b1 = ve1->pred;\n   basic_block b2 = ve2->pred;"}, {"sha": "f9dc88064399d1ca04179ff3c4b1fc1f5a0eaa88", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -226,18 +226,19 @@ struct same_succ_def\n   hashval_t hashval;\n \n   /* hash_table support.  */\n-  typedef same_succ_def T;\n-  static inline hashval_t hash (const same_succ_def *);\n-  static int equal (const same_succ_def *, const same_succ_def *);\n-  static void remove (same_succ_def *);\n+  typedef same_succ_def value_type;\n+  typedef same_succ_def compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static int equal (const value_type *, const compare_type *);\n+  static void remove (value_type *);\n };\n typedef struct same_succ_def *same_succ;\n typedef const struct same_succ_def *const_same_succ;\n \n /* hash routine for hash_table support, returns hashval of E.  */\n \n inline hashval_t\n-same_succ_def::hash (const same_succ_def *e)\n+same_succ_def::hash (const value_type *e)\n {\n   return e->hashval;\n }\n@@ -528,7 +529,7 @@ inverse_flags (const_same_succ e1, const_same_succ e2)\n /* Compares SAME_SUCCs E1 and E2.  */\n \n int\n-same_succ_def::equal (const_same_succ e1, const_same_succ e2)\n+same_succ_def::equal (const value_type *e1, const compare_type *e2)\n {\n   unsigned int i, first1, first2;\n   gimple_stmt_iterator gsi1, gsi2;"}, {"sha": "eca88a910c1ba6680ea11df151b41751d8acf7f1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -127,20 +127,21 @@ struct redirection_data : typed_free_remove<redirection_data>\n   struct el *incoming_edges;\n \n   /* hash_table support.  */\n-  typedef redirection_data T;\n-  static inline hashval_t hash (const redirection_data *);\n-  static inline int equal (const redirection_data *, const redirection_data *);\n+  typedef redirection_data value_type;\n+  typedef redirection_data compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline int equal (const value_type *, const compare_type *);\n };\n \n inline hashval_t\n-redirection_data::hash (const redirection_data *p)\n+redirection_data::hash (const value_type *p)\n {\n   edge e = p->outgoing_edge;\n   return e->dest->index;\n }\n \n inline int\n-redirection_data::equal (const redirection_data *p1, const redirection_data *p2)\n+redirection_data::equal (const value_type *p1, const compare_type *p2)\n {\n   edge e1 = p1->outgoing_edge;\n   edge e2 = p2->outgoing_edge;"}, {"sha": "44f2d213e65ffc0d0f95da65b8ab5a319dff4281", "filename": "gcc/valtrack.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fvaltrack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca/gcc%2Fvaltrack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.h?ref=5831a5f0a8393c05a6da99f9a5995ffc7aa6b8ca", "patch": "@@ -46,32 +46,33 @@ struct dead_debug_global_entry\n struct dead_debug_hash_descr\n {\n   /* The hash table contains pointers to entries of this type.  */\n-  typedef struct dead_debug_global_entry T;\n+  typedef struct dead_debug_global_entry value_type;\n+  typedef struct dead_debug_global_entry compare_type;\n   /* Hash on the pseudo number.  */\n-  static inline hashval_t hash (T const *my);\n+  static inline hashval_t hash (const value_type *my);\n   /* Entries are identical if they refer to the same pseudo.  */\n-  static inline bool equal (T const *my, T const *other);\n+  static inline bool equal (const value_type *my, const compare_type *other);\n   /* Release entries when they're removed.  */\n-  static inline void remove (T *p);\n+  static inline void remove (value_type *p);\n };\n \n /* Hash on the pseudo number.  */\n inline hashval_t\n-dead_debug_hash_descr::hash (T const *my)\n+dead_debug_hash_descr::hash (const value_type *my)\n {\n   return REGNO (my->reg);\n }\n \n /* Entries are identical if they refer to the same pseudo.  */\n inline bool\n-dead_debug_hash_descr::equal (T const *my, T const *other)\n+dead_debug_hash_descr::equal (const value_type *my, const compare_type *other)\n {\n   return my->reg == other->reg;\n }\n \n /* Release entries when they're removed.  */\n inline void\n-dead_debug_hash_descr::remove (T *p)\n+dead_debug_hash_descr::remove (value_type *p)\n {\n   XDELETE (p);\n }"}]}