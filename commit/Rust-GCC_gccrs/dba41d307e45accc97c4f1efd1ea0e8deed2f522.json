{"sha": "dba41d307e45accc97c4f1efd1ea0e8deed2f522", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJhNDFkMzA3ZTQ1YWNjYzk3YzRmMWVmZDFlYTBlOGRlZWQyZjUyMg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-10-19T04:19:09Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-10-19T04:19:09Z"}, "message": "gjavah.c (add_class_decl): Removed unused variables `tname', `tlen' and `name_index'.\n\n2000-10-18  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* gjavah.c (add_class_decl): Removed unused variables `tname',\n\t`tlen' and `name_index'.\n\t* java-tree.h (BUILD_FILENAME_IDENTIFIER_NODE): New macro.\n\t* jcf-parse.c (jcf_parse_source): Use it and set EXPR_WFL_FILENAME\n\tin `wfl_operator' with value.\n\t(yyparse): Use BUILD_FILENAME_IDENTIFIER_NODE.\n\t(jcf_figure_file_type): Fixed identation.\n\t* lex.c (java_get_line_col): Use EOF. Tuned `^' placement.\n\t* parse.y (analyze_clinit_body): New function.\n\t(static_initializer:): Reset `current_static_block'.\n\t(java_parser_context_restore_global): Set EXPR_WFL_FIILENAME_NODE in\n\t`wfl_operator' with new value.\n\t(lookup_cl): Use EXPR_WFL_FILENAME.\n\t(maybe_yank_clinit): Handle bogus <clinit> bodies, call\n\tanalyze_clinit_body.\n\t(build_outer_field_access): Access to this$<n> built from\n\tcurrent_class, not its outer context.\n\t(build_access_to_thisn): Fixed leading comment. Tidied things up.\n\t(resolve_qualified_expression_name): Handle `T.this' and `T.this.f()'.\n\t(patch_method_invocation): Use `is_static_flag' when already\n\tinitialized.\n\t(patch_newarray): Removed assignment in ternary operator.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-10/msg00629.html)\n\nFrom-SVN: r36946", "tree": {"sha": "a8158ec2c5d37f890d042e47898a6b93ffdc3d96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8158ec2c5d37f890d042e47898a6b93ffdc3d96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dba41d307e45accc97c4f1efd1ea0e8deed2f522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba41d307e45accc97c4f1efd1ea0e8deed2f522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dba41d307e45accc97c4f1efd1ea0e8deed2f522", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba41d307e45accc97c4f1efd1ea0e8deed2f522/comments", "author": null, "committer": null, "parents": [{"sha": "0a8c4c0cd9a83f013832eeb229956ee1e13e7a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8c4c0cd9a83f013832eeb229956ee1e13e7a17"}], "stats": {"total": 221, "additions": 152, "deletions": 69}, "files": [{"sha": "ea73dc4a1c2d6f86c401d1ab5937b3a0ef016cd5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dba41d307e45accc97c4f1efd1ea0e8deed2f522", "patch": "@@ -1,6 +1,31 @@\n+2000-10-18  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* gjavah.c (add_class_decl): Removed unused variables `tname',\n+\t`tlen' and `name_index'.\n+\t* java-tree.h (BUILD_FILENAME_IDENTIFIER_NODE): New macro.\n+\t* jcf-parse.c (jcf_parse_source): Use it and set EXPR_WFL_FILENAME\n+\tin `wfl_operator' with value.\n+\t(yyparse): Use BUILD_FILENAME_IDENTIFIER_NODE.\n+\t(jcf_figure_file_type): Fixed identation.\n+\t* lex.c (java_get_line_col): Use EOF. Tuned `^' placement.\n+\t* parse.y (analyze_clinit_body): New function.\n+\t(static_initializer:): Reset `current_static_block'.\n+\t(java_parser_context_restore_global): Set EXPR_WFL_FIILENAME_NODE in\n+\t`wfl_operator' with new value.\n+\t(lookup_cl): Use EXPR_WFL_FILENAME.\n+\t(maybe_yank_clinit): Handle bogus <clinit> bodies, call\n+\tanalyze_clinit_body.\n+\t(build_outer_field_access): Access to this$<n> built from\n+\tcurrent_class, not its outer context.\n+\t(build_access_to_thisn): Fixed leading comment. Tidied things up.\n+\t(resolve_qualified_expression_name): Handle `T.this' and `T.this.f()'. \n+\t(patch_method_invocation): Use `is_static_flag' when already\n+\tinitialized.\n+\t(patch_newarray): Removed assignment in ternary operator.\n+\n 2000-10-17  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* except.c (free_eh_ranges): Don't free `whole_range.'\n+\t* except.c (free_eh_ranges): Don't free `whole_range'.\n \n 2000-10-15  Anthony Green  <green@redhat.com>\n \n@@ -157,14 +182,14 @@ Tue Oct  3 13:44:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n Wed Sep 13 16:06:52 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* decl.c (give_name_to_locals): New local `code_offset'. Call\n- \t`maybe_adjust_start_pc.'\n+ \t`maybe_adjust_start_pc'.\n \t* expr.c (note_instructions): New function.\n \t(expand_byte_code): Don't collect insn starts here.\n \t(peek_opcode_at_pc): New function.\n \t(maybe_adjust_start_pc): Likewise.\n \t* java-tree.h (maybe_adjust_start_pc): Declare.\n \t(note_instructions): Likewise.\n-\t* jcf-parse.c (parse_class_file): Call `note_instructions.'\n+\t* jcf-parse.c (parse_class_file): Call `note_instructions'.\n \n Wed Sep 13 11:50:35 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n@@ -483,10 +508,10 @@ Sun Aug 13 09:41:49 2000  Anthony Green  <green@redhat.com>\n \tof a `invokeinterface' at the right time.\n \t* parse.h (WFL_STRIP_BRACKET): New macro.\n \t(SET_TYPE_FOR_RESOLUTION): Use it.\n-\t* parse.y (build_unresolved_array_type): Reuse `type_or_wfl.'\n+\t* parse.y (build_unresolved_array_type): Reuse `type_or_wfl'.\n \t(check_class_interface_creation): Don't check for cross package\n \tinnerclass name clashes.\n-\t(method_header): Behave properly if MDECL is `error_mark_node.'\n+\t(method_header): Behave properly if MDECL is `error_mark_node'.\n \t(method_declarator): Return `error_mark_node' if bogus current\n \tclass.\n \t(resolve_class): Apply WFL_STRIP_BRACKET on `cl' if necessary.\n@@ -520,7 +545,7 @@ Sun Aug 13 09:41:49 2000  Anthony Green  <green@redhat.com>\n 2000-08-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (build_dot_class_method_invocation): Changed parameter\n-\tname to `type.' Build signature from `type' and convert it to a\n+\tname to `type'. Build signature from `type' and convert it to a\n \tSTRING_CST if it's an array.\n \t(patch_incomplete_class_ref): `build_dot_class_method_invocation'\n \tto use `ref_type' directly.\n@@ -703,7 +728,7 @@ Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \tclasses.\n \t* java-tree.h (TYPE_PROTECTED_INNER_CLASS): New macro.\n \t(CLASS_PROTECTED): Likewise.\n-\t(struct lang_type): New bitfield `poic.'\n+\t(struct lang_type): New bitfield `poic'.\n \t* parse.y (jdep_resolve_class): Call check_inner_class_access on\n \tinner classes only.\n \t(check_inner_class_access): Renamed arguments, added\n@@ -713,7 +738,7 @@ Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n 2000-07-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (resolve_qualified_expression_name): Verify qualified\n-\taccess to `this.' Fixes gcj/239.\n+\taccess to `this'. Fixes gcj/239.\n \n 2000-07-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n@@ -745,7 +770,7 @@ Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n 2000-07-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* java-tree.h (java_debug_context): Declared `extern.'\n+\t* java-tree.h (java_debug_context): Declared `extern'.\n \t(safe_layout_class): Likewise.\n \t* parse.y (resolve_field_access): Field must be `static' in order\n \tto be replaced by its initial value. Added comments.\n@@ -754,7 +779,7 @@ Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \ttake over methods founds in the enclosing contexts.\n \t(java_complete_tree): Loosen restrictions on the type of DECLs\n \tthat can be replaced by their initialization values.\n-\t(valid_ref_assignconv_cast_p): Removed call to `enclosing_context_p.'\n+\t(valid_ref_assignconv_cast_p): Removed call to `enclosing_context_p'.\n \n 2000-07-05  Tom Tromey  <tromey@cygnus.com>\n \n@@ -848,7 +873,7 @@ Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \t* class.c (set_super_info): Handle ACC_PRIVATE for (inner)\n \tclasses.\n \t* java-tree.h (TYPE_PRIVATE_INNER_CLASS): New macro.\n-\t(struct lang_type): New field `pic.'\n+\t(struct lang_type): New field `pic'.\n \t(CLASS_PRIVATE): New macro.\n \t* parse.y (check_inner_class_access): New function.\n \t(jdep_resolve_class): Call it.\n@@ -1446,7 +1471,7 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n Mon Mar 20 08:58:51 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* jcf-write.c (generate_bytecode_insns): TRY_FINALLY_EXPR:\n-\tproperly initialize `finished_label.' Don't emit gotos for empty\n+\tproperly initialize `finished_label'. Don't emit gotos for empty\n \ttry statements.\n \n 2000-03-19  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n@@ -1922,7 +1947,7 @@ Thu Feb 10 20:10:43 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n Thu Feb 10 16:04:26 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n-\t* parse.y (resolve_package): New local `acc.' Try to progressively\n+\t* parse.y (resolve_package): New local `acc'. Try to progressively\n  \tbuild and guess a package and type name.\n \n Thu Feb 10 12:52:09 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n@@ -1936,7 +1961,7 @@ Thu Feb 10 12:52:09 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n         * class.c (layout_class): Set and test CLASS_BEING_LAIDOUT.\n         Generate error message if circularity is detected. New static\n-        local `list.'\n+        local `list'.\n         * java-tree.h (CLASS_BEING_LAIDOUT): New flag usage, new macro.  *\n         * jcf-write.c (generate_bytecode_insns): Very simply handle\n         SAVE_EXPR."}, {"sha": "29cbdf82ceff129dcece40ea542cb65c58585be5", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=dba41d307e45accc97c4f1efd1ea0e8deed2f522", "patch": "@@ -1561,10 +1561,6 @@ add_class_decl (out, jcf, signature)\n   const unsigned char *s = JPOOL_UTF_DATA (jcf, signature);\n   int len = JPOOL_UTF_LENGTH (jcf, signature);\n   int i;\n-  /* Name of class we are processing.  */\n-  int name_index = JPOOL_USHORT1 (jcf, jcf->this_class);\n-  int tlen = JPOOL_UTF_LENGTH (jcf, name_index);\n-  const char *tname = JPOOL_UTF_DATA (jcf, name_index);\n \n   for (i = 0; i < len; ++i)\n     {"}, {"sha": "8196ea649618ca1293cca846b7e71ae9c050b1ea", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=dba41d307e45accc97c4f1efd1ea0e8deed2f522", "patch": "@@ -1359,6 +1359,16 @@ extern tree *type_map;\n    scope of TYPE_DECL.  */\n #define DECL_INNER_CLASS_LIST(NODE) DECL_INITIAL (NODE)\n \n+/* Build a IDENTIFIER_POINTER for a file name we're considering. We\n+   need to register the root, but we're trying to register it only\n+   once.  */\n+#define BUILD_FILENAME_IDENTIFIER_NODE(F, S)\t\\\n+  if (!((F) = maybe_get_identifier ((S))))\t\\\n+    {\t\t\t\t\t\t\\\n+      (F) = get_identifier ((S));\t\t\\\n+      ggc_mark_tree ((F));\t\t\t\\\n+    }\n+\n /* Add a FIELD_DECL to RECORD_TYPE RTYPE.\n    The field has name NAME (a char*), and type FTYPE.\n    Unless this is the first field, FIELD most hold the previous field."}, {"sha": "30fc4a4b5262828e9d4b67ce83a9e25900be167b", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=dba41d307e45accc97c4f1efd1ea0e8deed2f522", "patch": "@@ -558,8 +558,9 @@ jcf_parse_source ()\n \n   java_parser_context_save_global ();\n   java_push_parser_context ();\n+  BUILD_FILENAME_IDENTIFIER_NODE (file, current_jcf->filename);\n+  EXPR_WFL_FILENAME_NODE (wfl_operator) = file;\n   input_filename = ggc_strdup (current_jcf->filename);\n-  file = get_identifier (input_filename);\n   current_class = NULL_TREE;\n   current_function_decl = NULL_TREE;\n   if (!HAS_BEEN_ALREADY_PARSED_P (file))\n@@ -855,7 +856,7 @@ yyparse ()\n \t    }\n \t  else\n \t    {\n-\t      node = get_identifier (value);\n+\t      BUILD_FILENAME_IDENTIFIER_NODE (node, value);\n \t      IS_A_COMMAND_LINE_FILENAME_P (node) = 1;\n \t      current_file_list = tree_cons (NULL_TREE, node, \n \t\t\t\t\t     current_file_list);\n@@ -1068,7 +1069,8 @@ DEFUN(jcf_figure_file_type, (jcf),\n       && !open_in_zip (jcf, input_filename, NULL, 0))\n     {\n       localToFile = ALLOC (sizeof (struct ZipFileCache));\n-      bcopy ((PTR) SeenZipFiles, (PTR) localToFile, sizeof (struct ZipFileCache));\n+      bcopy ((PTR) SeenZipFiles, (PTR) localToFile, \n+\t     sizeof (struct ZipFileCache));\n       process_zip_dir ();\t/* Register all the class defined there */\n       return JCF_ZIP;\n     }"}, {"sha": "329d62877599fea125c99a515302e31cd2db72aa", "filename": "gcc/java/lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=dba41d307e45accc97c4f1efd1ea0e8deed2f522", "patch": "@@ -1526,7 +1526,7 @@ java_get_line_col (filename, line, col)\n   while (cline != line)\n     {\n       c = getc (fp);\n-      if (c < 0)\n+      if (c == EOF)\n \t{\n \t  static char msg[] = \"<<file too short - unexpected EOF>>\";\n \t  obstack_grow (&temporary_obstack, msg, sizeof(msg)-1);\n@@ -1563,7 +1563,7 @@ java_get_line_col (filename, line, col)\n \n   /* Place the '^' a the right position */\n   base = obstack_base (&temporary_obstack);\n-  for (ccol = 1; ccol <= col; ccol++)\n+  for (ccol = 1; ccol <= col+3; ccol++)\n     {\n       /* Compute \\t when reaching first_non_space */\n       char c = (first_non_space ?"}, {"sha": "b3c2d87cba717bf8efa39a95205621792306bec7", "filename": "gcc/java/parse.y", "status": "modified", "additions": 96, "deletions": 46, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dba41d307e45accc97c4f1efd1ea0e8deed2f522/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=dba41d307e45accc97c4f1efd1ea0e8deed2f522", "patch": "@@ -140,6 +140,7 @@ static tree obtain_incomplete_type PARAMS ((tree));\n static tree java_complete_lhs PARAMS ((tree));\n static tree java_complete_tree PARAMS ((tree));\n static tree maybe_generate_pre_expand_clinit PARAMS ((tree));\n+static int analyze_clinit_body PARAMS ((tree));\n static int maybe_yank_clinit PARAMS ((tree));\n static void java_complete_expand_method PARAMS ((tree));\n static int  unresolved_type_p PARAMS ((tree, tree *));\n@@ -1131,6 +1132,7 @@ static_initializer:\n \t\t{\n \t\t  TREE_CHAIN ($2) = CPC_STATIC_INITIALIZER_STMT (ctxp);\n \t\t  SET_CPC_STATIC_INITIALIZER_STMT (ctxp, $2);\n+\t\t  current_static_block = NULL_TREE;\n \t\t}\n ;\n \n@@ -2711,6 +2713,12 @@ java_parser_context_restore_global ()\n   lineno = ctxp->lineno;\n   current_class = ctxp->class_type;\n   input_filename = ctxp->filename;\n+  if (wfl_operator)\n+    {\n+      tree s;\n+      BUILD_FILENAME_IDENTIFIER_NODE (s, input_filename);\n+      EXPR_WFL_FILENAME_NODE (wfl_operator) = s;\n+    }\n   current_function_decl = ctxp->function_decl;\n   ctxp->saved_data = 0;\n   if (ctxp->saved_data_ctx)\n@@ -6443,7 +6451,7 @@ lookup_cl (decl)\n   EXPR_WFL_FILENAME_NODE (cl) = get_identifier (DECL_SOURCE_FILE (decl));\n   EXPR_WFL_SET_LINECOL (cl, DECL_SOURCE_LINE_FIRST (decl), -1);\n \n-  line = java_get_line_col (IDENTIFIER_POINTER (EXPR_WFL_FILENAME_NODE (cl)),\n+  line = java_get_line_col (EXPR_WFL_FILENAME (cl), \n \t\t\t    EXPR_WFL_LINENO (cl), EXPR_WFL_COLNO (cl));\n \n   found = strstr ((const char *)line, \n@@ -7583,6 +7591,42 @@ maybe_generate_pre_expand_clinit (class_type)\n   return mdecl;\n }\n \n+/* Analyzes a method body and look for something that isn't a\n+   MODIFY_EXPR. */\n+\n+static int\n+analyze_clinit_body (bbody)\n+     tree bbody;\n+{\n+  while (bbody)\n+    switch (TREE_CODE (bbody))\n+      {\n+      case BLOCK:\n+\tbbody = BLOCK_EXPR_BODY (bbody);\n+\tbreak;\n+\t\n+      case EXPR_WITH_FILE_LOCATION:\n+\tbbody = EXPR_WFL_NODE (bbody);\n+\tbreak;\n+\t\n+      case COMPOUND_EXPR:\n+\tif (analyze_clinit_body (TREE_OPERAND (bbody, 0)))\n+\t  return 1;\n+\tbbody = TREE_OPERAND (bbody, 1);\n+\tbreak;\n+\t\n+      case MODIFY_EXPR:\n+\tbbody = NULL_TREE;\n+\tbreak;\n+\n+      default:\n+\tbbody = NULL_TREE;\n+\treturn 1;\n+      }\n+  return 0;\n+}\n+\n+\n /* See whether we could get rid of <clinit>. Criteria are: all static\n    final fields have constant initial values and the body of <clinit>\n    is empty. Return 1 if <clinit> was discarded, 0 otherwise. */\n@@ -7602,8 +7646,11 @@ maybe_yank_clinit (mdecl)\n      we're emitting classfiles, this isn't enough not to rule it\n      out. */\n   fbody = DECL_FUNCTION_BODY (mdecl);\n-  if ((bbody = BLOCK_EXPR_BODY (fbody)))\n+  bbody = BLOCK_EXPR_BODY (fbody);\n+  if (bbody && bbody != error_mark_node)\n     bbody = BLOCK_EXPR_BODY (bbody);\n+  else\n+    return 0;\n   if (bbody && ! flag_emit_class_files && bbody != empty_stmt_node)\n     return 0;\n   \n@@ -7644,30 +7691,9 @@ maybe_yank_clinit (mdecl)\n   /* Now we analyze the method body and look for something that\n      isn't a MODIFY_EXPR */\n   if (bbody == empty_stmt_node)\n-    bbody = NULL_TREE;\n-  while (bbody)\n-    switch (TREE_CODE (bbody))\n-      {\n-      case BLOCK:\n-\tbbody = BLOCK_EXPR_BODY (bbody);\n-\tbreak;\n-\t\n-      case EXPR_WITH_FILE_LOCATION:\n-\tbbody = EXPR_WFL_NODE (bbody);\n-\tbreak;\n-\t\n-      case COMPOUND_EXPR:\n-\tbbody = TREE_OPERAND (bbody, 0);\n-\tbreak;\n-\t\n-      case MODIFY_EXPR:\n-\tbbody = NULL_TREE;\n-\tbreak;\n-\n-      default:\n-\tbbody = NULL_TREE;\n-\tfound = 1;\n-      }\n+    found = 0;\n+  else\n+    found = analyze_clinit_body (bbody);\n \n   if (current || found)\n     return 0;\n@@ -7808,7 +7834,7 @@ build_outer_field_access (id, decl)\n       /* Now we chain the required number of calls to the access$0 to\n \t get a hold to the enclosing instance we need, and then we\n \t build the field access. */\n-      access = build_access_to_thisn (ctx, DECL_CONTEXT (decl), lc);\n+      access = build_access_to_thisn (current_class, DECL_CONTEXT (decl), lc);\n \n       /* If the field is private and we're generating bytecode, then\n          we generate an access method */\n@@ -8135,9 +8161,11 @@ build_outer_method_access_method (decl)\n    kept in a generated field called this$<n>, with <n> being the\n    inner class nesting level (starting from 0.)  */\n     \n-/* Build an access to a given this$<n>, possibly by chaining access\n-   call to others. Access methods to this$<n> are build on the fly if\n-   necessary */\n+/* Build an access to a given this$<n>, always chaining access call to\n+   others. Access methods to this$<n> are build on the fly if\n+   necessary. This CAN'T be used to solely access this$<n-1> from\n+   this$<n> (which alway yield to special cases and optimization, see\n+   for example build_outer_field_access).  */\n \n static tree\n build_access_to_thisn (from, to, lc)\n@@ -8148,21 +8176,23 @@ build_access_to_thisn (from, to, lc)\n \n   while (from != to)\n     {\n-      tree access0_wfl, cn;\n-\n-      maybe_build_thisn_access_method (from);\n-      access0_wfl = build_wfl_node (access0_identifier_node);\n-      cn = build_wfl_node (DECL_NAME (TYPE_NAME (from)));\n-      EXPR_WFL_LINECOL (access0_wfl) = lc;\n-      \n       if (!access)\n+        {\n+          access = build_current_thisn (from);\n+          access = build_wfl_node (access);\n+        }\n+      else\n \t{\n-\t  access = build_current_thisn (current_class);\n-\t  access = build_wfl_node (access);\n+\t  tree access0_wfl, cn;\n+\n+\t  maybe_build_thisn_access_method (from);\n+\t  access0_wfl = build_wfl_node (access0_identifier_node);\n+\t  cn = build_wfl_node (DECL_NAME (TYPE_NAME (from)));\n+\t  EXPR_WFL_LINECOL (access0_wfl) = lc;\n+\t  access = build_tree_list (NULL_TREE, access);\n+\t  access = build_method_invocation (access0_wfl, access);\n+\t  access = make_qualified_primary (cn, access, lc);\n \t}\n-      access = build_tree_list (NULL_TREE, access);\n-      access = build_method_invocation (access0_wfl, access);\n-      access = make_qualified_primary (cn, access, lc);\n       \n       from = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (from)));\n     }\n@@ -9014,10 +9044,21 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t     saved and restored shortly after */\n \t  saved_current = current_class;\n \t  saved_this = current_this;\n-\t  if (decl && TREE_CODE (qual_wfl) == NEW_CLASS_EXPR)\n+\t  if (decl \n+\t      && (TREE_CODE (qual_wfl) == NEW_CLASS_EXPR\n+\t\t  || from_qualified_this))\n \t    {\n+\t      /* If we still have `from_qualified_this', we have the form\n+\t\t <T>.this.f() and we need to build <T>.this */\n+\t      if (from_qualified_this)\n+\t\t{\n+\t\t  decl = build_access_to_thisn (current_class, type, 0);\n+\t\t  decl = java_complete_tree (decl);\n+\t\t  type = TREE_TYPE (TREE_TYPE (decl));\n+\t\t}\n \t      current_class = type;\n \t      current_this = decl;\n+\t      from_qualified_this = 0;\n \t    }\n \n \t  if (from_super && TREE_CODE (qual_wfl) == CALL_EXPR)\n@@ -9174,8 +9215,17 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t  free (p);\n \t\t  return 1;\n \t\t}\n-\t      *where_found = decl = build_current_thisn (type);\n \t      from_qualified_this = 1;\n+\t      /* If there's nothing else after that, we need to\n+                 produce something now, otherwise, the section of the\n+                 code that needs to produce <T>.this will generate\n+                 what is necessary. */\n+\t      if (!TREE_CHAIN (q))\n+\t\t{\n+\t\t  decl = build_access_to_thisn (current_class, type, 0);\n+\t\t  *where_found = decl = java_complete_tree (decl);\n+\t\t  *type_found = type = TREE_TYPE (decl);\n+\t\t}\n \t    }\n \n \t  from_type = 0;\n@@ -9925,7 +9975,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n     }\n \n   is_static_flag = METHOD_STATIC (list);\n-  if (! METHOD_STATIC (list) && this_arg != NULL_TREE)\n+  if (! is_static_flag && this_arg != NULL_TREE)\n     args = tree_cons (NULL_TREE, this_arg, args);\n \n   /* In the context of an explicit constructor invocation, we can't\n@@ -13748,7 +13798,7 @@ patch_newarray (node)\n       tree dim = TREE_VALUE (cdim);\n \n       /* Dim might have been saved during its evaluation */\n-      dim = (TREE_CODE (dim) == SAVE_EXPR ? dim = TREE_OPERAND (dim, 0) : dim);\n+      dim = (TREE_CODE (dim) == SAVE_EXPR ? TREE_OPERAND (dim, 0) : dim);\n \n       /* The type of each specified dimension must be an integral type. */\n       if (!JINTEGRAL_TYPE_P (TREE_TYPE (dim)))"}]}