{"sha": "3928c098e48c1066da265b0c840be1cc38e17b3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkyOGMwOThlNDhjMTA2NmRhMjY1YjBjODQwYmUxY2MzOGUxN2IzZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-18T11:11:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-18T11:11:32Z"}, "message": "tree-vrp.c (extract_range_from_assert): Split out range intersecting code.\n\n2012-06-18  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vrp.c (extract_range_from_assert): Split out range\n\tintersecting code.\n\t(intersect_ranges): New function.\n\t(vrp_intersect_ranges): Likewise.\n\nFrom-SVN: r188728", "tree": {"sha": "1eb8412c6b9a6243e4471bf3b1a5914bc855c1d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eb8412c6b9a6243e4471bf3b1a5914bc855c1d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3928c098e48c1066da265b0c840be1cc38e17b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3928c098e48c1066da265b0c840be1cc38e17b3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3928c098e48c1066da265b0c840be1cc38e17b3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3928c098e48c1066da265b0c840be1cc38e17b3e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ab4a745bd9a687e96f4ce604063fb96f6940e770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab4a745bd9a687e96f4ce604063fb96f6940e770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab4a745bd9a687e96f4ce604063fb96f6940e770"}], "stats": {"total": 476, "additions": 243, "deletions": 233}, "files": [{"sha": "3e3a8993b15ad1aca7edefed17a3e1aa3ac87954", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3928c098e48c1066da265b0c840be1cc38e17b3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3928c098e48c1066da265b0c840be1cc38e17b3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3928c098e48c1066da265b0c840be1cc38e17b3e", "patch": "@@ -1,3 +1,10 @@\n+2012-06-18  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (extract_range_from_assert): Split out range\n+\tintersecting code.\n+\t(intersect_ranges): New function.\n+\t(vrp_intersect_ranges): Likewise.\n+\n 2012-06-18  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/s390.c (s390_gimplify_va_arg): Revert change from"}, {"sha": "114755220bdf8ce354fa99d1733d5f4a5ccff8bc", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 236, "deletions": 233, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3928c098e48c1066da265b0c840be1cc38e17b3e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3928c098e48c1066da265b0c840be1cc38e17b3e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=3928c098e48c1066da265b0c840be1cc38e17b3e", "patch": "@@ -95,6 +95,7 @@ live_on_edge (edge e, tree name)\n static int compare_values (tree val1, tree val2);\n static int compare_values_warnv (tree val1, tree val2, bool *);\n static void vrp_meet (value_range_t *, value_range_t *);\n+static void vrp_intersect_ranges (value_range_t *, value_range_t *);\n static tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n \t\t\t\t\t\t     tree, tree, bool, bool *,\n \t\t\t\t\t\t     bool *);\n@@ -1515,7 +1516,7 @@ static void\n extract_range_from_assert (value_range_t *vr_p, tree expr)\n {\n   tree var, cond, limit, min, max, type;\n-  value_range_t *var_vr, *limit_vr;\n+  value_range_t *limit_vr;\n   enum tree_code cond_code;\n \n   var = ASSERT_EXPR_VAR (expr);\n@@ -1777,238 +1778,8 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n   else\n     gcc_unreachable ();\n \n-  /* If VAR already had a known range, it may happen that the new\n-     range we have computed and VAR's range are not compatible.  For\n-     instance,\n-\n-\tif (p_5 == NULL)\n-\t  p_6 = ASSERT_EXPR <p_5, p_5 == NULL>;\n-\t  x_7 = p_6->fld;\n-\t  p_8 = ASSERT_EXPR <p_6, p_6 != NULL>;\n-\n-     While the above comes from a faulty program, it will cause an ICE\n-     later because p_8 and p_6 will have incompatible ranges and at\n-     the same time will be considered equivalent.  A similar situation\n-     would arise from\n-\n-     \tif (i_5 > 10)\n-\t  i_6 = ASSERT_EXPR <i_5, i_5 > 10>;\n-\t  if (i_5 < 5)\n-\t    i_7 = ASSERT_EXPR <i_6, i_6 < 5>;\n-\n-     Again i_6 and i_7 will have incompatible ranges.  It would be\n-     pointless to try and do anything with i_7's range because\n-     anything dominated by 'if (i_5 < 5)' will be optimized away.\n-     Note, due to the wa in which simulation proceeds, the statement\n-     i_7 = ASSERT_EXPR <...> we would never be visited because the\n-     conditional 'if (i_5 < 5)' always evaluates to false.  However,\n-     this extra check does not hurt and may protect against future\n-     changes to VRP that may get into a situation similar to the\n-     NULL pointer dereference example.\n-\n-     Note that these compatibility tests are only needed when dealing\n-     with ranges or a mix of range and anti-range.  If VAR_VR and VR_P\n-     are both anti-ranges, they will always be compatible, because two\n-     anti-ranges will always have a non-empty intersection.  */\n-\n-  var_vr = get_value_range (var);\n-\n-  /* We may need to make adjustments when VR_P and VAR_VR are numeric\n-     ranges or anti-ranges.  */\n-  if (vr_p->type == VR_VARYING\n-      || vr_p->type == VR_UNDEFINED\n-      || var_vr->type == VR_VARYING\n-      || var_vr->type == VR_UNDEFINED\n-      || symbolic_range_p (vr_p)\n-      || symbolic_range_p (var_vr))\n-    return;\n-\n-  if (var_vr->type == VR_RANGE && vr_p->type == VR_RANGE)\n-    {\n-      /* If the two ranges have a non-empty intersection, we can\n-\t refine the resulting range.  Since the assert expression\n-\t creates an equivalency and at the same time it asserts a\n-\t predicate, we can take the intersection of the two ranges to\n-\t get better precision.  */\n-      if (value_ranges_intersect_p (var_vr, vr_p))\n-\t{\n-\t  /* Use the larger of the two minimums.  */\n-\t  if (compare_values (vr_p->min, var_vr->min) == -1)\n-\t    min = var_vr->min;\n-\t  else\n-\t    min = vr_p->min;\n-\n-\t  /* Use the smaller of the two maximums.  */\n-\t  if (compare_values (vr_p->max, var_vr->max) == 1)\n-\t    max = var_vr->max;\n-\t  else\n-\t    max = vr_p->max;\n-\n-\t  set_value_range (vr_p, vr_p->type, min, max, vr_p->equiv);\n-\t}\n-      else\n-\t{\n-\t  /* The two ranges do not intersect, set the new range to\n-\t     VARYING, because we will not be able to do anything\n-\t     meaningful with it.  */\n-\t  set_value_range_to_varying (vr_p);\n-\t}\n-    }\n-  else if ((var_vr->type == VR_RANGE && vr_p->type == VR_ANTI_RANGE)\n-           || (var_vr->type == VR_ANTI_RANGE && vr_p->type == VR_RANGE))\n-    {\n-      /* A range and an anti-range will cancel each other only if\n-\t their ends are the same.  For instance, in the example above,\n-\t p_8's range ~[0, 0] and p_6's range [0, 0] are incompatible,\n-\t so VR_P should be set to VR_VARYING.  */\n-      if (compare_values (var_vr->min, vr_p->min) == 0\n-\t  && compare_values (var_vr->max, vr_p->max) == 0)\n-\tset_value_range_to_varying (vr_p);\n-      else\n-\t{\n-\t  tree min, max, anti_min, anti_max, real_min, real_max;\n-\t  int cmp;\n-\n-\t  /* We want to compute the logical AND of the two ranges;\n-\t     there are three cases to consider.\n-\n-\n-\t     1. The VR_ANTI_RANGE range is completely within the\n-\t\tVR_RANGE and the endpoints of the ranges are\n-\t\tdifferent.  In that case the resulting range\n-\t\tshould be whichever range is more precise.\n-\t\tTypically that will be the VR_RANGE.\n-\n-\t     2. The VR_ANTI_RANGE is completely disjoint from\n-\t\tthe VR_RANGE.  In this case the resulting range\n-\t\tshould be the VR_RANGE.\n-\n-\t     3. There is some overlap between the VR_ANTI_RANGE\n-\t\tand the VR_RANGE.\n-\n-\t\t3a. If the high limit of the VR_ANTI_RANGE resides\n-\t\t    within the VR_RANGE, then the result is a new\n-\t\t    VR_RANGE starting at the high limit of the\n-\t\t    VR_ANTI_RANGE + 1 and extending to the\n-\t\t    high limit of the original VR_RANGE.\n-\n-\t\t3b. If the low limit of the VR_ANTI_RANGE resides\n-\t\t    within the VR_RANGE, then the result is a new\n-\t\t    VR_RANGE starting at the low limit of the original\n-\t\t    VR_RANGE and extending to the low limit of the\n-\t\t    VR_ANTI_RANGE - 1.  */\n-\t  if (vr_p->type == VR_ANTI_RANGE)\n-\t    {\n-\t      anti_min = vr_p->min;\n-\t      anti_max = vr_p->max;\n-\t      real_min = var_vr->min;\n-\t      real_max = var_vr->max;\n-\t    }\n-\t  else\n-\t    {\n-\t      anti_min = var_vr->min;\n-\t      anti_max = var_vr->max;\n-\t      real_min = vr_p->min;\n-\t      real_max = vr_p->max;\n-\t    }\n-\n-\n-\t  /* Case 1, VR_ANTI_RANGE completely within VR_RANGE,\n-\t     not including any endpoints.  */\n-\t  if (compare_values (anti_max, real_max) == -1\n-\t      && compare_values (anti_min, real_min) == 1)\n-\t    {\n-\t      /* If the range is covering the whole valid range of\n-\t\t the type keep the anti-range.  */\n-\t      if (!vrp_val_is_min (real_min)\n-\t\t  || !vrp_val_is_max (real_max))\n-\t        set_value_range (vr_p, VR_RANGE, real_min,\n-\t\t\t\t real_max, vr_p->equiv);\n-\t    }\n-\t  /* Case 2, VR_ANTI_RANGE completely disjoint from\n-\t     VR_RANGE.  */\n-\t  else if (compare_values (anti_min, real_max) == 1\n-\t\t   || compare_values (anti_max, real_min) == -1)\n-\t    {\n-\t      set_value_range (vr_p, VR_RANGE, real_min,\n-\t\t\t       real_max, vr_p->equiv);\n-\t    }\n-\t  /* Case 3a, the anti-range extends into the low\n-\t     part of the real range.  Thus creating a new\n-\t     low for the real range.  */\n-\t  else if (((cmp = compare_values (anti_max, real_min)) == 1\n-\t\t    || cmp == 0)\n-\t\t   && compare_values (anti_max, real_max) == -1)\n-\t    {\n-\t      gcc_assert (!is_positive_overflow_infinity (anti_max));\n-\t      if (needs_overflow_infinity (TREE_TYPE (anti_max))\n-\t\t  && vrp_val_is_max (anti_max))\n-\t\t{\n-\t\t  if (!supports_overflow_infinity (TREE_TYPE (var_vr->min)))\n-\t\t    {\n-\t\t      set_value_range_to_varying (vr_p);\n-\t\t      return;\n-\t\t    }\n-\t\t  min = positive_overflow_infinity (TREE_TYPE (var_vr->min));\n-\t\t}\n-\t      else if (!POINTER_TYPE_P (TREE_TYPE (var_vr->min)))\n-\t\t{\n-\t\t  if (TYPE_PRECISION (TREE_TYPE (var_vr->min)) == 1\n-\t\t      && !TYPE_UNSIGNED (TREE_TYPE (var_vr->min)))\n-\t\t    min = fold_build2 (MINUS_EXPR, TREE_TYPE (var_vr->min),\n-\t\t\t\t       anti_max,\n-\t\t\t\t       build_int_cst (TREE_TYPE (var_vr->min),\n-\t\t\t\t\t\t      -1));\n-\t\t  else\n-\t\t    min = fold_build2 (PLUS_EXPR, TREE_TYPE (var_vr->min),\n-\t\t\t\t       anti_max,\n-\t\t\t\t       build_int_cst (TREE_TYPE (var_vr->min),\n-\t\t\t\t\t\t      1));\n-\t\t}\n-\t      else\n-\t\tmin = fold_build_pointer_plus_hwi (anti_max, 1);\n-\t      max = real_max;\n-\t      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n-\t    }\n-\t  /* Case 3b, the anti-range extends into the high\n-\t     part of the real range.  Thus creating a new\n-\t     higher for the real range.  */\n-\t  else if (compare_values (anti_min, real_min) == 1\n-\t\t   && ((cmp = compare_values (anti_min, real_max)) == -1\n-\t\t       || cmp == 0))\n-\t    {\n-\t      gcc_assert (!is_negative_overflow_infinity (anti_min));\n-\t      if (needs_overflow_infinity (TREE_TYPE (anti_min))\n-\t\t  && vrp_val_is_min (anti_min))\n-\t\t{\n-\t\t  if (!supports_overflow_infinity (TREE_TYPE (var_vr->min)))\n-\t\t    {\n-\t\t      set_value_range_to_varying (vr_p);\n-\t\t      return;\n-\t\t    }\n-\t\t  max = negative_overflow_infinity (TREE_TYPE (var_vr->min));\n-\t\t}\n-\t      else if (!POINTER_TYPE_P (TREE_TYPE (var_vr->min)))\n-\t\t{\n-\t\t  if (TYPE_PRECISION (TREE_TYPE (var_vr->min)) == 1\n-\t\t      && !TYPE_UNSIGNED (TREE_TYPE (var_vr->min)))\n-\t\t    max = fold_build2 (PLUS_EXPR, TREE_TYPE (var_vr->min),\n-\t\t\t\t       anti_min,\n-\t\t\t\t       build_int_cst (TREE_TYPE (var_vr->min),\n-\t\t\t\t\t\t      -1));\n-\t\t  else\n-\t\t    max = fold_build2 (MINUS_EXPR, TREE_TYPE (var_vr->min),\n-\t\t\t\t       anti_min,\n-\t\t\t\t       build_int_cst (TREE_TYPE (var_vr->min),\n-\t\t\t\t\t\t      1));\n-\t\t}\n-\t      else\n-\t\tmax = fold_build_pointer_plus_hwi (anti_min, -1);\n-\t      min = real_min;\n-\t      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n-\t    }\n-\t}\n-    }\n+  /* Finally intersect the new range with what we already know about var.  */\n+  vrp_intersect_ranges (vr_p, get_value_range (var));\n }\n \n \n@@ -6999,6 +6770,238 @@ vrp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n   return SSA_PROP_VARYING;\n }\n \n+/* Intersect the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and\n+   { VR1TYPE, VR0MIN, VR0MAX } and store the result\n+   in { *VR0TYPE, *VR0MIN, *VR0MAX }.  This may not be the smallest\n+   possible such range.  The resulting range is not canonicalized.  */\n+\n+static void\n+intersect_ranges (enum value_range_type *vr0type,\n+\t\t  tree *vr0min, tree *vr0max,\n+\t\t  enum value_range_type vr1type,\n+\t\t  tree vr1min, tree vr1max)\n+{\n+  /* [] is vr0, () is vr1 in the following classification comments.  */\n+  if (operand_less_p (*vr0max, vr1min) == 1\n+      || operand_less_p (vr1max, *vr0min) == 1)\n+    {\n+      /* [ ] ( ) or ( ) [ ]\n+\t If the ranges have an empty intersection, the result of the\n+\t intersect operation is the range for intersecting an\n+\t anti-range with a range or empty when intersecting two ranges.\n+\t For intersecting two anti-ranges simply choose vr0.  */\n+      if (*vr0type == VR_RANGE\n+\t  && vr1type == VR_ANTI_RANGE)\n+\t;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = VR_UNDEFINED;\n+\t  *vr0min = NULL_TREE;\n+\t  *vr0max = NULL_TREE;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  /* Take VR0.  */\n+\t}\n+    }\n+  else if (operand_less_p (vr1max, *vr0max) == 1\n+\t   && operand_less_p (*vr0min, vr1min) == 1)\n+    {\n+      /* [ (  ) ]  */\n+      if (*vr0type == VR_RANGE)\n+\t{\n+\t  /* If the outer is a range choose the inner one.\n+\t     ???  If the inner is an anti-range this arbitrarily chooses\n+\t     the anti-range.  */\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t/* If both are anti-ranges the result is the outer one.  */\n+\t;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  /* The intersection is empty.  */\n+\t  *vr0type = VR_UNDEFINED;\n+\t  *vr0min = NULL_TREE;\n+\t  *vr0max = NULL_TREE;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if (operand_less_p (*vr0max, vr1max) == 1\n+\t   && operand_less_p (vr1min, *vr0min) == 1)\n+    {\n+      /* ( [  ] )  */\n+      if (vr1type == VR_RANGE)\n+\t/* If the outer is a range, choose the inner one.\n+\t   ???  If the inner is an anti-range this arbitrarily chooses\n+\t   the anti-range.  */\n+\t;\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  /* If both are anti-ranges the result is the outer one.  */\n+\t  *vr0type = vr1type;\n+\t  *vr0min = vr1min;\n+\t  *vr0max = vr1max;\n+\t}\n+      else if (vr1type == VR_ANTI_RANGE\n+\t       && *vr0type == VR_RANGE)\n+\t{\n+\t  /* The intersection is empty.  */\n+\t  *vr0type = VR_UNDEFINED;\n+\t  *vr0min = NULL_TREE;\n+\t  *vr0max = NULL_TREE;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if ((operand_less_p (vr1min, *vr0max) == 1\n+\t    || operand_equal_p (vr1min, *vr0max, 0))\n+\t   && (operand_less_p (*vr0min, vr1min) == 1\n+\t       || operand_equal_p (*vr0min, vr1min, 0)))\n+    {\n+      /* [  (  ]  ) */\n+      if (*vr0type == VR_ANTI_RANGE\n+\t  && vr1type == VR_ANTI_RANGE)\n+\t*vr0max = vr1max;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t*vr0min = vr1min;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  if (TREE_CODE (vr1min) == INTEGER_CST)\n+\t    *vr0max = int_const_binop (MINUS_EXPR, vr1min,\n+\t\t\t\t       integer_one_node);\n+\t  else\n+\t    *vr0max = vr1min;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = VR_RANGE;\n+\t  if (TREE_CODE (*vr0max) == INTEGER_CST)\n+\t    *vr0min = int_const_binop (PLUS_EXPR, *vr0max,\n+\t\t\t\t       integer_one_node);\n+\t  else\n+\t    *vr0min = *vr0max;\n+\t  *vr0max = vr1max;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  else if ((operand_less_p (*vr0min, vr1max) == 1\n+\t    || operand_equal_p (*vr0min, vr1max, 0))\n+\t   && (operand_less_p (vr1min, *vr0min) == 1\n+\t       || operand_equal_p (vr1min, *vr0min, 0)))\n+    {\n+      /* (  [  )  ] */\n+      if (*vr0type == VR_ANTI_RANGE\n+\t  && vr1type == VR_ANTI_RANGE)\n+\t*vr0min = vr1min;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t*vr0max = vr1max;\n+      else if (*vr0type == VR_RANGE\n+\t       && vr1type == VR_ANTI_RANGE)\n+\t{\n+\t  if (TREE_CODE (vr1max) == INTEGER_CST)\n+\t    *vr0min = int_const_binop (PLUS_EXPR, vr1max,\n+\t\t\t\t       integer_one_node);\n+\t  else\n+\t    *vr0min = vr1max;\n+\t}\n+      else if (*vr0type == VR_ANTI_RANGE\n+\t       && vr1type == VR_RANGE)\n+\t{\n+\t  *vr0type = VR_RANGE;\n+\t  if (TREE_CODE (*vr0min) == INTEGER_CST)\n+\t    *vr0max = int_const_binop (MINUS_EXPR, *vr0min,\n+\t\t\t\t       integer_one_node);\n+\t  else\n+\t    *vr0max = *vr0min;\n+\t  *vr0min = vr1min;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  /* As a fallback simply use { *VRTYPE, *VR0MIN, *VR0MAX } as\n+     result for the intersection.  That's always a conservative\n+     correct estimate.  */\n+\n+  return;\n+}\n+\n+\n+/* Intersect the two value-ranges *VR0 and *VR1 and store the result\n+   in *VR0.  This may not be the smallest possible such range.  */\n+\n+static void\n+vrp_intersect_ranges (value_range_t *vr0, value_range_t *vr1)\n+{\n+  value_range_t saved;\n+\n+  /* If either range is VR_VARYING the other one wins.  */\n+  if (vr1->type == VR_VARYING)\n+    return;\n+  if (vr0->type == VR_VARYING)\n+    {\n+      copy_value_range (vr0, vr1);\n+      return;\n+    }\n+\n+  /* When either range is VR_UNDEFINED the resulting range is\n+     VR_UNDEFINED, too.  */\n+  if (vr0->type == VR_UNDEFINED)\n+    return;\n+  if (vr1->type == VR_UNDEFINED)\n+    {\n+      set_value_range_to_undefined (vr0);\n+      return;\n+    }\n+\n+  /* Save the original vr0 so we can return it as conservative intersection\n+     result when our worker turns things to varying.  */\n+  saved = *vr0;\n+  intersect_ranges (&vr0->type, &vr0->min, &vr0->max,\n+\t\t    vr1->type, vr1->min, vr1->max);\n+  /* Make sure to canonicalize the result though as the inversion of a\n+     VR_RANGE can still be a VR_RANGE.  */\n+  set_and_canonicalize_value_range (vr0, vr0->type,\n+\t\t\t\t    vr0->min, vr0->max, vr0->equiv);\n+  /* If that failed, use the saved original VR0.  */\n+  if (vr0->type == VR_VARYING)\n+    {\n+      *vr0 = saved;\n+      return;\n+    }\n+  /* If the result is VR_UNDEFINED there is no need to mess with\n+     the equivalencies.  */\n+  if (vr0->type == VR_UNDEFINED)\n+    return;\n+\n+  /* The resulting set of equivalences for range intersection is the union of\n+     the two sets.  */\n+  if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n+    bitmap_ior_into (vr0->equiv, vr1->equiv);\n+  else if (vr1->equiv && !vr0->equiv)\n+    bitmap_copy (vr0->equiv, vr1->equiv);\n+}\n \n /* Meet operation for value ranges.  Given two value ranges VR0 and\n    VR1, store in VR0 a range that contains both VR0 and VR1.  This"}]}