{"sha": "dd61aa98caa43a54970c2a4eecf9c4e3f325d14e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ2MWFhOThjYWE0M2E1NDk3MGMyYTRlZWNmOWM0ZTNmMzI1ZDE0ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-08-17T19:24:09Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-08-17T19:24:09Z"}, "message": "simplify-rtx.c (associative_constant_p): New function to test whether an RTX expression is an immediate constant.\n\n\n\t* simplify-rtx.c (associative_constant_p): New function to test\n\twhether an RTX expression is an immediate constant.\n\t(simplify_associative_operation): New function to perform some\n\treassociation optimizations of associative binary expressions.\n\t(simplify_binary_operation): Use simplify_associative_operation\n\tto simplify PLUS, MULT, AND, IOR, XOR, SMIN, SMAX, UMIN and UMAX.\n\tFloating point expressions are only reassociated when unsafe\n\tmath optimizations are permitted.\n\nFrom-SVN: r70521", "tree": {"sha": "2aba6d2eebdcd078750a157d135eb00b220790dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aba6d2eebdcd078750a157d135eb00b220790dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e/comments", "author": null, "committer": null, "parents": [{"sha": "fde46628fa4b368217a182e8885475fe5279cc2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde46628fa4b368217a182e8885475fe5279cc2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fde46628fa4b368217a182e8885475fe5279cc2e"}], "stats": {"total": 135, "additions": 129, "deletions": 6}, "files": [{"sha": "a0055d88476418e71458f840b5817199f2ae7361", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd61aa98caa43a54970c2a4eecf9c4e3f325d14e", "patch": "@@ -1,3 +1,14 @@\n+2003-08-17  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* simplify-rtx.c (associative_constant_p): New function to test\n+\twhether an RTX expression is an immediate constant.\n+\t(simplify_associative_operation): New function to perform some\n+\treassociation optimizations of associative binary expressions.\n+\t(simplify_binary_operation): Use simplify_associative_operation\n+\tto simplify PLUS, MULT, AND, IOR, XOR, SMIN, SMAX, UMIN and UMAX.\n+\tFloating point expressions are only reassociated when unsafe\n+\tmath optimizations are permitted.\n+\n 2003-08-17  Andreas Jaeger  <aj@suse.de>\n \n \t* config/alpha/alpha.md: Remove usage of PARAMS."}, {"sha": "a5903ad9d7e40c9ea91407a15b9ea43d7e54f657", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 118, "deletions": 6, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd61aa98caa43a54970c2a4eecf9c4e3f325d14e/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=dd61aa98caa43a54970c2a4eecf9c4e3f325d14e", "patch": "@@ -53,6 +53,9 @@ static rtx neg_const_int (enum machine_mode, rtx);\n static int simplify_plus_minus_op_data_cmp (const void *, const void *);\n static rtx simplify_plus_minus (enum rtx_code, enum machine_mode, rtx,\n \t\t\t\trtx, int);\n+static bool associative_constant_p (rtx);\n+static rtx simplify_associative_operation (enum rtx_code, enum machine_mode,\n+\t\t\t\t\t   rtx, rtx);\n \f\n /* Negate a CONST_INT rtx, truncating (because a conversion from a\n    maximally negative number can overflow).  */\n@@ -854,6 +857,72 @@ simplify_unary_operation (enum rtx_code code, enum machine_mode mode,\n     }\n }\n \f\n+/* Subroutine of simplify_associative_operation.  Return true if rtx OP\n+   is a suitable integer or floating point immediate constant.  */\n+static bool\n+associative_constant_p (rtx op)\n+{\n+  if (GET_CODE (op) == CONST_INT\n+      || GET_CODE (op) == CONST_DOUBLE)\n+    return true;\n+  op = avoid_constant_pool_reference (op);\n+  return GET_CODE (op) == CONST_INT\n+\t || GET_CODE (op) == CONST_DOUBLE;\n+}\n+\n+/* Subroutine of simplify_binary_operation to simplify an associative\n+   binary operation CODE with result mode MODE, operating on OP0 and OP1.\n+   Return 0 if no simplification is possible.  */\n+static rtx\n+simplify_associative_operation (enum rtx_code code, enum machine_mode mode,\n+\t\t\t\trtx op0, rtx op1)\n+{\n+  rtx tem;\n+\n+  /* Simplify (x op c1) op c2 as x op (c1 op c2).  */\n+  if (GET_CODE (op0) == code\n+      && associative_constant_p (op1)\n+      && associative_constant_p (XEXP (op0, 1)))\n+    {\n+      tem = simplify_binary_operation (code, mode, XEXP (op0, 1), op1);\n+      if (! tem)\n+\treturn tem;\n+      return simplify_gen_binary (code, mode, XEXP (op0, 0), tem);\n+    }\n+\n+  /* Simplify (x op c1) op (y op c2) as (x op y) op (c1 op c2).  */\n+  if (GET_CODE (op0) == code\n+      && GET_CODE (op1) == code\n+      && associative_constant_p (XEXP (op0, 1))\n+      && associative_constant_p (XEXP (op1, 1)))\n+    {\n+      rtx c = simplify_binary_operation (code, mode,\n+\t\t\t\t\t XEXP (op0, 1), XEXP (op1, 1));\n+      if (! c)\n+\treturn 0;\n+      tem = simplify_gen_binary (code, mode, XEXP (op0, 0), XEXP (op1, 0));\n+      return simplify_gen_binary (code, mode, tem, c);\n+    }\n+\n+  /* Canonicalize (x op c) op y as (x op y) op c.  */\n+  if (GET_CODE (op0) == code\n+      && associative_constant_p (XEXP (op0, 1)))\n+    {\n+      tem = simplify_gen_binary (code, mode, XEXP (op0, 0), op1);\n+      return simplify_gen_binary (code, mode, tem, XEXP (op0, 1));\n+    }\n+\n+  /* Canonicalize x op (y op c) as (x op y) op c.  */\n+  if (GET_CODE (op1) == code\n+      && associative_constant_p (XEXP (op1, 1)))\n+    {\n+      tem = simplify_gen_binary (code, mode, op0, XEXP (op1, 0));\n+      return simplify_gen_binary (code, mode, tem, XEXP (op1, 1));\n+    }\n+\n+  return 0;\n+}\n+\n /* Simplify a binary operation CODE with result mode MODE, operating on OP0\n    and OP1.  Return 0 if no simplification is possible.\n \n@@ -1179,6 +1248,16 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t\t      && GET_CODE (XEXP (op1, 0)) == PLUS))\n \t      && (tem = simplify_plus_minus (code, mode, op0, op1, 0)) != 0)\n \t    return tem;\n+\n+\t  /* Reassociate floating point addition only when the user\n+\t     specifies unsafe math optimizations.  */\n+\t  if (FLOAT_MODE_P (mode)\n+\t      && flag_unsafe_math_optimizations)\n+\t    {\n+\t      tem = simplify_associative_operation (code, mode, op0, op1);\n+\t      if (tem)\n+\t\treturn tem;\n+\t    }\n \t  break;\n \n \tcase COMPARE:\n@@ -1388,6 +1467,16 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t      if (REAL_VALUES_EQUAL (d, dconstm1))\n \t\treturn simplify_gen_unary (NEG, mode, op0, mode);\n \t    }\n+\n+\t  /* Reassociate multiplication, but for floating point MULTs\n+\t     only when the user specifies unsafe math optimizations.  */\n+\t  if (! FLOAT_MODE_P (mode)\n+\t      || flag_unsafe_math_optimizations)\n+\t    {\n+\t      tem = simplify_associative_operation (code, mode, op0, op1);\n+\t      if (tem)\n+\t\treturn tem;\n+\t    }\n \t  break;\n \n \tcase IOR:\n@@ -1405,6 +1494,9 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return constm1_rtx;\n+\t  tem = simplify_associative_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n \t  break;\n \n \tcase XOR:\n@@ -1417,6 +1509,9 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t  if (trueop0 == trueop1 && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return const0_rtx;\n+\t  tem = simplify_associative_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n \t  break;\n \n \tcase AND:\n@@ -1435,6 +1530,9 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return const0_rtx;\n+\t  tem = simplify_associative_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n \t  break;\n \n \tcase UDIV:\n@@ -1524,36 +1622,50 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t  break;\n \n \tcase SMIN:\n-\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (trueop1) == CONST_INT\n+\t  if (width <= HOST_BITS_PER_WIDE_INT\n+\t      && GET_CODE (trueop1) == CONST_INT\n \t      && INTVAL (trueop1) == (HOST_WIDE_INT) 1 << (width -1)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n+\t  if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n+\t  tem = simplify_associative_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n \t  break;\n \n \tcase SMAX:\n-\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (trueop1) == CONST_INT\n+\t  if (width <= HOST_BITS_PER_WIDE_INT\n+\t      && GET_CODE (trueop1) == CONST_INT\n \t      && ((unsigned HOST_WIDE_INT) INTVAL (trueop1)\n \t\t  == (unsigned HOST_WIDE_INT) GET_MODE_MASK (mode) >> 1)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n+\t  if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n+\t  tem = simplify_associative_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n \t  break;\n \n \tcase UMIN:\n \t  if (trueop1 == const0_rtx && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n+\t  if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n+\t  tem = simplify_associative_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n \t  break;\n \n \tcase UMAX:\n \t  if (trueop1 == constm1_rtx && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n+\t  if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n+\t  tem = simplify_associative_operation (code, mode, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n \t  break;\n \n \tcase SS_PLUS:"}]}