{"sha": "2702902024749f65511625ca65c0aee627d458b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcwMjkwMjAyNDc0OWY2NTUxMTYyNWNhNjVjMGFlZTYyN2Q0NThiOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-17T15:32:57Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-17T15:32:57Z"}, "message": "revert\n\nFrom-SVN: r19269", "tree": {"sha": "7d85b9d0b6442f3eecfb0acb794a86b074654f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d85b9d0b6442f3eecfb0acb794a86b074654f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2702902024749f65511625ca65c0aee627d458b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2702902024749f65511625ca65c0aee627d458b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2702902024749f65511625ca65c0aee627d458b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2702902024749f65511625ca65c0aee627d458b8/comments", "author": null, "committer": null, "parents": [{"sha": "9577319f92093cc58c718a8cbf806e3ee505e52e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9577319f92093cc58c718a8cbf806e3ee505e52e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9577319f92093cc58c718a8cbf806e3ee505e52e"}], "stats": {"total": 129, "additions": 83, "deletions": 46}, "files": [{"sha": "e13a312f020a24a125ce5cceb21b41fcf624c2bb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 83, "deletions": 46, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2702902024749f65511625ca65c0aee627d458b8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2702902024749f65511625ca65c0aee627d458b8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=2702902024749f65511625ca65c0aee627d458b8", "patch": "@@ -877,10 +877,7 @@ comptypes (type1, type2, strict)\n \n    NPTRS is the number of pointers we can strip off and keep cool.\n    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,\n-   but to not permit B** to convert to A**.\n-\n-   This should go away.  Callers should use can_convert or something\n-   similar instead.  (jason 17 Apr 1997)  */\n+   but to not permit B** to convert to A**.  */\n \n int\n comp_target_types (ttl, ttr, nptrs)\n@@ -895,13 +892,12 @@ comp_target_types (ttl, ttr, nptrs)\n   if (TREE_CODE (ttr) != TREE_CODE (ttl))\n     return 0;\n \n-  if (TREE_CODE (ttr) == POINTER_TYPE\n-      || (TREE_CODE (ttr) == REFERENCE_TYPE))\n+  if (TREE_CODE (ttr) == POINTER_TYPE)\n     {\n       ttl = TREE_TYPE (ttl);\n       ttr = TREE_TYPE (ttr);\n \n-      if (nptrs > 0 && TREE_CODE (ttr) == POINTER_TYPE)\n+      if (nptrs > 0)\n \t{\n \t  if (TREE_CODE (ttl) == UNKNOWN_TYPE\n \t      || TREE_CODE (ttr) == UNKNOWN_TYPE)\n@@ -953,23 +949,27 @@ comp_target_types (ttl, ttr, nptrs)\n       }\n     }\n \n+  if (TREE_CODE (ttr) == REFERENCE_TYPE)\n+    return comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs);\n   if (TREE_CODE (ttr) == ARRAY_TYPE)\n     return comp_array_types (comp_target_types, ttl, ttr, 0);\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n     {\n-      if (pedantic)\n-\t{\n-\t  if (comptypes (TREE_TYPE (ttl), TREE_TYPE (ttr), 1) == 0)\n+      if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n+\tswitch (comp_target_parms (TYPE_ARG_TYPES (ttl),\n+\t\t\t\t   TYPE_ARG_TYPES (ttr), 1))\n+\t  {\n+\t  case 0:\n \t    return 0;\n-\t}\n+\t  case 1:\n+\t    return 1;\n+\t  case 2:\n+\t    return -1;\n+\t  default:\n+\t    my_friendly_abort (112);\n+\t  }\n       else\n-\t{\n-\t  if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1) == 0)\n-\t    return 0;\n-\t}\n-\n-      return comp_target_parms (TYPE_ARG_TYPES (ttl),\n-\t\t\t\tTYPE_ARG_TYPES (ttr), 1);\n+\treturn 0;\n     }\n   /* for C++ */\n   else if (TREE_CODE (ttr) == OFFSET_TYPE)\n@@ -1059,9 +1059,9 @@ common_base_type (tt1, tt2)\n    If either list is empty, we win.\n    Otherwise, the two lists must be equivalent, element by element.\n \n-   C++: See comment above about TYPE1, TYPE2.\n-\n-   STRICT is no longer used.  */\n+   C++: See comment above about TYPE1, TYPE2, STRICT.\n+   If STRICT == 3, it means checking is strict, but do not compare\n+   default parameter values.  */\n \n int\n compparms (parms1, parms2, strict)\n@@ -1073,30 +1073,42 @@ compparms (parms1, parms2, strict)\n   /* An unspecified parmlist matches any specified parmlist\n      whose argument types don't need default promotions.  */\n \n+  if (strict <= 0 && t1 == 0)\n+\treturn self_promoting_args_p (t2);\n+  if (strict < 0 && t2 == 0)\n+\treturn self_promoting_args_p (t1);\n+\n   while (1)\n     {\n       if (t1 == 0 && t2 == 0)\n \treturn 1;\n       /* If one parmlist is shorter than the other,\n-\t they fail to match.  */\n+\t they fail to match, unless STRICT is <= 0.  */\n       if (t1 == 0 || t2 == 0)\n-\treturn 0;\n-      if (! comptypes (TREE_VALUE (t2), TREE_VALUE (t1), 1))\n-\treturn 0;\n+\t{\n+\t  if (strict > 0)\n+\t    return 0;\n+\t  if (strict < 0)\n+\t    return 1;\n+\t  if (strict == 0)\n+\t    return t1 && TREE_PURPOSE (t1);\n+\t}\n+      if (! comptypes (TREE_VALUE (t2), TREE_VALUE (t1), strict))\n+\t{\n+\t  if (strict > 0)\n+\t    return 0;\n+\t  if (strict == 0)\n+\t    return t2 == void_list_node && TREE_PURPOSE (t1);\n+\t  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);\n+\t}\n \n       t1 = TREE_CHAIN (t1);\n       t2 = TREE_CHAIN (t2);\n     }\n }\n \n /* This really wants return whether or not parameter type lists\n-   would make their owning functions assignment compatible or not.\n-\n-   The return value is like for comp_target_types.\n-\n-   This should go away, possibly with the exception of the empty parmlist\n-   conversion; there are no conversions between function types in C++.\n-   (jason 17 Apr 1997)  */\n+   would make their owning functions assignment compatible or not.  */\n \n static int\n comp_target_parms (parms1, parms2, strict)\n@@ -1106,9 +1118,9 @@ comp_target_parms (parms1, parms2, strict)\n   register tree t1 = parms1, t2 = parms2;\n   int warn_contravariance = 0;\n \n-  /* In C, an unspecified parmlist matches any specified parmlist\n-     whose argument types don't need default promotions.  This is not\n-     true for C++, but let's do it anyway for unfixed headers.  */\n+  /* An unspecified parmlist matches any specified parmlist\n+     whose argument types don't need default promotions.\n+     @@@ see 13.3.3 for a counterexample...  */\n \n   if (t1 == 0 && t2 != 0)\n     {\n@@ -1135,12 +1147,9 @@ comp_target_parms (parms1, parms2, strict)\n \t}\n       p1 = TREE_VALUE (t1);\n       p2 = TREE_VALUE (t2);\n-      if (comptypes (p1, p2, 1))\n+      if (p1 == p2)\n \tcontinue;\n \n-      if (pedantic)\n-\treturn 0;\n-\n       if ((TREE_CODE (p1) == POINTER_TYPE && TREE_CODE (p2) == POINTER_TYPE)\n \t  || (TREE_CODE (p1) == REFERENCE_TYPE\n \t      && TREE_CODE (p2) == REFERENCE_TYPE))\n@@ -1161,24 +1170,52 @@ comp_target_parms (parms1, parms2, strict)\n \t    }\n \t  if (IS_AGGR_TYPE (TREE_TYPE (p1)))\n \t    {\n-\t      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (p1)),\n-\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (p2)), 1) == 0)\n-\t\treturn 0;\n+\t      if (comptypes (p2, p1, 0) == 0)\n+\t\t{\n+\t\t  if (comptypes (p1, p2, 0) != 0)\n+\t\t    warn_contravariance = 1;\n+\t\t  else\n+\t\t    return 0;\n+\t\t}\n+\t      continue;\n \t    }\n \t}\n       /* Note backwards order due to contravariance.  */\n-      if (comp_target_types (p2, p1, 1) <= 0)\n+      if (comp_target_types (p2, p1, 1) == 0)\n \t{\n-\t  if (comp_target_types (p1, p2, 1) > 0)\n+\t  if (comp_target_types (p1, p2, 1))\n \t    {\n \t      warn_contravariance = 1;\n \t      continue;\n \t    }\n \t  if (strict != 0)\n \t    return 0;\n \t}\n+      /* Target types are compatible--just make sure that if\n+\t we use parameter lists, that they are ok as well.  */\n+      if (TREE_CODE (p1) == FUNCTION_TYPE || TREE_CODE (p1) == METHOD_TYPE)\n+\tswitch (comp_target_parms (TYPE_ARG_TYPES (p1),\n+\t\t\t\t   TYPE_ARG_TYPES (p2),\n+\t\t\t\t   strict))\n+\t  {\n+\t  case 0:\n+\t    return 0;\n+\t  case 1:\n+\t    break;\n+\t  case 2:\n+\t    warn_contravariance = 1;\n+\t  }\n+\n+      if (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n+\t{\n+\t  int cmp = simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n+\t  if (cmp < 0)\n+\t    my_friendly_abort (114);\n+\t  if (cmp == 0)\n+\t    return 0;\n+\t}\n     }\n-  return warn_contravariance ? -1 : 1;\n+  return 1 + warn_contravariance;\n }\n \n /* Return 1 if PARMS specifies a fixed number of parameters\n@@ -6839,7 +6876,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     {\n       tree ttl = TYPE_PTRMEMFUNC_FN_TYPE (type);\n       tree ttr = (TREE_CODE (rhstype) == POINTER_TYPE ? rhstype\n-\t\t  : TYPE_PTRMEMFUNC_FN_TYPE (rhstype));\n+\t\t    : TYPE_PTRMEMFUNC_FN_TYPE (type));\n       int ctt = comp_target_types (ttl, ttr, 1);\n \n       if (ctt < 0)"}]}