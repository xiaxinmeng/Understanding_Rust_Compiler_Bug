{"sha": "c4fcd06a10ddacc81f535b165034dbaa93b6005c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRmY2QwNmExMGRkYWNjODFmNTM1YjE2NTAzNGRiYWE5M2I2MDA1Yw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-23T14:01:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-23T14:01:49Z"}, "message": "lto-symtab.c (lto_symtab_merge): Use gtc_mode enum values.\n\n2010-07-23  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-symtab.c (lto_symtab_merge): Use gtc_mode enum\n\tvalues.\n\t(lto_symtab_merge_decls_2): Likewise.\n\t* tree-ssa.c (useless_type_conversion_p): Likewise.\n\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n\t* gimple.c (gtc_visited2, gtc_ob2): Remove.\n\t(struct type_pair_d): Make same_p an array indexed by mode.\n\tUpdate comment.\n\t(lookup_type_pair): Update initialization.\n\t(struct sccs): Adjust same_p type.\n\t(gimple_types_compatible_p_1, gtc_visit, gimple_types_compatible_p):\n\tAdjust.\n\t(print_gimple_types_stats): Likewise.\n\t* gimple.h (enum gtc_mode): New.\n\t(gimple_types_compatible_p): Adjust prototype.\n\nFrom-SVN: r162461", "tree": {"sha": "6385e1fabde05644320c6c7f11ab4bd95f2dc27a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6385e1fabde05644320c6c7f11ab4bd95f2dc27a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4fcd06a10ddacc81f535b165034dbaa93b6005c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fcd06a10ddacc81f535b165034dbaa93b6005c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4fcd06a10ddacc81f535b165034dbaa93b6005c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4fcd06a10ddacc81f535b165034dbaa93b6005c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6afb52d3e2c1ea3376e3037d1c6e6a69ff7ac6fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6afb52d3e2c1ea3376e3037d1c6e6a69ff7ac6fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6afb52d3e2c1ea3376e3037d1c6e6a69ff7ac6fd"}], "stats": {"total": 143, "additions": 67, "deletions": 76}, "files": [{"sha": "eacb59ca7bce2de58274a13cfbe9e3bc9ac1b2c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4fcd06a10ddacc81f535b165034dbaa93b6005c", "patch": "@@ -1,3 +1,21 @@\n+2010-07-23  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-symtab.c (lto_symtab_merge): Use gtc_mode enum\n+\tvalues.\n+\t(lto_symtab_merge_decls_2): Likewise.\n+\t* tree-ssa.c (useless_type_conversion_p): Likewise.\n+\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n+\t* gimple.c (gtc_visited2, gtc_ob2): Remove.\n+\t(struct type_pair_d): Make same_p an array indexed by mode.\n+\tUpdate comment.\n+\t(lookup_type_pair): Update initialization.\n+\t(struct sccs): Adjust same_p type.\n+\t(gimple_types_compatible_p_1, gtc_visit, gimple_types_compatible_p):\n+\tAdjust.\n+\t(print_gimple_types_stats): Likewise.\n+\t* gimple.h (enum gtc_mode): New.\n+\t(gimple_types_compatible_p): Adjust prototype.\n+\n 2010-07-23  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* dwarf2out.c (dwarf2out_frame_debug): Check for queued saves"}, {"sha": "e3de8344c56fae5dcbede672f01c3e0511053a5e", "filename": "gcc/gimple.c", "status": "modified", "additions": 40, "deletions": 69, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=c4fcd06a10ddacc81f535b165034dbaa93b6005c", "patch": "@@ -47,8 +47,6 @@ static struct pointer_map_t *type_hash_cache;\n /* Global type comparison cache.  */\n static htab_t gtc_visited;\n static struct obstack gtc_ob;\n-static htab_t gtc_visited2;\n-static struct obstack gtc_ob2;\n \n /* All the tuples have their operand vector (if present) at the very bottom\n    of the structure.  Therefore, the offset required to find the\n@@ -3157,20 +3155,20 @@ static hashval_t gimple_type_hash (const void *);\n \n /* Structure used to maintain a cache of some type pairs compared by\n    gimple_types_compatible_p when comparing aggregate types.  There are\n-   four possible values for SAME_P:\n+   three possible values for SAME_P:\n \n    \t-2: The pair (T1, T2) has just been inserted in the table.\n-\t-1: The pair (T1, T2) is currently being compared.\n \t 0: T1 and T2 are different types.\n \t 1: T1 and T2 are the same type.\n \n-   This table is only used when comparing aggregate types to avoid\n-   infinite recursion due to self-referential types.  */\n+   The two elements in the SAME_P array are indexed by the comparison\n+   mode gtc_mode.  */\n+\n struct type_pair_d\n {\n   unsigned int uid1;\n   unsigned int uid2;\n-  int same_p;\n+  signed char same_p[2];\n };\n typedef struct type_pair_d *type_pair_t;\n \n@@ -3227,7 +3225,8 @@ lookup_type_pair (tree t1, tree t2, htab_t *visited_p, struct obstack *ob_p)\n       p = XOBNEW (ob_p, struct type_pair_d);\n       p->uid1 = TYPE_UID (t1);\n       p->uid2 = TYPE_UID (t2);\n-      p->same_p = -2;\n+      p->same_p[0] = -2;\n+      p->same_p[1] = -2;\n       *slot = (void *) p;\n     }\n \n@@ -3246,7 +3245,7 @@ struct sccs\n   bool on_sccstack;\n   union {\n     hashval_t hash;\n-    int same_p;\n+    signed char same_p;\n   } u;\n };\n \n@@ -3366,7 +3365,8 @@ gimple_compatible_complete_and_incomplete_subtype_p (tree t1, tree t2)\n }\n \n static bool\n-gimple_types_compatible_p_1 (tree, tree, bool, VEC(type_pair_t, heap) **,\n+gimple_types_compatible_p_1 (tree, tree, enum gtc_mode, type_pair_t,\n+\t\t\t     VEC(type_pair_t, heap) **,\n \t\t\t     struct pointer_map_t *, struct obstack *);\n \n /* DFS visit the edge from the callers type pair with state *STATE to\n@@ -3376,7 +3376,7 @@ gimple_types_compatible_p_1 (tree, tree, bool, VEC(type_pair_t, heap) **,\n    SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n \n static bool\n-gtc_visit (tree t1, tree t2, bool for_merging_p,\n+gtc_visit (tree t1, tree t2, enum gtc_mode mode,\n \t   struct sccs *state,\n \t   VEC(type_pair_t, heap) **sccstack,\n \t   struct pointer_map_t *sccstate,\n@@ -3456,33 +3456,28 @@ gtc_visit (tree t1, tree t2, bool for_merging_p,\n     return false;\n \n   /* Allocate a new cache entry for this comparison.  */\n-  p = lookup_type_pair (t1, t2,\n-\t\t\tfor_merging_p ? &gtc_visited : &gtc_visited2,\n-\t\t\tfor_merging_p ? &gtc_ob : &gtc_ob2);\n-  if (p->same_p == 0 || p->same_p == 1)\n+  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n+  if (p->same_p[mode] == 0 || p->same_p[mode] == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n \t same, return the cached result.  */\n-      return p->same_p == 1;\n+      return p->same_p[mode] == 1;\n     }\n \n-  gcc_assert (p->same_p == -2);\n-\n   if ((slot = pointer_map_contains (sccstate, p)) != NULL)\n     cstate = (struct sccs *)*slot;\n   if (!cstate)\n     {\n       bool res;\n       /* Not yet visited.  DFS recurse.  */\n-      res = gimple_types_compatible_p_1 (t1, t2, for_merging_p,\n+      res = gimple_types_compatible_p_1 (t1, t2, mode, p,\n \t\t\t\t\t sccstack, sccstate, sccstate_obstack);\n       if (!cstate)\n \tcstate = (struct sccs *)* pointer_map_contains (sccstate, p);\n       state->low = MIN (state->low, cstate->low);\n       /* If the type is no longer on the SCC stack and thus is not part\n-\t of the parents SCC mix in its hash value.  Otherwise we will\n-\t ignore the type for hashing purposes and return the unaltered\n-\t hash value.  */\n+\t of the parents SCC, return its state.  Otherwise we will\n+\t ignore this pair and assume equality.  */\n       if (!cstate->on_sccstack)\n \treturn res;\n     }\n@@ -3498,19 +3493,15 @@ gtc_visit (tree t1, tree t2, bool for_merging_p,\n    SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n \n static bool\n-gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n+gimple_types_compatible_p_1 (tree t1, tree t2, enum gtc_mode mode,\n+\t\t\t     type_pair_t p,\n \t\t\t     VEC(type_pair_t, heap) **sccstack,\n \t\t\t     struct pointer_map_t *sccstate,\n \t\t\t     struct obstack *sccstate_obstack)\n {\n-  type_pair_t p;\n   struct sccs *state;\n \n-  /* Allocate a new cache entry for this comparison.  */\n-  p = lookup_type_pair (t1, t2,\n-\t\t\tfor_merging_p ? &gtc_visited : &gtc_visited2,\n-\t\t\tfor_merging_p ? &gtc_ob : &gtc_ob2);\n-  gcc_assert (p->same_p == -2);\n+  gcc_assert (p->same_p[mode] == -2);\n \n   state = XOBNEW (sccstate_obstack, struct sccs);\n   *pointer_map_insert (sccstate, p) = state;\n@@ -3529,15 +3520,15 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n     {\n     case VECTOR_TYPE:\n     case COMPLEX_TYPE:\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n \t\t      state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n       goto same_types;\n \n     case ARRAY_TYPE:\n       /* Array types are the same if the element types are the same and\n \t the number of elements are the same.  */\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n \t\t      state, sccstack, sccstate, sccstate_obstack)\n \t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n \t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n@@ -3587,19 +3578,18 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n     case METHOD_TYPE:\n       /* Method types should belong to the same class.  */\n       if (!gtc_visit (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2),\n-\t\t      for_merging_p,\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n+\t\t      mode, state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n \n       /* Fallthru  */\n \n     case FUNCTION_TYPE:\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n-      if ((for_merging_p\n+      if ((mode != GTC_DIAG\n \t   || !gimple_compatible_complete_and_incomplete_subtype_p\n \t         (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\t  && !gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\t  && !gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n \t\t\t state, sccstack, sccstate, sccstate_obstack))\n \tgoto different_types;\n \n@@ -3616,11 +3606,10 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n \t       parms1 && parms2;\n \t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n-\t      if ((for_merging_p\n+\t      if ((mode == GTC_MERGE\n \t\t   || !gimple_compatible_complete_and_incomplete_subtype_p\n \t\t         (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n-\t\t  && !gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2),\n-\t\t\t\t for_merging_p,\n+\t\t  && !gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2), mode,\n \t\t\t\t state, sccstack, sccstate, sccstate_obstack))\n \t\tgoto different_types;\n \t    }\n@@ -3633,10 +3622,10 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n \n     case OFFSET_TYPE:\n       {\n-\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n \t\t\tstate, sccstack, sccstate, sccstate_obstack)\n \t    || !gtc_visit (TYPE_OFFSET_BASETYPE (t1),\n-\t\t\t   TYPE_OFFSET_BASETYPE (t2), for_merging_p,\n+\t\t\t   TYPE_OFFSET_BASETYPE (t2), mode,\n \t\t\t   state, sccstack, sccstate, sccstate_obstack))\n \t  goto different_types;\n \n@@ -3653,14 +3642,14 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n \n \t/* If one pointer points to an incomplete type variant of\n \t   the other pointed-to type they are the same.  */\n-\tif (!for_merging_p\n+\tif (mode == GTC_DIAG\n \t    && gimple_compatible_complete_and_incomplete_subtype_p\n \t         (TREE_TYPE (t1), TREE_TYPE (t2)))\n \t  goto same_types;\n \n \t/* Otherwise, pointer and reference types are the same if the\n \t   pointed-to types are the same.  */\n-\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), for_merging_p,\n+\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2), mode,\n \t\t       state, sccstack, sccstate, sccstate_obstack))\n \t  goto same_types;\n \n@@ -3756,7 +3745,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n \t    if (DECL_NAME (f1) != DECL_NAME (f2)\n \t\t|| DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n \t\t|| !gimple_compare_field_offset (f1, f2)\n-\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2), for_merging_p,\n+\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2), mode,\n \t\t\t       state, sccstack, sccstate, sccstate_obstack))\n \t      goto different_types;\n \t  }\n@@ -3795,7 +3784,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n \t  x = VEC_pop (type_pair_t, *sccstack);\n \t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n \t  cstate->on_sccstack = false;\n-\t  x->same_p = cstate->u.same_p;\n+\t  x->same_p[mode] = cstate->u.same_p;\n \t}\n       while (x != p);\n     }\n@@ -3808,7 +3797,7 @@ gimple_types_compatible_p_1 (tree t1, tree t2, bool for_merging_p,\n    are considered different, otherwise they are considered compatible.  */\n \n bool\n-gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n+gimple_types_compatible_p (tree t1, tree t2, enum gtc_mode mode)\n {\n   VEC(type_pair_t, heap) *sccstack = NULL;\n   struct pointer_map_t *sccstate;\n@@ -3889,21 +3878,19 @@ gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n \n   /* If we've visited this type pair before (in the case of aggregates\n      with self-referential types), and we made a decision, return it.  */\n-  p = lookup_type_pair (t1, t2,\n-\t\t\tfor_merging_p ? &gtc_visited : &gtc_visited2,\n-\t\t\tfor_merging_p ? &gtc_ob : &gtc_ob2);\n-  if (p->same_p == 0 || p->same_p == 1)\n+  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n+  if (p->same_p[mode] == 0 || p->same_p[mode] == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n \t same, return the cached result.  */\n-      return p->same_p == 1;\n+      return p->same_p[mode] == 1;\n     }\n \n   /* Now set up the SCC machinery for the comparison.  */\n   gtc_next_dfs_num = 1;\n   sccstate = pointer_map_create ();\n   gcc_obstack_init (&sccstate_obstack);\n-  res = gimple_types_compatible_p_1 (t1, t2, for_merging_p,\n+  res = gimple_types_compatible_p_1 (t1, t2, mode, p,\n \t\t\t\t     &sccstack, sccstate, &sccstate_obstack);\n   VEC_free (type_pair_t, heap, sccstack);\n   pointer_map_destroy (sccstate);\n@@ -4210,7 +4197,7 @@ gimple_type_eq (const void *p1, const void *p2)\n   const_tree t1 = (const_tree) p1;\n   const_tree t2 = (const_tree) p2;\n   return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n-\t\t\t\t    CONST_CAST_TREE (t2), true);\n+\t\t\t\t    CONST_CAST_TREE (t2), GTC_MERGE);\n }\n \n \n@@ -4323,23 +4310,13 @@ print_gimple_types_stats (void)\n   else\n     fprintf (stderr, \"GIMPLE type table is empty\\n\");\n   if (gtc_visited)\n-    fprintf (stderr, \"GIMPLE type merging comparison table: size %ld, %ld \"\n+    fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld \"\n \t     \"elements, %ld searches, %ld collisions (ratio: %f)\\n\",\n \t     (long) htab_size (gtc_visited),\n \t     (long) htab_elements (gtc_visited),\n \t     (long) gtc_visited->searches,\n \t     (long) gtc_visited->collisions,\n \t     htab_collisions (gtc_visited));\n-  else\n-    fprintf (stderr, \"GIMPLE type merging comparison table is empty\\n\");\n-  if (gtc_visited2)\n-    fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld \"\n-\t     \"elements, %ld searches, %ld collisions (ratio: %f)\\n\",\n-\t     (long) htab_size (gtc_visited2),\n-\t     (long) htab_elements (gtc_visited2),\n-\t     (long) gtc_visited2->searches,\n-\t     (long) gtc_visited2->collisions,\n-\t     htab_collisions (gtc_visited2));\n   else\n     fprintf (stderr, \"GIMPLE type comparison table is empty\\n\");\n }\n@@ -4369,12 +4346,6 @@ free_gimple_type_tables (void)\n       obstack_free (&gtc_ob, NULL);\n       gtc_visited = NULL;\n     }\n-  if (gtc_visited2)\n-    {\n-      htab_delete (gtc_visited2);\n-      obstack_free (&gtc_ob2, NULL);\n-      gtc_visited2 = NULL;\n-    }\n }\n \n "}, {"sha": "790998637f0bf0d0bf8466f18f317e5ff182fc95", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=c4fcd06a10ddacc81f535b165034dbaa93b6005c", "patch": "@@ -956,7 +956,8 @@ extern tree get_call_expr_in (tree t);\n extern void recalculate_side_effects (tree);\n extern bool gimple_compare_field_offset (tree, tree);\n extern tree gimple_register_type (tree);\n-extern bool gimple_types_compatible_p (tree, tree, bool);\n+enum gtc_mode { GTC_MERGE = 0, GTC_DIAG = 1 };\n+extern bool gimple_types_compatible_p (tree, tree, enum gtc_mode);\n extern void print_gimple_types_stats (void);\n extern void free_gimple_type_tables (void);\n extern tree gimple_unsigned_type (tree);"}, {"sha": "3451b84c076f581e58c2849ee11194161eddd714", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=c4fcd06a10ddacc81f535b165034dbaa93b6005c", "patch": "@@ -962,7 +962,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t      if (tem == field\n \t\t\t  || (gimple_types_compatible_p (TREE_TYPE (tem),\n \t\t\t\t\t\t\t TREE_TYPE (field),\n-\t\t\t\t\t\t\t false)\n+\t\t\t\t\t\t\t GTC_DIAG)\n \t\t\t      && DECL_NONADDRESSABLE_P (tem)\n \t\t\t\t == DECL_NONADDRESSABLE_P (field)\n \t\t\t      && gimple_compare_field_offset (tem, field)))"}, {"sha": "9e782d578a2b4339c6ec06e3857c33b2c0774638", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=c4fcd06a10ddacc81f535b165034dbaa93b6005c", "patch": "@@ -349,7 +349,7 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       if (!gimple_types_compatible_p (TREE_TYPE (prevailing_decl),\n-\t\t\t\t      TREE_TYPE (decl), false))\n+\t\t\t\t      TREE_TYPE (decl), GTC_DIAG))\n \t/* If we don't have a merged type yet...sigh.  The linker\n \t   wouldn't complain if the types were mismatched, so we\n \t   probably shouldn't either.  Just use the type from\n@@ -382,7 +382,7 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n      fixup process didn't yet run.  */\n   prevailing_type = gimple_register_type (prevailing_type);\n   type = gimple_register_type (type);\n-  if (!gimple_types_compatible_p (prevailing_type, type, false))\n+  if (!gimple_types_compatible_p (prevailing_type, type, GTC_DIAG))\n     {\n       if (COMPLETE_TYPE_P (type))\n \treturn false;\n@@ -408,7 +408,8 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n \t    return false;\n \n \t  if (!gimple_types_compatible_p (gimple_register_type (tem1),\n-\t\t\t\t\t  gimple_register_type (tem2), false))\n+\t\t\t\t\t  gimple_register_type (tem2),\n+\t\t\t\t\t  GTC_DIAG))\n \t    return false;\n \t}\n \n@@ -603,7 +604,7 @@ lto_symtab_merge_decls_2 (void **slot)\n   for (i = 0; VEC_iterate (tree, mismatches, i, decl); ++i)\n     {\n       if (!gimple_types_compatible_p (TREE_TYPE (prevailing->decl),\n-\t\t\t\t      TREE_TYPE (decl), false))\n+\t\t\t\t      TREE_TYPE (decl), GTC_DIAG))\n \tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t\t   \"type of %qD does not match original \"\n \t\t\t\t   \"declaration\", decl);"}, {"sha": "687c6393aaa290dff0fbd59c709ecb7edd24abd5", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4fcd06a10ddacc81f535b165034dbaa93b6005c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=c4fcd06a10ddacc81f535b165034dbaa93b6005c", "patch": "@@ -1427,7 +1427,7 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   else if (AGGREGATE_TYPE_P (inner_type)\n \t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n     return (in_lto_p\n-\t    && gimple_types_compatible_p (outer_type, inner_type, false));\n+\t    && gimple_types_compatible_p (outer_type, inner_type, GTC_DIAG));\n \n   return false;\n }"}]}