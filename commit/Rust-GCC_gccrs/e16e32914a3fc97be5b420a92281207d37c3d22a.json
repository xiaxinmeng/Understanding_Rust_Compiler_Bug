{"sha": "e16e32914a3fc97be5b420a92281207d37c3d22a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE2ZTMyOTE0YTNmYzk3YmU1YjQyMGE5MjI4MTIwN2QzN2MzZDIyYQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-03-06T23:07:08Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-03-06T23:07:08Z"}, "message": "reload1.c (reload): Unshare all rtl after reload is done.\n\n        * reload1.c (reload): Unshare all rtl after reload is done.\n\n\t* simplify-rtx.c (simplify_plus_minus): Do not abort,\n\tbut simply fail if the expression is too complex to simplify.\n\t(simplify_gen_binary): Handle simplify_plus_minus failures.\n\nFrom-SVN: r50380", "tree": {"sha": "2cde44acc5fa8132dc2f6b4d74e224267af6c0f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cde44acc5fa8132dc2f6b4d74e224267af6c0f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e16e32914a3fc97be5b420a92281207d37c3d22a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16e32914a3fc97be5b420a92281207d37c3d22a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e16e32914a3fc97be5b420a92281207d37c3d22a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16e32914a3fc97be5b420a92281207d37c3d22a/comments", "author": null, "committer": null, "parents": [{"sha": "348c9efcd3341f49e593a51983a594a7fb764386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348c9efcd3341f49e593a51983a594a7fb764386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348c9efcd3341f49e593a51983a594a7fb764386"}], "stats": {"total": 33, "additions": 24, "deletions": 9}, "files": [{"sha": "583e83a1ab32e6984f995039c868e2b5290f9a39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16e32914a3fc97be5b420a92281207d37c3d22a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16e32914a3fc97be5b420a92281207d37c3d22a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e16e32914a3fc97be5b420a92281207d37c3d22a", "patch": "@@ -1,3 +1,11 @@\n+2002-03-06  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+        * reload1.c (reload): Unshare all rtl after reload is done.\n+\n+\t* simplify-rtx.c (simplify_plus_minus): Do not abort, \n+\tbut simply fail if the expression is too complex to simplify.\n+\t(simplify_gen_binary): Handle simplify_plus_minus failures.\n+\n Wed Mar  6 20:32:09 CET 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* toplev.c (rest_of_compilation): Do jump threading before SSA path;"}, {"sha": "a4a9c0cfa91c8c4d26b2a3ed498f66a30a53f365", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16e32914a3fc97be5b420a92281207d37c3d22a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16e32914a3fc97be5b420a92281207d37c3d22a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e16e32914a3fc97be5b420a92281207d37c3d22a", "patch": "@@ -1278,6 +1278,11 @@ reload (first, global)\n   unused_insn_chains = 0;\n   fixup_abnormal_edges ();\n \n+  /* Replacing pseudos with their memory equivalents might have\n+     created shared rtx.  Subsequent passes would get confused\n+     by this, so unshare everything here.  */\n+  unshare_all_rtl_again (first);\n+\n   return failure;\n }\n "}, {"sha": "b50a3392f7b19470b91e73c59631b911b4db4571", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e16e32914a3fc97be5b420a92281207d37c3d22a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e16e32914a3fc97be5b420a92281207d37c3d22a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=e16e32914a3fc97be5b420a92281207d37c3d22a", "patch": "@@ -143,9 +143,13 @@ simplify_gen_binary (code, mode, op0, op1)\n      the operation.  */\n \n   if (code == PLUS || code == MINUS)\n-    return simplify_plus_minus (code, mode, op0, op1, 1);\n-  else\n-    return gen_rtx_fmt_ee (code, mode, op0, op1);\n+    {\n+      tem = simplify_plus_minus (code, mode, op0, op1, 1);\n+      if (tem)\n+\treturn tem;\n+    }\n+\n+  return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n /* If X is a MEM referencing the constant pool, return the real value.\n@@ -1649,7 +1653,9 @@ simplify_binary_operation (code, mode, op0, op1)\n    we rebuild the operation. \n \n    If FORCE is true, then always generate the rtx.  This is used to \n-   canonicalize stuff emitted from simplify_gen_binary.  */\n+   canonicalize stuff emitted from simplify_gen_binary.  Note that this\n+   can still fail if the rtx is too complex.  It won't fail just because\n+   the result is not 'simpler' than the input, however.  */\n \n struct simplify_plus_minus_op_data\n {\n@@ -1708,11 +1714,7 @@ simplify_plus_minus (code, mode, op0, op1, force)\n \t    case PLUS:\n \t    case MINUS:\n \t      if (n_ops == 7)\n-\t\t{\n-\t\t  if (force)\n-\t\t    abort ();\n-\t\t  return NULL_RTX;\n-\t\t}\n+\t\treturn NULL_RTX;\n \n \t      ops[n_ops].op = XEXP (this_op, 1);\n \t      ops[n_ops].neg = (this_code == MINUS) ^ this_neg;"}]}