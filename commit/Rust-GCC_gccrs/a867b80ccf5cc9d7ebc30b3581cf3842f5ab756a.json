{"sha": "a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg2N2I4MGNjZjVjYzlkN2ViYzMwYjM1ODFjZjM4NDJmNWFiNzU2YQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-06T22:35:04Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-06T22:35:04Z"}, "message": "* cppinternals.texi: Update.\n\nFrom-SVN: r40267", "tree": {"sha": "f6d2e4348bfabd04755e36ba7a7ad03d3db5f8d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d2e4348bfabd04755e36ba7a7ad03d3db5f8d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a/comments", "author": null, "committer": null, "parents": [{"sha": "d1188d919d1dc1376f8d4b3abbdead38f646d777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1188d919d1dc1376f8d4b3abbdead38f646d777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1188d919d1dc1376f8d4b3abbdead38f646d777"}], "stats": {"total": 101, "additions": 85, "deletions": 16}, "files": [{"sha": "273d4d6dc7edb17e15fefdc746e75413e38f2a53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a", "patch": "@@ -1,3 +1,7 @@\n+2001-03-06  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppinternals.texi: Update.\n+\n 2001-03-06  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* config/a29k/xm-a29k.h, config/a29k/xm-unix.h,"}, {"sha": "54560b76cef187ac8742f5f25abb0f10d501e8d7", "filename": "gcc/cppinternals.texi", "status": "modified", "additions": 81, "deletions": 16, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a/gcc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a/gcc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinternals.texi?ref=a867b80ccf5cc9d7ebc30b3581cf3842f5ab756a", "patch": "@@ -94,20 +94,23 @@ Identifiers, macro expansion, hash nodes, lexing.\n * Hash Nodes::      All identifiers are hashed.\n * Macro Expansion:: Macro expansion algorithm.\n * Files::\t    File handling.\n-* Concept Index::   Index of concepts and terms.\n * Index::           Index.\n @end menu\n \n @node Conventions, Lexer, Top, Top\n @unnumbered Conventions\n+@cindex interface\n+@cindex header files\n \n cpplib has two interfaces - one is exposed internally only, and the\n other is for both internal and external use.\n \n The convention is that functions and types that are exposed to multiple\n files internally are prefixed with @samp{_cpp_}, and are to be found in\n the file @samp{cpphash.h}.  Functions and types exposed to external\n-clients are in @samp{cpplib.h}, and prefixed with @samp{cpp_}.\n+clients are in @samp{cpplib.h}, and prefixed with @samp{cpp_}.  For\n+historical reasons this is no longer quite true, but we should strive to\n+stick to it.\n \n We are striving to reduce the information exposed in cpplib.h to the\n bare minimum necessary, and then to keep it there.  This makes clear\n@@ -118,6 +121,8 @@ behaviour.\n \n @node Lexer, Whitespace, Conventions, Top\n @unnumbered The Lexer\n+@cindex lexer\n+@cindex tokens\n \n The lexer is contained in the file @samp{cpplex.c}.  We want to have a\n lexer that is single-pass, for efficiency reasons.  We would also like\n@@ -186,10 +191,10 @@ we don't allow the terminators of header names to be escaped; the first\n \n Interpretation of some character sequences depends upon whether we are\n lexing C, C++ or Objective C, and on the revision of the standard in\n-force.  For example, @samp{@@foo} is a single identifier token in\n-objective C, but two separate tokens @samp{@@} and @samp{foo} in C or\n-C++.  Such cases are handled in the main function @samp{_cpp_lex_token},\n-based upon the flags set in the @samp{cpp_options} structure.\n+force.  For example, @samp{::} is a single token in C++, but two\n+separate @samp{:} tokens, and almost certainly a syntax error, in C.\n+Such cases are handled in the main function @samp{_cpp_lex_token}, based\n+upon the flags set in the @samp{cpp_options} structure.\n \n Note we have almost, but not quite, achieved the goal of not stepping\n backwards in the input stream.  Currently @samp{skip_escaped_newlines}\n@@ -201,6 +206,11 @@ buffer it and continue to treat it as 3 separate characters.\n \n @node Whitespace, Hash Nodes, Lexer, Top\n @unnumbered Whitespace\n+@cindex whitespace\n+@cindex newlines\n+@cindex escaped newlines\n+@cindex paste avoidance\n+@cindex line numbers\n \n The lexer has been written to treat each of @samp{\\r}, @samp{\\n},\n @samp{\\r\\n} and @samp{\\n\\r} as a single new line indicator.  This allows\n@@ -221,8 +231,70 @@ characters, and @samp{skip_escaped_newlines} takes care of arbitrarily\n long sequences of escaped newlines, deferring to @samp{handle_newline}\n to handle the newlines themselves.\n \n+Another whitespace issue only concerns the stand-alone preprocessor: we\n+want to guarantee that re-reading the preprocessed output results in an\n+identical token stream.  Without taking special measures, this might not\n+be the case because of macro substitution.  We could simply insert a\n+space between adjacent tokens, but ideally we would like to keep this to\n+a minimum, both for aesthetic reasons and because it causes problems for\n+people who still try to abuse the preprocessor for things like Fortran\n+source and Makefiles.\n+\n+The token structure contains a flags byte, and two flags are of interest\n+here: @samp{PREV_WHITE} and @samp{AVOID_LPASTE}.  @samp{PREV_WHITE}\n+indicates that the token was preceded by whitespace; if this is the case\n+we need not worry about it incorrectly pasting with its predecessor.\n+The @samp{AVOID_LPASTE} flag is set by the macro expansion routines, and\n+indicates that paste avoidance by insertion of a space to the left of\n+the token may be necessary.  Recursively, the first token of a macro\n+substitution, the first token after a macro substitution, the first\n+token of a substituted argument, and the first token after a substituted\n+argument are all flagged @samp{AVOID_LPASTE} by the macro expander.\n+\n+If a token flagged in this way does not have a @samp{PREV_WHITE} flag,\n+and the routine @var{cpp_avoid_paste} determines that it might be\n+misinterpreted by the lexer if a space is not inserted between it and\n+the immediately preceding token, then stand-alone CPP's output routines\n+will insert a space between them.  To avoid excessive spacing,\n+@var{cpp_avoid_paste} tries hard to only request a space if one is\n+likely to be necessary, but for reasons of efficiency it is slightly\n+conservative and might recommend a space where one is not strictly\n+needed.\n+\n+Finally, the preprocessor takes great care to ensure it keeps track of\n+both the position of a token in the source file, for diagnostic\n+purposes, and where it should appear in the output file, because using\n+CPP for other languages like assembler requires this.  The two positions\n+may differ for the following reasons:\n+\n+@itemize @bullet\n+@item\n+Escaped newlines are deleted, so lines spliced in this way are joined to\n+form a single logical line.\n+\n+@item\n+A macro expansion replaces the tokens that form its invocation, but any\n+newlines appearing in the macro's arguments are interpreted as a single\n+space, with the result that the macro's replacement appears in full on\n+the same line that the macro name appeared in the source file.  This is\n+particularly important for stringification of arguments - newlines\n+embedded in the arguments must appear in the string as spaces.\n+@end itemize\n+\n+The source file location is maintained in the @var{lineno} member of the\n+@var{cpp_buffer} structure, and the column number inferred from the\n+current position in the buffer relative to the @var{line_base} buffer\n+variable, which is updated with every newline whether escaped or not.\n+\n+TODO: Finish this.\n+\n @node Hash Nodes, Macro Expansion, Whitespace, Top\n @unnumbered Hash Nodes\n+@cindex hash table\n+@cindex identifiers\n+@cindex macros\n+@cindex assertions\n+@cindex named operators\n \n When cpplib encounters an \"identifier\", it generates a hash code for it\n and stores it in the hash table.  By \"identifier\" we mean tokens with\n@@ -279,24 +351,17 @@ argument, and which argument it is, is also an O(1) operation.  Further,\n each directive name, such as @samp{endif}, has an associated directive\n enum stored in its hash node, so that directive lookup is also O(1).\n \n-Later, CPP may also store C front-end information in its identifier hash\n-table, such as a @samp{tree} pointer.\n-\n @node Macro Expansion, Files, Hash Nodes, Top\n @unnumbered Macro Expansion Algorithm\n @printindex cp\n \n-@node Files, Concept Index, Macro Expansion, Top\n+@node Files, Index, Macro Expansion, Top\n @unnumbered File Handling\n @printindex cp\n \n-@node Concept Index, Index, Files, Top\n-@unnumbered Concept Index\n+@node Index,, Files, Top\n+@unnumbered Index\n @printindex cp\n \n-@node Index,, Concept Index, Top\n-@unnumbered Index of Directives, Macros and Options\n-@printindex fn\n-\n @contents\n @bye"}]}