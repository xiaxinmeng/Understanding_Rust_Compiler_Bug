{"sha": "33951763a85087927068d553be6709cd03953a09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM5NTE3NjNhODUwODc5MjcwNjhkNTUzYmU2NzA5Y2QwMzk1M2EwOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-23T14:31:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-23T14:31:13Z"}, "message": "Add more subreg offset helpers\n\nProvide versions of subreg_lowpart_offset and subreg_highpart_offset\nthat work on mode sizes rather than modes.  Also provide a routine\nthat converts an lsb position to a subreg offset.\n\nThe intent (in combination with later patches) is to move the\nhandling of the BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN case into\njust two places, so that for other combinations we don't have\nto split offsets into words and subwords.\n\ngcc/\n2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* rtl.h (subreg_size_offset_from_lsb): Declare.\n\t(subreg_offset_from_lsb): New function.\n\t(subreg_size_lowpart_offset): Declare.\n\t(subreg_lowpart_offset): Turn into an inline function.\n\t(subreg_size_highpart_offset): Declare.\n\t(subreg_highpart_offset): Turn into an inline function.\n\t* emit-rtl.c (subreg_size_lowpart_offset): New function.\n\t(subreg_size_highpart_offset): Likewise\n\t* rtlanal.c (subreg_size_offset_from_lsb): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r242755", "tree": {"sha": "4bfd3e1a9778ceec5f17a57b1b4e198e8b97acb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bfd3e1a9778ceec5f17a57b1b4e198e8b97acb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33951763a85087927068d553be6709cd03953a09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33951763a85087927068d553be6709cd03953a09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33951763a85087927068d553be6709cd03953a09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33951763a85087927068d553be6709cd03953a09/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbb88345e10ffb70e289408303c58aa01b1a059c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb88345e10ffb70e289408303c58aa01b1a059c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb88345e10ffb70e289408303c58aa01b1a059c"}], "stats": {"total": 149, "additions": 116, "deletions": 33}, "files": [{"sha": "aa1d22f92d7b19449df3e965e13fe3fa5db91eda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33951763a85087927068d553be6709cd03953a09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33951763a85087927068d553be6709cd03953a09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33951763a85087927068d553be6709cd03953a09", "patch": "@@ -1,3 +1,17 @@\n+2016-11-23  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (subreg_size_offset_from_lsb): Declare.\n+\t(subreg_offset_from_lsb): New function.\n+\t(subreg_size_lowpart_offset): Declare.\n+\t(subreg_lowpart_offset): Turn into an inline function.\n+\t(subreg_size_highpart_offset): Declare.\n+\t(subreg_highpart_offset): Turn into an inline function.\n+\t* emit-rtl.c (subreg_size_lowpart_offset): New function.\n+\t(subreg_size_highpart_offset): Likewise\n+\t* rtlanal.c (subreg_size_offset_from_lsb): Likewise.\n+\n 2016-11-23  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/78482"}, {"sha": "04ce2d1398b0e249c4ff877963426f44a0a25da1", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33951763a85087927068d553be6709cd03953a09/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33951763a85087927068d553be6709cd03953a09/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=33951763a85087927068d553be6709cd03953a09", "patch": "@@ -1478,44 +1478,41 @@ gen_highpart_mode (machine_mode outermode, machine_mode innermode, rtx exp)\n \t\t\t      subreg_highpart_offset (outermode, innermode));\n }\n \n-/* Return the SUBREG_BYTE for an OUTERMODE lowpart of an INNERMODE value.  */\n+/* Return the SUBREG_BYTE for a lowpart subreg whose outer mode has\n+   OUTER_BYTES bytes and whose inner mode has INNER_BYTES bytes.  */\n \n unsigned int\n-subreg_lowpart_offset (machine_mode outermode, machine_mode innermode)\n+subreg_size_lowpart_offset (unsigned int outer_bytes, unsigned int inner_bytes)\n {\n-  unsigned int offset = 0;\n-  int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n-\n-  if (difference > 0)\n-    {\n-      if (WORDS_BIG_ENDIAN)\n-\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset += difference % UNITS_PER_WORD;\n-    }\n+  if (outer_bytes > inner_bytes)\n+    /* Paradoxical subregs always have a SUBREG_BYTE of 0.  */\n+    return 0;\n \n-  return offset;\n+  if (BYTES_BIG_ENDIAN && WORDS_BIG_ENDIAN)\n+    return inner_bytes - outer_bytes;\n+  else if (!BYTES_BIG_ENDIAN && !WORDS_BIG_ENDIAN)\n+    return 0;\n+  else\n+    return subreg_size_offset_from_lsb (outer_bytes, inner_bytes, 0);\n }\n \n-/* Return offset in bytes to get OUTERMODE high part\n-   of the value in mode INNERMODE stored in memory in target format.  */\n+/* Return the SUBREG_BYTE for a highpart subreg whose outer mode has\n+   OUTER_BYTES bytes and whose inner mode has INNER_BYTES bytes.  */\n+\n unsigned int\n-subreg_highpart_offset (machine_mode outermode, machine_mode innermode)\n+subreg_size_highpart_offset (unsigned int outer_bytes,\n+\t\t\t     unsigned int inner_bytes)\n {\n-  unsigned int offset = 0;\n-  int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n+  gcc_assert (inner_bytes >= outer_bytes);\n \n-  gcc_assert (GET_MODE_SIZE (innermode) >= GET_MODE_SIZE (outermode));\n-\n-  if (difference > 0)\n-    {\n-      if (! WORDS_BIG_ENDIAN)\n-\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      if (! BYTES_BIG_ENDIAN)\n-\toffset += difference % UNITS_PER_WORD;\n-    }\n-\n-  return offset;\n+  if (BYTES_BIG_ENDIAN && WORDS_BIG_ENDIAN)\n+    return 0;\n+  else if (!BYTES_BIG_ENDIAN && !WORDS_BIG_ENDIAN)\n+    return inner_bytes - outer_bytes;\n+  else\n+    return subreg_size_offset_from_lsb (outer_bytes, inner_bytes,\n+\t\t\t\t\t(inner_bytes - outer_bytes)\n+\t\t\t\t\t* BITS_PER_UNIT);\n }\n \n /* Return 1 iff X, assumed to be a SUBREG,"}, {"sha": "660d381939da4cd22d06948c3b51c1993c892e73", "filename": "gcc/rtl.h", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33951763a85087927068d553be6709cd03953a09/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33951763a85087927068d553be6709cd03953a09/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=33951763a85087927068d553be6709cd03953a09", "patch": "@@ -2178,6 +2178,24 @@ extern void get_full_rtx_cost (rtx, machine_mode, enum rtx_code, int,\n extern unsigned int subreg_lsb (const_rtx);\n extern unsigned int subreg_lsb_1 (machine_mode, machine_mode,\n \t\t\t\t  unsigned int);\n+extern unsigned int subreg_size_offset_from_lsb (unsigned int, unsigned int,\n+\t\t\t\t\t\t unsigned int);\n+\n+/* Return the subreg byte offset for a subreg whose outer mode is\n+   OUTER_MODE, whose inner mode is INNER_MODE, and where there are\n+   LSB_SHIFT *bits* between the lsb of the outer value and the lsb of\n+   the inner value.  This is the inverse of subreg_lsb_1 (which converts\n+   byte offsets to bit shifts).  */\n+\n+inline unsigned int\n+subreg_offset_from_lsb (machine_mode outer_mode,\n+\t\t\tmachine_mode inner_mode,\n+\t\t\tunsigned int lsb_shift)\n+{\n+  return subreg_size_offset_from_lsb (GET_MODE_SIZE (outer_mode),\n+\t\t\t\t      GET_MODE_SIZE (inner_mode), lsb_shift);\n+}\n+\n extern unsigned int subreg_regno_offset\t(unsigned int, machine_mode,\n \t\t\t\t\t unsigned int, machine_mode);\n extern bool subreg_offset_representable_p (unsigned int, machine_mode,\n@@ -2764,10 +2782,28 @@ extern rtx operand_subword (rtx, unsigned int, int, machine_mode);\n extern rtx operand_subword_force (rtx, unsigned int, machine_mode);\n extern bool paradoxical_subreg_p (const_rtx);\n extern int subreg_lowpart_p (const_rtx);\n-extern unsigned int subreg_lowpart_offset (machine_mode,\n-\t\t\t\t\t   machine_mode);\n-extern unsigned int subreg_highpart_offset (machine_mode,\n-\t\t\t\t\t    machine_mode);\n+extern unsigned int subreg_size_lowpart_offset (unsigned int, unsigned int);\n+\n+/* Return the SUBREG_BYTE for an OUTERMODE lowpart of an INNERMODE value.  */\n+\n+inline unsigned int\n+subreg_lowpart_offset (machine_mode outermode, machine_mode innermode)\n+{\n+  return subreg_size_lowpart_offset (GET_MODE_SIZE (outermode),\n+\t\t\t\t     GET_MODE_SIZE (innermode));\n+}\n+\n+extern unsigned int subreg_size_highpart_offset (unsigned int, unsigned int);\n+\n+/* Return the SUBREG_BYTE for an OUTERMODE highpart of an INNERMODE value.  */\n+\n+inline unsigned int\n+subreg_highpart_offset (machine_mode outermode, machine_mode innermode)\n+{\n+  return subreg_size_highpart_offset (GET_MODE_SIZE (outermode),\n+\t\t\t\t      GET_MODE_SIZE (innermode));\n+}\n+\n extern int byte_lowpart_offset (machine_mode, machine_mode);\n extern rtx make_safe_from (rtx, rtx);\n extern rtx convert_memory_address_addr_space_1 (machine_mode, rtx,"}, {"sha": "d29a3fe75f7943f240d079013045398768a09c0b", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33951763a85087927068d553be6709cd03953a09/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33951763a85087927068d553be6709cd03953a09/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=33951763a85087927068d553be6709cd03953a09", "patch": "@@ -3528,6 +3528,42 @@ subreg_lsb (const_rtx x)\n \t\t       SUBREG_BYTE (x));\n }\n \n+/* Return the subreg byte offset for a subreg whose outer value has\n+   OUTER_BYTES bytes, whose inner value has INNER_BYTES bytes, and where\n+   there are LSB_SHIFT *bits* between the lsb of the outer value and the\n+   lsb of the inner value.  This is the inverse of the calculation\n+   performed by subreg_lsb_1 (which converts byte offsets to bit shifts).  */\n+\n+unsigned int\n+subreg_size_offset_from_lsb (unsigned int outer_bytes,\n+\t\t\t     unsigned int inner_bytes,\n+\t\t\t     unsigned int lsb_shift)\n+{\n+  /* A paradoxical subreg begins at bit position 0.  */\n+  if (outer_bytes > inner_bytes)\n+    {\n+      gcc_checking_assert (lsb_shift == 0);\n+      return 0;\n+    }\n+\n+  gcc_assert (lsb_shift % BITS_PER_UNIT == 0);\n+  unsigned int lower_bytes = lsb_shift / BITS_PER_UNIT;\n+  unsigned int upper_bytes = inner_bytes - (lower_bytes + outer_bytes);\n+  if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n+    return upper_bytes;\n+  else if (!WORDS_BIG_ENDIAN && !BYTES_BIG_ENDIAN)\n+    return lower_bytes;\n+  else\n+    {\n+      unsigned int lower_word_part = lower_bytes & -UNITS_PER_WORD;\n+      unsigned int upper_word_part = upper_bytes & -UNITS_PER_WORD;\n+      if (WORDS_BIG_ENDIAN)\n+\treturn upper_word_part + (lower_bytes - lower_word_part);\n+      else\n+\treturn lower_word_part + (upper_bytes - upper_word_part);\n+    }\n+}\n+\n /* Fill in information about a subreg of a hard register.\n    xregno - A regno of an inner hard subreg_reg (or what will become one).\n    xmode  - The mode of xregno."}]}