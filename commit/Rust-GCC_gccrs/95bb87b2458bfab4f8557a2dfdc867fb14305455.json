{"sha": "95bb87b2458bfab4f8557a2dfdc867fb14305455", "node_id": "C_kwDOANBUbNoAKDk1YmI4N2IyNDU4YmZhYjRmODU1N2EyZGZkYzg2N2ZiMTQzMDU0NTU", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-10-28T03:51:02Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-10-28T03:51:02Z"}, "message": "hardened conditionals\n\nThis patch introduces optional passes to harden conditionals used in\nbranches, and in computing boolean expressions, by adding redundant\ntests of the reversed conditions, and trapping in case of unexpected\nresults.  Though in abstract machines the redundant tests should never\nfail, CPUs may be led to misbehave under certain kinds of attacks,\nsuch as of power deprivation, and these tests reduce the likelihood of\ngoing too far down an unexpected execution path.\n\n\nfor  gcc/ChangeLog\n\n\t* common.opt (fharden-compares): New.\n\t(fharden-conditional-branches): New.\n\t* doc/invoke.texi: Document new options.\n\t* gimple-harden-conditionals.cc: New.\n\t* Makefile.in (OBJS): Build it.\n\t* passes.def: Add new passes.\n\t* tree-pass.h (make_pass_harden_compares): Declare.\n\t(make_pass_harden_conditional_branches): Declare.\n\nfor  gcc/ada/ChangeLog\n\n\t* doc/gnat_rm/security_hardening_features.rst\n\t(Hardened Conditionals): New.\n\nfor  gcc/testsuite/ChangeLog\n\n\t* c-c++-common/torture/harden-comp.c: New.\n\t* c-c++-common/torture/harden-cond.c: New.", "tree": {"sha": "f2631aca2523d8600de2182a5722c4d0b48f9100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2631aca2523d8600de2182a5722c4d0b48f9100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95bb87b2458bfab4f8557a2dfdc867fb14305455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bb87b2458bfab4f8557a2dfdc867fb14305455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95bb87b2458bfab4f8557a2dfdc867fb14305455", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bb87b2458bfab4f8557a2dfdc867fb14305455/comments", "author": null, "committer": null, "parents": [{"sha": "5f9ef1339e9d0d709af6a70b60e584bf7decd761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9ef1339e9d0d709af6a70b60e584bf7decd761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f9ef1339e9d0d709af6a70b60e584bf7decd761"}], "stats": {"total": 544, "additions": 544, "deletions": 0}, "files": [{"sha": "ec74a3a4bf375f762f676f06895f3e1921546fe4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -1391,6 +1391,7 @@ OBJS = \\\n \tgimple-if-to-switch.o \\\n \tgimple-iterator.o \\\n \tgimple-fold.o \\\n+\tgimple-harden-conditionals.o \\\n \tgimple-laddress.o \\\n \tgimple-loop-interchange.o \\\n \tgimple-loop-jam.o \\"}, {"sha": "52240d7e3dd541d1af33c92aac43f92f20797dbb", "filename": "gcc/ada/doc/gnat_rm/security_hardening_features.rst", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -87,3 +87,43 @@ types and subtypes, may be silently ignored.  Specifically, it is not\n currently recommended to rely on any effects this pragma might be\n expected to have when calling subprograms through access-to-subprogram\n variables.\n+\n+\n+.. Hardened Conditionals:\n+\n+Hardened Conditionals\n+=====================\n+\n+GNAT can harden conditionals to protect against control flow attacks.\n+\n+This is accomplished by two complementary transformations, each\n+activated by a separate command-line option.\n+\n+The option *-fharden-compares* enables hardening of compares that\n+compute results stored in variables, adding verification that the\n+reversed compare yields the opposite result.\n+\n+The option *-fharden-conditional-branches* enables hardening of\n+compares that guard conditional branches, adding verification of the\n+reversed compare to both execution paths.\n+\n+These transformations are introduced late in the compilation pipeline,\n+long after boolean expressions are decomposed into separate compares,\n+each one turned into either a conditional branch or a compare whose\n+result is stored in a boolean variable or temporary.  Compiler\n+optimizations, if enabled, may also turn conditional branches into\n+stored compares, and vice-versa.  Conditionals may also be optimized\n+out entirely, if their value can be determined at compile time, and\n+occasionally multiple compares can be combined into one.\n+\n+It is thus difficult to predict which of these two options will affect\n+a specific compare operation expressed in source code.  Using both\n+options ensures that every compare that is not optimized out will be\n+hardened.\n+\n+The addition of reversed compares can be observed by enabling the dump\n+files of the corresponding passes, through command line options\n+*-fdump-tree-hardcmp* and *-fdump-tree-hardcbr*, respectively.\n+\n+They are separate options, however, because of the significantly\n+different performance impact of the hardening transformations."}, {"sha": "eeba1a727f2c8d70ea40c395e5ee7fe93a3fe66e", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -1722,6 +1722,14 @@ fguess-branch-probability\n Common Var(flag_guess_branch_prob) Optimization\n Enable guessing of branch probabilities.\n \n+fharden-compares\n+Common Var(flag_harden_compares) Optimization\n+Harden conditionals not used in branches, checking reversed conditions.\n+\n+fharden-conditional-branches\n+Common Var(flag_harden_conditional_branches) Optimization\n+Harden conditional branches by checking reversed conditions.\n+\n ; Nonzero means ignore `#ident' directives.  0 means handle them.\n ; Generate position-independent code for executables if possible\n ; On SVR4 targets, it also controls whether or not to emit a"}, {"sha": "b28ef7e669e808798f1c973fbc1fc3b3afff0120", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -596,6 +596,7 @@ Objective-C and Objective-C++ Dialects}.\n -fasan-shadow-offset=@var{number}  -fsanitize-sections=@var{s1},@var{s2},... @gol\n -fsanitize-undefined-trap-on-error  -fbounds-check @gol\n -fcf-protection=@r{[}full@r{|}branch@r{|}return@r{|}none@r{|}check@r{]} @gol\n+-fharden-compares -fharden-conditional-branches @gol\n -fstack-protector  -fstack-protector-all  -fstack-protector-strong @gol\n -fstack-protector-explicit  -fstack-check @gol\n -fstack-limit-register=@var{reg}  -fstack-limit-symbol=@var{sym} @gol\n@@ -15550,6 +15551,24 @@ Currently the x86 GNU/Linux target provides an implementation based\n on Intel Control-flow Enforcement Technology (CET) which works for\n i686 processor or newer.\n \n+@item -fharden-compares\n+@opindex fharden-compares\n+For every logical test that survives gimple optimizations and is\n+@emph{not} the condition in a conditional branch (for example,\n+conditions tested for conditional moves, or to store in boolean\n+variables), emit extra code to compute and verify the reversed\n+condition, and to call @code{__builtin_trap} if the results do not\n+match.  Use with @samp{-fharden-conditional-branches} to cover all\n+conditionals.\n+\n+@item -fharden-conditional-branches\n+@opindex fharden-conditional-branches\n+For every non-vectorized conditional branch that survives gimple\n+optimizations, emit extra code to compute and verify the reversed\n+condition, and to call @code{__builtin_trap} if the result is\n+unexpected.  Use with @samp{-fharden-compares} to cover all\n+conditionals.\n+\n @item -fstack-protector\n @opindex fstack-protector\n Emit extra code to check for buffer overflows, such as stack smashing"}, {"sha": "8916420d7dfe93fd072ef35708212c44f6580b91", "filename": "gcc/gimple-harden-conditionals.cc", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fgimple-harden-conditionals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fgimple-harden-conditionals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-harden-conditionals.cc?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -0,0 +1,439 @@\n+/* Harden conditionals.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by Alexandre Oliva <oliva@adacore.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"fold-const.h\"\n+#include \"gimple.h\"\n+#include \"gimplify.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"basic-block.h\"\n+#include \"cfghooks.h\"\n+#include \"cfgloop.h\"\n+#include \"diagnostic.h\"\n+#include \"intl.h\"\n+\n+namespace {\n+\n+/* These passes introduces redundant, but reversed conditionals at\n+   compares, such as those used in conditional branches, and those\n+   that compute boolean results.  This doesn't make much sense for\n+   abstract CPUs, but this kind of hardening may avoid undesirable\n+   execution paths on actual CPUs under such attacks as of power\n+   deprivation.  */\n+\n+/* Define a pass to harden conditionals other than branches.  */\n+\n+const pass_data pass_data_harden_compares = {\n+  GIMPLE_PASS,\n+  \"hardcmp\",\n+  OPTGROUP_NONE,\n+  TV_NONE,\n+  PROP_cfg | PROP_ssa, // properties_required\n+  0,\t    // properties_provided\n+  0,\t    // properties_destroyed\n+  0,\t    // properties_start\n+  TODO_update_ssa\n+  | TODO_cleanup_cfg\n+  | TODO_verify_il, // properties_finish\n+};\n+\n+class pass_harden_compares : public gimple_opt_pass\n+{\n+public:\n+  pass_harden_compares (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_harden_compares, ctxt)\n+  {}\n+  opt_pass *clone () { return new pass_harden_compares (m_ctxt); }\n+  virtual bool gate (function *) {\n+    return flag_harden_compares;\n+  }\n+  virtual unsigned int execute (function *);\n+};\n+\n+/* Define a pass to harden conditionals in branches.  This pass must\n+   run after the above, otherwise it will re-harden the checks\n+   introduced by the above.  */\n+\n+const pass_data pass_data_harden_conditional_branches = {\n+  GIMPLE_PASS,\n+  \"hardcbr\",\n+  OPTGROUP_NONE,\n+  TV_NONE,\n+  PROP_cfg | PROP_ssa, // properties_required\n+  0,\t    // properties_provided\n+  0,\t    // properties_destroyed\n+  0,\t    // properties_start\n+  TODO_update_ssa\n+  | TODO_cleanup_cfg\n+  | TODO_verify_il, // properties_finish\n+};\n+\n+class pass_harden_conditional_branches : public gimple_opt_pass\n+{\n+public:\n+  pass_harden_conditional_branches (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_harden_conditional_branches, ctxt)\n+  {}\n+  opt_pass *clone () { return new pass_harden_conditional_branches (m_ctxt); }\n+  virtual bool gate (function *) {\n+    return flag_harden_conditional_branches;\n+  }\n+  virtual unsigned int execute (function *);\n+};\n+\n+}\n+\n+/* If VAL is an SSA name, return an SSA name holding the same value,\n+   but without the compiler's knowing that it holds the same value, so\n+   that uses thereof can't be optimized the way VAL might.  Insert\n+   stmts that initialize it before *GSIP, with LOC.\n+\n+   Otherwise, VAL must be an invariant, returned unchanged.  */\n+\n+static inline tree\n+detach_value (location_t loc, gimple_stmt_iterator *gsip, tree val)\n+{\n+  if (TREE_CONSTANT (val) || TREE_CODE (val) != SSA_NAME)\n+    {\n+      gcc_checking_assert (is_gimple_min_invariant (val));\n+      return val;\n+    }\n+\n+  tree ret = copy_ssa_name (val);\n+\n+  /* Output asm (\"\" : \"=g\" (ret) : \"0\" (val));  */\n+  vec<tree, va_gc> *inputs = NULL;\n+  vec<tree, va_gc> *outputs = NULL;\n+  vec_safe_push (outputs,\n+\t\t build_tree_list\n+\t\t (build_tree_list\n+\t\t  (NULL_TREE, build_string (2, \"=g\")),\n+\t\t  ret));\n+  vec_safe_push (inputs,\n+\t\t build_tree_list\n+\t\t (build_tree_list\n+\t\t  (NULL_TREE, build_string (1, \"0\")),\n+\t\t  val));\n+  gasm *detach = gimple_build_asm_vec (\"\", inputs, outputs,\n+\t\t\t\t       NULL, NULL);\n+  gimple_set_location (detach, loc);\n+  gsi_insert_before (gsip, detach, GSI_SAME_STMT);\n+\n+  SSA_NAME_DEF_STMT (ret) = detach;\n+\n+  return ret;\n+}\n+\n+/* Build a cond stmt out of COP, LHS, RHS, insert it before *GSIP with\n+   location LOC.  *GSIP must be at the end of a basic block.  The succ\n+   edge out of the block becomes the true or false edge opposite to\n+   that in FLAGS.  Create a new block with a single trap stmt, in the\n+   cold partition if the function is partitioned,, and a new edge to\n+   it as the other edge for the cond.  */\n+\n+static inline void\n+insert_check_and_trap (location_t loc, gimple_stmt_iterator *gsip,\n+\t\t       int flags, enum tree_code cop, tree lhs, tree rhs)\n+{\n+  basic_block chk = gsi_bb (*gsip);\n+\n+  gcond *cond = gimple_build_cond (cop, lhs, rhs, NULL, NULL);\n+  gimple_set_location (cond, loc);\n+  gsi_insert_before (gsip, cond, GSI_SAME_STMT);\n+\n+  basic_block trp = create_empty_bb (chk);\n+\n+  gimple_stmt_iterator gsit = gsi_after_labels (trp);\n+  gcall *trap = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+  gimple_set_location (trap, loc);\n+  gsi_insert_before (&gsit, trap, GSI_SAME_STMT);\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Adding reversed compare to block %i, and trap to block %i\\n\",\n+\t     chk->index, trp->index);\n+\n+  if (BB_PARTITION (chk))\n+    BB_SET_PARTITION (trp, BB_COLD_PARTITION);\n+\n+  int true_false_flag = flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+  gcc_assert (true_false_flag);\n+  int neg_true_false_flag = (~flags) & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\n+  /* Remove the fallthru bit, and set the truth value for the\n+     preexisting edge and for the newly-created one.  In hardcbr,\n+     FLAGS is taken from the edge of the original cond expr that we're\n+     dealing with, so the reversed compare is expected to yield the\n+     negated result, and the same result calls for a trap.  In\n+     hardcmp, we're comparing the boolean results of the original and\n+     of the reversed compare, so we're passed FLAGS to trap on\n+     equality.  */\n+  single_succ_edge (chk)->flags &= ~EDGE_FALLTHRU;\n+  single_succ_edge (chk)->flags |= neg_true_false_flag;\n+  edge e = make_edge (chk, trp, true_false_flag);\n+  e->goto_locus = loc;\n+\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    set_immediate_dominator (CDI_DOMINATORS, trp, chk);\n+  if (current_loops)\n+    add_bb_to_loop (trp, current_loops->tree_root);\n+}\n+\n+/* Split edge E, and insert_check_and_trap (see above) in the\n+   newly-created block, using detached copies of LHS's and RHS's\n+   values (see detach_value above) for the COP compare.  */\n+\n+static inline void\n+insert_edge_check_and_trap (location_t loc, edge e,\n+\t\t\t    enum tree_code cop, tree lhs, tree rhs)\n+{\n+  int flags = e->flags;\n+  basic_block src = e->src;\n+  basic_block dest = e->dest;\n+  location_t eloc = e->goto_locus;\n+\n+  basic_block chk = split_edge (e);\n+  e = NULL;\n+\n+  single_pred_edge (chk)->goto_locus = loc;\n+  single_succ_edge (chk)->goto_locus = eloc;\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Splitting edge %i->%i into block %i\\n\",\n+\t     src->index, dest->index, chk->index);\n+\n+  gimple_stmt_iterator gsik = gsi_after_labels (chk);\n+\n+  bool same_p = (lhs == rhs);\n+  lhs = detach_value (loc, &gsik, lhs);\n+  rhs = same_p ? lhs : detach_value (loc, &gsik, rhs);\n+\n+  insert_check_and_trap (loc, &gsik, flags, cop, lhs, rhs);\n+}\n+\n+/* Harden cond stmts at the end of FUN's blocks.  */\n+\n+unsigned int\n+pass_harden_conditional_branches::execute (function *fun)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB_REVERSE_FN (bb, fun)\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\n+      if (gsi_end_p (gsi))\n+\tcontinue;\n+\n+      gcond *cond = dyn_cast <gcond *> (gsi_stmt (gsi));\n+      if (!cond)\n+\tcontinue;\n+\n+      /* Turn:\n+\n+\t if (x op y) goto l1; else goto l2;\n+\n+\t into:\n+\n+\t if (x op y) goto l1'; else goto l2';\n+\t l1': if (x' cop y') goto l1'trap; else goto l1;\n+\t l1'trap: __builtin_trap ();\n+\t l2': if (x' cop y') goto l2; else goto l2'trap;\n+\t l2'trap: __builtin_trap ();\n+\n+\t where cop is a complementary boolean operation to op; l1', l1'trap,\n+\t l2' and l2'trap are newly-created labels; and x' and y' hold the same\n+\t value as x and y, but in a way that does not enable the compiler to\n+\t optimize the redundant compare away.\n+      */\n+\n+      enum tree_code op = gimple_cond_code (cond);\n+      tree lhs = gimple_cond_lhs (cond);\n+      tree rhs = gimple_cond_rhs (cond);\n+      location_t loc = gimple_location (cond);\n+\n+      enum tree_code cop = invert_tree_comparison (op, HONOR_NANS (lhs));\n+\n+      if (cop == ERROR_MARK)\n+\t/* ??? Can we do better?  */\n+\tcontinue;\n+\n+      insert_edge_check_and_trap (loc, EDGE_SUCC (bb, 0), cop, lhs, rhs);\n+      insert_edge_check_and_trap (loc, EDGE_SUCC (bb, 1), cop, lhs, rhs);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Instantiate a hardcbr pass.  */\n+\n+gimple_opt_pass *\n+make_pass_harden_conditional_branches (gcc::context *ctxt)\n+{\n+  return new pass_harden_conditional_branches (ctxt);\n+}\n+\n+/* Harden boolean-yielding compares in FUN.  */\n+\n+unsigned int\n+pass_harden_compares::execute (function *fun)\n+{\n+  basic_block bb;\n+  /* Go backwards over BBs and stmts, so that, even if we split the\n+     block multiple times to insert a cond_expr after each compare we\n+     find, we remain in the same block, visiting every preexisting\n+     stmt exactly once, and not visiting newly-added blocks or\n+     stmts.  */\n+  FOR_EACH_BB_REVERSE_FN (bb, fun)\n+    for (gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\t !gsi_end_p (gsi); gsi_prev (&gsi))\n+      {\n+\tgassign *asgn = dyn_cast <gassign *> (gsi_stmt (gsi));\n+\tif (!asgn)\n+\t  continue;\n+\n+\t/* Turn:\n+\n+\t   z = x op y;\n+\n+\t   into:\n+\n+\t   z = x op y;\n+\t   z' = x' cop y';\n+\t   if (z == z') __builtin_trap ();\n+\n+\t   where cop is a complementary boolean operation to op; and x'\n+\t   and y' hold the same value as x and y, but in a way that does\n+\t   not enable the compiler to optimize the redundant compare\n+\t   away.\n+\t*/\n+\n+\tenum tree_code op = gimple_assign_rhs_code (asgn);\n+\n+\tenum tree_code cop;\n+\n+\tswitch (op)\n+\t  {\n+\t  case EQ_EXPR:\n+\t  case NE_EXPR:\n+\t  case GT_EXPR:\n+\t  case GE_EXPR:\n+\t  case LT_EXPR:\n+\t  case LE_EXPR:\n+\t  case LTGT_EXPR:\n+\t  case UNEQ_EXPR:\n+\t  case UNGT_EXPR:\n+\t  case UNGE_EXPR:\n+\t  case UNLT_EXPR:\n+\t  case UNLE_EXPR:\n+\t  case ORDERED_EXPR:\n+\t  case UNORDERED_EXPR:\n+\t    cop = invert_tree_comparison (op,\n+\t\t\t\t\t  HONOR_NANS\n+\t\t\t\t\t  (gimple_assign_rhs1 (asgn)));\n+\n+\t    if (cop == ERROR_MARK)\n+\t      /* ??? Can we do better?  */\n+\t      continue;\n+\n+\t    break;\n+\n+\t    /* ??? Maybe handle these too?  */\n+\t  case TRUTH_NOT_EXPR:\n+\t    /* ??? The code below assumes binary ops, it would have to\n+\t       be adjusted for TRUTH_NOT_EXPR, since it's unary.  */\n+\t  case TRUTH_ANDIF_EXPR:\n+\t  case TRUTH_ORIF_EXPR:\n+\t  case TRUTH_AND_EXPR:\n+\t  case TRUTH_OR_EXPR:\n+\t  case TRUTH_XOR_EXPR:\n+\t  default:\n+\t    continue;\n+\t  }\n+\n+\t/* These are the operands for the verification.  */\n+\ttree lhs = gimple_assign_lhs (asgn);\n+\ttree op1 = gimple_assign_rhs1 (asgn);\n+\ttree op2 = gimple_assign_rhs2 (asgn);\n+\tlocation_t loc = gimple_location (asgn);\n+\n+\t/* Vector booleans can't be used in conditional branches.  ???\n+\t   Can we do better?  How to reduce compare and\n+\t   reversed-compare result vectors to a single boolean?  */\n+\tif (VECTOR_TYPE_P (TREE_TYPE (op1)))\n+\t  continue;\n+\n+\tgcc_checking_assert (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE);\n+\n+\ttree rhs = copy_ssa_name (lhs);\n+\n+\tgimple_stmt_iterator gsi_split = gsi;\n+\t/* Don't separate the original assignment from debug stmts\n+\t   that might be associated with it, and arrange to split the\n+\t   block after debug stmts, so as to make sure the split block\n+\t   won't be debug stmts only.  */\n+\tgsi_next_nondebug (&gsi_split);\n+\n+\tbool same_p = (op1 == op2);\n+\top1 = detach_value (loc, &gsi_split, op1);\n+\top2 = same_p ? op1 : detach_value (loc, &gsi_split, op2);\n+\n+\tgassign *asgnck = gimple_build_assign (rhs, cop, op1, op2);\n+\tgimple_set_location (asgnck, loc);\n+\tgsi_insert_before (&gsi_split, asgnck, GSI_SAME_STMT);\n+\n+\t/* We wish to insert a cond_expr after the compare, so arrange\n+\t   for it to be at the end of a block if it isn't.  */\n+\tif (!gsi_end_p (gsi_split))\n+\t  {\n+\t    gsi_prev (&gsi_split);\n+\t    split_block (bb, gsi_stmt (gsi_split));\n+\t    gsi_next (&gsi_split);\n+\t    gcc_checking_assert (gsi_end_p (gsi_split));\n+\n+\t    single_succ_edge (bb)->goto_locus = loc;\n+\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"Splitting block %i\\n\", bb->index);\n+\t  }\n+\n+\tgcc_checking_assert (single_succ_p (bb));\n+\n+\tinsert_check_and_trap (loc, &gsi_split, EDGE_TRUE_VALUE,\n+\t\t\t       EQ_EXPR, lhs, rhs);\n+      }\n+\n+  return 0;\n+}\n+\n+/* Instantiate a hardcmp pass.  */\n+\n+gimple_opt_pass *\n+make_pass_harden_compares (gcc::context *ctxt)\n+{\n+  return new pass_harden_compares (ctxt);\n+}"}, {"sha": "0a0e4fe63ebde1353fda1af0b6cdff5bd21c1226", "filename": "gcc/passes.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -419,6 +419,8 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_lower_resx);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_gimple_isel);\n+  NEXT_PASS (pass_harden_conditional_branches);\n+  NEXT_PASS (pass_harden_compares);\n   NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n   NEXT_PASS (pass_warn_function_noreturn);\n   NEXT_PASS (pass_warn_access);"}, {"sha": "1ee0b3663443dff0ac93d824981c083575455e23", "filename": "gcc/testsuite/c-c++-common/torture/harden-comp.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fharden-comp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fharden-comp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fharden-comp.c?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fharden-compares -fdump-tree-hardcmp -ffat-lto-objects\" } */\n+\n+int\n+f (int i, int j)\n+{\n+  return i < j;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Splitting block\" 1 \"hardcmp\" } } */\n+/* { dg-final { scan-tree-dump-times \"Adding reversed compare\" 1 \"hardcmp\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 1 \"hardcmp\" } } */\n+/* { dg-final { scan-tree-dump-times \"_\\[0-9\\]* = i_\\[0-9\\]*\\[(\\]D\\[)\\] < j_\\[0-9\\]*\\[(\\]D\\[)\\];\" 1 \"hardcmp\" } } */\n+/* { dg-final { scan-tree-dump-times \"_\\[0-9\\]* = i_\\[0-9\\]* >= j_\\[0-9\\]*;\" 1 \"hardcmp\" } } */"}, {"sha": "86de8e155ed386f602941ffafbe4739ad466eb27", "filename": "gcc/testsuite/c-c++-common/torture/harden-cond.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fharden-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fharden-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fharden-cond.c?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fharden-conditional-branches -fdump-tree-hardcbr -ffat-lto-objects\" } */\n+\n+extern int f1 (void);\n+extern int f2 (void);\n+\n+\n+int\n+f (int i, int j)\n+{\n+  return (i < j) ? f1 () : f2 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Splitting edge\" 2 \"hardcbr\" } } */\n+/* { dg-final { scan-tree-dump-times \"Adding reversed compare\" 2 \"hardcbr\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 2 \"hardcbr\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \\[(\\]i_\\[0-9\\]*\\[(\\]D\\[)\\] < j_\\[0-9\\]*\\[(\\]D\\[)\\]\\[)\\]\" 1 \"hardcbr\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \\[(\\]i_\\[0-9\\]* >= j_\\[0-9\\]*\\[)\\]\" 2 \"hardcbr\" } } */"}, {"sha": "e807ad855efd13bad9d6540df9da7ac80893d99e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bb87b2458bfab4f8557a2dfdc867fb14305455/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=95bb87b2458bfab4f8557a2dfdc867fb14305455", "patch": "@@ -644,6 +644,9 @@ extern gimple_opt_pass *make_pass_update_address_taken (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_convert_switch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_vaarg (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_gimple_isel (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_harden_compares (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_harden_conditional_branches (gcc::context\n+\t\t\t\t\t\t\t       *ctxt);\n \n /* Current optimization pass.  */\n extern opt_pass *current_pass;"}]}