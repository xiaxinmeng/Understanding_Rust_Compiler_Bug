{"sha": "69add2a8a5e947cafdfc26ea3f8c3f708fc3f093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlhZGQyYThhNWU5NDdjYWZkZmMyNmVhM2Y4YzNmNzA4ZmMzZjA5Mw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-10-28T19:33:09Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-10-28T19:33:09Z"}, "message": "Fix computation of goal_alternative_matched\n\nFrom-SVN: r37102", "tree": {"sha": "31c5a4c0b608a5f298f43ddba6435d09a7796138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31c5a4c0b608a5f298f43ddba6435d09a7796138"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093/comments", "author": null, "committer": null, "parents": [{"sha": "66cb3475e4f84deb77255034640e2520f235bd81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66cb3475e4f84deb77255034640e2520f235bd81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66cb3475e4f84deb77255034640e2520f235bd81"}], "stats": {"total": 36, "additions": 28, "deletions": 8}, "files": [{"sha": "c0653d8ce915ac12760f7f376fd6027a28289798", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69add2a8a5e947cafdfc26ea3f8c3f708fc3f093", "patch": "@@ -1,3 +1,9 @@\n+2000-10-28  Bernd Schmidt  <bernds@redhat.co.uk>\n+\n+\t* reload.c (find_reloads): Distinguish \"wins\" so that we know whether\n+\ta given operand won because of a matching constraint or not; then use\n+\tthat information to compute goal_alternative_matched properly.\n+\n 2000-10-28  Neil Booth  <neilb@earthling.net>\n \n \tNew macro expander."}, {"sha": "f3933b116f6b45d7566396a575a0eca4f9f6eabb", "filename": "gcc/reload.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69add2a8a5e947cafdfc26ea3f8c3f708fc3f093/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=69add2a8a5e947cafdfc26ea3f8c3f708fc3f093", "patch": "@@ -2399,6 +2399,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   int no_input_reloads = 0, no_output_reloads = 0;\n   int n_alternatives;\n   int this_alternative[MAX_RECOG_OPERANDS];\n+  char this_alternative_match_win[MAX_RECOG_OPERANDS];\n   char this_alternative_win[MAX_RECOG_OPERANDS];\n   char this_alternative_offmemok[MAX_RECOG_OPERANDS];\n   char this_alternative_earlyclobber[MAX_RECOG_OPERANDS];\n@@ -2410,6 +2411,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   int operand_reloadnum[MAX_RECOG_OPERANDS];\n   int goal_alternative_matches[MAX_RECOG_OPERANDS];\n   int goal_alternative_matched[MAX_RECOG_OPERANDS];\n+  char goal_alternative_match_win[MAX_RECOG_OPERANDS];\n   char goal_alternative_win[MAX_RECOG_OPERANDS];\n   char goal_alternative_offmemok[MAX_RECOG_OPERANDS];\n   char goal_alternative_earlyclobber[MAX_RECOG_OPERANDS];\n@@ -2741,6 +2743,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t{\n \t  register char *p = constraints[i];\n \t  register int win = 0;\n+\t  int did_match = 0;\n \t  /* 0 => this operand can be reloaded somehow for this alternative */\n \t  int badop = 1;\n \t  /* 0 => this operand can be reloaded if the alternative allows regs.  */\n@@ -2839,6 +2842,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t  this_alternative[i] = (int) NO_REGS;\n \t  this_alternative_win[i] = 0;\n+\t  this_alternative_match_win[i] = 0;\n \t  this_alternative_offmemok[i] = 0;\n \t  this_alternative_earlyclobber[i] = 0;\n \t  this_alternative_matches[i] = -1;\n@@ -2917,7 +2921,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t&& ! this_alternative_win[c])\n \t\t      bad = 1;\n \n-\t\t    win = this_alternative_win[c];\n+\t\t    did_match = this_alternative_win[c];\n \t\t  }\n \t\telse\n \t\t  {\n@@ -2953,12 +2957,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t   operand also had to match the same thing as this\n \t\t   operand, we don't know how to do that.  So reject this\n \t\t   alternative.  */\n-\t\tif (! win || force_reload)\n+\t\tif (! did_match || force_reload)\n \t\t  for (j = 0; j < i; j++)\n \t\t    if (this_alternative_matches[j]\n \t\t\t== this_alternative_matches[i])\n \t\t      badop = 1;\n-\n \t\tbreak;\n \n \t      case 'p':\n@@ -3175,6 +3178,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  this_alternative_earlyclobber[i] = earlyclobber;\n \t  if (win && ! force_reload)\n \t    this_alternative_win[i] = 1;\n+\t  else if (did_match && ! force_reload)\n+\t    this_alternative_match_win[i] = 1;\n \t  else\n \t    {\n \t      int const_to_mem = 0;\n@@ -3276,7 +3281,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     Don't do this if the preferred class has only one register\n \t     because we might otherwise exhaust the class.  */\n \n-\t  if (! win && this_alternative[i] != (int) NO_REGS\n+\t  if (! win && ! did_match\n+\t      && this_alternative[i] != (int) NO_REGS\n \t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n \t      && reg_class_size[(int) preferred_class[i]] > 1)\n \t    {\n@@ -3302,7 +3308,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       for (i = 0; i < noperands; i++)\n \tif (this_alternative_earlyclobber[i]\n-\t    && this_alternative_win[i])\n+\t    && (this_alternative_win[i] || this_alternative_match_win[i]))\n \t  {\n \t    struct decomposition early_data;\n \n@@ -3345,6 +3351,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t    {\n \t\t      losers++;\n \t\t      this_alternative_win[j] = 0;\n+\t\t      this_alternative_match_win[j] = 0;\n \t\t    }\n \t\t  else\n \t\t    break;\n@@ -3355,11 +3362,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      {\n \t\tlosers++;\n \t\tthis_alternative_win[i] = 0;\n+\t\tthis_alternative_match_win[j] = 0;\n \t\tfor (j = 0; j < noperands; j++)\n \t\t  if (this_alternative_matches[j] == i\n-\t\t      && this_alternative_win[j])\n+\t\t      && this_alternative_match_win[j])\n \t\t    {\n \t\t      this_alternative_win[j] = 0;\n+\t\t      this_alternative_match_win[j] = 0;\n \t\t      losers++;\n \t\t    }\n \t      }\n@@ -3378,7 +3387,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    }\n \t  for (i = 0; i < noperands; i++)\n \t    {\n-\t      goal_alternative_win[i] = 1;\n+\t      goal_alternative_win[i] = this_alternative_win[i];\n+\t      goal_alternative_match_win[i] = this_alternative_match_win[i];\n \t      goal_alternative[i] = this_alternative[i];\n \t      goal_alternative_offmemok[i] = this_alternative_offmemok[i];\n \t      goal_alternative_matches[i] = this_alternative_matches[i];\n@@ -3406,6 +3416,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    {\n \t      goal_alternative[i] = this_alternative[i];\n \t      goal_alternative_win[i] = this_alternative_win[i];\n+\t      goal_alternative_match_win[i] = this_alternative_match_win[i];\n \t      goal_alternative_offmemok[i] = this_alternative_offmemok[i];\n \t      goal_alternative_matches[i] = this_alternative_matches[i];\n \t      goal_alternative_earlyclobber[i]\n@@ -3487,12 +3498,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   for (i = 0; i < noperands; i++)\n     goal_alternative_matched[i] = -1;\n-\n+ \n   for (i = 0; i < noperands; i++)\n     if (! goal_alternative_win[i]\n \t&& goal_alternative_matches[i] >= 0)\n       goal_alternative_matched[goal_alternative_matches[i]] = i;\n \n+  for (i = 0; i < noperands; i++)\n+    goal_alternative_win[i] |= goal_alternative_match_win[i];\n+\n   /* If the best alternative is with operands 1 and 2 swapped,\n      consider them swapped before reporting the reloads.  Update the\n      operand numbers of any reloads already pushed.  */"}]}